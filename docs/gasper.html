<!DOCTYPE html><html><head><title>Help for package gasper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gasper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gasper-package'><p>gasper: Graph Signal Processing</p></a></li>
<li><a href='#adjacency_mat'><p>Compute the Adjacency Matrix of a Gaussian Weighted Graph</p></a></li>
<li><a href='#analysis'><p>Compute the Analysis Operator for a Graph Signal</p></a></li>
<li><a href='#betathresh'><p>Apply Beta Threshold to Data</p></a></li>
<li><a href='#download_graph'><p>Download Sparse Matrix form the SuiteSparse Matrix Collection</p></a></li>
<li><a href='#eigendec'><p>Spectral decomposition of a symetric matrix</p></a></li>
<li><a href='#eigensort'><p>Spectral Decomposition of a Symmetric Matrix</p></a></li>
<li><a href='#forward_gft'><p>Compute Forward Graph Fourier Transform</p></a></li>
<li><a href='#forward_sgwt'><p>Compute Forward Spectral Graph Wavelet Transform</p></a></li>
<li><a href='#full'><p>Conversion of Symmetric Sparse Matrix to Full Matrix</p></a></li>
<li><a href='#fullup'><p>Convert Symmetric Sparse Matrix to Full Matrix</p></a></li>
<li><a href='#get_graph_info'><p>Retrieve Information Tables about a Specific Graph from the SuiteSparse Matrix Collection</p></a></li>
<li><a href='#grid1'><p>Grid1 Graph from AG-Monien Graph Collection</p></a></li>
<li><a href='#GVN'><p>Graph Von Neumann Variance Estimator</p></a></li>
<li><a href='#HPFVN'><p>High Pass Filter Von Neumann Estimator</p></a></li>
<li><a href='#inverse_gft'><p>Compute Inverse Graph Fourier Transform</p></a></li>
<li><a href='#inverse_sgwt'><p>Compute Inverse Spectral Graph Wavelet Transform</p></a></li>
<li><a href='#laplacian_mat'><p>Compute the Graph Laplacian Matrix</p></a></li>
<li><a href='#LD_SUREthresh'><p>Level Dependent Stein's Unbiased Risk Estimate Thresholding</p></a></li>
<li><a href='#localize_gft'><p>Localize Kernel at a Graph Vertex Using GFT</p></a></li>
<li><a href='#localize_sgwt'><p>Localize a Kernel at a Specific Vertex using SGWT</p></a></li>
<li><a href='#minnesota'><p>Minnesota Road Network</p></a></li>
<li><a href='#NYCdata'><p>NYC Taxi Network Dataset</p></a></li>
<li><a href='#pittsburgh'><p>Pittsburgh Census Tracts Network.</p></a></li>
<li><a href='#plot_filter'><p>Plot Tight-Frame Filters</p></a></li>
<li><a href='#plot_graph'><p>Plot Graph</p></a></li>
<li><a href='#plot_signal'><p>Plot a Signal on Top of a Given Graph</p></a></li>
<li><a href='#PSNR'><p>Compute the Peak Signal to Noise Ratio</p></a></li>
<li><a href='#randsignal'><p>Generate Random Signal with Varying Regularity</p></a></li>
<li><a href='#rlogo'><p>R logo graph.</p></a></li>
<li><a href='#smoothmodulus'><p>Modulus of Smoothness for Graph Signal</p></a></li>
<li><a href='#SNR'><p>Compute the Signal to Noise Ratio</p></a></li>
<li><a href='#spectral_coords'><p>Spectral Coordinates for Graph Drawing</p></a></li>
<li><a href='#SuiteSparseData'><p>Matrix Data from SuiteSparse Matrix Collection</p></a></li>
<li><a href='#SURE_MSEthresh'><p>Stein's Unbiased Risk Estimate with MSE</p></a></li>
<li><a href='#SUREthresh'><p>Stein's Unbiased Risk Estimate</p></a></li>
<li><a href='#swissroll'><p>Swiss Roll Graph Generation</p></a></li>
<li><a href='#synthesis'><p>Compute the Synthesis Operator for Transform Coefficients</p></a></li>
<li><a href='#tight_frame'><p>Tight-Frame Computation</p></a></li>
<li><a href='#zetav'><p>Evaluate Localized Tight-Frame Filter Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graph Signal Processing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the standard operations for signal processing on graphs: 
    graph Fourier transform, spectral graph wavelet transform, 
    visualization tools. It also implements a data driven method
    for graph signal denoising/regression, for details see 
    De Loynes, Navarro, Olivier (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1906.01882">doi:10.48550/arXiv.1906.01882</a>&gt;. 
    The package also provides an interface to the SuiteSparse Matrix Collection, 
    <a href="https://sparse.tamu.edu/">https://sparse.tamu.edu/</a>, a large and widely used set of sparse matrix 
    benchmarks collected from a wide range of applications.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fabnavarro/gasper">https://github.com/fabnavarro/gasper</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fabnavarro/gasper/issues">https://github.com/fabnavarro/gasper/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, ggplot2, methods, Matrix, RSpectra, httr, curl</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, kableExtra, rmarkdown, rvest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-28 10:07:56 UTC; fnavarro</td>
</tr>
<tr>
<td>Author:</td>
<td>Basile de Loynes <a href="https://orcid.org/0000-0002-5397-6811"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Fabien Navarro <a href="https://orcid.org/0000-0002-4979-2745"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Baptiste Olivier <a href="https://orcid.org/0000-0002-5853-0341"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabien Navarro &lt;fabien.navarro@math.cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gasper-package'>gasper: Graph Signal Processing</h2><span id='topic+gasper'></span><span id='topic+gasper-package'></span>

<h3>Description</h3>

<p>Provides the standard operations for signal processing on graphs: graph Fourier transform, spectral graph wavelet transform, visualization tools. It also implements a data driven method for graph signal denoising/regression, for details see De Loynes, Navarro, Olivier (2019) <a href="https://arxiv.org/abs/1906.01882">arXiv:1906.01882</a>. The package also provides an interface to the SuiteSparse Matrix Collection, <a href="https://sparse.tamu.edu/">https://sparse.tamu.edu/</a>, a large and widely used set of sparse matrix benchmarks collected from a wide range of applications.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Fabien Navarro <a href="mailto:fabien.navarro@math.cnrs.fr">fabien.navarro@math.cnrs.fr</a> (<a href="https://orcid.org/0000-0002-4979-2745">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Basile de Loynes <a href="mailto:basile.deloynes@ensai.fr">basile.deloynes@ensai.fr</a> (<a href="https://orcid.org/0000-0002-5397-6811">ORCID</a>)
</p>
</li>
<li><p> Baptiste Olivier <a href="mailto:baptiste.olivier@orange.com">baptiste.olivier@orange.com</a> (<a href="https://orcid.org/0000-0002-5853-0341">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/fabnavarro/gasper">https://github.com/fabnavarro/gasper</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/fabnavarro/gasper/issues">https://github.com/fabnavarro/gasper/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adjacency_mat'>Compute the Adjacency Matrix of a Gaussian Weighted Graph</h2><span id='topic+adjacency_mat'></span>

<h3>Description</h3>

<p><code>adjacency_mat</code> calculates the adjacency matrix of a Gaussian weighted graph based on the distance between points in <code class="reqn">\mathbb{R}^3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency_mat(
  pts,
  f = function(x) {
     exp(-x^2/8)
 },
  s = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacency_mat_+3A_pts">pts</code></td>
<td>
<p>Matrix representing the coordinates of N points in <code class="reqn">\mathbb{R}^3</code>. Each row should correspond to a point.</p>
</td></tr>
<tr><td><code id="adjacency_mat_+3A_f">f</code></td>
<td>
<p>A scalar potential function. By default, the Gaussian potential <code class="reqn">\exp(-x^2/8)</code> is used.</p>
</td></tr>
<tr><td><code id="adjacency_mat_+3A_s">s</code></td>
<td>
<p>Numeric threshold used to sparsify the adjacency matrix. Any value below this threshold will be set to zero. Default is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes pairwise distances between each point in <code>pts</code> and weights the adjacency matrix based on the scalar potential <code>f</code>. The final adjacency matrix can be sparsified by setting values below the threshold <code>s</code> to zero.
</p>


<h3>Value</h3>

<p>A matrix representing the adjacency matrix of the Gaussian weighted graph.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+laplacian_mat">laplacian_mat</a></code> for calculating the Laplacian matrix,
<code><a href="#topic+swissroll">swissroll</a></code> for generating a Swiss roll dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts &lt;- swissroll(N=100, seed=0, a=1, b=4)
W &lt;- adjacency_mat(pts)
</code></pre>

<hr>
<h2 id='analysis'>Compute the Analysis Operator for a Graph Signal</h2><span id='topic+analysis'></span>

<h3>Description</h3>

<p><code>analysis</code> computes the transform coefficients of a given graph signal using the provided frame coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analysis(y, tf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analysis_+3A_y">y</code></td>
<td>
<p>Numeric vector or matrix representing the graph signal to analyze.</p>
</td></tr>
<tr><td><code id="analysis_+3A_tf">tf</code></td>
<td>
<p>Numeric matrix of frame coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>analysis</code> operator uses the frame coefficients to transform a given graph signal into its representation in the transform domain. It is defined by the linear map <code class="reqn">T_{\mathfrak F} : \mathbb R^V \rightarrow \mathbb R^I</code>. Given a function <code class="reqn">f \in \mathbb R^V</code>, the analysis operation is defined as:
</p>
<p style="text-align: center;"><code class="reqn">T_{\mathfrak F}f=(\langle f,r_i \rangle)_{i \in I}</code>
</p>

<p>where <code class="reqn">r_i</code> are the frame vectors.
</p>
<p>The transform is computed as:
</p>
<p style="text-align: center;"><code class="reqn">coef = tf . y</code>
</p>



<h3>Value</h3>

<p><code>coef</code> Numeric vector or matrix of transform coefficients of the graph signal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synthesis">synthesis</a></code>, <code><a href="#topic+tight_frame">tight_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L &lt;- laplacian_mat(grid1$sA)

# Compute the spectral decomposition of L
decomp &lt;- eigensort(L)

# Generate the tight frame coefficients using the tight_frame function
tf &lt;- tight_frame(decomp$evalues, decomp$evectors)

# Create a random graph signal.
f &lt;- rnorm(nrow(L))

# Compute the transform coefficients using the analysis operator
coef &lt;- analysis(f, tf)

## End(Not run)

</code></pre>

<hr>
<h2 id='betathresh'>Apply Beta Threshold to Data</h2><span id='topic+betathresh'></span>

<h3>Description</h3>

<p><code>betathresh</code> performs a generalized thresholding operation on the data <code>y</code>. The thresholding operation is parameterized by the parameter <code>beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betathresh(y, t, beta = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betathresh_+3A_y">y</code></td>
<td>
<p>Numeric vector or matrix representing the noisy data.</p>
</td></tr>
<tr><td><code id="betathresh_+3A_t">t</code></td>
<td>
<p>Non-negative numeric value representing the threshold.</p>
</td></tr>
<tr><td><code id="betathresh_+3A_beta">beta</code></td>
<td>
<p>Numeric value indicating the type of thresholding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function offers flexibility by allowing for different types of thresholding based on the <code>beta</code> parameter. Soft thresholding, commonly used in wavelet-based denoising corresponds to <code>beta</code>=1 . James-Stein thresholding corresponds to <code>beta</code>=2. The implementation includes a small constant for numerical stability when computing the thresholding operation.
</p>
<p>The thresholding operator is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
\tau(x,t) = x \max \left( 1 - t^{\beta} |x|^{-\beta}, 0 \right)
</code>
</p>

<p>with <code class="reqn">\beta \geq 1</code>.
</p>


<h3>Value</h3>

<p><code>x</code> Numeric vector or matrix of the filtered result.
</p>


<h3>References</h3>

<p>Donoho, D. L., &amp; Johnstone, I. M. (1995). Adapting to unknown smoothness via wavelet shrinkage. Journal of the american statistical association, 90(432), 1200-1224.
</p>
<p>de Loynes, B., Navarro, F., &amp; Olivier, B. (2021). Data-driven thresholding in denoising with spectral graph wavelet transform. Journal of Computational and Applied Mathematics, 389, 113319.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a 2x2 matrix
mat &lt;- matrix(c(2, -3, 1.5, -0.5), 2, 2)

# Apply soft thresholding with a threshold of 1
betathresh(mat, 1, 1)
</code></pre>

<hr>
<h2 id='download_graph'>Download Sparse Matrix form the SuiteSparse Matrix Collection</h2><span id='topic+download_graph'></span>

<h3>Description</h3>

<p><code>download_graph</code> allows to download sparse matrices from the SuiteSparse Matrix Collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_graph(matrixname, groupname, svd = FALSE, add_info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_graph_+3A_matrixname">matrixname</code></td>
<td>
<p>Name of the graph to download.</p>
</td></tr>
<tr><td><code id="download_graph_+3A_groupname">groupname</code></td>
<td>
<p>Name of the group that provides the graph.</p>
</td></tr>
<tr><td><code id="download_graph_+3A_svd">svd</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a &quot;.mat&quot; file containing the singular values of the matrix is downloaded (if available). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="download_graph_+3A_add_info">add_info</code></td>
<td>
<p>Logical, if <code>TRUE</code>, additional information about the graph will be fetched and included in the output. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>download_graph</code> automatically converts the downloaded matrix into a sparse matrix format. If coordinates are associated with the graphs, they are downloaded and included in the output. Visit <a href="https://sparse.tamu.edu/">https://sparse.tamu.edu/</a> or see <code><a href="#topic+SuiteSparseData">SuiteSparseData</a></code> to explore groups and matrix names.
</p>


<h3>Value</h3>

<p>A list containing several components:
</p>

<ul>
<li> <p><code>sA</code>: A sparse matrix representation of the downloaded graph.
</p>
</li>
<li> <p><code>xy</code>: Coordinates associated with the graph nodes (if available).
</p>
</li>
<li> <p><code>dim</code>: A data frame with the number of rows, columns, and numerically nonzero elements.
</p>
</li>
<li> <p><code>temp</code>: The path to the temporary directory where the matrix and downloaded files (including singular values if requested) are stored.
</p>
</li>
<li> <p><code>info</code>: Additional information about the graph (included when <code>add_info</code> is <code>TRUE</code>).
</p>
</li></ul>



<h3>Note</h3>

<p>This temporary directory can be accessed, for example, via <code>list.files(grid1$temp)</code>. To open the read .mat files (containing singular values),  &quot;R.matlab&quot; or &quot;foreign&quot; packages can be used. After using the downloaded data, you can delete the content of the temporary folder.
</p>
<p>When <code>add_info</code> is set to <code>TRUE</code>, the function retrieves comprehensive information about the graph using <code><a href="#topic+get_graph_info">get_graph_info</a></code>.
</p>


<h3>References</h3>

<p>Davis, T. A., &amp; Hu, Y. (2011). The University of Florida sparse matrix collection. ACM Transactions on Mathematical Software (TOMS), 38(1), 1-25.
</p>
<p>Kolodziej, S. P., Aznaveh, M., Bullock, M., David, J., Davis, T. A., Henderson, M., Hu, Y., &amp; Sandstrom, R. (2019). The suitesparse matrix collection website interface. Journal of Open Source Software, 4(35), 1244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_graph_info">get_graph_info</a></code>, <code><a href="#topic+SuiteSparseData">SuiteSparseData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
matrixname &lt;- "grid1"
groupname &lt;- "AG-Monien"
download_graph(matrixname,groupname)
list.files(grid1$temp)

## End(Not run)
</code></pre>

<hr>
<h2 id='eigendec'>Spectral decomposition of a symetric matrix</h2><span id='topic+eigendec'></span>

<h3>Description</h3>

<p>Eigen decomposition of dense symmetric/hermitian matrix M
using divide-and-conquer methods that provides slightly different results
than the standard method, but is considerably faster for large matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigendec(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigendec_+3A_m">M</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='eigensort'>Spectral Decomposition of a Symmetric Matrix</h2><span id='topic+eigensort'></span>

<h3>Description</h3>

<p><code>eigensort</code> performs the spectral decomposition of a symmetric matrix. The eigenvalues and eigenvectors are sorted in increasing order by eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigensort(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigensort_+3A_m">M</code></td>
<td>
<p>Symmetric matrix, either sparse or dense, to be decomposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>evalues</code>: A vector of sorted eigenvalues in increasing order.
</p>
</li>
<li> <p><code>evectors</code>: A matrix of corresponding eigenvectors.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(1, ncol=2, nrow=2)
dec &lt;- eigensort(A)
</code></pre>

<hr>
<h2 id='forward_gft'>Compute Forward Graph Fourier Transform</h2><span id='topic+forward_gft'></span>

<h3>Description</h3>

<p><code>forward_gft</code> computes the Graph Fourier Transform (GFT) of a given graph signal <code class="reqn">f</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_gft(L, f, U = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forward_gft_+3A_l">L</code></td>
<td>
<p>Laplacian matrix of the graph.</p>
</td></tr>
<tr><td><code id="forward_gft_+3A_f">f</code></td>
<td>
<p>Numeric vector of the graph signal to analyze.</p>
</td></tr>
<tr><td><code id="forward_gft_+3A_u">U</code></td>
<td>
<p>Matrix of the Eigenvectors of the Laplacian matrix. If NULL (default), the function will compute the eigendecomposition of the Laplacian.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GFT is the representation of the graph signal on an orthonormal basis of the  graph's Laplacian matrix. It allows to analyze the frequency content of signals defined on graphs. In this context, the &quot;frequency&quot; of a graph signal refers to its decomposition in terms of the graph's Laplacian eigenvectors, which are similar to the harmonics of classical Fourier analysis.
</p>
<p>The GFT of a graph signal <code class="reqn">f</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">
\hat{f} = U^T f
</code>
</p>

<p>where <code class="reqn">U</code> denotes the matrix of eigenvectors of the graph's Laplacian.
</p>
<p>When the eigenvectors <code class="reqn">U</code> are not provided, the function computes them using the Laplacian matrix <code class="reqn">L</code>.
</p>


<h3>Value</h3>

<p><code>hatf</code> Numeric vector. Graph Fourier Transform of <code class="reqn">f</code>.
</p>


<h3>References</h3>

<p>Ortega, A., Frossard, P., Kovačević, J., Moura, J. M., &amp; Vandergheynst, P. (2018). Graph signal processing: Overview, challenges, and applications. Proceedings of the IEEE, 106(5), 808-828.
</p>
<p>Shuman, D. I., Narang, S. K., Frossard, P., Ortega, A., &amp; Vandergheynst, P. (2013). The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains. IEEE signal processing magazine, 30(3), 83-98.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inverse_gft">inverse_gft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L &lt;- laplacian_mat(grid1$sA)

# Create a sample graph signal
f &lt;- rnorm(nrow(L))

# Compute the forward GFT
hatf &lt;- forward_gft(L, f)

## End(Not run)

</code></pre>

<hr>
<h2 id='forward_sgwt'>Compute Forward Spectral Graph Wavelet Transform</h2><span id='topic+forward_sgwt'></span>

<h3>Description</h3>

<p><code>forward_sgwt</code> computes the forward Spectral Graph Wavelet Transform (SGWT) for a given graph signal <code class="reqn">f</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_sgwt(
  f,
  evalues,
  evectors,
  b = 2,
  filter_func = zetav,
  filter_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forward_sgwt_+3A_f">f</code></td>
<td>
<p>Numeric vector representing the graph signal to analyze.</p>
</td></tr>
<tr><td><code id="forward_sgwt_+3A_evalues">evalues</code></td>
<td>
<p>Numeric vector of eigenvalues of the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="forward_sgwt_+3A_evectors">evectors</code></td>
<td>
<p>Matrix of eigenvectors of the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="forward_sgwt_+3A_b">b</code></td>
<td>
<p>Numeric scalar that controls the number of scales in the SGWT. It must be greater than 1.</p>
</td></tr>
<tr><td><code id="forward_sgwt_+3A_filter_func">filter_func</code></td>
<td>
<p>Function used to compute the filter values. By default, it uses the <code><a href="#topic+zetav">zetav</a></code> function but other frame filters can be pass.</p>
</td></tr>
<tr><td><code id="forward_sgwt_+3A_filter_params">filter_params</code></td>
<td>
<p>List of additional parameters required by <code>filter_func</code>. Default is an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transform is constructed based on the frame defined by the <code><a href="#topic+tight_frame">tight_frame</a></code> function, without the need for its explicit calculation. Other filters can be passed as parameters. The SGWT provides a multi-scale analysis of graph signals.
</p>
<p>Given a graph signal <code class="reqn">f</code> of length <code class="reqn">N</code>, <code>forward_sgwt</code> computes the wavelet coefficients using SGWT.
</p>
<p>The eigenvalues and eigenvectors of the graph Laplacian, are denoted as <code class="reqn">\Lambda</code> and <code class="reqn">U</code> respectively. The parameter <code class="reqn">b</code> controls the number of scales, and <code class="reqn">\lambda_{\text{max}}</code> is the largest eigenvalue.
</p>
<p>For each scale <code class="reqn">j = 0, \ldots, J</code>, where
</p>
<p style="text-align: center;"><code class="reqn">J = \left\lfloor \frac{\log(\lambda_{\text{max}})}{\log(b)} \right\rfloor + 2</code>
</p>
<p> the wavelet coefficients are computed as:
</p>
<p style="text-align: center;"><code class="reqn">
\mathbf{w}_j = U \left( g_j \odot (U^T f) \right)
</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">g_j(\lambda) = \sqrt{\psi_j(\lambda)}</code>
</p>
<p> and <code class="reqn">\odot</code> denotes element-wise multiplication.
</p>
<p>The final result is a concatenated vector of these coefficients for all scales.
</p>


<h3>Value</h3>

<p><code>wc</code> A concatenated vector of wavelet coefficients.
</p>


<h3>Note</h3>

<p><code>forward_sgwt</code> can be adapted for other filters by passing a different filter function to the <code>filter_func</code> parameter.
</p>
<p>The computation of <code class="reqn">k_{\text{max}}</code> using <code class="reqn">\lambda_{\text{max}}</code> and <code class="reqn">b</code> applies primarily to the default <code>zetav</code> filter. It can be overridden by providing it in the <code>filter_params</code> list for other filters.
</p>


<h3>References</h3>

<p>Göbel, F., Blanchard, G., von Luxburg, U. (2018). Construction of tight frames on graphs and application to denoising. In Handbook of Big Data Analytics (pp. 503-522). Springer, Cham.
</p>
<p>Hammond, D. K., Vandergheynst, P., &amp; Gribonval, R. (2011). Wavelets on graphs via spectral graph theory. Applied and Computational Harmonic Analysis, 30(2), 129-150.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inverse_sgwt">inverse_sgwt</a></code>, <code><a href="#topic+tight_frame">tight_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L &lt;- laplacian_mat(grid1$sA)

# Compute the spectral decomposition of L
decomp &lt;- eigensort(L)

# Create a sample graph signal
f &lt;- rnorm(nrow(L))

# Compute the forward Spectral Graph Wavelet Transform
wc &lt;- forward_sgwt(f, decomp$evalues, decomp$evectors)

## End(Not run)

</code></pre>

<hr>
<h2 id='full'>Conversion of Symmetric Sparse Matrix to Full Matrix</h2><span id='topic+full'></span>

<h3>Description</h3>

<p><code>full</code> converts a symmetric sparse matrix, represented as <code>sA</code>, into a full matrix <code>A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full(sA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_+3A_sa">sA</code></td>
<td>
<p>Symmetric sparse matrix, either in a sparse matrix format or in a three-column format, that needs to be converted into a full matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>A</code> Full matrix constructed from the symmetric sparse matrix <code>sA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fullup">fullup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sA &lt;- pittsburgh$sA
A &lt;- full(sA)
</code></pre>

<hr>
<h2 id='fullup'>Convert Symmetric Sparse Matrix to Full Matrix</h2><span id='topic+fullup'></span>

<h3>Description</h3>

<p><code>fullup</code> converts a symmetric sparse matrix <code>sA</code>, stored as an upper triangular matrix, to a full matrix <code>A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fullup(sA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fullup_+3A_sa">sA</code></td>
<td>
<p>Matrix (sparseMatrix). Symmetric upper triangular matrix to be converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used for transforming matrices that have been stored in a memory-efficient format (i.e., the upper triangle portion of a symmetric matrix) to their full format. The conversion is done either by directly transforming the sparse matrix or by leveraging the <code><a href="#topic+full">full</a></code> function.
</p>


<h3>Value</h3>

<p><code>A</code> Full symmetric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+full">full</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grid1)
A &lt;- fullup(grid1$sA)
</code></pre>

<hr>
<h2 id='get_graph_info'>Retrieve Information Tables about a Specific Graph from the SuiteSparse Matrix Collection</h2><span id='topic+get_graph_info'></span>

<h3>Description</h3>

<p><code>get_graph_info</code> fetches the overview tables about a specified graph/matrix from the SuiteSparse Matrix Collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_graph_info(matrixname, groupname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_graph_info_+3A_matrixname">matrixname</code></td>
<td>
<p>Name of the matrix/graph for which to fetch information.</p>
</td></tr>
<tr><td><code id="get_graph_info_+3A_groupname">groupname</code></td>
<td>
<p>Name of the group that provides the matrix/graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tables contain detailed information and properties about the graph/matrix, such as its size, number of non-zero elements, etc. Visit <a href="https://sparse.tamu.edu/">https://sparse.tamu.edu/</a> of see <code><a href="#topic+SuiteSparseData">SuiteSparseData</a></code> to explore groups and matrix names.
</p>


<h3>Value</h3>

<p>A list of tables with detailed information about the specified matrix/graph:
</p>

<ul>
<li><p> &quot;Matrix Information&quot;
</p>
</li>
<li><p> &quot;Matrix Properties&quot;
</p>
</li>
<li><p> &quot;SVD Statistics&quot; (if available)
</p>
</li></ul>



<h3>Note</h3>

<p>The <code>rvest</code> package is used for parsing HTML, if it is not installed, the function will prompt for installation.
</p>


<h3>References</h3>

<p>Davis, T. A., &amp; Hu, Y. (2011). The University of Florida sparse matrix collection. ACM Transactions on Mathematical Software (TOMS), 38(1), 1-25.
</p>
<p>Kolodziej, S. P., Aznaveh, M., Bullock, M., David, J., Davis, T. A., Henderson, M.,
Hu, Y., &amp; Sandstrom, R. (2019). The suitesparse matrix collection website interface. Journal of Open Source Software, 4(35), 1244.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
matrixname &lt;- "grid1"
groupname &lt;- "AG-Monien"
info_tables &lt;- get_graph_info(matrixname,groupname)

# Matrix Information
info_tables[[1]]

# Matrix Properties
info_tables[[2]]

# SVD Statistics
info_tables[[3]]

## End(Not run)
#' @seealso \code{\link{download_graph}}, \code{\link{SuiteSparseData}}
</code></pre>

<hr>
<h2 id='grid1'>Grid1 Graph from AG-Monien Graph Collection</h2><span id='topic+grid1'></span>

<h3>Description</h3>

<p>This dataset represents the &quot;grid1&quot; graph sourced from the AG-Monien Graph Collection,
a collection of test graphs provided by Ralf Diekmann and Robert Preis.
The AG-Monien collection encompasses graphs from various origins, including the Harwell-Boeing collection, NASA matrices, and other graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid1
</code></pre>


<h3>Format</h3>

<p>list of 3 elements
</p>

<ul>
<li> <p><code>xy</code>: A matrix with the coordinates for each node in the graph.
</p>
</li>
<li> <p><code>sA</code>: A sparse matrix representation of the graph's adjacency matrix.
</p>
</li>
<li> <p><code>dim</code>: A numeric vector containing the numbers of rows, columns, and numerically nonzero elements in the adjacency matrix.
</p>
</li>
<li> <p><code>temp</code>: empty list (the path to the temporary directory where the matrix and downloaded files from <code><a href="#topic+download_graph">download_graph</a></code> function).
</p>
</li>
<li> <p><code>info</code>: <code>info</code>: Additional information about the graph.
</p>
</li></ul>



<h3>Source</h3>

<p>AG-Monien Graph Collection by Ralf Diekmann and Robert Preis.
</p>

<hr>
<h2 id='GVN'>Graph Von Neumann Variance Estimator</h2><span id='topic+GVN'></span>

<h3>Description</h3>

<p><code>GVN</code> computes graph equivalent of the Von Neummann variance estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GVN(y, A, L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GVN_+3A_y">y</code></td>
<td>
<p>Numeric vector that represents the noisy data.</p>
</td></tr>
<tr><td><code id="GVN_+3A_a">A</code></td>
<td>
<p>Adjacency matrix of the graph.</p>
</td></tr>
<tr><td><code id="GVN_+3A_l">L</code></td>
<td>
<p>Laplacian matrix of the graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many real-world scenarios, the noise level <code class="reqn">\sigma^2</code> remains generally unknown. Given any function <code class="reqn">g : \mathbb R_+ \rightarrow \mathbb R_+</code>, a straightforward computation gives:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf E[\widetilde f^T g(L) \widetilde f] = f^T g(L) f + \mathbf E[\xi^T g(L) \xi] = f^T g(L) f + \sigma^2 \mathrm{Tr}(g(L))</code>
</p>

<p>A biased estimator of the variance <code class="reqn">\sigma^2</code> can be given by:
</p>
<p style="text-align: center;"><code class="reqn">\hat \sigma^2_1 = \frac{\widetilde f^T g(L) \widetilde f}{\mathrm{Tr}(g(L))}</code>
</p>

<p>Assuming the original graph signal is smooth enough that <code class="reqn">f^T g(L) f</code> is negligible compared to <code class="reqn">\mathrm{Tr}(g(L))</code>, <code class="reqn">\hat \sigma^2</code> provides a reasonably accurate estimate of <code class="reqn">\sigma^2</code>. For this function, a common choice is <code class="reqn">g(x) = x</code>. Thanks to Dirichlet's formula, it follows:
</p>
<p style="text-align: center;"><code class="reqn">\hat \sigma^2_1 = \frac{\widetilde f^T L \widetilde f}{\mathrm{Tr}(L)} = \frac{\sum_{i,j \in V} w_{ij} |\widetilde f(i) - \widetilde f(j)|^2}{2 \mathrm{Tr}(L)}</code>
</p>

<p>This is the graph adaptation of the Von Neumann estimator, hence the term Graph Von Neumann estimator (GVN).
</p>


<h3>Value</h3>

<p>The Graph Von Neumann variance estimate for the given noisy data.
</p>


<h3>References</h3>

<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>
<p>von Neumann, J. (1941). Distribution of the ratio of the mean square successive difference to the variance. <em>Ann. Math. Statistics</em>, 35(3), 433&ndash;451.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HPFVN">HPFVN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(minnesota)
A &lt;- minnesota$A
L &lt;- laplacian_mat(A)
x &lt;- minnesota$xy[ ,1]
n &lt;- length(x)
f &lt;- sin(x)
sigma &lt;- 0.1
noise &lt;- rnorm(n, sd = sigma)
y &lt;- f + noise
sigma^2
GVN(y, A, L)

## End(Not run)
</code></pre>

<hr>
<h2 id='HPFVN'>High Pass Filter Von Neumann Estimator</h2><span id='topic+HPFVN'></span>

<h3>Description</h3>

<p><code>HPFVN</code> computes graph extension of the Von Neummann variance estimator using finest scale coefficients (as in classical wavelet approaches).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPFVN(wcn, evalues, b, filter_func = zetav, filter_params = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HPFVN_+3A_wcn">wcn</code></td>
<td>
<p>Numeric vector of noisy wavelet coefficients.</p>
</td></tr>
<tr><td><code id="HPFVN_+3A_evalues">evalues</code></td>
<td>
<p>Numeric vector corresponding to Laplacian spectrum.</p>
</td></tr>
<tr><td><code id="HPFVN_+3A_b">b</code></td>
<td>
<p>numeric parameter that control the number of scales.</p>
</td></tr>
<tr><td><code id="HPFVN_+3A_filter_func">filter_func</code></td>
<td>
<p>Function used to compute the filter values. By default, it uses the <code><a href="#topic+zetav">zetav</a></code> function but other frame filters can be passed.</p>
</td></tr>
<tr><td><code id="HPFVN_+3A_filter_params">filter_params</code></td>
<td>
<p>List of additional parameters required by filter_func. Default is an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The High Pass Filter Von Neumann Estimator (HPFVN) is the graph analog of the classical Von Neumann estimator, focusing on the finest scale coefficients. It leverages the characteristics of the graph signal's wavelet coefficients to estimate the variance:
</p>
<p style="text-align: center;"><code class="reqn">\hat \sigma^2 = \frac{\sum_{i=nJ+1}^{n(J+1)} (\mathcal{W} y)^2_i}{\mathrm{Tr}~\psi_J(L)}</code>
</p>



<h3>Note</h3>

<p><code>HPFVN</code> can be adapted for other filters by passing a different filter function to the <code>filter_func</code> parameter.
</p>
<p>The computation of <code class="reqn">k_{\text{max}}</code> using <code class="reqn">\lambda_{\text{max}}</code> and <code class="reqn">b</code> applies primarily to the default <code>zetav</code> filter. It can be overridden by providing it in the <code>filter_params</code> list for other filters.
</p>


<h3>References</h3>

<p>Donoho, D. L., &amp; Johnstone, I. M. (1994). Ideal spatial adaptation by wavelet shrinkage. biometrika, 81(3), 425-455.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>
<p>von Neumann, J. (1941). Distribution of the ratio of the mean square successive difference to the variance. <em>Ann. Math. Statistics</em>, 35(3), 433&ndash;451.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GVN">GVN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
A &lt;- grid1$sA
L &lt;- laplacian_mat(A)
x &lt;- grid1$xy[ ,1]
n &lt;- length(x)
val1 &lt;- eigensort(L)
evalues &lt;- val1$evalues
evectors &lt;- val1$evectors
f &lt;- sin(x)
sigma &lt;- 0.1
noise &lt;- rnorm(n, sd = sigma)
y &lt;- f + noise
b &lt;- 2
wcn &lt;- forward_sgwt(y, evalues, evectors, b=b)
sigma^2
HPFVN(wcn, evalues, b)
## End(Not run)
</code></pre>

<hr>
<h2 id='inverse_gft'>Compute Inverse Graph Fourier Transform</h2><span id='topic+inverse_gft'></span>

<h3>Description</h3>

<p><code>inverse_gft</code> computes the Inverse Graph Fourier Transform (IGFT) of a given transformed graph signal <code class="reqn">\hat{f}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_gft(L, hatf, U = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_gft_+3A_l">L</code></td>
<td>
<p>Laplacian matrix of the graph (matrix).</p>
</td></tr>
<tr><td><code id="inverse_gft_+3A_hatf">hatf</code></td>
<td>
<p>Numeric vector. Graph Fourier Transform of the signal to be inverted.</p>
</td></tr>
<tr><td><code id="inverse_gft_+3A_u">U</code></td>
<td>
<p>Matrix of the eigenvectors of the Laplacian matrix. If NULL (default), the function will compute the eigendecomposition of the Laplacian.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IGFT enables the reconstruction of graph signals from their frequency domain representation. The &quot;frequency&quot; in the context of graph signal processing refers to the decomposition of the signal using the graph's Laplacian eigenvectors.
</p>
<p>The IGFT of a transformed graph signal <code class="reqn">\hat{f}</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">
f = U \hat{f}
</code>
</p>

<p>where <code class="reqn">U</code> represents the matrix of eigenvectors of the graph's Laplacian.
</p>
<p>When the eigenvectors <code class="reqn">U</code> are not provided, the function computes them from the Laplacian matrix <code class="reqn">L</code>.
</p>


<h3>Value</h3>

<p><code>f</code> Numeric vector. Original graph signal obtained from the inverse transform of <code class="reqn">\hat{f}</code>.
</p>


<h3>References</h3>

<p>Ortega, A., Frossard, P., Kovačević, J., Moura, J. M., &amp; Vandergheynst, P. (2018). Graph signal processing: Overview, challenges, and applications. Proceedings of the IEEE, 106(5), 808-828.
</p>
<p>Shuman, D. I., Narang, S. K., Frossard, P., Ortega, A., &amp; Vandergheynst, P. (2013). The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains. IEEE signal processing magazine, 30(3), 83-98.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forward_gft">forward_gft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L &lt;- laplacian_mat(grid1$sA)

# Create a sample graph signal
f &lt;- rnorm(nrow(L))

# Compute the forward GFT
hatf &lt;- forward_gft(L, f)

# Compute the forward GFT
recf &lt;- inverse_gft(L, hatf)

## End(Not run)

</code></pre>

<hr>
<h2 id='inverse_sgwt'>Compute Inverse Spectral Graph Wavelet Transform</h2><span id='topic+inverse_sgwt'></span>

<h3>Description</h3>

<p><code>inverse_sgwt</code> computes the pseudo-inverse Spectral Graph Wavelet Transform (SGWT) for wavelet coefficients <code>wc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_sgwt(
  wc,
  evalues,
  evectors,
  b = 2,
  filter_func = zetav,
  filter_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_sgwt_+3A_wc">wc</code></td>
<td>
<p>Numeric vector representing the spectral graph wavelet coefficients to reconstruct the graph signal from.</p>
</td></tr>
<tr><td><code id="inverse_sgwt_+3A_evalues">evalues</code></td>
<td>
<p>Numeric vector of eigenvalues of the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="inverse_sgwt_+3A_evectors">evectors</code></td>
<td>
<p>Matrix of eigenvectors of the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="inverse_sgwt_+3A_b">b</code></td>
<td>
<p>Numeric scalar that control the number of scales in the SGWT. It must be greater than 1.</p>
</td></tr>
<tr><td><code id="inverse_sgwt_+3A_filter_func">filter_func</code></td>
<td>
<p>Function used to compute the filter values. By default, it uses the <code><a href="#topic+zetav">zetav</a></code> function but other frame filters can be passed.</p>
</td></tr>
<tr><td><code id="inverse_sgwt_+3A_filter_params">filter_params</code></td>
<td>
<p>List of additional parameters required by filter_func. Default is an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation corresponds to the frame defined by the <code><a href="#topic+tight_frame">tight_frame</a></code> function. Other filters can be passed as parameters. Given the tightness of the frame, the inverse is simply the application of the adjoint linear transformation to the wavelet coefficients.
</p>
<p>Given wavelet coefficients <code>wc</code>, <code>inverse_sgwt</code> reconstructs the original graph signal using the inverse SGWT.
</p>
<p>The eigenvalues and eigenvectors of the graph Laplacian are denoted as <code class="reqn">\Lambda</code> and <code class="reqn">U</code> respectively. The parameter <code class="reqn">b</code> controls the number of scales, and <code class="reqn">\lambda_{\text{max}}</code> is the largest eigenvalue.
</p>
<p>For each scale <code class="reqn">j = 0,\ldots, J</code>, where
</p>
<p style="text-align: center;"><code class="reqn">J = \left\lfloor \frac{\log(\lambda_{\text{max}})}{\log(b)} \right\rfloor + 2</code>
</p>
<p> the reconstructed signal for that scale is computed as:
</p>
<p style="text-align: center;"><code class="reqn">
\mathbf{f}_j = (U \mathbf{wc}_j \odot g_j) U^T
</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">g_j(\lambda) = \sqrt{\psi_j(\lambda)}</code>
</p>
<p> and <code class="reqn">\odot</code> denotes element-wise multiplication.
</p>
<p>The final result is the sum of <code class="reqn">\mathbf{f}_j</code> across all scales to reconstruct the entire graph signal.
</p>


<h3>Value</h3>

<p><code>f</code> A graph signal obtained by applying the SGWT adjoint to <code>wc</code>.
</p>


<h3>Note</h3>

<p><code>inverse_sgwt</code> can be adapted for other filters by passing a different filter function to the <code>filter_func</code> parameter.
The computation of <code class="reqn">k_{\text{max}}</code> using <code class="reqn">\lambda_{\text{max}}</code> and <code class="reqn">b</code> applies primarily to the default <code>zetav</code> filter. It can be overridden by providing it in the <code>filter_params</code> list for other filters.
</p>


<h3>References</h3>

<p>Göbel, F., Blanchard, G., von Luxburg, U. (2018). Construction of tight frames on graphs and application to denoising. In Handbook of Big Data Analytics (pp. 503-522). Springer, Cham.
</p>
<p>Hammond, D. K., Vandergheynst, P., &amp; Gribonval, R. (2011). Wavelets on graphs via spectral graph theory. Applied and Computational Harmonic Analysis, 30(2), 129-150.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forward_sgwt">forward_sgwt</a></code>, <code><a href="#topic+tight_frame">tight_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L &lt;- laplacian_mat(grid1$sA)

# Compute the spectral decomposition of L
decomp &lt;- eigensort(L)

# Create a sample graph signal
f &lt;- rnorm(nrow(L))

# Compute the forward Spectral Graph Wavelet Transform
wc &lt;- forward_sgwt(f, decomp$evalues, decomp$evectors)

# Reconstruct the graph signal using the inverse SGWT
f_rec &lt;- inverse_sgwt(wc, decomp$evalues, decomp$evectors)

## End(Not run)

</code></pre>

<hr>
<h2 id='laplacian_mat'>Compute the Graph Laplacian Matrix</h2><span id='topic+laplacian_mat'></span>

<h3>Description</h3>

<p><code>laplacian_mat</code> computes various forms of the graph Laplacian matrix for a given adjacency matrix <code>W</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacian_mat(W, type = "unnormalized")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplacian_mat_+3A_w">W</code></td>
<td>
<p>Adjacency matrix (dense or sparseMatrix).</p>
</td></tr>
<tr><td><code id="laplacian_mat_+3A_type">type</code></td>
<td>
<p>Character string, type of Laplacian matrix to compute. Can be &quot;unnormalized&quot; (default), &quot;normalized&quot;, or &quot;randomwalk&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function supports three types of Laplacian matrices:
</p>

<ul>
<li><p> Unnormalized Laplacian:
</p>
<p style="text-align: center;"><code class="reqn">L = D - W</code>
</p>

</li>
<li><p> Normalized Laplacian:
</p>
<p style="text-align: center;"><code class="reqn">L_{norm} = I - D^{-1/2} W D^{-1/2}</code>
</p>

</li>
<li><p> Random Walk Laplacian:
</p>
<p style="text-align: center;"><code class="reqn">L_{rw} = I - D^{-1} W</code>
</p>

</li></ul>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">D</code> is the degree matrix, a diagonal matrix where each diagonal element <code class="reqn">D_{ii}</code> represents the sum of the weights of all edges connected to node <code class="reqn">i</code>.
</p>
</li>
<li> <p><code class="reqn">W</code> is the adjacency matrix of the graph.
</p>
</li>
<li> <p><code class="reqn">I</code> is the identity matrix.
</p>
</li></ul>

<p>The function supports both standard and sparse matrix representations of the adjacency matrix.
</p>


<h3>Value</h3>

<p><code>L</code> The graph Laplacian matrix.
</p>


<h3>References</h3>

<p>Chung, F. R. (1997). Spectral graph theory (Vol. 92). American Mathematical Soc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define the 3x3 adjacency matrix
W &lt;- matrix(c(0, 1, 0,
              1, 0, 1,
              0, 1, 0), ncol=3)

# Non-sparse cases
laplacian_mat(W, "unnormalized")
laplacian_mat(W, "normalized")
laplacian_mat(W, "randomwalk")

# Convert W to a sparse matrix
W_sparse &lt;- as(W, "sparseMatrix")

# Sparse cases
laplacian_mat(W_sparse, "unnormalized")
laplacian_mat(W_sparse, "normalized")
laplacian_mat(W_sparse, "randomwalk")
</code></pre>

<hr>
<h2 id='LD_SUREthresh'>Level Dependent Stein's Unbiased Risk Estimate Thresholding</h2><span id='topic+LD_SUREthresh'></span>

<h3>Description</h3>

<p>Adaptive threshold selection using the Level Dependent Stein's Unbiased Risk Estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LD_SUREthresh(
  J,
  wcn,
  diagWWt,
  beta = 2,
  sigma,
  hatsigma = NA,
  policy = "uniform",
  keepSURE = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD_SUREthresh_+3A_j">J</code></td>
<td>
<p>Integer. The finest scale, or the highest frequency. This parameter determines the total number of scales that the function will process.</p>
</td></tr>
<tr><td><code id="LD_SUREthresh_+3A_wcn">wcn</code></td>
<td>
<p>A numeric vector of noisy spectral graph wavelet coefficients that need to be thresholded.</p>
</td></tr>
<tr><td><code id="LD_SUREthresh_+3A_diagwwt">diagWWt</code></td>
<td>
<p>Numeric vector of weights.</p>
</td></tr>
<tr><td><code id="LD_SUREthresh_+3A_beta">beta</code></td>
<td>
<p>Numeric. The type of thresholding to be used. If beta=1, soft thresholding is applied. If beta=2, James-Stein thresholding is applied (Default is 2).</p>
</td></tr>
<tr><td><code id="LD_SUREthresh_+3A_sigma">sigma</code></td>
<td>
<p>Numeric. The standard deviation of the noise present in the wavelet coefficients.</p>
</td></tr>
<tr><td><code id="LD_SUREthresh_+3A_hatsigma">hatsigma</code></td>
<td>
<p>Numeric. An optional estimator of the noise standard deviation. If provided, the function will also compute wavelet coefficient estimates using this estimator.</p>
</td></tr>
<tr><td><code id="LD_SUREthresh_+3A_policy">policy</code></td>
<td>
<p>The policy for threshold setting. It can be either &quot;uniform&quot; (default) or
&quot;dependent&quot;.</p>
</td></tr>
<tr><td><code id="LD_SUREthresh_+3A_keepsure">keepSURE</code></td>
<td>
<p>A logical flag. If <code>TRUE</code>, the function will also return a list containing the results of the SURE thresholding for each scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies SURE in a level dependent manner to wavelet coefficients, which aims to minimize SURE at each wavelet scale.
</p>
<p>In the &quot;uniform&quot; policy, the thresholds are set based on the absolute value of the wavelet coefficients. In the &quot;dependent&quot; policy, the thresholds are set based on the wavelet coefficients normalized by the weights from <code>diagWWt</code>.
</p>


<h3>Value</h3>

<p>A list containing the wavelet coefficient estimates after applying the SURE
thresholding.
</p>

<ul>
<li> <p><code>wcLDSURE</code>: The wavelet coefficient estimates obtained by minimizing SURE.
</p>
</li>
<li> <p><code>wcLDhatSURE</code>: If <code>hatsigma</code> is provided, this component contains the
wavelet coefficient estimates obtained using the <code>hatsigma</code> estimator.
</p>
</li>
<li> <p><code>lev_thresh</code>: If <code>keepSURE</code> is <code>TRUE</code>, this component contains a list of results similar to the output of <code>SUREthresh</code> for each scale.
</p>
</li></ul>



<h3>References</h3>

<p>Donoho, D. L., &amp; Johnstone, I. M. (1995). Adapting to unknown smoothness via wavelet shrinkage. Journal of the american statistical association, 90(432), 1200-1224.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with
Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>
<p>Stein, C. M. (1981). Estimation of the mean of a multivariate normal distribution. The annals of Statistics, 1135-1151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SUREthresh">SUREthresh</a></code> for the underlying thresholding method used at each scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute the Laplacian matrix and its eigen-decomposition
L &lt;- laplacian_mat(grid1$sA)
U &lt;- eigensort(L)

# Compute the tight frame coefficients
tf &lt;- tight_frame(U$evalues, U$evectors)

# Generate some noisy observation
n &lt;- nrow(L)
f &lt;- randsignal(0.01, 3, grid1$sA)
sigma &lt;- 0.01
noise &lt;- rnorm(n, sd = sigma)
tilde_f &lt;- f + noise

# Compute the transform coefficients
wcn &lt;- forward_sgwt(f, U$evalues, U$evectors)
wcf &lt;- forward_sgwt(f, U$evalues, U$evectors)

# Compute the weights
diagWWt &lt;- colSums(t(tf)^2)

# Compute to optimal threshold
lmax &lt;- max(U$evalues)
J &lt;- floor(log(lmax)/log(b)) + 2
LD_opt_thresh_u &lt;- LD_SUREthresh(J=J,
                                 wcn=wcn,
                                 diagWWt=diagWWt,
                                 beta=2,
                                 sigma=sigma,
                                 hatsigma=NA,
                                 policy = "uniform",
                                 keepSURE = FALSE)

# Get the graph signal estimator
hatf_LD_SURE_u &lt;- synthesis(LD_opt_thresh_u$wcLDSURE, tf)

## End(Not run)

</code></pre>

<hr>
<h2 id='localize_gft'>Localize Kernel at a Graph Vertex Using GFT</h2><span id='topic+localize_gft'></span>

<h3>Description</h3>

<p>This function localizes a kernel at a specific vertex using the Graph Fourier Transform (GFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localize_gft(i, L, evectors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localize_gft_+3A_i">i</code></td>
<td>
<p>Integer index of the node where to localize the kernel.</p>
</td></tr>
<tr><td><code id="localize_gft_+3A_l">L</code></td>
<td>
<p>Laplacian matrix of the graph.</p>
</td></tr>
<tr><td><code id="localize_gft_+3A_evectors">evectors</code></td>
<td>
<p>Numeric matrix of the eigenvectors of the Laplacian matrix. If NULL (default), the function will compute the eigendecomposition of the Laplacian.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GFT represents the signal in the graph's frequency domain through the eigendecomposition of the Laplacian matrix.
</p>
<p>The kernel is localized by transforming an impulse signal centered at vertex <code class="reqn">i</code> using the GFT. The impulse for vertex <code class="reqn">i</code> is represented by a vector <code class="reqn">s</code> with all zeros except for a single one at the i-th position.
The GFT of a signal <code class="reqn">s</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{s} = U^T s</code>
</p>

<p>where <code class="reqn">U</code> is the matrix of eigenvectors of the Laplacian.
</p>
<p>Applying the GFT to the impulse signal provides a spatial representation of the eigenvector (or kernel) associated with a specific frequency (eigenvalue) centered around vertex <code class="reqn">i</code>. This depicts how the kernel influences the local neighborhood of the vertex.
</p>


<h3>Value</h3>

<p><code>s</code> Kernel localized at vertex <code>i</code> using GFT.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forward_gft">forward_gft</a></code>,<code><a href="#topic+localize_sgwt">localize_sgwt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
L &lt;- laplacian_mat(grid1$sA)
vertex_i &lt;- sample(1:nrow(L), 1)
s &lt;- localize_gft(vertex_i, L=L)
plot_signal(grid1, s)
s_gft &lt;- forward_gft(L, s)
barplot(abs(s_gft), main="GFT of Localized Signal",
        xlab="Eigenvalue Index", ylab="Magnitude")

## End(Not run)
</code></pre>

<hr>
<h2 id='localize_sgwt'>Localize a Kernel at a Specific Vertex using SGWT</h2><span id='topic+localize_sgwt'></span>

<h3>Description</h3>

<p>This function localizes a kernel at a specific vertex using the Spectral Graph Wavelet Transform (SGWT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localize_sgwt(i, evalues, evectors, b = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localize_sgwt_+3A_i">i</code></td>
<td>
<p>Integer index of the node where to localize the kernel.</p>
</td></tr>
<tr><td><code id="localize_sgwt_+3A_evalues">evalues</code></td>
<td>
<p>Numeric vector of the eigenvalues of the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="localize_sgwt_+3A_evectors">evectors</code></td>
<td>
<p>Numeric matrix of the eigenvectors of the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="localize_sgwt_+3A_b">b</code></td>
<td>
<p>Numeric scalar that controls the number of scales in the SGWT. It must be greater than 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SGWT offers a comprehensive understanding of graph signals by providing insights into both vertex (spatial) and spectral (frequency) domains.
</p>
<p>The kernel is localized by transforming an impulse signal centered at vertex <code class="reqn">i</code> using the SGWT.
The SGWT leverages a wavelet function <code class="reqn">\psi(\lambda)</code> to provide a multi-resolution analysis of the graph signal.
The impulse signal at vertex <code class="reqn">i</code> is a vector <code class="reqn">f</code> with a one at the i-th position and zeros elsewhere.
The SGWT is given by:
</p>
<p style="text-align: center;"><code class="reqn">W_f(\lambda) = f \ast \psi(\lambda) = U \psi(\Lambda) U^T f</code>
</p>

<p>where <code class="reqn">U</code> is the matrix of eigenvectors of the Laplacian and <code class="reqn">\Lambda</code> is the diagonal matrix of eigenvalues.
The localized spatial view of the kernel's behavior around vertex <code class="reqn">i</code> is achieved by transforming this impulse signal using the above expression.
</p>
<p>To gain insights into the spectral localization of this localized kernel, one can analyze its GFT to understand how the energy of the kernel is distributed across various graph frequencies. As SGWT scales move from coarse to fine, energy concentration of the localized kernel shifts from lower to higher graph frequencies, indicating tighter spectral localization.
</p>


<h3>Value</h3>

<p><code>f</code> Kernel localized at vertex <code>i</code> using SGWT.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forward_sgwt">forward_sgwt</a></code>, <code><a href="#topic+forward_gft">forward_gft</a></code>, <code><a href="#topic+forward_gft">forward_gft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute the Laplacian matrix and its eigen-decomposition
L &lt;- laplacian_mat(grid1$sA)
decomp &lt;- eigensort(L)

# Randomly select a vertex
vertex_i &lt;- sample(1:nrow(L), 1)

f_sgwt &lt;- localize_sgwt(vertex_i, evalues=decomp$evalues, evectors=decomp$evectors, b=2)

# Select one scale j from f_sgwt.
N &lt;- nrow(grid1$sA)
j &lt;- 5 # change scale j to view other scales
f &lt;- f_sgwt[ ((j-1)*N+1):(j*N)]

# Plot the localized kernel (for the chosen scale) as a signal on the graph
plot_signal(grid1, f)

# Plot the magnitude of the GFT coefficients
barplot(abs(f_gft), main="GFT of Localized Signal",
        xlab="Eigenvalue Index", ylab="Magnitude")

## End(Not run)
</code></pre>

<hr>
<h2 id='minnesota'>Minnesota Road Network</h2><span id='topic+minnesota'></span>

<h3>Description</h3>

<p>A dataset representing the Minnesota road network along with two associated synthetic signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minnesota
</code></pre>


<h3>Format</h3>

<p>A list with 5 elements:
</p>

<ul>
<li> <p><code>xy</code> A matrix indicating the spatial location of each node.
</p>
</li>
<li> <p><code>sA</code> A sparse matrix representation of the road network's adjacency matrix.
</p>
</li>
<li> <p><code>f1</code> Synthetic signal generated with parameters <code class="reqn">\eta = 0.01</code> and <code class="reqn">k = 2</code>.
</p>
</li>
<li> <p><code>f2</code> Synthetic signal generated with parameters <code class="reqn">\eta = 0.001</code> and <code class="reqn">k = 4</code>.
</p>
</li>
<li> <p><code>labels</code> A character vector with labels that represent various points of entry, border crossings, and notable cities within Minnesota, with some nodes possibly lacking specific location identifiers.
</p>
</li></ul>



<h3>Details</h3>

<p>The Minnesota roads graph represents a planar structure consisting of 2642 vertices and 6606 edges.
</p>
<p>The signals come from the referenced paper generated using <code><a href="#topic+randsignal">randsignal</a></code> with parameters <code class="reqn">\eta=0.01, k=2</code> and <code class="reqn">\eta=0.001,k=4</code>.
</p>


<h3>Source</h3>

<p>D. Gleich. The MatlabBGL Matlab library.
</p>


<h3>References</h3>

<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>

<hr>
<h2 id='NYCdata'>NYC Taxi Network Dataset</h2><span id='topic+NYCdata'></span>

<h3>Description</h3>

<p>A dataset derived from NYC taxi trip records. Additionally, the dataset includes a signal <code>f</code> that represents the total amount with added noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NYCdata
</code></pre>


<h3>Format</h3>

<p>A list with 2 elements:
</p>

<ul>
<li> <p><code>A</code>: NYC adjacency matrix, constructed using Gaussian weights based on mean distances between locations.
</p>
</li>
<li> <p><code>f</code>: Signal representing the &quot;total amount&quot; with added artificial noise.
</p>
</li></ul>



<h3>Details</h3>

<p>The graph constructed represents the connectivity based on taxi trips between different locations. The weights of the edges represent the frequency and distances of trips between locations.
</p>
<p>The data comes from the methodology in the referenced paper. It is constructed from real-world data fetched from NYC taxis databases. The graph consists of 265 vertices which correspond to different LocationID (both Pick-Up and Drop-Off points). Gaussian weights are defined by
</p>
<p style="text-align: center;"><code class="reqn">w_{ij} = \exp(-\tau d_{i,j}^2)</code>
</p>
<p>, where <code class="reqn">d_{i,j}</code> represents the mean distance taken on all the trips between locations <code class="reqn">i</code> and <code class="reqn">j</code> or <code class="reqn">j</code> and <code class="reqn">i</code>.
</p>
<p>The signal <code>f</code> is constructed based on the &quot;total amount&quot; variable from the taxi dataset, with added artificial noise.
</p>


<h3>References</h3>

<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>

<hr>
<h2 id='pittsburgh'>Pittsburgh Census Tracts Network.</h2><span id='topic+pittsburgh'></span>

<h3>Description</h3>

<p>A dataset representing the graph structure of 402 census tracts of Allegheny County, PA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pittsburgh
</code></pre>


<h3>Format</h3>

<p>A list with 4 elements:
</p>

<ul>
<li> <p><code>sA</code> A sparse matrix capturing the connections between spatially adjacent census tracts in Allegheny County.
</p>
</li>
<li> <p><code>xy</code> A matrix indicating the spatial location of each census tract.
</p>
</li>
<li> <p><code>f</code> Artificial signal with inhomogeneous smoothness across nodes and two sharp peaks near the center. This signal is formed using a mixture of five Gaussians in the underlying spatial coordinates.
</p>
</li>
<li> <p><code>y</code> Noisy version of the signal.
</p>
</li></ul>



<h3>Source</h3>

<p>Data and associated materials were sourced from codes provided by Yu-Xiang Wang (UC Santa Barbara) and are associated with the referenced paper.
</p>


<h3>References</h3>

<p>Wang, Y. X., Sharpnack, J., Smola, A. J., &amp; Tibshirani, R. J. (2016). Trend Filtering on Graphs. Journal of Machine Learning Research, 17, 1-41.
</p>

<hr>
<h2 id='plot_filter'>Plot Tight-Frame Filters</h2><span id='topic+plot_filter'></span>

<h3>Description</h3>

<p><code>plot_filter</code> provides a graphical representation of tight-frame filters as functions of the eigenvalues of the Laplacian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_filter(lmax, b, N = 1000, filter_func = zetav, filter_params = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_filter_+3A_lmax">lmax</code></td>
<td>
<p>Largest eigenvalue of the Laplacian matrix (numeric scalar).</p>
</td></tr>
<tr><td><code id="plot_filter_+3A_b">b</code></td>
<td>
<p>Parameter that controls the number of scales (numeric scalar).</p>
</td></tr>
<tr><td><code id="plot_filter_+3A_n">N</code></td>
<td>
<p>Number of discretization points for the x-axis. By default, N is set to 1000.</p>
</td></tr>
<tr><td><code id="plot_filter_+3A_filter_func">filter_func</code></td>
<td>
<p>Function used to compute the filter values. By default, it uses the <code><a href="#topic+zetav">zetav</a></code> function but other frame filters can be pass.</p>
</td></tr>
<tr><td><code id="plot_filter_+3A_filter_params">filter_params</code></td>
<td>
<p>List of additional parameters required by filter_func. Default is an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plotted functions represent the square root of the values given by the <code>zetav</code> function at different scales.
</p>
<p>This function plots the square roots of the functions forming the partition of unity, corresponding to the construction of tight frames on the graph. The square root operation is essential as it ensures the Parseval identity, making the constructed frame &quot;tight&quot; and preserving the energy of signals on the graph when mapped to their frame representation.
</p>
<p><code>plot_filter</code> first determines the number of scales based on the largest eigenvalue <code class="reqn">\lambda_{\text{max}}</code> and the parameter <code class="reqn">b</code> as:
</p>
<p style="text-align: center;"><code class="reqn">
k_{\text{max}} = \left\lfloor \frac{\log(\lambda_{\text{max}})}{\log(b)} \right\rfloor + 2
</code>
</p>

<p>The function then plots the square root of the values given by the <code><a href="#topic+zetav">zetav</a></code> function over the range [0, <code class="reqn">\lambda_{\text{max}}</code>] for each scale.
</p>


<h3>Note</h3>

<p><code>plot_filter</code> can be adapted for other filters by passing a different filter function to the <code>filter_func</code> parameter.
The computation of <code class="reqn">k_{\text{max}}</code> using <code class="reqn">\lambda_{\text{max}}</code> and <code class="reqn">b</code> applies primarily to the default <code>zetav</code> filter. It can be overridden by providing it in the <code>filter_params</code> list for other filters.
</p>


<h3>References</h3>

<p>Coulhon, T., Kerkyacharian, G., &amp; Petrushev, P. (2012). Heat kernel generated frames in the setting of Dirichlet spaces. Journal of Fourier Analysis and Applications, 18(5), 995-1066.
</p>
<p>Göbel, F., Blanchard, G., von Luxburg, U. (2018). Construction of tight frames on graphs and application to denoising. In Handbook of Big Data Analytics (pp. 503-522). Springer, Cham.
</p>
<p>Leonardi, N., &amp; Van De Ville, D. (2013). Tight wavelet frames on multislice graphs. IEEE Transactions on Signal Processing, 61(13), 3357-3367.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zetav">zetav</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_filter(6,2)
</code></pre>

<hr>
<h2 id='plot_graph'>Plot Graph</h2><span id='topic+plot_graph'></span>

<h3>Description</h3>

<p>Visualizes a graph using ggplot2. It plots nodes as points and edges as segments connecting these points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_graph(z, size = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_graph_+3A_z">z</code></td>
<td>
<p>A list containing graph data. This list must have the following components:
</p>

<ul>
<li><p>sA  An adjacency matrix or a sparse Matrix representation of the graph.
</p>
</li>
<li><p>xy  A matrix or dataframe containing the x and y coordinates of each node in the graph.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_graph_+3A_size">size</code></td>
<td>
<p>Numeric. Dot size for nodes. Default is 0.75.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is primarily designed to work with the output from the <code><a href="#topic+download_graph">download_graph</a></code> function. This ensures that the graph visualization upholds the structure and properties of the retrieved graph. However, the function can also be utilized to visualize custom graph structures, provided they match to the input format.
</p>


<h3>Note</h3>

<p>If node coordinates <code>xy</code> are not provided, they will be calculated using spectral methods <code><a href="#topic+spectral_coords">spectral_coords</a></code>. For large graphs, this can be computationally intensive and may take significant time. Use with caution for large graphs if node coordinates are not supplied.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+download_graph">download_graph</a></code>, <code><a href="#topic+plot_signal">plot_signal</a></code>, <code><a href="#topic+spectral_coords">spectral_coords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grid1)
plot_graph(grid1)
</code></pre>

<hr>
<h2 id='plot_signal'>Plot a Signal on Top of a Given Graph</h2><span id='topic+plot_signal'></span>

<h3>Description</h3>

<p>Visualize a signal over a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_signal(z, f, size = 0.75, limits = range(f), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_signal_+3A_z">z</code></td>
<td>
<p>A list containing graph data. This list must have the following components:
</p>

<ul>
<li><p>sA  An adjacency matrix or a sparse Matrix representation of the graph.
</p>
</li>
<li><p>xy  A matrix or dataframe containing the x and y coordinates of each node in the graph.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_signal_+3A_f">f</code></td>
<td>
<p>Signal to plot.</p>
</td></tr>
<tr><td><code id="plot_signal_+3A_size">size</code></td>
<td>
<p>Numeric. Dot size for nodes. Default is 0.75.</p>
</td></tr>
<tr><td><code id="plot_signal_+3A_limits">limits</code></td>
<td>
<p>Set colormap limits.</p>
</td></tr>
<tr><td><code id="plot_signal_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>guide_colourbar</code> to customize the colorbar appearance (see <code>?guide_colourbar</code> for more details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows visualization of a graph signal <code>f</code> superimposed on the structure of a graph defined by <code>z</code>. It offers an intuitive way to analyze  the behavior of graph signals in the vertex domain. The appearance of the colorbar can be customized by passing additional arguments that are available for <code>ggplot2::guide_colourbar</code>.
</p>


<h3>Note</h3>

<p>If node coordinates <code>xy</code> are not provided, they will be calculated using spectral methods <code><a href="#topic+spectral_coords">spectral_coords</a></code>. For large graphs, this can be computationally intensive and may take significant time. Use with caution for large graphs if node coordinates are not supplied.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_graph">plot_graph</a></code>, <code><a href="#topic+spectral_coords">spectral_coords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rnorm(length(grid1$xy[,1]))
plot_signal(grid1, f)
</code></pre>

<hr>
<h2 id='PSNR'>Compute the Peak Signal to Noise Ratio</h2><span id='topic+PSNR'></span>

<h3>Description</h3>

<p><code>PSNR</code> function computes the Peak Signal to Noise Ratio (PSNR) between two signals or images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSNR(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSNR_+3A_x">x</code></td>
<td>
<p>Numeric vector/matrix. Original reference signal/image.</p>
</td></tr>
<tr><td><code id="PSNR_+3A_y">y</code></td>
<td>
<p>numeric vector/matrix. Restored or noisy signal/image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Higher values of PSNR indicate closer similarity between the original and the compared signal or image.
</p>
<p>The PSNR is defined by:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{PSNR}(x,y) = 10 \log_{10}\left(\frac{\max(\max(x),\max(y))^2}{\mathrm{MSE}(x, y)}\right)</code>
</p>



<h3>Value</h3>

<p><code>PSNR</code> Numeric. Peak Signal to Noise Ratio.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SNR">SNR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cos(seq(0, 10, length=100))
y &lt;- x + rnorm(100, sd=0.5)
PSNR(x, y)
</code></pre>

<hr>
<h2 id='randsignal'>Generate Random Signal with Varying Regularity</h2><span id='topic+randsignal'></span>

<h3>Description</h3>

<p><code>randsignal</code> constructs a random signal with specific regularity properties, utilizing the adjacency matrix <code>A</code> of the graph, a smoothness parameter <code>eta</code>, and an exponent <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randsignal(eta, k, A, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randsignal_+3A_eta">eta</code></td>
<td>
<p>Numeric. Smoothness parameter (between 0 and 1).</p>
</td></tr>
<tr><td><code id="randsignal_+3A_k">k</code></td>
<td>
<p>Interger. Smoothness parameter.</p>
</td></tr>
<tr><td><code id="randsignal_+3A_a">A</code></td>
<td>
<p>Adjacency matrix. Must be symmetric.</p>
</td></tr>
<tr><td><code id="randsignal_+3A_r">r</code></td>
<td>
<p>Optional. Largest eigenvalue of <code>A</code> in magnitude (obtained using the <code>eigs</code> function from the <code>RSpectra</code> package if not provided).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is inspired by the approach described in the first referenced paper.
</p>
<p>The generated signal is formulated as
<code class="reqn">f = A^k x_{\eta} / r^k</code>
where <code class="reqn">x_{\eta}</code> represents Bernoulli random variables, and <code class="reqn">r</code> is the largest eigenvalue of the matrix <code class="reqn">A</code>.
</p>
<p>The power <code class="reqn">k</code> essentially captures the influence of a node's <code class="reqn">k</code>-hop neighborhood in the generated signal, implying that a higher <code class="reqn">k</code> would aggregate more neighborhood information resulting in a smoother signal.
</p>
<p>The normalization by the largest eigenvalue ensures that the signal remains bounded. This signal generation can be related to the Laplacian quadratic form that quantifies the smoothness of signals on graphs. By controlling the parameters <code class="reqn">\eta</code> and <code class="reqn">k</code>, we can modulate the smoothness or regularity of the generated signal.
</p>


<h3>Value</h3>

<p><code>f</code> a numeric vector representing the output signal.
</p>


<h3>Note</h3>

<p>While the <code>randsignal</code> function uses the adjacency matrix to parameterize and generate signals reflecting node-to-node interactions, the smoothness of these signals can subsequently be measured using the <code>smoothmodulus</code> function.
</p>
<p>The generation is carried out in sparse matrices format in order to scale up.
</p>


<h3>References</h3>

<p>Behjat, H., Richter, U., Van De Ville, D., &amp; Sörnmo, L. (2016). Signal-adapted tight frames on graphs. IEEE Transactions on Signal Processing, 64(22), 6017-6029.
</p>
<p>de Loynes, B., Navarro, F., &amp; Olivier, B. (2021). Data-driven thresholding in denoising with spectral graph wavelet transform. Journal of Computational and Applied Mathematics, 389, 113319.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothmodulus">smoothmodulus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a signal with smoothness parameters eta = 0.7 and k = 3
f &lt;- randsignal(eta = 0.7, k = 3, A = grid1$sA)

## End(Not run)
</code></pre>

<hr>
<h2 id='rlogo'>R logo graph.</h2><span id='topic+rlogo'></span>

<h3>Description</h3>

<p>A dataset containing a graph based on the R logo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlogo
</code></pre>


<h3>Format</h3>

<p>A list with 2 elements:
</p>

<ul>
<li> <p><code>xy</code>: A matrix representing the coordinates for each node in the graph.
</p>
</li>
<li> <p><code>sA</code>: Adjacency matrix.
</p>
</li></ul>


<hr>
<h2 id='smoothmodulus'>Modulus of Smoothness for Graph Signal</h2><span id='topic+smoothmodulus'></span>

<h3>Description</h3>

<p><code>smoothmodulus</code> computes the modulus of smoothness (or Laplacian quadratic form) for a graph signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothmodulus(f, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothmodulus_+3A_f">f</code></td>
<td>
<p>Numeric vector representing the signal on the graph nodes</p>
</td></tr>
<tr><td><code id="smoothmodulus_+3A_a">A</code></td>
<td>
<p>Adjacency matrix of the graph (matrix, can be either sparse or dense).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>smoothmodulus</code> provide a measure that quantifies the smoothness of a signal on a graph. In other words, it provides a measure of how much a signal varies between adjacent nodes. This measure is analogous to the Laplacian quadratic form, which is a widely used metric in spectral graph theory for quantifying signal smoothness.
</p>
<p>The modulus of smoothness is calculated using:
<code class="reqn">\mu(f) = 0.5 \times \sum_{(i,j) \in E} A_{ij} (f_i - f_j)^2</code>
where <code class="reqn">E</code> is the set of edges, <code class="reqn">A_{ij}</code> is the adjacency matrix entry for nodes i and j, and <code class="reqn">f_i</code> and <code class="reqn">f_j</code> are the signal values at nodes i and j respectively.
</p>
<p>This metric essentially sums up the squared differences of signal values across adjacent nodes, weighted by the adjacency matrix. A high value indicates a more variable or irregular signal across the graph, while a lower value indicates a smoother signal.
</p>


<h3>Value</h3>

<p>A numeric scalar value indicating the modulus of smoothness for the graph signal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randsignal">randsignal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
A &lt;- grid1$sA
x &lt;- grid1$xy[,1]
f &lt;- sin(x)
smoothmodulus(f, A)

## End(Not run)
</code></pre>

<hr>
<h2 id='SNR'>Compute the Signal to Noise Ratio</h2><span id='topic+SNR'></span>

<h3>Description</h3>

<p><code>SNR</code> computes the Signal to Noise Ratio (SNR) between two signals, indicating the level of desired signal to the level of background noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SNR(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNR_+3A_x">x</code></td>
<td>
<p>Numeric vector/matrix. Original reference signal.</p>
</td></tr>
<tr><td><code id="SNR_+3A_y">y</code></td>
<td>
<p>Numeric vector/matrix. Restored or noisy signal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Higher values of SNR indicate a cleaner signal compared to the noise level. The SNR is computed as the ratio of the power of the signal (or the square of the Euclidean norm of the signal) to the power of the noise (or the square of the Euclidean norm of the signal difference), represented in decibels (dB).
</p>
<p>The SNR is defined by:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{SNR}(x,y) = 20 \log_{10}\left(\frac{\|x\|_2}{\|x-y\|_2}\right)</code>
</p>



<h3>Value</h3>

<p><code>SNR</code> Numeric. Signal to Noise Ratio.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PSNR">PSNR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cos(seq(0, 10, length=100))
y &lt;- x + rnorm(100, sd=0.5)
SNR(x, y)
</code></pre>

<hr>
<h2 id='spectral_coords'>Spectral Coordinates for Graph Drawing</h2><span id='topic+spectral_coords'></span>

<h3>Description</h3>

<p>Calculates the spectral coordinates of a graph using the two smallest non-zero eigenvalues of the graph Laplacian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_coords(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_coords_+3A_adj_mat">adj_mat</code></td>
<td>
<p>A symmetric adjacency matrix or sparse matrix representing an undirected graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spectral_coords</code> function implements a 2-dimensional spectral graph drawing method based on the eigenvectors of the graph Laplacian associated with its two smallest non-zero eigenvalues. Given a graph with adjacency matrix <code>adj_mat</code>, the graph Laplacian <code>L</code> is computed, which is a matrix representation that encodes the graph's topology. The Laplacian's eigenvalues and eigenvectors are calculated, and the eigenvectors corresponding to the second and third non-zero smallest eigenvalues are used to determine the coordinates of the graph's vertices in the plane.
</p>


<h3>Value</h3>

<p>A matrix where each row represents the spectral coordinates of a node in the graph.
</p>


<h3>References</h3>

<p>Chung, F. R. K. (1997). Spectral Graph Theory. American Mathematical Soc.
</p>
<p>Hall, K. M. (1970). An r-dimensional quadratic placement algorithm. Management science, 17(3), 219-229.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_graph">plot_graph</a></code>, <code><a href="#topic+plot_signal">plot_signal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
matrixname &lt;- "bcspwr02"
groupname &lt;- "HB"
download_graph(matrixname,groupname)
xy &lt;- spectral_coords(bcspwr02$sA)
bcspwr02$xy &lt;- xy
plot_graph(bcspwr02)

## End(Not run)
</code></pre>

<hr>
<h2 id='SuiteSparseData'>Matrix Data from SuiteSparse Matrix Collection</h2><span id='topic+SuiteSparseData'></span>

<h3>Description</h3>

<p>This dataset represents the collection of matrices from the SuiteSparse Matrix Collection. The structure of the dataframe mirrors the structure presented on the SuiteSparse Matrix Collection website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuiteSparseData
</code></pre>


<h3>Format</h3>

<p>A data frame with 2893 rows and 8 columns:
</p>

<dl>
<dt><code>ID</code></dt><dd><p>Integer. Unique identifier for each matrix.</p>
</dd>
<dt><code>Name</code></dt><dd><p>Character. Name of the matrix.</p>
</dd>
<dt><code>Group</code></dt><dd><p>Character. Group name the matrix belongs to.</p>
</dd>
<dt><code>Rows</code></dt><dd><p>Integer. Number of rows in the matrix.</p>
</dd>
<dt><code>Cols</code></dt><dd><p>Integer. Number of columns in the matrix.</p>
</dd>
<dt><code>Nonzeros</code></dt><dd><p>Integer. Number of non-zero elements in the matrix.</p>
</dd>
<dt><code>Kind</code></dt><dd><p>Character. Kind or category of the matrix.</p>
</dd>
<dt><code>Date</code></dt><dd><p>Character. Date when the matrix was added or updated.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The SuiteSparse Matrix Collection is a large set of sparse matrices that arise in real applications. It is widely used by the numerical linear algebra community for the development and performance evaluation of sparse matrix algorithms. The Collection covers a wide spectrum of domains, including both geometric and non-geometric domains.
</p>


<h3>Note</h3>

<p>Data download date: 2023-11-01
Note that the number of matrices in the SuiteSparse Matrix Collection may have increased since this download date.
</p>


<h3>Source</h3>

<p>SuiteSparse Matrix Collection website: <a href="https://sparse.tamu.edu/">https://sparse.tamu.edu/</a>
</p>


<h3>References</h3>

<p>Davis, T. A., &amp; Hu, Y. (2011). The University of Florida sparse matrix collection. ACM Transactions on Mathematical Software (TOMS), 38(1), 1-25.
</p>
<p>Kolodziej, S. P., Aznaveh, M., Bullock, M., David, J., Davis, T. A., Henderson, M., Hu, Y., &amp; Sandstrom, R. (2019). The suitesparse matrix collection website interface. Journal of Open Source Software, 4(35), 1244.
</p>

<hr>
<h2 id='SURE_MSEthresh'>Stein's Unbiased Risk Estimate with MSE</h2><span id='topic+SURE_MSEthresh'></span>

<h3>Description</h3>

<p>Adaptive Threshold Selection Using Principle of SURE with the inclusion of Mean Squared Error (MSE) for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SURE_MSEthresh(
  wcn,
  wcf,
  thresh,
  diagWWt,
  beta = 2,
  sigma,
  hatsigma = NA,
  policy = "uniform",
  keepwc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SURE_MSEthresh_+3A_wcn">wcn</code></td>
<td>
<p>Numeric vector of the noisy spectral graph wavelet coefficients.</p>
</td></tr>
<tr><td><code id="SURE_MSEthresh_+3A_wcf">wcf</code></td>
<td>
<p>Numeric vector of the true spectral graph wavelet coefficients.</p>
</td></tr>
<tr><td><code id="SURE_MSEthresh_+3A_thresh">thresh</code></td>
<td>
<p>Numeric vector of threshold values.</p>
</td></tr>
<tr><td><code id="SURE_MSEthresh_+3A_diagwwt">diagWWt</code></td>
<td>
<p>Numeric vector of weights typically derived from the diagonal elements of the wavelet frame matrix.</p>
</td></tr>
<tr><td><code id="SURE_MSEthresh_+3A_beta">beta</code></td>
<td>
<p>A numeric value specifying the type of thresholding to be used, for example:
</p>

<ul>
<li><p> 1 for soft thresholding.
</p>
</li>
<li><p> 2 for James-Stein thresholding.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SURE_MSEthresh_+3A_sigma">sigma</code></td>
<td>
<p>A numeric value representing the standard deviation (sd) of the noise.</p>
</td></tr>
<tr><td><code id="SURE_MSEthresh_+3A_hatsigma">hatsigma</code></td>
<td>
<p>An optional numeric value providing an estimate of the noise standard deviation (default is NA).</p>
</td></tr>
<tr><td><code id="SURE_MSEthresh_+3A_policy">policy</code></td>
<td>
<p>A character string determining the thresholding policy. Valid options include:
</p>

<ul>
<li><p> &quot;uniform&quot; for a global threshold applied uniformly across all coefficients.
</p>
</li>
<li><p> &quot;dependent&quot; for threshold values that adaptively depend on the corresponding 'diagWWt' weights.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SURE_MSEthresh_+3A_keepwc">keepwc</code></td>
<td>
<p>A logical value determining if the thresholded wavelet coefficients should be returned (Default is TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SURE_MSEthresh</code> function extends the <code>SUREthresh</code> function by providing an MSE between the true coefficients and their thresholded versions for a given thresholding function <code class="reqn">h</code>. This allows for a more comprehensive evaluation of the denoising quality in simulated scenarios where the true function is known.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> A dataframe with calculated MSE, SURE, and hatSURE values.
</p>
</li>
<li><p> Minima of SURE, hatSURE, and MSE, and their corresponding optimal thresholds.
</p>
</li>
<li><p> Thresholded wavelet coefficients (if <code>keepwc = TRUE</code>).
</p>
</li></ul>



<h3>References</h3>

<p>Donoho, D. L., &amp; Johnstone, I. M. (1995). Adapting to unknown smoothness via wavelet shrinkage. Journal of the american statistical association, 90(432), 1200-1224.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>
<p>Stein, C. M. (1981). Estimation of the mean of a multivariate normal distribution. The annals of Statistics, 1135-1151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SUREthresh">SUREthresh</a></code>, <code><a href="#topic+GVN">GVN</a></code>, <code><a href="#topic+HPFVN">HPFVN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute the Laplacian matrix and its eigen-decomposition
L &lt;- laplacian_mat(grid1$sA)
U &lt;- eigensort(L)

# Compute the tight frame coefficients
tf &lt;- tight_frame(U$evalues, U$evectors)

# Generate some noisy observation
n &lt;- nrow(L)
f &lt;- randsignal(0.01, 3, grid1$sA)
sigma &lt;- 0.01
noise &lt;- rnorm(n, sd = sigma)
tilde_f &lt;- f + noise

# Compute the transform coefficients
wcn &lt;- analysis(tilde_f, tf)
wcf &lt;- analysis(f, tf)

# Compute the weights and use DJ trick for the SURE evaluation
diagWWt &lt;- colSums(t(tf)^2)
thresh &lt;- sort(abs(wcn))

# Compute to optimal threshold
opt_thresh_u &lt;- SURE_MSEthresh(wcn,
                               wcf,
                               thresh,
                               diagWWt,
                               beta=2,
                               sigma,
                               NA,
                               policy = "uniform",
                               keepwc = TRUE)
# Extract corresponding wavelet coefficients
wc_oracle_u &lt;- opt_thresh_u$wc[, opt_thresh_u$min["xminMSE"]]
wc_SURE_u &lt;- opt_thresh_u$wc[, opt_thresh_u$min["xminSURE"]]

# Get the graph signal estimators
hatf_oracle_u &lt;- synthesis(wc_oracle_u, tf)
hatf_SURE_u  &lt;- synthesis(wc_SURE_u, tf)

# Compare the perfomance according to SNR measure
round(SNR(f, hatf_oracle_u), 2)
round(SNR(f, hatf_SURE_u), 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='SUREthresh'>Stein's Unbiased Risk Estimate</h2><span id='topic+SUREthresh'></span>

<h3>Description</h3>

<p>Adaptive Threshold Selection Using Principle of Stein's Unbiased Risk Estimate (SURE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SUREthresh(
  wcn,
  thresh,
  diagWWt,
  beta = 2,
  sigma,
  hatsigma = NA,
  policy = "uniform",
  keepwc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SUREthresh_+3A_wcn">wcn</code></td>
<td>
<p>Numeric vector of the noisy spectral graph wavelet coefficients.</p>
</td></tr>
<tr><td><code id="SUREthresh_+3A_thresh">thresh</code></td>
<td>
<p>Numeric vector of threshold values.</p>
</td></tr>
<tr><td><code id="SUREthresh_+3A_diagwwt">diagWWt</code></td>
<td>
<p>Numeric vector of weights typically derived from the diagonal elements of the wavelet frame matrix.</p>
</td></tr>
<tr><td><code id="SUREthresh_+3A_beta">beta</code></td>
<td>
<p>A numeric value specifying the type of thresholding to be used, for example:
</p>

<ul>
<li><p> 1 for soft thresholding.
</p>
</li>
<li><p> 2 for James-Stein thresholding.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SUREthresh_+3A_sigma">sigma</code></td>
<td>
<p>A numeric value representing the standard deviation (sd) of the noise.</p>
</td></tr>
<tr><td><code id="SUREthresh_+3A_hatsigma">hatsigma</code></td>
<td>
<p>An optional numeric value providing an estimate of the noise standard deviation (default is <code>NA</code>).</p>
</td></tr>
<tr><td><code id="SUREthresh_+3A_policy">policy</code></td>
<td>
<p>A character string determining the thresholding policy. Valid options include:
</p>

<ul>
<li> <p><code>"uniform"</code> for a global threshold applied uniformly across all coefficients.
</p>
</li>
<li> <p><code>"dependent"</code> for threshold values that adaptively depend on the corresponding <code>diagWWt</code> weights.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SUREthresh_+3A_keepwc">keepwc</code></td>
<td>
<p>A logical value determining if the thresholded wavelet coefficients should be returned (Default is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SUREthresh</code> function is a data-driven approach to finding the optimal thresholding value for denoising wavelet coefficients. SURE provides a means to evaluate the denoising quality of a given thresholding function <code class="reqn">h</code>. The expected risk in terms of the mean squared error (MSE) between the original coefficients <code class="reqn">\mathbf{F}</code> and their thresholded counterparts <code class="reqn">h(\widetilde{\mathbf{F}})</code>, considering a noise variance <code class="reqn">\sigma^2</code>, is given by:
</p>
<p style="text-align: center;"><code class="reqn">
\mathbb E \left[\|\mathbf{F} - h(\widetilde{\mathbf{F}})\|_2^2 \right] = \mathbb E \left[-n\sigma^2 + \|\widetilde{\mathbf{F}} - h(\widetilde{\mathbf{F}})\|_2^2 + 2\sigma^2 \sum_{i,j = 1}^{n(J+1)} \gamma_{ij} \partial_j h_i(\widetilde{\mathbf{F}}) \right]
</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">\widetilde{\mathbf{F}}</code> are the noisy wavelet coefficients.
</p>
</li>
<li> <p><code class="reqn">\gamma_{ij}</code> represents the elements of the matrix obtained by multiplying the transpose of the wavelet transform matrix <code class="reqn">\mathbf{\Psi}</code> with itself, i.e., <code class="reqn">\gamma_{ij} = (\mathbf{\Psi}^\top \mathbf{\Psi})_{ij}</code>.
</p>
</li>
<li> <p><code class="reqn">h_i</code> is the <code class="reqn">i^{th}</code> component of the thresholding function <code class="reqn">h</code>.
</p>
</li>
<li> <p><code class="reqn">n</code> is the sample size.
</p>
</li></ul>

<p>The thresholding operator, represented by <code class="reqn">h</code> in the <code><a href="#topic+SUREthresh">SUREthresh</a></code> function, is obtained using this <code><a href="#topic+betathresh">betathresh</a></code> function. The SURE in the transformed domain can be explicitly stated as:
</p>
<p style="text-align: center;"><code class="reqn">
\mathbf{SURE}(h) = -n \sigma^2 + \sum_{i=1}^{n(J+1)} \widetilde{F}_i^2 \left ( 1 \wedge \frac{t_i^\beta}{|\widetilde{F}_i|^\beta} \right )^2
+ 2 \sum_{i=1}^{n(J+1)} \gamma_{ij} \mathbf{1}_{[t_i,\infty)}(|\widetilde{F}_i|) \left [ 1+\frac{(\beta-1) t_i^\beta}{|\widetilde{F}_i|^\beta} \right ].
</code>
</p>

<p><code><a href="#topic+GVN">GVN</a></code> and <code><a href="#topic+HPFVN">HPFVN</a></code> provide naive noise variance estimation.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> A dataframe with calculated SURE and hatSURE values.
</p>
</li>
<li><p> Minima of SURE and hatSURE and their corresponding optimal thresholds.
</p>
</li>
<li><p> Thresholded wavelet coefficients (if <code>keepwc = TRUE</code>).
</p>
</li></ul>



<h3>Note</h3>

<p>The vector of thresholds <code>thresh</code> for evaluating the SURE can be effectively determined by ordering the absolute values of the noisy wavelet coefficients. This approach aligns with Donoho and Johnstone's trick in standard wavelet thresholding, where SURE typically reaches its minimum at one of these coefficients. For further details, see Donoho and Johnstone Section 2.3 and de Loynes et al. Section 3.3.
</p>
<p>The function intentionally omits the irreducible variance term from the SURE calculations, as it doesn't affect the minimum's location.
</p>
<p>Also, when 'keepwc = TRUE', the function provides thresholded wavelet coefficients for all evaluated threshold values, offering deeper insights into the effects of different thresholds.
</p>


<h3>References</h3>

<p>Donoho, D. L., &amp; Johnstone, I. M. (1995). Adapting to unknown smoothness via wavelet shrinkage. Journal of the american statistical association, 90(432), 1200-1224.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>
<p>Stein, C. M. (1981). Estimation of the mean of a multivariate normal distribution. The annals of Statistics, 1135-1151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SURE_MSEthresh">SURE_MSEthresh</a></code>, <code><a href="#topic+GVN">GVN</a></code>, <code><a href="#topic+HPFVN">HPFVN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example in SURE_MSEthresh
#

</code></pre>

<hr>
<h2 id='swissroll'>Swiss Roll Graph Generation</h2><span id='topic+swissroll'></span>

<h3>Description</h3>

<p>Generates points for a Swiss roll graph. The function maps points from the square <code class="reqn">[0,1]^2</code> into the Swiss roll using the specified transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swissroll(N = 500, seed = NULL, a = 1, b = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swissroll_+3A_n">N</code></td>
<td>
<p>Number of points drawn (numeric).</p>
</td></tr>
<tr><td><code id="swissroll_+3A_seed">seed</code></td>
<td>
<p>Optionally specify a RNG seed for reproducible experiments (numeric).</p>
</td></tr>
<tr><td><code id="swissroll_+3A_a">a</code>, <code id="swissroll_+3A_b">b</code></td>
<td>
<p>Shape parameters (numeric).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given points <code class="reqn">(x,y)</code> within the unit square <code class="reqn">[0,1]^2</code>, the Swiss roll transformation is achieved using:
<code class="reqn">Sx = \pi \sqrt{(b^2 - a^2) x + a^2}</code> and
<code class="reqn">Sy = \frac{\pi^2 (b^2 - a^2) y}{2}</code>.
The transformed <code class="reqn">(x,y)</code> coordinates are then projected into 3D space to produce the characteristic rolled shape.
</p>


<h3>Value</h3>

<p>N x 3 array for 3d points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjacency_mat">adjacency_mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pts &lt;- swissroll(N=500, seed=0, a=1, b=4)
plot3D::scatter3D(pts[,1], pts[,2], pts[,3], colvar=NULL, col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='synthesis'>Compute the Synthesis Operator for Transform Coefficients</h2><span id='topic+synthesis'></span>

<h3>Description</h3>

<p><code>synthesis</code> computes the graph signal synthesis from its transform coefficients using the provided frame coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthesis(coeff, tf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synthesis_+3A_coeff">coeff</code></td>
<td>
<p>Numeric vector/matrix. Transformed coefficients of the graph signal.</p>
</td></tr>
<tr><td><code id="synthesis_+3A_tf">tf</code></td>
<td>
<p>Numeric matrix. Frame coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>synthesis</code> operator uses the frame coefficients to retrieve the graph signal from its representation in the transform domain. It is the adjoint of the analysis operator <code class="reqn">T_{\mathfrak F}</code> and is defined by the linear map <code class="reqn">T_{\mathfrak F}^\ast : \mathbb R^I \rightarrow \mathbb R^V</code>. For a vector of coefficients <code class="reqn">(c_i)_{i \in I}</code>, the synthesis operation is defined as:
</p>
<p style="text-align: center;"><code class="reqn">T^\ast_{\mathfrak F}(c_i)_{i \in I}=\sum_{i \in I} c_i r_i</code>
</p>

<p>The synthesis is computed as:
</p>
<p style="text-align: center;"><code class="reqn">\code{y} = \code{coeff}^T\code{tf}</code>
</p>



<h3>Value</h3>

<p><code>y</code> Numeric vector/matrix. Synthesized graph signal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analysis">analysis</a></code>, <code><a href="#topic+tight_frame">tight_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L &lt;- laplacian_mat(grid1$sA)

# Compute the spectral decomposition of L
decomp &lt;- eigensort(L)

# Generate the tight frame coefficients using the tight_frame function
tf &lt;- tight_frame(decomp$evalues, decomp$evectors)

# Create a random graph signal.
f &lt;- rnorm(nrow(L))

# Compute the transform coefficients using the analysis operator
coef &lt;- analysis(f, tf)

# Retrieve the graph signal using the synthesis operator
f_rec &lt;- synthesis(coef, tf)

## End(Not run)
</code></pre>

<hr>
<h2 id='tight_frame'>Tight-Frame Computation</h2><span id='topic+tight_frame'></span>

<h3>Description</h3>

<p>Constructs a tight-frame wavelet on graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tight_frame(
  evalues,
  evectors,
  b = 2,
  filter_func = zetav,
  filter_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tight_frame_+3A_evalues">evalues</code></td>
<td>
<p>Numeric vector containing the eigenvalues of the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="tight_frame_+3A_evectors">evectors</code></td>
<td>
<p>Matrix of the corresponding eigenvectors of the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="tight_frame_+3A_b">b</code></td>
<td>
<p>Numeric scalar. Parameter that controls the number of scales in the wavelet decomposition.</p>
</td></tr>
<tr><td><code id="tight_frame_+3A_filter_func">filter_func</code></td>
<td>
<p>Function used to compute the filter values. By default, it uses the <code><a href="#topic+zetav">zetav</a></code> function but other frame filters can be passed.</p>
</td></tr>
<tr><td><code id="tight_frame_+3A_filter_params">filter_params</code></td>
<td>
<p>List of additional parameters required by filter_func. Default is an empty list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the tight-frame wavelet coefficients.
</p>


<h3>Note</h3>

<p><code>tight_frame</code> can be adapted for other filters by passing a different filter function to the <code>filter_func</code> parameter.
The computation of <code class="reqn">k_{\text{max}}</code> using <code class="reqn">\lambda_{\text{max}}</code> and <code class="reqn">b</code> applies primarily to the default <code>zetav</code> filter. It can be overridden by providing it in the <code>filter_params</code> list for other filters.
</p>


<h3>References</h3>

<p>Coulhon, T., Kerkyacharian, G., &amp; Petrushev, P. (2012). Heat kernel generated frames in the setting of Dirichlet spaces. Journal of Fourier Analysis and Applications, 18(5), 995-1066.
</p>
<p>Göbel, F., Blanchard, G., von Luxburg, U. (2018). Construction of tight frames on graphs and application to denoising. In Handbook of Big Data Analytics (pp. 503-522). Springer, Cham.
</p>
<p>Leonardi, N., &amp; Van De Ville, D. (2013). Tight wavelet frames on multislice graphs. IEEE Transactions on Signal Processing, 61(13), 3357-3367.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L &lt;- laplacian_mat(grid1$sA)

# Compute the spectral decomposition of L
decomp &lt;- eigensort(L)

# Generate the tight frame coefficients using the tight_frame function
tf &lt;- tight_frame(decomp$evalues, decomp$evectors)

## End(Not run)

</code></pre>

<hr>
<h2 id='zetav'>Evaluate Localized Tight-Frame Filter Functions</h2><span id='topic+zetav'></span>

<h3>Description</h3>

<p><code>zetav</code> evaluates the filters associated with a specific tight-frame construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zetav(x, k, b = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zetav_+3A_x">x</code></td>
<td>
<p>A vector representing the support on which to evaluate the filter</p>
</td></tr>
<tr><td><code id="zetav_+3A_k">k</code></td>
<td>
<p>A scalar representing the scale index.</p>
</td></tr>
<tr><td><code id="zetav_+3A_b">b</code></td>
<td>
<p>A scalar parameter that governs the number of scales (b=2 default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>zetav</code> evaluates the partition of unity functions <code class="reqn">\psi</code> following the methodology described in the references similar to the Littlewood-Paley type, based on a partition of unity, as proposed in the reference papers. This approach, inspired by frame theory, facilitates the construction of filter banks, ensuring effective spectral localization.
</p>
<p>A finite collection <code class="reqn">(\psi_j)_{j=0, \ldots, J}</code> is a finite partition of unity on the compact interval <code class="reqn">[0, \lambda_{\mathrm{max}}]</code>. It satisfies:
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j : [0,\lambda_{\mathrm{max}}] \rightarrow [0,1]~\textrm{for all}~ j \in \{1,\ldots,J\}~\textrm{and}~\forall \lambda \in [0,\lambda_{\mathrm{max}}],~\sum_{j=0}^J \psi_j(\lambda)=1.
</code>
</p>

<p>Let <code class="reqn">\omega : \mathbb R^+ \rightarrow [0,1]</code> be a function with support in [0,1]. It's defined as:
</p>
<p style="text-align: center;"><code class="reqn">
\omega(x) = \begin{cases}
1 &amp; \text{if } x \in [0,b^{-1}] \\
b \cdot \frac{x}{1 - b} + \frac{b}{b - 1} &amp; \text{if } x \in (b^{-1}, 1] \\
0 &amp; \text{if } x &gt; 1
\end{cases}
</code>
</p>

<p>For a given <code class="reqn">b &gt; 1</code>. Based on this function <code class="reqn">\omega</code>, the partition of unity functions <code class="reqn">\psi</code> are defined as:
</p>
<p style="text-align: center;"><code class="reqn">
\psi_0(x) = \omega(x)
</code>
</p>

<p>and for all <code class="reqn">j \geq 1</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j(x) = \omega(b^{-j} x) - \omega(b^{-j+1} x)
</code>
</p>

<p>where <code class="reqn">J</code> is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
J = \left \lfloor \frac{\log \lambda_{\mathrm{max}}}{\log b} \right \rfloor + 2
</code>
</p>

<p>Given this finite partition of unity <code class="reqn">(\psi_j)_{j=0, \ldots, J}</code>, the Parseval identity implies that the following set of vectors forms a tight frame:
</p>
<p style="text-align: center;"><code class="reqn">
\mathfrak F = \left \{ \sqrt{\psi_j}(\mathcal{L})\delta_i : j=0, \ldots, J, i \in V \right \}.
</code>
</p>



<h3>Value</h3>

<p>Returns a numeric vector of evaluated filter values.
</p>


<h3>References</h3>

<p>Coulhon, T., Kerkyacharian, G., &amp; Petrushev, P. (2012). Heat kernel generated frames in the setting of Dirichlet spaces. Journal of Fourier Analysis and Applications, 18(5), 995-1066.
</p>
<p>Göbel, F., Blanchard, G., von Luxburg, U. (2018). Construction of tight frames on graphs and application to denoising. In Handbook of Big Data Analytics (pp. 503-522). Springer, Cham.
</p>
<p>Leonardi, N., &amp; Van De Ville, D. (2013). Tight wavelet frames on multislice graphs. IEEE Transactions on Signal Processing, 61(13), 3357-3367.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  x &lt;- seq(0, 2, by = 0.1)
  g &lt;- zetav(x, 1, 2)
  plot(x, g, type = "l")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
