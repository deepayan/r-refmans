<!DOCTYPE html><html><head><title>Help for package forecastML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forecastML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#combine_forecasts'><p>Combine multiple horizon-specific forecast models to produce one forecast</p></a></li>
<li><a href='#create_lagged_df'><p>Create model training and forecasting datasets with lagged, grouped, dynamic, and static features</p></a></li>
<li><a href='#create_skeleton'><p>Remove the features from a lagged training dataset to reduce memory consumption</p></a></li>
<li><a href='#create_windows'><p>Create time-contiguous validation datasets for model evaluation</p></a></li>
<li><a href='#data_buoy'><p>NOAA buoy weather data</p></a></li>
<li><a href='#data_buoy_gaps'><p>NOAA buoy weather data</p></a></li>
<li><a href='#data_seatbelts'><p>Road Casualties in Great Britain 1969-84</p></a></li>
<li><a href='#fill_gaps'><p>Prepare a dataset for modeling by filling in temporal gaps in data collection</p></a></li>
<li><a href='#plot.forecast_error'><p>Plot forecast error</p></a></li>
<li><a href='#plot.forecast_model_hyper'><p>Plot hyperparameters</p></a></li>
<li><a href='#plot.forecast_results'><p>Plot an object of class forecast_results</p></a></li>
<li><a href='#plot.forecastML'><p>Plot an object of class 'forecastML'</p></a></li>
<li><a href='#plot.lagged_df'><p>Plot datasets with lagged features</p></a></li>
<li><a href='#plot.training_results'><p>Plot an object of class training_results</p></a></li>
<li><a href='#plot.validation_error'><p>Plot validation dataset forecast error</p></a></li>
<li><a href='#plot.windows'><p>Plot validation datasets</p></a></li>
<li><a href='#predict.forecast_model'><p>Predict on validation datasets or forecast</p></a></li>
<li><a href='#return_error'><p>Compute forecast error</p></a></li>
<li><a href='#return_hyper'><p>Return model hyperparameters across validation datasets</p></a></li>
<li><a href='#summary.lagged_df'><p>Return a summary of a lagged_df object</p></a></li>
<li><a href='#train_model'><p>Train a model across horizons and validation datasets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Forecasting with Machine Learning Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Nickalus Redell</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nickalus Redell &lt;nickalusredell@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The purpose of 'forecastML' is to simplify the process of multi-step-ahead forecasting with standard machine learning algorithms. 'forecastML' supports lagged, dynamic, static, and grouping features for modeling single and grouped numeric or factor/sequence time series. In addition, simple wrapper functions are used to support model-building with most R packages. This approach to forecasting is inspired by Bergmeir, Hyndman, and Koo's (2018) paper "A note on the validity of cross-validation for evaluating autoregressive time series prediction" &lt;<a href="https://doi.org/10.1016%2Fj.csda.2017.11.003">doi:10.1016/j.csda.2017.11.003</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nredell/forecastML/">https://github.com/nredell/forecastML/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>tidyr (&ge; 0.8.1), rlang (&ge; 0.4.0), magrittr (&ge; 1.5),
lubridate (&ge; 1.7.4), ggplot2 (&ge; 3.1.0), future.apply (&ge;
1.3.0), methods, purrr (&ge; 0.3.2), data.table (&ge; 1.12.6),
dtplyr (&ge; 1.0.0), tibble (&ge; 2.1.3)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Collate:</td>
<td>'fill_gaps.R' 'create_windows.R' 'create_skeleton.R'
'combine_forecasts.R' 'lagged_df.R' 'return_error.R'
'return_hyper.R' 'train_model.R' 'data_seatbelts.R'
'data_buoy.R' 'data_buoy_gaps.R' 'zzz.R'</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), dplyr (&ge; 0.8.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glmnet (&ge; 2.0.16), DT (&ge; 0.5), knitr (&ge; 1.22), rmarkdown
(&ge; 1.12.6), xgboost (&ge; 0.82.1), randomForest (&ge; 4.6.14),
testthat (&ge; 2.2.1), covr (&ge; 3.3.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-06 04:46:53 UTC; nickr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-07 15:10:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='combine_forecasts'>Combine multiple horizon-specific forecast models to produce one forecast</h2><span id='topic+combine_forecasts'></span>

<h3>Description</h3>

<p>The horizon-specific models can either be combined to (a) produce final forecasts for only those
horizons at which they were trained (i.e., shorter-horizon models override longer-horizon models
when producing final short-horizon h-step-ahead forecasts) or (b) produce final forecasts using
any combination of horizon-specific models that minimized error over the validation/training dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_forecasts(
  ...,
  type = c("horizon", "error"),
  aggregate = stats::median,
  data_error = list(NULL),
  metric = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_forecasts_+3A_...">...</code></td>
<td>
<p>One or more objects of class 'forecast_results' from running <code>predict.forecast_model()</code> on
an input forward-looking forecast dataset. These are the forecasts from the horizon-specific
direct forecasting models trained over the entire training dataset by setting <code>create_windows(..., window_length = 0)</code>.
If multiple models are passed in <code>...</code> with the same direct forecast horizon, for <code>type = 'horizon'</code>,
forecasts for the same direct forecast horizon are combined with <code>aggregate</code>; for <code>type = 'error'</code>, the model that
minimizes the error metric at the given direct forecast horizon produces the forecast.</p>
</td></tr>
<tr><td><code id="combine_forecasts_+3A_type">type</code></td>
<td>
<p>Default: 'horizon'. A character vector of length 1 that identifies the forecast combination method.</p>
</td></tr>
<tr><td><code id="combine_forecasts_+3A_aggregate">aggregate</code></td>
<td>
<p>Default <code>median</code> for <code>type = 'horizon'</code>. A function&ndash;without parentheses&ndash;that aggregates forecasts if
more than one model passed in <code>...</code> has the same direct forecast horizon and <code>type = 'horizon'].</code></p>
</td></tr>
<tr><td><code id="combine_forecasts_+3A_data_error">data_error</code></td>
<td>
<p>Optional. A list of objects of class 'validation_error' from running <code>return_error()</code>
on a training dataset. The length and order of <code>data_error</code> should match the models passed in <code>...</code>.</p>
</td></tr>
<tr><td><code id="combine_forecasts_+3A_metric">metric</code></td>
<td>
<p>Required if <code>data_error</code> is given. A length 1 character vector naming the forecast
error metric used to select the optimal model at each forecast horizon from the models passed
in '...' e.g., 'mae'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'forecastML' with final h-step-ahead forecasts.
</p>
<p><strong>Forecast combination type:</strong>
</p>

<ul>
<li> <p><code>type = 'horizon'</code>: 1 final h-step-ahead forecast is returned for each model object passed in <code>...</code>.
</p>
</li>
<li> <p><code>type = 'error'</code>: 1 final h-step-ahead forecast is returned by selecting, for each forecast horizon,
the model that minimized the chosen error metric at that horizon on the outer-loop validation data sets.
</p>
</li></ul>

<p><strong>Columns in returned 'forecastML' data.frame:</strong>
</p>

<ul>
<li> <p><code>model</code>: User-supplied model name in <code>train_model()</code>.
</p>
</li>
<li> <p><code>model_forecast_horizon</code>: The direct-forecasting time horizon that the model was trained on.
</p>
</li>
<li> <p><code>horizon</code>: Forecast horizons, 1:h, measured in dataset rows.
</p>
</li>
<li> <p><code>forecast_period</code>: The forecast period in row indices or dates. The forecast period starts at either <code>attributes(create_lagged_df())$data_stop + 1</code> for row indices or <code>attributes(create_lagged_df())$data_stop + 1 * frequency</code> for date indices.
</p>
</li>
<li> <p><code>"groups"</code>: If given, the user-supplied groups in <code>create_lagged_df()</code>.
</p>
</li>
<li> <p><code>"outcome_name"_pred</code>: The final forecasts.
</p>
</li>
<li> <p><code>"outcome_name"_pred_lower</code>: If given, the lower forecast bounds returned by the user-supplied prediction function.
</p>
</li>
<li> <p><code>"outcome_name"_pred_upper</code>: If given, the upper forecast bounds returned by the user-supplied prediction function.
</p>
</li></ul>



<h3>Methods and related functions</h3>

<p>The output of <code>combine_forecasts()</code> has the following generic S3 methods
</p>

<ul>
<li> <p><code><a href="#topic+plot.forecastML">plot</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example with "type = 'horizon'".
data("data_seatbelts", package = "forecastML")

horizons &lt;- c(1, 3, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)

windows &lt;- create_windows(data_train, window_length = 0)

model_function &lt;- function(data, my_outcome_col) {
  model &lt;- lm(DriversKilled ~ ., data = data)
  return(model)
}

model_results &lt;- train_model(data_train, windows, model_name = "LM", model_function)

data_forecast &lt;- create_lagged_df(data_seatbelts, type = "forecast", outcome_col = 1,
                                  lookback = lookback, horizon = horizons)

prediction_function &lt;- function(model, data_features) {
  x &lt;- data_features
  data_pred &lt;- data.frame("y_pred" = predict(model, newdata = x))
  return(data_pred)
}

data_forecasts &lt;- predict(model_results, prediction_function = list(prediction_function),
                          data = data_forecast)

data_combined &lt;- combine_forecasts(data_forecasts)

plot(data_combined)
</code></pre>

<hr>
<h2 id='create_lagged_df'>Create model training and forecasting datasets with lagged, grouped, dynamic, and static features</h2><span id='topic+create_lagged_df'></span>

<h3>Description</h3>

<p>Create a list of datasets with lagged, grouped, dynamic, and static features to (a) train forecasting models for
specified forecast horizons and (b) forecast into the future with a trained ML model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lagged_df(
  data,
  type = c("train", "forecast"),
  method = c("direct", "multi_output"),
  outcome_col = 1,
  horizons,
  lookback = NULL,
  lookback_control = NULL,
  dates = NULL,
  frequency = NULL,
  dynamic_features = NULL,
  groups = NULL,
  static_features = NULL,
  predict_future = NULL,
  use_future = FALSE,
  keep_rows = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_lagged_df_+3A_data">data</code></td>
<td>
<p>A data.frame with the (a) target to be forecasted and (b) features/predictors. An optional date column can be given in the
<code>dates</code> argument (required for grouped time series). Note that '<code>orecastML</code> only works with regularly spaced date/time intervals and that missing
rows&ndash;usually due to periods when no data was collected&ndash;will result in incorrect feature lags.
Use <code><a href="#topic+fill_gaps">fill_gaps</a></code> to fill in any missing rows/data prior to running this function.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_type">type</code></td>
<td>
<p>The type of dataset to return&ndash;(a) model training or (b) forecast prediction. The default is <code>train</code>.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_method">method</code></td>
<td>
<p>The type of modeling dataset to create. <code>direct</code> returns 1 data.frame for each forecast horizon and
<code>multi_output</code> returns 1 data.frame for simultaneously modeling all forecast horizons. The default is <code>direct</code>.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_outcome_col">outcome_col</code></td>
<td>
<p>The column index&ndash;an integer&ndash;of the target to be forecasted. If <code>outcome_col != 1</code>, the
outcome column will be moved to position 1 and <code>outcome_col</code> will be set to 1 internally.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_horizons">horizons</code></td>
<td>
<p>A numeric vector of one or more forecast horizons, h, measured in dataset rows.
If <code>dates</code> are given, a horizon of 1, for example, would equal 1 * <code>frequency</code> in calendar time.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_lookback">lookback</code></td>
<td>
<p>A numeric vector giving the lags&ndash;in dataset rows&ndash;for creating the lagged features. All non-grouping,
non-static, and non-dynamic features in the input dataset, <code>data</code>, are lagged by the same values. The outcome is
also lagged by default. Either <code>lookback</code> or <code>lookback_control</code> need to be specified&ndash;but not both.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_lookback_control">lookback_control</code></td>
<td>
<p>A list of numeric vectors, specifying potentially unique lags for each feature. The length
of the list should equal <code>ncol(data)</code> and be ordered the same as the columns in <code>data</code>. Lag values for any grouping,
static, or dynamic feature columns are automatically coerced to 0 and not lagged. <code>list(NULL)</code> <code>lookback_control</code> values drop columns
from the input dataset. Either <code>lookback</code> or <code>lookback_control</code> need to be specified&ndash;but not both.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_dates">dates</code></td>
<td>
<p>A vector or 1-column data.frame of dates/times with class 'Date' or 'POSIXt'. The length
of <code>dates</code> should equal <code>nrow(data)</code>. Required if <code>groups</code> are given.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_frequency">frequency</code></td>
<td>
<p>Date/time frequency. Required if <code>dates</code> are given. A string taking the same input as <code>base::seq.Date(..., by = "frequency")</code> or
<code>base::seq.POSIXt(..., by = "frequency")</code> e.g., '1 hour', '1 month', '7 days', '10 years' etc.
The highest frequency supported at present is '1 sec'.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_dynamic_features">dynamic_features</code></td>
<td>
<p>A character vector of column names that identify features that change through time but which are not lagged (e.g., weekday or year).
If <code>type = "forecast"</code> and <code>method = "direct"</code>, these features will receive <code>NA</code> values; though, they can be filled in by the user after running this function.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_groups">groups</code></td>
<td>
<p>A character vector of column names that identify the groups/hierarchies when multiple time series are present. These columns are used as model features but
are not lagged. Note that combining feature lags with grouped time series will result in <code>NA</code> values throughout the data.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_static_features">static_features</code></td>
<td>
<p>For grouped time series only. A character vector of column names that identify features that do not change through time.
These columns are not lagged. If <code>type = "forecast"</code>, these features will be filled forward using the most recent value for the group.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_predict_future">predict_future</code></td>
<td>
<p>When <code>type = "forecast"</code>, a function for predicting the future values of any dynamic features.
This function takes <code>data</code> and <code>dates</code> as positional arguments and returns a data.frame with (a) one or more rows, (b) an
&quot;index&quot; column of future dates, (c) group columns if needed, and (d) 1 or more columns with name(s) in <code>dynamic_features</code>.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_use_future">use_future</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the <code>future.apply</code> package is used for creating lagged data.frames.
<code>multisession</code> or <code>multicore</code> futures are especially useful for (a) grouped time series with many groups and
(b) high-dimensional datasets with many lags per feature. Run <code>future::plan(future::multiprocess)</code> prior to this
function to set up multissession or multicore parallel dataset creation.</p>
</td></tr>
<tr><td><code id="create_lagged_df_+3A_keep_rows">keep_rows</code></td>
<td>
<p>Boolean. For non-grouped time series, keep the <code>1:max(lookback)</code> rows at the beginning of the time series. These rows will
contain missing values for lagged features that &quot;look back&quot; before the start of the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'lagged_df' or 'grouped_lagged_df': A list of data.frames with new columns for the lagged/non-lagged features.
For <code>method = "direct"</code>, the length of the returned list is equal to the number of forecast horizons and is in the order of
horizons supplied to the <code>horizons</code> argument. Horizon-specific datasets can be accessed with
<code>my_lagged_df$horizon_h</code> where 'h' gives the forecast horizon.
For <code>method = "multi_output"</code>, the length of the returned list is 1. Horizon-specific datasets can be accessed with
<code>my_lagged_df$horizon_1_3_5</code> where &quot;1_3_5&quot; represents the forecast horizons passed in <code>horizons</code>.
</p>
<p>The contents of the returned data.frames are as follows:
</p>

<dl>
<dt><strong>type = 'train', non-grouped:</strong></dt><dd><p>A data.frame with the outcome and lagged/dynamic features.</p>
</dd>
<dt><strong>type = 'train', grouped:</strong></dt><dd><p>A data.frame with the outcome and unlagged grouping columns followed by lagged, dynamic, and static features.</p>
</dd>
<dt><strong>type = 'forecast', non-grouped:</strong></dt><dd><p>(1) An 'index' column giving the row index or date of the
forecast periods (e.g., a 100 row non-date-based training dataset would start with an index of 101). (2) A 'horizon' column
that indicates the forecast period from <code>1:max(horizons)</code>. (3) Lagged features identical to the
'train', non-grouped dataset.</p>
</dd>
<dt><strong>type = 'forecast', grouped:</strong></dt><dd><p>(1) An 'index' column giving the date of the
forecast periods. The first forecast date for each group is the maximum date from the <code>dates</code> argument
+ 1 * <code>frequency</code> which is the user-supplied date/time frequency.(2) A 'horizon' column that indicates
the forecast period from <code>1:max(horizons)</code>. (3) Lagged, static, and dynamic features identical to the 'train', grouped dataset.</p>
</dd>
</dl>



<h3>Attributes</h3>


<ul>
<li> <p><code>names</code>: The horizon-specific datasets that can be accessed with <code>my_lagged_df$horizon_h</code>.
</p>
</li>
<li> <p><code>type</code>: Training, <code>train</code>, or forecasting, <code>forecast</code>, dataset(s).
</p>
</li>
<li> <p><code>method</code>: <code>direct</code> or <code>multi_output</code>.
</p>
</li>
<li> <p><code>horizons</code>: Forecast horizons measured in dataset rows.
</p>
</li>
<li> <p><code>outcome_col</code>: The column index of the target being forecasted.
</p>
</li>
<li> <p><code>outcome_cols</code>: If <code>method = multi_output</code>, the column indices of the multiple outputs in the transformed dataset.
</p>
</li>
<li> <p><code>outcome_name</code>: The name of the target being forecasted.
</p>
</li>
<li> <p><code>outcome_names</code>: If <code>method = multi_output</code>, the column names of the multiple outputs in the transformed dataset.
The names take the form &quot;outcome_name_h&quot; where 'h' is a horizon passed in <code>horizons</code>.
</p>
</li>
<li> <p><code>predictor_names</code>: The predictor or feature names from the input dataset.
</p>
</li>
<li> <p><code>row_indices</code>: The <code>row.names()</code> of the output dataset. For non-grouped datasets, the first
<code>lookback</code> + 1 rows are removed from the beginning of the dataset to remove <code>NA</code> values in the lagged features.
</p>
</li>
<li> <p><code>date_indices</code>: If <code>dates</code> are given, the vector of <code>dates</code>.
</p>
</li>
<li> <p><code>frequency</code>: If <code>dates</code> are given, the date/time frequency.
</p>
</li>
<li> <p><code>data_start</code>: <code>min(row_indices)</code> or <code>min(date_indices)</code>.
</p>
</li>
<li> <p><code>data_stop</code>: <code>max(row_indices)</code> or <code>max(date_indices)</code>.
</p>
</li>
<li> <p><code>groups</code>: If <code>groups</code> are given, a vector of group names.
</p>
</li>
<li> <p><code>class</code>: grouped_lagged_df, lagged_df, list
</p>
</li></ul>



<h3>Methods and related functions</h3>

<p>The output of <code>create_lagged_df()</code> is passed into
</p>

<ul>
<li> <p><code><a href="#topic+create_windows">create_windows</a></code>
</p>
</li></ul>

<p>and has the following generic S3 methods
</p>

<ul>
<li> <p><code><a href="#topic+summary.lagged_df">summary</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.lagged_df">plot</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")
#------------------------------------------------------------------------------
# Example 1 - Training data for 2 horizon-specific models w/ common lags per predictor.
horizons &lt;- c(1, 12)
lookback &lt;- 1:15

data &lt;- data_seatbelts

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               horizons = horizons, lookback = lookback)
head(data_train[[length(horizons)]])

# Example 1 - Forecasting dataset
# The last 'nrow(data_seatbelts) - horizon' rows are automatically used from data_seatbelts.
data_forecast &lt;- create_lagged_df(data_seatbelts, type = "forecast", outcome_col = 1,
                                  horizons = horizons, lookback = lookback)
head(data_forecast[[length(horizons)]])

#------------------------------------------------------------------------------
# Example 2 - Training data for one 3-month horizon model w/ unique lags per predictor.
horizons &lt;- 3
lookback &lt;- list(c(3, 6, 9, 12), c(4:12), c(6:15), c(8))

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               horizons = horizons, lookback_control = lookback)
head(data_train[[length(horizons)]])
</code></pre>

<hr>
<h2 id='create_skeleton'>Remove the features from a lagged training dataset to reduce memory consumption</h2><span id='topic+create_skeleton'></span>

<h3>Description</h3>

<p><code>create_skeleton()</code> strips the feature data from a <code>create_lagged_df()</code> object
but keeps the outcome column(s), any grouping columns, and meta-data which allows the resulting
<code>lagged_df</code> to be used downstream in the <code>forecastML</code> pipeline. The main benefit is
that the custom modeling function passed in <code>train_model()</code> can read data directly from the
disk or a database when the dataset is too large to fit into memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_skeleton(lagged_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_skeleton_+3A_lagged_df">lagged_df</code></td>
<td>
<p>An object of class 'lagged_df' from <code>create_lagged_df(..., type = 'train')</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'lagged_df' or 'grouped_lagged_df': A list of data.frames with the
outcome column(s) and any grouping columns but with all other features removed.
A special attribute <code>skeleton = TRUE</code> is added.
</p>


<h3>Methods and related functions</h3>

<p>The output of <code>create_skeleton</code> can be passed into
</p>

<ul>
<li> <p><code><a href="#topic+create_windows">create_windows</a></code>
</p>
</li></ul>


<hr>
<h2 id='create_windows'>Create time-contiguous validation datasets for model evaluation</h2><span id='topic+create_windows'></span>

<h3>Description</h3>

<p>Flexibly create blocks of time-contiguous validation datasets to assess the forecast accuracy
of trained models at various times in the past. These validation datasets are similar to
the outer loop of a nested cross-validation model training setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_windows(
  lagged_df,
  window_length = 12L,
  window_start = NULL,
  window_stop = NULL,
  skip = 0,
  include_partial_window = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_windows_+3A_lagged_df">lagged_df</code></td>
<td>
<p>An object of class 'lagged_df' or 'grouped_lagged_df' from <code><a href="#topic+create_lagged_df">create_lagged_df</a></code>.</p>
</td></tr>
<tr><td><code id="create_windows_+3A_window_length">window_length</code></td>
<td>
<p>An integer that defines the length of the contiguous validation dataset in dataset rows/dates.
If dates were given in <code>create_lagged_df()</code>, the validation window is 'window_length' * 'date frequency' in calendar time.
Setting <code>window_length = 0</code> trains the model on (a) the entire dataset or (b) between a single <code>window_start</code> and
<code>window_stop</code> value. Specifying multiple <code>window_start</code> and <code>window_stop</code> values with vectors of
length &gt; 1 overrides <code>window_length</code>.</p>
</td></tr>
<tr><td><code id="create_windows_+3A_window_start">window_start</code></td>
<td>
<p>Optional. A row index or date identifying the row/date to start creating contiguous validation datasets. A
vector of start rows/dates can be supplied for greater control. The length and order of <code>window_start</code> should match <code>window_stop</code>.
If <code>length(window_start) &gt; 1</code>, <code>window_length</code>, <code>skip</code>, and <code>include_partial_window</code> are ignored.</p>
</td></tr>
<tr><td><code id="create_windows_+3A_window_stop">window_stop</code></td>
<td>
<p>Optional. An index or date identifying the row/date to stop creating contiguous validation datasets. A
vector of start rows/dates can be supplied for greater control. The length and order of <code>window_stop</code> should match <code>window_start</code>.
If <code>length(window_stop) &gt; 1</code>, <code>window_length</code>, <code>skip</code>, and <code>include_partial_window</code> are ignored.</p>
</td></tr>
<tr><td><code id="create_windows_+3A_skip">skip</code></td>
<td>
<p>An integer giving a fixed number of dataset rows/dates to skip between validation datasets. If dates were given
in <code>create_lagged_df()</code>, the time between validation windows is <code>skip</code> * 'date frequency'.</p>
</td></tr>
<tr><td><code id="create_windows_+3A_include_partial_window">include_partial_window</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, keep validation datasets that are shorter than <code>window_length</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'windows': A data.frame giving the indices for the validation datasets.
</p>


<h3>Methods and related functions</h3>

<p>The output of <code>create_windows()</code> is passed into
</p>

<ul>
<li> <p><code><a href="#topic+train_model">train_model</a></code>
</p>
</li></ul>

<p>and has the following generic S3 methods
</p>

<ul>
<li> <p><code><a href="#topic+plot.windows">plot</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")

# Example - Training data for 2 horizon-specific models w/ common lags per feature.
horizons &lt;- c(1, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)

# All historical window lengths of 12 plus any partial windows at the end of the dataset.
windows &lt;- create_windows(data_train, window_length = 12)
windows

# Two custom validation windows with different lengths.
windows &lt;- create_windows(data_train, window_start = c(20, 80), window_stop = c(30, 100))
windows
</code></pre>

<hr>
<h2 id='data_buoy'>NOAA buoy weather data</h2><span id='topic+data_buoy'></span>

<h3>Description</h3>

<p>A dataset containing daily average sensor measurements of several environmental
conditions collected by 14 buoys in Lake Michigan from 2012 through 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_buoy
</code></pre>


<h3>Format</h3>

<p>A data.frame with 30,821 rows and 9 columns:
</p>

<dl>
<dt>date</dt><dd><p>date</p>
</dd>
<dt>wind_spd</dt><dd><p>average daily wind speed in kts</p>
</dd>
<dt>buoy_id</dt><dd><p>the station ID for each buoy</p>
</dd>
<dt>lat</dt><dd><p>latitude</p>
</dd>
<dt>lon</dt><dd><p>longitude</p>
</dd>
<dt>day</dt><dd><p>day of year</p>
</dd>
<dt>year</dt><dd><p>calendar year</p>
</dd>
<dt>air_temperature</dt><dd><p>air temperature in degrees Fahrenheit</p>
</dd>
<dt>sea_surface_temperature</dt><dd><p>water temperature in degrees Fahrenheit</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.ndbc.noaa.gov/">http://www.ndbc.noaa.gov/</a>
</p>

<hr>
<h2 id='data_buoy_gaps'>NOAA buoy weather data</h2><span id='topic+data_buoy_gaps'></span>

<h3>Description</h3>

<p>A dataset containing daily average sensor measurements of several environmental
conditions collected by 14 buoys in Lake Michigan from 2012 through 2018. This
dataset is identical to the <a href="#topic+data_buoy">data_buoy</a> dataset except that there are gaps in
the daily sensor data. Running <code>fill_gaps()</code> on <code>data_buoy_gaps</code> will
produce <code>data_buoy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_buoy_gaps
</code></pre>


<h3>Format</h3>

<p>A data.frame with 23,646 rows and 9 columns:
</p>

<dl>
<dt>date</dt><dd><p>date</p>
</dd>
<dt>wind_spd</dt><dd><p>average daily wind speed in kts</p>
</dd>
<dt>buoy_id</dt><dd><p>the station ID for each buoy</p>
</dd>
<dt>lat</dt><dd><p>latitude</p>
</dd>
<dt>lon</dt><dd><p>longitude</p>
</dd>
<dt>day</dt><dd><p>day of year</p>
</dd>
<dt>year</dt><dd><p>calendar year</p>
</dd>
<dt>air_temperature</dt><dd><p>air temperature in degrees Fahrenheit</p>
</dd>
<dt>sea_surface_temperature</dt><dd><p>water temperature in degrees Fahrenheit</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.ndbc.noaa.gov/">http://www.ndbc.noaa.gov/</a>
</p>

<hr>
<h2 id='data_seatbelts'>Road Casualties in Great Britain 1969-84</h2><span id='topic+data_seatbelts'></span>

<h3>Description</h3>

<p>This is the <code>Seatbelts</code> dataset from the <code>datasets</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_seatbelts
</code></pre>


<h3>Format</h3>

<p>A data.frame with 192 rows and 8 columns
</p>


<h3>Source</h3>

<p>Harvey, A.C. (1989). Forecasting, Structural Time Series Models and the Kalman Filter. Cambridge University Press, pp. 519â€“523.
</p>
<p>Durbin, J. and Koopman, S. J. (2001). Time Series Analysis by State Space Methods. Oxford University Press.
</p>
<p><a href="https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/UKDriverDeaths.html">https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/UKDriverDeaths.html</a>
</p>

<hr>
<h2 id='fill_gaps'>Prepare a dataset for modeling by filling in temporal gaps in data collection</h2><span id='topic+fill_gaps'></span>

<h3>Description</h3>

<p>In order to create a modeling dataset with feature lags that are temporally correct, the entry
function in <code>forecastML</code>, <code><a href="#topic+create_lagged_df">create_lagged_df</a></code>, needs evenly-spaced time series with no
gaps in data collection. <code>fill_gaps()</code> can help here.
This function takes a <code>data.frame</code> with (a) dates, (b) the outcome being forecasted, and, optionally,
(c) dynamic features that change through time, (d) group columns for multiple time series modeling,
and (e) static or non-dynamic features for multiple time series modeling and returns a <code>data.frame</code>
with rows evenly spaced in time. Specifically, this function adds rows to the input dataset
while filling in (a) dates, (b) grouping information, and (c) static features. The (a) outcome and (b)
dynamic features will be <code>NA</code> for any missing time periods; these <code>NA</code> values can be left
as-is, user-imputed, or removed from modeling in the user-supplied modeling wrapper function for <code><a href="#topic+train_model">train_model</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_gaps(data, date_col = 1, frequency, groups = NULL, static_features = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_gaps_+3A_data">data</code></td>
<td>
<p>A data.frame or object coercible to a data.frame with, minimally, dates and the outcome being forecasted.</p>
</td></tr>
<tr><td><code id="fill_gaps_+3A_date_col">date_col</code></td>
<td>
<p>The column index&ndash;an integer&ndash;of the date index. This column should have class 'Date' or 'POSIXt'.</p>
</td></tr>
<tr><td><code id="fill_gaps_+3A_frequency">frequency</code></td>
<td>
<p>Date/time frequency. A string taking the same input as <code>base::seq.Date(..., by = "frequency")</code>
or <code>base::seq.POSIXt..., by = "frequency")</code> e.g., '1 hour', '1 month', '7 days', '10 years' etc.
The highest frequency supported at present is '1 sec'.</p>
</td></tr>
<tr><td><code id="fill_gaps_+3A_groups">groups</code></td>
<td>
<p>Optional. A character vector of column names that identify the unique time series (i.e., groups/hierarchies)
when multiple time series are present.</p>
</td></tr>
<tr><td><code id="fill_gaps_+3A_static_features">static_features</code></td>
<td>
<p>Optional. For grouped time series only. A character vector of column names that identify features that do not change through time.
These columns are expected to be used as model features but are not lagged (e.g., a ZIP code column). The most recent values for each
static feature for each group are used to fill in the resulting missing data in static features when new rows are
added to the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'data.frame': The returned data.frame has the same number of columns and column order but
with additional rows to account for gaps in data collection. For grouped data, any new rows added to the returned data.frame will appear
between the minimum&ndash;or oldest&ndash;date for that group and the maximum&ndash;or most recent&ndash;date across all groups. If the user-supplied
forecasting algorithm(s) cannot handle missing outcome values or missing dynamic features, these should either be
imputed prior to <code>create_lagged_df()</code> or filtered out in the user-supplied modeling function for <code><a href="#topic+train_model">train_model</a></code>.
</p>


<h3>Methods and related functions</h3>

<p>The output of <code>fill_gaps()</code> is passed into
</p>

<ul>
<li> <p><code><a href="#topic+create_lagged_df">create_lagged_df</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># NOAA buoy dataset with gaps in data collection
data("data_buoy_gaps", package = "forecastML")

data_buoy_no_gaps &lt;- fill_gaps(data_buoy_gaps, date_col = 1, frequency = '1 day',
                               groups = 'buoy_id', static_features = c('lat', 'lon'))

# The returned data.frame has the same number of columns but the time-series
# are now evenly spaced at 1 day apart. Additionally, the unchanging grouping
# columns and static features columns have been filled in for the newly created dataset rows.
dim(data_buoy_gaps)
dim(data_buoy_no_gaps)

# Running create_lagged_df() is the next step in the forecastML forecasting
# process. If there are long gaps in data collection, like in this buoy dataset,
# and the user-supplied modeling algorithm cannot handle missing outcomes data,
# the best option is to filter these rows out in the user-supplied modeling function
# for train_model()
</code></pre>

<hr>
<h2 id='plot.forecast_error'>Plot forecast error</h2><span id='topic+plot.forecast_error'></span>

<h3>Description</h3>

<p>Plot forecast error at various levels of aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast_error'
plot(
  x,
  type = c("global"),
  metric = NULL,
  facet = NULL,
  models = NULL,
  horizons = NULL,
  windows = NULL,
  group_filter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.forecast_error_+3A_x">x</code></td>
<td>
<p>An object of class 'forecast_error' from <code>return_error()</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_error_+3A_type">type</code></td>
<td>
<p>Select plot type; <code>type = "global"</code> is the default plot.</p>
</td></tr>
<tr><td><code id="plot.forecast_error_+3A_metric">metric</code></td>
<td>
<p>Select error metric to plot (e.g., &quot;mae&quot;); <code>attributes(x)$error_metrics[1]</code> is the default metric.</p>
</td></tr>
<tr><td><code id="plot.forecast_error_+3A_facet">facet</code></td>
<td>
<p>Optional. A formula with any combination of <code>horizon</code>, <code>model</code>, or <code>group</code> (for grouped time series).
passed to <code>ggplot2::facet_grid()</code> internally (e.g., <code>horizon ~ model</code>, <code>horizon + model ~ .</code>, <code>~ horizon + group</code>).
Can be <code>NULL</code>. The default faceting is set internally depending on the plot <code>type</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_error_+3A_models">models</code></td>
<td>
<p>Optional. A vector of user-defined model names from <code>train_model()</code> to filter results.</p>
</td></tr>
<tr><td><code id="plot.forecast_error_+3A_horizons">horizons</code></td>
<td>
<p>Optional. A numeric vector to filter results by horizon.</p>
</td></tr>
<tr><td><code id="plot.forecast_error_+3A_windows">windows</code></td>
<td>
<p>Optional. A numeric vector to filter results by validation window number.</p>
</td></tr>
<tr><td><code id="plot.forecast_error_+3A_group_filter">group_filter</code></td>
<td>
<p>A string for filtering plot results for grouped time series (e.g., <code>"group_col_1 == 'A'"</code>).</p>
</td></tr>
<tr><td><code id="plot.forecast_error_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Forecast error plots of class 'ggplot'.
</p>

<hr>
<h2 id='plot.forecast_model_hyper'>Plot hyperparameters</h2><span id='topic+plot.forecast_model_hyper'></span>

<h3>Description</h3>

<p>Plot hyperparameter stability and relationship with error metrics across validation datasets and horizons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast_model_hyper'
plot(
  x,
  data_results,
  data_error,
  type = c("stability", "error"),
  horizons = NULL,
  windows = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.forecast_model_hyper_+3A_x">x</code></td>
<td>
<p>An object of class 'forecast_model_hyper' from <code>return_hyper()</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_model_hyper_+3A_data_results">data_results</code></td>
<td>
<p>An object of class 'training_results' from
<code>predict.forecast_model()</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_model_hyper_+3A_data_error">data_error</code></td>
<td>
<p>An object of class 'validation_error' from
<code>return_error()</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_model_hyper_+3A_type">type</code></td>
<td>
<p>Select plot type; 'stability' is the default.</p>
</td></tr>
<tr><td><code id="plot.forecast_model_hyper_+3A_horizons">horizons</code></td>
<td>
<p>Optional. A numeric vector to filter results by horizon.</p>
</td></tr>
<tr><td><code id="plot.forecast_model_hyper_+3A_windows">windows</code></td>
<td>
<p>Optional. A numeric vector to filter results by validation window number.</p>
</td></tr>
<tr><td><code id="plot.forecast_model_hyper_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hyper-parameter plots of class 'ggplot'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")

# Example - Training data for 2 horizon-specific models w/ common lags per predictor.
horizons &lt;- c(1, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)

# One custom validation window at the end of the dataset.
windows &lt;- create_windows(data_train, window_start = 181, window_stop = 192)

# User-define model - LASSO
# A user-defined wrapper function for model training that takes the following
# arguments: (1) a horizon-specific data.frame made with create_lagged_df(..., type = "train")
# (e.g., my_lagged_df$horizon_h) and, optionally, (2) any number of additional named arguments
# which are passed as '...' in train_model().
library(glmnet)
model_function &lt;- function(data, my_outcome_col) {

  x &lt;- data[, -(my_outcome_col), drop = FALSE]
  y &lt;- data[, my_outcome_col, drop = FALSE]
  x &lt;- as.matrix(x, ncol = ncol(x))
  y &lt;- as.matrix(y, ncol = ncol(y))

  model &lt;- glmnet::cv.glmnet(x, y, nfolds = 3)
  return(model)
}

# my_outcome_col = 1 is passed in ... but could have been defined in model_function().
model_results &lt;- train_model(data_train, windows, model_name = "LASSO", model_function,
                             my_outcome_col = 1)

# User-defined prediction function - LASSO
# The predict() wrapper takes two positional arguments. First,
# the returned model from the user-defined modeling function (model_function() above).
# Second, a data.frame of predictors--identical to the datasets returned from
# create_lagged_df(..., type = "train"). The function can return a 1- or 3-column data.frame
# with either (a) point forecasts or (b) point forecasts plus lower and upper forecast
# bounds (column order and column names do not matter).
prediction_function &lt;- function(model, data_features) {

  x &lt;- as.matrix(data_features, ncol = ncol(data_features))

  data_pred &lt;- data.frame("y_pred" = predict(model, x, s = "lambda.min"))
  return(data_pred)
}

# Predict on the validation datasets.
data_valid &lt;- predict(model_results, prediction_function = list(prediction_function),
                      data = data_train)

# User-defined hyperparameter function - LASSO
# The hyperparameter function should take one positional argument--the returned model
# from the user-defined modeling function (model_function() above). It should
# return a 1-row data.frame of the optimal hyperparameters.
hyper_function &lt;- function(model) {

  lambda_min &lt;- model$lambda.min
  lambda_1se &lt;- model$lambda.1se

  data_hyper &lt;- data.frame("lambda_min" = lambda_min, "lambda_1se" = lambda_1se)
  return(data_hyper)
}

data_error &lt;- return_error(data_valid)

data_hyper &lt;- return_hyper(model_results, hyper_function)

plot(data_hyper, data_valid, data_error, type = "stability", horizons = c(1, 12))
</code></pre>

<hr>
<h2 id='plot.forecast_results'>Plot an object of class forecast_results</h2><span id='topic+plot.forecast_results'></span>

<h3>Description</h3>

<p>A forecast plot for each horizon for each model in <code>predict.forecast_model()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast_results'
plot(
  x,
  data_actual = NULL,
  actual_indices = NULL,
  facet = horizon ~ model,
  models = NULL,
  horizons = NULL,
  windows = NULL,
  group_filter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.forecast_results_+3A_x">x</code></td>
<td>
<p>An object of class 'forecast_results' from <code>predict.forecast_model()</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_results_+3A_data_actual">data_actual</code></td>
<td>
<p>A data.frame containing the target/outcome name and any grouping columns.
The data can be historical actuals and/or holdout/test data.</p>
</td></tr>
<tr><td><code id="plot.forecast_results_+3A_actual_indices">actual_indices</code></td>
<td>
<p>Required if <code>data_actual</code> is given. A vector or 1-column data.frame
of numeric row indices or dates (class 'Date' or 'POSIXt') with length <code>nrow(data_actual)</code>.
The data can be historical actuals and/or holdout/test data.</p>
</td></tr>
<tr><td><code id="plot.forecast_results_+3A_facet">facet</code></td>
<td>
<p>Optional. For numeric outcomes, a formula with any combination of <code>horizon</code>, <code>model</code>, or <code>group</code> (for grouped time series)
passed to <code>ggplot2::facet_grid()</code> internally (e.g., <code>horizon ~ model</code>, <code>horizon + model ~ .</code>, <code>~ horizon + group</code>).
Can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_results_+3A_models">models</code></td>
<td>
<p>Optional. Filter results by user-defined model name from <code>train_model()</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_results_+3A_horizons">horizons</code></td>
<td>
<p>Optional. Filter results by horizon.</p>
</td></tr>
<tr><td><code id="plot.forecast_results_+3A_windows">windows</code></td>
<td>
<p>Optional. Filter results by validation window number.</p>
</td></tr>
<tr><td><code id="plot.forecast_results_+3A_group_filter">group_filter</code></td>
<td>
<p>Optional. A string for filtering plot results for grouped time-series (e.g., <code>"group_col_1 == 'A'"</code>);
passed to <code>dplyr::filter()</code> internally.</p>
</td></tr>
<tr><td><code id="plot.forecast_results_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Forecast plot of class 'ggplot'.
</p>

<hr>
<h2 id='plot.forecastML'>Plot an object of class 'forecastML'</h2><span id='topic+plot.forecastML'></span>

<h3>Description</h3>

<p>A forecast plot of h-step-ahead forecasts produced from multiple horizon-specific forecast models
using <code>combine_forecasts()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecastML'
plot(
  x,
  data_actual = NULL,
  actual_indices = NULL,
  facet = ~model,
  models = NULL,
  group_filter = NULL,
  drop_facet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.forecastML_+3A_x">x</code></td>
<td>
<p>An object of class 'forecastML' from <code>combine_forecasts()</code>.</p>
</td></tr>
<tr><td><code id="plot.forecastML_+3A_data_actual">data_actual</code></td>
<td>
<p>A data.frame containing the target/outcome name and any grouping columns.
The data can be historical actuals and/or holdout/test data.</p>
</td></tr>
<tr><td><code id="plot.forecastML_+3A_actual_indices">actual_indices</code></td>
<td>
<p>Required if <code>data_actual</code> is given. A vector or 1-column data.frame
of numeric row indices or dates (class 'Date' or 'POSIXt') with length <code>nrow(data_actual)</code>.
The data can be historical actuals and/or holdout/test data.</p>
</td></tr>
<tr><td><code id="plot.forecastML_+3A_facet">facet</code></td>
<td>
<p>Optional. A formula with any combination of <code>model</code>, or <code>group</code> (for grouped time series)
passed to <code>ggplot2::facet_grid()</code> internally (e.g., <code>~ model</code>, <code>model ~ .</code>, <code>~ model + group</code>).</p>
</td></tr>
<tr><td><code id="plot.forecastML_+3A_models">models</code></td>
<td>
<p>Optional. Filter results by user-defined model name from <code>train_model()</code>.</p>
</td></tr>
<tr><td><code id="plot.forecastML_+3A_group_filter">group_filter</code></td>
<td>
<p>Optional. A string for filtering plot results for grouped time-series (e.g., <code>"group_col_1 == 'A'"</code>);
passed to <code>dplyr::filter()</code> internally.</p>
</td></tr>
<tr><td><code id="plot.forecastML_+3A_drop_facet">drop_facet</code></td>
<td>
<p>Optional. Boolean. If actuals are given when forecasting factors, the plot facet with 'actual' data can be dropped.</p>
</td></tr>
<tr><td><code id="plot.forecastML_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Forecast plot of class 'ggplot'.
</p>

<hr>
<h2 id='plot.lagged_df'>Plot datasets with lagged features</h2><span id='topic+plot.lagged_df'></span>

<h3>Description</h3>

<p>Plot datasets with lagged features to view ther direct forecasting setup across horizons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lagged_df'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lagged_df_+3A_x">x</code></td>
<td>
<p>An object of class 'lagged_df' from <code>create_lagged_df()</code>.</p>
</td></tr>
<tr><td><code id="plot.lagged_df_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single plot of class 'ggplot' if <code>lookback</code> was specified in <code>create_lagged_df()</code>;
a list of plots, one per feature, of class 'ggplot' if <code>lookback_control</code> was specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")
#------------------------------------------------------------------------------
# Example 1 - Training data for 3 horizon-specific models w/ common lags per predictor.
horizons &lt;- c(1, 6, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)
plot(data_train)
#------------------------------------------------------------------------------
# Example 2 - Training data for one 3-month horizon model w/ unique lags per predictor.
horizons &lt;- 3
lookback &lt;- list(c(3, 6, 9, 12), c(4:12), c(6:15), c(8))

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback_control = lookback, horizon = horizons)
plot(data_train)
</code></pre>

<hr>
<h2 id='plot.training_results'>Plot an object of class training_results</h2><span id='topic+plot.training_results'></span>

<h3>Description</h3>

<p>Several diagnostic plots can be returned to assess the quality of the forecasts
based on predictions on the validation datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'training_results'
plot(
  x,
  type = c("prediction", "residual", "forecast_stability"),
  facet = horizon ~ model,
  models = NULL,
  horizons = NULL,
  windows = NULL,
  valid_indices = NULL,
  group_filter = NULL,
  keep_missing = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.training_results_+3A_x">x</code></td>
<td>
<p>An object of class 'training_results' from <code>predict.forecast_model()</code>.</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_type">type</code></td>
<td>
<p>Plot type. The default plot is &quot;prediction&quot; for validation dataset predictions.</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_facet">facet</code></td>
<td>
<p>Optional. For numeric outcomes, a formula with any combination of <code>horizon</code>, <code>model</code>, or <code>group</code> (for grouped time series)
passed to <code>ggplot2::facet_grid()</code> internally (e.g., <code>horizon ~ model</code>, <code>horizon + model ~ .</code>, <code>~ horizon + group</code>).</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_models">models</code></td>
<td>
<p>Optional. Filter results by user-defined model name from <code>train_model()</code>.</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_horizons">horizons</code></td>
<td>
<p>Optional. A numeric vector of model forecast horizons to filter results by horizon-specific model.</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_windows">windows</code></td>
<td>
<p>Optional. A numeric vector of window numbers to filter results.</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_valid_indices">valid_indices</code></td>
<td>
<p>Optional. A numeric or date vector to filter results by validation row indices or dates.</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_group_filter">group_filter</code></td>
<td>
<p>Optional. A string for filtering plot results for grouped time series
(e.g., <code>"group_col_1 == 'A'"</code>). The results are passed to <code>dplyr::filter()</code> internally.</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_keep_missing">keep_missing</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, predictions are plotted for indices/dates where the outcome is missing.</p>
</td></tr>
<tr><td><code id="plot.training_results_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Diagnostic plots of class 'ggplot'.
</p>

<hr>
<h2 id='plot.validation_error'>Plot validation dataset forecast error</h2><span id='topic+plot.validation_error'></span>

<h3>Description</h3>

<p>Plot forecast error at various levels of aggregation across validation datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'validation_error'
plot(
  x,
  type = c("window", "horizon", "global"),
  metric = NULL,
  facet = NULL,
  models = NULL,
  horizons = NULL,
  windows = NULL,
  group_filter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.validation_error_+3A_x">x</code></td>
<td>
<p>An object of class 'validation_error' from <code>return_error()</code>.</p>
</td></tr>
<tr><td><code id="plot.validation_error_+3A_type">type</code></td>
<td>
<p>Select plot type; <code>type = "window"</code> is the default plot.</p>
</td></tr>
<tr><td><code id="plot.validation_error_+3A_metric">metric</code></td>
<td>
<p>Select error metric to plot (e.g., &quot;mae&quot;); <code>attributes(x)$error_metrics[1]</code> is the default metric.</p>
</td></tr>
<tr><td><code id="plot.validation_error_+3A_facet">facet</code></td>
<td>
<p>Optional. A formula with any combination of <code>horizon</code>, <code>model</code>, or <code>group</code> (for grouped time series).
passed to <code>ggplot2::facet_grid()</code> internally (e.g., <code>horizon ~ model</code>, <code>horizon + model ~ .</code>, <code>~ horizon + group</code>).
Can be <code>NULL</code>. The default faceting is set internally depending on the plot <code>type</code>.</p>
</td></tr>
<tr><td><code id="plot.validation_error_+3A_models">models</code></td>
<td>
<p>Optional. A vector of user-defined model names from <code>train_model()</code> to filter results.</p>
</td></tr>
<tr><td><code id="plot.validation_error_+3A_horizons">horizons</code></td>
<td>
<p>Optional. A numeric vector to filter results by horizon.</p>
</td></tr>
<tr><td><code id="plot.validation_error_+3A_windows">windows</code></td>
<td>
<p>Optional. A numeric vector to filter results by validation window number.</p>
</td></tr>
<tr><td><code id="plot.validation_error_+3A_group_filter">group_filter</code></td>
<td>
<p>A string for filtering plot results for grouped time series (e.g., <code>"group_col_1 == 'A'"</code>).</p>
</td></tr>
<tr><td><code id="plot.validation_error_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Forecast error plots of class 'ggplot'.
</p>

<hr>
<h2 id='plot.windows'>Plot validation datasets</h2><span id='topic+plot.windows'></span>

<h3>Description</h3>

<p>Plot validation datasets across time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'windows'
plot(x, lagged_df, show_labels = TRUE, group_filter = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.windows_+3A_x">x</code></td>
<td>
<p>An object of class 'windows' from <code>create_windows()</code>.</p>
</td></tr>
<tr><td><code id="plot.windows_+3A_lagged_df">lagged_df</code></td>
<td>
<p>An object of class 'lagged_df' from <code>create_lagged_df()</code>.</p>
</td></tr>
<tr><td><code id="plot.windows_+3A_show_labels">show_labels</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, show validation dataset IDs on the plot.</p>
</td></tr>
<tr><td><code id="plot.windows_+3A_group_filter">group_filter</code></td>
<td>
<p>Optional. A string for filtering plot results for grouped time series (e.g., <code>"group_col_1 == 'A'"</code>).
This string is passed to <code>dplyr::filter()</code> internally.</p>
</td></tr>
<tr><td><code id="plot.windows_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the outer-loop nested cross-validation windows of class 'ggplot'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")

# Example - Training data for 3 horizon-specific models w/ common lags per predictor.
horizons &lt;- c(1, 6, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)

# All historical window lengths of 12 plus any partial windows at the end of the dataset.
windows &lt;- create_windows(data_train, window_length = 12)
plot(windows, data_train)

# Two custom validation windows with different lengths.
windows &lt;- create_windows(data_train, window_start = c(20, 80), window_stop = c(30, 100))
plot(windows, data_train)
</code></pre>

<hr>
<h2 id='predict.forecast_model'>Predict on validation datasets or forecast</h2><span id='topic+predict.forecast_model'></span>

<h3>Description</h3>

<p>Predict with a 'forecast_model' object from <code>train_model()</code>. If <code>data = create_lagged_df(..., type = "train")</code>,
predictions are returned for the outer-loop nested cross-validation datasets.
If <code>data</code> is an object of class 'lagged_df' from <code>create_lagged_df(..., type = "forecast")</code>,
predictions are returned for the horizons specified in <code>create_lagged_df(horizons = ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast_model'
predict(..., prediction_function = list(NULL), data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.forecast_model_+3A_...">...</code></td>
<td>
<p>One or more trained models from <code>train_model()</code>.</p>
</td></tr>
<tr><td><code id="predict.forecast_model_+3A_prediction_function">prediction_function</code></td>
<td>
<p>A list of user-defined prediction functions with length equal to
the number of models supplied in <code>...</code>. The prediction functions
take 2 required positional arguments&ndash;(1) a 'forecast_model' object from <code>train_model()</code> and (2) a
data.frame of model features from <code>create_lagged_df()</code>. For numeric outcomes and <code>method = "direct"</code>, the function should <code>return()</code>
1- or 3-column data.frame of model predictions. If the prediction function returns a 1-column data.frame, point forecasts are assumed.
If the prediction function returns a 3-column data.frame, lower and upper forecast bounds are assumed (the
order and names of the 3 columns does not matter). For factor outcomes and <code>method = "direct"</code>, the function should <code>return()</code>
(1) 1-column data.frame of the model-predicted factor level or (2) an L-column data.frame of class probabilities where
'L' equals the number of levels in the outcome; columns should be ordered, from left to right, the same as
<code>levels(data$outcome)</code> which is the default behavior for most <code>predict(..., type = "prob")</code> functions.
Column names do not matter. For numeric outcomes and <code>method = "multi_output"</code>, the function should <code>return()</code> and
h-column data.frame of model predictions&ndash;1 column for each horizon. Forecast intervals and factor outcomes are not currently
supported with <code>method = "multi_output"</code>.</p>
</td></tr>
<tr><td><code id="predict.forecast_model_+3A_data">data</code></td>
<td>
<p>If <code>data</code> is a training dataset from <code>create_lagged_df(..., type = "train")</code>, validation dataset
predictions are returned; else, if <code>data</code> is a forecasting dataset from <code>create_lagged_df(..., type = "forecast")</code>,
forecasts from horizons 1:h are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>data = create_lagged_df(..., type = "forecast")</code>, an S3 object of class 'training_results'. If
<code>data = create_lagged_df(..., type = "forecast")</code>, an S3 object of class 'forecast_results'.
</p>
<p><strong>Columns in returned 'training_results' data.frame:</strong>
</p>

<ul>
<li> <p><code>model</code>: User-supplied model name in <code>train_model()</code>.
</p>
</li>
<li> <p><code>model_forecast_horizon</code>: The direct-forecasting time horizon that the model was trained on.
</p>
</li>
<li> <p><code>window_length</code>: Validation window length measured in dataset rows.
</p>
</li>
<li> <p><code>window_number</code>: Validation dataset number.
</p>
</li>
<li> <p><code>valid_indices</code>: Validation dataset row names from <code>attributes(create_lagged_df())$row_indices</code>.
</p>
</li>
<li> <p><code>date_indices</code>: If given and <code>method = "direct"</code>, validation dataset date indices from <code>attributes(create_lagged_df())$date_indices</code>.
If given and <code>method = "multi_output"</code>, date_indices represents the date of the forecast.
</p>
</li>
<li> <p><code>"groups"</code>: If given, the user-supplied groups in <code>create_lagged_df()</code>.
</p>
</li>
<li> <p><code>"outcome_name"</code>: The target being forecasted.
</p>
</li>
<li> <p><code>"outcome_name"_pred</code>: The model predictions.
</p>
</li>
<li> <p><code>"outcome_name"_pred_lower</code>: If given, the lower prediction bounds returned by the user-supplied prediction function.
</p>
</li>
<li> <p><code>"outcome_name"_pred_upper</code>: If given, the upper prediction bounds returned by the user-supplied prediction function.
</p>
</li>
<li> <p><code>forecast_indices</code>: If <code>method = "multi_output"</code>, the validation index of the h-step-ahead forecast.
</p>
</li>
<li> <p><code>forecast_date_indices</code>: If <code>method = "multi_output"</code>, the validation date index of the h-step-ahead forecast.
</p>
</li></ul>

<p><strong>Columns in returned 'forecast_results' data.frame:</strong>
</p>

<ul>
<li> <p><code>model</code>: User-supplied model name in <code>train_model()</code>.
</p>
</li>
<li> <p><code>model_forecast_horizon</code>: If <code>method = "direct"</code>, the direct-forecasting time horizon that the model was trained on.
</p>
</li>
<li> <p><code>horizon</code>: Forecast horizons, 1:h, measured in dataset rows.
</p>
</li>
<li> <p><code>window_length</code>: Validation window length measured in dataset rows.
</p>
</li>
<li> <p><code>forecast_period</code>: The forecast period in row indices or dates. The forecast period starts at either <code>attributes(create_lagged_df())$data_stop + 1</code> for row indices or <code>attributes(create_lagged_df())$data_stop + 1 * frequency</code> for date indices.
</p>
</li>
<li> <p><code>"groups"</code>: If given, the user-supplied groups in <code>create_lagged_df()</code>.
</p>
</li>
<li> <p><code>"outcome_name"</code>: The target being forecasted.
</p>
</li>
<li> <p><code>"outcome_name"_pred</code>: The model forecasts.
</p>
</li>
<li> <p><code>"outcome_name"_pred_lower</code>: If given, the lower forecast bounds returned by the user-supplied prediction function.
</p>
</li>
<li> <p><code>"outcome_name"_pred_upper</code>: If given, the upper forecast bounds returned by the user-supplied prediction function.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")

# Example - Training data for 2 horizon-specific models w/ common lags per predictor.
horizons &lt;- c(1, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)

# One custom validation window at the end of the dataset.
windows &lt;- create_windows(data_train, window_start = 181, window_stop = 192)

# User-define model - LASSO
# A user-defined wrapper function for model training that takes the following
# arguments: (1) a horizon-specific data.frame made with create_lagged_df(..., type = "train")
# (e.g., my_lagged_df$horizon_h) and, optionally, (2) any number of additional named arguments
# which are passed as '...' in train_model().
library(glmnet)
model_function &lt;- function(data, my_outcome_col) {

  x &lt;- data[, -(my_outcome_col), drop = FALSE]
  y &lt;- data[, my_outcome_col, drop = FALSE]
  x &lt;- as.matrix(x, ncol = ncol(x))
  y &lt;- as.matrix(y, ncol = ncol(y))

  model &lt;- glmnet::cv.glmnet(x, y, nfolds = 3)
  return(model)
}

# my_outcome_col = 1 is passed in ... but could have been defined in model_function().
model_results &lt;- train_model(data_train, windows, model_name = "LASSO", model_function,
                             my_outcome_col = 1)

# User-defined prediction function - LASSO
# The predict() wrapper takes two positional arguments. First,
# the returned model from the user-defined modeling function (model_function() above).
# Second, a data.frame of predictors--identical to the datasets returned from
# create_lagged_df(..., type = "train"). The function can return a 1- or 3-column data.frame
# with either (a) point forecasts or (b) point forecasts plus lower and upper forecast
# bounds (column order and column names do not matter).
prediction_function &lt;- function(model, data_features) {

  x &lt;- as.matrix(data_features, ncol = ncol(data_features))

  data_pred &lt;- data.frame("y_pred" = predict(model, x, s = "lambda.min"))
  return(data_pred)
}

# Predict on the validation datasets.
data_valid &lt;- predict(model_results, prediction_function = list(prediction_function),
                      data = data_train)

# Forecast.
data_forecast &lt;- create_lagged_df(data_seatbelts, type = "forecast", outcome_col = 1,
                                  lookback = lookback, horizon = horizons)

data_forecasts &lt;- predict(model_results, prediction_function = list(prediction_function),
                          data = data_forecast)
</code></pre>

<hr>
<h2 id='return_error'>Compute forecast error</h2><span id='topic+return_error'></span>

<h3>Description</h3>

<p>Compute forecast error metrics on the validation datasets or a new test dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_error(
  data_results,
  data_test = NULL,
  test_indices = NULL,
  aggregate = stats::median,
  metrics = c("mae", "mape", "mdape", "smape", "rmse", "rmsse"),
  models = NULL,
  horizons = NULL,
  windows = NULL,
  group_filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_error_+3A_data_results">data_results</code></td>
<td>
<p>An object of class 'training_results' or 'forecast_results' from running (a)
<code><a href="#topic+predict.forecast_model">predict</a></code> on a trained model or (b) <code>combine_forecasts()</code>.</p>
</td></tr>
<tr><td><code id="return_error_+3A_data_test">data_test</code></td>
<td>
<p>Required for forecast results only. If <code>data_results</code> is an object of class 'forecast_results', a data.frame used to
assess the accuracy of a 'forecast_results' object. <code>data_test</code> should have the outcome/target columns
and any grouping columns.</p>
</td></tr>
<tr><td><code id="return_error_+3A_test_indices">test_indices</code></td>
<td>
<p>Required if <code>data_test</code> is given or 'rmsse' 
row indices or dates (class 'Date' or 'POSIXt') with length <code>nrow(data_test)</code>.</p>
</td></tr>
<tr><td><code id="return_error_+3A_aggregate">aggregate</code></td>
<td>
<p>Default <code>median</code>. A function&ndash;without parentheses&ndash;that aggregates historical prediction or forecast error across time series.
All error metrics are first calculated at the level of the individual time series. <code>aggregate</code> is then used to combine error metrics across
validation windows and horizons. Aggregations are returned at the group level if <code>data_results</code> contains groups.</p>
</td></tr>
<tr><td><code id="return_error_+3A_metrics">metrics</code></td>
<td>
<p>A character vector of common forecast error metrics. The default behavior is to return all metrics.</p>
</td></tr>
<tr><td><code id="return_error_+3A_models">models</code></td>
<td>
<p>Optional. A character vector of user-defined model names supplied to <code>train_model()</code> to filter results.</p>
</td></tr>
<tr><td><code id="return_error_+3A_horizons">horizons</code></td>
<td>
<p>Optional. A numeric vector to filter results by horizon.</p>
</td></tr>
<tr><td><code id="return_error_+3A_windows">windows</code></td>
<td>
<p>Optional. A numeric vector to filter results by validation window number.</p>
</td></tr>
<tr><td><code id="return_error_+3A_group_filter">group_filter</code></td>
<td>
<p>Optional. A string for filtering plot results for grouped time series
(e.g., <code>"group_col_1 == 'A'"</code>). <code>group_filter</code> is passed to <code>dplyr::filter()</code> internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'validation_error', 'forecast_error', or 'forecastML_error': A list of data.frames
of error metrics for the validation or forecast dataset depending on the class of <code>data_results</code>: 'training_results',
'forecast_results', or 'forecastML' from <code>combine_forecasts()</code>.
</p>
<p>A list containing: <br />
</p>

<ul>
<li><p> Error metrics by model, horizon, and validation window
</p>
</li>
<li><p> Error metrics by model and horizon, collapsed across validation windows
</p>
</li>
<li><p> Global error metrics by model collapsed across horizons and validation windows
</p>
</li></ul>



<h3>Error Metrics</h3>


<ul>
<li> <p><code>mae</code>: Mean absolute error (works with factor outcomes)
</p>
</li>
<li> <p><code>mape</code>: Mean absolute percentage error
</p>
</li>
<li> <p><code>mdape</code>: Median absolute percentage error
</p>
</li>
<li> <p><code>smape</code>: Symmetrical mean absolute percentage error
</p>
</li>
<li> <p><code>rmse</code>: Root mean squared error
</p>
</li>
<li> <p><code>rmsse</code>: Root mean squared scaled error from the M5 competition
</p>
</li></ul>



<h3>Methods and related functions</h3>

<p>The output of <code>return_error()</code> has the following generic S3 methods
</p>

<ul>
<li> <p><code><a href="#topic+plot.validation_error">plot</a></code> from <code>return_error()</code>
</p>
</li>
<li> <p><code><a href="#topic+plot.forecast_error">plot</a></code> from <code>return_error()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")

# Example - Training data for 2 horizon-specific models w/ common lags per predictor.
horizons &lt;- c(1, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)

# One custom validation window at the end of the dataset.
windows &lt;- create_windows(data_train, window_start = 181, window_stop = 192)

# User-define model - LASSO
# A user-defined wrapper function for model training that takes the following
# arguments: (1) a horizon-specific data.frame made with create_lagged_df(..., type = "train")
# (e.g., my_lagged_df$horizon_h) and, optionally, (2) any number of additional named arguments
# which are passed as '...' in train_model().
library(glmnet)
model_function &lt;- function(data, my_outcome_col) {

  x &lt;- data[, -(my_outcome_col), drop = FALSE]
  y &lt;- data[, my_outcome_col, drop = FALSE]
  x &lt;- as.matrix(x, ncol = ncol(x))
  y &lt;- as.matrix(y, ncol = ncol(y))

  model &lt;- glmnet::cv.glmnet(x, y, nfolds = 3)
  return(model)
}

# my_outcome_col = 1 is passed in ... but could have been defined in model_function().
model_results &lt;- train_model(data_train, windows, model_name = "LASSO", model_function,
                             my_outcome_col = 1)

# User-defined prediction function - LASSO
# The predict() wrapper takes two positional arguments. First,
# the returned model from the user-defined modeling function (model_function() above).
# Second, a data.frame of predictors--identical to the datasets returned from
# create_lagged_df(..., type = "train"). The function can return a 1- or 3-column data.frame
# with either (a) point forecasts or (b) point forecasts plus lower and upper forecast
# bounds (column order and column names do not matter).
prediction_function &lt;- function(model, data_features) {

  x &lt;- as.matrix(data_features, ncol = ncol(data_features))

  data_pred &lt;- data.frame("y_pred" = predict(model, x, s = "lambda.min"))
  return(data_pred)
}

# Predict on the validation datasets.
data_valid &lt;- predict(model_results, prediction_function = list(prediction_function),
                      data = data_train)

# Forecast error metrics for validation datasets.
data_error &lt;- return_error(data_valid)
</code></pre>

<hr>
<h2 id='return_hyper'>Return model hyperparameters across validation datasets</h2><span id='topic+return_hyper'></span>

<h3>Description</h3>

<p>The purpose of this function is to support investigation into
the stability of hyperparameters in the nested cross-validation and across
forecast horizons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_hyper(forecast_model, hyper_function)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_hyper_+3A_forecast_model">forecast_model</code></td>
<td>
<p>An object of class 'forecast_model' from <code><a href="#topic+train_model">train_model</a></code>.</p>
</td></tr>
<tr><td><code id="return_hyper_+3A_hyper_function">hyper_function</code></td>
<td>
<p>A user-defined function for retrieving model hyperparameters. See the
example below for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'forecast_model_hyper': A data.frame of model-specific hyperparameters.
</p>


<h3>Methods and related functions</h3>

<p>The output of <code>return_hyper()</code> has the following generic S3 methods
</p>

<ul>
<li> <p><code><a href="#topic+plot.forecast_model_hyper">plot</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")

# Example - Training data for 2 horizon-specific models w/ common lags per predictor.
horizons &lt;- c(1, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)

# One custom validation window at the end of the dataset.
windows &lt;- create_windows(data_train, window_start = 181, window_stop = 192)

# User-define model - LASSO
# A user-defined wrapper function for model training that takes the following
# arguments: (1) a horizon-specific data.frame made with create_lagged_df(..., type = "train")
# (e.g., my_lagged_df$horizon_h) and, optionally, (2) any number of additional named arguments
# which are passed as '...' in train_model().
library(glmnet)
model_function &lt;- function(data, my_outcome_col) {

  x &lt;- data[, -(my_outcome_col), drop = FALSE]
  y &lt;- data[, my_outcome_col, drop = FALSE]
  x &lt;- as.matrix(x, ncol = ncol(x))
  y &lt;- as.matrix(y, ncol = ncol(y))

  model &lt;- glmnet::cv.glmnet(x, y, nfolds = 3)
  return(model)
}

# my_outcome_col = 1 is passed in ... but could have been defined in model_function().
model_results &lt;- train_model(data_train, windows, model_name = "LASSO", model_function,
                             my_outcome_col = 1)

# User-defined prediction function - LASSO
# The predict() wrapper takes two positional arguments. First,
# the returned model from the user-defined modeling function (model_function() above).
# Second, a data.frame of predictors--identical to the datasets returned from
# create_lagged_df(..., type = "train"). The function can return a 1- or 3-column data.frame
# with either (a) point forecasts or (b) point forecasts plus lower and upper forecast
# bounds (column order and column names do not matter).
prediction_function &lt;- function(model, data_features) {

  x &lt;- as.matrix(data_features, ncol = ncol(data_features))

  data_pred &lt;- data.frame("y_pred" = predict(model, x, s = "lambda.min"))
  return(data_pred)
}

# Predict on the validation datasets.
data_valid &lt;- predict(model_results, prediction_function = list(prediction_function),
                      data = data_train)

# User-defined hyperparameter function - LASSO
# The hyperparameter function should take one positional argument--the returned model
# from the user-defined modeling function (model_function() above). It should
# return a 1-row data.frame of the optimal hyperparameters.
hyper_function &lt;- function(model) {

  lambda_min &lt;- model$lambda.min
  lambda_1se &lt;- model$lambda.1se

  data_hyper &lt;- data.frame("lambda_min" = lambda_min, "lambda_1se" = lambda_1se)
  return(data_hyper)
}

data_error &lt;- return_error(data_valid)

data_hyper &lt;- return_hyper(model_results, hyper_function)

plot(data_hyper, data_valid, data_error, type = "stability", horizons = c(1, 12))
</code></pre>

<hr>
<h2 id='summary.lagged_df'>Return a summary of a lagged_df object</h2><span id='topic+summary.lagged_df'></span>

<h3>Description</h3>

<p>Return a summary of a lagged_df object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lagged_df'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lagged_df_+3A_object">object</code></td>
<td>
<p>An object of class 'lagged_df' from <code>create_lagged_df()</code>.</p>
</td></tr>
<tr><td><code id="summary.lagged_df_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printed summary of the contents of the lagged_df object.
</p>

<hr>
<h2 id='train_model'>Train a model across horizons and validation datasets</h2><span id='topic+train_model'></span>

<h3>Description</h3>

<p>Train a user-defined forecast model for each horizon, 'h', and across the validation
datasets, 'd'. If <code>method = "direct"</code>, a total of 'h' * 'd' models are trained.
If <code>method = "multi_output"</code>, a total of 1 * 'd' models are trained.
These models can be trained in parallel with the <code>future</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_model(
  lagged_df,
  windows,
  model_name,
  model_function,
  ...,
  use_future = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_model_+3A_lagged_df">lagged_df</code></td>
<td>
<p>An object of class 'lagged_df' from <code><a href="#topic+create_lagged_df">create_lagged_df</a></code>.</p>
</td></tr>
<tr><td><code id="train_model_+3A_windows">windows</code></td>
<td>
<p>An object of class 'windows' from <code><a href="#topic+create_windows">create_windows</a></code>.</p>
</td></tr>
<tr><td><code id="train_model_+3A_model_name">model_name</code></td>
<td>
<p>A name for the model.</p>
</td></tr>
<tr><td><code id="train_model_+3A_model_function">model_function</code></td>
<td>
<p>A user-defined wrapper function for model training that takes the following
arguments: (1) a horizon-specific data.frame made with <code>create_lagged_df(..., type = "train")</code>
(i.e., the dataset(s) stored in <code>lagged_df</code>) and, optionally, (2) any number of additional named arguments
which can be passed in <code>...</code> in this function.</p>
</td></tr>
<tr><td><code id="train_model_+3A_...">...</code></td>
<td>
<p>Optional. Named arguments passed into the user-defined <code>model_function</code>.</p>
</td></tr>
<tr><td><code id="train_model_+3A_use_future">use_future</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the <code>future</code> package is used for training models in parallel.
The models will train in parallel across either (1) model forecast horizons or (b) validation windows,
whichever is longer (i.e., <code>length(create_lagged_df())</code> or <code>nrow(create_windows())</code>). The user
should run <code>future::plan(future::multiprocess)</code> or similar prior to this function to train these models
in parallel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'forecast_model': A nested list of trained models. Models can be accessed with
<code>my_trained_model$horizon_h$window_w$model</code> where 'h' gives the forecast horizon and 'w' gives
the validation dataset window number from <code>create_windows()</code>.
</p>


<h3>Methods and related functions</h3>

<p>The output of <code>train_model</code> can be passed into
</p>

<ul>
<li> <p><code><a href="#topic+return_error">return_error</a></code>
</p>
</li>
<li> <p><code><a href="#topic+return_hyper">return_hyper</a></code>
</p>
</li></ul>

<p>and has the following generic S3 methods
</p>

<ul>
<li> <p><code><a href="#topic+predict.forecast_model">predict</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.training_results">plot</a></code> (from <code>predict.forecast_model(data = create_lagged_df(..., type = "train"))</code>)
</p>
</li>
<li> <p><code><a href="#topic+plot.forecast_results">plot</a></code> (from <code>predict.forecast_model(data = create_lagged_df(..., type = "forecast"))</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Sampled Seatbelts data from the R package datasets.
data("data_seatbelts", package = "forecastML")

# Example - Training data for 2 horizon-specific models w/ common lags per predictor.
horizons &lt;- c(1, 12)
lookback &lt;- 1:15

data_train &lt;- create_lagged_df(data_seatbelts, type = "train", outcome_col = 1,
                               lookback = lookback, horizon = horizons)

# One custom validation window at the end of the dataset.
windows &lt;- create_windows(data_train, window_start = 181, window_stop = 192)

# User-define model - LASSO
# A user-defined wrapper function for model training that takes the following
# arguments: (1) a horizon-specific data.frame made with create_lagged_df(..., type = "train")
# (e.g., my_lagged_df$horizon_h) and, optionally, (2) any number of additional named arguments
# which are passed as '...' in train_model().
library(glmnet)
model_function &lt;- function(data, my_outcome_col) {

  x &lt;- data[, -(my_outcome_col), drop = FALSE]
  y &lt;- data[, my_outcome_col, drop = FALSE]
  x &lt;- as.matrix(x, ncol = ncol(x))
  y &lt;- as.matrix(y, ncol = ncol(y))

  model &lt;- glmnet::cv.glmnet(x, y, nfolds = 3)
  return(model)
}

# my_outcome_col = 1 is passed in ... but could have been defined in model_function().
model_results &lt;- train_model(data_train, windows, model_name = "LASSO", model_function,
                             my_outcome_col = 1)

# View the results for the model (a) trained on the first horizon
# and (b) to be assessed on the first outer-loop validation window.
model_results$horizon_1$window_1$model
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
