<!DOCTYPE html><html><head><title>Help for package rayshader</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rayshader}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>re-export magrittr pipe operator</p></a></li>
<li><a href='#add_multi_padding'><p>add_multi_padding</p></a></li>
<li><a href='#add_overlay'><p>Add Overlay</p></a></li>
<li><a href='#add_padding'><p>add_padding</p></a></li>
<li><a href='#add_shadow'><p>Add Shadow</p></a></li>
<li><a href='#add_water'><p>Add Water</p></a></li>
<li><a href='#ambient_shade'><p>Calculate Ambient Occlusion Map</p></a></li>
<li><a href='#build_from_w'><p>Build From W</p></a></li>
<li><a href='#calculate_normal'><p>Calculate Normal</p></a></li>
<li><a href='#cloud_shade'><p>Cloud Shade</p></a></li>
<li><a href='#constant_shade'><p>Calculate Constant Color Map</p></a></li>
<li><a href='#convert_color'><p>Convert Color</p></a></li>
<li><a href='#convert_path_to_animation_coords'><p>Calculate Animation Coordinates from Path</p></a></li>
<li><a href='#convert_rgl_to_raymesh'><p>Convert rayshader RGL scene to ray_mesh object</p></a></li>
<li><a href='#create_texture'><p>Create Texture</p></a></li>
<li><a href='#cross'><p>Cross Product</p></a></li>
<li><a href='#darken_color'><p>Darken Color</p></a></li>
<li><a href='#detect_water'><p>Detect water</p></a></li>
<li><a href='#drawkeyfunction_lines'><p>drawkeyfunction lines</p></a></li>
<li><a href='#drawkeyfunction_points'><p>drawkeyfunction points</p></a></li>
<li><a href='#fix_manifold_geometry'><p>Fix Manifold Geometry</p></a></li>
<li><a href='#flag_banner_obj'><p>Flag Banner 3D Model</p></a></li>
<li><a href='#flag_full_obj'><p>Flag 3D Model</p></a></li>
<li><a href='#flag_pole_obj'><p>Flag Pole 3D Model</p></a></li>
<li><a href='#fliplr'><p>Flip Left-Right</p></a></li>
<li><a href='#flipud'><p>Flip Up-Down</p></a></li>
<li><a href='#gen_fractal_perlin'><p>Generate Fractal Perlin Noise</p></a></li>
<li><a href='#generate_altitude_overlay'><p>Generate Altitude Overlay</p></a></li>
<li><a href='#generate_base_shape'><p>Generate Base Shape</p></a></li>
<li><a href='#generate_cloud_layer'><p>Calculate a single raymarched cloud layer</p></a></li>
<li><a href='#generate_compass_overlay'><p>Generate Compass Overlay</p></a></li>
<li><a href='#generate_contour_overlay'><p>Generate Contour Overlay</p></a></li>
<li><a href='#generate_label_overlay'><p>Generate Label Overlay</p></a></li>
<li><a href='#generate_line_overlay'><p>Generate Line Overlay</p></a></li>
<li><a href='#generate_point_overlay'><p>Generate Point Overlay</p></a></li>
<li><a href='#generate_polygon_overlay'><p>Generate Polygon Overlay</p></a></li>
<li><a href='#generate_rot_matrix'><p>Generate Rotation Matrix</p></a></li>
<li><a href='#generate_scalebar_overlay'><p>Generate Scalebar Overlay</p></a></li>
<li><a href='#generate_soil_textures'><p>Generate Soil Textures</p></a></li>
<li><a href='#generate_surface'><p>generate_surface</p></a></li>
<li><a href='#generate_waterline_overlay'><p>Generate Waterline Overlay</p></a></li>
<li><a href='#get_extent'><p>Get Extent</p></a></li>
<li><a href='#get_ids_with_labels'><p>Get IDs with Labels</p></a></li>
<li><a href='#get_interpolated_points_path'><p>Get Distance Along Bezier Curve</p></a></li>
<li><a href='#get_polygon_data_value'><p>Get Data Value from spatial object</p></a></li>
<li><a href='#get_scene_depth'><p>Get the scene depth from rgl to offset rayrender scenes</p></a></li>
<li><a href='#height_shade'><p>Calculate Terrain Color Map</p></a></li>
<li><a href='#lamb_shade'><p>Calculate Lambert Shading Map</p></a></li>
<li><a href='#load_image'><p>Load Image</p></a></li>
<li><a href='#local_to_world'><p>Local To World</p></a></li>
<li><a href='#lookat'><p>Generate LookAt Matrix</p></a></li>
<li><a href='#make_base'><p>make_base</p></a></li>
<li><a href='#make_base_triangulated'><p>Make Base (for triangulated height maps)</p></a></li>
<li><a href='#make_lines'><p>make_lines</p></a></li>
<li><a href='#make_shadow'><p>make_shadow</p></a></li>
<li><a href='#make_water'><p>make_water</p></a></li>
<li><a href='#make_waterlines'><p>make_waterlines</p></a></li>
<li><a href='#monterey_counties_sf'><p>California County Data Around Monterey Bay</p></a></li>
<li><a href='#monterey_roads_sf'><p>Road Data Around Monterey Bay</p></a></li>
<li><a href='#montereybay'><p>Monterey Bay combined topographic and bathymetric elevation matrix.</p></a></li>
<li><a href='#plot_3d'><p>Plot 3D</p></a></li>
<li><a href='#plot_gg'><p>Transform ggplot2 objects into 3D</p></a></li>
<li><a href='#plot_map'><p>Plot Map</p></a></li>
<li><a href='#raster_to_matrix'><p>Raster to Matrix</p></a></li>
<li><a href='#ray_merge_reorder'><p>Reorder Lines</p></a></li>
<li><a href='#ray_shade'><p>Calculate Raytraced Shadow Map</p></a></li>
<li><a href='#raymarch_cloud_layer'><p>Calculate a single raymarched cloud layer</p></a></li>
<li><a href='#reduce_matrix_size'><p>Reduce Matrix Size (deprecated)</p></a></li>
<li><a href='#render_beveled_polygons'><p>Render Beveled Polygons</p></a></li>
<li><a href='#render_buildings'><p>Render Buildings</p></a></li>
<li><a href='#render_camera'><p>Render Camera</p></a></li>
<li><a href='#render_clouds'><p>Render Clouds</p></a></li>
<li><a href='#render_compass'><p>Render Compass Symbol</p></a></li>
<li><a href='#render_contours'><p>Render Contours</p></a></li>
<li><a href='#render_depth'><p>Render Depth of Field</p></a></li>
<li><a href='#render_floating_overlay'><p>Render Floating overlay</p></a></li>
<li><a href='#render_highquality'><p>Render High Quality</p></a></li>
<li><a href='#render_label'><p>Render Label</p></a></li>
<li><a href='#render_movie'><p>Render Movie</p></a></li>
<li><a href='#render_multipolygonz'><p>Render MULTIPOLYGON Z Geometry</p></a></li>
<li><a href='#render_obj'><p>Render Obj</p></a></li>
<li><a href='#render_path'><p>Render Path</p></a></li>
<li><a href='#render_points'><p>Render Points</p></a></li>
<li><a href='#render_polygons'><p>Render Polygons</p></a></li>
<li><a href='#render_raymesh'><p>Render Raymesh</p></a></li>
<li><a href='#render_resize_window'><p>Resize the rgl Window</p></a></li>
<li><a href='#render_scalebar'><p>Render Scale Bar</p></a></li>
<li><a href='#render_snapshot'><p>Render Snapshot of 3D Visualization</p></a></li>
<li><a href='#render_snapshot_software'><p>Render Software Snapshot</p></a></li>
<li><a href='#render_tree'><p>Render Tree</p></a></li>
<li><a href='#render_water'><p>Render Water Layer</p></a></li>
<li><a href='#resize_matrix'><p>Resize Matrix</p></a></li>
<li><a href='#rot_to_euler'><p>Rotation Matrix to Euler Angle Transform</p></a></li>
<li><a href='#run_documentation'><p>Run Documentation</p></a></li>
<li><a href='#save_3dprint'><p>Save 3D Print</p></a></li>
<li><a href='#save_multipolygonz_to_obj'><p>Save MULTIPOLYGON Z sf data to OBJ file</p></a></li>
<li><a href='#save_obj'><p>Save OBJ</p></a></li>
<li><a href='#save_png'><p>Save PNG</p></a></li>
<li><a href='#sphere_shade'><p>Calculate Surface Color Map</p></a></li>
<li><a href='#texture_shade'><p>Calculate Texture Shading Map</p></a></li>
<li><a href='#transform_into_heightmap_coords'><p>Get Position from Lat/Long and heightmap/extent</p></a></li>
<li><a href='#transform_points_custom_crs'><p>Transform Polygon into Raycoords</p></a></li>
<li><a href='#transform_points_into_raycoords'><p>Transform Points into Raycoords</p></a></li>
<li><a href='#transform_polygon_custom_crs'><p>Transform Polygon into Raycoords</p></a></li>
<li><a href='#transform_polygon_into_raycoords'><p>Transform Polygon into Raycoords</p></a></li>
<li><a href='#translate_shape_string'><p>translate_shape_string</p></a></li>
<li><a href='#tree_basic_center_obj'><p>Flag 3D Model</p></a></li>
<li><a href='#tree_cone_center_obj'><p>Flag 3D Model</p></a></li>
<li><a href='#tree_trunk_obj'><p>Flag 3D Model</p></a></li>
<li><a href='#trim_padding'><p>trim_padding</p></a></li>
<li><a href='#unit_vector'><p>Unit Vector</p></a></li>
<li><a href='#washington_monument_multipolygonz'><p>Washington Monument 3D Model as Multipolygon Z Data</p></a></li>
<li><a href='#write_stl'><p>Write STL</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Maps and Visualize Data in 2D and 3D</td>
</tr>
<tr>
<td>Version:</td>
<td>0.37.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Morgan-Wall &lt;tylermw@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses a combination of raytracing and multiple hill shading methods to produce 2D and 3D data visualizations and maps. Includes water detection and layering functions, programmable color palette generation, several built-in textures for hill shading, 2D and 3D plotting options, a built-in path tracer, 'Wavefront' OBJ file export, and the ability to save 3D visualizations to a 3D printable format.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, Rcpp, progress, raster, scales, png,
jpeg, magrittr, rgl (&ge; 0.110.7), grDevices, grid, utils,
methods, terrainmeshr, rayimage (&ge; 0.10.0), rayvertex (&ge;
0.10.4), rayrender (&ge; 0.32.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>reshape2, viridis, av, magick, ggplot2, sf, isoband, car (&ge;
3.1-1), geosphere, gifski, ambient, terra, lidR, elevatr,
gridExtra, testthat (&ge; 3.0.0), osmdata, raybevel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, progress, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rayshader.com">https://www.rayshader.com</a>,
<a href="https://github.com/tylermorganwall/rayshader">https://github.com/tylermorganwall/rayshader</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tylermorganwall/rayshader/issues">https://github.com/tylermorganwall/rayshader/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://tylermorganwall.r-universe.dev/">https://tylermorganwall.r-universe.dev/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 03:47:56 UTC; tyler</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Morgan-Wall <a href="https://orcid.org/0000-0002-3131-3814"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>re-export magrittr pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='add_multi_padding'>add_multi_padding</h2><span id='topic+add_multi_padding'></span>

<h3>Description</h3>

<p>Adds multiple levels padding to the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_multi_padding(heightmap, pad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_multi_padding_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="add_multi_padding_+3A_pad">pad</code></td>
<td>
<p>Number of padding entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hillshade with edges padded
</p>

<hr>
<h2 id='add_overlay'>Add Overlay</h2><span id='topic+add_overlay'></span>

<h3>Description</h3>

<p>Overlays an image (with a transparency layer) on the current map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_overlay(
  hillshade = NULL,
  overlay = NULL,
  alphalayer = 1,
  alphacolor = NULL,
  alphamethod = "max",
  rescale_original = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_overlay_+3A_hillshade">hillshade</code></td>
<td>
<p>A three-dimensional RGB array or 2D matrix of shadow intensities.</p>
</td></tr>
<tr><td><code id="add_overlay_+3A_overlay">overlay</code></td>
<td>
<p>A three or four dimensional RGB array, where the 4th dimension represents the alpha (transparency) channel. 
If the array is 3D, 'alphacolor' should also be passed to indicate transparent regions.</p>
</td></tr>
<tr><td><code id="add_overlay_+3A_alphalayer">alphalayer</code></td>
<td>
<p>Default '1'. Defines minimum tranparaency of layer. If transparency already exists in 'overlay', the way 'add_overlay' combines 
the two is determined in argument 'alphamethod'.</p>
</td></tr>
<tr><td><code id="add_overlay_+3A_alphacolor">alphacolor</code></td>
<td>
<p>Default 'NULL'. If 'overlay' is a 3-layer array, this argument tells which color is interpretted as completely transparent.</p>
</td></tr>
<tr><td><code id="add_overlay_+3A_alphamethod">alphamethod</code></td>
<td>
<p>Default 'max'. Method for dealing with pre-existing transparency with 'layeralpha'. 
If 'max', converts all alpha levels higher than 'layeralpha' to the value set in 'layeralpha'. Otherwise,
this just sets all transparency to 'layeralpha'.</p>
</td></tr>
<tr><td><code id="add_overlay_+3A_rescale_original">rescale_original</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', 'hillshade' will be scaled to match the dimensions of 'overlay' (instead of
the other way around).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hillshade with overlay.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Combining base R plotting with rayshader's spherical color mapping and raytracing:
if(run_documentation()) {
montereybay %&gt;%
  sphere_shade() %&gt;%
  add_overlay(height_shade(montereybay),alphalayer = 0.6)  %&gt;%
  add_shadow(ray_shade(montereybay,zscale=50)) %&gt;%
  plot_map()
}

if(run_documentation()) {
#Add contours with `generate_contour_overlay()`
montereybay %&gt;%
  height_shade() %&gt;%
  add_overlay(generate_contour_overlay(montereybay))  %&gt;%
  add_shadow(ray_shade(montereybay,zscale=50)) %&gt;%
  plot_map()
}
</code></pre>

<hr>
<h2 id='add_padding'>add_padding</h2><span id='topic+add_padding'></span>

<h3>Description</h3>

<p>Adds padding to the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_padding(heightmap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_padding_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hillshade with edges padded
</p>

<hr>
<h2 id='add_shadow'>Add Shadow</h2><span id='topic+add_shadow'></span>

<h3>Description</h3>

<p>Multiplies a texture array or shadow map by a shadow map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_shadow(hillshade, shadowmap, max_darken = 0.7, rescale_original = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_shadow_+3A_hillshade">hillshade</code></td>
<td>
<p>A three-dimensional RGB array or 2D matrix of shadow intensities.</p>
</td></tr>
<tr><td><code id="add_shadow_+3A_shadowmap">shadowmap</code></td>
<td>
<p>A matrix that incidates the intensity of the shadow at that point. 0 is full darkness, 1 is full light.</p>
</td></tr>
<tr><td><code id="add_shadow_+3A_max_darken">max_darken</code></td>
<td>
<p>Default '0.7'. The lower limit for how much the image will be darkened. 0 is completely black,
1 means the shadow map will have no effect.</p>
</td></tr>
<tr><td><code id="add_shadow_+3A_rescale_original">rescale_original</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', 'hillshade' will be scaled to match the dimensions of 'shadowmap' (instead of
the other way around).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shaded texture map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#First we plot the sphere_shade() hillshade of `montereybay` with no shadows

if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(colorintensity=0.5) %&gt;%
 plot_map()
}

#Raytrace the `montereybay` elevation map and add that shadow to the output of sphere_shade()
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(colorintensity=0.5) %&gt;%
 add_shadow(ray_shade(montereybay,sunaltitude=20,zscale=50),max_darken=0.3) %&gt;%
 plot_map()
}

#Increase the intensity of the shadow map with the max_darken argument.
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(colorintensity=0.5) %&gt;%
 add_shadow(ray_shade(montereybay,sunaltitude=20,zscale=50),max_darken=0.1) %&gt;%
 plot_map()
}

#Decrease the intensity of the shadow map.
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(colorintensity=0.5) %&gt;%
 add_shadow(ray_shade(montereybay,sunaltitude=20,zscale=50),max_darken=0.7) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='add_water'>Add Water</h2><span id='topic+add_water'></span>

<h3>Description</h3>

<p>Adds a layer of water to a map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_water(hillshade, watermap, color = "imhof1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_water_+3A_hillshade">hillshade</code></td>
<td>
<p>A three-dimensional RGB array.</p>
</td></tr>
<tr><td><code id="add_water_+3A_watermap">watermap</code></td>
<td>
<p>Matrix indicating whether water was detected at that point. 1 indicates water, 0 indicates no water.</p>
</td></tr>
<tr><td><code id="add_water_+3A_color">color</code></td>
<td>
<p>Default 'imhof1'. The water fill color. A hexcode or recognized color string. 
Also includes built-in colors to match the palettes included in sphere_shade: 
('imhof1','imhof2','imhof3','imhof4', 'desert', 'bw', and 'unicorn').</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Here we even out a portion of the volcano dataset to simulate water:
island_volcano = volcano
island_volcano[island_volcano &lt; mean(island_volcano)] = mean(island_volcano)

#Setting a minimum area avoids classifying small flat areas as water:
if(run_documentation()) {
island_volcano %&gt;%
 sphere_shade(texture="imhof3") %&gt;%
 add_water(detect_water(island_volcano, min_area = 400),color="imhof3") %&gt;%
 plot_map()
}
 
#We'll do the same thing with the Monterey Bay dataset to fill in the ocean:

montbay_water = montereybay
montbay_water[montbay_water &lt; 0] = 0

if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(texture="imhof4") %&gt;%
 add_water(detect_water(montbay_water),color="imhof4") %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='ambient_shade'>Calculate Ambient Occlusion Map</h2><span id='topic+ambient_shade'></span>

<h3>Description</h3>

<p>Calculates Ambient Occlusion Shadow Map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ambient_shade(
  heightmap,
  anglebreaks = 90 * cospi(seq(5, 85, by = 5)/180),
  sunbreaks = 24,
  maxsearch = 30,
  multicore = FALSE,
  zscale = 1,
  cache_mask = NULL,
  shadow_cache = NULL,
  progbar = interactive(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ambient_shade_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_anglebreaks">anglebreaks</code></td>
<td>
<p>Default '90*cospi(seq(5, 85,by =5)/180)'. The angle(s), in degrees, as measured from the horizon from which the light originates.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_sunbreaks">sunbreaks</code></td>
<td>
<p>Default '24'. Number of rays to be sent out in a circle, evenly spaced, around the point being tested.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_maxsearch">maxsearch</code></td>
<td>
<p>Default '30'. The maximum horizontal distance that the system should propogate rays to check for surface intersections.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_multicore">multicore</code></td>
<td>
<p>Default FALSE. If TRUE, multiple cores will be used to compute the shadow matrix. By default, this uses all cores available, unless the user has
set 'options(&quot;cores&quot;)' in which the multicore option will only use that many cores.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_zscale">zscale</code></td>
<td>
<p>Default 1. The ratio between the x and y spacing (which are assumed to be equal) and the z axis.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_cache_mask">cache_mask</code></td>
<td>
<p>Default 'NULL'. A matrix of 1 and 0s, indicating which points on which the raytracer will operate.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_shadow_cache">shadow_cache</code></td>
<td>
<p>Default 'NULL'. The shadow matrix to be updated at the points defined by the argument 'cache_mask'.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_progbar">progbar</code></td>
<td>
<p>Default 'TRUE' if interactive, 'FALSE' otherwise. If 'FALSE', turns off progress bar.</p>
</td></tr>
<tr><td><code id="ambient_shade_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the 'makeCluster' function when 'multicore=TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shaded texture map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Here we produce a ambient occlusion map of the `montereybay` elevation map.
if(run_documentation()) {
plot_map(ambient_shade(heightmap = montereybay))
}

#We can increase the distance to look for surface intersections `maxsearch`
#and the density of rays sent out around the point `sunbreaks`.
if(run_documentation()) {
plot_map(ambient_shade(montereybay, sunbreaks = 24,maxsearch = 100, multicore=TRUE))
}
#Create the Red Relief Image Map (RRIM) technique using a custom texture and ambient_shade(),
#with an addition lambertian layer added with lamb_shade() to improve topographic clarity.
if(run_documentation()) {
bigmb = resize_matrix(montereybay, scale=2, method="cubic")
bigmb %&gt;%
 sphere_shade(zscale=3, texture = create_texture("red","red","red","red","white")) %&gt;%
 add_shadow(ambient_shade(bigmb, maxsearch = 100, multicore = TRUE,zscale=1),0) %&gt;%
 add_shadow(lamb_shade(bigmb),0.5) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='build_from_w'>Build From W</h2><span id='topic+build_from_w'></span>

<h3>Description</h3>

<p>Build From W
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_from_w(dir)
</code></pre>


<h3>Value</h3>

<p>mat
</p>

<hr>
<h2 id='calculate_normal'>Calculate Normal</h2><span id='topic+calculate_normal'></span>

<h3>Description</h3>

<p>Calculates the normal unit vector for every point on the grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_normal(heightmap, zscale = 1, progbar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_normal_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="calculate_normal_+3A_zscale">zscale</code></td>
<td>
<p>Default 1.</p>
</td></tr>
<tr><td><code id="calculate_normal_+3A_progbar">progbar</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', turns on progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of light intensities at each point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Here we produce a light intensity map of the `volcano` elevation map.

#Cache the normal vectors of the volcano dataset
if(run_documentation()) {
volcanocache = calculate_normal(volcano)
}

#Use the cached vectors to speed up calculation of `sphere_shade()` on a map.
if(run_documentation()) {
sphere_shade(volcano,normalvectors = volcanocache) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='cloud_shade'>Cloud Shade</h2><span id='topic+cloud_shade'></span>

<h3>Description</h3>

<p>Render shadows from the 3D floating cloud layer on the ground. Use this function
to add shadows to the map with the 'add_shadow()' function.
</p>
<p>For realistic results, argument should match those passed to 'render_clouds()'. The exception to this
is 'attenuation_coef', which can be used to adjust the darkness of the resulting shadows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cloud_shade(
  heightmap,
  start_altitude = 1000,
  end_altitude = 2000,
  sun_altitude = 90,
  sun_angle = 315,
  time = 0,
  cloud_cover = 0.5,
  layers = 10,
  offset_x = 0,
  offset_y = 0,
  scale_x = 1,
  scale_y = 1,
  scale_z = 1,
  frequency = 0.005,
  fractal_levels = 16,
  attenuation_coef = 1,
  seed = 1,
  zscale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cloud_shade_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. This is used by 'render_clouds()' to 
calculate the regions the clouds should be rendered in.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_start_altitude">start_altitude</code></td>
<td>
<p>Default '1000'. The bottom of the cloud layer.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_end_altitude">end_altitude</code></td>
<td>
<p>Default '2000'. The top of the cloud layer.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_sun_altitude">sun_altitude</code></td>
<td>
<p>Default '10'. The angle, in degrees (as measured from the horizon) from which the light originates.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_sun_angle">sun_angle</code></td>
<td>
<p>Default '315' (NW). The angle, in degrees, around the matrix from which the light originates. Zero degrees is North, increasing clockwise</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_time">time</code></td>
<td>
<p>Default '0'. Advance this to make the clouds evolve and change in shape.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_cloud_cover">cloud_cover</code></td>
<td>
<p>Default '0.5'. The percentage of cloud cover.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_layers">layers</code></td>
<td>
<p>Default '90'. The number of layers to render the cloud layer.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_offset_x">offset_x</code></td>
<td>
<p>Default '0'. Change this to move the cloud layer sideways.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_offset_y">offset_y</code></td>
<td>
<p>Default '0'. Change this to move the cloud layer backwards and forward</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_scale_x">scale_x</code></td>
<td>
<p>Default '1'. Scale the fractal pattern in the x direction.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_scale_y">scale_y</code></td>
<td>
<p>Default '1'. Scale the fractal pattern in the y direction.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_scale_z">scale_z</code></td>
<td>
<p>Default '1'. Scale the fractal pattern in the z (altitude) direction. (automatically calculated). Scale the fractal pattern in the z (vertical) direction. s.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_frequency">frequency</code></td>
<td>
<p>Default '0.005'. The base frequency of the noise used to calculate the fractal cloud structure.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_fractal_levels">fractal_levels</code></td>
<td>
<p>Default '16'. The fractal dimension used to calculate the noise. Higher values give more fine structure, but take longer to calculate.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_attenuation_coef">attenuation_coef</code></td>
<td>
<p>Default '1'. Amount of attenuation in the cloud (higher numbers give darker shadows). This value is automatically scaled to account for increasing the number of layers.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_seed">seed</code></td>
<td>
<p>Default '1'. Random seed used to generate clouds.</p>
</td></tr>
<tr><td><code id="cloud_shade_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2D shadow matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Render clouds with cloud shadows on the ground
montereybay  %&gt;%
 sphere_shade()  %&gt;%
 add_shadow(cloud_shade(montereybay,zscale=50), 0.0) %&gt;%
 plot_3d(montereybay,background="darkred",zscale=50)
render_camera(theta=-65, phi = 25, zoom = 0.45, fov = 80)
render_clouds(montereybay, zscale=50)    
render_snapshot()
}
if(run_documentation()) {
#Adjust the light direction for shadows and increase the attenuation for darker clouds
montereybay  %&gt;%
 sphere_shade()  %&gt;%
 add_shadow(cloud_shade(montereybay,zscale=50, sun_altitude=20, attenuation_coef = 3), 0.0) %&gt;%
 plot_3d(montereybay,background="darkred",zscale=50)
render_camera(theta=-65, phi = 25, zoom = 0.45, fov = 80)
render_clouds(montereybay, zscale=50)    
render_snapshot()
}
</code></pre>

<hr>
<h2 id='constant_shade'>Calculate Constant Color Map</h2><span id='topic+constant_shade'></span>

<h3>Description</h3>

<p>Generates a constant color layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constant_shade(heightmap, color = "white", alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constant_shade_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point.</p>
</td></tr>
<tr><td><code id="constant_shade_+3A_color">color</code></td>
<td>
<p>Default '&quot;white&quot;'. Color for the constant layer.</p>
</td></tr>
<tr><td><code id="constant_shade_+3A_alpha">alpha</code></td>
<td>
<p>Default '1', the alpha transparency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGB array of a single color layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Shade a red map
montereybay %&gt;%
 constant_shade("red") %&gt;%
 add_shadow(lamb_shade(montereybay),0) |&gt; 
 plot_map()
}
if(run_documentation()) {
#Shade a green map
montereybay %&gt;%
 constant_shade("green") %&gt;%
 add_shadow(lamb_shade(montereybay),0) |&gt; 
 plot_map()
}
if(run_documentation()) {
#Add a blue tint
montereybay %&gt;%
 height_shade() |&gt; 
 add_overlay(constant_shade(montereybay, "dodgerblue", alpha=0.25)) %&gt;%
 add_shadow(lamb_shade(montereybay,zscale=50),0) |&gt; 
 plot_map()
}
if(run_documentation()) {
#Use a blank map on which to draw other data
montereybay %&gt;%
 constant_shade() %&gt;%
 add_overlay(generate_line_overlay(monterey_roads_sf, linewidth=5, color="black",
                                   attr(montereybay,"extent"), width = 1080, height = 1080),
                                   alphalayer=0.8)  %&gt;%
 add_water(detect_water(montereybay &lt; 0), "dodgerblue") %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='convert_color'>Convert Color</h2><span id='topic+convert_color'></span>

<h3>Description</h3>

<p>Convert Color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_color(color, as_hex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_color_+3A_color">color</code></td>
<td>
<p>The color to convert. Can be either a hexadecimal code, or a numeric rgb 
vector listing three intensities between '0' and '1'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#none
</code></pre>

<hr>
<h2 id='convert_path_to_animation_coords'>Calculate Animation Coordinates from Path</h2><span id='topic+convert_path_to_animation_coords'></span>

<h3>Description</h3>

<p>Transforms latitude/longitude/altitude coordinates to the reference system used in 'render_highquality()',
so they can be used to create high quality pathtraced animations by passing the output to the 'animation_camera_coords'
argument in 'render_highquality()'.
</p>
<p>This function converts the path values to rayshader coordinates (by setting 'return_coords = TRUE' in 'render_path()') 
and then subtracts out the rgl y-offset, which can be obtained by calling the internal function 'rayshader:::get_scene_depth()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_path_to_animation_coords(
  lat,
  long = NULL,
  altitude = NULL,
  extent = NULL,
  frames = 360,
  reorder = FALSE,
  reorder_first_index = 1,
  reorder_duplicate_tolerance = 0.1,
  reorder_merge_tolerance = 1,
  simplify_tolerance = 0,
  zscale = 1,
  heightmap = NULL,
  offset = 5,
  type = "bezier",
  offset_lookat = 1,
  constant_step = TRUE,
  curvature_adjust = "none",
  curvature_scale = 30,
  follow_camera = FALSE,
  follow_distance = 100,
  follow_angle = 45,
  follow_rotations = 0,
  follow_fixed = FALSE,
  follow_fixed_offset = c(10, 10, 10),
  damp_motion = FALSE,
  damp_magnitude = 0.1,
  resample_path_evenly = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_path_to_animation_coords_+3A_lat">lat</code></td>
<td>
<p>Vector of latitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_long">long</code></td>
<td>
<p>Vector of longitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_altitude">altitude</code></td>
<td>
<p>Elevation of each point, in units of the elevation matrix (scaled by zscale). 
If left 'NULL', this will be just the elevation value at ths surface, offset by 'offset'. If a single value, 
all data will be rendered at that altitude.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_frames">frames</code></td>
<td>
<p>Default '360'. Total number of animation frames.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_reorder">reorder</code></td>
<td>
<p>Default 'TRUE'. If 'TRUE', this will attempt to re-order the rows within an 'sf' object with
multiple paths to be one continuous, end-to-end path. This happens in two steps: merging duplicate 
paths that have end points that match with another object (within 'reorder_duplicate_tolerance' distance), and then
merges them (within 'reorder_merge_tolerance' distance) to form a continuous path.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_reorder_first_index">reorder_first_index</code></td>
<td>
<p>Default '1'. The index (row) of the 'sf' object in which to begin the reordering
process. This merges and reorders paths within 'reorder_merge_tolerance' distance until it cannot 
merge any more, and then repeats the process in the opposite direction.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_reorder_duplicate_tolerance">reorder_duplicate_tolerance</code></td>
<td>
<p>Default '0.1'. Lines that have start and end points (does not matter which)
within this tolerance that match a line already processed (order determined by 'reorder_first_index') will be 
discarded.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_reorder_merge_tolerance">reorder_merge_tolerance</code></td>
<td>
<p>Default '1'. Lines that have start points that are within this distance 
to a previously processed line's end point (order determined by 'reorder_first_index') will be reordered 
within the 'sf' object to form a continuous, end-to-end path.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_simplify_tolerance">simplify_tolerance</code></td>
<td>
<p>Default '0' (no simplification). If greater than zero, simplifies
the path to the tolerance specified. This happens after the data has been merged if 'reorder = TRUE'. 
If the input data is specified with long-lat coordinates and 'sf_use_s2()' returns 'TRUE', 
then the value of simplify_tolerance must be specified in meters.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_offset">offset</code></td>
<td>
<p>Default '5'. Offset of the track from the surface, if 'altitude = NULL'.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_type">type</code></td>
<td>
<p>Default 'cubic'. Type of transition between keyframes. 
Other options are 'linear', 'quad', 'bezier', 'exp', and 'manual'. 'manual' just returns the values 
passed in, properly formatted to be passed to 'render_animation()'.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_offset_lookat">offset_lookat</code></td>
<td>
<p>Default '0'. Amount to offset the lookat position, either along the path (if 'constant_step = TRUE')
or towards the derivative of the Bezier curve.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_constant_step">constant_step</code></td>
<td>
<p>Default 'TRUE'. This will make the camera travel at a constant speed.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_curvature_adjust">curvature_adjust</code></td>
<td>
<p>Default 'none'. Other options are 'position', 'lookat', and 'both'. Whether to slow down the camera at areas of high curvature
to prevent fast swings. Only used for curve 'type = bezier'. This does not preserve key frame positions.
Note: This feature will likely result in the 'lookat' and 'position' diverging if they do not 
have similar curvatures at each point. This feature is best used when passing the same set of points to 'positions' and 'lookats' 
and providing an 'offset_lookat' value, which ensures the curvature will be the same.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_curvature_scale">curvature_scale</code></td>
<td>
<p>Default '30'. Constant dividing factor for curvature. Higher values will subdivide the
path more, potentially finding a smoother path, but increasing the calculation time. Only used for curve 'type = bezier'.
Increasing this value after a certain point will not increase the quality of the path, but it is scene-dependent.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_follow_camera">follow_camera</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this generates a 3rd person view that follows the path specified in 'lat', 'long', and 'altitude'.
The distance to the camera is specified by 'follow_distance', and the angle (off the ground) is specified by 'follow_angle'. 
Make the camera rotate around the point as it moves by setting 'follow_rotations' to a non-zero number. The camera points in the direction of the 
You can also set the camera to be a fixed distance and angle above the by settings 'follow_fixed = TRUE' and specifying the distance
in 'follow_fixed_offset'.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_follow_distance">follow_distance</code></td>
<td>
<p>Default '100'. Distance for the camera to follow the point when 'follow_camera = TRUE'.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_follow_angle">follow_angle</code></td>
<td>
<p>Default '45'.  Angle (off the ground) of the camera when 'follow_camera = TRUE'.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_follow_rotations">follow_rotations</code></td>
<td>
<p>Default '0'. Number of rotations around the point when 'follow_camera = TRUE'.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_follow_fixed">follow_fixed</code></td>
<td>
<p>Default &lsquo;FALSE'. If 'TRUE', the camera doesn&rsquo;t look in the direction of the path,
but rather sits at a fixed relative location to the path.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_follow_fixed_offset">follow_fixed_offset</code></td>
<td>
<p>Default 'c(10,10,10)'. If 'follow_fixed = TRUE', the offset from the path to place
the camera.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_damp_motion">damp_motion</code></td>
<td>
<p>Default 'FALSE'. Whether the suppress quick, jerky movements of the camera by linearly interpolating
between the current camera position and the goal position. Amount of linear interpolation set in 'damp_magnitude'.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_damp_magnitude">damp_magnitude</code></td>
<td>
<p>Default '0.1'. Amount of linear interpolation if 'damp_motion = TRUE'.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_resample_path_evenly">resample_path_evenly</code></td>
<td>
<p>Default 'TRUE'. This re-samples points along the path so that the camera moves 
at a constant speed along the path. This also allows paths with large numbers of points to be used with a
smaller number of frames, and improves computation time of the animation path in those instances.</p>
</td></tr>
<tr><td><code id="convert_path_to_animation_coords_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to 'rayrender::generate_camera_motion()'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a circle in Monterey Bay and fly around on top of it
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50,water=TRUE,
         shadowcolor="#40310a", background = "tan",
         theta=210,  phi=22, zoom=0.40, fov=55)
         
moss_landing_coord = c(36.806807, -121.793332)
t = seq(0,2*pi,length.out=1000)
circle_coords_lat = moss_landing_coord[1] + 0.25 * sin(t)
circle_coords_long = moss_landing_coord[2] + 0.25  *  cos(t)
render_path(extent = attr(montereybay,"extent"), heightmap = montereybay,
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long),
           zscale=50, color="red", antialias=TRUE,
           offset=100, linewidth=2)
render_snapshot()

camera_path = convert_path_to_animation_coords(extent = attr(montereybay,"extent"), 
                                              heightmap = montereybay,
                                              lat = unlist(circle_coords_lat), 
                                              long = unlist(circle_coords_long),
                                              fovs = 80,
                                              zscale=50, offset=250, frames = 25)

#Render a series of frames, following the path specified above
temp_dir = tempdir()
render_highquality(samples=16, animation_camera_coords = camera_path, 
                  width=200,height=200, filename = sprintf("%s/frame",temp_dir),
                  use_extruded_paths = TRUE,
                  sample_method="sobol_blue")

#Plot all these frames
image_list = list()
for(i in 1:25) {
  image_list[[i]] = png::readPNG(sprintf("%s/frame%d.png",temp_dir,i))
}
rayimage::plot_image_grid(image_list, dim = c(5,5))
}

if(run_documentation()) {
#Now render a third-person view by setting `follow_camera = TRUE`
camera_path = convert_path_to_animation_coords(extent = attr(montereybay,"extent"), 
                                              heightmap = montereybay,
                                              lat = unlist(circle_coords_lat), 
                                              long = unlist(circle_coords_long),
                                              fovs = 80,
                                              follow_camera = TRUE,
                                              zscale=50, offset=250, frames = 25)

#Render a series of frames, following the path specified above
temp_dir = tempdir()
render_highquality(samples=16, animation_camera_coords = camera_path, 
                  width=200,height=200, filename = sprintf("%s/frame",temp_dir),
                  use_extruded_paths = TRUE,
                  sample_method="sobol_blue")

#Plot all these frames
image_list = list()
for(i in 1:25) {
  image_list[[i]] = png::readPNG(sprintf("%s/frame%d.png",temp_dir,i))
}
rayimage::plot_image_grid(image_list, dim = c(5,5))
}
</code></pre>

<hr>
<h2 id='convert_rgl_to_raymesh'>Convert rayshader RGL scene to ray_mesh object</h2><span id='topic+convert_rgl_to_raymesh'></span>

<h3>Description</h3>

<p>Converts the current RGL rayshader scene to a 'ray_mesh' object (see 'rayvertex' package for more information)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_rgl_to_raymesh(save_shadow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_rgl_to_raymesh_+3A_save_shadow">save_shadow</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this saves a plane with the shadow texture below the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ray_mesh' object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename_obj = tempfile(fileext = ".obj")
#Save model of volcano
if(run_documentation()) {
volcano %&gt;%
 sphere_shade() %&gt;%
 plot_3d(volcano, zscale = 2)

rm_obj = convert_rgl_to_raymesh()
}
</code></pre>

<hr>
<h2 id='create_texture'>Create Texture</h2><span id='topic+create_texture'></span>

<h3>Description</h3>

<p>Creates a texture map based on 5 user-supplied colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_texture(
  lightcolor,
  shadowcolor,
  leftcolor,
  rightcolor,
  centercolor,
  cornercolors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_texture_+3A_lightcolor">lightcolor</code></td>
<td>
<p>The main highlight color. Corresponds to the top center of the texture map.</p>
</td></tr>
<tr><td><code id="create_texture_+3A_shadowcolor">shadowcolor</code></td>
<td>
<p>The main shadow color. Corresponds to the bottom center of the texture map. This color represents slopes directed 
directly opposite to the main highlight color.</p>
</td></tr>
<tr><td><code id="create_texture_+3A_leftcolor">leftcolor</code></td>
<td>
<p>The left fill color. Corresponds to the left center of the texture map. This color represents slopes directed 
90 degrees to the left of the main highlight color.</p>
</td></tr>
<tr><td><code id="create_texture_+3A_rightcolor">rightcolor</code></td>
<td>
<p>The right fill color. Corresponds to the right center of the texture map. This color represents slopes directed 
90 degrees to the right of the main highlight color.</p>
</td></tr>
<tr><td><code id="create_texture_+3A_centercolor">centercolor</code></td>
<td>
<p>The center color. Corresponds to the center of the texture map. This color represents flat areas.</p>
</td></tr>
<tr><td><code id="create_texture_+3A_cornercolors">cornercolors</code></td>
<td>
<p>Default &lsquo;NULL'. The colors at the corners, in this order: NW, NE, SW, SE. If this vector isn&rsquo;t present (or
all corners are specified), the mid-points will just be interpolated from the main colors.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Here is the `imhof1` palette:
create_texture("#fff673","#55967a","#8fb28a","#55967a","#cfe0a9") %&gt;%
 plot_map()

#Here is the `unicorn` palette:
create_texture("red","green","blue","yellow","white") %&gt;%
 plot_map()
</code></pre>

<hr>
<h2 id='cross'>Cross Product</h2><span id='topic+cross'></span>

<h3>Description</h3>

<p>Cross Product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross(u, v)
</code></pre>


<h3>Value</h3>

<p>vec
</p>

<hr>
<h2 id='darken_color'>Darken Color</h2><span id='topic+darken_color'></span>

<h3>Description</h3>

<p>Convert RGB to XYZ color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>darken_color(col, darken = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="darken_color_+3A_col">col</code></td>
<td>
<p>RGB colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euler angles in degrees. c(phi,theta,yaw)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#None
</code></pre>

<hr>
<h2 id='detect_water'>Detect water</h2><span id='topic+detect_water'></span>

<h3>Description</h3>

<p>Detects bodies of water (of a user-defined minimum size) within an elevation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_water(
  heightmap,
  zscale = 1,
  cutoff = 0.999,
  min_area = length(heightmap)/400,
  max_height = NULL,
  normalvectors = NULL,
  keep_groups = FALSE,
  progbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_water_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. 
All grid points are assumed to be evenly spaced. Alternatively, if heightmap is a logical matrix, each entry
specifies whether that point is water or not.</p>
</td></tr>
<tr><td><code id="detect_water_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="detect_water_+3A_cutoff">cutoff</code></td>
<td>
<p>Default '0.999'. The lower limit of the z-component of the unit normal vector to be classified as water.</p>
</td></tr>
<tr><td><code id="detect_water_+3A_min_area">min_area</code></td>
<td>
<p>Default length(heightmap)/400. Minimum area (in units of the height matrix x and y spacing) to be considered a body of water.</p>
</td></tr>
<tr><td><code id="detect_water_+3A_max_height">max_height</code></td>
<td>
<p>Default 'NULL'. If passed, this number will specify the maximum height a point can be considered to be water.</p>
</td></tr>
<tr><td><code id="detect_water_+3A_normalvectors">normalvectors</code></td>
<td>
<p>Default 'NULL'. Pre-computed array of normal vectors from the 'calculate_normal' function. Supplying this will speed up water detection.</p>
</td></tr>
<tr><td><code id="detect_water_+3A_keep_groups">keep_groups</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the matrix returned will retain the numbered grouping information.</p>
</td></tr>
<tr><td><code id="detect_water_+3A_progbar">progbar</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', turns on progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix indicating whether water was detected at that point. 1 indicates water, 0 indicates no water.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
#Here we even out a portion of the volcano dataset to simulate water:
island_volcano = volcano
island_volcano[island_volcano &lt; mean(island_volcano)] = mean(island_volcano)

#Setting a minimum area avoids classifying small flat areas as water:
island_volcano %&gt;%
 sphere_shade(texture="imhof3") %&gt;%
 add_water(detect_water(island_volcano, min_area = 400),color="imhof3") %&gt;%
 plot_map()
</code></pre>

<hr>
<h2 id='drawkeyfunction_lines'>drawkeyfunction lines</h2><span id='topic+drawkeyfunction_lines'></span>

<h3>Description</h3>

<p>Required internal ggplot object for 3D ggplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawkeyfunction_lines(data, params, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawkeyfunction_lines_+3A_data">data</code></td>
<td>
<p>Data.</p>
</td></tr>
<tr><td><code id="drawkeyfunction_lines_+3A_params">params</code></td>
<td>
<p>Params.</p>
</td></tr>
<tr><td><code id="drawkeyfunction_lines_+3A_size">size</code></td>
<td>
<p>Sizes.</p>
</td></tr>
</table>

<hr>
<h2 id='drawkeyfunction_points'>drawkeyfunction points</h2><span id='topic+drawkeyfunction_points'></span>

<h3>Description</h3>

<p>Required internal ggplot object for 3D ggplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawkeyfunction_points(data, params, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawkeyfunction_points_+3A_data">data</code></td>
<td>
<p>Data.</p>
</td></tr>
<tr><td><code id="drawkeyfunction_points_+3A_params">params</code></td>
<td>
<p>Params.</p>
</td></tr>
<tr><td><code id="drawkeyfunction_points_+3A_size">size</code></td>
<td>
<p>Sizes.</p>
</td></tr>
</table>

<hr>
<h2 id='fix_manifold_geometry'>Fix Manifold Geometry</h2><span id='topic+fix_manifold_geometry'></span>

<h3>Description</h3>

<p>Writes the textured 3D rayshader visualization to an OBJ file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_manifold_geometry(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_manifold_geometry_+3A_filename">filename</code></td>
<td>
<p>String with the filename. If '.obj' is not at the end of the string, it will be appended automatically.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Test
</code></pre>

<hr>
<h2 id='flag_banner_obj'>Flag Banner 3D Model</h2><span id='topic+flag_banner_obj'></span>

<h3>Description</h3>

<p>3D obj model of a flag (sans pole), to be used with 'render_obj()'. Use 'flag_full_obj()' to get the complete
pole, and 'flag_banner_obj()' and 'flag_pole_obj()' to style them separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_banner_obj()
</code></pre>


<h3>Value</h3>

<p>File location of the included flag OBJ file (saved with a .txt extension)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Print the location of the flag file
flag_banner_obj()
</code></pre>

<hr>
<h2 id='flag_full_obj'>Flag 3D Model</h2><span id='topic+flag_full_obj'></span>

<h3>Description</h3>

<p>3D obj model of a flag, to be used with 'render_obj()'. Use 'flag_full_obj()' to get the complete
pole, and 'flag_banner_obj()' and 'flag_pole_obj()' to style them separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_full_obj()
</code></pre>


<h3>Value</h3>

<p>File location of the included flag OBJ file (saved with a .txt extension)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Print the location of the flag file
flag_full_obj()
</code></pre>

<hr>
<h2 id='flag_pole_obj'>Flag Pole 3D Model</h2><span id='topic+flag_pole_obj'></span>

<h3>Description</h3>

<p>3D obj model of a flag pole, to be used with 'render_obj()'. Use 'full_flag_obj()' to get the complete
pole, and 'flag_banner_obj()' and 'flag_pole_obj()' to style them separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_pole_obj()
</code></pre>


<h3>Value</h3>

<p>File location of the included flag OBJ file (saved with a .txt extension)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Print the location of the flag file
flag_pole_obj()
</code></pre>

<hr>
<h2 id='fliplr'>Flip Left-Right</h2><span id='topic+fliplr'></span>

<h3>Description</h3>

<p>Flip Left-Right
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fliplr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fliplr_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='flipud'>Flip Up-Down</h2><span id='topic+flipud'></span>

<h3>Description</h3>

<p>Flip Up-Down
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipud(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipud_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='gen_fractal_perlin'>Generate Fractal Perlin Noise</h2><span id='topic+gen_fractal_perlin'></span>

<h3>Description</h3>

<p>Generate Fractal Perlin Noise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_fractal_perlin(
  ray_d,
  xyz,
  altitude,
  nrow = NULL,
  ncol = NULL,
  t_mat = NULL,
  levels = 8,
  inc = 100,
  freq = 0.01/2,
  seed = 1,
  time = 0,
  scale_x = 1,
  scale_y = 1,
  scale_z = 1
)
</code></pre>


<h3>Value</h3>

<p>image array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='generate_altitude_overlay'>Generate Altitude Overlay</h2><span id='topic+generate_altitude_overlay'></span>

<h3>Description</h3>

<p>Using a hillshade and the height map, generates a semi-transparent hillshade to
layer onto an existing map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_altitude_overlay(
  hillshade,
  heightmap,
  start_transition,
  end_transition = NULL,
  lower = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_altitude_overlay_+3A_hillshade">hillshade</code></td>
<td>
<p>The hillshade to transition into.</p>
</td></tr>
<tr><td><code id="generate_altitude_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All grid points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="generate_altitude_overlay_+3A_start_transition">start_transition</code></td>
<td>
<p>Elevation above which 'hillshade' is completely transparent.</p>
</td></tr>
<tr><td><code id="generate_altitude_overlay_+3A_end_transition">end_transition</code></td>
<td>
<p>Default 'NULL'. Elevation below which 'hillshade' is completely opaque. By default, this is equal to 'start_transition'.</p>
</td></tr>
<tr><td><code id="generate_altitude_overlay_+3A_lower">lower</code></td>
<td>
<p>Default 'TRUE'. This makes 'hillshade' completely opaque below 'start_transition'. If
'FALSE', the direction will be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4-layer RGB array representing the semi-transparent hillshade.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a bathymetric hillshade
if(run_documentation()) {
water_palette = colorRampPalette(c("darkblue", "dodgerblue", "lightblue"))(200)
bathy_hs = height_shade(montereybay, texture = water_palette)
plot_map(bathy_hs)
}

if(run_documentation()) {
#Set everything below 0m to water palette
montereybay %&gt;%
 sphere_shade(zscale=10) %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}

#Add snow peaks by setting `lower = FALSE`  
snow_palette = "white"
snow_hs = height_shade(montereybay, texture = snow_palette)

if(run_documentation()) {
#Set the snow transition region from 500m to 1200m
montereybay %&gt;%
 sphere_shade(zscale=10, texture = "desert") %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_overlay(generate_altitude_overlay(snow_hs, montereybay, 500, 1200, lower=FALSE))  %&gt;%
 add_shadow(ambient_shade(montereybay,zscale=50,maxsearch=100),0) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='generate_base_shape'>Generate Base Shape</h2><span id='topic+generate_base_shape'></span>

<h3>Description</h3>

<p>Generate Base Shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_base_shape(heightmap, baseshape, angle = 0)
</code></pre>


<h3>Value</h3>

<p>image array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='generate_cloud_layer'>Calculate a single raymarched cloud layer</h2><span id='topic+generate_cloud_layer'></span>

<h3>Description</h3>

<p>Calculate a single raymarched cloud layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_cloud_layer(
  heightmap,
  sun_altitude = 90,
  sun_angle = 315,
  levels = 8,
  offset_x = 0,
  offset_y = 0,
  time = 0,
  start_altitude = 1000,
  end_altitude = 2500,
  alpha_coef = 0.8,
  scale_x = 1,
  scale_y = 1,
  scale_z = 1,
  freq = 0.01/2,
  coef = 0.05,
  seed = 1
)
</code></pre>


<h3>Value</h3>

<p>image array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='generate_compass_overlay'>Generate Compass Overlay</h2><span id='topic+generate_compass_overlay'></span>

<h3>Description</h3>

<p>This adds the compass
</p>
<p>Based on code from &quot;Auxiliary Cartographic Functions in R: North Arrow, Scale Bar, and Label with a Leader Arrow&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_compass_overlay(
  x = 0.85,
  y = 0.15,
  size = 0.075,
  text_size = 1,
  bearing = 0,
  heightmap = NULL,
  width = NA,
  height = NA,
  resolution_multiply = 1,
  color1 = "white",
  color2 = "black",
  text_color = "black",
  border_color = "black",
  border_width = 1,
  halo_color = NA,
  halo_expand = 1,
  halo_alpha = 1,
  halo_offset = c(0, 0),
  halo_blur = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_compass_overlay_+3A_x">x</code></td>
<td>
<p>Default 'NULL'. The horizontal percentage across the map (measured from the bottom-left corner) where
the compass is located.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_y">y</code></td>
<td>
<p>Default 'NULL'. The vertical percentage across the map (measured from the bottom-left corner) where
the compass is located.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_size">size</code></td>
<td>
<p>Default '0.05'. Size of the compass, in percentage of the map size..</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_text_size">text_size</code></td>
<td>
<p>Default '1'. Text size.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_bearing">bearing</code></td>
<td>
<p>Default '0'. Angle (in degrees) of north.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. The original height map. Pass this in to extract the dimensions of the resulting 
RGB image array automatically.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_width">width</code></td>
<td>
<p>Default 'NA'. Width of the resulting image array. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_height">height</code></td>
<td>
<p>Default 'NA'. Width of the resulting image array. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_resolution_multiply">resolution_multiply</code></td>
<td>
<p>Default '1'. If passing in 'heightmap' instead of width/height, amount to 
increase the resolution of the overlay, which should make lines/polygons finer. 
Should be combined with 'add_overlay(rescale_original = TRUE)' to ensure those added details are captured
in the final map.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_color1">color1</code></td>
<td>
<p>Default 'white'. Primary color of the compass.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_color2">color2</code></td>
<td>
<p>Default 'black'. Secondary color of the symcompass.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_text_color">text_color</code></td>
<td>
<p>Default 'black'. Text color.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_border_color">border_color</code></td>
<td>
<p>Default 'black'. Border color of the scale bar.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_border_width">border_width</code></td>
<td>
<p>Default '1'. Width of the scale bar border.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_halo_color">halo_color</code></td>
<td>
<p>Default 'NA', no halo. If a color is specified, the compass will be surrounded by a halo
of this color.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_halo_expand">halo_expand</code></td>
<td>
<p>Default '1'. Number of pixels to expand the halo.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_halo_alpha">halo_alpha</code></td>
<td>
<p>Default '1'. Transparency of the halo.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_halo_offset">halo_offset</code></td>
<td>
<p>Default 'c(0,0)'. Horizontal and vertical offset to apply to the halo, in percentage of the image.</p>
</td></tr>
<tr><td><code id="generate_compass_overlay_+3A_halo_blur">halo_blur</code></td>
<td>
<p>Default &lsquo;1'. Amount of blur to apply to the halo. Values greater than '30' won&rsquo;t result in further blurring.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Semi-transparent overlay with a compass.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Create the water palette
water_palette = colorRampPalette(c("darkblue", "dodgerblue", "lightblue"))(200)
bathy_hs = height_shade(montereybay, texture = water_palette)

#Generate flat water heightmap
mbay = montereybay
mbay[mbay &lt; 0] = 0

base_map = mbay %&gt;% 
 height_shade() %&gt;% 
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_shadow(lamb_shade(montereybay,zscale=50),0.3)
 
#Plot a compass
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay)) %&gt;% 
 plot_map()
}

if(run_documentation()) {
#Change the position to be over the water
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15)) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Change the text color for visibility
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15, text_color="white")) %&gt;% 
 plot_map()
} 
if(run_documentation()) {
#Alternatively, add a halo color to improve contrast
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15, y=0.15,
             halo_color="white", halo_expand = 1)) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Alternatively, add a halo color to improve contrast
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15, y=0.15,
             halo_color="white", halo_expand = 1)) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Change the color scheme
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15, y=0.15,
             halo_color="white", halo_expand = 1, color1 = "purple", color2 = "red")) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Remove the inner border
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15, y=0.15,
             border_color=NA,
             halo_color="white", halo_expand = 1, 
             color1 = "darkolivegreen4", color2 = "burlywood3")) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Change the size of the compass and text
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.75, y=0.75,
             halo_color="white", halo_expand = 1, 
             size=0.075*2, text_size = 1.25)) %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.45, y=0.45,
             halo_color="white", halo_expand = 1, 
             size=0.075)) %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15, y=0.15,
             halo_color="white", halo_expand = 1, 
             size=0.075/2, text_size = 0.75)) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Change the bearing of the compass
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.85, y=0.85,
             halo_color="white", halo_expand = 1, bearing=30,
             size=0.075)) %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.5, y=0.5,
             halo_color="white", halo_expand = 1, bearing=15,
             size=0.075)) %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15, y=0.15,
             halo_color="white", halo_expand = 1, bearing=-45,
             size=0.075)) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Create a drop shadow effect
base_map %&gt;% 
 add_overlay(generate_compass_overlay(heightmap = montereybay, x = 0.15, y=0.15,
             text_color="white", halo_alpha=0.5, halo_blur=2,
             halo_color="black", halo_expand = 1, halo_offset = c(0.003,-0.003))) %&gt;% 
 plot_map()
}
</code></pre>

<hr>
<h2 id='generate_contour_overlay'>Generate Contour Overlay</h2><span id='topic+generate_contour_overlay'></span>

<h3>Description</h3>

<p>Calculates and returns an overlay of contour lines for the current height map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_contour_overlay(
  heightmap,
  levels = NA,
  nlevels = NA,
  zscale = 1,
  width = NA,
  height = NA,
  resolution_multiply = 1,
  color = "black",
  linewidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_contour_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All grid points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="generate_contour_overlay_+3A_levels">levels</code></td>
<td>
<p>Default 'NA'. Automatically generated with 10 levels. This argument specifies the exact height levels of each contour.</p>
</td></tr>
<tr><td><code id="generate_contour_overlay_+3A_nlevels">nlevels</code></td>
<td>
<p>Default 'NA'. Controls the auto-generation of levels. If levels is length-2, 
this will automatically generate 'nlevels' breaks between 'levels[1]' and 'levels[2]'.</p>
</td></tr>
<tr><td><code id="generate_contour_overlay_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="generate_contour_overlay_+3A_width">width</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as heightmap.</p>
</td></tr>
<tr><td><code id="generate_contour_overlay_+3A_height">height</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as heightmap.</p>
</td></tr>
<tr><td><code id="generate_contour_overlay_+3A_resolution_multiply">resolution_multiply</code></td>
<td>
<p>Default '1'. If passing in 'heightmap' instead of width/height, amount to 
increase the resolution of the overlay, which should make lines/polygons finer. 
Should be combined with 'add_overlay(rescale_original = TRUE)' to ensure those added details are captured
in the final map.</p>
</td></tr>
<tr><td><code id="generate_contour_overlay_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color.</p>
</td></tr>
<tr><td><code id="generate_contour_overlay_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '1'. Line width.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Semi-transparent overlay with contours.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Add contours to the montereybay dataset
if(run_documentation()) {
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_contour_overlay(montereybay))  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}

#Add a different contour color for above and below water, and specify levels manually
water_palette = colorRampPalette(c("darkblue", "dodgerblue", "lightblue"))(200)
bathy_hs = height_shade(montereybay, texture = water_palette)
breaks = seq(range(montereybay)[1],range(montereybay)[2],length.out=50)
water_breaks = breaks[breaks &lt; 0]
land_breaks = breaks[breaks &gt; 0]

if(run_documentation()) {
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_contour_overlay(montereybay, levels = water_breaks, color="white"))  %&gt;%
 add_overlay(generate_contour_overlay(montereybay, levels = land_breaks, color="black"))  %&gt;%
 plot_map()
}
if(run_documentation()) {
#Increase the resolution of the contour to improve the appearance of lines
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_contour_overlay(montereybay, levels = water_breaks, color="white",
                                      height = nrow(montereybay)*2, 
                                      width  = ncol(montereybay)*2))  %&gt;%
 add_overlay(generate_contour_overlay(montereybay, levels = land_breaks, color="black",
                                      height = nrow(montereybay)*2, 
                                      width  = ncol(montereybay)*2))  %&gt;%
 plot_map()
}
if(run_documentation()) {
#Increase the number of breaks and the transparency (via add_overlay)
montereybay %&gt;%
 height_shade() %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_contour_overlay(montereybay, linewidth=2, nlevels=100,
                                      height = nrow(montereybay)*2, color="black",
                                      width  = ncol(montereybay)*2), alphalayer=0.5) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Manually specify the breaks with levels
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_contour_overlay(montereybay, linewidth=2, levels = seq(-2000,0,100))) %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='generate_label_overlay'>Generate Label Overlay</h2><span id='topic+generate_label_overlay'></span>

<h3>Description</h3>

<p>This uses the 'car::placeLabel()' function to generate labels for the given scene. Either
use an 'sf' object or manually specify the x/y coordinates and label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_label_overlay(
  labels,
  extent,
  x = NULL,
  y = NULL,
  heightmap = NULL,
  width = NA,
  height = NA,
  resolution_multiply = 1,
  text_size = 1,
  color = "black",
  font = 1,
  pch = 16,
  point_size = 1,
  point_color = NA,
  offset = c(0, 0),
  data_label_column = NULL,
  halo_color = NA,
  halo_expand = 0,
  halo_alpha = 1,
  halo_offset = c(0, 0),
  halo_blur = 1,
  seed = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_label_overlay_+3A_labels">labels</code></td>
<td>
<p>A character vector of labels, or an 'sf' object with 'POINT' geometry and a column for labels.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_x">x</code></td>
<td>
<p>Default 'NULL'. The x-coordinate, if 'labels' is not an 'sf' object.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_y">y</code></td>
<td>
<p>Default 'NULL'. The y-coordinate, if 'labels' is not an 'sf' object.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. The original height map. Pass this in to extract the dimensions of the resulting 
overlay automatically.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_width">width</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_height">height</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_resolution_multiply">resolution_multiply</code></td>
<td>
<p>Default '1'. If passing in 'heightmap' instead of width/height, amount to 
increase the resolution of the overlay, which should make lines/polygons/text finer. 
Should be combined with 'add_overlay(rescale_original = TRUE)' to ensure those added details are captured
in the final map.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_text_size">text_size</code></td>
<td>
<p>Default '1'. Text size.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the labels.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_font">font</code></td>
<td>
<p>Default '1'. An integer which specifies which font to use for text. 
If possible, device drivers arrange so that 1 corresponds to plain text (the default), 
2 to bold face, 3 to italic and 4 to bold italic.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_pch">pch</code></td>
<td>
<p>Default '20', solid. Point symbol. 
'0' = square, '1' = circle, '2' = triangle point up, '3' = plus, '4' = cross, 
'5' = diamond, '6' = triangle point down, '7' = square cross, '8' = star, 
'9' = diamond plus, '10' = circle plus, '11' = triangles up and down, 
'12' = square plus, '13' = circle cross, '14' = square and triangle down, 
'15' = filled square, '16' = filled circle, '17' = filled triangle point-up, 
'18' = filled diamond, '19' = solid circle, '20' = bullet (smaller circle), 
'21' = filled circle blue, '22' = filled square blue, '23' = filled diamond blue, 
'24' = filled triangle point-up blue, '25' = filled triangle point down blue</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_point_size">point_size</code></td>
<td>
<p>Default '0', no points. Point size.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_point_color">point_color</code></td>
<td>
<p>Default 'NA'. Colors of the points. Unless otherwise specified, this defaults to 'color'.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_offset">offset</code></td>
<td>
<p>Default 'c(0,0)'. Horizontal and vertical offset to apply to the label, in units of 'geometry'.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_data_label_column">data_label_column</code></td>
<td>
<p>Default 'NULL'. The column in the 'sf' object that contains the labels.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_halo_color">halo_color</code></td>
<td>
<p>Default 'NA', no halo. If a color is specified, the text label will be surrounded by a halo
of this color.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_halo_expand">halo_expand</code></td>
<td>
<p>Default '2'. Number of pixels to expand the halo.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_halo_alpha">halo_alpha</code></td>
<td>
<p>Default '1'. Transparency of the halo.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_halo_offset">halo_offset</code></td>
<td>
<p>Default 'c(0,0)'. Horizontal and vertical offset to apply to the halo, in units of 'geometry'.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_halo_blur">halo_blur</code></td>
<td>
<p>Default &lsquo;1'. Amount of blur to apply to the halo. Values greater than '30' won&rsquo;t result in further blurring.</p>
</td></tr>
<tr><td><code id="generate_label_overlay_+3A_seed">seed</code></td>
<td>
<p>Default 'NA', no seed. Random seed for ensuring the consistent placement of labels around points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Semi-transparent overlay with labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Add the included `sf` object with roads to the montereybay dataset
if(run_documentation()) {
#Create the water palette
water_palette = colorRampPalette(c("darkblue", "dodgerblue", "lightblue"))(200)
bathy_hs = height_shade(montereybay, texture = water_palette)
#Set label font
par(family = "Arial")

#We're plotting the polygon data here for counties around Monterey Bay. We'll first
#plot the county names at the polygon centroids.
bathy_hs %&gt;% 
 add_shadow(lamb_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_polygon_overlay(monterey_counties_sf, palette = rainbow, 
                                      extent = attr(montereybay,"extent"),
                                      heightmap = montereybay)) %&gt;% 
 add_overlay(generate_label_overlay(labels=monterey_counties_sf,
                                    color="black", point_size = 1, text_size = 1,
                                    data_label_column = "NAME",
                                    extent= attr(montereybay,"extent"), heightmap = montereybay,
                                    seed=1))  %&gt;%
 plot_map()
}
if(run_documentation()) {
#It's hard to read these values, so we'll add a white halo.
bathy_hs %&gt;% 
 add_shadow(lamb_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_polygon_overlay(monterey_counties_sf, palette = rainbow, 
                                      extent = attr(montereybay,"extent"),
                                      heightmap = montereybay)) %&gt;% 
 add_overlay(generate_label_overlay(labels=monterey_counties_sf,
                                    color="black", point_size = 1, text_size = 1,
                                    data_label_column = "NAME",
                                    extent= attr(montereybay,"extent"), heightmap = montereybay,
                                    halo_color = "white", halo_expand = 3,
                                    seed=1))  %&gt;%
 plot_map()
}
if(run_documentation()) {
#Plot the actual town locations, using the manual plotting interface instead of the `sf` object
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0)) %&gt;% 
 add_shadow(lamb_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_label_overlay(labels=as.character(monterey_counties_sf$NAME),
                                    x=as.numeric(as.character(monterey_counties_sf$INTPTLON)),
                                    y=as.numeric(as.character(monterey_counties_sf$INTPTLAT)),
                                    color="black", point_size = 1, text_size = 1,
                                    extent= attr(montereybay,"extent"), heightmap = montereybay,
                                    halo_color = "white", halo_expand = 3,
                                    seed=1))  %&gt;%
 plot_map()
}
if(run_documentation()) {
#Adding a softer blurred halo
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0)) %&gt;% 
 add_shadow(lamb_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_label_overlay(labels=as.character(monterey_counties_sf$NAME),
                                    x=as.numeric(as.character(monterey_counties_sf$INTPTLON)),
                                    y=as.numeric(as.character(monterey_counties_sf$INTPTLAT)),
                                    color="black", point_size = 1, text_size = 1,
                                    extent= attr(montereybay,"extent"), heightmap = montereybay,
                                    halo_color = "white", halo_expand = 3, halo_blur=10,
                                    seed=1))  %&gt;%
 plot_map()
}
if(run_documentation()) {
#Changing the seed changes the locations of the labels
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0)) %&gt;% 
 add_shadow(lamb_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_label_overlay(labels=as.character(monterey_counties_sf$NAME),
                                    x=as.numeric(as.character(monterey_counties_sf$INTPTLON)),
                                    y=as.numeric(as.character(monterey_counties_sf$INTPTLAT)),
                                    color="black", point_size = 1, text_size = 1,
                                    extent= attr(montereybay,"extent"), heightmap = montereybay,
                                    halo_color = "white", halo_expand = 3, halo_blur=10,
                                    seed=2))  %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='generate_line_overlay'>Generate Line Overlay</h2><span id='topic+generate_line_overlay'></span>

<h3>Description</h3>

<p>Calculates and returns an overlay of lines for the current height map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_line_overlay(
  geometry,
  extent,
  heightmap = NULL,
  width = NA,
  height = NA,
  resolution_multiply = 1,
  color = "black",
  linewidth = 1,
  lty = 1,
  data_column_width = NULL,
  offset = c(0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_line_overlay_+3A_geometry">geometry</code></td>
<td>
<p>An 'sf' object with LINESTRING geometry.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. The original height map. Pass this in to extract the dimensions of the resulting 
overlay automatically.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_width">width</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_height">height</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_resolution_multiply">resolution_multiply</code></td>
<td>
<p>Default '1'. If passing in 'heightmap' instead of width/height, amount to 
increase the resolution of the overlay, which should make lines/polygons/text finer. 
Should be combined with 'add_overlay(rescale_original = TRUE)' to ensure those added details are captured
in the final map.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the lines.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '1'. Line width.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_lty">lty</code></td>
<td>
<p>Default '1'. Line type. '1' is solid, '2' is dashed, '3' is dotted,'4' is dot-dash,
'5' is long dash, and '6' is dash-long-dash.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_data_column_width">data_column_width</code></td>
<td>
<p>Default 'NULL'. The numeric column to map the width to. The maximum width will be the value
specified in 'linewidth'.</p>
</td></tr>
<tr><td><code id="generate_line_overlay_+3A_offset">offset</code></td>
<td>
<p>Default 'c(0,0)'. Horizontal and vertical offset to apply to the line, in units of 'geometry'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Semi-transparent overlay with contours.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Add the included `sf` object with roads to the montereybay dataset
if(run_documentation()) {
water_palette = colorRampPalette(c("darkblue", "dodgerblue", "lightblue"))(200)
bathy_hs = height_shade(montereybay, texture = water_palette)
montereybay %&gt;% 
 height_shade() %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_overlay(generate_line_overlay(monterey_roads_sf, 
                                   attr(montereybay,"extent"), heightmap = montereybay))  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Change the line width, color, and transparency
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_overlay(generate_line_overlay(monterey_roads_sf, linewidth=3, color="white",
                                   attr(montereybay,"extent"), heightmap = montereybay),
                                   alphalayer=0.8)  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Manually specify the width and height to improve visual quality of the lines
montereybay %&gt;%
 height_shade() %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 add_overlay(generate_line_overlay(monterey_roads_sf, linewidth=3, color="white",
                                   attr(montereybay,"extent"), width = 1080, height = 1080),
                                   alphalayer=0.8)  %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='generate_point_overlay'>Generate Point Overlay</h2><span id='topic+generate_point_overlay'></span>

<h3>Description</h3>

<p>Calculates and returns an overlay of points for the current map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_point_overlay(
  geometry,
  extent,
  heightmap = NULL,
  width = NA,
  height = NA,
  resolution_multiply = 1,
  pch = 20,
  color = "black",
  size = 1,
  offset = c(0, 0),
  data_column_width = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_point_overlay_+3A_geometry">geometry</code></td>
<td>
<p>An 'sf' object with POINT geometry.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. The original height map. Pass this in to extract the dimensions of the resulting 
overlay automatically.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_width">width</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_height">height</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_resolution_multiply">resolution_multiply</code></td>
<td>
<p>Default '1'. If passing in 'heightmap' instead of width/height, amount to 
increase the resolution of the overlay, which should make lines/polygons/points finer. 
Should be combined with 'add_overlay(rescale_original = TRUE)' to ensure those added details are captured
in the final map.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_pch">pch</code></td>
<td>
<p>Default '20', solid. Point symbol. 
'0' = square, '1' = circle, '2' = triangle point up, '3' = plus, '4' = cross, 
'5' = diamond, '6' = triangle point down, '7' = square cross, '8' = star, 
'9' = diamond plus, '10' = circle plus, '11' = triangles up and down, 
'12' = square plus, '13' = circle cross, '14' = square and triangle down, 
'15' = filled square, '16' = filled circle, '17' = filled triangle point-up, 
'18' = filled diamond, '19' = solid circle, '20' = bullet (smaller circle), 
'21' = filled circle blue, '22' = filled square blue, '23' = filled diamond blue, 
'24' = filled triangle point-up blue, '25' = filled triangle point down blue</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the points.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_size">size</code></td>
<td>
<p>Default '1'. Point size.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_offset">offset</code></td>
<td>
<p>Default 'c(0,0)'. Horizontal and vertical offset to apply to the polygon, in units of 'geometry'.</p>
</td></tr>
<tr><td><code id="generate_point_overlay_+3A_data_column_width">data_column_width</code></td>
<td>
<p>Default 'NULL'. The numeric column to map the width to. The maximum width will be the value
specified in 'linewidth'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Semi-transparent overlay with contours.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Add the included `sf` object with roads to the montereybay dataset
if(run_documentation()) {
 monterey_city = sf::st_sfc(sf::st_point(c(-121.893611, 36.603056)))
 montereybay %&gt;% 
   height_shade() %&gt;%
   add_overlay(generate_point_overlay(monterey_city, color="red", size=12, 
                                   attr(montereybay,"extent"), heightmap = montereybay))  %&gt;%
   add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
   plot_map()
}
</code></pre>

<hr>
<h2 id='generate_polygon_overlay'>Generate Polygon Overlay</h2><span id='topic+generate_polygon_overlay'></span>

<h3>Description</h3>

<p>Transforms an input 'sf' object into an image overlay for the current height map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_polygon_overlay(
  geometry,
  extent,
  heightmap = NULL,
  width = NA,
  height = NA,
  resolution_multiply = 1,
  offset = c(0, 0),
  data_column_fill = NULL,
  linecolor = "black",
  palette = "white",
  linewidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_polygon_overlay_+3A_geometry">geometry</code></td>
<td>
<p>An 'sf' object with POLYGON geometry.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. The original height map. Pass this in to extract the dimensions of the resulting 
overlay automatically.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_width">width</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_height">height</code></td>
<td>
<p>Default 'NA'. Width of the resulting overlay. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_resolution_multiply">resolution_multiply</code></td>
<td>
<p>Default '1'. If passing in 'heightmap' instead of width/height, amount to 
increase the resolution of the overlay, which should make lines/polygons/text finer. 
Should be combined with 'add_overlay(rescale_original = TRUE)' to ensure those added details are captured
in the final map.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_offset">offset</code></td>
<td>
<p>Default 'c(0,0)'. Horizontal and vertical offset to apply to the polygon, in units of 'geometry'.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_data_column_fill">data_column_fill</code></td>
<td>
<p>Default 'NULL'. The column to map the polygon fill color to.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_linecolor">linecolor</code></td>
<td>
<p>Default 'black'. Color of the lines.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_palette">palette</code></td>
<td>
<p>Default 'black'. Single color, named vector color palette, or palette function. 
If this is a named vector and 'data_column_fill' is not 'NULL', 
it will map the colors in the vector to the names. If 'data_column_fill' is a numeric column,
this will give a continuous mapping.</p>
</td></tr>
<tr><td><code id="generate_polygon_overlay_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '1'. Line width.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Image overlay representing the input polygon data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Plot the counties around Monterey Bay, CA
if(run_documentation()) {
generate_polygon_overlay(monterey_counties_sf, palette = rainbow, 
                        extent = attr(montereybay,"extent"), heightmap = montereybay) %&gt;%
 plot_map() 
}
if(run_documentation()) {
#These counties include the water, so we'll plot bathymetry data over the polygon
#data to only include parts of the polygon that fall on land.
water_palette = colorRampPalette(c("darkblue", "dodgerblue", "lightblue"))(200)
bathy_hs = height_shade(montereybay, texture = water_palette)

generate_polygon_overlay(monterey_counties_sf, palette = rainbow, 
                        extent = attr(montereybay,"extent"), heightmap = montereybay) %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, start_transition = 0)) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Add a semi-transparent hillshade and change the palette, and remove the polygon lines
montereybay %&gt;%
 sphere_shade(texture = "bw") %&gt;%
 add_overlay(generate_polygon_overlay(monterey_counties_sf, 
                        palette = terrain.colors, linewidth=NA,
                        extent = attr(montereybay,"extent"), heightmap = montereybay),
                        alphalayer=0.7) %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, start_transition = 0)) %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Map one of the variables in the sf object and use an explicitly defined color palette
county_palette = c("087" = "red",    "053" = "blue",   "081" = "green", 
                  "069" = "yellow", "085" = "orange", "099" = "purple") 
montereybay %&gt;%
 sphere_shade(texture = "bw") %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0) %&gt;%
 add_overlay(generate_polygon_overlay(monterey_counties_sf, linecolor="white", linewidth=3,
                        palette = county_palette, data_column_fill = "COUNTYFP",
                        extent = attr(montereybay,"extent"), heightmap = montereybay),
                        alphalayer=0.7) %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, start_transition = 0)) %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.5) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='generate_rot_matrix'>Generate Rotation Matrix</h2><span id='topic+generate_rot_matrix'></span>

<h3>Description</h3>

<p>Generate Rotation Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_rot_matrix(angle, order_rotation = c(1, 2, 3))
</code></pre>


<h3>Value</h3>

<p>mat
</p>

<hr>
<h2 id='generate_scalebar_overlay'>Generate Scalebar Overlay</h2><span id='topic+generate_scalebar_overlay'></span>

<h3>Description</h3>

<p>This function creates an overlay with a scale bar of a user-specified length. 
It uses the coordinates of the map (specified by passing an extent) 
and then creates a scale bar at a specified x/y proportion across the map. If the map is not projected
(i.e. is in lat/long coordinates) this function will use the 'geosphere' package to create a 
scale bar of the proper length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_scalebar_overlay(
  extent,
  length,
  x = 0.05,
  y = 0.05,
  latlong = FALSE,
  thickness = NA,
  bearing = 90,
  unit = "m",
  flip_ticks = FALSE,
  labels = NA,
  text_size = 1,
  decimals = 0,
  text_offset = 1,
  adj = 0.5,
  heightmap = NULL,
  width = NA,
  height = NA,
  resolution_multiply = 1,
  color1 = "white",
  color2 = "black",
  text_color = "black",
  font = 1,
  border_color = "black",
  tick_color = "black",
  border_width = 1,
  tick_width = 1,
  halo_color = NA,
  halo_expand = 1,
  halo_alpha = 1,
  halo_offset = c(0, 0),
  halo_blur = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_scalebar_overlay_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object. If this is in
lat/long coordinates, be sure to set 'latlong = TRUE'.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_length">length</code></td>
<td>
<p>The length of the scale bar, in 'units'. This should match the units used on the map, 
unless 'extent' uses lat/long coordinates. In that case, the distance should be in meters.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_x">x</code></td>
<td>
<p>Default '0.05'. The x-coordinate of the bottom-left corner of the scale bar, as a proportion of the full map width.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_y">y</code></td>
<td>
<p>Default '0.05'. The y-coordinate of the bottom-left corner of the scale bar, as a proportion of the full map height.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_latlong">latlong</code></td>
<td>
<p>Default 'FALSE'. Set to 'TRUE' if the map is in lat/long coordinates to get an accurate
scale bar (using distance calculated with the 'geosphere' package).</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_thickness">thickness</code></td>
<td>
<p>Default 'NA', automatically computed as 1/20th the length of the scale bar. Width of the scale bar.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_bearing">bearing</code></td>
<td>
<p>Default '90', horizontal. Direction (measured from north) of the scale bar.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_unit">unit</code></td>
<td>
<p>Default 'm'. Displayed unit on the scale bar.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_flip_ticks">flip_ticks</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the ticks to the other side of the scale bar.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_labels">labels</code></td>
<td>
<p>Default 'NA'. Manually specify the three labels with a length-3 character vector. 
Use this if you want display units other than meters.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_text_size">text_size</code></td>
<td>
<p>Default '1'. Text size.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_decimals">decimals</code></td>
<td>
<p>Default '0'. Number of decimal places for scale bar labels.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_text_offset">text_offset</code></td>
<td>
<p>Default '1'. Amount of offset to apply to the text from the scale bar, as a multiple of
'thickness'.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_adj">adj</code></td>
<td>
<p>Default '0.5', centered. Text justification. '0' is left-justified, and '1' is right-justified.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. The original height map. Pass this in to extract the dimensions of the resulting 
RGB image array automatically.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_width">width</code></td>
<td>
<p>Default 'NA'. Width of the resulting image array. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_height">height</code></td>
<td>
<p>Default 'NA'. Width of the resulting image array. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_resolution_multiply">resolution_multiply</code></td>
<td>
<p>Default '1'. If passing in 'heightmap' instead of width/height, amount to 
increase the resolution of the overlay, which should make lines/polygons/text finer. 
Should be combined with 'add_overlay(rescale_original = TRUE)' to ensure those added details are captured
in the final map.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_color1">color1</code></td>
<td>
<p>Default 'black'. Primary color of the scale bar.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_color2">color2</code></td>
<td>
<p>Default 'white'. Secondary color of the scale bar.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_text_color">text_color</code></td>
<td>
<p>Default 'black'. Text color.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_font">font</code></td>
<td>
<p>Default '1'. An integer which specifies which font to use for text. 
If possible, device drivers arrange so that 1 corresponds to plain text (the default), 
2 to bold face, 3 to italic and 4 to bold italic.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_border_color">border_color</code></td>
<td>
<p>Default 'black'. Border color of the scale bar.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_tick_color">tick_color</code></td>
<td>
<p>Default 'black'. Tick color of the scale bar.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_border_width">border_width</code></td>
<td>
<p>Default '1'. Width of the scale bar border.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_tick_width">tick_width</code></td>
<td>
<p>Default '1'. Width of the tick.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_halo_color">halo_color</code></td>
<td>
<p>Default 'NA', no halo. If a color is specified, the text label will be surrounded by a halo
of this color.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_halo_expand">halo_expand</code></td>
<td>
<p>Default '1'. Number of pixels to expand the halo.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_halo_alpha">halo_alpha</code></td>
<td>
<p>Default '1'. Transparency of the halo.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_halo_offset">halo_offset</code></td>
<td>
<p>Default 'c(0,0)'. Horizontal and vertical offset to apply to the halo, as a proportion of the full scene.</p>
</td></tr>
<tr><td><code id="generate_scalebar_overlay_+3A_halo_blur">halo_blur</code></td>
<td>
<p>Default &lsquo;1'. Amount of blur to apply to the halo. Values greater than '30' won&rsquo;t result in further blurring.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Semi-transparent overlay with a scale bar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Create the water palette
water_palette = colorRampPalette(c("darkblue", "dodgerblue", "lightblue"))(200)
bathy_hs = height_shade(montereybay, texture = water_palette)
#Set scalebar font
par(family = "Arial")

#Generate flat water heightmap
mbay = montereybay
mbay[mbay &lt; 0] = 0

base_map = mbay %&gt;%
height_shade() %&gt;%
add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
add_shadow(lamb_shade(montereybay,zscale=50),0.3)

#For convenience, the extent of the montereybay dataset is included as an attribute
mb_extent = attr(montereybay, "extent")

#Add a scalebar
base_map %&gt;%
add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 40000,
                                      heightmap = montereybay, 
                                      latlong=TRUE)) %&gt;%
plot_map()
}
if(run_documentation()) {
#Change the text color
base_map %&gt;%
 add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 40000,
                                       text_color = "white",
                                       heightmap = montereybay, 
                                       latlong=TRUE)) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Change the length
base_map %&gt;%
 add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 30000,
                                       text_color = "white",
                                       heightmap = montereybay, 
                                       latlong=TRUE)) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Change the thickness (default is length/20)
base_map %&gt;%
 add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 30000,
                                       text_color = "white", thickness = 30000/10,
                                       heightmap = montereybay, 
                                       latlong=TRUE)) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Change the text offset (given in multiples of thickness)
base_map %&gt;%
 add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 30000,
                                       text_color = "white", thickness = 30000/10,
                                       text_offset = 0.75,
                                       heightmap = montereybay, 
                                       latlong=TRUE)) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Change the primary and secondary colors, along with the border and tick color
base_map %&gt;%
 add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 30000,
                                       text_color = "white", border_color = "white",
                                       tick_color = "white",
                                       color1 = "darkolivegreen4", color2 = "burlywood3",
                                       heightmap = montereybay, 
                                       latlong=TRUE)) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Add a halo
base_map %&gt;%
 add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 40000,
                                       halo_color = "white", halo_expand = 1,
                                       heightmap = montereybay, 
                                       latlong=TRUE)) %&gt;%
 plot_map()
}
if(run_documentation()) {
#Change the orientation, position, text alignment, and flip the ticks to the other side
base_map %&gt;%
 add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 40000, x = 0.07,
                                       bearing=0, adj = 0, flip_ticks = TRUE,
                                       halo_color = "white", halo_expand = 1.5,
                                       heightmap = montereybay, 
                                       latlong=TRUE)) %&gt;%
 plot_map()
}
if(run_documentation()) { 
#64373.8 meters in 40 miles
#Create custom labels, change font and text size, remove the border/ticks, and change the color
#Here, we specify a width and height to double the resolution of the image (for sharper text)
base_map %&gt;%
 add_overlay(generate_scalebar_overlay(extent = mb_extent, length = 64373.8, x = 0.07,
                                       labels = c("0", "20", "40 miles"), thickness=2500,
                                       text_size=3, font = 2, text_offset = 0,
                                       text_color="white", color2="#bf323b", border_color=NA,
                                       tick_color="red", tick_width=0,
                                       bearing=0, adj = 0, flip_ticks = TRUE,
                                       halo_color="black", halo_blur=3, halo_alpha=0.5,
                                       width = ncol(montereybay)*2,
                                       height = nrow(montereybay)*2,
                                       latlong=TRUE), rescale_original=TRUE) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='generate_soil_textures'>Generate Soil Textures</h2><span id='topic+generate_soil_textures'></span>

<h3>Description</h3>

<p>Makes the base below the 3D elevation map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_soil_textures(
  heightmap,
  base_depth = 10,
  color1 = "#7d6f5b",
  color2 = "#3b3020",
  freq = 0.1,
  zscale = 1,
  levels = 8,
  soil_gradient = 0,
  gradient_darken = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_soil_textures_+3A_heightmap">heightmap</code></td>
<td>
<p>Height matrix;</p>
</td></tr>
<tr><td><code id="generate_soil_textures_+3A_color1">color1</code></td>
<td>
<p>Default 'tan'.</p>
</td></tr>
<tr><td><code id="generate_soil_textures_+3A_color2">color2</code></td>
<td>
<p>Default 'brown'.</p>
</td></tr>
<tr><td><code id="generate_soil_textures_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
</table>

<hr>
<h2 id='generate_surface'>generate_surface</h2><span id='topic+generate_surface'></span>

<h3>Description</h3>

<p>Makes the base below the 3D elevation map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_surface(heightmap, zscale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_surface_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="generate_surface_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
</table>

<hr>
<h2 id='generate_waterline_overlay'>Generate Waterline Overlay</h2><span id='topic+generate_waterline_overlay'></span>

<h3>Description</h3>

<p>Using a height map or a boolean matrix, generates a semi-transparent waterline overlay to
layer onto an existing map. This uses the method described by P. Felzenszwalb &amp; D. Huttenlocher in 
&quot;Distance Transforms of Sampled Functions&quot; (Theory of Computing, Vol. 8, No. 19, September 2012) 
to calculate the distance to the coast. This distance matrix can be returned directly by setting 
the 'return_distance_matrix' argument to 'TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_waterline_overlay(
  heightmap,
  color = "white",
  linewidth = 1,
  boolean = FALSE,
  min = 0.001,
  max = 0.2,
  breaks = 9,
  smooth = 0,
  fade = TRUE,
  alpha_dist = max,
  alpha = 1,
  falloff = 1.3,
  evenly_spaced = FALSE,
  zscale = 1,
  cutoff = 0.999,
  width = NA,
  height = NA,
  resolution_multiply = 1,
  min_area = length(heightmap)/400,
  max_height = NULL,
  return_distance_matrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_waterline_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. 
If 'boolean = TRUE', this will instead be interpreted as a logical matrix indicating areas of water.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_color">color</code></td>
<td>
<p>Default 'white'. Color of the lines.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '1'. Line width.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_boolean">boolean</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this is a boolean matrix (0 and 1) indicating contiguous areas in 
which the lines are generated (instead of a height matrix, from which the boolean matrix is derived using 'detect_water()')</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_min">min</code></td>
<td>
<p>Default '0.001'. Percent distance (measured from the furthest point from shore) where the waterlines stop.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_max">max</code></td>
<td>
<p>Default '0.2'. Percent distance (measured from the furthest point from shore) where the waterlines begin.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_breaks">breaks</code></td>
<td>
<p>Default '9'. Number of water lines.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_smooth">smooth</code></td>
<td>
<p>Default '0', no smoothing. Increase this to smooth water lines around corners.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_fade">fade</code></td>
<td>
<p>Default 'TRUE'. If 'FALSE', lines will not fade with distance from shore.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_alpha_dist">alpha_dist</code></td>
<td>
<p>Default to the value specified in 'max'. Percent distance (measured from the furthest point from shore) where the 
waterlines fade entirely, when 'fade = TRUE'.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_alpha">alpha</code></td>
<td>
<p>Default '1'. Maximum transparency for waterlines. This scales the transparency for all other levels.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_falloff">falloff</code></td>
<td>
<p>Default '1.3'. Multiplicative decrease in distance between each waterline level.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_evenly_spaced">evenly_spaced</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', 'falloff' will be ignored and the lines will be evenly spaced.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. Arguments passed to 'detect_water()'. Ignored if 'boolean = TRUE'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_cutoff">cutoff</code></td>
<td>
<p>Default '0.999'. Arguments passed to 'detect_water()'. Ignored if 'boolean = TRUE'.The lower limit of the z-component of the unit normal vector to be classified as water.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_width">width</code></td>
<td>
<p>Default 'NA'. Width of the resulting image array. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_height">height</code></td>
<td>
<p>Default 'NA'. Width of the resulting image array. Default the same dimensions as height map.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_resolution_multiply">resolution_multiply</code></td>
<td>
<p>Default '1'. If passing in 'heightmap' instead of width/height, amount to 
increase the resolution of the overlay, which should make lines/polygons/text finer. 
Should be combined with 'add_overlay(rescale_original = TRUE)' to ensure those added details are captured
in the final map.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_min_area">min_area</code></td>
<td>
<p>Default 'length(heightmap)/400'. Arguments passed to 'detect_water()'. Ignored if 'boolean = TRUE'. Minimum area (in units of the height matrix x and y spacing) to be considered a body of water.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_max_height">max_height</code></td>
<td>
<p>Default 'NULL'. Arguments passed to 'detect_water()'. Ignored if 'boolean = TRUE'. If passed, this number will specify the maximum height a point can be considered to be water.
'FALSE', the direction will be reversed.</p>
</td></tr>
<tr><td><code id="generate_waterline_overlay_+3A_return_distance_matrix">return_distance_matrix</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this function will return the boolean distance matrix instead of
contour lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4-layer RGB array representing the waterline overlay.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Create a flat body of water for Monterey Bay
montbay = montereybay
montbay[montbay &lt; 0] = 0

#Generate base map with no lines
basemap = montbay %&gt;%
  height_shade() %&gt;%
  add_water(detect_water(montbay), color="dodgerblue") %&gt;%
  add_shadow(texture_shade(montbay, detail=1/3, brightness = 15, contrast = 5),0) %&gt;%
  add_shadow(lamb_shade(montbay,zscale=50),0) 

plot_map(basemap)
}
if(run_documentation()) {
#Add waterlines
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay)) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Change minimum line distance:
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay, min = 0.02)) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Change maximum line distance
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay, max = 0.4)) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Smooth waterlines
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay, max = 0.4, smooth=2)) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Increase number of breaks
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay, breaks = 20, max=0.4)) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Make lines evenly spaced:
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay, evenly_spaced = TRUE)) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Change variable distance between each line
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay, falloff=1.5)) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Turn off fading
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay, fade=FALSE)) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Fill up the entire body of water with lines and make them all 50% transparent
basemap %&gt;% 
  add_overlay(generate_waterline_overlay(montbay, fade=FALSE, max=1, alpha = 0.5, color="white",
                                         evenly_spaced = TRUE, breaks=50)) %&gt;% 
  plot_map()
}
</code></pre>

<hr>
<h2 id='get_extent'>Get Extent</h2><span id='topic+get_extent'></span>

<h3>Description</h3>

<p>Get Extent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_extent(extent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_extent_+3A_extent">extent</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bounding box
</p>

<hr>
<h2 id='get_ids_with_labels'>Get IDs with Labels</h2><span id='topic+get_ids_with_labels'></span>

<h3>Description</h3>

<p>Gets the rgl IDs with associated rayshader labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ids_with_labels(typeval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ids_with_labels_+3A_typeval">typeval</code></td>
<td>
<p>Default 'NULL'. Select to filter just one of the types: 'surface', 'base','lines', 'waterlines','shadow', 'basebottom',</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of IDs with labels
</p>

<hr>
<h2 id='get_interpolated_points_path'>Get Distance Along Bezier Curve</h2><span id='topic+get_interpolated_points_path'></span>

<h3>Description</h3>

<p>Get Distance Along Bezier Curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_interpolated_points_path(points, n = 360, use_altitude = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_interpolated_points_path_+3A_points">points</code></td>
<td>
<p>3D points to interpolate</p>
</td></tr>
<tr><td><code id="get_interpolated_points_path_+3A_n">n</code></td>
<td>
<p>Number of interpolation breaks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of points along path, along with distances
</p>

<hr>
<h2 id='get_polygon_data_value'>Get Data Value from spatial object</h2><span id='topic+get_polygon_data_value'></span>

<h3>Description</h3>

<p>Get Data Value from spatial object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_polygon_data_value(
  polygon,
  data_column_name = NULL,
  default_value = 0,
  scale_data = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_polygon_data_value_+3A_polygon">polygon</code></td>
<td>
<p>This is an sf object</p>
</td></tr>
</table>

<hr>
<h2 id='get_scene_depth'>Get the scene depth from rgl to offset rayrender scenes</h2><span id='topic+get_scene_depth'></span>

<h3>Description</h3>

<p>Get the scene depth from rgl to offset rayrender scenes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_scene_depth()
</code></pre>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='height_shade'>Calculate Terrain Color Map</h2><span id='topic+height_shade'></span>

<h3>Description</h3>

<p>Calculates a color for each point on the surface using a direct elevation-to-color mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>height_shade(
  heightmap,
  texture = (grDevices::colorRampPalette(c("#6AA85B", "#D9CC9A", "#FFFFFF")))(256),
  range = NULL,
  keep_user_par = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="height_shade_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point.</p>
</td></tr>
<tr><td><code id="height_shade_+3A_texture">texture</code></td>
<td>
<p>Default 'terrain.colors(256)'. A color palette for the plot.</p>
</td></tr>
<tr><td><code id="height_shade_+3A_range">range</code></td>
<td>
<p>Default 'NULL', the full range of the heightmap. A length-2 vector specifying the maximum
and minimum values to map the color palette to.</p>
</td></tr>
<tr><td><code id="height_shade_+3A_keep_user_par">keep_user_par</code></td>
<td>
<p>Default &lsquo;TRUE'. Whether to keep the user&rsquo;s 'par()' settings. Set to 'FALSE' if you 
want to set up a multi-pane plot (e.g. set 'par(mfrow)').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGB array of hillshaded texture mappings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a direct mapping of elevation to color:
montereybay %&gt;%
 height_shade() %&gt;%
 plot_map()
 
#Add a shadow:
if(run_documentation()) {
montereybay %&gt;%
 height_shade() %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}

#Change the palette:
if(run_documentation()) {
montereybay %&gt;%
 height_shade(texture = topo.colors(256)) %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}

#Really change the palette:
if(run_documentation()) {
montereybay %&gt;%
 height_shade(texture = rainbow(256)) %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='lamb_shade'>Calculate Lambert Shading Map</h2><span id='topic+lamb_shade'></span>

<h3>Description</h3>

<p>Calculates local shadow map for a elevation matrix by calculating the dot 
product between light direction and the surface normal vector at that point. Each point's
intensity is proportional to the cosine of the normal vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lamb_shade(
  heightmap,
  sunaltitude = 45,
  sunangle = 315,
  zscale = 1,
  zero_negative = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lamb_shade_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="lamb_shade_+3A_sunaltitude">sunaltitude</code></td>
<td>
<p>Default '45'. The azimuth angle as measured from the horizon from which the light originates.</p>
</td></tr>
<tr><td><code id="lamb_shade_+3A_sunangle">sunangle</code></td>
<td>
<p>Default '315' (NW). The angle around the matrix from which the light originates.</p>
</td></tr>
<tr><td><code id="lamb_shade_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis.</p>
</td></tr>
<tr><td><code id="lamb_shade_+3A_zero_negative">zero_negative</code></td>
<td>
<p>Default 'TRUE'. Zeros out all values below 0 (corresponding to surfaces facing away from the light source).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of light intensities at each point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a basic hillshade
montereybay %&gt;% 
 lamb_shade(zscale=200) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Increase the intensity by decreasing the zscale
montereybay %&gt;% 
 lamb_shade(zscale=50) %&gt;% 
 plot_map()
}
if(run_documentation()) { 
#Change the sun direction
montereybay %&gt;% 
 lamb_shade(zscale=200, sunangle=45) %&gt;% 
 plot_map()
}
if(run_documentation()) {
#Change the sun altitude
montereybay %&gt;% 
 lamb_shade(zscale=200, sunaltitude=60) %&gt;% 
 plot_map()
}
</code></pre>

<hr>
<h2 id='load_image'>Load Image</h2><span id='topic+load_image'></span>

<h3>Description</h3>

<p>Load Image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_image(image, reorient)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_image_+3A_image">image</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>image array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='local_to_world'>Local To World</h2><span id='topic+local_to_world'></span>

<h3>Description</h3>

<p>Local To World
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_to_world(a, mat)
</code></pre>


<h3>Value</h3>

<p>mat
</p>

<hr>
<h2 id='lookat'>Generate LookAt Matrix</h2><span id='topic+lookat'></span>

<h3>Description</h3>

<p>Generate LookAt Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookat(from, to, up = c(0, 1, 0))
</code></pre>


<h3>Value</h3>

<p>mat
</p>

<hr>
<h2 id='make_base'>make_base</h2><span id='topic+make_base'></span>

<h3>Description</h3>

<p>Makes the base below the 3D elevation map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_base(
  heightmap,
  basedepth = 0,
  basecolor = "grey20",
  zscale = 1,
  soil = FALSE,
  soil_freq = 0.1,
  soil_levels = 8,
  soil_color1 = "black",
  soil_color2 = "black",
  soil_gradient = 0,
  gradient_darken = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_base_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="make_base_+3A_basedepth">basedepth</code></td>
<td>
<p>Default '0'.</p>
</td></tr>
<tr><td><code id="make_base_+3A_basecolor">basecolor</code></td>
<td>
<p>Default 'grey20'.</p>
</td></tr>
<tr><td><code id="make_base_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
</table>

<hr>
<h2 id='make_base_triangulated'>Make Base (for triangulated height maps)</h2><span id='topic+make_base_triangulated'></span>

<h3>Description</h3>

<p>Makes the base below the 3D elevation map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_base_triangulated(tris, basedepth = 0, basecolor = "grey20")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_base_triangulated_+3A_tris">tris</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="make_base_triangulated_+3A_basedepth">basedepth</code></td>
<td>
<p>Default '0'.</p>
</td></tr>
<tr><td><code id="make_base_triangulated_+3A_basecolor">basecolor</code></td>
<td>
<p>Default 'grey20'.</p>
</td></tr>
</table>

<hr>
<h2 id='make_lines'>make_lines</h2><span id='topic+make_lines'></span>

<h3>Description</h3>

<p>Makes the lines in the corner of the base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_lines(
  heightmap,
  basedepth = 0,
  linecolor = "grey20",
  zscale = 1,
  alpha = 1,
  linewidth = 2,
  solid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_lines_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="make_lines_+3A_basedepth">basedepth</code></td>
<td>
<p>Default '0'.</p>
</td></tr>
<tr><td><code id="make_lines_+3A_linecolor">linecolor</code></td>
<td>
<p>Default 'grey40'.</p>
</td></tr>
<tr><td><code id="make_lines_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="make_lines_+3A_alpha">alpha</code></td>
<td>
<p>Default '1'. Transparency.</p>
</td></tr>
<tr><td><code id="make_lines_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '2'. Linewidth</p>
</td></tr>
<tr><td><code id="make_lines_+3A_solid">solid</code></td>
<td>
<p>Default &lsquo;TRUE'. Whether it&rsquo;s solid or water.</p>
</td></tr>
</table>

<hr>
<h2 id='make_shadow'>make_shadow</h2><span id='topic+make_shadow'></span>

<h3>Description</h3>

<p>Makes the base below the 3D elevation map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_shadow(
  heightmap,
  basedepth,
  shadowwidth,
  color,
  shadowcolor,
  offset = c(0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_shadow_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="make_shadow_+3A_basedepth">basedepth</code></td>
<td>
<p>Default 'grey20'.</p>
</td></tr>
<tr><td><code id="make_shadow_+3A_shadowwidth">shadowwidth</code></td>
<td>
<p>Default '50'. Shadow width.</p>
</td></tr>
</table>

<hr>
<h2 id='make_water'>make_water</h2><span id='topic+make_water'></span>

<h3>Description</h3>

<p>Makes the water in the 3D elevation map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_water(
  heightmap,
  waterheight = mean(heightmap),
  watercolor = "lightblue",
  zscale = 1,
  wateralpha = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_water_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="make_water_+3A_waterheight">waterheight</code></td>
<td>
<p>Default '0'.</p>
</td></tr>
<tr><td><code id="make_water_+3A_watercolor">watercolor</code></td>
<td>
<p>Default 'blue'.</p>
</td></tr>
<tr><td><code id="make_water_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="make_water_+3A_wateralpha">wateralpha</code></td>
<td>
<p>Default '0.5'. Water transparency.</p>
</td></tr>
</table>

<hr>
<h2 id='make_waterlines'>make_waterlines</h2><span id='topic+make_waterlines'></span>

<h3>Description</h3>

<p>Makes the edge lines of
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_waterlines(
  heightmap,
  waterdepth = 0,
  linecolor = "grey40",
  zscale = 1,
  alpha = 1,
  linewidth = 2,
  antialias = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_waterlines_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="make_waterlines_+3A_waterdepth">waterdepth</code></td>
<td>
<p>Default '0'.</p>
</td></tr>
<tr><td><code id="make_waterlines_+3A_linecolor">linecolor</code></td>
<td>
<p>Default 'grey40'.</p>
</td></tr>
<tr><td><code id="make_waterlines_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="make_waterlines_+3A_alpha">alpha</code></td>
<td>
<p>Default '1'. Transparency of lines.</p>
</td></tr>
<tr><td><code id="make_waterlines_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '2'. Water line width.</p>
</td></tr>
<tr><td><code id="make_waterlines_+3A_antialias">antialias</code></td>
<td>
<p>Default 'FALSE'.</p>
</td></tr>
</table>

<hr>
<h2 id='monterey_counties_sf'>California County Data Around Monterey Bay</h2><span id='topic+monterey_counties_sf'></span>

<h3>Description</h3>

<p>This dataset is an 'sf' object containing polygon data from the U.S. Department of Commerce
with selected geographic and cartographic information from the U.S. Census Bureau's Master 
Address File / Topologically Integrated Geographic Encoding and Referencing (MAF/TIGER) 
Database (MTDB). This data has been trimmed to only include 26 features in the extent of
the 'montereybay' dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monterey_counties_sf
</code></pre>


<h3>Format</h3>

<p>An 'sf' object with MULTIPOLYGON geometry.
</p>


<h3>Source</h3>

<p>https://catalog.data.gov/dataset/tiger-line-shapefile-2016-state-california-current-county-subdivision-state-based
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is the full code (commented out) used to generate this dataset from the original data:
#counties = sf::st_read("tl_2016_06_cousub.shp")
#monterey_counties_sf = sf::st_crop(counties, attr(montereybay,"extent"))
</code></pre>

<hr>
<h2 id='monterey_roads_sf'>Road Data Around Monterey Bay</h2><span id='topic+monterey_roads_sf'></span>

<h3>Description</h3>

<p>This dataset is an 'sf' object containing line data from the U.S. Department of Commerce
with selected roads, TIGER/Line Shapefile, 2015,  state, California, Primary and Secondary 
Roads State-based Shapefile. This data has been trimmed to only include 330 features in the extent of
the 'montereybay' dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monterey_roads_sf
</code></pre>


<h3>Format</h3>

<p>An 'sf' object with LINESTRING geometry.
</p>


<h3>Source</h3>

<p>https://www2.census.gov/geo/tiger/TIGER2015/PRISECROADS/tl_2015_06_prisecroads.zip
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is the full code (commented out) used to generate this dataset from the original data:
#counties = sf::st_read("tl_2015_06_prisecroads.shp")
#monterey_roads_sf = sf::st_crop(counties, attr(montereybay,"extent"))
</code></pre>

<hr>
<h2 id='montereybay'>Monterey Bay combined topographic and bathymetric elevation matrix.</h2><span id='topic+montereybay'></span>

<h3>Description</h3>

<p>This dataset is a downsampled version of a combined topographic and bathymetric 
elevation matrix representing the Monterey Bay, CA region. Original data from 
from the NOAA National Map website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>montereybay
</code></pre>


<h3>Format</h3>

<p>A matrix with 540 rows and 540 columns. Elevation is in meters, and the spacing between each
coordinate is 200 meters (zscale = 200). Water level is 0. Raster extent located in &quot;extent&quot; attribute. CRS located in &quot;CRS&quot; attribute.
</p>


<h3>Source</h3>

<p>https://www.ncei.noaa.gov/metadata/geoportal/rest/metadata/item/gov.noaa.ngdc.mgg.dem:3544/html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is the full code (commented out) used to generate this dataset from the original NOAA data:
#raster::raster("monterey_13_navd88_2012.nc")
#bottom_left = c(y=-122.366765, x=36.179392)
#top_right   = c(y=-121.366765, x=37.179392) 
#extent_latlong = sp::SpatialPoints(rbind(bottom_left, top_right), 
#                 proj4string=sp::CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))
#monterey_cropped = raster::crop(montbay,extent_latlong)
#montbay_mat = raster_to_matrix(montbay_cropped)
#montereybay = resize_matrix(montbay_mat,0.05)
#attr(montereybay, "extent") = extent_latlong
#attr(montereybay, "crs") = crs(monterey_cropped)
#attr(montereybay, "crs") = crs(monterey_cropped)
#attr(montereybay, "rayshader_data") = TRUE
</code></pre>

<hr>
<h2 id='plot_3d'>Plot 3D</h2><span id='topic+plot_3d'></span>

<h3>Description</h3>

<p>Displays the shaded map in 3D with the 'rgl' package. 
</p>
<p>Note: Calling 'plot_3d()' resets the scene cache for the 'render_snapshot()', 'render_depth()', and 'render_highquality()'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_3d(
  hillshade,
  heightmap,
  zscale = 1,
  baseshape = "rectangle",
  solid = TRUE,
  soliddepth = "auto",
  solidcolor = "grey20",
  solidlinecolor = "grey30",
  shadow = TRUE,
  shadowdepth = "auto",
  shadowcolor = "auto",
  shadow_darkness = 0.5,
  shadowwidth = "auto",
  water = FALSE,
  waterdepth = 0,
  watercolor = "dodgerblue",
  wateralpha = 0.5,
  waterlinecolor = NULL,
  waterlinealpha = 1,
  linewidth = 2,
  lineantialias = FALSE,
  soil = FALSE,
  soil_freq = 0.1,
  soil_levels = 16,
  soil_color_light = "#b39474",
  soil_color_dark = "#8a623b",
  soil_gradient = 2,
  soil_gradient_darken = 4,
  theta = 45,
  phi = 45,
  fov = 0,
  zoom = 1,
  background = "white",
  windowsize = 600,
  precomputed_normals = NULL,
  asp = 1,
  triangulate = FALSE,
  max_error = 0,
  max_tri = 0,
  verbose = FALSE,
  plot_new = TRUE,
  close_previous = TRUE,
  clear_previous = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_3d_+3A_hillshade">hillshade</code></td>
<td>
<p>Hillshade/image to be added to 3D surface map.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10. Adjust the zscale down to exaggerate elevation features.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_baseshape">baseshape</code></td>
<td>
<p>Default 'rectangle'. Shape of the base. Options are 'c(&quot;rectangle&quot;,&quot;circle&quot;,&quot;hex&quot;)'.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_solid">solid</code></td>
<td>
<p>Default 'TRUE'. If 'FALSE', just the surface is rendered.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_soliddepth">soliddepth</code></td>
<td>
<p>Default 'auto', which sets it to the lowest elevation in the matrix minus one unit (scaled by zscale). Depth of the solid base. If heightmap is uniform and set on 'auto', this is automatically set to a slightly lower level than the uniform elevation.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_solidcolor">solidcolor</code></td>
<td>
<p>Default 'grey20'. Base color.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_solidlinecolor">solidlinecolor</code></td>
<td>
<p>Default 'grey30'. Base edge line color.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_shadow">shadow</code></td>
<td>
<p>Default 'TRUE'. If 'FALSE', no shadow is rendered.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_shadowdepth">shadowdepth</code></td>
<td>
<p>Default 'auto', which sets it to 'soliddepth - soliddepth/10'. Depth of the shadow layer.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_shadowcolor">shadowcolor</code></td>
<td>
<p>Default 'auto'. Color of the shadow, automatically computed as 'shadow_darkness'
the luminance of the 'background' color in the CIELuv colorspace if not specified.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_shadow_darkness">shadow_darkness</code></td>
<td>
<p>Default '0.5'. Darkness of the shadow, if 'shadowcolor = &quot;auto&quot;'.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_shadowwidth">shadowwidth</code></td>
<td>
<p>Default 'auto', which sizes it to 1/10th the smallest dimension of 'heightmap'. Width of the shadow in units of the matrix.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_water">water</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', a water layer is rendered.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_waterdepth">waterdepth</code></td>
<td>
<p>Default '0'. Water level.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_watercolor">watercolor</code></td>
<td>
<p>Default 'lightblue'. Color of the water.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_wateralpha">wateralpha</code></td>
<td>
<p>Default '0.5'. Water transparency.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_waterlinecolor">waterlinecolor</code></td>
<td>
<p>Default 'NULL'. Color of the lines around the edges of the water layer.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_waterlinealpha">waterlinealpha</code></td>
<td>
<p>Default '1'. Water line tranparency.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '2'. Width of the edge lines in the scene.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_lineantialias">lineantialias</code></td>
<td>
<p>Default 'FALSE'. Whether to anti-alias the lines in the scene.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_soil">soil</code></td>
<td>
<p>Default 'FALSE'. Whether to draw the solid base with a textured soil layer.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_soil_freq">soil_freq</code></td>
<td>
<p>Default '0.1'. Frequency of soil clumps. Higher frequency values give smaller soil clumps.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_soil_levels">soil_levels</code></td>
<td>
<p>Default '16'. Fractal level of the soil.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_soil_color_light">soil_color_light</code></td>
<td>
<p>Default '&quot;#b39474&quot;'. Light tint of soil.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_soil_color_dark">soil_color_dark</code></td>
<td>
<p>Default '&quot;#8a623b&quot;'. Dark tint of soil.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_soil_gradient">soil_gradient</code></td>
<td>
<p>Default '2'. Sharpness of the soil darkening gradient. '0' turns off the gradient entirely.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_soil_gradient_darken">soil_gradient_darken</code></td>
<td>
<p>Default '4'. Amount to darken the 'soil_color_dark' value for the deepest soil layers. Higher
numbers increase the darkening effect.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_theta">theta</code></td>
<td>
<p>Default '45'. Rotation around z-axis.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_phi">phi</code></td>
<td>
<p>Default '45'. Azimuth angle.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_fov">fov</code></td>
<td>
<p>Default '0'&ndash;isometric. Field-of-view angle.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_zoom">zoom</code></td>
<td>
<p>Default '1'. Zoom factor.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_background">background</code></td>
<td>
<p>Default 'grey10'. Color of the background.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_windowsize">windowsize</code></td>
<td>
<p>Default '600'. Position, width, and height of the 'rgl' device displaying the plot. 
If a single number, viewport will be a square and located in upper left corner. 
If two numbers, (e.g. 'c(600,800)'), user will specify width and height separately. 
If four numbers (e.g. 'c(200,0,600,800)'), the first two coordinates 
specify the location of the x-y coordinates of the bottom-left corner of the viewport on the screen,
and the next two (or one, if square) specify the window size. NOTE: The absolute positioning of the
window does not currently work on macOS (tested on Mojave), but the size can still be specified.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_precomputed_normals">precomputed_normals</code></td>
<td>
<p>Default 'NULL'. Takes the output of 'calculate_normals()' to save
computing normals internally.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_asp">asp</code></td>
<td>
<p>Default '1'. Aspect ratio of the resulting plot. Use 'asp = 1/cospi(mean_latitude/180)' to rescale
lat/long at higher latitudes to the correct the aspect ratio.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_triangulate">triangulate</code></td>
<td>
<p>Default 'FALSE'. Reduce the size of the 3D model by triangulating the height map.
Set this to 'TRUE' if generating the model is slow, or moving it is choppy. Will also reduce the size
of 3D models saved to disk.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_max_error">max_error</code></td>
<td>
<p>Default '0.001'. Maximum allowable error when triangulating the height map,
when 'triangulate = TRUE'. Increase this if you encounter problems with 3D performance, want
to decrease render time with 'render_highquality()', or need 
to save a smaller 3D OBJ file to disk with 'save_obj()',</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_max_tri">max_tri</code></td>
<td>
<p>Default '0', which turns this setting off and uses 'max_error'. 
Maximum number of triangles allowed with triangulating the
height map, when 'triangulate = TRUE'. Increase this if you encounter problems with 3D performance, want
to decrease render time with 'render_highquality()', or need 
to save a smaller 3D OBJ file to disk with 'save_obj()',</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_verbose">verbose</code></td>
<td>
<p>Default 'TRUE', if 'interactive()'. Prints information about the mesh triangulation
if 'triangulate = TRUE'.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_plot_new">plot_new</code></td>
<td>
<p>Default 'TRUE', opens new window with each 'plot_3d()' call. If 'FALSE', 
the data will be plotted in the same window.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_close_previous">close_previous</code></td>
<td>
<p>Default 'TRUE'. Closes any previously open 'rgl' window. If 'FALSE', 
old windows will be kept open.</p>
</td></tr>
<tr><td><code id="plot_3d_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'TRUE'. Clears the previously open 'rgl' window if 'plot_new = FALSE'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Plotting a spherical texture map of the built-in `montereybay` dataset.
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(texture="desert") %&gt;%
 plot_3d(montereybay,zscale=50)
render_snapshot()
}

#With a water layer  
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(texture="imhof2") %&gt;%
 plot_3d(montereybay, zscale=50, water = TRUE, watercolor="imhof2", 
         waterlinecolor="white", waterlinealpha=0.5)
render_snapshot()
}

#With a soil texture to the base  
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(texture="imhof3") %&gt;%
 plot_3d(montereybay, zscale=50, water = TRUE,  watercolor="imhof4", 
         waterlinecolor="white", waterlinealpha=0.5, soil=TRUE)
render_camera(theta=225, phi=7, zoom=0.5, fov=67)
render_snapshot()
}

#We can also change the base by setting "baseshape" to "hex" or "circle"
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(texture="imhof1") %&gt;%
 plot_3d(montereybay, zscale=50, water = TRUE, watercolor="imhof1", theta=-45, zoom=0.7,
         waterlinecolor="white", waterlinealpha=0.5,baseshape="circle")
render_snapshot()
}

if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(texture="imhof1") %&gt;%
 plot_3d(montereybay, zscale=50, water = TRUE, watercolor="imhof1", theta=-45, zoom=0.7,
         waterlinecolor="white", waterlinealpha=0.5,baseshape="hex")
render_snapshot()
}



#Or we can carve out the region of interest ourselves, by setting those entries to NA
#to the elevation map passed into `plot_3d`

#Here, we only include the deep bathymetry data by setting all points greater than -10
#in the copied elevation matrix to NA.

mb_water = montereybay
mb_water[mb_water &gt; -10] = NA

if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(texture="imhof1") %&gt;%
 plot_3d(mb_water, zscale=50, water = TRUE, watercolor="imhof1", theta=-45,
         waterlinecolor="white", waterlinealpha=0.5)
render_snapshot()
}
</code></pre>

<hr>
<h2 id='plot_gg'>Transform ggplot2 objects into 3D</h2><span id='topic+plot_gg'></span>

<h3>Description</h3>

<p>Plots a ggplot2 object in 3D by mapping the color or fill aesthetic to elevation.
</p>
<p>Currently, this function does not transform lines mapped to color into 3D.
</p>
<p>If there are multiple legends/guides due to multiple aesthetics being mapped (e.g. color and shape),
the package author recommends that the user pass the order of the guides manually using the ggplot2 function &quot;guides()'. 
Otherwise, the order may change when processing the ggplot2 object and result in a mismatch between the 3D mapping
and the underlying plot.
</p>
<p>Using the shape aesthetic with more than three groups is not recommended, unless the user passes in 
custom, solid shapes. By default in ggplot2, only the first three shapes are solid, which is a requirement to be projected
into 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gg(
  ggobj,
  ggobj_height = NULL,
  width = 3,
  height = 3,
  height_aes = NULL,
  invert = FALSE,
  shadow_intensity = 0.5,
  units = c("in", "cm", "mm"),
  scale = 150,
  pointcontract = 0.7,
  offset_edges = FALSE,
  flat_plot_render = FALSE,
  flat_distance = "auto",
  flat_transparent_bg = FALSE,
  flat_direction = "-z",
  shadow = TRUE,
  shadowdepth = "auto",
  shadowcolor = "auto",
  shadow_darkness = 0.5,
  background = "white",
  preview = FALSE,
  raytrace = TRUE,
  sunangle = 315,
  anglebreaks = seq(30, 40, 0.1),
  multicore = FALSE,
  lambert = TRUE,
  triangulate = TRUE,
  max_error = 0.001,
  max_tri = 0,
  verbose = FALSE,
  emboss_text = 0,
  emboss_grid = 0,
  reduce_size = NULL,
  save_height_matrix = FALSE,
  save_shadow_matrix = FALSE,
  saved_shadow_matrix = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gg_+3A_ggobj">ggobj</code></td>
<td>
<p>ggplot object to projected into 3D.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_ggobj_height">ggobj_height</code></td>
<td>
<p>Default 'NULL'. A ggplot object that can be used to specify the 3D extrusion separately from the
'ggobj'.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_width">width</code></td>
<td>
<p>Default '3'. Width of ggplot, in 'units'.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_height">height</code></td>
<td>
<p>Default '3'. Height of ggplot, in 'units'.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_height_aes">height_aes</code></td>
<td>
<p>Default 'NULL'. Whether the 'fill' or 'color' aesthetic should be used for height values, 
which the user can specify by passing either 'fill' or 'color' to this argument.
Automatically detected. If both 'fill' and 'color' aesthetics are present, then 'fill' is default.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_invert">invert</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the height mapping is inverted.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_shadow_intensity">shadow_intensity</code></td>
<td>
<p>Default '0.5'. The intensity of the calculated shadows.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_units">units</code></td>
<td>
<p>Default 'in'. One of c(&quot;in&quot;, &quot;cm&quot;, &quot;mm&quot;).</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_scale">scale</code></td>
<td>
<p>Default '150'. Multiplier for vertical scaling: a higher number increases the height
of the 3D transformation.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_pointcontract">pointcontract</code></td>
<td>
<p>Default '0.7'. This multiplies the size of the points and shrinks
them around their center in the 3D surface mapping. Decrease this to reduce color bleed on edges, and set to
'1' to turn off entirely. Note: If 'size' is passed as an aesthetic to the same geom
that is being mapped to elevation, this scaling will not be applied. If 'alpha' varies on the variable 
being mapped, you may want to set this to '1', since the points now have a non-zero width stroke outline (however,
mapping 'alpha' in the same variable you are projecting to height is probably not a good choice. as the 'alpha'
variable is ignored when performing the 3D projection).</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_offset_edges">offset_edges</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', inserts a small amount of space between polygons for &quot;geom_sf&quot;, &quot;geom_tile&quot;, &quot;geom_hex&quot;, and &quot;geom_polygon&quot; layers.
If you pass in a number, the space between polygons will be a line of that width. You can also specify a number to control the thickness of the offset. 
Note: this feature may end up removing thin polygons from the plot entirely&ndash;use with care.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_flat_plot_render">flat_plot_render</code></td>
<td>
<p>Default 'FALSE'. Whether to render a flat version of the ggplot above (or alongside) the 3D version.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_flat_distance">flat_distance</code></td>
<td>
<p>Default '&quot;auto&quot;'. Distance to render the flat version of the plot from the 3D version.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_flat_transparent_bg">flat_transparent_bg</code></td>
<td>
<p>Default 'FALSE'. Whether to set the background of the flat version of the ggplot to transparent.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_flat_direction">flat_direction</code></td>
<td>
<p>Default '&quot;-z&quot;'. Direction to render the flat copy of the plot, if 'flat_plot_render = TRUE'.
Other options 'c(&quot;z&quot;, &quot;x&quot;, &quot;-x&quot;, &quot;y&quot;, &quot;-y&quot;)'.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_shadow">shadow</code></td>
<td>
<p>Default 'TRUE'. If 'FALSE', no shadow is rendered.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_shadowdepth">shadowdepth</code></td>
<td>
<p>Default 'auto', which sets it to 'soliddepth - soliddepth/10'. Depth of the shadow layer.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_shadowcolor">shadowcolor</code></td>
<td>
<p>Default 'auto'. Color of the shadow, automatically computed as 'shadow_darkness'
the luminance of the 'background' color in the CIELab colorspace if not specified.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_shadow_darkness">shadow_darkness</code></td>
<td>
<p>Default '0.5'. Darkness of the shadow, if 'shadowcolor = &quot;auto&quot;'.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_background">background</code></td>
<td>
<p>Default '&quot;white&quot;'. Background color.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_preview">preview</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the raytraced 2D ggplot will be displayed on the current device.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_raytrace">raytrace</code></td>
<td>
<p>Default 'FALSE'. Whether to add a raytraced layer.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_sunangle">sunangle</code></td>
<td>
<p>Default '315' (NW). If raytracing, the angle (in degrees) around the matrix from which the light originates.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_anglebreaks">anglebreaks</code></td>
<td>
<p>Default 'seq(30,40,0.1)'. The azimuth angle(s), in degrees, as measured from the horizon from which the light originates.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_multicore">multicore</code></td>
<td>
<p>Default 'FALSE'. If raytracing and 'TRUE', multiple cores will be used to compute the shadow matrix. By default, this uses all cores available, unless the user has
set 'options(&quot;cores&quot;)' in which the multicore option will only use that many cores.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_lambert">lambert</code></td>
<td>
<p>Default 'TRUE'. If raytracing, changes the intensity of the light at each point based proportional to the
dot product of the ray direction and the surface normal at that point. Zeros out all values directed away from
the ray.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_triangulate">triangulate</code></td>
<td>
<p>Default 'FALSE'. Reduce the size of the 3D model by triangulating the height map.
Set this to 'TRUE' if generating the model is slow, or moving it is choppy. Will also reduce the size
of 3D models saved to disk.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_max_error">max_error</code></td>
<td>
<p>Default '0.001'. Maximum allowable error when triangulating the height map,
when 'triangulate = TRUE'. Increase this if you encounter problems with 3D performance, want
to decrease render time with 'render_highquality()', or need 
to save a smaller 3D OBJ file to disk with 'save_obj()',</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_max_tri">max_tri</code></td>
<td>
<p>Default '0', which turns this setting off and uses 'max_error'. 
Maximum number of triangles allowed with triangulating the
height map, when 'triangulate = TRUE'. Increase this if you encounter problems with 3D performance, want
to decrease render time with 'render_highquality()', or need 
to save a smaller 3D OBJ file to disk with 'save_obj()',</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_verbose">verbose</code></td>
<td>
<p>Default 'TRUE', if 'interactive()'. Prints information about the mesh triangulation
if 'triangulate = TRUE'.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_emboss_text">emboss_text</code></td>
<td>
<p>Default '0', max '1'. Amount to emboss the text, where '1' is the tallest feature in the scene.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_emboss_grid">emboss_grid</code></td>
<td>
<p>Default '0', max '1'. Amount to emboss the grid lines, where '1' is the tallest feature in the scene.
By default, the minor grid lines will be half the size of the major lines. Pass a length-2 vector to specify them seperately (second value 
is the minor grid height).</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_reduce_size">reduce_size</code></td>
<td>
<p>Default 'NULL'. A number between '0' and '1' that specifies how much to reduce the resolution of the plot, for faster plotting. By
default, this just decreases the size of height map, not the image. If you wish the image to be reduced in resolution as well, pass a numeric vector of size 2.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_save_height_matrix">save_height_matrix</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the function will return the height matrix used for the ggplot.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_save_shadow_matrix">save_shadow_matrix</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the function will return the shadow matrix for use in future updates via the 'shadow_cache' argument passed to 'ray_shade'.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_saved_shadow_matrix">saved_shadow_matrix</code></td>
<td>
<p>Default 'NULL'. A cached shadow matrix (saved by the a previous invocation of 'plot_gg(..., save_shadow_matrix=TRUE)' to use instead of raytracing a shadow map each time.</p>
</td></tr>
<tr><td><code id="plot_gg_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to 'plot_3d()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Opens a 3D plot in rgl.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(viridis)


ggdiamonds = ggplot(diamonds, aes(x, depth)) +
 stat_density_2d(aes(fill = after_stat(nlevel)), geom = "polygon", 
                 n = 200, bins = 50,contour = TRUE) +
 facet_wrap(clarity~.) +
 scale_fill_viridis_c(option = "A")
if(run_documentation()) {
plot_gg(ggdiamonds,multicore = TRUE,width=5,height=5,scale=250,windowsize=c(1400,866),
       zoom = 0.55, phi = 30)
render_snapshot()
}
#Change the camera angle and take a snapshot:
if(run_documentation()) {
render_camera(zoom=0.5,theta=-30,phi=30)
render_snapshot()
}

#Contours and other lines will automatically be ignored. Here is the volcano dataset:
ggvolcano = volcano %&gt;% 
 reshape2::melt() %&gt;%
 ggplot() +
 geom_tile(aes(x=Var1,y=Var2,fill=value)) +
 geom_contour(aes(x=Var1,y=Var2,z=value),color="black") +
 scale_x_continuous("X",expand = c(0,0)) +
 scale_y_continuous("Y",expand = c(0,0)) +
 scale_fill_gradientn("Z",colours = terrain.colors(10)) +
 coord_fixed() + 
 theme(legend.position = "none")
ggvolcano

if(run_documentation()) {
plot_gg(ggvolcano, multicore = TRUE, raytrace = TRUE, width = 7, height = 4, 
       scale = 300, windowsize = c(1400, 866), zoom = 0.6, phi = 30, theta = 30)
render_snapshot()
}

if(run_documentation()) {
#You can specify the color and height separately using the `ggobj_height()` argument.
ggvolcano_surface = volcano %&gt;%
reshape2::melt() %&gt;%
 ggplot() +
 geom_contour(aes(x=Var1,y=Var2,z=value),color="black") +
 geom_contour_filled(aes(x=Var1,y=Var2,z=value))+
 scale_x_continuous("X",expand = c(0,0)) +
 scale_y_continuous("Y",expand = c(0,0)) +
 coord_fixed() +
 theme(legend.position = "none")

plot_gg(ggvolcano_surface, ggobj_height = ggvolcano, 
      multicore = TRUE, raytrace = TRUE, width = 7, height = 4,
      scale = 300, windowsize = c(1400, 866), zoom = 0.6, phi = 30, theta = 30)
render_snapshot()
}
#Here, we will create a 3D plot of the mtcars dataset. This automatically detects 
#that the user used the `color` aesthetic instead of the `fill`.
mtplot = ggplot(mtcars) + 
 geom_point(aes(x=mpg,y=disp,color=cyl)) + 
 scale_color_continuous(limits=c(0,8)) 

#Preview how the plot will look by setting `preview = TRUE`: We also adjust the angle of the light.
if(run_documentation()) {
plot_gg(mtplot, width=3.5, sunangle=225, preview = TRUE)
}
if(run_documentation()) {
plot_gg(mtplot, width=3.5, multicore = TRUE, windowsize = c(1400,866), sunangle=225,
       zoom = 0.60, phi = 30, theta = 45)
render_snapshot()
}
#Now let's plot a density plot in 3D.
mtplot_density = ggplot(mtcars) + 
 stat_density_2d(aes(x=mpg,y=disp, fill=after_stat(!!str2lang("density"))), 
                 geom = "raster", contour = FALSE) +
 scale_x_continuous(expand=c(0,0)) +
 scale_y_continuous(expand=c(0,0)) +
 scale_fill_gradient(low="pink", high="red")
mtplot_density

if(run_documentation()) {
plot_gg(mtplot_density, width = 4,zoom = 0.60, theta = -45, phi = 30, 
       windowsize = c(1400,866))
render_snapshot()
}
#This also works facetted.
mtplot_density_facet = mtplot_density + facet_wrap(~cyl) 

#Preview this plot in 2D:
if(run_documentation()) {
plot_gg(mtplot_density_facet, preview = TRUE)
}
if(run_documentation()) {
plot_gg(mtplot_density_facet, windowsize=c(1400,866),
       zoom = 0.55, theta = -10, phi = 25)
render_snapshot()
}
#That is a little cramped. Specifying a larger width will improve the readability of this plot.
if(run_documentation()) {
plot_gg(mtplot_density_facet, width = 6, preview = TRUE)
}

#That's better. Let's plot it in 3D, and increase the scale.
if(run_documentation()) {
plot_gg(mtplot_density_facet, width = 6, windowsize=c(1400,866),
       zoom = 0.55, theta = -10, phi = 25, scale=300)
render_snapshot()
}

#We can also render a flat version of the plot alongside (or above/below) the 3D version.
if(run_documentation()) {
plot_gg(mtplot_density_facet, width = 6, windowsize=c(1400,866),
       zoom = 0.65, theta = -25, phi = 35, scale=300, flat_plot_render=TRUE,
       flat_direction = "x")
render_snapshot()
}
</code></pre>

<hr>
<h2 id='plot_map'>Plot Map</h2><span id='topic+plot_map'></span>

<h3>Description</h3>

<p>Displays the map in the current device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_map(
  hillshade,
  rotate = 0,
  asp = 1,
  title_text = NA,
  title_offset = c(20, 20),
  title_color = "black",
  title_size = 30,
  title_font = "sans",
  title_style = "normal",
  title_bar_color = NULL,
  title_bar_alpha = 0.5,
  title_position = "northwest",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_map_+3A_hillshade">hillshade</code></td>
<td>
<p>Hillshade to be plotted.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_rotate">rotate</code></td>
<td>
<p>Default '0'. Rotates the output. Possible values: '0', '90', '180', '270'.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_asp">asp</code></td>
<td>
<p>Default '1'. Aspect ratio of the resulting plot. Use 'asp = 1/cospi(mean_latitude/180)' to rescale
lat/long at higher latitudes to the correct the aspect ratio.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_text">title_text</code></td>
<td>
<p>Default 'NULL'. Text. Adds a title to the image, using 'magick::image_annotate()'.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_offset">title_offset</code></td>
<td>
<p>Default 'c(20,20)'. Distance from the top-left (default, 'gravity' direction in
image_annotate) corner to offset the title.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_color">title_color</code></td>
<td>
<p>Default 'black'. Font color.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_size">title_size</code></td>
<td>
<p>Default '30'. Font size in pixels.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_font">title_font</code></td>
<td>
<p>Default 'sans'. String with font family such as &quot;sans&quot;, &quot;mono&quot;, &quot;serif&quot;, &quot;Times&quot;, &quot;Helvetica&quot;,
&quot;Trebuchet&quot;, &quot;Georgia&quot;, &quot;Palatino&quot; or &quot;Comic Sans&quot;.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_style">title_style</code></td>
<td>
<p>Default 'normal'. Font style (e.g. 'italic').</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_bar_color">title_bar_color</code></td>
<td>
<p>Default 'NULL'. If a color, this will create a colored bar under the title.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_bar_alpha">title_bar_alpha</code></td>
<td>
<p>Default '0.5'. Transparency of the title bar.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title_position">title_position</code></td>
<td>
<p>Default 'northwest'. Position of the title.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the 'raster::plotRGB' function that displays the map.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Plotting the Monterey Bay dataset with bathymetry data
if(run_documentation()) {
water_palette = colorRampPalette(c("darkblue", "dodgerblue", "lightblue"))(200)
bathy_hs = height_shade(montereybay, texture = water_palette)
#For compass text
par(family = "Arial")

#Set everything below 0m to water palette
montereybay %&gt;%
 sphere_shade(zscale=10) %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map()
}
#Correcting the aspect ratio for the latitude of Monterey Bay

extent_mb = attr(montereybay,"extent")
mean_latitude = mean(c(extent_mb@ymax,extent_mb@ymin))
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade(zscale=10) %&gt;%
 add_overlay(generate_altitude_overlay(bathy_hs, montereybay, 0, 0))  %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_map(asp = 1/cospi(mean_latitude/180))
}
</code></pre>

<hr>
<h2 id='raster_to_matrix'>Raster to Matrix</h2><span id='topic+raster_to_matrix'></span>

<h3>Description</h3>

<p>Turns a raster into a matrix suitable for rayshader.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_to_matrix(raster, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_to_matrix_+3A_raster">raster</code></td>
<td>
<p>The input raster. Either a RasterLayer object, a terra SpatRaster object, or a filename.</p>
</td></tr>
<tr><td><code id="raster_to_matrix_+3A_verbose">verbose</code></td>
<td>
<p>Default 'interactive()'. Will print dimensions of the resulting matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Save montereybay as a raster and open using the filename.
if(run_documentation()) {
temp_raster_filename = paste0(tempfile(),".tif")
raster::writeRaster(raster::raster(t(montereybay)),temp_raster_filename)
elmat = raster_to_matrix(temp_raster_filename)
elmat %&gt;%
 sphere_shade() %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='ray_merge_reorder'>Reorder Lines</h2><span id='topic+ray_merge_reorder'></span>

<h3>Description</h3>

<p>Reorder Lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_merge_reorder(
  sf_data,
  start_index = 1,
  merge_tolerance = 0.1,
  duplicate_tolerance = 0.1
)
</code></pre>


<h3>Value</h3>

<p>data
</p>

<hr>
<h2 id='ray_shade'>Calculate Raytraced Shadow Map</h2><span id='topic+ray_shade'></span>

<h3>Description</h3>

<p>Calculates shadow map for a elevation matrix by propogating rays from each matrix point to the light source(s),
lowering the brightness at each point for each ray that intersects the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_shade(
  heightmap,
  sunaltitude = 45,
  sunangle = 315,
  maxsearch = NULL,
  lambert = TRUE,
  zscale = 1,
  multicore = FALSE,
  cache_mask = NULL,
  shadow_cache = NULL,
  progbar = interactive(),
  anglebreaks = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ray_shade_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_sunaltitude">sunaltitude</code></td>
<td>
<p>Default '45'. The angle, in degrees (as measured from the horizon) from which the light originates. The width of the light
is centered on this value and has an angular extent of 0.533 degrees, which is the angular extent of the sun. Use the 'anglebreaks' argument
to create a softer (wider) light. This has a hard minimum/maximum of 0/90 degrees.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_sunangle">sunangle</code></td>
<td>
<p>Default '315' (NW). The angle, in degrees, around the matrix from which the light originates. Zero degrees is North, increasing clockwise.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_maxsearch">maxsearch</code></td>
<td>
<p>Defaults to the longest possible shadow given the 'sunaltitude' and 'heightmap'. 
Otherwise, this argument specifies the maximum distance that the system should propagate rays to check.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_lambert">lambert</code></td>
<td>
<p>Default 'TRUE'. Changes the intensity of the light at each point based proportional to the
dot product of the ray direction and the surface normal at that point. Zeros out all values directed away from
the ray.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation is in units
of meters and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_multicore">multicore</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', multiple cores will be used to compute the shadow matrix. By default, this uses all cores available, unless the user has
set 'options(&quot;cores&quot;)' in which the multicore option will only use that many cores.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_cache_mask">cache_mask</code></td>
<td>
<p>Default 'NULL'. A matrix of 1 and 0s, indicating which points on which the raytracer will operate.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_shadow_cache">shadow_cache</code></td>
<td>
<p>Default 'NULL'. The shadow matrix to be updated at the points defined by the argument 'cache_mask'.
If present, this will only compute the raytraced shadows for those points with value '1' in the mask.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_progbar">progbar</code></td>
<td>
<p>Default 'TRUE' if interactive, 'FALSE' otherwise. If 'FALSE', turns off progress bar.</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_anglebreaks">anglebreaks</code></td>
<td>
<p>Default 'NULL'. A vector of angle(s) in degrees (as measured from the horizon) specifying from where the light originates. 
Use this instead of 'sunaltitude' to create a softer shadow by specifying a wider light. E.g. 'anglebreaks = seq(40,50,by=0.5)' creates a light 
10 degrees wide, as opposed to the default</p>
</td></tr>
<tr><td><code id="ray_shade_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the 'makeCluster' function when 'multicore=TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of light intensities at each point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#First we ray trace the Monterey Bay dataset.
#The default angle is from 40-50 degrees azimuth, from the north east.
if(run_documentation()) {
montereybay %&gt;%
 ray_shade(zscale=50) %&gt;%
 plot_map()
}
#Change the altitude of the sun to 25 degrees
if(run_documentation()) {
montereybay %&gt;%
 ray_shade(zscale=50, sunaltitude=25) %&gt;%
 plot_map()
}
#Remove the lambertian shading to just calculate shadow intensity.
if(run_documentation()) {
montereybay %&gt;%
 ray_shade(zscale=50, sunaltitude=25, lambert=FALSE) %&gt;%
 plot_map()
}

#Change the direction of the sun to the South East
if(run_documentation()) {
montereybay %&gt;%
 ray_shade(zscale=50, sunaltitude=25, sunangle=225) %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='raymarch_cloud_layer'>Calculate a single raymarched cloud layer</h2><span id='topic+raymarch_cloud_layer'></span>

<h3>Description</h3>

<p>Calculate a single raymarched cloud layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raymarch_cloud_layer(
  heightmap,
  sun_altitude = 90,
  sun_angle = 315,
  levels = 8,
  start_noise = 0,
  end_noise = 10,
  start_altitude_real = 0,
  end_altitude_real = 0,
  time = 0,
  alpha_coef = 0.8,
  layers = 10,
  offset_x = 0,
  offset_y = 0,
  scale_x = 1,
  scale_y = 1,
  scale_z = 1,
  step = 100,
  freq = 0.01/2,
  coef = 0.05,
  seed = 1
)
</code></pre>


<h3>Value</h3>

<p>image array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='reduce_matrix_size'>Reduce Matrix Size (deprecated)</h2><span id='topic+reduce_matrix_size'></span>

<h3>Description</h3>

<p>Reduce Matrix Size (deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_matrix_size(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_matrix_size_+3A_...">...</code></td>
<td>
<p>Arguments to pass to resize_matrix() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reduced matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Deprecated lambertian material. Will display a warning.
if(run_documentation()) {
montbaysmall = reduce_matrix_size(montereybay, scale=0.5)
montbaysmall %&gt;%
 sphere_shade() %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='render_beveled_polygons'>Render Beveled Polygons</h2><span id='topic+render_beveled_polygons'></span>

<h3>Description</h3>

<p>Adds beveled polygon to the scene using the 'raybevel' package. See
the 'raybevel::generate_beveled_polygon()' function for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_beveled_polygons(
  polygon,
  extent,
  material = "grey",
  bevel_material = NA,
  angle = 45,
  bevel_width = 5,
  width_raw_units = FALSE,
  bevel = NA,
  zscale = 1,
  bevel_height = 1,
  base_height = 0,
  raw_heights = FALSE,
  raw_offsets = FALSE,
  heights_relative_to_centroid = TRUE,
  set_max_height = FALSE,
  max_height = 10,
  scale_all_max = TRUE,
  data_column_top = NULL,
  data_column_bottom = NULL,
  heightmap = NULL,
  scale_data = 1,
  holes = 0,
  alpha = 1,
  lit = TRUE,
  flat_shading = FALSE,
  light_altitude = c(45, 30),
  light_direction = c(315, 225),
  light_intensity = 1,
  light_relative = FALSE,
  clear_previous = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_beveled_polygons_+3A_polygon">polygon</code></td>
<td>
<p>'sf' object, &quot;SpatialPolygon&quot; 'sp' object,  or xy coordinates
of polygon represented in a way that can be processed by 'xy.coords()'.  If
xy-coordinate based polygons are open, they will be closed by adding an
edge from the last point to the first.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the 3D scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;, &quot;ymin&quot;, &quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_material">material</code></td>
<td>
<p>Default '&quot;grey80&quot;'. If a color string, this will specify the color of the sides/base of the polygon. 
Alternatively (for more customization), this can be a r'ayvertex::material_list()' object to specify
the full color/appearance/material options for the resulting 'ray_mesh' mesh.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_bevel_material">bevel_material</code></td>
<td>
<p>Default 'NA', defaults to the material specified in 'material'. If a color string, this will specify the color of the polygon bevel. 
Alternatively (for more customization), this can be a 'rayvertex::material_list()' object to specify
the full color/appearance/material options for the resulting 'ray_mesh' mesh.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_angle">angle</code></td>
<td>
<p>Default '45'. Angle of the bevel.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_bevel_width">bevel_width</code></td>
<td>
<p>Default '5'. Width of the bevel.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_width_raw_units">width_raw_units</code></td>
<td>
<p>Default 'FALSE'. Whether the bevel width should be measured in raw display units,
or the actual units of the map.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_bevel">bevel</code></td>
<td>
<p>Default 'NULL'. A list with 'x'/'y' components that specify a bevel profile. See 'raybevel::generate_bevel()'</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_bevel_height">bevel_height</code></td>
<td>
<p>Default '1'. Height from the base of the polygon to the start of the beveled top.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_base_height">base_height</code></td>
<td>
<p>Default '0'. Height of the base of the polygon.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_raw_heights">raw_heights</code></td>
<td>
<p>Default 'FALSE'. A logical flag indicating whether the 'bevel_heights' are already 
in raw format and do not need to be multiplied by the maximum time of the skeleton.
See the documentation for 'raybevel::generate_beveled_polygon()' for more info.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_raw_offsets">raw_offsets</code></td>
<td>
<p>Default 'FALSE'. A logical flag indicating whether the 'bevel_offsets' are already 
in raw format and do not need to be multiplied by the maximum time of the skeleton. 
See the documentation for 'raybevel::generate_beveled_polygon()' for more info.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_heights_relative_to_centroid">heights_relative_to_centroid</code></td>
<td>
<p>Default 'FALSE'. Whether the heights should be measured in absolute
terms, or relative to the centroid of the polygon.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_set_max_height">set_max_height</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether to set the max height of the roof based on the 'max_height' argument.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_max_height">max_height</code></td>
<td>
<p>Default '1'. The maximum height of the polygon.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_scale_all_max">scale_all_max</code></td>
<td>
<p>Default 'FALSE'. If passing in a list of multiple skeletons with polygons, whether to scale each polygon to the overall
max height, or whether to scale each max height to the maximum internal distance in the polygon.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_data_column_top">data_column_top</code></td>
<td>
<p>Default 'NULL'. A string indicating the column in the 'sf' object to use 
to specify the top of the beveled polygon.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_data_column_bottom">data_column_bottom</code></td>
<td>
<p>Default 'NULL'. A string indicating the column in the 'sf' object to use 
to specify the bottom of the beveled polygon.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_scale_data">scale_data</code></td>
<td>
<p>Default '1'. If specifying 'data_column_top' or 'data_column_bottom', how
much to scale that value when rendering.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_holes">holes</code></td>
<td>
<p>Default '0'. If passing in a polygon directly, this specifies which index represents
the holes in the polygon. See the 'earcut' function in the 'decido' package for more information.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_alpha">alpha</code></td>
<td>
<p>Default '1'. Transparency of the polygons.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_lit">lit</code></td>
<td>
<p>Default 'TRUE'. Whether to light the polygons.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_flat_shading">flat_shading</code></td>
<td>
<p>Default 'FALSE'. Set to 'TRUE' to have nicer shading on the 3D polygons. This comes
with the slight penalty of increasing the memory use of the scene due to vertex duplication. This
will not affect software or high quality renders.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_light_altitude">light_altitude</code></td>
<td>
<p>Default 'c(45, 30)'. Degree(s) from the horizon from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_light_direction">light_direction</code></td>
<td>
<p>Default 'c(315, 225)'. Degree(s) from north from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_light_intensity">light_intensity</code></td>
<td>
<p>Default '1'. Intensity of the specular highlight on the polygons.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_light_relative">light_relative</code></td>
<td>
<p>Default 'FALSE'. Whether the light direction should be taken relative to the camera,
or absolute.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing polygons.</p>
</td></tr>
<tr><td><code id="render_beveled_polygons_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'rgl::triangles3d()'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# This function can also create fake "terrain" from polygons by visualizing the distance 
# to the nearest edge.
if(run_documentation()) {
#Render the county borders as polygons in Monterey Bay as terrain
montereybay %&gt;%
  sphere_shade(texture = "desert") %&gt;%
  add_shadow(ray_shade(montereybay,zscale = 50)) %&gt;%
  plot_3d(montereybay, water = TRUE, windowsize = 800, watercolor = "dodgerblue",
          background = "pink")

#We will apply a negative buffer to create space between adjacent polygons. You may
#have to call `sf::sf_use_s2(FALSE)` before running this code to get it to run.
sf::sf_use_s2(FALSE)
mont_county_buff = sf::st_simplify(sf::st_buffer(monterey_counties_sf,-0.003), dTolerance=0.001)

render_beveled_polygons(mont_county_buff,  flat_shading  = TRUE, angle = 45 , 
                        heightmap = montereybay, bevel_width=2000,
                        material = "red",
                        extent = attr(montereybay,"extent"),  
                        bevel_height = 5000, base_height=0, 
                        zscale=200) 
render_camera(theta = 0,  phi = 90, zoom = 0.65, fov = 0)
render_snapshot()
render_camera(theta=194, phi= 35,   zoom = 0.5, fov= 80)
render_snapshot()
}

# Changing the color of the beveled top:
if(run_documentation()) {
render_beveled_polygons(mont_county_buff,  flat_shading  = TRUE, angle = 45 , 
                        heightmap = montereybay, bevel_width=2000,
                        material = "tan", bevel_material = "darkgreen",
                        extent = attr(montereybay,"extent"), clear_previous=TRUE,
                        bevel_height = 5000, base_height=0, 
                        zscale=200) 
}
# We can create a nice curved surface by passing in a bevel generated with the 
# `raybevel::generate_bevel()` function. 
if(run_documentation()) {
render_beveled_polygons(mont_county_buff, flat_shading  = TRUE, heightmap = montereybay,
                        bevel = raybevel::generate_bevel("exp",bevel_end = 0.4),
                        #max_height = 10, scale_all_max = TRUE, set_max_height = TRUE,
                        material = rayvertex::material_list(diffuse="red", 
                                                            ambient = "darkred", 
                                                            diffuse_intensity = 0.2,
                                                            ambient_intensity = 0.1),
                        light_intensity = 1, light_relative = FALSE,
                        extent = attr(montereybay,"extent"), bevel_height = 5000, 
                        base_height=0, clear_previous = TRUE,
                        zscale=200) 
render_snapshot()
}

# While the bevels all start at the same point in the above example,
# they rise to different levels due to being scaled by the maximum internal distance
# in the polygon. Setting `scale_all_max = TRUE` ensures the bevels are all scaled to the 
# same maximum height (in this case, 3000m above the 5000m bevel start height).
if(run_documentation()) {
render_beveled_polygons(mont_county_buff, flat_shading  = TRUE, heightmap = montereybay,
                 bevel = raybevel::generate_bevel("exp",bevel_end = 0.4),
                 max_height = 3000, scale_all_max = TRUE, set_max_height = TRUE,
                 material = rayvertex::material_list(diffuse="red", 
                                                     ambient = "darkred", 
                                                     diffuse_intensity = 0.2,
                                                     ambient_intensity = 0.1),
                 light_intensity = 1, light_relative = FALSE,
                 extent = attr(montereybay,"extent"), bevel_height = 5000, 
                 base_height=0, clear_previous = TRUE,
                 zscale=200) 
render_snapshot()
}

# Rendering the polygons with `render_highquality()`
if(run_documentation()) {
  render_highquality()
}

# We can scale the size of the polygon to a column in the `sf` object as well:
# raybevel::generate_bevel() function. We can scale this data down using the `scale_data`
# argument. Note that this is applied as well as the `zscale` argument, and that you 
# must think carefully about your scales and values if trying to represent a meaningful
# data visualization with this object.
if(run_documentation()) {
render_beveled_polygons(mont_county_buff,  flat_shading  = TRUE, angle = 45, bevel_width=1000, 
                 data_column_top = "ALAND", scale_data = 1e-5, heightmap = montereybay,
                 #max_height = 1000, scale_all_max = TRUE, set_max_height = TRUE,
                 material = rayvertex::material_list(diffuse="red"),
                 light_intensity = 1, light_relative = FALSE,
                 extent = attr(montereybay,"extent"), clear_previous = TRUE,
                 zscale=200) 
render_snapshot()
}
</code></pre>

<hr>
<h2 id='render_buildings'>Render Buildings</h2><span id='topic+render_buildings'></span>

<h3>Description</h3>

<p>Adds 3D polygons with roofs to the current scene, 
using latitude/longitude or coordinates in the reference system defined by the extent object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_buildings(
  polygon,
  extent,
  material = "grey",
  roof_material = NA,
  angle = 45,
  zscale = 1,
  scale_data = 1,
  relative_heights = TRUE,
  heights_relative_to_centroid = FALSE,
  roof_height = 1,
  base_height = 0,
  data_column_top = NULL,
  data_column_bottom = NULL,
  heightmap = NULL,
  holes = 0,
  alpha = 1,
  lit = TRUE,
  flat_shading = FALSE,
  light_altitude = c(45, 30),
  light_direction = c(315, 225),
  light_intensity = 1,
  light_relative = FALSE,
  clear_previous = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_buildings_+3A_polygon">polygon</code></td>
<td>
<p>'sf' object, &quot;SpatialPolygon&quot; 'sp' object,  or xy coordinates
of polygon represented in a way that can be processed by 'xy.coords()'.  If
xy-coordinate based polygons are open, they will be closed by adding an
edge from the last point to the first.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the 3D scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;, &quot;ymin&quot;, &quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_material">material</code></td>
<td>
<p>Default '&quot;grey80&quot;'. If a color string, this will specify the color of the sides/base of the building 
Alternatively (for more customization), this can be a r'ayvertex::material_list()' object to specify
the full color/appearance/material options for the resulting 'ray_mesh' mesh.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_roof_material">roof_material</code></td>
<td>
<p>Default 'NA', defaults to the material specified in 'material'. If a color string, this will specify the color of the roof of the building. 
Alternatively (for more customization), this can be a 'rayvertex::material_list()' object to specify
the full color/appearance/material options for the resulting 'ray_mesh' mesh.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_angle">angle</code></td>
<td>
<p>Default '45'. Angle of the roof.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_scale_data">scale_data</code></td>
<td>
<p>Default '1'. How much to scale the 'top'/'bottom' value when rendering. Use
'zscale' to adjust the data to account for 'x'/'y' grid spacing, and this argument to scale the data
for visualization.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_relative_heights">relative_heights</code></td>
<td>
<p>Default 'TRUE'. Whether the heights specified in 'roof_height' and 'base_height' should
be measured relative to the underlying heightmap.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_heights_relative_to_centroid">heights_relative_to_centroid</code></td>
<td>
<p>Default 'FALSE'. Whether the heights should be measured in absolute
terms, or relative to the centroid of the polygon.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_roof_height">roof_height</code></td>
<td>
<p>Default '1'. Height from the base of the building to the start of the roof.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_base_height">base_height</code></td>
<td>
<p>Default '0'. Height of the base of the roof.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_data_column_top">data_column_top</code></td>
<td>
<p>Default 'NULL'. A string indicating the column in the 'sf' object to use 
to specify the top of the extruded polygon.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_data_column_bottom">data_column_bottom</code></td>
<td>
<p>Default 'NULL'. A string indicating the column in the 'sf' object to use 
to specify the bottom of the extruded polygon.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_holes">holes</code></td>
<td>
<p>Default '0'. If passing in a polygon directly, this specifies which index represents
the holes in the polygon. See the 'earcut' function in the 'decido' package for more information.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_alpha">alpha</code></td>
<td>
<p>Default '1'. Transparency of the polygons.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_lit">lit</code></td>
<td>
<p>Default 'TRUE'. Whether to light the polygons.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_flat_shading">flat_shading</code></td>
<td>
<p>Default 'FALSE'. Set to 'TRUE' to have nicer shading on the 3D polygons. This comes
with the slight penalty of increasing the memory use of the scene due to vertex duplication. This
will not affect software or high quality renders.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_light_altitude">light_altitude</code></td>
<td>
<p>Default 'c(45, 30)'. Degree(s) from the horizon from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_light_direction">light_direction</code></td>
<td>
<p>Default 'c(315, 225)'. Degree(s) from north from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_light_intensity">light_intensity</code></td>
<td>
<p>Default '1'. Intensity of the specular highlight on the polygons.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_light_relative">light_relative</code></td>
<td>
<p>Default 'FALSE'. Whether the light direction should be taken relative to the camera,
or absolute.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing polygons.</p>
</td></tr>
<tr><td><code id="render_buildings_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'rgl::triangles3d()'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
# Load and visualize building footprints from Open Street Map
library(osmdata)
library(sf)
library(raster)

osm_bbox = c(-121.9472, 36.6019, -121.9179, 36.6385)

#Get buildings from OpenStreetMap
opq(osm_bbox) |&gt;
  add_osm_feature("building") |&gt;
  osmdata_sf() -&gt;
osm_data

#Get roads from OpenStreetMap
opq(osm_bbox) |&gt;
  add_osm_feature("highway") |&gt;
  osmdata_sf() -&gt;
osm_road

#Get extent
building_polys = osm_data$osm_polygons
osm_dem = elevatr::get_elev_raster(building_polys, z = 11, clip = "bbox")
e = extent(building_polys)

# Crop DEM, but note that the cropped DEM will have an extent slightly different than what's 
# specified in `e`. Save that new extent to `new_e`.
osm_dem |&gt; 
  crop(e) |&gt; 
  extent() -&gt;
new_e

osm_dem |&gt; 
  crop(e) |&gt; 
  raster_to_matrix() -&gt;
osm_mat

#Visualize areas less than one meter as water (approximate tidal range)
osm_mat[osm_mat &lt;= 1] = -2

osm_mat %&gt;%
  rayimage::render_resized(mag=4) |&gt; 
  sphere_shade(texture = "desert") |&gt;
  add_overlay(generate_polygon_overlay(building_polys, extent = new_e,
                                       heightmap = osm_mat, 
                                       linewidth = 6,
                                       resolution_multiply = 50), rescale_original = TRUE) |&gt;
  add_overlay(generate_line_overlay(osm_road$osm_lines, extent = new_e,
                                    heightmap = osm_mat, 
                                    linewidth = 6,
                                    resolution_multiply = 50), rescale_original = TRUE) |&gt;
  plot_3d(osm_mat, water = TRUE, windowsize = 800, watercolor = "dodgerblue",
          zscale = 10,
          background = "pink")

#Render buildings
render_buildings(building_polys,  flat_shading  = TRUE, 
                 angle = 30 , heightmap = osm_mat, 
                 material = "white", roof_material = "white",
                 extent = new_e, roof_height = 3, base_height = 0,
                 zscale=10)
render_camera(theta=220, phi=22, zoom=0.45, fov=0)
render_snapshot()
}

if(run_documentation()) {
#Zoom in to show roof details and render with render_highquality()
render_camera(fov=110)
render_highquality(camera_location = c(18.22, 0.57, -50.83),
                   camera_lookat = c(20.88, -2.83, -38.87),
                   focal_distance = 13, 
                   lightdirection = 45)

}
</code></pre>

<hr>
<h2 id='render_camera'>Render Camera</h2><span id='topic+render_camera'></span>

<h3>Description</h3>

<p>Changes the position and properties of the camera around the scene. If no 
values are entered, prints and returns the current values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_camera(
  theta = NULL,
  phi = NULL,
  zoom = NULL,
  fov = NULL,
  shift_vertical = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_camera_+3A_theta">theta</code></td>
<td>
<p>Defaults to current value. Rotation angle.</p>
</td></tr>
<tr><td><code id="render_camera_+3A_phi">phi</code></td>
<td>
<p>Defaults to current value. Azimuth angle. Maximum '90'.</p>
</td></tr>
<tr><td><code id="render_camera_+3A_zoom">zoom</code></td>
<td>
<p>Defaults to current value. Positive value indicating camera magnification.</p>
</td></tr>
<tr><td><code id="render_camera_+3A_fov">fov</code></td>
<td>
<p>Defaults to current value. Field of view of the camera. Maximum '180'.</p>
</td></tr>
<tr><td><code id="render_camera_+3A_shift_vertical">shift_vertical</code></td>
<td>
<p>Default '0'. Amount to shift the viewpoint.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale = 50, water = TRUE, waterlinecolor="white")
render_snapshot()
}

#Shift the camera over and add a title
if(run_documentation()) {
render_camera(theta = -45, phi = 45)
render_snapshot(title_text = "Monterey Bay, CA",
               title_bar_color = "grey50")
}

#Shift to an overhead view (and change the text/title bar color)
if(run_documentation()) {
render_camera(theta = 0, phi = 89.9, zoom = 0.9)
render_snapshot(title_text = "Monterey Bay, CA",
               title_color = "white",
               title_bar_color = "darkgreen")
}

#Shift to an front view and add a vignette effect
if(run_documentation()) {
render_camera(theta = -90, phi = 30,zoom = 0.8)
render_snapshot(title_text = "Monterey Bay, CA",
               title_color = "white",
               title_bar_color = "blue",
               vignette = TRUE)
}

#Change the field of view (fov) and make the title bar opaque.
if(run_documentation()) {
render_camera(theta = -90, phi = 30,zoom = 0.5,fov = 130)
render_snapshot(title_text = "Monterey Bay, CA",
               title_color = "black",
               title_bar_alpha = 1,
               title_bar_color = "lightblue",
               vignette = TRUE)
}

#Here we render a series of frames to later stitch together into a movie.

if(run_documentation()) {
phivec = 20 + 70 * 1/(1 + exp(seq(-5, 10, length.out = 180)))
phivecfull = c(phivec, rev(phivec))
thetavec = 270 + 45 * sin(seq(0,359,length.out = 360) * pi/180)
zoomvechalf = 0.5 + 0.5 * 1/(1 + exp(seq(-5, 10, length.out = 180)))
zoomvec = c(zoomvechalf, rev(zoomvechalf))

for(i in 1:360) {
 render_camera(theta = thetavec[i],phi = phivecfull[i],zoom = zoomvec[i])
 #uncomment the next line to save each frame to the working directory
 #render_snapshot(paste0("frame", i, ".png"))
}
#Run this command in the command line using ffmpeg to stitch together a video:
#ffmpeg -framerate 60 -i frame%d.png -vcodec libx264 raymovie.mp4

#And run this command to convert the video to post to the web:
#ffmpeg -i raymovie.mp4 -pix_fmt yuv420p -profile:v baseline -level 3 -vf scale=-2:-2 rayweb.mp4

#Or we can use render_movie() to do this all automatically with type="custom" (uncomment to run):
#render_movie(filename = tempfile(fileext = ".mp4"), type = "custom", 
#             theta = thetavec, phi = phivecfull, zoom = zoomvec, fov=0)
}
</code></pre>

<hr>
<h2 id='render_clouds'>Render Clouds</h2><span id='topic+render_clouds'></span>

<h3>Description</h3>

<p>Render a 3D floating cloud layer of the map.
</p>
<p>Note: Underlying layers with transparency can cause rendering issues in rgl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_clouds(
  heightmap,
  start_altitude = 1000,
  end_altitude = 2000,
  sun_altitude = 10,
  sun_angle = 315,
  time = 0,
  cloud_cover = 0.5,
  layers = 10,
  offset_x = 0,
  offset_y = 0,
  scale_x = 1,
  scale_y = 1,
  scale_z = 1,
  frequency = 0.005,
  fractal_levels = 16,
  attenuation_coef = 1,
  seed = 1,
  zscale = 1,
  baseshape = "rectangle",
  clear_clouds = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_clouds_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. This is used by 'render_clouds()' to 
calculate the regions the clouds should be rendered in.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_start_altitude">start_altitude</code></td>
<td>
<p>Default '1000'. The bottom of the cloud layer.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_end_altitude">end_altitude</code></td>
<td>
<p>Default '2000'. The top of the cloud layer.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_sun_altitude">sun_altitude</code></td>
<td>
<p>Default '90'. The angle, in degrees (as measured from the horizon) from which the light originates.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_sun_angle">sun_angle</code></td>
<td>
<p>Default '315' (NW). The angle, in degrees, around the matrix from which the light originates. Zero degrees is North, increasing clockwise</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_time">time</code></td>
<td>
<p>Default '0'. Advance this to make the clouds evolve and change in shape.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_cloud_cover">cloud_cover</code></td>
<td>
<p>Default '0.5'. The percentage of cloud cover.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_layers">layers</code></td>
<td>
<p>Default '10'. The number of layers to render the cloud layer. 
The default is 'layers/(start_altitude - end_altitude)'.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_offset_x">offset_x</code></td>
<td>
<p>Default '0'. Change this to move the cloud layer sideways.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_offset_y">offset_y</code></td>
<td>
<p>Default '0'. Change this to move the cloud layer backwards and forwards.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_scale_x">scale_x</code></td>
<td>
<p>Default '1'. Scale the fractal pattern in the x direction.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_scale_y">scale_y</code></td>
<td>
<p>Default '1'. Scale the fractal pattern in the y direction.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_scale_z">scale_z</code></td>
<td>
<p>Default '1'. Scale the fractal pattern in the z (vertical) direction. (automatically calculated). Scale the fractal pattern in the z (vertical) direction.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_frequency">frequency</code></td>
<td>
<p>Default '0.005'. The base frequency of the noise used to calculate the fractal cloud structure.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_fractal_levels">fractal_levels</code></td>
<td>
<p>Default '16'. The fractal dimension used to calculate the noise. Higher values give more fine structure, but take longer to calculate.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_attenuation_coef">attenuation_coef</code></td>
<td>
<p>Default '1'. Amount of attenuation in the cloud (higher numbers give darker shadows).  This value is automatically scaled to account for increasing the number of layers.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_seed">seed</code></td>
<td>
<p>Default '1'. Random seed used to generate clouds.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_baseshape">baseshape</code></td>
<td>
<p>Default 'rectangle'. Shape of the base. Options are 'c(&quot;rectangle&quot;,&quot;circle&quot;,&quot;hex&quot;)'.</p>
</td></tr>
<tr><td><code id="render_clouds_+3A_clear_clouds">clear_clouds</code></td>
<td>
<p>Default 'FALSE'. Clears all existing floating layers on the visualization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds a 3D floating cloud layer to the map. No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Render a cloud layer over Monterey Bay
montereybay  %&gt;%
 sphere_shade()  %&gt;%
 plot_3d(montereybay,background="brown",zscale=50)

#Render some clouds
render_clouds(montereybay, zscale=50)  
render_snapshot()
}
if(run_documentation()) {
#Change the seed for a different set of clouds and add cloud shadows on the ground
montereybay  %&gt;%
 sphere_shade()  %&gt;%
 add_shadow(cloud_shade(montereybay,zscale=50, seed = 2), 0.0) %&gt;%
 plot_3d(montereybay,background="brown",zscale=50)
render_camera(theta=-65, phi = 25, zoom = 0.45, fov = 80)
render_clouds(montereybay, zscale=50, seed=2, clear_clouds = T)    
render_snapshot()
}

if(run_documentation()) {
montereybay  %&gt;%
 sphere_shade()  %&gt;%
 plot_3d(montereybay,background="brown",zscale=50)
 
#Lower the frequency for larger, smoother clouds
render_clouds(montereybay, zscale=50, frequency = 0.001, clear_clouds = T)
render_snapshot()
}
if(run_documentation()) {
#Increase the frequency for more broken clouds
render_clouds(montereybay, zscale=50, frequency = 0.05, clear_clouds = T)
render_snapshot()
}
if(run_documentation()) {
#Increase the fractal level for fluffier, bumpier clouds
render_clouds(montereybay, zscale=50, fractal_levels = 32, clear_clouds = T)
render_snapshot()
}
if(run_documentation()) {
#Decrease the fractal level for more smoother, continuous clouds
render_clouds(montereybay, zscale=50, fractal_levels = 4, clear_clouds = T)
render_snapshot()
}
if(run_documentation()) {
#Increase the cloud cover
render_clouds(montereybay, zscale=50, cloud_cover=0.8, clear_clouds = T)            
render_snapshot()
}
if(run_documentation()) {
#Decrease the cloud cover
render_clouds(montereybay, zscale=50, cloud_cover=0.2, clear_clouds = T)            
render_snapshot()
}
if(run_documentation()) {
#Change the altitude range of the clouds
render_clouds(montereybay,zscale=50,start_altitude=2000,end_altitude = 4000, clear_clouds = T)            
render_snapshot()
}
if(run_documentation()) {
#Increase the number of layers 
render_clouds(montereybay, zscale=50,start_altitude=2000,end_altitude = 4000, layers = 20,
             clear_clouds = T)
render_snapshot()
}
if(run_documentation()) {
#Change the sun angle and altitude, and increase the attenuation for darker clouds
render_clouds(montereybay,zscale=50,sun_angle=45, sun_altitude= 5, attenuation_coef = 5,
             clear_clouds = T)
render_snapshot()
}
if(run_documentation()) {
#Render the scene with a different baseshape
montereybay  %&gt;%
 sphere_shade()  %&gt;%
 plot_3d(montereybay,background="darkred",zscale=50, baseshape="hex")
render_clouds(montereybay,zscale=50, seed=3, baseshape="hex", clear_clouds = T)  
render_camera(zoom=0.65)
render_snapshot()
}
</code></pre>

<hr>
<h2 id='render_compass'>Render Compass Symbol</h2><span id='topic+render_compass'></span>

<h3>Description</h3>

<p>Places a compass on the map to specify the North direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_compass(
  angle = 0,
  position = "SE",
  altitude = NULL,
  zscale = 1,
  x = NULL,
  y = NULL,
  z = NULL,
  compass_radius = NULL,
  scale_distance = 1,
  color_n = "darkred",
  color_arrow = "grey90",
  color_background = "grey60",
  color_bevel = "grey20",
  position_circular = FALSE,
  clear_compass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_compass_+3A_angle">angle</code></td>
<td>
<p>Default '0'. The direction the arrow should be facing.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_position">position</code></td>
<td>
<p>Default 'SE'. A string representing a cardinal direction. Ignored if 'x', 'y', and 'z'
are manually specified.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_altitude">altitude</code></td>
<td>
<p>Default 'NULL'. Altitude of the compass, defaults to maximum height in the map.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. 
Only used in combination with 'altitude'.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_x">x</code></td>
<td>
<p>Default 'NULL'. X position. If not entered, automatically calculated using 'position' argument.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_y">y</code></td>
<td>
<p>Default 'NULL'. Y position. If not entered, automatically calculated using 'position' argument.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_z">z</code></td>
<td>
<p>Default 'NULL'. Z position. If not entered, automatically calculated using 'position' argument.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_compass_radius">compass_radius</code></td>
<td>
<p>Default 'NULL'. The radius of the compass. If not entered, automatically calculated. 
Increase or decrease the size of the compass.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_scale_distance">scale_distance</code></td>
<td>
<p>Default '1'. Multiplier that moves the compass away from the center of the map.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_color_n">color_n</code></td>
<td>
<p>Default 'darkred'. Color of the letter N.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_color_arrow">color_arrow</code></td>
<td>
<p>Default 'grey90'. Color of the arrow.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_color_background">color_background</code></td>
<td>
<p>Default 'grey20'. Color of the area right under the arrow.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_color_bevel">color_bevel</code></td>
<td>
<p>Default 'grey20'. Color of the bevel.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_position_circular">position_circular</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', will place compass at a constant radius away from
the map, as opposed to directly next to it. Overridden if user manually specifies position.</p>
</td></tr>
<tr><td><code id="render_compass_+3A_clear_compass">clear_compass</code></td>
<td>
<p>Default 'FALSE'. Clears the compass symbol(s) on the map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds compass to map. No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Add a North arrow to the map, by default in the bottom right (SE)
if(run_documentation()) {
montereybay %&gt;% 
 sphere_shade() %&gt;%
 plot_3d(montereybay,theta=-45, water=TRUE)
render_compass()
render_snapshot()
}
if(run_documentation()) {
#Remove the existing symbol with `clear_compass = TRUE`
render_compass(clear_compass = TRUE)

#Point the N towards the light, at 315 degrees:
render_compass(angle = 315)
render_snapshot()
}
if(run_documentation()) {
render_compass(clear_compass = TRUE)

#We can change the position by specifying a direction (here are three):
render_camera(theta=45,phi=45)
render_compass(position = "NW")
render_compass(position = "E")
render_compass(position = "S")
render_snapshot()
}
if(run_documentation()) {
render_compass(clear_compass = TRUE)

#We can also change the distance away from the edge by setting the `scale_distance` argument.
render_compass(position = "NW", scale_distance = 1.4)
render_compass(position = "E", scale_distance = 1.4)
render_compass(position = "S", scale_distance = 1.4)

#Zoom in slightly:
render_camera(theta=45,phi=45,zoom=0.7)
render_snapshot()
}
if(run_documentation()) {
render_compass(clear_compass = TRUE)

#We can also specify the radius directly with `compass_radius`:
render_camera(theta=0,phi=45,zoom=1)
render_compass(position = "N", scale_distance = 1.5, compass_radius=200)
render_compass(position = "E", scale_distance = 1.4, compass_radius=50)
render_compass(position = "S", scale_distance = 1.3, compass_radius=25)
render_compass(position = "W", scale_distance = 1.2, compass_radius=10)
render_snapshot()

render_compass(clear_compass = TRUE)
}
if(run_documentation()) {
#We can also adjust the position manually, be specifying all x, y and z arguments.
render_camera(theta=-45,phi=45,zoom=0.9)
render_compass(x = 150, y = 50, z = 150)
render_snapshot()
}
if(run_documentation()) {
# Compass support is also included in render_highquality()
render_highquality(clamp_value=10, min_variance = 0, sample_method = "sobol_blue")
}
if(run_documentation()) {
render_compass(clear_compass = TRUE)

#We can change the colors in the compass, and also set it a constant distance away with
#`position_circular = TRUE`:

render_camera(theta=0,phi=45,zoom=0.75)
render_compass(position = "N", color_n = "#55967a", color_arrow = "#fff673", 
            color_background = "#cfe0a9", color_bevel = "#8fb28a", position_circular = TRUE)
render_compass(position = "NE", color_n = "black", color_arrow = "grey90", 
            color_background = "grey50", color_bevel = "grey20", position_circular = TRUE)
render_compass(position = "E", color_n = "red", color_arrow = "blue",
            color_background = "yellow", color_bevel = "purple", position_circular = TRUE)
render_compass(position = "SE", color_n = c(0.7,0.5,0.9), color_arrow = c(0.8,0.8,1), 
            color_background = c(0.2,0.2,1), color_bevel = c(0.6,0.4,0.6), 
            position_circular = TRUE)
render_compass(position = "S", color_n = "#ffe3b3", color_arrow = "#6a463a", 
            color_background = "#abaf98", color_bevel = "grey20", position_circular = TRUE)
render_compass(position = "SW", color_n = "#ffe3a3", color_arrow = "#f1c3a9", 
            color_background = "#abaf98", color_bevel = "#66615e", position_circular = TRUE)
render_compass(position = "W", color_n = "#e9e671", color_arrow = "#cbb387", 
            color_background = "#7c9695", color_bevel = "#cbb387", position_circular = TRUE)
render_compass(position = "NW", color_n = c(0.7,0,0), color_arrow = c(0.3,0,0), 
            color_background = c(0.7,0.5,0.5), color_bevel = c(0.2,0,0), position_circular = TRUE)
render_snapshot()
}
</code></pre>

<hr>
<h2 id='render_contours'>Render Contours</h2><span id='topic+render_contours'></span>

<h3>Description</h3>

<p>Adds 3D contours to the current scene, using the heightmap of the 3D surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_contours(
  heightmap = NULL,
  zscale = 1,
  levels = NA,
  nlevels = NA,
  linewidth = 3,
  color = "black",
  palette = NULL,
  antialias = FALSE,
  offset = 0,
  clear_previous = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_contours_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All grid points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_levels">levels</code></td>
<td>
<p>Default 'NA'. Automatically generated with 10 levels. This argument specifies the exact height levels of each contour.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_nlevels">nlevels</code></td>
<td>
<p>Default 'NA'. Controls the auto-generation of levels. If levels is length-2, 
this will automatically generate 'nlevels' breaks between 'levels[1]' and 'levels[2]'.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '3'. The line width.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the line.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_palette">palette</code></td>
<td>
<p>Default 'NULL'. Overrides 'color'. Either a function that returns a color palette 
of 'n' colors, or a character vector with colors that specifies each color manually.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_antialias">antialias</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the line with be have anti-aliasing applied. NOTE: anti-aliasing can cause some unpredictable behavior with transparent surfaces.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_offset">offset</code></td>
<td>
<p>Default '5'. Offset of the track from the surface, if 'altitude = NULL'.</p>
</td></tr>
<tr><td><code id="render_contours_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing paths.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Add contours to the montereybay dataset
if(run_documentation()) {
montereybay %&gt;%
 height_shade() %&gt;%
 add_shadow(ray_shade(montereybay,zscale=50),0.3) %&gt;%
 plot_3d(montereybay, theta = -45, zscale=50)
render_contours(montereybay, zscale = 50, offset = 100)
render_snapshot()
}

if(run_documentation()) {
#Specify the number of levels
render_contours(montereybay, zscale = 50, offset = 100, nlevels = 30,
               clear_previous = TRUE)
render_snapshot()
}

if(run_documentation()) {
#Manually specify the breaks with levels
render_contours(montereybay, linewidth = 2,  offset = 100, zscale = 50,
               levels = seq(-2000, 0, 100), clear_previous = TRUE)
render_snapshot()
}

if(run_documentation()) {
#Use a color palette for the contours 
volcano |&gt; 
 constant_shade() |&gt; 
 plot_3d(volcano, zscale = 2, solid = FALSE, zoom = 0.8)
palette = grDevices::colorRampPalette(c("red", "purple", "pink"))
render_contours(volcano, offset = 1, palette = palette, zscale = 2, nlevels = 20)
render_snapshot()
}

if(run_documentation()) {
#Render using `render_highquality()` for a neon light effect
render_highquality(light = FALSE, 
                  line_radius = 0.1, sample_method="sobol_blue",
                  path_material = rayrender::light, ground_size = 0,
                  path_material_args = list(importance_sample = FALSE,
                                            color = "purple", intensity = 2))
}
</code></pre>

<hr>
<h2 id='render_depth'>Render Depth of Field</h2><span id='topic+render_depth'></span>

<h3>Description</h3>

<p>Adds depth of field to the current RGL scene by simulating a synthetic aperture. 
</p>
<p>The size of the circle of confusion is determined by the following formula (z_depth is from the image's depth map).
</p>
<p><code>abs(z_depth-focus)*focal_length^2/(f_stop*z_depth*(focus - focal_length))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_depth(
  focus = NULL,
  focallength = 100,
  fstop = 4,
  filename = NULL,
  preview_focus = FALSE,
  bokehshape = "circle",
  bokehintensity = 1,
  bokehlimit = 0.8,
  rotation = 0,
  gamma_correction = TRUE,
  aberration = 0,
  transparent_water = FALSE,
  heightmap = NULL,
  zscale = NULL,
  title_text = NULL,
  title_offset = c(20, 20),
  title_color = "black",
  title_size = 30,
  title_font = "sans",
  title_bar_color = NULL,
  title_bar_alpha = 0.5,
  title_position = "northwest",
  image_overlay = NULL,
  vignette = FALSE,
  vignette_color = "black",
  vignette_radius = 1.3,
  progbar = interactive(),
  software_render = FALSE,
  width = NULL,
  height = NULL,
  camera_location = NULL,
  camera_lookat = c(0, 0, 0),
  background = "white",
  text_angle = NULL,
  text_size = 10,
  text_offset = c(0, 0, 0),
  point_radius = 0.5,
  line_offset = 1e-07,
  cache_scene = FALSE,
  reset_scene_cache = FALSE,
  print_scene_info = FALSE,
  instant_capture = interactive(),
  clear = FALSE,
  bring_to_front = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_depth_+3A_focus">focus</code></td>
<td>
<p>Focal point. Defaults to the center of the bounding box. Depth in which to blur, in distance to the camera plane.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_focallength">focallength</code></td>
<td>
<p>Default '1'. Focal length of the virtual camera.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_fstop">fstop</code></td>
<td>
<p>Default '1'. F-stop of the virtual camera.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_filename">filename</code></td>
<td>
<p>The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_preview_focus">preview_focus</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', a red line will be drawn across the image
showing where the camera will be focused.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_bokehshape">bokehshape</code></td>
<td>
<p>Default 'circle'. Also built-in: 'hex'. The shape of the bokeh.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_bokehintensity">bokehintensity</code></td>
<td>
<p>Default '3'. Intensity of the bokeh when the pixel intensity is greater than 'bokehlimit'.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_bokehlimit">bokehlimit</code></td>
<td>
<p>Default '0.8'. Limit after which the bokeh intensity is increased by 'bokehintensity'.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_rotation">rotation</code></td>
<td>
<p>Default '0'. Number of degrees to rotate the hexagon bokeh shape.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_gamma_correction">gamma_correction</code></td>
<td>
<p>Default 'TRUE'. Controls gamma correction when adding colors. Default exponent of 2.2.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_aberration">aberration</code></td>
<td>
<p>Default '0'. Adds chromatic aberration to the image. Maximum of '1'.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_transparent_water">transparent_water</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', depth is determined without water layer. User will have to re-render the water
layer with 'render_water()' if they want to recreate the water layer.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. The height matrix for the scene. Passing this will allow 'render_depth()' 
to automatically redraw the water layer if 'transparent_water = TRUE'.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_zscale">zscale</code></td>
<td>
<p>Default 'NULL'. The zscale value for the heightmap. Passing this will allow 'render_depth()' 
to automatically redraw the water layer if 'transparent_water = TRUE'.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_title_text">title_text</code></td>
<td>
<p>Default 'NULL'. Text. Adds a title to the image, using magick::image_annotate.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_title_offset">title_offset</code></td>
<td>
<p>Default 'c(20,20)'. Distance from the top-left (default, 'gravity' direction in 
image_annotate) corner to offset the title.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_title_color">title_color</code></td>
<td>
<p>Default 'black'. Font color.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_title_size">title_size</code></td>
<td>
<p>Default '30'. Font size in pixels.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_title_font">title_font</code></td>
<td>
<p>Default 'sans'. String with font family such as &quot;sans&quot;, &quot;mono&quot;, &quot;serif&quot;, &quot;Times&quot;, &quot;Helvetica&quot;, 
&quot;Trebuchet&quot;, &quot;Georgia&quot;, &quot;Palatino&quot; or &quot;Comic Sans&quot;.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_title_bar_color">title_bar_color</code></td>
<td>
<p>Default 'NULL'. If a color, this will create a colored bar under the title.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_title_bar_alpha">title_bar_alpha</code></td>
<td>
<p>Default '0.5'. Transparency of the title bar.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_title_position">title_position</code></td>
<td>
<p>Default 'northwest'. Position of the title.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_image_overlay">image_overlay</code></td>
<td>
<p>Default 'NULL'. Either a string indicating the location of a png image to overlay
over the image (transparency included), or a 4-layer RGBA array. This image will be resized to the 
dimension of the image if it does not match exactly.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_vignette">vignette</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE' or numeric, a camera vignetting effect will be added to the image.
'1' is the darkest vignetting, while '0' is no vignetting. If vignette is a length-2 vector, the second entry will
control the blurriness of the vignette effect.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_vignette_color">vignette_color</code></td>
<td>
<p>Default '&quot;black&quot;'. Color of the vignette.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_vignette_radius">vignette_radius</code></td>
<td>
<p>Default '1.3'. Radius of the vignette, as a porportion of the image dimensions.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_progbar">progbar</code></td>
<td>
<p>Default 'TRUE' if in an interactive session. Displays a progress bar.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_software_render">software_render</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', rayshader will use the rayvertex package to render the snapshot, which
is not constrained by the screen size or requires OpenGL.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_width">width</code></td>
<td>
<p>Default 'NULL'. Optional argument to pass to 'rgl::snapshot3d()' to specify the
width when 'software_render = TRUE'..</p>
</td></tr>
<tr><td><code id="render_depth_+3A_height">height</code></td>
<td>
<p>Default 'NULL'. Optional argument to pass to 'rgl::snapshot3d()' to specify the
height when 'software_render = TRUE'.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_camera_location">camera_location</code></td>
<td>
<p>Default 'NULL'. Custom position of the camera. The 'FOV', 'width', and 'height' arguments will still
be derived from the rgl window.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_camera_lookat">camera_lookat</code></td>
<td>
<p>Default 'NULL'. Custom point at which the camera is directed. The 'FOV', 'width', and 'height' arguments will still
be derived from the rgl window.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_background">background</code></td>
<td>
<p>Default '&quot;white&quot;'. Background color when 'software_render = TRUE'.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_text_angle">text_angle</code></td>
<td>
<p>Default 'NULL', which forces the text always to face the camera. If a single angle (degrees),
will specify the absolute angle all the labels are facing. If three angles, this will specify all three orientations
(relative to the x,y, and z axes) of the text labels.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_text_size">text_size</code></td>
<td>
<p>Default '10'. Height of the text.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_text_offset">text_offset</code></td>
<td>
<p>Default 'c(0,0,0)'. Offset to be applied to all text labels.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_point_radius">point_radius</code></td>
<td>
<p>Default '0.5'. Radius of 3D points (rendered with 'render_points()'.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_line_offset">line_offset</code></td>
<td>
<p>Default '1e-7'. Small number indicating the offset in the scene to apply to lines if using software rendering. Increase this if your lines 
aren't showing up, or decrease it if lines are appearing through solid objects.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_cache_scene">cache_scene</code></td>
<td>
<p>Default 'FALSE'. Whether to cache the current scene to memory so it does not have to be converted to a 'raymesh' object 
each time 'render_snapshot()' is called. If 'TRUE' and a scene has been cached, it will be used when rendering.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_reset_scene_cache">reset_scene_cache</code></td>
<td>
<p>Default 'FALSE'. Resets the scene cache before rendering.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_print_scene_info">print_scene_info</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will print the position and lookat point of the camera.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_instant_capture">instant_capture</code></td>
<td>
<p>Default 'TRUE' if interactive, 'FALSE' otherwise. If 'FALSE', a slight delay is added 
before taking the snapshot. This can help stop prevent rendering issues when running scripts.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_clear">clear</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the current 'rgl' device will be cleared.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_bring_to_front">bring_to_front</code></td>
<td>
<p>Default 'FALSE'. Whether to bring the window to the front when rendering the snapshot.</p>
</td></tr>
<tr><td><code id="render_depth_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to 'rayvertex::rasterize_scene()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4-layer RGBA array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50, water=TRUE, waterlinecolor="white",
         zoom=0.3,theta=-135,fov=70, phi=20) 
 
#Preview where the focal plane lies
render_depth(preview_focus=TRUE)
}
if(run_documentation()) {
#Render the depth of field effect
render_depth(focallength = 300)
}
if(run_documentation()) {
#Add a chromatic aberration effect
render_depth(focallength = 300, aberration = 0.3)
}
if(run_documentation()) {
#Render the depth of field effect, ignoring water and re-drawing the waterlayer
render_depth(preview_focus=TRUE, 
            heightmap = montereybay, zscale=50, focallength=300, transparent_water=TRUE)
render_depth(heightmap = montereybay, zscale=50, focallength=300, transparent_water=TRUE)
render_camera(theta=45,zoom=0.15,phi=20)
}

if(run_documentation()) {
#Change the bokeh shape and intensity
render_depth(focus=900, bokehshape = "circle",focallength=500,bokehintensity=30,
            title_text = "Circular Bokeh", title_size = 30, title_color = "white", 
            title_bar_color = "black")
render_depth(focus=900, bokehshape = "hex",focallength=500,bokehintensity=30,
            title_text = "Hexagonal Bokeh", title_size = 30, title_color = "white", 
            title_bar_color = "black")
}

if(run_documentation()) {
#Add a title and vignette effect.
render_camera(theta=0,zoom=0.7,phi=30)
render_depth(focallength = 250, title_text = "Monterey Bay, CA", 
            title_size = 20, title_color = "white", title_bar_color = "black", vignette = TRUE)
}
</code></pre>

<hr>
<h2 id='render_floating_overlay'>Render Floating overlay</h2><span id='topic+render_floating_overlay'></span>

<h3>Description</h3>

<p>Render a 2D floating overlay over the map. 
</p>
<p>Note: Multiple layers with transparency can cause rendering issues in rgl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_floating_overlay(
  overlay = NULL,
  altitude = NULL,
  heightmap = NULL,
  zscale = 1,
  alpha = 1,
  baseshape = "rectangle",
  remove_na = TRUE,
  reorient = TRUE,
  clear_layers = FALSE,
  horizontal_offset = c(0, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_floating_overlay_+3A_overlay">overlay</code></td>
<td>
<p>Overlay (4D RGBA array) to be rendered on the 3D map.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_altitude">altitude</code></td>
<td>
<p>Altitude to place the overlay.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_heightmap">heightmap</code></td>
<td>
<p>The underlying surface. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10. Adjust the zscale down to exaggerate elevation features.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_alpha">alpha</code></td>
<td>
<p>Default &lsquo;1'. Multiplies the layer&rsquo;s transparency by this factor. 0 is completely transparent.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_baseshape">baseshape</code></td>
<td>
<p>Default 'rectangle'. Shape of the overlay. Options are 'c(&quot;rectangle&quot;, &quot;circle&quot;, &quot;hex&quot;)'.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_remove_na">remove_na</code></td>
<td>
<p>Default 'TRUE'. Whether to make the overlay transparent above empty spaces (represented by 'NA' values) in the underlying elevation matrix.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_reorient">reorient</code></td>
<td>
<p>Default 'TRUE'. Whether to reorient the image array to match the 3D plot.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_clear_layers">clear_layers</code></td>
<td>
<p>Default 'FALSE'. Clears all existing floating layers on the visualization.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_horizontal_offset">horizontal_offset</code></td>
<td>
<p>Default 'c(0,0)'. Distance (in 3D space) to offset the floating offset in the x/y directions.</p>
</td></tr>
<tr><td><code id="render_floating_overlay_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'rgl::triangles3d()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds a 3D floating layer to the map. No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Render the road network as a floating overlay layer, along with a label annotation and a floating
#point annotation
if(all(length(find.package("sf", quiet = TRUE)) &gt; 0,
      length(find.package("magick", quiet = TRUE)) &gt; 0)) {
 monterey = c(-121.892933,36.603053)
 monterey_city = sf::st_sfc(sf::st_point(monterey))
 
 #Generate Overlays
 road_overlay = generate_line_overlay(monterey_roads_sf, attr(montereybay,"extent"), 
                                      heightmap = montereybay)
 point_overlay = generate_point_overlay(monterey_city, color="red", size=12,
                                        attr(montereybay,"extent"), heightmap = montereybay)
                                        
 #Create 3D plot (water transparency set to 1 because multiple transparency layers can interfere)
 montereybay |&gt;
   height_shade() |&gt;
   add_shadow(ray_shade(montereybay,zscale=50),0.3) |&gt; 
   plot_3d(montereybay, water = T, wateralpha = 1, windowsize = 800, watercolor = "lightblue")
 render_camera(theta=-55,phi=45,zoom=0.8)
 
 #Render label
 render_label(montereybay, lat = monterey[2], long = monterey[1], altitude = 9900,
              extent = attr(montereybay, "extent"),
              zscale = 50, text = "Monterey", textcolor = "black", linecolor="darkred")
 
 #Render Floating Overlays
 render_floating_overlay(road_overlay, altitude = 10000,zscale = 50)
 render_floating_overlay(point_overlay, altitude = 100,zscale = 50)
 render_snapshot()
}
}
</code></pre>

<hr>
<h2 id='render_highquality'>Render High Quality</h2><span id='topic+render_highquality'></span>

<h3>Description</h3>

<p>Renders a raytraced version of the displayed rgl scene, using the 'rayrender' package. 
User can specify the light direction, intensity, and color, as well as specify the material of the 
ground and add additional scene elements.
</p>
<p>This function can also generate frames for an animation by passing camera animation information from 
either 'convert_path_to_animation_coords()' or 'rayrender::generate_camera_motion()' functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_highquality(
  filename = NA,
  samples = 128,
  sample_method = "sobol_blue",
  min_variance = 1e-07,
  light = TRUE,
  lightdirection = 315,
  lightaltitude = 45,
  lightsize = NULL,
  lightintensity = 500,
  lightcolor = "white",
  material = rayrender::diffuse(),
  override_material = FALSE,
  cache_scene = FALSE,
  reset_scene_cache = FALSE,
  width = NULL,
  height = NULL,
  text_angle = NULL,
  text_size = 6,
  text_offset = c(0, 0, 0),
  line_radius = 0.5,
  point_radius = 0.5,
  smooth_line = FALSE,
  use_extruded_paths = FALSE,
  scale_text_angle = NULL,
  scale_text_size = 6,
  scale_text_offset = c(0, 0, 0),
  title_text = NULL,
  title_offset = c(20, 20),
  title_color = "black",
  title_size = 30,
  title_font = "sans",
  title_bar_color = NULL,
  title_bar_alpha = 0.5,
  ground_material = rayrender::diffuse(),
  ground_size = 1e+05,
  scene_elements = NULL,
  camera_location = NULL,
  camera_lookat = NULL,
  camera_interpolate = 1,
  clear = FALSE,
  return_scene = FALSE,
  print_scene_info = FALSE,
  clamp_value = 10,
  calculate_consistent_normals = FALSE,
  load_normals = TRUE,
  point_material = rayrender::diffuse,
  point_material_args = list(),
  path_material = rayrender::diffuse,
  path_material_args = list(),
  animation_camera_coords = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_highquality_+3A_filename">filename</code></td>
<td>
<p>Default 'NA'. Filename of saved image. If missing, will display to current device.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_samples">samples</code></td>
<td>
<p>Default '128'. The maximum number of samples for each pixel. Increase this to increase the quality of the rendering.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_sample_method">sample_method</code></td>
<td>
<p>Default '&quot;sobol_blue&quot;', unless 'samples &gt; 256', in which it defaults to '&quot;sobol&quot;'.
The type of sampling method used to generate random numbers. 
The other options are 'random' (worst quality but fastest), 
'sobol_blue' (best option for sample counts below 256), and 'sobol' 
(slowest but best quality, better than 'sobol_blue' for sample counts greater than 256).</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_min_variance">min_variance</code></td>
<td>
<p>Default '1e-6'. Minimum acceptable variance for a block of pixels for the adaptive sampler. 
Smaller numbers give higher quality images, at the expense of longer rendering times. 
If this is set to zero, the adaptive sampler will be turned off and the renderer will use the maximum number of samples everywhere.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_light">light</code></td>
<td>
<p>Default 'TRUE'. Whether there should be a light in the scene. If not, the scene will be lit with a bluish sky.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_lightdirection">lightdirection</code></td>
<td>
<p>Default '315'. Position of the light angle around the scene. 
If this is a vector longer than one, multiple lights will be generated (using values from 
'lightaltitude', 'lightintensity', and 'lightcolor')</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_lightaltitude">lightaltitude</code></td>
<td>
<p>Default '45'. Angle above the horizon that the light is located. 
If this is a vector longer than one, multiple lights will be generated (using values from 
'lightdirection', 'lightintensity', and 'lightcolor')</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_lightsize">lightsize</code></td>
<td>
<p>Default 'NULL'. Radius of the light(s). Automatically chosen, but can be set here by the user.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_lightintensity">lightintensity</code></td>
<td>
<p>Default '500'. Intensity of the light.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_lightcolor">lightcolor</code></td>
<td>
<p>Default 'white'. The color of the light.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_material">material</code></td>
<td>
<p>Default 'rayrender::diffuse()'. The material properties of the object file. Only used if 'override_material = TRUE'</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_override_material">override_material</code></td>
<td>
<p>Default 'FALSE'. Whether to override the default diffuse material with that in argument 'material'.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_cache_scene">cache_scene</code></td>
<td>
<p>Default 'FALSE'. Whether to cache the current scene to memory so it does not have to be converted to a 'raymesh' object 
each time 'render_snapshot()' is called. If 'TRUE' and a scene has been cached, it will be used when rendering.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_reset_scene_cache">reset_scene_cache</code></td>
<td>
<p>Default 'FALSE'. Resets the scene cache before rendering.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_width">width</code></td>
<td>
<p>Defaults to the width of the rgl window. Width of the rendering.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_height">height</code></td>
<td>
<p>Defaults to the height of the rgl window. Height of the rendering.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_text_angle">text_angle</code></td>
<td>
<p>Default 'NULL', which forces the text always to face the camera. If a single angle (degrees),
will specify the absolute angle all the labels are facing. If three angles, this will specify all three orientations
(relative to the x,y, and z axes) of the text labels.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_text_size">text_size</code></td>
<td>
<p>Default '6'. Height of the text.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_text_offset">text_offset</code></td>
<td>
<p>Default 'c(0,0,0)'. Offset to be applied to all text labels.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_line_radius">line_radius</code></td>
<td>
<p>Default '0.5'. Radius of line/path segments.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_point_radius">point_radius</code></td>
<td>
<p>Default '0.5'. Radius of 3D points (rendered with 'render_points()'.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_smooth_line">smooth_line</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the line will be rendered with a continuous smooth line, rather
than straight segments.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_use_extruded_paths">use_extruded_paths</code></td>
<td>
<p>Default 'TRUE'. If 'FALSE', paths will be generated with the 'rayrender::path()' object, instead
of 'rayrender::extruded_path()'.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_scale_text_angle">scale_text_angle</code></td>
<td>
<p>Default 'NULL'. Same as 'text_angle', but for the scale bar.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_scale_text_size">scale_text_size</code></td>
<td>
<p>Default '6'. Height of the scale bar text.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_scale_text_offset">scale_text_offset</code></td>
<td>
<p>Default 'c(0,0,0)'. Offset to be applied to all scale bar text labels.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_title_text">title_text</code></td>
<td>
<p>Default 'NULL'. Text. Adds a title to the image, using magick::image_annotate.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_title_offset">title_offset</code></td>
<td>
<p>Default 'c(20,20)'. Distance from the top-left (default, 'gravity' direction in 
image_annotate) corner to offset the title.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_title_color">title_color</code></td>
<td>
<p>Default 'black'. Font color.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_title_size">title_size</code></td>
<td>
<p>Default '30'. Font size in pixels.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_title_font">title_font</code></td>
<td>
<p>Default 'sans'. String with font family such as &quot;sans&quot;, &quot;mono&quot;, &quot;serif&quot;, &quot;Times&quot;, &quot;Helvetica&quot;, 
&quot;Trebuchet&quot;, &quot;Georgia&quot;, &quot;Palatino&quot; or &quot;Comic Sans&quot;.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_title_bar_color">title_bar_color</code></td>
<td>
<p>Default 'NULL'. If a color, this will create a colored bar under the title.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_title_bar_alpha">title_bar_alpha</code></td>
<td>
<p>Default '0.5'. Transparency of the title bar.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_ground_material">ground_material</code></td>
<td>
<p>Default 'diffuse()'. Material defined by the rayrender material functions.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_ground_size">ground_size</code></td>
<td>
<p>Default '100000'. The width of the plane representing the ground.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_scene_elements">scene_elements</code></td>
<td>
<p>Default 'NULL'. Extra scene elements to add to the scene, created with rayrender.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_camera_location">camera_location</code></td>
<td>
<p>Default 'NULL'. Custom position of the camera. The 'FOV', 'width', and 'height' arguments will still
be derived from the rgl window.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_camera_lookat">camera_lookat</code></td>
<td>
<p>Default 'NULL'. Custom point at which the camera is directed. The 'FOV', 'width', and 'height' arguments will still
be derived from the rgl window.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_camera_interpolate">camera_interpolate</code></td>
<td>
<p>Default 'c(0,0)'. Maximum '1', minimum '0'. Sets the camera at a point between the 'rgl' view and the 'camera_location' 
and 'camera_lookat' vectors.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_clear">clear</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the current 'rgl' device will be cleared.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_return_scene">return_scene</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will return the rayrender scene (instead of rendering the image).</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_print_scene_info">print_scene_info</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will print the position and lookat point of the camera.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_clamp_value">clamp_value</code></td>
<td>
<p>Default '10'. See documentation for 'rayrender::render_scene()'.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_calculate_consistent_normals">calculate_consistent_normals</code></td>
<td>
<p>Default 'FALSE'. Whether to calculate consistent vertex normals to prevent energy 
loss at edges.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_load_normals">load_normals</code></td>
<td>
<p>Default 'TRUE'. Whether to load the vertex normals if they exist in the OBJ file.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_point_material">point_material</code></td>
<td>
<p>Default 'rayrender::diffuse'. The rayrender material function to be applied
to point data.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_point_material_args">point_material_args</code></td>
<td>
<p>Default empty 'list()'. The function arguments to 'point_material'. 
The argument 'color' will be automatically extracted from the rgl scene, but all other arguments 
can be specified here.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_path_material">path_material</code></td>
<td>
<p>Default 'rayrender::diffuse'. The rayrender material function to be applied
to path data.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_path_material_args">path_material_args</code></td>
<td>
<p>Default empty 'list()'. The function arguments to 'path_material'. 
The argument 'color' will be automatically extracted from the rgl scene, but all other arguments 
can be specified here.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_animation_camera_coords">animation_camera_coords</code></td>
<td>
<p>Default 'NULL'. Expects camera animation output from either 'convert_path_to_animation_coords()'
or 'rayrender::generate_camera_motion()' functions.</p>
</td></tr>
<tr><td><code id="render_highquality_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to 'rayrender::render_scene'()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Render the volcano dataset using pathtracing
if(run_documentation()) {
volcano %&gt;%
 sphere_shade() %&gt;%
 plot_3d(volcano,zscale = 2)
render_highquality(min_variance = 0, sample_method = "sobol_blue") 
}

#Change position of light
if(run_documentation()) {
render_highquality(lightdirection = 45, min_variance = 0, sample_method = "sobol_blue")
}

#Change vertical position of light
if(run_documentation()) {
render_highquality(lightdirection = 45, lightaltitude = 10, 
                  min_variance = 0, sample_method = "sobol_blue")
}

#Change the ground material
if(run_documentation()) {
render_highquality(lightdirection = 45, lightaltitude=60,
                  ground_material = rayrender::diffuse(checkerperiod = 30, checkercolor="grey50"),
                  min_variance = 0, sample_method = "sobol_blue")
}

#Add three different color lights and a title
if(run_documentation()) {
render_highquality(lightdirection = c(0,120,240), lightaltitude=45,
                  lightcolor=c("red","green","blue"), title_text = "Red, Green, Blue",
                  title_bar_color="white", title_bar_alpha=0.8,
                  min_variance = 0, sample_method = "sobol_blue")
}

#Change the camera:
if(run_documentation()) {
render_camera(theta=-45,phi=60,fov=60,zoom=0.8)
render_highquality(lightdirection = c(0),
                  title_bar_color="white", title_bar_alpha=0.8,
                  min_variance = 0, sample_method = "sobol_blue")
}
#Add a shiny metal sphere
if(run_documentation()) {
render_camera(theta=-45,phi=60,fov=60,zoom=0.8)
render_highquality(lightdirection = c(0,120,240), lightaltitude=45, 
                  lightcolor=c("red","green","blue"),
                  scene_elements = rayrender::sphere(z=-60,y=0,
                                                     radius=20,material=rayrender::metal()),
                  min_variance = 0, sample_method = "sobol_blue")
}

#Add a red light to the volcano and change the ambient light to dusk
if(run_documentation()) {
render_camera(theta=45,phi=45)
render_highquality(lightdirection = c(240), lightaltitude=30, 
                  lightcolor=c("#5555ff"),
                  scene_elements = rayrender::sphere(z=0,y=15, x=-18, radius=5,
                                   material=rayrender::light(color="red",intensity=10)),
                  min_variance = 0, sample_method = "sobol_blue")
}
#Manually change the camera location and direction
if(run_documentation()) {
render_camera(theta=45,phi=45,fov=90)
render_highquality(lightdirection = c(240), lightaltitude=30, lightcolor=c("#5555ff"), 
                  camera_location = c(50,10,10), camera_lookat = c(0,15,0),
                  scene_elements = rayrender::sphere(z=0,y=15, x=-18, radius=5,
                                   material=rayrender::light(color="red",intensity=10)),
                  min_variance = 0, sample_method = "sobol_blue")
}
</code></pre>

<hr>
<h2 id='render_label'>Render Label</h2><span id='topic+render_label'></span>

<h3>Description</h3>

<p>Adds a marker and label to the current 3D plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_label(
  heightmap,
  text,
  lat,
  long,
  altitude = NULL,
  extent = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  zscale = 1,
  relativez = TRUE,
  offset = 0,
  clear_previous = FALSE,
  textsize = 1,
  dashed = FALSE,
  dashlength = "auto",
  linewidth = 3,
  antialias = FALSE,
  alpha = 1,
  textalpha = 1,
  freetype = TRUE,
  adjustvec = NULL,
  family = "sans",
  fonttype = "standard",
  linecolor = "black",
  textcolor = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_label_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_label_+3A_text">text</code></td>
<td>
<p>The label text.</p>
</td></tr>
<tr><td><code id="render_label_+3A_lat">lat</code></td>
<td>
<p>A latitude for the text. Must provide an 'raster::extent' object to argument 'extent' for the map.</p>
</td></tr>
<tr><td><code id="render_label_+3A_long">long</code></td>
<td>
<p>A latitude for the text. Must provide an 'raster::extent' object to argument 'extent' for the map.</p>
</td></tr>
<tr><td><code id="render_label_+3A_altitude">altitude</code></td>
<td>
<p>Default 'NULL'. Elevation of the label, in units of the elevation matrix (scaled by zscale). If none is passed, this will default to 10 percent above the maximum altitude in the heightmap.</p>
</td></tr>
<tr><td><code id="render_label_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_label_+3A_x">x</code></td>
<td>
<p>Default 'NULL'. Directly specify the 'x' index in the matrix to place the label.</p>
</td></tr>
<tr><td><code id="render_label_+3A_y">y</code></td>
<td>
<p>Default 'NULL'. Directly specify the 'y' index in the matrix to place the label.</p>
</td></tr>
<tr><td><code id="render_label_+3A_z">z</code></td>
<td>
<p>Default 'NULL'. Elevation of the label, in units of the elevation matrix (scaled by zscale).</p>
</td></tr>
<tr><td><code id="render_label_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units</p>
</td></tr>
<tr><td><code id="render_label_+3A_relativez">relativez</code></td>
<td>
<p>Default 'TRUE'. Whether 'z' should be measured in relation to the underlying elevation at that point in the heightmap, or set absolutely ('FALSE').</p>
</td></tr>
<tr><td><code id="render_label_+3A_offset">offset</code></td>
<td>
<p>Elevation above the surface (at the label point) to start drawing the line.</p>
</td></tr>
<tr><td><code id="render_label_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing text and lines rendered with 'render_label()'. If no
other arguments are passed to 'render_label()', this will just remove all existing lines.</p>
</td></tr>
<tr><td><code id="render_label_+3A_textsize">textsize</code></td>
<td>
<p>Default '1'. A numeric character expansion value.</p>
</td></tr>
<tr><td><code id="render_label_+3A_dashed">dashed</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the label line is dashed.</p>
</td></tr>
<tr><td><code id="render_label_+3A_dashlength">dashlength</code></td>
<td>
<p>Default 'auto'. Length, in units of the elevation matrix (scaled by 'zscale') of the dashes if 'dashed = TRUE'.</p>
</td></tr>
<tr><td><code id="render_label_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '3'. The line width.</p>
</td></tr>
<tr><td><code id="render_label_+3A_antialias">antialias</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the line with be have anti-aliasing applied. NOTE: anti-aliasing can cause some unpredictable behavior with transparent surfaces.</p>
</td></tr>
<tr><td><code id="render_label_+3A_alpha">alpha</code></td>
<td>
<p>Default '1'. Transparency of the label line.</p>
</td></tr>
<tr><td><code id="render_label_+3A_textalpha">textalpha</code></td>
<td>
<p>Default '1'. Transparency of the label text.</p>
</td></tr>
<tr><td><code id="render_label_+3A_freetype">freetype</code></td>
<td>
<p>Default 'TRUE'. Set to 'FALSE' if freetype is not installed (freetype enables anti-aliased fonts). NOTE: There are occasionally transparency issues when positioning Freetype fonts in front and behind a transparent surface.</p>
</td></tr>
<tr><td><code id="render_label_+3A_adjustvec">adjustvec</code></td>
<td>
<p>Default 'c(0.5,-0.5)'. The horizontal and vertical offset for the text. If 'freetype = FALSE' and on macOS/Linux, this is adjusted to 'c(0.33,-0.5)' to keep the type centered.</p>
</td></tr>
<tr><td><code id="render_label_+3A_family">family</code></td>
<td>
<p>Default '&quot;sans&quot;'. Font family. Choices are 'c(&quot;serif&quot;, &quot;sans&quot;, &quot;mono&quot;, &quot;symbol&quot;)'.</p>
</td></tr>
<tr><td><code id="render_label_+3A_fonttype">fonttype</code></td>
<td>
<p>Default '&quot;standard&quot;'. The font type. Choices are 'c(&quot;standard&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bolditalic&quot;)'. NOTE: These require FreeType fonts, which may not be installed on your system. See the documentation for rgl::text3d() for more information.</p>
</td></tr>
<tr><td><code id="render_label_+3A_linecolor">linecolor</code></td>
<td>
<p>Default 'black'. Color of the line.</p>
</td></tr>
<tr><td><code id="render_label_+3A_textcolor">textcolor</code></td>
<td>
<p>Default 'black'. Color of the text.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50,water=TRUE, watercolor="#233aa1")
render_snapshot() 
}

santa_cruz = c(36.962957, -122.021033) 
#We want to add a label to Santa Cruz, so we use the x and y matrix coordinate (x=220 and y=330)
if(run_documentation()) {
render_label(montereybay,lat = santa_cruz[1], long = santa_cruz[2],
            extent = attr(montereybay, "extent"),
            altitude=12000, zscale=50, text = "Santa Cruz")
render_snapshot()
}

monterey = c(36.603053, -121.892933)
#We can also change the linetype to dashed by setting `dashed = TRUE` (additional options allow
#the user to control the dash length). You can clear the existing lines by setting 
#`clear_previous = TRUE`.
if(run_documentation()) {
render_label(montereybay, lat = monterey[1], long = monterey[2], altitude = 10000, 
            extent = attr(montereybay, "extent"),
            zscale = 50, text = "Monterey", textcolor = "white", linecolor="darkred",
            dashed = TRUE, clear_previous = TRUE)
render_snapshot()
}

canyon = c(36.621049, -122.333912)
#By default, z specifies the altitude above that point on the elevation matrix. We can also specify 
#an absolute height by setting `relativez=FALSE`.
if(run_documentation()) {
render_label(montereybay,lat=canyon[1], long = canyon[2], altitude = 2000,
            extent = attr(montereybay,"extent"),
            zscale=50,text = "Monterey Canyon", relativez=FALSE)
render_snapshot()
}

#We can also render labels in high quality with `render_highquality()`, specifying a custom
#line radius. By default, the labels point towards the camera, but you can fix their angle with
#argument `text_angle`.
if(run_documentation()) {
render_camera(theta=35, phi = 35, zoom = 0.80, fov=60)
render_label(montereybay, lat = monterey[1], long = monterey[2], altitude = 10000, 
            extent = attr(montereybay, "extent"),
            zscale = 50, text = "Monterey", textcolor = "white", linecolor="darkred",
            dashed = TRUE, clear_previous = TRUE)
               
render_label(montereybay,lat=canyon[1], long = canyon[2], altitude = 2000, zscale=50,
            extent = attr(montereybay,"extent"), textcolor = "white", linecolor="white",
            text = "Monterey Canyon", relativez=FALSE)
            
render_highquality(samples = 128,text_size = 24, line_radius = 2, text_offset = c(0, 20, 0),
                  lightdirection = 180, clamp_value = 10, min_variance = 0,
                  sample_method = "sobol_blue")
}
if(run_documentation()) {
#Fixed text angle
render_highquality(samples = 128,text_size = 24, line_radius = 2, text_offset = c(0, 20, 0),
                  lightdirection = 180, text_angle = 0, clamp_value=10, min_variance = 0,
                  sample_method = "sobol_blue")
}
#We can remove all existing labels by calling `render_label(clear_previous = TRUE)`
if(run_documentation()) {
render_label(clear_previous = TRUE) 
render_snapshot()
}
</code></pre>

<hr>
<h2 id='render_movie'>Render Movie</h2><span id='topic+render_movie'></span>

<h3>Description</h3>

<p>Renders a movie using the <span class="pkg">av</span> or <span class="pkg">gifski</span> packages. Moves the camera around a 3D visualization 
using either a standard orbit, or accepts vectors listing user-defined values for each camera parameter. If the latter,
the values must be equal in length to 'frames' (or of length '1', in which the value will be fixed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_movie(
  filename,
  type = "orbit",
  frames = 360,
  fps = 30,
  phi = 30,
  theta = 0,
  zoom = NULL,
  fov = NULL,
  width = NULL,
  height = NULL,
  title_text = NULL,
  title_offset = c(20, 20),
  title_color = "black",
  title_size = 30,
  title_font = "sans",
  title_bar_color = NULL,
  title_bar_alpha = 0.5,
  image_overlay = NULL,
  vignette = FALSE,
  vignette_color = "black",
  vignette_radius = 1.3,
  title_position = "northwest",
  audio = NULL,
  progbar = interactive(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_movie_+3A_filename">filename</code></td>
<td>
<p>Filename. If not appended with '.mp4', it will be appended automatically. If the file extension is 'gif', 
the <span class="pkg">gifski</span> package will be used to generate the animation.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_type">type</code></td>
<td>
<p>Default 'orbit', which orbits the 3D object at the user-set camera settings 'phi', 'zoom', and 'fov'. 
Other options are 'oscillate' (sine wave around 'theta' value, covering 90 degrees), or 'custom' (which uses the values from the 
'theta', 'phi', 'zoom', and 'fov' vectors passed in by the user).</p>
</td></tr>
<tr><td><code id="render_movie_+3A_frames">frames</code></td>
<td>
<p>Default '360'. Number of frames to render.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_fps">fps</code></td>
<td>
<p>Default '30'. Frames per second. Recommmend either 30 or 60 for web.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_phi">phi</code></td>
<td>
<p>Defaults to current view. Azimuth values, in degrees.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_theta">theta</code></td>
<td>
<p>Default to current view. Theta values, in degrees.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_zoom">zoom</code></td>
<td>
<p>Defaults to the current view. Zoom value, between '0' and '1'.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_fov">fov</code></td>
<td>
<p>Defaults to the current view. Field of view values, in degrees.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_width">width</code></td>
<td>
<p>Default 'NULL', uses the window size by default. Width of the movie. Note that the frames will still
be captured at the resolution (and aspect ratio) of the rgl window.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_height">height</code></td>
<td>
<p>Default 'NULL', uses the window size by default. Height of the movie. Note that the frames will still
be captured at the resolution (and aspect ratio) of the rgl window.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_title_text">title_text</code></td>
<td>
<p>Default 'NULL'. Text. Adds a title to the movie, using magick::image_annotate.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_title_offset">title_offset</code></td>
<td>
<p>Default 'c(20,20)'. Distance from the top-left (default, 'gravity' direction in 
image_annotate) corner to offset the title.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_title_color">title_color</code></td>
<td>
<p>Default 'black'. Font color.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_title_size">title_size</code></td>
<td>
<p>Default '30'. Font size in pixels.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_title_font">title_font</code></td>
<td>
<p>Default 'sans'. String with font family such as &quot;sans&quot;, &quot;mono&quot;, &quot;serif&quot;, &quot;Times&quot;, &quot;Helvetica&quot;, 
&quot;Trebuchet&quot;, &quot;Georgia&quot;, &quot;Palatino&quot; or &quot;Comic Sans&quot;.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_title_bar_color">title_bar_color</code></td>
<td>
<p>Default 'NULL'. If a color, this will create a colored bar under the title.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_title_bar_alpha">title_bar_alpha</code></td>
<td>
<p>Default '0.5'. Transparency of the title bar.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_image_overlay">image_overlay</code></td>
<td>
<p>Default 'NULL'. Either a string indicating the location of a png image to overlay
over the whole movie (transparency included), or a 4-layer RGBA array. This image will be resized to the 
dimension of the movie if it does not match exactly.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_vignette">vignette</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE' or numeric, a camera vignetting effect will be added to the image.
'1' is the darkest vignetting, while '0' is no vignetting. If vignette is a length-2 vector, the second entry will
control the blurriness of the vignette effect.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_vignette_color">vignette_color</code></td>
<td>
<p>Default '&quot;black&quot;'. Color of the vignette.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_vignette_radius">vignette_radius</code></td>
<td>
<p>Default '1.3'. Radius of the vignette, as a porportion of the image dimensions.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_title_position">title_position</code></td>
<td>
<p>Default 'northwest'. Position of the title.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_audio">audio</code></td>
<td>
<p>Default 'NULL'. Optional file with audio to add to the video.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_progbar">progbar</code></td>
<td>
<p>Default 'TRUE' if interactive, 'FALSE' otherwise. If 'FALSE', turns off progress bar. 
Will display a progress bar when adding an overlay or title.</p>
</td></tr>
<tr><td><code id="render_movie_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to magick::image_annotate.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
filename_movie = tempfile()

#By default, the function produces a 12 second orbit at 30 frames per second, at 30 degrees azimuth.

montereybay %&gt;%
 sphere_shade(texture="imhof1") %&gt;%
 plot_3d(montereybay, zscale=50, water = TRUE, watercolor="imhof1", 
         waterlinecolor="white", waterlinealpha=0.5)
#Un-comment the following to run:
#render_movie(filename = filename_movie)
    
filename_movie = tempfile()

#You can change to an oscillating orbit. The magnification is increased and azimuth angle set to 30.
#A title has also been added using the title_text argument.

#Un-comment the following to run:
#render_movie(filename = filename_movie, type = "oscillate", 
#             frames = 60,  phi = 30, zoom = 0.8, theta = -90,
#             title_text = "Monterey Bay: Oscillating")
             
filename_movie = tempfile()

#Finally, you can pass your own set of values to the 
#camera parameters as a vector with type = "custom".

phivechalf = 30 + 60 * 1/(1 + exp(seq(-7, 20, length.out = 180)/2))
phivecfull = c(phivechalf, rev(phivechalf))
thetavec = -90 + 45 * sin(seq(0,359,length.out = 360) * pi/180)
zoomvec = 0.45 + 0.2 * 1/(1 + exp(seq(-5, 20, length.out = 180)))
zoomvecfull = c(zoomvec, rev(zoomvec))

#Un-comment the following to run
#render_movie(filename = filename_movie, type = "custom", 
#             frames = 360,  phi = phivecfull, zoom = zoomvecfull, theta = thetavec)

}
</code></pre>

<hr>
<h2 id='render_multipolygonz'>Render MULTIPOLYGON Z Geometry</h2><span id='topic+render_multipolygonz'></span>

<h3>Description</h3>

<p>Adds MULTIPOLYGONZ will be plotted in the coordinate system set by the user-specified
'extent' argument as-is. 
</p>
<p>You can also use 'save_multipolygonz_to_obj()' manually to convert sf objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_multipolygonz(
  sfobj,
  extent = NULL,
  zscale = 1,
  heightmap = NULL,
  color = "grey50",
  offset = 0,
  obj_zscale = TRUE,
  swap_yz = TRUE,
  clear_previous = FALSE,
  baseshape = "rectangle",
  rgl_tag = "_multipolygon",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_multipolygonz_+3A_sfobj">sfobj</code></td>
<td>
<p>An sf object with MULTIPOLYGON Z geometry.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the 3D model, if 'load_material = FALSE'.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_offset">offset</code></td>
<td>
<p>Default '5'. Offset of the track from the surface, if 'altitude = NULL'.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_obj_zscale">obj_zscale</code></td>
<td>
<p>Default 'TRUE'. Whether to scale the size of the OBJ by zscale to have it match
the size of the map. If zscale is very big, this will make the model very small.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_swap_yz">swap_yz</code></td>
<td>
<p>Default 'TRUE'. Whether to swap and Y and Z axes. (Y axis is vertical in 
rayshader coordinates, but data is often provided with Z being vertical).</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing points.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_baseshape">baseshape</code></td>
<td>
<p>Default 'rectangle'. Shape of the base. Options are 'c(&quot;rectangle&quot;,&quot;circle&quot;,&quot;hex&quot;)'.</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_rgl_tag">rgl_tag</code></td>
<td>
<p>Default '&quot;&quot;'. Tag to add to the rgl scene id, will be prefixed by '&quot;obj&quot;'</p>
</td></tr>
<tr><td><code id="render_multipolygonz_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'rgl::triangles3d()'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>run_examples = length(find.package("sf", quiet = TRUE)) &amp;&amp;
              length(find.package("elevatr", quiet = TRUE)) &amp;&amp;
              length(find.package("raster", quiet = TRUE)) &amp;&amp;
              run_documentation()
if(run_examples) {
library(sf)
#Set location of washington monument
washington_monument_location =  st_point(c(-77.035249, 38.889462))
wm_point = washington_monument_location |&gt; 
 st_point() |&gt; 
 st_sfc(crs = 4326) |&gt; 
 st_transform(st_crs(washington_monument_multipolygonz))
 
elevation_data = elevatr::get_elev_raster(locations = wm_point, z = 14)
                                         
scene_bbox = st_bbox(st_buffer(wm_point,300))
cropped_data = raster::crop(elevation_data, scene_bbox)

#Use rayshader to convert that raster data to a matrix
dc_elevation_matrix = raster_to_matrix(cropped_data)

#Remove negative elevation data
dc_elevation_matrix[dc_elevation_matrix &lt; 0] = 0

#Plot a 3D map of the national mall
dc_elevation_matrix |&gt; 
 height_shade() |&gt;
 add_shadow(lamb_shade(dc_elevation_matrix), 0) |&gt; 
 plot_3d(dc_elevation_matrix, zscale=3.7, water = TRUE, waterdepth = 1, 
         soliddepth=-50, windowsize = 800)
render_snapshot()
}
if(run_examples) {
#Zoom in on the monument
render_camera(theta=150,  phi=35, zoom= 0.55, fov=70)
#Render the national monument
rgl::par3d(ignoreExtent = TRUE)
render_multipolygonz(washington_monument_multipolygonz, 
                    extent = raster::extent(cropped_data), 
                    zscale = 4, color = "white",
                    heightmap = dc_elevation_matrix)
render_snapshot()
}
if(run_examples) {
#This works with `render_highquality()`
render_highquality(sample_method="sobol_blue", clamp_value=10, min_variance = 0)
}
</code></pre>

<hr>
<h2 id='render_obj'>Render Obj</h2><span id='topic+render_obj'></span>

<h3>Description</h3>

<p>Adds 3D OBJ model to the current scene, using latitude/longitude or coordinates in the reference
system defined by the extent object. If no altitude is provided, the OBJ will be elevated a constant offset 
above the heightmap. If the OBJ goes off the edge, the OBJ will be filtered out.
</p>
<p>If no latitudes or longitudes are passed in, the OBJ will be plotted in the coordinate system set by the user-specified
'extent' argument as-is. Use this alongside 'save_multipolygonz_to_obj()' to plot 3D polygons imported from geospatial sources
in the proper location (but for ease of use, use 'render_multipolygonz()' to plot this data directly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_obj(
  filename,
  extent = NULL,
  lat = NULL,
  long = NULL,
  altitude = NULL,
  xyz = NULL,
  zscale = 1,
  heightmap = NULL,
  load_material = FALSE,
  load_normals = TRUE,
  color = "grey50",
  offset = 0,
  obj_zscale = FALSE,
  swap_yz = NULL,
  angle = c(0, 0, 0),
  scale = c(1, 1, 1),
  clear_previous = FALSE,
  baseshape = "rectangle",
  lit = FALSE,
  light_altitude = c(45, 30),
  light_direction = c(315, 135),
  light_intensity = 0.3,
  light_relative = FALSE,
  rgl_tag = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_obj_+3A_filename">filename</code></td>
<td>
<p>Filename for the OBJ file.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_lat">lat</code></td>
<td>
<p>Vector of latitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="render_obj_+3A_long">long</code></td>
<td>
<p>Vector of longitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="render_obj_+3A_altitude">altitude</code></td>
<td>
<p>Default 'NULL'. Elevation of each point, in units of the elevation matrix (scaled by 'zscale'). 
If left 'NULL', this will be just the elevation value at ths surface, offset by 'offset'. If a single value, 
the OBJ will be rendered at that altitude.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_xyz">xyz</code></td>
<td>
<p>Default 'NULL', ignored. A 3 column numeric matrix, with each row specifying the x/y/z 
coordinates of the OBJ model(s). Overrides lat/long/altitude and ignores extent to plot the OBJ in raw rgl coordinates.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_load_material">load_material</code></td>
<td>
<p>Default 'TRUE'. Whether to load the accompanying MTL file to load materials for the 3D model.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_load_normals">load_normals</code></td>
<td>
<p>Default 'TRUE'. Whether to load normals for the 3D model.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the 3D model, if 'load_material = FALSE'.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_offset">offset</code></td>
<td>
<p>Default '5'. Offset of the model from the surface, if 'altitude = NULL'.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_obj_zscale">obj_zscale</code></td>
<td>
<p>Default 'FALSE'. Whether to scale the size of the OBJ by zscale to have it match
the size of the map. If zscale is very big, this will make the model very small.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_swap_yz">swap_yz</code></td>
<td>
<p>Default 'NULL', defaults to 'FALSE' unless plotting raw coordinates (no lat or long passed).
Whether to swap and Y and Z axes. (Y axis is vertical in 
rayshader coordinates, but data is often provided with Z being vertical).</p>
</td></tr>
<tr><td><code id="render_obj_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0,0,0)'. Angle of rotation around the x, y, and z axes. If this is a matrix or list,
each row (or list entry) specifies the rotation of the nth model specified (number of rows/length of list must
equal the length of 'lat'/'long').</p>
</td></tr>
<tr><td><code id="render_obj_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1,1,1)'. Amount to scale the 3D model in the x, y, and z axes. If this is a matrix or list,
each row (or list entry) specifies the scale of the nth model specified (number of rows/length of list must
equal the length of 'lat'/'long').</p>
</td></tr>
<tr><td><code id="render_obj_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing points.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_baseshape">baseshape</code></td>
<td>
<p>Default 'rectangle'. Shape of the base. Options are 'c(&quot;rectangle&quot;,&quot;circle&quot;,&quot;hex&quot;)'.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_lit">lit</code></td>
<td>
<p>Default 'TRUE'. Whether to light the polygons.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_light_altitude">light_altitude</code></td>
<td>
<p>Default 'c(45, 60)'. Degree(s) from the horizon from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_light_direction">light_direction</code></td>
<td>
<p>Default 'c(45, 60)'. Degree(s) from north from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_light_intensity">light_intensity</code></td>
<td>
<p>Default '0.3'. Intensity of the specular highlight on the polygons.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_light_relative">light_relative</code></td>
<td>
<p>Default 'FALSE'. Whether the light direction should be taken relative to the camera,
or absolute.</p>
</td></tr>
<tr><td><code id="render_obj_+3A_rgl_tag">rgl_tag</code></td>
<td>
<p>Default '&quot;&quot;'. Tag to add to the rgl scene id, will be prefixed by '&quot;obj&quot;'</p>
</td></tr>
<tr><td><code id="render_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'rgl::triangles3d()'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Render the 3D map
moss_landing_coord = c(36.806807, -121.793332)
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50,water=TRUE,
         shadowcolor="#40310a", background = "tan",
         theta=210,  phi=22, zoom=0.20, fov=55)

t = seq(0,2*pi,length.out=100)
circle_coords_lat = moss_landing_coord[1] + 0.3 * sin(t)
circle_coords_long = moss_landing_coord[2] + 0.3 * cos(t)

#Create a rainbow spectrum of flags
render_obj(flag_full_obj(), extent = attr(montereybay,"extent"), heightmap = montereybay,
          lat = unlist(circle_coords_lat), long = unlist(circle_coords_long),
          scale=c(2,2,2), angle=c(0,45,0),
          zscale=50, color=rainbow(100), smooth = FALSE, clear_previous = TRUE) 
render_snapshot()
}
if(run_documentation()) {
#Rotate the flag to follow the circle
render_obj(flag_full_obj(), extent = attr(montereybay,"extent"), heightmap = montereybay,
          lat = unlist(circle_coords_lat), long = unlist(circle_coords_long),
          scale=c(2,2,2), 
          angle=matrix(c(rep(0,100), seq(0,-360,length.out=101)[-1],rep(0,100)),ncol=3),
          zscale=50, color=rainbow(100), smooth = FALSE, clear_previous = TRUE) 
render_snapshot()
}
if(run_documentation()) {
#Style the pole with a different color
render_obj(flag_pole_obj(), extent = attr(montereybay,"extent"), heightmap = montereybay,
          lat = unlist(circle_coords_lat), long = unlist(circle_coords_long),
          scale=c(2,2,2), 
          angle=matrix(c(rep(0,100), seq(0,-360,length.out=101)[-1],rep(0,100)),ncol=3),
          zscale=50, color="grey20", smooth = FALSE, clear_previous = TRUE) 
render_obj(flag_banner_obj(), extent = attr(montereybay,"extent"), heightmap = montereybay,
          lat = unlist(circle_coords_lat), long = unlist(circle_coords_long),
          scale=c(2,2,2),
          angle=matrix(c(rep(0,100), seq(0,-360,length.out=101)[-1],rep(0,100)),ncol=3),
          zscale=50, color=rainbow(100), smooth = FALSE) 

#And all of these work with `render_highquality()`
render_highquality(sample_method="sobol_blue",clamp_value=10)
}
</code></pre>

<hr>
<h2 id='render_path'>Render Path</h2><span id='topic+render_path'></span>

<h3>Description</h3>

<p>Adds a 3D path to the current scene, using latitude/longitude or coordinates in the reference
system defined by the extent object. If no altitude is provided, the path will be elevated a constant offset 
above the heightmap. If the path goes off the edge, the nearest height on the heightmap will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_path(
  lat,
  long = NULL,
  altitude = NULL,
  groups = NULL,
  extent = NULL,
  zscale = 1,
  heightmap = NULL,
  resample_evenly = FALSE,
  resample_n = 360,
  reorder = FALSE,
  reorder_first_index = 1,
  reorder_duplicate_tolerance = 0.1,
  reorder_merge_tolerance = 1,
  simplify_tolerance = 0,
  linewidth = 3,
  color = "black",
  antialias = FALSE,
  offset = 5,
  clear_previous = FALSE,
  return_coords = FALSE,
  tag = "path3d"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_path_+3A_lat">lat</code></td>
<td>
<p>Vector of latitudes (or other coordinate in the same coordinate reference system as extent).
Can also be an 'sf' or 'SpatialLineDataFrame' object.</p>
</td></tr>
<tr><td><code id="render_path_+3A_long">long</code></td>
<td>
<p>Default 'NULL'. Vector of longitudes (or other coordinate in the same coordinate reference system as extent).
Ignored if lat is an 'sf' or 'SpatialLineDataFrame' object.</p>
</td></tr>
<tr><td><code id="render_path_+3A_altitude">altitude</code></td>
<td>
<p>Default 'NULL'. Elevation of each point, in units of the elevation matrix (scaled by zscale).
If left 'NULL', this will be just the elevation value at ths surface, offset by 'offset'. If a single value, 
all data will be rendered at that altitude.</p>
</td></tr>
<tr><td><code id="render_path_+3A_groups">groups</code></td>
<td>
<p>Default 'NULL'. Integer vector specifying the grouping of each lat/long path segment, if lat/long are
specified as numeric vectors (as opposed to 'sf' or 'SpatialLineDataFrame' objects, where this information
is built-in to the object).</p>
</td></tr>
<tr><td><code id="render_path_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the 3D scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_path_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="render_path_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Pass this if not including an 'altitude' argument, or if no extent passed. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_path_+3A_resample_evenly">resample_evenly</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will re-sample the path evenly from beginning to end, which can help vastly
reduce the number of points used to draw it (which can improve the performance of 'render_highquality()' and 'render_snapshot(software_render = TRUE)').
This function works only if 'reorder = TRUE', or if the sf object is already ordered from beginning to end.</p>
</td></tr>
<tr><td><code id="render_path_+3A_resample_n">resample_n</code></td>
<td>
<p>Default '360'. Number of breaks in which to evenly resample the line if 'resample_evenly = TRUE'.</p>
</td></tr>
<tr><td><code id="render_path_+3A_reorder">reorder</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will attempt to re-order the rows within an 'sf' object with
multiple paths to be one continuous, end-to-end path. This happens in two steps: merging duplicate 
paths that have end points that match with another object (within 'reorder_duplicate_tolerance' distance), and then
merges them (within 'reorder_merge_tolerance' distance) to form a continuous path.</p>
</td></tr>
<tr><td><code id="render_path_+3A_reorder_first_index">reorder_first_index</code></td>
<td>
<p>Default '1'. The index (row) of the 'sf' object in which to begin the reordering
process. This merges and reorders paths within 'reorder_merge_tolerance' distance until it cannot 
merge any more, and then repeats the process in the opposite direction.</p>
</td></tr>
<tr><td><code id="render_path_+3A_reorder_duplicate_tolerance">reorder_duplicate_tolerance</code></td>
<td>
<p>Default '0.1'. Lines that have start and end points (does not matter which)
within this tolerance that match a line already processed (order determined by 'reorder_first_index') will be 
discarded.</p>
</td></tr>
<tr><td><code id="render_path_+3A_reorder_merge_tolerance">reorder_merge_tolerance</code></td>
<td>
<p>Default '1'. Lines that have start points that are within this distance 
to a previously processed line's end point (order determined by 'reorder_first_index') will be reordered 
within the 'sf' object to form a continuous, end-to-end path.</p>
</td></tr>
<tr><td><code id="render_path_+3A_simplify_tolerance">simplify_tolerance</code></td>
<td>
<p>Default '0' (no simplification). If greater than zero, simplifies
the path to the tolerance specified. This happens after the data has been merged if 'reorder = TRUE'. 
If the input data is specified with long-lat coordinates and 'sf_use_s2()' returns 'TRUE', 
then the value of simplify_tolerance must be specified in meters.</p>
</td></tr>
<tr><td><code id="render_path_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '3'. The line width.</p>
</td></tr>
<tr><td><code id="render_path_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the line.</p>
</td></tr>
<tr><td><code id="render_path_+3A_antialias">antialias</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the line with be have anti-aliasing applied. NOTE: anti-aliasing can cause some unpredictable behavior with transparent surfaces.</p>
</td></tr>
<tr><td><code id="render_path_+3A_offset">offset</code></td>
<td>
<p>Default '5'. Offset of the track from the surface, if 'altitude = NULL'.</p>
</td></tr>
<tr><td><code id="render_path_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing paths.</p>
</td></tr>
<tr><td><code id="render_path_+3A_return_coords">return_coords</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will return the internal rayshader coordinates of the path, instead of 
plotting the line.</p>
</td></tr>
<tr><td><code id="render_path_+3A_tag">tag</code></td>
<td>
<p>Default '&quot;path3d&quot;'. The rgl tag to use when adding the path to the scene.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Starting at Moss Landing in Monterey Bay, we are going to simulate a flight of a bird going
#out to sea and diving for food.

#First, create simulated lat/long data
set.seed(2009)
moss_landing_coord = c(36.806807, -121.793332)
x_vel_out = -0.001 + rnorm(1000)[1:300]/1000
y_vel_out = rnorm(1000)[1:300]/200
z_out = c(seq(0,2000,length.out = 180), seq(2000,0,length.out=10),
         seq(0,2000,length.out = 100), seq(2000,0,length.out=10))

bird_track_lat = list()
bird_track_long = list()
bird_track_lat[[1]] = moss_landing_coord[1]
bird_track_long[[1]] = moss_landing_coord[2]
for(i in 2:300) {
bird_track_lat[[i]] = bird_track_lat[[i-1]] + y_vel_out[i]
bird_track_long[[i]] = bird_track_long[[i-1]] + x_vel_out[i]
}


#Render the 3D map 
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50,water=TRUE,
         shadowcolor="#40310a", watercolor="#233aa1", background = "tan",
         theta=210,  phi=22, zoom=0.20, fov=55)

#Pass in the extent of the underlying raster (stored in an attribute for the montereybay
#dataset) and the latitudes, longitudes, and altitudes of the track.
render_path(extent = attr(montereybay,"extent"), 
           lat = unlist(bird_track_lat), long = unlist(bird_track_long), 
           altitude = z_out, zscale=50,color="white", antialias=TRUE)
render_snapshot()
}
if(run_documentation()) {
#We'll set the altitude to right above the water to give the tracks a "shadow".
render_path(extent = attr(montereybay,"extent"), 
           lat = unlist(bird_track_lat), long = unlist(bird_track_long), 
           altitude = 10, zscale=50, color="black", antialias=TRUE)
render_camera(theta=30,phi=35,zoom=0.45,fov=70)
render_snapshot()
}

if(run_documentation()) {
#Remove the path:
render_path(clear_previous=TRUE)

#Finally, we can also plot just GPS coordinates offset from the surface by leaving altitude `NULL`
# Here we plot a spiral of values surrounding Moss Landing. This requires the original heightmap.

t = seq(0,2*pi,length.out=1000)
circle_coords_lat = moss_landing_coord[1] + 0.5 * t/8 * sin(t*6)
circle_coords_long = moss_landing_coord[2] + 0.5 * t/8 *  cos(t*6)
render_path(extent = attr(montereybay,"extent"), heightmap = montereybay, 
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long), 
           zscale=50, color="red", antialias=TRUE,offset=100, linewidth=5)
render_camera(theta = 160, phi=33, zoom=0.4, fov=55)
render_snapshot()
}

if(run_documentation()) {
#And all of these work with `render_highquality()`. Here, I set `use_extruded_paths = TRUE`
#to get thick continuous paths.
render_highquality(clamp_value=10, line_radius=3, min_variance = 0,
                  use_extruded_paths = TRUE,
                  sample_method = "sobol_blue", samples = 128)
}
if(run_documentation()) {
#We can also change the material of the objects by setting the `point_material` and
#`point_material_args` arguments in `render_highquality()`
render_highquality(clamp_value=10, line_radius=3, min_variance = 0,
                  sample_method = "sobol_blue", samples = 128,
                  path_material = rayrender::glossy,  use_extruded_paths = TRUE,
                  path_material_args = list(gloss = 0.5, reflectance = 0.2))
}

if(run_documentation()) {
#For transmissive materials (like `dielectric`), we should specify that the path
#should be rendered with an extruded path. We'll use the `attenuation` argument in 
#the `dielectric` function to specify a realistic glass color.
render_path(extent = attr(montereybay,"extent"), heightmap = montereybay, clear_previous = TRUE,
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long), 
           zscale=50, color="white", offset=200, linewidth=5)
render_highquality(clamp_value=10, line_radius=6, min_variance = 0,
                  sample_method = "sobol_blue", samples = 128,
                  lightsize = 2000, lightintensity = 10,
                  path_material = rayrender::dielectric, use_extruded_paths = TRUE,
                  path_material_args = list(refraction = 1.5, attenuation = c(0.05,0.2,0.2)))
}
</code></pre>

<hr>
<h2 id='render_points'>Render Points</h2><span id='topic+render_points'></span>

<h3>Description</h3>

<p>Adds 3D datapoints to the current scene, using latitude/longitude or coordinates in the reference
system defined by the extent object. If no altitude is provided, the points will be elevated a constant offset 
above the heightmap. If the points goes off the edge, the nearest height on the heightmap will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_points(
  lat = NULL,
  long = NULL,
  altitude = NULL,
  extent = NULL,
  zscale = 1,
  heightmap = NULL,
  size = 3,
  color = "black",
  offset = 5,
  clear_previous = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_points_+3A_lat">lat</code></td>
<td>
<p>Vector of latitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="render_points_+3A_long">long</code></td>
<td>
<p>Vector of longitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="render_points_+3A_altitude">altitude</code></td>
<td>
<p>Default 'NULL'. Elevation of each point, in units of the elevation matrix (scaled by zscale). If a single value, 
all data will be rendered at that altitude.</p>
</td></tr>
<tr><td><code id="render_points_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the 3D scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_points_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="render_points_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_points_+3A_size">size</code></td>
<td>
<p>Default '3'. The point size.</p>
</td></tr>
<tr><td><code id="render_points_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the point.</p>
</td></tr>
<tr><td><code id="render_points_+3A_offset">offset</code></td>
<td>
<p>Default '5'. Offset of the track from the surface, if 'altitude = NULL'.</p>
</td></tr>
<tr><td><code id="render_points_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing points.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Starting at Moss Landing in Monterey Bay, we are going to simulate a flight of a bird going
#out to sea and diving for food.

#First, create simulated lat/long data
set.seed(2009)
moss_landing_coord = c(36.806807, -121.793332)
x_vel_out = -0.001 + rnorm(1000)[1:300]/1000
y_vel_out = rnorm(1000)[1:300]/200
z_out = c(seq(0,2000,length.out = 180), seq(2000,0,length.out=10),
         seq(0,2000,length.out = 100), seq(2000,0,length.out=10))

bird_track_lat = list()
bird_track_long = list()
bird_track_lat[[1]] = moss_landing_coord[1]
bird_track_long[[1]] = moss_landing_coord[2]
for(i in 2:300) {
bird_track_lat[[i]] = bird_track_lat[[i-1]] + y_vel_out[i]
bird_track_long[[i]] = bird_track_long[[i-1]] + x_vel_out[i]
}


#Render the 3D map
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50,water=TRUE,
         shadowcolor="#40310a", background = "tan",
         theta=210,  phi=22, zoom=0.20, fov=55)

#Pass in the extent of the underlying raster (stored in an attribute for the montereybay
#dataset) and the latitudes, longitudes, and altitudes of the track.
render_points(extent = attr(montereybay,"extent"), 
             lat = unlist(bird_track_lat), long = unlist(bird_track_long), 
             altitude = z_out, zscale=50,color="white")
render_snapshot()
}
if(run_documentation()) {
#We'll set the altitude to zero to give the tracks a "shadow" over the water. 
render_points(extent = attr(montereybay,"extent"), 
             lat = unlist(bird_track_lat), long = unlist(bird_track_long), 
             offset = 0, zscale=50, color="black")
render_camera(theta=30,phi=35,zoom=0.45,fov=70)
render_snapshot()
}
if(run_documentation()) {
#Remove the points:
render_points(clear_previous=TRUE)

# Finally, we can also plot just GPS coordinates offset from the surface by leaving altitude `NULL`
# Here we plot a circle of values surrounding Moss Landing. This requires the original heightmap.

t = seq(0,2*pi,length.out=100)
circle_coords_lat = moss_landing_coord[1] + 0.3 * sin(t)
circle_coords_long = moss_landing_coord[2] + 0.3 * cos(t)
render_points(extent = attr(montereybay,"extent"), heightmap = montereybay,
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long), 
           zscale=50, color="red", offset=100, size=5)
render_camera(theta = 160, phi=33, zoom=0.4, fov=55)
render_snapshot()
}
if(run_documentation()) {
#And all of these work with `render_highquality()`
render_highquality(point_radius = 6, clamp_value=10, min_variance = 0,
                  sample_method = "sobol_blue", samples = 128)
}

if(run_documentation()) {
#We can also change the material of the objects by setting the `point_material` and
#`point_material_args` arguments in `render_highquality()`
render_highquality(point_radius = 6, clamp_value=10, min_variance = 0,
                  sample_method = "sobol_blue", samples = 128,
                  point_material = rayrender::glossy, 
                  point_material_args = list(gloss = 0.5, reflectance = 0.2))
}
</code></pre>

<hr>
<h2 id='render_polygons'>Render Polygons</h2><span id='topic+render_polygons'></span>

<h3>Description</h3>

<p>Adds 3D polygons to the current scene, using latitude/longitude or coordinates in the reference
system defined by the extent object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_polygons(
  polygon,
  extent,
  color = "red",
  top = 1,
  bottom = NA,
  data_column_top = NULL,
  data_column_bottom = NULL,
  heightmap = NULL,
  scale_data = 1,
  parallel = FALSE,
  holes = 0,
  alpha = 1,
  lit = TRUE,
  light_altitude = c(45, 30),
  light_direction = c(315, 135),
  light_intensity = 0.3,
  light_relative = FALSE,
  clear_previous = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_polygons_+3A_polygon">polygon</code></td>
<td>
<p>'sf' object, &quot;SpatialPolygon&quot; 'sp' object,  or xy coordinates
of polygon represented in a way that can be processed by 'xy.coords()'.  If
xy-coordinate based polygons are open, they will be closed by adding an
edge from the last point to the first.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the 3D scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;, &quot;ymin&quot;, &quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the polygon.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_top">top</code></td>
<td>
<p>Default '1'. Extruded top distance. If this equals 'bottom', the polygon will not be
extruded and just the one side will be rendered.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_bottom">bottom</code></td>
<td>
<p>Default '0'. Extruded bottom distance. If this equals 'top', the polygon will not be
extruded and just the one side will be rendered.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_data_column_top">data_column_top</code></td>
<td>
<p>Default 'NULL'. A string indicating the column in the 'sf' object to use 
to specify the top of the extruded polygon.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_data_column_bottom">data_column_bottom</code></td>
<td>
<p>Default 'NULL'. A string indicating the column in the 'sf' object to use 
to specify the bottom of the extruded polygon.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_scale_data">scale_data</code></td>
<td>
<p>Default '1'. If specifying 'data_column_top' or 'data_column_bottom', how
much to scale that value when rendering.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_parallel">parallel</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', polygons will be extruded in parallel, which
may be faster (depending on how many geometries are in 'polygon').</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_holes">holes</code></td>
<td>
<p>Default '0'. If passing in a polygon directly, this specifies which index represents
the holes in the polygon. See the 'earcut' function in the 'decido' package for more information.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_alpha">alpha</code></td>
<td>
<p>Default '1'. Transparency of the polygons.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_lit">lit</code></td>
<td>
<p>Default 'TRUE'. Whether to light the polygons.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_light_altitude">light_altitude</code></td>
<td>
<p>Default 'c(45, 60)'. Degree(s) from the horizon from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_light_direction">light_direction</code></td>
<td>
<p>Default 'c(45, 60)'. Degree(s) from north from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_light_intensity">light_intensity</code></td>
<td>
<p>Default '0.3'. Intensity of the specular highlight on the polygons.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_light_relative">light_relative</code></td>
<td>
<p>Default 'FALSE'. Whether the light direction should be taken relative to the camera,
or absolute.</p>
</td></tr>
<tr><td><code id="render_polygons_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing polygons.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Render the county borders as polygons in Monterey Bay
montereybay %&gt;%
  sphere_shade(texture = "desert") %&gt;%
  add_shadow(ray_shade(montereybay,zscale = 50)) %&gt;%
  plot_3d(montereybay, water = TRUE, windowsize = 800, watercolor = "dodgerblue")
render_camera(theta = 140,  phi = 55, zoom = 0.85, fov = 30)

#We will apply a negative buffer to create space between adjacent polygons. You may 
#have to call `sf::sf_use_s2(FALSE)` before running this code to get it to run.
sf::sf_use_s2(FALSE)
mont_county_buff = sf::st_simplify(sf::st_buffer(monterey_counties_sf,-0.003), dTolerance=0.001)

render_polygons(mont_county_buff, 
                extent = attr(montereybay,"extent"), top = 10,
                parallel = FALSE)
render_snapshot()
}
if(run_documentation()) {
#We can specify the bottom of the polygons as well. Here I float the polygons above the surface
#by specifying the bottom argument. We clear the previous polygons with `clear_previous = TRUE`.
render_camera(theta=-60,  phi=20, zoom = 0.85, fov=0)
render_polygons(mont_county_buff, 
                extent = attr(montereybay,"extent"), bottom = 190, top=200,
                parallel=FALSE,clear_previous=TRUE)
render_snapshot()
}
if(run_documentation()) {
#We can set the height of the data to a column in the sf object: we'll use the land area.
#We'll have to scale this value because its max value is 2.6 billion:
render_camera(theta=-60,  phi=60, zoom = 0.85, fov=30)
render_polygons(mont_county_buff, 
                extent = attr(montereybay, "extent"), data_column_top = "ALAND",
                scale_data = 300/(2.6E9), color = "chartreuse4",
                clear_previous = TRUE)
render_snapshot()      
}  
if(run_documentation()) {
#This function also works with `render_highquality()`
render_highquality(samples = 128, clamp_value = 10, sample_method="sobol_blue",
                   min_variance = 0)
}
</code></pre>

<hr>
<h2 id='render_raymesh'>Render Raymesh</h2><span id='topic+render_raymesh'></span>

<h3>Description</h3>

<p>Adds 3D raymesh model to the current scene, using latitude/longitude or coordinates in the reference
system defined by the extent object. If no altitude is provided, the raymesh will be elevated a constant offset 
above the heightmap. If the raymesh goes off the edge, the raymesh will be filtered out.
</p>
<p>If no latitudes or longitudes are passed in, the raymesh will be plotted in the coordinate system set by the user-specified
'extent' argument as-is. Use this alongside 'save_multipolygonz_to_obj()' to plot 3D polygons imported from geospatial sources
in the proper location (but for ease of use, use 'render_multipolygonz()' to plot this data directly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_raymesh(
  raymesh,
  extent = NULL,
  lat = NULL,
  long = NULL,
  altitude = NULL,
  xyz = NULL,
  zscale = 1,
  heightmap = NULL,
  load_normals = TRUE,
  change_material = TRUE,
  color = "grey50",
  offset = 0,
  obj_zscale = FALSE,
  swap_yz = NULL,
  angle = c(0, 0, 0),
  scale = c(1, 1, 1),
  clear_previous = FALSE,
  baseshape = "rectangle",
  flat_shading = FALSE,
  lit = FALSE,
  light_altitude = c(45, 30),
  light_direction = c(315, 135),
  light_intensity = 1,
  light_relative = FALSE,
  rgl_tag = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_raymesh_+3A_raymesh">raymesh</code></td>
<td>
<p>'raymesh' object (see the rayvertex package for a description)</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;,&quot;ymin&quot;,&quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_lat">lat</code></td>
<td>
<p>Vector of latitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_long">long</code></td>
<td>
<p>Vector of longitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_altitude">altitude</code></td>
<td>
<p>Default 'NULL'. Elevation of each point, in units of the elevation matrix (scaled by 'zscale'). 
If left 'NULL', this will be just the elevation value at ths surface, offset by 'offset'. If a single value, 
the OBJ will be rendered at that altitude.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_xyz">xyz</code></td>
<td>
<p>Default 'NULL', ignored. A 3 column numeric matrix, with each row specifying the x/y/z 
coordinates of the OBJ model(s). Overrides lat/long/altitude and ignores extent to plot the OBJ in raw rgl coordinates.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_load_normals">load_normals</code></td>
<td>
<p>Default 'TRUE'. Whether to load normals for the 3D model.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_change_material">change_material</code></td>
<td>
<p>Default 'TRUE'. Whether to change the raymesh material (to customize the color).</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_color">color</code></td>
<td>
<p>Default 'black'. Color of the 3D model, if 'load_material = FALSE'.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_offset">offset</code></td>
<td>
<p>Default '5'. Offset of the track from the surface, if 'altitude = NULL'.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_obj_zscale">obj_zscale</code></td>
<td>
<p>Default 'FALSE'. Whether to scale the size of the OBJ by zscale to have it match
the size of the map. If zscale is very big, this will make the model very small.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_swap_yz">swap_yz</code></td>
<td>
<p>Default 'NULL', defaults to 'FALSE' unless plotting raw coordinates (no lat or long passed).
Whether to swap and Y and Z axes. (Y axis is vertical in 
rayshader coordinates, but data is often provided with Z being vertical).</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0,0,0)'. Angle of rotation around the x, y, and z axes. If this is a matrix or list,
each row (or list entry) specifies the rotation of the nth model specified (number of rows/length of list must
equal the length of 'lat'/'long').</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1,1,1)'. Amount to scale the 3D model in the x, y, and z axes. If this is a matrix or list,
each row (or list entry) specifies the scale of the nth model specified (number of rows/length of list must
equal the length of 'lat'/'long').</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing points.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_baseshape">baseshape</code></td>
<td>
<p>Default 'rectangle'. Shape of the base. Options are 'c(&quot;rectangle&quot;,&quot;circle&quot;,&quot;hex&quot;)'.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_flat_shading">flat_shading</code></td>
<td>
<p>Default &lsquo;FALSE'. If 'TRUE', this will use rgl&rsquo;s flat shading.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_lit">lit</code></td>
<td>
<p>Default 'TRUE'. Whether to light the polygons.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_light_altitude">light_altitude</code></td>
<td>
<p>Default 'c(45, 60)'. Degree(s) from the horizon from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_light_direction">light_direction</code></td>
<td>
<p>Default 'c(45, 60)'. Degree(s) from north from which to light the polygons.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_light_intensity">light_intensity</code></td>
<td>
<p>Default '0.3'. Intensity of the specular highlight on the polygons.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_light_relative">light_relative</code></td>
<td>
<p>Default 'FALSE'. Whether the light direction should be taken relative to the camera,
or absolute.</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_rgl_tag">rgl_tag</code></td>
<td>
<p>Default '&quot;&quot;'. Tag to add to the rgl scene id, will be prefixed by '&quot;objraymsh&quot;'</p>
</td></tr>
<tr><td><code id="render_raymesh_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'rgl::triangles3d()'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
}
</code></pre>

<hr>
<h2 id='render_resize_window'>Resize the rgl Window</h2><span id='topic+render_resize_window'></span>

<h3>Description</h3>

<p>Resize the rgl Window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_resize_window(width = NULL, height = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_resize_window_+3A_width">width</code></td>
<td>
<p>Default 'NULL', no change to the current value. New window width.</p>
</td></tr>
<tr><td><code id="render_resize_window_+3A_height">height</code></td>
<td>
<p>Default 'NULL', no change to the current value. New window height</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Resize the rgl window to various sizes
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50,zoom=0.6,theta=-90,phi=30)
render_resize_window(width = 800, height = 800)
render_snapshot()
}
 
if(run_documentation()) {
render_resize_window(width = 200, height = 200)
render_snapshot()
}
if(run_documentation()) {
render_resize_window(width = 800, height = 400)
render_snapshot()
}
</code></pre>

<hr>
<h2 id='render_scalebar'>Render Scale Bar</h2><span id='topic+render_scalebar'></span>

<h3>Description</h3>

<p>Places a scale bar on the map in 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_scalebar(
  limits,
  position = "W",
  y = NULL,
  segments = 10,
  scale_length = 1,
  label_unit = "",
  offset = NULL,
  radius = NULL,
  color_first = "darkred",
  color_second = "grey80",
  color_text = "black",
  text_switch_side = FALSE,
  text_x_offset = 0,
  text_y_offset = 0,
  text_z_offset = 0,
  clear_scalebar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_scalebar_+3A_limits">limits</code></td>
<td>
<p>The distance represented by the scale bar. If a numeric vector greater than length 1, 
this will specify the breaks along the scale bar to place labels, with the maximum value in 
limits assumed to be the last label. Must be non-negative.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_position">position</code></td>
<td>
<p>Default 'W'. A string representing a direction. Can be 'N', 'E', 'S', and 'W'.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_y">y</code></td>
<td>
<p>Default 'NULL'. The height of the scale bar, automatically calculated if 'NULL'.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_segments">segments</code></td>
<td>
<p>Default '10'. Number of colored segments in the scalebar.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_scale_length">scale_length</code></td>
<td>
<p>Default '1'. Length of the scale bar, relative to the 
side of the map specified in 'position'. If a length-2 vector, the first number specifies the start
and stop points along the side.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_label_unit">label_unit</code></td>
<td>
<p>Default 'NULL'. The distance unit for the label.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_offset">offset</code></td>
<td>
<p>Default 'NULL'. The distance away from the edge to place the scale bar.
If 'NULL', automatically calculated.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_radius">radius</code></td>
<td>
<p>Default 'NULL'. The radius of the cylinder representing the scale bar.
If 'NULL', automatically calculated.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_color_first">color_first</code></td>
<td>
<p>Default 'darkred'. Primary color in the scale bar.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_color_second">color_second</code></td>
<td>
<p>Default 'grey90'. Seconary color in the scale bar.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_color_text">color_text</code></td>
<td>
<p>Default 'black'. Color of the text.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_text_switch_side">text_switch_side</code></td>
<td>
<p>Default 'FALSE'. Switches the order of the text.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_text_x_offset">text_x_offset</code></td>
<td>
<p>Default '0'. Distance offset for text in the x direction.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_text_y_offset">text_y_offset</code></td>
<td>
<p>Default '0'. Distance offset for text in the y direction.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_text_z_offset">text_z_offset</code></td>
<td>
<p>Default '0'. Distance offset for text in the z direction.</p>
</td></tr>
<tr><td><code id="render_scalebar_+3A_clear_scalebar">clear_scalebar</code></td>
<td>
<p>Default 'FALSE'. Clears the scale bar(s) on the map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays snapshot of current rgl plot (or saves to disk).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Add a scale bar to the montereybay dataset, here representing about 80km
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,theta=45, water=TRUE)
render_scalebar(limits=c(0, 80), label_unit = "km")
render_snapshot()
}
if(run_documentation()) {
#This function works with `render_highquality()`
render_highquality(lightdirection = 250, lightaltitude = 40, 
                  scale_text_size = 24, clamp_value = 10,
                  sample_method = "sobol_blue", samples = 128)
render_scalebar(clear_scalebar = TRUE)
}
if(run_documentation()) {
#We can change the position by specifying a cardinal direction to `position`, and the 
#color by setting `color_first` and `color_second`

render_scalebar(limits=c(0,80), label_unit = "km", position = "N",
               color_first = "darkgreen", color_second = "lightgreen")
render_snapshot()
render_scalebar(clear_scalebar = TRUE)
}
if(run_documentation()) {
#And switch the orientation by setting `text_switch_side = TRUE`
render_scalebar(limits=c(0,80), label_unit = "km", position = "N", text_switch_side = TRUE,
               color_first = "darkgreen", color_second = "lightgreen")
render_snapshot()
render_scalebar(clear_scalebar = TRUE)
}
if(run_documentation()) {
#We can add additional breaks by specifying additional distances in `limits`

render_scalebar(limits=c(0,40,80), label_unit = "km")
render_snapshot()
render_scalebar(clear_scalebar = TRUE)
}
if(run_documentation()) {
#We can also manually specify the height by setting the `y` argument:

render_scalebar(limits=c(0,40,80), y=-70, label_unit = "km")
render_snapshot()
render_scalebar(clear_scalebar = TRUE)
}
if(run_documentation()) {
#Here we change the total size by specifying a start and end point along the side,
#and set the number of colored `segments`:

render_scalebar(limits=c(0,20, 40), segments = 4, scale_length = c(0.5,1), label_unit = "km")
render_scalebar(limits=c(0,20, 40), segments = 4, position = "N", text_switch_side = TRUE,
               scale_length = c(0.25,0.75), label_unit = "km")
render_snapshot()
render_scalebar(clear_scalebar = TRUE)
}
if(run_documentation()) {
#Change the radius of the scale bar with `radius`. Here, the autopositioning doesn't work well with
#the labels, so we provide additional offsets with `text_y_offset` and `text_x_offset` to fix it.

render_scalebar(limits=c(0,20, 40), segments = 4, scale_length = c(0.5,1), 
               label_unit = "km", radius=10,text_y_offset=-20,text_x_offset=20)
render_snapshot()
}
</code></pre>

<hr>
<h2 id='render_snapshot'>Render Snapshot of 3D Visualization</h2><span id='topic+render_snapshot'></span>

<h3>Description</h3>

<p>Either captures the current rgl view and displays, or saves the current view to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_snapshot(
  filename,
  clear = FALSE,
  title_text = NULL,
  title_offset = c(20, 20),
  title_color = "black",
  title_size = 30,
  title_font = "sans",
  title_bar_color = NULL,
  title_bar_alpha = 0.5,
  title_position = "northwest",
  image_overlay = NULL,
  vignette = FALSE,
  vignette_color = "black",
  vignette_radius = 1.3,
  instant_capture = interactive(),
  bring_to_front = FALSE,
  webshot = FALSE,
  width = NULL,
  height = NULL,
  software_render = FALSE,
  camera_location = NULL,
  camera_lookat = c(0, 0, 0),
  background = NULL,
  text_angle = NULL,
  text_size = 30,
  text_offset = c(0, 0, 0),
  point_radius = 2,
  line_offset = 1e-07,
  thick_lines = TRUE,
  line_radius = 0.5,
  cache_scene = FALSE,
  reset_scene_cache = FALSE,
  new_page = TRUE,
  print_scene_info = FALSE,
  fsaa = 1,
  rayvertex_lighting = FALSE,
  rayvertex_lights = NULL,
  rayvertex_shadow_map = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_snapshot_+3A_filename">filename</code></td>
<td>
<p>Filename of snapshot. If missing, will display to current device.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_clear">clear</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the current 'rgl' device will be cleared.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_title_text">title_text</code></td>
<td>
<p>Default 'NULL'. Text. Adds a title to the image, using magick::image_annotate.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_title_offset">title_offset</code></td>
<td>
<p>Default 'c(20,20)'. Distance from the top-left (default, 'gravity' direction in 
image_annotate) corner to offset the title.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_title_color">title_color</code></td>
<td>
<p>Default 'black'. Font color.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_title_size">title_size</code></td>
<td>
<p>Default '30'. Font size in pixels.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_title_font">title_font</code></td>
<td>
<p>Default 'sans'. String with font family such as &quot;sans&quot;, &quot;mono&quot;, &quot;serif&quot;, &quot;Times&quot;, &quot;Helvetica&quot;, 
&quot;Trebuchet&quot;, &quot;Georgia&quot;, &quot;Palatino&quot; or &quot;Comic Sans&quot;.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_title_bar_color">title_bar_color</code></td>
<td>
<p>Default 'NULL'. If a color, this will create a colored bar under the title.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_title_bar_alpha">title_bar_alpha</code></td>
<td>
<p>Default '0.5'. Transparency of the title bar.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_title_position">title_position</code></td>
<td>
<p>Default 'northwest'. Position of the title.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_image_overlay">image_overlay</code></td>
<td>
<p>Default 'NULL'. Either a string indicating the location of a png image to overlay
over the image (transparency included), or a 4-layer RGBA array. This image will be resized to the 
dimension of the image if it does not match exactly.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_vignette">vignette</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE' or numeric, a camera vignetting effect will be added to the image.
'1' is the darkest vignetting, while '0' is no vignetting. If vignette is a length-2 vector, the second entry will
control the blurriness of the vignette effect.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_vignette_color">vignette_color</code></td>
<td>
<p>Default '&quot;black&quot;'. Color of the vignette.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_vignette_radius">vignette_radius</code></td>
<td>
<p>Default '1.3'. Radius of the vignette, as a porportion of the image dimensions.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_instant_capture">instant_capture</code></td>
<td>
<p>Default 'TRUE' if interactive, 'FALSE' otherwise. If 'FALSE', a slight delay is added 
before taking the snapshot. This can help stop prevent rendering issues when running scripts.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_bring_to_front">bring_to_front</code></td>
<td>
<p>Default 'FALSE'. Whether to bring the window to the front when taking the snapshot.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_webshot">webshot</code></td>
<td>
<p>Default 'FALSE'. Set to 'TRUE' to have rgl use the 'webshot2' package to take images,
which can be used when 'rgl.useNULL = TRUE'.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_width">width</code></td>
<td>
<p>Default 'NULL'. Optional argument to pass to 'rgl::snapshot3d()' to specify the
width when 'software_render = TRUE'..</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_height">height</code></td>
<td>
<p>Default 'NULL'. Optional argument to pass to 'rgl::snapshot3d()' to specify the
height when 'software_render = TRUE'.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_software_render">software_render</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', rayshader will use the rayvertex package to render the snapshot, which
is not constrained by the screen size or requires OpenGL.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_camera_location">camera_location</code></td>
<td>
<p>Default 'NULL'. Custom position of the camera. The 'FOV', 'width', and 'height' arguments will still
be derived from the rgl window.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_camera_lookat">camera_lookat</code></td>
<td>
<p>Default 'NULL'. Custom point at which the camera is directed. The 'FOV', 'width', and 'height' arguments will still
be derived from the rgl window.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_background">background</code></td>
<td>
<p>Default 'NULL', defaults to device background. Background color when 'software_render = TRUE'.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_text_angle">text_angle</code></td>
<td>
<p>Default 'NULL', which forces the text always to face the camera. If a single angle (degrees),
will specify the absolute angle all the labels are facing. If three angles, this will specify all three orientations
(relative to the x,y, and z axes) of the text labels.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_text_size">text_size</code></td>
<td>
<p>Default '30'. Height of the text.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_text_offset">text_offset</code></td>
<td>
<p>Default 'c(0,0,0)'. Offset to be applied to all text labels.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_point_radius">point_radius</code></td>
<td>
<p>Default '2'. Radius of 3D points (rendered with 'render_points()'.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_line_offset">line_offset</code></td>
<td>
<p>Default '1e-7'. Small number indicating the offset in the scene to apply to lines if using software rendering. Increase this if your lines 
aren't showing up, or decrease it if lines are appearing through solid objects.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_thick_lines">thick_lines</code></td>
<td>
<p>Default 'TRUE'. If 'software_render = TRUE', this will render path segments as thick cylinders. Otherwise, it will 
render the lines using a single-pixel anti-aliased line algorithm.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_line_radius">line_radius</code></td>
<td>
<p>Default '0.5'. The radius of the thick cylinders if 'thick_lines = TRUE' and 'software_render = TRUE'.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_cache_scene">cache_scene</code></td>
<td>
<p>Default 'FALSE'. Whether to cache the current scene to memory so it does not have to be converted to a 'raymesh' object 
each time 'render_snapshot()' is called. If 'TRUE' and a scene has been cached, it will be used when rendering.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_reset_scene_cache">reset_scene_cache</code></td>
<td>
<p>Default 'FALSE'. Resets the scene cache before rendering.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_new_page">new_page</code></td>
<td>
<p>Default 'TRUE'. Whether to call 'grid::grid.newpage()' before plotting the image.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_print_scene_info">print_scene_info</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will print the position and lookat point of the camera.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_fsaa">fsaa</code></td>
<td>
<p>Default '1'. Integer specifying the amount of anti-aliasing applied 'software_render = TRUE'.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_rayvertex_lighting">rayvertex_lighting</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE' and 'software_render = TRUE', the scene will use rayvertex lighting when rendering
the scene, using the lights specified in 'rayvertex_lights'. If no lights are specified there, they will be pulled
from 'light' objects in the 'rgl' scene.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_rayvertex_lights">rayvertex_lights</code></td>
<td>
<p>Default 'NULL'. Use 'rayvertex::directional_light()' and 'rayvertex::point_light()' along with the 
'rayvertex::add_light()' function to specify lighting for your scene when 'rayvertex_lighting = TRUE'.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_rayvertex_shadow_map">rayvertex_shadow_map</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE' and 'rayvertex_lighting = TRUE' along with 'software_render = TRUE', shadow mapping will also
be applied to the rendered scene.</p>
</td></tr>
<tr><td><code id="render_snapshot_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to 'rayvertex::rasterize_scene()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays snapshot of current rgl plot (or saves to disk).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50,zoom=0.6,theta=-90,phi=30)
}
 
if(run_documentation()) {
render_snapshot()
}
 
#Create a title
if(run_documentation()) {
render_snapshot(title_text = "Monterey Bay, California", title_offset=c(0,20),
               title_color = "white", title_bar_color = "black",
               title_font = "Helvetica", title_position = "north")
               
#Add a vignette effect
render_camera(zoom=0.8)
render_snapshot(title_text = "Monterey Bay, California", 
               title_color = "white", title_bar_color = "darkgreen",
               vignette = TRUE, title_offset=c(0,20),
               title_font = "Helvetica", title_position = "north")
}
#Use software rendering to render a scene with shadow mapping
if(run_documentation()) {
montereybay |&gt; 
 height_shade() |&gt; 
 plot_3d(montereybay, shadow=FALSE, solidlinecolor = NULL)
#No shadows
render_snapshot(software_render = TRUE)
}
if(run_documentation()) {
#Now with shadow mapped shadows, calculated in rayvertex
render_snapshot(rayvertex_lighting = TRUE, 
               rayvertex_lights = rayvertex::directional_light(intensity = 1.2, 
                                                               direction = c(-1, 1, -1)), 
               rayvertex_shadow_map = TRUE, software_render = TRUE)
}
</code></pre>

<hr>
<h2 id='render_snapshot_software'>Render Software Snapshot</h2><span id='topic+render_snapshot_software'></span>

<h3>Description</h3>

<p>Render Software Snapshot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_snapshot_software(
  filename,
  cache_scene = FALSE,
  camera_location = NULL,
  camera_lookat = c(0, 0, 0),
  background = NULL,
  return_all = FALSE,
  width = NULL,
  height = NULL,
  light_direction = NULL,
  fake_shadow = TRUE,
  text_angle = NULL,
  text_size = 1,
  text_offset = c(0, 0, 0),
  fov = NULL,
  print_scene_info = FALSE,
  point_radius = 1,
  line_offset = -1e-07,
  fsaa = 1,
  thick_lines = FALSE,
  line_radius = 0.5,
  rayvertex_lighting = FALSE,
  rayvertex_lights = NULL,
  rayvertex_shadow_map = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_snapshot_software_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to 'rayvertex::rasterize_scene()'</p>
</td></tr>
</table>

<hr>
<h2 id='render_tree'>Render Tree</h2><span id='topic+render_tree'></span>

<h3>Description</h3>

<p>Adds a 3D representation of trees to an existing 3D scene generated with rayshader.
Users can specify the trees' geographical positions using latitude and longitude or the same coordinate reference system as 'extent'.
Different types of tree models can be used, including a basic and a cone-shaped tree. Users can also use their own custom tree model in
OBJ format. The function allows customization of various aspects of the tree, including the color of the crown and the trunk,
the size of the crown (the leafy part of the tree) and the trunk, the overall scale of the tree, and the rotation angle around the x, y, and z axes.
Users can also specify the minimum and maximum height of the trees to be rendered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_tree(
  lat = NULL,
  long = NULL,
  extent = NULL,
  type = "basic",
  custom_obj_tree = NULL,
  custom_obj_crown = NULL,
  custom_obj_trunk = NULL,
  crown_color = "#22aa22",
  trunk_color = "#964B00",
  absolute_height = FALSE,
  tree_height = NULL,
  trunk_height_ratio = NULL,
  crown_width_ratio = NULL,
  crown_width = NULL,
  trunk_radius = NULL,
  tree_zscale = TRUE,
  min_height = 0,
  max_height = Inf,
  zscale = 1,
  lit = TRUE,
  heightmap = NULL,
  baseshape = "rectangle",
  angle = c(0, 0, 0),
  clear_previous = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_tree_+3A_lat">lat</code></td>
<td>
<p>Vector of latitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="render_tree_+3A_long">long</code></td>
<td>
<p>Vector of longitudes (or other coordinate in the same coordinate reference system as extent).</p>
</td></tr>
<tr><td><code id="render_tree_+3A_extent">extent</code></td>
<td>
<p>Either an object representing the spatial extent of the 3D scene 
(either from the 'raster', 'terra', 'sf', or 'sp' packages), 
a length-4 numeric vector specifying 'c(&quot;xmin&quot;, &quot;xmax&quot;, &quot;ymin&quot;, &quot;ymax&quot;)', or the spatial object (from 
the previously aforementioned packages) which will be automatically converted to an extent object.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_type">type</code></td>
<td>
<p>Default '&quot;basic&quot;'. Type of tree. Other built-in option: '&quot;cone&quot;'.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_custom_obj_tree">custom_obj_tree</code></td>
<td>
<p>Default 'NULL'. Instead of using the built-in types, users can also load a custom tree 
model in OBJ format. This function loads and manipulates the model, assuming the tree model's trunk begins 
at the origin. Color and specific trunk/crown proportions will be fixed to the model specified, although the overall 
scale can be changed per-tree via 'crown_height'.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_custom_obj_crown">custom_obj_crown</code></td>
<td>
<p>Default 'NULL'. Instead of using the built-in types, users can also load a custom crown 
model in OBJ format. This function loads a crown model and allows you to control the crown and trunk proportions separately.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_custom_obj_trunk">custom_obj_trunk</code></td>
<td>
<p>Default 'NULL'.  Instead of using the built-in types, users can also load a custom trunk 
model in OBJ format. This function loads a trunk model and allows you to control the crown and trunk proportions separately.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_crown_color">crown_color</code></td>
<td>
<p>Default '&quot;darkgreen&quot;'. Color(s) of the crown.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_trunk_color">trunk_color</code></td>
<td>
<p>Default '&quot;#964B00&quot;' (brown). Color(s) of the trunk,</p>
</td></tr>
<tr><td><code id="render_tree_+3A_absolute_height">absolute_height</code></td>
<td>
<p>Default 'FALSE'. Default is specifying the tree height directly, relative to the 
underlying height map. If 'TRUE', 'crown_height' will specified by the actual altitude of the top of the tree.  
Total tree height will be 'crown_height + trunk_height'.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_tree_height">tree_height</code></td>
<td>
<p>Default 'NULL'. Height of the tree, automatically set to '10' if not specified. If 'absolute_height = TRUE', then this is interpreted as 
the altitude of the top of the tree in the coordinate reference system used. If 'absolute_height = FALSE', then 
this is interpreted as the height of the tree relative to the underlying heightmap.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_trunk_height_ratio">trunk_height_ratio</code></td>
<td>
<p>Default 'NULL'. The ratio of the height of the trunk to the total height of the tree.
Default is 1/3rd the crown height if 'type = &quot;basic&quot;', and 1/6th the crown height if 'type = &quot;cone&quot;'.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_crown_width_ratio">crown_width_ratio</code></td>
<td>
<p>Default 'NULL'. Ratio of the crown width to the crown height. A value of '1' is spherical.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_crown_width">crown_width</code></td>
<td>
<p>Default 'NULL'. As an alternative to specifying the ratio, you can use this argument to 
specify the crown width directly.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_trunk_radius">trunk_radius</code></td>
<td>
<p>Default 'NULL', automatically computed.
Default is 1/5rd the trunk height if 'type = &quot;basic&quot;', and 1/10th the trunk height if 'type = &quot;cone&quot;'.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_tree_zscale">tree_zscale</code></td>
<td>
<p>Default 'TRUE'. Whether to scale the size of the tree by zscale to have it match
the size of the map. If zscale is very big, this will make the trees very small.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_min_height">min_height</code></td>
<td>
<p>Default 'NULL'. Minimum height of a tree. Set to a positive number to filter out trees 
below that height.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_max_height">max_height</code></td>
<td>
<p>Default 'NA'. Maximum height of a tree. Set to a positive number to filter out trees 
above that height.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_lit">lit</code></td>
<td>
<p>Default 'TRUE'. Whether to apply lighting to the tree.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_heightmap">heightmap</code></td>
<td>
<p>Default 'NULL'. Automatically extracted from the rgl window&ndash;only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_baseshape">baseshape</code></td>
<td>
<p>Default 'rectangle'. Shape of the base. Options are 'c(&quot;rectangle&quot;,&quot;circle&quot;,&quot;hex&quot;)'.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0,0,0)'. Angle of rotation around the x, y, and z axes. If this is a matrix or list,
each row (or list entry) specifies the rotation of the nth tree specified (number of rows/length of list must
equal the length of 'lat'/'long').</p>
</td></tr>
<tr><td><code id="render_tree_+3A_clear_previous">clear_previous</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will clear all existing trees.</p>
</td></tr>
<tr><td><code id="render_tree_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'rgl::triangles3d()'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Let's first start by drawing some trees in a circle around Monterey Bay
#We won't scale these to a realistic size (yet)
moss_landing_coord = c(36.806807, -121.793332)
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50,water=TRUE,
         shadowcolor="#40310a", background = "tan",
         theta=210,  phi=22, zoom=0.20, fov=55)

t = seq(0,2*pi,length.out=20)
circle_coords_lat = moss_landing_coord[1] + 0.3 * sin(t)
circle_coords_long = moss_landing_coord[2] + 0.3 * cos(t)

render_tree(extent = attr(montereybay,"extent"), heightmap = montereybay,
           tree_zscale = FALSE, tree_height = 30,  lit = TRUE,
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long), zscale=50) 
render_snapshot()
}
if(run_documentation()) {
#Change the crown width ratio (compared to the height)
render_tree(extent = attr(montereybay,"extent"), heightmap = montereybay,
           tree_zscale = FALSE, tree_height = 60, crown_width_ratio = 0.5,
           clear_previous = TRUE, 
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long), zscale=50) 
render_snapshot()
}
if(run_documentation()) {
#Change the trunk height and width
render_tree(extent = attr(montereybay,"extent"), heightmap = montereybay,
           tree_zscale = FALSE, tree_height = 40, crown_width_ratio = 2,
           clear_previous = TRUE, trunk_height_ratio=1/2, trunk_radius = 1.5,
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long), zscale=50) 
render_snapshot()
}
if(run_documentation()) {
#Change the tree type
render_tree(extent = attr(montereybay,"extent"), heightmap = montereybay,
           tree_zscale = FALSE, tree_height = 30, 
           clear_previous = TRUE, type = "cone",trunk_height_ratio = 1/6,
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long), zscale=50) 
render_snapshot()
}
if(run_documentation()) {
#Change the crown color:
render_camera(theta = 150,  phi = 38, zoom = 0.4, fov = 55)
render_tree(extent = attr(montereybay,"extent"), heightmap = montereybay,
           tree_zscale = FALSE, tree_height = 30, crown_width_ratio = 0.5 + runif(20),
           crown_color = rainbow(20),  clear_previous = TRUE, 
           lat = unlist(circle_coords_lat), long = unlist(circle_coords_long), zscale=50) 
render_snapshot()
}

#We will use the lidR package to generate a DEM and detect the crown tops of trees, and
#then use rayshader to render 3D tree models scaled to those heights on the map.
run_example = length(find.package("lidR", quiet = TRUE)) &gt; 0 &amp;&amp; 
             length(find.package("sf", quiet = TRUE)) &gt; 0 &amp;&amp; 
             length(find.package("terra", quiet = TRUE)) &gt; 0 &amp;&amp;
             run_documentation()
if (run_example) {
#Load the example data from the lidR package
LASfile = system.file("extdata", "Topography.laz", package="lidR")
las = lidR::readLAS(LASfile, filter = "-inside 273450 5274350 273550 5274450")

#Convert the lidar point data to a DEM and detect the location of trees from the same data
dem = lidR::rasterize_terrain(las, algorithm = lidR::tin())
tree_top_data = lidR::locate_trees(las, lidR::lmf(ws = 5))
tree_locations = sf::st_coordinates(tree_top_data)

#Convert DEM to a matrix and extract the extent of the scene
dem_matrix = raster_to_matrix(dem)
dem_extent = terra::ext(dem)
extent_values = dem_extent@ptr$vector

#Plot the ground
dem_matrix |&gt;
 height_shade() |&gt;
 add_shadow(texture_shade(dem_matrix),0.2) |&gt; 
 add_shadow(lamb_shade(dem_matrix),0) |&gt; 
 plot_3d(dem_matrix)
render_snapshot()
}
if (run_example) {
#The tree locations are given as an absolute height (as opposed to relative to the surface)
#so we set `absolute_height = TRUE`.
render_tree(lat = tree_locations[,2], 
           long = tree_locations[,1],
           crown_width_ratio = 0.5, 
           absolute_height = TRUE, 
           tree_height = tree_locations[,3],
           trunk_height_ratio = 0.2 + 0.1*runif(nrow(tree_locations)),
           crown_color = "#00aa00",
           extent = raster::extent(extent_values), 
           heightmap = dem_matrix,
           clear_previous = TRUE)
           
#Remove existing lights and add our own with rgl
rgl::pop3d("lights")
rgl::light3d(phi=35,theta=90, viewpoint.rel=F, diffuse="#ffffff", specular="#000000")
rgl::light3d(phi=-45,theta=-40, viewpoint.rel=F, diffuse="#aaaaaa", specular="#000000")
render_snapshot() 
}
if (run_example) {
#Render tree also works with `render_highquality()`
render_highquality(lightdirection=c(90,45),lightaltitude=c(90,45), 
                  lightcolor=c("dodgerblue","orange"), 
                  min_variance = 0, sample_method="sobol_blue", clamp_value=10)
}
</code></pre>

<hr>
<h2 id='render_water'>Render Water Layer</h2><span id='topic+render_water'></span>

<h3>Description</h3>

<p>Adds water layer to the scene, removing the previous water layer if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_water(
  heightmap,
  waterdepth = 0,
  watercolor = "lightblue",
  zscale = 1,
  wateralpha = 0.5,
  waterlinecolor = NULL,
  waterlinealpha = 1,
  linewidth = 2,
  remove_water = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_water_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="render_water_+3A_waterdepth">waterdepth</code></td>
<td>
<p>Default '0'.</p>
</td></tr>
<tr><td><code id="render_water_+3A_watercolor">watercolor</code></td>
<td>
<p>Default 'lightblue'.</p>
</td></tr>
<tr><td><code id="render_water_+3A_zscale">zscale</code></td>
<td>
<p>Default '1'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. For example, if the elevation levels are in units
of 1 meter and the grid values are separated by 10 meters, 'zscale' would be 10.</p>
</td></tr>
<tr><td><code id="render_water_+3A_wateralpha">wateralpha</code></td>
<td>
<p>Default '0.5'. Water transparency.</p>
</td></tr>
<tr><td><code id="render_water_+3A_waterlinecolor">waterlinecolor</code></td>
<td>
<p>Default 'NULL'. Color of the lines around the edges of the water layer.</p>
</td></tr>
<tr><td><code id="render_water_+3A_waterlinealpha">waterlinealpha</code></td>
<td>
<p>Default '1'. Water line tranparency.</p>
</td></tr>
<tr><td><code id="render_water_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '2'. Width of the edge lines in the scene.</p>
</td></tr>
<tr><td><code id="render_water_+3A_remove_water">remove_water</code></td>
<td>
<p>Default 'TRUE'. If 'TRUE', will remove existing water layer and replace it with new layer.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay,zscale=50)
render_snapshot()
}
 
#We want to add a layer of water after the initial render.
if(run_documentation()) {
render_water(montereybay,zscale=50)
render_snapshot()
}

#Call it again to change the water depth
if(run_documentation()) {
render_water(montereybay,zscale=50,waterdepth=-1000)
render_snapshot()
}

#Add waterlines
if(run_documentation()) {
render_camera(theta=-45)
render_water(montereybay,zscale=50,waterlinecolor="white")
render_snapshot()
}
</code></pre>

<hr>
<h2 id='resize_matrix'>Resize Matrix</h2><span id='topic+resize_matrix'></span>

<h3>Description</h3>

<p>Resizes a matrix (preserving contents) by specifying the desired output dimensions or a scaling factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resize_matrix(
  heightmap,
  scale = 1,
  width = NULL,
  height = NULL,
  method = "bilinear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resize_matrix_+3A_heightmap">heightmap</code></td>
<td>
<p>The elevation matrix.</p>
</td></tr>
<tr><td><code id="resize_matrix_+3A_scale">scale</code></td>
<td>
<p>Default '0.5'. The amount to scale down the matrix. Scales using bilinear interpolation.</p>
</td></tr>
<tr><td><code id="resize_matrix_+3A_width">width</code></td>
<td>
<p>Default 'NULL'.  Alternative to 'scale' argument. The desired output width. If 'width' is less than 1, it will be interpreted as a scaling factor&ndash;
e.g. 0.5 would halve the resolution for the width.</p>
</td></tr>
<tr><td><code id="resize_matrix_+3A_height">height</code></td>
<td>
<p>Default 'NULL'. Alternative to 'scale' argument. The desired output width. If 'height' is less than 1, it will be interpreted as a scaling factor&ndash;
e.g. 0.5 would halve the resolution for the height.</p>
</td></tr>
<tr><td><code id="resize_matrix_+3A_method">method</code></td>
<td>
<p>Default 'bilinear'. Method of interpolation. Alteratively 'cubic', which is slightly smoother, although
current implementation slightly scales the image.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Reduce the size of the monterey bay dataset by half

if(run_documentation()) {
montbaysmall = resize_matrix(montereybay, scale=0.5)
montbaysmall %&gt;%
 sphere_shade() %&gt;%
 plot_map()
}
if(run_documentation()) {
#Reduce the size of the monterey bay dataset from 540x540 to 100x100
montbaysmall = resize_matrix(montereybay, width = 100, height = 100)
montbaysmall %&gt;%
 sphere_shade() %&gt;%
 plot_map()
}
if(run_documentation()) {
#Increase the size of the volcano dataset 3x
volcanobig = resize_matrix(volcano, scale=3)
volcanobig %&gt;% 
 sphere_shade() %&gt;%
 plot_map()
}
if(run_documentation()) {
#Increase the size of the volcano dataset 2x, using cubic interpolation
volcanobig = resize_matrix(volcano, scale=3, method="cubic")
volcanobig %&gt;% 
 sphere_shade() %&gt;%
 plot_map()
}
</code></pre>

<hr>
<h2 id='rot_to_euler'>Rotation Matrix to Euler Angle Transform</h2><span id='topic+rot_to_euler'></span>

<h3>Description</h3>

<p>Transforms a rotation matrix (R_X R_Y R_Z) into Euler angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rot_to_euler(rotmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rot_to_euler_+3A_rotmat">rotmat</code></td>
<td>
<p>The rotation matrix. Can be 3x3 or 4x4 (homogeneous coordinates).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euler angles in degrees. c(phi,theta,yaw)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#None
</code></pre>

<hr>
<h2 id='run_documentation'>Run Documentation</h2><span id='topic+run_documentation'></span>

<h3>Description</h3>

<p>This function determines if the examples are being run in pkgdown. It is not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_documentation()
</code></pre>


<h3>Value</h3>

<p>Boolean value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See if the documentation should be run.
run_documentation()
</code></pre>

<hr>
<h2 id='save_3dprint'>Save 3D Print</h2><span id='topic+save_3dprint'></span>

<h3>Description</h3>

<p>Writes a stereolithography (STL) file that can be used in 3D printing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_3dprint(filename, maxwidth = 125, unit = "mm", rotate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_3dprint_+3A_filename">filename</code></td>
<td>
<p>String with the filename. If '.stl' is not at the end of the string, it will be appended automatically.</p>
</td></tr>
<tr><td><code id="save_3dprint_+3A_maxwidth">maxwidth</code></td>
<td>
<p>Default '125'. Desired maximum width of the 3D print in millimeters. Uses the units set in 'unit' argument. Can also pass in a string, &quot;125mm&quot; or &quot;5in&quot;.</p>
</td></tr>
<tr><td><code id="save_3dprint_+3A_unit">unit</code></td>
<td>
<p>Default 'mm'. Units of the 'maxwidth' argument. Can also be set to inches with 'in'.</p>
</td></tr>
<tr><td><code id="save_3dprint_+3A_rotate">rotate</code></td>
<td>
<p>Default 'TRUE'. If 'FALSE', the map will be printing on its side. This may improve resolution for some 3D printing types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Writes an STL file to 'filename'. Regardless of the unit displayed, the output STL is in millimeters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename_stl = tempfile()

#Save the STL file into `filename_stl`
if(run_documentation()) {
volcano %&gt;%
 sphere_shade() %&gt;%
 plot_3d(volcano,zscale=3)
render_snapshot()
save_3dprint(filename_stl)
}

#Save the STL file into `filename_stl`, setting maximum width to 100 mm
if(run_documentation()) {
volcano %&gt;%
 sphere_shade() %&gt;%
 plot_3d(volcano,zscale=3)
render_snapshot()
save_3dprint(filename_stl, maxwidth = 100)
}

#'#Save the STL file into `filename_stl`, setting maximum width to 4 inches
if(run_documentation()) {
volcano %&gt;%
 sphere_shade() %&gt;%
 plot_3d(volcano,zscale=3)
render_snapshot()
save_3dprint(filename_stl, maxwidth = 4, unit = "in")
}
#'#'#Save the STL file into `filename_stl`, setting maximum width (character) to 120mm
if(run_documentation()) {
volcano %&gt;%
 sphere_shade() %&gt;%
 plot_3d(volcano,zscale=3)
render_snapshot()
save_3dprint(filename_stl, maxwidth = "120mm")
}
</code></pre>

<hr>
<h2 id='save_multipolygonz_to_obj'>Save MULTIPOLYGON Z sf data to OBJ file</h2><span id='topic+save_multipolygonz_to_obj'></span>

<h3>Description</h3>

<p>Converts MULTIPOLYGON Z features into a 3D OBJ model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_multipolygonz_to_obj(sfobj, filename, swap_yz = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_multipolygonz_to_obj_+3A_sfobj">sfobj</code></td>
<td>
<p>sf object with MULTIPOLYGON Z geometry,</p>
</td></tr>
<tr><td><code id="save_multipolygonz_to_obj_+3A_filename">filename</code></td>
<td>
<p>Filename of the OBJ to save the 3D model to.</p>
</td></tr>
<tr><td><code id="save_multipolygonz_to_obj_+3A_swap_yz">swap_yz</code></td>
<td>
<p>Default 'TRUE'., Whether to swap and Y and Z axes. (Y axis is vertical in 
rayshader coordinates, but data is often provided with Z being vertical).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Convert the built-in Washington Monument MULTIPOLYGON Z data to an OBJ file
obj_temp = tempfile(fileext=".obk")
save_multipolygonz_to_obj(washington_monument_multipolygonz, obj_temp, swap_yz=TRUE)
#Render with rgl
rgl::open3d()
render_obj(filename=obj_temp, xyz=matrix(c(0,0,0),ncol=3), color="red")
render_camera(theta=30,phi=40)
</code></pre>

<hr>
<h2 id='save_obj'>Save OBJ</h2><span id='topic+save_obj'></span>

<h3>Description</h3>

<p>Writes the textured 3D rayshader visualization to an OBJ file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_obj(
  filename,
  save_texture = TRUE,
  water_index_refraction = 1,
  manifold_geometry = FALSE,
  all_face_fields = FALSE,
  save_shadow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_obj_+3A_filename">filename</code></td>
<td>
<p>String with the filename. If '.obj' is not at the end of the string, it will be appended automatically.</p>
</td></tr>
<tr><td><code id="save_obj_+3A_save_texture">save_texture</code></td>
<td>
<p>Default 'TRUE'. If the texture should be saved along with the geometry.</p>
</td></tr>
<tr><td><code id="save_obj_+3A_water_index_refraction">water_index_refraction</code></td>
<td>
<p>Default '1'. The index of refraction for the rendered water.</p>
</td></tr>
<tr><td><code id="save_obj_+3A_manifold_geometry">manifold_geometry</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will take the additional step of making the mesh manifold.</p>
</td></tr>
<tr><td><code id="save_obj_+3A_all_face_fields">all_face_fields</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', all OBJ face fields (v/vn/vt) will always be written.</p>
</td></tr>
<tr><td><code id="save_obj_+3A_save_shadow">save_shadow</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this saves a plane with the shadow texture below the model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
filename_obj = tempfile(fileext = ".obj")

#Save model of volcano
if(run_documentation()) {
volcano %&gt;%
 sphere_shade() %&gt;%
 plot_3d(volcano, zscale = 2)

save_obj(filename_obj)
}

#Save model of volcano without texture
if(run_documentation()) {
save_obj(filename_obj, save_texture = FALSE)
}

#Make water have realistic index of refraction
if(run_documentation()) {
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_3d(montereybay, zscale = 50)
 
save_obj(filename_obj, water_index_refraction = 1.5)
}
}
</code></pre>

<hr>
<h2 id='save_png'>Save PNG</h2><span id='topic+save_png'></span>

<h3>Description</h3>

<p>Writes the hillshaded map to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_png(
  hillshade,
  filename,
  title_text = NA,
  title_offset = c(20, 20),
  title_color = "black",
  title_size = 30,
  title_font = "sans",
  title_style = "normal",
  title_bar_color = NULL,
  title_bar_alpha = 0.5,
  title_position = "northwest",
  rotate = 0,
  asp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_png_+3A_hillshade">hillshade</code></td>
<td>
<p>Array (or matrix) of hillshade to be written.</p>
</td></tr>
<tr><td><code id="save_png_+3A_filename">filename</code></td>
<td>
<p>String with the filename. If '.png' is not at the end of the string, it will be appended automatically.</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_text">title_text</code></td>
<td>
<p>Default 'NULL'. Text. Adds a title to the image, using 'magick::image_annotate()'.</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_offset">title_offset</code></td>
<td>
<p>Default 'c(20,20)'. Distance from the top-left (default, 'gravity' direction in
image_annotate) corner to offset the title.</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_color">title_color</code></td>
<td>
<p>Default 'black'. Font color.</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_size">title_size</code></td>
<td>
<p>Default '30'. Font size in pixels.</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_font">title_font</code></td>
<td>
<p>Default 'sans'. String with font family such as &quot;sans&quot;, &quot;mono&quot;, &quot;serif&quot;, &quot;Times&quot;, &quot;Helvetica&quot;,
&quot;Trebuchet&quot;, &quot;Georgia&quot;, &quot;Palatino&quot; or &quot;Comic Sans&quot;.</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_style">title_style</code></td>
<td>
<p>Default 'normal'. Font style (e.g. 'italic').</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_bar_color">title_bar_color</code></td>
<td>
<p>Default 'NULL'. If a color, this will create a colored bar under the title.</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_bar_alpha">title_bar_alpha</code></td>
<td>
<p>Default '0.5'. Transparency of the title bar.</p>
</td></tr>
<tr><td><code id="save_png_+3A_title_position">title_position</code></td>
<td>
<p>Default 'northwest'. Position of the title.</p>
</td></tr>
<tr><td><code id="save_png_+3A_rotate">rotate</code></td>
<td>
<p>Default 0. Rotates the output. Possible values: 0, 90, 180, 270.</p>
</td></tr>
<tr><td><code id="save_png_+3A_asp">asp</code></td>
<td>
<p>Default '1'. Aspect ratio of the resulting plot. Use 'asp = 1/cospi(mean_latitude/180)' to rescale
lat/long at higher latitudes to the correct the aspect ratio.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>filename_map = tempfile()

#Save the map into `filename_map`
montereybay %&gt;%
 sphere_shade() %&gt;%
 save_png(filename_map)
 
#Rotate the map 180 degrees:

montereybay %&gt;%
 sphere_shade() %&gt;%
 save_png(filename_map,rotate=180)
</code></pre>

<hr>
<h2 id='sphere_shade'>Calculate Surface Color Map</h2><span id='topic+sphere_shade'></span>

<h3>Description</h3>

<p>Calculates a color for each point on the surface using the surface normals and
hemispherical UV mapping. This uses either a texture map provided by the user (as an RGB array),
or a built-in color texture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere_shade(
  heightmap,
  sunangle = 315,
  texture = "imhof1",
  normalvectors = NULL,
  colorintensity = 1,
  zscale = 1,
  progbar = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphere_shade_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="sphere_shade_+3A_sunangle">sunangle</code></td>
<td>
<p>Default '315' (NW). The direction of the main highlight color (derived from the built-in palettes or the 'create_texture' function).</p>
</td></tr>
<tr><td><code id="sphere_shade_+3A_texture">texture</code></td>
<td>
<p>Default 'imhof1'. Either a square matrix indicating the spherical texture mapping, or a string indicating one 
of the built-in palettes ('imhof1','imhof2','imhof3','imhof4','desert', 'bw', and 'unicorn').</p>
</td></tr>
<tr><td><code id="sphere_shade_+3A_normalvectors">normalvectors</code></td>
<td>
<p>Default 'NULL'. Cache of the normal vectors (from 'calculate_normal' function). Supply this to speed up texture mapping.</p>
</td></tr>
<tr><td><code id="sphere_shade_+3A_colorintensity">colorintensity</code></td>
<td>
<p>Default '1'. The intensity of the color mapping. Higher values will increase the intensity of the color mapping.</p>
</td></tr>
<tr><td><code id="sphere_shade_+3A_zscale">zscale</code></td>
<td>
<p>Default '1/colorintensity'. The ratio between the x and y spacing (which are assumed to be equal) and the z axis. 
Ignored unless 'colorintensity' missing.</p>
</td></tr>
<tr><td><code id="sphere_shade_+3A_progbar">progbar</code></td>
<td>
<p>Default 'TRUE' if interactive, 'FALSE' otherwise. If 'FALSE', turns off progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGB array of hillshaded texture mappings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Basic example:
montereybay %&gt;%
 sphere_shade() %&gt;%
 plot_map()
 
#Decrease the color intensity:
montereybay %&gt;%
 sphere_shade(colorintensity=0.1) %&gt;%
 plot_map()
 
#Change to a built-in color texture:
montereybay %&gt;%
 sphere_shade(texture="desert") %&gt;%
 plot_map()

#Change the highlight angle:
montereybay %&gt;%
 sphere_shade(texture="desert", sunangle = 45) %&gt;%
 plot_map()

#Create our own texture using the `create_texture` function:
montereybay %&gt;%
 sphere_shade(zscale=10,texture=create_texture("#E9C68D","#AF7F38",
                                               "#674F30","#494D30",
                                               "#B3BEA3")) %&gt;%
 plot_map()
</code></pre>

<hr>
<h2 id='texture_shade'>Calculate Texture Shading Map</h2><span id='topic+texture_shade'></span>

<h3>Description</h3>

<p>Calculates a shadow for each point on the surface using the method described by
Leland Brown in &quot;Texture Shading: A New Technique for Depicting Terrain Relief.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>texture_shade(
  heightmap,
  detail = 0.5,
  contrast = 1,
  brightness = 0,
  transform = TRUE,
  dx = 1,
  dy = 1,
  pad = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="texture_shade_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point.</p>
</td></tr>
<tr><td><code id="texture_shade_+3A_detail">detail</code></td>
<td>
<p>Default '0.5'. Amount of detail in texture shading algorithm. '0' is the least detail, 
while '1' is the most.</p>
</td></tr>
<tr><td><code id="texture_shade_+3A_contrast">contrast</code></td>
<td>
<p>Default '1',standard brightness. Amount of contrast in the texture shading. 
This transforms the resulting darkness using the formula 'tanh(input * contrast + brightness)'.</p>
</td></tr>
<tr><td><code id="texture_shade_+3A_brightness">brightness</code></td>
<td>
<p>Default '0', standard brightness. Higher values will brighten the texture hillshade, 
while lower values will darken it.</p>
</td></tr>
<tr><td><code id="texture_shade_+3A_transform">transform</code></td>
<td>
<p>Default 'TRUE'. Whether to apply the 'tanh(input * contrast + brightness)' transformation.
This transforms the resulting darkness using the formula 'tanh(input * contrast + brightness)'.</p>
</td></tr>
<tr><td><code id="texture_shade_+3A_dx">dx</code></td>
<td>
<p>Default '1'. The distance between each row of data (compared to the height axis).</p>
</td></tr>
<tr><td><code id="texture_shade_+3A_dy">dy</code></td>
<td>
<p>Default '1'. The distance between each column of data (compared to the height axis).</p>
</td></tr>
<tr><td><code id="texture_shade_+3A_pad">pad</code></td>
<td>
<p>Default &lsquo;50'. The amount to pad the heightmap so edge effects don&rsquo;t appear from the
fourier transform. Only increase this if you encounter boundary effects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2D matrix of hillshade values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a direct mapping of elevation to color:
if(run_documentation()) {

#Plut using default values
montereybay %&gt;% 
  texture_shade() %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Increase the level of detail
montereybay %&gt;% 
  texture_shade(detail=1) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Decrease the level of detail
montereybay %&gt;% 
  texture_shade(detail=0) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Increase the level of contrast
montereybay %&gt;% 
  texture_shade(contrast=3) %&gt;% 
  plot_map()
}
if(run_documentation()) {
#Increase the brightness for this level of contrast
montereybay %&gt;% 
  texture_shade(contrast=5, brightness = 2) %&gt;% 
  plot_map()
}
#Add a texture_shade() layer into a map
montbay = montereybay
montbay[montbay &lt; 0] = 0
if(run_documentation()) {
montbay %&gt;%
  height_shade() %&gt;%
  add_water(detect_water(montbay), color="dodgerblue") %&gt;%
  add_shadow(texture_shade(montbay, detail=1/3, contrast = 5, brightness = 6),0) %&gt;%
  add_shadow(lamb_shade(montbay,zscale=50),0) %&gt;% 
  plot_map()
}
</code></pre>

<hr>
<h2 id='transform_into_heightmap_coords'>Get Position from Lat/Long and heightmap/extent</h2><span id='topic+transform_into_heightmap_coords'></span>

<h3>Description</h3>

<p>Get Position from Lat/Long and heightmap/extent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_into_heightmap_coords(
  extent,
  heightmap,
  lat = NULL,
  long = NULL,
  altitude = NULL,
  offset = 0,
  zscale = 1,
  use_altitude = TRUE,
  filter_bounds = TRUE
)
</code></pre>


<h3>Value</h3>

<p>x/y/z
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='transform_points_custom_crs'>Transform Polygon into Raycoords</h2><span id='topic+transform_points_custom_crs'></span>

<h3>Description</h3>

<p>Transform Polygon into Raycoords
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_points_custom_crs(sf_object, orig_extent, new_extent)
</code></pre>

<hr>
<h2 id='transform_points_into_raycoords'>Transform Points into Raycoords</h2><span id='topic+transform_points_into_raycoords'></span>

<h3>Description</h3>

<p>Transform Points into Raycoords
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_points_into_raycoords(
  points,
  heightmap = NULL,
  e = NULL,
  top = NULL,
  bottom = NULL
)
</code></pre>

<hr>
<h2 id='transform_polygon_custom_crs'>Transform Polygon into Raycoords</h2><span id='topic+transform_polygon_custom_crs'></span>

<h3>Description</h3>

<p>Transform Polygon into Raycoords
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_polygon_custom_crs(sf_object, orig_extent, new_extent)
</code></pre>

<hr>
<h2 id='transform_polygon_into_raycoords'>Transform Polygon into Raycoords</h2><span id='topic+transform_polygon_into_raycoords'></span>

<h3>Description</h3>

<p>Transform Polygon into Raycoords
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_polygon_into_raycoords(
  polygon,
  heightmap = NULL,
  e = NULL,
  top = NULL,
  bottom = NULL
)
</code></pre>

<hr>
<h2 id='translate_shape_string'>translate_shape_string</h2><span id='topic+translate_shape_string'></span>

<h3>Description</h3>

<p>Required internal ggplot object for 3D ggplots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_shape_string(shape_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_shape_string_+3A_shape_string">shape_string</code></td>
<td>
<p>A shape string.</p>
</td></tr>
</table>

<hr>
<h2 id='tree_basic_center_obj'>Flag 3D Model</h2><span id='topic+tree_basic_center_obj'></span>

<h3>Description</h3>

<p>3D obj model of a flag pole, to be used with 'render_obj()'. Use 'full_flag_obj()' to get the complete
pole, and 'flag_banner_obj()' and 'flag_pole_obj()' to style them separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_basic_center_obj()
</code></pre>


<h3>Value</h3>

<p>File location of the included flag OBJ file (saved with a .txt extension)
</p>

<hr>
<h2 id='tree_cone_center_obj'>Flag 3D Model</h2><span id='topic+tree_cone_center_obj'></span>

<h3>Description</h3>

<p>3D obj model of a flag pole, to be used with 'render_obj()'. Use 'full_flag_obj()' to get the complete
pole, and 'flag_banner_obj()' and 'flag_pole_obj()' to style them separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_cone_center_obj()
</code></pre>


<h3>Value</h3>

<p>File location of the included flag OBJ file (saved with a .txt extension)
</p>

<hr>
<h2 id='tree_trunk_obj'>Flag 3D Model</h2><span id='topic+tree_trunk_obj'></span>

<h3>Description</h3>

<p>3D obj model of a flag pole, to be used with 'render_obj()'. Use 'full_flag_obj()' to get the complete
pole, and 'flag_banner_obj()' and 'flag_pole_obj()' to style them separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_trunk_obj()
</code></pre>


<h3>Value</h3>

<p>File location of the included flag OBJ file (saved with a .txt extension)
</p>

<hr>
<h2 id='trim_padding'>trim_padding</h2><span id='topic+trim_padding'></span>

<h3>Description</h3>

<p>Trims padding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_padding(heightmap, pad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_padding_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="trim_padding_+3A_pad">pad</code></td>
<td>
<p>Number of padding entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hillshade with edges trimmed
</p>

<hr>
<h2 id='unit_vector'>Unit Vector</h2><span id='topic+unit_vector'></span>

<h3>Description</h3>

<p>Unit Vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_vector(x)
</code></pre>


<h3>Value</h3>

<p>vec
</p>

<hr>
<h2 id='washington_monument_multipolygonz'>Washington Monument 3D Model as Multipolygon Z Data</h2><span id='topic+washington_monument_multipolygonz'></span>

<h3>Description</h3>

<p>This dataset is an 'sf' object containing MULTIPOLYGON Z 3D data of the Washington Monument in Washington, DC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>washington_monument_multipolygonz
</code></pre>


<h3>Format</h3>

<p>An 'sf' object with MULTIPOLYGONZ geometry.
</p>


<h3>Source</h3>

<p>https://opendata.dc.gov/documents/DCGIS::buildings-in-3d/
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the `render_multipolygonz()` documentation for examples of using this data.
</code></pre>

<hr>
<h2 id='write_stl'>Write STL</h2><span id='topic+write_stl'></span>

<h3>Description</h3>

<p>Write STL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_stl(filename, rotate = FALSE, maxwidth = 100, unit = "mm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_stl_+3A_filename">filename</code></td>
<td>
<p>The filename</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
