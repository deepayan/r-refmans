<!DOCTYPE html><html><head><title>Help for package heimdall</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {heimdall}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dfr_adwin'><p>ADWIN method</p></a></li>
<li><a href='#dfr_cusum'><p>Cumulative Sum for Concept Drift Detection (CUMSUM) method</p></a></li>
<li><a href='#dfr_ddm'><p>Adapted Drift Detection Method (DDM) method</p></a></li>
<li><a href='#dfr_ecdd'><p>Adapted EWMA for Concept Drift Detection (ECDD) method</p></a></li>
<li><a href='#dfr_eddm'><p>Adapted Early Drift Detection Method (EDDM) method</p></a></li>
<li><a href='#dfr_hddm'><p>Adapted Hoeffding Drift Detection Method (HDDM) method</p></a></li>
<li><a href='#dfr_inactive'><p>Inactive dummy detector</p></a></li>
<li><a href='#dfr_kldist'><p>KL Distance method</p></a></li>
<li><a href='#dfr_kswin'><p>KSWIN method</p></a></li>
<li><a href='#dfr_mcdd'><p>Mean Comparison Distance method</p></a></li>
<li><a href='#dfr_page_hinkley'><p>Adapted Page Hinkley method</p></a></li>
<li><a href='#dfr_passive'><p>Passive dummy detector</p></a></li>
<li><a href='#dist_based'><p>Distribution Based Drifter sub-class</p></a></li>
<li><a href='#drifter'><p>Drifter</p></a></li>
<li><a href='#error_based'><p>Error Based Drifter sub-class</p></a></li>
<li><a href='#fit.drifter'><p>Process Batch</p></a></li>
<li><a href='#metric'><p>Metric</p></a></li>
<li><a href='#mt_fscore'><p>FScore Calculator</p></a></li>
<li><a href='#mt_precision'><p>Precision Calculator</p></a></li>
<li><a href='#mt_recall'><p>Recall Calculator</p></a></li>
<li><a href='#multi_criteria'><p>Multi Criteria Drifter sub-class</p></a></li>
<li><a href='#reset_state'><p>Reset State</p></a></li>
<li><a href='#st_drift_examples'><p>Synthetic time series for concept drift detection</p></a></li>
<li><a href='#stealthy'><p>Stealthy</p></a></li>
<li><a href='#update_state'><p>Update State</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Drift Adaptable Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.717</td>
</tr>
<tr>
<td>Description:</td>
<td>By analyzing streaming datasets, it is possible to observe significant changes in the data distribution or models' accuracy during their prediction (concept drift). The goal of 'heimdall' is to measure when concept drift occurs. The package makes available several state-of-the-art methods. It also tackles how to adapt models in a nonstationary context. Some concept drifts methods are described in Tavares (2022) &lt;<a href="https://doi.org/10.1007%2Fs12530-021-09415-z">doi:10.1007/s12530-021-09415-z</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cefet-rj-dal/heimdall">https://github.com/cefet-rj-dal/heimdall</a>,
<a href="https://cefet-rj-dal.github.io/heimdall/">https://cefet-rj-dal.github.io/heimdall/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, caret, daltoolbox, ggplot2, reticulate</td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package = "scipy"),
list(package = "torch"), list(package = "pandas"), list(package
= "numpy"), list(package = "matplotlib"), list(package =
"scikit-learn"), list(package = "functools"), list(package =
"operator"), list(package = "sys") ) )</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-27 13:40:17 UTC; gpca</td>
</tr>
<tr>
<td>Author:</td>
<td>Lucas Tavares [aut],
  Leonardo Carvalho [aut],
  Diego Carvalho [aut],
  Esther Pacitti [aut],
  Fabio Porto [aut],
  Eduardo Ogasawara <a href="https://orcid.org/0000-0002-0466-0626"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths, cre],
  Federal Center for Technological Education of Rio de Janeiro (CEFET/RJ)
    [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo Ogasawara &lt;eogasawara@ieee.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-30 09:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='dfr_adwin'>ADWIN method</h2><span id='topic+dfr_adwin'></span>

<h3>Description</h3>

<p>Adaptive Windowing method for concept drift detection <a href="doi:10.1137/1.9781611972771.42">doi:10.1137/1.9781611972771.42</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_adwin(target_feat, delta = 0.002)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_adwin_+3A_target_feat">target_feat</code></td>
<td>
<p>Feature to be monitored.</p>
</td></tr>
<tr><td><code id="dfr_adwin_+3A_delta">delta</code></td>
<td>
<p>The significance parameter for the ADWIN algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_adwin</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Use the same example of dfr_cumsum changing the constructor to:
#model &lt;- dfr_adwin(target_feat='serie')
</code></pre>

<hr>
<h2 id='dfr_cusum'>Cumulative Sum for Concept Drift Detection (CUMSUM) method</h2><span id='topic+dfr_cusum'></span>

<h3>Description</h3>

<p>The cumulative sum (CUSUM) is a sequential analysis technique used for change detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_cusum(lambda = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_cusum_+3A_lambda">lambda</code></td>
<td>
<p>Necessary level for warning zone (2 standard deviation)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_cusum</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example uses an error-based drift detector with a synthetic a 
# model residual where 1 is an error and 0 is a correct prediction.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL
data$prediction &lt;- st_drift_examples$univariate$serie &gt; 4

model &lt;- dfr_cusum()

detection &lt;- NULL
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$prediction)){
 output &lt;- update_state(output$obj, data$prediction[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, data.frame(idx=i, event=output$drift, type=type))
}

detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_ddm'>Adapted Drift Detection Method (DDM) method</h2><span id='topic+dfr_ddm'></span>

<h3>Description</h3>

<p>DDM is a concept change detection method based on the PAC learning model premise, that the learnerâ€™s error rate will decrease as the number of analysed samples increase, as long as the data distribution is stationary. <a href="doi:10.1007/978-3-540-28645-5_29">doi:10.1007/978-3-540-28645-5_29</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_ddm(min_instances = 30, warning_level = 2, out_control_level = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_ddm_+3A_min_instances">min_instances</code></td>
<td>
<p>The minimum number of instances before detecting change</p>
</td></tr>
<tr><td><code id="dfr_ddm_+3A_warning_level">warning_level</code></td>
<td>
<p>Necessary level for warning zone (2 standard deviation)</p>
</td></tr>
<tr><td><code id="dfr_ddm_+3A_out_control_level">out_control_level</code></td>
<td>
<p>Necessary level for a positive drift detection</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_ddm</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example uses an error-based drift detector with a synthetic a 
# model residual where 1 is an error and 0 is a correct prediction.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL
data$prediction &lt;- st_drift_examples$univariate$serie &gt; 4

model &lt;- dfr_ddm()

detection &lt;- NULL
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$prediction)){
 output &lt;- update_state(output$obj, data$prediction[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, data.frame(idx=i, event=output$drift, type=type))
}

detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_ecdd'>Adapted EWMA for Concept Drift Detection (ECDD) method</h2><span id='topic+dfr_ecdd'></span>

<h3>Description</h3>

<p>ECDD is a concept change detection method that uses an exponentially weighted moving average (EWMA) chart to monitor the misclassification rate of an streaming classifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_ecdd(lambda = 0.2, min_run_instances = 30, average_run_length = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_ecdd_+3A_lambda">lambda</code></td>
<td>
<p>The minimum number of instances before detecting change</p>
</td></tr>
<tr><td><code id="dfr_ecdd_+3A_min_run_instances">min_run_instances</code></td>
<td>
<p>Necessary level for warning zone (2 standard deviation)</p>
</td></tr>
<tr><td><code id="dfr_ecdd_+3A_average_run_length">average_run_length</code></td>
<td>
<p>Necessary level for a positive drift detection</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_ecdd</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example uses a dist-based drift detector with a synthetic dataset.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL

model &lt;- dfr_ecdd()

detection &lt;- NULL
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$serie)){
 output &lt;- update_state(output$obj, data$serie[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, data.frame(idx=i, event=output$drift, type=type))
}

detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_eddm'>Adapted Early Drift Detection Method (EDDM) method</h2><span id='topic+dfr_eddm'></span>

<h3>Description</h3>

<p>EDDM (Early Drift Detection Method) aims to improve the detection rate of gradual concept drift in DDM, while keeping a good performance against abrupt concept drift. <a href="doi:2747577a61c70bc3874380130615e15aff76339e">doi:2747577a61c70bc3874380130615e15aff76339e</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_eddm(
  min_instances = 30,
  min_num_errors = 30,
  warning_level = 0.95,
  out_control_level = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_eddm_+3A_min_instances">min_instances</code></td>
<td>
<p>The minimum number of instances before detecting change</p>
</td></tr>
<tr><td><code id="dfr_eddm_+3A_min_num_errors">min_num_errors</code></td>
<td>
<p>The minimum number of errors before detecting change</p>
</td></tr>
<tr><td><code id="dfr_eddm_+3A_warning_level">warning_level</code></td>
<td>
<p>Necessary level for warning zone</p>
</td></tr>
<tr><td><code id="dfr_eddm_+3A_out_control_level">out_control_level</code></td>
<td>
<p>Necessary level for a positive drift detection</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_eddm</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example uses an error-based drift detector with a synthetic a 
# model residual where 1 is an error and 0 is a correct prediction.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL
data$prediction &lt;- st_drift_examples$univariate$serie &gt; 4

model &lt;- dfr_eddm()

detection &lt;- NULL
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$prediction)){
 output &lt;- update_state(output$obj, data$prediction[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, data.frame(idx=i, event=output$drift, type=type))
}

detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_hddm'>Adapted Hoeffding Drift Detection Method (HDDM) method</h2><span id='topic+dfr_hddm'></span>

<h3>Description</h3>

<p>is a drift detection method based on the Hoeffdingâ€™s inequality. HDDM_A uses the average as estimator.  <a href="doi:10.1109/TKDE.2014.2345382">doi:10.1109/TKDE.2014.2345382</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_hddm(
  drift_confidence = 0.001,
  warning_confidence = 0.005,
  two_side_option = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_hddm_+3A_drift_confidence">drift_confidence</code></td>
<td>
<p>Confidence to the drift</p>
</td></tr>
<tr><td><code id="dfr_hddm_+3A_warning_confidence">warning_confidence</code></td>
<td>
<p>Confidence to the warning</p>
</td></tr>
<tr><td><code id="dfr_hddm_+3A_two_side_option">two_side_option</code></td>
<td>
<p>Option to monitor error increments and decrements (two-sided) or only increments (one-sided)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_hddm</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example uses an error-based drift detector with a synthetic a 
# model residual where 1 is an error and 0 is a correct prediction.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL
data$prediction &lt;- st_drift_examples$univariate$serie &gt; 4

model &lt;- dfr_hddm()

detection &lt;- NULL
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$prediction)){
 output &lt;- update_state(output$obj, data$prediction[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, data.frame(idx=i, event=output$drift, type=type))
}

detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_inactive'>Inactive dummy detector</h2><span id='topic+dfr_inactive'></span>

<h3>Description</h3>

<p>Implements Inactive Dummy Detector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_inactive()
</code></pre>


<h3>Value</h3>

<p>Drifter object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?hcd_ddm for an example of DDM drift detector
</code></pre>

<hr>
<h2 id='dfr_kldist'>KL Distance method</h2><span id='topic+dfr_kldist'></span>

<h3>Description</h3>

<p>Kullback Leibler Windowing method for concept drift detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_kldist(target_feat, window_size = 100, p_th = 0.9, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_kldist_+3A_target_feat">target_feat</code></td>
<td>
<p>Feature to be monitored.</p>
</td></tr>
<tr><td><code id="dfr_kldist_+3A_window_size">window_size</code></td>
<td>
<p>Size of the sliding window (must be &gt; 2*stat_size)</p>
</td></tr>
<tr><td><code id="dfr_kldist_+3A_p_th">p_th</code></td>
<td>
<p>Probability theshold for the test statistic of the Kullback Leibler distance.</p>
</td></tr>
<tr><td><code id="dfr_kldist_+3A_data">data</code></td>
<td>
<p>Already collected data to avoid cold start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_kldist</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example uses a dist-based drift detector with a synthetic dataset.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL

model &lt;- dfr_kldist(target_feat='serie')

detection &lt;- NULL
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$serie)){
 output &lt;- update_state(output$obj, data$serie[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, data.frame(idx=i, event=output$drift, type=type))
}

detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_kswin'>KSWIN method</h2><span id='topic+dfr_kswin'></span>

<h3>Description</h3>

<p>Kolmogorov-Smirnov Windowing method for concept drift detection <a href="doi:10.1016/j.neucom.2019.11.111">doi:10.1016/j.neucom.2019.11.111</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_kswin(
  target_feat,
  window_size = 100,
  stat_size = 30,
  alpha = 0.005,
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_kswin_+3A_target_feat">target_feat</code></td>
<td>
<p>Feature to be monitored.</p>
</td></tr>
<tr><td><code id="dfr_kswin_+3A_window_size">window_size</code></td>
<td>
<p>Size of the sliding window (must be &gt; 2*stat_size)</p>
</td></tr>
<tr><td><code id="dfr_kswin_+3A_stat_size">stat_size</code></td>
<td>
<p>Size of the statistic window</p>
</td></tr>
<tr><td><code id="dfr_kswin_+3A_alpha">alpha</code></td>
<td>
<p>Probability for the test statistic of the Kolmogorov-Smirnov-Test The alpha parameter is very sensitive, therefore should be set below 0.01.</p>
</td></tr>
<tr><td><code id="dfr_kswin_+3A_data">data</code></td>
<td>
<p>Already collected data to avoid cold start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_kswin</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example uses a dist-based drift detector with a synthetic dataset.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL

model &lt;- dfr_kswin(target_feat='serie')

detection &lt;- NULL
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$serie)){
 output &lt;- update_state(output$obj, data$serie[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, data.frame(idx=i, event=output$drift, type=type))
}

detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_mcdd'>Mean Comparison Distance method</h2><span id='topic+dfr_mcdd'></span>

<h3>Description</h3>

<p>Mean Comparison statistical method for concept drift detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_mcdd(target_feat, alpha = 0.05, window_size = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_mcdd_+3A_target_feat">target_feat</code></td>
<td>
<p>Feature to be monitored</p>
</td></tr>
<tr><td><code id="dfr_mcdd_+3A_alpha">alpha</code></td>
<td>
<p>Probability theshold for all test statistics</p>
</td></tr>
<tr><td><code id="dfr_mcdd_+3A_window_size">window_size</code></td>
<td>
<p>Size of the sliding window</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_mcdd</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example uses a dist-based drift detector with a synthetic dataset.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL

model &lt;- dfr_mcdd(target_feat='depart_visibility')

detection &lt;- NULL
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$serie)){
 output &lt;- update_state(output$obj, data$serie[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, data.frame(idx=i, event=output$drift, type=type))
}

detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_page_hinkley'>Adapted Page Hinkley method</h2><span id='topic+dfr_page_hinkley'></span>

<h3>Description</h3>

<p>Change-point detection method works by computing the observed values and their mean up to the current moment <a href="doi:10.2307/2333009">doi:10.2307/2333009</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_page_hinkley(
  target_feat,
  min_instances = 30,
  delta = 0.005,
  threshold = 50,
  alpha = 1 - 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfr_page_hinkley_+3A_target_feat">target_feat</code></td>
<td>
<p>Feature to be monitored.</p>
</td></tr>
<tr><td><code id="dfr_page_hinkley_+3A_min_instances">min_instances</code></td>
<td>
<p>The minimum number of instances before detecting change</p>
</td></tr>
<tr><td><code id="dfr_page_hinkley_+3A_delta">delta</code></td>
<td>
<p>The delta factor for the Page Hinkley test</p>
</td></tr>
<tr><td><code id="dfr_page_hinkley_+3A_threshold">threshold</code></td>
<td>
<p>The change detection threshold (lambda)</p>
</td></tr>
<tr><td><code id="dfr_page_hinkley_+3A_alpha">alpha</code></td>
<td>
<p>The forgetting factor, used to weight the observed value and the mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfr_page_hinkley</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
library(heimdall)

# This example assumes a model residual where 1 is an error and 0 is a correct prediction.

data(st_drift_examples)
data &lt;- st_drift_examples$univariate
data$event &lt;- NULL
data$prediction &lt;- st_drift_examples$univariate$serie &gt; 4


model &lt;- dfr_page_hinkley(target_feat='serie')

detection &lt;- c()
output &lt;- list(obj=model, drift=FALSE)
for (i in 1:length(data$serie)){
 output &lt;- update_state(output$obj, data$serie[i])
 if (output$drift){
   type &lt;- 'drift'
   output$obj &lt;- reset_state(output$obj)
 }else{
   type &lt;- ''
 }
 detection &lt;- rbind(detection, list(idx=i, event=output$drift, type=type))
}

detection &lt;- as.data.frame(detection)
detection[detection$type == 'drift',]
</code></pre>

<hr>
<h2 id='dfr_passive'>Passive dummy detector</h2><span id='topic+dfr_passive'></span>

<h3>Description</h3>

<p>Implements Passive Dummy Detector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfr_passive()
</code></pre>


<h3>Value</h3>

<p>Drifter object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?hcd_ddm for an example of DDM drift detector
</code></pre>

<hr>
<h2 id='dist_based'>Distribution Based Drifter sub-class</h2><span id='topic+dist_based'></span>

<h3>Description</h3>

<p>Implements Distribution Based drift detectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_based(target_feat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_based_+3A_target_feat">target_feat</code></td>
<td>
<p>Feature to be monitored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Drifter object
</p>

<hr>
<h2 id='drifter'>Drifter</h2><span id='topic+drifter'></span>

<h3>Description</h3>

<p>Ancestor class for drift detection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drifter()
</code></pre>


<h3>Value</h3>

<p>Drifter object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?dd_ddm for an example of DDM drift detector
</code></pre>

<hr>
<h2 id='error_based'>Error Based Drifter sub-class</h2><span id='topic+error_based'></span>

<h3>Description</h3>

<p>Implements Error Based drift detectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_based()
</code></pre>


<h3>Value</h3>

<p>Drifter object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?hcd_ddm for an example of DDM drift detector
</code></pre>

<hr>
<h2 id='fit.drifter'>Process Batch</h2><span id='topic+fit.drifter'></span>

<h3>Description</h3>

<p>Process Batch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drifter'
fit(obj, data, prediction, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.drifter_+3A_obj">obj</code></td>
<td>
<p>Drifter object</p>
</td></tr>
<tr><td><code id="fit.drifter_+3A_data">data</code></td>
<td>
<p>data batch in data frame format</p>
</td></tr>
<tr><td><code id="fit.drifter_+3A_prediction">prediction</code></td>
<td>
<p>prediction batch as vector format</p>
</td></tr>
<tr><td><code id="fit.drifter_+3A_...">...</code></td>
<td>
<p>opitional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated Drifter object
</p>

<hr>
<h2 id='metric'>Metric</h2><span id='topic+metric'></span>

<h3>Description</h3>

<p>Ancestor class for metric calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric()
</code></pre>


<h3>Value</h3>

<p>Metric object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?metric for an example of DDM drift detector
</code></pre>

<hr>
<h2 id='mt_fscore'>FScore Calculator</h2><span id='topic+mt_fscore'></span>

<h3>Description</h3>

<p>Class for FScore calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_fscore(f = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_fscore_+3A_f">f</code></td>
<td>
<p>The F parameter for the F-Score metric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Metric object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?mt_precision for an example of FScore Calculator
</code></pre>

<hr>
<h2 id='mt_precision'>Precision Calculator</h2><span id='topic+mt_precision'></span>

<h3>Description</h3>

<p>Class for precision calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_precision()
</code></pre>


<h3>Value</h3>

<p>Metric object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?mt_precision for an example of Precision Calculator
</code></pre>

<hr>
<h2 id='mt_recall'>Recall Calculator</h2><span id='topic+mt_recall'></span>

<h3>Description</h3>

<p>Class for recall calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_recall()
</code></pre>


<h3>Value</h3>

<p>Metric object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?mt_recall for an example of Recall Calculator
</code></pre>

<hr>
<h2 id='multi_criteria'>Multi Criteria Drifter sub-class</h2><span id='topic+multi_criteria'></span>

<h3>Description</h3>

<p>Implements Multi Criteria drift detectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_criteria()
</code></pre>


<h3>Value</h3>

<p>Drifter object
</p>

<hr>
<h2 id='reset_state'>Reset State</h2><span id='topic+reset_state'></span>

<h3>Description</h3>

<p>Reset Drifter State
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_state(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_state_+3A_obj">obj</code></td>
<td>
<p>Drifter object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated Drifter object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?hcd_ddm for an example of DDM drift detector
</code></pre>

<hr>
<h2 id='st_drift_examples'>Synthetic time series for concept drift detection</h2><span id='topic+st_drift_examples'></span>

<h3>Description</h3>

<p>A list of multivariate time series for drift detection
</p>

<ul>
<li><p> example1: a bivariate dataset with one multivariate concept drift example
</p>
</li></ul>

<p>#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(st_drift_examples)
</code></pre>


<h3>Format</h3>

<p>A list of time series.
</p>


<h3>Source</h3>

<p><a href="https://github.com/cefet-rj-dal/heimdall">Stealthy package</a>
</p>


<h3>References</h3>

<p><a href="https://github.com/cefet-rj-dal/heimdall">Stealthy package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(st_drift_examples)
dataset &lt;- st_drift_examples$example1
</code></pre>

<hr>
<h2 id='stealthy'>Stealthy</h2><span id='topic+stealthy'></span>

<h3>Description</h3>

<p>Ancestor class for drift adaptive models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stealthy(model, drift_method, th = 0.5, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stealthy_+3A_model">model</code></td>
<td>
<p>The algorithm object to be used for predictions</p>
</td></tr>
<tr><td><code id="stealthy_+3A_drift_method">drift_method</code></td>
<td>
<p>The algorithm object to detect drifts</p>
</td></tr>
<tr><td><code id="stealthy_+3A_th">th</code></td>
<td>
<p>The threshold to be used with classification algorithms</p>
</td></tr>
<tr><td><code id="stealthy_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE shows drift messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stealthy object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?dd_ddm for an example of DDM drift detector
</code></pre>

<hr>
<h2 id='update_state'>Update State</h2><span id='topic+update_state'></span>

<h3>Description</h3>

<p>Update Drifter State
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_state(obj, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_state_+3A_obj">obj</code></td>
<td>
<p>Drifter object</p>
</td></tr>
<tr><td><code id="update_state_+3A_value">value</code></td>
<td>
<p>a value that represents a processed batch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated Drifter object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?hcd_ddm for an example of DDM drift detector
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
