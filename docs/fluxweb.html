<!DOCTYPE html><html lang="en"><head><title>Help for package fluxweb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fluxweb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fluxweb-package'><p>The fluxweb package</p></a></li>
<li><a href='#create.jacob'><p>Internal function to compute Jacobian</p></a></li>
<li><a href='#fluxing'><p>generate fluxes</p></a></li>
<li><a href='#groups.level'><p>Aggregated version of the Food web of a soil network ecosystem and species general information (<code>species.level</code>).</p></a></li>
<li><a href='#make.stability'><p>making network stability</p></a></li>
<li><a href='#sensitivity'><p>sensitivity analysis</p></a></li>
<li><a href='#simple.case'><p>Food web of a soil network ecosystem and species general information.</p></a></li>
<li><a href='#species.level'><p>Food web of a soil network ecosystem and species general information.</p></a></li>
<li><a href='#stability.value'><p>Estimates network stability</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Energy Fluxes in Food Webs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Benoit Gauzens </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benoit Gauzens &lt;benoit.gauzens@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute energy fluxes in trophic networks, from resources to their consumers, and can be applied to systems ranging from simple two-species interactions to highly complex food webs. It implements the approach described in Gauzens et al. (2017) &lt;<a href="https://doi.org/10.1101%2F229450">doi:10.1101/229450</a>&gt; to calculate energy fluxes, which are also used to calculate equilibrium stability.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.biorxiv.org/content/early/2017/12/06/229450">https://www.biorxiv.org/content/early/2017/12/06/229450</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-09-26 11:20:24 UTC; bg33novu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-09-27 12:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='fluxweb-package'>The fluxweb package</h2><span id='topic+fluxweb-package'></span>

<h3>Description</h3>

<p>the new fancy package fluxweb that fluxes webs
</p>


<h3>Author(s)</h3>

<p>Benoit Gauzens
</p>

<hr>
<h2 id='create.jacob'>Internal function to compute Jacobian</h2><span id='topic+create.jacob'></span>

<h3>Description</h3>

<p>Internal function to compute Jacobian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.jacob(val.mat, biomasses, losses, efficiencies, growth.rate,
  bioms.prefs = TRUE, bioms.losses = TRUE, ef.level = "prey")
</code></pre>

<hr>
<h2 id='fluxing'>generate fluxes</h2><span id='topic+fluxing'></span>

<h3>Description</h3>

<p>Creates a valuated graph adjacency matrix from its binary version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluxing(mat, biomasses = NULL, losses, efficiencies, bioms.prefs = TRUE,
  bioms.losses = TRUE, ef.level = "prey")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fluxing_+3A_mat">mat</code></td>
<td>
<p>Network adjacency matrix describing interactions among species. Interactions can be either binary or weighted.</p>
</td></tr>
<tr><td><code id="fluxing_+3A_biomasses">biomasses</code></td>
<td>
<p>Vector of species biomasses.</p>
</td></tr>
<tr><td><code id="fluxing_+3A_losses">losses</code></td>
<td>
<p>A vector or an array of species energy losses (excluding consumption).</p>
</td></tr>
<tr><td><code id="fluxing_+3A_efficiencies">efficiencies</code></td>
<td>
<p>A vector or an array of conversion efficiencies of species in the adjacency matrix. These values describe the proportion of consumed energy that is converted to biomass of the consumer.</p>
</td></tr>
<tr><td><code id="fluxing_+3A_bioms.prefs">bioms.prefs</code></td>
<td>
<p>Logical - if <code>TRUE</code>, consumer preferences are scaled according to species biomasses.</p>
</td></tr>
<tr><td><code id="fluxing_+3A_bioms.losses">bioms.losses</code></td>
<td>
<p>Logical - if <code>TRUE</code>, losses are scaled with species biomasses.</p>
</td></tr>
<tr><td><code id="fluxing_+3A_ef.level">ef.level</code></td>
<td>
<p>Set to <code>"prey"</code> if efficiencies are defined by prey, <code>"pred"</code> if they are a property of the predator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes fluxes in food webs based on an equilibrium hypothesis: for each species, sum of ingoing fluxes (gains from predation) balances the sum of outgoing fluxes.
Outgoing fluxes are defined by consumption and the <code>losses</code> argument. Usually <code>losses</code> relate to species metabolic rates and/or natural death rates. For each species <code>i</code>, sum of ingoing fluxes <code>F_i</code> is computed as:
</p>
<p style="text-align: center;"><code class="reqn">
F_{i} = \frac{1}{e_i} (L_i + \sum_j W_{ij}F_j) \quad if \quad \code{ef.level == "pred"}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
F_{i} = \frac{L_i + \sum_j W_{ij}F_j}{\sum_j W_{ji}e_j} \quad if \quad \code{ef.level == "pred"}
</code>
</p>

<p><code>W</code> set the matrix of preferences estimated from <code>mat</code>, according to <code>bioms.prefs</code>. <code>L</code> is the vector depicting sum of losses
(scaled or not by biomasses, accordingly to <code>bioms.losses</code>) and <code>e</code> is the vector of species efficiencies.
</p>

<ul>
<li><p><code>mat</code>: Either a binary or a valuated matrix can be used. A non zero value for mat[i,j] means that species i is consumed by species j.
Matrix entries would assess predator preferences on its prey, thus providing a binary matrix assumes no preferences.
</p>
</li>
<li><p><code>losses</code>: Express species energetic losses not related to consumption. Usually metabolic or death rates.
When an array is provided, losses associated to each species correspond to line sums.
</p>
</li>
<li><p><code>efficiencies</code>: Determines how efficient species are to convert energy (see <code>ef.level</code> for more details).
Providing an array will assume values depending on both prey and predator identity.
</p>
</li>
<li><p><code>bioms.pref</code>: If <code>TRUE</code>, preferences <code class="reqn">W_{ij}</code> of predator j on prey i are scaled accordingly to species biomass using the following formula:
</p>
<p style="text-align: center;"><code class="reqn">
W_{i,j} = \frac{mat[i,j] * biomasses[i]}{\sum_k mat[i,k]* biomasses[k]}
</code>
</p>

<p>If <code>FALSE</code>, a normalisation on column values is performed.
</p>
</li>
<li><p><code>bioms.losses</code>: Set to true, function will assume that losses are defined per biomass unit.
Thus, total losses will be thereafter multiplied by biomass values for each species.
</p>
</li>
<li><p><code>ef.level</code>: If <code>"prey"</code> (resp <code>"pred"</code>), the total amount of energy that can be metabolized from a trophic link
will be determined by prey (resp predator) identity. <code>"link.specific"</code> assumes that efficiencies are defined for each trophic interaction
and implies <code>efficiencies</code> parameter to be a matrix.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an adjacency matrix where entries are the computed energy fluxes between consumer species and their respective resources.
</p>


<h3>Author(s)</h3>

<p>Benoit gauzens, <a href="mailto:benoit.gauzens@gmail.com">benoit.gauzens@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first compute species per unit biomass metabolic rates using the metabolic theory:
losses = 0.1 * species.level$bodymasses^(-0.25)

# call of the function:
fluxing(species.level$mat, 
       species.level$biomasses, 
       losses, 
       species.level$efficiencies, 
       bioms.pref = TRUE, 
       ef.level = "prey")

</code></pre>

<hr>
<h2 id='groups.level'>Aggregated version of the Food web of a soil network ecosystem and species general information (<code>species.level</code>).</h2><span id='topic+groups.level'></span>

<h3>Description</h3>

<p>This dataset contains the matrix describing trophic interactions between trophic groups of a soil food-web (Digel et al. 2014, Oikos)
as well as some ecological information on these groups: biomasses, body masses and and species composition.
</p>


<h3>Format</h3>

<p>a list of 5 elements:
</p>

<dl>
<dt>mat</dt><dd><p>the network adjacency matrix</p>
</dd>
<dt>biomasses</dt><dd><p>groups total biomasses (g)</p>
</dd>
<dt>bodymasses</dt><dd><p>group mean bodymasses of species (g)</p>
</dd>
<dt>efficiencies</dt><dd><p>group species mean assimilation efficiencies</p>
</dd>
<dt>species.tgs</dt><dd><p>groups' species composition</p>
</dd>
</dl>

<hr>
<h2 id='make.stability'>making network stability</h2><span id='topic+make.stability'></span>

<h3>Description</h3>

<p>Find the smallest scalar multiplying a variable from losses insuring system stability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.stability(val.mat, biomasses, losses, efficiencies, growth.rate,
  losses.scale = NULL, bioms.prefs = TRUE, bioms.losses = TRUE,
  ef.level = "prey", interval = c(1e-12, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.stability_+3A_val.mat">val.mat</code></td>
<td>
<p>A matrix describing fluxes between species (usually a result of <code><a href="#topic+fluxing">fluxing</a></code> function).</p>
</td></tr>
<tr><td><code id="make.stability_+3A_biomasses">biomasses</code></td>
<td>
<p>A vector of species biomasses.</p>
</td></tr>
<tr><td><code id="make.stability_+3A_losses">losses</code></td>
<td>
<p>A vector or an array of species energy losses (excluding predation).</p>
</td></tr>
<tr><td><code id="make.stability_+3A_efficiencies">efficiencies</code></td>
<td>
<p>A vector or an array of conversion efficiencies of species in the adjacency matrix. These values describe the proportion of consumed energy that is converted to biomass of the consumer.</p>
</td></tr>
<tr><td><code id="make.stability_+3A_growth.rate">growth.rate</code></td>
<td>
<p>A vector defining growth rate of basal species.</p>
</td></tr>
<tr><td><code id="make.stability_+3A_losses.scale">losses.scale</code></td>
<td>
<p>Defines a Column from <code>losses</code> on which scalar multiplication will be tested. (default <code>NULL</code> if the value is independent of losses).</p>
</td></tr>
<tr><td><code id="make.stability_+3A_bioms.prefs">bioms.prefs</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) preferences are scaled accordingly to species biomasses.</p>
</td></tr>
<tr><td><code id="make.stability_+3A_bioms.losses">bioms.losses</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) losses are scaled with biomass.</p>
</td></tr>
<tr><td><code id="make.stability_+3A_ef.level">ef.level</code></td>
<td>
<p>Set to <code>"prey"</code> if efficiencies are defined by prey, <code>"pred"</code> if they are a property of the predator.</p>
</td></tr>
<tr><td><code id="make.stability_+3A_interval">interval</code></td>
<td>
<p>Search interval for returned value.</p>
</td></tr>
<tr><td><code id="make.stability_+3A_...">...</code></td>
<td>
<p>Optional parameters for function <code><a href="stats.html#topic+uniroot">uniroot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes a monotonous increase of stability with multiplication by a scalar value. Solution is estimated from the <code><a href="stats.html#topic+uniroot">uniroot</a></code> function, and stability using the <code><a href="#topic+fluxing">fluxing</a></code> function
Thus, accordingly to <code><a href="stats.html#topic+uniroot">uniroot</a></code> solving criteria, if stability values at the two extremum parts of the interval are of same sign, an error is raised.
</p>
<p>Behavior of the multiplicative term depends on the type of losses:
</p>

<ul>
<li><p><code>losses.scale = NULL</code> and <code>is.vector(losses)</code>: multiplication will be applied to the <code>losses</code> vector.
</p>
</li>
<li><p><code>losses.scale = NULL</code> and <code>is.matrix(losses)</code>: multiplication will be independent of any columns from <code>losses</code>.
</p>
</li>
<li><p><code>losses.scale = FALSE</code> : value used for multiplication always independent of losses.
</p>
</li>
<li><p>other values: should refer to an element of losses.
</p>
</li></ul>



<h3>Value</h3>

<p>A list from <code><a href="stats.html#topic+uniroot">uniroot</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for root estimate and <code><a href="#topic+stability.value">stability.value</a></code> for assessing system stability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
losses = 0.15 * groups.level$bodymasses^(-0.25)

# growth rates of basal sppecies
growth.rates = rep(NA, dim(groups.level$mat)[1])
growth.rates[colSums(groups.level$mat) == 0] = 0.5

val.mat = fluxing(groups.level$mat, 
                  groups.level$biomasses, 
                  losses, 
                  groups.level$efficiencies, 
                  bioms.pref = TRUE, 
                  ef.level = "pred")
make.stability(val.mat, 
               groups.level$biomasses, 
               losses, 
               groups.level$efficiencies, 
               growth.rates, 
               ef.level = "pred")

</code></pre>

<hr>
<h2 id='sensitivity'>sensitivity analysis</h2><span id='topic+sensitivity'></span>

<h3>Description</h3>

<p>Assesses how sensitive the results from argument function are to variability of input parameter through coefficient of variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity(fun.name, param.name, var, n, full.output = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sensitivity_+3A_fun.name">fun.name</code></td>
<td>
<p>Function to analyse.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_param.name">param.name</code></td>
<td>
<p>Parameter from <code>...</code> on which variation is applied.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_var">var</code></td>
<td>
<p>Define the interval of uncertainty for the uniform law around <code>x</code> as <code>[x - x*var, x + x*var]</code>.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_n">n</code></td>
<td>
<p>Number of replicates.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_full.output">full.output</code></td>
<td>
<p>Logical, if <code>TRUE</code> all of <code>n</code> estimations of <code>fun.name</code> are returned. Only their mean otherwise.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>fun.name</code>. Argument names must exactly match those of fun.name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each replicate, a coefficient of variation is computed (relative to results obtained form <code>fun.name</code> without random variation).
if <code>full.output</code> is <code>FALSE</code> (default) a list of two objects of the same type as the one produced by <code>fun.name</code> is returned, 
first element contains the mean coefficient of variation in comparison to non randomised inputs among all the replicates, 
second element contains the standard deviation of these coefficients of variation
If <code>full.output</code> is <code>TRUE</code>, a list of size <code>n</code> with of objects containing the coefficients of variation  is returned.
</p>
<p>Argument for <code>...</code> should be passed with their names.
</p>


<h3>Value</h3>

<p>a list of two elements of the same type as <code>param.name</code>: 
first element contains the mean coefficient of variation in comparison to non randomised inputs among all the replicates, 
second element contains the standard deviation of these coefficient of variation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# first compute species per unit biomass metabolic rates using the metabolic theory:
losses = 0.1 * species.level$bodymasses^(-0.25)


res = sensitivity(fluxing, "mat", 0.1, 5, full.output = TRUE, 
                 mat = species.level$mat, 
                 biomasses = species.level$biomasses, 
                 losses = losses, 
                 efficiencies = species.level$efficiencies)
res = sensitivity(fluxing, "efficiencies", 0.01, 50, 
                 mat = species.level$mat, 
                 biomasses = species.level$biomasses, 
                 losses = losses, 
                 efficiencies = species.level$efficiencies)

# growth rates of basal species
growth.rates = rep(NA, dim(species.level$mat)[1])
growth.rates[colSums(species.level$mat) == 0] = 0.5

val.mat = fluxing(species.level$mat, species.level$biomasses, losses, species.level$efficiencies)



</code></pre>

<hr>
<h2 id='simple.case'>Food web of a soil network ecosystem and species general information.</h2><span id='topic+simple.case'></span>

<h3>Description</h3>

<p>This dataset correspond to the food web of a microcosm assembled from the Chesapeake Bay estuary (Lefcheck and Duffy 2010, Ecology)
</p>


<h3>Format</h3>

<p>a list of 4 elements:
</p>

<dl>
<dt>mat</dt><dd><p>the network adjacency matrix</p>
</dd>
<dt>met.rate</dt><dd><p>metabolic rates of species (J.h-1)</p>
</dd>
<dt>biomasses</dt><dd><p>species biomasses (g)</p>
</dd>
<dt>efficiencies</dt><dd><p>species assimilation efficiencies</p>
</dd>
<dt>names</dt><dd><p>species names</p>
</dd>
</dl>

<hr>
<h2 id='species.level'>Food web of a soil network ecosystem and species general information.</h2><span id='topic+species.level'></span>

<h3>Description</h3>

<p>This dataset contains the matrix describing trophic interactions from a deutsch soil food-web (Digel et al. 2014, Oikos)
as well as some ecological information on species: biomasses, body masses and and species names.
</p>


<h3>Format</h3>

<p>a list of 5 elements:
</p>

<dl>
<dt>mat</dt><dd><p>the network adjacency matrix</p>
</dd>
<dt>biomasses</dt><dd><p>species biomasses (g)</p>
</dd>
<dt>bodymasses</dt><dd><p>species bodymasses (g)</p>
</dd>
<dt>efficiencies</dt><dd><p>species assimilation efficiencies</p>
</dd>
<dt>names</dt><dd><p>species names</p>
</dd>
</dl>

<hr>
<h2 id='stability.value'>Estimates network stability</h2><span id='topic+stability.value'></span>

<h3>Description</h3>

<p>Computes resilience of the system through Jacobian matrix eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stability.value(val.mat, biomasses, losses, efficiencies, growth.rate,
  bioms.prefs = TRUE, bioms.losses = TRUE, ef.level = "prey",
  full.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stability.value_+3A_val.mat">val.mat</code></td>
<td>
<p>A matrix describing fluxes between species (usually a result of <code><a href="#topic+fluxing">fluxing</a></code> function).</p>
</td></tr>
<tr><td><code id="stability.value_+3A_biomasses">biomasses</code></td>
<td>
<p>A vector of species biomasses.</p>
</td></tr>
<tr><td><code id="stability.value_+3A_losses">losses</code></td>
<td>
<p>A vector or an array of species energy losses (excluding predation).</p>
</td></tr>
<tr><td><code id="stability.value_+3A_efficiencies">efficiencies</code></td>
<td>
<p>A vector or an array of conversion efficiencies of species in the adjacency matrix. These values describe the proportion of consumed energy that is converted to biomass of the consumer.</p>
</td></tr>
<tr><td><code id="stability.value_+3A_growth.rate">growth.rate</code></td>
<td>
<p>A vector defining growth rate of basal species.</p>
</td></tr>
<tr><td><code id="stability.value_+3A_bioms.prefs">bioms.prefs</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) preferences are scaled according to species biomasses.</p>
</td></tr>
<tr><td><code id="stability.value_+3A_bioms.losses">bioms.losses</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) losses are scaled with biomass.</p>
</td></tr>
<tr><td><code id="stability.value_+3A_ef.level">ef.level</code></td>
<td>
<p>Set to <code>"prey"</code> if efficiencies are defined by prey, <code>"pred"</code> if they are a property of the predator.</p>
</td></tr>
<tr><td><code id="stability.value_+3A_full.output">full.output</code></td>
<td>
<p>Logical, if <code>TRUE</code> function return supplementary informations.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>losses</code>: Express species energetic losses not related to consumption. Usually metabolic or death rates.
When an array is provided, losses associated to each species correspond to line sums.
</p>
</li>
<li><p><code>efficiencies</code>: Determines how efficient species are to convert energy (see <code>ef.level</code> for more details).
Providing an array will assume values depending on both prey and predator identity.
</p>
</li>
<li><p><code>growth.rate</code>: Growth rates of basal species defined. Length of the vector should be equal to the number of species. 
expects positive numeric values for index corresponding to basal species, NA otherwise
</p>
</li>
<li><p><code>bioms.pref</code>: If <code>TRUE</code>, preferences <code class="reqn">w_{ij}</code> of predator j on prey i are scaled according to species biomass using the following formula:
</p>
<p style="text-align: center;"><code class="reqn">
w_{i,j} = \frac{mat[i,j] * biomasses[i]}{\sum_k mat[i,k]* biomasses[k]}
</code>
</p>

</li>
<li><p><code>bioms.losses</code>: If <code>TRUE</code>, function will assume that losses are defined per biomass unit.
Thus, total losses will be thereafter multiplied by biomass values for each species.
</p>
</li>
<li><p><code>ef.level</code>: If <code>"prey"</code> (resp <code>"pred"</code>), the total amount of energy that can be metabolized from a trophic link
will be determined by prey (resp pred) identity. <code>"link.specific"</code> assumes that efficiencies are defined for each trophic interaction
and implies <code>efficiencies</code> parameter to be a matrix
</p>
</li>
<li><p><code>full.output</code>: If <code>TRUE</code>, function result is a list of eigenvalues and eigenvectors of the Jacobian matrix.
</p>
</li></ul>



<h3>Value</h3>

<p>Maximum eigenvalue of the Jacobian matrix of a Lotka Voltera like system of equations. If full.output, Jacobian eigenvalues and eigenvectors are returned.
</p>


<h3>Author(s)</h3>

<p>Benoit Gauzens, <a href="mailto:benoit.gauzens@gmail.com">benoit.gauzens@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>losses = 0.15 * groups.level$bodymasses^(-0.25)

# growth rates of basal sppecies
growth.rates = rep(NA, dim(groups.level$mat)[1])
growth.rates[colSums(groups.level$mat) == 0] = 0.5

val.mat = fluxing(groups.level$mat, 
                  groups.level$biomasses, 
                  losses, 
                  groups.level$efficiencies, 
                  bioms.pref = TRUE, 
                  ef.level = "pred")
                  
stability.value(val.mat, 
                groups.level$biomasses, 
                losses, 
                groups.level$efficiencies, 
                growth.rates, 
                ef.level = "pred")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
