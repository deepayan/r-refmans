<!DOCTYPE html><html><head><title>Help for package aws</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aws}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auxiliary'>
<p>Auxiliary functions (for internal use)</p></a></li>
<li><a href='#aws'><p>AWS for local constant models on a grid</p></a></li>
<li><a href='#aws-class'><p>Class <code>"aws"</code></p></a></li>
<li><a href='#aws-package'>
<p>Adaptive Weights Smoothing</p></a></li>
<li><a href='#aws.gaussian'><p> Adaptive weights smoothing for Gaussian data with variance depending on the mean.</p></a></li>
<li><a href='#aws.irreg'><p> local constant AWS for irregular (1D/2D) design</p></a></li>
<li><a href='#aws.segment'><p> Segmentation by adaptive weights for Gaussian models.</p></a></li>
<li><a href='#awsdata'><p>Extract information from an object of class aws</p></a></li>
<li><a href='#awsLocalSigma'>
<p>3D variance estimation</p></a></li>
<li><a href='#awssegment-class'><p>Class <code>"awssegment"</code></p></a></li>
<li><a href='#awstestprop'>
<p>Propagation condition for adaptive weights smoothing</p></a></li>
<li><a href='#awsweights'><p>Generate weight scheme that would be used in an additional aws step</p></a></li>
<li><a href='#binning'><p> Binning in 1D, 2D or 3D</p></a></li>
<li><a href='#extract-methods'><p> Methods for Function <code>extract</code> in Package <span class="pkg">aws</span></p></a></li>
<li><a href='#ICIcombined'>
<p>Adaptive smoothing by Intersection of Confidence Intervals (ICI) using multiple windows</p></a></li>
<li><a href='#ICIsmooth'>
<p>Adaptive smoothing by Intersection of Confidence Intervals (ICI)</p></a></li>
<li><a href='#ICIsmooth-class'><p>Class <code>"ICIsmooth"</code></p></a></li>
<li><a href='#kernsm'>
<p>Kernel smoothing on a 1D, 2D or 3D grid</p></a></li>
<li><a href='#kernsm-class'><p>Class <code>"kernsm"</code></p></a></li>
<li><a href='#lpaws'><p>Local polynomial smoothing by AWS</p></a></li>
<li><a href='#nlmeans'>
<p>NLMeans filter in 1D/2D/3D</p></a></li>
<li><a href='#paws'>
<p>Adaptive weigths smoothing using patches</p></a></li>
<li><a href='#plot-methods'><p>Methods for Function &lsquo;plot&rsquo; from package 'graphics' in Package &lsquo;aws&rsquo;</p></a></li>
<li><a href='#print-methods'><p>Methods for Function &lsquo;print&rsquo; from package 'base' in Package &lsquo;aws&rsquo;</p></a></li>
<li><a href='#qmeasures'>
<p>Quality assessment for image reconstructions.</p></a></li>
<li><a href='#risk-methods'><p>Compute risks characterizing the quality of smoothing results</p></a></li>
<li><a href='#show-methods'><p>Methods for Function &lsquo;show&rsquo; in Package &lsquo;aws&rsquo;</p></a></li>
<li><a href='#smooth3D'>
<p>Auxiliary 3D smoothing routines</p></a></li>
<li><a href='#smse3ms'>
<p>Adaptive smoothing in orientation space SE(3)</p></a></li>
<li><a href='#summary-methods'><p>Methods for Function &lsquo;summary&rsquo; from package 'base' in Package &lsquo;aws&rsquo;</p></a></li>
<li><a href='#TV_denoising'>
<p>TV/TGV denoising of image data</p></a></li>
<li><a href='#vaws'>
<p>vector valued version of function <code>aws</code></p>
The function implements the propagation separation approach to
nonparametric smoothing (formerly introduced as Adaptive weights smoothing)
for varying coefficient likelihood models with vector valued response on a 1D, 2D or 3D grid.</a></li>
<li><a href='#vpaws'>
<p>vector valued version of function <code>paws</code> with homogeneous covariance structure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.5-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive Weights Smoothing</td>
</tr>
<tr>
<td>Author:</td>
<td>Joerg Polzehl [aut, cre],
  Felix Anker [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joerg Polzehl &lt;joerg.polzehl@wias-berlin.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), awsMethods (&ge; 1.1-1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, gsl</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a collection of R-functions implementing
    adaptive smoothing procedures in 1D, 2D and 3D. This includes the
    Propagation-Separation Approach to adaptive smoothing,
   the Intersecting Confidence Intervals (ICI), variational approaches and a non-local means filter.
   The package is described in detail in Polzehl J, Papafitsoros K, Tabelow K (2020). 
   Patch-Wise Adaptive Weights Smoothing in R. Journal of Statistical Software, 95(6), 1-27. 
   &lt;<a href="https://doi.org/10.18637%2Fjss.v095.i06">doi:10.18637/jss.v095.i06</a>&gt;,
    Usage of the package in MR imaging is illustrated in Polzehl and Tabelow (2023),
   Magnetic Resonance Brain Imaging, 2nd Ed. Appendix A, Springer, Use R! Series.
   &lt;<a href="https://doi.org/10.1007%2F978-3-031-38949-8">doi:10.1007/978-3-031-38949-8</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package is Copyright (C) 2005-2024 Weierstrass
Institute for Applied Analysis and Stochastics.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 12:22:11 UTC; polzehl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auxiliary'>
Auxiliary functions (for internal use)
</h2><span id='topic+gethani'></span><span id='topic+getvofh'></span><span id='topic+sofmchi'></span><span id='topic+residualSpatialCorr'></span><span id='topic+residualVariance'></span>

<h3>Description</h3>

<p>Function <code>gethani</code> determines a bandwidth that leads to, for the specified kernel, a variance reduction for a non-adaptive kernel estimate by a factor of <code>value</code>.
<code>getvofh</code> calculates the sum of location weights for a given bandwidth vector and kernel.
<code>sofmchi</code> precomputes the variance of a non-central chi distribution 
with <code>2*L</code> degrees of freedom as a function of the noncentrality parameter for an interval <code>c(0,to)</code>.
Functions <code>residualVariance</code> and <code>residualSpatialCorr</code> are
used in package <code>fmri</code> to calculate variances and spatial correlations from residual objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gethani(x, y, lkern, value, wght, eps = 0.01)
getvofh(bw, lkern, wght)
sofmchi(L, to = 50, delta = 0.01)
residualVariance(residuals, mask, resscale = 1, compact = FALSE)
residualSpatialCorr(residuals, mask, lags = c(5, 5, 3), compact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auxiliary_+3A_x">x</code></td>
<td>

<p>lower bound of search interval
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_y">y</code></td>
<td>

<p>upper bound of search interval
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_lkern">lkern</code></td>
<td>

<p>code for location kernel 
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_value">value</code></td>
<td>

<p>target sum of location weights
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_wght">wght</code></td>
<td>

<p>relative size of voxel dimensions <code>c(0,0)</code> for 1D and <code>c(w1,0)</code>
for 2D problems.
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_eps">eps</code></td>
<td>

<p>attempted precision for bandwidth search
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_bw">bw</code></td>
<td>

<p>vector of bandwidths, length equal to 1,2 or 3 depending on the dimensionality of the problem.
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_l">L</code></td>
<td>
<p>number of effective coils, <code>2*L</code> is the degree of freedom of the non-central chi distribution.
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_to">to</code></td>
<td>

<p>upper interval bound.
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_delta">delta</code></td>
<td>

<p>discretization width.
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_residuals">residuals</code></td>
<td>

<p>array of residuals, if<code>compact</code> only containing voxel with mask, otherwise for complete data cubes.
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_mask">mask</code></td>
<td>

<p>mask of active voxel (e.g. brain masks)
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_resscale">resscale</code></td>
<td>

<p>scale for residuals (residuals may be scaled for optimal integer*2 storage)
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_compact">compact</code></td>
<td>

<p>logical, determines if only information for voxel within mask or full for full data cubes is given.
</p>
</td></tr>
<tr><td><code id="auxiliary_+3A_lags">lags</code></td>
<td>

<p>positive integer vector of length 3, maximum lags for spatial correlations
for each coordinate direction to be computed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are auxiliary functions not to be used by the user. They are only exported to be available for internal use in packages <code>fmri</code>, <code>dti</code>, <code>qMRI</code> and <code>adimpro</code>.
</p>


<h3>Value</h3>

<p><code>gethani</code> returns a vector of bandwidths,
<code>getvofh</code> returns the variance reduction that would be obtained with a kernel estimate employing the specified kernel and bandwidth,
<code>sofmchi</code> returns a list with, e.g., components <code>ncp</code> and <code>s2</code> containing vectors of noncentralityparameter values and corresponding variances, respectively, for the specified noncentral Chi distribution, 
<code>residualVariance</code> returns a vector (compact==TRUE) or array(compact==FALSE) of voxelwise residual variances,
<code>residualSpatialCorr</code> returns an array of dimension <code>lags</code> 
containing spatial correlations.
</p>


<h3>Note</h3>

<p>These functions are for internal use only. They are only exported to be available in other packages.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>

<hr>
<h2 id='aws'>AWS for local constant models on a grid</h2><span id='topic+aws'></span>

<h3>Description</h3>

<p>The function implements the propagation separation approach to
nonparametric smoothing (formerly introduced as Adaptive weights smoothing)
for varying coefficient likelihood models on a 1D, 2D or 3D grid. For &quot;Gaussian&quot;
models, i.e. regression with additive &quot;Gaussian&quot; errors, a homoskedastic
or heteroskedastic model is used depending on the content of <code>sigma2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aws(y,hmax=NULL, mask=NULL, aws=TRUE, memory=FALSE, family="Gaussian",
                lkern="Triangle", aggkern="Uniform",
                sigma2=NULL, shape=NULL, scorr=0, spmin=0.25,
		            ladjust=1,wghts=NULL,u=NULL,graph=FALSE,demo=FALSE,
                testprop=FALSE,maxni=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aws_+3A_y">y</code></td>
<td>
<p>array <code>y</code> containing the observe response (image intensity) data. <code>dim(y)</code> determines the dimensionality and extend of the grid design.</p>
</td></tr>
<tr><td><code id="aws_+3A_hmax">hmax</code></td>
<td>
 <p><code>hmax</code> specifies the maximal bandwidth. Defaults to <code>hmax=250, 12, 5</code>
for 1D, 2D, 3D images, respectively.
In case of <code>lkern="Gaussian"</code> the bandwidth is assumed to be given in full width half maximum (FWHM) units, i.e., <code>0.42466</code> times gridsize.   </p>
</td></tr>
<tr><td><code id="aws_+3A_aws">aws</code></td>
<td>
<p> logical: if TRUE structural adaptation (AWS) is used. </p>
</td></tr>
<tr><td><code id="aws_+3A_mask">mask</code></td>
<td>
<p> optional logical mask, same dimensionality as <code>y</code></p>
</td></tr>
<tr><td><code id="aws_+3A_memory">memory</code></td>
<td>
<p> logical: if TRUE stagewise aggregation is used as an additional
adaptation scheme. </p>
</td></tr>
<tr><td><code id="aws_+3A_family">family</code></td>
<td>
<p><code>family</code> specifies the probability distribution. Default is <code>family="Gaussian"</code>, also implemented
are &quot;Bernoulli&quot;, &quot;Poisson&quot;, &quot;Exponential&quot;, &quot;Volatility&quot;, &quot;Variance&quot; and &quot;NCchi&quot;. <code>family="Volatility"</code> specifies a Gaussian distribution with
expectation 0 and unknown variance. <code>family="Volatility"</code> specifies that <code>p*y/theta</code> is distributed as <code class="reqn">\chi^2</code> with <code>p=shape</code>
degrees of freedom. <code>family="NCchi"</code> uses a noncentral Chi distribution with <code>p=shape</code> degrees of freedom and noncentrality parameter <code>theta</code></p>
</td></tr>
<tr><td><code id="aws_+3A_lkern">lkern</code></td>
<td>
<p> character: location kernel, either &quot;Triangle&quot;, &quot;Plateau&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot; or &quot;Gaussian&quot;.
The default &quot;Triangle&quot; is equivalent to using an Epanechnikov kernel, &quot;Quadratic&quot; and  &quot;Cubic&quot; refer to a Bi-weight and Tri-weight
kernel, see Fan and Gijbels (1996). &quot;Gaussian&quot; is a truncated (compact support) Gaussian kernel.
This is included for comparisons only and should be avoided due to its large computational costs.</p>
</td></tr>
<tr><td><code id="aws_+3A_aggkern">aggkern</code></td>
<td>
<p> character: kernel used in stagewise aggregation, either &quot;Triangle&quot; or &quot;Uniform&quot; </p>
</td></tr>
<tr><td><code id="aws_+3A_sigma2">sigma2</code></td>
<td>
<p><code>sigma2</code> allows to specify the variance in case of <code>family="Gaussian"</code>. Not used if <code>family!="Gaussian"</code>.
Defaults to <code>NULL</code>. In this case a homoskedastic variance estimate is generated. If <code>length(sigma2)==length(y)</code> then <code>sigma2</code>
is assumed to contain the pointwise variance of <code>y</code> and a heteroscedastic variance model is used.</p>
</td></tr>
<tr><td><code id="aws_+3A_shape">shape</code></td>
<td>
<p>Allows to specify an additional shape parameter for certain family models. Currently only used for family=&quot;Variance&quot;, that is <code class="reqn">\chi</code>-Square distributed observations
with <code>shape</code> degrees of freedom. </p>
</td></tr>
<tr><td><code id="aws_+3A_scorr">scorr</code></td>
<td>
<p>The vector <code>scorr</code> allows to specify a first order correlations of the noise for each coordinate direction,
defaults to 0 (no correlation). </p>
</td></tr>
<tr><td><code id="aws_+3A_spmin">spmin</code></td>
<td>
<p>Determines the form (size of the plateau) in the adaptation kernel.
Not to be changed by the user.</p>
</td></tr>
<tr><td><code id="aws_+3A_ladjust">ladjust</code></td>
<td>
<p> factor to increase the default value of lambda </p>
</td></tr>
<tr><td><code id="aws_+3A_wghts">wghts</code></td>
<td>
 <p><code>wghts</code> specifies the  diagonal elements of a weight matrix to adjust for different distances between grid-points
in different coordinate directions, i.e. allows to define a more appropriate metric in the design space. </p>
</td></tr>
<tr><td><code id="aws_+3A_u">u</code></td>
<td>
<p> a &quot;true&quot; value of the regression function, may be provided to
report risks at each iteration. This can be used to test the propagation condition with <code>u=0</code> </p>
</td></tr>
<tr><td><code id="aws_+3A_graph">graph</code></td>
<td>
<p>If  <code>graph=TRUE</code> intermediate results are illustrated after each iteration step. Defaults to <code>graph=FALSE</code>. </p>
</td></tr>
<tr><td><code id="aws_+3A_demo">demo</code></td>
<td>
<p> If <code>demo=TRUE</code> the function pauses after each iteration. Defaults to <code>demo=FALSE</code>. </p>
</td></tr>
<tr><td><code id="aws_+3A_testprop">testprop</code></td>
<td>
<p>If set this provides diagnostics for testing the propagation condition. The values of <code>y</code> should correspond to the specified
family and a global model. </p>
</td></tr>
<tr><td><code id="aws_+3A_maxni">maxni</code></td>
<td>
<p>If TRUE use <code class="reqn">max_{l&lt;=k}(N_i^{(l)}</code> instead of <code class="reqn">(N_i^{(k)}</code> in the definition of the statistical penalty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the propagation separation approach to
nonparametric smoothing (formerly introduced as Adaptive weights smoothing)
for varying coefficient likelihood models  on a 1D, 2D or 3D grid. For &quot;Gaussian&quot;
models, i.e. regression with additive &quot;Gaussian&quot; errors, a homoskedastic
or heteroskedastic model is used depending on the content of <code>sigma2</code>.
<code>aws==FALSE</code> provides the stagewise aggregation procedure from Belomestny and Spokoiny (2004).
<code>memory==FALSE</code> provides Adaptive weights smoothing without control by stagewise aggregation.
</p>
<p>The essential parameter in the procedure is a critical value <code>lambda</code>. This parameter has an
interpretation as a significance level of a test for equivalence of two local
parameter estimates. Optimal values mainly depend on the choosen <code>family</code>.
Values set internally are choosen to fulfil a propagation condition, i.e. in case of a
constant (global) parameter value and large <code>hmax</code> the procedure
provides, with a high probability, the global (parametric) estimate.
More formally we require the parameter <code>lambda</code>
to be specified such that
<code class="reqn">\bf{E} |\hat{\theta}^k - \theta| \le (1+\alpha) \bf{E} |\tilde{\theta}^k - \theta|</code>
where <code class="reqn">\hat{\theta}^k</code> is the aws-estimate in step <code>k</code> and <code class="reqn">\tilde{\theta}^k</code>
is corresponding nonadaptive estimate using the same bandwidth (<code>lambda=Inf</code>).
The value of lambda can be adjusted by specifying the factor <code>ladjust</code>. Values <code>ladjust&gt;1</code> lead to an less effective adaptation while <code>ladjust&lt;&lt;1</code> may lead to random segmentation
of, with respect to a constant model, homogeneous regions.
</p>
<p>The numerical complexity of the procedure is mainly determined by <code>hmax</code>. The number
of iterations is approximately <code>Const*d*log(hmax)/log(1.25)</code> with <code>d</code> being the dimension
of <code>y</code> and the constant depending on the kernel <code>lkern</code>. Comlexity in each iteration step is <code>Const*hakt*n</code> with <code>hakt</code>
being the actual bandwith in the iteration step and <code>n</code> the number of design points.
<code>hmax</code> determines the maximal possible variance reduction.
</p>


<h3>Value</h3>

<p>returns anobject of class <code>aws</code> with slots
</p>
<table>
<tr><td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td></tr>
<tr><td><code>x = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>ni = "integer"</code></td>
<td>
<p>integer(0)</p>
</td></tr>
<tr><td><code>mask = "logical"</code></td>
<td>
<p>logical(0)</p>
</td></tr>
<tr><td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function, <code>length: length(y)</code></p>
</td></tr>
<tr><td><code>mae = "numeric"</code></td>
<td>
<p>Mean absolute error for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates of the regression function. Please note that this does not reflect variability due to randomness of weights.</p>
</td></tr>
<tr><td><code>xmin = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>xmax = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>wghts = "numeric"</code></td>
<td>
<p>numeric(0), ratio of distances <code>wghts[-1]/wghts[1]</code></p>
</td></tr>
<tr><td><code>degree = "integer"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td></tr>
<tr><td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated error variance</p>
</td></tr>
<tr><td><code>scorr = "numeric"</code></td>
<td>
<p>scorr</p>
</td></tr>
<tr><td><code>family = "character"</code></td>
<td>
<p>family</p>
</td></tr>
<tr><td><code>shape = "numeric"</code></td>
<td>
<p>shape</p>
</td></tr>
<tr><td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1=&quot;Plateau&quot;, 2=&quot;Triangle&quot;, 3=&quot;Quadratic&quot;, 4=&quot;Cubic&quot;, 5=&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td></tr>
<tr><td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td></tr>
<tr><td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td></tr>
<tr><td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td></tr>
<tr><td><code>homogen = "logical"</code></td>
<td>
<p>homogen</p>
</td></tr>
<tr><td><code>earlystop = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>varmodel = "character"</code></td>
<td>
<p>&quot;Constant&quot;</p>
</td></tr>
<tr><td><code>vcoef = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>aws</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>use <code>setCores='number of threads'</code> to enable parallel execution.
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a></p>


<h3>References</h3>

<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Appendix A.
Doi:10.1007/978-3-030-29184-6.
</p>
<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06.
</p>
<p>J. Polzehl, V. Spokoiny,  Adaptive Weights Smoothing with applications to image restoration,
J. R. Stat. Soc. Ser. B Stat. Methodol.  62 ,  (2000)  , pp. 335&ndash;354. DOI:10.1111/1467-9868.00235.
</p>
<p>J. Polzehl, V. Spokoiny,  Propagation-separation approach for local likelihood estimation,
Probab. Theory Related Fields  135 (3),  (2006)  , pp. 335&ndash;362. DOI:10.1007/s00440-005-0464-1.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+paws">paws</a></code>, <code><a href="#topic+lpaws">lpaws</a></code>, <code><a href="#topic+vaws">vaws</a></code>,<code>link{awsdata}</code>, <code><a href="#topic+aws.irreg">aws.irreg</a></code>, <code><a href="#topic+aws.gaussian">aws.gaussian</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(aws)
# 1D local constant smoothing
## Not run: demo(aws_ex1)
## Not run: demo(aws_ex2)
# 2D local constant smoothing
## Not run: demo(aws_ex3)
</code></pre>

<hr>
<h2 id='aws-class'>Class <code>"aws"</code></h2><span id='topic+aws-class'></span>

<h3>Description</h3>

<p>The <code>"aws"</code> class is
used for objects obtained by functions <code>aws</code>, <code>lpaws</code>, <code>aws.irreg</code> and <code>aws.gaussian</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls to functions <code>aws</code>, <code>lpaws</code>, <code>aws.irreg</code> and <code>aws.gaussian</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code>, usually empty. </p>
</dd>
<dt><code>y</code>:</dt><dd><p>Object of class <code>"array"</code> containing the original (response) data </p>
</dd>
<dt><code>dy</code>:</dt><dd><p>Object of class <code>"numeric"</code> dimension attribute of <code>y</code> </p>
</dd>
<dt><code>nvec</code>:</dt><dd><p>Object of class <code>"integer"</code> leading dimension of <code>y</code> in vector valued data.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> if provided the design points</p>
</dd>
<dt><code>ni</code>:</dt><dd><p>Object of class <code>"numeric"</code> sum of weights used in final estimate </p>
</dd>
<dt><code>mask</code>:</dt><dd><p>Object of class <code>"logical"</code> mask of design points where computations are performed </p>
</dd>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"array"</code> containes the smoothed object and in case
of function <code>lpaws</code> its derivatives up to the specified degree.
Dimension is <code>dim(theta)=c(dy,p)</code></p>
</dd>
<dt><code>hseq</code>:</dt><dd><p>Sequence of bandwidths employed.</p>
</dd>
<dt><code>mae</code>:</dt><dd><p>Object of class <code>"numeric"</code> Mean absolute error with respect to
array in argument <code>u</code> if provided. </p>
</dd>
<dt><code>psnr</code>:</dt><dd><p>Object of class <code>"numeric"</code> Peak Signal to Noise Ratio (PSNR) with respect to
array in argument <code>u</code> if provided. </p>
</dd>
<dt><code>var</code>:</dt><dd><p>Object of class <code>"numeric"</code> pointwise variance of
<code>theta[...,1]</code></p>
</dd>
<dt><code>xmin</code>:</dt><dd><p>Object of class <code>"numeric"</code> min of <code>x</code> in case of irregular design </p>
</dd>
<dt><code>xmax</code>:</dt><dd><p>Object of class <code>"numeric"</code> max of <code>x</code> in case of irregular design</p>
</dd>
<dt><code>wghts</code>:</dt><dd><p>Object of class <code>"numeric"</code> weights used in location penalty for
different coordinate directions, corresponds to ratios of distances in coordinate directions 2 and 3 to
and distance in coordinate direction 1.</p>
</dd>
<dt><code>degree</code>:</dt><dd><p>Object of class <code>"integer"</code> degree of local polynomials used in
function <code>lpaws</code> </p>
</dd>
<dt><code>hmax</code>:</dt><dd><p>Object of class <code>"numeric"</code> maximal bandwidth </p>
</dd>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> estimated error variance </p>
</dd>
<dt><code>scorr</code>:</dt><dd><p>Object of class <code>"numeric"</code> estimated spatial correlation </p>
</dd>
<dt><code>family</code>:</dt><dd><p>Object of class <code>"character"</code> distribution of <code>y</code>,
can be any of <code>c("Gaussian","Bernoulli","Poisson","Exponential",
           "Volatility","Variance")</code> </p>
</dd>
<dt><code>shape</code>:</dt><dd><p>Object of class <code>"numeric"</code> possible shape parameter of distribution of <code>y</code></p>
</dd>
<dt><code>lkern</code>:</dt><dd><p>Object of class <code>"integer"</code> location kernel, can be
any of <code>c("Triangle","Quadratic","Cubic","Plateau","Gaussian")</code>, defauts to
<code>"Triangle"</code></p>
</dd>
<dt><code>lambda</code>:</dt><dd><p>Object of class <code>"numeric"</code> scale parameter used in adaptation</p>
</dd>
<dt><code>ladjust</code>:</dt><dd><p>Object of class <code>"numeric"</code> factor to adjust scale parameter with respect to its
predetermined default. </p>
</dd>
<dt><code>aws</code>:</dt><dd><p>Object of class <code>"logical"</code> Adaptation by Propagation-Separation  </p>
</dd>
<dt><code>memory</code>:</dt><dd><p>Object of class <code>"logical"</code> Adaptation by Stagewise Aggregation </p>
</dd>
<dt><code>homogen</code>:</dt><dd><p>Object of class <code>"logical"</code> detect regions of homogeneity (used to speed up
the calculations) </p>
</dd>
<dt><code>earlystop</code>:</dt><dd><p>Object of class <code>"logical"</code> further speedup in function <code>lpaws</code>
estimates are fixed if sum of weigths does not increase with iterations. </p>
</dd>
<dt><code>varmodel</code>:</dt><dd><p>Object of class <code>"character"</code> variance model used in
function <code>aws.gaussian</code> </p>
</dd>
<dt><code>vcoef</code>:</dt><dd><p>Object of class <code>"numeric"</code> estimates variance parameters
in function <code>aws.gaussian</code> </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class  <code>"call"</code> that created the object. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>extract</dt><dd><p><code>signature(x = "aws")</code>: ... </p>
</dd>
<dt>risk</dt><dd><p><code>signature(y = "aws")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p> Method for Function &lsquo;plot&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>show</dt><dd><p> Method for Function &lsquo;show&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>print</dt><dd><p> Method for Function &lsquo;print&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>summary</dt><dd><p> Method for Function &lsquo;summary&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>Joerg Polzehl, Vladimir Spokoiny,  Adaptive Weights Smoothing with applications to image restoration,  J. R. Stat. Soc. Ser. B Stat. Methodol.  62 ,  (2000)  , pp. 335&ndash;354
</p>
<p>Joerg Polzehl, Vladimir Spokoiny,  Propagation-separation approach for local likelihood estimation,  Probab. Theory Related Fields  135 (3),  (2006)  , pp. 335&ndash;362.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aws">aws</a></code>, <code><a href="#topic+lpaws">lpaws</a></code>, <code><a href="#topic+aws.irreg">aws.irreg</a></code>, <code><a href="#topic+aws.gaussian">aws.gaussian</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("aws")
</code></pre>

<hr>
<h2 id='aws-package'>
Adaptive Weights Smoothing
</h2><span id='topic+aws-package'></span>

<h3>Description</h3>

<p>We provide a collection of R-functions implementing
    adaptive smoothing procedures in 1D, 2D and 3D. This includes the
    Propagation-Separation Approach to adaptive smoothing,
   the Intersecting Confidence Intervals (ICI), variational approaches and a non-local means filter.
   The package is described in detail in Polzehl J, Papafitsoros K, Tabelow K (2020). 
   Patch-Wise Adaptive Weights Smoothing in R. Journal of Statistical Software, 95(6), 1-27. 
   &lt;doi:10.18637/jss.v095.i06&gt;,
    Usage of the package in MR imaging is illustrated in Polzehl and Tabelow (2023),
   Magnetic Resonance Brain Imaging, 2nd Ed. Appendix A, Springer, Use R! Series.
   &lt;doi:10.1007/978-3-031-38949-8&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> aws</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.5-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-07</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Adaptive Weights Smoothing</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Joerg","Polzehl",role=c("aut","cre"),email="joerg.polzehl@wias-berlin.de"),person("Felix","Anker",role=c("ctb")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Joerg Polzehl [aut, cre], Felix Anker [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Joerg Polzehl &lt;joerg.polzehl@wias-berlin.de&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.4.0), awsMethods (&gt;= 1.1-1)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> methods, gsl</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> We provide a collection of R-functions implementing
    adaptive smoothing procedures in 1D, 2D and 3D. This includes the
    Propagation-Separation Approach to adaptive smoothing,
   the Intersecting Confidence Intervals (ICI), variational approaches and a non-local means filter.
   The package is described in detail in Polzehl J, Papafitsoros K, Tabelow K (2020). 
   Patch-Wise Adaptive Weights Smoothing in R. Journal of Statistical Software, 95(6), 1-27. 
   &lt;doi:10.18637/jss.v095.i06&gt;,
    Usage of the package in MR imaging is illustrated in Polzehl and Tabelow (2023),
   Magnetic Resonance Brain Imaging, 2nd Ed. Appendix A, Springer, Use R! Series.
   &lt;doi:10.1007/978-3-031-38949-8&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Copyright: </td><td style="text-align: left;"> This package is Copyright (C) 2005-2024 Weierstrass Institute
for Applied Analysis and Stochastics.</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.wias-berlin.de/people/polzehl/</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 5.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
ICIcombined             Adaptive smoothing by Intersection of
                        Confidence Intervals (ICI) using multiple
                        windows
ICIsmooth               Adaptive smoothing by Intersection of
                        Confidence Intervals (ICI)
ICIsmooth-class         Class '"ICIsmooth"'
TV_denoising            TV/TGV denoising of image data
aws                     AWS for local constant models on a grid
aws-class               Class '"aws"'
aws-package             Adaptive Weights Smoothing
aws.gaussian            Adaptive weights smoothing for Gaussian data
                        with variance depending on the mean.
aws.irreg               local constant AWS for irregular (1D/2D) design
aws.segment             Segmentation by adaptive weights for Gaussian
                        models.
awsLocalSigma           3D variance estimation
awsdata                 Extract information from an object of class aws
awssegment-class        Class '"awssegment"'
awstestprop             Propagation condition for adaptive weights
                        smoothing
awsweights              Generate weight scheme that would be used in an
                        additional aws step
binning                 Binning in 1D, 2D or 3D
extract-methods         Methods for Function 'extract' in Package 'aws'
gethani                 Auxiliary functions (for internal use)
kernsm                  Kernel smoothing on a 1D, 2D or 3D grid
kernsm-class            Class '"kernsm"'
lpaws                   Local polynomial smoothing by AWS
nlmeans                 NLMeans filter in 1D/2D/3D
paws                    Adaptive weigths smoothing using patches
plot-methods            Methods for Function 'plot' from package
                        'graphics' in Package 'aws'
print-methods           Methods for Function 'print' from package
                        'base' in Package 'aws'
qmeasures               Quality assessment for image reconstructions.
risk-methods            Compute risks characterizing the quality of
                        smoothing results
show-methods            Methods for Function 'show' in Package 'aws'
smooth3D                Auxiliary 3D smoothing routines
smse3ms                 Adaptive smoothing in orientation space SE(3)
summary-methods         Methods for Function 'summary' from package
                        'base' in Package 'aws'
vaws                    vector valued version of function 'aws' The
                        function implements the propagation separation
                        approach to nonparametric smoothing (formerly
                        introduced as Adaptive weights smoothing) for
                        varying coefficient likelihood models with
                        vector valued response on a 1D, 2D or 3D grid.
vpaws                   vector valued version of function 'paws' with
                        homogeneous covariance structure
</pre>


<h3>Author(s)</h3>

<p>Joerg Polzehl [aut, cre], Felix Anker [ctb]
</p>
<p>Maintainer: Joerg Polzehl &lt;joerg.polzehl@wias-berlin.de&gt;
</p>


<h3>References</h3>

<p> J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Appendix A.
Doi:10.1007/978-3-030-29184-6.
</p>
<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06.
</p>
<p>J. Polzehl and V. Spokoiny (2006)
Propagation-Separation Approach for Local Likelihood Estimation,
Prob. Theory and Rel. Fields 135(3), 335-362. DOI:10.1007/s00440-005-0464-1.
</p>
<p>J. Polzehl, V. Spokoiny,  Adaptive Weights Smoothing with applications to image restoration,
J. R. Stat. Soc. Ser. B Stat. Methodol.  62 ,  (2000)  , pp. 335&ndash;354. DOI:10.1111/1467-9868.00235.
</p>
<p>V. Katkovnik, K. Egiazarian and J. Astola (2006)
Local Approximation Techniques in Signal and Image Processing,
SPIE Press Monograph Vol. PM 157
</p>
<p>A. Buades, B. Coll and J. M. Morel (2006). A review of image denoising algorithms,
with a new one.
Simulation, 4, 490-530. DOI:10.1137/040616024.
</p>
<p>Rudin, L.I., Osher, S. and Fatemi, E. (1992). Nonlinear total variation based
noise removal algorithms. Phys. D, 60, 259-268. DOI: 10.1016/0167-2789(92)90242-F.
</p>
<p>Bredies, K., Kunisch, K. and Pock, T. (2010). Total Generalized Variation.
SIAM J. Imaging Sci., 3, 492-526. DOI:10.1137/090769521.
</p>

<hr>
<h2 id='aws.gaussian'> Adaptive weights smoothing for Gaussian data with variance depending on the mean.  </h2><span id='topic+aws.gaussian'></span>

<h3>Description</h3>

<p>The function implements an semiparametric adaptive weights smoothing algorithm designed
for regression with additive heteroskedastic Gaussian noise. The noise variance is assumed to
depend on the value of the regression function. This dependence is modeled by a global parametric
(polynomial) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aws.gaussian(y, hmax = NULL, hpre = NULL, aws = TRUE, memory = FALSE,
             varmodel = "Constant", lkern = "Triangle",
             aggkern = "Uniform", scorr = 0, mask=NULL, ladjust = 1,
             wghts = NULL, u = NULL, varprop = 0.1, graph = FALSE, demo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aws.gaussian_+3A_y">y</code></td>
<td>
 <p><code>y</code> contains the observed response data. <code>dim(y)</code> determines the dimensionality and extend of the grid design.</p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_hmax">hmax</code></td>
<td>
 <p><code>hmax</code> specifies the maximal bandwidth. Defaults to
<code>hmax=250, 12, 5</code> for <code>dd=1, 2, 3</code>, respectively.</p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_hpre">hpre</code></td>
<td>
<p> Describe <code>hpre</code> Bandwidth used for an initial nonadaptive estimate.
The first estimate of variance parameters  is obtained from residuals with respect to this estimate. </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_aws">aws</code></td>
<td>
<p> logical: if TRUE structural adaptation (AWS) is used. </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_memory">memory</code></td>
<td>
<p> logical: if TRUE stagewise aggregation is used as an additional
adaptation scheme. </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_varmodel">varmodel</code></td>
<td>
<p>Implemented are &quot;Constant&quot;, &quot;Linear&quot; and &quot;Quadratic&quot; refering to a polynomial model of degree 0 to 2.</p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_lkern">lkern</code></td>
<td>
<p> character: location kernel, either &quot;Triangle&quot;, &quot;Plateau&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot; or &quot;Gaussian&quot;.
The default &quot;Triangle&quot; is equivalent to using an Epanechnikov kernel, &quot;Quadratic&quot; and  &quot;Cubic&quot; refer to a Bi-weight and Tri-weight
kernel, see Fan and Gijbels (1996). &quot;Gaussian&quot; is a truncated (compact support) Gaussian kernel.
This is included for comparisons only and should be avoided due to its large computational costs.</p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_aggkern">aggkern</code></td>
<td>
<p> character: kernel used in stagewise aggregation, either &quot;Triangle&quot; or &quot;Uniform&quot; </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_scorr">scorr</code></td>
<td>
<p>The vector <code>scorr</code> allows to specify a first order correlations of the noise for each coordinate direction,
defaults to 0 (no correlation). </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_mask">mask</code></td>
<td>
<p>Restrict smoothing to points where <code>mask==TRUE</code>. Defaults to <code>TRUE</code> in all voxel.</p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_ladjust">ladjust</code></td>
<td>
<p> factor to increase the default value of lambda </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_wghts">wghts</code></td>
<td>
 <p><code>wghts</code> specifies the  diagonal elements of a weight matrix to adjust for different distances between grid-points
in different coordinate directions, i.e. allows to define a more appropriate metric in the design space. </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_u">u</code></td>
<td>
<p> a &quot;true&quot; value of the regression function, may be provided to
report risks at each iteration. This can be used to test the propagation condition with <code>u=0</code> </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_varprop">varprop</code></td>
<td>
<p> Small variance estimates are replaced by <code>varprop</code> times the mean variance.</p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_graph">graph</code></td>
<td>
<p>If  <code>graph=TRUE</code> intermediate results are illustrated after each iteration step. Defaults to <code>graph=FALSE</code>. </p>
</td></tr>
<tr><td><code id="aws.gaussian_+3A_demo">demo</code></td>
<td>
<p> If <code>demo=TRUE</code> the function pauses after each iteration. Defaults to <code>demo=FALSE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the propagation separation approach to
nonparametric smoothing (formerly introduced as Adaptive weights smoothing)
for varying coefficient likelihood models  on a 1D, 2D or 3D grid.
In contrast to function <code>aws</code> observations are assumed to follow a Gaussian distribution
with variance depending on the mean according to a specified global variance model.
<code>aws==FALSE</code> provides the stagewise aggregation procedure from Belomestny and Spokoiny (2004).
<code>memory==FALSE</code> provides Adaptive weights smoothing without control by stagewise aggregation.
</p>
<p>The essential parameter in the procedure is a critical value <code>lambda</code>. This parameter has an
interpretation as a significance level of a test for equivalence of two local
parameter estimates.
Values set internally are choosen to fulfil a propagation condition, i.e. in case of a
constant (global) parameter value and large <code>hmax</code> the procedure
provides, with a high probability, the global (parametric) estimate.
More formally we require the parameter <code>lambda</code>
to be specified such that
<code class="reqn">\bf{E} |\hat{\theta}^k - \theta| \le (1+\alpha) \bf{E} |\tilde{\theta}^k - \theta|</code>
where <code class="reqn">\hat{\theta}^k</code> is the aws-estimate in step <code>k</code> and <code class="reqn">\tilde{\theta}^k</code>
is corresponding nonadaptive estimate using the same bandwidth (<code>lambda=Inf</code>).
The value of lambda can be adjusted by specifying the factor <code>ladjust</code>. Values
<code>ladjust&gt;1</code> lead to an less effective adaptation while <code>ladjust&lt;&lt;1</code> may lead
to random segmentation of, with respect to a constant model, homogeneous regions.
</p>
<p>The numerical complexity of the procedure is mainly determined by <code>hmax</code>. The number
of iterations is approximately <code>Const*d*log(hmax)/log(1.25)</code> with <code>d</code> being the dimension
of <code>y</code> and the constant depending on the kernel <code>lkern</code>. Comlexity in each
iteration step is <code>Const*hakt*n</code> with <code>hakt</code> being the actual bandwith
in the iteration step and <code>n</code> the number of design points.
<code>hmax</code> determines the maximal possible variance reduction.
</p>


<h3>Value</h3>

<p>returns anobject of class <code>aws</code> with slots
</p>
<table>
<tr><td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td></tr>
<tr><td><code>x = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>ni = "integer"</code></td>
<td>
<p>integer(0)</p>
</td></tr>
<tr><td><code>mask = "logical"</code></td>
<td>
<p>logical(0)</p>
</td></tr>
<tr><td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function, <code>length: length(y)</code></p>
</td></tr>
<tr><td><code>mae = "numeric"</code></td>
<td>
<p>Mean absolute error for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates of the regression function. Please note that this does not reflect variability due to randomness of weights.</p>
</td></tr>
<tr><td><code>xmin = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>xmax = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>wghts = "numeric"</code></td>
<td>
<p>numeric(0), ratio of distances <code>wghts[-1]/wghts[1]</code></p>
</td></tr>
<tr><td><code>degree = "integer"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td></tr>
<tr><td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated error variance</p>
</td></tr>
<tr><td><code>scorr = "numeric"</code></td>
<td>
<p>scorr</p>
</td></tr>
<tr><td><code>family = "character"</code></td>
<td>
<p>&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>shape = "numeric"</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1=&quot;Plateau&quot;, 2=&quot;Triangle&quot;, 3=&quot;Quadratic&quot;, 4=&quot;Cubic&quot;, 5=&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td></tr>
<tr><td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td></tr>
<tr><td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td></tr>
<tr><td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td></tr>
<tr><td><code>homogen = "logical"</code></td>
<td>
<p>homogen</p>
</td></tr>
<tr><td><code>earlystop = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>varmodel = "character"</code></td>
<td>
<p>varmodel</p>
</td></tr>
<tr><td><code>vcoef = "numeric"</code></td>
<td>
<p>estimated parameters of the variance model</p>
</td></tr>
<tr><td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>aws.gaussian</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a> </p>


<h3>References</h3>

<p> Joerg Polzehl, Vladimir Spokoiny,  Adaptive Weights Smoothing with applications to image restoration,  J. R. Stat. Soc. Ser. B Stat. Methodol.  62 ,  (2000)  , pp. 335&ndash;354
</p>
<p>Joerg Polzehl, Vladimir Spokoiny,  Propagation-separation approach for local likelihood estimation,  Probab. Theory Related Fields  135 (3),  (2006)  , pp. 335&ndash;362.
</p>
<p>Joerg Polzehl, Vladimir Spokoiny, in V. Chen, C.; Haerdle, W. and Unwin, A. (ed.) Handbook of Data Visualization Structural adaptive smoothing by propagation-separation methods Springer-Verlag, 2008, 471-492
</p>


<h3>See Also</h3>

<p>See also  <code><a href="#topic+aws">aws</a></code>, <code>link{awsdata}</code>, <code><a href="#topic+aws.irreg">aws.irreg</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>require(aws)
</code></pre>

<hr>
<h2 id='aws.irreg'> local constant AWS for irregular (1D/2D) design </h2><span id='topic+aws.irreg'></span>

<h3>Description</h3>

<p>The function implements the propagation separation approach to
nonparametric smoothing (formerly introduced as Adaptive weights smoothing)
for varying coefficient Gaussian models on a 1D or 2D irregulat design.
The function allows for a paramertic (polynomial) mean-variance dependence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aws.irreg(y, x, hmax = NULL, aws=TRUE, memory=FALSE, varmodel = "Constant",
          lkern = "Triangle", aggkern = "Uniform", sigma2 = NULL, nbins = 100,
          hpre = NULL, henv = NULL, ladjust =1, varprop = 0.1, graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aws.irreg_+3A_y">y</code></td>
<td>
<p> The observed response vector (length n) </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_x">x</code></td>
<td>
<p> Design matrix, dimension n x d, <code>d %in% 1:2</code> </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_hmax">hmax</code></td>
<td>
 <p><code>hmax</code> specifies the maximal bandwidth. Unit is binwidth in the first dimension.</p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_aws">aws</code></td>
<td>
<p> logical: if TRUE structural adaptation (AWS) is used. </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_memory">memory</code></td>
<td>
<p> logical: if TRUE stagewise aggregation is used as an additional
adaptation scheme. </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_varmodel">varmodel</code></td>
<td>
<p> determines the model that relates variance to mean. Either
&quot;Constant&quot;, &quot;Linear&quot; or &quot;Quadratic&quot;. </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_lkern">lkern</code></td>
<td>
<p> character: location kernel, either &quot;Triangle&quot;, &quot;Plateau&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_aggkern">aggkern</code></td>
<td>
<p> character: kernel used in stagewise aggregation, either &quot;Triangle&quot; or &quot;Uniform&quot; </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_sigma2">sigma2</code></td>
<td>
<p><code>sigma2</code> allows to specify the variance in case of <code>varmodel="Constant"</code>, estimated if not given.  </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_nbins">nbins</code></td>
<td>
<p> numer of bins, can be NULL, a positive integer or a vector of positive integers (length d) </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_hpre">hpre</code></td>
<td>
<p> smoothing bandwidth for initial variance estimate </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_henv">henv</code></td>
<td>
<p> radius of balls around each observed design point where
estimates will be calculated </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_ladjust">ladjust</code></td>
<td>
<p> factor to increase the default value of lambda </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_varprop">varprop</code></td>
<td>
<p> exclude the largest 100*varprop% squared residuals when estimating the error variance </p>
</td></tr>
<tr><td><code id="aws.irreg_+3A_graph">graph</code></td>
<td>
<p>If  <code>graph=TRUE</code> intermediate results are illustrated after each iteration step. Defaults to <code>graph=FALSE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are first binned (1D/2D), then aws is performed on all datapoints within
distance &lt;= henv of nonempty bins.
</p>


<h3>Value</h3>

<p>returns anobject of class <code>aws</code> with slots
</p>
<table>
<tr><td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td></tr>
<tr><td><code>x = "numeric"</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code>ni = "integer"</code></td>
<td>
<p>number of observations per bin</p>
</td></tr>
<tr><td><code>mask = "logical"</code></td>
<td>
<p>bins where parameters have been estimated</p>
</td></tr>
<tr><td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function, <code>length: length(y)</code></p>
</td></tr>
<tr><td><code>mae = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates of the regression function. Please note that this does not reflect variability due to randomness of weights.</p>
</td></tr>
<tr><td><code>xmin = "numeric"</code></td>
<td>
<p>vector of minimal x-values (bins)</p>
</td></tr>
<tr><td><code>xmax = "numeric"</code></td>
<td>
<p>vector of maximal x-values (bins)</p>
</td></tr>
<tr><td><code>wghts = "numeric"</code></td>
<td>
<p>relative binwidths</p>
</td></tr>
<tr><td><code>degree = "integer"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td></tr>
<tr><td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated error variance</p>
</td></tr>
<tr><td><code>scorr = "numeric"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>family = "character"</code></td>
<td>
<p>&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>shape = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1=&quot;Plateau&quot;, 2=&quot;Triangle&quot;, 3=&quot;Quadratic&quot;, 4=&quot;Cubic&quot;, 5=&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td></tr>
<tr><td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td></tr>
<tr><td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td></tr>
<tr><td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td></tr>
<tr><td><code>homogen = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>earlystop = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>varmodel = "character"</code></td>
<td>
<p>varmodel</p>
</td></tr>
<tr><td><code>vcoef = "numeric"</code></td>
<td>
<p>estimated coefficients in variance model</p>
</td></tr>
<tr><td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>aws</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>References</h3>

<p> J. Polzehl, V. Spokoiny, in V. Chen, C.; Haerdle, W. and Unwin, A. (ed.)
Handbook of Data Visualization Structural adaptive smoothing by propagation-separation methods.
Springer-Verlag, 2008, 471-492. DOI:10.1007/978-3-540-33037-0_19.
</p>


<h3>See Also</h3>

<p> See also  <code><a href="#topic+lpaws">lpaws</a></code>, <code>link{awsdata}</code>, <code><a href="#topic+lpaws">lpaws</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>require(aws)
# 1D local constant smoothing
## Not run: demo(irreg_ex1)
# 2D local constant smoothing
## Not run: demo(irreg_ex2)
</code></pre>

<hr>
<h2 id='aws.segment'> Segmentation by adaptive weights for Gaussian models. </h2><span id='topic+aws.segment'></span>

<h3>Description</h3>

<p>The function implements a modification of the adaptive weights smoothing algorithm for
segmentation into three classes. The
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aws.segment(y, level, delta = 0, hmax = NULL, hpre = NULL, mask =NULL,
            varmodel = "Constant", lkern = "Triangle", scorr = 0, ladjust = 1,
            wghts = NULL, u = NULL, varprop = 0.1, ext = 0, graph = FALSE,
            demo = FALSE, fov=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aws.segment_+3A_y">y</code></td>
<td>
 <p><code>y</code> contains the observed response data. <code>dim(y)</code> determines the dimensionality and extend of the grid design.</p>
</td></tr>
<tr><td><code id="aws.segment_+3A_level">level</code></td>
<td>
<p> center of second class </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_delta">delta</code></td>
<td>
<p> half width of second class </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_hmax">hmax</code></td>
<td>
 <p><code>hmax</code> specifies the maximal bandwidth. Defaults to <code>hmax=250, 12, 5</code> for <code>dd=1, 2, 3</code>, respectively.</p>
</td></tr>
<tr><td><code id="aws.segment_+3A_hpre">hpre</code></td>
<td>
<p> Describe <code>hpre</code> Bandwidth used for an initial nonadaptive estimate. The first estimate
of variance parameters  is obtained from residuals with respect to this estimate. </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_mask">mask</code></td>
<td>
<p> optional logical mask, same dimensionality as <code>y</code></p>
</td></tr>
<tr><td><code id="aws.segment_+3A_varmodel">varmodel</code></td>
<td>
<p>Implemented are &quot;Constant&quot;, &quot;Linear&quot; and &quot;Quadratic&quot; refering to a polynomial model of degree 0 to 2.</p>
</td></tr>
<tr><td><code id="aws.segment_+3A_lkern">lkern</code></td>
<td>
<p> character: location kernel, either &quot;Triangle&quot;, &quot;Plateau&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot; or &quot;Gaussian&quot;.
The default &quot;Triangle&quot; is equivalent to using an Epanechnikov kernel, &quot;Quadratic&quot; and  &quot;Cubic&quot; refer to a Bi-weight and Tri-weight
kernel, see Fan and Gijbels (1996). &quot;Gaussian&quot; is a truncated (compact support) Gaussian kernel.
This is included for comparisons only and should be avoided due to its large computational costs.</p>
</td></tr>
<tr><td><code id="aws.segment_+3A_scorr">scorr</code></td>
<td>
<p>The vector <code>scorr</code> allows to specify a first order correlations of the noise for each coordinate direction,
defaults to 0 (no correlation). </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_ladjust">ladjust</code></td>
<td>
<p> factor to increase the default value of lambda </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_wghts">wghts</code></td>
<td>
 <p><code>wghts</code> specifies the  diagonal elements of a weight matrix to adjust for different distances between grid-points
in different coordinate directions, i.e. allows to define a more appropriate metric in the design space. </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_u">u</code></td>
<td>
<p> a &quot;true&quot; value of the regression function, may be provided to
report risks at each iteration. This can be used to test the propagation condition with <code>u=0</code> </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_varprop">varprop</code></td>
<td>
<p> Small variance estimates are replaced by <code>varprop</code> times the mean variance.</p>
</td></tr>
<tr><td><code id="aws.segment_+3A_ext">ext</code></td>
<td>
<p> Intermediate results are fixed if the test statistics exceeds the critical value by <code>ext</code>.</p>
</td></tr>
<tr><td><code id="aws.segment_+3A_graph">graph</code></td>
<td>
<p>If  <code>graph=TRUE</code> intermediate results are illustrated after each iteration step. Defaults to <code>graph=FALSE</code>. </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_demo">demo</code></td>
<td>
<p> If <code>demo=TRUE</code> the function pauses after each iteration. Defaults to <code>demo=FALSE</code>. </p>
</td></tr>
<tr><td><code id="aws.segment_+3A_fov">fov</code></td>
<td>
<p>Field of view. Size of region (sample size) to adjust for in multiscale testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The image is segmented into three parts by performing multiscale tests
of the hypotheses H1
<code>value &gt;= level - delta</code> and H2 <code>value &lt;= level + delta</code>.
Pixel where the first hypotesis is rejected are classified as <code>-1</code> (segment 1)
while rejection of H2 results in classification  <code>1</code> (segment 3).
Pixel where neither H1 or H2 are rejected ar assigned to a value <code>0</code> (segment 2). Critical values for the tests are adjusted for smoothness at the different scales inspected in the iteration process using results from multiscale testing,
see e.g. Duembgen and Spokoiny (2001). Critical values also depend on the
size of the region of interest specified in parameter <code>fov</code>.
</p>
<p>Within segment 2 structural adaptive smoothing is performed while if a pair of pixel belongs to segment 1 or segment 3 the corresponding weight will be nonadaptive.
</p>


<h3>Value</h3>

<p>returns anobject of class <code>aws</code> with slots
</p>
<table>
<tr><td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td></tr>
<tr><td><code>x = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>ni = "integer"</code></td>
<td>
<p>integer(0)</p>
</td></tr>
<tr><td><code>mask = "logical"</code></td>
<td>
<p>logical(0)</p>
</td></tr>
<tr><td><code>segment = "integer"</code></td>
<td>
<p>Segmentation results, class numbers 1-3 </p>
</td></tr>
<tr><td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function, <code>length: length(y)</code></p>
</td></tr>
<tr><td><code>mae = "numeric"</code></td>
<td>
<p>Mean absolute error for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates of the regression function. Please note that this does not reflect variability due to randomness of weights.</p>
</td></tr>
<tr><td><code>xmin = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>xmax = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>wghts = "numeric"</code></td>
<td>
<p>numeric(0), ratio of distances <code>wghts[-1]/wghts[1]</code></p>
</td></tr>
<tr><td><code>degree = "integer"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td></tr>
<tr><td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated error variance</p>
</td></tr>
<tr><td><code>scorr = "numeric"</code></td>
<td>
<p>scorr</p>
</td></tr>
<tr><td><code>family = "character"</code></td>
<td>
<p>&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>shape = "numeric"</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1=&quot;Plateau&quot;, 2=&quot;Triangle&quot;, 3=&quot;Quadratic&quot;, 4=&quot;Cubic&quot;, 5=&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td></tr>
<tr><td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td></tr>
<tr><td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td></tr>
<tr><td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td></tr>
<tr><td><code>homogen = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>earlystop = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>varmodel = "character"</code></td>
<td>
<p>varmodel</p>
</td></tr>
<tr><td><code>vcoef = "numeric"</code></td>
<td>
<p>estimated parameters of the variance model</p>
</td></tr>
<tr><td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>aws.gaussian</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function is still experimental and may be changes considerably in future.</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a>  </p>


<h3>References</h3>

<p>J. Polzehl, H.U. Voss, K. Tabelow (2010). Structural adaptive segmentation for
statistical parametric mapping, NeuroImage, 52, pp. 515&ndash;523. DOI:10.1016/j.neuroimage.2010.04.241
</p>
<p>Duembgen, L. and Spokoiny, V. (2001). Multiscale testing of qualitative hypoteses. Ann. Stat. 29, 124&ndash;152.
</p>
<p>Polzehl, J. and Spokoiny, V. (2006). Propagation-Separation Approach for Local
Likelihood Estimation. Probability Theory and Related Fields. 3 (135)
335 - 362. DOI:10.1007/s00440-005-0464-1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aws">aws</a></code>, <code><a href="#topic+aws.gaussian">aws.gaussian</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>require(aws)
</code></pre>

<hr>
<h2 id='awsdata'>Extract information from an object of class aws</h2><span id='topic+awsdata'></span>

<h3>Description</h3>

<p>Extract data and estimates  from an object of class aws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awsdata(awsobj, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="awsdata_+3A_awsobj">awsobj</code></td>
<td>
<p> an object of class <code>aws</code> </p>
</td></tr>
<tr><td><code id="awsdata_+3A_what">what</code></td>
<td>
<p> can be &quot;data&quot; (extracts observed response),
&quot;theta&quot; (estimated parameters),
&quot;est&quot; (estimated regression function), 
&quot;var&quot; (approx. variance of estimated regression function), 
&quot;sd&quot; (approx. standard deviation of estimated regression function),
&quot;sigma2&quot; (error variance),
&quot;mae&quot; (mean absolute error for each iteration step, if available),
&quot;ni&quot; (number of observations per bin),
&quot;mask&quot; (logical indicator for bins where the regression function is estimated).
&quot;bi&quot; (array of sum of weights or NULL)
&quot;bi2&quot; (array of sum of squared weights or NULL)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned object is formatted as an array if appropriate. 
The returned object may be NULL if the information is not available.
</p>


<h3>Value</h3>

<p>an vector or array containing the specified information.
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>  </p>


<h3>References</h3>

 
<p>Joerg Polzehl, Vladimir Spokoiny,  Adaptive Weights Smoothing with applications to image restoration,  J. R. Stat. Soc. Ser. B Stat. Methodol.  62 ,  (2000)  , pp. 335&ndash;354
</p>
<p>Joerg Polzehl, Vladimir Spokoiny,  Propagation-separation approach for local likelihood estimation,  Probab. Theory Related Fields  135 (3),  (2006)  , pp. 335&ndash;362.
</p>
<p>Joerg Polzehl, Vladimir Spokoiny, in V. Chen, C.; Haerdle, W. and Unwin, A. (ed.) Handbook of Data Visualization Structural adaptive smoothing by propagation-separation methods Springer-Verlag, 2008, 471-492
</p>


<h3>See Also</h3>

<p><code>link{awsdata}</code>,<code><a href="#topic+aws">aws</a></code>, <code><a href="#topic+aws.irreg">aws.irreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(aws)
# 1D local constant smoothing
## Not run: demo(aws_ex1)
## Not run: demo(aws_ex2)
# 2D local constant smoothing
## Not run: demo(aws_ex3)
# 1D local polynomial smoothing
## Not run: demo(lpaws_ex1)
# 2D local polynomial smoothing
## Not run: demo(lpaws_ex2)
# 1D irregular design
## Not run: demo(irreg_ex1)
# 2D irregular design 
## Not run: demo(irreg_ex2)

</code></pre>

<hr>
<h2 id='awsLocalSigma'>
3D variance estimation
</h2><span id='topic+awsLocalSigma'></span><span id='topic+awslinsd'></span><span id='topic+estimateSigmaCompl'></span><span id='topic+AFLocalSigma'></span><span id='topic+estGlobalSigma'></span>

<h3>Description</h3>

<p>Functions for 3D variance estimation. <code>awsLocalSigma</code> implements the
local adaptive variance estimation procedure introduced in Tabelow, Voss and Polzehl (2015).
<code>awslinsd</code> uses a parametric model for varianc/mesn dependence. Functions
<code>AFLocalSigma</code> and <code>estGlobalSigma</code> implement various proposals for local
and global variance estimates from Aja-Fernandez (2009, 2013) and a global variant of the
approach from Tabelow, Voss and Polzehl (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awsLocalSigma(y, steps, mask, ncoils, vext = c(1, 1), lambda = 5,
    minni = 2, hsig = 5, sigma = NULL, family = c("NCchi", "Gauss"),
    verbose = FALSE, trace = FALSE, u = NULL)
awslinsd(y, hmax = NULL, hpre = NULL, h0 = NULL, mask = NULL,
    ladjust = 1, wghts = NULL, varprop = 0.1, A0, A1)
AFLocalSigma(y, ncoils, level = NULL, mask = NULL, h = 2, hadj = 1,
    vext = c(1, 1))
estGlobalSigma(y, mask = NULL, ncoils = 1, steps = 16, vext = c(1, 1),
    lambda = 20, hinit = 2, hadj = 1, q = 0.25, level = NULL,
    sequence = FALSE, method = c("awsVar", "awsMAD", "AFmodevn",
                "AFmodem1chi", "AFbkm2chi", "AFbkm1chi"))
estimateSigmaCompl(magnitude, phase, mask, kstar = 20, kmin = 8, hsig = 5,
        lambda = 12, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="awsLocalSigma_+3A_y">y</code></td>
<td>

<p>3D array of image intensities.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_steps">steps</code></td>
<td>

<p>number of steps in adapive weights smoothing, used to reveal the unerlying
mean structure.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_mask">mask</code></td>
<td>

<p>restrict computations to voxel in mask, if <code>is.null(mask)</code> all voxel are used.
In function <code>estGlobalSigma</code> mask should refer to background for <code>method %in% c("modem1chi","bkm2chi","bkm1chi")</code> and to voxel within the head for
<code>method=="modevn"</code>.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_ncoils">ncoils</code></td>
<td>

<p>effective number of coils, or equivalently number of effective degrees of freedom of non-central chi distribution divided by 2.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_vext">vext</code></td>
<td>

<p>voxel extentions or relative voxel extensions
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_lambda">lambda</code></td>
<td>

<p>scale parameter in adaptive weights smoothing
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_minni">minni</code></td>
<td>

<p>minimal bandwidth for calculating local variance estimates
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_hsig">hsig</code></td>
<td>

<p>bandwwidth for median filter
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_sigma">sigma</code></td>
<td>

<p>optional initial global variance estimate
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_family">family</code></td>
<td>

<p>type of distribution, either noncentral Chi (&quot;NCchi&quot;) or Gaussian (&quot;Gauss&quot;)
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_verbose">verbose</code></td>
<td>

<p>if <code>verbose==TRUE</code> density plots
and quantiles of local estimates of <code>sigma</code> are provided.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_trace">trace</code></td>
<td>

<p>if <code>trace==TRUE</code> intermediate results for each step are
returned in component tergs for all voxel in mask.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_u">u</code></td>
<td>
<p>if <code>verbose==TRUE</code> an array of noncentrality paramters for
comparisons. Internal use for tests only
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_hmax">hmax</code></td>
<td>

<p>maximal bandwidth
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_hpre">hpre</code></td>
<td>

<p>minimal bandwidth
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_h0">h0</code></td>
<td>

<p>bandwidth vector characterizing to spatial correlation as correlation induced
by convolution with a Gaussian kernel
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_ladjust">ladjust</code></td>
<td>

<p>correction factor for lambda
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_wghts">wghts</code></td>
<td>

<p>relative voxel extensions
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_varprop">varprop</code></td>
<td>

<p>defines a lower bound for the estimated variance as <code>varprop*mean(sigma2hat</code>
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_a0">A0</code></td>
<td>

<p>select voxel with <code>A0 &lt; theta &lt; A1</code> to estimate parameters of the variance model
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_a1">A1</code></td>
<td>

<p>select voxel with <code>A0 &lt; theta &lt; A1</code> to estimate parameters of the variance model
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_level">level</code></td>
<td>

<p>threshold for mask definition
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_h">h</code></td>
<td>

<p>bandwidth for local variance estimates.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_hinit">hinit</code></td>
<td>

<p>minimal bandwidth for local variance estimates with <code>method="awsxxx"</code>.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_hadj">hadj</code></td>
<td>

<p>bandwidth for mode estimation
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_q">q</code></td>
<td>

<p>Quantile for interquantile estimate of standard deviation
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_sequence">sequence</code></td>
<td>

<p>logical, return sequence of estimated variances for iterative methods.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_method">method</code></td>
<td>

<p>determines variance estimation method
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_magnitude">magnitude</code></td>
<td>

<p>magnitude of complex 3D image
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_phase">phase</code></td>
<td>

<p>phase of complex 3D image
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_kstar">kstar</code></td>
<td>

<p>number of steps in adapive weights smoothing, used to reveal the unerlying
mean structure.
</p>
</td></tr>
<tr><td><code id="awsLocalSigma_+3A_kmin">kmin</code></td>
<td>

<p>iteration to start adaptation
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>all functions return lists with variance estimates in component <code>sigma</code>
</p>


<h3>Author(s)</h3>

<p>J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>K. Tabelow, H.U. Voss, J. Polzehl, Local estimation of the noise level in MRI using
structural adaptation, Medical Image Analysis, 20 (2015), 76&ndash;86. DOI:10.1016/j.media.2014.10.008.
</p>
<p>S. Aja-Fernandez, V. Brion, A. Tristan-Vega, Effective noise estimation and
filtering from correlated multiple-coil MR data. Magn Reson Imaging, 31 (2013), 272-285.
DOI:10.1016/j.mri.2012.07.006
</p>
<p>S. Aja-Fernandez, A. Tristan-Vega, C. Alberola-Lopez, Noise estimation in
single- and multiple-coil magnetic resonance data based on statistical models.
Magn Reson Imaging, 27 (2009), 1397-1409. DOI:10.1016/j.mri.2009.05.025.
</p>

<hr>
<h2 id='awssegment-class'>Class <code>"awssegment"</code></h2><span id='topic+awssegment-class'></span>

<h3>Description</h3>

<p>The <code>"aws"</code> class is 
used for objects obtained by functions <code>aws.segment</code>
</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls to functions <code>aws.segment</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code>, usually empty. </p>
</dd>
<dt><code>y</code>:</dt><dd><p>Object of class <code>"array"</code> containing the original (response) data </p>
</dd>
<dt><code>dy</code>:</dt><dd><p>Object of class <code>"numeric"</code> dimension attribute of <code>y</code> </p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> if provided the design points</p>
</dd>
<dt><code>ni</code>:</dt><dd><p>Object of class <code>"numeric"</code> sum of weights used in final estimate </p>
</dd>
<dt><code>mask</code>:</dt><dd><p>Object of class <code>"logical"</code> mask of design points where computations are performed </p>
</dd>
<dt><code>segment</code>:</dt><dd><p>Object of class <code>"array"</code> segmentation results 
(3 segments coded by <code>c(-1, 0, 1)</code>)</p>
</dd>
<dt><code>level</code>:</dt><dd><p>Object of class <code>"numeric"</code> center of segment <code>0</code> </p>
</dd>
<dt><code>delta</code>:</dt><dd><p>Object of class <code>"numeric"</code> half width of segment <code>0</code> </p>
</dd>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"array"</code> ~~ </p>
</dd>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"array"</code> containes the smoothed object and in case
of function <code>lpaws</code> its derivatives up to the specified degree. 
Dimension is <code>dim(theta)=c(dy,p)</code></p>
</dd>
<dt><code>mae</code>:</dt><dd><p>Object of class <code>"numeric"</code> Mean absolute error with respect to 
array in argument <code>u</code> if provided. </p>
</dd>
<dt><code>var</code>:</dt><dd><p>Object of class <code>"numeric"</code> pointwise variance of 
<code>theta[...,1]</code></p>
</dd>
<dt><code>xmin</code>:</dt><dd><p>Object of class <code>"numeric"</code> not used </p>
</dd>
<dt><code>xmax</code>:</dt><dd><p>Object of class <code>"numeric"</code> not used</p>
</dd>
<dt><code>wghts</code>:</dt><dd><p>Object of class <code>"numeric"</code> weights used in location penalty for 
different coordinate directions </p>
</dd>
<dt><code>degree</code>:</dt><dd><p>not used </p>
</dd>
<dt><code>hmax</code>:</dt><dd><p>Object of class <code>"numeric"</code> maximal bandwidth </p>
</dd>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> estimated error variance </p>
</dd>
<dt><code>scorr</code>:</dt><dd><p>Object of class <code>"numeric"</code> estimated spatial correlation </p>
</dd>
<dt><code>family</code>:</dt><dd><p>Object of class <code>"character"</code> distribution of <code>y</code>,
can be any of <code>c("Gaussian","Bernoulli","Poisson","Exponential",
           "Volatility","Variance")</code> </p>
</dd>
<dt><code>shape</code>:</dt><dd><p>Object of class <code>"numeric"</code> possible shape parameter of distribution of <code>y</code></p>
</dd>
<dt><code>lkern</code>:</dt><dd><p>Object of class <code>"integer"</code> location kernel, can be 
any of <code>c("Triangle","Quadratic","Cubic","Plateau","Gaussian")</code>, defauts to 
<code>"Triangle"</code></p>
</dd>
<dt><code>lambda</code>:</dt><dd><p>Object of class <code>"numeric"</code> scale parameter used in adaptation</p>
</dd>
<dt><code>ladjust</code>:</dt><dd><p>Object of class <code>"numeric"</code> factor to adjust scale parameter with respect to its
predetermined default. </p>
</dd>
<dt><code>aws</code>:</dt><dd><p>Object of class <code>"logical"</code> Adaptation by Propagation-Separation  </p>
</dd>
<dt><code>memory</code>:</dt><dd><p>Object of class <code>"logical"</code> Adaptation by Stagewise Aggregation </p>
</dd>
<dt><code>homogen</code>:</dt><dd><p>Object of class <code>"logical"</code> detect regions of homogeneity (used to speed up
the calculations) currently <code>FALSE</code></p>
</dd>
<dt><code>earlystop</code>:</dt><dd><p>Object of class <code>"logical"</code> currently <code>FALSE</code> </p>
</dd>
<dt><code>varmodel</code>:</dt><dd><p>Object of class <code>"character"</code> variance model used  
currently <code>"Gaussian"</code> </p>
</dd>
<dt><code>vcoef</code>:</dt><dd><p>Object of class <code>"numeric"</code> contains <code>NULL</code> </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class  <code>"call"</code> that created the object. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>extract</dt><dd><p><code>signature(x = "awssegment")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "awssegment")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "awssegment")</code>: ... </p>
</dd>
<dt>risk</dt><dd><p><code>signature(y = "awssegment")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "awssegment")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "awssegment")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aws.segment">aws.segment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("awssegment")
</code></pre>

<hr>
<h2 id='awstestprop'>
Propagation condition for adaptive weights smoothing
</h2><span id='topic+awstestprop'></span><span id='topic+pawstestprop'></span>

<h3>Description</h3>

<p>The function enables testing of the propagation condition in order to select
appropriate values for the parameter <code>lambda</code> in function <code>aws</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awstestprop(dy, hmax, theta = 1, family = "Gaussian", lkern = "Triangle",
            aws = TRUE, memory = FALSE, shape = 2, homogeneous=TRUE, varadapt=FALSE,
            ladjust = 1, spmin=0.25, seed = 1, minlevel=1e-6, maxz=25, diffz=.5,
            maxni=FALSE, verbose=FALSE)
pawstestprop(dy, hmax, theta = 1, family = "Gaussian", lkern = "Triangle",
             aws = TRUE, patchsize=1, shape = 2,
             ladjust = 1, spmin = 0.25, seed = 1, minlevel = 1e-6,
             maxz = 25, diffz = .5, maxni = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="awstestprop_+3A_dy">dy</code></td>
<td>
<p> Dimension of grid used in 1D, 2D or 3D. May also be specified as an array of values.
In this case data are generated with parameters <code>dy-mean(dy)+theta</code> and the propagation condition
is testet as if <code>theta</code> is the true parameter. This can be used to study properties for a
slighty misspecified structural assumption.
</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_hmax">hmax</code></td>
<td>

<p>Maximum bandwidth.
</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_theta">theta</code></td>
<td>

<p>Parameter determining the distribution in case of
<code>family %in% c("Poisson","Bernoulli")</code>
</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_family">family</code></td>
<td>

<p><code>family</code> specifies the probability distribution. Default is <code>family="Gaussian"</code>, also implemented
are &quot;Bernoulli&quot;, &quot;Poisson&quot;, &quot;Exponential&quot;, &quot;Volatility&quot;, &quot;Variance&quot; and &quot;NCchi&quot;. <code>family="Volatility"</code> specifies a Gaussian distribution with
expectation 0 and unknown variance. <code>family="Volatility"</code> specifies that <code>p*y/theta</code> is distributed as <code class="reqn">\chi^2</code> with <code>p=shape</code>
degrees of freedom. <code>family="NCchi"</code> uses a noncentral Chi distribution with <code>p=shape</code> degrees of freedom and noncentrality parameter <code>theta</code>.
</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_lkern">lkern</code></td>
<td>

<p>character: location kernel, either &quot;Triangle&quot;, &quot;Plateau&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_aws">aws</code></td>
<td>

<p>logical: if TRUE structural adaptation (AWS) is used. </p>
</td></tr>
<tr><td><code id="awstestprop_+3A_patchsize">patchsize</code></td>
<td>

<p>patchsize in case of paws. </p>
</td></tr>
<tr><td><code id="awstestprop_+3A_memory">memory</code></td>
<td>

<p>logical: if TRUE stagewise aggregation is used as an additional
adaptation scheme.</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_shape">shape</code></td>
<td>

<p>Allows to specify an additional shape parameter for certain family models. Currently only used for family=&quot;Variance&quot;, that is <code class="reqn">\chi</code>-Square distributed observations
with <code>shape</code> degrees of freedom.</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_homogeneous">homogeneous</code></td>
<td>

<p>if <code>homgeneous==FALSE</code> and <code>family==Gaussian</code> then create heterogeneous variances according to
a chi-squared distribution with number of degrees of freedom given by <code>sphere</code></p>
</td></tr>
<tr><td><code id="awstestprop_+3A_varadapt">varadapt</code></td>
<td>

<p>if <code>varadapt==TRUE</code> use inverse of variance reduction instead of sum of weights in definition of statistical penalty.</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_ladjust">ladjust</code></td>
<td>

<p>Factor to increase the default value of lambda </p>
</td></tr>
<tr><td><code id="awstestprop_+3A_spmin">spmin</code></td>
<td>
<p>Determines the form (size of the plateau) in the adaptation kernel.
Not to be changed by the user.</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_seed">seed</code></td>
<td>
<p>Seed value for random generator.</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_minlevel">minlevel</code></td>
<td>
<p>Minimum exceedence probability to use in contour plots.</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_maxz">maxz</code></td>
<td>
<p>Maximum of z-scale in plots.</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_diffz">diffz</code></td>
<td>
<p>Gridlength in z</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_maxni">maxni</code></td>
<td>
<p>If TRUE use <code class="reqn">max_{l&lt;=k}(N_i^{(l)}</code> instead of <code class="reqn">(N_i^{(k)}</code> in the definition of the statistical penalty.</p>
</td></tr>
<tr><td><code id="awstestprop_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE provide additional information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates exceedence probabilities
</p>
<p>Results for intermediate steps are provided as contour plots. For a good choice of lambda
(ladjust) the contours up to probabilities of <code>1e-5</code> should be vertical.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p>Sequence of bandwidths used</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p><code>seq(0,30,.5)</code>, the quantiles exceedence probabilities refer to</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>the matrix of exceedence probabilities, columns corresponding to <code>h</code></p>
</td></tr>
<tr><td><code>probna</code></td>
<td>
<p>the matrix of exceedence probabilities for corresponding nonadaptive estimates, columns corresponding to <code>h</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>S. Becker, P. Mathe, Electron. J. Statist. (2013), 2702-2736, doi:10.1214/13-EJS860

</p>


<h3>See Also</h3>

<p><code><a href="#topic+aws">aws</a></code>
</p>

<hr>
<h2 id='awsweights'>Generate weight scheme that would be used in an additional aws step
</h2><span id='topic+awsweights'></span>

<h3>Description</h3>

<p>Utility function to create a weighting scheme for an additional aws step.
Inteded to be used for illustrations only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awsweights(awsobj, spmin = 0.25, inx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="awsweights_+3A_awsobj">awsobj</code></td>
<td>

<p>object obtained by a call to function <code>aws</code>
</p>
</td></tr>
<tr><td><code id="awsweights_+3A_spmin">spmin</code></td>
<td>

<p>Size of the plateau in the adaptation kernel. 
</p>
</td></tr>
<tr><td><code id="awsweights_+3A_inx">inx</code></td>
<td>

<p>either a matrix of dimension length(awsobj@dy) x number of points
containing the integer coordinates of points of interest
or 
NULL. In the latter case the weight scheme for all points is
generated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array of either dimension
awsobj@dy x number of points or awsobj@dy x awsobj@dy





</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>, 
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a>

</p>


<h3>References</h3>

<p>Joerg Polzehl, Vladimir Spokoiny,  Adaptive Weights Smoothing with applications to image restoration,  J. R. Stat. Soc. Ser. B Stat. Methodol.  62 ,  (2000)  , pp. 335&ndash;354
</p>
<p>Joerg Polzehl, Vladimir Spokoiny,  Propagation-separation approach for local likelihood estimation,  Probab. Theory Related Fields  135 (3),  (2006)  , pp. 335&ndash;362.
</p>
<p>Joerg Polzehl, Kostas Papafitsoros, Karsten Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06.
</p>



<h3>See Also</h3>

<p>See also  <code><a href="#topic+aws">aws</a></code>
</p>

<hr>
<h2 id='binning'> Binning in 1D, 2D or 3D</h2><span id='topic+binning'></span>

<h3>Description</h3>

<p>The function performs a binning in 1D, 2D or 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binning(x, y, nbins, xrange = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binning_+3A_x">x</code></td>
<td>
<p> design matrix, dimension n x d, <code>d %in% 1:3</code>. </p>
</td></tr>
<tr><td><code id="binning_+3A_y">y</code></td>
<td>
<p> either a response vector of length n or NULL </p>
</td></tr>
<tr><td><code id="binning_+3A_nbins">nbins</code></td>
<td>
<p> vector of length d containing number of bins for each dimension,
may be set to NULL </p>
</td></tr>
<tr><td><code id="binning_+3A_xrange">xrange</code></td>
<td>
<p> range for endpoints of bins for each dimension, either matrix
of dimension 2 x d or NULL. <code>xrange</code> is increased if the cube defined  does not contain all design points. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>matrix of coordinates of non-empty bin centers </p>
</td></tr>
<tr><td><code>x.freq</code></td>
<td>
<p>number of observations in nonempty bins</p>
</td></tr>
<tr><td><code>midpoints.x1</code></td>
<td>
<p>Bin centers in dimension 1</p>
</td></tr>
<tr><td><code>midpoints.x2</code></td>
<td>
<p>if <code>d&gt;1</code> Bin centers in dimension 2</p>
</td></tr>
<tr><td><code>midpoints.x3</code></td>
<td>
<p>if <code>d&gt;2</code> Bin centers in dimension 3</p>
</td></tr>
<tr><td><code>breaks.x1</code></td>
<td>
<p>Break points dimension 1</p>
</td></tr>
<tr><td><code>breaks.x2</code></td>
<td>
<p>if <code>d&gt;1</code> Break points dimension 2</p>
</td></tr>
<tr><td><code>breaks.x3</code></td>
<td>
<p>if <code>d&gt;2</code> Break points dimension 3</p>
</td></tr>
<tr><td><code>table.freq</code></td>
<td>
<p>number of observations per bin</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>if <code>!is.null(y)</code> mean of y in non-empty bins</p>
</td></tr>
<tr><td><code>devs</code></td>
<td>
<p>if <code>!is.null(y)</code> standard deviations of y in non-empty bins</p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function has been adapted from the code of function binning in package sm.
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+aws.irreg">aws.irreg</a></code> </p>

<hr>
<h2 id='extract-methods'> Methods for Function <code>extract</code> in Package <span class="pkg">aws</span></h2><span id='topic+extract-methods'></span><span id='topic+extract+2CANY-method'></span><span id='topic+extract+2Caws-method'></span><span id='topic+extract+2Cawssegment-method'></span><span id='topic+extract+2CICIsmooth-method'></span><span id='topic+extract+2Ckernsm-method'></span>

<h3>Description</h3>

<p>The method extract and/or compute specified statistics from object of class 
<code>"aws"</code>, <code>"awssegment"</code>, <code>ICIsmooth</code> and <code>"kernsm"</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'aws'
extract(x, what="y")
  ## S4 method for signature 'awssegment'
extract(x, what="y")
  ## S4 method for signature 'ICIsmooth'
extract(x, what="y")
  ## S4 method for signature 'kernsm'
extract(x, what="y")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract-methods_+3A_x">x</code></td>
<td>
<p> object </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_what">what</code></td>
<td>
<p>Statistics to extract, defaults to <code>what="y"</code> corresponding to the 
original data (response variable). Alternatives are
<code>what="yhat"</code> for the smoothed response, <code>what="vhat"</code> for the 
estimated variance of the smoothed response, <code>what="sigma2"</code> for the 
estimated error variance of the original data, <code>what="vred"</code> for the variance
reduction achieved and in case of <code>signature(x = "ICIsmooth")</code> 
<code>what="hbest"</code>
for the selected bandwidth. A vector of any of these choices may be provided.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>
<p>Returns a message that method <code>extract</code>  is not defined.
</p>
</dd>
<dt><code>signature(x = "aws")</code></dt><dd>
<p>Returns a list with components containing the requested statistics. Component names correspond to
<code>tolower(what)</code>  
</p>
</dd>
<dt><code>signature(x = "awssegment")</code></dt><dd>
<p>Returns a list with components containing the requested statistics. Component names correspond to
<code>tolower(what)</code>  
</p>
</dd>
<dt><code>signature(x = "ICIsmooth")</code></dt><dd>
<p>Returns a list with components containing the requested statistics. Component names correspond to
<code>tolower(what)</code>.  
</p>
</dd>
<dt><code>signature(x = "kernsm")</code></dt><dd>
<p>Returns a list with components containing the requested statistics. Component names correspond to
<code>tolower(what)</code>.  
</p>
</dd>
</dl>

<hr>
<h2 id='ICIcombined'>
Adaptive smoothing by Intersection of Confidence Intervals (ICI) using multiple windows
</h2><span id='topic+ICIcombined'></span>

<h3>Description</h3>

<p>The function performs adaptive smoothing by Intersection of Confidence Intervals (ICI)
using multiple windows as described in Katkovnik et al (2006)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICIcombined(y, hmax, hinc = 1.45, thresh = NULL, kern = "Gaussian", m = 0,
            sigma = NULL, nsector = 1, symmetric = FALSE, presmooth = FALSE,
            combine = "weighted", unit = c("SD","FWHM"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICIcombined_+3A_y">y</code></td>
<td>
<p>Object of class <code>"array"</code> containing the original (response) data
on a grid
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_hmax">hmax</code></td>
<td>

<p>maximum bandwidth
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_hinc">hinc</code></td>
<td>

<p>factor used to increase the bandwidth from scale to scale
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_thresh">thresh</code></td>
<td>

<p>threshold used in tests to determine the best scale
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_kern">kern</code></td>
<td>
<p>Determines the kernel function.
Object of class <code>"character"</code> kernel, can be any of
<code>c("Gaussian","Uniform","Triangle","Epanechnicov","Biweight","Triweight")</code>.
Defaults to <code>kern="Gaussian"</code>.
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_m">m</code></td>
<td>

<p>Object of class <code>"integer"</code> vector of length <code>length(dy)</code>
determining the order of derivatives specified for the coordinate directios.</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_sigma">sigma</code></td>
<td>

<p>error standard deviation
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_nsector">nsector</code></td>
<td>

<p>number of sectors to use.
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_symmetric">symmetric</code></td>
<td>

<p>Object of class <code>"logical"</code> determines if sectors are symmetric with respect to
the origin.
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_presmooth">presmooth</code></td>
<td>

<p>Object of class <code>"logical"</code> determines if bandwidths are  smoothed
for more stable results.
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_combine">combine</code></td>
<td>

<p>Either <code>"weighted"</code> or <code>"minvar"</code>. Determines how whether to combine
sectorial results a weighted (with inverse variance) mean or to chose the sectorial
estimate with minimal variance.
</p>
</td></tr>
<tr><td><code id="ICIcombined_+3A_unit">unit</code></td>
<td>

<p>How should the bandwidth be interpreted in case of a Gaussian kernel.
For <code>"SD"</code> the bandwidth refers to the standard deviation of the
kernel while <code>"FWHM"</code> interprets the banwidth in terms of Full Width Half
Maximum of the kernel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This mainly follows Chapter 6.2 in Katkovnik et al (2006).
</p>


<h3>Value</h3>

<p>An object of class <code>ICIsmooth</code>
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06.
</p>
<p>V. Katkovnik, K. Egiazarian and J. Astola,
<em>Local Approximation Techniques in Signal And Image Processing</em>,
SPIE Society of Photo-Optical Instrumentation Engin., 2006, PM157
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICIsmooth">ICIsmooth</a></code>, <code><a href="#topic+ICIsmooth-class">ICIsmooth-class</a></code>, <code><a href="#topic+kernsm">kernsm</a></code>
</p>

<hr>
<h2 id='ICIsmooth'>
Adaptive smoothing by Intersection of Confidence Intervals (ICI)
</h2><span id='topic+ICIsmooth'></span>

<h3>Description</h3>

<p>The function performs adaptive smoothing by Intersection of Confidence Intervals (ICI)
as described in Katkovnik et al (2006)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICIsmooth(y, hmax, hinc = 1.45, thresh = NULL, kern = "Gaussian", m = 0,
          sigma = NULL, nsector = 1, sector = 1, symmetric = FALSE,
          presmooth = FALSE, unit = c("SD","FWHM"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICIsmooth_+3A_y">y</code></td>
<td>
<p>Object of class <code>"array"</code> containing the original (response) data
on a grid
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_hmax">hmax</code></td>
<td>

<p>maximum bandwidth
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_hinc">hinc</code></td>
<td>

<p>factor used to increase the bandwidth from scale to scale
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_thresh">thresh</code></td>
<td>

<p>threshold used in tests to determine the best scale
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_kern">kern</code></td>
<td>
<p>Determines the kernel function.
Object of class <code>"character"</code> kernel, can be any of
<code>c("Gaussian","Uniform","Triangle","Epanechnicov","Biweight","Triweight")</code>.
Defaults to <code>kern="Gaussian"</code>.
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_m">m</code></td>
<td>

<p>Object of class <code>"integer"</code> vector of length <code>length(dy)</code>
determining the order of derivatives specified for the coordinate directios.</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_sigma">sigma</code></td>
<td>

<p>error standard deviation
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_nsector">nsector</code></td>
<td>

<p>number of sectors to use. Positive weights are restricted to the sector
selected by <code>sector</code>
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_sector">sector</code></td>
<td>

<p>Object of class <code>"integer"</code> between <code>1</code> and <code>nsector</code>. sector used.
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_symmetric">symmetric</code></td>
<td>

<p>Object of class <code>"logical"</code> determines if sectors are symmetric with respect to the origin.
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_presmooth">presmooth</code></td>
<td>

<p>Object of class <code>"logical"</code> determines if bandwidths are  smoothed
for more stable results.
</p>
</td></tr>
<tr><td><code id="ICIsmooth_+3A_unit">unit</code></td>
<td>

<p>How should the bandwidth be interpreted in case of a Gaussian kernel.
For <code>"SD"</code> the bandwidth refers to the standard deviation of the
kernel while <code>"FWHM"</code> interprets the banwidth in terms of Full Width Half
Maximum of the kernel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This mainly follows Chapter 6.1 in Katkovnik et al (2006).
</p>


<h3>Value</h3>

<p>An object of class <code>ICIsmooth</code>
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06.
</p>
<p>V. Katkovnik, K. Egiazarian and J. Astola,
<em>Local Approximation Techniques in Signal And Image Processing</em>,
SPIE Society of Photo-Optical Instrumentation Engin., 2006, PM157
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICIcombined">ICIcombined</a></code>, <code><a href="#topic+ICIsmooth-class">ICIsmooth-class</a></code>, <code><a href="#topic+kernsm">kernsm</a></code>
</p>

<hr>
<h2 id='ICIsmooth-class'>Class <code>"ICIsmooth"</code></h2><span id='topic+ICIsmooth-class'></span>

<h3>Description</h3>

<p>The <code>"ICIsmooth"</code> class is 
used for objects obtained by functions <code>ICIsmooth</code> and <code>ICIcombined</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ICIsmooth", ...)</code>
or by functions <code>ICIsmooth</code> and <code>ICIcombined</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code>, usually empty. </p>
</dd>
<dt><code>y</code>:</dt><dd><p>Object of class <code>"array"</code> containing the original (response) data </p>
</dd>
<dt><code>dy</code>:</dt><dd><p>Object of class <code>"numeric"</code> dimension attribute of <code>y</code> </p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> if provided the design points</p>
</dd>
<dt><code>hmax</code>:</dt><dd><p>Object of class <code>"numeric"</code> maximum bandwidth </p>
</dd>
<dt><code>hinc</code>:</dt><dd><p>Object of class <code>"numeric"</code> initial bandwidth </p>
</dd>
<dt><code>thresh</code>:</dt><dd><p>Object of class <code>"numeric"</code> threshold used for bandwidth selection </p>
</dd>
<dt><code>kern</code>:</dt><dd><p>Object of class <code>"character"</code> kernel, can be any of
<code>c("Gaussian","Uniform","Triangle","Epanechnicov","Biweight","Triweight")</code>.
Defaults to <code>kern="Gaussian"</code>. </p>
</dd>
<dt><code>m</code>:</dt><dd><p>Object of class <code>"integer"</code> vector of length <code>length(dy)</code> 
determining the order of derivatives specified for the coordinate directios.</p>
</dd>
<dt><code>nsector</code>:</dt><dd><p>Object of class <code>"integer"</code> number of sectors to use. </p>
</dd>
<dt><code>sector</code>:</dt><dd><p>Object of class <code>"integer"</code> sector used. </p>
</dd>
<dt><code>symmetric</code>:</dt><dd><p>Object of class <code>"logical"</code> sectors are symmetric with respect to the origin. </p>
</dd>
<dt><code>yhat</code>:</dt><dd><p>Object of class <code>"array"</code> smoothed response variable </p>
</dd>
<dt><code>vhat</code>:</dt><dd><p>Object of class <code>"array"</code> estimated variance of smoothed response variable </p>
</dd>
<dt><code>hbest</code>:</dt><dd><p>Object of class <code>"array"</code> selected bandwidth(s)) </p>
</dd>
<dt><code>sigma</code>:</dt><dd><p>Object of class <code>"numeric"</code> estimated standard deviation of errors in <code>y</code> </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class  <code>"call"</code> that created the object.  </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>extract</dt><dd><p><code>signature(x = "ICIsmooth")</code>: ... </p>
</dd>
<dt>risk</dt><dd><p><code>signature(y = "ICIsmooth")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p> Method for Function &lsquo;plot&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>show</dt><dd><p> Method for Function &lsquo;show&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>print</dt><dd><p> Method for Function &lsquo;print&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>summary</dt><dd><p> Method for Function &lsquo;summary&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>V. Katkovnik, K. Egiazarian and J. Astola, 
<em>Local Approximation Techniques in Signal And Image Processing</em>,
SPIE Society of Photo-Optical Instrumentation Engin., 2006, PM157
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICIsmooth">ICIsmooth</a></code>, <code><a href="#topic+ICIcombined">ICIcombined</a></code>, <code><a href="#topic+kernsm">kernsm</a></code>, <code><a href="#topic+aws">aws</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ICIsmooth")
</code></pre>

<hr>
<h2 id='kernsm'>
Kernel smoothing on a 1D, 2D or 3D grid
</h2><span id='topic+kernsm'></span>

<h3>Description</h3>

<p>Performs Kernel smoothing on a 1D, 2D or 3D grid by fft
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernsm(y, h = 1, kern = "Gaussian", m = 0, nsector = 1, sector = 1,
       symmetric = FALSE, unit = c("SD","FWHM"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernsm_+3A_y">y</code></td>
<td>

<p>Object of class <code>"array"</code> containing the original (response) data
on a grid
</p>
</td></tr>
<tr><td><code id="kernsm_+3A_h">h</code></td>
<td>

<p>bandwidth
</p>
</td></tr>
<tr><td><code id="kernsm_+3A_kern">kern</code></td>
<td>

<p>Determines the kernel function.
Object of class <code>"character"</code> kernel, can be any of
<code>c("Gaussian","Uniform","Triangle","Epanechnicov","Biweight","Triweight")</code>.
Defaults to <code>kern="Gaussian"</code>
</p>
</td></tr>
<tr><td><code id="kernsm_+3A_m">m</code></td>
<td>

<p>Object of class <code>"integer"</code> vector of length <code>length(dy)</code>
determining the order of derivatives specified for the coordinate directios.</p>
</td></tr>
<tr><td><code id="kernsm_+3A_nsector">nsector</code></td>
<td>

<p>number of sectors to use. Positive weights are restricted to the sector
selected by <code>sector</code>
</p>
</td></tr>
<tr><td><code id="kernsm_+3A_sector">sector</code></td>
<td>

<p>Object of class <code>"integer"</code> between <code>1</code> and <code>nsector</code>. sector used.
</p>
</td></tr>
<tr><td><code id="kernsm_+3A_symmetric">symmetric</code></td>
<td>

<p>Object of class <code>"logical"</code> determines if sectors are symmetric with respect to the origin.
</p>
</td></tr>
<tr><td><code id="kernsm_+3A_unit">unit</code></td>
<td>

<p>How should the bandwidth be interpreted in case of a Gaussian kernel.
For <code>"SD"</code> the bandwidth refers to the standard deviation of the
kernel while <code>"FWHM"</code> interprets the banwidth in terms of Full Width Half
Maximum of the kernel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of <code>any(m&gt;0)</code> derivative kernels are generated and applied for the
corresponding coordinate directions. If <code>nsector&gt;1</code> the support of the kernel
is restricted to a circular sector determined by <code>sector</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>kernsm</code>
</p>


<h3>Author(s)</h3>


<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06 .
</p>
<p>V. Katkovnik, K. Egiazarian and J. Astola,
<em>Local Approximation Techniques in Signal And Image Processing</em>,
SPIE Society of Photo-Optical Instrumentation Engin., 2006, PM157
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernsm-class">kernsm-class</a></code>, <code><a href="#topic+ICIsmooth">ICIsmooth</a></code>,<code><a href="#topic+ICIcombined">ICIcombined</a></code>

</p>

<hr>
<h2 id='kernsm-class'>Class <code>"kernsm"</code></h2><span id='topic+kernsm-class'></span>

<h3>Description</h3>

<p>This class refers to objects created by function kernsm. These objects
contain 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("kernsm", ...). they are usually
created by a call to function{kernsm}</code>.

</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code>, usually empty. </p>
</dd>
<dt><code>y</code>:</dt><dd><p>Object of class <code>"array"</code> containing the response in
nonparametric regression. The design is assumed to be a 1D, 2D or 3D grid,
with dimensionality determined by <code>dim(y)</code>. </p>
</dd>
<dt><code>dy</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing dim(y). </p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> currently not used.  </p>
</dd>
<dt><code>h</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the bandwidth employed. </p>
</dd>
<dt><code>kern</code>:</dt><dd><p>Object of class <code>"character"</code> determining the kernel that was used,
can be one of <code>c("Gaussian","Uniform","Triangle","Epanechnikov","Biweight","Triweight")</code> </p>
</dd>
<dt><code>m</code>:</dt><dd><p>Object of class <code>"integer"</code> with length <code>length(dy)</code> determining the
order of derivatives in the corresponding coordinate directions. If <code>m[i6&gt;0]</code> a
dirivative kernel derived from <code>kern</code> has been used for the 
corresponding coordinate direction. </p>
</dd>
<dt><code>nsector</code>:</dt><dd><p>Object of class <code>"integer"</code>. If <code>nsector&gt;1</code> positive weights 
are restricted to a segment of a circle (1D or 2D only). The segment is given by
<code>sector</code>.</p>
</dd>
<dt><code>sector</code>:</dt><dd><p>Object of class <code>"integer"</code> containing the number of the segment 
used in case of <code>nsector&gt;1</code> </p>
</dd>
<dt><code>symmetric</code>:</dt><dd><p>Object of class <code>"logical"</code> determines if the sector is mirrored at the origin. </p>
</dd>
<dt><code>yhat</code>:</dt><dd><p>Object of class <code>"array"</code> with same size and dimension as <code>y</code> providing
the convolution of <code>y</code> with the chosen kernel. </p>
</dd>
<dt><code>vred</code>:</dt><dd><p>Object of class <code>"array"</code> Variance reduction achieved by convolution
assuming independence. </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"function"</code>, call that created the object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>extract</dt><dd><p><code>signature(x = "aws")</code>: ... </p>
</dd>
<dt>risk</dt><dd><p><code>signature(y = "aws")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p> Method for Function &lsquo;plot&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>show</dt><dd><p> Method for Function &lsquo;show&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>print</dt><dd><p> Method for Function &lsquo;print&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
<dt>summary</dt><dd><p> Method for Function &lsquo;summary&rsquo; in Package &lsquo;aws&rsquo;. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernsm">kernsm</a></code>, 
<code><a href="#topic+ICIsmooth">ICIsmooth</a></code>, 
<code><a href="#topic+ICIcombined">ICIcombined</a></code>, 
<code><a href="#topic+ICIsmooth-class">ICIsmooth</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("kernsm")
</code></pre>

<hr>
<h2 id='lpaws'>Local polynomial smoothing by AWS</h2><span id='topic+lpaws'></span>

<h3>Description</h3>

<p>The function allows for structural adaptive smoothing using a local
polynomial (degree &lt;=2) structural assumption. Response variables are assumed to be observed on a 1 or 2 dimensional regular grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpaws(y, degree = 1, hmax = NULL, aws = TRUE, memory = FALSE, lkern = "Triangle",
      homogen = TRUE, earlystop = TRUE, aggkern = "Uniform", sigma2 = NULL,
      hw = NULL, ladjust = 1, u = NULL, graph = FALSE, demo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpaws_+3A_y">y</code></td>
<td>
<p>Response, either a vector (1D) or matrix (2D). The corresponding design is assumed to be a regular grid in 1D or 2D, respectively. </p>
</td></tr>
<tr><td><code id="lpaws_+3A_degree">degree</code></td>
<td>
<p>Polynomial degree of the local model </p>
</td></tr>
<tr><td><code id="lpaws_+3A_hmax">hmax</code></td>
<td>
<p> maximal bandwidth </p>
</td></tr>
<tr><td><code id="lpaws_+3A_aws">aws</code></td>
<td>
<p> logical: if TRUE structural adaptation (AWS) is used. </p>
</td></tr>
<tr><td><code id="lpaws_+3A_memory">memory</code></td>
<td>
<p> logical: if TRUE stagewise aggregation is used as an additional
adaptation scheme. </p>
</td></tr>
<tr><td><code id="lpaws_+3A_lkern">lkern</code></td>
<td>
<p> character: location kernel, either &quot;Triangle&quot;, &quot;Plateau&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot; or &quot;Gaussian&quot;.
The default &quot;Triangle&quot; is equivalent to using an Epanechnikov kernel, &quot;Quadratic&quot; and  &quot;Cubic&quot; refer to a Bi-weight and Tri-weight
kernel, see Fan and Gijbels (1996). &quot;Gaussian&quot; is a truncated (compact support) Gaussian kernel.
This is included for comparisons only and should be avoided due to its large computational costs.</p>
</td></tr>
<tr><td><code id="lpaws_+3A_homogen">homogen</code></td>
<td>
<p> logical: if TRUE the function tries to determine regions
where weights can be fixed to 1. This may increase speed.</p>
</td></tr>
<tr><td><code id="lpaws_+3A_earlystop">earlystop</code></td>
<td>
<p> logical: if TRUE the function tries to determine points
where the homogeneous region is unlikely to change in further steps. This may increase speed.</p>
</td></tr>
<tr><td><code id="lpaws_+3A_aggkern">aggkern</code></td>
<td>
<p> character: kernel used in stagewise aggregation, either &quot;Triangle&quot; or &quot;Uniform&quot; </p>
</td></tr>
<tr><td><code id="lpaws_+3A_sigma2">sigma2</code></td>
<td>
<p> Error variance, the value is estimated if not provided. </p>
</td></tr>
<tr><td><code id="lpaws_+3A_hw">hw</code></td>
<td>
<p> Regularisation bandwidth, used to prevent from unidentifiability of
local estimates for small bandwidths. </p>
</td></tr>
<tr><td><code id="lpaws_+3A_ladjust">ladjust</code></td>
<td>
<p> factor to increase the default value of lambda </p>
</td></tr>
<tr><td><code id="lpaws_+3A_u">u</code></td>
<td>
<p> a &quot;true&quot; value of the regression function, may be provided to
report risks at each iteration. This can be used to test the propagation condition with <code>u=0</code> </p>
</td></tr>
<tr><td><code id="lpaws_+3A_graph">graph</code></td>
<td>
<p> logical: If TRUE intermediate results are illustrated graphically. May significantly slow down the computations in 2D. Please
avoid using the default <code>X11()</code> on systems build with <code>cairo</code>, use
<code>X11(type="Xlib")</code> instead (faster by a factor of 30). </p>
</td></tr>
<tr><td><code id="lpaws_+3A_demo">demo</code></td>
<td>
<p> logical: if TRUE wait after each iteration </p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns anobject of class <code>aws</code> with slots
</p>
<table>
<tr><td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td></tr>
<tr><td><code>x = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>ni = "integer"</code></td>
<td>
<p>integer(0)</p>
</td></tr>
<tr><td><code>mask = "logical"</code></td>
<td>
<p>logical(0)</p>
</td></tr>
<tr><td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function and derivatives, <code>length: length(y)*(degree+1)</code></p>
</td></tr>
<tr><td><code>mae = "numeric"</code></td>
<td>
<p>Mean absolute error for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates of the regression function. Please note that this does not reflect variability due to randomness of weights.</p>
</td></tr>
<tr><td><code>xmin = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>xmax = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>wghts = "numeric"</code></td>
<td>
<p>numeric(0), ratio of distances <code>wghts[-1]/wghts[1]</code></p>
</td></tr>
<tr><td><code>degree = "integer"</code></td>
<td>
<p>degree</p>
</td></tr>
<tr><td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td></tr>
<tr><td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated error variance</p>
</td></tr>
<tr><td><code>scorr = "numeric"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>family = "character"</code></td>
<td>
<p>&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>shape = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1=&quot;Plateau&quot;, 2=&quot;Triangle&quot;, 3=&quot;Quadratic&quot;, 4=&quot;Cubic&quot;, 5=&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td></tr>
<tr><td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td></tr>
<tr><td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td></tr>
<tr><td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td></tr>
<tr><td><code>homogen = "logical"</code></td>
<td>
<p>homogen</p>
</td></tr>
<tr><td><code>earlystop = "logical"</code></td>
<td>
<p>eralustop</p>
</td></tr>
<tr><td><code>varmodel = "character"</code></td>
<td>
<p>&quot;Constant&quot;</p>
</td></tr>
<tr><td><code>vcoef = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>lpaws</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>If you specify <code>graph=TRUE</code> for 2D problems
avoid using the default <code>X11()</code> on systems build with <code>cairo</code>, use
<code>X11(type="Xlib")</code> instead (faster by a factor of 30).
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>References</h3>

<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06 .
</p>
<p>J. Polzehl, V. Spokoiny, in V. Chen, C.; Haerdle, W. and Unwin, A. (ed.)
Handbook of Data Visualization Structural adaptive smoothing by propagation-separation methods.
Springer-Verlag, 2008, 471-492. DOI:10.1007/978-3-540-33037-0_19.
</p>


<h3>See Also</h3>

<p><code>link{awsdata}</code>,<code><a href="#topic+aws">aws</a></code>, <code><a href="#topic+aws.irreg">aws.irreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(aws)
# 1D local polynomial smoothing
## Not run: demo(lpaws_ex1)
# 2D local polynomial smoothing
## Not run: demo(lpaws_ex2)


</code></pre>

<hr>
<h2 id='nlmeans'>
NLMeans filter in 1D/2D/3D
</h2><span id='topic+nlmeans'></span>

<h3>Description</h3>

<p>Implements the Non-Local-Means Filter of Buades et al 2005
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmeans(x, lambda, sigma, patchhw = 1, searchhw = 7, pd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlmeans_+3A_x">x</code></td>
<td>

<p>1, 2 or 3-dimensional array of obseved response (image intensity) data.
</p>
</td></tr>
<tr><td><code id="nlmeans_+3A_lambda">lambda</code></td>
<td>

<p>scale factor for kernel in image space.
</p>
</td></tr>
<tr><td><code id="nlmeans_+3A_sigma">sigma</code></td>
<td>

<p>error standard deviation (for additive Gaussian errors).
</p>
</td></tr>
<tr><td><code id="nlmeans_+3A_patchhw">patchhw</code></td>
<td>

<p>Half width of patches in each dimension (patchsize is <code>(2*patchhw+1)^d</code>
for d-dimensional array).
</p>
</td></tr>
<tr><td><code id="nlmeans_+3A_searchhw">searchhw</code></td>
<td>

<p>Half width of search area (size of search area is <code>(2searchhw+1)^d</code>
for d-dimensional array)).
</p>
</td></tr>
<tr><td><code id="nlmeans_+3A_pd">pd</code></td>
<td>

<p>If <code>pd &lt; (2*patchhw+1)^d</code> use <code>pd</code> principal components instead
of complete patches.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation follows the description of the Non-Local-Means Filter of
Buades et al 2005 on <a href="http://www.numerical-tours.com/matlab/denoisingadv_6_nl_means/#biblio">http://www.numerical-tours.com/matlab/denoisingadv_6_nl_means/#biblio</a>
that incorporates dimension reduction for patch comparisons by PCA.
</p>


<h3>Value</h3>



<p>A list of class <code>"nlmeans"</code> with components
</p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>Denoised array</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Scale parameter used</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The error standard deviation</p>
</td></tr>
<tr><td><code>patchhw</code></td>
<td>
<p>Half width of patches</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>
<p>Effective patchsize used</p>
</td></tr>
<tr><td><code>searchhw</code></td>
<td>
<p>Half width of search area</p>
</td></tr>
</table>


<h3>Note</h3>

<p>use <code>setCores='number of threads'</code> to enable parallel execution.
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06 .
</p>
<p>A. Buades, B. Coll and J. M. Morel (2006). A review of image denoising algorithms, with a new one.
Simulation, 4, 490-530. DOI:10.1137/040616024.
</p>
<p><a href="http://www.numerical-tours.com/matlab/denoisingadv_6_nl_means/#biblio">http://www.numerical-tours.com/matlab/denoisingadv_6_nl_means/#biblio</a>
</p>

<hr>
<h2 id='paws'>
Adaptive weigths smoothing using patches
</h2><span id='topic+paws'></span><span id='topic+pawsm'></span>

<h3>Description</h3>

<p>The function implements a version the propagation separation approach that
uses patches instead of individuel voxels for comparisons in parameter space. Functionality is analog to function <code><a href="#topic+aws">aws</a></code>. Using patches allows for an improved
handling of locally smooth functions and in 2D and 3D for improved smoothness of
discontinuities at the expense of increased computing time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paws(y, hmax = NULL, mask=NULL, onestep = FALSE, aws = TRUE, family = "Gaussian",
     lkern = "Triangle", aggkern = "Uniform", sigma2 = NULL, shape = NULL,
     scorr = 0, spmin = 0.25, ladjust = 1, wghts = NULL, u = NULL,
     graph = FALSE, demo = FALSE, patchsize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paws_+3A_y">y</code></td>
<td>
<p>array <code>y</code> containing the observe response (image intensity) data.
<code>dim(y)</code> determines the dimensionality and extend of the grid design.
</p>
</td></tr>
<tr><td><code id="paws_+3A_mask">mask</code></td>
<td>
<p>logical array defining a mask. All computations are restricted to the mask.
</p>
</td></tr>
<tr><td><code id="paws_+3A_hmax">hmax</code></td>
<td>
 <p><code>hmax</code> specifies the maximal bandwidth. Defaults to <code>hmax=250, 12, 5</code>
for 1D, 2D, 3D images, respectively.
In case of <code>lkern="Gaussian"</code> the bandwidth is assumed to be given in full width half maximum (FWHM) units, i.e., <code>0.42466</code> times gridsize.
</p>
</td></tr>
<tr><td><code id="paws_+3A_onestep">onestep</code></td>
<td>

<p>apply the last step only (use for test purposes only)
</p>
</td></tr>
<tr><td><code id="paws_+3A_aws">aws</code></td>
<td>

<p>logical: if TRUE structural adaptation (AWS) is used.
</p>
</td></tr>
<tr><td><code id="paws_+3A_family">family</code></td>
<td>
<p><code>family</code> specifies the probability distribution. Default is <code>family="Gaussian"</code>, also implemented
are &quot;Bernoulli&quot;, &quot;Poisson&quot;, &quot;Exponential&quot;, &quot;Volatility&quot;, &quot;Variance&quot; and &quot;NCchi&quot;. <code>family="Volatility"</code> specifies a Gaussian distribution with
expectation 0 and unknown variance. <code>family="Volatility"</code> specifies that <code>p*y/theta</code> is distributed as <code class="reqn">\chi^2</code> with <code>p=shape</code>
degrees of freedom. <code>family="NCchi"</code> uses a noncentral Chi distribution with <code>p=shape</code> degrees of freedom and noncentrality parameter <code>theta</code>
</p>
</td></tr>
<tr><td><code id="paws_+3A_lkern">lkern</code></td>
<td>

<p>character: location kernel, either &quot;Triangle&quot;, &quot;Plateau&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot; or &quot;Gaussian&quot;.
The default &quot;Triangle&quot; is equivalent to using an Epanechnikov kernel, &quot;Quadratic&quot; and  &quot;Cubic&quot; refer to a Bi-weight and Tri-weight
kernel, see Fan and Gijbels (1996). &quot;Gaussian&quot; is a truncated (compact support) Gaussian kernel.
This is included for comparisons only and should be avoided due to its large computational costs.
</p>
</td></tr>
<tr><td><code id="paws_+3A_aggkern">aggkern</code></td>
<td>

<p>character: kernel used in stagewise aggregation, either &quot;Triangle&quot; or &quot;Uniform&quot;
</p>
</td></tr>
<tr><td><code id="paws_+3A_sigma2">sigma2</code></td>
<td>

<p><code>sigma2</code> allows to specify the variance in case of <code>family="Gaussian"</code>. Not used if <code>family!="Gaussian"</code>.
Defaults to <code>NULL</code>. In this case a homoskedastic variance estimate is generated. If <code>length(sigma2)==length(y)</code> then <code>sigma2</code>
is assumed to contain the pointwise variance of <code>y</code> and a heteroscedastic variance model is used.
</p>
</td></tr>
<tr><td><code id="paws_+3A_shape">shape</code></td>
<td>
<p>Allows to specify an additional shape parameter for certain family models. Currently only used for family=&quot;Variance&quot;, that is <code class="reqn">\chi</code>-Square distributed observations
with <code>shape</code> degrees of freedom.
</p>
</td></tr>
<tr><td><code id="paws_+3A_scorr">scorr</code></td>
<td>

<p>The vector <code>scorr</code> allows to specify a first order correlations of the noise for each coordinate direction,
defaults to 0 (no correlation).
</p>
</td></tr>
<tr><td><code id="paws_+3A_spmin">spmin</code></td>
<td>

<p>Determines the form (size of the plateau) in the adaptation kernel.
Not to be changed by the user.
</p>
</td></tr>
<tr><td><code id="paws_+3A_ladjust">ladjust</code></td>
<td>

<p>factor to increase the default value of lambda
</p>
</td></tr>
<tr><td><code id="paws_+3A_wghts">wghts</code></td>
<td>
<p><code>wghts</code> specifies the  diagonal elements of a weight matrix to adjust for different distances between grid-points
in different coordinate directions, i.e. allows to define a more appropriate metric in the design space.
</p>
</td></tr>
<tr><td><code id="paws_+3A_u">u</code></td>
<td>

<p>a &quot;true&quot; value of the regression function, may be provided to
report risks at each iteration. This can be used to test the propagation condition with <code>u=0</code>
</p>
</td></tr>
<tr><td><code id="paws_+3A_graph">graph</code></td>
<td>
<p>If  <code>graph=TRUE</code> intermediate results are illustrated after each iteration step. Defaults to <code>graph=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="paws_+3A_demo">demo</code></td>
<td>
<p> If <code>demo=TRUE</code> the function pauses after each iteration. Defaults to <code>demo=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="paws_+3A_patchsize">patchsize</code></td>
<td>

<p>positive integer defining the size of patches. Number of grid points within the patch is <code>(2*patchsize+1)^d</code> with <code>d</code> denoting the dimensionality of the design.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> see <code><a href="#topic+aws">aws</a>. The procedure is supposed to produce superior results if the assumption of a local constant image is violated or if smooothness of discontinuities is desired.</code>
</p>


<h3>Value</h3>

<p>returns an object of class <code>aws</code> with slots
</p>
<table>
<tr><td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td></tr>
<tr><td><code>x = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>ni = "integer"</code></td>
<td>
<p>integer(0)</p>
</td></tr>
<tr><td><code>mask = "logical"</code></td>
<td>
<p>logical(0)</p>
</td></tr>
<tr><td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function, <code>length: length(y)</code></p>
</td></tr>
<tr><td><code>hseq = "numeric"</code></td>
<td>
<p>sequence of bandwidths employed</p>
</td></tr>
<tr><td><code>mae = "numeric"</code></td>
<td>
<p>Mean absolute error for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>psnr = "numeric"</code></td>
<td>
<p>Peak signal-to-noise ratio for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates of the regression function. Please note that this does not reflect variability due to randomness of weights.</p>
</td></tr>
<tr><td><code>xmin = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>xmax = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>wghts = "numeric"</code></td>
<td>
<p>numeric(0), ratio of distances <code>wghts[-1]/wghts[1]</code></p>
</td></tr>
<tr><td><code>degree = "integer"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td></tr>
<tr><td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated error variance</p>
</td></tr>
<tr><td><code>scorr = "numeric"</code></td>
<td>
<p>scorr</p>
</td></tr>
<tr><td><code>family = "character"</code></td>
<td>
<p>family</p>
</td></tr>
<tr><td><code>shape = "numeric"</code></td>
<td>
<p>shape</p>
</td></tr>
<tr><td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1=&quot;Plateau&quot;, 2=&quot;Triangle&quot;, 3=&quot;Quadratic&quot;, 4=&quot;Cubic&quot;, 5=&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td></tr>
<tr><td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td></tr>
<tr><td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td></tr>
<tr><td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td></tr>
<tr><td><code>homogen = "logical"</code></td>
<td>
<p>homogen</p>
</td></tr>
<tr><td><code>earlystop = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>varmodel = "character"</code></td>
<td>
<p>&quot;Constant&quot;</p>
</td></tr>
<tr><td><code>vcoef = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>aws</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>use <code>setCores='number of threads'</code> to enable parallel execution.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Appendix A.
Doi:10.1007/978-3-030-29184-6.
</p>
<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06 .
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+aws">aws</a></code>, <code><a href="#topic+lpaws">lpaws</a></code>, <code><a href="#topic+vpaws">vpaws</a></code>,<code>link{awsdata}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setCores(2)
y &lt;- array(rnorm(64^3),c(64,64,64))
yhat &lt;- paws(y,hmax=6)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot-methods'>Methods for Function &lsquo;plot&rsquo; from package 'graphics' in Package &lsquo;aws&rsquo;</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY-method'></span><span id='topic+plot+2Caws-method'></span><span id='topic+plot+2Cawssegment-method'></span><span id='topic+plot+2CICIsmooth-method'></span><span id='topic+plot+2Ckernsm-method'></span>

<h3>Description</h3>

<p>Visualization of objects of class <code>"aws"</code>, <code>"awsswgment"</code>, 
<code>"kernsm"</code> and <code>"ICIsmooth"</code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>
<p>Generic function: see <code><a href="graphics.html#topic+plot">plot</a></code>. 
</p>
</dd>
<dt><code>signature(x = "aws")</code></dt><dd>
<p>Visualization of objects of class <code>"aws"</code>
</p>
</dd>
<dt><code>signature(x = "awssegment")</code></dt><dd>
<p>Visualization of objects of class <code>"awssegment"</code>
</p>
</dd>
<dt><code>signature(x = "ICIsmooth")</code></dt><dd>
<p>Visualization of objects of class <code>"ICIsmooth"</code>
</p>
</dd>
<dt><code>signature(x = "kernsm")</code></dt><dd>
<p>Visualization of objects of class <code>"kernsm"</code>
</p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+aws-class">aws</a></code>, 
<code><a href="#topic+awssegment-class">awssegment</a></code>, 
<code><a href="#topic+ICIsmooth-class">ICIsmooth</a></code>
<code><a href="#topic+kernsm-class">kernsm</a></code>
</p>

<hr>
<h2 id='print-methods'>Methods for Function &lsquo;print&rsquo; from package 'base' in Package &lsquo;aws&rsquo;</h2><span id='topic+print-methods'></span><span id='topic+print+2CANY-method'></span><span id='topic+print+2Caws-method'></span><span id='topic+print+2Cawssegment-method'></span><span id='topic+print+2CICIsmooth-method'></span><span id='topic+print+2Ckernsm-method'></span>

<h3>Description</h3>

<p>The function provides information on data dimensions, creation of the object and 
existing slot-names for objects of class <code>"aws"</code>, <code>"awssegment"</code>,
<code>"ICIsmooth"</code> and  <code>"kernsm"</code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>
<p>Generic function: see <code><a href="base.html#topic+print">print</a></code>.
</p>
</dd>
<dt><code>signature(x = "aws")</code></dt><dd>
<p>Provide information on data dimensions, creation of the object and 
existing slot-names for objects of class <code>"aws"</code>
</p>
</dd>
<dt><code>signature(x = "awssegment")</code></dt><dd>
<p>Provide information on data dimensions, creation of the object and 
existing slot-names for objects of class <code>"awssegment"</code>
</p>
</dd>
<dt><code>signature(x = "ICIsmooth")</code></dt><dd>
<p>Provide information on data dimensions, creation of the object and 
existing slot-names for objects of class <code>"ICIsmooth"</code>
</p>
</dd>
<dt><code>signature(x = "kernsm")</code></dt><dd>
<p>Provide information on data dimensions, creation of the object and 
existing slot-names for objects of class <code>"kernsm"</code>
</p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+aws-class">aws</a></code>, 
<code><a href="#topic+awssegment-class">awssegment</a></code>, 
<code><a href="#topic+ICIsmooth-class">ICIsmooth</a></code>
<code><a href="#topic+kernsm-class">kernsm</a></code>
</p>

<hr>
<h2 id='qmeasures'>
Quality assessment for image reconstructions.
</h2><span id='topic+qmeasures'></span>

<h3>Description</h3>

<p>Computes selected criteria for quality assessments of
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmeasures(img, ref,
  which = c("PSNR", "MAE", "MSE", "RMSE", "SSIM", "MAGE", "RMSGE"),
  mask = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmeasures_+3A_img">img</code></td>
<td>

<p>2D/3D image, object of class <code>"aws", "ICIsmooth", "kernsm", "nlmeans"</code>
or array.
</p>
</td></tr>
<tr><td><code id="qmeasures_+3A_ref">ref</code></td>
<td>

<p>Reference image (array, matrix or vector) for comparison.
</p>
</td></tr>
<tr><td><code id="qmeasures_+3A_which">which</code></td>
<td>

<p>Criterion to use for Quality assessment. Please specify a subset of
<code>"PSNR"</code> (Peak Signal to Noise Ratio),
<code>"MAE"</code> (Mean Absolute Error),
<code>"MSE"</code> (Mean Squared Error),
<code>"RMSE"</code> (Root Mean Squared Error),
<code>"SSIM"</code> (Structural SIMilarity),
<code>"MAGE"</code> (Mean Absolute Gradient Error),
<code>"RMSGE"</code> (Root Mean Squared Gradient Error).
</p>
</td></tr>
<tr><td><code id="qmeasures_+3A_mask">mask</code></td>
<td>

<p>Logical of same dimension as img/ref. Calculation can be restricted to mask.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates specified quality indices.
</p>


<h3>Value</h3>

<p>A vector with names as specified in <code>which</code>.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a>
</p>

<hr>
<h2 id='risk-methods'>Compute risks characterizing the quality of smoothing results</h2><span id='topic+risk-methods'></span><span id='topic+risk+2CANY-method'></span><span id='topic+risk+2Carray-method'></span><span id='topic+risk+2Caws-method'></span><span id='topic+risk+2Cawssegment-method'></span><span id='topic+risk+2CICIsmooth-method'></span><span id='topic+risk+2Ckernsm-method'></span><span id='topic+risk+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods function <code>risk</code> in package <span class="pkg">aws</span>. For an given array <code>u</code> 
the following statistics are computed :
Root Mean Squared Error <code>RMSE &lt;- sqrt(mean((y-u)^2))</code>,
Signal to Noise Ratio <code>SNR &lt;- 10*log(mean(u^2)/MSE,10)</code>,
Peak Signal to Noise Ratio <code>PSNR &lt;- 10*log(max(u^2)/MSE,10)</code>,
Mean Absolute Error <code>MAE &lt;- mean(abs(y-u))</code>,
Maximal Absolute Error <code>MaxAE &lt;- max(abs(y-u))</code>,
Universal Image Quality Index (UIQI) (Wang and Bovik (2002)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'array'
risk(y, u=0)
  ## S4 method for signature 'aws'
risk(y, u=0)
  ## S4 method for signature 'awssegment'
risk(y, u=0)
  ## S4 method for signature 'ICIsmooth'
risk(y, u=0)
  ## S4 method for signature 'kernsm'
risk(y, u=0)
  ## S4 method for signature 'numeric'
risk(y, u=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="risk-methods_+3A_y">y</code></td>
<td>
<p> object </p>
</td></tr>
<tr><td><code id="risk-methods_+3A_u">u</code></td>
<td>
<p> array of dimension <code>dim(y)</code> or <code>dim(extract(y,what="yhat")$y)</code>
or scalar value used in comparisons. </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(y = "ANY")</code></dt><dd>
<p>The method extract and/or compute specified statistics from object of class 
</p>
</dd>
<dt><code>signature(y = "array")</code></dt><dd>
<p>Returns a list with components <code>RMSE, SNR, PSNR, MAE, MaxAE, UIQI</code>
</p>
</dd>
<dt><code>signature(y = "aws")</code></dt><dd>
<p>Returns a list with components <code>RMSE, SNR, PSNR, MAE, MaxAE, UIQI</code>
</p>
</dd>
<dt><code>signature(y = "awssegment")</code></dt><dd>
<p>Returns a list with components <code>RMSE, SNR, PSNR, MAE, MaxAE, UIQI</code>
</p>
</dd>
<dt><code>signature(y = "ICIsmooth")</code></dt><dd>
<p>Returns a list with components <code>RMSE, SNR, PSNR, MAE, MaxAE, UIQI</code>
</p>
</dd>
<dt><code>signature(y = "kernsm")</code></dt><dd>
<p>Returns a list with components <code>RMSE, SNR, PSNR, MAE, MaxAE, UIQI</code>
</p>
</dd>
<dt><code>signature(y = "numeric")</code></dt><dd>
<p>Returns a list with components <code>RMSE, SNR, PSNR, MAE, MaxAE, UIQI</code>
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

 
<p>V. Katkovnik, K. Egiazarian and J. Astola, 
<em>Local Approximation Techniques in Signal And Image Processing</em>,
SPIE Society of Photo-Optical Instrumentation Engin., 2006, PM157
</p>
<p>Z. Wang  and A. C. Bovik, <em>A universal image quality index</em>, 
IEEE Signal Processing Letters,
vol. 9, N3, pp. 81-84, 2002.
</p>

<hr>
<h2 id='show-methods'>Methods for Function &lsquo;show&rsquo; in Package &lsquo;aws&rsquo;</h2><span id='topic+show-methods'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2Caws-method'></span><span id='topic+show+2Cawssegment-method'></span><span id='topic+show+2CICIsmooth-method'></span><span id='topic+show+2Ckernsm-method'></span>

<h3>Description</h3>

<p>The function provides information on data dimensions, data source and 
existing slot-names for objects of class <code>"aws"</code>, <code>"awssegment"</code>,
<code>"ICIsmooth"</code> and <code>"kernsm"</code> in package <span class="pkg">aws</span>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
<p>Generic function. 
</p>
</dd>
<dt><code>signature(object = "aws")</code></dt><dd>
<p>Provide information on data dimensions, data source and existing slot-names for objects of class <code>"dti"</code>
and classes that extent <code>"aws"</code>.</p>
</dd>
<dt><code>signature(object = "awssegment")</code></dt><dd>
<p>Provide information on data dimensions, data source and existing slot-names for objects of class <code>"dti"</code>
and classes that extent <code>"awssegment"</code>.</p>
</dd>
<dt><code>signature(object = "ICIsmooth")</code></dt><dd>
<p>Provide information on data dimensions, data source and existing slot-names for objects of class <code>"dti"</code>
and classes that extent <code>"ICIsmooth"</code>.</p>
</dd>
<dt><code>signature(object = "kernsm")</code></dt><dd>
<p>Provide information on data dimensions, data source and existing slot-names for objects of class <code>"dti"</code>
and classes that extent <code>"kernsm"</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+aws-class">aws</a></code>, 
<code><a href="#topic+awssegment-class">awssegment</a></code>, 
<code><a href="#topic+ICIsmooth-class">ICIsmooth</a></code>
<code><a href="#topic+kernsm-class">kernsm</a></code>
</p>

<hr>
<h2 id='smooth3D'>
Auxiliary 3D smoothing routines
</h2><span id='topic+smooth3D'></span><span id='topic+medianFilter3D'></span><span id='topic+aws3Dmask'></span><span id='topic+aws3Dmaskfull'></span>

<h3>Description</h3>

<p><code>smooth3D</code> and <code>medianFilter3D</code> are auxiliary functions for non-adaptive
smoothing of 3D image data using kernel or median smoothing. Both function restrict
to sub-areas determined by a mask.  The functions are used in packages <code>dti</code> and
<code>qMRI</code>.
</p>
<p>Functions <code>aws3Dmask</code> and <code>aws3Dmaskfull</code> perform adaptive weights smoothing on
statistical parametric maps in fMRI. Variability of results is determined from smoothed
(using the same weighting schemes) residuals in order to correctly account for spatial
correlation. These functions are intended to be used internally in package <code>fmri</code>.
They have been moved here because they share significant parts of the
openMP parallelized Fortran code underlying function <code>aws</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth3D(y, h, mask, lkern = "Gaussian", weighted = FALSE, sigma2 = NULL,
         wghts = NULL)
medianFilter3D(y, h = 10, mask = NULL)
aws3Dmask(y, mask, lambda, hmax, res = NULL, sigma2 = NULL, lkern = "Gaussian",
   skern = "Plateau", weighted = TRUE, u = NULL, wghts = NULL,
   h0 = c(0, 0, 0), testprop = FALSE)
aws3Dmaskfull(y, mask, lambda, hmax, res = NULL, sigma2 = NULL, lkern = "Gaussian",
       skern = "Plateau", weighted = TRUE, u = NULL, wghts = NULL,
       testprop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth3D_+3A_y">y</code></td>
<td>

<p>3D array of data in case of functions <code>smooth3D</code> and <code>medianFilter3D</code>. For <code>aws3Dmask*</code>
with <code>!is.null(mask)</code> a vector of length <code>sum(mask)</code> containing only data values within the specified mask.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_lkern">lkern</code></td>
<td>
<p>character: location kernel, either &quot;Triangle&quot;, &quot;Plateau&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot; or &quot;Gaussian&quot;.
The default &quot;Triangle&quot; is equivalent to using an Epanechnikov kernel, &quot;Quadratic&quot; and  &quot;Cubic&quot; refer to a Bi-weight and Tri-weight
kernel, see Fan and Gijbels (1996). &quot;Gaussian&quot; is a truncated (compact support) Gaussian kernel.
This is included for comparisons only and should be avoided due to its large computational costs.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_weighted">weighted</code></td>
<td>

<p>logical: use inverse variances as weights.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_sigma2">sigma2</code></td>
<td>

<p><code>sigma2</code> allows to specify the variance of data entries.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_mask">mask</code></td>
<td>

<p>optional logical mask, same dimensionality as <code>y</code>
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_h">h</code></td>
<td>

<p>bandwidth to use. In case of <code>lkern="Gaussian"</code> this is in FWHM (full width half maximum) units.
Value refers to first voxel dimension.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_wghts">wghts</code></td>
<td>

<p>voxel dimensions. Defaults to <code>c(1,1,1)</code>
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_lambda">lambda</code></td>
<td>

<p>kritical scale parameter in hypothesis testing (adaptive weights smoothing)
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_hmax">hmax</code></td>
<td>

<p>maximum bandwidth for adaptive weights smoothing
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_res">res</code></td>
<td>

<p>array of residuals with dimension <code>c(nres,sum(mask))</code>.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_skern">skern</code></td>
<td>
 <p><code>skern</code> specifies the kernel for the statistical
penalty. Defaults to &quot;Plateau&quot;, the alternatives are &quot;Triangle&quot; and &quot;Exp&quot;.
&quot;Plateau&quot; specifies a kernel that is equal to 1 in the interval (0,.3),
decays linearly in (.3,1) and is 0 for arguments larger than 1.
<code>lkern="Plateau"</code> and <code>lkern="Triangle"</code> allow for much faster computation (saves up
to 50% CPU-time). <code>lkern="Plateau"</code> produces a less random weighting scheme.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_u">u</code></td>
<td>

<p>For test purposes in simulations: noisless 3D data.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_h0">h0</code></td>
<td>

<p>Vector of 3 bandwidths corresponding to a Gaussian kernel that would produce a
comparable spatial correlation by convoluting iid data.
</p>
</td></tr>
<tr><td><code id="smooth3D_+3A_testprop">testprop</code></td>
<td>

<p>logical: test the validity of a propagation condition for the specified value of <code>lambda</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions <code>smooth3D</code> and <code>medianFilter3D</code> return a 3D array.
Functions <code>awsmask*</code> return a list with smoothed values of <code>y</code> in
component <code>theta</code> and smoothed residuals in component <code>res</code>.
</p>


<h3>Note</h3>

<p>Functions <code>awsmask*</code> are used intenally in package <code>fmri</code>. They refer to the
situation, typical for fMRI, where the data are spatially correlated and this correlation
can be accessed using residuals with respect to a model.
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a>
</p>

<hr>
<h2 id='smse3ms'>
Adaptive smoothing in orientation space SE(3)
</h2><span id='topic+smse3'></span><span id='topic+smse3ms'></span>

<h3>Description</h3>

<p>The functions perform adaptive weights smoothing for data in orientation space SE(3),
e.g. diffusion weighted MR data,
with spatial coordinates given by voxel location within a mask and spherical information given
by gradient direction. Observations can belong to different shells characterized by b-value <code>bv</code>.
The data provided should only refer to voxel within mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smse3ms(sb, s0, bv, grad, kstar, lambda, kappa0, mask, sigma,
    ns0 = 1, ws0 = 1, vext = NULL, ncoils = 1, verbose = FALSE, usemaxni = TRUE)
smse3(sb, s0, bv, grad, mask, sigma, kstar, lambda, kappa0,
    ns0 = 1, vext = NULL, vred = 4, ncoils = 1, model = 0, dist = 1,
    verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smse3ms_+3A_sb">sb</code></td>
<td>

<p>2D array of diffion weighted data, first dimension refers to index ov voxel within the mask,
second dimension to the number diffusion weighted images.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_s0">s0</code></td>
<td>

<p>vector of length <code>sum(mask)</code> containing values within mask of an average non-diffusion-weigthed image.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_bv">bv</code></td>
<td>

<p>vector of b-values.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_grad">grad</code></td>
<td>

<p>matrix of gradient directions with <code>dim(grad)[1]==3</code>.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_kstar">kstar</code></td>
<td>

<p>number of steps in adaptive weights smoothing.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_lambda">lambda</code></td>
<td>

<p>Scale parameter in adaptation
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_kappa0">kappa0</code></td>
<td>

<p>determines amount of smoothing on the sphere. Larger values correspond to stronger smoothing
on the sphere. If <code>kappa0=NULL</code> a value is that corresponds to a variace reduction
with factor <code>vred</code> on the sphere.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_mask">mask</code></td>
<td>

<p>3D image defining a mask (logical)
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_sigma">sigma</code></td>
<td>

<p>Error standard deviation. Assumed to be known and homogeneous in the current implementation.
A reasonable estimate may be defined
as the modal value of standard deviations obtained using method <code>getsdofsb</code>.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_ns0">ns0</code></td>
<td>

<p>Actual number of non-diffusion-weigthed images used to obtain <code>s0</code> by averaging.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_ws0">ws0</code></td>
<td>

<p>Weight for non-diffusion-weigthed images in statistical penalty.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_vext">vext</code></td>
<td>

<p>Voxel extensions.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_ncoils">ncoils</code></td>
<td>

<p>Effective number of receiver coils (in case of e.g. GRAPPA reconstructions),
should be 1 in case of SENSE reconstructions. <code>2*ncoils</code> is the number of degrees of freedom of
the intensity distribution used.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_verbose">verbose</code></td>
<td>

<p>If <code>verbose=TRUE</code> additional reports are given.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_usemaxni">usemaxni</code></td>
<td>

<p>If <code>"usemaxni==TRUE"</code> a strikter penalization is used.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_vred">vred</code></td>
<td>

<p>Used if <code>kappa0=NULL</code> to specify the variance reduction on the
sphere when suggesting a value of <code>kappa0</code>.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_model">model</code></td>
<td>

<p>Determines which quantities are smoothed. Possible values are
<code>"Chi"</code> for observed values (assumed to be distributed as noncentral
Chi with <code>2*ncoils</code> degrees of freedom), <code>"Chi2"</code> for squares of
observed values (assumed to be distributed as noncentral
Chi-squared with <code>2*ncoils</code> degrees of freedom). <code>"Gapprox"</code>
and <code>"Gapprox2"</code> use a Gaussian approximation for the noncentral
Chi distribution to smooth ovserved and squared values, respectively.
</p>
</td></tr>
<tr><td><code id="smse3ms_+3A_dist">dist</code></td>
<td>

<p>Distance in SE3. Reasonable values are 1 (default, see Becker et.al. 2012),
2 ( a slight modification of 1: with k6^2 instead of abs(k6)) and
3 (using a 'naive' distance on the sphere)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return lists with main results in components
<code>th</code> and <code>th0</code> containing the smoothed data.
</p>


<h3>Note</h3>

<p>These functions are intended to be used internally in package <code>dti</code> only.
</p>


<h3>Author(s)</h3>

<p>J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>Joerg Polzehl, Karsten Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>
<p>S. Becker, K. Tabelow, H.U. Voss, A. Anwander, R. Heidemann, J. Polzehl.
Position-orientation adaptive smoothing of diffusion weighted magnetic resonance
data (POAS). Medical Image Analysis, 2012, 16, 1142-1155. DOI:10.1016/j.media.2012.05.007.
</p>
<p>S. Becker, K. Tabelow, S. Mohammadi, N. Weiskopf, J. Polzehl. Adaptive smoothing
of multi-shell diffusion-weighted magnetic resonance data by msPOAS.
Neuroimage, 2014, 95, 90-105. DOI:10.1016/j.neuroimage.2014.03.053.
</p>

<hr>
<h2 id='summary-methods'>Methods for Function &lsquo;summary&rsquo; from package 'base' in Package &lsquo;aws&rsquo; </h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2Caws-method'></span><span id='topic+summary+2Cawssegment-method'></span><span id='topic+summary+2CICIsmooth-method'></span><span id='topic+summary+2Ckernsm-method'></span>

<h3>Description</h3>

<p>The method provides summary information for objects of class <code>"aws"</code>. </p>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dti"</code>, <code>"dtiData"</code>, <code>"dtiTensor"</code>, <code>"dwiMixtensor"</code>, <code>"dtiIndices"</code>,  <code>"dwiQball"</code> or <code>"dwiFiber"</code>. </p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p> Additional arguments in <code>...</code> are passed to function <code>quantile</code>, e.g. argument <code>probs</code> may be specified here.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
<p>Generic function: see <code><a href="base.html#topic+summary">summary</a></code>.
</p>
</dd>
<dt><code>signature(object = "aws")</code></dt><dd>
<p>The function provides summary information for objects of class <code>"aws"</code>
</p>
</dd>
<dt><code>signature(object = "awssegment")</code></dt><dd>
<p>The function provides summary information for objects of class <code>"awssegment"</code>
</p>
</dd>
<dt><code>signature(object = "ICIsmooth")</code></dt><dd>
<p>The function provides summary information for objects of class <code>"ICIsmooth"</code>
</p>
</dd>
<dt><code>signature(object = "kernsm")</code></dt><dd>
<p>The function provides summary information for objects of class <code>"kernsm"</code>
</p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+aws-class">aws</a></code>, 
<code><a href="#topic+awssegment-class">awssegment</a></code>, 
<code><a href="#topic+ICIsmooth-class">ICIsmooth</a></code>
<code><a href="#topic+kernsm-class">kernsm</a></code>
</p>

<hr>
<h2 id='TV_denoising'>
TV/TGV denoising of image data
</h2><span id='topic+TV_denoising'></span><span id='topic+TGV_denoising'></span><span id='topic+TV_denoising_colour'></span><span id='topic+TGV_denoising_colour'></span>

<h3>Description</h3>

<p>Total variation and total generalized variation are classical energy minimizing methods
for image denoising.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TV_denoising(datanoisy, alpha, iter = 1000, tolmean = 1e-06,
             tolsup = 1e-04, scale = 1, verbose=FALSE)
TGV_denoising(datanoisy, alpha, beta, iter = 1000, tolmean = 1e-06,
              tolsup = 1e-04, scale = 1, verbose=FALSE)
TV_denoising_colour(datanoisy, alpha, iter = 1000, tolmean = 1e-06,
                    tolsup = 1e-04, scale = 1, verbose=FALSE)
TGV_denoising_colour(datanoisy, alpha, beta, iter = 1000, tolmean = 1e-06,
                     tolsup = 1e-04, scale = 1, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TV_denoising_+3A_datanoisy">datanoisy</code></td>
<td>

<p>matrix of noisy 2D image data. In case of <code>TV_denoising_colour</code>
and <code>TGV_denoising_colour</code> and array with third dimension refering to
RGB channels.
</p>
</td></tr>
<tr><td><code id="TV_denoising_+3A_alpha">alpha</code></td>
<td>

<p>TV regularization parameter.
</p>
</td></tr>
<tr><td><code id="TV_denoising_+3A_beta">beta</code></td>
<td>

<p>additional TGV regularization parameter.
</p>
</td></tr>
<tr><td><code id="TV_denoising_+3A_iter">iter</code></td>
<td>

<p>max. number of iterations
</p>
</td></tr>
<tr><td><code id="TV_denoising_+3A_tolmean">tolmean</code></td>
<td>

<p>requested accuracy for mean image correction
</p>
</td></tr>
<tr><td><code id="TV_denoising_+3A_tolsup">tolsup</code></td>
<td>

<p>requested accuracy for max (over pixel) image correction
</p>
</td></tr>
<tr><td><code id="TV_denoising_+3A_scale">scale</code></td>
<td>

<p>image scale
</p>
</td></tr>
<tr><td><code id="TV_denoising_+3A_verbose">verbose</code></td>
<td>

<p>report convergence diagnostics.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reimplementation of original matlab code by Kostas Papafitsoros (WIAS).
</p>


<h3>Value</h3>

<p>TV/TGV reconstructed image data (2D array)
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06.
</p>
<p>Rudin, L.I., Osher, S. and Fatemi, E. (1992). Nonlinear total variation based
noise removal algorithms. Phys. D, 60, 259-268. DOI: 10.1016/0167-2789(92)90242-F.
</p>
<p>Bredies, K., Kunisch, K. and Pock, T. (2010). Total Generalized Variation.
SIAM J. Imaging Sci., 3, 492-526. DOI:10.1137/090769521.
</p>

<hr>
<h2 id='vaws'>
vector valued version of function <code><a href="#topic+aws">aws</a></code>
The function implements the propagation separation approach to
nonparametric smoothing (formerly introduced as Adaptive weights smoothing)
for varying coefficient likelihood models with vector valued response on a 1D, 2D or 3D grid.
</h2><span id='topic+vaws'></span><span id='topic+vawscov'></span>

<h3>Description</h3>

<p>The function implements a version the propagation separation approach that
uses vector valued instead of scalar responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vaws(y, kstar = 16, sigma2 = 1, mask = NULL, scorr = 0, spmin = 0.25,
     ladjust = 1, wghts = NULL, u = NULL, maxni = FALSE)
vawscov(y, kstar = 16, invcov = NULL, mask = NULL, scorr = 0, spmin = 0.25,
          ladjust = 1, wghts = NULL, u = NULL, maxni = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vaws_+3A_y">y</code></td>
<td>
<p><code>y</code> contains the observed response data. <code>dim(y)</code> determines the dimensionality and extend of the grid design. First component varies over components of the response vector.
</p>
</td></tr>
<tr><td><code id="vaws_+3A_kstar">kstar</code></td>
<td>

<p>maximal number of steps to employ. Determines maximal bandwidth.
</p>
</td></tr>
<tr><td><code id="vaws_+3A_sigma2">sigma2</code></td>
<td>

<p>specifies a homogeneous error variance.
</p>
</td></tr>
<tr><td><code id="vaws_+3A_invcov">invcov</code></td>
<td>

<p>array of voxelwise inverse covariance matrixes, first index corresponds to
upper diagonal inverse covariance matrix.
</p>
</td></tr>
<tr><td><code id="vaws_+3A_mask">mask</code></td>
<td>

<p>logical mask. All computations are restrikted to design poins within the mask.
</p>
</td></tr>
<tr><td><code id="vaws_+3A_scorr">scorr</code></td>
<td>

<p>The vector <code>scorr</code> allows to specify a first order correlations of the noise for each coordinate direction,
defaults to 0 (no correlation).
</p>
</td></tr>
<tr><td><code id="vaws_+3A_spmin">spmin</code></td>
<td>

<p>determines the form (size of the plateau) in the adaptation kernel.
Not to be changed by the user.
</p>
</td></tr>
<tr><td><code id="vaws_+3A_ladjust">ladjust</code></td>
<td>

<p>factor to increase the default value of lambda
</p>
</td></tr>
<tr><td><code id="vaws_+3A_wghts">wghts</code></td>
<td>
<p><code>wghts</code> specifies the  diagonal elements of a weight matrix to adjust for different distances between grid-points
in different coordinate directions, i.e. allows to define a more appropriate metric in the design space.
</p>
</td></tr>
<tr><td><code id="vaws_+3A_u">u</code></td>
<td>

<p>a &quot;true&quot; value of the regression function, may be provided to
report risks at each iteration. This can be used to test the propagation condition with <code>u=0</code>
</p>
</td></tr>
<tr><td><code id="vaws_+3A_maxni">maxni</code></td>
<td>

<p>If TRUE use <code class="reqn">max_{l&lt;=k}(N_i^{(l)}</code> instead of <code class="reqn">(N_i^{(k)}</code> in the definition of the statistical penalty.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> see <code><a href="#topic+aws">aws</a></code>. Expets vector valued responses. Currently only implements the case of additive Gaussian errors.
</p>


<h3>Value</h3>

<p>returns anobject of class <code>aws</code> with slots
</p>
<table>
<tr><td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td></tr>
<tr><td><code>x = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>ni = "integer"</code></td>
<td>
<p>integer(0)</p>
</td></tr>
<tr><td><code>mask = "logical"</code></td>
<td>
<p>logical(0)</p>
</td></tr>
<tr><td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function, <code>length: length(y)</code></p>
</td></tr>
<tr><td><code>hseq = "numeric"</code></td>
<td>
<p>sequence of bandwidths employed</p>
</td></tr>
<tr><td><code>mae = "numeric"</code></td>
<td>
<p>Mean absolute error for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>psnr = "numeric"</code></td>
<td>
<p>Peak signal-to-noise ratio for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates
of the regression function.
Please note that this does not reflect variability due to
randomness of weights.</p>
</td></tr>
<tr><td><code>xmin = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>xmax = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>wghts = "numeric"</code></td>
<td>
<p>numeric(0), ratio of distances <code>wghts[-1]/wghts[1]</code></p>
</td></tr>
<tr><td><code>degree = "integer"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td></tr>
<tr><td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated (inverse) error variance</p>
</td></tr>
<tr><td><code>scorr = "numeric"</code></td>
<td>
<p>scorr</p>
</td></tr>
<tr><td><code>family = "character"</code></td>
<td>
<p>family</p>
</td></tr>
<tr><td><code>shape = "numeric"</code></td>
<td>
<p>shape</p>
</td></tr>
<tr><td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1=&quot;Plateau&quot;, 2=&quot;Triangle&quot;, 3=&quot;Quadratic&quot;, 4=&quot;Cubic&quot;, 5=&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td></tr>
<tr><td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td></tr>
<tr><td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td></tr>
<tr><td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td></tr>
<tr><td><code>homogen = "logical"</code></td>
<td>
<p>homogen</p>
</td></tr>
<tr><td><code>earlystop = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>varmodel = "character"</code></td>
<td>
<p>&quot;Constant&quot;</p>
</td></tr>
<tr><td><code>vcoef = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>aws</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>use <code>setCores='number of threads'</code> to enable parallel execution.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Appendix A.
Doi:10.1007/978-3-030-29184-6.
</p>
<p>J. Polzehl, V. Spokoiny,  Adaptive Weights Smoothing with applications to image restoration,
J. R. Stat. Soc. Ser. B Stat. Methodol.  62 ,  (2000)  , pp. 335&ndash;354. DOI:10.1111/1467-9868.00235.
</p>
<p>J. Polzehl, V. Spokoiny,  Propagation-separation approach for local likelihood estimation,
Probab. Theory Related Fields  135 (3),  (2006)  , pp. 335&ndash;362. DOI:10.1007/s00440-005-0464-1.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+aws">aws</a></code>, <code><a href="#topic+vpaws">vpaws</a></code>,<code>link{awsdata}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setCores(2)
y &lt;- array(rnorm(4*64^3),c(4,64,64,64))
yhat &lt;- vaws(y,kstar=20)

## End(Not run)

</code></pre>

<hr>
<h2 id='vpaws'>
vector valued version of function <code><a href="#topic+paws">paws</a></code> with homogeneous covariance structure
</h2><span id='topic+vpaws'></span><span id='topic+vpawscov'></span><span id='topic+vpawscov2'></span>

<h3>Description</h3>

<p>The function implements a vector-valued version the propagation separation approach that
uses patches instead of individuel voxels for comparisons in parameter space. Functionality is analog to function <code><a href="#topic+vaws">vaws</a></code>. Using patches allows for an improved
handling of locally smooth functions and in 2D and 3D for improved smoothness of
discontinuities at the expense of increased computing time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vpaws(y, kstar = 16, sigma2 = 1, invcov = NULL, mask = NULL, scorr = 0, spmin = 0.25,
      ladjust = 1, wghts = NULL, u = NULL, patchsize = 1)
vpawscov(y, kstar = 16, invcov = NULL, mask = NULL, scorr = 0, spmin = 0.25, ladjust = 1, 
      wghts = NULL, maxni = FALSE, patchsize = 1)
vpawscov2(y, kstar = 16, invcov = NULL, mask = NULL, scorr = 0, spmin = 0.25,
      lambda = NULL, ladjust = 1, wghts = NULL, patchsize = 1,
      data = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vpaws_+3A_y">y</code></td>
<td>
<p><code>y</code>  can be a full array of vector valued data, or, if <code>mask</code> is provided,
be a matrix with columns corresponding to points/pixel/voxel within the mask. In the first case
<code>dim(y)</code> determines the dimensionality and extend of the grid design, in the second
case tis information is obtained from the dimensions of <code>mask</code>.
the first component varies over components of the response vector.
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_kstar">kstar</code></td>
<td>

<p>maximal number of steps to employ. Determines maximal bandwidth.
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_sigma2">sigma2</code></td>
<td>

<p>specifies a homogeneous error variance.
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_invcov">invcov</code></td>
<td>

<p>array (or matrix) of voxelwise inverse covariance matrixes, first index corresponds to
upper diagonal inverse covariance matrix.
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_mask">mask</code></td>
<td>

<p>logical mask. All computations are restrikted to design poins within the mask.
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_scorr">scorr</code></td>
<td>

<p>The vector <code>scorr</code> allows to specify a first order correlations of the noise for each coordinate direction,
defaults to 0 (no correlation).
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_spmin">spmin</code></td>
<td>

<p>determines the form (size of the plateau) in the adaptation kernel.
Not to be changed by the user.
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_ladjust">ladjust</code></td>
<td>

<p>factor to increase the default value of lambda
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_wghts">wghts</code></td>
<td>
<p><code>wghts</code> specifies the  diagonal elements of a weight matrix to adjust for different distances between grid-points
in different coordinate directions, i.e. allows to define a more appropriate metric in the design space.
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_u">u</code></td>
<td>

<p>a &quot;true&quot; value of the regression function, may be provided to
report risks at each iteration. This can be used to test the propagation condition with <code>u=0</code>
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_patchsize">patchsize</code></td>
<td>

<p>positive integer defining the size of patches. Number of grid points within the patch is <code>(2*patchsize+1)^d</code> with <code>d</code> denoting the dimensionality of the design.
</p>
</td></tr>
<tr><td><code id="vpaws_+3A_maxni">maxni</code></td>
<td>
<p>require growing sum of weights</p>
</td></tr>
<tr><td><code id="vpaws_+3A_lambda">lambda</code></td>
<td>
<p>explicit value of lambda</p>
</td></tr>
<tr><td><code id="vpaws_+3A_data">data</code></td>
<td>
<p>optional vector-valued images to be smoothed using the weighting scheme of the last step</p>
</td></tr>
<tr><td><code id="vpaws_+3A_verbose">verbose</code></td>
<td>
<p>logical: provide information on progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+vaws">vaws</a></code>.
Parameter <code>y</code>
The procedure is supposed to produce superior results if the assumption of a
local constant image is violated or if smooothness of discontinuities is desired.
</p>
<p>Function <code>vpawscov2</code> is intended for internal use in package <code>qMRI</code> only.
</p>


<h3>Value</h3>

<p> function <code>vpaws</code> returns
returns an object of class <code>aws</code> with slots
</p>
<table>
<tr><td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td></tr>
<tr><td><code>x = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>ni = "integer"</code></td>
<td>
<p>integer(0)</p>
</td></tr>
<tr><td><code>mask = "logical"</code></td>
<td>
<p>logical(0)</p>
</td></tr>
<tr><td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function, <code>length: length(y)</code></p>
</td></tr>
<tr><td><code>hseq = "numeric"</code></td>
<td>
<p>sequence of bandwidths employed</p>
</td></tr>
<tr><td><code>mae = "numeric"</code></td>
<td>
<p>Mean absolute error for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>psnr = "numeric"</code></td>
<td>
<p>Peak signal-to-noise ratio for each iteration step if u was specified,  numeric(0) else</p>
</td></tr>
<tr><td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates of the regression function. Please note that this does not reflect variability due to randomness of weights.Currently also uses factor <code>1/ni</code> instead of the correct
<code>sum(wij^2)/ni^2</code></p>
</td></tr>
<tr><td><code>xmin = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>xmax = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>wghts = "numeric"</code></td>
<td>
<p>numeric(0), ratio of distances <code>wghts[-1]/wghts[1]</code></p>
</td></tr>
<tr><td><code>degree = "integer"</code></td>
<td>
<p>0</p>
</td></tr>
<tr><td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td></tr>
<tr><td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated error variance</p>
</td></tr>
<tr><td><code>scorr = "numeric"</code></td>
<td>
<p>scorr</p>
</td></tr>
<tr><td><code>family = "character"</code></td>
<td>
<p>family</p>
</td></tr>
<tr><td><code>shape = "numeric"</code></td>
<td>
<p>shape</p>
</td></tr>
<tr><td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1=&quot;Plateau&quot;, 2=&quot;Triangle&quot;, 3=&quot;Quadratic&quot;, 4=&quot;Cubic&quot;, 5=&quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td></tr>
<tr><td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td></tr>
<tr><td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td></tr>
<tr><td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td></tr>
<tr><td><code>homogen = "logical"</code></td>
<td>
<p>homogen</p>
</td></tr>
<tr><td><code>earlystop = "logical"</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>varmodel = "character"</code></td>
<td>
<p>&quot;Constant&quot;</p>
</td></tr>
<tr><td><code>vcoef = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td></tr>
<tr><td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>aws</code></p>
</td></tr>
</table>
<p>If <code>y</code> contained only information (condensed data) for positions within a mask, then the returned object only contains
results for these positions.
</p>


<h3>Note</h3>

<p>use <code>setCores='number of threads'</code> to enable parallel execution.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Appendix A.
Doi:10.1007/978-3-030-29184-6.
</p>
<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06 .
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+vaws">vaws</a></code>, <code><a href="#topic+lpaws">lpaws</a></code>, <code><a href="#topic+vawscov">vawscov</a></code>,<code>link{awsdata}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setCores(2)
y &lt;- array(rnorm(4*64^3),c(4,64,64,64))
yhat &lt;- vpaws(y,kstar=20)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
