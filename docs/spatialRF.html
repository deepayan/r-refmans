<!DOCTYPE html><html><head><title>Help for package spatialRF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatialRF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auc'><p>Area under the ROC curve</p></a></li>
<li><a href='#auto_cor'><p>Multicollinearity reduction via Pearson correlation</p></a></li>
<li><a href='#auto_vif'><p>Multicollinearity reduction via Variance Inflation Factor</p></a></li>
<li><a href='#beowulf_cluster'><p>Defines a beowulf cluster</p></a></li>
<li><a href='#case_weights'><p>Generates case weights for binary data</p></a></li>
<li><a href='#default_distance_thresholds'><p>Default distance thresholds to generate spatial predictors</p></a></li>
<li><a href='#distance_matrix'><p>Matrix of distances among ecoregion edges.</p></a></li>
<li><a href='#double_center_distance_matrix'><p>Double centers a distance matrix</p></a></li>
<li><a href='#filter_spatial_predictors'><p>Removes redundant spatial predictors</p></a></li>
<li><a href='#get_evaluation'><p>Gets performance data frame from a cross-validated model</p></a></li>
<li><a href='#get_importance'><p>Gets the global importance data frame from a model</p></a></li>
<li><a href='#get_importance_local'><p>Gets the local importance data frame from a model</p></a></li>
<li><a href='#get_moran'><p>Gets Moran's I test of model residuals</p></a></li>
<li><a href='#get_performance'><p>Gets out-of-bag performance scores from a model</p></a></li>
<li><a href='#get_predictions'><p>Gets model predictions</p></a></li>
<li><a href='#get_residuals'><p>Gets model residuals</p></a></li>
<li><a href='#get_response_curves'><p>Gets data to allow custom plotting of response curves</p></a></li>
<li><a href='#get_spatial_predictors'><p>Gets the spatial predictors of a spatial model</p></a></li>
<li><a href='#is_binary'><p>Checks if dependent variable is binary with values 1 and 0</p></a></li>
<li><a href='#make_spatial_fold'><p>Makes one training and one testing spatial folds</p></a></li>
<li><a href='#make_spatial_folds'><p>Makes training and testing spatial folds</p></a></li>
<li><a href='#mem'><p>Moran's Eigenvector Maps of a distance matrix</p></a></li>
<li><a href='#mem_multithreshold'><p>Moran's Eigenvector Maps for different distance thresholds</p></a></li>
<li><a href='#moran'><p>Moran's I test</p></a></li>
<li><a href='#moran_multithreshold'><p>Moran's I test on a numeric vector for different neighborhoods</p></a></li>
<li><a href='#objects_size'><p>Shows size of objects in the R environment</p></a></li>
<li><a href='#optimization_function'><p>Optimization equation to select spatial predictors</p></a></li>
<li><a href='#pca'><p>Principal Components Analysis</p></a></li>
<li><a href='#pca_multithreshold'><p>PCA of a distance matrix over distance thresholds</p></a></li>
<li><a href='#plant_richness_df'><p>Plant richness and predictors of American ecoregions</p></a></li>
<li><a href='#plot_evaluation'><p>Plots the results of a spatial cross-validation</p></a></li>
<li><a href='#plot_importance'><p>Plots the variable importance of a model</p></a></li>
<li><a href='#plot_moran'><p>Plots a Moran's I test of model residuals</p></a></li>
<li><a href='#plot_optimization'><p>Optimization plot of a selection of spatial predictors</p></a></li>
<li><a href='#plot_residuals_diagnostics'><p>Plot residuals diagnostics</p></a></li>
<li><a href='#plot_response_curves'><p>Plots the response curves of a model.</p></a></li>
<li><a href='#plot_response_surface'><p>Plots the response surfaces of a random forest model</p></a></li>
<li><a href='#plot_training_df'><p>Scatterplots of a training data frame</p></a></li>
<li><a href='#plot_training_df_moran'><p>Moran's I plots of a training data frame</p></a></li>
<li><a href='#plot_tuning'><p>Plots a tuning object produced by <code>rf_tuning()</code></p></a></li>
<li><a href='#prepare_importance_spatial'><p>Prepares variable importance objects for spatial models</p></a></li>
<li><a href='#print_evaluation'><p>Prints cross-validation results</p></a></li>
<li><a href='#print_importance'><p>Prints variable importance</p></a></li>
<li><a href='#print_moran'><p>Prints results of a Moran's I test</p></a></li>
<li><a href='#print_performance'><p>print_performance</p></a></li>
<li><a href='#print.rf'><p>Custom print method for random forest models</p></a></li>
<li><a href='#rank_spatial_predictors'><p>Ranks spatial predictors</p></a></li>
<li><a href='#rescale_vector'><p>Rescales a numeric vector into a new range</p></a></li>
<li><a href='#residuals_diagnostics'><p>Normality test of a numeric vector</p></a></li>
<li><a href='#residuals_test'><p>Normality test of a numeric vector</p></a></li>
<li><a href='#rf'><p>Random forest models with Moran's I test of the residuals</p></a></li>
<li><a href='#rf_compare'><p>Compares models via spatial cross-validation</p></a></li>
<li><a href='#rf_evaluate'><p>Evaluates random forest models with spatial cross-validation</p></a></li>
<li><a href='#rf_importance'><p>Contribution of each predictor to model transferability</p></a></li>
<li><a href='#rf_repeat'><p>Fits several random forest models on the same data</p></a></li>
<li><a href='#rf_spatial'><p>Fits spatial random forest models</p></a></li>
<li><a href='#rf_tuning'><p>Tuning of random forest hyperparameters via spatial cross-validation</p></a></li>
<li><a href='#root_mean_squared_error'><p>RMSE and normalized RMSE</p></a></li>
<li><a href='#select_spatial_predictors_recursive'><p>Finds optimal combinations of spatial predictors</p></a></li>
<li><a href='#select_spatial_predictors_sequential'><p>Sequential introduction of spatial predictors into a model</p></a></li>
<li><a href='#standard_error'><p>Standard error of the mean of a numeric vector</p></a></li>
<li><a href='#statistical_mode'><p>Statistical mode of a vector</p></a></li>
<li><a href='#the_feature_engineer'><p>Suggest variable interactions and composite features for random forest models</p></a></li>
<li><a href='#thinning'><p>Applies thinning to pairs of coordinates</p></a></li>
<li><a href='#thinning_til_n'><p>Applies thinning to pairs of coordinates until reaching a given n</p></a></li>
<li><a href='#vif'><p>Variance Inflation Factor of a data frame</p></a></li>
<li><a href='#weights_from_distance_matrix'><p>Transforms a distance matrix into a matrix of weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Easy Spatial Modeling with Random Forest</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://blasbenito.github.io/spatialRF/">https://blasbenito.github.io/spatialRF/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/BlasBenito/spatialRF/issues/">https://github.com/BlasBenito/spatialRF/issues/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Automatic generation and selection of spatial predictors for spatial regression with Random Forest. Spatial predictors are surrogates of variables driving the spatial structure of a response variable. The package offers two methods to generate spatial predictors from a distance matrix among training cases: 1) Moran's Eigenvector Maps (MEMs; Dray, Legendre, and Peres-Neto 2006 &lt;<a href="https://doi.org/10.1016%2Fj.ecolmodel.2006.02.015">doi:10.1016/j.ecolmodel.2006.02.015</a>&gt;): computed as the eigenvectors of a weighted matrix of distances; 2) RFsp (Hengl et al. &lt;<a href="https://doi.org/10.7717%2Fpeerj.5518">doi:10.7717/peerj.5518</a>&gt;): columns of the distance matrix used as spatial predictors. Spatial predictors help minimize the spatial autocorrelation of the model residuals and facilitate an honest assessment of the importance scores of the non-spatial predictors. Additionally, functions to reduce multicollinearity, identify relevant variable interactions, tune random forest hyperparameters, assess model transferability via spatial cross-validation, and explore model results via partial dependence curves and interaction surfaces are included in the package. The modelling functions are built around the highly efficient 'ranger' package (Wright and Ziegler 2017 &lt;<a href="https://doi.org/10.18637%2Fjss.v077.i01">doi:10.18637/jss.v077.i01</a>&gt;).  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, magrittr, stats, tibble, utils, foreach,
doParallel, ranger, rlang, tidyr, tidyselect, huxtable,
patchwork, viridis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, spelling</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-19 15:35:43 UTC; blas</td>
</tr>
<tr>
<td>Author:</td>
<td>Blas M. Benito <a href="https://orcid.org/0000-0001-5105-7232"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blas M. Benito &lt;blasbenito@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auc'>Area under the ROC curve</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>Computes the area under the ROC curve in models with binary responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(o, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_o">o</code></td>
<td>
<p>Numeric vector with observations, must have the same length as <code>p</code>.</p>
</td></tr>
<tr><td><code id="auc_+3A_p">p</code></td>
<td>
<p>Numeric vector with predictions, must have the same length as <code>o</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, AUC value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 out &lt;- auc(
   o = c(0, 0, 1, 1),
   p = c(0.1, 0.6, 0.4, 0.8)
   )

}
</code></pre>

<hr>
<h2 id='auto_cor'>Multicollinearity reduction via Pearson correlation</h2><span id='topic+auto_cor'></span>

<h3>Description</h3>

<p>Computes the correlation matrix among a set of predictors, orders the correlation matrix according to a user-defined preference order, and removes variables one by one, taking into account the preference order, until the remaining ones are below a given Pearson correlation threshold. <strong>Warning</strong>: variables in <code>preference.order</code> not in <code>colnames(x)</code>, and non-numeric columns are removed silently from <code>x</code> and <code>preference.order</code>. The same happens with rows having NA values (<code><a href="stats.html#topic+na.omit">na.omit()</a></code> is applied). The function issues a warning if zero-variance columns are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_cor(
  x = NULL,
  preference.order = NULL,
  cor.threshold = 0.5,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_cor_+3A_x">x</code></td>
<td>
<p>A data frame with predictors, or the result of <code><a href="#topic+auto_vif">auto_vif()</a></code> Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="auto_cor_+3A_preference.order">preference.order</code></td>
<td>
<p>Character vector indicating the user's order of preference to keep variables. Doesn't need to contain If not provided, variables in <code>x</code> are prioritised by their column order. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="auto_cor_+3A_cor.threshold">cor.threshold</code></td>
<td>
<p>Numeric between 0 and 1, with recommended values between 0.5 and 0.9. Maximum Pearson correlation between any pair of the selected variables. Default: <code>0.50</code></p>
</td></tr>
<tr><td><code id="auto_cor_+3A_verbose">verbose</code></td>
<td>
<p>Logical. if <code>TRUE</code>, describes the function operations to the user. Default:: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be chained together with <code><a href="#topic+auto_vif">auto_vif()</a></code> through pipes, see the examples below.
</p>


<h3>Value</h3>

<p>List with three slots:
</p>

<ul>
<li> <p><code>cor</code>: correlation matrix of the selected variables.
</p>
</li>
<li> <p><code>selected.variables</code>: character vector with the names of the selected variables.
</p>
</li>
<li> <p><code>selected.variables.df</code>: data frame with the selected variables.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+auto_vif">auto_vif()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #load data
 data(plant_richness_df)

 #on a data frame
 out &lt;- auto_cor(x = plant_richness_df[, 5:21])

 #getting the correlation matrix
 out$cor

 #getting the names of the selected variables
 out$selected.variables

 #getting the data frame of selected variables
 out$selected.variables.df

 #on the result of auto_vif
 out &lt;- auto_vif(x = plant_richness_df[, 5:21])
 out &lt;- auto_cor(x = out)

 #with pipes
 out &lt;- plant_richness_df[, 5:21] %&gt;%
 auto_vif() %&gt;%
 auto_cor()

}
</code></pre>

<hr>
<h2 id='auto_vif'>Multicollinearity reduction via Variance Inflation Factor</h2><span id='topic+auto_vif'></span>

<h3>Description</h3>

<p>Selects predictors that are not linear combinations of other predictors by using computing their variance inflation factors (VIF). Allows the user to define an order of preference for the selection of predictors. <strong>Warning</strong>: variables in <code>preference.order</code> not in <code>colnames(x)</code>, and non-numeric columns are removed silently from <code>x</code> and <code>preference.order</code>. The same happens with rows having NA values (<code><a href="stats.html#topic+na.omit">na.omit()</a></code> is applied). The function issues a warning if zero-variance columns are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_vif(
  x = NULL,
  preference.order = NULL,
  vif.threshold = 5,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_vif_+3A_x">x</code></td>
<td>
<p>A data frame with predictors or the result of <code><a href="#topic+auto_cor">auto_cor()</a></code>. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="auto_vif_+3A_preference.order">preference.order</code></td>
<td>
<p>a character vector with columns names of x ordered by the user preference, Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="auto_vif_+3A_vif.threshold">vif.threshold</code></td>
<td>
<p>Numeric between 2.5 and 10 defining the selection threshold for the VIF analysis. Higher numbers result in a more relaxed variable selection. Default: 5.</p>
</td></tr>
<tr><td><code id="auto_vif_+3A_verbose">verbose</code></td>
<td>
<p>Logical. if <code>TRUE</code>, describes the function operations to the user. Default:: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has two modes of operation:
</p>

<ul>
<li><p> 1. When the argument <code>preference.order</code> is <code>NULL</code>, the function removes on each iteration the variable with the highest VIF until all VIF values are lower than <code>vif.threshold</code>.
</p>
</li>
<li><p> 2. When <code>preference.order</code> is provided, the variables are selected by giving them priority according to their order in <code>preference.order</code>. If there are variables not in <code>preference.order</code>, these are selected as in option 1. Once both groups of variables have been processed, all variables are put together and selected by giving priority to the ones in <code>preference.order</code>. This method preserves the variables desired by the user as much as possible.
</p>
</li></ul>

<p>Can be chained together with <code><a href="#topic+auto_cor">auto_cor()</a></code> through pipes, see the examples below.
</p>


<h3>Value</h3>

<p>List with three slots:
</p>

<ul>
<li> <p><code>vif</code>: data frame with the names of the selected variables and their respective VIF scores.
</p>
</li>
<li> <p><code>selected.variables</code>: character vector with the names of the selected variables.
</p>
</li>
<li> <p><code>selected.variables.df</code>: data frame with the selected variables.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+auto_cor">auto_cor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading data
data(plant_richness_df)

#on a data frame
out &lt;- auto_vif(x = plant_richness_df[, 5:21])

#getting out the vif data frame
out$vif

#getting the names of the selected variables
out$selected.variables

#getting the data frame of selected variables
out$selected.variables.df

#on the result of auto_cor
out &lt;- auto_cor(x = plant_richness_df[, 5:21])
out &lt;- auto_vif(x = out)

#with pipes
out &lt;- plant_richness_df[, 5:21] %&gt;%
 auto_cor() %&gt;%
 auto_vif()

}
</code></pre>

<hr>
<h2 id='beowulf_cluster'>Defines a beowulf cluster</h2><span id='topic+beowulf_cluster'></span>

<h3>Description</h3>

<p>Defines a Beowulf cluster from the IPs of the machines in the cluster, the number of cores of each machine, and the user name. The returned cluster has to be registered with <code>doParallel::registerDoParallel()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beowulf_cluster(
  cluster.ips = NULL,
  cluster.cores = NULL,
  cluster.user = Sys.info()[["user"]],
  cluster.port = "11000",
  outfile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beowulf_cluster_+3A_cluster.ips">cluster.ips</code></td>
<td>
<p>Character vector with the IPs of the machines in the cluster. The first machine will be considered the main node of the cluster, and will generally be the machine on which the R code is being executed. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="beowulf_cluster_+3A_cluster.cores">cluster.cores</code></td>
<td>
<p>Numeric integer vector, number of cores on each machine. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="beowulf_cluster_+3A_cluster.user">cluster.user</code></td>
<td>
<p>Character string, name of the user (should be the same throughout machines), Defaults to the current system user.</p>
</td></tr>
<tr><td><code id="beowulf_cluster_+3A_cluster.port">cluster.port</code></td>
<td>
<p>Character, port used by the machines in the cluster to communicate. The firewall in all computers must allow traffic from and to such port. Default: <code>"11000"</code></p>
</td></tr>
<tr><td><code id="beowulf_cluster_+3A_outfile">outfile</code></td>
<td>
<p>Where to direct the messages provided by the workers. When working on a local computer, <code>""</code> prints the worker's messages in the console. A text file path will append worker's messages on the given file.  Default: <code style="white-space: pre;">&#8288;/dev/null&#8288;</code> en Linux and  <code style="white-space: pre;">&#8288;nul:&#8288;</code> on windows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list ready to be used as input for the <code>spec</code> argument of the function <a href="parallel.html#topic+makeCluster">makeCluster</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

beowulf.cluster &lt;- beowulf_cluster(
 cluster.ips = c(
   "10.42.0.1",
   "10.42.0.34",
   "10.42.0.104"
   ),
cluster.cores = c(7, 4, 4),
cluster.user = "blas",
cluster.port = "11000"
)


doParallel::registerDoParallel(cl = beowulf.cluster)

#PARALLELIZED foreach LOOP HERE

parallel::stopCluster(cl = beowulf.cluster)

}

</code></pre>

<hr>
<h2 id='case_weights'>Generates case weights for binary data</h2><span id='topic+case_weights'></span>

<h3>Description</h3>

<p>When the data is binary, setting the <code>ranager</code> argument <code>case.weights</code> helps to minimize the issues produced by class imbalance. This function takes a binary response variable and returns a vector of weights populated with the values <code style="white-space: pre;">&#8288;1/#zeros&#8288;</code> and <code style="white-space: pre;">&#8288;1/#ones&#8288;</code>. It is used internally by the function <code><a href="#topic+rf">rf()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_weights(data = NULL, dependent.variable.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_weights_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="case_weights_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with a length equal to <code>nrow(data)</code> with the respective weights of the cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 data &lt;- data.frame(
   response = c(0, 0, 0, 1, 1)
 )

 case_weights(
   data = data,
   dependent.variable.name = "response"
 )

 }
</code></pre>

<hr>
<h2 id='default_distance_thresholds'>Default distance thresholds to generate spatial predictors</h2><span id='topic+default_distance_thresholds'></span>

<h3>Description</h3>

<p>Generates four distance thresholds, from 0 to max(distance.matrix)/2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_distance_thresholds(distance.matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_distance_thresholds_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Distance matrix. Default: <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with distance thresholds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example distance matrix
 data(distance_matrix)

 #computing set of default distance thresholds
 default_distance_thresholds(distance_matrix)

 }
</code></pre>

<hr>
<h2 id='distance_matrix'>Matrix of distances among ecoregion edges.</h2><span id='topic+distance_matrix'></span>

<h3>Description</h3>

<p>Distance matrix (in km) among the edges of the American ecoregions described in the <a href="#topic+plant_richness_df">plant_richness_df</a> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(distance_matrix)
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 227 rows and columns.
</p>


<h3>See Also</h3>

<p><a href="#topic+plant_richness_df">plant_richness_df</a>
</p>

<hr>
<h2 id='double_center_distance_matrix'>Double centers a distance matrix</h2><span id='topic+double_center_distance_matrix'></span>

<h3>Description</h3>

<p>Generates a double-centered matrix (row and column means are zero) from the weights of a distance matrix (see <code><a href="#topic+weights_from_distance_matrix">weights_from_distance_matrix()</a></code>) and a distance threshold. This is a required step before the computation of Moran's Eigenvector Maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>double_center_distance_matrix (
  distance.matrix = NULL,
  distance.threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="double_center_distance_matrix_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Distance matrix. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="double_center_distance_matrix_+3A_distance.threshold">distance.threshold</code></td>
<td>
<p>Numeric, positive, in the range of values of <code>x</code>. Distances below this value in the distance matrix are set to 0.  Default: <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double-centered matrix of the same dimensions as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weights_from_distance_matrix">weights_from_distance_matrix()</a></code>, <code><a href="#topic+mem">mem()</a></code>, <code><a href="#topic+mem_multithreshold">mem_multithreshold()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading the distance matrix
 data(distance_matrix)

 x &lt;- double_center_distance_matrix(
   distance.matrix = distance_matrix
 )
 x

 }
</code></pre>

<hr>
<h2 id='filter_spatial_predictors'>Removes redundant spatial predictors</h2><span id='topic+filter_spatial_predictors'></span>

<h3>Description</h3>

<p>Removes spatial predictors that are pair-wise correlated with other spatial predictors (which happens when there are several close distance thresholds), and spatial predictors correlated with non-spatial predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_spatial_predictors(
  data = NULL,
  predictor.variable.names = NULL,
  spatial.predictors.df = NULL,
  cor.threshold = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_spatial_predictors_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="filter_spatial_predictors_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="filter_spatial_predictors_+3A_spatial.predictors.df">spatial.predictors.df</code></td>
<td>
<p>Data frame of spatial predictors.</p>
</td></tr>
<tr><td><code id="filter_spatial_predictors_+3A_cor.threshold">cor.threshold</code></td>
<td>
<p>Numeric between 0 and 1, maximum Pearson correlation between any pair of the selected variables. Default: <code>0.50</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with non-redundant spatial predictors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading data
data("distance_matrix")
data("plant_richness_df")

#computing Moran's Eigenvector Maps
spatial.predictors.df &lt;- mem_multithreshold(
  distance_matrix = distance_matrix,
  distance.thresholds = c(0, 1000)
  )

#filtering spatial predictors
spatial.predictors.df &lt;- filter_spatial_predictors(
  data = plant_richness_df,
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  spatial.predictors.df = spatial.predictors.df,
  cor.threshold = 0.50
 )


}
</code></pre>

<hr>
<h2 id='get_evaluation'>Gets performance data frame from a cross-validated model</h2><span id='topic+get_evaluation'></span>

<h3>Description</h3>

<p>Returns performance metrics produced by <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_evaluation(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_evaluation_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with evaluation scores. The following columns are shown:
</p>

<ul>
<li> <p><code>model</code>: Identifies the given model. The values are &quot;Full&quot;, (original model introduced into <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>), &quot;Training&quot; (model trained on an independent training spatial fold), and &quot;Testing&quot; (predictive performance of the training model on an independent testing spatial fold). The performance values of the &quot;Testing&quot; model represent the model performance on unseen data, and hence its ability to generalize.
</p>
</li>
<li> <p><code>metric</code>: Four values representing different evaluation metrics, &quot;rmse&quot;, &quot;nrmse&quot;, &quot;r.squared&quot;, and &quot;pseudo.r.squared&quot;.
</p>
</li>
<li> <p><code>mean</code>, <code>sd</code>, <code>min</code>, and <code>max</code>: Average, standard deviation, minimum, and maximum of each metric across the evaluation (cross-validation) iterations.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>, <code><a href="#topic+plot_evaluation">plot_evaluation()</a></code>, <code><a href="#topic+print_evaluation">print_evaluation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading data
data(plant_richness_df)
data(distance_matrix)

#fitting a random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

#evaluating the model with spatial cross-validation
rf.model &lt;- rf_evaluate(
  model = rf.model,
  xy = plant_richness_df[, c("x", "y")],
  n.cores = 1,
  verbose = FALSE
)

#getting evaluation results from the model
x &lt;- get_evaluation(rf.model)
x

}
</code></pre>

<hr>
<h2 id='get_importance'>Gets the global importance data frame from a model</h2><span id='topic+get_importance'></span>

<h3>Description</h3>

<p>Gets variable importance scores from <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, and <code><a href="#topic+rf_spatial">rf_spatial()</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_importance(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_importance_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with variable names and importance scores.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, <code><a href="#topic+rf_spatial">rf_spatial()</a></code>, <code><a href="#topic+plot_importance">plot_importance()</a></code>, <code><a href="#topic+print_importance">print_importance()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

data(plant_richness_df)
data(distance_matrix)

rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

x &lt;- get_importance(rf.model)
x

}
</code></pre>

<hr>
<h2 id='get_importance_local'>Gets the local importance data frame from a model</h2><span id='topic+get_importance_local'></span>

<h3>Description</h3>

<p>Gets local importance scores from <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, and <code><a href="#topic+rf_spatial">rf_spatial()</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_importance_local(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_importance_local_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with variable names and local importance scores.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, <code><a href="#topic+rf_spatial">rf_spatial()</a></code>, <code><a href="#topic+plot_importance">plot_importance()</a></code>, <code><a href="#topic+print_importance">print_importance()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)
data(distance_matrix)

#fittinga random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

#getting importance scores
x &lt;- get_importance_local(rf.model)
x

}
</code></pre>

<hr>
<h2 id='get_moran'>Gets Moran's I test of model residuals</h2><span id='topic+get_moran'></span>

<h3>Description</h3>

<p>Returns the Moran's I test on the residuals of a model produced by <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_moran(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_moran_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with Moran's I test results produced by <code><a href="#topic+moran_multithreshold">moran_multithreshold()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran">moran()</a></code>, <code><a href="#topic+moran_multithreshold">moran_multithreshold()</a></code>, <code><a href="#topic+plot_moran">plot_moran()</a></code>, <code><a href="#topic+print_moran">print_moran()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)
 data(distance_matrix)

 #fitting a random forest model
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = c(0, 1000, 2000),
   n.cores = 1,
   verbose = FALSE
 )

 #getting Moran's I of the residuals
 x &lt;- get_moran(rf.model)

}
</code></pre>

<hr>
<h2 id='get_performance'>Gets out-of-bag performance scores from a model</h2><span id='topic+get_performance'></span>

<h3>Description</h3>

<p>Returns the performance slot of an <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code> model computed on the out-of-bag data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_performance(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_performance_+3A_model">model</code></td>
<td>
<p>Model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with four columns:
</p>

<ul>
<li> <p><code>metric</code> Name of the performance metric.
</p>
</li>
<li> <p><code>median</code> Value of the performance metric. Truly a median only if the model is fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code>.
</p>
</li>
<li> <p><code>median_absolute_deviation</code> median absolute deviation (MAD), only if the model is fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, and <code>NA</code> otherwise.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+print_performance">print_performance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)
 data(distance.matrix)

 #fitting random forest model
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   n.cores = 1,
   verbose = FALSE
 )

 #getting model performance
 x &lt;- get_performance(rf.model)
 x

}
</code></pre>

<hr>
<h2 id='get_predictions'>Gets model predictions</h2><span id='topic+get_predictions'></span>

<h3>Description</h3>

<p>Returns model predictions from a model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predictions(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predictions_+3A_model">model</code></td>
<td>
<p>A model produced by <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with predictions, or median of the predictions across repetitions if the model was fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)

#fitting a random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  n.cores = 1,
  verbose = FALSE
)

#get vector of predictions
x &lt;- get_predictions(rf.model)
x

}
</code></pre>

<hr>
<h2 id='get_residuals'>Gets model residuals</h2><span id='topic+get_residuals'></span>

<h3>Description</h3>

<p>Returns the residuals of models fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_residuals(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_residuals_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with model residuals, or the median of model residuals across repetitions if the model was fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#load example data
data(plant_richness_df)

#fit random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  n.cores = 1,
  verbose = FALSE
)

#getting vector with residuals
x &lt;- get_residuals(rf.model)
x

}
</code></pre>

<hr>
<h2 id='get_response_curves'>Gets data to allow custom plotting of response curves</h2><span id='topic+get_response_curves'></span>

<h3>Description</h3>

<p>Generates and returns the data required to plot the response curves of a model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_response_curves(
  model = NULL,
  variables = NULL,
  quantiles = c(0.1, 0.5, 0.9),
  grid.resolution = 200,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_response_curves_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_variables">variables</code></td>
<td>
<p>Character vector, names of predictors to plot. If <code>NULL</code>, the most important variables (importance higher than the median) in <code>model</code> are selected. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector with values between 0 and 1, argument <code>probs</code> of <a href="stats.html#topic+quantile">quantile</a>. Quantiles to set the other variables to. Default: <code>c(0.1, 0.5, 0.9)</code></p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_grid.resolution">grid.resolution</code></td>
<td>
<p>Integer between 20 and 500. Resolution of the plotted curve Default: <code>100</code></p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if TRUE the plot is printed. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All variables that are not plotted in a particular response curve are set to the values of their respective quantiles, and the response curve for each one of these quantiles is shown in the plot.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>

<ul>
<li> <p><code>response</code>: Predicted values of the response, obtained with <code>stats::predict()</code>.
</p>
</li>
<li> <p><code>predictor</code>: Values of the given predictor.
</p>
</li>
<li> <p><code>quantile</code>: Grouping column, values of the quantiles at which the other predictors are set to generate the response curve.
</p>
</li>
<li> <p><code>model</code>: Model number, only relevant if the model was produced with <code><a href="#topic+rf_repeat">rf_repeat()</a></code>.
</p>
</li>
<li> <p><code>predictor.name</code>: Grouping variable, name of the predictor.
</p>
</li>
<li> <p><code>response.name</code>: Grouping variable, name of the response variable.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_response_curves">plot_response_curves()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)

#fitting random forest model
out &lt;- rf(
 data = plant_richness_df,
 dependent.variable.name = "richness_species_vascular",
 predictor.variable.names = colnames(plant_richness_df)[5:21],
 n.cores = 1,
 verbose = FALSE
)

#getting data frame with response curves
p &lt;- get_response_curves(out)
head(p)

}
</code></pre>

<hr>
<h2 id='get_spatial_predictors'>Gets the spatial predictors of a spatial model</h2><span id='topic+get_spatial_predictors'></span>

<h3>Description</h3>

<p>Returns spatial predictors from a model fitted with <code><a href="#topic+rf_spatial">rf_spatial()</a></code> in order of importance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_spatial_predictors(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_spatial_predictors_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the spatial predictors included in the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(distance_matrix)
 data(plant_richness_df)

 #fittind spatial model
 model &lt;- rf_spatial(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = c(0, 1000),
   n.cores = 1,
   method = "mem.moran.sequential"
 )

#getting data frame with the selected spatial predictors
spatial.predictors &lt;- get_spatial_predictors(model)
head(spatial.predictors)

}
</code></pre>

<hr>
<h2 id='is_binary'>Checks if dependent variable is binary with values 1 and 0</h2><span id='topic+is_binary'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if <code>dependent.variable.name</code> is a binary variable with the values 1 and 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_binary(data = NULL, dependent.variable.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_binary_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="is_binary_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #dummy data frame
 data &lt;- data.frame(
   response = c(0, 0, 0, 1, 1)
 )

 #checking if response is binary
 is_binary(
   data = data,
   dependent.variable.name = "response"
 )

}
</code></pre>

<hr>
<h2 id='make_spatial_fold'>Makes one training and one testing spatial folds</h2><span id='topic+make_spatial_fold'></span>

<h3>Description</h3>

<p>Used internally by <code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code> and <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>. Uses the coordinates of a point <code>xy.i</code> to generate two spatially independent data folds from the data frame <code>xy</code>. It does so by growing a rectangular buffer from <code>xy.i</code> until a number of records defined by <code>training.fraction</code> is inside the buffer. The indices of these records are then stored as &quot;training&quot; in the output list. The indices of the remaining records outside of the buffer are stored as &quot;testing&quot;. These training and testing records can be then used to evaluate a model on independent data via cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_spatial_fold(
  data = NULL,
  dependent.variable.name = NULL,
  xy.i = NULL,
  xy = NULL,
  distance.step.x = NULL,
  distance.step.y = NULL,
  training.fraction = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_spatial_fold_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="make_spatial_fold_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="make_spatial_fold_+3A_xy.i">xy.i</code></td>
<td>
<p>One row data frame with at least three columns: &quot;x&quot; (longitude), &quot;y&quot; (latitude), and &quot;id&quot; (integer, id of the record). Can be a row of <code>xy</code>. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="make_spatial_fold_+3A_xy">xy</code></td>
<td>
<p>A data frame with at least three columns: &quot;x&quot; (longitude), &quot;y&quot; (latitude), and &quot;id&quot; (integer, index of the record). Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="make_spatial_fold_+3A_distance.step.x">distance.step.x</code></td>
<td>
<p>Numeric, distance step used during the growth in the x axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the x coordinates).</p>
</td></tr>
<tr><td><code id="make_spatial_fold_+3A_distance.step.y">distance.step.y</code></td>
<td>
<p>Numeric, distance step used during the growth in the y axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the y coordinates).</p>
</td></tr>
<tr><td><code id="make_spatial_fold_+3A_training.fraction">training.fraction</code></td>
<td>
<p>Numeric, fraction of the data to be included in the training fold, Default: <code>0.8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two slots named <code>training</code> and <code>testing</code> with the former having the indices of the training records selected from <code>xy</code>, and the latter having the indices of the testing records.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code>, <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)

 #getting case coordinates
 xy &lt;- plant_richness_df[, 1:3]
 colnames(xy) &lt;- c("id", "x", "y")

 #building a spatial fold centered in the first pair of coordinates
 out &lt;- make_spatial_fold(
   xy.i = xy[1, ],
   xy = xy,
   training.fraction = 0.6
 )

 #indices of the training and testing folds
 out$training
 out$testing

 #plotting the data
 plot(xy[ c("x", "y")], type = "n", xlab = "", ylab = "")
 #plots training points
 points(xy[out$training, c("x", "y")], col = "red4", pch = 15)
 #plots testing points
 points(xy[out$testing, c("x", "y")], col = "blue4", pch = 15)
 #plots xy.i
 points(xy[1, c("x", "y")], col = "black", pch = 15, cex = 2)

}
</code></pre>

<hr>
<h2 id='make_spatial_folds'>Makes training and testing spatial folds</h2><span id='topic+make_spatial_folds'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+make_spatial_fold">make_spatial_fold()</a></code> to every record in a data frame <code>xy.selected</code> to generate as many spatially independent folds over the dataset <code>xy</code> as rows are in <code>xy.selected</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_spatial_folds(
  data = NULL,
  dependent.variable.name = NULL,
  xy.selected = NULL,
  xy = NULL,
  distance.step.x = NULL,
  distance.step.y = NULL,
  training.fraction = 0.75,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_spatial_folds_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="make_spatial_folds_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="make_spatial_folds_+3A_xy.selected">xy.selected</code></td>
<td>
<p>Data frame with at least three columns: &quot;x&quot; (longitude), &quot;y&quot; (latitude), and &quot;id&quot; (integer, id of the record). Usually a subset of <code>xy</code>. Usually the result of applying <code><a href="#topic+thinning">thinning()</a></code> or <code><a href="#topic+thinning_til_n">thinning_til_n()</a></code> to 'xy' Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="make_spatial_folds_+3A_xy">xy</code></td>
<td>
<p>data frame with at least three columns: &quot;x&quot; (longitude), &quot;y&quot; (latitude), and &quot;id&quot; (integer, index of the record). Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="make_spatial_folds_+3A_distance.step.x">distance.step.x</code></td>
<td>
<p>Numeric, distance step used during the growth in the x axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the x coordinates).</p>
</td></tr>
<tr><td><code id="make_spatial_folds_+3A_distance.step.y">distance.step.y</code></td>
<td>
<p>Numeric, distance step used during the growth in the y axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the y coordinates).</p>
</td></tr>
<tr><td><code id="make_spatial_folds_+3A_training.fraction">training.fraction</code></td>
<td>
<p>numeric, fraction of the data to be included in the growing buffer as training data, Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="make_spatial_folds_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="make_spatial_folds_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with as many slots as rows are in <code>xy.selected</code>. Each slot has two slots named <code>training</code> and <code>testing</code>, with the former having the indices of the training records selected from xy, and the latter having the indices of the testing records.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_spatial_fold">make_spatial_fold()</a></code>, <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)

 #getting case coordinates
 xy &lt;- plant_richness_df[, 1:3]
 colnames(xy) &lt;- c("id", "x", "y")

 #thining til 20 cases
 xy.selected &lt;- thinning_til_n(
   xy = xy,
   n = 20
   )

 #making spatial folds centered on these 20 cases
 out &lt;- make_spatial_folds(
   xy.selected = xy.selected,
   xy = xy,
   distance.step = 0.05, #degrees
   training.fraction = 0.6,
   n.cores = 1
 )

 #plotting training and testing folds
 plot(xy[ c("x", "y")], type = "n", xlab = "", ylab = "")
 #plots training points
 points(xy[out[[10]]$training, c("x", "y")], col = "red4", pch = 15)
 #plots testing points
 points(xy[out[[10]]$testing, c("x", "y")], col = "blue4", pch = 15)
 #plots xy.i
 points(xy[10, c("x", "y")], col = "black", pch = 15, cex = 2)

}
</code></pre>

<hr>
<h2 id='mem'>Moran's Eigenvector Maps of a distance matrix</h2><span id='topic+mem'></span>

<h3>Description</h3>

<p>Computes the positive Moran's Eigenvector Maps of a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem(
  distance.matrix = NULL,
  distance.threshold = 0,
  colnames.prefix = "mem"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mem_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Distance matrix. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mem_+3A_distance.threshold">distance.threshold</code></td>
<td>
<p>Numeric vector with distance thresholds defining different neighborhood extents within the distance matrix, Default: 0</p>
</td></tr>
<tr><td><code id="mem_+3A_colnames.prefix">colnames.prefix</code></td>
<td>
<p>Character, name prefix for the output columns. Default: <code>"mem"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the distance matrix <code>x</code>, double-centers it with <code><a href="#topic+double_center_distance_matrix">double_center_distance_matrix()</a></code>, applies <a href="base.html#topic+eigen">eigen</a>, and returns eigenvectors with positive normalized eigenvalues (a.k.a Moran's Eigenvector Maps, or MEMs). These MEMs are later used as spatial predictors by <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Value</h3>

<p>A data frame with positive Moran's Eigenvector Maps.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mem_multithreshold">mem_multithreshold()</a></code>, <code><a href="#topic+rf_spatial">rf_spatial()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example distance matrix
 data(distance_matrix)

 #Moran's Eigenvector Maps of the distance matrix
 mem &lt;- mem(x = distance_matrix)

}
</code></pre>

<hr>
<h2 id='mem_multithreshold'>Moran's Eigenvector Maps for different distance thresholds</h2><span id='topic+mem_multithreshold'></span>

<h3>Description</h3>

<p>Computes Moran's Eigenvector Maps of a distance matrix (using <code><a href="#topic+mem">mem()</a></code>) over different distance thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem_multithreshold(
  distance.matrix = NULL,
  distance.thresholds = NULL,
  max.spatial.predictors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mem_multithreshold_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Distance matrix. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mem_multithreshold_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector with distance thresholds defining neighborhood in the distance matrix, Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mem_multithreshold_+3A_max.spatial.predictors">max.spatial.predictors</code></td>
<td>
<p>Maximum number of spatial predictors to generate. Only useful to save memory when the distance matrix <code>x</code> is very large. Default: <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the distance matrix <code>x</code>, computes its weights at difference distance thresholds, double-centers the resulting weight matrices with <code><a href="#topic+double_center_distance_matrix">double_center_distance_matrix()</a></code>, applies <a href="base.html#topic+eigen">eigen</a> to each double-centered matrix, and returns eigenvectors with positive normalized eigenvalues for different distance thresholds.
</p>


<h3>Value</h3>

<p>A data frame with as many rows as the distance matrix <code>x</code> containing positive Moran's Eigenvector Maps. The data frame columns are named &quot;spatial_predictor_DISTANCE_COLUMN&quot;, where DISTANCE is the given distance threshold, and COLUMN is the column index of the given spatial predictor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(distance_matrix)

 #computing Moran's eigenvector maps for 0, 1000, and 2000 km
 mem.df &lt;- mem_multithreshold(
   distance.matrix = distance_matrix,
   distance.thresholds = c(0, 1000, 2000)
   )
 head(mem.df)

}
</code></pre>

<hr>
<h2 id='moran'>Moran's I test</h2><span id='topic+moran'></span>

<h3>Description</h3>

<p>Computes the spatial correlation coefficient (Moran's I) of a vector given a distance matrix, and a distance threshold used to define &quot;neighborhood&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran(
  x = NULL,
  distance.matrix = NULL,
  distance.threshold = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran_+3A_x">x</code></td>
<td>
<p>Numeric vector, generally model residuals, Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="moran_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Distance matrix among cases in <code>x</code>. The number of rows of this matrix must be equal to the length of <code>x</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="moran_+3A_distance.threshold">distance.threshold</code></td>
<td>
<p>numeric value in the range of values available in <code>distance.matrix</code>. Distances below such threshold are set to 0. Default: <code>NULL</code> (which defaults to 0).</p>
</td></tr>
<tr><td><code id="moran_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, prints a Moran's I plot. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired in the <code>Moran.I()</code> function of the <a href="https://cran.r-project.org/package=ape">ape</a> package.
</p>


<h3>Value</h3>

<p>A list with three named slots:
</p>

<ul>
<li> <p><code>test</code>: Data frame with observed and expected Moran's I values, p-value, and interpretation.
</p>
</li>
<li> <p><code>plot</code>: Moran's plot of the vector x against the spatial lags of x.
</p>
</li>
<li> <p><code>plot.df</code>: Data used in the Moran's plot.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+moran_multithreshold">moran_multithreshold()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(distance_matrix)
 data(plant_richness)

 #Moran's I of the response variable
 out &lt;- moran(
   x = plant_richness$richness_species_vascular,
   distance.matrix = distance_matrix
   )
 out

}
</code></pre>

<hr>
<h2 id='moran_multithreshold'>Moran's I test on a numeric vector for different neighborhoods</h2><span id='topic+moran_multithreshold'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+moran">moran()</a></code> to different distance thresholds at the same time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran_multithreshold(
  x = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran_multithreshold_+3A_x">x</code></td>
<td>
<p>Numeric vector, generally model residuals, Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="moran_multithreshold_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Distance matrix among cases in <code>x</code>. The number of rows of this matrix must be equal to the length of <code>x</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="moran_multithreshold_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector, distances below each value are set to 0 on separated copies of the distance matrix for the computation of Moran's I at different neighborhood distances. If <code>NULL</code>, it defaults to <code>seq(0, max(distance.matrix)/4, length.out = 2)</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="moran_multithreshold_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, plots Moran's I values for each distance threshold. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using different distance thresholds helps to take into account the uncertainty about what &quot;neighborhood&quot; means in ecological systems (1000km in geological time means little, but 100m might be quite a long distance for a tree to disperse seeds over), and allows to explore spatial autocorrelation of model residuals for several minimum-distance criteria at once.
</p>


<h3>Value</h3>

<p>A named list with the slots:
</p>

<ul>
<li> <p><code>df</code>: Data frame with the results of <a href="#topic+moran">moran</a> per distance threshold.
</p>
</li>
<li> <p><code>plot</code>: A plot of Moran's I across distance thresholds.
</p>
</li>
<li> <p><code>max.moran</code>: Maximum value of Moran's I across thresholds.
</p>
</li>
<li> <p><code>max.moran.distance.threshold</code>: Distance threshold with the maximum Moran's I value.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+moran">moran()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(distance_matrix)
 data(plant_richness)

 #computing Moran's I for the response variable at several reference distances
 out &lt;- moran_multithreshold(
   x = plant_richness$richness_species_vascular,
   distance.matrix = distance_matrix,
   distance.thresholds = c(0, 100, 1000, 10000),
   plot = TRUE
   )
 out

}
</code></pre>

<hr>
<h2 id='objects_size'>Shows size of objects in the R environment</h2><span id='topic+objects_size'></span>

<h3>Description</h3>

<p>Shows the size of the objects currently in the R environment. Helps to locate large objects cluttering the R environment and/or causing memory problems during the execution of large workflows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objects_size(n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objects_size_+3A_n">n</code></td>
<td>
<p>Number of objects to show, Default: <code>10</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the row names indicating the object name, the field 'Type' indicating the object type, 'Size' indicating the object size, and the columns 'Length/Rows' and 'Columns' indicating the object dimensions if applicable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #creating dummy objects
 x &lt;- matrix(runif(100), 10, 10)
 y &lt;- matrix(runif(10000), 100, 100)

 #reading their in-memory size
 objects_size()

}
</code></pre>

<hr>
<h2 id='optimization_function'>Optimization equation to select spatial predictors</h2><span id='topic+optimization_function'></span>

<h3>Description</h3>

<p>Optimizes the selection of spatial predictors using two different methods: &quot;moran.i&quot;, and &quot;p.value&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimization_function(
  x = NULL,
  weight.r.squared = NULL,
  weight.penalization.n.predictors = NULL,
  optimization.method = "moran.i"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimization_function_+3A_x">x</code></td>
<td>
<p>Optimization data frame generated internally by <code><a href="#topic+select_spatial_predictors_sequential">select_spatial_predictors_sequential()</a></code> or <code><a href="#topic+select_spatial_predictors_recursive">select_spatial_predictors_recursive()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="optimization_function_+3A_weight.r.squared">weight.r.squared</code></td>
<td>
<p>Numeric between 0 and 1, weight of R-squared in the optimization process. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="optimization_function_+3A_weight.penalization.n.predictors">weight.penalization.n.predictors</code></td>
<td>
<p>Numeric between 0 and 1, weight of the penalization on the number of added spatial predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="optimization_function_+3A_optimization.method">optimization.method</code></td>
<td>
<p>Character, one of &quot;moran.i&quot;, and &quot;p.value&quot;. Default: <code>"moran.i"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method &quot;moran.i&quot; tries to maximize <code style="white-space: pre;">&#8288;1 - Moran's&#8288;</code> I while taking into account the R-squared of the model and a penalization on the number of introduced spatial predictors through the expression
</p>
<p>(1 - Moran's I) + w1 * r.squared - w2 * penalization
</p>
<p>The method &quot;p.value&quot; uses a binary version of the p-values of Moran's I (1 if &gt;= 0.05, 0 otherwise), and uses the expression
</p>
<p>max(1 - Moran's I, binary p-value) + w1 * r.squared - w2 * penalization
</p>
<p>The &quot;moran.i&quot; method generally selects more spatial predictors than the &quot;p.value&quot; method.
</p>


<h3>Value</h3>

<p>A numeric vector with the optimization criteria.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select_spatial_predictors_recursive">select_spatial_predictors_recursive()</a></code>, <code><a href="#topic+select_spatial_predictors_sequential">select_spatial_predictors_sequential()</a></code>
</p>

<hr>
<h2 id='pca'>Principal Components Analysis</h2><span id='topic+pca'></span>

<h3>Description</h3>

<p>Extracts all factors of a principal component analysis of a matrix or data frame. Just a convenient wrapper for <a href="stats.html#topic+prcomp">prcomp</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(
  x = NULL,
  colnames.prefix = "pca_factor"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_x">x</code></td>
<td>
<p>numeric matrix or data frame, Default: NULL</p>
</td></tr>
<tr><td><code id="pca_+3A_colnames.prefix">colnames.prefix</code></td>
<td>
<p>character, name prefix for the output columns, Default: 'pca_factor'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns in <code>x</code> with zero variance are removed before computing the PCA.
</p>


<h3>Value</h3>

<p>A data frame with the PCA factors of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca_multithreshold">pca_multithreshold()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #load example distance matrix
 data(distance_matrix)

 #PCA of the distance matrix
 out &lt;- pca(x = distance_matrix)
 out

}
</code></pre>

<hr>
<h2 id='pca_multithreshold'>PCA of a distance matrix over distance thresholds</h2><span id='topic+pca_multithreshold'></span>

<h3>Description</h3>

<p>Computes PCA factors of a distance matrix over different distance thresholds to generate spatial predictors for a model fitted with <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_multithreshold(
  distance.matrix = NULL,
  distance.thresholds = NULL,
  max.spatial.predictors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_multithreshold_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Distance matrix. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="pca_multithreshold_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector with distance thresholds defining neighborhood in the distance matrix, Default: <code>0</code></p>
</td></tr>
<tr><td><code id="pca_multithreshold_+3A_max.spatial.predictors">max.spatial.predictors</code></td>
<td>
<p>Integer, maximum number of spatial predictors to generate. Only useful when the distance matrix <code>x</code> is very large. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance matrix is converted into weights with <code><a href="#topic+weights_from_distance_matrix">weights_from_distance_matrix()</a></code> before computing the PCA. This produces more meaningful spatial predictors than using the distance matrix as is.
</p>


<h3>Value</h3>

<p>A data frame with the PCA factors of the thresholded matrix. The data frame columns are named &quot;spatial_predictor_DISTANCE_COLUMN&quot;, where DISTANCE is the given distance threshold, and COLUMN is the column index of the given predictor.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca">pca()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example distance matrix
 load(distance_matrix)

 #PCA factors of the distance matrix for two reference distances
 x &lt;- pca_multithreshold(
   distance.matrix = distance_matrix,
   distance.thresholds = c(0, 1000)
   )
 head(x)

}
</code></pre>

<hr>
<h2 id='plant_richness_df'>Plant richness and predictors of American ecoregions</h2><span id='topic+plant_richness_df'></span>

<h3>Description</h3>

<p>Richness of vascular plants of the American ecoregions as defined in <a href="https://ecoregions2017.appspot.com/">Ecoregions 2017</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plant_richness_df)
</code></pre>


<h3>Format</h3>

<p>A data frame with 227 rows and 22 columns:
</p>

<ul>
<li> <p><code>ecoregion_id</code>: Id of the ecoregion).
</p>
</li>
<li> <p><code>x</code>: Longitude in degrees (WGS84).
</p>
</li>
<li> <p><code>y</code>: Latitude in degrees (WGS84).
</p>
</li>
<li> <p><code>richness_species_vascular</code>: Number of vascular species found in the ecoregion. Response variable.
</p>
</li>
<li> <p><code>bias_area_km2</code>: Area of the ecoregion in squared kilometers.
</p>
</li>
<li> <p><code>bias_species_per_record</code>: Number of species divided by the number of spatial GBIF records available in the ecoregion as a measure of sampling bias.
</p>
</li>
<li> <p><code>climate_aridity_index_average</code>: Average of the ecoregion.
</p>
</li>
<li> <p><code>climate_hypervolume</code>: Volume of the climatic envelope of the ecoregion, computed with the <a href="https://cran.r-project.org/package=hypervolume">hypervolume</a> package.
</p>
</li>
<li> <p><code>climate_velocity_lgm_average</code>: Average climate velocity of the ecoregion since the Last Glacial Maximum.
</p>
</li>
<li> <p><code>neighbors_count</code>: Number of immediate neighbors of the ecoregion as a measure of connectivity/isolation.
</p>
</li>
<li> <p><code>neighbors_percent_shared_edge</code>: Percentage of shared edge with the neighbors as a measure of connectivity/isolation.
</p>
</li>
<li> <p><code>human_population_density</code>: Population density of the ecoregion.
</p>
</li>
<li> <p><code>topography_elevation_average</code>: Average elevation of the ecoregion.
</p>
</li>
<li> <p><code>landcover_herbs_percent_average</code>: Average cover percentage of herbs extracted from MODIS Vegetation Continuous Fields.
</p>
</li>
<li> <p><code>fragmentation_cohesion</code>: Geographic fragmentation index of the ecoregion as computed with the R package <a href="https://CRAN.R-project.org/package=landscapemetrics">landscapemetrics</a>.
</p>
</li>
<li> <p><code>fragmentation_division</code>: Another fragmentation index.
</p>
</li>
<li> <p><code>neighbors_area</code>: Total area of the ecoregions's immediate neighbors.
</p>
</li>
<li> <p><code>human_population</code>: Human population in the ecoregion.
</p>
</li>
<li> <p><code>human_footprint_average</code>: Average human footprint in the ecoregion.
</p>
</li>
<li> <p><code>climate_bio1_average</code>: Average mean annual temperature.
</p>
</li>
<li> <p><code>climate_bio15_minimum</code>: Average precipitation seasonality.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+distance_matrix">distance_matrix</a>
</p>

<hr>
<h2 id='plot_evaluation'>Plots the results of a spatial cross-validation</h2><span id='topic+plot_evaluation'></span>

<h3>Description</h3>

<p>Plots the results of an spatial cross-validation performed with <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_evaluation(
  model,
  fill.color = viridis::viridis(
    3,
    option = "F",
    alpha = 0.8,
    direction = -1
    ),
  line.color = "gray30",
  verbose = TRUE,
  notch = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_evaluation_+3A_model">model</code></td>
<td>
<p>A model resulting from <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_evaluation_+3A_fill.color">fill.color</code></td>
<td>
<p>Character vector with three hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(3)</code>). Default: <code>viridis::viridis(3, option = "F", alpha = 0.8, direction = -1)</code></p>
</td></tr>
<tr><td><code id="plot_evaluation_+3A_line.color">line.color</code></td>
<td>
<p>Character string, color of the line produced by <code>ggplot2::geom_smooth()</code>. Default: <code>"gray30"</code></p>
</td></tr>
<tr><td><code id="plot_evaluation_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code> the plot is printed. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot_evaluation_+3A_notch">notch</code></td>
<td>
<p>Logical, if <code>TRUE</code>, boxplot notches are plotted. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>, <code><a href="#topic+get_evaluation">get_evaluation()</a></code>, <code><a href="#topic+print_evaluation">print_evaluation()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)
data(distance_matrix)

#fitting a random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

#evaluating the model with spatial cross-validation
rf.model &lt;- rf_evaluate(
  model = rf.model,
  xy = plant_richness_df[, c("x", "y")],
  n.cores = 1
)

#plotting the evaluation results
plot_evaluation(rf.model)

}

</code></pre>

<hr>
<h2 id='plot_importance'>Plots the variable importance of a model</h2><span id='topic+plot_importance'></span>

<h3>Description</h3>

<p>Plots variable importance scores of <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, and <code><a href="#topic+rf_spatial">rf_spatial()</a></code> models. Distributions of importance scores produced with <code><a href="#topic+rf_repeat">rf_repeat()</a></code> are plotted using <code>ggplot2::geom_violin</code>, which shows the median of the density estimate rather than the actual median of the data. However, the violin plots are ordered from top to bottom by the real median of the data to make small differences in median importance easier to spot. Ths function does not plot the result of <code><a href="#topic+rf_importance">rf_importance()</a></code> yet, but you can find it under <code>model$importance$cv.per.variable.plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_importance(
  model,
  fill.color = viridis::viridis(
    100,
    option = "F",
    direction = -1,
    alpha = 1,
    end = 0.9
   ),
  line.color = "white",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_importance_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>, or a data frame with variable importance scores (only for internal use within the package functions).</p>
</td></tr>
<tr><td><code id="plot_importance_+3A_fill.color">fill.color</code></td>
<td>
<p>Character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F", direction = -1, alpha = 0.8, end = 0.9)</code></p>
</td></tr>
<tr><td><code id="plot_importance_+3A_line.color">line.color</code></td>
<td>
<p>Character string, color of the line produced by <code>ggplot2::geom_smooth()</code>. Default: <code>"white"</code></p>
</td></tr>
<tr><td><code id="plot_importance_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the plot is printed. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print_importance">print_importance()</a></code>, <code><a href="#topic+get_importance">get_importance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)
data(distance_matrix)

#fitting a random forest model
rf.model &lt;- rf(
 data = plant_richness_df,
 dependent.variable.name = "richness_species_vascular",
 predictor.variable.names = colnames(plant_richness_df)[5:21],
 distance.matrix = distance_matrix,
 distance.thresholds = 0,
 n.cores = 1,
 verbose = FALSE
)

#plotting variable importance scores
plot_importance(model = rf.model)

}
</code></pre>

<hr>
<h2 id='plot_moran'>Plots a Moran's I test of model residuals</h2><span id='topic+plot_moran'></span>

<h3>Description</h3>

<p>Plots the results of spatial autocorrelation tests for a variety of functions within the package. The x axis represents the Moran's I estimate, the y axis contains the values of the distance thresholds, the dot sizes represent the p-values of the Moran's I estimate, and the red dashed line represents the theoretical null value of the Moran's I estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_moran(
  model,
  point.color = viridis::viridis(
    100,
    option = "F",
    direction = -1
   ),
  line.color = "gray30",
  option = 1,
  ncol = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_moran_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>, or a data frame generated by <code><a href="#topic+moran">moran()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_moran_+3A_point.color">point.color</code></td>
<td>
<p>Colors of the plotted points. Can be a single color name (e.g. &quot;red4&quot;), a character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F")</code></p>
</td></tr>
<tr><td><code id="plot_moran_+3A_line.color">line.color</code></td>
<td>
<p>Character string, color of the line produced by <code>ggplot2::geom_smooth()</code>. Default: <code>"gray30"</code></p>
</td></tr>
<tr><td><code id="plot_moran_+3A_option">option</code></td>
<td>
<p>Integer, type of plot. If <code>1</code> (default) a line plot with Moran's I and p-values across distance thresholds is returned. If <code>2</code>, scatterplots of residuals versus lagged residuals per distance threshold and their corresponding slopes are returned. In models fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, the residuals and lags of the residuals are computed from the median residuals across repetitions. Option <code>2</code> is disabled if <code>x</code> is a data frame generated by <code><a href="#topic+moran">moran()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_moran_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns of the plot. Only relevant when <code>option = 2</code>. Argument <code>ncol</code> of <a href="patchwork.html#topic+wrap_plots">wrap_plots</a>.</p>
</td></tr>
<tr><td><code id="plot_moran_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the resulting plot is printed, Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran">moran()</a></code>, <code><a href="#topic+moran_multithreshold">moran_multithreshold()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)
 data(distance.matrix)

 #fitting a random forest model
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = c(0, 1000, 2000),
   n.cores = 1,
   verbose = FALSE
 )

 #Incremental/multiscale Moran's I
 plot_moran(rf.model)

 #Moran's scatterplot
 plot_moran(rf.model, option = 2)

}
</code></pre>

<hr>
<h2 id='plot_optimization'>Optimization plot of a selection of spatial predictors</h2><span id='topic+plot_optimization'></span>

<h3>Description</h3>

<p>Plots optimization data frames produced by <code><a href="#topic+select_spatial_predictors_sequential">select_spatial_predictors_sequential()</a></code>
and <code><a href="#topic+select_spatial_predictors_recursive">select_spatial_predictors_recursive()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_optimization(
  model,
  point.color = viridis::viridis(
    100,
    option = "F",
    direction = -1
  ),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_optimization_+3A_model">model</code></td>
<td>
<p>A model produced by <code><a href="#topic+rf_spatial">rf_spatial()</a></code>, or an optimization data frame produced by <code><a href="#topic+select_spatial_predictors_sequential">select_spatial_predictors_sequential()</a></code> or <code><a href="#topic+select_spatial_predictors_recursive">select_spatial_predictors_recursive()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_optimization_+3A_point.color">point.color</code></td>
<td>
<p>Colors of the plotted points. Can be a single color name (e.g. &quot;red4&quot;), a character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F", direction = -1)</code></p>
</td></tr>
<tr><td><code id="plot_optimization_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code> the plot is printed. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the method used to fit a model with <code><a href="#topic+rf_spatial">rf_spatial()</a></code> is &quot;hengl&quot;, the function returns nothing, as this method does not require optimization.
</p>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(distance_matrix)
 data(plant_richness_df)

 #names of the response and predictors
 dependent.variable.name &lt;- "richness_species_vascular"
 predictor.variable.names &lt;- colnames(plant_richness_df)[5:21]

 #spatial model
 model &lt;- rf_spatial(
   data = plant_richness_df,
   dependent.variable.name = dependent.variable.name,
   predictor.variable.names = predictor.variable.names,
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   method = "mem.moran.sequential",
   n.cores = 1,
   seed = 1
 )

 #plotting selection of spatial predictors
 plot_optimization(model = model)


}
</code></pre>

<hr>
<h2 id='plot_residuals_diagnostics'>Plot residuals diagnostics</h2><span id='topic+plot_residuals_diagnostics'></span>

<h3>Description</h3>

<p>Plots normality and autocorrelation tests of model residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_residuals_diagnostics(
  model,
  point.color = viridis::viridis(100, option = "F"),
  line.color = "gray10",
  fill.color = viridis::viridis(4, option = "F", alpha = 0.95)[2],
  option = 1,
  ncol = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_residuals_diagnostics_+3A_model">model</code></td>
<td>
<p>A model produced by <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_residuals_diagnostics_+3A_point.color">point.color</code></td>
<td>
<p>Colors of the plotted points. Can be a single color name (e.g. &quot;red4&quot;), a character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F")</code></p>
</td></tr>
<tr><td><code id="plot_residuals_diagnostics_+3A_line.color">line.color</code></td>
<td>
<p>Character string, color of the line produced by <code>ggplot2::geom_smooth()</code>. Default: <code>"gray30"</code></p>
</td></tr>
<tr><td><code id="plot_residuals_diagnostics_+3A_fill.color">fill.color</code></td>
<td>
<p>Character string, fill color of the bars produced by <code>ggplot2::geom_histogram()</code>. Default: <code>viridis::viridis(4, option = "F", alpha = 0.95 )[2]</code></p>
</td></tr>
<tr><td><code id="plot_residuals_diagnostics_+3A_option">option</code></td>
<td>
<p>(argument of <code><a href="#topic+plot_moran">plot_moran()</a></code>) Integer, type of plot. If <code>1</code> (default) a line plot with Moran's I and p-values across distance thresholds is returned. If <code>2</code>, scatterplots of residuals versus lagged residuals per distance threshold and their corresponding slopes are returned. In models fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, the residuals and lags of the residuals are computed from the median residuals across repetitions. Option <code>2</code> is disabled if <code>x</code> is a data frame generated by <code><a href="#topic+moran">moran()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_residuals_diagnostics_+3A_ncol">ncol</code></td>
<td>
<p>(argument of <code><a href="#topic+plot_moran">plot_moran()</a></code>) Number of columns of the Moran's I plot if <code>option = 2</code>.</p>
</td></tr>
<tr><td><code id="plot_residuals_diagnostics_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the resulting plot is printed, Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patchwork object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #load example data
 data(plant_richness_df)
 data(distance_matrix)

 #fit a random forest model
 x &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   n.cores = 1
 )

 #residuals diagnostics
 plot_residuals_diagnostics(x)

}
</code></pre>

<hr>
<h2 id='plot_response_curves'>Plots the response curves of a model.</h2><span id='topic+plot_response_curves'></span>

<h3>Description</h3>

<p>Plots the response curves of models fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or  <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_response_curves(
  model = NULL,
  variables = NULL,
  quantiles = c(0.1, 0.5, 0.9),
  grid.resolution = 200,
  line.color = viridis::viridis(length(quantiles), option = "F", end = 0.9),
  ncol = 2,
  show.data = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_response_curves_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_response_curves_+3A_variables">variables</code></td>
<td>
<p>Character vector, names of predictors to plot. If <code>NULL</code>, the most important variables (importance higher than the median) in <code>x</code> are selected. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_response_curves_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector with values between 0 and 1, argument <code>probs</code> of <a href="stats.html#topic+quantile">quantile</a>. Quantiles to set the other variables to. Default: <code>c(0.1, 0.5, 0.9)</code></p>
</td></tr>
<tr><td><code id="plot_response_curves_+3A_grid.resolution">grid.resolution</code></td>
<td>
<p>Integer between 20 and 500. Resolution of the plotted curve Default: <code>100</code></p>
</td></tr>
<tr><td><code id="plot_response_curves_+3A_line.color">line.color</code></td>
<td>
<p>Character vector with colors, or function to generate colors for the lines representing <code>quantiles</code>. Must have the same number of colors as <code>quantiles</code> are defined. Default: <code>viridis::viridis(length(quantiles), option = "F", end = 0.9)</code></p>
</td></tr>
<tr><td><code id="plot_response_curves_+3A_ncol">ncol</code></td>
<td>
<p>Integer, argument of <a href="patchwork.html#topic+wrap_plots">wrap_plots</a>. Defaults to the rounded squared root of the number of plots. Default: <code>2</code></p>
</td></tr>
<tr><td><code id="plot_response_curves_+3A_show.data">show.data</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the observed data is plotted along with the response curves. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot_response_curves_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if TRUE the plot is printed. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All variables that are not plotted in a particular response curve are set to the values of their respective quantiles, and the response curve for each one of these quantiles is shown in the plot. When the input model was fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code> with <code>keep.models = TRUE</code>, then the plot shows the median of all model runs, and each model run separately as a thinner line. The output list can be plotted all at once with <code>patchwork::wrap_plots(p)</code> or <code>cowplot::plot_grid(plotlist = p)</code>, or one by one by extracting each plot from the list.
</p>


<h3>Value</h3>

<p>A list with slots named after the selected <code>variables</code>, with one ggplot each.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_response_surface">plot_response_surface()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)

#fitting a random forest model
m &lt;- rf(
 data = plant_richness_df,
 dependent.variable.name = "richness_species_vascular",
 predictor.variable.names = colnames(plant_richness_df)[5:21],
 n.cores = 1,
 verbose = FALSE
)

#response curves of most important predictors
plot_response_curves(model = m)

}
</code></pre>

<hr>
<h2 id='plot_response_surface'>Plots the response surfaces of a random forest model</h2><span id='topic+plot_response_surface'></span>

<h3>Description</h3>

<p>Plots response surfaces for any given pair of predictors in a <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_response_surface(
  model = NULL,
  a = NULL,
  b = NULL,
  quantiles = 0.5,
  grid.resolution = 100,
  point.size.range = c(0.5, 2.5),
  point.alpha = 1,
  fill.color = viridis::viridis(100, option = "F", direction = -1, alpha = 0.9),
  point.color = "gray30",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_response_surface_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>. Default <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_a">a</code></td>
<td>
<p>Character string, name of a model predictor. If <code>NULL</code>, the most important variable in <code>model</code> is selected. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_b">b</code></td>
<td>
<p>Character string, name of a model predictor. If <code>NULL</code>, the second most important variable in <code>model</code> is selected. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector between 0 and 1. Argument <code>probs</code> of the function <a href="stats.html#topic+quantile">quantile</a>. Quantiles to set the other variables to. Default: <code>0.5</code></p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_grid.resolution">grid.resolution</code></td>
<td>
<p>Integer between 20 and 500. Resolution of the plotted surface Default: <code>100</code></p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_point.size.range">point.size.range</code></td>
<td>
<p>Numeric vector of length 2 with the range of point sizes used by <a href="ggplot2.html#topic+geom_point">geom_point</a>. Using <code>c(-1, -1)</code> removes the points. Default: <code>c(0.5, 2.5)</code></p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_point.alpha">point.alpha</code></td>
<td>
<p>Numeric between 0 and 1, transparency of the points. Setting it to <code>0</code> removes all points. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_fill.color">fill.color</code></td>
<td>
<p>Character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F", direction = -1, alpha = 0.9)</code></p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_point.color">point.color</code></td>
<td>
<p>Character vector with a color name (e.g. &quot;red4&quot;). Default: <code>gray30</code></p>
</td></tr>
<tr><td><code id="plot_response_surface_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if TRUE the plot is printed. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All variables that are not <code>a</code> or <code>b</code> in a response curve are set to the values of their respective quantiles to plot the response surfaces. The output list can be plotted all at once with <code>patchwork::wrap_plots(p)</code> or <code>cowplot::plot_grid(plotlist = p)</code>, or one by one by extracting each plot from the list.
</p>


<h3>Value</h3>

<p>A list with slots named after the selected <code>quantiles</code>, each one with a ggplot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_response_curves">plot_response_curves()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#load example data
data(plant_richness_df)

#fit random forest model
out &lt;- rf(
 data = plant_richness_df,
 dependent.variable.name = "richness_species_vascular",
 predictor.variable.names = colnames(plant_richness_df)[5:21],
 n.cores = 1,
 verbose = FALSE
)

#plot interactions between most important predictors
plot_response_surfaces(x = out)


}
</code></pre>

<hr>
<h2 id='plot_training_df'>Scatterplots of a training data frame</h2><span id='topic+plot_training_df'></span>

<h3>Description</h3>

<p>Plots the dependent variable against each predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_training_df(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  ncol = 4,
  method = "loess",
  point.color = viridis::viridis(100, option = "F"),
  line.color = "gray30"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_training_df_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_training_df_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. If the dependent variable is binary with values 1 and 0, the argument <code>case.weights</code> of <code>ranger</code> is populated by the function <code><a href="#topic+case_weights">case_weights()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_training_df_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Optionally, the result of <code><a href="#topic+auto_cor">auto_cor()</a></code> or <code><a href="#topic+auto_vif">auto_vif()</a></code> Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_training_df_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns of the plot. Argument <code>ncol</code> of <a href="patchwork.html#topic+wrap_plots">wrap_plots</a>.</p>
</td></tr>
<tr><td><code id="plot_training_df_+3A_method">method</code></td>
<td>
<p>Method for <a href="ggplot2.html#topic+geom_smooth">geom_smooth</a>, one of: &quot;lm&quot;, &quot;glm&quot;, &quot;gam&quot;, &quot;loess&quot;, or a function, for example <code>mgcv::gam</code> Default: 'loess'</p>
</td></tr>
<tr><td><code id="plot_training_df_+3A_point.color">point.color</code></td>
<td>
<p>Colors of the plotted points. Can be a single color name (e.g. &quot;red4&quot;), a character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F")</code></p>
</td></tr>
<tr><td><code id="plot_training_df_+3A_line.color">line.color</code></td>
<td>
<p>Character string, color of the line produced by <code>ggplot2::geom_smooth()</code>. Default: <code>"gray30"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="patchwork.html#topic+wrap_plots">wrap_plots</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

   #load example data
   data(plant_richness_df)

   #scatterplot of the training data
   plot_training_data(
     data = plant_richness_df,
     dependent.variable.name = "richness_species_vascular",
     predictor.variable.names = colnames(plant_richness_df)[5:21]
     )
 }
</code></pre>

<hr>
<h2 id='plot_training_df_moran'>Moran's I plots of a training data frame</h2><span id='topic+plot_training_df_moran'></span>

<h3>Description</h3>

<p>Plots the the Moran's I test of the response and the predictors in a training data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_training_df_moran(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  fill.color = viridis::viridis(100, option = "F", direction = -1),
  point.color = "gray30"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_training_df_moran_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_training_df_moran_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. If the dependent variable is binary with values 1 and 0, the argument <code>case.weights</code> of <code>ranger</code> is populated by the function <code><a href="#topic+case_weights">case_weights()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_training_df_moran_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Optionally, the result of <code><a href="#topic+auto_cor">auto_cor()</a></code> or <code><a href="#topic+auto_vif">auto_vif()</a></code> Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_training_df_moran_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_training_df_moran_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector, distances below each value are set to 0 on separated copies of the distance matrix for the computation of Moran's I at different neighborhood distances. If <code>NULL</code>, it defaults to <code>seq(0, max(distance.matrix)/4, length.out = 2)</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_training_df_moran_+3A_fill.color">fill.color</code></td>
<td>
<p>Character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F", direction = -1)</code></p>
</td></tr>
<tr><td><code id="plot_training_df_moran_+3A_point.color">point.color</code></td>
<td>
<p>Character vector with a color name (e.g. &quot;red4&quot;). Default: <code>gray30</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

   #load example data
   data(plant_richness_df)
   data(distance_matrix)

   #plot Moran's I of training data
   plot_moran_training_data(
     data = plant_richness_df,
     dependent.variable.name = "richness_species_vascular",
     predictor.variable.names = colnames(plant_richness_df)[5:21],
     distance.matrix = distance_matrix,
     distance.thresholds = c(
       0,
       2000,
       4000,
       6000,
       8000
       )
     )
}
</code></pre>

<hr>
<h2 id='plot_tuning'>Plots a tuning object produced by <code><a href="#topic+rf_tuning">rf_tuning()</a></code></h2><span id='topic+plot_tuning'></span>

<h3>Description</h3>

<p>Plots the tuning of the hyperparameters <code>num.trees</code>, <code>mtry</code>, and <code>min.node.size</code> performed by <code><a href="#topic+rf_tuning">rf_tuning()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tuning(
  model,
  point.color = viridis::viridis(
    100,
    option = "F"
  ),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_tuning_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf_tuning">rf_tuning()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_tuning_+3A_point.color">point.color</code></td>
<td>
<p>Colors of the plotted points. Can be a single color name (e.g. &quot;red4&quot;), a character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F")</code></p>
</td></tr>
<tr><td><code id="plot_tuning_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the plot is printed. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf_tuning">rf_tuning()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#load example data
data(plant_richness_df)

#fit random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

#tune random forest model
rf.model &lt;- rf_tuning(
 model = rf.model,
 xy = plant_richness_df[, c("x", "y")],
 n.cores = 1,
 verbose = FALSE
)

#generate tuning plot
plot_tuning(model = rf.model)

}
</code></pre>

<hr>
<h2 id='prepare_importance_spatial'>Prepares variable importance objects for spatial models</h2><span id='topic+prepare_importance_spatial'></span>

<h3>Description</h3>

<p>Prepares variable importance data frames and plots for models fitted with <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_importance_spatial(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_importance_spatial_+3A_model">model</code></td>
<td>
<p>An importance data frame with spatial predictors, or a model fitted with <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with importance data frames in different formats depending on whether the model was fitted with <code><a href="#topic+rf">rf()</a></code> or <code><a href="#topic+rf_repeat">rf_repeat()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(distance_matrix)
 data(plant_richness_df)

 #fittind spatial model
 model &lt;- rf_spatial(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds =  0,
   n.cores = 1
 )

 #preparing the importance data frame
 importance &lt;- prepare_importance_spatial(model)
 names(importance)

}
</code></pre>

<hr>
<h2 id='print_evaluation'>Prints cross-validation results</h2><span id='topic+print_evaluation'></span>

<h3>Description</h3>

<p>Prints the results of an spatial cross-validation performed with <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_evaluation(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_evaluation_+3A_model">model</code></td>
<td>
<p>A model resulting from <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table printed to the standard output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_evaluation">plot_evaluation()</a></code>, <code><a href="#topic+get_evaluation">get_evaluation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)
data(distance_matrix)

#fitting random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

#evaluation with spatial cross-validation
rf.model &lt;- rf_evaluate(
  model = rf.model,
  xy = plant_richness_df[, c("x", "y")],
  n.cores = 1
)

#checking evaluation results
print_evaluation(rf.model)

}
</code></pre>

<hr>
<h2 id='print_importance'>Prints variable importance</h2><span id='topic+print_importance'></span>

<h3>Description</h3>

<p>Prints variable importance scores from <a href="#topic+rf">rf</a>, <a href="#topic+rf_repeat">rf_repeat</a>, and <a href="#topic+rf_spatial">rf_spatial</a> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_importance(
  model,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_importance_+3A_model">model</code></td>
<td>
<p>A model fitted with <a href="#topic+rf">rf</a>, <a href="#topic+rf_repeat">rf_repeat</a>, or <a href="#topic+rf_spatial">rf_spatial</a>.</p>
</td></tr>
<tr><td><code id="print_importance_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, variable importance is returned. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table printed to the standard output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_importance">plot_importance()</a></code>, <code><a href="#topic+get_importance">get_importance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)
data(distance.matrix)

#fitting a random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

#printing variable importance scores
print_importance(model = rf.model)

}
</code></pre>

<hr>
<h2 id='print_moran'>Prints results of a Moran's I test</h2><span id='topic+print_moran'></span>

<h3>Description</h3>

<p>Prints the results of a Moran's I test on the residuals of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_moran(
  model,
  caption = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_moran_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
<tr><td><code id="print_moran_+3A_caption">caption</code></td>
<td>
<p>Character, caption of the output table, Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="print_moran_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the resulting table is printed into the console, Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a table in the console using the <a href="huxtable.html#topic+huxtable">huxtable</a> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran">moran()</a></code>, <code><a href="#topic+moran_multithreshold">moran_multithreshold()</a></code>, <code><a href="#topic+get_moran">get_moran()</a></code>, <code><a href="#topic+plot_moran">plot_moran()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)
 data(distance.matrix)

 #fitting random forest model
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = c(0, 1000, 2000),
   n.cores = 1,
   verbose = FALSE
 )

 #printing Moran's I of model's residuals
 print_moran(rf.model)

}
</code></pre>

<hr>
<h2 id='print_performance'>print_performance</h2><span id='topic+print_performance'></span>

<h3>Description</h3>

<p>Prints the performance slot of a model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>. For models fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code> it shows the median and the median absolute deviation of each performance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_performance(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_performance_+3A_model">model</code></td>
<td>
<p>Model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints model performance scores to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print_performance">print_performance()</a></code>, <code><a href="#topic+get_performance">get_performance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)
 data(distance.matrix)

 #fitting a random forest model
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   n.cores = 1,
   verbose = FALSE
 )

 #printing performance scores
 print_performance(rf.model)

}
</code></pre>

<hr>
<h2 id='print.rf'>Custom print method for random forest models</h2><span id='topic+print.rf'></span>

<h3>Description</h3>

<p>Custom print method for models fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, and <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rf_+3A_x">x</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
<tr><td><code id="print.rf_+3A_...">...</code></td>
<td>
<p>Additional arguments for print methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints model details to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print_evaluation">print_evaluation()</a></code>, <code><a href="#topic+print_importance">print_importance()</a></code>, <code><a href="#topic+print_moran">print_moran()</a></code>, <code><a href="#topic+print_performance">print_performance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data("plant_richness_df")
 data("distance_matrix")

 #fitting random forest model
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   n.cores = 1
 )

 #printing model summary
 print(rf.model)
}
</code></pre>

<hr>
<h2 id='rank_spatial_predictors'>Ranks spatial predictors</h2><span id='topic+rank_spatial_predictors'></span>

<h3>Description</h3>

<p>Ranks spatial predictors generated by <code><a href="#topic+mem_multithreshold">mem_multithreshold()</a></code> or <code><a href="#topic+pca_multithreshold">pca_multithreshold()</a></code> by their effect in reducing the Moran's I of the model residuals (<code>ranking.method = "effect"</code>), or by their own Moran's I (<code>ranking.method = "moran"</code>).
</p>
<p>In the former case, one model of the type <code>y ~ predictors + spatial_predictor_X</code> is fitted per spatial predictor, and the Moran's I of this model's residuals is compared with the one of the model without spatial predictors (<code>y ~ predictors</code>), to finally rank the spatial predictor from maximum to minimum difference in Moran's I.
</p>
<p>In the latter case, the spatial predictors are ordered by their Moran's I alone (this is the faster option).
</p>
<p>In both cases, spatial predictors that are redundant with others at a Pearson correlation &gt; 0.5 and spatial predictors with no effect (no reduction of Moran's I  or Moran's I of the spatial predictor equal or lower than 0) are removed.
</p>
<p>This function has been designed to be used internally by <code><a href="#topic+rf_spatial">rf_spatial()</a></code> rather than directly by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_spatial_predictors(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  ranking.method = c("moran", "effect"),
  reference.moran.i = 1,
  verbose = FALSE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_spatial_predictors_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector with neighborhood distances. All distances in the distance matrix below each value in <code>dustance.thresholds</code> are set to 0 for the computation of Moran's I. If <code>NULL</code>, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_ranger.arguments">ranger.arguments</code></td>
<td>
<p>List with <a href="ranger.html#topic+ranger">ranger</a> arguments. See <a href="#topic+rf">rf</a> or <a href="#topic+rf_repeat">rf_repeat</a> for further details.</p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_spatial.predictors.df">spatial.predictors.df</code></td>
<td>
<p>Data frame of spatial predictors.</p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_ranking.method">ranking.method</code></td>
<td>
<p>Character, method used by to rank spatial predictors. The method &quot;effect&quot; ranks spatial predictors according how much each predictor reduces Moran's I of the model residuals, while the method &quot;moran&quot; ranks them by their own Moran's I. Default: <code>"moran"</code>.</p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_reference.moran.i">reference.moran.i</code></td>
<td>
<p>Moran's I of the residuals of the model without spatial predictors. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_verbose">verbose</code></td>
<td>
<p>Logical, ff <code>TRUE</code>, messages and plots generated during the execution of the function are displayed, Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="rank_spatial_predictors_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four slots:
</p>

<ul>
<li> <p><code>method</code>: Character, name of the method used to rank the spatial predictors.
</p>
</li>
<li> <p><code>criteria</code>: Data frame with two different configurations depending on the ranking method. If <code>ranking.method = "effect"</code>, the columns contain the names of the spatial predictors, the r-squared of the model, the Moran's I of the model residuals, the difference between the Moran's I of the model including the given spatial predictor, and the Moran's I of the model fitted without spatial predictors, and the interpretation of the Moran's I value. If <code>ranking.method = "moran"</code>, only the name of the spatial predictor and it's Moran's I are in the output data frame.
</p>
</li>
<li> <p><code>ranking</code>: Ordered character vector with the names of the spatial predictors selected.
</p>
</li>
<li> <p><code>spatial.predictors.df</code>: data frame with the selected spatial predictors in the order of the ranking.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading distance matrix
 data(distance_matrix)

 #computing Moran's Eigenvector Maps
 mem.df &lt;- mem(
  distance.matrix = distance_matrix[1:50, 1:50],
  distance.threshold = 0
 )

 #ranking by the Moran's I of the spatial predictor
 rank &lt;- rank_spatial_predictors(
  distance.matrix = distance_matrix[1:50, 1:50],
  distance.thresholds = 0,
  spatial.predictors.df = mem.df,
  ranking.method = "moran",
  n.cores = 1
 )

 #checking Moran's I of MEMs
 rank$criteria

 #checking rank of MEMs
 rank$ranking
}
</code></pre>

<hr>
<h2 id='rescale_vector'>Rescales a numeric vector into a new range</h2><span id='topic+rescale_vector'></span>

<h3>Description</h3>

<p>Rescales a numeric vector to a new range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_vector(
  x = NULL,
  new.min = 0,
  new.max = 1,
  integer = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_vector_+3A_x">x</code></td>
<td>
<p>Numeric vector. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rescale_vector_+3A_new.min">new.min</code></td>
<td>
<p>New minimum value. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="rescale_vector_+3A_new.max">new.max</code></td>
<td>
<p>New maximum value. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="rescale_vector_+3A_integer">integer</code></td>
<td>
<p>Logical, if <code>TRUE</code>, coerces the output to integer. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as x, but with its values rescaled between <code>new.min</code> and <code>new.max.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 out &lt;- rescale_vector(
   x = rnorm(100),
   new.min = 0,
   new.max = 100,
   integer = TRUE
   )
   out

}
</code></pre>

<hr>
<h2 id='residuals_diagnostics'>Normality test of a numeric vector</h2><span id='topic+residuals_diagnostics'></span>

<h3>Description</h3>

<p>Applies a Shapiro-Wilks test to a numeric vector, and plots the qq plot and the histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals_diagnostics(residuals, predictions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_diagnostics_+3A_residuals">residuals</code></td>
<td>
<p>Numeric vector, model residuals.</p>
</td></tr>
<tr><td><code id="residuals_diagnostics_+3A_predictions">predictions</code></td>
<td>
<p>Numeric vector, model predictions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>shapiro.test()</code> has a hard limit of 5000 cases. If the model residuals have more than 5000 cases, then <code>sample(x = residuals, size = 5000)</code> is applied to the model residuals before the test.
</p>


<h3>Value</h3>

<p>A list with four slots:
</p>

<p>/item <code>w</code> W statistic returned by <code><a href="stats.html#topic+shapiro.test">shapiro.test()</a></code>.
/item <code>p.value</code> p-value of the Shapiro test.
/item <code>interpretation</code> Character vector, one of &quot;x is normal&quot;, &quot;x is not normal&quot;.
/item <code>plot</code> A patchwork plot with the qq plot and the histogram of x.

</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>,<code><a href="ggplot2.html#topic+aes">aes</a></code>,<code><a href="ggplot2.html#topic+geom_qq_line">geom_qq_line</a></code>,<code><a href="ggplot2.html#topic+ggtheme">ggtheme</a></code>,<code><a href="ggplot2.html#topic+labs">labs</a></code>,<code><a href="ggplot2.html#topic+geom_freqpoly">geom_freqpoly</a></code>,<code><a href="ggplot2.html#topic+geom_abline">geom_abline</a></code>
<code><a href="patchwork.html#topic+plot_annotation">plot_annotation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 residuals_diagnostics(
   residuals = runif(100),
   predictions = runif(100)
 )

 }
</code></pre>

<hr>
<h2 id='residuals_test'>Normality test of a numeric vector</h2><span id='topic+residuals_test'></span>

<h3>Description</h3>

<p>Applies a Shapiro-Wilks test to a numeric vector, and returns a list with the statistic W, its p-value, and a character string with the interpretation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals_test(residuals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_test_+3A_residuals">residuals</code></td>
<td>
<p>Numeric vector, model residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four slots:
</p>

<p>/item <code>w</code> W statistic returned by <code><a href="stats.html#topic+shapiro.test">shapiro.test()</a></code>.
/item <code>p.value</code> p-value of the Shapiro test.
/item <code>interpretation</code> Character vector, one of &quot;x is normal&quot;, &quot;x is not normal&quot;.
/item <code>plot</code> A patchwork plot with the qq plot and the histogram of x.

</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>,<code><a href="ggplot2.html#topic+aes">aes</a></code>,<code><a href="ggplot2.html#topic+geom_qq_line">geom_qq_line</a></code>,<code><a href="ggplot2.html#topic+ggtheme">ggtheme</a></code>,<code><a href="ggplot2.html#topic+labs">labs</a></code>,<code><a href="ggplot2.html#topic+geom_freqpoly">geom_freqpoly</a></code>,<code><a href="ggplot2.html#topic+geom_abline">geom_abline</a></code>
<code><a href="patchwork.html#topic+plot_annotation">plot_annotation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 residuals_test(residuals = runif(100))

}
</code></pre>

<hr>
<h2 id='rf'>Random forest models with Moran's I test of the residuals</h2><span id='topic+rf'></span>

<h3>Description</h3>

<p>A convenient wrapper for <a href="ranger.html#topic+ranger">ranger</a> that completes its output by providing the Moran's I of the residuals for different distance thresholds, the rmse and nrmse (as computed by <code><a href="#topic+root_mean_squared_error">root_mean_squared_error()</a></code>), and variable importance scores based on a scaled version of the data generated by <a href="base.html#topic+scale">scale</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  xy = NULL,
  ranger.arguments = NULL,
  scaled.importance = FALSE,
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. If the dependent variable is binary with values 1 and 0, the argument <code>case.weights</code> of <code>ranger</code> is populated by the function <code><a href="#topic+case_weights">case_weights()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Optionally, the result of <code><a href="#topic+auto_cor">auto_cor()</a></code> or <code><a href="#topic+auto_vif">auto_vif()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector with neighborhood distances. All distances in the distance matrix below each value in <code>dustance.thresholds</code> are set to 0 for the computation of Moran's I. If <code>NULL</code>, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_+3A_xy">xy</code></td>
<td>
<p>(optional) Data frame or matrix with two columns containing coordinates and named &quot;x&quot; and &quot;y&quot;. It is not used by this function, but it is stored in the slot <code>ranger.arguments$xy</code> of the model, so it can be used by <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code> and <code><a href="#topic+rf_tuning">rf_tuning()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_+3A_ranger.arguments">ranger.arguments</code></td>
<td>
<p>Named list with <a href="ranger.html#topic+ranger">ranger</a> arguments (other arguments of this function can also go here). All <a href="ranger.html#topic+ranger">ranger</a> arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. The ranger arguments <code>x</code>, <code>y</code>, and <code>formula</code> are disabled. Please, consult the help file of <a href="ranger.html#topic+ranger">ranger</a> if you are not familiar with the arguments of this function.</p>
</td></tr>
<tr><td><code id="rf_+3A_scaled.importance">scaled.importance</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the function scales <code>data</code> with <a href="base.html#topic+scale">scale</a> and fits a new model to compute scaled variable importance scores. This makes variable importance scores of different models somewhat comparable. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="rf_+3A_seed">seed</code></td>
<td>
<p>Integer, random seed to facilitate reproducibility. If set to a given number, the returned model is always the same. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="rf_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If TRUE, messages and plots generated during the execution of the function are displayed. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rf_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="rf_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. This function does not use the cluster, but can pass it on to other functions when using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. It will be stored in the slot <code>cluster</code> of the output list. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please read the help file of <a href="ranger.html#topic+ranger">ranger</a> for further details. Notice that the <code>formula</code> interface of <a href="ranger.html#topic+ranger">ranger</a> is supported through <code>ranger.arguments</code>, but variable interactions are not allowed (but check <code><a href="#topic+the_feature_engineer">the_feature_engineer()</a></code>).
</p>


<h3>Value</h3>

<p>A ranger model with several extra slots:
</p>

<ul>
<li> <p><code>ranger.arguments</code>: Stores the values of the arguments used to fit the ranger model.
</p>
</li>
<li> <p><code>importance</code>: A list containing a data frame with the predictors ordered by their importance, a ggplot showing the importance values, and local importance scores (difference in accuracy between permuted and non permuted variables for every case, computed on the out-of-bag data).
</p>
</li>
<li> <p><code>performance</code>: performance scores: R squared on out-of-bag data, R squared (cor(observed, predicted) ^ 2), pseudo R squared (cor(observed, predicted)), RMSE, and normalized RMSE (NRMSE).
</p>
</li>
<li> <p><code>residuals</code>: residuals, normality test of the residuals computed with <code><a href="#topic+residuals_test">residuals_test()</a></code>, and spatial autocorrelation of the residuals computed with <code><a href="#topic+moran_multithreshold">moran_multithreshold()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data("plant_richness_df")
 data("distance_matrix")

 #fittind random forest model
 out &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   n.cores = 1
 )

 class(out)

 #data frame with ordered variable importance
 out$importance$per.variable

 #variable importance plot
 out$importance$per.variable.plot

 #performance
 out$performance

 #spatial correlation of the residuals
 out$spatial.correlation.residuals$per.distance

 #plot of the Moran's I of the residuals for different distance thresholds
 out$spatial.correlation.residuals$plot

 #predictions for new data as done with ranger models:
 predicted &lt;- stats::predict(
   object = out,
   data = plant_richness_df,
   type = "response"
 )$predictions

 #alternative data input methods
 ###############################

 #ranger.arguments can contain ranger arguments and any other rf argument
 my.ranger.arguments &lt;- list(
 data = plant_richness_df,
 dependent.variable.name = "richness_species_vascular",
 predictor.variable.names = colnames(plant_richness_df)[8:21],
 distance.matrix = distance_matrix,
 distance.thresholds = c(0, 1000)
 )

 #fitting model with these ranger arguments
 out &lt;- rf(
   ranger.arguments = my.ranger.arguments,
   n.cores = 1
   )

}
</code></pre>

<hr>
<h2 id='rf_compare'>Compares models via spatial cross-validation</h2><span id='topic+rf_compare'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code> to compare the performance of several models on independent spatial folds via spatial cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_compare(
  models = NULL,
  xy = NULL,
  repetitions = 30,
  training.fraction = 0.75,
  metrics = c("r.squared", "pseudo.r.squared", "rmse", "nrmse", "auc"),
  distance.step = NULL,
  distance.step.x = NULL,
  distance.step.y = NULL,
  fill.color = viridis::viridis(100, option = "F", direction = -1, alpha = 0.8),
  line.color = "gray30",
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_compare_+3A_models">models</code></td>
<td>
<p>Named list with models resulting from <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_spatial">rf_spatial()</a></code>, <code><a href="#topic+rf_tuning">rf_tuning()</a></code>, or <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>. Example: <code>models = list(a = model.a, b = model.b)</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_xy">xy</code></td>
<td>
<p>Data frame or matrix with two columns containing coordinates and named &quot;x&quot; and &quot;y&quot;. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_repetitions">repetitions</code></td>
<td>
<p>Integer, number of spatial folds to use during cross-validation. Must be lower than the total number of rows available in the model's data. Default: <code>30</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_training.fraction">training.fraction</code></td>
<td>
<p>Proportion between 0.5 and 0.9 indicating the proportion of records to be used as training set during spatial cross-validation. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_metrics">metrics</code></td>
<td>
<p>Character vector, names of the performance metrics selected. The possible values are: &quot;r.squared&quot; (<code>cor(obs, pred) ^ 2</code>), &quot;pseudo.r.squared&quot; (<code>cor(obs, pred)</code>), &quot;rmse&quot; (<code>sqrt(sum((obs - pred)^2)/length(obs))</code>), &quot;nrmse&quot; (<code>rmse/(quantile(obs, 0.75) - quantile(obs, 0.25))</code>). Default: <code>c("r.squared", "pseudo.r.squared", "rmse", "nrmse")</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_distance.step">distance.step</code></td>
<td>
<p>Numeric, argument <code>distance.step</code> of <code><a href="#topic+thinning_til_n">thinning_til_n()</a></code>. distance step used during the selection of the centers of the training folds. These fold centers are selected by thinning the data until a number of folds equal or lower than <code>repetitions</code> is reached. Its default value is 1/1000th the maximum distance within records in <code>xy</code>. Reduce it if the number of training folds is lower than expected.</p>
</td></tr>
<tr><td><code id="rf_compare_+3A_distance.step.x">distance.step.x</code></td>
<td>
<p>Numeric, argument <code>distance.step.x</code> of <code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code>. Distance step used during the growth in the x axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the x coordinates).</p>
</td></tr>
<tr><td><code id="rf_compare_+3A_distance.step.y">distance.step.y</code></td>
<td>
<p>Numeric, argument <code>distance.step.x</code> of <code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code>. Distance step used during the growth in the y axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the y coordinates).</p>
</td></tr>
<tr><td><code id="rf_compare_+3A_fill.color">fill.color</code></td>
<td>
<p>Character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F", direction = -1)</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_line.color">line.color</code></td>
<td>
<p>Character string, color of the line produced by <code>ggplot2::geom_smooth()</code>. Default: <code>"gray30"</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_seed">seed</code></td>
<td>
<p>Integer, random seed to facilitate reproduciblity. If set to a given number, the results of the function are always the same. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="rf_compare_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, messages and plots generated during the execution of the function are displayed, Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="rf_compare_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three slots:
</p>

<ul>
<li> <p><code>comparison.df</code>: Data frame with one performance value per spatial fold, metric, and model.
</p>
</li>
<li> <p><code>spatial.folds</code>: List with the indices of the training and testing records for each evaluation repetition.
</p>
</li>
<li> <p><code>plot</code>: Violin-plot of <code>comparison.df</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(distance_matrix)
 data(plant_richness_df)

 #fitting random forest model
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   n.cores = 1
 )

 #fitting a spatial model with Moran's Eigenvector Maps
 rf.spatial &lt;- rf_spatial(
 model = rf.model,
 n.cores = 1
 )

 #comparing the spatial and non spatial models
 comparison &lt;- rf_compare(
 models = list(
   `Non spatial` = rf.model,
   Spatial = rf.spatial
 ),
 xy = plant_richness_df[, c("x", "y")],
 metrics = c("r.squared", "rmse"),
 n.cores = 1
 )

}
</code></pre>

<hr>
<h2 id='rf_evaluate'>Evaluates random forest models with spatial cross-validation</h2><span id='topic+rf_evaluate'></span>

<h3>Description</h3>

<p>Evaluates the performance of random forest on unseen data over independent spatial folds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_evaluate(
  model = NULL,
  xy = NULL,
  repetitions = 30,
  training.fraction = 0.75,
  metrics = c("r.squared", "pseudo.r.squared", "rmse", "nrmse", "auc"),
  distance.step = NULL,
  distance.step.x = NULL,
  distance.step.y = NULL,
  grow.testing.folds = FALSE,
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_evaluate_+3A_model">model</code></td>
<td>
<p>Model fitted with <code><a href="#topic+rf">rf()</a></code>, <code><a href="#topic+rf_repeat">rf_repeat()</a></code>, or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>.</p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_xy">xy</code></td>
<td>
<p>Data frame or matrix with two columns containing coordinates and named &quot;x&quot; and &quot;y&quot;. If <code>NULL</code>, the function will throw an error. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_repetitions">repetitions</code></td>
<td>
<p>Integer, number of spatial folds to use during cross-validation. Must be lower than the total number of rows available in the model's data. Default: <code>30</code></p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_training.fraction">training.fraction</code></td>
<td>
<p>Proportion between 0.5 and 0.9 indicating the proportion of records to be used as training set during spatial cross-validation. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_metrics">metrics</code></td>
<td>
<p>Character vector, names of the performance metrics selected. The possible values are: &quot;r.squared&quot; (<code>cor(obs, pred) ^ 2</code>), &quot;pseudo.r.squared&quot; (<code>cor(obs, pred)</code>), &quot;rmse&quot; (<code>sqrt(sum((obs - pred)^2)/length(obs))</code>), &quot;nrmse&quot; (<code>rmse/(quantile(obs, 0.75) - quantile(obs, 0.25))</code>), and &quot;auc&quot; (only for binary responses with values 1 and 0). Default: <code>c("r.squared", "pseudo.r.squared", "rmse", "nrmse")</code></p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_distance.step">distance.step</code></td>
<td>
<p>Numeric, argument <code>distance.step</code> of <code><a href="#topic+thinning_til_n">thinning_til_n()</a></code>. distance step used during the selection of the centers of the training folds. These fold centers are selected by thinning the data until a number of folds equal or lower than <code>repetitions</code> is reached. Its default value is 1/1000th the maximum distance within records in <code>xy</code>. Reduce it if the number of training folds is lower than expected.</p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_distance.step.x">distance.step.x</code></td>
<td>
<p>Numeric, argument <code>distance.step.x</code> of <code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code>. Distance step used during the growth in the x axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the x coordinates).</p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_distance.step.y">distance.step.y</code></td>
<td>
<p>Numeric, argument <code>distance.step.x</code> of <code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code>. Distance step used during the growth in the y axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the y coordinates).</p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_grow.testing.folds">grow.testing.folds</code></td>
<td>
<p>Logic. By default, this function grows contiguous training folds to keep the spatial structure of the data as intact as possible. However, when setting <code>grow.testing.folds = TRUE</code>, the argument <code>training.fraction</code> is set to <code>1 - training.fraction</code>, and the training and testing folds are switched. This option might be useful when the training data has a spatial structure that does not match well with the default behavior of the function. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_seed">seed</code></td>
<td>
<p>Integer, random seed to facilitate reproduciblity. If set to a given number, the results of the function are always the same. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, messages and plots generated during the execution of the function are displayed, Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="rf_evaluate_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The evaluation algorithm works as follows: the number of <code>repetitions</code> and the input dataset (stored in <code>model$ranger.arguments$data</code>) are used as inputs for the function <code><a href="#topic+thinning_til_n">thinning_til_n()</a></code>, that applies <code><a href="#topic+thinning">thinning()</a></code> to the input data until as many cases as <code>repetitions</code> are left, and as separated as possible. Each of these remaining records will be used as a &quot;fold center&quot;. From that point, the fold grows, until a number of points equal (or close) to <code>training.fraction</code> is reached. The indices of the records within the grown spatial fold are stored as &quot;training&quot; in the output list, and the remaining ones as &quot;testing&quot;. Then, for each spatial fold, a &quot;training model&quot; is fitted using the cases corresponding with the training indices, and predicted over the cases corresponding with the testing indices. The model predictions on the &quot;unseen&quot; data are compared with the observations, and the performance measures (R squared, pseudo R squared, RMSE and NRMSE) computed.
</p>


<h3>Value</h3>

<p>A model of the class &quot;rf_evaluate&quot; with a new slot named &quot;evaluation&quot;, that is a list with the following slots:
</p>

<ul>
<li> <p><code>training.fraction</code>: Value of the argument <code>training.fraction</code>.
</p>
</li>
<li> <p><code>spatial.folds</code>: Result of applying <code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code> on the data coordinates. It is a list with as many slots as <code>repetitions</code> are indicated by the user. Each slot has two slots named &quot;training&quot; and &quot;testing&quot;, each one having the indices of the cases used on the training and testing models.
</p>
</li>
<li> <p><code>per.fold</code>: Data frame with the evaluation results per spatial fold (or repetition). It contains the ID of each fold, it's central coordinates, the number of training and testing cases, and the training and testing performance measures: R squared, pseudo R squared (cor(observed, predicted)), rmse, and normalized rmse.
</p>
</li>
<li> <p><code>per.model</code>: Same data as above, but organized per fold and model (&quot;Training&quot;, &quot;Testing&quot;, and &quot;Full&quot;).
</p>
</li>
<li> <p><code>aggregated</code>: Same data, but aggregated by model and performance measure.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)
data(distance_matrix)

#fitting random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

#evaluation with spatial cross-validation
rf.model &lt;- rf_evaluate(
  model = rf.model,
  xy = plant_richness_df[, c("x", "y")],
  n.cores = 1
)

#checking evaluation results
plot_evaluation(rf.model)
print_evaluation(rf.model)
x &lt;- get_evaluation(rf.model)

}
</code></pre>

<hr>
<h2 id='rf_importance'>Contribution of each predictor to model transferability</h2><span id='topic+rf_importance'></span>

<h3>Description</h3>

<p>Evaluates the contribution of the predictors to model transferability via spatial cross-validation. The function returns the median increase or decrease in a given evaluation metric (R2, pseudo R2, RMSE, nRMSE, or AUC) when a variable is introduced in a model, by comparing and evaluating via spatial cross-validation models with and without the given variable. This function was devised to provide importance scores that would be less sensitive to spatial autocorrelation than those computed internally by random forest on the out-of-bag data. This function is experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_importance(
  model = NULL,
  xy = NULL,
  repetitions = 30,
  training.fraction = 0.75,
  metric = c("r.squared", "pseudo.r.squared", "rmse", "nrmse", "auc"),
  distance.step = NULL,
  distance.step.x = NULL,
  distance.step.y = NULL,
  fill.color = viridis::viridis(100, option = "F", direction = -1, alpha = 1, end = 0.9),
  line.color = "white",
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_importance_+3A_model">model</code></td>
<td>
<p>Model fitted with <code><a href="#topic+rf">rf()</a></code> and/or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>. The function doesn't work with models fitted with <code><a href="#topic+rf_repeat">rf_repeat()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_xy">xy</code></td>
<td>
<p>Data frame or matrix with two columns containing coordinates and named &quot;x&quot; and &quot;y&quot;. If <code>NULL</code>, the function will throw an error. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_repetitions">repetitions</code></td>
<td>
<p>Integer, number of spatial folds to use during cross-validation. Must be lower than the total number of rows available in the model's data. Default: <code>30</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_training.fraction">training.fraction</code></td>
<td>
<p>Proportion between 0.5 and 0.9 indicating the proportion of records to be used as training set during spatial cross-validation. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_metric">metric</code></td>
<td>
<p>Character, nams of the performance metric to use. The possible values are: &quot;r.squared&quot; (<code>cor(obs, pred) ^ 2</code>), &quot;pseudo.r.squared&quot; (<code>cor(obs, pred)</code>), &quot;rmse&quot; (<code>sqrt(sum((obs - pred)^2)/length(obs))</code>), &quot;nrmse&quot; (<code>rmse/(quantile(obs, 0.75) - quantile(obs, 0.25))</code>), and &quot;auc&quot; (only for binary responses with values 1 and 0). Default: <code>"r.squared"</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_distance.step">distance.step</code></td>
<td>
<p>Numeric, argument <code>distance.step</code> of <code><a href="#topic+thinning_til_n">thinning_til_n()</a></code>. distance step used during the selection of the centers of the training folds. These fold centers are selected by thinning the data until a number of folds equal or lower than <code>repetitions</code> is reached. Its default value is 1/1000th the maximum distance within records in <code>xy</code>. Reduce it if the number of training folds is lower than expected.</p>
</td></tr>
<tr><td><code id="rf_importance_+3A_distance.step.x">distance.step.x</code></td>
<td>
<p>Numeric, argument <code>distance.step.x</code> of <code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code>. Distance step used during the growth in the x axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the x coordinates).</p>
</td></tr>
<tr><td><code id="rf_importance_+3A_distance.step.y">distance.step.y</code></td>
<td>
<p>Numeric, argument <code>distance.step.x</code> of <code><a href="#topic+make_spatial_folds">make_spatial_folds()</a></code>. Distance step used during the growth in the y axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the y coordinates).</p>
</td></tr>
<tr><td><code id="rf_importance_+3A_fill.color">fill.color</code></td>
<td>
<p>Character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F", direction = -1, alpha = 0.8, end = 0.9)</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_line.color">line.color</code></td>
<td>
<p>Character string, color of the line produced by <code>ggplot2::geom_smooth()</code>. Default: <code>"white"</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_seed">seed</code></td>
<td>
<p>Integer, random seed to facilitate reproduciblity. If set to a given number, the results of the function are always the same. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="rf_importance_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, messages and plots generated during the execution of the function are displayed, Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="rf_importance_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input model with new data in its &quot;importance&quot; slot. The new importance scores are included in the data frame <code>model$importance$per.variable</code>, under the column names &quot;importance.cv&quot; (median contribution to transferability over spatial cross-validation repetitions), &quot;importance.cv.mad&quot; (median absolute deviation of the performance scores over spatial cross-validation repetitions), &quot;importance.cv.percent&quot; (&quot;importance.cv&quot; expressed as a percent, taking the full model's performance as baseline), and &quot;importance.cv.mad&quot; (median absolute deviation of &quot;importance.cv&quot;). The plot is stored as &quot;cv.per.variable.plot&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)
data(distance_matrix)
xy &lt;- plant_richness_df[, c("x", "y")]

#fitting random forest model
rf.model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  xy = xy,
  n.cores = 1,
  verbose = FALSE
)

#computing predictor contribution to model transferability
rf.model &lt;- rf_importance(rf.model)

}

</code></pre>

<hr>
<h2 id='rf_repeat'>Fits several random forest models on the same data</h2><span id='topic+rf_repeat'></span>

<h3>Description</h3>

<p>Fits several random forest models on the same data in order to capture the effect of the algorithm's stochasticity on the variable importance scores, predictions, residuals, and performance measures. The function relies on the median to aggregate performance and importance values across repetitions. It is recommended to use it after a model is fitted (<code><a href="#topic+rf">rf()</a></code> or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>), tuned (<code><a href="#topic+rf_tuning">rf_tuning()</a></code>), and/or evaluated (<code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>). This function is designed to be used after fitting a model with <code><a href="#topic+rf">rf()</a></code> or <code><a href="#topic+rf_spatial">rf_spatial()</a></code>, tuning it with <code><a href="#topic+rf_tuning">rf_tuning()</a></code> and evaluating it with <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_repeat(
  model = NULL,
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  xy = NULL,
  ranger.arguments = NULL,
  scaled.importance = FALSE,
  repetitions = 10,
  keep.models = TRUE,
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_repeat_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>. If provided, the data and ranger arguments are taken directly from the model definition (stored in <code>model$ranger.arguments</code>). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. If the dependent variable is binary with values 1 and 0, the argument <code>case.weights</code> of <code>ranger</code> is populated by the function <code><a href="#topic+case_weights">case_weights()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector with neighborhood distances. All distances in the distance matrix below each value in <code>dustance.thresholds</code> are set to 0 for the computation of Moran's I. If <code>NULL</code>, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_xy">xy</code></td>
<td>
<p>(optional) Data frame or matrix with two columns containing coordinates and named &quot;x&quot; and &quot;y&quot;. It is not used by this function, but it is stored in the slot <code>ranger.arguments$xy</code> of the model, so it can be used by <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code> and <code><a href="#topic+rf_tuning">rf_tuning()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_ranger.arguments">ranger.arguments</code></td>
<td>
<p>Named list with <a href="ranger.html#topic+ranger">ranger</a> arguments (other arguments of this function can also go here). All <a href="ranger.html#topic+ranger">ranger</a> arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. Please, consult the help file of <a href="ranger.html#topic+ranger">ranger</a> if you are not familiar with the arguments of this function.</p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_scaled.importance">scaled.importance</code></td>
<td>
<p>Logical. If <code>TRUE</code>, and 'importance = &quot;permutation', the function scales 'data' with <a href="base.html#topic+scale">scale</a> and fits a new model to compute scaled variable importance scores. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_repetitions">repetitions</code></td>
<td>
<p>Integer, number of random forest models to fit. Default: <code>10</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_keep.models">keep.models</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the fitted models are returned in the <code>models</code> slot. Set to <code>FALSE</code> if the accumulation of models is creating issues with the RAM memory available. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_seed">seed</code></td>
<td>
<p>Integer, random seed to facilitate reproduciblity. If set to a given number, the results of the function are always the same. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_verbose">verbose</code></td>
<td>
<p>Logical, ff <code>TRUE</code>, messages and plots generated during the execution of the function are displayed, Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="rf_repeat_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ranger model with several new slots:
</p>

<ul>
<li> <p><code>ranger.arguments</code>: Stores the values of the arguments used to fit the ranger model.
</p>
</li>
<li> <p><code>importance</code>: A list containing a data frame with the predictors ordered by their importance, a ggplot showing the importance values, and local importance scores.
</p>
</li>
<li> <p><code>performance</code>: out-of-bag performance scores: R squared, pseudo R squared, RMSE, and normalized RMSE (NRMSE).
</p>
</li>
<li> <p><code>pseudo.r.squared</code>: computed as the correlation between the observations and the predictions.
</p>
</li>
<li> <p><code>residuals</code>: residuals, normality test of the residuals computed with <code><a href="#topic+residuals_test">residuals_test()</a></code>, and spatial autocorrelation of the residuals computed with <code><a href="#topic+moran_multithreshold">moran_multithreshold()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)
 data(distance_matrix)

 #fitting 5 random forest models
 out &lt;- rf_repeat(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   repetitions = 5,
   n.cores = 1
 )

 #data frame with ordered variable importance
 out$importance$per.variable

 #per repetition
 out$importance$per.repetition

 #variable importance plot
 out$importance$per.repetition.plot

 #performance
 out$performance


 #spatial correlation of the residuals for different distance thresholds
 out$spatial.correlation.residuals$per.distance

 #plot of the Moran's I of the residuals for different distance thresholds
 out$spatial.correlation.residuals$plot

 #using a model as an input for rf_repeat()
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[8:21],
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   n.cores = 1
   )

 #repeating the model 5 times
 rf.repeat &lt;- rf_repeat(
   model = rf.model,
   n.cores = 1
   )


 rf.repeat$performance
 rf.repeat$importance$per.repetition.plot

}
</code></pre>

<hr>
<h2 id='rf_spatial'>Fits spatial random forest models</h2><span id='topic+rf_spatial'></span>

<h3>Description</h3>

<p>Fits spatial random forest models using different methods to generate, rank, and select spatial predictors acting as proxies of spatial processes not considered by the non-spatial predictors. The end goal is providing the model with information about the spatial structure of the data to minimize the spatial correlation (Moran's I) of the model residuals and generate honest variable importance scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_spatial(
  model = NULL,
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  xy = NULL,
  ranger.arguments = NULL,
  scaled.importance = TRUE,
  method = c("mem.moran.sequential", "mem.effect.sequential", "mem.effect.recursive",
    "hengl", "hengl.moran.sequential", "hengl.effect.sequential",
    "hengl.effect.recursive", "pca.moran.sequential", "pca.effect.sequential",
    "pca.effect.recursive"),
  max.spatial.predictors = NULL,
  weight.r.squared = NULL,
  weight.penalization.n.predictors = NULL,
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_spatial_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>. If used, the arguments <code>data</code>, <code>dependent.variable.name</code>, <code>predictor.variable.names</code>, <code>distance.matrix</code>, <code>distance.thresholds</code>, <code>ranger.arguments</code>, and <code>scaled.importance</code> are taken directly from the model definition. Default: NULL</p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. If the dependent variable is binary with values 1 and 0, the argument <code>case.weights</code> of <code>ranger</code> is populated by the function <code><a href="#topic+case_weights">case_weights()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector with distances in the same units as <code>distance.matrix</code> Distances below each distance threshold are set to 0 on separated copies of the distance matrix to compute Moran's I at different neighborhood distances. If <code>NULL</code>, it defaults to <code>seq(0, max(distance.matrix)/2, length.out = 4)</code> (defined by <code><a href="#topic+default_distance_thresholds">default_distance_thresholds()</a></code>). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_xy">xy</code></td>
<td>
<p>(optional) Data frame or matrix with two columns containing coordinates and named &quot;x&quot; and &quot;y&quot;. It is not used by this function, but it is stored in the slot <code>ranger.arguments$xy</code> of the model, so it can be used by <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code> and <code><a href="#topic+rf_tuning">rf_tuning()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_ranger.arguments">ranger.arguments</code></td>
<td>
<p>Named list with <a href="ranger.html#topic+ranger">ranger</a> arguments (other arguments of this function can also go here). All <a href="ranger.html#topic+ranger">ranger</a> arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. Please, consult the help file of <a href="ranger.html#topic+ranger">ranger</a> if you are not familiar with the arguments of this function.</p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_scaled.importance">scaled.importance</code></td>
<td>
<p>Logical. If <code>TRUE</code>, and 'importance = &quot;permutation', the function scales 'data' with <a href="base.html#topic+scale">scale</a> and fits a new model to compute scaled variable importance scores. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_method">method</code></td>
<td>
<p>Character, method to build, rank, and select spatial predictors. One of:
</p>

<ul>
<li><p> &quot;hengl&quot;
</p>
</li>
<li><p> &quot;hengl.moran.sequential&quot;  (experimental)
</p>
</li>
<li><p> &quot;hengl.effect.sequential&quot; (experimental)
</p>
</li>
<li><p> &quot;hengl.effect.recursive&quot;  (experimental)
</p>
</li>
<li><p> &quot;pca.moran.sequential&quot;    (experimental)
</p>
</li>
<li><p> &quot;pca.effect.sequential&quot;   (experimental)
</p>
</li>
<li><p> &quot;pca.effect.recursive&quot;    (experimental)
</p>
</li>
<li><p> &quot;mem.moran.sequential&quot;
</p>
</li>
<li><p> &quot;mem.effect.sequential&quot;
</p>
</li>
<li><p> &quot;mem.effect.recursive&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="rf_spatial_+3A_max.spatial.predictors">max.spatial.predictors</code></td>
<td>
<p>Integer, maximum number of spatial predictors to generate. Useful when memory problems arise due to a large number of spatial predictors, Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_weight.r.squared">weight.r.squared</code></td>
<td>
<p>Numeric between 0 and 1, weight of R-squared in the selection of spatial components. See Details, Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_weight.penalization.n.predictors">weight.penalization.n.predictors</code></td>
<td>
<p>Numeric between 0 and 1, weight of the penalization for adding an increasing number of spatial predictors during selection. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_seed">seed</code></td>
<td>
<p>Integer, random seed to facilitate reproducibility. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, messages and plots generated during the execution of the function are displayed, Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="rf_spatial_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses three different methods to generate spatial predictors (&quot;hengl&quot;, &quot;pca&quot;, and &quot;mem&quot;), two methods to rank them in order to define in what order they are introduced in the model (&quot;effect&quot; and &quot;moran), and two methods to select the spatial predictors that minimize the spatial correlation of the model residuals (&quot;sequential&quot; and &quot;recursive&quot;). All method names but &quot;hengl&quot; (that uses the complete distance matrix as predictors in the spatial model) are named by combining a method to generate the spatial predictors, a method to rank them, and a method to select them, separated by a point. Examples are &quot;mem.moran.sequential&quot; or &quot;mem.effect.recursive&quot;. All combinations are not possible, since the ranking method &quot;moran&quot; cannot be used with the selection method &quot;recursive&quot; (because the logics behind them are very different, see below).
Methods to generate spatial predictors:
</p>

<ul>
<li> <p><code>"hengl"</code>: named after the method RFsp presented in the paper &quot;Random forest as a generic framework for predictive modeling of spatial and spatio-temporal variables&quot;, by Hengl et al. (2018), where the authors propose to use the distance matrix among records as predictors in spatial random forest models (RFsp method). In this function, all methods starting with &quot;hengl&quot; use either the complete distance matrix, or select columns of the distance matrix as spatial predictors.
</p>
</li>
<li> <p><code>"mem"</code>: Generates Moran's Eigenvector Maps, that is, the eigenvectors of the double-centered weights of the distance matrix. The method is described in &quot;Spatial modelling: a comprehensive framework for principal coordinate analysis of neighbour matrices (PCNM)&quot;, by Dray et al. (2006), and &quot;Statistical methods for temporal and spacetime analysis of community composition data&quot;, by Legendre and Gauthier (2014).
</p>
</li>
<li> <p><code>"pca"</code>: Computes spatial predictors from the principal component analysis of a weighted distance matrix (see <code><a href="#topic+weights_from_distance_matrix">weights_from_distance_matrix()</a></code>). This is an experimental method, use with caution.
</p>
</li></ul>

<p>Methods to rank spatial predictors (see <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code>):
</p>

<ul>
<li> <p><code>"moran"</code>: Computes the Moran's I of each spatial predictor, selects the ones with positive values, and ranks them from higher to lower Moran's I.
</p>
</li>
<li> <p><code>"effect"</code>: If a given non-spatial random forest model is defined as <code>y = p1 + ... + pn</code>, being <code>p1 + ... + pn</code> the set of predictors, for every spatial predictor generated (<code>spX</code>) a spatial model <code>y = p1 + ... + pn + spX</code> is fitted, and the Moran's I of its residuals is computed. The spatial predictors are then ranked by how much they help to reduce spatial autocorrelation between the non-spatial and the spatial model.
</p>
</li></ul>

<p>Methods to select spatial predictors:
</p>

<ul>
<li> <p><code>"sequential"</code> (see <code><a href="#topic+select_spatial_predictors_sequential">select_spatial_predictors_sequential()</a></code>): The spatial predictors are added one by one in the order they were ranked, and once all spatial predictors are introduced, the best first n predictors are selected. This method is similar to the one employed in the MEM methodology (Moran's Eigenvector Maps) described in the paper &quot;Spatial modelling: a comprehensive framework for principal coordinate analysis of neighbour matrices (PCNM)&quot;, by Dray et al. (2006), and &quot;Statistical methods for temporal and spacetime analysis of community composition data&quot;, by Legendre and Gauthier (2014). This method generally introduces tens of predictors into the model, but usually offers good results.
</p>
</li>
<li> <p><code>"recursive"</code> (see <code><a href="#topic+select_spatial_predictors_recursive">select_spatial_predictors_recursive()</a></code>): This method tries to find the smallest combination of spatial predictors that reduce the spatial correlation of the model's residuals the most. The algorithm goes as follows: 1. The first ranked spatial predictor is introduced into the model; 2. the remaining predictors are ranked again using the &quot;effect&quot; method, using the model in 1. as reference. The first spatial predictor in the resulting ranking is then introduced into the model, and the steps 1. and 2. are repeated until spatial predictors stop having an effect in reducing the Moran's I of the model residuals. This method takes longer to compute, but generates smaller sets of spatial predictors. This is an experimental method, use with caution.
</p>
</li></ul>

<p>Once ranking procedure is completed, an algorithm is used to select the minimal subset of spatial predictors that reduce the most the Moran's I of the residuals: for each new spatial predictor introduced in the model, the Moran's I of the residuals, it's p-value, a binary version of the p-value (0 if &lt; 0.05 and 1 if &gt;= 0.05), the R-squared of the model, and a penalization linear with the number of spatial predictors introduced (computed as <code style="white-space: pre;">&#8288;(1 / total spatial predictors) * introduced spatial predictors&#8288;</code>) are rescaled between 0 and 1. Then, the optimization criteria is computed as <code style="white-space: pre;">&#8288;max(1 - Moran's I, p-value binary) + (weight.r.squared * R-squared) - (weight.penalization.n.predictors * penalization)&#8288;</code>. The predictors from the first one to the one with the highest optimization criteria are then selected as the best ones in reducing the spatial correlation of the model residuals, and used along with <code>data</code> to fit the final spatial model.
</p>


<h3>Value</h3>

<p>A ranger model with several new slots:
</p>

<ul>
<li> <p><code>ranger.arguments</code>: Values of the arguments used to fit the ranger model.
</p>
</li>
<li> <p><code>importance</code>: A list containing the vector of variable importance as originally returned by ranger (scaled or not depending on the value of 'scaled.importance'), a data frame with the predictors ordered by their importance, and a ggplot showing the importance values.
</p>
</li>
<li> <p><code>performance</code>: With the out-of-bag R squared, pseudo R squared, RMSE and NRMSE of the model.
</p>
</li>
<li> <p><code>residuals</code>: residuals, normality test of the residuals computed with <code><a href="#topic+residuals_test">residuals_test()</a></code>, and spatial autocorrelation of the residuals computed with <code><a href="#topic+moran_multithreshold">moran_multithreshold()</a></code>.
</p>
</li>
<li> <p><code>spatial</code>: A list with four slots:
</p>

<ul>
<li> <p><code>method</code>: Character, method used to generate, rank, and select spatial predictors.
</p>
</li>
<li> <p><code>names</code>: Character vector with the names of the selected spatial predictors. Not returned if the method is &quot;hengl&quot;.
</p>
</li>
<li> <p><code>optimization</code>: Criteria used to select the spatial predictors. Not returned if the method is &quot;hengl&quot;.
</p>
</li>
<li> <p><code>plot</code>: Plot of the criteria used to select the spatial predictors. Not returned if the method is &quot;hengl&quot;.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(distance_matrix)
 data(plant_richness_df)

 #names of the response and predictors
 dependent.variable.name &lt;- "richness_species_vascular"
 predictor.variable.names &lt;- colnames(plant_richness_df)[5:21]

 #hengl
 model &lt;- rf_spatial(
   data = plant_richness_df,
   dependent.variable.name = dependent.variable.name,
   predictor.variable.names = predictor.variable.names,
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   method = "hengl",
   n.cores = 1
 )

 #mem.moran.sequential
 model &lt;- rf_spatial(
   data = plant_richness_df,
   dependent.variable.name = dependent.variable.name,
   predictor.variable.names = predictor.variable.names,
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   method = "mem.moran.sequential",
   n.cores = 1
 )

 #fitting an rf_spatial model from an rf model
 rf.model &lt;- rf(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   distance.matrix = distance_matrix,
   distance.thresholds = 0,
   n.cores = 1,
   verbose = FALSE
 )
 rf.model$spatial.correlation.residuals$plot

 #spatial version of the rf model
 rf.spatial &lt;- rf_spatial(model = rf.model)
 rf.spatial$spatial.correlation.residuals$plot


}
</code></pre>

<hr>
<h2 id='rf_tuning'>Tuning of random forest hyperparameters via spatial cross-validation</h2><span id='topic+rf_tuning'></span>

<h3>Description</h3>

<p>Finds the optimal set of random forest hyperparameters <code>num.trees</code>, <code>mtry</code>, and <code>min.node.size</code> via grid search by maximizing the model's R squared, or AUC, if the response variable is binomial, via spatial cross-validation performed with <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_tuning(
  model = NULL,
  num.trees = NULL,
  mtry = NULL,
  min.node.size = NULL,
  xy = NULL,
  repetitions = 30,
  training.fraction = 0.75,
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_tuning_+3A_model">model</code></td>
<td>
<p>A model fitted with <code><a href="#topic+rf">rf()</a></code>. If provided, the training data is taken directly from the model definition (stored in <code>model$ranger.arguments</code>). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_num.trees">num.trees</code></td>
<td>
<p>Numeric integer vector with the number of trees to fit on each model repetition. Default: <code>c(500, 1000, 2000)</code>.</p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_mtry">mtry</code></td>
<td>
<p>Numeric integer vector, number of predictors to randomly select from the complete pool of predictors on each tree split. Default: <code>floor(seq(1, length(predictor.variable.names), length.out = 4))</code></p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_min.node.size">min.node.size</code></td>
<td>
<p>Numeric integer, minimal number of cases in a terminal node. Default: <code>c(5, 10, 20, 40)</code></p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_xy">xy</code></td>
<td>
<p>Data frame or matrix with two columns containing coordinates and named &quot;x&quot; and &quot;y&quot;. If <code>NULL</code>, the function will throw an error. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_repetitions">repetitions</code></td>
<td>
<p>Integer, number of independent spatial folds to use during the cross-validation. Default: <code>30</code>.</p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_training.fraction">training.fraction</code></td>
<td>
<p>Proportion between 0.2 and 0.9 indicating the number of records to be used in model training. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_seed">seed</code></td>
<td>
<p>Integer, random seed to facilitate reproduciblity. If set to a given number, the results of the function are always the same. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, messages and plots generated during the execution of the function are displayed, Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="rf_tuning_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model with a new slot named <code>tuning</code>, with a data frame with the results of the tuning analysis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(plant_richness_df)
data(distance_matrix)

#fitting model to tune
out &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = "richness_species_vascular",
  predictor.variable.names = colnames(plant_richness_df)[5:21],
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1
)

#model tuning
tuning &lt;- rf_tuning(
  model = out,
  num.trees = c(100, 500),
  mtry = c(2, 8),
  min.node.size = c(5, 10),
  xy = plant_richness_df[, c("x", "y")],
  n.cores = 1
)

}
</code></pre>

<hr>
<h2 id='root_mean_squared_error'>RMSE and normalized RMSE</h2><span id='topic+root_mean_squared_error'></span>

<h3>Description</h3>

<p>Computes the rmse or normalized rmse (nrmse) between two numeric vectors of the same length representing observations and model predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root_mean_squared_error(
  o,
  p,
  normalization = c("rmse", "all", "mean", "sd", "maxmin", "iq")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_mean_squared_error_+3A_o">o</code></td>
<td>
<p>Numeric vector with observations, must have the same length as <code>p</code>.</p>
</td></tr>
<tr><td><code id="root_mean_squared_error_+3A_p">p</code></td>
<td>
<p>Numeric vector with predictions, must have the same length as <code>o</code>.</p>
</td></tr>
<tr><td><code id="root_mean_squared_error_+3A_normalization">normalization</code></td>
<td>
<p>character, normalization method, Default: &quot;rmse&quot; (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normalization methods go as follows:
</p>

<ul>
<li> <p><code>"rmse"</code>: RMSE with no normalization.
</p>
</li>
<li> <p><code>"mean"</code>: RMSE dividied by the mean of the observations (rmse/mean(o)).
</p>
</li>
<li> <p><code>"sd"</code>: RMSE dividied by the standard deviation of the observations (rmse/sd(o)).
</p>
</li>
<li> <p><code>"maxmin"</code>: RMSE divided by the range of the observations (rmse/(max(o) - min(o))).
</p>
</li>
<li><p> &quot;<code style="white-space: pre;">&#8288;iq"&#8288;</code>: RMSE divided by the interquartile range of the observations (rmse/(quantile(o, 0.75) - quantile(o, 0.25)))
</p>
</li></ul>



<h3>Value</h3>

<p>Named numeric vector with either one or 5 values, as selected by the user.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 root_mean_squared_error(
   o = runif(10),
   p = runif(10)
   )

}
</code></pre>

<hr>
<h2 id='select_spatial_predictors_recursive'>Finds optimal combinations of spatial predictors</h2><span id='topic+select_spatial_predictors_recursive'></span>

<h3>Description</h3>

<p>Selects spatial predictors following these steps:
</p>

<ol>
<li><p> Gets the spatial predictors ranked by <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code> and fits a model of the form <code>y ~ predictors + best_spatial_predictor_1</code>. The Moran's I of the residuals of this model is used as reference value for the next step.
</p>
</li>
<li><p> The remaining spatial predictors are introduced again into <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code>, and the spatial predictor with the highest ranking is introduced in a new model of the form <code>y ~  predictors + best_spatial_predictor_1 + best_spatial_predictor_2</code>.
</p>
</li>
<li><p> Steps 1 and 2 are repeated until the Moran's I doesn't improve for a number of repetitions equal to the 20 percent of the total number of spatial predictors introduced in the function.
</p>
</li></ol>

<p>This method allows to select the smallest set of spatial predictors that have the largest joint effect in reducing the spatial correlation of the model residuals, while maintaining the model's R-squared as high as possible. As a consequence of running <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code> on each iteration, this method includes in the final model less spatial predictors than the sequential method implemented in <code><a href="#topic+select_spatial_predictors_sequential">select_spatial_predictors_sequential()</a></code> would do, while minimizing spatial correlation and maximizing the R squared of the model as much as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_spatial_predictors_recursive(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  spatial.predictors.ranking = NULL,
  weight.r.squared = 0.25,
  weight.penalization.n.predictors = 0,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_spatial_predictors_recursive_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector with neighborhood distances. All distances in the distance matrix below each value in <code>dustance.thresholds</code> are set to 0 for the computation of Moran's I. If <code>NULL</code>, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_ranger.arguments">ranger.arguments</code></td>
<td>
<p>Named list with <a href="ranger.html#topic+ranger">ranger</a> arguments (other arguments of this function can also go here). All <a href="ranger.html#topic+ranger">ranger</a> arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. Please, consult the help file of <a href="ranger.html#topic+ranger">ranger</a> if you are not familiar with the arguments of this function.</p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_spatial.predictors.df">spatial.predictors.df</code></td>
<td>
<p>Data frame of spatial predictors.</p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_spatial.predictors.ranking">spatial.predictors.ranking</code></td>
<td>
<p>Ranking of predictors returned by <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code>.</p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_weight.r.squared">weight.r.squared</code></td>
<td>
<p>Numeric between 0 and 1, weight of R-squared in the optimization index. Default: <code>0.25</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_weight.penalization.n.predictors">weight.penalization.n.predictors</code></td>
<td>
<p>Numeric between 0 and 1, weight of the penalization for the number of spatial predictors added in the optimization index. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_recursive_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated by <code>parallel::makeCluster()</code>. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works as follows. If the function <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code> returns 10 ranked spatial predictors (sp1 to sp10, being sp7 the best one), <code><a href="#topic+select_spatial_predictors_recursive">select_spatial_predictors_recursive()</a></code> is going to first fit the model <code>y ~ predictors + sp7</code>. Then, the spatial predictors sp2 to sp9 are again ranked with <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code> using the model <code>y ~ predictors + sp7</code> as reference (at this stage, some of the spatial predictors might be dropped due to lack of effect). When the new ranking of spatial predictors is ready (let's say they are sp5, sp3, and sp4), the best one (sp5) is included in the model <code>y ~ predictors + sp7 + sp5</code>, and the remaining ones go again to <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code> to repeat the process until spatial predictors are depleted.
</p>


<h3>Value</h3>

<p>A list with two slots: <code>optimization</code>, a data frame with the index of the spatial predictor added on each iteration, the spatial correlation of the model residuals, and the R-squared of the model, and <code>best.spatial.predictors</code>, that is a character vector with the names of the spatial predictors that minimize the Moran's I of the residuals and maximize the R-squared of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(distance_matrix)
data(plant_richness_df)

#response and preditor names
dependent.variable.name = "richness_species_vascular"
predictor.variable.names = colnames(plant_richness_df)[5:21]

#non-spatial model
model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1
)

#preparing spatial predictors
spatial.predictors &lt;- mem_multithreshold(
  distance.matrix = distance_matrix,
  distance.thresholds = 0
)

#ranking spatial predictors
spatial.predictors.ranking &lt;- rank_spatial_predictors(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  spatial.predictors.df = spatial.predictors,
  ranking.method = "moran",
  reference.moran.i = model$spatial.correlation.residuals$max.moran,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1
)

#selecting the best subset of predictors
selection &lt;- select_spatial_predictors_recursive(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  spatial.predictors.df = spatial.predictors,
  spatial.predictors.ranking = spatial.predictors.ranking,
  n.cores = 1
)

selection$optimization
selection$best.spatial.predictors
plot_optimization(selection$optimization)

}
</code></pre>

<hr>
<h2 id='select_spatial_predictors_sequential'>Sequential introduction of spatial predictors into a model</h2><span id='topic+select_spatial_predictors_sequential'></span>

<h3>Description</h3>

<p>Selects spatial predictors by adding them sequentially into a model while monitoring the Moran's I of the model residuals and the model's R-squared. Once all the available spatial predictors have been added to the model, the function identifies the first <code>n</code> predictors that minimize the spatial correlation of the residuals and maximize R-squared, and returns the names of the selected spatial predictors and a data frame with the selection criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_spatial_predictors_sequential(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  spatial.predictors.ranking = NULL,
  weight.r.squared = 0.75,
  weight.penalization.n.predictors = 0.25,
  verbose = FALSE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_spatial_predictors_sequential_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_distance.thresholds">distance.thresholds</code></td>
<td>
<p>Numeric vector with neighborhood distances. All distances in the distance matrix below each value in <code>dustance.thresholds</code> are set to 0 for the computation of Moran's I. If <code>NULL</code>, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_ranger.arguments">ranger.arguments</code></td>
<td>
<p>Named list with <a href="ranger.html#topic+ranger">ranger</a> arguments (other arguments of this function can also go here). All <a href="ranger.html#topic+ranger">ranger</a> arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. Please, consult the help file of <a href="ranger.html#topic+ranger">ranger</a> if you are not familiar with the arguments of this function.</p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_spatial.predictors.df">spatial.predictors.df</code></td>
<td>
<p>Data frame of spatial predictors.</p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_spatial.predictors.ranking">spatial.predictors.ranking</code></td>
<td>
<p>Ranking of the spatial predictors returned by <code><a href="#topic+rank_spatial_predictors">rank_spatial_predictors()</a></code>.</p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_weight.r.squared">weight.r.squared</code></td>
<td>
<p>Numeric between 0 and 1, weight of R-squared in the optimization index. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_weight.penalization.n.predictors">weight.penalization.n.predictors</code></td>
<td>
<p>Numeric between 0 and 1, weight of the penalization for the number of spatial predictors added in the optimization index. Default: <code>0.25</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_verbose">verbose</code></td>
<td>
<p>Logical, ff <code>TRUE</code>, messages and plots generated during the execution of the function are displayed, Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="select_spatial_predictors_sequential_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated by <code>parallel::makeCluster()</code>. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works as follows: If the function <a href="#topic+rank_spatial_predictors">rank_spatial_predictors</a> returns 10 spatial predictors (sp1 to sp10, ordered from best to worst), <a href="#topic+select_spatial_predictors_sequential">select_spatial_predictors_sequential</a> is going to fit the models <code>y ~ predictors + sp1</code>, <code>y ~ predictors + sp1 + sp2</code>, until all spatial predictors are used in <code style="white-space: pre;">&#8288;y ~ predictors + sp1 ... sp10&#8288;</code>. The model with lower Moran's I of the residuals and higher R-squared (computed on the out-of-bag data) is selected, and its spatial predictors returned.
</p>


<h3>Value</h3>

<p>A list with two slots: <code>optimization</code>, a data frame with the index of the spatial predictor added on each iteration, the spatial correlation of the model residuals, and the R-squared of the model, and <code>best.spatial.predictors</code>, that is a character vector with the names of the spatial predictors that minimize the Moran's I of the residuals and maximize the R-squared of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

#loading example data
data(distance_matrix)
data(plant_richness_df)

#common arguments
dependent.variable.name = "richness_species_vascular"
predictor.variable.names = colnames(plant_richness_df)[5:21]

#non-spatial model
model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1
)

#preparing spatial predictors
spatial.predictors &lt;- mem_multithreshold(
  distance.matrix = distance.matrix,
  distance.thresholds = 0
)
#ranking spatial predictors by their Moran's I (faster option)
spatial.predictors.ranking &lt;- rank_spatial_predictors(
  ranking.method = "moran",
  spatial.predictors.df = spatial.predictors,
  reference.moran.i = model$spatial.correlation.residuals$max.moran,
  distance.matrix = distance.matrix,
  distance.thresholds = 0,
  n.cores = 1
)

#selecting the best subset of predictors
selection &lt;- select_spatial_predictors_sequential(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  spatial.predictors.df = spatial.predictors,
  spatial.predictors.ranking = spatial.predictors.ranking,
  n.cores = 1
)

selection$optimization
selection$best.spatial.predictors
plot_optimization(selection$optimization)

}
</code></pre>

<hr>
<h2 id='standard_error'>Standard error of the mean of a numeric vector</h2><span id='topic+standard_error'></span>

<h3>Description</h3>

<p>Computes the standard error of the mean of a numeric vector as <code>round(sqrt(var(x)/length(x)), 3)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard_error(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standard_error_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function removes <code>NA</code> values before computing the standard error, and rounds the result to 3 decimal places.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 standard_error(runif(10))

}
</code></pre>

<hr>
<h2 id='statistical_mode'>Statistical mode of a vector</h2><span id='topic+statistical_mode'></span>

<h3>Description</h3>

<p>Computes the mode of a numeric or character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statistical_mode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statistical_mode_+3A_x">x</code></td>
<td>
<p>Numeric or character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Statistical mode of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 statistical_mode(c(10, 9, 10, 8))

}
</code></pre>

<hr>
<h2 id='the_feature_engineer'>Suggest variable interactions and composite features for random forest models</h2><span id='topic+the_feature_engineer'></span>

<h3>Description</h3>

<p>Suggests candidate variable interactions and composite features able to improve predictive accuracy over data not used to train the model via spatial cross-validation with <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>. For a pair of predictors <code>a</code> and <code>b</code>, interactions are build via multiplication (<code>a * b</code>), while composite features are built by extracting the first factor of a principal component analysis performed with <code><a href="#topic+pca">pca()</a></code>, after rescaling <code>a</code> and <code>b</code> between 1 and 100. Interactions and composite features are named <code>a..x..b</code> and <code>a..pca..b</code> respectively.
</p>
<p>Candidate variables <code>a</code> and <code>b</code> are selected from those predictors in <code>predictor.variable.names</code> with a variable importance above <code>importance.threshold</code> (set by default to the median of the importance scores).
</p>
<p>For each interaction and composite feature, a model including all the predictors plus the interaction or composite feature is fitted, and it's R squared (or AUC if the response is binary) computed via spatial cross-validation (see <code><a href="#topic+rf_evaluate">rf_evaluate()</a></code>) is compared with the R squared of the model without interactions or composite features.
</p>
<p>From all the potential interactions screened, only those with a positive increase in R squared (or AUC when the response is binomial) of the model, a variable importance above the median, and a maximum correlation among themselves and with the predictors in <code>predictor.variable.names</code> not higher than <code>cor.threshold</code> (set to 0.5 by default) are selected. Such a restrictive set of rules ensures that the selected interactions can be used right away for modeling purposes without increasing model complexity unnecessarily. However, the suggested variable interactions might not make sense from a domain expertise standpoint, so please, examine them with care.
</p>
<p>The function returns the criteria used to select the interactions, and the data required to use these interactions a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>the_feature_engineer(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  xy = NULL,
  ranger.arguments = NULL,
  repetitions = 30,
  training.fraction = 0.75,
  importance.threshold = 0.75,
  cor.threshold = 0.75,
  point.color = viridis::viridis(100, option = "F", alpha = 0.8),
  seed = NULL,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="the_feature_engineer_+3A_data">data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. If the dependent variable is binary with values 1 and 0, the argument <code>case.weights</code> of <code>ranger</code> is populated by the function <code><a href="#topic+case_weights">case_weights()</a></code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_predictor.variable.names">predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables, or object of class <code>"variable_selection"</code> produced by <code><a href="#topic+auto_vif">auto_vif()</a></code> and/or <code><a href="#topic+auto_cor">auto_cor()</a></code>. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_xy">xy</code></td>
<td>
<p>Data frame or matrix with two columns containing coordinates and named &quot;x&quot; and &quot;y&quot;. If not provided, the comparison between models with and without variable interactions is not done.</p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_ranger.arguments">ranger.arguments</code></td>
<td>
<p>Named list with <a href="ranger.html#topic+ranger">ranger</a> arguments (other arguments of this function can also go here). All <a href="ranger.html#topic+ranger">ranger</a> arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. Please, consult the help file of <a href="ranger.html#topic+ranger">ranger</a> if you are not familiar with the arguments of this function.</p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_repetitions">repetitions</code></td>
<td>
<p>Integer, number of spatial folds to use during cross-validation. Must be lower than the total number of rows available in the model's data. Default: <code>30</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_training.fraction">training.fraction</code></td>
<td>
<p>Proportion between 0.5 and 0.9 indicating the proportion of records to be used as training set during spatial cross-validation. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_importance.threshold">importance.threshold</code></td>
<td>
<p>Numeric between 0 and 1, quantile of variable importance scores over which to select individual predictors to explore interactions among them. Larger values reduce the number of potential interactions explored. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_cor.threshold">cor.threshold</code></td>
<td>
<p>Numeric, maximum Pearson correlation between any pair of the selected interactions, and between any interaction and the predictors in <code>predictor.variable.names</code>. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_point.color">point.color</code></td>
<td>
<p>Colors of the plotted points. Can be a single color name (e.g. &quot;red4&quot;), a character vector with hexadecimal codes (e.g. &quot;#440154FF&quot; &quot;#21908CFF&quot; &quot;#FDE725FF&quot;), or function generating a palette (e.g. <code>viridis::viridis(100)</code>). Default: <code>viridis::viridis(100, option = "F", alpha = 0.8)</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_seed">seed</code></td>
<td>
<p>Integer, random seed to facilitate reproduciblity. If set to a given number, the results of the function are always the same. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, messages and plots generated during the execution of the function are displayed. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_n.cores">n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td></tr>
<tr><td><code id="the_feature_engineer_+3A_cluster">cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name &quot;cluster&quot; so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> pipe. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with seven slots:
</p>

<ul>
<li> <p><code>screening</code>: Data frame with selection scores of all the interactions considered.
</p>
</li>
<li> <p><code>selected</code>: Data frame with selection scores of the selected interactions.
</p>
</li>
<li> <p><code>df</code>: Data frame with the computed interactions.
</p>
</li>
<li> <p><code>plot</code>: List of plots of the selected interactions versus the response variable. The output list can be plotted all at once with <code>patchwork::wrap_plots(p)</code> or <code>cowplot::plot_grid(plotlist = p)</code>, or one by one by extracting each plot from the list.
</p>
</li>
<li> <p><code>data</code>: Data frame with the response variable, the predictors, and the selected interactions, ready to be used as <code>data</code> argument in the package functions.
</p>
</li>
<li> <p><code>dependent.variable.name</code>: Character, name of the response.
</p>
</li>
<li> <p><code>predictor.variable.names</code>: Character vector with the names of the predictors and the selected interactions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #load example data
 data(plant_richness_df)

 new.features &lt;- the_feature_engineer(
   data = plant_richness_df,
   dependent.variable.name = "richness_species_vascular",
   predictor.variable.names = colnames(plant_richness_df)[5:21],
   n.cores = 1,
   verbose = TRUE
 )

 new.features$screening
 new.features$selected
 new.features$columns

}
</code></pre>

<hr>
<h2 id='thinning'>Applies thinning to pairs of coordinates</h2><span id='topic+thinning'></span>

<h3>Description</h3>

<p>Resamples a set of points with x and y coordinates to impose a minimum distance among nearby points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinning(xy, minimum.distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinning_+3A_xy">xy</code></td>
<td>
<p>A data frame with columns named &quot;x&quot; and &quot;y&quot; representing geographic coordinates.</p>
</td></tr>
<tr><td><code id="thinning_+3A_minimum.distance">minimum.distance</code></td>
<td>
<p>Numeric, minimum distance to be set between nearby points, in the same units as the coordinates of xy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally used to remove redundant points that could produce pseudo-replication, and to limit sampling bias by disaggregating clusters of points.
</p>


<h3>Value</h3>

<p>A data frame with the same columns as <code>xy</code> with points separated by the defined minimum distance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thinning_til_n">thinning_til_n()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #load example data
 data(plant_richness_df)

 #thinning to points separated by 5 degrees
 plant_richness.thin &lt;- thinning(
   x = plant_richness_df,
   minimum.distance = 5 #points separated by at least 5 degrees
   )

 plant_richness.thin

}
</code></pre>

<hr>
<h2 id='thinning_til_n'>Applies thinning to pairs of coordinates until reaching a given n</h2><span id='topic+thinning_til_n'></span>

<h3>Description</h3>

<p>Resamples a set of points with x and y coordinates by increasing the distance step by step until a given sample size is obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinning_til_n(
  xy,
  n = 30,
  distance.step = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinning_til_n_+3A_xy">xy</code></td>
<td>
<p>A data frame with columns named &quot;x&quot; and &quot;y&quot; representing geographic coordinates. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="thinning_til_n_+3A_n">n</code></td>
<td>
<p>Integer, number of samples to obtain. Must be lower than <code>nrow(xy)</code>. Default: <code>30</code></p>
</td></tr>
<tr><td><code id="thinning_til_n_+3A_distance.step">distance.step</code></td>
<td>
<p>Numeric, distance step used during the thinning iterations. If <code>NULL</code>, the one percent of the maximum distance among points in <code>xy</code> is used. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the same columns as xy with a row number close to n.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thinning">thinning()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example data
 data(plant_richness_df)

 #thinning to ~20 records
 plant_richness.thin &lt;- thinning_til_n(
   x = plant_richness_df,
   n = 20
   )

 plant_richness.thin

}
</code></pre>

<hr>
<h2 id='vif'>Variance Inflation Factor of a data frame</h2><span id='topic+vif'></span>

<h3>Description</h3>

<p>Computes the variance inflation factor (VIF) of the colums in a data frame. <strong>Warning</strong>: variables in <code>preference.order</code> not in <code>colnames(x)</code>, and non-numeric columns are removed silently from <code>x</code> and <code>preference.order</code>. The same happens with rows having NA values (<code><a href="stats.html#topic+na.omit">na.omit()</a></code> is applied). The function issues a warning if zero-variance columns are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vif_+3A_x">x</code></td>
<td>
<p>Data frame with numeric columns, typically containing a set of model predictors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns having the name of the variables in 'x' and their respective VIF values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auto_vif">auto_vif()</a></code>, <code><a href="#topic+auto_cor">auto_cor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 data(plant_richness_df)

 vif(plant_richness_df[, 5:21])

}
</code></pre>

<hr>
<h2 id='weights_from_distance_matrix'>Transforms a distance matrix into a matrix of weights</h2><span id='topic+weights_from_distance_matrix'></span>

<h3>Description</h3>

<p>Transforms a distance matrix into weights (1/distance.matrix) normalized by the row sums. Used to compute Moran's I values and Moran's Eigenvector Maps. Allows to apply a threshold to the distance matrix before computing the weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_from_distance_matrix(
  distance.matrix = NULL,
  distance.threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights_from_distance_matrix_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Distance matrix. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="weights_from_distance_matrix_+3A_distance.threshold">distance.threshold</code></td>
<td>
<p>Numeric, positive, in the range of values of <code>distance.matrix</code>. Distances below this value in the distance matrix are set to 0., Default: <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted distance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 #loading example distance matrix
 data(distance_matrix)

 #computing matrix of weights
 distance.matrix.weights &lt;- weights_from_distance_matrix(
   distance.matrix = distance_matrix
   )

 distance.matrix.weights

}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
