<!DOCTYPE html><html><head><title>Help for package bite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Anolis_map'><p>Anolis map of regimes</p></a></li>
<li><a href='#Anolis_traits'><p>Anolis snout to vent length</p></a></li>
<li><a href='#Anolis_tree'><p>Anolis phylogenetic tree</p></a></li>
<li><a href='#control_jive'><p>Control tuning parameters of the jive algorithm</p></a></li>
<li><a href='#format_jive_traits'><p>Format traits matrix to parse into <code>make_jive</code> function</p></a></li>
<li><a href='#hpfun'><p>Hyper-prior function</p></a></li>
<li><a href='#make_jive'><p>Create a list that can be used as an input to mcmc_bite</p></a></li>
<li><a href='#marginal_lik'><p>Calculate marginal likelihood by thermodynamic integration (LTI)</p></a></li>
<li><a href='#mcmc_bite'><p>MCMC algorithm</p></a></li>
<li><a href='#plot_bf'><p>Plots summary of Bayes Factors calculations</p></a></li>
<li><a href='#plot_hp'><p>plot Hyper-prior function</p></a></li>
<li><a href='#plot_jive'><p>plot input data from a jive object</p></a></li>
<li><a href='#plot_mcmc_bite'><p>Plot trace and density from a log file</p></a></li>
<li><a href='#plot_post_beast'><p>Plot posterior probabilities from beast</p></a></li>
<li><a href='#plot_pvo'><p>Plots estimates of species traits distribution</p></a></li>
<li><a href='#sim_jive'><p>Simulate JIVE process</p></a></li>
<li><a href='#sim_mte'><p>Simulate MTE process</p></a></li>
<li><a href='#xml_bite'><p>Write xml file with model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Integrative Models of Trait Evolution</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains the JIVE (joint inter and intra-specific model of variance evolution) model and other Bayesian models aimed at understanding trait evolution. The goal of the package is to join phylogenetic comparative models (PCM) that tend to integrate various type of data (individual observations, environmental data, fossil data) into a hierarchical Bayesian framework. It contains various PCMs as well as functions to join those models into a hierarchical Bayesian framework in a flexible and user friendly way. It contains various Markov chain Monte-Carlo (MCMC) algorithms, methods for model comparison and many plotting function for pre- and post-processing data visualization. Finally, this package integrates functions allowing bridges between 'R' and the 'BEAST2' implementations of PCMs. Kostikova A, Silvestro D, Pearman PB, Salamin N (2016) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyw010">doi:10.1093/sysbio/syw010</a>&gt;. Gaboriau T, Mendes FK, Joly S, Silvestro D, Salamin N (in prep).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, MASS, phytools, coda, sm, vioplot, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvMORPH</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-15 14:40:22 UTC; tgaboria</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Theo Gaboriau [aut, cre],
  Anna Kostikova [aut],
  Daniele Silvestro [aut],
  Sacha Laurent [crt],
  Martha Serrano [crt],
  Glenn Litsios [crt],
  Wim Hordijk [crt],
  Simon Joly [crt],
  Nicolas Salamin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Theo Gaboriau &lt;theo.gaboriau@unil.ch&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-22 16:44:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='Anolis_map'>Anolis map of regimes</h2><span id='topic+Anolis_map'></span>

<h3>Description</h3>

<p>Anolis map of regimes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Anolis_map)
</code></pre>


<h3>Format</h3>

<p>A two columns matrix giving the evolutionary time spent by each branch of <code><a href="#topic+Anolis_tree">Anolis_tree</a></code> in the two islands
C: Cuba and H: Hispniola</p>


<h3>Details</h3>

<p>This data contains a map of the Anolis lizards' clades geographic position onto the Anolis phylogeny.
A two columns matrix giving the evolutionary time spent by each branch of <code><a href="#topic+Anolis_tree">Anolis_tree</a></code> in the two islands
C: Cuba and H: Hispniola. Each row represents a branch of <code><a href="#topic+Anolis_tree">Anolis_tree</a></code>, numbers represent the evolutionary time spent on each island by the clade.
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>

<hr>
<h2 id='Anolis_traits'>Anolis snout to vent length</h2><span id='topic+Anolis_traits'></span>

<h3>Description</h3>

<p>Anolis snout to vent length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Anolis_traits)
</code></pre>


<h3>Format</h3>

<p>A three columns data.frame with species names (species) and snout to vent length (svl) and elevation of individual observations</p>


<h3>Details</h3>

<p>This data has been extracted from the study of Munoz et al., 2014
It contains individual observations of Anolis lizards' snout to vent length (mm) and elevation (m) from Hispaniola and Cuba islands in a three columns data.frame with species names (species) and snout to vent length (svl) and elevation of individual observations.
</p>


<h3>Author(s)</h3>

<p>Martha Munoz, Johanna Wegener and Adam Algar.
</p>


<h3>References</h3>

<p>Munoz, M. M., Wegener, J. E., and Algar, A. C. (2014).
Untangling intra- and interspecific effects on body size clines reveals divergent processes structuring convergent patterns in Anolis lizards.
Am. Nat. , 184(5):636-46.
</p>
<p>Munoz, Martha M., Wegener, Johanna E., Algar, Adam C. (2014),
Data from: Untangling intra- and interspecific effects on body size clines reveals divergent processes structuring convergent patterns in Anolis lizards,
Dryad, Dataset, https://doi.org/10.5061/dryad.q39h2
</p>

<hr>
<h2 id='Anolis_tree'>Anolis phylogenetic tree</h2><span id='topic+Anolis_tree'></span>

<h3>Description</h3>

<p>Anolis phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Anolis_tree)
</code></pre>


<h3>Format</h3>

<p>A dated phylogenetic tree of class &quot;phylo&quot; including 16 species of Anolis lizards</p>


<h3>Details</h3>

<p>This phylogenetic tree as been extracted from the Anolis phylogeny of Poe et al., 2017
It contains dated phylogenetic tree of class &quot;phylo&quot; including 16 species of Anolis lizards
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>References</h3>

<p>Poe, S., Nieto&amp;#45;Montes de Oca, A., Torres&amp;#45;carvajal, O., De Queiroz, K., Velasco, J. A.,
Truett, B., Gray, L. N., Ryan, M. J., Kohler, G., Ayala&amp;#45;varela, F., and Latella, I. (2017).
A Phylogenetic, biogeographic, and taxonomic study of all extant species of Anolis (Squamata, Iguanidae).
Syst. Biol., 66(5):663-697
</p>

<hr>
<h2 id='control_jive'>Control tuning parameters of the jive algorithm</h2><span id='topic+control_jive'></span>

<h3>Description</h3>

<p>This function modifies a jive object to tune the jive mcmc algorithm. The output will be different regarding which level of the jive model the user wants to tune ($lik, $priors). This function allows tuning of : initial window size for proposals, starting parameter value, proposal methods, Hyperpriors and update frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_jive(jive, level = c("lik", "prior"), intvar = NULL,
  pars = NULL, window.size = NULL, initial.values = NULL,
  proposals = NULL, hyperprior = NULL, update.freq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_jive_+3A_jive">jive</code></td>
<td>
<p>a jive object obtained from <code><a href="#topic+make_jive">make_jive</a></code></p>
</td></tr>
<tr><td><code id="control_jive_+3A_level">level</code></td>
<td>
<p>character taken in c(&quot;lik&quot;, &quot;prior&quot;) to specify on which level of the jive model, the control will operate (see details)</p>
</td></tr>
<tr><td><code id="control_jive_+3A_intvar">intvar</code></td>
<td>
<p>character taken in names(jive$priors) giving the variable to be edited (see details)</p>
</td></tr>
<tr><td><code id="control_jive_+3A_pars">pars</code></td>
<td>
<p>vector of character taken in names(jive$priors[[intvar]]$init) giving the names of the hyper parameter to be edited</p>
</td></tr>
<tr><td><code id="control_jive_+3A_window.size">window.size</code></td>
<td>
<p>initial window size for proposals during the mcmc algorithm. matrix or vector depending on the value of level and nreg (see details)</p>
</td></tr>
<tr><td><code id="control_jive_+3A_initial.values">initial.values</code></td>
<td>
<p>starting parameter values of the mcmc algorithm. matrix or vector depending on the value of level and nreg (see details)</p>
</td></tr>
<tr><td><code id="control_jive_+3A_proposals">proposals</code></td>
<td>
<p>vector of characters taken in c(&quot;slidingWin&quot;, &quot;slidingWinAbs&quot;, &quot;logSlidingWinAbs&quot;,&quot;multiplierProposal&quot;, &quot;multiplierProposalLakner&quot;,&quot;logNormal&quot;, &quot;absNormal&quot;) to control proposal methods during mcmc algorithm (see details)</p>
</td></tr>
<tr><td><code id="control_jive_+3A_hyperprior">hyperprior</code></td>
<td>
<p>list of hyperprior functions that can be generated with <code><a href="#topic+hpfun">hpfun</a></code>function. Ignored if level == &quot;lik&quot; (see details)</p>
</td></tr>
<tr><td><code id="control_jive_+3A_update.freq">update.freq</code></td>
<td>
<p>numeric giving the frequency at which parameters should be updated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If level == &quot;lik&quot; changes will be applied to the likelihood level of the algorithm. intvar is giving the variable on whic the changes will be operated
window.size and initial.values must be entered as a vector of length equal to the number of species. proposal must be a character
</p>
<p>If level == &quot;prior&quot; changes will be applied to the prior level of the algorithm. intvar is giving the variable on which te change will be operated.
window.size and initial.values must be entered as a vector of size equal to the number of parameters or equal to the length of pars. 
</p>
<p>Note that if you want to change the tuning at the three levels of the algorithm, you will have to use the control_jive function three times
</p>
<p>proposals
Has to be one the following : &quot;slidingWin&quot; for Sliding window proposal unconstrained at maximum, &quot;multiplierProposal&quot;, for multiplier proposal
</p>
<p>Hyperprior
list of hyperpriror functions (see <code><a href="#topic+hpfun">hpfun</a></code>). User must provide a list of size equal to the number of parameters or equal to the length of pars
</p>


<h3>Value</h3>

<p>A JIVE (of class &quot;JIVE&quot; and &quot;list&quot;) object to parse into mcmc_bite function (see <code><a href="#topic+make_jive">make_jive</a></code>)
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Anolis_traits)
data(Anolis_tree)
 
## Create a jive object
my.jive &lt;- make_jive(Anolis_tree, Anolis_traits[,-3],
model.priors = list(mean = "BM", logvar= c("OU", "root")))

## change starting values for the species means
my.jive$lik$init #default values
new.init &lt;- rep(40,16)
my.jive &lt;- control_jive(my.jive, level = "lik", intvar = "mean", initial.values = new.init)
my.jive$lik$init #mean initial values changed

 ## change hyperpriors for prior.mean
 plot_hp(my.jive) #default values
 new.hprior &lt;- list(hpfun("Gamma", hp.pars = c(2,6)), hpfun("Uniform", c(20,80)))
 my.jive &lt;- control_jive(my.jive, level = "prior", intvar = "mean", hyperprior = new.hprior)
 plot_hp(my.jive) #mean initial values changed
</code></pre>

<hr>
<h2 id='format_jive_traits'>Format traits matrix to parse into <code><a href="#topic+make_jive">make_jive</a></code> function</h2><span id='topic+format_jive_traits'></span>

<h3>Description</h3>

<p>This function takes a dataframe with indivdual observations ans species names and returns a traits matrix to to parse into <code><a href="#topic+make_jive">make_jive</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_jive_traits(obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_jive_traits_+3A_obs">obs</code></td>
<td>
<p>a dataframe with species names in the first column and individual trait values in the second columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of size equal to the number of species. Each element contains a vector of numerical values representing individual observation for that species.
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>

<hr>
<h2 id='hpfun'>Hyper-prior function</h2><span id='topic+hpfun'></span>

<h3>Description</h3>

<p>This function creates a hyper-prior density function. 
Currently supported density function are Uniform, Gamma and Normal. 
The resulting function is used during MCMC <code><a href="#topic+mcmc_bite">mcmc_bite</a></code>
to estimate parameters of priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpfun(hpf = "Uniform", hp.pars = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpfun_+3A_hpf">hpf</code></td>
<td>
<p>name of a density function. Supported density functions are: Uniform, Gamma and Normal (abbreviations are not supported)</p>
</td></tr>
<tr><td><code id="hpfun_+3A_hp.pars">hp.pars</code></td>
<td>
<p>a vector of density function parameters</p>
</td></tr>
<tr><td><code id="hpfun_+3A_...">...</code></td>
<td>
<p>additional parameters that can be passed to a density function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three currently implemented density function: 
Uniform, Gamma and Normal. Each of these densities requires two input parameters and hp.pars 
must be a vector of two values and cannot be left empty.
</p>


<h3>Value</h3>

<p>A hyper-prior density function (of class &quot;function&quot;)
</p>


<h3>Author(s)</h3>

<p>Anna Kostikova and Daniele Silvestro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.hp &lt;- hpfun(hpf="Uniform", hp.pars=c(1,2))

</code></pre>

<hr>
<h2 id='make_jive'>Create a list that can be used as an input to mcmc_bite</h2><span id='topic+make_jive'></span>

<h3>Description</h3>

<p>This function creates a jive object from a matrix of intraspecific observations
and species phylogeny. The obtained jive object is a list that can than be used as an input to <code><a href="#topic+mcmc_bite">mcmc_bite</a></code> function
Intraspecific observations should be stored as matrix, where lines are vector of observations for each species,
with NA for no data. Phylogenetic tree can be either a simmap object (<code><a href="phytools.html#topic+make.simmap">make.simmap</a></code>) or phylo object (<code><a href="ape.html#topic+as.phylo">as.phylo</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_jive(phy = NULL, traits, map = NULL, model.priors = list(mean =
  "BM", logvar = "OU"), scale = FALSE, nreg = NULL, lik.f = NULL,
  init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_jive_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree provided as either a simmap or a phylo object</p>
</td></tr>
<tr><td><code id="make_jive_+3A_traits">traits</code></td>
<td>
<p>matrix of traits value for every species of phy (see details)</p>
</td></tr>
<tr><td><code id="make_jive_+3A_map">map</code></td>
<td>
<p>matrix mapping regimes on every edge of phy (see details)</p>
</td></tr>
<tr><td><code id="make_jive_+3A_model.priors">model.priors</code></td>
<td>
<p>list giving model specification for trait evolution preferably given along with variable names. Supported models are &quot;OU&quot;, &quot;BM&quot;, &quot;WN&quot;. The user can also specify if the assumptions of the model should be relaxed and can also enter a function (see details)</p>
</td></tr>
<tr><td><code id="make_jive_+3A_scale">scale</code></td>
<td>
<p>boolean indicating whether the tree should be scaled to unit length for the model fitting</p>
</td></tr>
<tr><td><code id="make_jive_+3A_nreg">nreg</code></td>
<td>
<p>integer giving the number of regimes for a Beast analysis. Only evaluated if phy == NULL</p>
</td></tr>
<tr><td><code id="make_jive_+3A_lik.f">lik.f</code></td>
<td>
<p>alternative likelihood function of the form function(pars.lik, traits, counts) to model intraspecific variation (see details)</p>
</td></tr>
<tr><td><code id="make_jive_+3A_init">init</code></td>
<td>
<p>matrix giving initial values for parameters with the variables in rows and the species in columns (see examples)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a jive object needed for <code><a href="#topic+mcmc_bite">mcmc_bite</a></code> function.  
Trait values must be stored as a matrix, where lines are vectors of observations for each species, with NA for no data. Rownames are species names that should match exactly tip labels of the phylogenetic tree.
</p>
<p>Phylogenetic tree must be provided as either simmap object or as a phylo object. If the phylogenetic tree is a phylo object but model specification indicates multiple regimes, user must provide a mapping of the regime in map. If you keep the phy = NULL options the JIVE object can only be parsed to the <code><a href="#topic+xml_bite">xml_bite</a></code> function.
</p>
<p>map is a matrix giving the mapping of regimes on phy edges. Each row correspond to an edge in phy and each column correspond to a regime. If map is provided the map from the simmap object is ignored.   
</p>
<p>trait evolution can be modeled with Ornstein-Uhlenbeck (OU), Brownian Motion (BM) or White Noise (WN) processes. Multiple regimes can be defined for both models and will apply on thetas: c(&quot;OU&quot;, &quot;theta&quot;), sigmas: c(&quot;OU&quot;, &quot;sigma&quot;) or alphas: c(&quot;OU&quot;, &quot;alpha&quot;) for OU and on sigmas only for WN: c(&quot;WN&quot;, &quot;sigma&quot;) and BM: c(&quot;BM&quot;, &quot;sigma&quot;). While using the OU model, the user can also relax the stationarity of the root: c(&quot;OU&quot;, &quot;root&quot;) and relax several assumptions at the same time c(&quot;OU&quot;, &quot;root&quot;, &quot;theta&quot;) 
Species-specific distributions are modeled as multivariate normal distributions. User defined functions of trait evolution can be used in model.priors. The function should be of the form: function(tree, x, pars) and return a loglikelihood value with &quot;tree&quot; being the phylogenetic tree, x being a vector of trait value of size equal to the number of species and ordered as tree$tip.label and pars should be a vector of model parameters (see examples)
</p>
<p>parameters used in the different pre-defined models:
</p>
<p>White Noise model (WN):
</p>

<ul>
<li><p> root: root value
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in model.priors
</p>
</li></ul>

<p>Brownian Motion model (BM):
</p>

<ul>
<li><p> root: root value
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in model.priors
</p>
</li></ul>

<p>Ornstein Uhlenbeck model (OU):
</p>

<ul>
<li><p> root: root value. Only used if &quot;root&quot; is specified in model.priors
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in model.priors
</p>
</li>
<li><p> theta: optimal value, n regimes if &quot;theta&quot; is specified in model.priors
</p>
</li>
<li><p> alpha: strength of selection, n regimes if &quot;alpha&quot; is specified in model.priors
</p>
</li></ul>



<h3>Value</h3>

<p>A list of functions and tuning parameters (of class &quot;JIVE&quot; and &quot;list&quot;) representing the plan of the hierarchical model to parse into <code><a href="#topic+mcmc_bite">mcmc_bite</a></code>.
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau, Anna Kostikova, Daniele Silvestro and Simon Joly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xml_bite">xml_bite</a></code>, <code><a href="#topic+mcmc_bite">mcmc_bite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load test data
data(Anolis_traits)
data(Anolis_tree)
data(Anolis_map)

## JIVE object to run jive with single regimes
my.jive &lt;- make_jive(phy = Anolis_tree, traits = Anolis_traits[,-3],
 model.priors = list(mean = "BM", logvar= c("OU", "root")))

## JIVE object to run jive with multiple regimes
my.jive &lt;- make_jive(Anolis_tree, Anolis_traits[,-3], map = Anolis_map,
 model.priors =list(mean = "BM", logvar = c("OU", "theta", "alpha")))

## JIVE object to run jive from an ancestral state reconstruction (stochastic mapping)
# First generate simmap object
library(phytools)
n= length(Anolis_tree$tip.label)
trait = rep(0,n)
trait[c(4,3,14,16, 6,5)] = 1
names(trait) =  Anolis_tree$tip.label

mapped_tree=make.simmap(Anolis_tree, trait, model='SYM')
plotSimmap(mapped_tree)

my.jive &lt;- make_jive(mapped_tree, Anolis_traits[,-3]
, model.priors = list(mean = "OU" , logvar = c("OU", "theta")))
 
 ## Jive object using another model of trait evolution (EB from mvMORPH)
 library(mvMORPH)
 early_burst &lt;- function(tree, x, pars){
  suppressMessages(mvEB(tree, x, method = "inverse", optimization = "fixed", 
   echo = FALSE)$llik(pars, root.mle = FALSE))
 }
 
 my.jive &lt;- make_jive(phy = Anolis_tree, traits = Anolis_traits[,-3]
, model.priors = list(mean = early_burst , logvar = c("OU", "root")))
 initial.values &lt;- c(0.1, 1, 50)
 window.size &lt;- c(0.1, 0.2, 1)
 proposals &lt;- list("slidingWin", "slidingWin", "slidingWin")
 hyperprior &lt;- list(hpfun("Gamma", hp.pars = c(1.1, 5)), hpfun("Gamma", hp.pars = c(3, 5)),
                     hpfun("Uniform", hp.pars = c(30, 80)))
 names(initial.values) &lt;- names(window.size) &lt;- c("sigma_sq", "beta", "root")
 names(proposals) &lt;- names(hyperprior) &lt;- c("sigma_sq", "beta", "root")
 my.jive &lt;- control_jive(jive = my.jive, level = "prior", intvar = "mean",
  pars = names(initial.values), window.size = window.size,
  initial.values = initial.values, proposals = proposals, hyperprior = hyperprior)
 
 ## Jive object using another model of intraspecific variation (uniform model)
 lik_unif &lt;- function(pars.lik, traits, counts){
   if(!"mid" %in% names(pars.lik)) stop("'mid' parameter cannot be found in model.priors")
   if(!"logrange" %in% names(pars.lik)){
    stop("'logrange' parameter cannot be found in model.priors")
   }

   min.sp &lt;- pars.lik$mid - 1/2*exp(pars.lik$logrange)
   max.sp &lt;- pars.lik$mid + 1/2*exp(pars.lik$logrange)
   
   log.lik.U &lt;- sapply(1:length(traits), function(i){
   sum(dunif(traits[[i]], min.sp[i], max.sp[i], log = TRUE))
   })
   
   if (is.na(sum(log.lik.U))) {
     return(-Inf)
   } else {
     return(log.lik.U)
   }
 }
 
 init_unif &lt;- sapply(Anolis_tree$tip.label, function(sp){
  logrange &lt;- log(diff(range(Anolis_traits[Anolis_traits[,1] == sp, 3])) + 2)
  mid &lt;- mean(range(Anolis_traits[Anolis_traits[,1] == sp, 3]))
  c(mid = mid, logrange = logrange)
 })
 
 my.jive &lt;- make_jive(phy = Anolis_tree, traits = Anolis_traits[,-2],  
 model.priors = list(mid = "BM" , logrange = c("OU", "root")),
 lik.f = lik_unif, init = init_unif)
 
</code></pre>

<hr>
<h2 id='marginal_lik'>Calculate marginal likelihood by thermodynamic integration (LTI)</h2><span id='topic+marginal_lik'></span>

<h3>Description</h3>

<p>Calculate the marginal likelihood from a logfile generated by <code><a href="#topic+mcmc_bite">mcmc_bite</a></code> with thermodynamic integration (Lartillot and Philippe, 2006) or stepping stone (Xie et al., 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_lik(mcmc.log, burnin = 0, method = "SS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_lik_+3A_mcmc.log">mcmc.log</code></td>
<td>
<p>the output file of a <code><a href="#topic+mcmc_bite">mcmc_bite</a></code> run</p>
</td></tr>
<tr><td><code id="marginal_lik_+3A_burnin">burnin</code></td>
<td>
<p>number or proportion of iteration to delete</p>
</td></tr>
<tr><td><code id="marginal_lik_+3A_method">method</code></td>
<td>
<p>one of &quot;TI&quot; for thermodynamic integration and &quot;SS&quot; for stepping stone integration (the default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length one numeric double giving the marginal likelihood of the model.
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau and Simon Joly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load test data
data(Anolis_traits)
data(Anolis_tree)
data(Anolis_map)

## Run a MCMC chain with thermodynamic Integration
set.seed(300)
my.jive &lt;- make_jive(Anolis_tree, Anolis_traits[,-3],
  model.priors = list(mean="BM", logvar="OU"))
bite_ex &lt;- tempdir()
logfile &lt;- sprintf("%s/my.jive_mcmc_TI.log", bite_ex)
mcmc_bite(my.jive, log.file=logfile, ncat=10, sampling.freq=10,
 print.freq=100, ngen=1000, burnin=0) 
 
## import the results in R
res &lt;- read.csv(logfile, header = TRUE, sep = "\t")
 
mlikTI &lt;- marginal_lik(res, burnin = 0.1, method = "TI")
mlikTI

mlikSS &lt;- marginal_lik(res, burnin = 0.1, method = "SS")
mlikSS
</code></pre>

<hr>
<h2 id='mcmc_bite'>MCMC algorithm</h2><span id='topic+mcmc_bite'></span>

<h3>Description</h3>

<p>Implements Markov chain Monte Carlo sampling for trait evolution models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_bite(model, log.file = "bite_mcmc.log", sampling.freq = 1000,
  print.freq = 1000, ncat = 1, beta.param = 0.3, ngen = 5e+06,
  burnin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_bite_+3A_model">model</code></td>
<td>
<p>an object of class &quot;jive&quot; or other objects from the bite package (see details)</p>
</td></tr>
<tr><td><code id="mcmc_bite_+3A_log.file">log.file</code></td>
<td>
<p>name of the output file that will store the log of MCMC chain</p>
</td></tr>
<tr><td><code id="mcmc_bite_+3A_sampling.freq">sampling.freq</code></td>
<td>
<p>sampling frequency of the MCMC chain (how often chain will be saved into output file</p>
</td></tr>
<tr><td><code id="mcmc_bite_+3A_print.freq">print.freq</code></td>
<td>
<p>printing frequency of the MCMC chain (how often chain will be printed in the R console). Setting it to 0 will suppress every printed message</p>
</td></tr>
<tr><td><code id="mcmc_bite_+3A_ncat">ncat</code></td>
<td>
<p>number of classes for thermodynamic integration (see details)</p>
</td></tr>
<tr><td><code id="mcmc_bite_+3A_beta.param">beta.param</code></td>
<td>
<p>beta value to define classes for thermodynamic integration (see details)</p>
</td></tr>
<tr><td><code id="mcmc_bite_+3A_ngen">ngen</code></td>
<td>
<p>number of generation in MCMC chain</p>
</td></tr>
<tr><td><code id="mcmc_bite_+3A_burnin">burnin</code></td>
<td>
<p>a burning phase of MCMC chain (has to be specified for thermodynamic integration)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs MCMC sampling on jive object <code><a href="#topic+make_jive">make_jive</a></code> or objects describing other models of the bite package.
The jive object contains both the dataset and set of model to be used in MCMC. This function implements both a conventional MCMC
and an MCMC with thermodynamic integration. The latter option is turned off by default and can be changed by
setting ncat to values &gt; 1. The recommended ncat for TI is 10. When setting ncat &gt; 1, make sure to specify burning.
As a rule of thumb set burning to 1/10 fraction of ngen.
</p>


<h3>Value</h3>

<p>Generates a log file in the users filespace at the path defined by log.file
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau, Anna Kostikova, Daniele Silvestro, and Simon Joly
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Load test data
 data(Anolis_traits)
 data(Anolis_tree)
 data(Anolis_map)
 
 ## Run a simple MCMC chain
 set.seed(300)
 my.jive &lt;- make_jive(phy = Anolis_tree, traits = Anolis_traits[,-3],
  model.priors = list(mean = "BM", logvar= c("OU", "root")))
 bite_ex &lt;- tempdir()
 logfile &lt;- sprintf("%s/my.jive_mcmc.log", bite_ex)
 mcmc_bite(model = my.jive, log.file=logfile,
 sampling.freq=10, print.freq=0, ngen=1000) 
  
 ## Run an MCMC chain with thermodynamic integration
 logfile &lt;- sprintf("%s/my.jive_mcmc_TI.log", bite_ex)
 mcmc_bite(my.jive, log.file=logfile, ncat=10, 
  sampling.freq=10, print.freq=100, ngen=1000, burnin=10) 
</code></pre>

<hr>
<h2 id='plot_bf'>Plots summary of Bayes Factors calculations</h2><span id='topic+plot_bf'></span>

<h3>Description</h3>

<p>Lolipop plot representing values of BF (Bayes Factor) scores for different models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_bf(m.liks, thr = 2, dir = c("vertical", "horizontal"),
  col = c("#d32f23", "#2e86ab", "#000000"), col.thr = c("#a6e1fa"),
  ax.lab = "log(BF)", main = "", rank = TRUE, dec = TRUE,
  group.pattern = NULL, cex = c(1.2, 1, 1), mod.lab = NULL,
  srt.lab = 0, adj.lab = 0, space = c(1.2, 0.8))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_bf_+3A_m.liks">m.liks</code></td>
<td>
<p>matrix of marginal likelihoods (see details)</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_thr">thr</code></td>
<td>
<p>value of BF threshold for model selection (default is 2), Several thresholds can be given in the form of a vector</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_dir">dir</code></td>
<td>
<p>string giving the direction of the plot (&quot;vertical&quot;, &quot;horizontal&quot;)</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_col">col</code></td>
<td>
<p>color of the lines and dots. Could be of size one or more. The first element applies to the best model, the second to the ones below thr[1] and so on...</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_col.thr">col.thr</code></td>
<td>
<p>color for the threshold area (must be at the sime length as thr)</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_ax.lab">ax.lab</code></td>
<td>
<p>label of the axis.</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_main">main</code></td>
<td>
<p>an overall title for the plot</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_rank">rank</code></td>
<td>
<p>logical: should models be ranked by BF scores? (default is TRUE)</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_dec">dec</code></td>
<td>
<p>logical: should models be displayed in decreasing order? (default is TRUE)</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_group.pattern">group.pattern</code></td>
<td>
<p>Regular expression given a pattern to be matched in names(m.liks). The values matching that pattern will be grouped in the plot</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_cex">cex</code></td>
<td>
<p>size of the dots and width of the lines. Could be of size one or more. The first element applies to the best model, the second to the ones below thr[1] and so on...</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_mod.lab">mod.lab</code></td>
<td>
<p>name of the models. If mod.lab = NULL the names of m.liks are used</p>
</td></tr>
<tr><td><code id="plot_bf_+3A_srt.lab">srt.lab</code>, <code id="plot_bf_+3A_adj.lab">adj.lab</code></td>
<td>
<p>rotation and justification of model names, see srt and adj in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot_bf_+3A_space">space</code></td>
<td>
<p>only evaluated if group.pattern != NULL, numeric(2) indicating the space between groups and the space between members of the same groups</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fake marginal likelihood data
m.liks &lt;- c(20 ,33, 56, 51, 55, 12)
names(m.liks) &lt;- c("MBM-VBM", "MBM-VWN", "MBM-VOU", "MOU-VBM", "MOU-VWN", "MOU-VOU")

#Does not go well with default margin sizes
oldmar &lt;- par()$mar
par(mar = c(5,1,4,6))
plot_bf(m.liks)
plot_bf(m.liks, thr = c(2,6), col.thr = c("#a2c5ac", "#ade1e5"),
 col = c("#d32f23", "#468189","#2e86ab","#000000"), cex = c(1.2,1,0.8,0.8))
plot_bf(m.liks, group.pattern = "MBM", rank = FALSE)
plot_bf(m.liks, group.pattern = "MOU", rank = TRUE)
plot_bf(m.liks, group.pattern = c("VWN", "VOU", "VBM"), rank = TRUE)
par(mar = c(6,5,1,2))
plot_bf(m.liks, dir = "horizontal", srt.lab = -60, adj.lab = c(0,0.8))
par(mar = oldmar)
</code></pre>

<hr>
<h2 id='plot_hp'>plot Hyper-prior function</h2><span id='topic+plot_hp'></span>

<h3>Description</h3>

<p>This function plots a hyper-prior density function. 
Currently supported density function are Uniform, Gamma, Normal, Loggamma and Lognormal. 
The resulting function is used during MCMC <code><a href="#topic+mcmc_bite">mcmc_bite</a></code>
to estimate parameters of priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hp(hpf, col = c("#bfdbf7", "#f49e4c"), border = c("#2e86ab",
  "#a31621"), bty = "n", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hp_+3A_hpf">hpf</code></td>
<td>
<p>name of a density function. Supported density functions are: Uniform, Gamma and Normal</p>
</td></tr>
<tr><td><code id="plot_hp_+3A_col">col</code></td>
<td>
<p>color of the density area. Can be of size 2 (hpriors for the means, hpriors for the logvars) if a jive object is plotted</p>
</td></tr>
<tr><td><code id="plot_hp_+3A_border">border</code></td>
<td>
<p>color of the density curve. Can be of size 2 (hpriors for the means, hpriors for the logvars) if a jive object is plotted</p>
</td></tr>
<tr><td><code id="plot_hp_+3A_bty">bty</code>, <code id="plot_hp_+3A_...">...</code></td>
<td>
<p>additional parameters that can be passed to a density function and  <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three currently implemented density function: 
Uniform, Gamma and Normal. Each of these densities requires two input parameters and hp.pars 
must be a vector of two values and cannot be left empty.
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Load test data
 data(Anolis_traits)
 data(Anolis_tree)
   
 my.hp &lt;- hpfun(hpf="Uniform", hp.pars=c(1,2))
 plot_hp(my.hp)
 
 my.jive &lt;- make_jive(Anolis_tree, Anolis_traits[,-3], model.priors = list(mean="BM", logvar="OU"))
 plot_hp(my.jive, cex.main = .8)
</code></pre>

<hr>
<h2 id='plot_jive'>plot input data from a jive object</h2><span id='topic+plot_jive'></span>

<h3>Description</h3>

<p>This function plots the phylogenetic tree, the trait data and the map used as an input for a jive analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_jive(jive, col.map = NULL, col = "lightgrey",
  show.tip.label = TRUE, show.models = TRUE,
  direction = "rightwards", trait.lab = "x", trait.lim = NULL,
  srt.label = 0, c.reg = NULL, tip.color = "#000000", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_jive_+3A_jive">jive</code></td>
<td>
<p>a jive object built with the function <code><a href="#topic+make_jive">make_jive</a></code></p>
</td></tr>
<tr><td><code id="plot_jive_+3A_col.map">col.map</code></td>
<td>
<p>a vector of mode character indicating colors of the edges for the map ploting. It should be of same size than the number of regimes</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_col">col</code></td>
<td>
<p>a character indicating the color of the vioplots</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>a logical indicating whether to show the tip labels on the phylogeny (defaults to TRUE, i.e. the labels are shown).</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_show.models">show.models</code></td>
<td>
<p>a logical indicating whether to show details about model specification in the jive object.</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_direction">direction</code></td>
<td>
<p>a character string specifying the direction of the tree. Two values are possible: &quot;rightwards&quot; (the default) and &quot;upwards&quot;.</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_trait.lab">trait.lab</code></td>
<td>
<p>a charachter specifying the axis label for the traits</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_trait.lim">trait.lim</code></td>
<td>
<p>a vector of mode numeric indicating the limits for trait ploting</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_srt.label">srt.label</code></td>
<td>
<p>an integer indicating the string rotation in degrees for the tip labels</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_c.reg">c.reg</code></td>
<td>
<p>a real number indicating where to plot the names of the regimes. The names are not plotted if c.reg == NULL.</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_tip.color">tip.color</code></td>
<td>
<p>the colours used for the tip labels, eventually recycled.</p>
</td></tr>
<tr><td><code id="plot_jive_+3A_...">...</code></td>
<td>
<p>additional parameters that can be passed to <code><a href="vioplot.html#topic+vioplot">vioplot</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Anolis_traits)
data(Anolis_tree)
data(Anolis_map)

colnames(Anolis_map) &lt;- c("Hispaniola", "Cuba")
my.jive &lt;- make_jive(Anolis_tree, Anolis_traits[,-3], 
 model.priors = list(m="BM", v = "OU"))
par(cex.lab = .8, cex.axis = .8, las = 1, mgp = c(2,0.5,0))
plot_jive(jive = my.jive, show.tip.label = TRUE, 
trait.lab = "Snout to vent length (cm)", srt.label = 0, c.reg = 2)

my.jive &lt;- make_jive(Anolis_tree, Anolis_traits[,-3], Anolis_map,
 model.priors = list(m = "BM", v = c("OU", "theta")))
par(cex.lab = .8, cex.axis = .8, las = 1, mgp = c(2,0.5,0))
plot_jive(jive = my.jive, show.tip.label = TRUE, c.reg = 2,
 trait.lab = "Snout to vent length (cm)", srt.label = 70, direction = "upwards")
 
</code></pre>

<hr>
<h2 id='plot_mcmc_bite'>Plot trace and density from a log file</h2><span id='topic+plot_mcmc_bite'></span>

<h3>Description</h3>

<p>This function plots the trace and/or density of each mcmc sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mcmc_bite(mcmc.log, type = c("trace", "density"), burnin = 0,
  variable = NA, label = NA, col = "#000000", cex.est = 1,
  bty = "n", kp.burn = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mcmc_bite_+3A_mcmc.log">mcmc.log</code></td>
<td>
<p>Any mcmc sample with the saved iterations in rows and the variables in columns</p>
</td></tr>
<tr><td><code id="plot_mcmc_bite_+3A_type">type</code></td>
<td>
<p>Character taken in c(&quot;trace&quot;, &quot;density&quot;). If both are specified, they are plotted side by side in the same graphical device</p>
</td></tr>
<tr><td><code id="plot_mcmc_bite_+3A_burnin">burnin</code></td>
<td>
<p>The size of the burnin in number of iterations or the proportion of iteration you want to remove</p>
</td></tr>
<tr><td><code id="plot_mcmc_bite_+3A_variable">variable</code></td>
<td>
<p>The name or number of the variable to plot. If is.na(variable), all columns of mcmc.log will be plotted except &quot;iter&quot; and &quot;temperature&quot;</p>
</td></tr>
<tr><td><code id="plot_mcmc_bite_+3A_label">label</code></td>
<td>
<p>Full variable name to be plotted</p>
</td></tr>
<tr><td><code id="plot_mcmc_bite_+3A_col">col</code>, <code id="plot_mcmc_bite_+3A_bty">bty</code>, <code id="plot_mcmc_bite_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to parse to <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot_mcmc_bite_+3A_cex.est">cex.est</code></td>
<td>
<p>The magnification to be used for estimates display</p>
</td></tr>
<tr><td><code id="plot_mcmc_bite_+3A_kp.burn">kp.burn</code></td>
<td>
<p>Logical specifying whether the plot window should adjust to the pre-burnin values (only evaluated if &quot;trace&quot; in type)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Load test data
 data(Anolis_traits)
 data(Anolis_tree)
 data(Anolis_map)
 
 ## Run a simple MCMC chain
 my.jive &lt;- make_jive(Anolis_tree, Anolis_traits[-3],  model.priors = list(mean="BM", logvar="OU"))
 bite_ex &lt;- tempdir()
 logfile &lt;- sprintf("%s/my.jive_mcmc.log", bite_ex)
 mcmc_bite(my.jive, log.file=logfile, sampling.freq=10, print.freq=10, ngen=1000) 

 ## import the results in R
 res &lt;- read.csv(logfile, header = TRUE, sep = "\t")
 
 ## plot the results
 plot_mcmc_bite(res, burnin = 0.2, variable = NA, cex.est = .7)
 plot_mcmc_bite(res, burnin = 0.2, variable = "prior.mean", cex.est = .7)
</code></pre>

<hr>
<h2 id='plot_post_beast'>Plot posterior probabilities from beast</h2><span id='topic+plot_post_beast'></span>

<h3>Description</h3>

<p>This function plots the phylogenetic tree along with mean posterior probabilities of the chosen parameter. 
The default plots paramenter value under multiple regimes estimated with the beast implementation of JIVE, OU, BM and WN.
Options are included to plot node support and age bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_post_beast(mcc, post = TRUE, post.var = "rate",
  post.cex = par("cex"), post.col = "#ee964b", post.alpha = 1,
  post.border = "#000000", post.lwd = par("lwd"), leg = TRUE,
  leg.frac = c(0.2, 0.5), leg.lab = "rate", leg.cex = par("cex")/2,
  sup = TRUE, sup.var = "posterior", sup.cex = par("cex")/2,
  bars = FALSE, bar.var = "height_95%_HPD", bar.col = "#2e86ab",
  bar.alpha = 0.8, bar.thc = par("cex")/10, bar.border = "#000000",
  bar.lwd = par("lwd"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_post_beast_+3A_mcc">mcc</code></td>
<td>
<p>A character containing the path to the Maximum credibility tree from the Beast analysis and extracted from treeAnnotator</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_post">post</code></td>
<td>
<p>A logical specifying whether the mean posterior value of a parameter should be plot along the tree</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_post.var">post.var</code></td>
<td>
<p>A character containing the name of the parameter (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_post.cex">post.cex</code></td>
<td>
<p>A numeric giving the size of the dots (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_post.col">post.col</code></td>
<td>
<p>Color of the dots (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_post.alpha">post.alpha</code></td>
<td>
<p>A numeric giving the transparency of the dots (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_post.border">post.border</code></td>
<td>
<p>Color of the dots' border (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_post.lwd">post.lwd</code></td>
<td>
<p>Line width of the dots' border (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_leg">leg</code></td>
<td>
<p>A logical specifying whether a legend should be plotted (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_leg.frac">leg.frac</code></td>
<td>
<p>A vector giving the proportion of the plot window taken by the legend (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_leg.lab">leg.lab</code></td>
<td>
<p>Label of the legend (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_leg.cex">leg.cex</code></td>
<td>
<p>A numeric giving the size of the legend (only evaluated if post == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_sup">sup</code></td>
<td>
<p>A logical specifying whether node support information should be displayed</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_sup.var">sup.var</code></td>
<td>
<p>A character containing the name of the support variable (only evaluated if sup == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_sup.cex">sup.cex</code></td>
<td>
<p>A numeric giving the size of node support information (only evaluated if sup == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_bars">bars</code></td>
<td>
<p>A logical specifying whether node age bars should be plotted</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_bar.var">bar.var</code></td>
<td>
<p>A character containing the name of the node age variable. MIN and MAX should be available for this variable (only evaluated if bars == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_bar.col">bar.col</code></td>
<td>
<p>Color of the bars (only evaluated if bars == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_bar.alpha">bar.alpha</code></td>
<td>
<p>A numeric giving the transparency of the bars (only evaluated if bars == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_bar.thc">bar.thc</code></td>
<td>
<p>A numeric giving the thickness of the bars (only evaluated if bars == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_bar.border">bar.border</code></td>
<td>
<p>Color of the bars' border (only evaluated if bars == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_bar.lwd">bar.lwd</code></td>
<td>
<p>Line width of the bars' border (only evaluated if bars == TRUE)</p>
</td></tr>
<tr><td><code id="plot_post_beast_+3A_...">...</code></td>
<td>
<p>additional parameters that can be parsed to <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>leg = TRUE changes the proportion of the plot.window taken by the plot. Use <code>par(fig = c(0,1,0,1))</code> to restore default parameters
</p>


<h3>Value</h3>

<p>plot
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>

<hr>
<h2 id='plot_pvo'>Plots estimates of species traits distribution</h2><span id='topic+plot_pvo'></span>

<h3>Description</h3>

<p>Density plot representing estimated species trait distributions under a jive model.
This function plots the mean or median density distribution and the HPD distributions assuming that the trait is normally distributed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pvo(phy, traits, map = NULL, mcmc.log, tip = NA, burnin = 0.1,
  conf = 0.95, stat = "median", trait.lab = "x", col = NULL,
  lab = TRUE, lolipop = c(0.4, 0.4), cex.tip = par("cex"),
  var.f = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pvo_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree provided as either a simmap or a phylo object</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_traits">traits</code></td>
<td>
<p>trait data used to perform the jive analysis. This has to be of the same form as the one used in <code><a href="#topic+make_jive">make_jive</a></code></p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_map">map</code></td>
<td>
<p>map used to perform the jive analysis. This has to be of the same form as the one used in <code><a href="#topic+make_jive">make_jive</a></code></p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_mcmc.log">mcmc.log</code></td>
<td>
<p>the output file of a <code><a href="#topic+mcmc_bite">mcmc_bite</a></code> run</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_tip">tip</code></td>
<td>
<p>A string giving the species to be plotted. If tip == NA, the posterior distribution of every tip is plotted along with the phylogenetic tree</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_burnin">burnin</code></td>
<td>
<p>The size of the burnin in number of iterations or the proportion of iteration you want to remove</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_conf">conf</code></td>
<td>
<p>A number of [0,1] giving the confidence level desired.</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_stat">stat</code></td>
<td>
<p>A character giving the function to be used to estimate species mean and variance from the posterior distributions. Must be one of be &quot;mean&quot; and &quot;median&quot;</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_trait.lab">trait.lab</code></td>
<td>
<p>a charachter specifying the axis label for the traits</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_col">col</code></td>
<td>
<p>color of the density filling. Must be of size two for estimates and HPD. If col and border are NULL, two random colors are assigned</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_lab">lab</code></td>
<td>
<p>logical indicating whether to show species name in the plot. Only evaluated if tip =! NA</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_lolipop">lolipop</code></td>
<td>
<p>size and width of the lolipops representing samples</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_cex.tip">cex.tip</code></td>
<td>
<p>size of the tips</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_var.f">var.f</code></td>
<td>
<p>alternative distribution used to model intraspecific variation of the form function(n, pars). The function must return n samples from the given distribution.</p>
</td></tr>
<tr><td><code id="plot_pvo_+3A_...">...</code></td>
<td>
<p>Additional parameters that can be parsed to plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load test data
data(Anolis_traits)
data(Anolis_tree)
data(Anolis_map)
# Run a simple MCMC chain
my.jive &lt;- make_jive(Anolis_tree, Anolis_traits[,-3],  model.priors=list(mean="BM", logvar = "OU"))
bite_ex &lt;- tempdir()
logfile &lt;- sprintf("%s/my.jive_mcmc.log", bite_ex)
mcmc_bite(my.jive, log.file=logfile, sampling.freq=1, print.freq=1, ngen=500) 
# import the results in R
res &lt;- read.csv(logfile, header = TRUE, sep = "\t")
 plot_pvo(phy = Anolis_tree, traits = Anolis_traits, tip = NA, mcmc.log = res)

</code></pre>

<hr>
<h2 id='sim_jive'>Simulate JIVE process</h2><span id='topic+sim_jive'></span>

<h3>Description</h3>

<p>Generate random values of trait mean and variance simulated under a JIVE process along a phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_jive(phy, map = NULL, models = list(mean = c("BM"), logvar =
  c("OU")), pars = list(mean = c(root = 0, sigma_sq = 0.1), logvar =
  c(root = 2, theta = 1, sigma_sq = 0.1, alpha = 1)), sampling = c(1, 7),
  bounds = list(c(-Inf, Inf), c(-Inf, Inf)), var.f = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_jive_+3A_phy">phy</code></td>
<td>
<p>Phylogenetic tree</p>
</td></tr>
<tr><td><code id="sim_jive_+3A_map">map</code></td>
<td>
<p>list containing the mapping of regimes over each edge (see details)</p>
</td></tr>
<tr><td><code id="sim_jive_+3A_models">models</code></td>
<td>
<p>list giving model specification for the simulation of trait evolution. Supported models are c(&quot;OU&quot;, &quot;BM&quot;, &quot;WN&quot;). The user can also specify if the assumptions of the model should be relaxed (see details)</p>
</td></tr>
<tr><td><code id="sim_jive_+3A_pars">pars</code></td>
<td>
<p>list giving parameters used for the simulation of trait evolution (see details). Name of parameters must be explecitly entered (see details)</p>
</td></tr>
<tr><td><code id="sim_jive_+3A_sampling">sampling</code></td>
<td>
<p>vector of size 2 giving the min and max number of individual per species</p>
</td></tr>
<tr><td><code id="sim_jive_+3A_bounds">bounds</code></td>
<td>
<p>list giving traits bounds</p>
</td></tr>
<tr><td><code id="sim_jive_+3A_var.f">var.f</code></td>
<td>
<p>alternative function to model intraspecific variation of the form: function(n, pars) with n, number of individuals and pars, parameters of the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>map : the list must be ordered in the same order than phy$edge. Each element represents an edge and contains a vector indicating the time spent under each regime in the branch. The name of the regimes must appear on the map
models : trait evolution can be simulated using Ornstein-Uhlenbeck (OU), Brownian Motion (BM) or White Noise (WN) processes. Multiple regimes can be defined for both models and will apply on thetas: c(&quot;OU&quot;, &quot;theta&quot;), sigmas: c(&quot;OU&quot;, &quot;sigma&quot;) or alphas: c(&quot;OU&quot;, &quot;alpha&quot;) for OU and on sigmas only for WN: c(&quot;WN&quot;, &quot;sigma&quot;) and BM: c(&quot;BM&quot;, &quot;sigma&quot;). While using the OU model, the user can also relax the stationarity of the root: c(&quot;OU&quot;, &quot;root&quot;) and relax several assumptions at the same time c(&quot;OU&quot;, &quot;root&quot;, &quot;theta&quot;) 
pars : list containing parameters depending on the chosen model. Elements of that lists must be vectors of size 1 or n, with n = number of regimes in the map.
Each element of pars must be named with the corresponding parameter abbreviation.
Parameters used in the different models:
</p>
<p>White Noise model (WN):
</p>

<ul>
<li><p> root: root value
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in models
</p>
</li></ul>

<p>Brownian Motion model (BM):
</p>

<ul>
<li><p> root: root value
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in models
</p>
</li></ul>

<p>Ornstein Uhlenbeck model (OU):
</p>

<ul>
<li><p> root: root value. Only used if &quot;root&quot; is specified in models
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in models
</p>
</li>
<li><p> theta: optimal value, n regimes if &quot;theta&quot; is specified in models
</p>
</li>
<li><p> alpha: strength of selection, n regimes if &quot;alpha&quot; is specified in models
</p>
</li></ul>



<h3>Value</h3>

<p>A list of length two containing a numeric matrix named &quot;evo_traits&quot; giving simulated traits representing intraspecific variation and a data.frame called &quot;obs&quot; containing species name in the fisrt column and individual observation of the trait in the second.
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(phytools)
phy &lt;- pbtree(n = 50)
Q &lt;- cbind(c(-.002, .002), c(.002, -.002))
phy &lt;- sim.history(phy, Q = Q)
# MBM and VOU
jive_phy &lt;- sim_jive(phy = phy, map = phy$maps)

# MWN + sigma and VOU + theta + root + alpha
jive_phy &lt;- sim_jive(phy = phy, map = phy$maps, 
   models = list(mean= c("WN", "sigma"), logvar = c("OU")),
   pars = list(mean = c(root = 0, sigma_sq1 = 0.1, sigma_sq2 = 0.5), 
              logvar = c(root = 10, theta1 = 5, theta2 = 10,
                         sigma_sq = 0.1, alpha1 = 0.2, alpha2 = 0.8))
 )


# With a different model of intraspecific variation:
unif.f &lt;- function(n, pars){
 runif(n, pars[1] - exp(pars[2])/2, pars[1] + exp(pars[2])/2)
}

unif_phy &lt;- sim_jive(phy = phy, map = phy$maps, models = list(mid=c("BM"), logrange=c("OU")),
 pars = list(mid = c(root = 0, sigma_sq = 0.1),
             logrange = c(root = 2, theta = 1, sigma_sq = 0.1, alpha = 1)),
 var.f = unif.f)

</code></pre>

<hr>
<h2 id='sim_mte'>Simulate MTE process</h2><span id='topic+sim_mte'></span>

<h3>Description</h3>

<p>Generate random values of trait mean simulated under a MTE process along a phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_mte(phy, map = NULL, model = "OU", pars = c(root = 2, theta = 1,
  sigma_sq = 0.1, alpha = 1), sampling = c(1, 7), bounds = c(-Inf,
  Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_mte_+3A_phy">phy</code></td>
<td>
<p>Phylogenetic tree</p>
</td></tr>
<tr><td><code id="sim_mte_+3A_map">map</code></td>
<td>
<p>list containing the mapping of regimes over each edge (see details).</p>
</td></tr>
<tr><td><code id="sim_mte_+3A_model">model</code></td>
<td>
<p>model specification for the simulation of trait mean evolution. Supported models are c(&quot;OU&quot;, &quot;BM&quot;, &quot;WN&quot;)</p>
</td></tr>
<tr><td><code id="sim_mte_+3A_pars">pars</code></td>
<td>
<p>parameters used for the simulation of trait mean evolution (see details).</p>
</td></tr>
<tr><td><code id="sim_mte_+3A_sampling">sampling</code></td>
<td>
<p>vector of size 2 giving the min and max number of individual per species</p>
</td></tr>
<tr><td><code id="sim_mte_+3A_bounds">bounds</code></td>
<td>
<p>vector of size 2 giving the bounds of the mean</p>
</td></tr>
</table>


<h3>Details</h3>

<p>map : the list must be ordered in the same order than phy$edge. Each element represents an edge and contains a vector indicating the time spent under each regime in the branch. The name of the regimes must appear on the map
pars : list containing parameters depending on the chosen model. Elements of that lists must be vectors of size 1 or n, with n = number of regimes in the map.
Each element of pars must be named with the corresponding parameter abbreviation.
Parameters used in the different models:
</p>
<p>White Noise model (WN):
</p>

<ul>
<li><p> root: root value
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in models
</p>
</li></ul>

<p>Brownian Motion model (BM):
</p>

<ul>
<li><p> root: root value
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in models
</p>
</li></ul>

<p>Ornstein Uhlenbeck model (OU):
</p>

<ul>
<li><p> root: root value. Only used if &quot;root&quot; is specified in models
</p>
</li>
<li><p> sigma_sq: evolutionary rate, n regimes if &quot;sigma&quot; is specified in models
</p>
</li>
<li><p> theta: optimal value, n regimes if &quot;theta&quot; is specified in models
</p>
</li>
<li><p> alpha: strength of selection, n regimes if &quot;alpha&quot; is specified in models
</p>
</li></ul>



<h3>Value</h3>

<p>returns a numeric vector giving the simulated mean value of the trait for each species of the tree.
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(phytools)
phy &lt;- pbtree(n = 50)
Q &lt;- cbind(c(-.002, .002), c(.002, -.002))
phy &lt;- sim.history(phy, Q = Q)
# MBM and VOU
mte_phy &lt;- sim_mte(phy, phy$maps)

</code></pre>

<hr>
<h2 id='xml_bite'>Write xml file with model</h2><span id='topic+xml_bite'></span>

<h3>Description</h3>

<p>Modifies a .xml file from beauti to include a model model in the Beast 2 analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_bite(model, xml, out = sprintf("%s_edited.xml", gsub(".xml", "",
  xml)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_bite_+3A_model">model</code></td>
<td>
<p>an object of class &quot;model&quot; (see details)</p>
</td></tr>
<tr><td><code id="xml_bite_+3A_xml">xml</code></td>
<td>
<p>name of the output file that will store the log of MCMC chain</p>
</td></tr>
<tr><td><code id="xml_bite_+3A_out">out</code></td>
<td>
<p>where to write the edited xml</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a .xml file generated with Beauti and a model object generated with <code><a href="#topic+make_jive">make_jive</a></code>
Only model objects that use models supported by the Beast implementation of model (&quot;BM&quot;, c(&quot;BM&quot;, &quot;sigma&quot;), &quot;WN&quot;, &quot;OU&quot;, c(&quot;OU&quot;, &quot;theta&quot;), c(&quot;OU&quot;, &quot;root&quot;), c(&quot;OU&quot;, &quot;root&quot;, &quot;theta&quot;))
</p>


<h3>Value</h3>

<p>no return value, called for side effects
</p>
<p>No return value: Modifies the .xml file given in xml in the user's filespace.
</p>


<h3>Author(s)</h3>

<p>Theo Gaboriau
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
