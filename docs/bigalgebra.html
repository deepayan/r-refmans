<!DOCTYPE html><html><head><title>Help for package bigalgebra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigalgebra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#balgebra-methods'><p>Class <code>"big.matrix"</code> arithmetic methods</p></a></li>
<li><a href='#bigalgebra-package'>
<p>Arithmetic routines for native R matrices and big.matrix objects.</p></a></li>
<li><a href='#daxpy'><p>BLAS daxpy functionality</p></a></li>
<li><a href='#dcopy'><p>Copy a vector.</p></a></li>
<li><a href='#dgeev'><p>DGEEV computes eigenvalues and eigenvectors.</p></a></li>
<li><a href='#dgemm'><p>Matrix Multiply</p></a></li>
<li><a href='#dgeqrf'><p>QR factorization</p></a></li>
<li><a href='#dgesdd'><p>DGESDD computes the singular value decomposition (SVD) of a real matrix.</p></a></li>
<li><a href='#dpotrf'><p>Cholesky factorization</p></a></li>
<li><a href='#dscal'><p>Scales a vector by a constant.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'BLAS' and 'LAPACK' Routines for Native R Matrices and
'big.matrix' Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-08</td>
</tr>
<tr>
<td>Depends:</td>
<td>bigmemory (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>bigmemory, BH, Rcpp</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederic Bertrand <a href="https://orcid.org/0000-0002-0837-8281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, ctb],
  Michael J. Kane [aut],
  Bryan Lewis [aut],
  John W. Emerson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederic Bertrand &lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides arithmetic functions for R matrix and 'big.matrix' objects as well as functions for QR factorization, Cholesky factorization, General eigenvalue, and Singular value decomposition (SVD). A method matrix multiplication and an arithmetic method -for matrix addition, matrix difference- allows for mixed type operation -a matrix class object and a big.matrix class object- and pure type operation for two big.matrix class objects.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Copyright:</td>
<td>(C) 2014 Michael J. Kane, Bryan Lewis, and John W. Emerson</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fbertran.github.io/bigalgebra/">https://fbertran.github.io/bigalgebra/</a>,
<a href="https://github.com/fbertran/bigalgebra/">https://github.com/fbertran/bigalgebra/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fbertran/bigalgebra/issues/">https://github.com/fbertran/bigalgebra/issues/</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 20:27:39 UTC; fbertran</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-09 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='balgebra-methods'>Class <code>"big.matrix"</code> arithmetic methods</h2><span id='topic++25+2A+25+2Cbig.matrix+2Cbig.matrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2Cbig.matrix-method'></span><span id='topic++25+2A+25+2Cbig.matrix+2Cmatrix-method'></span><span id='topic+Arith+2Cbig.matrix+2Cbig.matrix-method'></span><span id='topic+Arith+2Cbig.matrix+2Cmatrix-method'></span><span id='topic+Arith+2Cmatrix+2Cbig.matrix-method'></span><span id='topic+Arith+2Cbig.matrix+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2Cbig.matrix-method'></span>

<h3>Description</h3>

<p>Arithmetic operations for big.matrices</p>


<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature{x="big.matrix", y="big.matrix"}</code>: ...</p>
</dd>
<dt>%*%</dt><dd><p><code>signature{x="matrix", y="big.matrix"}</code>: ...</p>
</dd>
<dt>%*%</dt><dd><p><code>signature{x="big.matrix", y="matrix"}</code>: ...</p>
</dd>
<dt>Arith</dt><dd><p><code>signature{x="big.matrix", y="big.matrix"}</code>: ...</p>
</dd>
<dt>Arith</dt><dd><p><code>signature{x="big.matrix", y="matrix"}</code>: ...</p>
</dd>
<dt>Arith</dt><dd><p><code>signature{x="matrix", y="big.matrix"}</code>: ...</p>
</dd>
<dt>Arith</dt><dd><p><code>signature{x="big.matrix", y="numeric"}</code>: ...</p>
</dd>
<dt>Arith</dt><dd><p><code>signature{x="numeric", y="big.matrix"}</code>: ...</p>
</dd>
</dl>



<h3>Notes</h3>

<p>Miscellaneous arithmetic methods for matrices and big.matrices. See
also <code>options("bigalgebra.mixed_arithmetic_returns_R_matrix")</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@illposed.net&gt;
</p>

<hr>
<h2 id='bigalgebra-package'>
Arithmetic routines for native R matrices and big.matrix objects.
</h2><span id='topic+bigalgebra-package'></span><span id='topic+bigalgebra'></span>

<h3>Description</h3>

<p>This package provides arithmetic functions for native <span class="rlang"><b>R</b></span> matrices and
<code><a href="bigmemory.html#topic+big.matrix">big.matrix</a></code> objects.
</p>


<h3>Details</h3>

<p>This package provides arithmetic functions for native <span class="rlang"><b>R</b></span> matrices and
<code><a href="bigmemory.html#topic+big.matrix">big.matrix</a></code> objects. 
</p>
<p>The package defines a number of 
global options that begin with <code>bigalgebra</code>.
They include:
</p>

<table>
<tr>
 <td style="text-align: left;">
Option </td><td style="text-align: left;"> Default value</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bigalgebra.temp_pattern</code> </td><td style="text-align: left;"> "matrix_"</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bigalgebra.tempdir</code> </td><td style="text-align: left;"> <code>tempdir</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bigalgebra.mixed_arithmetic_returns_R_matrix</code> </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bigalgebra.DEBUG</code> </td><td style="text-align: left;"> FALSE</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>bigalgebra.tempdir</code> option must be a function that returns
a temporary directory path used to big matrix results of BLAS and
LAPACK operations. The deault value is simply the default R <code>tempdir</code>
function.
</p>
<p>The <code>bigalgebra.temp_pattern</code> is a name prefix for file names of generated
big matrix objects output as a result of BLAS and LAPACK operations.
</p>
<p>The <code>bigalgebra.mixed_arithmetic_returns_R_matrix</code> option determines
whether arithmetic operations involving an R matrix or vector and a big.matrix
matrix or vector return a big matrix (when the option is <code>FALSE</code>), or
return a normal R matrix (<code>TRUE</code>).
</p>
<p>The package is built, by default, with <span class="rlang"><b>R</b></span>'s native BLAS libraries, which use
32-bit signed integer indexing. The default build is limited to vectors of at
most 2**31 - 1 entries and matrices with at most 2**31 - 1 rows and 2**31 - 1
columns (note that standard R matrices are limtied to 2**31 - 1 total entries).
</p>
<p>The package includes a reference BLAS implementation that supports 64-bit
integer indexing, relaxing the limitation on vector lengths and matrix
row and column limits. Installation of this package with the 64-bit reference
BLAS implementation may be performed from the command-line install:
</p>
<p><code>REFBLAS=1 R CMD INSTALL bigalgebra</code>
</p>
<p>where &quot;<code>bigalgebra</code>&quot; is the source package (for example,
<code>bigalgebra_0.8.4.tar.gz</code>).
</p>
<p>The package may also be build with user-supplied external BLAS and LAPACK
libraries, in either 32- or 64-bit varieties. This is an advanced topic
that requires additional Makevars modification, and may include adjustment
of the low-level calling syntax depending on the library used.
</p>
<p>Feel free to contact us for help installing and running the package.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand, Michael J. Kane, Bryan Lewis, John W. Emerson
</p>
<p>Maintainer: Frédéric Bertrand &lt;frederic.bertrand@utt.fr&gt;
</p>


<h3>References</h3>

<p><a href="https://www.netlib.org/blas/">https://www.netlib.org/blas/</a>
</p>
<p><a href="https://www.netlib.org/lapack/">https://www.netlib.org/lapack/</a>
</p>


<h3>See Also</h3>

<p><code><a href="bigmemory.html#topic+bigmemory">bigmemory</a></code>, <code><a href="bigmemory.html#topic+big.matrix">big.matrix</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Testing the development of the user-friendly operators:
# if you have any problems, please email us!  - Jay &amp; Mike 4/29/2010

library("bigmemory")
A &lt;- big.matrix(5,4, type="double", init=0,
                dimnames=list(NULL, c("alpha", "beta")))
B &lt;- big.matrix(4,4, type="double", init=0,
                dimnames=list(NULL, c("alpha", "beta")))

C &lt;- A 
D &lt;- A[] 

print(C - D)       # Compare the results (subtraction of an R matrix from a
                   # big.matrix)

# The next example illustrates mixing R and big.matrix objects. It returns by
# default (see # options("bigalgebra.mixed_arithmetic_returns_R_matrix")
D &lt;- matrix(rnorm(16),4)
E &lt;- A 
</code></pre>

<hr>
<h2 id='daxpy'>BLAS daxpy functionality</h2><span id='topic+daxpy'></span>

<h3>Description</h3>

<p>This function implements the function Y := A * X + Y where X and Y may be either native double-precision valued R matrices or numeric vectors, or double-precision valued <code><a href="bigmemory.html#topic+big.matrix">big.matrix</a></code> objects, and A is a scalar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daxpy(A = 1, X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daxpy_+3A_a">A</code></td>
<td>
<p>Optional numeric scalar value to scale the matrix <code>X</code> by, with a default value of 1.</p>
</td></tr>
<tr><td><code id="daxpy_+3A_x">X</code></td>
<td>
<p>Requried to be either a native <span class="rlang"><b>R</b></span> <code><a href="base.html#topic+matrix">matrix</a></code> or numeric vector, or a <code><a href="bigmemory.html#topic+big.matrix">big.matrix</a></code> object</p>
</td></tr>
<tr><td><code id="daxpy_+3A_y">Y</code></td>
<td>
<p>Optional native <span class="rlang"><b>R</b></span> <code><a href="base.html#topic+matrix">matrix</a></code> or numeric vector, or a <code><a href="bigmemory.html#topic+big.matrix">big.matrix</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of either <code>X</code> or <code>Y</code> must be a <code>big.matrix</code>. All values must be of type <code>double</code> (the only type presently supported by the bigalgebra package).
</p>
<p>This function is rarely necessary to use directly since the bigalgebra package defines standard arithmetic operations and scalar multiplication. It is more efficient to use <code>daxpy</code> directly when both scaling and matrix addition are required, in which case both operations are performed in one step.
</p>


<h3>Value</h3>

<p>The output value depends on the classes of input values <code>X</code> and <code>Y</code> and on the value of the global option <code>bigalgebra.mixed_arithmetic_returns_R_matrix</code>.
</p>
<p>If <code>X</code> and <code>Y</code> are both big matrices, or <code>Y</code> is missing, <code>options("bigalgebra.mixed_arithmetic_returns_R_matrix")</code> is <code>FALSE</code>, then a <code>big.matrix</code> is returned. The returned <code>big.matrix</code> is backed by a temporary file mapping that will be deleted when the returned result is garbage collected by R (see the examples).
</p>
<p>Otherwise, a standard R matrix is returned. The dimensional shape of the output is taken from <code>X</code>. If input <code>X</code> is dimensionless (that is, lacks a dimension attribute), then the output is a column vector.
</p>


<h3>Author(s)</h3>

<p>Michael J. Kane
</p>


<h3>References</h3>

<p><a href="https://www.netlib.org/blas/daxpy.f">https://www.netlib.org/blas/daxpy.f</a>
</p>


<h3>See Also</h3>

<p><code><a href="bigmemory.html#topic+bigmemory">bigmemory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bigmemory)
A = matrix(1, nrow=3, ncol=2)
B &lt;- big.matrix(3, 2, type="double", init=0,
               dimnames=list(NULL, c("alpha", "beta")), shared=FALSE)
C = B + B   # C is a new big matrix
D = A + B   # D defaults to a regular R matrix, to change this, set the option:
# options(bigalgebra.mixed_arithmetic_returns_R_matrix=FALSE)
E = daxpy(A=1.0, X=B, Y=B)  # Same kind of result as C
print(C[])
print(D)
print(E[])

# The C and E big.matrix file backings will be deleted when garbage collected:
# (We enable debugging to see this explicitly)
options(bigalgebra.DEBUG=TRUE)
rm(C,E)
gc()

</code></pre>

<hr>
<h2 id='dcopy'>Copy a vector.</h2><span id='topic+dcopy'></span>

<h3>Description</h3>

<p>Copy double precision DX to double precision DY.
For I = 0 to N-1, copy DX(LX+I*INCX) to DY(LY+I*INCY),
where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
defined in a similar way using INCY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcopy(N = NULL, X, INCX = 1, Y, INCY = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcopy_+3A_n">N</code></td>
<td>
<p>number of elements in input vector(s)</p>
</td></tr>
<tr><td><code id="dcopy_+3A_x">X</code></td>
<td>
<p>double precision vector with N elements</p>
</td></tr>
<tr><td><code id="dcopy_+3A_incx">INCX</code></td>
<td>
<p>storage spacing between elements of DX</p>
</td></tr>
<tr><td><code id="dcopy_+3A_y">Y</code></td>
<td>
<p>double precision vector with N elements</p>
</td></tr>
<tr><td><code id="dcopy_+3A_incy">INCY</code></td>
<td>
<p>storage spacing between elements of DY</p>
</td></tr>
</table>


<h3>Value</h3>

<p>DY copy of vector DX (unchanged if N .LE. 0)
</p>


<h3>References</h3>

<p>C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T. Krogh, Basic linear algebra subprograms for Fortran usage, Algorithm No. 539, Transactions on Mathematical Software 5, 3 (September 1979), pp. 308-323.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(4669)
A = big.matrix(3, 2, type="double", init=1, dimnames=list(NULL, 
c("alpha", "beta")), shared=FALSE)
B = big.matrix(3, 2, type="double", init=0, dimnames=list(NULL, 
c("alpha", "beta")), shared=FALSE)

dcopy(X=A,Y=B)
A[,]-B[,]

# The big.matrix file backings will be deleted when garbage collected.
rm(A,B)
gc()

## End(Not run)
</code></pre>

<hr>
<h2 id='dgeev'>DGEEV computes eigenvalues and eigenvectors.</h2><span id='topic+dgeev'></span>

<h3>Description</h3>

<p>DGEEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices.
</p>
<p>DGEEV computes for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors.
The right eigenvector v(j) of A satisfies A * v(j) = lambda(j) * v(j) where lambda(j) is its eigenvalue.
The left eigenvector u(j) of A satisfies u(j)**H * A = lambda(j) * u(j)**H where u(j)**H denotes the conjugate-transpose of u(j).
</p>
<p>The computed eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgeev(
  JOBVL = "V",
  JOBVR = "V",
  N = NULL,
  A,
  LDA = NULL,
  WR,
  WI,
  VL,
  LDVL = NULL,
  VR = NULL,
  LDVR = NULL,
  WORK = NULL,
  LWORK = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgeev_+3A_jobvl">JOBVL</code></td>
<td>
<p>a character.
</p>

<dl>
<dt>= 'N':</dt><dd><p>left eigenvectors of A are not computed;</p>
</dd>
<dt>= 'V':</dt><dd><p>left eigenvectors of A are computed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgeev_+3A_jobvr">JOBVR</code></td>
<td>
<p>a character.
</p>

<dl>
<dt>= 'N':</dt><dd><p>right eigenvectors of A are not computed;</p>
</dd>
<dt>= 'V':</dt><dd><p>right eigenvectors of A are computed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgeev_+3A_n">N</code></td>
<td>
<p>an integer. The order of the matrix A. N &gt;= 0.</p>
</td></tr>
<tr><td><code id="dgeev_+3A_a">A</code></td>
<td>
<p>a matrix of dimension (LDA,N), the N-by-N matrix A.</p>
</td></tr>
<tr><td><code id="dgeev_+3A_lda">LDA</code></td>
<td>
<p>an integer. The leading dimension of the matrix A. LDA &gt;= max(1,N).</p>
</td></tr>
<tr><td><code id="dgeev_+3A_wr">WR</code></td>
<td>
<p>a vector of dimension (N). WR contain the real part of the computed eigenvalues. Complex conjugate pairs of eigenvalues appear consecutively with the eigenvalue having the positive imaginary part first.</p>
</td></tr>
<tr><td><code id="dgeev_+3A_wi">WI</code></td>
<td>
<p>a vector of dimension (N). WI contain the imaginary part of the computed eigenvalues. Complex conjugate pairs of eigenvalues appear consecutively with the eigenvalue having the positive imaginary part first.</p>
</td></tr>
<tr><td><code id="dgeev_+3A_vl">VL</code></td>
<td>
<p>a matrx of dimension (LDVL,N)
</p>

<dl>
<dt>If</dt><dd><p> JOBVL = 'V', the left eigenvectors u(j) are stored one
after another in the columns of VL, in the same order
as their eigenvalues.</p>
</dd>
<dt>If</dt><dd><p> JOBVL = 'N', VL is not referenced.</p>
</dd>
<dt>If</dt><dd><p> the j-th eigenvalue is real, then u(j) = VL(:,j),
the j-th column of VL.</p>
</dd>
<dt>If</dt><dd><p> the j-th and (j+1)-st eigenvalues form a complex
conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
u(j+1) = VL(:,j) - i*VL(:,j+1).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgeev_+3A_ldvl">LDVL</code></td>
<td>
<p>an integer. The leading dimension of the array VL. LDVL &gt;= 1; if JOBVL = 'V', LDVL &gt;= N.</p>
</td></tr>
<tr><td><code id="dgeev_+3A_vr">VR</code></td>
<td>
<p>a matrix of dimension (LDVR,N). 
</p>

<dl>
<dt>If</dt><dd><p> JOBVR = 'V', the right eigenvectors v(j) are stored one after another in the columns of VR, in the same order as their eigenvalues.</p>
</dd>
<dt>If</dt><dd><p> JOBVR = 'N', VR is not referenced.</p>
</dd>
<dt>If</dt><dd><p> the j-th eigenvalue is real, then v(j) = VR(:,j), the j-th column of VR.</p>
</dd>
<dt>If</dt><dd><p> the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and v(j+1) = VR(:,j) - i*VR(:,j+1).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgeev_+3A_ldvr">LDVR</code></td>
<td>
<p>an integer. The leading dimension of the array VR.  LDVR &gt;= 1; if JOBVR = 'V', LDVR &gt;= N.</p>
</td></tr>
<tr><td><code id="dgeev_+3A_work">WORK</code></td>
<td>
<p>a matrix of dimension (MAX(1,LWORK))</p>
</td></tr>
<tr><td><code id="dgeev_+3A_lwork">LWORK</code></td>
<td>
<p>an integer. The dimension of the array WORK.LWORK &gt;= max(1,3*N), and if JOBVL = 'V' or JOBVR = 'V', LWORK &gt;= 4*N. For good performance, LWORK must generally be larger. If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>WR, WI, VR, VL and Work. On exit, A has been overwritten.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(4669)
A = matrix(rnorm(16),4)
WR= matrix(0,nrow=4,ncol=1)
WI= matrix(0,nrow=4,ncol=1)
VL = matrix(0,ncol=4,nrow=4)
eigen(A)
dgeev(A=A,WR=WR,WI=WI,VL=VL)
VL
WR
WI

rm(A,WR,WI,VL)

A = as.big.matrix(matrix(rnorm(16),4))
WR= matrix(0,nrow=4,ncol=1)
WI= matrix(0,nrow=4,ncol=1)
VL = as.big.matrix(matrix(0,ncol=4,nrow=4))
eigen(A[,])
dgeev(A=A,WR=WR,WI=WI,VL=VL)
VL[,]
WR[,]
WI[,]

rm(A,WR,WI,VL)
gc()

## End(Not run)
</code></pre>

<hr>
<h2 id='dgemm'>Matrix Multiply</h2><span id='topic+dgemm'></span>

<h3>Description</h3>

<p>This is function provides dgemm functionality, which DGEMM 
performs one of the matrix-matrix operations.
C := ALPHA * op(A) * op(B) + BETA * C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgemm(
  TRANSA = "N",
  TRANSB = "N",
  M = NULL,
  N = NULL,
  K = NULL,
  ALPHA = 1,
  A,
  LDA = NULL,
  B,
  LDB = NULL,
  BETA = 0,
  C,
  LDC = NULL,
  COFF = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgemm_+3A_transa">TRANSA</code></td>
<td>
<p>a character. TRANSA specifies the form of op( A ) to be used in the matrix multiplication as follows:
</p>

<dl>
<dt>TRANSA =</dt><dd><p> 'N' or 'n',  op( A ) = A.</p>
</dd>
<dt>TRANSA =</dt><dd><p> 'T' or 't',  op( A ) = A**T.</p>
</dd>
<dt>TRANSA =</dt><dd><p> 'C' or 'c',  op( A ) = A**T.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgemm_+3A_transb">TRANSB</code></td>
<td>
<p>a character. TRANSB specifies the form of op( B ) to be used in the matrix multiplication as follows:
#' </p>

<dl>
<dt>TRANSA =</dt><dd><p> 'N' or 'n',  op( B ) = B.</p>
</dd>
<dt>TRANSA =</dt><dd><p> 'T' or 't',  op( B ) = B**T.</p>
</dd>
<dt>TRANSA =</dt><dd><p> 'C' or 'c',  op( B ) = B**T.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgemm_+3A_m">M</code></td>
<td>
<p>an integer. M specifies the number of rows  of the  matrix op( A )  and of the  matrix  C.  M  must  be at least  zero.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_n">N</code></td>
<td>
<p>an integer. N specifies the number of columns  of the  matrix op( B )  and of the  matrix  C.  N  must  be at least  zero.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_k">K</code></td>
<td>
<p>an integer. K specifies the number of columns  of the  matrix op( A )  and the number of rows of the  matrix  op( B ).  K  must  be at least  zero.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_alpha">ALPHA</code></td>
<td>
<p>a real number. Specifies the scalar alpha.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_a">A</code></td>
<td>
<p>a matrix of dimension (LDA, ka), where ka is k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. Before entry with  TRANSA = 'N' or 'n',  the leading  m by k part of the array  A  must contain the matrix  A,  otherwise the leading  k by m  part of the array  A  must contain  the matrix A.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_lda">LDA</code></td>
<td>
<p>an integer.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_b">B</code></td>
<td>
<p>a matrix of dimension ( LDB, kb ), where kb is n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. Before entry with  TRANSB = 'N' or 'n',  the leading  k by n part of the array  B  must contain the matrix  B,  otherwise the leading  n by k  part of the array  B  must contain  the matrix B.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_ldb">LDB</code></td>
<td>
<p>an integer.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_beta">BETA</code></td>
<td>
<p>a real number. Specifies the scalar beta</p>
</td></tr>
<tr><td><code id="dgemm_+3A_c">C</code></td>
<td>
<p>a matrix of dimension ( LDC, N ). Before entry, the leading  m by n  part of the array  C must contain the matrix  C,  except when  beta  is zero, in which case C need not be set on entry. On exit, the array  C  is overwritten by the  m by n  matrix ( alpha*op( A )*op( B ) + beta*C ).</p>
</td></tr>
<tr><td><code id="dgemm_+3A_ldc">LDC</code></td>
<td>
<p>an integer.</p>
</td></tr>
<tr><td><code id="dgemm_+3A_coff">COFF</code></td>
<td>
<p>offset for C.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Update C with the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bigmemory)
A = as.big.matrix(matrix(1, nrow=3, ncol=2))
B &lt;- big.matrix(2, 3, type="double", init=-1,
                dimnames=list(NULL, c("alpha", "beta")), shared=FALSE)
C = big.matrix(3, 3, type="double", init=1,
               dimnames=list(NULL, c("alpha", "beta", "gamma")), shared=FALSE)  
2*A[,]%*%B[,]+0.5*C[,]
E = dgemm(ALPHA=2.0, A=A, B=B, BETA=0.5, C=C)
E[,] # Same result

# The big.matrix file backings will be deleted when garbage collected.
rm(A,B,C,E)
gc()
</code></pre>

<hr>
<h2 id='dgeqrf'>QR factorization</h2><span id='topic+dgeqrf'></span>

<h3>Description</h3>

<p>DGEQRF computes a QR factorization of a real M-by-N matrix A: A = Q * R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgeqrf(
  M = NULL,
  N = NULL,
  A,
  LDA = NULL,
  TAU = NULL,
  WORK = NULL,
  LWORK = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgeqrf_+3A_m">M</code></td>
<td>
<p>an integer. The number of rows of the matrix A.  M &gt;= 0.</p>
</td></tr>
<tr><td><code id="dgeqrf_+3A_n">N</code></td>
<td>
<p>an integer. The number of columns of the matrix A.  N &gt;= 0.</p>
</td></tr>
<tr><td><code id="dgeqrf_+3A_a">A</code></td>
<td>
<p>the M-by-N big matrix A.</p>
</td></tr>
<tr><td><code id="dgeqrf_+3A_lda">LDA</code></td>
<td>
<p>an integer. The leading dimension of the array A.  LDA &gt;= max(1,M).</p>
</td></tr>
<tr><td><code id="dgeqrf_+3A_tau">TAU</code></td>
<td>
<p>a min(M,N) matrix. The scalar factors of the elementary reflectors.</p>
</td></tr>
<tr><td><code id="dgeqrf_+3A_work">WORK</code></td>
<td>
<p>a (MAX(1,LWORK)) matrix. On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</p>
</td></tr>
<tr><td><code id="dgeqrf_+3A_lwork">LWORK</code></td>
<td>
<p>an integer. The dimension of th array WORK.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>M-by-N big matrix A. The elements on and above the diagonal of the 
array contain the min(M,N)-by-N upper trapezoidal matrix R (R is upper 
triangular if m &gt;= n); the elements below the diagonal, with the array TAU, 
represent the orthogonal matrix Q as a product of min(m,n) elementary 
reflectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#' hilbert &lt;- function(n) { i &lt;- 1:n; 1 / outer(i - 1, i, "+") }
h9 &lt;- hilbert(9); h9
qr(h9)$rank           #--&gt; only 7
qrh9 &lt;- qr(h9, tol = 1e-10)
qrh9$rank 
C &lt;- as.big.matrix(h9)
dgeqrf(A=C)

# The big.matrix file backings will be deleted when garbage collected.
rm(C)
gc()

## End(Not run)
</code></pre>

<hr>
<h2 id='dgesdd'>DGESDD computes the singular value decomposition (SVD) of a real matrix.</h2><span id='topic+dgesdd'></span>

<h3>Description</h3>

<p>DGESDD computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and right singular vectors.  If singular vectors are desired, it uses a divide-and-conquer algorithm.
</p>
<p>The SVD is written
</p>
<p>A = U * SIGMA * transpose(V)
</p>
<p>where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order.  The first min(m,n) columns of U and V are the left and right singular vectors of A.
</p>
<p>Note that the routine returns VT = V**T, not V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgesdd(
  JOBZ = "A",
  M = NULL,
  N = NULL,
  A,
  LDA = NULL,
  S,
  U,
  LDU = NULL,
  VT,
  LDVT = NULL,
  WORK = NULL,
  LWORK = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgesdd_+3A_jobz">JOBZ</code></td>
<td>
<p>a character. Specifies options for computing all or part of the matrix U:
</p>

<dl>
<dt>= 'A':</dt><dd><p> all M columns of U and all N rows of V**T are returned in the arrays U and VT;</p>
</dd>
<dt>= 'S':</dt><dd><p> the first min(M,N) columns of U and the first min(M,N) rows of V**T are returned in the arrays U and VT;</p>
</dd>
<dt>= 'O':</dt><dd><p> If M &gt;= N, the first N columns of U are overwritten on the array A and all rows of V**T are returned in the array VT; otherwise, all columns of U are returned in the array U and the first M rows of V**T are overwritten in the array A;</p>
</dd>
<dt>= 'N':</dt><dd><p> no columns of U or rows of V**T are computed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgesdd_+3A_m">M</code></td>
<td>
<p>an integer. The number of rows of the input matrix A. M &gt;= 0.</p>
</td></tr>
<tr><td><code id="dgesdd_+3A_n">N</code></td>
<td>
<p>an integer. The number of columns of the input matrix A. N &gt;= 0.</p>
</td></tr>
<tr><td><code id="dgesdd_+3A_a">A</code></td>
<td>
<p>the M-by-N matrix A.</p>
</td></tr>
<tr><td><code id="dgesdd_+3A_lda">LDA</code></td>
<td>
<p>an integer. The leading dimension of the matrix A.  LDA &gt;= max(1,M).</p>
</td></tr>
<tr><td><code id="dgesdd_+3A_s">S</code></td>
<td>
<p>a matrix of dimension (min(M,N)). The singular values of A, sorted so that S(i) &gt;= S(i+1).</p>
</td></tr>
<tr><td><code id="dgesdd_+3A_u">U</code></td>
<td>
<p>U is a matrx of dimension (LDU,UCOL)
</p>

<dl>
<dt>UCOL = M if</dt><dd><p> JOBZ = 'A' or JOBZ = 'O' and M &lt; N; UCOL = min(M,N) if JOBZ = 'S'.</p>
</dd>
<dt>If</dt><dd><p> JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M orthogonal matrix U;</p>
</dd>
<dt>if</dt><dd><p> JOBZ = 'S', U contains the first min(M,N) columns of U (the left singular vectors, stored columnwise);</p>
</dd>
<dt>if</dt><dd><p> JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgesdd_+3A_ldu">LDU</code></td>
<td>
<p>an integer. The leading dimension of the matrix U.  LDU &gt;= 1; if JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.</p>
</td></tr>
<tr><td><code id="dgesdd_+3A_vt">VT</code></td>
<td>
<p>VT is matrix of dimension (LDVT,N)
</p>

<dl>
<dt>If</dt><dd><p> JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the N-by-N orthogonal matrix V**T;</p>
</dd>
<dt>if</dt><dd><p> JOBZ = 'S', VT contains the first min(M,N) rows of V**T (the right singular vectors, stored rowwise);</p>
</dd>
<dt>if</dt><dd><p> JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dgesdd_+3A_ldvt">LDVT</code></td>
<td>
<p>an integer. The leading dimension of the matrix VT.  LDVT &gt;= 1; if JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N; if JOBZ = 'S', LDVT &gt;= min(M,N).</p>
</td></tr>
<tr><td><code id="dgesdd_+3A_work">WORK</code></td>
<td>
<p>a matrix of dimension (MAX(1,LWORK))</p>
</td></tr>
<tr><td><code id="dgesdd_+3A_lwork">LWORK</code></td>
<td>
<p>an integer. The dimension of the array WORK. LWORK &gt;= 1.
If LWORK = -1, a workspace query is assumed.  The optimal
size for the WORK array is calculated and stored in WORK(1),
and no other work except argument checking is performed.
</p>
<p>Let mx = max(M,N) and mn = min(M,N).
</p>

<dl>
<dt>If</dt><dd><p> JOBZ = 'N', LWORK &gt;= 3*mn + max( mx, 7*mn ).</p>
</dd>
<dt>If</dt><dd><p> JOBZ = 'O', LWORK &gt;= 3*mn + max( mx, 5*mn*mn + 4*mn ).</p>
</dd>
<dt>If</dt><dd><p> JOBZ = 'S', LWORK &gt;= 4*mn*mn + 7*mn.</p>
</dd>
<dt>If</dt><dd><p> JOBZ = 'A', LWORK &gt;= 4*mn*mn + 6*mn + mx.</p>
</dd>
</dl>

<p>These are not tight minimums in all cases; see comments inside code.
For good performance, LWORK should generally be larger;
a query is recommended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IWORK an integer matrix dimension of (8*min(M,N))
A is updated.
</p>

<dl>
<dt>if</dt><dd><p> JOBZ = 'O',  A is overwritten with the first N columns of U (the left singular vectors, stored columnwise) if M &gt;= N; A is overwritten with the first M rows of V**T (the right singular vectors, stored rowwise) otherwise.</p>
</dd>
<dt>if</dt><dd><p> JOBZ .ne. 'O', the contents of A are destroyed.</p>
</dd>
</dl>

<p>INFO an integer
</p>

<dl>
<dt>= 0:</dt><dd><p> successful exit.</p>
</dd>
<dt>&lt; 0:</dt><dd><p> if INFO = -i, the i-th argument had an illegal value.</p>
</dd>
<dt>&gt; 0:</dt><dd><p> DBDSDC did not converge, updating process failed.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(4669)
A = matrix(rnorm(12),4,3)
S = matrix(0,nrow=3,ncol=1)
U = matrix(0,nrow=4,ncol=4)
VT = matrix(0,ncol=3,nrow=3)
dgesdd(A=A,S=S,U=U,VT=VT)
S
U
VT

rm(A,S,U,VT)

A = as.big.matrix(matrix(rnorm(12),4,3))
S = as.big.matrix(matrix(0,nrow=3,ncol=1))
U = as.big.matrix(matrix(0,nrow=4,ncol=4))
VT = as.big.matrix(matrix(0,ncol=3,nrow=3))
dgesdd(A=A,S=S,U=U,VT=VT)
S[,]
U[,]
VT[,]

rm(A,S,U,VT)
gc()

## End(Not run)
</code></pre>

<hr>
<h2 id='dpotrf'>Cholesky factorization</h2><span id='topic+dpotrf'></span>

<h3>Description</h3>

<p>DPOTRF computes the Cholesky factorization of a real symmetric positive definite matrix A.
</p>
<p>The factorization has the form
</p>

<dl>
<dt>A =</dt><dd><p> U**T * U,  if UPLO = 'U', or</p>
</dd>
<dt>A =</dt><dd><p> L  * L**T,  if UPLO = 'L',</p>
</dd>
</dl>

<p>where U is an upper triangular matrix and L is lower triangular.
</p>
<p>This is the block version of the algorithm, calling Level 3 BLAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpotrf(UPLO = "U", N = NULL, A, LDA = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpotrf_+3A_uplo">UPLO</code></td>
<td>
<p>a character. 
</p>

<dl>
<dt>'U':</dt><dd><p> Upper triangle of A is stored;</p>
</dd>
<dt>'L':</dt><dd><p> Lower triangle of A is stored.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dpotrf_+3A_n">N</code></td>
<td>
<p>an integer. The order of the matrix A.  N &gt;= 0.</p>
</td></tr>
<tr><td><code id="dpotrf_+3A_a">A</code></td>
<td>
<p>a big.matrix, dimension (LDA,N).</p>
</td></tr>
<tr><td><code id="dpotrf_+3A_lda">LDA</code></td>
<td>
<p>an integer. Dimension of the array A.  LDA &gt;= max(1,N).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updates the big matrix A with the result, INFO is an integer 
</p>

<dl>
<dt>= 0:</dt><dd><p> successful exit</p>
</dd>
<dt>&lt; 0:</dt><dd><p> if INFO = -i, the i-th argument had an illegal value</p>
</dd>
<dt>&gt; 0:</dt><dd><p> if INFO = i, the leading minor of order i is not positive definite, and the factorization could not be completed.</p>
</dd>
</dl>

<p>Terms laying out of the computed triangle should be discarded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4669)
A = matrix(rnorm(16),4)
B = as.big.matrix(A %*% t(A))
C = A %*% t(A)
chol(C)
dpotrf(UPLO='U', N=4, A=B, LDA=4)
D &lt;- B[,]
D[lower.tri(D)]&lt;-0
D
D-chol(C)
t(D)%*%D-C

#' # The big.matrix file backings will be deleted when garbage collected.
rm(A,B,C,D)
gc()
</code></pre>

<hr>
<h2 id='dscal'>Scales a vector by a constant.</h2><span id='topic+dscal'></span>

<h3>Description</h3>

<p>Scales a vector by a constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dscal(N = NULL, ALPHA, Y, INCY = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dscal_+3A_n">N</code></td>
<td>
<p>an integer. Number of elements in input vector(s)</p>
</td></tr>
<tr><td><code id="dscal_+3A_alpha">ALPHA</code></td>
<td>
<p>a real number. The scalar alpha</p>
</td></tr>
<tr><td><code id="dscal_+3A_y">Y</code></td>
<td>
<p>a big matrix to scale by ALPHA</p>
</td></tr>
<tr><td><code id="dscal_+3A_incy">INCY</code></td>
<td>
<p>an integer. Storage spacing between elements of Y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Update Y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(4669)
A = big.matrix(3, 2, type="double", init=1, dimnames=list(NULL, 
c("alpha", "beta")), shared=FALSE)
dscal(ALPHA=2,Y=A)
A[,]

# The big.matrix file backings will be deleted when garbage collected.
rm(A)
gc()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
