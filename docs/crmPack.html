<!DOCTYPE html><html><head><title>Help for package crmPack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crmPack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crmPack-package'><p>Object-oriented implementation of CRM designs</p></a></li>
<li><a href='#&amp;,Stopping,Stopping-method'><p>The method combining two atomic stopping rules</p></a></li>
<li><a href='#&amp;,Stopping,StoppingAll-method'><p>The method combining an atomic and a stopping list</p></a></li>
<li><a href='#&amp;,StoppingAll,Stopping-method'><p>The method combining a stopping list and an atomic</p></a></li>
<li><a href='#AllModels-class'><p>Class for All models</p>
This is a class where all models inherit.</a></li>
<li><a href='#approximate'><p>Approximate posterior with (log) normal distribution</p></a></li>
<li><a href='#as.list,GeneralData-method'><p>as.list method for the &quot;GeneralData&quot; class</p></a></li>
<li><a href='#biomLevel'><p>Compute the biomarker level for a given dose, given model and samples</p></a></li>
<li><a href='#CohortSize-class'><p>The virtual class for cohort sizes</p></a></li>
<li><a href='#CohortSizeConst'><p>Initialization function for &quot;CohortSizeConst&quot;</p></a></li>
<li><a href='#CohortSizeConst-class'><p>Constant cohort size</p></a></li>
<li><a href='#CohortSizeDLT'><p>Initialization function for &quot;CohortSizeDLT&quot;</p></a></li>
<li><a href='#CohortSizeDLT-class'><p>Cohort size based on number of DLTs</p></a></li>
<li><a href='#CohortSizeMax'><p>Initialization function for &quot;CohortSizeMax&quot;</p></a></li>
<li><a href='#CohortSizeMax-class'><p>Size based on maximum of multiple cohort size rules</p></a></li>
<li><a href='#CohortSizeMin'><p>Initialization function for &quot;CohortSizeMin&quot;</p></a></li>
<li><a href='#CohortSizeMin-class'><p>Size based on minimum of multiple cohort size rules</p></a></li>
<li><a href='#CohortSizeParts'><p>Initialization function for &quot;CohortSizeParts&quot;</p></a></li>
<li><a href='#CohortSizeParts-class'><p>Cohort size based on the parts</p></a></li>
<li><a href='#CohortSizeRange'><p>Initialization function for &quot;CohortSizeRange&quot;</p></a></li>
<li><a href='#CohortSizeRange-class'><p>Cohort size based on dose range</p></a></li>
<li><a href='#crmPackExample'><p>Open the example pdf for crmPack</p></a></li>
<li><a href='#crmPackHelp'><p>Open the browser with help pages for crmPack</p></a></li>
<li><a href='#Data'><p>Initialization function for the &quot;Data&quot; class</p></a></li>
<li><a href='#Data-class'><p>Class for the data input</p></a></li>
<li><a href='#DataDual'><p>Initialization function for the &quot;DataDual&quot; class</p></a></li>
<li><a href='#DataDual-class'><p>Class for the dual endpoint data input</p></a></li>
<li><a href='#DataMixture'><p>Initialization function for the &quot;DataMixture&quot; class</p></a></li>
<li><a href='#DataMixture-class'><p>Class for the data with mixture sharing</p></a></li>
<li><a href='#DataParts'><p>Initialization function for the &quot;DataParts&quot; class</p></a></li>
<li><a href='#DataParts-class'><p>Class for the data with two study parts</p></a></li>
<li><a href='#Design'><p>Initialization function for &quot;Design&quot;</p></a></li>
<li><a href='#Design-class'><p>Class for the CRM design</p></a></li>
<li><a href='#dinvGamma'><p>Compute the density of Inverse gamma distribution</p></a></li>
<li><a href='#dose'><p>Compute the doses for a given probability, given model and samples</p></a></li>
<li><a href='#DualDesign'><p>Initialization function for &quot;DualDesign&quot;</p></a></li>
<li><a href='#DualDesign-class'><p>Class for the dual-endpoint CRM design</p></a></li>
<li><a href='#DualEndpoint'><p>Initialization function for the &quot;DualEndpoint&quot; class</p></a></li>
<li><a href='#DualEndpoint-class'><p>General class for the dual endpoint model</p></a></li>
<li><a href='#DualEndpointBeta'><p>Initialization function for the &quot;DualEndpointBeta&quot; class</p></a></li>
<li><a href='#DualEndpointBeta-class'><p>Dual endpoint model with beta function for dose-biomarker relationship</p></a></li>
<li><a href='#DualEndpointEmax'><p>Initialization function for the &quot;DualEndpointEmax&quot; class</p></a></li>
<li><a href='#DualEndpointEmax-class'><p>Dual endpoint model with emax function for dose-biomarker relationship</p></a></li>
<li><a href='#DualEndpointOld-class'><p>Dual endpoint model</p></a></li>
<li><a href='#DualEndpointRW'><p>Initialization function for the &quot;DualEndpointRW&quot; class</p></a></li>
<li><a href='#DualEndpointRW-class'><p>Dual endpoint model with RW prior for biomarker</p></a></li>
<li><a href='#DualResponsesDesign'><p>Initialization function for 'DualResponsesDesign&quot;</p></a></li>
<li><a href='#DualResponsesDesign-class'><p>This is a class of design based on DLE responses using the <code>LogisticIndepBeta</code> model</p>
model and efficacy responses using <code>ModelEff</code>  model class
without DLE and efficacy samples. It contain all slots in
<code>RuleDesign</code> and <code>TDDesign</code> class object</a></li>
<li><a href='#DualResponsesSamplesDesign'><p>Initialization function for 'DualResponsesSamplesDesign&quot;</p></a></li>
<li><a href='#DualResponsesSamplesDesign-class'><p>This is a class of design based on DLE responses using the <code>LogisticIndepBeta</code> model</p>
model and efficacy responses using <code>ModelEff</code>  model class
with DLE and efficacy samples.It contain all slots in
<code>RuleDesign</code> and <code>TDsamplesDesign</code> class object</a></li>
<li><a href='#DualSimulations'><p>Initialization function for &quot;DualSimulations&quot;</p></a></li>
<li><a href='#DualSimulations-class'><p>Class for the simulations output from dual-endpoint model based designs</p></a></li>
<li><a href='#DualSimulationsSummary-class'><p>Class for the summary of dual-endpoint simulations output</p></a></li>
<li><a href='#EffFlexi'><p>Initialization function for the &quot;EffFlexi&quot; class</p></a></li>
<li><a href='#EffFlexi-class'><p>Class for the efficacy model in flexible form for prior expressed in form of pseudo data</p></a></li>
<li><a href='#Effloglog'><p>Initialization function for the &quot;Effloglog&quot; class</p></a></li>
<li><a href='#Effloglog-class'><p>Class for the linear log-log efficacy model using pseudo data prior</p></a></li>
<li><a href='#examine'><p>Obtain hypothetical trial course table for a design</p></a></li>
<li><a href='#ExpEff'><p>Compute the expected efficacy based on a given dose, a given pseudo Efficacy log-log model and a given</p>
efficacy sample</a></li>
<li><a href='#fit'><p>Fit method for the Samples class</p></a></li>
<li><a href='#fitGain'><p>Get the fiited values for the gain values at all dose levels based on</p>
a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample
and data. This method returns a data frame with dose, middle, lower and upper quantiles
of the gain value samples</a></li>
<li><a href='#gain'><p>Compute the gain value with a given dose level, given a pseudo DLE model, a DLE sample,</p>
a pseudo Efficacy log-log model and a Efficacy sample</a></li>
<li><a href='#GeneralData-class'><p>Class for general data input</p></a></li>
<li><a href='#GeneralModel-class'><p>No Intitialization function for this</p>
General class for model input</a></li>
<li><a href='#GeneralSimulations'><p>Initialization function for &quot;GeneralSimulations&quot;</p></a></li>
<li><a href='#GeneralSimulations-class'><p>General class for the simulations output</p></a></li>
<li><a href='#GeneralSimulationsSummary-class'><p>Class for the summary of general simulations output</p></a></li>
<li><a href='#get,Samples,character-method'><p>Get specific parameter samples and produce a data.frame</p></a></li>
<li><a href='#getEff'><p>Extracting efficacy responses for subjects without or with a DLE. This is a class where we separate</p>
efficacy responses with or without a DLE. It outputs the efficacy responses and their corresponding
dose levels treated at in two categories (with or without DLE)</a></li>
<li><a href='#getMinInfBeta'><p>Get the minimal informative unimodal beta distribution</p></a></li>
<li><a href='#getResultList'><p>Helper function to obtain simulation results list</p></a></li>
<li><a href='#IncrementMin'><p>Initialization function for &quot;IncrementMin&quot;</p></a></li>
<li><a href='#IncrementMin-class'><p>Max increment based on minimum of multiple increment rules</p></a></li>
<li><a href='#Increments-class'><p>The virtual class for controlling increments</p></a></li>
<li><a href='#IncrementsNumDoseLevels'><p>Initialization function for &quot;IncrementsNumDoseLevels&quot;</p></a></li>
<li><a href='#IncrementsNumDoseLevels-class'><p>Increments control based on number of dose levels</p></a></li>
<li><a href='#IncrementsRelative'><p>Initialization function for &quot;IncrementsRelative&quot;</p></a></li>
<li><a href='#IncrementsRelative-class'><p>Increments control based on relative differences in intervals</p></a></li>
<li><a href='#IncrementsRelativeDLT'><p>Initialization function for &quot;IncrementsRelativeDLT&quot;</p></a></li>
<li><a href='#IncrementsRelativeDLT-class'><p>Increments control based on relative differences in terms of DLTs</p></a></li>
<li><a href='#IncrementsRelativeParts'><p>Initialization function for &quot;IncrementsRelativeParts&quot;</p></a></li>
<li><a href='#IncrementsRelativeParts-class'><p>Increments control based on relative differences in intervals,</p>
with special rules for part 1 and beginning of part 2</a></li>
<li><a href='#initialize,DualEndpointOld-method'><p>Initialization method for the &quot;DualEndpointOld&quot; class</p></a></li>
<li><a href='#is.bool'><p>Predicate checking for a boolean option</p></a></li>
<li><a href='#is.probability'><p>Predicate checking for a probability</p></a></li>
<li><a href='#is.probRange'><p>Predicate checking for a probability range</p></a></li>
<li><a href='#is.range'><p>Predicate checking for a numeric range</p></a></li>
<li><a href='#is.scalar'><p>Checking for scalar</p></a></li>
<li><a href='#is.wholenumber'><p>checks for whole numbers (integers)</p></a></li>
<li><a href='#joinBodies'><p>Helper function to join two function bodies</p></a></li>
<li><a href='#joinModels'><p>Helper function to join two BUGS models</p></a></li>
<li><a href='#LogisticIndepBeta'><p>Intialization function for &quot;LogisticIndepBeta&quot; class</p></a></li>
<li><a href='#LogisticIndepBeta-class'><p>No initialization function</p>
Standard logistic model with prior in form of pseudo data</a></li>
<li><a href='#LogisticKadane'><p>Initialization function for the &quot;LogisticKadane&quot; class</p></a></li>
<li><a href='#LogisticKadane-class'><p>Reparametrized logistic model</p></a></li>
<li><a href='#LogisticLogNormal'><p>Initialization function for the &quot;LogisticLogNormal&quot; class</p></a></li>
<li><a href='#LogisticLogNormal-class'><p>Standard logistic model with bivariate (log) normal prior</p></a></li>
<li><a href='#LogisticLogNormalMixture'><p>Initialization function for the &quot;LogisticLogNormalMixture&quot; class</p></a></li>
<li><a href='#LogisticLogNormalMixture-class'><p>Standard logistic model with online mixture of two bivariate log normal priors</p></a></li>
<li><a href='#LogisticLogNormalSub'><p>Initialization function for the &quot;LogisticLogNormalSub&quot; class</p></a></li>
<li><a href='#LogisticLogNormalSub-class'><p>Standard logistic model with bivariate (log) normal prior with substractive</p>
dose standardization</a></li>
<li><a href='#LogisticNormal'><p>Initialization function for the &quot;LogisticNormal&quot; class</p></a></li>
<li><a href='#LogisticNormal-class'><p>Standard logistic model with bivariate normal prior</p></a></li>
<li><a href='#LogisticNormalFixedMixture'><p>Initialization function for the &quot;LogisticNormalFixedMixture&quot; class</p></a></li>
<li><a href='#LogisticNormalFixedMixture-class'><p>Standard logistic model with fixed mixture of multiple bivariate (log) normal priors</p></a></li>
<li><a href='#LogisticNormalMixture'><p>Initialization function for the &quot;LogisticNormalMixture&quot; class</p></a></li>
<li><a href='#LogisticNormalMixture-class'><p>Standard logistic model with flexible mixture of two bivariate normal priors</p></a></li>
<li><a href='#logit'><p>Shorthand for logit function</p></a></li>
<li><a href='#matchTolerance'><p>Helper function for value matching with tolerance</p></a></li>
<li><a href='#maxDose'><p>Determine the maximum possible next dose</p></a></li>
<li><a href='#maxSize'><p>&quot;MAX&quot; combination of cohort size rules</p></a></li>
<li><a href='#mcmc'><p>Obtain posterior samples for all model parameters</p></a></li>
<li><a href='#McmcOptions'><p>Initialization function for the &quot;McmcOptions&quot; class</p></a></li>
<li><a href='#McmcOptions-class'><p>Class for the three canonical MCMC options</p></a></li>
<li><a href='#MinimalInformative'><p>Construct a minimally informative prior</p></a></li>
<li><a href='#minSize'><p>&quot;MIN&quot; combination of cohort size rules</p></a></li>
<li><a href='#Model-class'><p>Class for the model input</p></a></li>
<li><a href='#ModelEff-class'><p>No Initialization function</p>
class for Efficacy models using pseudo data prior</a></li>
<li><a href='#ModelPseudo-class'><p>Class of models using expressing their prior in form of Pseudo data</p></a></li>
<li><a href='#ModelTox-class'><p>No intialization function</p>
Class for DLE models using pseudo data prior.
This is a class of DLE (dose-limiting events) models/ toxicity model which contains all DLE models
for which their prior are specified in form of pseudo data (as if there is some data before
the trial starts). It inherits all slots from <code>ModelPseudo</code></a></li>
<li><a href='#multiplot'><p>Multiple plot function</p></a></li>
<li><a href='#myBarplot'><p>Convenience function to make barplots of percentages</p></a></li>
<li><a href='#myBayesLogit'><p>Do MCMC sampling for Bayesian logistic regression model</p></a></li>
<li><a href='#nextBest'><p>Find the next best dose</p></a></li>
<li><a href='#NextBest-class'><p>The virtual class for finding next best dose</p></a></li>
<li><a href='#NextBestDualEndpoint'><p>Initialization function for &quot;NextBestDualEndpoint&quot;</p></a></li>
<li><a href='#NextBestDualEndpoint-class'><p>The class with the input for finding the next dose</p>
based on the dual endpoint model</a></li>
<li><a href='#NextBestMaxGain'><p>Initialization function for the class 'NextBestMaxGain'</p></a></li>
<li><a href='#NextBestMaxGain-class'><p>Next best dose with maximum gain value based on a pseudo DLE and efficacy model without samples</p></a></li>
<li><a href='#NextBestMaxGainSamples'><p>Initialization function for class &quot;NextBestMaxGainSamples&quot;</p></a></li>
<li><a href='#NextBestMaxGainSamples-class'><p>Next best dose with maximum gain value based on a pseudo DLE and efficacy model with samples</p></a></li>
<li><a href='#NextBestMTD'><p>Initialization function for class &quot;NextBestMTD&quot;</p></a></li>
<li><a href='#NextBestMTD-class'><p>The class with the input for finding the next best MTD estimate</p></a></li>
<li><a href='#NextBestNCRM'><p>Initialization function for &quot;NextBestNCRM&quot;</p></a></li>
<li><a href='#NextBestNCRM-class'><p>The class with the input for finding the next dose in target interval</p></a></li>
<li><a href='#NextBestTD'><p>Initialization function for the class &quot;NextBestTD&quot;</p></a></li>
<li><a href='#NextBestTD-class'><p>Next best dose based on Pseudo DLE model without sample</p></a></li>
<li><a href='#NextBestTDsamples'><p>Initialization function for class &quot;NextBestTDsamples&quot;</p></a></li>
<li><a href='#NextBestTDsamples-class'><p>Next best dose based on Pseudo DLE Model with samples</p></a></li>
<li><a href='#NextBestThreePlusThree'><p>Initialization function for &quot;NextBestThreePlusThree&quot;</p></a></li>
<li><a href='#NextBestThreePlusThree-class'><p>The class with the input for finding the next dose in target interval</p></a></li>
<li><a href='#noOverlap'><p>Check overlap of two character vectors</p></a></li>
<li><a href='#or-Stopping-Stopping'><p>The method combining two atomic stopping rules</p></a></li>
<li><a href='#or-Stopping-StoppingAny'><p>The method combining a stopping list and an atomic</p></a></li>
<li><a href='#or-StoppingAny-Stopping'><p>The method combining an atomic and a stopping list</p></a></li>
<li><a href='#pinvGamma'><p>Compute the distribution function of Inverse gamma distribution</p></a></li>
<li><a href='#plot,Data,missing-method'><p>Plot method for the &quot;Data&quot; class</p></a></li>
<li><a href='#plot,Data,ModelTox-method'><p>Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples</p></a></li>
<li><a href='#plot,DataDual,missing-method'><p>Plot method for the &quot;DataDual&quot; class</p></a></li>
<li><a href='#plot,DataDual,ModelEff-method'><p>Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples</p></a></li>
<li><a href='#plot,DualSimulations,missing-method'><p>Plot dual-endpoint simulations</p></a></li>
<li><a href='#plot,DualSimulationsSummary,missing-method'><p>Plot summaries of the dual-endpoint design simulations</p></a></li>
<li><a href='#plot,GeneralSimulations,missing-method'><p>Plot simulations</p></a></li>
<li><a href='#plot,GeneralSimulationsSummary,missing-method'><p>Graphical display of the general simulation summary</p></a></li>
<li><a href='#plot,PseudoDualFlexiSimulations,missing-method'><p>Plot for PseudoDualFlexiSimulations</p></a></li>
<li><a href='#plot,PseudoDualSimulations,missing-method'><p>Plot simulations</p></a></li>
<li><a href='#plot,PseudoDualSimulationsSummary,missing-method'><p>Plot the summary of Pseudo Dual Simulations summary</p></a></li>
<li><a href='#plot,PseudoSimulationsSummary,missing-method'><p>Plot summaries of the pseudo simulations</p></a></li>
<li><a href='#plot,Samples,DualEndpoint-method'><p>Plotting dose-toxicity and dose-biomarker model fits</p></a></li>
<li><a href='#plot,Samples,Model-method'><p>Plotting dose-toxicity model fits</p></a></li>
<li><a href='#plot,Samples,ModelEff-method'><p>Plot the fitted dose-effcacy curve using a model from <code>ModelEff</code> class</p>
with samples</a></li>
<li><a href='#plot,Samples,ModelTox-method'><p>Plot the fitted dose-DLE curve using a <code>ModelTox</code> class model with samples</p></a></li>
<li><a href='#plot,SimulationsSummary,missing-method'><p>Plot summaries of the model-based design simulations</p></a></li>
<li><a href='#plot.gtable'><p>Plots gtable objects</p></a></li>
<li><a href='#plotDualResponses'><p>Plot of the DLE and efficacy curve side by side given a DLE pseudo model,</p>
a DLE sample, an efficacy pseudo model and a given efficacy sample</a></li>
<li><a href='#plotGain'><p>Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,</p>
a DLE sample, a given efficacy pseudo model and an efficacy sample</a></li>
<li><a href='#printVignette'><p>Taken from utils package (print.vignette)</p></a></li>
<li><a href='#prob'><p>Compute the probability for a given dose, given model and samples</p></a></li>
<li><a href='#probit'><p>Shorthand for probit function</p></a></li>
<li><a href='#ProbitLogNormal'><p>Initialization function for the &quot;ProbitLogNormal&quot; class</p></a></li>
<li><a href='#ProbitLogNormal-class'><p>Probit model with bivariate log normal prior</p></a></li>
<li><a href='#PseudoDualFlexiSimulations'><p>Initialization function for 'PseudoDualFlexiSimulations' class</p></a></li>
<li><a href='#PseudoDualFlexiSimulations-class'><p>This is a class which captures the trial simulations design using both the</p>
DLE and efficacy responses. The design of model from <code>ModelTox</code>
class and the efficacy model from <code>EffFlexi</code> class
It contains all slots from
<code>GeneralSimulations</code>, <code>PseudoSimulations</code>
and <code>PseudoDualSimulations</code> object.
In comparison to the parent class <code>PseudoDualSimulations</code>,
it contains additional slots to
capture the sigma2betaW estimates.</a></li>
<li><a href='#PseudoDualSimulations'><p>Initialization function for 'DualPseudoSimulations' class</p></a></li>
<li><a href='#PseudoDualSimulations-class'><p>This is a class which captures the trial simulations design using both the</p>
DLE and efficacy responses. The design of model from <code>ModelTox</code>
class and the efficacy model from <code>ModelEff</code> class
(except <code>EffFlexi</code> class). It contains all slots from
<code>GeneralSimulations</code> and <code>PseudoSimulations</code> object.
In comparison to the parent class <code>PseudoSimulations</code>,
it contains additional slots to
capture the dose-efficacy curve and the sigma2 estimates.</a></li>
<li><a href='#PseudoDualSimulationsSummary-class'><p>Class for the summary of the dual responses simulations using pseudo models</p></a></li>
<li><a href='#PseudoSimulations'><p>Initialization function of the 'PseudoSimulations' class</p></a></li>
<li><a href='#PseudoSimulations-class'><p>This is a class which captures the trial simulations from designs using</p>
pseudo model. The design for DLE only responses and model from <code>ModelTox</code>
class object. It contains all slots from <code>GeneralSimulations</code> object.
Additional slots fit and stopReasons compared to the general class
<code>GeneralSimulations</code>.</a></li>
<li><a href='#PseudoSimulationsSummary-class'><p>Class for the summary of pseudo-models simulations output</p></a></li>
<li><a href='#qinvGamma'><p>Compute the quantile function of Inverse gamma distribution</p></a></li>
<li><a href='#Quantiles2LogisticNormal'><p>Convert prior quantiles (lower, median, upper) to logistic (log)</p>
normal model</a></li>
<li><a href='#Report'><p>A Reference Class to represent sequentially updated reporting objects.</p></a></li>
<li><a href='#rinvGamma'><p>The random generation of the Inverse gamma distribution</p></a></li>
<li><a href='#RuleDesign'><p>Initialization function for &quot;RuleDesign&quot;</p></a></li>
<li><a href='#RuleDesign-class'><p>Class for rule-based designs</p></a></li>
<li><a href='#safeInteger'><p>Safe conversion to integer vector</p></a></li>
<li><a href='#Samples'><p>Initialization function for &quot;Samples&quot;</p></a></li>
<li><a href='#Samples-class'><p>Class for the MCMC output</p></a></li>
<li><a href='#sampleSize'><p>Compute the number of samples for a given MCMC options triple</p></a></li>
<li><a href='#saveSample'><p>Determine if we should save this sample</p></a></li>
<li><a href='#setSeed'><p>Helper function to set and save the RNG seed</p></a></li>
<li><a href='#show,DualSimulationsSummary-method'><p>Show the summary of the dual-endpoint simulations</p></a></li>
<li><a href='#show,GeneralSimulationsSummary-method'><p>Show the summary of the simulations</p></a></li>
<li><a href='#show,PseudoDualSimulationsSummary-method'><p>Show the summary of Pseudo Dual simulations summary</p></a></li>
<li><a href='#show,PseudoSimulationsSummary-method'><p>Show the summary of the simulations</p></a></li>
<li><a href='#show,SimulationsSummary-method'><p>Show the summary of the simulations</p></a></li>
<li><a href='#simulate,Design-method'><p>Simulate outcomes from a CRM design</p></a></li>
<li><a href='#simulate,DualDesign-method'><p>Simulate outcomes from a dual-endpoint design</p></a></li>
<li><a href='#simulate,DualResponsesDesign-method'><p>This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.</p>
This is a method based on the <code>DualResponsesDesign</code> where DLEmodel used are of
<code>ModelTox</code> class object and efficacy model used are of <code>ModelEff</code>
class object. In addition, no DLE and efficacy samples are involved or generated in the simulation
process</a></li>
<li><a href='#simulate,DualResponsesSamplesDesign-method'><p>This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.</p>
This is a method based on the <code>DualResponsesSamplesDesign</code> where DLEmodel
used are of
<code>ModelTox</code> class object and efficacy model used are of
<code>ModelEff</code>
class object (special case is <code>EffFlexi</code> class model object).
In addition, DLE and efficacy samples are involved or generated in the simulation
process</a></li>
<li><a href='#simulate,RuleDesign-method'><p>Simulate outcomes from a rule-based design</p></a></li>
<li><a href='#simulate,TDDesign-method'><p>This is a methods to simulate dose escalation procedure only using the DLE responses.</p>
This is a method based on the <code>TDDesign</code> where model used are of
<code>ModelTox</code> class object and no samples are involved.</a></li>
<li><a href='#simulate,TDsamplesDesign-method'><p>This is a methods to simulate dose escalation procedure only using the DLE responses.</p>
This is a method based on the <code>TDsamplesDesign</code> where model used are of
<code>ModelTox</code> class object DLE samples are also used</a></li>
<li><a href='#Simulations'><p>Initialization function for the &quot;Simulations&quot; class</p></a></li>
<li><a href='#Simulations-class'><p>Class for the simulations output from model based designs</p></a></li>
<li><a href='#SimulationsSummary-class'><p>Class for the summary of model-based simulations output</p></a></li>
<li><a href='#size'><p>Determine the size of the next cohort</p></a></li>
<li><a href='#Stopping-class'><p>The virtual class for stopping rules</p></a></li>
<li><a href='#StoppingAll'><p>Initialization function for &quot;StoppingAll&quot;</p></a></li>
<li><a href='#StoppingAll-class'><p>Stop based on fullfillment of all multiple stopping rules</p></a></li>
<li><a href='#StoppingAny'><p>Initialization function for &quot;StoppingAny&quot;</p></a></li>
<li><a href='#StoppingAny-class'><p>Stop based on fullfillment of any stopping rule</p></a></li>
<li><a href='#StoppingCohortsNearDose'><p>Initialization function for &quot;StoppingCohortsNearDose&quot;</p></a></li>
<li><a href='#StoppingCohortsNearDose-class'><p>Stop based on number of cohorts near to next best dose</p></a></li>
<li><a href='#StoppingGstarCIRatio'><p>Initialization function for &quot;StoppingGstarCIRatio&quot;</p></a></li>
<li><a href='#StoppingGstarCIRatio-class'><p>Stop based on a target ratio, the ratio of the upper to the lower</p>
95% credibility interval of the estimate of the minimum of the dose which gives the maximum gain (Gstar) and
the TD end of trial, the dose with probability of DLE equals to the target
probability of DLE used at the end of a trial.</a></li>
<li><a href='#StoppingHighestDose'><p>Initialization function for &quot;StoppingHighestDose&quot;</p></a></li>
<li><a href='#StoppingHighestDose-class'><p>Stop when the highest dose is reached</p></a></li>
<li><a href='#StoppingList'><p>Initialization function for &quot;StoppingList&quot;</p></a></li>
<li><a href='#StoppingList-class'><p>Stop based on multiple stopping rules</p></a></li>
<li><a href='#StoppingMinCohorts'><p>Initialization function for &quot;StoppingMinCohorts&quot;</p></a></li>
<li><a href='#StoppingMinCohorts-class'><p>Stop based on minimum number of cohorts</p></a></li>
<li><a href='#StoppingMinPatients'><p>Initialization function for &quot;StoppingMinPatients&quot;</p></a></li>
<li><a href='#StoppingMinPatients-class'><p>Stop based on minimum number of patients</p></a></li>
<li><a href='#StoppingMTDdistribution'><p>Initialization function for &quot;StoppingMTDdistribution&quot;</p></a></li>
<li><a href='#StoppingMTDdistribution-class'><p>Stop based on MTD distribution</p></a></li>
<li><a href='#StoppingPatientsNearDose'><p>Initialization function for &quot;StoppingPatientsNearDose&quot;</p></a></li>
<li><a href='#StoppingPatientsNearDose-class'><p>Stop based on number of patients near to next best dose</p></a></li>
<li><a href='#StoppingTargetBiomarker'><p>Initialization function for &quot;StoppingTargetBiomarker&quot;</p></a></li>
<li><a href='#StoppingTargetBiomarker-class'><p>Stop based on probability of target biomarker</p></a></li>
<li><a href='#StoppingTargetProb'><p>Initialization function for &quot;StoppingTargetProb&quot;</p></a></li>
<li><a href='#StoppingTargetProb-class'><p>Stop based on probability of target tox interval</p></a></li>
<li><a href='#StoppingTDCIRatio'><p>Initialization function for &quot;StoppingTDCIRatio&quot;</p></a></li>
<li><a href='#StoppingTDCIRatio-class'><p>Stop based on a target ratio, the ratio of the upper to the lower</p>
95% credibility interval of the estimate of TD end of trial, the dose with probability of DLE equals to the target
probability of DLE used at the end of a trial</a></li>
<li><a href='#stopTrial'><p>Stop the trial?</p></a></li>
<li><a href='#summary,DualSimulations-method'><p>Summarize the dual-endpoint design simulations, relative to given true</p>
dose-toxicity and dose-biomarker curves</a></li>
<li><a href='#summary,GeneralSimulations-method'><p>Summarize the simulations, relative to a given truth</p></a></li>
<li><a href='#summary,PseudoDualFlexiSimulations-method'><p>Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model.</p></a></li>
<li><a href='#summary,PseudoDualSimulations-method'><p>Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model</p>
(except the EffFlexi class model)</a></li>
<li><a href='#summary,PseudoSimulations-method'><p>Summarize the simulations, relative to a given truth</p></a></li>
<li><a href='#summary,Simulations-method'><p>Summarize the model-based design simulations, relative to a given truth</p></a></li>
<li><a href='#TDDesign'><p>Initialization function for 'TDDesign' class</p></a></li>
<li><a href='#TDDesign-class'><p>Design class using DLE responses only based on the pseudo DLE model without sample</p></a></li>
<li><a href='#TDsamplesDesign'><p>Initialization function for 'TDsamplesDesign' class</p></a></li>
<li><a href='#TDsamplesDesign-class'><p>This is a class of design based only on DLE responses using the 'LogisticIndepBeta' class model</p>
and DLE samples are also used.
In addition to the slots in the more simple <code>RuleDesign</code>,
objects of this class contain:</a></li>
<li><a href='#ThreePlusThreeDesign'><p>Creates a new 3+3 design object from a dose grid</p></a></li>
<li><a href='#update,Data-method'><p>Update method for the &quot;Data&quot; class</p></a></li>
<li><a href='#update,DataDual-method'><p>Update method for the &quot;DataDual&quot; class</p></a></li>
<li><a href='#update,DataParts-method'><p>Update method for the &quot;DataParts&quot; class</p></a></li>
<li><a href='#update,EffFlexi-method'><p>Update method for the 'EffFlexi' Model class. This is a method to update</p>
estimates both for the flexible form model and the random walk model (see details in
<code>EffFlexi</code> class object) when new data
or new observations of responses are available and added in.</a></li>
<li><a href='#update,Effloglog-method'><p>Update method for the 'Effloglog' Model class. This is a method to update the modal</p>
estimates of the model parameters <code class="reqn">\theta_1</code> (theta1), <code class="reqn">\theta_2</code> (theta2)  and <code class="reqn">\nu</code>
(nu, the precision of the efficacy responses) when new data
or new observations of responses are available and added in.</a></li>
<li><a href='#update,LogisticIndepBeta-method'><p>Update method for the 'LogisticIndepBeta'Model class. This is a method to update the modal</p>
estimates of the model parameters <code class="reqn">\phi_1</code> (phi1) and <code class="reqn">\phi_2</code> (phi2) when new data
or new observations of responses are available and added in.</a></li>
<li><a href='#Validate'><p>A Reference Class to help programming validation for new S4 classes</p></a></li>
<li><a href='#writeModel'><p>Creating a WinBUGS model file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Object-Oriented Implementation of CRM Designs</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a wide range of model-based dose
    escalation designs, ranging from classical and modern continual
    reassessment methods (CRMs) based on dose-limiting toxicity endpoints to
    dual-endpoint designs taking into account a biomarker/efficacy outcome. The
    focus is on Bayesian inference, making it very easy to setup a new design
    with its own JAGS code. However, it is also possible to implement 3+3
    designs for comparison or models with non-Bayesian estimation. The whole
    package is written in a modular form in the S4 class system, making it very
    flexible for adaptation to new models, escalation or stopping rules.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Copyright:</td>
<td>F. Hoffmann-La Roche Ltd</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/roche/crmPack">https://github.com/roche/crmPack</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/roche/crmPack/issues">https://github.com/roche/crmPack/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), ggplot2 (&ge; 2.0.0), graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, grid, gridExtra, GenSA, mvtnorm, parallel, rjags,
utils, tools, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggmcmc, knitr, Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Collate:</td>
<td>'helpers.R' 'Data-class.R' 'Data-methods.R' 'Rules-class.R'
'Model-class.R' 'Design-class.R' 'writeModel.R'
'McmcOptions-methods.R' 'McmcOptions-class.R' 'Samples-class.R'
'mcmc.R' 'Simulations-class.R' 'Model-methods.R'
'Rules-methods.R' 'Design-methods.R' 'fromQuantiles.R'
'Samples-methods.R' 'Simulations-methods.R' 'crmPack-package.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Sabanes Bove [aut, cre],
  Wai Yin Yeung [aut],
  Giuseppe Palermo [aut],
  Thomas Jaki [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Sabanes Bove &lt;daniel.sabanes_bove@roche.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-04 20:38:10 UTC; sabanesd</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-04 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='crmPack-package'>Object-oriented implementation of CRM designs</h2><span id='topic+crmPack-package'></span><span id='topic+crmPack'></span>

<h3>Description</h3>

<p>Object-oriented implementation of CRM designs
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove <a href="mailto:daniel.sabanes_bove@roche.com">daniel.sabanes_bove@roche.com</a>,
Wai Yin Yeung <a href="mailto:winnie.yeung@roche.com">winnie.yeung@roche.com</a>,
Giuseppe Palermo <a href="mailto:giuseppe.palermo@roche.com">giuseppe.palermo@roche.com</a>,
Thomas Jaki <a href="mailto:jaki.thomas@gmail.com">jaki.thomas@gmail.com</a>
</p>


<h3>References</h3>

<p>Sabanes Bove D, Yeung WY, Palermo G, Jaki T (2019). 
&quot;Model-Based Dose Escalation Designs in R with crmPack.&quot;
Journal of Statistical Software, 89(10), 1-22. 
doi:10.18637/jss.v089.i10 (URL: http://doi.org/10.18637/jss.v089.i10).
</p>

<hr>
<h2 id='+26amp+3B+2CStopping+2CStopping-method'>The method combining two atomic stopping rules</h2><span id='topic++26+2CStopping+2CStopping-method'></span>

<h3>Description</h3>

<p>The method combining two atomic stopping rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Stopping,Stopping'
e1 &amp; e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B26amp+2B3B+2B2CStopping+2B2CStopping-method_+3A_e1">e1</code></td>
<td>
<p>First <code><a href="#topic+Stopping-class">Stopping</a></code> object</p>
</td></tr>
<tr><td><code id="+2B26amp+2B3B+2B2CStopping+2B2CStopping-method_+3A_e2">e2</code></td>
<td>
<p>Second <code><a href="#topic+Stopping-class">Stopping</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+StoppingAll-class">StoppingAll</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example of combining two atomic stopping rules with an AND ('&amp;') operator

myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)

myStopping &lt;- myStopping1 &amp; myStopping2 




</code></pre>

<hr>
<h2 id='+26amp+3B+2CStopping+2CStoppingAll-method'>The method combining an atomic and a stopping list</h2><span id='topic++26+2CStopping+2CStoppingAll-method'></span>

<h3>Description</h3>

<p>The method combining an atomic and a stopping list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Stopping,StoppingAll'
e1 &amp; e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B26amp+2B3B+2B2CStopping+2B2CStoppingAll-method_+3A_e1">e1</code></td>
<td>
<p><code><a href="#topic+Stopping-class">Stopping</a></code> object</p>
</td></tr>
<tr><td><code id="+2B26amp+2B3B+2B2CStopping+2B2CStoppingAll-method_+3A_e2">e2</code></td>
<td>
<p><code><a href="#topic+StoppingAll-class">StoppingAll</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <code><a href="#topic+StoppingAll-class">StoppingAll</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example of combining an atomic stopping rule with a list of stopping rules
## with an AND ('&amp;') operator

myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)

myStopping3 &lt;- StoppingMinPatients(nPatients=20)

myStopping &lt;-  myStopping3 &amp; (myStopping1 | myStopping2 ) 




</code></pre>

<hr>
<h2 id='+26amp+3B+2CStoppingAll+2CStopping-method'>The method combining a stopping list and an atomic</h2><span id='topic++26+2CStoppingAll+2CStopping-method'></span>

<h3>Description</h3>

<p>The method combining a stopping list and an atomic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'StoppingAll,Stopping'
e1 &amp; e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B26amp+2B3B+2B2CStoppingAll+2B2CStopping-method_+3A_e1">e1</code></td>
<td>
<p><code><a href="#topic+StoppingAll-class">StoppingAll</a></code> object</p>
</td></tr>
<tr><td><code id="+2B26amp+2B3B+2B2CStoppingAll+2B2CStopping-method_+3A_e2">e2</code></td>
<td>
<p><code><a href="#topic+Stopping-class">Stopping</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <code><a href="#topic+StoppingAll-class">StoppingAll</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example of combining a list of stopping rules with an atomic stopping rule
## with an AND ('&amp;') operator

myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)

myStopping3 &lt;- StoppingMinPatients(nPatients=20)

myStopping &lt;- (myStopping1 | myStopping2 ) &amp; myStopping3 




</code></pre>

<hr>
<h2 id='AllModels-class'>Class for All models
This is a class where all models inherit.</h2><span id='topic+AllModels-class'></span><span id='topic+.AllModels'></span>

<h3>Description</h3>

<p>Class for All models
This is a class where all models inherit.
</p>


<h3>Slots</h3>


<dl>
<dt><code>datanames</code></dt><dd><p>The names of all data slots that are used in all models. 
In particularly, those are also used in the <code>datamodel</code> and/or
<code>priormodel</code> definition for <code><a href="#topic+GeneralModel-class">GeneralModel</a></code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+GeneralModel-class">GeneralModel</a></code>, <code><a href="#topic+ModelPseudo-class">ModelPseudo</a></code>
</p>

<hr>
<h2 id='approximate'>Approximate posterior with (log) normal distribution</h2><span id='topic+approximate'></span><span id='topic+approximate+2CSamples-method'></span>

<h3>Description</h3>

<p>It is recommended to use <code><a href="base.html#topic+set.seed">set.seed</a></code> before, in order
to be able to reproduce the resulting approximating model exactly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approximate(object, model, data, ...)

## S4 method for signature 'Samples'
approximate(
  object,
  model,
  data,
  points = seq(from = min(data@doseGrid), to = max(data@doseGrid), length = 5L),
  refDose = median(points),
  logNormal = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approximate_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="approximate_+3A_model">model</code></td>
<td>
<p>the <code><a href="#topic+Model-class">Model</a></code> object</p>
</td></tr>
<tr><td><code id="approximate_+3A_data">data</code></td>
<td>
<p>the <code><a href="#topic+Data-class">Data</a></code> object</p>
</td></tr>
<tr><td><code id="approximate_+3A_...">...</code></td>
<td>
<p>additional arguments (see methods)</p>
</td></tr>
<tr><td><code id="approximate_+3A_points">points</code></td>
<td>
<p>optional parameter, which gives the dose values at which
the approximation should rely on (default: 5 values equally spaced from
minimum to maximum of the dose grid)</p>
</td></tr>
<tr><td><code id="approximate_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose to be used (default: median of
<code>points</code>)</p>
</td></tr>
<tr><td><code id="approximate_+3A_lognormal">logNormal</code></td>
<td>
<p>use the log-normal prior? (not default) otherwise, the
normal prior for the logistic regression coefficients is used</p>
</td></tr>
<tr><td><code id="approximate_+3A_verbose">verbose</code></td>
<td>
<p>be verbose (progress statements and plot)? (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the approximation model
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>approximate(Samples)</code>: Here the ... argument can transport additional arguments for
<code><a href="#topic+Quantiles2LogisticNormal">Quantiles2LogisticNormal</a></code>, e.g. in order to control the
approximation quality, etc.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data
data &lt;- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y = c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort = c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid = c(0.1, 0.5, 1.5, 3, 6,
                          seq(from = 10, to = 80, by=2)))

# Initialize a model 
model &lt;- LogisticLogNormal(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 56)

# Get posterior for all model parameters
options &lt;- McmcOptions(burnin = 100,
                       step = 2,
                       samples = 2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Approximate the posterior distribution with a bivariate normal
# max.time and maxit are very small only for the purpose of showing the example. They 
# should be increased for a real case.
set.seed(94)
posterior &lt;- approximate(object = samples,
                         model = model,
                         data = data,
                         logNormal=TRUE,
                         control = list(threshold.stop = 0.1,
                                        max.time = 1,
                                        maxit = 1))



</code></pre>

<hr>
<h2 id='as.list+2CGeneralData-method'>as.list method for the &quot;GeneralData&quot; class</h2><span id='topic+as.list+2CGeneralData-method'></span>

<h3>Description</h3>

<p>as.list method for the &quot;GeneralData&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeneralData'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list+2B2CGeneralData-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+GeneralData-class">GeneralData</a></code> object we want to convert</p>
</td></tr>
<tr><td><code id="as.list+2B2CGeneralData-method_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all slots in <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data of class 'Data'
myData &lt;- Data(x=c(0.1,0.5,1.5,3,6,10,10,10),
               y=c(0,0,0,0,0,0,1,0),
               doseGrid=c(0.1,0.5,1.5,3,6,
               seq(from=10,to=80,by=2)))

# Converting Data object to list
as.list(myData)
</code></pre>

<hr>
<h2 id='biomLevel'>Compute the biomarker level for a given dose, given model and samples</h2><span id='topic+biomLevel'></span><span id='topic+biomLevel+2Cnumeric+2CDualEndpoint+2CSamples-method'></span>

<h3>Description</h3>

<p>Compute the biomarker level for a given dose, given model and samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biomLevel(dose, model, samples, ...)

## S4 method for signature 'numeric,DualEndpoint,Samples'
biomLevel(dose, model, samples, xLevel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biomLevel_+3A_dose">dose</code></td>
<td>
<p>the dose</p>
</td></tr>
<tr><td><code id="biomLevel_+3A_model">model</code></td>
<td>
<p>the <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> object</p>
</td></tr>
<tr><td><code id="biomLevel_+3A_samples">samples</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="biomLevel_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="biomLevel_+3A_xlevel">xLevel</code></td>
<td>
<p>the grid index of <code>dose</code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>biomLevel(dose = numeric, model = DualEndpoint, samples = Samples)</code>: Here it is very easy, we just return the corresponding
column (index <code>xLevel</code>) of the biomarker samples matrix, since we save
that in the samples
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create the data
data &lt;- DataDual(
  x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,
      20, 20, 20, 40, 40, 40, 50, 50, 50),
  y=c(0, 0, 0, 0, 0, 0, 1, 0,
      0, 1, 1, 0, 0, 1, 0, 1, 1),
  w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,
      0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),
  doseGrid=c(0.1, 0.5, 1.5, 3, 6,
             seq(from=10, to=80, by=2)))

# Initialize the Dual-Endpoint model (in this case RW1)
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth = "RW1")

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=500)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Obtain the biomarker level for a given dose, given model and samples
biomLevel(dose = 0.5,
          model = model,
          samples = samples,
          xLevel = 2)



</code></pre>

<hr>
<h2 id='CohortSize-class'>The virtual class for cohort sizes</h2><span id='topic+CohortSize-class'></span>

<h3>Description</h3>

<p>The virtual class for cohort sizes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CohortSizeMax-class">CohortSizeMax</a></code>,
<code><a href="#topic+CohortSizeMin-class">CohortSizeMin</a></code>,
<code><a href="#topic+CohortSizeRange-class">CohortSizeRange</a></code>,
<code><a href="#topic+CohortSizeDLT-class">CohortSizeDLT</a></code>,
<code><a href="#topic+CohortSizeConst-class">CohortSizeConst</a></code>,
<code><a href="#topic+CohortSizeParts-class">CohortSizeParts</a></code>
</p>

<hr>
<h2 id='CohortSizeConst'>Initialization function for &quot;CohortSizeConst&quot;</h2><span id='topic+CohortSizeConst'></span>

<h3>Description</h3>

<p>Initialization function for &quot;CohortSizeConst&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CohortSizeConst(size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CohortSizeConst_+3A_size">size</code></td>
<td>
<p>see <code><a href="#topic+CohortSizeConst-class">CohortSizeConst</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+CohortSizeConst-class">CohortSizeConst</a></code> object
</p>

<hr>
<h2 id='CohortSizeConst-class'>Constant cohort size</h2><span id='topic+CohortSizeConst-class'></span><span id='topic+.CohortSizeConst'></span>

<h3>Description</h3>

<p>This class is used when the cohort size should be kept constant.
</p>


<h3>Slots</h3>


<dl>
<dt><code>size</code></dt><dd><p>the constant integer size</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is to have along the study a constant cohort size of 3
mySize &lt;- CohortSizeConst(size=3)

</code></pre>

<hr>
<h2 id='CohortSizeDLT'>Initialization function for &quot;CohortSizeDLT&quot;</h2><span id='topic+CohortSizeDLT'></span>

<h3>Description</h3>

<p>Initialization function for &quot;CohortSizeDLT&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CohortSizeDLT(DLTintervals, cohortSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CohortSizeDLT_+3A_dltintervals">DLTintervals</code></td>
<td>
<p>see <code><a href="#topic+CohortSizeDLT-class">CohortSizeDLT</a></code></p>
</td></tr>
<tr><td><code id="CohortSizeDLT_+3A_cohortsize">cohortSize</code></td>
<td>
<p>see <code><a href="#topic+CohortSizeDLT-class">CohortSizeDLT</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+CohortSizeDLT-class">CohortSizeDLT</a></code> object
</p>

<hr>
<h2 id='CohortSizeDLT-class'>Cohort size based on number of DLTs</h2><span id='topic+CohortSizeDLT-class'></span><span id='topic+.CohortSizeDLT'></span>

<h3>Description</h3>

<p>Cohort size based on number of DLTs
</p>


<h3>Slots</h3>


<dl>
<dt><code>DLTintervals</code></dt><dd><p>an integer vector with the left bounds of the relevant
DLT intervals</p>
</dd>
<dt><code>cohortSize</code></dt><dd><p>an integer vector of the same length with the cohort
sizes in the <code>DLTintervals</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#   having cohort of size 1 until no DLT were observed
#   and having cohort of size 3 as soon as 1 DLT is observed

mySize &lt;- CohortSizeDLT(DLTintervals = c(0, 1),
                        cohortSize = c(1, 3))

</code></pre>

<hr>
<h2 id='CohortSizeMax'>Initialization function for &quot;CohortSizeMax&quot;</h2><span id='topic+CohortSizeMax'></span>

<h3>Description</h3>

<p>Initialization function for &quot;CohortSizeMax&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CohortSizeMax(cohortSizeList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CohortSizeMax_+3A_cohortsizelist">cohortSizeList</code></td>
<td>
<p>see <code><a href="#topic+CohortSizeMax-class">CohortSizeMax</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+CohortSizeMax-class">CohortSizeMax</a></code> object
</p>

<hr>
<h2 id='CohortSizeMax-class'>Size based on maximum of multiple cohort size rules</h2><span id='topic+CohortSizeMax-class'></span><span id='topic+.CohortSizeMax'></span>

<h3>Description</h3>

<p>This class can be used to combine multiple cohort size rules with the MAX
operation.
</p>


<h3>Details</h3>

<p><code>cohortSizeList</code> contains all cohort size rules, which are again
objects of class <code><a href="#topic+CohortSize-class">CohortSize</a></code>. The maximum of these
individual cohort sizes is taken to give the final cohort size.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cohortSizeList</code></dt><dd><p>list of cohort size rules</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Rule for having cohort of size 1 for doses &lt;30
#      and having cohort of size 3 for doses &gt;=30
mySize1 &lt;- CohortSizeRange(intervals = c(0, 10),
                           cohortSize = c(1, 3))

# Rule for having cohort of size 1 until no DLT were observed
#      and having cohort of size 3 as soon as 1 DLT is observed
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))

# Create a list of cohort size rules of class 'CohortSizeMax' which will then be 
# combined with the 'max' operation
mySize &lt;- CohortSizeMax(cohortSizeList=list(mySize1, 
                                            mySize2))


</code></pre>

<hr>
<h2 id='CohortSizeMin'>Initialization function for &quot;CohortSizeMin&quot;</h2><span id='topic+CohortSizeMin'></span>

<h3>Description</h3>

<p>Initialization function for &quot;CohortSizeMin&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CohortSizeMin(cohortSizeList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CohortSizeMin_+3A_cohortsizelist">cohortSizeList</code></td>
<td>
<p>see <code><a href="#topic+CohortSizeMin-class">CohortSizeMin</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+CohortSizeMin-class">CohortSizeMin</a></code> object
</p>

<hr>
<h2 id='CohortSizeMin-class'>Size based on minimum of multiple cohort size rules</h2><span id='topic+CohortSizeMin-class'></span><span id='topic+.CohortSizeMin'></span>

<h3>Description</h3>

<p>This class can be used to combine multiple cohort size rules with the MIN
operation.
</p>


<h3>Details</h3>

<p><code>cohortSizeList</code> contains all cohort size rules, which are again
objects of class <code><a href="#topic+CohortSize-class">CohortSize</a></code>. The minimum of these
individual cohort sizes is taken to give the final cohort size.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cohortSizeList</code></dt><dd><p>list of cohort size rules</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Rule for having cohort of size 1 for doses &lt;30
#      and having cohort of size 3 for doses &gt;=30
mySize1 &lt;- CohortSizeRange(intervals = c(0, 10),
                           cohortSize = c(1, 3))

# Rule for having cohort of size 1 until no DLT were observed
#      and having cohort of size 3 as soon as 1 DLT is observed
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))

# Create a list of cohort size rules of class 'CohortSizeMax' which will then be 
# combined with the 'min' operation
mySize &lt;- CohortSizeMin(cohortSizeList=list(mySize1, 
                                            mySize2))


</code></pre>

<hr>
<h2 id='CohortSizeParts'>Initialization function for &quot;CohortSizeParts&quot;</h2><span id='topic+CohortSizeParts'></span>

<h3>Description</h3>

<p>Initialization function for &quot;CohortSizeParts&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CohortSizeParts(sizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CohortSizeParts_+3A_sizes">sizes</code></td>
<td>
<p>see <code><a href="#topic+CohortSizeParts-class">CohortSizeParts</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+CohortSizeParts-class">CohortSizeParts</a></code> object
</p>

<hr>
<h2 id='CohortSizeParts-class'>Cohort size based on the parts</h2><span id='topic+CohortSizeParts-class'></span><span id='topic+.CohortSizeParts'></span>

<h3>Description</h3>

<p>This class is used when the cohort size should change for the second part of
the dose escalation. Only works in conjunction with
<code><a href="#topic+DataParts-class">DataParts</a></code> objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sizes</code></dt><dd><p>the two sizes for part 1 and part 2</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
mySize &lt;- CohortSizeParts(sizes=c(1,3))

</code></pre>

<hr>
<h2 id='CohortSizeRange'>Initialization function for &quot;CohortSizeRange&quot;</h2><span id='topic+CohortSizeRange'></span>

<h3>Description</h3>

<p>Initialization function for &quot;CohortSizeRange&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CohortSizeRange(intervals, cohortSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CohortSizeRange_+3A_intervals">intervals</code></td>
<td>
<p>see <code><a href="#topic+CohortSizeRange-class">CohortSizeRange</a></code></p>
</td></tr>
<tr><td><code id="CohortSizeRange_+3A_cohortsize">cohortSize</code></td>
<td>
<p>see <code><a href="#topic+CohortSizeRange-class">CohortSizeRange</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+CohortSizeRange-class">CohortSizeRange</a></code> object
</p>

<hr>
<h2 id='CohortSizeRange-class'>Cohort size based on dose range</h2><span id='topic+CohortSizeRange-class'></span><span id='topic+.CohortSizeRange'></span>

<h3>Description</h3>

<p>Cohort size based on dose range
</p>


<h3>Slots</h3>


<dl>
<dt><code>intervals</code></dt><dd><p>a vector with the left bounds of the relevant dose intervals</p>
</dd>
<dt><code>cohortSize</code></dt><dd><p>an integer vector of the same length with the cohort
sizes in the <code>intervals</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#   having cohort of size 1 for doses &lt;30
#   and having cohort of size 3 for doses &gt;=30

mySize &lt;- CohortSizeRange(intervals=c(0, 30),
                          cohortSize=c(1, 3))

</code></pre>

<hr>
<h2 id='crmPackExample'>Open the example pdf for crmPack</h2><span id='topic+crmPackExample'></span>

<h3>Description</h3>

<p>Calling this helper function should open the example.pdf document,
residing in the doc subfolder of the package installation directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crmPackExample()
</code></pre>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove <a href="mailto:sabanesd@roche.com">sabanesd@roche.com</a>
</p>

<hr>
<h2 id='crmPackHelp'>Open the browser with help pages for crmPack</h2><span id='topic+crmPackHelp'></span>

<h3>Description</h3>

<p>This convenience function opens your browser with the help pages for
crmPack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crmPackHelp()
</code></pre>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove <a href="mailto:sabanesd@roche.com">sabanesd@roche.com</a>
</p>

<hr>
<h2 id='Data'>Initialization function for the &quot;Data&quot; class</h2><span id='topic+Data'></span>

<h3>Description</h3>

<p>This is the function for initializing a &quot;Data&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Data(
  x = numeric(),
  y = integer(),
  ID = integer(),
  cohort = integer(),
  doseGrid = numeric(),
  placebo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Data_+3A_x">x</code></td>
<td>
<p>the doses for the patients</p>
</td></tr>
<tr><td><code id="Data_+3A_y">y</code></td>
<td>
<p>the vector of toxicity events (0 or 1 integers). You can also
normal numeric vectors, but these will then be converted to integers.</p>
</td></tr>
<tr><td><code id="Data_+3A_id">ID</code></td>
<td>
<p>unique patient IDs (integer vector)</p>
</td></tr>
<tr><td><code id="Data_+3A_cohort">cohort</code></td>
<td>
<p>the cohort indices (sorted values from 0, 1, 2, ...)</p>
</td></tr>
<tr><td><code id="Data_+3A_dosegrid">doseGrid</code></td>
<td>
<p>the vector of all possible doses</p>
</td></tr>
<tr><td><code id="Data_+3A_placebo">placebo</code></td>
<td>
<p>logical value: if TRUE the first dose level in the grid is 
considered as PLACEBO</p>
</td></tr>
<tr><td><code id="Data_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>ID</code> and <code>cohort</code> can be missing, then a warning
will be issued and the variables will be filled with default
IDs and best guesses, respectively.
</p>


<h3>Value</h3>

<p>the initialized <code><a href="#topic+Data-class">Data</a></code> object
</p>

<hr>
<h2 id='Data-class'>Class for the data input</h2><span id='topic+Data-class'></span><span id='topic+.Data'></span>

<h3>Description</h3>

<p>This class inherits from <code><a href="#topic+GeneralData-class">GeneralData</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>the doses for the patients</p>
</dd>
<dt><code>y</code></dt><dd><p>the vector of toxicity events (0 or 1 integers)</p>
</dd>
<dt><code>doseGrid</code></dt><dd><p>the vector of all possible doses (sorted), i.e. the dose
grid</p>
</dd>
<dt><code>nGrid</code></dt><dd><p>number of gridpoints</p>
</dd>
<dt><code>xLevel</code></dt><dd><p>the levels for the doses the patients have been given</p>
</dd>
<dt><code>placebo</code></dt><dd><p>logical value: if TRUE the first dose level in the grid is
considered as PLACEBO</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># create some data from the class 'Data'
myData &lt;- Data(x=c(0.1,0.5,1.5,3,6,10,10,10),
               y=c(0,0,0,0,0,0,1,0),
               doseGrid=c(0.1,0.5,1.5,3,6,
                          seq(from=10,to=80,by=2)))
</code></pre>

<hr>
<h2 id='DataDual'>Initialization function for the &quot;DataDual&quot; class</h2><span id='topic+DataDual'></span>

<h3>Description</h3>

<p>This is the function for initializing a &quot;DataDual&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataDual(w = numeric(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataDual_+3A_w">w</code></td>
<td>
<p>the continuous vector of biomarker values</p>
</td></tr>
<tr><td><code id="DataDual_+3A_...">...</code></td>
<td>
<p>additional parameters from <code><a href="#topic+Data">Data</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the initialized <code><a href="#topic+DataDual-class">DataDual</a></code> object
</p>

<hr>
<h2 id='DataDual-class'>Class for the dual endpoint data input</h2><span id='topic+DataDual-class'></span><span id='topic+.DataDual'></span>

<h3>Description</h3>

<p>This is a subclass of <code><a href="#topic+Data-class">Data</a></code>, so contains all
slots from <code><a href="#topic+Data-class">Data</a></code>, and in addition biomarker
values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>w</code></dt><dd><p>the continuous vector of biomarker values</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># Create some data from the class 'DataDual'
myData &lt;- DataDual(x=c(0.1,0.5,1.5,3,6,10,10,10),
                   y=c(0,0,0,0,0,0,1,0),
                   w=rnorm(8),
                   doseGrid=c(0.1,0.5,1.5,3,6,
                              seq(from=10,to=80,by=2)))
</code></pre>

<hr>
<h2 id='DataMixture'>Initialization function for the &quot;DataMixture&quot; class</h2><span id='topic+DataMixture'></span>

<h3>Description</h3>

<p>This is the function for initializing a &quot;DataMixture&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataMixture(xshare = numeric(), yshare = integer(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataMixture_+3A_xshare">xshare</code></td>
<td>
<p>see <code><a href="#topic+DataMixture-class">DataMixture</a></code></p>
</td></tr>
<tr><td><code id="DataMixture_+3A_yshare">yshare</code></td>
<td>
<p>see <code><a href="#topic+DataMixture-class">DataMixture</a></code></p>
</td></tr>
<tr><td><code id="DataMixture_+3A_...">...</code></td>
<td>
<p>additional arguments for the underlying Data slots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the initialized <code><a href="#topic+DataMixture-class">DataMixture</a></code> object
</p>

<hr>
<h2 id='DataMixture-class'>Class for the data with mixture sharing</h2><span id='topic+DataMixture-class'></span><span id='topic+.DataMixture'></span>

<h3>Description</h3>

<p>Class for the data with mixture sharing
</p>


<h3>Slots</h3>


<dl>
<dt><code>xshare</code></dt><dd><p>the doses for the share patients</p>
</dd>
<dt><code>yshare</code></dt><dd><p>the vector of toxicity events (0 or 1 integers) for the share
patients</p>
</dd>
<dt><code>nObsshare</code></dt><dd><p>number of share patients</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+LogisticLogNormalMixture-class">LogisticLogNormalMixture</a></code> for the explanation
how to use this data class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## decide on the dose grid:
doseGrid &lt;- 1:80

## and MCMC options:
options &lt;- McmcOptions()

## the classic model would be:
model &lt;- LogisticLogNormal(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 50)

nodata &lt;- Data(doseGrid=doseGrid)

priorSamples &lt;- mcmc(nodata, model, options)
plot(priorSamples, model, nodata)

## set up the mixture model and data share object:
modelShare &lt;- LogisticLogNormalMixture(shareWeight=0.1,
                                       mean = c(-0.85, 1),
                                       cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                                       refDose = 50)

nodataShare &lt;- DataMixture(doseGrid=doseGrid,
                           xshare=
                             c(rep(10, 4),
                               rep(20, 4),
                               rep(40, 4)),
                           yshare=
                             c(rep(0L, 4),
                               rep(0L, 4),
                               rep(0L, 4)))

## now compare with the resulting prior model:
priorSamplesShare &lt;- mcmc(nodataShare, modelShare, options)
plot(priorSamplesShare, modelShare, nodataShare)
</code></pre>

<hr>
<h2 id='DataParts'>Initialization function for the &quot;DataParts&quot; class</h2><span id='topic+DataParts'></span>

<h3>Description</h3>

<p>This is the function for initializing a <code><a href="#topic+DataParts-class">DataParts</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataParts(part = integer(), nextPart = 1L, part1Ladder = numeric(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataParts_+3A_part">part</code></td>
<td>
<p>which part does each of the patients belong to?</p>
</td></tr>
<tr><td><code id="DataParts_+3A_nextpart">nextPart</code></td>
<td>
<p>what is the part for the next cohort? (1 or 2)</p>
</td></tr>
<tr><td><code id="DataParts_+3A_part1ladder">part1Ladder</code></td>
<td>
<p>what is the escalation ladder for
part 1?</p>
</td></tr>
<tr><td><code id="DataParts_+3A_...">...</code></td>
<td>
<p>additional parameters from <code><a href="#topic+Data">Data</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the initialized <code><a href="#topic+DataParts-class">DataParts</a></code> object
</p>

<hr>
<h2 id='DataParts-class'>Class for the data with two study parts</h2><span id='topic+DataParts-class'></span><span id='topic+.DataParts'></span>

<h3>Description</h3>

<p>This is a subclass of <code><a href="#topic+Data-class">Data</a></code>, so contains all
slots from <code><a href="#topic+Data-class">Data</a></code>, and in addition information on the two
study parts.
</p>


<h3>Slots</h3>


<dl>
<dt><code>part</code></dt><dd><p>integer vector; which part does each of the patients belong to?</p>
</dd>
<dt><code>nextPart</code></dt><dd><p>integer; what is the part for the next cohort?</p>
</dd>
<dt><code>part1Ladder</code></dt><dd><p>sorted numeric vector; what is the escalation ladder for
part 1? This shall be a subset of the <code>doseGrid</code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># create an object of class 'DataParts'
myData &lt;- DataParts(x=c(0.1,0.5,1.5),
                    y=c(0,0,0),
                    doseGrid=c(0.1,0.5,1.5,3,6,
                               seq(from=10,to=80,by=2)),
                    part=c(1L,1L,1L),
                    nextPart=1L,
                    part1Ladder=c(0.1,0.5,1.5,3,6,10))
</code></pre>

<hr>
<h2 id='Design'>Initialization function for &quot;Design&quot;</h2><span id='topic+Design'></span>

<h3>Description</h3>

<p>Initialization function for &quot;Design&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Design(model, stopping, increments, PLcohortSize = CohortSizeConst(0L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Design_+3A_model">model</code></td>
<td>
<p>see <code><a href="#topic+Design-class">Design</a></code></p>
</td></tr>
<tr><td><code id="Design_+3A_stopping">stopping</code></td>
<td>
<p>see <code><a href="#topic+Design-class">Design</a></code></p>
</td></tr>
<tr><td><code id="Design_+3A_increments">increments</code></td>
<td>
<p>see <code><a href="#topic+Design-class">Design</a></code></p>
</td></tr>
<tr><td><code id="Design_+3A_plcohortsize">PLcohortSize</code></td>
<td>
<p>see <code><a href="#topic+Design-class">Design</a></code></p>
</td></tr>
<tr><td><code id="Design_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="#topic+RuleDesign">RuleDesign</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+Design-class">Design</a></code> object
</p>

<hr>
<h2 id='Design-class'>Class for the CRM design</h2><span id='topic+Design-class'></span><span id='topic+.Design'></span>

<h3>Description</h3>

<p>In addition to the slots in the more simple <code><a href="#topic+RuleDesign-class">RuleDesign</a></code>,
objects of this class contain:
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>the model to be used, an object of class
<code><a href="#topic+Model-class">Model</a></code></p>
</dd>
<dt><code>stopping</code></dt><dd><p>stopping rule(s) for the trial, an object of class
<code><a href="#topic+Stopping-class">Stopping</a></code></p>
</dd>
<dt><code>increments</code></dt><dd><p>how to control increments between dose levels,
an object of class <code><a href="#topic+Increments-class">Increments</a></code></p>
</dd>
<dt><code>PLcohortSize</code></dt><dd><p>rules for the cohort sizes for placebo, if any planned
an object of class <code><a href="#topic+CohortSize-class">CohortSize</a></code> (defaults to constant
0 placebo patients)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)
myStopping &lt;- (myStopping1 &amp; myStopping2) | myStopping3

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- Design(model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 data=emptydata,
                 startingDose=3)
  
  
</code></pre>

<hr>
<h2 id='dinvGamma'>Compute the density of Inverse gamma distribution</h2><span id='topic+dinvGamma'></span>

<h3>Description</h3>

<p>Compute the density of Inverse gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvGamma(x, a, b, log = FALSE, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dinvGamma_+3A_x">x</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_a">a</code></td>
<td>
<p>the shape parameter of the inverse gamma distribution</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_b">b</code></td>
<td>
<p>the scale parameter of the inverse gamm distribution</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p)</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_normalize">normalize</code></td>
<td>
<p>logical; if TRUE, the output will be normalized</p>
</td></tr>
</table>

<hr>
<h2 id='dose'>Compute the doses for a given probability, given model and samples</h2><span id='topic+dose'></span><span id='topic+dose+2Cnumeric+2CModel+2CSamples-method'></span><span id='topic+dose+2Cnumeric+2CModelTox+2CSamples-method'></span><span id='topic+dose+2Cnumeric+2CModelTox+2Cmissing-method'></span>

<h3>Description</h3>

<p>Compute the doses for a given probability, given model and samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose(prob, model, samples, ...)

## S4 method for signature 'numeric,Model,Samples'
dose(prob, model, samples, ...)

## S4 method for signature 'numeric,ModelTox,Samples'
dose(prob, model, samples, ...)

## S4 method for signature 'numeric,ModelTox,missing'
dose(prob, model, samples, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dose_+3A_prob">prob</code></td>
<td>
<p>the probability</p>
</td></tr>
<tr><td><code id="dose_+3A_model">model</code></td>
<td>
<p>the <code><a href="#topic+Model-class">Model</a></code></p>
</td></tr>
<tr><td><code id="dose_+3A_samples">samples</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code></p>
</td></tr>
<tr><td><code id="dose_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>dose(prob = numeric, model = ModelTox, samples = Samples)</code>: Compute the doses for a given probability, given 
Pseudo DLE model with samples
</p>
</li>
<li> <p><code>dose(prob = numeric, model = ModelTox, samples = missing)</code>: Compute the dose for a given probability and a given 
Pseudo DLE model without samples
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# create some data
data &lt;- Data(x =c (0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y = c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort = c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid = c(0.1, 0.5, 1.5, 3, 6,
                          seq(from=10, to=80, by=2)))

# Initialize a  model
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=matrix(c(1, -0.5, -0.5, 1),
                                      nrow=2),
                           refDose=56)

# Get samples from posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Posterior for the dose achieving Prob(DLE) = 0.45
TD45 &lt;- dose(prob=0.45,model=model,samples=samples)


# create data from the 'Data" (or DataDual') class
data &lt;- Data(x = c(25,50,25,50,75,300,250,150),
             y = c(0,0,0,0,0,1,1,0),
             doseGrid = seq(25,300,25))

## Initialize a model from 'ModelTox' class e.g using 'LogisticIndepBeta' model
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

options &lt;- McmcOptions(burnin=100, step=2, samples=200)
DLEsamples &lt;- mcmc(data=data,model=DLEmodel,options=options)

TD45 &lt;- dose(prob=0.45, model = DLEmodel,samples = DLEsamples)


# create data from the 'Data' (or 'DataDual') class
data &lt;- Data(x = c(25,50,25,50,75,300,250,150),
                 y = c(0,0,0,0,0,1,1,0),
                 doseGrid = seq(25,300,25))

## Initialize a model from 'ModelTox' class e.g using 'LogisticIndepBeta' model
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

TD45 &lt;- dose(prob=0.45, model = DLEmodel)

</code></pre>

<hr>
<h2 id='DualDesign'>Initialization function for &quot;DualDesign&quot;</h2><span id='topic+DualDesign'></span>

<h3>Description</h3>

<p>Initialization function for &quot;DualDesign&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DualDesign(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DualDesign_+3A_model">model</code></td>
<td>
<p>see <code><a href="#topic+DualDesign-class">DualDesign</a></code></p>
</td></tr>
<tr><td><code id="DualDesign_+3A_data">data</code></td>
<td>
<p>see <code><a href="#topic+DualDesign-class">DualDesign</a></code></p>
</td></tr>
<tr><td><code id="DualDesign_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="#topic+Design">Design</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+DualDesign-class">DualDesign</a></code> object
</p>

<hr>
<h2 id='DualDesign-class'>Class for the dual-endpoint CRM design</h2><span id='topic+DualDesign-class'></span><span id='topic+.DualDesign'></span>

<h3>Description</h3>

<p>This class has special requirements for the <code>model</code> and <code>data</code>
slots in comparison to the parent class <code><a href="#topic+Design-class">Design</a></code>:
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>the model to be used, an object of class
<code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code></p>
</dd>
<dt><code>data</code></dt><dd><p>what is the dose grid, any previous data, etc., contained
in an object of class <code><a href="#topic+DataDual-class">DataDual</a></code>
</p>
<p>Note that the <code>NextBest</code> slot can be of any class, this allows for easy
comparison with recommendation methods that don't use the
biomarker information.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth="RW1")

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping4 &lt;- StoppingTargetBiomarker(target=c(0.9, 1),
                                       prob=0.5)
myStopping &lt;- myStopping4 | StoppingMinPatients(40)

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- DualDesign(model = model,
                     data = emptydata,
                     nextBest = myNextBest,
                     stopping = myStopping,
                     increments = myIncrements,
                     cohortSize = mySize,
                     startingDose = 3)
  
  
</code></pre>

<hr>
<h2 id='DualEndpoint'>Initialization function for the &quot;DualEndpoint&quot; class</h2><span id='topic+DualEndpoint'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;DualEndpoint&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DualEndpoint(mu, Sigma, refDose = 1, useLogDose = FALSE, sigma2W, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DualEndpoint_+3A_mu">mu</code></td>
<td>
<p>see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code></p>
</td></tr>
<tr><td><code id="DualEndpoint_+3A_sigma">Sigma</code></td>
<td>
<p>see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code></p>
</td></tr>
<tr><td><code id="DualEndpoint_+3A_refdose">refDose</code></td>
<td>
<p>see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> (default: 1)</p>
</td></tr>
<tr><td><code id="DualEndpoint_+3A_uselogdose">useLogDose</code></td>
<td>
<p>see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> 
(default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="DualEndpoint_+3A_sigma2w">sigma2W</code></td>
<td>
<p>see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code></p>
</td></tr>
<tr><td><code id="DualEndpoint_+3A_rho">rho</code></td>
<td>
<p>see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> object
</p>

<hr>
<h2 id='DualEndpoint-class'>General class for the dual endpoint model</h2><span id='topic+DualEndpoint-class'></span><span id='topic+.DualEndpoint'></span>

<h3>Description</h3>

<p>The idea of the dual-endpoint models is to model not only the dose-toxicity
relationship, but also to model at the same time the relationship of a PD
biomarker with the dose. The subclasses of this class detail how the
dose-biomarker relationship is parametrized and are those to be used. This
class here shall contain all the common features to reduce duplicate code.
(However, this class must not be virtual, because we need to create objects
of it during the construction of subclass objects.)
</p>


<h3>Details</h3>

<p>Currently a probit regression model
</p>
<p style="text-align: center;"><code class="reqn">probit[p(x)] = \beta_{Z1} + \beta_{Z2} 
\cdot x/x^{*}</code>
</p>

<p>or
</p>
<p style="text-align: center;"><code class="reqn">probit[p(x)] = \beta_{Z1} + \beta_{Z2} 
\cdot \log(x/x^{*})</code>
</p>

<p>in case that the option <code>useLogDose</code> is <code>TRUE</code>.
Here <code class="reqn">p(x)</code> is the probability of observing a DLT for a given
dose <code class="reqn">x</code>, <code class="reqn">\Phi</code> is the standard normal cdf, and <code class="reqn">x^{*}</code> is
the reference dose.
</p>
<p>The prior is </p>
<p style="text-align: center;"><code class="reqn">\left( \beta_{Z1} , log(\beta_{Z2}) \right) 
\sim Normal(\mu, \Sigma)</code>
</p>
<p>.
</p>
<p>For the biomarker response w at a dose x, we assume
</p>
<p style="text-align: center;"><code class="reqn">w(x) \sim Normal(f(x), \sigma^{2}_{W})</code>
</p>

<p>and <code class="reqn">f(x)</code> is a function of the dose x, which is further specified in
the subclasses. The biomarker variance <code class="reqn">\sigma^{2}_{W}</code> can be fixed or
assigned an inverse gamma prior distribution; see the details below under
slot <code>sigma2W</code>.
</p>
<p>Finally, the two endpoints y (the binary DLT variable) and w (the biomarker)
can be correlated, by assuming a correlation <code class="reqn">\rho</code> between the
underlying continuous latent toxicity variable z and the biomarker w.
Again, this correlation can be fixed or assigned a prior distribution from
the scaled beta family; see the details below under slot <code>rho</code>.
</p>
<p>Please see the Hive page for more details on the model and the example
vignette by typing <code>crmPackExample()</code> for a full example.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code></dt><dd><p>For the probit toxicity model, <code>mu</code> contains the prior mean
vector</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>For the probit toxicity model, contains the prior covariance
matrix</p>
</dd>
<dt><code>refDose</code></dt><dd><p>For the probit toxicity model, the reference dose</p>
</dd>
<dt><code>useLogDose</code></dt><dd><p>For the probit toxicity model, whether a log transformation
of the (standardized) dose should be used?</p>
</dd>
<dt><code>sigma2W</code></dt><dd><p>Either a fixed value for the biomarker variance, or a vector
with elements <code>a</code> and <code>b</code> for the inverse-gamma prior parameters.</p>
</dd>
<dt><code>rho</code></dt><dd><p>Either a fixed value for the correlation (between -1 and 1), or a
vector with elements <code>a</code> and <code>b</code> for the Beta prior on the
transformation kappa = (rho + 1) / 2, which is in (0, 1). For example,
<code>a=1,b=1</code> leads to a uniform prior on rho.</p>
</dd>
<dt><code>useFixed</code></dt><dd><p>a list with logical value for each of the parameters
indicating whether a fixed value is used or not; this slot is needed for
internal purposes and not to be touched by the user.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Current subclasses: <code><a href="#topic+DualEndpointRW-class">DualEndpointRW</a></code>,
<code><a href="#topic+DualEndpointBeta-class">DualEndpointBeta</a></code>
</p>

<hr>
<h2 id='DualEndpointBeta'>Initialization function for the &quot;DualEndpointBeta&quot; class</h2><span id='topic+DualEndpointBeta'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;DualEndpointBeta&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DualEndpointBeta(E0, Emax, delta1, mode, refDoseBeta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DualEndpointBeta_+3A_e0">E0</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointBeta-class">DualEndpointBeta</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointBeta_+3A_emax">Emax</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointBeta-class">DualEndpointBeta</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointBeta_+3A_delta1">delta1</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointBeta-class">DualEndpointBeta</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointBeta_+3A_mode">mode</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointBeta-class">DualEndpointBeta</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointBeta_+3A_refdosebeta">refDoseBeta</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointBeta-class">DualEndpointBeta</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointBeta_+3A_...">...</code></td>
<td>
<p>additional parameters, see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+DualEndpointBeta-class">DualEndpointBeta</a></code> object
</p>

<hr>
<h2 id='DualEndpointBeta-class'>Dual endpoint model with beta function for dose-biomarker relationship</h2><span id='topic+DualEndpointBeta-class'></span><span id='topic+.DualEndpointBeta'></span>

<h3>Description</h3>

<p>This class extends the <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> class. Here the
dose-biomarker relationship <code class="reqn">f(x)</code> is modelled by a parametric, rescaled
beta density function:
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">f(x) = E_{0} + (E_{max} - E_{0}) * Beta(\delta_{1}, \delta_{2}) *
                  (x/x^{*})^{\delta_{1}} * (1 - x/x^{*})^{\delta_{2}}</code>
</p>

<p>where <code class="reqn">x^{*}</code> is the maximum dose (end of the dose range to be
considered), <code class="reqn">\delta_{1}</code> and <code class="reqn">\delta_{2}</code> are the two beta
parameters, and <code class="reqn">E_{0}</code> and <code class="reqn">E_{max}</code> are the minimum and maximum
levels, respectively. For ease of interpretation, we parametrize with
<code class="reqn">\delta_{1}</code> and the mode of the curve instead, where
</p>
<p style="text-align: center;"><code class="reqn">mode = \delta_{1} / (\delta_{1} + \delta_{2}),</code>
</p>

<p>and multiplying this with <code class="reqn">x^{*}</code> gives the mode on the dose grid.
</p>
<p>All parameters can currently be assigned uniform distributions or be fixed
in advance. Note that <code>E0</code> and <code>Emax</code> can have negative values or uniform 
distributions reaching into negative range, while <code>delta1</code> and <code>mode</code>
must be positive or have uniform distributions in the positive range.
</p>


<h3>Slots</h3>


<dl>
<dt><code>E0</code></dt><dd><p>either a fixed number or the two uniform distribution parameters</p>
</dd>
<dt><code>Emax</code></dt><dd><p>either a fixed number or the two uniform distribution parameters</p>
</dd>
<dt><code>delta1</code></dt><dd><p>either a fixed number or the two uniform distribution parameters</p>
</dd>
<dt><code>mode</code></dt><dd><p>either a fixed number or the two uniform distribution parameters</p>
</dd>
<dt><code>refDoseBeta</code></dt><dd><p>the reference dose <code class="reqn">x^{*}</code> (note that this is different from
the <code>refDose</code> in the inherited <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> model)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- DualEndpointBeta(E0 = c(0, 100),
                          Emax = c(0, 500),
                          delta1 = c(0, 5),
                          mode = c(1, 15),
                          refDose=10,
                          useLogDose=TRUE,
                          refDoseBeta = 1000,
                          mu = c(0, 1),
                          Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                          sigma2W = c(a=0.1, b=0.1),
                          rho = c(a=1, b=1))


</code></pre>

<hr>
<h2 id='DualEndpointEmax'>Initialization function for the &quot;DualEndpointEmax&quot; class</h2><span id='topic+DualEndpointEmax'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;DualEndpointEmax&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DualEndpointEmax(E0, Emax, ED50, refDoseEmax, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DualEndpointEmax_+3A_e0">E0</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointEmax-class">DualEndpointEmax</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointEmax_+3A_emax">Emax</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointEmax-class">DualEndpointEmax</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointEmax_+3A_ed50">ED50</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointEmax-class">DualEndpointEmax</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointEmax_+3A_refdoseemax">refDoseEmax</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointEmax-class">DualEndpointEmax</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointEmax_+3A_...">...</code></td>
<td>
<p>additional parameters, see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+DualEndpointEmax-class">DualEndpointEmax</a></code> object
</p>

<hr>
<h2 id='DualEndpointEmax-class'>Dual endpoint model with emax function for dose-biomarker relationship</h2><span id='topic+DualEndpointEmax-class'></span><span id='topic+.DualEndpointEmax'></span>

<h3>Description</h3>

<p>This class extends the <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> class. Here the
dose-biomarker relationship <code class="reqn">f(x)</code> is modelled by a parametric EMAX function:
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">f(x) = E_{0} + \frac{(E_{max} - E_{0}) * (x/x^{*})}{ED_{50} + (x/x^{*})}</code>
</p>

<p>where <code class="reqn">x^{*}</code> is a reference dose, <code class="reqn">E_{0}</code> and <code class="reqn">E_{max}</code> are the
minimum and maximum levels for the biomarker and <code class="reqn">ED_{50}</code> is the dose
achieving half of the maximum effect <code class="reqn">0.5 * E_{max}</code>.
</p>
<p>All parameters can currently be assigned uniform distributions or be fixed
in advance.
</p>


<h3>Slots</h3>


<dl>
<dt><code>E0</code></dt><dd><p>either a fixed number or the two uniform distribution parameters</p>
</dd>
<dt><code>Emax</code></dt><dd><p>either a fixed number or the two uniform distribution parameters</p>
</dd>
<dt><code>ED50</code></dt><dd><p>either a fixed number or the two uniform distribution parameters</p>
</dd>
<dt><code>refDoseEmax</code></dt><dd><p>the reference dose <code class="reqn">x^{*}</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- DualEndpointEmax(E0 = c(0, 100),
                          Emax = c(0, 500),
                          ED50 = c(10,200),
                          refDoseEmax = 1000,
                          mu = c(0, 1),
                          Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                          sigma2W = c(a=0.1, b=0.1),
                          rho = c(a=1, b=1))


</code></pre>

<hr>
<h2 id='DualEndpointOld-class'>Dual endpoint model</h2><span id='topic+DualEndpointOld-class'></span>

<h3>Description</h3>

<p>todo: describe the model
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code></dt><dd><p>For the probit toxicity model, <code>mu</code> contains the prior mean
vector</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>For the probit toxicity model, contains the prior covariance
matrix</p>
</dd>
<dt><code>sigma2betaW</code></dt><dd><p>For the biomarker model, contains the prior variance
factor of the random walk prior. If it is not a single number, it can also
contain a vector with elements <code>a</code> and <code>b</code> for the inverse-gamma prior
on <code>sigma2betaW</code>.</p>
</dd>
<dt><code>sigma2W</code></dt><dd><p>Either a fixed value for the biomarker variance, or a vector
with elements <code>a</code> and <code>b</code> for the inverse-gamma prior parameters.</p>
</dd>
<dt><code>rho</code></dt><dd><p>Either a fixed value for the correlation (between -1 and 1), or a
vector with elements <code>a</code> and <code>b</code> for the Beta prior on the
transformation kappa = (rho + 1) / 2, which is in (0, 1). For example,
<code>a=1,b=1</code> leads to a uniform prior on rho.</p>
</dd>
<dt><code>useRW1</code></dt><dd><p>for specifying the random walk prior on the biomarker level: if
<code>TRUE</code>, RW1 is used, otherwise RW2.</p>
</dd>
<dt><code>useFixed</code></dt><dd><p>a list with logical value for each of the three parameters
<code>sigma2betaW</code>, <code>sigma2W</code> and <code>rho</code> indicating whether
a fixed value is used or not.</p>
</dd>
</dl>

<hr>
<h2 id='DualEndpointRW'>Initialization function for the &quot;DualEndpointRW&quot; class</h2><span id='topic+DualEndpointRW'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;DualEndpointRW&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DualEndpointRW(sigma2betaW, smooth = c("RW1", "RW2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DualEndpointRW_+3A_sigma2betaw">sigma2betaW</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointRW-class">DualEndpointRW</a></code></p>
</td></tr>
<tr><td><code id="DualEndpointRW_+3A_smooth">smooth</code></td>
<td>
<p>either &ldquo;RW1&rdquo; (default) or &ldquo;RW2&rdquo;, for
specifying the random walk prior on the biomarker level.</p>
</td></tr>
<tr><td><code id="DualEndpointRW_+3A_...">...</code></td>
<td>
<p>additional parameters, see <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+DualEndpointRW-class">DualEndpointRW</a></code> object
</p>

<hr>
<h2 id='DualEndpointRW-class'>Dual endpoint model with RW prior for biomarker</h2><span id='topic+DualEndpointRW-class'></span><span id='topic+.DualEndpointRW'></span>

<h3>Description</h3>

<p>This class extends the <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> class. Here the
dose-biomarker relationship <code class="reqn">f(x)</code> is modelled by a non-parametric
random-walk of first (RW1) or second order (RW2).
</p>


<h3>Details</h3>

<p>That means, for the RW1 we assume
</p>
<p style="text-align: center;"><code class="reqn">\beta_{W,i} - \beta_{W,i-1} \sim Normal(0, (x_{i} - x_{i-1}) \sigma^{2}_{\beta_{W}}),</code>
</p>

<p>where <code class="reqn">\beta_{W,i} = f(x_{i})</code> is the biomarker mean at the i-th dose
gridpoint <code class="reqn">x_{i}</code>.
For the RW2, the second-order differences instead of the first-order
differences of the biomarker means follow the normal distribution.
</p>
<p>The variance parameter <code class="reqn">\sigma^{2}_{\beta_{W}}</code> is important because it
steers the smoothness of the function f(x): if it is large, then f(x) will
be very wiggly; if it is small, then f(x) will be smooth. This parameter can
either be fixed or assigned an inverse gamma prior distribution.
</p>
<p>Non-equidistant dose grids can be used now, because the difference
<code class="reqn">x_{i} - x_{i-1}</code> is included in the modelling assumption above.
</p>
<p>Please note that due to impropriety of the RW prior distributions, it is 
not possible to produce MCMC samples with empty data objects (i.e., sample
from the prior). This is not a bug, but a theoretical feature of this
model.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sigma2betaW</code></dt><dd><p>Contains the prior variance factor of the random walk
prior for the biomarker model. If it is not a single number, it can also
contain a vector with elements <code>a</code> and <code>b</code> for the inverse-gamma prior
on <code>sigma2betaW</code>.</p>
</dd>
<dt><code>useRW1</code></dt><dd><p>for specifying the random walk prior on the biomarker level: if
<code>TRUE</code>, RW1 is used, otherwise RW2.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth="RW1")


</code></pre>

<hr>
<h2 id='DualResponsesDesign'>Initialization function for 'DualResponsesDesign&quot;</h2><span id='topic+DualResponsesDesign'></span>

<h3>Description</h3>

<p>Initialization function for 'DualResponsesDesign&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DualResponsesDesign(Effmodel, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DualResponsesDesign_+3A_effmodel">Effmodel</code></td>
<td>
<p>please refer to <code><a href="#topic+DualResponsesDesign-class">DualResponsesDesign</a></code> class object</p>
</td></tr>
<tr><td><code id="DualResponsesDesign_+3A_data">data</code></td>
<td>
<p>please refer to <code><a href="#topic+DualResponsesDesign-class">DualResponsesDesign</a></code> class object</p>
</td></tr>
<tr><td><code id="DualResponsesDesign_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="#topic+TDDesign">TDDesign</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+DualResponsesDesign-class">DualResponsesDesign</a></code> class object
</p>

<hr>
<h2 id='DualResponsesDesign-class'>This is a class of design based on DLE responses using the <code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code> model 
model and efficacy responses using <code><a href="#topic+ModelEff-class">ModelEff</a></code>  model class
without DLE and efficacy samples. It contain all slots in 
<code><a href="#topic+RuleDesign-class">RuleDesign</a></code> and <code><a href="#topic+TDDesign-class">TDDesign</a></code> class object</h2><span id='topic+DualResponsesDesign-class'></span><span id='topic+.DualResponsesDesign'></span>

<h3>Description</h3>

<p>This is a class of design based on DLE responses using the <code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code> model 
model and efficacy responses using <code><a href="#topic+ModelEff-class">ModelEff</a></code>  model class
without DLE and efficacy samples. It contain all slots in 
<code><a href="#topic+RuleDesign-class">RuleDesign</a></code> and <code><a href="#topic+TDDesign-class">TDDesign</a></code> class object
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>the data set of <code><a href="#topic+DataDual-class">DataDual</a></code> class object</p>
</dd>
<dt><code>Effmodel</code></dt><dd><p>the pseudo efficacy model to be used, an object class of 
<code><a href="#topic+ModelEff-class">ModelEff</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Construct the DualResponsesDesign for simulations
##The design comprises the DLE and efficacy models, the escalation rule, starting data, 
##a cohort size and a starting dose
##Define your data set first using an empty data set 
## with dose levels from 25 to 300 with increments 25
data &lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

##The efficacy model of 'ModelEff' (e.g 'Effloglog') class 
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),
                    nu=c(a=1,b=0.025),data=data,c=0)

##The escalation rule using the 'NextBestMaxGain' class
mynextbest&lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,
                            DLEEndOfTrialtarget=0.3)


##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 36 subjects are treated
myStopping &lt;- StoppingMinPatients(nPatients=36)
##Now specified the design with all the above information and starting with a dose of 25

design &lt;- DualResponsesDesign(nextBest=mynextbest,
                              model=DLEmodel,
                              Effmodel=Effmodel,
                              stopping=myStopping,
                              increments=myIncrements,
                              cohortSize=mySize,
                              data=data,startingDose=25)
</code></pre>

<hr>
<h2 id='DualResponsesSamplesDesign'>Initialization function for 'DualResponsesSamplesDesign&quot;</h2><span id='topic+DualResponsesSamplesDesign'></span>

<h3>Description</h3>

<p>Initialization function for 'DualResponsesSamplesDesign&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DualResponsesSamplesDesign(Effmodel, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DualResponsesSamplesDesign_+3A_effmodel">Effmodel</code></td>
<td>
<p>please refer to <code><a href="#topic+DualResponsesSamplesDesign-class">DualResponsesSamplesDesign</a></code> class object</p>
</td></tr>
<tr><td><code id="DualResponsesSamplesDesign_+3A_data">data</code></td>
<td>
<p>please refer to <code><a href="#topic+DualResponsesSamplesDesign-class">DualResponsesSamplesDesign</a></code> class object</p>
</td></tr>
<tr><td><code id="DualResponsesSamplesDesign_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="#topic+TDsamplesDesign">TDsamplesDesign</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+DualResponsesSamplesDesign-class">DualResponsesSamplesDesign</a></code> class object
</p>

<hr>
<h2 id='DualResponsesSamplesDesign-class'>This is a class of design based on DLE responses using the <code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code> model 
model and efficacy responses using <code><a href="#topic+ModelEff-class">ModelEff</a></code>  model class
with DLE and efficacy samples.It contain all slots in 
<code><a href="#topic+RuleDesign-class">RuleDesign</a></code> and <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code> class object</h2><span id='topic+DualResponsesSamplesDesign-class'></span><span id='topic+.DualResponsesSamplesDesign'></span>

<h3>Description</h3>

<p>This is a class of design based on DLE responses using the <code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code> model 
model and efficacy responses using <code><a href="#topic+ModelEff-class">ModelEff</a></code>  model class
with DLE and efficacy samples.It contain all slots in 
<code><a href="#topic+RuleDesign-class">RuleDesign</a></code> and <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code> class object
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>the data set of <code><a href="#topic+DataDual-class">DataDual</a></code> class object</p>
</dd>
<dt><code>Effmodel</code></dt><dd><p>the pseudo efficacy model to be used, an object class of 
<code><a href="#topic+ModelEff-class">ModelEff</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Construct the DualResponsesSamplesDesign for simulations
##The design comprises the DLE and efficacy models, the escalation rule, starting data, 
##a cohort size and a starting dose
##Define your data set first using an empty data set 
## with dose levels from 25 to 300 with increments 25
data &lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)

## First for the DLE model and DLE samples
## The DLE model must be of 'ModelTox' 
## (e.g 'LogisticIndepBeta') class and 
## DLEsamples of 'Samples' class
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),
                              DLEdose=c(25,300),data=data)
DLEsamples&lt;-mcmc(data,DLEmodel,options)
##The efficacy model of 'ModelEff' (e.g 'Effloglog') class and the efficacy samples
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
Effsamples&lt;-mcmc(data,Effmodel,options)
##The escalation rule using the 'NextBestMaxGainSamples' class
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})


##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 36 subjects are treated
myStopping &lt;- StoppingMinPatients(nPatients=36)
##Now specified the design with all the above information and starting with a dose of 25

design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)

</code></pre>

<hr>
<h2 id='DualSimulations'>Initialization function for &quot;DualSimulations&quot;</h2><span id='topic+DualSimulations'></span>

<h3>Description</h3>

<p>Initialization function for &quot;DualSimulations&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DualSimulations(rhoEst, sigma2West, fitBiomarker, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DualSimulations_+3A_rhoest">rhoEst</code></td>
<td>
<p>see <code><a href="#topic+DualSimulations-class">DualSimulations</a></code></p>
</td></tr>
<tr><td><code id="DualSimulations_+3A_sigma2west">sigma2West</code></td>
<td>
<p>see <code><a href="#topic+DualSimulations-class">DualSimulations</a></code></p>
</td></tr>
<tr><td><code id="DualSimulations_+3A_fitbiomarker">fitBiomarker</code></td>
<td>
<p>see <code><a href="#topic+DualSimulations-class">DualSimulations</a></code></p>
</td></tr>
<tr><td><code id="DualSimulations_+3A_...">...</code></td>
<td>
<p>additional parameters from <code><a href="#topic+Simulations">Simulations</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+DualSimulations-class">DualSimulations</a></code> object
</p>

<hr>
<h2 id='DualSimulations-class'>Class for the simulations output from dual-endpoint model based designs</h2><span id='topic+DualSimulations-class'></span><span id='topic+.DualSimulations'></span>

<h3>Description</h3>

<p>This class captures the trial simulations from dual-endpoint model based
designs. In comparison to the parent class <code><a href="#topic+Simulations-class">Simulations</a></code>,
it contains additional slots to capture the dose-biomarker fits, and the
sigma2W and rho estimates.
</p>


<h3>Slots</h3>


<dl>
<dt><code>rhoEst</code></dt><dd><p>the vector of final posterior median rho estimates</p>
</dd>
<dt><code>sigma2West</code></dt><dd><p>the vector of final posterior median sigma2W estimates</p>
</dd>
<dt><code>fitBiomarker</code></dt><dd><p>list with the final dose-biomarker curve fits</p>
</dd>
</dl>

<hr>
<h2 id='DualSimulationsSummary-class'>Class for the summary of dual-endpoint simulations output</h2><span id='topic+DualSimulationsSummary-class'></span><span id='topic+.DualSimulationsSummary'></span>

<h3>Description</h3>

<p>In addition to the slots in the parent class
<code><a href="#topic+SimulationsSummary-class">SimulationsSummary</a></code>, it contains two slots for the
biomarker model fit information.
</p>


<h3>Details</h3>

<p>Note that objects should not be created by users, therefore no
initialization function is provided for this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>biomarkerFitAtDoseMostSelected</code></dt><dd><p>fitted biomarker level at dose most often selected</p>
</dd>
<dt><code>meanBiomarkerFit</code></dt><dd><p>list with the average, lower (2.5
quantiles of the mean fitted biomarker level at each dose level</p>
</dd>
</dl>

<hr>
<h2 id='EffFlexi'>Initialization function for the &quot;EffFlexi&quot; class</h2><span id='topic+EffFlexi'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;EffFlexi&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EffFlexi(Eff, Effdose, sigma2, sigma2betaW, smooth = c("RW1", "RW2"), data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EffFlexi_+3A_eff">Eff</code></td>
<td>
<p>the pseudo efficacy responses</p>
</td></tr>
<tr><td><code id="EffFlexi_+3A_effdose">Effdose</code></td>
<td>
<p>the corresponding dose levels for the pseudo efficacy responses</p>
</td></tr>
<tr><td><code id="EffFlexi_+3A_sigma2">sigma2</code></td>
<td>
<p>the prior variance of the efficacy responses which can be specified 
with a single positive scalar or with two positive scalar values fot the shape <code>a</code> and 
the rate <code>b</code> parameters of the inverse gamma distribtuion.</p>
</td></tr>
<tr><td><code id="EffFlexi_+3A_sigma2betaw">sigma2betaW</code></td>
<td>
<p>the prior variance of the random walk model used for smoothing which can be
specified with a single postive scalar or with two positive scalars representing the shape <code>a</code>
and the rate <code>b</code> parameter of the inverse gamma distribution.</p>
</td></tr>
<tr><td><code id="EffFlexi_+3A_smooth">smooth</code></td>
<td>
<p>used for smoothing data for this efficacy model. That is either the &quot;RW1&quot;, the 
first-order random walk model or &quot;RW2&quot;, the second-order random walk model is used of the mean
efficacy responses.</p>
</td></tr>
<tr><td><code id="EffFlexi_+3A_data">data</code></td>
<td>
<p>the input data to update estimates of model parameters and 
follow the <code><a href="#topic+DataDual-class">DataDual</a></code> object class specification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class object
</p>

<hr>
<h2 id='EffFlexi-class'>Class for the efficacy model in flexible form for prior expressed in form of pseudo data</h2><span id='topic+EffFlexi-class'></span><span id='topic+.EffFlexi'></span>

<h3>Description</h3>

<p>This is a class where a flexible form is used to describe the realtionship between the efficacy
responses and the dose levels. This flexible form aims to capture different shape for the 
dose-efficacy curve and the mean efficacy responses at each dose level are estimated using MCMC.
In addition, the first (RW1) or second order (RW2) random walk model can be used for smoothing data. That is 
the random walk model is used to model the first or the second order differnece of the mean 
efficacy responses to its neighbouring dose levels of their mean efficacy responses.
The flexible form is specified as 
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{W}\vert\boldsymbol{\beta_w}, \sigma^2 \sim Normal (\mathbf{X}_w \boldsymbol{\beta_w}, \sigma^2 \mathbf{I})</code>
</p>

<p>where <code class="reqn">\mathbf{W}</code> represent the column vector of the efficacy responses, <code class="reqn">\boldsymbol{\beta_w}</code>
is th column vector of the mean efficacy responses for all dose levels, <code class="reqn">\mathbf{X_w}</code> is the 
design matrix with entries <code class="reqn">I_{i(j)}</code> which gives a value 1 if subject i is allocated to 
dose j. The <code class="reqn">\sigma^2</code> (sigma2) is the variance of the efficacy responses which can be either fixed or from
an inverse gamma distribution.
</p>


<h3>Details</h3>

<p>The RW1 model is given as 
</p>
<p style="text-align: center;"><code class="reqn">\beta_{W,(j)} - \beta_{W,(j-1)} \sim Normal(0, \sigma^{2}_{\beta_{W}})</code>
</p>

<p>where <code class="reqn">\beta_{W,(j)}</code> is the mean efficacy responses at dose j
For the RW2 is given as 
</p>
<p style="text-align: center;"><code class="reqn">\beta_{W,(j-2)} - 2 \beta_{W,(j-1)} + \beta_{W,(j)} \sim Normal(0, \sigma^{2}_{\beta_{W}})</code>
</p>

<p>The variance parameter <code class="reqn">\sigma^{2}_{\beta_{W}}</code>. The variance <code class="reqn">\sigma^{2}_{\beta_{W}}</code> 
(sigma2betaW) will be the same at all dose levels and can
either be fixed or assigned an inverse gamma prior distribution.
</p>
<p>The <code>Eff</code> and <code>Effdose</code> are the pseduo efficacy responses and dose levels at which these 
pseudo efficacy responses are observed at. (see more details for <code><a href="#topic+Effloglog-class">Effloglog</a></code> class)
<code>Eff</code> and <code>Effdose</code> must be vector of at least length 2. The values or elements in vectors
<code>Eff</code> or <code>Effdose</code> must put in the same position with its corresponding value in the other 
vector. The <code>sigma2</code> is the prior variance of the flexible efficacy form. The variance is either specified
with a single scalar value (fixed) or postive scalar value have to be specified for the <code>a</code> shape and 
<code>b</code> slope parameter for th inverse gamme distribtuion. Similarly, <code>sigma2betaW</code> is the prior variance 
of the random walk model which can be specified with a single scalar (fixed) value or specifying positive 
scalar values for the shape <code>a</code> and rate <code>b</code> parameters for the inverse gamma distributions. 
This model will output the updated value or the updated values of the paramters of the inverse gamma
distributions for <code class="reqn">sigma^2</code> (sigma2) and <code class="reqn">\sigma^2_{\beta_W}</code> (sigma2betaW)
</p>


<h3>Slots</h3>


<dl>
<dt><code>Eff</code></dt><dd><p>the pseudo efficacy responses. A vector of at least length 2 with the elements here and its 
corresponding value in <code>Effdose</code> must be specified in the same position. (see dtails above)</p>
</dd>
<dt><code>Effdose</code></dt><dd><p>the dose levels at which the pseudo efficacy responses are observed. This is a vector of at 
least length 2 and the elements here and its corrresponding value in <code>Eff</code> must be specified in the
same postion. (see details from above)</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>the prior variance of the flexible efficacy form. It can be specified with a single positive
scalar or specifying <code>a</code>, the shape and <code>b</code>, the rate parameter of the inverse gamma 
distribution. (see details from above)</p>
</dd>
<dt><code>sigma2betaW</code></dt><dd><p>the prior variance of the random walk model for the mean efficact responses. A single
positve scalar can be specified or specifying <code>a</code>, the shape and <code>b</code>, the rate parameter of 
the inverse gamma distribution (see details from above)</p>
</dd>
<dt><code>useFixed</code></dt><dd><p>a list of with logical value to each of the parameters <code>sigma2</code> and <code>sigma2betaw</code>
indicating whether a fixed value is used or not; this slot is needed for internal purposes and not to
be touched by the user.</p>
</dd>
<dt><code>useRW1</code></dt><dd><p>for specifying the random walk model for the mean efficacy responses; if <code>TRUE</code>, 
first order random walk model is used, otherwise the second-order random walk model.</p>
</dd>
<dt><code>designW</code></dt><dd><p>is the design matrix for the efficacy responses. If only the pseudo efficacy responses 
are used, this will be the design matrix of the pseudo efficacy responses. If there are some observed
efficacy responses available. It will be the design matrix based on both the pseudo and the observed
efficacy responses.</p>
</dd>
<dt><code>RWmat</code></dt><dd><p>is the the difference matrix for the random walk model. This slot is needed for internal 
purposes and not to be touched by the user.</p>
</dd>
<dt><code>RWmatRank</code></dt><dd><p>is the rank of the difference matrix. This slot is needed for internal purposes and not
to be touched by the user.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Obtain prior estimates for the EffFlexi (efficacy model) given the pseudo data.
##First define an empty data set by only define the dose levels used in the study
## 12 dose levels are usesd from 25 to 300 mg with increments of 25.
emptydata&lt;-DataDual(doseGrid=seq(25,300,25))
data&lt;-emptydata
## define the pseudo data as first fixed 2 dose levels 25 and 300 mg and 
## specified in (Effdose slot).
## Then the efficacy responses observed at these two dose levels are 1.223 and 2.513 and 
## specified in (Eff slot).
## The prior variance of the pseudo efficay responses. This can be either a fixed value of 
## specifying the shape (a) and the rate (b) parameters for the inverse gamma distribution 
## in (sigma2 slot). The prior variance of the random walk model which can be a fixed value or 
## two value for the shape (a) and rate (b) parameter of the inverse gamma distribution in 
## (sigma2betaW slot). The data are specified in (data slot)


Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),
                    smooth="RW2",data=data)

##Obtain estimates from the model given some observed responses
## first specified the data
data&lt;-DataDual(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25))

Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),
                    smooth="RW2",data=data)

</code></pre>

<hr>
<h2 id='Effloglog'>Initialization function for the &quot;Effloglog&quot; class</h2><span id='topic+Effloglog'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;Effloglog&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Effloglog(Eff, Effdose, nu, data, c = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Effloglog_+3A_eff">Eff</code></td>
<td>
<p>the pseudo efficacy responses</p>
</td></tr>
<tr><td><code id="Effloglog_+3A_effdose">Effdose</code></td>
<td>
<p>the corresponding dose levels for the pseudo efficacy responses</p>
</td></tr>
<tr><td><code id="Effloglog_+3A_nu">nu</code></td>
<td>
<p>the precision (inverse of the variance) of the efficacy responses</p>
</td></tr>
<tr><td><code id="Effloglog_+3A_data">data</code></td>
<td>
<p>the input data of <code><a href="#topic+DataDual-class">DataDual</a></code> class to update model estimates</p>
</td></tr>
<tr><td><code id="Effloglog_+3A_c">c</code></td>
<td>
<p>the constant value added to the dose level when the dose level value is less than or
equal to 1 and a special form of the linear log-log has to applied (Yeung et al. (2015).).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+Effloglog-class">Effloglog</a></code> object
</p>

<hr>
<h2 id='Effloglog-class'>Class for the linear log-log efficacy model using pseudo data prior</h2><span id='topic+Effloglog-class'></span><span id='topic+.Effloglog'></span>

<h3>Description</h3>

<p>This is the efficacy model which describe the relationship of the continuous efficacy responses and 
the dose levels. More specifically, this is a model to describe the linear relationship between the 
continuous efficacy responses and its coressponding dose level in log-log scale. 
The efficacy log-log model is given as 
</p>
<p style="text-align: center;"><code class="reqn">y_i=\theta_1 +theta_2 log(log(d_i))+\epsilon_i</code>
</p>

<p>where <code class="reqn">y_i</code> is the efficacy responses
for subject i, <code class="reqn">d_i</code> is the dose level treated for subject i and <code class="reqn">\epsilon_i</code> is the random error 
term of efficacy model at subject i such that <code class="reqn">\epsilon_i</code> has a normal distribution of mean 0 and 
variance <code class="reqn">\sigma^2=\nu^{-1}</code>. This variance is assumed to be the same for all subjects.
</p>


<h3>Details</h3>

<p>There are three parameters in this model which is to intercept <code class="reqn">\theta_1</code>, the slope <code class="reqn">\theta_2</code> 
and the precision <code class="reqn">\nu</code> of the efficay responses.
It inherit all slots from <code><a href="#topic+ModelEff-class">ModelEff</a></code>
</p>
<p>The prior of this model is specified in form of pseudo data. First at least two dose levels are fixed.
Then ask for experts' opinion about the efficacy values that can be obtained at each of the dose levels
if one subject is treated at each of these dose levels. The prior modal estimates (same as the maximum 
likelihood estimates) can be obtained for the intercept and slope paramters in this model.
</p>
<p>The <code>Eff</code> and <code>Effdose</code> are used to represent the prior in form of the pseudo data. 
The <code>Eff</code> represents the pseudo scalar efficacy values. The <code>Effdose</code> represents the dose levels
at which these pseudo efficacy values are observed. These pseudo efficay values are always specified by
assuming one subject are treated in each of the dose levels. Since at least 2 pseudo efficacy values are 
needed to obtain modal estimates of the intercept and slope parameters, both <code>Eff</code> and <code>Effdose</code>
must be vector of at least length 2. The position of the values or elements specified in <code>Eff</code> or
<code>Effdose</code> must be corresponds to the same elements or values in the other vector.
</p>
<p>The <code>nu</code> represents the prior presion <code class="reqn">\nu</code> of the pseudo efficacy responses. It is also known as the inverse 
of the variance of the pseduo efficacy responses. The precision can be a fixed constant or having a gamma
distribution. Therefore, single scalar value, a fixed 
value of the precision can be specified. If not, two positive scalar values must be specified as the 
shape and rate parameter of the gamma distribution. If there are some observed efficacy responses available,
in the output, <code>nu</code> will display the updated value of the precision or the updated values for the 
parameters of the gamma distribution.
</p>
<p>Given the variance of the pseudo efficacy responses, the joint prior distribution of the intercept <code class="reqn">\theta_1</code>
(theta1) and the slope <code class="reqn">\theta_2</code> (theta2) of this model is a bivariate normal distribution. 
A conjugate posterior joint distribution is also used for theta1 and theta2. The joint prior bivariate 
normal distribution has 
mean <code class="reqn">\boldsymbol\mu_0</code> and covariance matrix <code class="reqn">(\nu \mathbf{Q}_0)^{-1}</code>. <code class="reqn">\boldsymbol\mu_0</code> is a 
<code class="reqn">2 \times 1</code>
column vector contains the prior modal estimates of the intercept (theta1) and the slope (theta2). Based on 
<code class="reqn">r</code> for <code class="reqn">r \geq 2</code> pseudo efficacy responses specified, <code class="reqn">\mathbf{X}_0</code> will be the 
<code class="reqn">r \times 2</code> design matrix 
obtained for these pseudo efficacy responses. the matrix <code class="reqn">\mathbf{Q}_0</code> will be calculated by 
<code class="reqn">\mathbf{Q}_0=\mathbf{X}_0 \mathbf{X}^T_0</code> where <code class="reqn">\nu</code> is the precision of the pseudo efficacy responses.
For the joint posterior bivariate distribution, we have <code class="reqn">\boldsymbol{\mu}</code> as the mean and 
<code class="reqn">(\nu\mathbf{Q}_0)^{-1}</code> as the covariance matrix. Here, <code class="reqn">\boldsymbol\mu</code> is the column vector containing the 
posterior modal estimates
of the intercept (theta1) and the slope (theta2). The design matrix <code class="reqn">\mathbf{X}</code> obtained based only on 
observed efficacy responses will give <code class="reqn">\mathbf{Q}=\mathbf{X}\mathbf{X}^T</code> with <code class="reqn">\nu</code> as the precision of 
the observed efficay responses. If no observed efficay responses are availble (i.e only pseudo 
efficay responses are used), the <code>vecmu</code>, <code>matX</code>, <code>matQ</code> and <code>vecY</code> represents 
<code class="reqn">\boldsymbol\mu_0</code>, <code class="reqn">\mathbf{X}_0</code>, <code class="reqn">\mathbf{Q}_0</code> and the column vector of pseudo efficay responses,
respectively. If there are some observed efficacy responses, <code>vecmu</code>, <code>matX</code>, <code>matQ</code> 
and <code>vecY</code> will represent <code class="reqn">\boldsymbol\mu</code>, <code class="reqn">\mathbf{X}</code>, <code class="reqn">\mathbf{Q}</code> and the column vector contains
all observed efficacy responses, respectively. (see details in about the form of prior and posterior distribution)
</p>


<h3>Slots</h3>


<dl>
<dt><code>Eff</code></dt><dd><p>the pseudo efficacy response, the scalar efficacy values. This must be a vector of at least 
length 2. Each element or value here must represents responses treated based on one subject. The order
of its elements must corresponds to the values presented in vector <code>Effdose</code> (see details above)</p>
</dd>
<dt><code>Effdose</code></dt><dd><p>the pseudo efficacy dose level. This is the dose levels at which the pseudo efficacy 
responses are observed at. This must be a vector of at least length 2 and the orde of its elements must
corresponds to values presented in vector <code>Eff</code> (see detial above)</p>
</dd>
<dt><code>nu</code></dt><dd><p>refers to the prior precision of pseudo efficacy responses. This is either a fixed value or a 
vector of elements <code>a</code>, a positive scalar for the shape parameter, and <code>b</code>, a positive scalar 
for the rate parameter for the gamma dsitribution. (see detail from above)</p>
</dd>
<dt><code>useFixed</code></dt><dd><p>a logical value if <code>nu</code> specified is a fixed value or not. This slot is needed for 
internal purposes and not to be touched by the user.</p>
</dd>
<dt><code>theta1</code></dt><dd><p>The intercept <code class="reqn">\theta_1</code> parameter of this efficacy log-log model. This slot is used in output to display
the resulting prior or posterior modal estimates obtained based on the pseudo data and (if any) the 
observed data/ responses.</p>
</dd>
<dt><code>theta2</code></dt><dd><p>The slope <code class="reqn">theta_2</code> parameter of the efficacy log-lgo model. This slot is used in output to display 
the resulting prior or posterior modal estimates obtained based on the pseudo data and (if any) the 
observed data/ responses.</p>
</dd>
<dt><code>Pcov</code></dt><dd><p>refers to the covariance matrix of the intercept (phi1) and slope (phi2) paramters of this model.
This slot is used in output to display the covariance matrix obtained based on the pseudo data and (if any)
the observed data/responses. This slot is needed for internal purposes.</p>
</dd>
<dt><code>vecmu</code></dt><dd><p>is the column vector of the prior or the posterior modal estimates of the intercept (phi1) and 
the slope (phi2).
This slot is used in output to display as the mean of the prior or posterior bivariate normal distribtuion
for phi1 and phi2. (see details from above)</p>
</dd>
<dt><code>matX</code></dt><dd><p>is the design matrix based on either the pseudo or all observed efficacy response. This is used in 
output to display the design matrix for the pseudo or the observed efficacy responses (see details from above)</p>
</dd>
<dt><code>matQ</code></dt><dd><p>is the square matrix of multiplying the the design matrix with its transponse. This is represented 
either using the only the pseudo efficay responses or only with the observed efficacy responses. This is display 
in the output (see details from above)</p>
</dd>
<dt><code>vecY</code></dt><dd><p>is the column vector either contains the pseudo efficay responses or all the observed efficacy 
responses. This is used in output to display the pseudo or observed efficacy responses (see detail from above)</p>
</dd>
<dt><code>c</code></dt><dd><p>is a constant value greater or equal to 0, with the default 0 leading
to the model form described above. In general, the model has the form
<code class="reqn">y_i=\theta_1 +theta_2 log(log(d_i + c))+\epsilon_i</code>, such that dose levels
greater than <code class="reqn">1-c</code> can be considered as described in Yeung et al. (2015).</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Obtain prior modal estimates for the Effloglog model (efficacy model) given the pseudo data.
##First define an empty data set by only define the dose levels used in the study,
## 12 dose levels are usesd from 25 to 300 mg with increments of 25.
emptydata&lt;-DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
data&lt;-emptydata
## define the pseudo data as first fixed 2 dose levels 25 and 300 mg and specified in 
## (Effdose slot).
## Then the efficacy responses observed at these two dose levels are 1.223 and 2.513 and 
## specified in (Eff slot).
## The prior precision of the pseudo efficay responses. This can be either a fixed value of 
## specifying the shape (a) and the rate (b) parameters for the gamma distribution in (nu slot).
## Then specify all data currentl available in (data slot).

Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)

##Obtain posterior modal estimates and other estimates from the model given some observed responses
## If there is some observations available
## first specified the data
data&lt;-DataDual(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25))

Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data)


</code></pre>

<hr>
<h2 id='examine'>Obtain hypothetical trial course table for a design</h2><span id='topic+examine'></span><span id='topic+examine+2CDesign-method'></span><span id='topic+examine+2CRuleDesign-method'></span>

<h3>Description</h3>

<p>This generic function takes a design and generates a dataframe
showing the beginning of several hypothetical trial courses under
the design. This means, from the generated dataframe one can read off:
- how many cohorts are required in the optimal case (no DLTs observed) in
order to reach the highest dose of the specified dose grid (or until
the stopping rule is fulfilled)
- assuming no DLTs are observed until a certain dose level, what the next
recommended dose is for all possible number of DLTs observed
- the actual relative increments that will be used in these cases
- whether the trial would stop at a certain cohort
Examining the &quot;single trial&quot; behavior of a dose escalation design is
the first important step in evaluating a design, and cannot be replaced by
studying solely the operating characteristics in &quot;many trials&quot;. The cohort
sizes are also taken from the design, assuming no DLTs occur until the dose
listed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>examine(object, ..., maxNoIncrement = 100L)

## S4 method for signature 'Design'
examine(object, mcmcOptions = McmcOptions(), ..., maxNoIncrement)

## S4 method for signature 'RuleDesign'
examine(object, ..., maxNoIncrement = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="examine_+3A_object">object</code></td>
<td>
<p>the design (<code><a href="#topic+Design-class">Design</a></code> or
<code><a href="#topic+RuleDesign-class">RuleDesign</a></code> object) we want to examine</p>
</td></tr>
<tr><td><code id="examine_+3A_...">...</code></td>
<td>
<p>additional arguments (see methods)</p>
</td></tr>
<tr><td><code id="examine_+3A_maxnoincrement">maxNoIncrement</code></td>
<td>
<p>maximum number of contiguous next doses at 0 
DLTs that are the same as before, i.e. no increment (default to 100)</p>
</td></tr>
<tr><td><code id="examine_+3A_mcmcoptions">mcmcOptions</code></td>
<td>
<p>object of class <code><a href="#topic+McmcOptions-class">McmcOptions</a></code>,
giving the MCMC options for each evaluation in the trial. By default,
the standard options are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>examine(Design)</code>: Examine a model-based CRM
</p>
</li>
<li> <p><code>examine(RuleDesign)</code>: Examine a rule-based design
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25))

# Initialize the CRM model 
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)
myStopping &lt;- (myStopping1 &amp; myStopping2) | myStopping3

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- Design(model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 data=emptydata,
                 startingDose=3)

# Examine the design
set.seed(4235)
# MCMC parameters are set to small values only to show this example. They should be
# increased for a real case.
options &lt;- McmcOptions(burnin=10,step=1,samples=20)
examine(design, options)
  
## example where examine stops because stopping rule already fulfilled
myStopping4 &lt;- StoppingMinPatients(nPatients=3)
myStopping &lt;- (myStopping1 &amp; myStopping2) | myStopping4
design &lt;- Design(model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 data=emptydata,
                 startingDose=3)
examine(design,mcmcOptions=options)

## example where examine stops because infinite looping
## (note that here a very low threshold is used for the parameter
## "maxNoIncrement" in "examine" to keep the execution time short)
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.00001))
myStopping &lt;- (myStopping1 &amp; myStopping2) 
design &lt;- Design(model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 data=emptydata,
                 startingDose=3)
examine(design, mcmcOptions=options, maxNoIncrement = 2)

# Define the dose-grid
emptydata &lt;- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))

# inizialing a 3+3 design with constant cohort size of 3 and
# starting dose equal 5
myDesign &lt;- RuleDesign(nextBest = NextBestThreePlusThree(),
                       cohortSize = CohortSizeConst(size=3L),
                       data = emptydata,
                       startingDose = 5)
  
# Examine the design
set.seed(4235)
examine(myDesign)
</code></pre>

<hr>
<h2 id='ExpEff'>Compute the expected efficacy based on a given dose, a given pseudo Efficacy log-log model and a given 
efficacy sample</h2><span id='topic+ExpEff'></span><span id='topic+ExpEff+2Cnumeric+2CEffloglog+2CSamples-method'></span><span id='topic+ExpEff+2Cnumeric+2CEffloglog+2Cmissing-method'></span><span id='topic+ExpEff+2Cnumeric+2CEffFlexi+2CSamples-method'></span>

<h3>Description</h3>

<p>Compute the expected efficacy based on a given dose, a given pseudo Efficacy log-log model and a given 
efficacy sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpEff(dose, model, samples, ...)

## S4 method for signature 'numeric,Effloglog,Samples'
ExpEff(dose, model, samples, ...)

## S4 method for signature 'numeric,Effloglog,missing'
ExpEff(dose, model, samples, ...)

## S4 method for signature 'numeric,EffFlexi,Samples'
ExpEff(dose, model, samples, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpEff_+3A_dose">dose</code></td>
<td>
<p>the dose</p>
</td></tr>
<tr><td><code id="ExpEff_+3A_model">model</code></td>
<td>
<p>the <code><a href="#topic+Effloglog-class">Effloglog</a></code> class object</p>
</td></tr>
<tr><td><code id="ExpEff_+3A_samples">samples</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> class object 
(can also be missing)</p>
</td></tr>
<tr><td><code id="ExpEff_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>ExpEff(dose = numeric, model = Effloglog, samples = Samples)</code>: Method for the Effloglog class
</p>
</li>
<li> <p><code>ExpEff(dose = numeric, model = Effloglog, samples = missing)</code>: Compute the Expected Efficacy based a given dose and a given Pseudo Efficacy log log model without
samples
</p>
</li>
<li> <p><code>ExpEff(dose = numeric, model = EffFlexi, samples = Samples)</code>: Compute the Expected Efficacy based a given dose, Efficacy 
Flexible model with samples
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>##Obtain the expected efficacy value for a given dose, a given pseudo 
## efficacy model and a given efficacy sample
##The efficacy model must be from 'ModelEff' class (model slot)
##The efficacy sample must be from 'Samples' class (sample slot)
emptydata&lt;-DataDual(doseGrid=seq(25,300,25))
data&lt;-emptydata
model&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                 sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
set.seed(94)
samples&lt;-mcmc(data=data,model=model,options=options)
## Given the dose 75 (dose slot)
ExpEff(dose=75,model=model,samples=samples)
##Obtain the expected efficacy value for a given dose and a given pseudo efficacy model 

##The efficacy model must be from 'ModelEff' class (model slot)
emptydata&lt;-DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
data&lt;-emptydata

model&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)


## Given the dose 75 (dose slot)
ExpEff(dose=75,model=model)
##Obtain the expected efficacy value for a given dose, the 'EffFlexi' efficacy model and 
##samples generated from this efficacy model
##The efficacy model must be from 'EffFlexi' class (model slot)
##The efficacy samples must be from 'Samples' class (samples slot)
model&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                 sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)
set.seed(94)
samples&lt;-mcmc(data=data,model=model,options=options)
## Given the dose 75 (dose slot)
ExpEff(dose=75,model=model,samples=samples)
</code></pre>

<hr>
<h2 id='fit'>Fit method for the Samples class</h2><span id='topic+fit'></span><span id='topic+fit+2CSamples+2CModel+2CData-method'></span><span id='topic+fit+2CSamples+2CDualEndpoint+2CDataDual-method'></span><span id='topic+fit+2CSamples+2CLogisticIndepBeta+2CData-method'></span><span id='topic+fit+2CSamples+2CEffloglog+2CDataDual-method'></span><span id='topic+fit+2CSamples+2CEffFlexi+2CDataDual-method'></span>

<h3>Description</h3>

<p>Note this new generic function is necessary because the <code><a href="stats.html#topic+fitted">fitted</a></code>
function only allows the first argument <code>object</code> to appear in the
signature. But we need also other arguments in the signature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(object, model, data, ...)

## S4 method for signature 'Samples,Model,Data'
fit(
  object,
  model,
  data,
  points = data@doseGrid,
  quantiles = c(0.025, 0.975),
  middle = mean,
  ...
)

## S4 method for signature 'Samples,DualEndpoint,DataDual'
fit(object, model, data, quantiles = c(0.025, 0.975), middle = mean, ...)

## S4 method for signature 'Samples,LogisticIndepBeta,Data'
fit(
  object,
  model,
  data,
  points = data@doseGrid,
  quantiles = c(0.025, 0.975),
  middle = mean,
  ...
)

## S4 method for signature 'Samples,Effloglog,DataDual'
fit(
  object,
  model,
  data,
  points = data@doseGrid,
  quantiles = c(0.025, 0.975),
  middle = mean,
  ...
)

## S4 method for signature 'Samples,EffFlexi,DataDual'
fit(
  object,
  model,
  data,
  points = data@doseGrid,
  quantiles = c(0.025, 0.975),
  middle = mean,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="fit_+3A_model">model</code></td>
<td>
<p>the <code><a href="#topic+Model-class">Model</a></code> object</p>
</td></tr>
<tr><td><code id="fit_+3A_data">data</code></td>
<td>
<p>the <code><a href="#topic+Data-class">Data</a></code> object</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="fit_+3A_points">points</code></td>
<td>
<p>at which dose levels is the fit requested? default is the dose
grid</p>
</td></tr>
<tr><td><code id="fit_+3A_quantiles">quantiles</code></td>
<td>
<p>the quantiles to be calculated (default: 0.025 and
0.975)</p>
</td></tr>
<tr><td><code id="fit_+3A_middle">middle</code></td>
<td>
<p>the function for computing the middle point. Default:
<code><a href="base.html#topic+mean">mean</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data frame with required information (see method details)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fit(object = Samples, model = Model, data = Data)</code>: This method returns a data frame with dose, middle, lower
and upper quantiles for the dose-toxicity curve
</p>
</li>
<li> <p><code>fit(object = Samples, model = DualEndpoint, data = DataDual)</code>: This method returns a data frame with dose, and middle,
lower and upper quantiles, for both the dose-tox and dose-biomarker (suffix
&quot;Biomarker&quot;) curves, for all grid points (Note that currently only the grid
points can be used, because the DualEndpointRW models only allow that)
</p>
</li>
<li> <p><code>fit(object = Samples, model = LogisticIndepBeta, data = Data)</code>: This method return a data frame with dose, middle lower and upper quantiles 
for the dose-DLE curve using DLE samples for &ldquo;LogisticIndepBeta&rdquo; model class
</p>
</li>
<li> <p><code>fit(object = Samples, model = Effloglog, data = DataDual)</code>: This method returns a data frame with dose, middle, lower, upper quantiles for 
the dose-efficacy curve using efficacy samples for &ldquo;Effloglog&rdquo; model class
</p>
</li>
<li> <p><code>fit(object = Samples, model = EffFlexi, data = DataDual)</code>: This method returns a data frame with dose, middle, lower and upper 
quantiles for the dose-efficacy curve using efficacy samples for &ldquo;EffFlexi&rdquo; 
model class
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data
data &lt;- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y = c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort = c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid = c(0.1, 0.5, 1.5, 3, 6,
                          seq(from = 10, to = 80, by=2)))

# Initialize a model 
model &lt;- LogisticLogNormal(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 56)

# Get posterior for all model parameters
options &lt;- McmcOptions(burnin = 100,
                       step = 2,
                       samples = 2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Extract the posterior mean  (and empirical 2.5 and 97.5 percentile)
# for the prob(DLT) by doses
fitted &lt;- fit(object = samples,
              model = model,
              data = data,
              quantiles=c(0.025, 0.975),
              middle=mean)


# ----------------------------------------------
# A different example using a different model
## we need a data object with doses &gt;= 1:
data&lt;-Data(x=c(25,50,50,75,150,200,225,300),
           y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(from=25,to=300,by=25))


model &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                           DLEweights=c(3,3),
                           DLEdose=c(25,300),
                           data=data)
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=200)
## samples must be from 'Samples' class (object slot in fit)
samples &lt;- mcmc(data,model,options)

fitted &lt;- fit(object=samples, model=model, data=data)



# Create some data
data &lt;- DataDual(
  x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,
      20, 20, 20, 40, 40, 40, 50, 50, 50),
  y=c(0, 0, 0, 0, 0, 0, 1, 0,
      0, 1, 1, 0, 0, 1, 0, 1, 1),
  w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,
      0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),
  doseGrid=c(0.1, 0.5, 1.5, 3, 6,
             seq(from=10, to=80, by=2)))

# Initialize the Dual-Endpoint model (in this case RW1)
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth = "RW1")

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=500)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Extract the posterior mean  (and empirical 2.5 and 97.5 percentile)
# for the prob(DLT) by doses and the Biomarker by doses
fitted &lt;- fit(object = samples,
              model = model,
              data = data,
              quantiles=c(0.025, 0.975),
              middle=mean)
##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-DLE curve
## at all dose levels using a DLE sample, a DLE model and the data
## samples must be from 'Samples' class (object slot)
## we need a data object with doses &gt;= 1:
data&lt;-Data(x=c(25,50,50,75,150,200,225,300),
           y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(from=25,to=300,by=25))
## model must be from 'Model' or 'ModelTox' class e.g using 'LogisticIbdepBeta' model class
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##options for MCMC
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
## samples must be from 'Samples' class (object slot in fit)
samples&lt;-mcmc(data,model,options)

fit(object=samples, model=model,data=data)
##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-efficacy curve
## at all dose levels using an efficacy sample, a pseudo efficacy model and the data
## data must be from 'DataDual' class
data&lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
               y=c(0,0,0,0,0,1,1,0),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25),
               placebo=FALSE)
## model must be from 'ModelEff' e.g using 'Effloglog' class
Effmodel&lt;-Effloglog(c(1.223,2.513),c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
## samples must be from 'Samples' class (object slot in fit)
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
Effsamples &lt;- mcmc(data=data,model=Effmodel,options=options)
fit(object=Effsamples, model=Effmodel,data=data)
##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-efficacy curve
## at all dose levels using an efficacy sample, the 'EffFlexi' efficacy model and the data
## data must be from 'DataDual' class
data&lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
               y=c(0,0,0,0,0,1,1,0),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25),
               placebo=FALSE)
## model must be from 'ModelEff' e.g using 'Effloglog' class
Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)

## samples must be from 'Samples' class (object slot in fit)
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
Effsamples &lt;- mcmc(data=data,model=Effmodel,options=options)
fit(object=Effsamples, model=Effmodel,data=data)
</code></pre>

<hr>
<h2 id='fitGain'>Get the fiited values for the gain values at all dose levels based on 
a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample 
and data. This method returns a data frame with dose, middle, lower and upper quantiles 
of the gain value samples</h2><span id='topic+fitGain'></span><span id='topic+fitGain+2CModelTox+2CSamples+2CModelEff+2CSamples+2CDataDual-method'></span>

<h3>Description</h3>

<p>Get the fiited values for the gain values at all dose levels based on 
a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample 
and data. This method returns a data frame with dose, middle, lower and upper quantiles 
of the gain value samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)

## S4 method for signature 'ModelTox,Samples,ModelEff,Samples,DataDual'
fitGain(
  DLEmodel,
  DLEsamples,
  Effmodel,
  Effsamples,
  data,
  points = data@doseGrid,
  quantiles = c(0.025, 0.975),
  middle = mean,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGain_+3A_dlemodel">DLEmodel</code></td>
<td>
<p>the DLE pseudo model of <code><a href="#topic+ModelTox-class">ModelTox</a></code> class object</p>
</td></tr>
<tr><td><code id="fitGain_+3A_dlesamples">DLEsamples</code></td>
<td>
<p>the DLE samples of <code><a href="#topic+Samples-class">Samples</a></code> class object</p>
</td></tr>
<tr><td><code id="fitGain_+3A_effmodel">Effmodel</code></td>
<td>
<p>the efficacy pseudo model of <code><a href="#topic+ModelEff-class">ModelEff</a></code> class object</p>
</td></tr>
<tr><td><code id="fitGain_+3A_effsamples">Effsamples</code></td>
<td>
<p>the efficacy samples of <code><a href="#topic+Samples-class">Samples</a></code> class object</p>
</td></tr>
<tr><td><code id="fitGain_+3A_data">data</code></td>
<td>
<p>the data input of <code><a href="#topic+DataDual-class">DataDual</a></code> class object</p>
</td></tr>
<tr><td><code id="fitGain_+3A_...">...</code></td>
<td>
<p>additional arguments for methods</p>
</td></tr>
<tr><td><code id="fitGain_+3A_points">points</code></td>
<td>
<p>at which dose levels is the fit requested? default is the dose
grid</p>
</td></tr>
<tr><td><code id="fitGain_+3A_quantiles">quantiles</code></td>
<td>
<p>the quantiles to be calculated (default: 0.025 and
0.975)</p>
</td></tr>
<tr><td><code id="fitGain_+3A_middle">middle</code></td>
<td>
<p>the function for computing the middle point. Default:
<code><a href="base.html#topic+mean">mean</a></code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>fitGain(
  DLEmodel = ModelTox,
  DLEsamples = Samples,
  Effmodel = ModelEff,
  Effsamples = Samples,
  data = DataDual
)</code>: This method returns a data frame with dose, middle, lower, upper quantiles for 
the gain values obtained given the DLE and the efficacy samples
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>##Obtain the 'fitGain' the middle, uppper and lower quantiles for the samples of gain values
## at all dose levels using a pseudo DLE model, a DLE sample, a pseudo Efficacy model and
## a efficacy sample
## data must be from 'DataDual' class
data&lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
               y=c(0,0,0,0,0,1,1,0),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25),
               placebo=FALSE)
## DLE model must be from 'ModelTox' class e.g using 'LogisticIndepBeta' model
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

## Efficacy model must be from 'ModelEff' class e.g using 'Effloglog' model
Effmodel&lt;-Effloglog(c(1.223,2.513),c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
## samples must be from 'Samples' class (object slot in fit)
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
##set up the same data set in class 'Data' for MCMC sampling for DLE
data1 &lt;- Data(x=data@x,y=data@y,doseGrid=data@doseGrid)

DLEsamples &lt;- mcmc(data=data1,model=DLEmodel,options=options)
Effsamples &lt;- mcmc(data=data,model=Effmodel,options=options)

fitGain(DLEmodel=DLEmodel,DLEsamples=DLEsamples,
        Effmodel=Effmodel, Effsamples=Effsamples,data=data)
</code></pre>

<hr>
<h2 id='gain'>Compute the gain value with a given dose level, given a pseudo DLE model, a DLE sample, 
a pseudo Efficacy log-log model and a Efficacy sample</h2><span id='topic+gain'></span><span id='topic+gain+2Cnumeric+2CModelTox+2CSamples+2CEffloglog+2CSamples-method'></span><span id='topic+gain+2Cnumeric+2CModelTox+2CSamples+2CEffFlexi+2CSamples-method'></span><span id='topic+gain+2Cnumeric+2CModelTox+2Cmissing+2CEffloglog+2Cmissing-method'></span>

<h3>Description</h3>

<p>Compute the gain value with a given dose level, given a pseudo DLE model, a DLE sample, 
a pseudo Efficacy log-log model and a Efficacy sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gain(dose, DLEmodel, DLEsamples, Effmodel, Effsamples, ...)

## S4 method for signature 'numeric,ModelTox,Samples,Effloglog,Samples'
gain(dose, DLEmodel, DLEsamples, Effmodel, Effsamples, ...)

## S4 method for signature 'numeric,ModelTox,Samples,EffFlexi,Samples'
gain(dose, DLEmodel, DLEsamples, Effmodel, Effsamples, ...)

## S4 method for signature 'numeric,ModelTox,missing,Effloglog,missing'
gain(dose, DLEmodel, DLEsamples, Effmodel, Effsamples, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gain_+3A_dose">dose</code></td>
<td>
<p>the dose</p>
</td></tr>
<tr><td><code id="gain_+3A_dlemodel">DLEmodel</code></td>
<td>
<p>the <code><a href="#topic+ModelTox-class">ModelTox</a></code> object</p>
</td></tr>
<tr><td><code id="gain_+3A_dlesamples">DLEsamples</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object (can also be missing)</p>
</td></tr>
<tr><td><code id="gain_+3A_effmodel">Effmodel</code></td>
<td>
<p>the <code><a href="#topic+Effloglog-class">Effloglog</a></code> or the <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> object</p>
</td></tr>
<tr><td><code id="gain_+3A_effsamples">Effsamples</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object (can also be missing)</p>
</td></tr>
<tr><td><code id="gain_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>gain(
  dose = numeric,
  DLEmodel = ModelTox,
  DLEsamples = Samples,
  Effmodel = EffFlexi,
  Effsamples = Samples
)</code>: Compute the gain given a dose level, a pseduo DLE model, a DLE sample, 
the pseudo EffFlexi model and an Efficacy sample
</p>
</li>
<li> <p><code>gain(
  dose = numeric,
  DLEmodel = ModelTox,
  DLEsamples = missing,
  Effmodel = Effloglog,
  Effsamples = missing
)</code>: Compute the gain value given a dose level, a pseudo DLE model and a pseudo
efficacy model of <code><a href="#topic+Effloglog-class">Effloglog</a></code> class object without DLE and the efficacy sample
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>##Obtain the gain value for a given dose, a pseudo DLE model, a DLE sample, 
## a pseudo efficacy model and an efficacy sample
##The DLE model must be from 'ModelTox' class (DLEmodel slot)
emptydata&lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
data&lt;-emptydata
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
DLEsamples &lt;- mcmc(data, DLEmodel, McmcOptions(burnin=100,step=2,samples=200))

##The efficacy model must be from 'ModelEff' class (Effmodel slot)
## The DLE and efficayc samples must be from 'Samples' class (DLEsamples and Effsamples slot)
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
Effsamples &lt;- mcmc(data, Effmodel, McmcOptions(burnin=100,step=2,samples=200))

## Given a dose level 75,
gain(dose=75,DLEmodel=DLEmodel,DLEsamples=DLEsamples,Effmodel=Effmodel,Effsamples=Effsamples)
##Obtain the gain value for a given dose, a pseudo DLE model, a DLE sample, 
## the 'EffFlexi' efficacy model and an efficacy sample
##The DLE model must be from 'ModelTox' class (DLEmodel slot)
emptydata&lt;- DataDual(doseGrid=seq(25,300,25))
data&lt;-emptydata
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
DLEsamples &lt;- mcmc(data, DLEmodel, McmcOptions(burnin=100,step=2,samples=200))

##The efficacy model must be from 'EffFlexi' class (Effmodel slot)
## The DLE and efficayc samples must be from 'Samples' class (DLEsamples and Effsamples slot)
EffFleximodel &lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                     sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)
Effsamples &lt;- mcmc(data, EffFleximodel, McmcOptions(burnin=100,step=2,samples=200))

## Given a dose level 75,
gain(dose=75,DLEmodel=DLEmodel,DLEsamples=DLEsamples,Effmodel=EffFleximodel,Effsamples=Effsamples)
##Obtain the gain value for a given dose, a pseudo DLE model and  a pseudo efficacy model
## without samples
##The DLE model must be from 'ModelTox' class (DLEmodel slot)
emptydata&lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
data&lt;-Data(doseGrid=seq(25,300,25),placebo=FALSE)

DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##The efficacy model must be from 'Effloglog' class  (Effmodel slot)
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=emptydata,c=0)
## Given a dose level 75,
gain(dose=75,DLEmodel=DLEmodel,Effmodel=Effmodel)
</code></pre>

<hr>
<h2 id='GeneralData-class'>Class for general data input</h2><span id='topic+GeneralData-class'></span><span id='topic+.GeneralData'></span>

<h3>Description</h3>

<p>Class for general data input
</p>


<h3>Slots</h3>


<dl>
<dt><code>ID</code></dt><dd><p>unique patient IDs (integer vector)</p>
</dd>
<dt><code>cohort</code></dt><dd><p>the cohort indices (sorted values from 0, 1, 2, ...)</p>
</dd>
<dt><code>nObs</code></dt><dd><p>number of observations</p>
</dd>
</dl>

<hr>
<h2 id='GeneralModel-class'>No Intitialization function for this
General class for model input</h2><span id='topic+GeneralModel-class'></span><span id='topic+.GeneralModel'></span>

<h3>Description</h3>

<p>This is the general model class, from which all other specific models for 
involving BUGS (the software) for computing result. 
It inherits all slots from <code><a href="#topic+AllModels-class">AllModels</a></code>
</p>


<h3>Details</h3>

<p>The <code>datamodel</code> must obey the convention that the data input is
called exactly as in the corresponding data class.
All prior distributions for parameters should be contained in the
model function <code>priormodel</code>. The background is that this can
be used to simulate from the prior distribution, before obtaining any
data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>datamodel</code></dt><dd><p>a function representing the BUGS data model specification
(see the details above)</p>
</dd>
<dt><code>priormodel</code></dt><dd><p>a function representing the BUGS prior specification
(see the details above)</p>
</dd>
<dt><code>modelspecs</code></dt><dd><p>a function computing the list of the data model and prior
model specifications that are required for fully specifying them (e.g. prior
parameters, reference dose, etc.), based on the data
slots that are then required as arguments of this function. This will then
be passed to BUGS for the computations.</p>
</dd>
<dt><code>init</code></dt><dd><p>a function computing the list of starting values for parameters
required to be initialized in the MCMC sampler, based on the
data slots that are then required as arguments of this
function</p>
</dd>
<dt><code>sample</code></dt><dd><p>names of all parameters from which you would like to save the
MCMC samples.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Model-class">Model</a></code>
</p>

<hr>
<h2 id='GeneralSimulations'>Initialization function for &quot;GeneralSimulations&quot;</h2><span id='topic+GeneralSimulations'></span>

<h3>Description</h3>

<p>Initialization function for &quot;GeneralSimulations&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneralSimulations(data, doses, seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralSimulations_+3A_data">data</code></td>
<td>
<p>see <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code></p>
</td></tr>
<tr><td><code id="GeneralSimulations_+3A_doses">doses</code></td>
<td>
<p>see <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code></p>
</td></tr>
<tr><td><code id="GeneralSimulations_+3A_seed">seed</code></td>
<td>
<p>see <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code> object
</p>

<hr>
<h2 id='GeneralSimulations-class'>General class for the simulations output</h2><span id='topic+GeneralSimulations-class'></span><span id='topic+.GeneralSimulations'></span>

<h3>Description</h3>

<p>This class captures trial simulations.
</p>


<h3>Details</h3>

<p>Here also the random generator state before starting the simulation is
saved, in order to be able to reproduce the outcome. For this just use
<code><a href="base.html#topic+set.seed">set.seed</a></code> with the <code>seed</code> as argument before running
<code><a href="#topic+simulate+2CDesign-method">simulate,Design-method</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>list of produced <code><a href="#topic+Data-class">Data</a></code> objects</p>
</dd>
<dt><code>doses</code></dt><dd><p>the vector of final dose recommendations</p>
</dd>
<dt><code>seed</code></dt><dd><p>random generator state before starting the simulation</p>
</dd>
</dl>

<hr>
<h2 id='GeneralSimulationsSummary-class'>Class for the summary of general simulations output</h2><span id='topic+GeneralSimulationsSummary-class'></span><span id='topic+.GeneralSimulationsSummary'></span>

<h3>Description</h3>

<p>Note that objects should not be created by users, therefore no
initialization function is provided for this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>target</code></dt><dd><p>target toxicity interval</p>
</dd>
<dt><code>targetDoseInterval</code></dt><dd><p>corresponding target dose interval</p>
</dd>
<dt><code>nsim</code></dt><dd><p>number of simulations</p>
</dd>
<dt><code>propDLTs</code></dt><dd><p>proportions of DLTs in the trials</p>
</dd>
<dt><code>meanToxRisk</code></dt><dd><p>mean toxicity risks for the patients</p>
</dd>
<dt><code>doseSelected</code></dt><dd><p>doses selected as MTD</p>
</dd>
<dt><code>toxAtDosesSelected</code></dt><dd><p>true toxicity at doses selected</p>
</dd>
<dt><code>propAtTarget</code></dt><dd><p>Proportion of trials selecting target MTD</p>
</dd>
<dt><code>doseMostSelected</code></dt><dd><p>dose most often selected as MTD</p>
</dd>
<dt><code>obsToxRateAtDoseMostSelected</code></dt><dd><p>observed toxicity rate at dose most often
selected</p>
</dd>
<dt><code>nObs</code></dt><dd><p>number of patients overall</p>
</dd>
<dt><code>nAboveTarget</code></dt><dd><p>number of patients treated above target tox interval</p>
</dd>
<dt><code>doseGrid</code></dt><dd><p>the dose grid that has been used</p>
</dd>
<dt><code>placebo</code></dt><dd><p>set to TRUE (default is FALSE) for a design with placebo</p>
</dd>
</dl>

<hr>
<h2 id='get+2CSamples+2Ccharacter-method'>Get specific parameter samples and produce a data.frame</h2><span id='topic+get+2CSamples+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Here you have to specify with <code>pos</code> which
parameter you would like to extract from the <code><a href="#topic+Samples-class">Samples</a></code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Samples,character'
get(x, pos = -1L, envir = NULL, mode = NULL, inherits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get+2B2CSamples+2B2Ccharacter-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="get+2B2CSamples+2B2Ccharacter-method_+3A_pos">pos</code></td>
<td>
<p>the name of the parameter</p>
</td></tr>
<tr><td><code id="get+2B2CSamples+2B2Ccharacter-method_+3A_envir">envir</code></td>
<td>
<p>for vectorial parameters, you can give the indices of the
elements you would like to extract. If <code>NULL</code>, the whole vector samples
will be returned</p>
</td></tr>
<tr><td><code id="get+2B2CSamples+2B2Ccharacter-method_+3A_mode">mode</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="get+2B2CSamples+2B2Ccharacter-method_+3A_inherits">inherits</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data frame suitable for use with <code><a href="ggmcmc.html#topic+ggmcmc">ggmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data
data &lt;- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y = c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort = c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid = c(0.1, 0.5, 1.5, 3, 6,
                          seq(from = 10, to = 80, by=2)))

# Initialize a model 
model &lt;- LogisticLogNormal(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 56)

# Get posterior for all model parameters
options &lt;- McmcOptions(burnin = 100,
                       step = 2,
                       samples = 2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# now extract the alpha0 samples (intercept of the regression model)
alpha0samples &lt;- get(samples, "alpha0")
</code></pre>

<hr>
<h2 id='getEff'>Extracting efficacy responses for subjects without or with a DLE. This is a class where we separate
efficacy responses with or without a DLE. It outputs the efficacy responses and their corresponding 
dose levels treated at in two categories (with or without DLE)</h2><span id='topic+getEff'></span><span id='topic+getEff+2CDataDual-method'></span>

<h3>Description</h3>

<p>Extracting efficacy responses for subjects without or with a DLE. This is a class where we separate
efficacy responses with or without a DLE. It outputs the efficacy responses and their corresponding 
dose levels treated at in two categories (with or without DLE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEff(object, ...)

## S4 method for signature 'DataDual'
getEff(object, x, y, w, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEff_+3A_object">object</code></td>
<td>
<p>for data input from <code><a href="#topic+DataDual-class">DataDual</a></code> object</p>
</td></tr>
<tr><td><code id="getEff_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="getEff_+3A_x">x</code></td>
<td>
<p>todo</p>
</td></tr>
<tr><td><code id="getEff_+3A_y">y</code></td>
<td>
<p>todo</p>
</td></tr>
<tr><td><code id="getEff_+3A_w">w</code></td>
<td>
<p>todo</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Separate the efficacy responses of subjects with or without DLE
## data must be specified for in 'DataDual' class
data&lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
               y=c(0,0,0,0,0,1,1,0),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25))
##Display the efficacy response and their corresponding dose levels 
## treated at when no or a DLE is observed
getEff(data)
</code></pre>

<hr>
<h2 id='getMinInfBeta'>Get the minimal informative unimodal beta distribution</h2><span id='topic+getMinInfBeta'></span>

<h3>Description</h3>

<p>As defined in Neuenschwander et al (2008), this function computes the
parameters of the minimal informative unimodal beta distribution, given the
request that the p-quantile should be q, i.e. X ~ Be(a, b) with Pr(X &lt;= q) =
p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMinInfBeta(p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMinInfBeta_+3A_p">p</code></td>
<td>
<p>the probability (&gt; 0 and &lt; 1)</p>
</td></tr>
<tr><td><code id="getMinInfBeta_+3A_q">q</code></td>
<td>
<p>the quantile (&gt; 0 and &lt; 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the two resulting beta parameters a and b in a list
</p>

<hr>
<h2 id='getResultList'>Helper function to obtain simulation results list</h2><span id='topic+getResultList'></span>

<h3>Description</h3>

<p>The function <code>fun</code> can use variables that are visible to itself. The
names of these variables have to given in the vector <code>vars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResultList(fun, nsim, vars, parallel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResultList_+3A_fun">fun</code></td>
<td>
<p>the simulation function for a single iteration, which takes as
single parameter the iteration index</p>
</td></tr>
<tr><td><code id="getResultList_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to be conducted</p>
</td></tr>
<tr><td><code id="getResultList_+3A_vars">vars</code></td>
<td>
<p>names of the variables</p>
</td></tr>
<tr><td><code id="getResultList_+3A_parallel">parallel</code></td>
<td>
<p>shall the iterations be parallelized across the cores?
if NULL, then no parallelization will be done. If scalar positive number, 
then so many cores will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list with all simulation results (one iteration corresponds
to one list element)
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove <a href="mailto:sabanesd@roche.com">sabanesd@roche.com</a>
</p>

<hr>
<h2 id='IncrementMin'>Initialization function for &quot;IncrementMin&quot;</h2><span id='topic+IncrementMin'></span>

<h3>Description</h3>

<p>Initialization function for &quot;IncrementMin&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IncrementMin(IncrementsList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IncrementMin_+3A_incrementslist">IncrementsList</code></td>
<td>
<p>see <code><a href="#topic+IncrementMin-class">IncrementMin</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+IncrementMin-class">IncrementMin</a></code> object
</p>

<hr>
<h2 id='IncrementMin-class'>Max increment based on minimum of multiple increment rules</h2><span id='topic+IncrementMin-class'></span><span id='topic+.IncrementMin'></span>

<h3>Description</h3>

<p>This class can be used to combine multiple increment rules with the MIN
operation.
</p>


<h3>Details</h3>

<p><code>IncrementsList</code> contains all increment rules, which are again
objects of class <code><a href="#topic+Increments-class">Increments</a></code>. The minimum of these
individual increments is taken to give the final maximum increment.
</p>


<h3>Slots</h3>


<dl>
<dt><code>IncrementsList</code></dt><dd><p>list of increment rules</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here we are combining 2 different increment rules. 

# The first rule is the following: 
#      maximum doubling the dose if no DLTs were observed at the current dose
#      or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose
#      or maximum increasing the dose by 1.22 if 3 or more DLTs were observed

# The second rule is the following: 
#   maximum doubling the dose if the current dose is &lt;20
#   OR only maximum increasing the dose by 1.33 if the current dose is &gt;=20


myIncrements1 &lt;- IncrementsRelativeDLT(DLTintervals = c(0, 1, 3),
                                      increments = c(1, 0.33, 0.2))

myIncrements2 &lt;- IncrementsRelative(intervals=c(0, 20),
                                    increments=c(1, 0.33))

# Now we combine the 2 rules
combIncrement &lt;- IncrementMin(IncrementsList=
                                list(myIncrements1,myIncrements2))


</code></pre>

<hr>
<h2 id='Increments-class'>The virtual class for controlling increments</h2><span id='topic+Increments-class'></span>

<h3>Description</h3>

<p>The virtual class for controlling increments
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IncrementsRelative-class">IncrementsRelative</a></code>,
<code><a href="#topic+IncrementsRelativeDLT-class">IncrementsRelativeDLT</a></code>,
<code><a href="#topic+IncrementsRelativeParts-class">IncrementsRelativeParts</a></code>
</p>

<hr>
<h2 id='IncrementsNumDoseLevels'>Initialization function for &quot;IncrementsNumDoseLevels&quot;</h2><span id='topic+IncrementsNumDoseLevels'></span>

<h3>Description</h3>

<p>Initialization function for &quot;IncrementsNumDoseLevels&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IncrementsNumDoseLevels(maxLevels = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IncrementsNumDoseLevels_+3A_maxlevels">maxLevels</code></td>
<td>
<p>see <code><a href="#topic+IncrementsNumDoseLevels-class">IncrementsNumDoseLevels</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+IncrementsNumDoseLevels-class">IncrementsNumDoseLevels</a></code> object
</p>

<hr>
<h2 id='IncrementsNumDoseLevels-class'>Increments control based on number of dose levels</h2><span id='topic+IncrementsNumDoseLevels-class'></span><span id='topic+.IncrementsNumDoseLevels'></span>

<h3>Description</h3>

<p>Increments control based on number of dose levels
</p>


<h3>Slots</h3>


<dl>
<dt><code>maxLevels</code></dt><dd><p>scalar positive integer for the number of maximum 
dose levels to increment for the next dose. It defaults to 1, 
which means that no dose skipping is allowed - the next dose 
can be maximum one level higher than the current dose.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
# maximum skip one dose level, that is 2 dose levels higher is maximum
# increment
myIncrements &lt;- IncrementsNumDoseLevels(maxLevels=2)

</code></pre>

<hr>
<h2 id='IncrementsRelative'>Initialization function for &quot;IncrementsRelative&quot;</h2><span id='topic+IncrementsRelative'></span>

<h3>Description</h3>

<p>Initialization function for &quot;IncrementsRelative&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IncrementsRelative(intervals, increments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IncrementsRelative_+3A_intervals">intervals</code></td>
<td>
<p>see <code><a href="#topic+IncrementsRelative-class">IncrementsRelative</a></code></p>
</td></tr>
<tr><td><code id="IncrementsRelative_+3A_increments">increments</code></td>
<td>
<p>see <code><a href="#topic+IncrementsRelative-class">IncrementsRelative</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+IncrementsRelative-class">IncrementsRelative</a></code> object
</p>

<hr>
<h2 id='IncrementsRelative-class'>Increments control based on relative differences in intervals</h2><span id='topic+IncrementsRelative-class'></span><span id='topic+.IncrementsRelative'></span>

<h3>Description</h3>

<p>Note that <code>intervals</code> is to be read as follows. If for example,
we want to specify three intervals: First 0 to less than 50, second at least
50 up to less than 100 mg, and third at least 100 mg, then we specify
<code>intervals</code> to be <code>c(0, 50, 100)</code>. That means, the right
bound of the intervals are exclusive to the interval, and the last interval
goes from the last value until infinity.
</p>


<h3>Slots</h3>


<dl>
<dt><code>intervals</code></dt><dd><p>a vector with the left bounds of the relevant intervals</p>
</dd>
<dt><code>increments</code></dt><dd><p>a vector of the same length with the maximum allowable
relative increments in the <code>intervals</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#   maximum doubling the dose if the current dose is &lt;20
#   OR only maximum increasing the dose by 1.33 if the current dose is &gt;=20

myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

</code></pre>

<hr>
<h2 id='IncrementsRelativeDLT'>Initialization function for &quot;IncrementsRelativeDLT&quot;</h2><span id='topic+IncrementsRelativeDLT'></span>

<h3>Description</h3>

<p>Initialization function for &quot;IncrementsRelativeDLT&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IncrementsRelativeDLT(DLTintervals, increments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IncrementsRelativeDLT_+3A_dltintervals">DLTintervals</code></td>
<td>
<p>see <code><a href="#topic+IncrementsRelativeDLT-class">IncrementsRelativeDLT</a></code></p>
</td></tr>
<tr><td><code id="IncrementsRelativeDLT_+3A_increments">increments</code></td>
<td>
<p>see <code><a href="#topic+IncrementsRelativeDLT-class">IncrementsRelativeDLT</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+IncrementsRelativeDLT-class">IncrementsRelativeDLT</a></code> object
</p>

<hr>
<h2 id='IncrementsRelativeDLT-class'>Increments control based on relative differences in terms of DLTs</h2><span id='topic+IncrementsRelativeDLT-class'></span><span id='topic+.IncrementsRelativeDLT'></span>

<h3>Description</h3>

<p>Note that <code>DLTintervals</code> is to be read as follows. If for example,
we want to specify three intervals: First 0 DLTs, second 1 or 2 DLTs, and
third at least 3 DLTs, then we specify
<code>DLTintervals</code> to be <code>c(0, 1, 3)</code>. That means, the right
bound of the intervals are exclusive to the interval &ndash; the vector only
gives the left bounds of the intervals. The last interval goes from 3 to
infinity.
</p>


<h3>Slots</h3>


<dl>
<dt><code>DLTintervals</code></dt><dd><p>an integer vector with the left bounds of the relevant
DLT intervals</p>
</dd>
<dt><code>increments</code></dt><dd><p>a vector of the same length with the maximum allowable
relative increments in the <code>DLTintervals</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#      maximum doubling the dose if no DLTs were observed at the current dose
#      or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose
#      or maximum increasing the dose by 1.22 if 3 or more DLTs were observed

myIncrements &lt;- IncrementsRelativeDLT(DLTintervals = c(0, 1, 3),
                                      increments = c(1, 0.33, 0.2))

</code></pre>

<hr>
<h2 id='IncrementsRelativeParts'>Initialization function for &quot;IncrementsRelativeParts&quot;</h2><span id='topic+IncrementsRelativeParts'></span>

<h3>Description</h3>

<p>Initialization function for &quot;IncrementsRelativeParts&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IncrementsRelativeParts(dltStart, cleanStart, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IncrementsRelativeParts_+3A_dltstart">dltStart</code></td>
<td>
<p>see <code><a href="#topic+IncrementsRelativeParts-class">IncrementsRelativeParts</a></code></p>
</td></tr>
<tr><td><code id="IncrementsRelativeParts_+3A_cleanstart">cleanStart</code></td>
<td>
<p>see <code><a href="#topic+IncrementsRelativeParts-class">IncrementsRelativeParts</a></code></p>
</td></tr>
<tr><td><code id="IncrementsRelativeParts_+3A_...">...</code></td>
<td>
<p>additional slots from <code><a href="#topic+IncrementsRelative-class">IncrementsRelative</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+IncrementsRelativeParts-class">IncrementsRelativeParts</a></code> object
</p>

<hr>
<h2 id='IncrementsRelativeParts-class'>Increments control based on relative differences in intervals,
with special rules for part 1 and beginning of part 2</h2><span id='topic+IncrementsRelativeParts-class'></span><span id='topic+.IncrementsRelativeParts'></span>

<h3>Description</h3>

<p>Note that this only works in conjunction with <code><a href="#topic+DataParts-class">DataParts</a></code>
objects. If the part 2 will just be started in the next cohort, then the
next maximum dose will be either <code>dltStart</code> (e.g. -1) shift of the last
part 1 dose in case of a DLT in part 1, or <code>cleanStart</code> shift (e.g. 0)
in case of no DLTs in part 1. If part 1 will still be on in the next cohort,
then the next dose level will be the next higher dose level in the
<code>part1Ladder</code> of the data object. If part 2 has been started before,
the usual relative increment rules apply, see
<code><a href="#topic+IncrementsRelative-class">IncrementsRelative</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dltStart</code></dt><dd><p>integer giving the dose level increment for starting part 2
in case of a DLT in part 1</p>
</dd>
<dt><code>cleanStart</code></dt><dd><p>integer giving the dose level increment for starting part 2
in case of a DLT in part 1. If this is less or equal to 0, then the part 1
ladder will be used to find the maximum next dose. If this is larger than 0,
then the relative increment rules will be applied to find the next maximum
dose level.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
myIncrements &lt;- IncrementsRelativeParts(dltStart=0,
                                        cleanStart=1)

</code></pre>

<hr>
<h2 id='initialize+2CDualEndpointOld-method'>Initialization method for the &quot;DualEndpointOld&quot; class</h2><span id='topic+initialize+2CDualEndpointOld-method'></span>

<h3>Description</h3>

<p>Initialization method for the &quot;DualEndpointOld&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DualEndpointOld'
initialize(
  .Object,
  mu,
  Sigma,
  sigma2betaW,
  sigma2W,
  rho,
  smooth = c("RW1", "RW2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CDualEndpointOld-method_+3A_.object">.Object</code></td>
<td>
<p>the <code><a href="#topic+DualEndpointOld-class">DualEndpointOld</a></code> we want to
initialize</p>
</td></tr>
<tr><td><code id="initialize+2B2CDualEndpointOld-method_+3A_mu">mu</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointOld-class">DualEndpointOld</a></code></p>
</td></tr>
<tr><td><code id="initialize+2B2CDualEndpointOld-method_+3A_sigma">Sigma</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointOld-class">DualEndpointOld</a></code></p>
</td></tr>
<tr><td><code id="initialize+2B2CDualEndpointOld-method_+3A_sigma2betaw">sigma2betaW</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointOld-class">DualEndpointOld</a></code></p>
</td></tr>
<tr><td><code id="initialize+2B2CDualEndpointOld-method_+3A_sigma2w">sigma2W</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointOld-class">DualEndpointOld</a></code></p>
</td></tr>
<tr><td><code id="initialize+2B2CDualEndpointOld-method_+3A_rho">rho</code></td>
<td>
<p>see <code><a href="#topic+DualEndpointOld-class">DualEndpointOld</a></code></p>
</td></tr>
<tr><td><code id="initialize+2B2CDualEndpointOld-method_+3A_smooth">smooth</code></td>
<td>
<p>either &ldquo;RW1&rdquo; (default) or &ldquo;RW2&rdquo;, for
specifying the random walk prior on the biomarker level.</p>
</td></tr>
<tr><td><code id="initialize+2B2CDualEndpointOld-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='is.bool'>Predicate checking for a boolean option</h2><span id='topic+is.bool'></span>

<h3>Description</h3>

<p>Predicate checking for a boolean option
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bool(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.bool_+3A_x">x</code></td>
<td>
<p>the object being checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> is a length one logical vector (i.e., a
scalar)
</p>

<hr>
<h2 id='is.probability'>Predicate checking for a probability</h2><span id='topic+is.probability'></span>

<h3>Description</h3>

<p>Predicate checking for a probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.probability(x, bounds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.probability_+3A_x">x</code></td>
<td>
<p>the object being checked</p>
</td></tr>
<tr><td><code id="is.probability_+3A_bounds">bounds</code></td>
<td>
<p>whether to include the bounds 0 and 1 (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> is a probability
</p>

<hr>
<h2 id='is.probRange'>Predicate checking for a probability range</h2><span id='topic+is.probRange'></span>

<h3>Description</h3>

<p>Predicate checking for a probability range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.probRange(x, bounds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.probRange_+3A_x">x</code></td>
<td>
<p>the object being checked</p>
</td></tr>
<tr><td><code id="is.probRange_+3A_bounds">bounds</code></td>
<td>
<p>whether to include the bounds 0 and 1 (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> is a probability range
</p>

<hr>
<h2 id='is.range'>Predicate checking for a numeric range</h2><span id='topic+is.range'></span>

<h3>Description</h3>

<p>Predicate checking for a numeric range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.range(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.range_+3A_x">x</code></td>
<td>
<p>the object being checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> is a numeric range
</p>

<hr>
<h2 id='is.scalar'>Checking for scalar</h2><span id='topic+is.scalar'></span>

<h3>Description</h3>

<p>Checking for scalar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.scalar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.scalar_+3A_x">x</code></td>
<td>
<p>the input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> is a length one vector
(i.e., a scalar)
</p>

<hr>
<h2 id='is.wholenumber'>checks for whole numbers (integers)</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>checks for whole numbers (integers)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>the numeric vector</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>the tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE for each element of x
</p>

<hr>
<h2 id='joinBodies'>Helper function to join two function bodies</h2><span id='topic+joinBodies'></span>

<h3>Description</h3>

<p>Helper function to join two function bodies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinBodies(body1, body2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinBodies_+3A_body1">body1</code></td>
<td>
<p>first body</p>
</td></tr>
<tr><td><code id="joinBodies_+3A_body2">body2</code></td>
<td>
<p>second body</p>
</td></tr>
</table>


<h3>Value</h3>

<p>joined body
</p>

<hr>
<h2 id='joinModels'>Helper function to join two BUGS models</h2><span id='topic+joinModels'></span>

<h3>Description</h3>

<p>Helper function to join two BUGS models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinModels(model1, model2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinModels_+3A_model1">model1</code></td>
<td>
<p>first model</p>
</td></tr>
<tr><td><code id="joinModels_+3A_model2">model2</code></td>
<td>
<p>second model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>joined model
</p>

<hr>
<h2 id='LogisticIndepBeta'>Intialization function for &quot;LogisticIndepBeta&quot; class</h2><span id='topic+LogisticIndepBeta'></span>

<h3>Description</h3>

<p>Intialization function for &quot;LogisticIndepBeta&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticIndepBeta(binDLE, DLEdose, DLEweights, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticIndepBeta_+3A_bindle">binDLE</code></td>
<td>
<p>the number of subjects observed with a DLE, the pseudo DLE responses</p>
</td></tr>
<tr><td><code id="LogisticIndepBeta_+3A_dledose">DLEdose</code></td>
<td>
<p>the corresponding dose levels for the pseudo DLE responses, pseudo dose levels</p>
</td></tr>
<tr><td><code id="LogisticIndepBeta_+3A_dleweights">DLEweights</code></td>
<td>
<p>the total number of subjects treated at each of the dose levels, pseudo weights</p>
</td></tr>
<tr><td><code id="LogisticIndepBeta_+3A_data">data</code></td>
<td>
<p>the input data to update estimates of model parameters and 
follow the <code><a href="#topic+Data-class">Data</a></code> object class specification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code>
</p>

<hr>
<h2 id='LogisticIndepBeta-class'>No initialization function
Standard logistic model with prior in form of pseudo data</h2><span id='topic+LogisticIndepBeta-class'></span><span id='topic+.LogisticIndepBeta'></span>

<h3>Description</h3>

<p>This is a class for the two-parameter logistic regression DLE model with prior expressed
in form of pseudo data. This model describe the relationhship of the binary DLE (dose-limiting
events) responses and the dose levels. More specifically, this DLE model reprsents the relationship 
of the probabilities of the occurrence of a DLE with their corresponding dose levels in log scale.
This model is specified as 
</p>
<p style="text-align: center;"><code class="reqn">p(d_{(j)})= \frac{exp(\phi_1+\phi_2 log(d_{(j)}))}{1+exp(\phi_1+\phi_2 log(d_{(j)}))}</code>
</p>

<p>for any dose j where <code class="reqn">p(d_{(j)})</code> is the probability of the occurrence of a DLE at dose j.
The two parameters of this model is the intercept <code class="reqn">\phi_1</code> and the slope <code class="reqn">\phi_2</code>
It inherits all slots from <code><a href="#topic+ModelTox-class">ModelTox</a></code> class.
</p>


<h3>Details</h3>

<p>The pseudo data can be interpreted as as if we obtain some observations before the trial starts.
These pseudo data can be used to express our prior, the initial beliefs for the model parameter(s).
The pseudo data are expressed in the following way. First, fix at least two dose levels which are
Then ask for experts' opinion how many subjects are to be treated at each of these dose levels and
the number of subjects observed with DLE are observed. At each dose level, the number of subjects 
observed with a DLE divided by the total number of subjects treated is the probability of the 
occurrence of a DLE at that particular dose level. The probabilities of the occurrence of a DLE
based on these pseudo data are independent Beta distributions. Therefore, the joint prior probability 
density function of all these probabilities can be obtained. Hence, by a change of variable, the 
joint prior probability density function of the two parameters in this model can also be obtained.
In addition, a conjugate joint perior density function of the two paramaters in the model is used.
For details about the form of all these joint prior and posterior probability density function, please 
refers to Whitehead and Willamson (1998). 
</p>
<p>When expressing the pseudo data, <code>binDLE</code>,<code>DLEdose</code> and <code>DLEweights</code> are used.
The <code>binDLE</code> represents the number of subjects observed with DLE. Note that, since the imaginary 
nature of the pseudo data, the number of subjects observed wtih DLE is not necesssary to be integer(s)
but any scalar value.
The <code>DLEdose</code> represents the dose levels at which the pseudo DLE responses (<code>binDLE</code>) are 
observed.
The <code>DLEweights</code> represents the total number of subjects treated.
Since at least two DLE pseudo responses are needed to obtain prior modal estimates (same as the maximum 
likelihood estimates) for the model parameters. <code>binDLE</code>, <code>DLEdose</code> and <code>DLEweights</code> must
all be vectors of at least length 2. Since given one pseudo DLE responses, the number of subjects observed 
with a DLE relates to at which dose level they are treated and the total number of of subjects treated at
this dose level. Therefore, each of the elements in any of the vectors of <code>binDLE</code>, <code>DLEdose</code> and 
<code>DLEweights</code> must have a corresponding elements in the other two vectors. A set of three values with
one of each in the vectors of <code>binDLE</code>, <code>DLEdose</code> and <code>DLEweights</code>. In this model, each of 
these three values must be specified in the same position as in each of the vector of <code>binDLE</code>, 
<code>DLEdose</code> and <code>DLEweights</code>. The order of the values or elements in one of the vector <code>binDLE</code>, 
<code>DLEdose</code> and <code>DLEweights</code> must corresponds to the values or elements specified in the other two 
vectors.
</p>


<h3>Slots</h3>


<dl>
<dt><code>binDLE</code></dt><dd><p>represents the vector of pseudo DLE responses. This must be at least f length 2 and the 
order of its elements must corresponds to values specified in <code>DLEdose</code> and <code>DLEweights</code>. 
(see details from above)</p>
</dd>
<dt><code>DLEdose</code></dt><dd><p>represents the vector of the corresponding dose levels observed at each of the 
pseudo DLE responses (<code>binDLE</code>). This mus be at least of length 2 and the order of its elements
must corresponds to values specified in <code>binDLE</code> and <code>DLEweights</code>.
(see details from above)</p>
</dd>
<dt><code>DLEweights</code></dt><dd><p>refers to the total number of subjects treated at each of the pseudo dose level 
(<code>DLEdose</code>). This must be of length of at least 2 and the oreder of its elements must corresponds
to values specified in <code>binDLE</code> and <code>DLEdose</code>. (see details from above)</p>
</dd>
<dt><code>phi1</code></dt><dd><p>refers the intercept of the model. This slot is used in output to display the resulting prior 
or posterior modal estimate of the intercept obtained based on the pseudo data and (if any) 
observed data/responses.</p>
</dd>
<dt><code>phi2</code></dt><dd><p>refers to slope of the model. This slot is used in output to display the resulting prior or 
posterior modal estimate of the slope obtained based on the pseudo data and (if any) the observed data/responses.</p>
</dd>
<dt><code>Pcov</code></dt><dd><p>refers to the covariance matrix of the intercept (phi1) and the slope parameters (phi2) of the 
model. This is used in output to display the resulting prior and posterior covariance matrix of phi1 and 
phi2 obtained, based on the pseudo data and (if any) the observed data and responses. This slot is needed for 
internal purposes.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Obtain prior modal estimates given the pseudo data.
##First we used an empty data set such that only the dose levels under investigations are given.
##In total, 12 dose levels are under investigation ranging from 25 to 300 mg with increments of 25
##(i.e 25, 50, 75, ..., 300).
emptydata&lt;- Data(doseGrid=seq(25,300,25))

##specified our data set is the empty data
data&lt;-emptydata
## Given the pseudo data such that
## Fix two dose level 25 and 300 mg and specified in (DLEdose slot).
## Total number of subjects treated in each of these levels is 3, specified in (DLEweights slot).
## The number of subjects observed with a DLE is 1.05 at dose 25 mg and 1.8 at dose 300 mg, 
## and specified in (binDLE slot).
## the data set we used in the emptydata set, and specified in (data slot).
## Then to modal estimates of the model parameters.
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

##using a data set (see data -class example specification) with observed DLE responses 
##to obtain posterior modal estimates. 
##for the model given the pseudo data

data&lt;-Data(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(25,300,25))

model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

</code></pre>

<hr>
<h2 id='LogisticKadane'>Initialization function for the &quot;LogisticKadane&quot; class</h2><span id='topic+LogisticKadane'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;LogisticKadane&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticKadane(theta, xmin, xmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticKadane_+3A_theta">theta</code></td>
<td>
<p>the target toxicity probability</p>
</td></tr>
<tr><td><code id="LogisticKadane_+3A_xmin">xmin</code></td>
<td>
<p>the minimum of the dose range</p>
</td></tr>
<tr><td><code id="LogisticKadane_+3A_xmax">xmax</code></td>
<td>
<p>the maximum of the dose range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+LogisticKadane-class">LogisticKadane</a></code>
</p>

<hr>
<h2 id='LogisticKadane-class'>Reparametrized logistic model</h2><span id='topic+LogisticKadane-class'></span><span id='topic+.LogisticKadane'></span>

<h3>Description</h3>

<p>This is the logistic model in the parametrization of Kadane et al. (1980).
</p>


<h3>Details</h3>

<p>Let <code class="reqn">\rho_{0} = p(x_{min})</code> be the probability of a DLT and the minimum
dose <code class="reqn">x_{min}</code>, and let <code class="reqn">\gamma</code> be the dose with target toxicity
probability <code class="reqn">\theta</code>, i.e. <code class="reqn">p(\gamma) = \theta</code>. Then it can easily
be shown that the logistic regression model has intercept
</p>
<p style="text-align: center;"><code class="reqn">\frac{\gamma logit(\rho_{0}) - x_{min} logit(\theta)}{\gamma -
x_{min}}</code>
</p>

<p>and slope
</p>
<p style="text-align: center;"><code class="reqn">\frac{logit(theta) - logit(\rho_{0})}{\gamma - x_{min}}</code>
</p>

<p>The prior is a uniform distribution for <code class="reqn">\gamma</code> between <code class="reqn">x_{min}</code>
and <code class="reqn">x_{max}</code>, and for <code class="reqn">\rho_{0}</code> as well a uniform distribution
between <code class="reqn">0</code> and <code class="reqn">\theta</code>.
</p>
<p>The slots of this class, required for creating the model, are the target
toxicity, as well as the minimum and maximum of the dose range. Note that
these can be different from the minimum and maximum of the dose grid in the
data later on.
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code></dt><dd><p>the target toxicity probability <code class="reqn">\theta</code></p>
</dd>
<dt><code>xmin</code></dt><dd><p>the minimum of the dose range <code class="reqn">x_{min}</code></p>
</dd>
<dt><code>xmax</code></dt><dd><p>the maximum of the dose range <code class="reqn">x_{max}</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- LogisticKadane(theta = 0.33,
                        xmin = 1,
                        xmax = 200)


</code></pre>

<hr>
<h2 id='LogisticLogNormal'>Initialization function for the &quot;LogisticLogNormal&quot; class</h2><span id='topic+LogisticLogNormal'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;LogisticLogNormal&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticLogNormal(mean, cov, refDose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticLogNormal_+3A_mean">mean</code></td>
<td>
<p>the prior mean vector</p>
</td></tr>
<tr><td><code id="LogisticLogNormal_+3A_cov">cov</code></td>
<td>
<p>the prior covariance matrix</p>
</td></tr>
<tr><td><code id="LogisticLogNormal_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+LogisticLogNormal-class">LogisticLogNormal</a></code> object
</p>

<hr>
<h2 id='LogisticLogNormal-class'>Standard logistic model with bivariate (log) normal prior</h2><span id='topic+LogisticLogNormal-class'></span><span id='topic+.LogisticLogNormal'></span>

<h3>Description</h3>

<p>This is the usual logistic regression model with a bivariate normal prior on
the intercept and log slope.
</p>


<h3>Details</h3>

<p>The covariate is the natural logarithm of the dose <code class="reqn">x</code> divided by
the reference dose <code class="reqn">x^{*}</code>:
</p>
<p style="text-align: center;"><code class="reqn">logit[p(x)] = \alpha + \beta \cdot \log(x/x^{*})</code>
</p>

<p>where <code class="reqn">p(x)</code> is the probability of observing a DLT for a given dose
<code class="reqn">x</code>.
</p>
<p>The prior is
</p>
<p style="text-align: center;"><code class="reqn">(\alpha, \log(\beta)) \sim Normal(\mu, \Sigma)</code>
</p>

<p>The slots of this class contain the mean vector and the covariance matrix of
the bivariate normal distribution, as well as the reference dose.
</p>
<p>Note that the parametrization inside the class uses alpha0 and alpha1.
alpha0 is identical to the intercept <code class="reqn">\alpha</code> above and is the log-odds
for a DLT at the reference dose x*. Therefore, the prior mean for alpha0
is the expected log-odds at the reference dose x* before observing any data.
Note that the expected odds is not just the exp of the prior mean of alpha0,
because the non-linearity of the exp transformation. The log-normal
distribution on Wikipedia gives the formula for computing the prior mean of
exp(alpha0). alpha0 is the log(alpha) in the Neuenschwander et al. (2008)
paper. alpha1 is identical to <code class="reqn">\beta</code> above and equals the beta
in the Neuenschwander et al paper. exp(alpha1) gives the odds-ratio for DLT
between two doses that differ by the factor exp(1) ~ 2.7. alpha1 has a
log-normal distribution in the LogisticLogNormal model in order to ensure
positivity of alpha1 and thus exp(alpha1) &gt; 1.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mean</code></dt><dd><p>the prior mean vector <code class="reqn">\mu</code></p>
</dd>
<dt><code>cov</code></dt><dd><p>the prior covariance matrix <code class="reqn">\Sigma</code></p>
</dd>
<dt><code>refDose</code></dt><dd><p>the reference dose <code class="reqn">x^{*}</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- LogisticLogNormal(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 50)


</code></pre>

<hr>
<h2 id='LogisticLogNormalMixture'>Initialization function for the &quot;LogisticLogNormalMixture&quot; class</h2><span id='topic+LogisticLogNormalMixture'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;LogisticLogNormalMixture&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticLogNormalMixture(mean, cov, refDose, shareWeight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticLogNormalMixture_+3A_mean">mean</code></td>
<td>
<p>the prior mean vector</p>
</td></tr>
<tr><td><code id="LogisticLogNormalMixture_+3A_cov">cov</code></td>
<td>
<p>the prior covariance matrix</p>
</td></tr>
<tr><td><code id="LogisticLogNormalMixture_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose</p>
</td></tr>
<tr><td><code id="LogisticLogNormalMixture_+3A_shareweight">shareWeight</code></td>
<td>
<p>the prior weight for the share component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+LogisticLogNormalMixture-class">LogisticLogNormalMixture</a></code> object
</p>

<hr>
<h2 id='LogisticLogNormalMixture-class'>Standard logistic model with online mixture of two bivariate log normal priors</h2><span id='topic+LogisticLogNormalMixture-class'></span><span id='topic+.LogisticLogNormalMixture'></span>

<h3>Description</h3>

<p>This model can be used when data is arising online from the informative
component of the prior, at the same time with the data of the trial of
main interest. Formally, this is achieved by assuming that the probability
of a DLT at dose <code class="reqn">x</code> is given by
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">p(x) = \pi p_{1}(x) + (1 - \pi) p_{2}(x)</code>
</p>

<p>where <code class="reqn">\pi</code> is the probability for the model <code class="reqn">p(x)</code> being the same
as the model <code class="reqn">p_{1}(x)</code> - this is 
the informative component of the prior. From this model data arises in 
parallel: at doses <code>xshare</code>, DLT information <code>yshare</code> is observed, 
in total <code>nObsshare</code> data points, see <code><a href="#topic+DataMixture-class">DataMixture</a></code>.
On the other hand, <code class="reqn">1 - \pi</code>
is the probability of a separate model <code class="reqn">p_{2}(x)</code>. Both components 
have the same log normal prior distribution, which can be specified by the
user, and which is inherited from the <code><a href="#topic+LogisticLogNormal-class">LogisticLogNormal</a></code>
class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>shareWeight</code></dt><dd><p>the prior weight for sharing the same model <code class="reqn">p_{1}(x)</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p>the <code><a href="#topic+DataMixture-class">DataMixture</a></code> class for use with this model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## decide on the dose grid:
doseGrid &lt;- 1:80

## and MCMC options:
options &lt;- McmcOptions()

## the classic model would be:
model &lt;- LogisticLogNormal(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 50)

nodata &lt;- Data(doseGrid=doseGrid)

priorSamples &lt;- mcmc(nodata, model, options)
plot(priorSamples, model, nodata)

## set up the mixture model and data share object:
modelShare &lt;- LogisticLogNormalMixture(shareWeight=0.1,
                                       mean = c(-0.85, 1),
                                       cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                                       refDose = 50)

nodataShare &lt;- DataMixture(doseGrid=doseGrid,
                           xshare=
                             c(rep(10, 4),
                               rep(20, 4),
                               rep(40, 4)),
                           yshare=
                             c(rep(0L, 4),
                               rep(0L, 4),
                               rep(0L, 4)))

## now compare with the resulting prior model:
priorSamplesShare &lt;- mcmc(nodataShare, modelShare, options)
plot(priorSamplesShare, modelShare, nodataShare)
</code></pre>

<hr>
<h2 id='LogisticLogNormalSub'>Initialization function for the &quot;LogisticLogNormalSub&quot; class</h2><span id='topic+LogisticLogNormalSub'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;LogisticLogNormalSub&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticLogNormalSub(mean, cov, refDose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticLogNormalSub_+3A_mean">mean</code></td>
<td>
<p>the prior mean vector</p>
</td></tr>
<tr><td><code id="LogisticLogNormalSub_+3A_cov">cov</code></td>
<td>
<p>the prior covariance matrix</p>
</td></tr>
<tr><td><code id="LogisticLogNormalSub_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+LogisticLogNormalSub-class">LogisticLogNormalSub</a></code> object
</p>

<hr>
<h2 id='LogisticLogNormalSub-class'>Standard logistic model with bivariate (log) normal prior with substractive
dose standardization</h2><span id='topic+LogisticLogNormalSub-class'></span><span id='topic+.LogisticLogNormalSub'></span>

<h3>Description</h3>

<p>This is the usual logistic regression model with a bivariate normal prior on
the intercept and log slope.
</p>


<h3>Details</h3>

<p>The covariate is the dose <code class="reqn">x</code> minus the reference dose <code class="reqn">x^{*}</code>:
</p>
<p style="text-align: center;"><code class="reqn">logit[p(x)] = \alpha + \beta \cdot (x - x^{*})</code>
</p>

<p>where <code class="reqn">p(x)</code> is the probability of observing a DLT for a given dose
<code class="reqn">x</code>.
</p>
<p>The prior is
</p>
<p style="text-align: center;"><code class="reqn">(\alpha, \log(\beta)) \sim Normal(\mu, \Sigma)</code>
</p>

<p>The slots of this class contain the mean vector and the covariance matrix of
the bivariate normal distribution, as well as the reference dose.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mean</code></dt><dd><p>the prior mean vector <code class="reqn">\mu</code></p>
</dd>
<dt><code>cov</code></dt><dd><p>the prior covariance matrix <code class="reqn">\Sigma</code></p>
</dd>
<dt><code>refDose</code></dt><dd><p>the reference dose <code class="reqn">x^{*}</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- LogisticLogNormalSub(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 50)


</code></pre>

<hr>
<h2 id='LogisticNormal'>Initialization function for the &quot;LogisticNormal&quot; class</h2><span id='topic+LogisticNormal'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;LogisticNormal&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticNormal(mean, cov, refDose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticNormal_+3A_mean">mean</code></td>
<td>
<p>the prior mean vector</p>
</td></tr>
<tr><td><code id="LogisticNormal_+3A_cov">cov</code></td>
<td>
<p>the prior covariance matrix</p>
</td></tr>
<tr><td><code id="LogisticNormal_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+LogisticNormal-class">LogisticNormal</a></code> object
</p>

<hr>
<h2 id='LogisticNormal-class'>Standard logistic model with bivariate normal prior</h2><span id='topic+LogisticNormal-class'></span><span id='topic+.LogisticNormal'></span>

<h3>Description</h3>

<p>This is the usual logistic regression model with a bivariate normal prior on
the intercept and slope.
</p>


<h3>Details</h3>

<p>The covariate is the natural logarithm of the dose <code class="reqn">x</code> divided by
the reference dose <code class="reqn">x^{*}</code>:
</p>
<p style="text-align: center;"><code class="reqn">logit[p(x)] = \alpha + \beta \cdot \log(x/x^{*})</code>
</p>

<p>where <code class="reqn">p(x)</code> is the probability of observing a DLT for a given dose
<code class="reqn">x</code>.
</p>
<p>The prior is
</p>
<p style="text-align: center;"><code class="reqn">(\alpha, \beta) \sim Normal(\mu, \Sigma)</code>
</p>

<p>The slots of this class contain the mean vector, the covariance and
precision matrices of the bivariate normal distribution, as well as the
reference dose.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mean</code></dt><dd><p>the prior mean vector <code class="reqn">\mu</code></p>
</dd>
<dt><code>cov</code></dt><dd><p>the prior covariance matrix <code class="reqn">\Sigma</code></p>
</dd>
<dt><code>prec</code></dt><dd><p>the prior precision matrix <code class="reqn">\Sigma^{-1}</code></p>
</dd>
<dt><code>refDose</code></dt><dd><p>the reference dose <code class="reqn">x^{*}</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># Define the dose-grid
emptydata &lt;- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))


model &lt;- LogisticNormal(mean = c(-0.85, 1),
                        cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                        refDose = 50)

options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=1000)

options(error=recover)
mcmc(emptydata, model, options)
</code></pre>

<hr>
<h2 id='LogisticNormalFixedMixture'>Initialization function for the &quot;LogisticNormalFixedMixture&quot; class</h2><span id='topic+LogisticNormalFixedMixture'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;LogisticNormalFixedMixture&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticNormalFixedMixture(components, weights, refDose, logNormal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticNormalFixedMixture_+3A_components">components</code></td>
<td>
<p>the specifications of the mixture components: a list with
one list of <code>mean</code> and <code>cov</code> for each bivariate (log) normal prior</p>
</td></tr>
<tr><td><code id="LogisticNormalFixedMixture_+3A_weights">weights</code></td>
<td>
<p>the weights of the components, these must be positive and
will be normalized to sum to 1</p>
</td></tr>
<tr><td><code id="LogisticNormalFixedMixture_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose</p>
</td></tr>
<tr><td><code id="LogisticNormalFixedMixture_+3A_lognormal">logNormal</code></td>
<td>
<p>should a log normal prior be specified, such that the mean
vectors and covariance matrices are valid for the intercept and log slope?
(not default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+LogisticNormalFixedMixture-class">LogisticNormalFixedMixture</a></code> object
</p>

<hr>
<h2 id='LogisticNormalFixedMixture-class'>Standard logistic model with fixed mixture of multiple bivariate (log) normal priors</h2><span id='topic+LogisticNormalFixedMixture-class'></span><span id='topic+.LogisticNormalFixedMixture'></span>

<h3>Description</h3>

<p>This is standard logistic regression model with a mixture of multiple bivariate
(log) normal priors on the intercept and slope parameters. The weights of the
normal priors are fixed, hence no additional model parameters are introduced.
This type of prior is often used to better approximate a given posterior
distribution, or when the information is given in terms of a mixture.
</p>


<h3>Details</h3>

<p>The covariate is the natural logarithm of the dose <code class="reqn">x</code> divided by
the reference dose <code class="reqn">x^{*}</code>:
</p>
<p style="text-align: center;"><code class="reqn">logit[p(x)] = \alpha + \beta \cdot \log(x/x^{*})</code>
</p>

<p>where <code class="reqn">p(x)</code> is the probability of observing a DLT for a given dose
<code class="reqn">x</code>.
</p>
<p>The prior is
</p>
<p style="text-align: center;"><code class="reqn">(\alpha, \beta) \sim
\sum_{j=1}^{K} w_{j} Normal(\mu_{j}, \Sigma_{j})</code>
</p>

<p>if a normal prior is used and
</p>
<p style="text-align: center;"><code class="reqn">(\alpha, \log(\beta)) \sim
\sum_{j=1}^{K} w_{j} Normal(\mu_{j}, \Sigma_{j})</code>
</p>

<p>if a log normal prior is used.
</p>
<p>The weight <code class="reqn">w_{j}</code> of the components are fixed and sum to 1.
</p>
<p>The (additional) slots of this class comprise two lists, containing the mean
vector, the covariance and precision matrices of the two bivariate normal
distributions each, the parameters of the beta prior for the first component
weight, as well as the reference dose. Moreover, a slot specifies whether a
log normal prior is used.
</p>


<h3>Slots</h3>


<dl>
<dt><code>components</code></dt><dd><p>a list with one entry per component of the mixture.
Each entry is a list with <code>mean</code>, <code>cov</code> and <code>prec</code> for the
bivariate normal prior</p>
</dd>
<dt><code>weights</code></dt><dd><p>the weights of the components, these must be positive and sum
to 1</p>
</dd>
<dt><code>refDose</code></dt><dd><p>the reference dose <code class="reqn">x^{*}</code></p>
</dd>
<dt><code>logNormal</code></dt><dd><p>is a log normal prior specified for each of the components?</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- LogisticNormalFixedMixture(components = 
                                      list(comp1 = list(mean = c(-0.85, 1),
                                                        cov = matrix(c(1, -0.5, -0.5, 1), 
                                                                     nrow = 2)),
                                           comp2 = list(mean = c(1, 1.5),
                                                        cov = matrix(c(1.2, -0.45, -0.45, 0.6), 
                                                                     nrow = 2))),
                                    weights = c(0.3,0.7),
                                    refDose = 50)


</code></pre>

<hr>
<h2 id='LogisticNormalMixture'>Initialization function for the &quot;LogisticNormalMixture&quot; class</h2><span id='topic+LogisticNormalMixture'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;LogisticNormalMixture&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticNormalMixture(comp1, comp2, weightpar, refDose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticNormalMixture_+3A_comp1">comp1</code></td>
<td>
<p>the specifications of the first component: a list with
<code>mean</code> and <code>cov</code> for the first bivariate normal prior</p>
</td></tr>
<tr><td><code id="LogisticNormalMixture_+3A_comp2">comp2</code></td>
<td>
<p>the specifications of the second component</p>
</td></tr>
<tr><td><code id="LogisticNormalMixture_+3A_weightpar">weightpar</code></td>
<td>
<p>the beta parameters for the weight of the first component</p>
</td></tr>
<tr><td><code id="LogisticNormalMixture_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+LogisticNormalMixture-class">LogisticNormalMixture</a></code> object
</p>

<hr>
<h2 id='LogisticNormalMixture-class'>Standard logistic model with flexible mixture of two bivariate normal priors</h2><span id='topic+LogisticNormalMixture-class'></span><span id='topic+.LogisticNormalMixture'></span>

<h3>Description</h3>

<p>This is standard logistic regression model with a mixture of two bivariate
normal priors on the intercept and slope parameters. The weight of the two
normal priors is a model parameter, hence it is a flexible mixture.
This type of prior is often used with a mixture of a minimal informative
and an informative component, in order to make the CRM more robust to
data deviations from the informative component.
</p>


<h3>Details</h3>

<p>The covariate is the natural logarithm of the dose <code class="reqn">x</code> divided by
the reference dose <code class="reqn">x^{*}</code>:
</p>
<p style="text-align: center;"><code class="reqn">logit[p(x)] = \alpha + \beta \cdot \log(x/x^{*})</code>
</p>

<p>where <code class="reqn">p(x)</code> is the probability of observing a DLT for a given dose
<code class="reqn">x</code>.
</p>
<p>The prior is
</p>
<p style="text-align: center;"><code class="reqn">(\alpha, \beta) \sim
w * Normal(\mu_{1}, \Sigma_{1}) + (1 - w) * Normal(\mu_{2}, \Sigma_{2})</code>
</p>

<p>The weight w for the first component is assigned a beta prior B(a, b).
</p>
<p>The slots of this class comprise two lists, containing the mean vector, the
covariance and precision matrices of the two bivariate normal distributions
each, the parameters of the beta prior for the first component weight, as
well as the reference dose.
</p>


<h3>Slots</h3>


<dl>
<dt><code>comp1</code></dt><dd><p>the specifications of the first component: a list with
<code>mean</code>, <code>cov</code> and <code>prec</code> for the first bivariate normal prior</p>
</dd>
<dt><code>comp2</code></dt><dd><p>the specifications of the second component</p>
</dd>
<dt><code>weightpar</code></dt><dd><p>the beta parameters for the weight of the first component</p>
</dd>
<dt><code>refDose</code></dt><dd><p>the reference dose <code class="reqn">x^{*}</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- LogisticNormalMixture(comp1 = list(mean = c(-0.85, 1),
                                            cov = matrix(c(1, -0.5, -0.5, 1), 
                                                         nrow = 2)),
                               comp2 = list(mean = c(1, 1.5),
                                            cov = matrix(c(1.2, -0.45, -0.45, 0.6), 
                                                         nrow = 2)),
                               weightpar = c(a=1, b=1),
                               refDose = 50)


</code></pre>

<hr>
<h2 id='logit'>Shorthand for logit function</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Shorthand for logit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>the function argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the logit(x)
</p>

<hr>
<h2 id='matchTolerance'>Helper function for value matching with tolerance</h2><span id='topic+matchTolerance'></span><span id='topic++25~+25'></span>

<h3>Description</h3>

<p>This is a modified version of <code>match</code> that supports tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchTolerance(x, table)

x %~% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchTolerance_+3A_x">x</code></td>
<td>
<p>the values to be matched</p>
</td></tr>
<tr><td><code id="matchTolerance_+3A_table">table</code></td>
<td>
<p>the values to be matched against</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>x %~% table</code>: Helper function for checking inclusion in a table with tolerance
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>myDose &lt;- c(rep(0.030, 6), rep(0.050, 3), rep(0.075, 4), rep(0.1, 9), rep(0.15, 7))
doseGrid &lt;- seq(from = .025, to = .15, by = .005)

myDose %in% doseGrid
matchTolerance(myDose, doseGrid)
myDose %~% doseGrid

matchTolerance(c(myDose, 500), doseGrid)
c(myDose, 500) %~% doseGrid
</code></pre>

<hr>
<h2 id='maxDose'>Determine the maximum possible next dose</h2><span id='topic+maxDose'></span><span id='topic+maxDose+2CIncrementsRelative+2CData-method'></span><span id='topic+maxDose+2CIncrementsNumDoseLevels+2CData-method'></span><span id='topic+maxDose+2CIncrementsRelativeParts+2CDataParts-method'></span><span id='topic+maxDose+2CIncrementsRelativeDLT+2CData-method'></span><span id='topic+maxDose+2CIncrementMin+2CData-method'></span>

<h3>Description</h3>

<p>Determine the upper limit of the next dose based on the increments rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxDose(increments, data, ...)

## S4 method for signature 'IncrementsRelative,Data'
maxDose(increments, data, ...)

## S4 method for signature 'IncrementsNumDoseLevels,Data'
maxDose(increments, data, ...)

## S4 method for signature 'IncrementsRelativeParts,DataParts'
maxDose(increments, data, ...)

## S4 method for signature 'IncrementsRelativeDLT,Data'
maxDose(increments, data, ...)

## S4 method for signature 'IncrementMin,Data'
maxDose(increments, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxDose_+3A_increments">increments</code></td>
<td>
<p>The rule, an object of class
<code><a href="#topic+Increments-class">Increments</a></code></p>
</td></tr>
<tr><td><code id="maxDose_+3A_data">data</code></td>
<td>
<p>The data input, an object of class <code><a href="#topic+Data-class">Data</a></code></p>
</td></tr>
<tr><td><code id="maxDose_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function outputs the maximum possible next dose, based on the
corresponding rule <code>increments</code> and the <code>data</code>.
</p>


<h3>Value</h3>

<p>the maximum possible next dose
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>maxDose(increments = IncrementsRelative, data = Data)</code>: Determine the maximum possible next dose based on
relative increments
</p>
</li>
<li> <p><code>maxDose(increments = IncrementsNumDoseLevels, data = Data)</code>: Determine the maximum possible next dose based on
maximum dose levels to increment for the next dose
</p>
</li>
<li> <p><code>maxDose(increments = IncrementsRelativeParts, data = DataParts)</code>: Determine the maximum possible next dose based on
relative increments and part 1 and 2
</p>
</li>
<li> <p><code>maxDose(increments = IncrementsRelativeDLT, data = Data)</code>: Determine the maximum possible next dose based on
relative increments determined by DLTs so far
</p>
</li>
<li> <p><code>maxDose(increments = IncrementMin, data = Data)</code>: Determine the maximum possible next dose based on
multiple increment rules (taking the minimum across individual increments).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6, 8,
                 seq(from=10, to=80, by=2)))


# In this example we define a rule for dose increments which would allow:
#   - doubling the dose if the last dose was below 20
#   - only increasing the dose by 1.33 if the last dose was equal or above 20
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Based on the rule above, we then calculate the maximum dose allowed
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6, 8,
                 seq(from=10, to=80, by=2)))


# In this example we define a rule for dose increments which would allow:
# maximum skip one dose level, that is 2 dose levels higher is maximum
# increment
myIncrements &lt;- IncrementsNumDoseLevels(maxLevels=2)

# Based on the rule above, we then calculate the maximum dose allowed
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)


# create an object of class 'DataParts'
myData &lt;- DataParts(x=c(0.1,0.5,1.5),
                    y=c(0,0,0),
                    doseGrid=c(0.1,0.5,1.5,3,6,
                               seq(from=10,to=80,by=2)),
                    part=c(1L,1L,1L),
                    nextPart=1L,
                    part1Ladder=c(0.1,0.5,1.5,3,6,10))


myIncrements &lt;- IncrementsRelativeParts(dltStart=0,
                                        cleanStart=1)

nextMaxDose &lt;- maxDose(myIncrements,
                       data=myData)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))


# In this example we define a rule for dose increments which would allow:
#   - doubling the dose if no DLTs were yet observed
#   - only increasing the dose by 1.33 if 1 or 2 DLTs were already observed
#   - only increasing the dose by 1.2 if at least 3 DLTs were already observed
myIncrements &lt;- IncrementsRelativeDLT(DLTintervals = c(0, 1, 3),
                                      increments = c(1, 0.33, 0.2))

# Based on the rule above, we then calculate the maximum dose allowed
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6, 8,
                 seq(from=10, to=80, by=2)))


# As example, here we are combining 2 different increment rules. 

# The first rule is the following: 
#      maximum doubling the dose if no DLTs were observed at the current dose
#      or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose
#      or maximum increasing the dose by 1.22 if 3 or more DLTs were observed

# The second rule is the following: 
#   maximum doubling the dose if the current dose is &lt;20
#   OR only maximum increasing the dose by 1.33 if the current dose is &gt;=20

myIncrements1 &lt;- IncrementsRelativeDLT(DLTintervals = c(0, 1, 3),
                                       increments = c(1, 0.33, 0.2))

myIncrements2 &lt;- IncrementsRelative(intervals=c(0, 20),
                                    increments=c(1, 0.33))

# Now we combine the 2 rules
combIncrement &lt;- IncrementMin(IncrementsList=
                                list(myIncrements1,myIncrements2))

# Finally we then calculate the maximum dose allowed by taking the minimum of the two rules
nextMaxDose &lt;- maxDose(combIncrement, 
                       data)

</code></pre>

<hr>
<h2 id='maxSize'>&quot;MAX&quot; combination of cohort size rules</h2><span id='topic+maxSize'></span><span id='topic+maxSize+2CCohortSize-method'></span>

<h3>Description</h3>

<p>This function combines cohort size rules by taking
the maximum of all sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxSize(...)

## S4 method for signature 'CohortSize'
maxSize(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxSize_+3A_...">...</code></td>
<td>
<p>Objects of class <code><a href="#topic+CohortSize-class">CohortSize</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the combination as an object of class
<code><a href="#topic+CohortSizeMax-class">CohortSizeMax</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>maxSize(CohortSize)</code>: The method combining cohort size rules by taking maximum
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+minSize">minSize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Here is the rule for: 
#   having cohort of size 1 for doses &lt;30
#   and having cohort of size 3 for doses &gt;=30
mySize1 &lt;- CohortSizeRange(intervals = c(0, 30),
                           cohortSize = c(1, 3))

# Here is the rule for: 
#   having cohort of size 1 until no DLT were observed
#   and having cohort of size 3 as soon as 1 DLT is observed
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))

# This is combining the two rules above by taking the maximum of the sample sizes of
# the single rules
mySize &lt;- maxSize(mySize1, mySize2)

</code></pre>

<hr>
<h2 id='mcmc'>Obtain posterior samples for all model parameters</h2><span id='topic+mcmc'></span><span id='topic+mcmc+2CGeneralData+2CGeneralModel+2CMcmcOptions-method'></span><span id='topic+mcmc+2CDataMixture+2CGeneralModel+2CMcmcOptions-method'></span><span id='topic+mcmc+2CData+2CLogisticIndepBeta+2CMcmcOptions-method'></span><span id='topic+mcmc+2CDataDual+2CEffloglog+2CMcmcOptions-method'></span><span id='topic+mcmc+2CDataDual+2CEffFlexi+2CMcmcOptions-method'></span>

<h3>Description</h3>

<p>This is the function to actually run the MCMC machinery to produce posterior
samples from all model parameters and required derived values. It is a
generic function, so that customized versions may be conveniently defined
for specific subclasses of GeneralData, GeneralModel, and McmcOptions input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc(data, model, options, ...)

## S4 method for signature 'GeneralData,GeneralModel,McmcOptions'
mcmc(
  data,
  model,
  options,
  program = c("JAGS"),
  verbose = FALSE,
  fromPrior = data@nObs == 0L,
  ...
)

## S4 method for signature 'DataMixture,GeneralModel,McmcOptions'
mcmc(
  data,
  model,
  options,
  fromPrior = data@nObs == 0L &amp; data@nObsshare == 0L,
  ...
)

## S4 method for signature 'Data,LogisticIndepBeta,McmcOptions'
mcmc(data, model, options, ...)

## S4 method for signature 'DataDual,Effloglog,McmcOptions'
mcmc(data, model, options, ...)

## S4 method for signature 'DataDual,EffFlexi,McmcOptions'
mcmc(data, model, options, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_+3A_data">data</code></td>
<td>
<p>The data input, an object of class <code><a href="#topic+GeneralData-class">GeneralData</a></code></p>
</td></tr>
<tr><td><code id="mcmc_+3A_model">model</code></td>
<td>
<p>The model input, an object of class <code><a href="#topic+GeneralModel-class">GeneralModel</a></code></p>
</td></tr>
<tr><td><code id="mcmc_+3A_options">options</code></td>
<td>
<p>MCMC options, an object of class
<code><a href="#topic+McmcOptions-class">McmcOptions</a></code></p>
</td></tr>
<tr><td><code id="mcmc_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="mcmc_+3A_program">program</code></td>
<td>
<p>the program which shall be used: currently only &ldquo;JAGS&rdquo;
is supported</p>
</td></tr>
<tr><td><code id="mcmc_+3A_verbose">verbose</code></td>
<td>
<p>shall progress bar and messages be printed? (not default)</p>
</td></tr>
<tr><td><code id="mcmc_+3A_fromprior">fromPrior</code></td>
<td>
<p>sample from the prior only? Defaults to checking if nObs is
0. For some models it might be necessary to specify it manually here though.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reproducible samples can be obtained by setting the seed via
<code><a href="base.html#topic+set.seed">set.seed</a></code> before in the user code as usual. However, note that
because the RNG sampler used is external to R, running this MCMC function
will not change the seed position &ndash; that is, the repeated call to this
function will then result in exactly the same output.
</p>


<h3>Value</h3>

<p>The posterior samples, an object of class
<code><a href="#topic+Samples-class">Samples</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mcmc(data = GeneralData, model = GeneralModel, options = McmcOptions)</code>: Standard method which uses JAGS
</p>
</li>
<li> <p><code>mcmc(data = DataMixture, model = GeneralModel, options = McmcOptions)</code>: Method for DataMixture with different fromPrior default
</p>
</li>
<li> <p><code>mcmc(data = Data, model = LogisticIndepBeta, options = McmcOptions)</code>: Obtain posterior samples for the model parameters based on the pseudo 'LogisticsIndepBeta'
DLE model. The joint prior and posterior probability density function of 
the intercept <code class="reqn">\phi_1</code> (phi1) and the slope <code class="reqn">\phi_2</code> (phi2) are given in Whitehead and 
Williamson (1998) and TsuTakawa (1975). However, since asymptotically, the joint posterior probability density 
will be bivariate normal and we will use the bivariate normal distribution to
generate posterior samples of the intercept and the slope parameters. For the prior samples of 
of the intercept and the slope a bivariate normal distribution with mean and the covariance matrix given in Whitehead and 
Williamson (1998) is used.
</p>
</li>
<li> <p><code>mcmc(data = DataDual, model = Effloglog, options = McmcOptions)</code>: Obtain the posterior samples for the model parameters in the 
Efficacy log log model. Given the value of <code class="reqn">\nu</code>, the precision of the efficacy responses,
the joint prior or the posterior probability of the intercept <code class="reqn">\theta_1</code> (theta1) and 
the slope <code class="reqn">\theta_2</code> (theta2) is a bivariate normal distribtuion. The  <code class="reqn">\nu</code> (nu), 
the precision of the efficacy responses is either a fixed value or has a gamma distribution.
If a gamma distribution is used, the samples of nu will be first generated. 
Then the mean of the of the nu samples 
will be used the generate samples of the intercept and slope parameters of the model
</p>
</li>
<li> <p><code>mcmc(data = DataDual, model = EffFlexi, options = McmcOptions)</code>: Obtain the posterior samples for the estimates in the Efficacy Flexible form.
This is the mcmc procedure based on what is described in Lang and Brezger (2004) such that 
samples of the mean efficacy responses at all dose levels, samples of sigma2 <code class="reqn">sigma^2</code>, 
the variance of the efficacy response and samples of sigma2betaW <code class="reqn">sigma^2_{beta_W}</code>, the variance of
the random walk model will
be generated. Please refer to Lang and Brezger (2004) for the procedures and the form of 
the joint prior and posterior probability density for the mean efficay responses. In addition,
both sigma2 and sigma2betaW acan be fixed or having an inverse-gamma prior and posterior distribution. 
Therefore, if the inverse gamma distribution(s) are used, the parameters in the distribution will be 
first updated and then samples of sigma2 and sigma2betaW will be generated using the updated parameters.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# create some data from the class 'Data'
myData &lt;- Data(x=c(0.1,0.5,1.5,3,6,10,10,10),
               y=c(0,0,0,0,0,0,1,0),
               doseGrid=c(0.1,0.5,1.5,3,6,
                          seq(from=10,to=80,by=2)))

# Initialize the CRM model 
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)


# Sample from the posterior distribution
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=1000)

samples &lt;- mcmc(data = myData, model = model, options=options)


##obtain mcmc DLE samples given the data, LogisticIndepBeta (DLE model) and mcmc simulations options
## data must be of 'Data' class
data&lt;-Data(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(25,300,25))
## model must be of 'LogisticIndepBeta' class
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
## options must be ''McmcOptions' class
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
set.seed(94)
samples&lt;-mcmc(data=data,model=model,options=options)
##obtain mcmc efficacy samples given the data, 'Effloglog' model (efficacy model) and
## mcmc simulations options data must be of 'DataDual' class
data&lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
              y=c(0,0,0,0,0,1,1,0),
              w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
              doseGrid=seq(25,300,25),placebo=FALSE)
## model must be of 'Effloglog' class
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)

## options must be ''McmcOptions' class
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
set.seed(94)
samples&lt;-mcmc(data=data,model=Effmodel,options=options)
##obtain mcmc efficacy samples given the data, 'EffFlexi' model (efficacy model) and 
## mcmc simulations options
## data must be of 'DataDual' class
data&lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
               y=c(0,0,0,0,0,1,1,0),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25))
## model must be of 'EffFlexi' class

Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)

## options must be ''McmcOptions' class
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
set.seed(94)
samples&lt;-mcmc(data=data,model=Effmodel,options=options)
</code></pre>

<hr>
<h2 id='McmcOptions'>Initialization function for the &quot;McmcOptions&quot; class</h2><span id='topic+McmcOptions'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;McmcOptions&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>McmcOptions(burnin = 10000L, step = 2L, samples = 10000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="McmcOptions_+3A_burnin">burnin</code></td>
<td>
<p>number of burn-in iterations which are not saved (default:
<code>10,000</code>)</p>
</td></tr>
<tr><td><code id="McmcOptions_+3A_step">step</code></td>
<td>
<p>only every step-th iteration is saved after the burn-in
(default: <code>2</code>)</p>
</td></tr>
<tr><td><code id="McmcOptions_+3A_samples">samples</code></td>
<td>
<p>number of resulting samples (by default <code>10,000</code> will
result)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+McmcOptions-class">McmcOptions</a></code> object
</p>

<hr>
<h2 id='McmcOptions-class'>Class for the three canonical MCMC options</h2><span id='topic+McmcOptions-class'></span><span id='topic+.McmcOptions'></span>

<h3>Description</h3>

<p>Class for the three canonical MCMC options
</p>


<h3>Slots</h3>


<dl>
<dt><code>iterations</code></dt><dd><p>number of MCMC iterations</p>
</dd>
<dt><code>burnin</code></dt><dd><p>number of burn-in iterations which are not saved</p>
</dd>
<dt><code>step</code></dt><dd><p>only every step-th iteration is saved after the burn-in</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set up MCMC option in order to have a burn-in of 10000 iterations and
# then take every other iteration up to a collection of 10000 samples
options &lt;- McmcOptions(burnin=10000,
                       step=2,
                       samples=10000)

</code></pre>

<hr>
<h2 id='MinimalInformative'>Construct a minimally informative prior</h2><span id='topic+MinimalInformative'></span>

<h3>Description</h3>

<p>This function constructs a minimally informative prior, which is captured in
a <code><a href="#topic+LogisticNormal-class">LogisticNormal</a></code> (or
<code><a href="#topic+LogisticLogNormal-class">LogisticLogNormal</a></code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinimalInformative(
  dosegrid,
  refDose,
  threshmin = 0.2,
  threshmax = 0.3,
  probmin = 0.05,
  probmax = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinimalInformative_+3A_dosegrid">dosegrid</code></td>
<td>
<p>the dose grid</p>
</td></tr>
<tr><td><code id="MinimalInformative_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose</p>
</td></tr>
<tr><td><code id="MinimalInformative_+3A_threshmin">threshmin</code></td>
<td>
<p>Any toxicity probability above this threshold would
be very unlikely (see <code>probmin</code>) at the minimum dose (default: 0.2)</p>
</td></tr>
<tr><td><code id="MinimalInformative_+3A_threshmax">threshmax</code></td>
<td>
<p>Any toxicity probability below this threshold would
be very unlikely (see <code>probmax</code>) at the maximum dose (default: 0.3)</p>
</td></tr>
<tr><td><code id="MinimalInformative_+3A_probmin">probmin</code></td>
<td>
<p>the prior probability of exceeding <code>threshmin</code> at the
minimum dose (default: 0.05)</p>
</td></tr>
<tr><td><code id="MinimalInformative_+3A_probmax">probmax</code></td>
<td>
<p>the prior probability of being below <code>threshmax</code> at the
maximum dose (default: 0.05)</p>
</td></tr>
<tr><td><code id="MinimalInformative_+3A_...">...</code></td>
<td>
<p>additional arguments for computations, see
<code><a href="#topic+Quantiles2LogisticNormal">Quantiles2LogisticNormal</a></code>, e.g. <code>refDose</code> and
<code>logNormal=TRUE</code> to obtain a minimal informative log normal prior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the proposal by Neuenschwander et al (2008, Statistics in
Medicine), a minimally informative prior distribution is constructed. The
required key input is the minimum (<code class="reqn">d_{1}</code> in the notation of the
Appendix A.1 of that paper) and the maximum value (<code class="reqn">d_{J}</code>) of the dose
grid supplied to this function. Then <code>threshmin</code> is the probability
threshold <code class="reqn">q_{1}</code>, such that any probability of DLT larger than
<code class="reqn">q_{1}</code> has only 5% probability. Therefore <code class="reqn">q_{1}</code> is the 95%
quantile of the beta distribution and hence <code class="reqn">p_{1} = 0.95</code>. Likewise,
<code>threshmax</code> is the probability threshold <code class="reqn">q_{J}</code>, such that any
probability of DLT smaller than <code class="reqn">q_{J}</code> has only 5% probability
(<code class="reqn">p_{J} = 0.05</code>). The probabilities <code class="reqn">1 - p_{1}</code> and <code class="reqn">p_{J}</code> can be 
controlled with the arguments <code>probmin</code> and <code>probmax</code>, respectively. 
Subsequently, for all doses supplied in the
<code>dosegrid</code> argument, beta distributions are set up from the assumption
that the prior medians are linear in log-dose on the logit scale, and
<code><a href="#topic+Quantiles2LogisticNormal">Quantiles2LogisticNormal</a></code> is used to transform the resulting
quantiles into an approximating <code><a href="#topic+LogisticNormal-class">LogisticNormal</a></code> (or
<code><a href="#topic+LogisticLogNormal-class">LogisticLogNormal</a></code>) model. Note that the reference dose
is not required for these computations.
</p>


<h3>Value</h3>

<p>see <code><a href="#topic+Quantiles2LogisticNormal">Quantiles2LogisticNormal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setting up a minimal informative prior 
# max.time is quite small only for the purpose of showing the example. They 
# should be increased for a real case.
set.seed(132)
coarseGrid &lt;- c(0.1, 10, 30, 60, 100)
minInfModel &lt;- MinimalInformative(dosegrid = coarseGrid,
                                  refDose=50,
                                  threshmin=0.2,
                                  threshmax=0.3,
                                  control=## for real case: leave out control 
                                    list(max.time=0.1)) 

# Plotting the result
matplot(x=coarseGrid,
        y=minInfModel$required,
        type="b", pch=19, col="blue", lty=1,
        xlab="dose",
        ylab="prior probability of DLT")
matlines(x=coarseGrid,
         y=minInfModel$quantiles,
         type="b", pch=19, col="red", lty=1)
legend("right",
       legend=c("quantiles", "approximation"),
       col=c("blue", "red"),
       lty=1,
       bty="n")

</code></pre>

<hr>
<h2 id='minSize'>&quot;MIN&quot; combination of cohort size rules</h2><span id='topic+minSize'></span><span id='topic+minSize+2CCohortSize-method'></span>

<h3>Description</h3>

<p>This function combines cohort size rules by taking
the minimum of all sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minSize(...)

## S4 method for signature 'CohortSize'
minSize(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minSize_+3A_...">...</code></td>
<td>
<p>Objects of class <code><a href="#topic+CohortSize-class">CohortSize</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the combination as an object of class
<code><a href="#topic+CohortSizeMin-class">CohortSizeMin</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>minSize(CohortSize)</code>: The method combining cohort size rules by taking minimum
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+maxSize">maxSize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Here is the rule for: 
#   having cohort of size 1 for doses &lt;30
#   and having cohort of size 3 for doses &gt;=30
mySize1 &lt;- CohortSizeRange(intervals = c(0, 30),
                           cohortSize = c(1, 3))

# Here is the rule for: 
#   having cohort of size 1 until no DLT were observed
#   and having cohort of size 3 as soon as 1 DLT is observed
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))

# This is combining the two rules above by taking the minimum of the sample sizes of
# the single rules
mySize &lt;- minSize(mySize1, mySize2)

</code></pre>

<hr>
<h2 id='Model-class'>Class for the model input</h2><span id='topic+Model-class'></span><span id='topic+.Model'></span>

<h3>Description</h3>

<p>This is the model class for single agent dose escalation,
from which all other specific models inherit. It inherits all slots
from <code><a href="#topic+GeneralModel-class">GeneralModel</a></code>.
</p>


<h3>Details</h3>

<p>The <code>datamodel</code> must obey the convention that the data input is
called exactly as in the <code><a href="#topic+Data-class">Data</a></code> class.
All prior distributions for parameters should be contained in the
model function <code>priormodel</code>. The background is that this can
be used to simulate from the prior distribution, before obtaining any
data.
</p>
<p>The <code>dose</code> function has as first argument <code>prob</code>, a scalar
toxicity probability which is targeted. Additional arguments are model
parameters. Then it computes, using model parameter(s) (samples), the
resulting dose. Note that the model parameters are called exactly as in the
<code>model</code> and must be included in the <code>sample</code> vector. The vectors
of all samples for these parameters will then be supplied to the function.
So your function must be able to process vectors of the model parameters,
i.e. it must vectorize over them.
</p>
<p>The <code>prob</code> function has as first argument <code>dose</code>, which is a
scalar dose. Additional arguments are model parameters. Then it computes,
using model parameter(s) (samples), the resulting probability of toxicity at
that dose. Again here, the function must vectorize over the model
parameters.
</p>
<p>If you work with multivariate parameters, then please assume that your
the two functions receive either one parameter value as a row vector,
or a samples matrix where the rows correspond to the sampling index, i.e.
the layout is then nSamples x dimParameter.
</p>
<p>Note that <code>dose</code> and <code>prob</code> are the inverse functions of each
other.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dose</code></dt><dd><p>a function computing the dose reaching a specific target
probability, based on the model parameters and additional prior settings
(see the details above)</p>
</dd>
<dt><code>prob</code></dt><dd><p>a function computing the probability of toxicity for a specific
dose, based on the model parameters and additional prior settings (see the
details above)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+LogisticNormal-class">LogisticNormal</a></code>,
<code><a href="#topic+LogisticLogNormal-class">LogisticLogNormal</a></code>,
<code><a href="#topic+LogisticLogNormalSub-class">LogisticLogNormalSub</a></code>,
<code><a href="#topic+LogisticKadane-class">LogisticKadane</a></code>,
<code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code>
</p>

<hr>
<h2 id='ModelEff-class'>No Initialization function
class for Efficacy models using pseudo data prior</h2><span id='topic+ModelEff-class'></span><span id='topic+.ModelEff'></span>

<h3>Description</h3>

<p>This is a class of which contains all efficacy models for which their prior are specified in 
form of pseudo data. It inherits all slots from <code><a href="#topic+ModelPseudo-class">ModelPseudo</a></code>
</p>


<h3>Details</h3>

<p>The <code>dose</code> function has a first argument <code>ExpEff</code>, a scalar expected efficacy value 
which is targeted. Additional arguements are model parameters. It computes using modal estimate(s)
or samples model parameter(s), the resulting expected efficacy value at that dose level. If samples
of the model parameters are used, the function must vectorize over the model parameters.
</p>
<p>The <code>ExpEff</code> function has a first argument <code>dose</code>, a scalar dose level which is targeted. 
Additional arguments are model parameters. It computes using modal estimates or samples of the
model parameter(s), the resulting dose level given that particular expected efficacy value. If samples
of the model parameter(s) are used, the function must vectorize over the model parameters.
</p>
<p>The <code>data</code> must obey the covention that the data input is called exactly in the 
<code><a href="#topic+DataDual-class">DataDual</a></code> class. This refers to any observed Efficacy/biomarker responses 
(<code>w</code> in 
<code><a href="#topic+DataDual-class">DataDual</a></code> class), the dose (levels) (<code>x</code> in <code><a href="#topic+DataDual-class">DataDual</a></code> or
<code>Data</code> class)
at which these responses are observed, all dose levels considered in the study (<code>doseGrid</code>
in <code><a href="#topic+DataDual-class">DataDual</a></code> or <code>Data</code>) class and other specifications in 
<code><a href="#topic+DataDual-class">DataDual</a></code>
class that can be used to generate prior or
posterior modal estimates or samples estimates for model parmater(s). If no responses is observed,
at least <code>doseGrid</code> in <code><a href="#topic+DataDual-class">DataDual</a></code> has to be specified in <code>data</code> slot
for which prior modal estimates or samples can be obtained for model parameters based on 
the specified pseudo data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dose</code></dt><dd><p>a function computing the dose reaching a specific target value of expected efficacy, based
on the model parameter(s). The model parameter(s) (samples) are obtained based on prior specified 
in form of pseudo data and if any together with any observed responses (see details above)</p>
</dd>
<dt><code>ExpEff</code></dt><dd><p>a function computing the expected efficacy (value) for a specific dose, based on model 
parameter(s). The model parameter(s) (samples) are obtained based on pseudo data prior and (if any) 
with observed responses (see details above)</p>
</dd>
<dt><code>data</code></dt><dd><p>refers to the data input specification in <code><a href="#topic+DataDual-class">DataDual</a></code> class which are used to
obtain model paramters estimates or samples (see details above)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Effloglog-class">Effloglog</a></code>,
<code><a href="#topic+EffFlexi-class">EffFlexi</a></code>
</p>

<hr>
<h2 id='ModelPseudo-class'>Class of models using expressing their prior in form of Pseudo data</h2><span id='topic+ModelPseudo-class'></span><span id='topic+.ModelPseudo'></span>

<h3>Description</h3>

<p>This is the Pseudo model class, from which all models where their prior 
are expressed in form of pseudo data (as if some data are 
available before the trial starts) inherit. It also inherits all slots
from <code><a href="#topic+AllModels-class">AllModels</a></code>.No slots for this class
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code>,
<code><a href="#topic+Effloglog-class">Effloglog</a></code>,
<code><a href="#topic+EffFlexi-class">EffFlexi</a></code>
</p>

<hr>
<h2 id='ModelTox-class'>No intialization function
Class for DLE models using pseudo data prior. 
This is a class of DLE (dose-limiting events) models/ toxicity model which contains all DLE models 
for which their prior are specified in form of pseudo data (as if there is some data before
the trial starts). It inherits all slots from <code><a href="#topic+ModelPseudo-class">ModelPseudo</a></code></h2><span id='topic+ModelTox-class'></span><span id='topic+.ModelTox'></span>

<h3>Description</h3>

<p>The <code>dose</code> function has a first argument <code>prob</code>, a scalar a probability of 
the occurrence of a DLE which is targeted. Additional arguments are models parameters. 
It computes, using the model parameter(s)/ model parameter(s) samples, the resulting dose. 
Note that the model parameters are called exactly as in the <code>model</code>. The model estimates 
generated can be single values of the maximum likelihodd estimates (prior or posterior modal
estimates) or samples of the model estimates generated. If samples of the model estimates are
generated, the model parameters (samples) must be included in the <code>samples</code> vector.
The vectors of all samples for these model paramters will be supplied to the function such 
that the function will be able to process vectors of model parameters.
</p>


<h3>Details</h3>

<p>The <code>prob</code> function has a first argument <code>dose</code>, a scalar dose level which is targeted.
Additional arguments are model paramters. It computes using model paramter(s) (samples), the 
resulting probabilities of a DLE occuring at the target dose level. If samples of model parameters
are generated, the function must vectorize over the model parameters.
</p>
<p>Note that <code>dose</code> and <code>prob</code> are the inverse functions of each other.
</p>
<p>The <code>data</code> must obey the covention that the data input is called exactly in the 
<code><a href="#topic+Data-class">Data</a></code> class. This refers to any observed DLE responses (<code>y</code> in 
<code><a href="#topic+Data-class">Data</a></code> class), the dose (levels) (<code>x</code> in <code><a href="#topic+Data-class">Data</a></code> class)
at which these responses are observed, all dose levels considered in the study (<code>doseGrid</code>
in <code><a href="#topic+Data-class">Data</a></code>) class and other specifications in <code><a href="#topic+Data-class">Data</a></code>
class that can be used to generate prior or
posterior modal estimates or samples estimates for model parmater(s). If no responses is observed,
at least <code>doseGrid</code> in <code><a href="#topic+Data-class">Data</a></code> has to be specified in <code>data</code> slot for which
prior modal estimates or samples can be obtained for model parameters based on the specified pseudo 
data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dose</code></dt><dd><p>a function computing the dose level reaching a specific target probabilty of the occurrence 
of a DLE, based on the model parameters. The model paramters (samples)are obtained based on the prior 
specified in form of pseudo data and together with (if any) the observed
DLE responses and their corresponding dose levels (see details above)</p>
</dd>
<dt><code>prob</code></dt><dd><p>a function computing the probability of the occurrence of a DLEat a specidfied dose level, 
based on the model parameters. The model paramters (samples) are obtained the prior specified in form 
of pseudo data and together with (if any) the observed DLE responses and their 
corresponding dose levels (see dtails above)</p>
</dd>
<dt><code>data</code></dt><dd><p>refers to the data input specification in <code><a href="#topic+Data-class">Data</a></code> class which are used to
obtain model paramters estimates or samples (see details above)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code>,
<code><a href="#topic+Effloglog-class">Effloglog</a></code>,
<code><a href="#topic+EffFlexi-class">EffFlexi</a></code>
</p>

<hr>
<h2 id='multiplot'>Multiple plot function</h2><span id='topic+multiplot'></span>

<h3>Description</h3>

<p>ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects).
If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
then plot 1 will go in the upper left, 2 will go in the upper right, and
3 will go all the way across the bottom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplot(..., plotlist = NULL, rows = 1, layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplot_+3A_...">...</code></td>
<td>
<p>Objects to be passed</p>
</td></tr>
<tr><td><code id="multiplot_+3A_plotlist">plotlist</code></td>
<td>
<p>a list of additional objects</p>
</td></tr>
<tr><td><code id="multiplot_+3A_rows">rows</code></td>
<td>
<p>Number of rows in layout</p>
</td></tr>
<tr><td><code id="multiplot_+3A_layout">layout</code></td>
<td>
<p>A matrix specifying the layout. If present, <code>rows</code> 
is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for the side effect of plotting
</p>

<hr>
<h2 id='myBarplot'>Convenience function to make barplots of percentages</h2><span id='topic+myBarplot'></span>

<h3>Description</h3>

<p>Convenience function to make barplots of percentages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myBarplot(x, description, xaxisround = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myBarplot_+3A_x">x</code></td>
<td>
<p>vector of samples</p>
</td></tr>
<tr><td><code id="myBarplot_+3A_description">description</code></td>
<td>
<p>xlab string</p>
</td></tr>
<tr><td><code id="myBarplot_+3A_xaxisround">xaxisround</code></td>
<td>
<p>rounding for xaxis labels (default: 0, i.e. integers will
be used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crmPack:::myBarplot(rpois(n=100, lambda=2), 
                    "test")
</code></pre>

<hr>
<h2 id='myBayesLogit'>Do MCMC sampling for Bayesian logistic regression model</h2><span id='topic+myBayesLogit'></span>

<h3>Description</h3>

<p>Do MCMC sampling for Bayesian logistic regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myBayesLogit(y, X, m0, P0, options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myBayesLogit_+3A_y">y</code></td>
<td>
<p>0/1 vector of responses</p>
</td></tr>
<tr><td><code id="myBayesLogit_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="myBayesLogit_+3A_m0">m0</code></td>
<td>
<p>prior mean vector</p>
</td></tr>
<tr><td><code id="myBayesLogit_+3A_p0">P0</code></td>
<td>
<p>precision matrix</p>
</td></tr>
<tr><td><code id="myBayesLogit_+3A_options">options</code></td>
<td>
<p>McmcOptions object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix of samples (samples x parameters)
</p>

<hr>
<h2 id='nextBest'>Find the next best dose</h2><span id='topic+nextBest'></span><span id='topic+nextBest+2CNextBestMTD+2Cnumeric+2CSamples+2CModel+2CData-method'></span><span id='topic+nextBest+2CNextBestNCRM+2Cnumeric+2CSamples+2CModel+2CData-method'></span><span id='topic+nextBest+2CNextBestNCRM+2Cnumeric+2CSamples+2CModel+2CDataParts-method'></span><span id='topic+nextBest+2CNextBestThreePlusThree+2Cmissing+2Cmissing+2Cmissing+2CData-method'></span><span id='topic+nextBest+2CNextBestDualEndpoint+2Cnumeric+2CSamples+2CDualEndpoint+2CData-method'></span><span id='topic+nextBest+2CNextBestTDsamples+2Cnumeric+2CSamples+2CLogisticIndepBeta+2CData-method'></span><span id='topic+nextBest+2CNextBestTD+2Cnumeric+2Cmissing+2CLogisticIndepBeta+2CData-method'></span><span id='topic+nextBest+2CNextBestMaxGain+2Cnumeric+2Cmissing+2CModelTox+2CDataDual-method'></span><span id='topic+nextBest+2CNextBestMaxGainSamples+2Cnumeric+2CSamples+2CModelTox+2CDataDual-method'></span>

<h3>Description</h3>

<p>Compute the recommended next best dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextBest(nextBest, doselimit, samples, model, data, ...)

## S4 method for signature 'NextBestMTD,numeric,Samples,Model,Data'
nextBest(nextBest, doselimit, samples, model, data, ...)

## S4 method for signature 'NextBestNCRM,numeric,Samples,Model,Data'
nextBest(nextBest, doselimit, samples, model, data, ...)

## S4 method for signature 'NextBestNCRM,numeric,Samples,Model,DataParts'
nextBest(nextBest, doselimit, samples, model, data, ...)

## S4 method for signature 
## 'NextBestThreePlusThree,missing,missing,missing,Data'
nextBest(nextBest, doselimit, samples, model, data, ...)

## S4 method for signature 
## 'NextBestDualEndpoint,numeric,Samples,DualEndpoint,Data'
nextBest(nextBest, doselimit, samples, model, data, ...)

## S4 method for signature 
## 'NextBestTDsamples,numeric,Samples,LogisticIndepBeta,Data'
nextBest(nextBest, doselimit, samples, model, data, ...)

## S4 method for signature 'NextBestTD,numeric,missing,LogisticIndepBeta,Data'
nextBest(nextBest, doselimit, model, data, SIM = FALSE, ...)

## S4 method for signature 'NextBestMaxGain,numeric,missing,ModelTox,DataDual'
nextBest(nextBest, doselimit, model, data, Effmodel, SIM = FALSE, ...)

## S4 method for signature 
## 'NextBestMaxGainSamples,numeric,Samples,ModelTox,DataDual'
nextBest(
  nextBest,
  doselimit,
  samples,
  model,
  data,
  Effmodel,
  Effsamples,
  SIM = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextBest_+3A_nextbest">nextBest</code></td>
<td>
<p>The rule, an object of class <code><a href="#topic+NextBest-class">NextBest</a></code></p>
</td></tr>
<tr><td><code id="nextBest_+3A_doselimit">doselimit</code></td>
<td>
<p>The maximum allowed next dose. If this is an empty (length
0) vector, then no dose limit will be applied in the course of dose
recommendation calculation, and a corresponding warning is given.</p>
</td></tr>
<tr><td><code id="nextBest_+3A_samples">samples</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="nextBest_+3A_model">model</code></td>
<td>
<p>The model input, an object of class <code><a href="#topic+Model-class">Model</a></code></p>
</td></tr>
<tr><td><code id="nextBest_+3A_data">data</code></td>
<td>
<p>The data input, an object of class <code><a href="#topic+Data-class">Data</a></code></p>
</td></tr>
<tr><td><code id="nextBest_+3A_...">...</code></td>
<td>
<p>possible additional arguments without method dispatch</p>
</td></tr>
<tr><td><code id="nextBest_+3A_sim">SIM</code></td>
<td>
<p>internal command to notify if this method is used within simulations. Default as FALSE</p>
</td></tr>
<tr><td><code id="nextBest_+3A_effmodel">Effmodel</code></td>
<td>
<p>the efficacy model of <code><a href="#topic+ModelEff-class">ModelEff</a></code> class object</p>
</td></tr>
<tr><td><code id="nextBest_+3A_effsamples">Effsamples</code></td>
<td>
<p>the efficacy samples of <code><a href="#topic+Samples-class">Samples</a></code> class object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function outputs the next best dose recommendation based on the
corresponding rule <code>nextBest</code>, the posterior <code>samples</code> from the
<code>model</code> and the underlying <code>data</code>.
</p>


<h3>Value</h3>

<p>a list with the next best dose (element <code>value</code>)
on the grid defined in <code>data</code>, and a plot depicting this recommendation
(element <code>plot</code>). In case of multiple plots also an element <code>singlePlots</code>
is included which returns the list of single plots, which allows for further
customization of these. Also additional list elements describing the outcome
of the rule can be contained.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nextBest(
  nextBest = NextBestMTD,
  doselimit = numeric,
  samples = Samples,
  model = Model,
  data = Data
)</code>: Find the next best dose based on the MTD rule
</p>
</li>
<li> <p><code>nextBest(
  nextBest = NextBestNCRM,
  doselimit = numeric,
  samples = Samples,
  model = Model,
  data = Data
)</code>: Find the next best dose based on the NCRM method. The
additional list element <code>probs</code> contains the target and overdosing
probabilities (across all doses in the dose grid) 
used in the derivation of the next best dose.
</p>
</li>
<li> <p><code>nextBest(
  nextBest = NextBestNCRM,
  doselimit = numeric,
  samples = Samples,
  model = Model,
  data = DataParts
)</code>: Find the next best dose based on the NCRM method when
two parts trial is used - todo: need an example here for DataParts
</p>
</li>
<li> <p><code>nextBest(
  nextBest = NextBestThreePlusThree,
  doselimit = missing,
  samples = missing,
  model = missing,
  data = Data
)</code>: Find the next best dose based on the 3+3 method
</p>
</li>
<li> <p><code>nextBest(
  nextBest = NextBestDualEndpoint,
  doselimit = numeric,
  samples = Samples,
  model = DualEndpoint,
  data = Data
)</code>: Find the next best dose based on the dual endpoint
model. The additional list element <code>probs</code> contains the target and 
overdosing probabilities (across all doses in the dose grid) used in the 
derivation of the next best dose.
</p>
</li>
<li> <p><code>nextBest(
  nextBest = NextBestTDsamples,
  doselimit = numeric,
  samples = Samples,
  model = LogisticIndepBeta,
  data = Data
)</code>: Find the next best dose based on the 'NextBestTDsamples'
class rule. This a method based only on the DLE responses and for 
<code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code> model class object involving DLE samples
</p>
</li>
<li> <p><code>nextBest(
  nextBest = NextBestTD,
  doselimit = numeric,
  samples = missing,
  model = LogisticIndepBeta,
  data = Data
)</code>: Find the next best dose based on the 'NextBestTD'
class rule. This a method based only on the DLE responses and for 
<code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code> model class object without DLE samples
</p>
</li>
<li> <p><code>nextBest(
  nextBest = NextBestMaxGain,
  doselimit = numeric,
  samples = missing,
  model = ModelTox,
  data = DataDual
)</code>: for slots <code>nextBest</code>,<code>doselimit</code>, <code>data</code> and <code>SIM</code>. This is 
a function to find the next best dose based on the 'NextBestMaxGain'
class rule. This a method based on the DLE responses and efficacy responses without DLE and 
efficacy samples.
</p>
</li>
<li> <p><code>nextBest(
  nextBest = NextBestMaxGainSamples,
  doselimit = numeric,
  samples = Samples,
  model = ModelTox,
  data = DataDual
)</code>: for slots <code>nextBest</code>,<code>doselimit</code>, <code>data</code> and <code>SIM</code>. This is 
a function to find the next best dose based on the 'NextBestMaxGainSamples'
class rule. This a method based on the DLE responses and efficacy responses with DLE and 
efficacy samples. Effmodel must be of class <code><a href="#topic+Effloglog-class">Effloglog</a></code> or  
<code><a href="#topic+EffFlexi-class">EffFlexi</a></code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestMTD'
mtdNextBest &lt;- NextBestMTD(target=0.33,
                           derive=
                             function(mtdSamples){
                               quantile(mtdSamples, probs=0.25)
                             })

# Calculate the next best dose
doseRecommendation &lt;- nextBest(mtdNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Look at the probabilities
doseRecommendation$probs



# create an object of class 'DataParts'
data &lt;- DataParts(x=c(0.1,0.5,1.5),
                    y=c(0,0,0),
                    doseGrid=c(0.1,0.5,1.5,3,6,
                               seq(from=10,to=80,by=2)),
                    part=c(1L,1L,1L),
                    nextPart=1L,
                    part1Ladder=c(0.1,0.5,1.5,3,6,10))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

myIncrements &lt;- IncrementsRelativeParts(dltStart=0,
                                        cleanStart=1)
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, 
                               model=model, 
                               data=data)


# Create the data
data &lt;- Data(x=c(5, 5, 5, 10, 10, 10),
             y=c(0, 0, 0, 0, 1, 0),
             cohort=c(0, 0, 0, 1, 1, 1),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 5,
                 seq(from=10, to=80, by=2)))


# The rule to select the next best dose will be based on the 3+3 method
myNextBest &lt;- NextBestThreePlusThree()

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               data=data)


# Create the data
data &lt;- DataDual(
  x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,
      20, 20, 20, 40, 40, 40, 50, 50, 50),
  y=c(0, 0, 0, 0, 0, 0, 1, 0,
      0, 1, 1, 0, 0, 1, 0, 1, 1),
  w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,
      0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),
  doseGrid=c(0.1, 0.5, 1.5, 3, 6,
             seq(from=10, to=80, by=2)))

# Initialize the Dual-Endpoint model (in this case RW1)
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth = "RW1")

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=500)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# In this case target a dose achieving at least 0.9 of maximum biomarker level (efficacy)
# and with a probability below 0.25 that prob(DLT)&gt;0.35 (safety)
myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples,
                               model=model,
                               data=data)

## joint plot
print(doseRecommendation$plot)

## show customization of single plot
variant1 &lt;- doseRecommendation$singlePlots$plot1 + xlim(0, 20)
print(variant1)

## we need a data object with doses &gt;= 1:
data&lt;-Data(x=c(25,50,50,75,150,200,225,300),
           y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(from=25,to=300,by=25))
##The 'nextBest' method using NextBestTDsamples' rules class object
## That is dose-esclation procedure using the 'logisticIndepBeta' DLE model involving DLE samples
## model must be of 'LogisticIndepBeta' class
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

##Define the options for MCMC
options &lt;- McmcOptions(burnin=100,step=2,samples=1000)
##Then genreate the samples
samples &lt;- mcmc(data, model, options)

##target probabilities of the occurrence of a DLE during trial and at the end of trial are 
## defined as 0.35 and 0.3, respectively
##Specified in 'derive' such that the 30% posterior quantile of the TD35 and TD30 samples 
## will be used as TD35 and TD30 estimates
tdNextBest&lt;-NextBestTDsamples(targetDuringTrial=0.35,targetEndOfTrial=0.3,
                              derive=function(TDsamples){quantile(TDsamples,probs=0.3)})

##doselimit is the maximum allowable dose level to be given to subjects
RecommendDose&lt;-nextBest(tdNextBest,doselimit=max(data@doseGrid),samples=samples,
                        model=model,data=data)
## we need a data object with doses &gt;= 1:
data&lt;-Data(x=c(25,50,50,75,150,200,225,300),
           y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(from=25,to=300,by=25))
##The 'nextBest' method using NextBestTD' rules class object
## That is dose-esclation procedure using the 'logisticIndepBeta' DLE model involving DLE samples
## model must be of 'LogisticIndepBeta' class
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##target probabilities of the occurrence of a DLE during trial and at the end of trial 
## are defined as 0.35 and 0.3, respectively
tdNextBest&lt;-NextBestTD(targetDuringTrial=0.35,targetEndOfTrial=0.3)

##doselimit is the maximum allowable dose level to be given to subjects
RecommendDose&lt;- nextBest(tdNextBest,
              doselimit=max(data@doseGrid),
              model=model,
              data=data)
## we need a data object with doses &gt;= 1:
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
               y=c(0,0,0,0,0,1,1,0),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25),placebo=FALSE)

##The 'nextBest' method using NextBestMaxGain' rules class object
## using the 'ModelTox' class DLE model 
## DLEmodel e.g 'LogisticIndepBeta' class
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

## using the 'ModelEff' class efficacy model 
## Effmodel e.g 'Effloglog' class
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)

##target probabilities of the occurrence of a DLE during trial and at the
## end of trial are defined as
## 0.35 and 0.3, respectively
mynextbest&lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,DLEEndOfTrialtarget=0.3)

##doselimit is the maximum allowable dose level to be given to subjects
RecommendDose&lt;-nextBest(mynextbest,doselimit=300,model=DLEmodel,Effmodel=Effmodel,data=data)
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
                y=c(0,0,0,0,0,1,1,0),
                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                doseGrid=seq(25,300,25),placebo=FALSE)
##The 'nextBest' method using NextBestMaxGainSamples' rules class object
## using the 'ModelTox' class DLE model 
## DLEmodel e.g 'LogisticIndepBeta' class
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

## using the 'ModelEff' class efficacy model 
## Effmodel e.g 'Effloglog' class
Effmodel&lt;-Effloglog(c(1.223,2.513),c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
##DLE and efficacy samples must be of 'Samples' Class
DLEsamples&lt;-mcmc(data,DLEmodel,options)
Effsamples&lt;-mcmc(data,Effmodel,options)

##target probabilities of the occurrence of a DLE during trial and at the end of trial 
## are defined as 0.35 and 0.3, respectively
## Using 30% posterior quantile of the TD35 and TD30 samples as estimates of TD35 and TD30, 
## function specified in TDderive slot
## Using the 50% posterior quantile of the Gstar (the dose which gives the maxim gain value) 
## samples as Gstar estimate,function specified in Gstarderive slot 
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})

RecommendDose&lt;-nextBest(mynextbest,doselimit=max(data@doseGrid),samples=DLEsamples,model=DLEmodel,
                        data=data,Effmodel=Effmodel,Effsamples=Effsamples)

## now using the 'EffFlexi' class efficacy model:

##The 'nextBest' method using NextBestMaxGainSamples' rules class object for 'EffFlexi' model class
## using the 'ModelTox' class DLE model 
## DLEmodel e.g 'LogisticIndepBeta' class
Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),
                    sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)

##DLE and efficacy samples must be of 'Samples' Class
DLEsamples&lt;-mcmc(data,DLEmodel,options)
Effsamples&lt;-mcmc(data,Effmodel,options)

##target probabilities of the occurrence of a DLE during trial and at the 
## end of trial are defined as 0.35 and 0.3, respectively
## Using 30% posterior quantile of the TD35 and TD30 samples as estimates of 
## TD35 and TD30, function specified in TDderive slot
## Using the 50% posterio quantile of the Gstar (the dose which gives the maximum 
## gain value) samples as Gstar estimate,function specified in Gstarderive slot 
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})

RecommendDose&lt;-nextBest(mynextbest,doselimit=max(data@doseGrid),samples=DLEsamples,
                        model=DLEmodel,
                        data=data,Effmodel=Effmodel,Effsamples=Effsamples)

</code></pre>

<hr>
<h2 id='NextBest-class'>The virtual class for finding next best dose</h2><span id='topic+NextBest-class'></span>

<h3>Description</h3>

<p>The virtual class for finding next best dose
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NextBestMTD-class">NextBestMTD</a></code>,
<code><a href="#topic+NextBestNCRM-class">NextBestNCRM</a></code>,
<code><a href="#topic+NextBestDualEndpoint-class">NextBestDualEndpoint</a></code>,
<code><a href="#topic+NextBestThreePlusThree-class">NextBestThreePlusThree</a></code>
</p>

<hr>
<h2 id='NextBestDualEndpoint'>Initialization function for &quot;NextBestDualEndpoint&quot;</h2><span id='topic+NextBestDualEndpoint'></span>

<h3>Description</h3>

<p>Initialization function for &quot;NextBestDualEndpoint&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NextBestDualEndpoint(
  target,
  scale = c("relative", "absolute"),
  overdose,
  maxOverdoseProb,
  targetThresh = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NextBestDualEndpoint_+3A_target">target</code></td>
<td>
<p>see <code><a href="#topic+NextBestDualEndpoint-class">NextBestDualEndpoint</a></code></p>
</td></tr>
<tr><td><code id="NextBestDualEndpoint_+3A_scale">scale</code></td>
<td>
<p>see <code><a href="#topic+NextBestDualEndpoint-class">NextBestDualEndpoint</a></code></p>
</td></tr>
<tr><td><code id="NextBestDualEndpoint_+3A_overdose">overdose</code></td>
<td>
<p>see <code><a href="#topic+NextBestDualEndpoint-class">NextBestDualEndpoint</a></code></p>
</td></tr>
<tr><td><code id="NextBestDualEndpoint_+3A_maxoverdoseprob">maxOverdoseProb</code></td>
<td>
<p>see <code><a href="#topic+NextBestDualEndpoint-class">NextBestDualEndpoint</a></code></p>
</td></tr>
<tr><td><code id="NextBestDualEndpoint_+3A_targetthresh">targetThresh</code></td>
<td>
<p>see <code><a href="#topic+NextBestDualEndpoint-class">NextBestDualEndpoint</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+NextBestDualEndpoint-class">NextBestDualEndpoint</a></code> object
</p>

<hr>
<h2 id='NextBestDualEndpoint-class'>The class with the input for finding the next dose
based on the dual endpoint model</h2><span id='topic+NextBestDualEndpoint-class'></span><span id='topic+.NextBestDualEndpoint'></span>

<h3>Description</h3>

<p>This rule first excludes all doses that exceed the probability
<code>maxOverdoseProb</code> of having an overdose toxicity, as specified by the
overdose interval <code>overdose</code>. Then, it picks under the remaining
admissible doses the one that maximizes the probability to be in the
<code>target</code> biomarker range, by default relative to the maximum biomarker level
across the dose grid or relative to the Emax parameter in case a parametric
model was selected (e.g. <code><a href="#topic+DualEndpointBeta-class">DualEndpointBeta</a></code>,
<code><a href="#topic+DualEndpointEmax-class">DualEndpointEmax</a></code>)) However, is <code>scale</code> is set to
&quot;absolute&quot; then the natural absolute biomarker scale can be used to set a target.
</p>


<h3>Slots</h3>


<dl>
<dt><code>target</code></dt><dd><p>the biomarker target range, that
needs to be reached. For example, (0.8, 1.0) and <code>scale="relative"</code> 
means we target a dose
with at least 80% of maximum biomarker level. As an other example,
(0.5, 0.8) would mean that we target a dose between 50% and 80% of
the maximum biomarker level.</p>
</dd>
<dt><code>scale</code></dt><dd><p>either <code>relative</code> (default, then the <code>target</code> is interpreted 
relative to the maximum, so must be a probability range) or <code>absolute</code>
(then the <code>target</code> is interpreted as absolute biomarker range)</p>
</dd>
<dt><code>overdose</code></dt><dd><p>the overdose toxicity interval (lower limit excluded, upper
limit included)</p>
</dd>
<dt><code>maxOverdoseProb</code></dt><dd><p>maximum overdose probability that is allowed</p>
</dd>
<dt><code>targetThresh</code></dt><dd><p>which target probability threshold needs to be fulfilled before the 
target probability will be used for deriving the next best dose (default: 0.01)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Target a dose achieving at least 0.9 of maximum biomarker level (efficacy)
# and with a probability below 0.25 that prob(DLT)&gt;0.35 (safety)

myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

## now do it with an absolute target on the natural biomarker scale:

myNextBest &lt;- NextBestDualEndpoint(target=c(200, 300),
                                   scale="absolute",
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)
</code></pre>

<hr>
<h2 id='NextBestMaxGain'>Initialization function for the class 'NextBestMaxGain'</h2><span id='topic+NextBestMaxGain'></span>

<h3>Description</h3>

<p>Initialization function for the class 'NextBestMaxGain'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NextBestMaxGain(DLEDuringTrialtarget, DLEEndOfTrialtarget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NextBestMaxGain_+3A_dleduringtrialtarget">DLEDuringTrialtarget</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestMaxGain-class">NextBestMaxGain</a></code> class object</p>
</td></tr>
<tr><td><code id="NextBestMaxGain_+3A_dleendoftrialtarget">DLEEndOfTrialtarget</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestMaxGain-class">NextBestMaxGain</a></code> class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+NextBestMaxGain-class">NextBestMaxGain</a></code> class object
</p>

<hr>
<h2 id='NextBestMaxGain-class'>Next best dose with maximum gain value based on a pseudo DLE and efficacy model without samples</h2><span id='topic+NextBestMaxGain-class'></span><span id='topic+.NextBestMaxGain'></span>

<h3>Description</h3>

<p>This is a class for which to find the next dose which is safe and give the maximum gain value 
for allocation. This is a class where no DLE and efficacy samples are involved. This is only based 
on the probabilities of the occurrence of a DLE and the values of the mean efficacy responses
obtained by using the modal estimates of the DLE and efficacy model parameters.
There are two inputs which are the two target 
probabilities of the occurrence of a DLE used during trial
and used at the end of trial, for finding the next best dose that is safe and gives the maximum 
gain value and the dose to recommend at the end of a trial. This is only suitable to use with DLE models
specified in 'ModelTox' class and efficacy models  specified in 'ModelEff' (except 'EffFlexi' model)
class
</p>


<h3>Slots</h3>


<dl>
<dt><code>DLEDuringTrialtarget</code></dt><dd><p>the target probability of the occurrrence of a DLE to be used
during the trial</p>
</dd>
<dt><code>DLEEndOfTrialtarget</code></dt><dd><p>the target probability of the occurrence of a DLE to be used at the end 
of the trial. This target is particularly used to recommend the dose for which its posterior 
probability of the occurrence of a DLE is equal to this target</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##define the NextBestMaxGain class (no samples and based a pseudo DLE model and a efficacy model)
##specified the target probability of the occurrence of a DLE during the trial be 0.35
##specified the target probability of the occurrence of a DLE at the end of trial be 0.3

myNextBest &lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,
                             DLEEndOfTrialtarget=0.3)
</code></pre>

<hr>
<h2 id='NextBestMaxGainSamples'>Initialization function for class &quot;NextBestMaxGainSamples&quot;</h2><span id='topic+NextBestMaxGainSamples'></span>

<h3>Description</h3>

<p>Initialization function for class &quot;NextBestMaxGainSamples&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NextBestMaxGainSamples(
  DLEDuringTrialtarget,
  DLEEndOfTrialtarget,
  TDderive,
  Gstarderive
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NextBestMaxGainSamples_+3A_dleduringtrialtarget">DLEDuringTrialtarget</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestMaxGainSamples-class">NextBestMaxGainSamples</a></code> class object</p>
</td></tr>
<tr><td><code id="NextBestMaxGainSamples_+3A_dleendoftrialtarget">DLEEndOfTrialtarget</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestMaxGainSamples-class">NextBestMaxGainSamples</a></code> class object</p>
</td></tr>
<tr><td><code id="NextBestMaxGainSamples_+3A_tdderive">TDderive</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestMaxGainSamples-class">NextBestMaxGainSamples</a></code> class object</p>
</td></tr>
<tr><td><code id="NextBestMaxGainSamples_+3A_gstarderive">Gstarderive</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestMaxGainSamples-class">NextBestMaxGainSamples</a></code> class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+NextBestMaxGainSamples-class">NextBestMaxGainSamples</a></code> class object
</p>

<hr>
<h2 id='NextBestMaxGainSamples-class'>Next best dose with maximum gain value based on a pseudo DLE and efficacy model with samples</h2><span id='topic+NextBestMaxGainSamples-class'></span><span id='topic+.NextBestMaxGainSamples'></span>

<h3>Description</h3>

<p>This is a class for which to find the next dose which is safe and give the maximum gain value 
for allocation. This is a class where DLE and efficacy samples are involved.
There are two inputs which are the two target 
probabilities of the occurrence of a DLE used during trial
and used at the end of trial, for finding the next best dose that is safe and gives the maximum 
gain value and the dose to recommend at the end of a trial. This is only suitable to use with DLE models
specified in 'ModelTox' class and efficacy models  specified in 'ModelEff' class
class
</p>


<h3>Slots</h3>


<dl>
<dt><code>DLEDuringTrialtarget</code></dt><dd><p>the target probability of the occurrrence of a DLE to be used
during the trial</p>
</dd>
<dt><code>DLEEndOfTrialtarget</code></dt><dd><p>the target probability of the occurrence of a DLE to be used at the end 
of the trial. This target is particularly used to recommend the dose for which its posterior 
probability of the occurrence of a DLE is equal to this target</p>
</dd>
<dt><code>TDderive</code></dt><dd><p>the function which derives from the input, a vector of the posterior samples called 
<code>TDsamples</code> of the dose
which has the probability of the occurrence of DLE equals to either the targetDuringTrial or
targetEndOfTrial, the final next best TDtargetDuringTrial (the dose with probability of the 
occurrence of DLE equals to the targetDuringTrial)and TDtargetEndOfTrial estimate.</p>
</dd>
<dt><code>Gstarderive</code></dt><dd><p>the function which derives from the input, a vector of the posterior Gstar (the dose
which gives the maximum gain value) samples 
called <code>Gstarsamples</code>, the final next best Gstar estimate.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##define the NextBestMaxGainsamples class
##specified the target probability of the occurrence of a DLE during the trial be 0.35
##specified the target probability of the occurrence of a DLE at the end of trial be 0.3
## we want the use the 30% posterior quantile (the 30th percentaile) of the TD35 
## (the dose level with probability of DLE equals 0.35) and TD30 samples
## For Gstar (the dose which gives tha maximum
##gain) samples, we will use the 50% posterio quantile (the median or th 50th percentile) 
## of the Gstar sample
##A function is then defined in the 'TDderive' slot for the TD30 and TD35 samples
## and another function is defined in the 'Gstarderive' slot for Gstar samples
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})
</code></pre>

<hr>
<h2 id='NextBestMTD'>Initialization function for class &quot;NextBestMTD&quot;</h2><span id='topic+NextBestMTD'></span>

<h3>Description</h3>

<p>Initialization function for class &quot;NextBestMTD&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NextBestMTD(target, derive)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NextBestMTD_+3A_target">target</code></td>
<td>
<p>see <code><a href="#topic+NextBestMTD-class">NextBestMTD</a></code></p>
</td></tr>
<tr><td><code id="NextBestMTD_+3A_derive">derive</code></td>
<td>
<p>see <code><a href="#topic+NextBestMTD-class">NextBestMTD</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+NextBestMTD-class">NextBestMTD</a></code> object
</p>

<hr>
<h2 id='NextBestMTD-class'>The class with the input for finding the next best MTD estimate</h2><span id='topic+NextBestMTD-class'></span><span id='topic+.NextBestMTD'></span>

<h3>Description</h3>

<p>The class with the input for finding the next best MTD estimate
</p>


<h3>Slots</h3>


<dl>
<dt><code>target</code></dt><dd><p>the target toxicity probability</p>
</dd>
<dt><code>derive</code></dt><dd><p>the function which derives from the input, a vector of
posterior MTD samples called <code>mtdSamples</code>, the final next best MTD
estimate.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# In the example below the MTD is defined as the dose for which prob(DLE)=0.33 and
# we will use the 25th quantile of the posterior of MTD as our next best dose.
mtdNextBest &lt;- NextBestMTD(target=0.33,
                           derive=
                             function(mtdSamples){
                               quantile(mtdSamples, probs=0.25)
                             })


</code></pre>

<hr>
<h2 id='NextBestNCRM'>Initialization function for &quot;NextBestNCRM&quot;</h2><span id='topic+NextBestNCRM'></span>

<h3>Description</h3>

<p>Initialization function for &quot;NextBestNCRM&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NextBestNCRM(target, overdose, maxOverdoseProb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NextBestNCRM_+3A_target">target</code></td>
<td>
<p>see <code><a href="#topic+NextBestNCRM-class">NextBestNCRM</a></code></p>
</td></tr>
<tr><td><code id="NextBestNCRM_+3A_overdose">overdose</code></td>
<td>
<p>see <code><a href="#topic+NextBestNCRM-class">NextBestNCRM</a></code></p>
</td></tr>
<tr><td><code id="NextBestNCRM_+3A_maxoverdoseprob">maxOverdoseProb</code></td>
<td>
<p>see <code><a href="#topic+NextBestNCRM-class">NextBestNCRM</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+NextBestNCRM-class">NextBestNCRM</a></code> object
</p>

<hr>
<h2 id='NextBestNCRM-class'>The class with the input for finding the next dose in target interval</h2><span id='topic+NextBestNCRM-class'></span><span id='topic+.NextBestNCRM'></span>

<h3>Description</h3>

<p>Note that to avoid numerical problems, the dose selection algorithm has been
implemented as follows: First admissible doses are found, which are those
with probability to fall in <code>overdose</code> category being below
<code>maxOverdoseProb</code>. Next, within the admissible doses, the maximum
probability to fall in the <code>target</code> category is calculated. If that is
above 5% (i.e., it is not just numerical error), then the corresponding
dose is the next recommended dose. Otherwise, the highest admissible dose is
the next recommended dose.
</p>


<h3>Slots</h3>


<dl>
<dt><code>target</code></dt><dd><p>the target toxicity interval (limits included)</p>
</dd>
<dt><code>overdose</code></dt><dd><p>the overdose toxicity interval (lower limit excluded, upper
limit included)</p>
</dd>
<dt><code>maxOverdoseProb</code></dt><dd><p>maximum overdose probability that is allowed</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# In the example below, the target toxiciy interval [0.2, 0.35] while the 
# overdose interval is (0.35,1]. Finally we would like to constrain the probability
# of overdosing below 25%.
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)


</code></pre>

<hr>
<h2 id='NextBestTD'>Initialization function for the class &quot;NextBestTD&quot;</h2><span id='topic+NextBestTD'></span>

<h3>Description</h3>

<p>Initialization function for the class &quot;NextBestTD&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NextBestTD(targetDuringTrial, targetEndOfTrial)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NextBestTD_+3A_targetduringtrial">targetDuringTrial</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestTD-class">NextBestTD</a></code> class object</p>
</td></tr>
<tr><td><code id="NextBestTD_+3A_targetendoftrial">targetEndOfTrial</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestTD-class">NextBestTD</a></code> class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+NextBestTD-class">NextBestTD</a></code> class object
</p>

<hr>
<h2 id='NextBestTD-class'>Next best dose based on Pseudo DLE model without sample</h2><span id='topic+NextBestTD-class'></span><span id='topic+.NextBestTD'></span>

<h3>Description</h3>

<p>The class is to find the next best dose for allocation and the dose for final recommendation 
at the end of a trial without involving any samples. This is a class for which only
DLE response will be incorporated for the dose-allocation.
This is only based on the probabilities of
the occurrence of a DLE obtained by using the modal estimates of the model paramters.
There are two inputs inputs which are the two target 
probabilities of the occurrence of a DLE used during trial
and used at the end of trial, for finding the next best dose for allocation and the dose 
for recommendation at the end of the trial.
It is only suitable to use with the model specified in <code>ModelTox</code> class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>targetDuringTrial</code></dt><dd><p>the target probability of the occurrrence of a DLE to be used
during the trial</p>
</dd>
<dt><code>targetEndOfTrial</code></dt><dd><p>the target probability of the occurrence of a DLE to be used at the end 
of the trial. This target is particularly used to recommend the dose for which its posterior 
probability of the occurrence of a DLE is equal to this target</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##define the NextBestTD class (no samples and based a pseudo DLE model)
##specified the target probability of the occurrence of a DLE during the trial be 0.35
##specified the target probability of the occurrence of a DLE at the end of trial be 0.3

myNextBest &lt;-NextBestTD(targetDuringTrial=0.35,
                        targetEndOfTrial=0.3)
</code></pre>

<hr>
<h2 id='NextBestTDsamples'>Initialization function for class &quot;NextBestTDsamples&quot;</h2><span id='topic+NextBestTDsamples'></span>

<h3>Description</h3>

<p>Initialization function for class &quot;NextBestTDsamples&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NextBestTDsamples(targetDuringTrial, targetEndOfTrial, derive)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NextBestTDsamples_+3A_targetduringtrial">targetDuringTrial</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestTDsamples-class">NextBestTDsamples</a></code> class object</p>
</td></tr>
<tr><td><code id="NextBestTDsamples_+3A_targetendoftrial">targetEndOfTrial</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestTDsamples-class">NextBestTDsamples</a></code> class object</p>
</td></tr>
<tr><td><code id="NextBestTDsamples_+3A_derive">derive</code></td>
<td>
<p>please refer to <code><a href="#topic+NextBestTDsamples-class">NextBestTDsamples</a></code> class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+NextBestTDsamples-class">NextBestTDsamples</a></code> class object
</p>

<hr>
<h2 id='NextBestTDsamples-class'>Next best dose based on Pseudo DLE Model with samples</h2><span id='topic+NextBestTDsamples-class'></span><span id='topic+.NextBestTDsamples'></span>

<h3>Description</h3>

<p>The class is to find the next best dose for allocation and the dose for final recommendation 
at the end of a trial. There are two input target probabilities of the occurrence of a DLE 
used during trial and used at the end of trial to find the two doses. For this class, only
DLE response will be incorporated for the dose allocation and DLEsamples
must be used to obtain the next dose for allocation.
</p>


<h3>Slots</h3>


<dl>
<dt><code>targetDuringTrial</code></dt><dd><p>the target probability of the occurrrence of a DLE to be used
during the trial</p>
</dd>
<dt><code>targetEndOfTrial</code></dt><dd><p>the target probability of the occurrence of a DLE to be used at the end 
of the trial. This target is particularly used to recommend the dose at the end of a trial
for which its posterior 
probability of the occurrence of a DLE is equal to this target</p>
</dd>
<dt><code>derive</code></dt><dd><p>the function which derives from the input, a vector of the posterior samples called 
<code>TDsamples</code> of the dose
which has the probability of the occurrence of DLE equals to either the targetDuringTrial or
targetEndOfTrial, the final next best TDtargetDuringTrial (the dose with probability of the 
occurrence of DLE equals to the targetDuringTrial)and TDtargetEndOfTrial estimate.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##define the NextBestTDsamples class
##specified the target probability of the occurrence of a DLE during the trial be 0.35
##specified the target probability of the occurrence of a DLE at the end of trial be 0.3
## we want the use the 30% posterior quantile (the 30th percentaile) of the TD35 (the dose 
## level with probability of DLE equals 0.35) and TD30 samples. A function is then defined 
## in the 'derive' slot
myNextBest &lt;-NextBestTDsamples(targetDuringTrial=0.35,
                               targetEndOfTrial=0.3,
                               derive=function(TDsamples){quantile(TDsamples,probs=0.3)})
</code></pre>

<hr>
<h2 id='NextBestThreePlusThree'>Initialization function for &quot;NextBestThreePlusThree&quot;</h2><span id='topic+NextBestThreePlusThree'></span>

<h3>Description</h3>

<p>Initialization function for &quot;NextBestThreePlusThree&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NextBestThreePlusThree()
</code></pre>


<h3>Value</h3>

<p>the <code><a href="#topic+NextBestThreePlusThree-class">NextBestThreePlusThree</a></code> object
</p>

<hr>
<h2 id='NextBestThreePlusThree-class'>The class with the input for finding the next dose in target interval</h2><span id='topic+NextBestThreePlusThree-class'></span><span id='topic+.NextBestThreePlusThree'></span>

<h3>Description</h3>

<p>Implements the classical 3+3 dose recommendation.
No input is required, hence this class has no slots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Choose the next best dose using the  classical 3+3 design.
## No input is required, hence this function has no parameters.
myNextBest &lt;- NextBestThreePlusThree()


</code></pre>

<hr>
<h2 id='noOverlap'>Check overlap of two character vectors</h2><span id='topic+noOverlap'></span>

<h3>Description</h3>

<p>Check overlap of two character vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noOverlap(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noOverlap_+3A_a">a</code></td>
<td>
<p>first character vector</p>
</td></tr>
<tr><td><code id="noOverlap_+3A_b">b</code></td>
<td>
<p>second character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns TRUE if there is no overlap between the two character
vectors, otherwise FALSE
</p>

<hr>
<h2 id='or-Stopping-Stopping'>The method combining two atomic stopping rules</h2><span id='topic+or-Stopping-Stopping'></span><span id='topic++7C+2CStopping+2CStopping-method'></span>

<h3>Description</h3>

<p>The method combining two atomic stopping rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Stopping,Stopping'
e1 | e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="or-Stopping-Stopping_+3A_e1">e1</code></td>
<td>
<p>First <code><a href="#topic+Stopping-class">Stopping</a></code> object</p>
</td></tr>
<tr><td><code id="or-Stopping-Stopping_+3A_e2">e2</code></td>
<td>
<p>Second <code><a href="#topic+Stopping-class">Stopping</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+StoppingAny-class">StoppingAny</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example of combining two atomic stopping rules with an OR ('|') operator

myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)

myStopping &lt;- myStopping1 | myStopping2 




</code></pre>

<hr>
<h2 id='or-Stopping-StoppingAny'>The method combining a stopping list and an atomic</h2><span id='topic+or-Stopping-StoppingAny'></span><span id='topic++7C+2CStoppingAny+2CStopping-method'></span>

<h3>Description</h3>

<p>The method combining a stopping list and an atomic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'StoppingAny,Stopping'
e1 | e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="or-Stopping-StoppingAny_+3A_e1">e1</code></td>
<td>
<p><code><a href="#topic+StoppingAny-class">StoppingAny</a></code> object</p>
</td></tr>
<tr><td><code id="or-Stopping-StoppingAny_+3A_e2">e2</code></td>
<td>
<p><code><a href="#topic+Stopping-class">Stopping</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <code><a href="#topic+StoppingAny-class">StoppingAny</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example of combining a list of stopping rules with an atomic stopping rule
## with an OR ('|') operator

myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)

myStopping3 &lt;- StoppingMinPatients(nPatients=20)

myStopping &lt;- (myStopping1 &amp; myStopping2 ) | myStopping3 




</code></pre>

<hr>
<h2 id='or-StoppingAny-Stopping'>The method combining an atomic and a stopping list</h2><span id='topic+or-StoppingAny-Stopping'></span><span id='topic++7C+2CStopping+2CStoppingAny-method'></span>

<h3>Description</h3>

<p>The method combining an atomic and a stopping list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Stopping,StoppingAny'
e1 | e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="or-StoppingAny-Stopping_+3A_e1">e1</code></td>
<td>
<p><code><a href="#topic+Stopping-class">Stopping</a></code> object</p>
</td></tr>
<tr><td><code id="or-StoppingAny-Stopping_+3A_e2">e2</code></td>
<td>
<p><code><a href="#topic+StoppingAny-class">StoppingAny</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <code><a href="#topic+StoppingAny-class">StoppingAny</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example of combining an atomic stopping rule with a list of stopping rules
## with an OR ('|') operator

myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)

myStopping3 &lt;- StoppingMinPatients(nPatients=20)

myStopping &lt;-  myStopping3 | (myStopping1 &amp; myStopping2 ) 




</code></pre>

<hr>
<h2 id='pinvGamma'>Compute the distribution function of Inverse gamma distribution</h2><span id='topic+pinvGamma'></span>

<h3>Description</h3>

<p>Compute the distribution function of Inverse gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinvGamma(q, a, b, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pinvGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="pinvGamma_+3A_a">a</code></td>
<td>
<p>the shape parameter of the inverse gamma distribution</p>
</td></tr>
<tr><td><code id="pinvGamma_+3A_b">b</code></td>
<td>
<p>the scale parameter of the inverse gamm distribution</p>
</td></tr>
<tr><td><code id="pinvGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X  &gt; x], otherwise, P[X &lt;= x].</p>
</td></tr>
<tr><td><code id="pinvGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if FALSE (default) return the probability, otherwise return the natural logarithm of the probability</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CData+2Cmissing-method'>Plot method for the &quot;Data&quot; class</h2><span id='topic+plot+2CData+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot method for the &quot;Data&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Data,missing'
plot(x, y, blind = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CData+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+Data-class">Data</a></code> object we want to plot</p>
</td></tr>
<tr><td><code id="plot+2B2CData+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CData+2B2Cmissing-method_+3A_blind">blind</code></td>
<td>
<p>Logical (default FALSE) if to blind the data. If TRUE, then placebo
subjects are reported by the active dose level of the corresponding cohort and
DLEs are always assigned to the firsts subjects.</p>
</td></tr>
<tr><td><code id="plot+2B2CData+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data of class 'Data'
myData &lt;- Data(x=c(0.1,0.5,1.5,3,6,10,10,10),
               y=c(0,0,0,0,0,0,1,0),
               doseGrid=c(0.1,0.5,1.5,3,6,
                          seq(from=10,to=80,by=2)))

# Plot the data
plot(myData)

</code></pre>

<hr>
<h2 id='plot+2CData+2CModelTox-method'>Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples</h2><span id='topic+plot+2CData+2CModelTox-method'></span>

<h3>Description</h3>

<p>Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Data,ModelTox'
plot(
  x,
  y,
  xlab = "Dose level",
  ylab = "Probability of DLE",
  showLegend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CData+2B2CModelTox-method_+3A_x">x</code></td>
<td>
<p>the data of <code><a href="#topic+Data-class">Data</a></code> class object</p>
</td></tr>
<tr><td><code id="plot+2B2CData+2B2CModelTox-method_+3A_y">y</code></td>
<td>
<p>the model of the <code><a href="#topic+ModelTox-class">ModelTox</a></code> class object</p>
</td></tr>
<tr><td><code id="plot+2B2CData+2B2CModelTox-method_+3A_xlab">xlab</code></td>
<td>
<p>the x axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CData+2B2CModelTox-method_+3A_ylab">ylab</code></td>
<td>
<p>the y axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CData+2B2CModelTox-method_+3A_showlegend">showLegend</code></td>
<td>
<p>should the legend be shown? (default)</p>
</td></tr>
<tr><td><code id="plot+2B2CData+2B2CModelTox-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
object for the dose-DLE model plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##plot the dose-DLE curve given a pseudo DLE model using data without samples
##data must be of 'Data' class 
##define the data 
data&lt;-Data(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(25,300,25))
##model must be from 'ModelTox' class e.g 'LogisticIndepBeta' class model
##define the model (see LogisticIndepBeta example)
model &lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
## plot the dose-DLE curve
## 'x' is the data and 'y' is the model in plot
plot(x=data,y=model)
</code></pre>

<hr>
<h2 id='plot+2CDataDual+2Cmissing-method'>Plot method for the &quot;DataDual&quot; class</h2><span id='topic+plot+2CDataDual+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot method for the &quot;DataDual&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DataDual,missing'
plot(x, y, blind = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDataDual+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+DataDual-class">DataDual</a></code> object we want to plot</p>
</td></tr>
<tr><td><code id="plot+2B2CDataDual+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CDataDual+2B2Cmissing-method_+3A_blind">blind</code></td>
<td>
<p>Logical (default FALSE) if to blind the data</p>
</td></tr>
<tr><td><code id="plot+2B2CDataDual+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data of class 'DataDual'
myData &lt;- DataDual(x=c(0.1,0.5,1.5,3,6,10,10,10),
                   y=c(0,0,0,0,0,0,1,0),
                   w=rnorm(8),
                   doseGrid=c(0.1,0.5,1.5,3,6,
                              seq(from=10,to=80,by=2)))

# Plot the data
#grid.arrange(plot(myData))

plot(myData)
</code></pre>

<hr>
<h2 id='plot+2CDataDual+2CModelEff-method'>Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples</h2><span id='topic+plot+2CDataDual+2CModelEff-method'></span>

<h3>Description</h3>

<p>Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DataDual,ModelEff'
plot(
  x,
  y,
  ...,
  xlab = "Dose level",
  ylab = "Expected Efficacy",
  showLegend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDataDual+2B2CModelEff-method_+3A_x">x</code></td>
<td>
<p>the data of <code><a href="#topic+DataDual-class">DataDual</a></code> class object</p>
</td></tr>
<tr><td><code id="plot+2B2CDataDual+2B2CModelEff-method_+3A_y">y</code></td>
<td>
<p>the model of the <code><a href="#topic+ModelEff-class">ModelEff</a></code> class object</p>
</td></tr>
<tr><td><code id="plot+2B2CDataDual+2B2CModelEff-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot+2B2CDataDual+2B2CModelEff-method_+3A_xlab">xlab</code></td>
<td>
<p>the x axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CDataDual+2B2CModelEff-method_+3A_ylab">ylab</code></td>
<td>
<p>the y axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CDataDual+2B2CModelEff-method_+3A_showlegend">showLegend</code></td>
<td>
<p>should the legend be shown? (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
object for the dose-efficacy model plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##plot the dose-efficacy curve given a pseudo efficacy model using data without samples
##data must be of 'DataDual' class 
##define the data 
data&lt;-DataDual(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25),placebo=FALSE)
##model must be from 'ModelEff' class e.g 'Effloglog' class model
##define the model (see Effloglog example)
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
## plot the dose-efficacy curve
## 'x' is the data and 'y' is the model in plot
plot(x=data,y=Effmodel)
</code></pre>

<hr>
<h2 id='plot+2CDualSimulations+2Cmissing-method'>Plot dual-endpoint simulations</h2><span id='topic+plot+2CDualSimulations+2Cmissing-method'></span>

<h3>Description</h3>

<p>This plot method can be applied to <code><a href="#topic+DualSimulations-class">DualSimulations</a></code>
objects in order to summarize them graphically. In addition to the standard
plot types, there is
</p>

<dl>
<dt>sigma2W</dt><dd><p>Plot a boxplot of the final biomarker variance estimates in
the simulated trials</p>
</dd>
<dt>rho</dt><dd><p>Plot a boxplot of the final correlation estimates in
the simulated trials</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DualSimulations,missing'
plot(x, y, type = c("trajectory", "dosesTried", "sigma2W", "rho"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDualSimulations+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+DualSimulations-class">DualSimulations</a></code> object we want
to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CDualSimulations+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CDualSimulations+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the type of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CDualSimulations+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth="RW1")

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping4 &lt;- StoppingTargetBiomarker(target=c(0.9, 1),
                                       prob=0.5)
myStopping &lt;- myStopping4 | StoppingMinPatients(40)

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- DualDesign(model = model,
                     data = emptydata,
                     nextBest = myNextBest,
                     stopping = myStopping,
                     increments = myIncrements,
                     cohortSize = CohortSizeConst(3),
                     startingDose = 3)
  
# define scenarios for the TRUE toxicity and efficacy profiles
betaMod &lt;- function (dose, e0, eMax, delta1, delta2, scal)
{
  maxDens &lt;- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))
  dose &lt;- dose/scal
  e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2
}

trueBiomarker &lt;- function(dose)
{
  betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100)
}

trueTox &lt;- function(dose)
{
  pnorm((dose-60)/10)
}

# Draw the TRUE profiles
par(mfrow=c(1, 2))
curve(trueTox(x), from=0, to=80)
curve(trueBiomarker(x), from=0, to=80)

# Run the simulation on the desired design
# We only generate 1 trial outcome here for illustration, for the actual study 
##Also for illustration purpose, we will use 5 burn-ins to generate 20 samples
# this should be increased of course
mySims &lt;- simulate(design,
                   trueTox=trueTox,
                   trueBiomarker=trueBiomarker,
                   sigma2W=0.01,
                   rho=0,
                   nsim=1,
                   parallel=FALSE,
                   seed=3,
                   startingDose=6,
                   mcmcOptions =
                     McmcOptions(burnin=5,
                                 step=1,
                                 samples=20))

# Plot the results of the simulation
print(plot(mySims))



  
</code></pre>

<hr>
<h2 id='plot+2CDualSimulationsSummary+2Cmissing-method'>Plot summaries of the dual-endpoint design simulations</h2><span id='topic+plot+2CDualSimulationsSummary+2Cmissing-method'></span>

<h3>Description</h3>

<p>This plot method can be applied to <code><a href="#topic+DualSimulationsSummary-class">DualSimulationsSummary</a></code>
objects in order to summarize them graphically. Possible <code>type</code> of
plots at the moment are those listed in
<code><a href="#topic+plot+2CSimulationsSummary+2Cmissing-method">plot,SimulationsSummary,missing-method</a></code> plus:
</p>

<dl>
<dt>meanBiomarkerFit</dt><dd><p>Plot showing the average fitted dose-biomarker curve across
the trials, together with 95% credible intervals, and comparison with the
assumed truth (as specified by the <code>trueBiomarker</code> argument to
<code><a href="#topic+summary+2CDualSimulations-method">summary,DualSimulations-method</a></code>)</p>
</dd>
</dl>

<p>You can specify any subset of these in the <code>type</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DualSimulationsSummary,missing'
plot(
  x,
  y,
  type = c("nObs", "doseSelected", "propDLTs", "nAboveTarget", "meanFit",
    "meanBiomarkerFit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDualSimulationsSummary+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+DualSimulationsSummary-class">DualSimulationsSummary</a></code> object we want
to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CDualSimulationsSummary+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CDualSimulationsSummary+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the types of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CDualSimulationsSummary+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth="RW1")

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping4 &lt;- StoppingTargetBiomarker(target=c(0.9, 1),
                                       prob=0.5)
# only 10 patients here for illustration!
myStopping &lt;- myStopping4 | StoppingMinPatients(10)

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- DualDesign(model = model,
                     data = emptydata,
                     nextBest = myNextBest,
                     stopping = myStopping,
                     increments = myIncrements,
                     cohortSize = CohortSizeConst(3),
                     startingDose = 3)
  
# define scenarios for the TRUE toxicity and efficacy profiles
betaMod &lt;- function (dose, e0, eMax, delta1, delta2, scal)
{
  maxDens &lt;- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))
  dose &lt;- dose/scal
  e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2
}

trueBiomarker &lt;- function(dose)
{
  betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100)
}

trueTox &lt;- function(dose)
{
  pnorm((dose-60)/10)
}

# Draw the TRUE profiles
par(mfrow=c(1, 2))
curve(trueTox(x), from=0, to=80)
curve(trueBiomarker(x), from=0, to=80)

# Run the simulation on the desired design
# We only generate 1 trial outcome here for illustration, for the actual study
##For illustration purpose we will use 5 burn-ins to generate 20 samples
# this should be increased of course
mySims &lt;- simulate(design,
                   trueTox=trueTox,
                   trueBiomarker=trueBiomarker,
                   sigma2W=0.01,
                   rho=0,
                   nsim=1,
                   parallel=FALSE,
                   seed=3,
                   startingDose=6,
                   mcmcOptions =
                     McmcOptions(burnin=5,
                                 step=1,
                                 samples=20))

# Plot the summary of the Simulations
plot(summary(mySims,
             trueTox = trueTox,
             trueBiomarker = trueBiomarker))



  
</code></pre>

<hr>
<h2 id='plot+2CGeneralSimulations+2Cmissing-method'>Plot simulations</h2><span id='topic+plot+2CGeneralSimulations+2Cmissing-method'></span>

<h3>Description</h3>

<p>Summarize the simulations with plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeneralSimulations,missing'
plot(x, y, type = c("trajectory", "dosesTried"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CGeneralSimulations+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code> object we want
to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CGeneralSimulations+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CGeneralSimulations+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the type of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeneralSimulations+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot method can be applied to <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code>
objects in order to summarize them graphically. Possible <code>type</code>s of
plots at the moment are: </p>
 <dl>
<dt>trajectory</dt><dd><p>Summary of the
trajectory of the simulated trials</p>
</dd> <dt>dosesTried</dt><dd><p>Average proportions of
the doses tested in patients</p>
</dd> </dl>
<p> You can specify one or both of these in the
<code>type</code> argument.
</p>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##obtain the plot for the simulation results
##If only DLE responses are considered in the simulations

##Specified your simulations when no DLE samples are used
##Define your data set first using an empty data set 
## with dose levels from 25 to 300 with increments 25
data &lt;- Data(doseGrid=seq(25,300,25))

##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##Then the escalation rule
tdNextBest &lt;- NextBestTD(targetDuringTrial=0.35,
                         targetEndOfTrial=0.3)

## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 12 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=12)
##Now specified the design with all the above information and starting with a dose of 25
design &lt;- TDDesign(model=model,
                   nextBest=tdNextBest,
                   stopping=myStopping,
                   increments=myIncrements,
                   cohortSize=mySize,
                   data=data,startingDose=25)

##Specify the truth of the DLE responses
myTruth &lt;- function(dose)
{ model@prob(dose, phi1=-53.66584, phi2=10.50499)
}

## Then specified the simulations and generate the trial 
##For illustration purpose only 1 simulation is produced (nsim=1). 
##The simulations
mySim &lt;- simulate(design,
                  args=NULL,
                  truth=myTruth,
                  nsim=1,
                  seed=819,
                  parallel=FALSE)


##plot the simulations
print(plot(mySim))



##If DLE samples are involved
##The escalation rule
tdNextBest&lt;-NextBestTDsamples(targetDuringTrial=0.35,
                              targetEndOfTrial=0.3,
                              derive=function(TDsamples){quantile(TDsamples,probs=0.3)})
##specify the design
design &lt;- TDsamplesDesign(model=model,
                          nextBest=tdNextBest,
                          stopping=myStopping,
                          increments=myIncrements,
                          cohortSize=mySize,
                          data=data,startingDose=25)
##options for MCMC
##The simulations
##For illustration purpose only 1 simulation is produced (nsim=1). 
# mySim &lt;- simulate(design,
#                   args=NULL,
#                   truth=myTruth,
#                   nsim=1,
#                   seed=819,
#                   mcmcOptions=options,
#                   parallel=FALSE)
# 
# ##plot the simulations
# print(plot(mySim))
# 
</code></pre>

<hr>
<h2 id='plot+2CGeneralSimulationsSummary+2Cmissing-method'>Graphical display of the general simulation summary</h2><span id='topic+plot+2CGeneralSimulationsSummary+2Cmissing-method'></span>

<h3>Description</h3>

<p>This plot method can be applied to
<code><a href="#topic+GeneralSimulationsSummary-class">GeneralSimulationsSummary</a></code> objects in order to
summarize them graphically. Possible <code>type</code>s of plots at the moment
are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeneralSimulationsSummary,missing'
plot(x, y, type = c("nObs", "doseSelected", "propDLTs", "nAboveTarget"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CGeneralSimulationsSummary+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+GeneralSimulationsSummary-class">GeneralSimulationsSummary</a></code> object we want
to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CGeneralSimulationsSummary+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CGeneralSimulationsSummary+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the types of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeneralSimulationsSummary+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>nObs</dt><dd><p>Distribution of the number of patients in the simulated trials</p>
</dd>
<dt>doseSelected</dt><dd><p>Distribution of the final selected doses in the trials.
Note that this can include zero entries, meaning that the trial was stopped
because all doses in the dose grid appeared too toxic.</p>
</dd>
<dt>propDLTs</dt><dd><p>Distribution of the proportion of patients with DLTs in the
trials</p>
</dd>
<dt>nAboveTarget</dt><dd><p>Distribution of the number of patients treated at doses
which are above the target toxicity interval (as specified by the
<code>truth</code> and <code>target</code> arguments to
<code><a href="#topic+summary+2CGeneralSimulations-method">summary,GeneralSimulations-method</a></code>)</p>
</dd>
</dl>

<p>You can specify any subset of these in the <code>type</code> argument.
</p>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>

<hr>
<h2 id='plot+2CPseudoDualFlexiSimulations+2Cmissing-method'>Plot for PseudoDualFlexiSimulations</h2><span id='topic+plot+2CPseudoDualFlexiSimulations+2Cmissing-method'></span>

<h3>Description</h3>

<p>This plot method can be applied to <code><a href="#topic+PseudoDualFlexiSimulations-class">PseudoDualFlexiSimulations</a></code>
objects in order to summarize them graphically. Possible <code>type</code>s of
plots at the moment are: 
</p>
 
<dl>
<dt>trajectory</dt><dd><p>Summary of the trajectory of the simulated trials</p>
</dd> 
<dt>dosesTried</dt><dd><p>Average proportions of the doses tested in patients</p>
</dd> 
<dt>sigma2</dt><dd><p>The variance of the efficacy responses</p>
</dd> 
<dt>sigma2betaW</dt><dd><p>The variance of the random walk model</p>
</dd>
</dl>
 
<p>You can specify one or both of these in the
<code>type</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoDualFlexiSimulations,missing'
plot(x, y, type = c("trajectory", "dosesTried", "sigma2", "sigma2betaW"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CPseudoDualFlexiSimulations+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+PseudoDualFlexiSimulations-class">PseudoDualFlexiSimulations</a></code> object we want
to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualFlexiSimulations+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualFlexiSimulations+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the type of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualFlexiSimulations+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##obtain the plot for the simulation results
##If DLE and efficacy responses are considered in the simulations


data &lt;- DataDual(doseGrid=seq(25,300,25))
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

##The efficacy model must be of 'EffFlexi' class

Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)

##The escalation rule using the 'NextBestMaxGainSamples' class
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})

## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=36)


##Specified the design 
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##specified the true DLE curve and the true expected efficacy values at all dose levels
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- c(-0.5478867, 0.1645417,  0.5248031,  0.7604467,  
               0.9333009  ,1.0687031,  1.1793942 , 1.2726408 , 
               1.3529598 , 1.4233411 , 1.4858613 , 1.5420182)
##The true gain curve can also be seen
myTruthGain &lt;- function(dose)
{return((myTruthEff(dose))/(1+(myTruthDLE(dose)/(1-myTruthDLE(dose)))))}


##options for MCMC
options&lt;-McmcOptions(burnin=10,step=1,samples=20)
##The simulations
##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim&lt;-simulate(object=design,
                args=NULL,
                trueDLE=myTruthDLE,
                trueEff=myTruthEff,
                trueSigma2=0.025,
                trueSigma2betaW=1,
                mcmcOptions=options,
                nsim=1,
                seed=819,
                parallel=FALSE)
##plot this simulated results
print(plot(mySim))
</code></pre>

<hr>
<h2 id='plot+2CPseudoDualSimulations+2Cmissing-method'>Plot simulations</h2><span id='topic+plot+2CPseudoDualSimulations+2Cmissing-method'></span>

<h3>Description</h3>

<p>Summarize the simulations with plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoDualSimulations,missing'
plot(x, y, type = c("trajectory", "dosesTried", "sigma2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CPseudoDualSimulations+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> object we want
to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualSimulations+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualSimulations+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the type of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualSimulations+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot method can be applied to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code>
objects in order to summarize them graphically. Possible <code>type</code>s of
plots at the moment are: </p>
 <dl>
<dt>trajectory</dt><dd><p>Summary of the
trajectory of the simulated trials</p>
</dd> <dt>dosesTried</dt><dd><p>Average proportions of
the doses tested in patients</p>
</dd> <dt>sigma2</dt><dd><p>The variance of the efficacy responses</p>
</dd></dl>
 
<p>You can specify one or both of these in the
<code>type</code> argument.
</p>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##obtain the plot for the simulation results
##If DLE and efficacy responses are considered in the simulations
##Specified your simulations when no samples are used
## we need a data object with doses &gt;= 1:
data &lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

##The efficacy model of 'ModelEff' (e.g 'Effloglog') class 
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),
                    nu=c(a=1,b=0.025),data=data,c=0)

##The escalation rule using the 'NextBestMaxGain' class
mynextbest&lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,
                            DLEEndOfTrialtarget=0.3)


##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 36 subjects are treated
myStopping &lt;- StoppingMinPatients(nPatients=36)
##Now specified the design with all the above information and starting with a dose of 25

##Specified the design(for details please refer to the 'DualResponsesDesign' example)
design &lt;- DualResponsesDesign(nextBest=mynextbest,
                              model=DLEmodel,
                              Effmodel=Effmodel,
                              stopping=myStopping,
                              increments=myIncrements,
                              cohortSize=mySize,
                              data=data,startingDose=25)
##Specify the true DLE and efficacy curves
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- function(dose)
{Effmodel@ExpEff(dose,theta1=-4.818429,theta2=3.653058)
}

## Then specified the simulations and generate the trial
##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim &lt;-simulate(object=design,
                 args=NULL,
                 trueDLE=myTruthDLE,
                 trueEff=myTruthEff,
                 trueNu=1/0.025,
                 nsim=1,
                 seed=819,
                 parallel=FALSE)

##plot the simulation results
print(plot(mySim))

##If DLE and efficacy samples are involved
##The escalation rule using the 'NextBestMaxGainSamples' class
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})
##The design of 'DualResponsesSamplesDesign' class
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##options for MCMC
options&lt;-McmcOptions(burnin=10,step=1,samples=20)
##The simulations
##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim&lt;-simulate(design,
                args=NULL,
                trueDLE=myTruthDLE,
                trueEff=myTruthEff,
                trueNu=1/0.025,
                nsim=1,
                mcmcOptions=options,
                seed=819,
                parallel=FALSE)
##plot the simulation results
print(plot(mySim))
</code></pre>

<hr>
<h2 id='plot+2CPseudoDualSimulationsSummary+2Cmissing-method'>Plot the summary of Pseudo Dual Simulations summary</h2><span id='topic+plot+2CPseudoDualSimulationsSummary+2Cmissing-method'></span>

<h3>Description</h3>

<p>This plot method can be applied to <code><a href="#topic+PseudoDualSimulationsSummary-class">PseudoDualSimulationsSummary</a></code> objects in order
to summarize them graphically. Possible <code>type</code> of plots at the moment are those listed in
<code><a href="#topic+plot+2CPseudoSimulationsSummary+2Cmissing-method">plot,PseudoSimulationsSummary,missing-method</a></code> plus: 
</p>
<dl>
<dt>meanEffFit</dt><dd><p>Plot showing the fitted dose-efficacy curve. If no samples are involved, only the
average fitted dose-efficacy curve across the trials will be ploted. If samples (DLE and efficacy) are involved, 
the average fitted dose-efficacy curve across the trials, together with the 95% credibility interval; and comparison 
with the assumed truth (as specified by the <code>trueEff</code> argument to 
<code><a href="#topic+summary+2CPseudoDualSimulations-method">summary,PseudoDualSimulations-method</a></code>)</p>
</dd></dl>

<p>You can specify any subset of these in the <code>type</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoDualSimulationsSummary,missing'
plot(
  x,
  y,
  type = c("nObs", "doseSelected", "propDLE", "nAboveTargetEndOfTrial", "meanFit",
    "meanEffFit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CPseudoDualSimulationsSummary+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+PseudoDualSimulationsSummary-class">PseudoDualSimulationsSummary</a></code> object we want to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualSimulationsSummary+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualSimulationsSummary+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the types of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoDualSimulationsSummary+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##obtain the plot of the summary for the simulation results
##If DLE and efficacy responses are considered in the simulations
##Specified your simulations when no samples are used
## we need a data object with doses &gt;= 1:
data &lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

##The efficacy model of 'ModelEff' (e.g 'Effloglog') class 
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),
                    nu=c(a=1,b=0.025),data=data,c=0)

##The escalation rule using the 'NextBestMaxGain' class
mynextbest&lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,
                            DLEEndOfTrialtarget=0.3)


##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 10 subjects are treated (for illustration)
myStopping &lt;- StoppingMinPatients(nPatients=10)
##Now specified the design with all the above information and starting with a dose of 25

##Specified the design(for details please refer to the 'DualResponsesDesign' example)
design &lt;- DualResponsesDesign(nextBest=mynextbest,
                              model=DLEmodel,
                              Effmodel=Effmodel,
                              stopping=myStopping,
                              increments=myIncrements,
                              cohortSize=mySize,
                              data=data,startingDose=25)
##Specify the true DLE and efficacy curves
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- function(dose)
{Effmodel@ExpEff(dose,theta1=-4.818429,theta2=3.653058)
}

## Then specified the simulations and generate the trial
##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim &lt;-simulate(object=design,
                 args=NULL,
                 trueDLE=myTruthDLE,
                 trueEff=myTruthEff,
                 trueNu=1/0.025,
                 nsim=1,
                 ## this would need to be increased in the real
                 ## application:
                 mcmcOptions=McmcOptions(burnin=10, step=1, samples=50),
                 seed=819,
                 parallel=FALSE)

##Then produce a summary of your simulations
MYSUM &lt;- summary(mySim,
                 trueDLE=myTruthDLE,
                 trueEff=myTruthEff)

##Then plot the summary of the simulations
print(plot(MYSUM))



##If DLE and efficacy samples are involved
##Please refer to design-method 'simulate DualResponsesSamplesDesign' examples for details
##specified the next best
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})
##specified the design
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##options for MCMC
##for illustration purpose we use 10 burn-in and generate 50 samples
options&lt;-McmcOptions(burnin=10,step=2,samples=50)
##The simulations
##For illustration purpose only 1 simulation is produced (nsim=1). 
# mySim&lt;-simulate(design,
#                 args=NULL,
#                 trueDLE=myTruthDLE,
#                 trueEff=myTruthEff,
#                 trueNu=1/0.025,
#                 nsim=1,
#                 mcmcOptions=options,
#                 seed=819,
#                 parallel=FALSE)
# 
# ##Then produce a summary of your simulations
# MYSUM &lt;- summary(mySim,
#                  trueDLE=myTruthDLE,
#                  trueEff=myTruthEff)
# 
# ##Then plot the summary of the simulations
# print(plot(MYSUM))



##OR if the 'EffFlexi' class is used 
## for the efficacy model

Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)

##Specified the design 
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##specified the true DLE curve and the true expected efficacy values at all dose levels
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- c(-0.5478867, 0.1645417,  0.5248031,  0.7604467,  
               0.9333009  ,1.0687031,  1.1793942 , 1.2726408 , 
               1.3529598 , 1.4233411 , 1.4858613 , 1.5420182)
##The true gain curve can also be seen
myTruthGain &lt;- function(dose)
{return((myTruthEff(dose))/(1+(myTruthDLE(dose)/(1-myTruthDLE(dose)))))}

##The simulations
# ##For illustration purpose only 1 simulation is produced (nsim=1). 
# mySim&lt;-simulate(object=design,
#                 args=NULL,
#                 trueDLE=myTruthDLE,
#                 trueEff=myTruthEff,
#                 trueSigma2=0.025,
#                 trueSigma2betaW=1,
#                 nsim=1,
#                 mcmcOptions=options,
#                 seed=819,
#                 parallel=FALSE)
# ##Then produce a summary of your simulations
# MYSUM &lt;- summary(mySim,
#                  trueDLE=myTruthDLE,
#                  trueEff=myTruthEff)
# 
# ##Then plot the summary of the simulations
# print(plot(MYSUM))
</code></pre>

<hr>
<h2 id='plot+2CPseudoSimulationsSummary+2Cmissing-method'>Plot summaries of the pseudo simulations</h2><span id='topic+plot+2CPseudoSimulationsSummary+2Cmissing-method'></span>

<h3>Description</h3>

<p>Graphical display of the simulation summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoSimulationsSummary,missing'
plot(
  x,
  y,
  type = c("nObs", "doseSelected", "propDLE", "nAboveTargetEndOfTrial", "meanFit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CPseudoSimulationsSummary+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+PseudoSimulationsSummary-class">PseudoSimulationsSummary</a></code> object we want
to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoSimulationsSummary+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoSimulationsSummary+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the types of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CPseudoSimulationsSummary+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot method can be applied to <code><a href="#topic+PseudoSimulationsSummary-class">PseudoSimulationsSummary</a></code>
objects in order to summarize them graphically. This can be used when only DLE responses are involved
in the simulations. This also applied to results with or without samples generated during the simulations
</p>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##obtain the plot for the simulation results
##If only DLE responses are considered in the simulations
##Specified your simulations when no DLE samples are used
##Define your data set first using an empty data set 
## with dose levels from 25 to 300 with increments 25
data &lt;- Data(doseGrid=seq(25,300,25))

##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##Then the escalation rule
tdNextBest &lt;- NextBestTD(targetDuringTrial=0.35,
                         targetEndOfTrial=0.3)

## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 12 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=12)
##Now specified the design with all the above information and starting with a dose of 25
design &lt;- TDDesign(model=model,
                   nextBest=tdNextBest,
                   stopping=myStopping,
                   increments=myIncrements,
                   cohortSize=mySize,
                  data=data,startingDose=25)

##Specify the truth of the DLE responses
myTruth &lt;- function(dose)
{ model@prob(dose, phi1=-53.66584, phi2=10.50499)
}

## Then specified the simulations and generate the trial 
##For illustration purpose only 1 simulation is produced (nsim=1). 
##The simulations
mySim &lt;- simulate(design,
                  args=NULL,
                  truth=myTruth,
                  nsim=1,
                  seed=819,
                  parallel=FALSE)

##Then produce a summary of your simulations
MYSUM &lt;- summary(mySim,
                 truth=myTruth)
##plot the summary of the simulations
print(plot(MYSUM))



##If DLE samples are involved
##The escalation rule
tdNextBest&lt;-NextBestTDsamples(targetDuringTrial=0.35,
                              targetEndOfTrial=0.3,
                              derive=function(TDsamples){quantile(TDsamples,probs=0.3)})
##specify the design
design &lt;- TDsamplesDesign(model=model,
                          nextBest=tdNextBest,
                          stopping=myStopping,
                          increments=myIncrements,
                          cohortSize=mySize,
                          data=data,startingDose=25)
##options for MCMC
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
##The simulations
##For illustration purpose only 1 simulation is produced (nsim=1). 
# mySim &lt;- simulate(design,
#                   args=NULL,
#                   truth=myTruth,
#                   nsim=1,
#                   seed=819,
#                   mcmcOptions=options,
#                   parallel=FALSE)
# ##Then produce a summary of your simulations
# MYSUM &lt;- summary(mySim,
#                  truth=myTruth)
# ##plot the summary of the simulations
# print(plot(MYSUM))
</code></pre>

<hr>
<h2 id='plot+2CSamples+2CDualEndpoint-method'>Plotting dose-toxicity and dose-biomarker model fits</h2><span id='topic+plot+2CSamples+2CDualEndpoint-method'></span>

<h3>Description</h3>

<p>When we have the dual endpoint model,
also the dose-biomarker fit is shown in the plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Samples,DualEndpoint'
plot(x, y, data, extrapolate = TRUE, showLegend = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSamples+2B2CDualEndpoint-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CDualEndpoint-method_+3A_y">y</code></td>
<td>
<p>the <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CDualEndpoint-method_+3A_data">data</code></td>
<td>
<p>the <code><a href="#topic+DataDual-class">DataDual</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CDualEndpoint-method_+3A_extrapolate">extrapolate</code></td>
<td>
<p>should the biomarker fit be extrapolated to the whole
dose grid? (default)</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CDualEndpoint-method_+3A_showlegend">showLegend</code></td>
<td>
<p>should the legend be shown? (not default)</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CDualEndpoint-method_+3A_...">...</code></td>
<td>
<p>additional arguments for the parent method
<code><a href="#topic+plot+2CSamples+2CModel-method">plot,Samples,Model-method</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
object with the dose-toxicity and dose-biomarker model fits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data
data &lt;- DataDual(
  x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,
      20, 20, 20, 40, 40, 40, 50, 50, 50),
  y=c(0, 0, 0, 0, 0, 0, 1, 0,
      0, 1, 1, 0, 0, 1, 0, 1, 1),
  w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,
      0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),
  doseGrid=c(0.1, 0.5, 1.5, 3, 6,
             seq(from=10, to=80, by=2)))

# Initialize the Dual-Endpoint model (in this case RW1)
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth = "RW1")

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=500)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Plot the posterior mean  (and empirical 2.5 and 97.5 percentile)
# for the prob(DLT) by doses and the Biomarker by doses
#grid.arrange(plot(x = samples, y = model, data = data))
              
plot(x = samples, y = model, data = data)


</code></pre>

<hr>
<h2 id='plot+2CSamples+2CModel-method'>Plotting dose-toxicity model fits</h2><span id='topic+plot+2CSamples+2CModel-method'></span>

<h3>Description</h3>

<p>Plotting dose-toxicity model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Samples,Model'
plot(
  x,
  y,
  data,
  ...,
  xlab = "Dose level",
  ylab = "Probability of DLT [%]",
  showLegend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSamples+2B2CModel-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModel-method_+3A_y">y</code></td>
<td>
<p>the <code><a href="#topic+Model-class">Model</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModel-method_+3A_data">data</code></td>
<td>
<p>the <code><a href="#topic+Data-class">Data</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModel-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModel-method_+3A_xlab">xlab</code></td>
<td>
<p>the x axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModel-method_+3A_ylab">ylab</code></td>
<td>
<p>the y axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModel-method_+3A_showlegend">showLegend</code></td>
<td>
<p>should the legend be shown? (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
object for the dose-toxicity model fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data
data &lt;- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y = c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort = c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid = c(0.1, 0.5, 1.5, 3, 6,
                          seq(from = 10, to = 80, by=2)))

# Initialize a model 
model &lt;- LogisticLogNormal(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 56)

# Get posterior for all model parameters
options &lt;- McmcOptions(burnin = 100,
                       step = 2,
                       samples = 2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Plot the posterior mean  (and empirical 2.5 and 97.5 percentile)
# for the prob(DLT) by doses
plot(x = samples, y = model, data = data)
              



</code></pre>

<hr>
<h2 id='plot+2CSamples+2CModelEff-method'>Plot the fitted dose-effcacy curve using a model from <code><a href="#topic+ModelEff-class">ModelEff</a></code> class
with samples</h2><span id='topic+plot+2CSamples+2CModelEff-method'></span>

<h3>Description</h3>

<p>Plot the fitted dose-effcacy curve using a model from <code><a href="#topic+ModelEff-class">ModelEff</a></code> class
with samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Samples,ModelEff'
plot(
  x,
  y,
  data,
  ...,
  xlab = "Dose level",
  ylab = "Expected Efficacy",
  showLegend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSamples+2B2CModelEff-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelEff-method_+3A_y">y</code></td>
<td>
<p>the <code><a href="#topic+ModelEff-class">ModelEff</a></code> model class object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelEff-method_+3A_data">data</code></td>
<td>
<p>the <code><a href="#topic+Data-class">Data</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelEff-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelEff-method_+3A_xlab">xlab</code></td>
<td>
<p>the x axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelEff-method_+3A_ylab">ylab</code></td>
<td>
<p>the y axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelEff-method_+3A_showlegend">showLegend</code></td>
<td>
<p>should the legend be shown? (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
object for the dose-efficacy model fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## we need a data object with doses &gt;= 1:
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
                y=c(0,0,0,0,0,1,1,0),
                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                doseGrid=seq(25,300,25),
                placebo=FALSE)
##plot the dose-efficacy curve with samples using the model from 'ModelEff' 
##class e.g. 'Effloglog' class model
##define the model (see Effloglog example)
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
## define the samples obtained using the 'Effloglog' model (see details in 'Samples' example)
##options for MCMC
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
## samples must be of 'Samples' class
samples &lt;- mcmc(data=data,model=Effmodel,options=options)
## plot the fitted dose-efficacy curve including the 95% credibility interval of the samples
## 'x' should be of 'Samples' class and 'y' of 'ModelEff' class
plot(x=samples,y=Effmodel,data=data)
</code></pre>

<hr>
<h2 id='plot+2CSamples+2CModelTox-method'>Plot the fitted dose-DLE curve using a <code><a href="#topic+ModelTox-class">ModelTox</a></code> class model with samples</h2><span id='topic+plot+2CSamples+2CModelTox-method'></span>

<h3>Description</h3>

<p>Plot the fitted dose-DLE curve using a <code><a href="#topic+ModelTox-class">ModelTox</a></code> class model with samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Samples,ModelTox'
plot(
  x,
  y,
  data,
  ...,
  xlab = "Dose level",
  ylab = "Probability of DLT [%]",
  showLegend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSamples+2B2CModelTox-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelTox-method_+3A_y">y</code></td>
<td>
<p>the <code><a href="#topic+ModelTox-class">ModelTox</a></code> model class object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelTox-method_+3A_data">data</code></td>
<td>
<p>the <code><a href="#topic+Data-class">Data</a></code> object</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelTox-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelTox-method_+3A_xlab">xlab</code></td>
<td>
<p>the x axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelTox-method_+3A_ylab">ylab</code></td>
<td>
<p>the y axis label</p>
</td></tr>
<tr><td><code id="plot+2B2CSamples+2B2CModelTox-method_+3A_showlegend">showLegend</code></td>
<td>
<p>should the legend be shown? (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
object for the dose-DLE model fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## we need a data object with doses &gt;= 1:
data&lt;-Data(x=c(25,50,50,75,150,200,225,300),
           y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(from=25,to=300,by=25))
##plot the dose-DLE curve with samples using the model from 'ModelTox' 
##class e.g. 'LogisticIndepBeta' class model
##define the model (see LogisticIndepBeta example)
model &lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
## define the samples obtained using the 'LogisticIndepGBeta' model 

##Define options for MCMC
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
## (see details in 'Samples' example) samples must be of 'Samples' class
samples &lt;- mcmc(data=data,model=model,options=options)
## plot the fitted dose-DLE curve including the 95% credibility interval of the samples
## 'x' should be of 'Samples' class and 'y' of 'ModelTox' class
plot(x=samples,y=model,data=data)
</code></pre>

<hr>
<h2 id='plot+2CSimulationsSummary+2Cmissing-method'>Plot summaries of the model-based design simulations</h2><span id='topic+plot+2CSimulationsSummary+2Cmissing-method'></span>

<h3>Description</h3>

<p>Graphical display of the simulation summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimulationsSummary,missing'
plot(
  x,
  y,
  type = c("nObs", "doseSelected", "propDLTs", "nAboveTarget", "meanFit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSimulationsSummary+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+SimulationsSummary-class">SimulationsSummary</a></code> object we want
to plot from</p>
</td></tr>
<tr><td><code id="plot+2B2CSimulationsSummary+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2CSimulationsSummary+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>the types of plots you want to obtain.</p>
</td></tr>
<tr><td><code id="plot+2B2CSimulationsSummary+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot method can be applied to <code><a href="#topic+SimulationsSummary-class">SimulationsSummary</a></code>
objects in order to summarize them graphically. Possible <code>type</code> of
plots at the moment are those listed in
<code><a href="#topic+plot+2CGeneralSimulationsSummary+2Cmissing-method">plot,GeneralSimulationsSummary,missing-method</a></code> plus:
</p>

<dl>
<dt>meanFit</dt><dd><p>Plot showing the average fitted dose-toxicity curve across
the trials, together with 95% credible intervals, and comparison with the
assumed truth (as specified by the <code>truth</code> argument to
<code><a href="#topic+summary+2CSimulations-method">summary,Simulations-method</a></code>)</p>
</dd>
</dl>

<p>You can specify any subset of these in the <code>type</code> argument.
</p>


<h3>Value</h3>

<p>A single <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object if a single plot is
asked for, otherwise a <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a>{gTree}</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)
myStopping &lt;- (myStopping1 &amp; myStopping2) | myStopping3

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- Design(model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 data=emptydata,
                 startingDose=3)

## define the true function
myTruth &lt;- function(dose)
{
  model@prob(dose, alpha0=7, alpha1=8)
}

# Run the simulation on the desired design
# We only generate 1 trial outcomes here for illustration, for the actual study 
# this should be increased of course
options &lt;- McmcOptions(burnin=10,
                       step=1,
                       samples=100)
time &lt;- system.time(mySims &lt;- simulate(design,
                                       args=NULL,
                                       truth=myTruth,
                                       nsim=1,
                                       seed=819,
                                       mcmcOptions=options,
                                       parallel=FALSE))[3]

# Plot the Summary of the Simulations
plot(summary(mySims,truth=myTruth))


</code></pre>

<hr>
<h2 id='plot.gtable'>Plots gtable objects</h2><span id='topic+plot.gtable'></span>

<h3>Description</h3>

<p>Plots gtable objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtable'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gtable_+3A_x">x</code></td>
<td>
<p>the gtable object</p>
</td></tr>
<tr><td><code id="plot.gtable_+3A_...">...</code></td>
<td>
<p>additional parameters for <code><a href="grid.html#topic+grid.draw">grid.draw</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='plotDualResponses'>Plot of the DLE and efficacy curve side by side given a DLE pseudo model,
a DLE sample, an efficacy pseudo model and a given efficacy sample</h2><span id='topic+plotDualResponses'></span><span id='topic+plotDualResponses+2CModelTox+2CSamples+2CModelEff+2CSamples-method'></span><span id='topic+plotDualResponses+2CModelTox+2Cmissing+2CModelEff+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot of the DLE and efficacy curve side by side given a DLE pseudo model,
a DLE sample, an efficacy pseudo model and a given efficacy sample
</p>
<p>Plot of the dose-DLE and dose-efficacy curve side by side given a DLE pseudo model 
and a given pseudo efficacy model without DLE and efficacy samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDualResponses(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)

## S4 method for signature 'ModelTox,Samples,ModelEff,Samples'
plotDualResponses(
  DLEmodel,
  DLEsamples,
  Effmodel,
  Effsamples,
  data,
  extrapolate = TRUE,
  showLegend = FALSE,
  ...
)

## S4 method for signature 'ModelTox,missing,ModelEff,missing'
plotDualResponses(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDualResponses_+3A_dlemodel">DLEmodel</code></td>
<td>
<p>the pseudo DLE model of <code><a href="#topic+ModelTox-class">ModelTox</a></code> class object</p>
</td></tr>
<tr><td><code id="plotDualResponses_+3A_dlesamples">DLEsamples</code></td>
<td>
<p>the DLE samples of <code><a href="#topic+Samples-class">Samples</a></code> class object</p>
</td></tr>
<tr><td><code id="plotDualResponses_+3A_effmodel">Effmodel</code></td>
<td>
<p>the pseudo efficacy model of <code><a href="#topic+ModelEff-class">ModelEff</a></code> class object</p>
</td></tr>
<tr><td><code id="plotDualResponses_+3A_effsamples">Effsamples</code></td>
<td>
<p>the Efficacy samples of <code><a href="#topic+Samples-class">Samples</a></code> class object</p>
</td></tr>
<tr><td><code id="plotDualResponses_+3A_data">data</code></td>
<td>
<p>the data input of <code><a href="#topic+DataDual-class">DataDual</a></code> class object</p>
</td></tr>
<tr><td><code id="plotDualResponses_+3A_...">...</code></td>
<td>
<p>additional arguments for the parent method
<code><a href="#topic+plot+2CSamples+2CModel-method">plot,Samples,Model-method</a></code></p>
</td></tr>
<tr><td><code id="plotDualResponses_+3A_extrapolate">extrapolate</code></td>
<td>
<p>should the biomarker fit be extrapolated to the whole
dose grid? (default)</p>
</td></tr>
<tr><td><code id="plotDualResponses_+3A_showlegend">showLegend</code></td>
<td>
<p>should the legend be shown? (not default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
object with the dose-toxicity and dose-efficacy model fits
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plotDualResponses(
  DLEmodel = ModelTox,
  DLEsamples = Samples,
  Effmodel = ModelEff,
  Effsamples = Samples
)</code>: function todo
</p>
</li>
<li> <p><code>plotDualResponses(
  DLEmodel = ModelTox,
  DLEsamples = missing,
  Effmodel = ModelEff,
  Effsamples = missing
)</code>: Plot the DLE and efficacy curve side by side given a DLE model
and an efficacy model without any samples
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## we need a data object with doses &gt;= 1:
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
                y=c(0,0,0,0,0,1,1,0),
                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                doseGrid=seq(25,300,25),
                placebo=FALSE)
##plot the dose-DLE and dose-efficacy curves in two plots with DLE and efficacy samples
##define the DLE model which must be of 'ModelTox' class 
##(e.g 'LogisticIndepBeta' class model)
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
## define the efficacy model which must be of 'ModelEff' class
## (e.g 'Effloglog' class)
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
##define the DLE sample of 'Samples' class
##set up the same data set in class 'Data' for MCMC sampling for DLE
data1 &lt;- Data(x=data@x,y=data@y,doseGrid=data@doseGrid)
##Specify the options for MCMC
options &lt;- McmcOptions(burnin=100,step=2,samples=1000)


DLEsamples &lt;- mcmc(data=data1,model=DLEmodel,options=options)
##define the efficacy sample of 'Samples' class
Effsamples &lt;- mcmc(data=data,model=Effmodel,options=options)
##plot the dose-DLE and dose-efficacy curves with two plot side by side.
##For each curve the 95% credibility interval of the two samples are alos given
plotDualResponses(DLEmodel=DLEmodel,DLEsamples=DLEsamples,
         Effmodel=Effmodel,Effsamples=Effsamples,
         data=data)
## we need a data object with doses &gt;= 1:
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
                y=c(0,0,0,0,0,1,1,0),
                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                doseGrid=seq(25,300,25),
                placebo=FALSE)
##plot the dose-DLE and dose-efficacy curves in two plots without DLE and efficacy samples
##define the DLE model which must be of 'ModelTox' class 
##(e.g 'LogisticIndepBeta' class model)
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
## define the efficacy model which must be of 'ModelEff' class
## (e.g 'Effloglog' class)
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
##plot the dose-DLE and dose-efficacy curves with two plot side by side.
plotDualResponses(DLEmodel=DLEmodel,
                  Effmodel=Effmodel,
                  data=data)
</code></pre>

<hr>
<h2 id='plotGain'>Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,
a DLE sample, a given efficacy pseudo model and an efficacy sample</h2><span id='topic+plotGain'></span><span id='topic+plotGain+2CModelTox+2CSamples+2CModelEff+2CSamples-method'></span><span id='topic+plotGain+2CModelTox+2Cmissing+2CModelEff+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,
a DLE sample, a given efficacy pseudo model and an efficacy sample
</p>
<p>Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,
and a given efficacy pseudo model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)

## S4 method for signature 'ModelTox,Samples,ModelEff,Samples'
plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)

## S4 method for signature 'ModelTox,missing,ModelEff,missing'
plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGain_+3A_dlemodel">DLEmodel</code></td>
<td>
<p>the dose-DLE model of <code><a href="#topic+ModelTox-class">ModelTox</a></code> class object</p>
</td></tr>
<tr><td><code id="plotGain_+3A_dlesamples">DLEsamples</code></td>
<td>
<p>the DLE sample of <code><a href="#topic+Samples-class">Samples</a></code> class object</p>
</td></tr>
<tr><td><code id="plotGain_+3A_effmodel">Effmodel</code></td>
<td>
<p>the dose-efficacy model of <code><a href="#topic+ModelEff-class">ModelEff</a></code> class object</p>
</td></tr>
<tr><td><code id="plotGain_+3A_effsamples">Effsamples</code></td>
<td>
<p>the efficacy sample of of <code><a href="#topic+Samples-class">Samples</a></code> class object</p>
</td></tr>
<tr><td><code id="plotGain_+3A_data">data</code></td>
<td>
<p>the data input of <code><a href="#topic+DataDual-class">DataDual</a></code> class object</p>
</td></tr>
<tr><td><code id="plotGain_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
object for the plot
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plotGain(
  DLEmodel = ModelTox,
  DLEsamples = Samples,
  Effmodel = ModelEff,
  Effsamples = Samples
)</code>: Standard method
</p>
</li>
<li> <p><code>plotGain(
  DLEmodel = ModelTox,
  DLEsamples = missing,
  Effmodel = ModelEff,
  Effsamples = missing
)</code>: Standard method
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## we need a data object with doses &gt;= 1:
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
                y=c(0,0,0,0,0,1,1,0),
                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                doseGrid=seq(25,300,25),
                placebo=FALSE)
##plot the dose-DLE , dose-efficacy and gain curve in the same plot with DLE and efficacy samples
##define the DLE model which must be of 'ModelTox' class 
##(e.g 'LogisticIndepBeta' class model)
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
## define the efficacy model which must be of 'ModelEff' class
## (e.g 'Effloglog' class)
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
##define the DLE sample of 'Samples' class
##set up the same data set in class 'Data' for MCMC sampling for DLE
data1 &lt;- Data(x=data@x,y=data@y,doseGrid=data@doseGrid)

##Define the options for MCMC
options &lt;- McmcOptions(burnin=100,step=2,samples=1000)


DLEsamples &lt;- mcmc(data=data1,model=DLEmodel,options=options)
##define the efficacy sample of 'Samples' class
Effsamples &lt;- mcmc(data=data,model=Effmodel,options=options)
##plot the three curves of mean values of the DLEsamples, Effsamples and 
##gain value samples (obtained within this plotGain function) at all dose levels
plotGain(DLEmodel=DLEmodel,DLEsamples=DLEsamples,
         Effmodel=Effmodel,Effsamples=Effsamples,
         data=data)
## we need a data object with doses &gt;= 1:
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
                y=c(0,0,0,0,0,1,1,0),
                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                doseGrid=seq(25,300,25),
                placebo=FALSE)
##plot the dose-DLE , dose-efficacy and gain curve in the same plot with DLE and efficacy samples
##define the DLE model which must be of 'ModelTox' class 
##(e.g 'LogisticIndepBeta' class model)
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
## define the efficacy model which must be of 'ModelEff' class
## (e.g 'Effloglog' class)
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
##plot the three curves of using modal estimates of model parameters at all dose levels
plotGain(DLEmodel=DLEmodel,
         Effmodel=Effmodel,
         data=data)
</code></pre>

<hr>
<h2 id='printVignette'>Taken from utils package (print.vignette)</h2><span id='topic+printVignette'></span>

<h3>Description</h3>

<p>Taken from utils package (print.vignette)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printVignette(x, ...)
</code></pre>

<hr>
<h2 id='prob'>Compute the probability for a given dose, given model and samples</h2><span id='topic+prob'></span><span id='topic+prob+2Cnumeric+2CModel+2CSamples-method'></span><span id='topic+prob+2Cnumeric+2CModelTox+2CSamples-method'></span><span id='topic+prob+2Cnumeric+2CModelTox+2Cmissing-method'></span>

<h3>Description</h3>

<p>Compute the probability for a given dose, given model and samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob(dose, model, samples, ...)

## S4 method for signature 'numeric,Model,Samples'
prob(dose, model, samples, ...)

## S4 method for signature 'numeric,ModelTox,Samples'
prob(dose, model, samples, ...)

## S4 method for signature 'numeric,ModelTox,missing'
prob(dose, model, samples, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_+3A_dose">dose</code></td>
<td>
<p>the dose</p>
</td></tr>
<tr><td><code id="prob_+3A_model">model</code></td>
<td>
<p>the <code><a href="#topic+Model-class">Model</a></code> object</p>
</td></tr>
<tr><td><code id="prob_+3A_samples">samples</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code></p>
</td></tr>
<tr><td><code id="prob_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector (for <code><a href="#topic+Model-class">Model</a></code> objects) of probability
samples.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>prob(dose = numeric, model = ModelTox, samples = Samples)</code>: Compute the probability for a given dose, 
given Pseudo DLE model and samples
</p>
</li>
<li> <p><code>prob(dose = numeric, model = ModelTox, samples = missing)</code>: Compute the probability for a given dose, given Pseudo DLE model without samples
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# create some data
data &lt;- Data(x =c (0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y = c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort = c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid = c(0.1, 0.5, 1.5, 3, 6,
                          seq(from=10, to=80, by=2)))

# Initialize a  model
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=matrix(c(1, -0.5, -0.5, 1),
                                      nrow=2),
                           refDose=56)

# Get samples from posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# posterior for Prob(DLT | dose=50)
tox.prob &lt;- prob(dose=50, model=model, samples=samples)




# create data from the 'DataDual' class
data &lt;- DataDual(x = c(25,50,25,50,75,300,250,150),
                 y = c(0,0,0,0,0,1,1,0),
                 w = c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                 doseGrid = seq(25,300,25))

## Initialize a model from 'ModelTox' class e.g using 'LogisticIndepBeta' model
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

options &lt;- McmcOptions(burnin=100, step=2, samples=200)
DLEsamples &lt;- mcmc(data=data,model=DLEmodel,options=options)

tox.prob &lt;- prob(dose=100, model = DLEmodel, samples = DLEsamples)



# create data from the 'DataDual' class
data &lt;- DataDual(x = c(25,50,25,50,75,300,250,150),
                 y = c(0,0,0,0,0,1,1,0),
                 w = c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                 doseGrid = seq(25,300,25))

## Initialize a model from 'ModelTox' class e.g using 'LogisticIndepBeta' model
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

tox.prob &lt;- prob(dose=100, model = DLEmodel)

</code></pre>

<hr>
<h2 id='probit'>Shorthand for probit function</h2><span id='topic+probit'></span>

<h3>Description</h3>

<p>Shorthand for probit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probit_+3A_x">x</code></td>
<td>
<p>the function argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the probit(x)
</p>

<hr>
<h2 id='ProbitLogNormal'>Initialization function for the &quot;ProbitLogNormal&quot; class</h2><span id='topic+ProbitLogNormal'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;ProbitLogNormal&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProbitLogNormal(mu, Sigma, refDose = 1, useLogDose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProbitLogNormal_+3A_mu">mu</code></td>
<td>
<p>the prior mean vector</p>
</td></tr>
<tr><td><code id="ProbitLogNormal_+3A_sigma">Sigma</code></td>
<td>
<p>the prior covariance matrix</p>
</td></tr>
<tr><td><code id="ProbitLogNormal_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose <code class="reqn">x^{*}</code>, default 1 (no standardization)</p>
</td></tr>
<tr><td><code id="ProbitLogNormal_+3A_uselogdose">useLogDose</code></td>
<td>
<p>should the log of (standardized) dose be used? (not default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+ProbitLogNormal-class">ProbitLogNormal</a></code> object
</p>

<hr>
<h2 id='ProbitLogNormal-class'>Probit model with bivariate log normal prior</h2><span id='topic+ProbitLogNormal-class'></span><span id='topic+.ProbitLogNormal'></span>

<h3>Description</h3>

<p>This is probit regression model with a bivariate normal prior on
the intercept and log slope. 
The covariate is the dose <code class="reqn">x</code> itself, potentially divided
by a reference dose <code class="reqn">x^{*}</code>, or the logarithm of it:
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">probit[p(x)] = \alpha + \beta 
\cdot x/x^{*}</code>
</p>

<p>or
</p>
<p style="text-align: center;"><code class="reqn">probit[p(x)] = \alpha + \beta 
\cdot \log(x/x^{*})</code>
</p>

<p>in case that the option <code>useLogDose</code> is <code>TRUE</code>.
Here <code class="reqn">p(x)</code> is the probability of observing a DLT for a given dose
<code class="reqn">x</code>.
</p>
<p>The prior is
</p>
<p style="text-align: center;"><code class="reqn">(\alpha, \log(\beta)) \sim Normal(\mu, \Sigma)</code>
</p>

<p>The slots of this class contain the mean vector and the covariance matrix of
the bivariate normal distribution, as well as the reference dose.
Note that the parametrization inside the class uses alpha0 and alpha1.
</p>
<p>This model is also used in the <code><a href="#topic+DualEndpoint-class">DualEndpoint</a></code> classes,
so this class can be used to check the prior assumptions on the dose-toxicity
model - even when sampling from the prior distribution of the dual endpoint model
is not possible.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code></dt><dd><p>the prior mean vector <code class="reqn">\mu</code></p>
</dd>
<dt><code>Sigma</code></dt><dd><p>the prior covariance matrix <code class="reqn">\Sigma</code></p>
</dd>
<dt><code>refDose</code></dt><dd><p>the reference dose <code class="reqn">x^{*}</code></p>
</dd>
<dt><code>useLogDose</code></dt><dd><p>should the log of (standardized) dose be used?</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- ProbitLogNormal(mu = c(-0.85, 1),
                           Sigma = matrix(c(1, -0.5, -0.5, 1), nrow = 2))

## we can also specify a reference dose, and use a log transformation of
## standardized dose in the model:
model &lt;- ProbitLogNormal(mu = c(-0.85, 1),
                         Sigma = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                         refDose = 7.2,
                         useLogDose=TRUE)


</code></pre>

<hr>
<h2 id='PseudoDualFlexiSimulations'>Initialization function for 'PseudoDualFlexiSimulations' class</h2><span id='topic+PseudoDualFlexiSimulations'></span>

<h3>Description</h3>

<p>Initialization function for 'PseudoDualFlexiSimulations' class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PseudoDualFlexiSimulations(sigma2betaWest, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PseudoDualFlexiSimulations_+3A_sigma2betawest">sigma2betaWest</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualFlexiSimulations-class">PseudoDualFlexiSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualFlexiSimulations_+3A_...">...</code></td>
<td>
<p>additional parameters from <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+PseudoDualFlexiSimulations-class">PseudoDualFlexiSimulations</a></code> object
</p>

<hr>
<h2 id='PseudoDualFlexiSimulations-class'>This is a class which captures the trial simulations design using both the
DLE and efficacy responses. The design of model from <code><a href="#topic+ModelTox-class">ModelTox</a></code>
class and the efficacy model from <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class 
It contains all slots from 
<code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code>, <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> 
and <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> object.
In comparison to the parent class <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code>, 
it contains additional slots to 
capture the sigma2betaW estimates.</h2><span id='topic+PseudoDualFlexiSimulations-class'></span><span id='topic+.PseudoDualFlexiSimulations'></span>

<h3>Description</h3>

<p>This is a class which captures the trial simulations design using both the
DLE and efficacy responses. The design of model from <code><a href="#topic+ModelTox-class">ModelTox</a></code>
class and the efficacy model from <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class 
It contains all slots from 
<code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code>, <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> 
and <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> object.
In comparison to the parent class <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code>, 
it contains additional slots to 
capture the sigma2betaW estimates.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sigma2betaWest</code></dt><dd><p>the vector of the final posterior mean sigma2betaW estimates</p>
</dd>
</dl>

<hr>
<h2 id='PseudoDualSimulations'>Initialization function for 'DualPseudoSimulations' class</h2><span id='topic+PseudoDualSimulations'></span>

<h3>Description</h3>

<p>Initialization function for 'DualPseudoSimulations' class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PseudoDualSimulations(
  fitEff,
  FinalGstarEstimates,
  FinalGstarAtDoseGrid,
  FinalGstarCIs,
  FinalGstarRatios,
  FinalOptimalDose,
  FinalOptimalDoseAtDoseGrid,
  sigma2est,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PseudoDualSimulations_+3A_fiteff">fitEff</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualSimulations_+3A_finalgstarestimates">FinalGstarEstimates</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualSimulations_+3A_finalgstaratdosegrid">FinalGstarAtDoseGrid</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualSimulations_+3A_finalgstarcis">FinalGstarCIs</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualSimulations_+3A_finalgstarratios">FinalGstarRatios</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualSimulations_+3A_finaloptimaldose">FinalOptimalDose</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualSimulations_+3A_finaloptimaldoseatdosegrid">FinalOptimalDoseAtDoseGrid</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualSimulations_+3A_sigma2est">sigma2est</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoDualSimulations_+3A_...">...</code></td>
<td>
<p>additional parameters from <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> object
</p>

<hr>
<h2 id='PseudoDualSimulations-class'>This is a class which captures the trial simulations design using both the
DLE and efficacy responses. The design of model from <code><a href="#topic+ModelTox-class">ModelTox</a></code>
class and the efficacy model from <code><a href="#topic+ModelEff-class">ModelEff</a></code> class 
(except <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class). It contains all slots from 
<code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code> and <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> object.
In comparison to the parent class <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code>, 
it contains additional slots to 
capture the dose-efficacy curve and the sigma2 estimates.</h2><span id='topic+PseudoDualSimulations-class'></span><span id='topic+.PseudoDualSimulations'></span>

<h3>Description</h3>

<p>This is a class which captures the trial simulations design using both the
DLE and efficacy responses. The design of model from <code><a href="#topic+ModelTox-class">ModelTox</a></code>
class and the efficacy model from <code><a href="#topic+ModelEff-class">ModelEff</a></code> class 
(except <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class). It contains all slots from 
<code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code> and <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> object.
In comparison to the parent class <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code>, 
it contains additional slots to 
capture the dose-efficacy curve and the sigma2 estimates.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fitEff</code></dt><dd><p>list of the final values. If DLE and efficacy samples are gerneated, it contains the
final fitted values. If no DLE and efficacy samples are used, it contains the modal estimates of the
parameters in the two models and the posterior estimates of the probabilities of the occurrence of a
DLE and the expected efficacy responses.</p>
</dd>
<dt><code>FinalGstarEstimates</code></dt><dd><p>a vector of the final estimates of Gstar at the end of each simulations.</p>
</dd>
<dt><code>FinalGstarAtDoseGrid</code></dt><dd><p>is a vectorof the final estimates of Gstar at dose Grid at the end of each simulations</p>
</dd>
<dt><code>FinalGstarCIs</code></dt><dd><p>is the list of all 95% credibility interval of the final estimates of Gstar</p>
</dd>
<dt><code>FinalGstarRatios</code></dt><dd><p>is the vector of the ratios of the CI, the ratio of the upper to the lower 95% credibility interval
of the final estimates of Gstar</p>
</dd>
<dt><code>FinalOptimalDose</code></dt><dd><p>is the vector of the final optimal dose, the minimum of the final TDtargetEndOfTrial estimates and Gstar
estimates</p>
</dd>
<dt><code>FinalOptimalDoseAtDoseGrid</code></dt><dd><p>is the vector of the final optimal dose, the minimum of the final TDtargetEndOfTrial estimates 
and Gstar estimates at dose Grid</p>
</dd>
<dt><code>sigma2est</code></dt><dd><p>the vector of the final posterior mean sigma2 estimates</p>
</dd>
</dl>

<hr>
<h2 id='PseudoDualSimulationsSummary-class'>Class for the summary of the dual responses simulations using pseudo models</h2><span id='topic+PseudoDualSimulationsSummary-class'></span><span id='topic+.PseudoDualSimulationsSummary'></span>

<h3>Description</h3>

<p>It contains all slots from <code><a href="#topic+PseudoSimulationsSummary-class">PseudoSimulationsSummary</a></code> object. In addition to 
the slots in the parent class <code><a href="#topic+PseudoSimulationsSummary-class">PseudoSimulationsSummary</a></code>, it contains four 
more slots for the efficacy model fit information.
</p>


<h3>Details</h3>

<p>Note that objects should not be created by users, therefore no initialization function
is provided for this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>targetGstar</code></dt><dd><p>the target dose level such that its gain value is at maximum</p>
</dd>
<dt><code>targetGstarAtDoseGrid</code></dt><dd><p>the dose level at dose Grid closest and below Gstar</p>
</dd>
<dt><code>GstarSummary</code></dt><dd><p>the six-number table summary (lowest, 25th, 50th (median), 75th percentile, mean 
and highest value) of the final Gstar values obtained across all simulations</p>
</dd>
<dt><code>ratioGstarSummary</code></dt><dd><p>the six-number summary table of the ratios of the upper to the lower 95%
credibility intervals of the final Gstar across all simulations</p>
</dd>
<dt><code>EffFitAtDoseMostSelected</code></dt><dd><p>fitted expected mean efficacy value at dose most often
selected</p>
</dd>
<dt><code>meanEffFit</code></dt><dd><p>list with mean, lower (2.5
efficacy value at each dose level.</p>
</dd>
</dl>

<hr>
<h2 id='PseudoSimulations'>Initialization function of the 'PseudoSimulations' class</h2><span id='topic+PseudoSimulations'></span>

<h3>Description</h3>

<p>Initialization function of the 'PseudoSimulations' class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PseudoSimulations(
  fit,
  FinalTDtargetDuringTrialEstimates,
  FinalTDtargetEndOfTrialEstimates,
  FinalTDtargetDuringTrialAtDoseGrid,
  FinalTDtargetEndOfTrialAtDoseGrid,
  FinalTDEOTCIs,
  FinalTDEOTRatios,
  FinalCIs,
  FinalRatios,
  stopReasons,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PseudoSimulations_+3A_fit">fit</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_finaltdtargetduringtrialestimates">FinalTDtargetDuringTrialEstimates</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_finaltdtargetendoftrialestimates">FinalTDtargetEndOfTrialEstimates</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_finaltdtargetduringtrialatdosegrid">FinalTDtargetDuringTrialAtDoseGrid</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_finaltdtargetendoftrialatdosegrid">FinalTDtargetEndOfTrialAtDoseGrid</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_finaltdeotcis">FinalTDEOTCIs</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_finaltdeotratios">FinalTDEOTRatios</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_finalcis">FinalCIs</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_finalratios">FinalRatios</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_stopreasons">stopReasons</code></td>
<td>
<p>please refer to <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> class object</p>
</td></tr>
<tr><td><code id="PseudoSimulations_+3A_...">...</code></td>
<td>
<p>additional parameters from <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> object
</p>

<hr>
<h2 id='PseudoSimulations-class'>This is a class which captures the trial simulations from designs using 
pseudo model. The design for DLE only responses and model from <code><a href="#topic+ModelTox-class">ModelTox</a></code>
class object. It contains all slots from <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code> object.
Additional slots fit and stopReasons compared to the general class 
<code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code>.</h2><span id='topic+PseudoSimulations-class'></span><span id='topic+.PseudoSimulations'></span>

<h3>Description</h3>

<p>This is a class which captures the trial simulations from designs using 
pseudo model. The design for DLE only responses and model from <code><a href="#topic+ModelTox-class">ModelTox</a></code>
class object. It contains all slots from <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code> object.
Additional slots fit and stopReasons compared to the general class 
<code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fit</code></dt><dd><p>list of the final values. If samples are involved, these are the final fitted values.
If no samples are involved, these are included the final modal estimates of the model parameters
and the posterior estimates of the probabilities of the occurrence of a DLE.</p>
</dd>
<dt><code>FinalTDtargetDuringTrialEstimates</code></dt><dd><p>the vector of all final estimates (the last estimate of) the TDtargetDuringTrial at the end 
of each simultaions/when each trial stops</p>
</dd>
<dt><code>FinalTDtargetEndOfTrialEstimates</code></dt><dd><p>vector of all final estimates or the last estimate of the TDtargetEndOfTrial when each trial 
stops</p>
</dd>
<dt><code>FinalTDtargetDuringTrialAtDoseGrid</code></dt><dd><p>vector of the dose levels at dose grid closest below the final TDtargetDuringTrial estimates</p>
</dd>
<dt><code>FinalTDtargetEndOfTrialAtDoseGrid</code></dt><dd><p>vector of  the dose levels at dose grid closest below the final TDtargetEndOfTrial estimates</p>
</dd>
<dt><code>FinalTDEOTCIs</code></dt><dd><p>is the list of all 95% credibility interval of the final estimates of the TDtargetEndOfTrial</p>
</dd>
<dt><code>FinalTDEOTRatios</code></dt><dd><p>is the vector of the ratios of the CI, the raatio of the upper to the lower 95% credibility intervals 
of the final estimates of the TDtargetEndOfTrial</p>
</dd>
<dt><code>FinalCIs</code></dt><dd><p>list of all the final 95% credibility intervals of the TDtargetEndofTrial estimates or of the final optimal dose 
estimates when DLE and efficacy responses are incorporated after each simulations</p>
</dd>
<dt><code>FinalRatios</code></dt><dd><p>vector of all the final ratios, the ratios of the upper to the lower 95% credibility interval of the 
final estimates of the TDtargetEndOfTrial or of the final optimal dose estiamtes (when DLE and efficacy responses are
incorporated) after each simulations</p>
</dd>
<dt><code>stopReasons</code></dt><dd><p>todo: add slot description</p>
</dd>
</dl>

<hr>
<h2 id='PseudoSimulationsSummary-class'>Class for the summary of pseudo-models simulations output</h2><span id='topic+PseudoSimulationsSummary-class'></span><span id='topic+.PseudoSimulationsSummary'></span>

<h3>Description</h3>

<p>Note that objects should not be created by users, therefore no
initialization function is provided for this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>targetEndOfTrial</code></dt><dd><p>the target probability of DLE wanted at the end of a trial</p>
</dd>
<dt><code>targetDoseEndOfTrial</code></dt><dd><p>the dose level corresponds to the target probability
of DLE wanted at the end of a trial, TDEOT</p>
</dd>
<dt><code>targetDoseEndOfTrialAtDoseGrid</code></dt><dd><p>the dose level at dose grid corresponds to the target probability
of DLE wanted at the end of a trial</p>
</dd>
<dt><code>targetDuringTrial</code></dt><dd><p>the target probability of DLE wanted during a trial</p>
</dd>
<dt><code>targetDoseDuringTrial</code></dt><dd><p>the dose level corresponds to the target probability of DLE
wanted during the trial. TDDT</p>
</dd>
<dt><code>targetDoseDuringTrialAtDoseGrid</code></dt><dd><p>the dose level at dose grid corresponds to the target probability
of DLE wanted during a trial</p>
</dd>
<dt><code>TDEOTSummary</code></dt><dd><p>the six-number table summary, include the lowest, the 25th precentile (lower quatile), 
the 50th percentile (median), the mean, the 27th percentile and the highest values of the 
final dose levels obtained corresponds to the target probability of DLE
want at the end of a trial across all simulations</p>
</dd>
<dt><code>TDDTSummary</code></dt><dd><p>the six-number table summary, include the lowest, the 25th precentile (lower quatile), 
the 50th percentile (median), the mean, the 27th percentile and the highest values of the 
final dose levels obtained corresponds to the target probability of DLE
want during a trial across all simulations</p>
</dd>
<dt><code>FinalDoseRecSummary</code></dt><dd><p>the six-number table summary, include the lowest, the 25th precentile (lower quatile), 
the 50th percentile (median), the mean, the 27th percentile and the highest values of the 
final optimal doses, which is either the TDEOT when only DLE response are incorporated into 
the escalation procedure or the minimum of the TDEOT and Gstar when DLE and efficacy responses are
incorporated, across all simulations</p>
</dd>
<dt><code>ratioTDEOTSummary</code></dt><dd><p>the six-number summary table of the final ratios of the upper to the lower 95%
credibility intervals of the final TDEOTs across all simulations</p>
</dd>
<dt><code>FinalRatioSummary</code></dt><dd><p>the six-number summary table of the final ratios of the upper to the lower 95%
credibility intervals of the final optimal doses across all simulations
#@slot doseRec the dose level that will be recommend for subsequent study</p>
</dd>
<dt><code>nsim</code></dt><dd><p>number of simulations</p>
</dd>
<dt><code>propDLE</code></dt><dd><p>proportions of DLE in the trials</p>
</dd>
<dt><code>meanToxRisk</code></dt><dd><p>mean toxicity risks for the patients</p>
</dd>
<dt><code>doseSelected</code></dt><dd><p>doses selected as MTD (targetDoseEndOfTrial)</p>
</dd>
<dt><code>toxAtDosesSelected</code></dt><dd><p>true toxicity at doses selected</p>
</dd>
<dt><code>propAtTargetEndOfTrial</code></dt><dd><p>Proportion of trials selecting at the doseGrid closest below the MTD, the 
targetDoseEndOfTrial</p>
</dd>
<dt><code>propAtTargetDuringTrial</code></dt><dd><p>Proportion of trials selecting at the doseGrid closest below the 
targetDoseDuringTrial</p>
</dd>
<dt><code>doseMostSelected</code></dt><dd><p>dose most often selected as MTD</p>
</dd>
<dt><code>obsToxRateAtDoseMostSelected</code></dt><dd><p>observed toxicity rate at dose most often
selected</p>
</dd>
<dt><code>nObs</code></dt><dd><p>number of patients overall</p>
</dd>
<dt><code>nAboveTargetEndOfTrial</code></dt><dd><p>number of patients treated above targetDoseEndOfTrial</p>
</dd>
<dt><code>nAboveTargetDuringTrial</code></dt><dd><p>number of patients treated above targetDoseDuringTrial</p>
</dd>
<dt><code>doseGrid</code></dt><dd><p>the dose grid that has been used</p>
</dd>
<dt><code>fitAtDoseMostSelected</code></dt><dd><p>fitted toxicity rate at dose most often selected</p>
</dd>
<dt><code>meanFit</code></dt><dd><p>list with the average, lower (2.5
quantiles of the mean fitted toxicity at each dose level</p>
</dd>
</dl>

<hr>
<h2 id='qinvGamma'>Compute the quantile function of Inverse gamma distribution</h2><span id='topic+qinvGamma'></span>

<h3>Description</h3>

<p>Compute the quantile function of Inverse gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qinvGamma(p, a, b, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qinvGamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="qinvGamma_+3A_a">a</code></td>
<td>
<p>the shape parameter of the inverse gamma distribution</p>
</td></tr>
<tr><td><code id="qinvGamma_+3A_b">b</code></td>
<td>
<p>the scale parameter of the inverse gamm distribution</p>
</td></tr>
<tr><td><code id="qinvGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X  &gt; x], otherwise, P[X &lt;= x].</p>
</td></tr>
<tr><td><code id="qinvGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if FALSE (default) expect that <code>p</code> is a probability, otherwise interpret it as <code>log(p)</code></p>
</td></tr>
</table>

<hr>
<h2 id='Quantiles2LogisticNormal'>Convert prior quantiles (lower, median, upper) to logistic (log)
normal model</h2><span id='topic+Quantiles2LogisticNormal'></span>

<h3>Description</h3>

<p>This function uses generalised simulated annealing to optimise
a <code><a href="#topic+LogisticNormal-class">LogisticNormal</a></code> model to be as close as possible
to the given prior quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Quantiles2LogisticNormal(
  dosegrid,
  refDose,
  lower,
  median,
  upper,
  level = 0.95,
  logNormal = FALSE,
  parstart = NULL,
  parlower = c(-10, -10, 0, 0, -0.95),
  parupper = c(10, 10, 10, 10, 0.95),
  seed = 12345,
  verbose = TRUE,
  control = list(threshold.stop = 0.01, maxit = 50000, temperature = 50000, max.time =
    600)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Quantiles2LogisticNormal_+3A_dosegrid">dosegrid</code></td>
<td>
<p>the dose grid</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_refdose">refDose</code></td>
<td>
<p>the reference dose</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_lower">lower</code></td>
<td>
<p>the lower quantiles</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_median">median</code></td>
<td>
<p>the medians</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_upper">upper</code></td>
<td>
<p>the upper quantiles</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_level">level</code></td>
<td>
<p>the credible level of the (lower, upper) intervals (default:
0.95)</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_lognormal">logNormal</code></td>
<td>
<p>use the log-normal prior? (not default) otherwise, the
normal prior for the logistic regression coefficients is used</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_parstart">parstart</code></td>
<td>
<p>starting values for the parameters. By default, these
are determined from the medians supplied.</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_parlower">parlower</code></td>
<td>
<p>lower bounds on the parameters (intercept alpha and the
slope beta, the corresponding standard deviations and the correlation.)</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_parupper">parupper</code></td>
<td>
<p>upper bounds on the parameters</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_seed">seed</code></td>
<td>
<p>seed for random number generation</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_verbose">verbose</code></td>
<td>
<p>be verbose? (default)</p>
</td></tr>
<tr><td><code id="Quantiles2LogisticNormal_+3A_control">control</code></td>
<td>
<p>additional options for the optimisation routine, see
<code><a href="GenSA.html#topic+GenSA">GenSA</a></code> for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the best approximating <code>model</code>
(<code><a href="#topic+LogisticNormal-class">LogisticNormal</a></code> or
<code><a href="#topic+LogisticLogNormal-class">LogisticLogNormal</a></code>), the resulting <code>quantiles</code>, the
<code>required</code> quantiles and the <code>distance</code> to the required quantiles,
as well as the final <code>parameters</code> (which could be used for running the
algorithm a second time)
</p>

<hr>
<h2 id='Report'>A Reference Class to represent sequentially updated reporting objects.</h2><span id='topic+Report'></span>

<h3>Description</h3>

<p>A Reference Class to represent sequentially updated reporting objects.
</p>


<h3>Fields</h3>


<dl>
<dt><code>object</code></dt><dd><p>The object from which to report</p>
</dd>
<dt><code>df</code></dt><dd><p>the data frame to which columns are sequentially added</p>
</dd>
<dt><code>dfNames</code></dt><dd><p>the names to which strings are sequentially added</p>
</dd>
</dl>

<hr>
<h2 id='rinvGamma'>The random generation of the Inverse gamma distribution</h2><span id='topic+rinvGamma'></span>

<h3>Description</h3>

<p>The random generation of the Inverse gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rinvGamma(n, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rinvGamma_+3A_n">n</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code id="rinvGamma_+3A_a">a</code></td>
<td>
<p>the shape parameter of the inverse gamma distribution</p>
</td></tr>
<tr><td><code id="rinvGamma_+3A_b">b</code></td>
<td>
<p>the scale parameter of the inverse gamm distribution</p>
</td></tr>
</table>

<hr>
<h2 id='RuleDesign'>Initialization function for &quot;RuleDesign&quot;</h2><span id='topic+RuleDesign'></span>

<h3>Description</h3>

<p>Initialization function for &quot;RuleDesign&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RuleDesign(nextBest, cohortSize, data, startingDose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RuleDesign_+3A_nextbest">nextBest</code></td>
<td>
<p>see <code><a href="#topic+RuleDesign-class">RuleDesign</a></code></p>
</td></tr>
<tr><td><code id="RuleDesign_+3A_cohortsize">cohortSize</code></td>
<td>
<p>see <code><a href="#topic+RuleDesign-class">RuleDesign</a></code></p>
</td></tr>
<tr><td><code id="RuleDesign_+3A_data">data</code></td>
<td>
<p>see <code><a href="#topic+RuleDesign-class">RuleDesign</a></code></p>
</td></tr>
<tr><td><code id="RuleDesign_+3A_startingdose">startingDose</code></td>
<td>
<p>see <code><a href="#topic+RuleDesign-class">RuleDesign</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+RuleDesign-class">RuleDesign</a></code> object
</p>

<hr>
<h2 id='RuleDesign-class'>Class for rule-based designs</h2><span id='topic+RuleDesign-class'></span><span id='topic+.RuleDesign'></span>

<h3>Description</h3>

<p>The difference to <code><a href="#topic+Design-class">Design</a></code> class is that
model, stopping and increments slots are missing.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nextBest</code></dt><dd><p>how to find the next best dose, an object of class
<code><a href="#topic+NextBest-class">NextBest</a></code></p>
</dd>
<dt><code>cohortSize</code></dt><dd><p>rules for the cohort sizes,
an object of class <code><a href="#topic+CohortSize-class">CohortSize</a></code></p>
</dd>
<dt><code>data</code></dt><dd><p>what is the dose grid, any previous data, etc., contained
in an object of class <code><a href="#topic+Data-class">Data</a></code></p>
</dd>
<dt><code>startingDose</code></dt><dd><p>what is the starting dose? Must lie on the grid in
<code>data</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
emptydata &lt;- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))

# inizialing a 3+3 design with constant cohort size of 3 and
# starting dose equal 5
myDesign &lt;- RuleDesign(nextBest = NextBestThreePlusThree(),
                       cohortSize = CohortSizeConst(size=3L),
                       data = emptydata,
                       startingDose = 5)
  
  
</code></pre>

<hr>
<h2 id='safeInteger'>Safe conversion to integer vector</h2><span id='topic+safeInteger'></span>

<h3>Description</h3>

<p>Safe conversion to integer vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safeInteger(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="safeInteger_+3A_x">x</code></td>
<td>
<p>the numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the integer vector
</p>

<hr>
<h2 id='Samples'>Initialization function for &quot;Samples&quot;</h2><span id='topic+Samples'></span>

<h3>Description</h3>

<p>Initialization function for &quot;Samples&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Samples(data, options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Samples_+3A_data">data</code></td>
<td>
<p>see <code><a href="#topic+Samples-class">Samples</a></code></p>
</td></tr>
<tr><td><code id="Samples_+3A_options">options</code></td>
<td>
<p>see <code><a href="#topic+Samples-class">Samples</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+Samples-class">Samples</a></code> object
</p>

<hr>
<h2 id='Samples-class'>Class for the MCMC output</h2><span id='topic+Samples-class'></span><span id='topic+.Samples'></span>

<h3>Description</h3>

<p>Class for the MCMC output
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>a list where each entry contains the samples of a (vector-valued)
parameter in a vector/matrix in the format (number of samples) x (dimension
of the parameter).</p>
</dd>
<dt><code>options</code></dt><dd><p>the <code><a href="#topic+McmcOptions-class">McmcOptions</a></code> which have been used</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Saving the mcmc options which were used to generate the samples
options &lt;- McmcOptions(burnin=10000,
                       step=2,
                       samples=10000)

# Create an object of class 'Samples'
# Here the parameters 'alpha' and 'beta' are randomly generated. Of coure in 
# a real example these would come as an output from mcmc procedures
samples &lt;- Samples(data=list(alpha=rnorm(10000),beta=rnorm(10000)),
                   options=options)

</code></pre>

<hr>
<h2 id='sampleSize'>Compute the number of samples for a given MCMC options triple</h2><span id='topic+sampleSize'></span>

<h3>Description</h3>

<p>Compute the number of samples for a given MCMC options triple
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleSize(mcmcOptions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleSize_+3A_mcmcoptions">mcmcOptions</code></td>
<td>
<p>the <code><a href="#topic+McmcOptions-class">McmcOptions</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting sample size
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set up MCMC option in order to have a burn-in of 10000 iterations and
# then take every other iteration up to a collection of 10000 samples
options &lt;- McmcOptions(burnin=10000,
                       step=2,
                       samples=10000)

sampleSize(options)

</code></pre>

<hr>
<h2 id='saveSample'>Determine if we should save this sample</h2><span id='topic+saveSample'></span>

<h3>Description</h3>

<p>Determine if we should save this sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveSample(iteration, mcmcOptions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveSample_+3A_iteration">iteration</code></td>
<td>
<p>the current iteration index</p>
</td></tr>
<tr><td><code id="saveSample_+3A_mcmcoptions">mcmcOptions</code></td>
<td>
<p>the <code><a href="#topic+McmcOptions-class">McmcOptions</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value, if we should save this sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set up MCMC option in order to have a burn-in of 10000 iterations and
# then take every other iteration up to a collection of 10000 samples
options &lt;- McmcOptions(burnin=10000,
                       step=2,
                       samples=10000)

sampleSize(options)

saveSample(iteration=5,
           mcmcOptions=options)
</code></pre>

<hr>
<h2 id='setSeed'>Helper function to set and save the RNG seed</h2><span id='topic+setSeed'></span>

<h3>Description</h3>

<p>This is basically copied from simulate.lm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSeed(seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSeed_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator
should be initialized (&ldquo;seeded&rdquo;). Either <code>NULL</code> (default) or an
integer that will be used in a call to <code><a href="base.html#topic+set.seed">set.seed</a></code> before
simulating the response vectors. If set, the value is saved as the
<code>seed</code> slot of the returned object. The default, <code>NULL</code> will
not change the random generator state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The RNGstate will be returned, in order to call this function
with this input to reproduce the obtained simulation results
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove <a href="mailto:sabanesd@roche.com">sabanesd@roche.com</a>
</p>

<hr>
<h2 id='show+2CDualSimulationsSummary-method'>Show the summary of the dual-endpoint simulations</h2><span id='topic+show+2CDualSimulationsSummary-method'></span>

<h3>Description</h3>

<p>Show the summary of the dual-endpoint simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DualSimulationsSummary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CDualSimulationsSummary-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+DualSimulationsSummary-class">DualSimulationsSummary</a></code> object we want
to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns a data frame of the results with one row and
appropriate column names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 30))

# Initialize the CRM model 
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth="RW1")

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping4 &lt;- StoppingTargetBiomarker(target=c(0.9, 1),
                                       prob=0.5)
# small number of patients just for illustration here
myStopping &lt;- myStopping4 | StoppingMinPatients(10)

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- DualDesign(model = model,
                     data = emptydata,
                     nextBest = myNextBest,
                     stopping = myStopping,
                     increments = myIncrements,
                     cohortSize = CohortSizeConst(3),
                     startingDose = 3)
  
# define scenarios for the TRUE toxicity and efficacy profiles
betaMod &lt;- function (dose, e0, eMax, delta1, delta2, scal)
{
  maxDens &lt;- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))
  dose &lt;- dose/scal
  e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2
}

trueBiomarker &lt;- function(dose)
{
  betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100)
}

trueTox &lt;- function(dose)
{
  pnorm((dose-60)/10)
}

# Draw the TRUE profiles
par(mfrow=c(1, 2))
curve(trueTox(x), from=0, to=80)
curve(trueBiomarker(x), from=0, to=80)

# Run the simulation on the desired design
# We only generate 1 trial outcome here for illustration, for the actual study 
# Also for illustration purpose, we will use 5 burn-ins to generate 20 samples
# this should be increased of course
mySims &lt;- simulate(design,
                   trueTox=trueTox,
                   trueBiomarker=trueBiomarker,
                   sigma2W=0.01,
                   rho=0,
                   nsim=1,
                   parallel=FALSE,
                   seed=3,
                   startingDose=6,
                   mcmcOptions =
                     McmcOptions(burnin=5,
                                 step=1,
                                 samples=20))

# Show the summary of the Simulations
show(summary(mySims,
             trueTox = trueTox,
             trueBiomarker = trueBiomarker))



  
</code></pre>

<hr>
<h2 id='show+2CGeneralSimulationsSummary-method'>Show the summary of the simulations</h2><span id='topic+show+2CGeneralSimulationsSummary-method'></span>

<h3>Description</h3>

<p>Show the summary of the simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeneralSimulationsSummary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CGeneralSimulationsSummary-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeneralSimulationsSummary-class">GeneralSimulationsSummary</a></code> object we want
to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns a data frame of the results with one row and
appropriate column names
</p>

<hr>
<h2 id='show+2CPseudoDualSimulationsSummary-method'>Show the summary of Pseudo Dual simulations summary</h2><span id='topic+show+2CPseudoDualSimulationsSummary-method'></span>

<h3>Description</h3>

<p>Show the summary of Pseudo Dual simulations summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoDualSimulationsSummary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CPseudoDualSimulationsSummary-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+PseudoDualSimulationsSummary-class">PseudoDualSimulationsSummary</a></code> object we want to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns a data frame of the results with one row and appropriate column names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##If DLE and efficacy responses are considered in the simulations
##Specified your simulations when no samples are used
## we need a data object with doses &gt;= 1:
data &lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

##The efficacy model of 'ModelEff' (e.g 'Effloglog') class 
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),
                    nu=c(a=1,b=0.025),data=data,c=0)

##The escalation rule using the 'NextBestMaxGain' class
mynextbest&lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,
                            DLEEndOfTrialtarget=0.3)


##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 36 subjects are treated
myStopping &lt;- StoppingMinPatients(nPatients=36)
##Now specified the design with all the above information and starting with a dose of 25

##Specified the design(for details please refer to the 'DualResponsesDesign' example)
design &lt;- DualResponsesDesign(nextBest=mynextbest,
                              model=DLEmodel,
                              Effmodel=Effmodel,
                              stopping=myStopping,
                              increments=myIncrements,
                              cohortSize=mySize,
                              data=data,startingDose=25)
##Specify the true DLE and efficacy curves
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- function(dose)
{Effmodel@ExpEff(dose,theta1=-4.818429,theta2=3.653058)
}

## Then specified the simulations and generate the trial 
##For illustration purpose only 2 simulation is produced (nsim=2). 
mySim &lt;-simulate(object=design,
                 args=NULL,
                 trueDLE=myTruthDLE,
                 trueEff=myTruthEff,
                 trueNu=1/0.025,
                 nsim=2,
                 seed=819,
                 parallel=FALSE)
##Then produce a summary of your simulations
MYSUM &lt;- summary(mySim,
                 trueDLE=myTruthDLE,
                 trueEff=myTruthEff)
##Then show the summary in data frame for your simulations
show(MYSUM)




##If DLE and efficacy samples are involved
##The escalation rule using the 'NextBestMaxGainSamples' class
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})
##The design of 'DualResponsesSamplesDesign' class
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##options for MCMC
##for illustration purpose, we will use 50 burn-ins to generate 200 samples
options&lt;-McmcOptions(burnin=50,step=2,samples=200)
##The simulations for illustration purpose we only simulate 2 trials (nsim=2)
mySim&lt;-simulate(design,
                args=NULL,
                trueDLE=myTruthDLE,
                trueEff=myTruthEff,
                trueNu=1/0.025,
                nsim=2,
                mcmcOptions=options,
                seed=819,
                parallel=FALSE)


##Then produce a summary of your simulations
MYSUM &lt;- summary(mySim,
                 trueDLE=myTruthDLE,
                trueEff=myTruthEff)
##Then show the summary in data frame for your simulations
show(MYSUM)
</code></pre>

<hr>
<h2 id='show+2CPseudoSimulationsSummary-method'>Show the summary of the simulations</h2><span id='topic+show+2CPseudoSimulationsSummary-method'></span>

<h3>Description</h3>

<p>Show the summary of the simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoSimulationsSummary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CPseudoSimulationsSummary-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+PseudoSimulationsSummary-class">PseudoSimulationsSummary</a></code> object we want
to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns a data frame of the results with one row and
appropriate column names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##obtain the plot for the simulation results
##If only DLE responses are considered in the simulations
##Specified your simulations when no DLE samples are used
data &lt;- Data(doseGrid=seq(25,300,25))

##The design only incorporate DLE responses and DLE samples are involved
##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##Then the escalation rule
tdNextBest &lt;- NextBestTD(targetDuringTrial=0.35,
                         targetEndOfTrial=0.3)

##Then the starting data, an empty data set
emptydata&lt;-Data(doseGrid=seq(25,300,25))
## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=36)


##Specified the design(for details please refer to the 'TDDesign' example)
design &lt;- TDDesign(model=model,
                   nextBest=tdNextBest,
                   stopping=myStopping,
                   increments=myIncrements,
                   cohortSize=mySize,
                   data=data,startingDose=25)

##Specify the truth of the DLE responses
myTruth &lt;- function(dose)
{ model@prob(dose, phi1=-53.66584, phi2=10.50499)
}

##The simulations
##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim &lt;- simulate(design,
                  args=NULL,
                  truth=myTruth,
                  nsim=1,
                  seed=819,
                  parallel=FALSE)
##Then produce a summary of your simulations
MYSUM &lt;- summary(mySim,
                 truth=myTruth)
##show the summary of the simulated results in a data frame
show(MYSUM)



##If DLE samples are involved
##The escalation rule
tdNextBest&lt;-NextBestTDsamples(targetDuringTrial=0.35,
                              targetEndOfTrial=0.3,
                              derive=function(TDsamples){quantile(TDsamples,probs=0.3)})
##The design
design &lt;- TDsamplesDesign(model=model,
                          nextBest=tdNextBest,
                          stopping=myStopping,
                          increments=myIncrements,
                          cohortSize=mySize,
                          data=data,startingDose=25)
##Options for MCMC
##For illustration purpose, we will use 50 burn-ins to generate 200 samples and 
##only simulate for 2 trials (nsim=2)
options&lt;-McmcOptions(burnin=50,step=2,samples=200)
##The simualtions
mySim &lt;- simulate(design,
                  args=NULL,
                  truth=myTruth,
                  nsim=2,
                  seed=819,
                  mcmcOptions=options,
                  parallel=FALSE)
##Then produce a summary of your simulations
MYSUM &lt;- summary(mySim,
         truth=myTruth)
##show the summary of the simulated results in a data frame
show(MYSUM)
</code></pre>

<hr>
<h2 id='show+2CSimulationsSummary-method'>Show the summary of the simulations</h2><span id='topic+show+2CSimulationsSummary-method'></span>

<h3>Description</h3>

<p>Show the summary of the simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SimulationsSummary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSimulationsSummary-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+SimulationsSummary-class">SimulationsSummary</a></code> object we want
to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns a data frame of the results with one row and
appropriate column names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)
myStopping &lt;- (myStopping1 &amp; myStopping2) | myStopping3

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- Design(model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 data=emptydata,
                 startingDose=3)

## define the true function
myTruth &lt;- function(dose)
{
  model@prob(dose, alpha0=7, alpha1=8)
}

# Run the simulation on the desired design
# We only generate 1 trial outcome here for illustration, for the actual study 
# this should be increased of course
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=1000)
time &lt;- system.time(mySims &lt;- simulate(design,
                                       args=NULL,
                                       truth=myTruth,
                                       nsim=1,
                                       seed=819,
                                       mcmcOptions=options,
                                       parallel=FALSE))[3]

# Show the Summary of the Simulations
show(summary(mySims,truth=myTruth))


</code></pre>

<hr>
<h2 id='simulate+2CDesign-method'>Simulate outcomes from a CRM design</h2><span id='topic+simulate+2CDesign-method'></span>

<h3>Description</h3>

<p>Simulate outcomes from a CRM design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Design'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  truth,
  args = NULL,
  firstSeparate = FALSE,
  mcmcOptions = McmcOptions(),
  parallel = FALSE,
  nCores = min(parallel::detectCores(), 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CDesign-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+Design-class">Design</a></code> object we want to simulate
data from</p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations (default: 1)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_seed">seed</code></td>
<td>
<p>see <code><a href="#topic+setSeed">setSeed</a></code></p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_truth">truth</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the
true probability (vector) for toxicity. Additional arguments can be supplied
in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_args">args</code></td>
<td>
<p>data frame with arguments for the <code>truth</code> function. The
column names correspond to the argument names, the rows to the values of the
arguments. The rows are appropriately recycled in the <code>nsim</code>
simulations. In order to produce outcomes from the posterior predictive
distribution, e.g, pass an <code>object</code> that contains the data observed so
far, <code>truth</code> contains the <code>prob</code> function from the model in
<code>object</code>, and <code>args</code> contains posterior samples from the model.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_firstseparate">firstSeparate</code></td>
<td>
<p>enroll the first patient separately from the rest of
the cohort? (not default) If yes, the cohort will be closed if a DLT occurs
in this patient.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_mcmcoptions">mcmcOptions</code></td>
<td>
<p>object of class <code><a href="#topic+McmcOptions-class">McmcOptions</a></code>,
giving the MCMC options for each evaluation in the trial. By default,
the standard options are used</p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_parallel">parallel</code></td>
<td>
<p>should the simulation runs be parallelized across the
clusters of the computer? (not default)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_ncores">nCores</code></td>
<td>
<p>how many cores should be used for parallel computing?
Defaults to the number of cores on the machine, maximum 5.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDesign-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+Simulations-class">Simulations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)
myStopping &lt;- (myStopping1 &amp; myStopping2) | myStopping3

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- Design(model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 data=emptydata,
                 startingDose=3)

## define the true function
myTruth &lt;- function(dose)
{
  model@prob(dose, alpha0=7, alpha1=8)
}

# Run the simulation on the desired design
# We only generate 1 trial outcomes here for illustration, for the actual study 
# this should be increased of course
options &lt;- McmcOptions(burnin=100,
                       step=1,
                       samples=2000)
time &lt;- system.time(mySims &lt;- simulate(design,
                                       args=NULL,
                                       truth=myTruth,
                                       nsim=1,
                                       seed=819,
                                       mcmcOptions=options,
                                       parallel=FALSE))[3]
  
  
</code></pre>

<hr>
<h2 id='simulate+2CDualDesign-method'>Simulate outcomes from a dual-endpoint design</h2><span id='topic+simulate+2CDualDesign-method'></span>

<h3>Description</h3>

<p>Simulate outcomes from a dual-endpoint design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DualDesign'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  trueTox,
  trueBiomarker,
  args = NULL,
  sigma2W,
  rho = 0,
  firstSeparate = FALSE,
  mcmcOptions = McmcOptions(),
  parallel = FALSE,
  nCores = min(parallel::detectCores(), 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+DualDesign-class">DualDesign</a></code> object we want to simulate
data from</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations (default: 1)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_seed">seed</code></td>
<td>
<p>see <code><a href="#topic+setSeed">setSeed</a></code></p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_truetox">trueTox</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the
true probability (vector) for toxicity. Additional arguments can be supplied
in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_truebiomarker">trueBiomarker</code></td>
<td>
<p>a function which takes as input a dose (vector) and
returns the true biomarker level (vector). Additional arguments can be
supplied in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_args">args</code></td>
<td>
<p>data frame with arguments for the <code>trueTox</code> and
<code>trueBiomarker</code> function. The column names correspond to the argument
names, the rows to the values of the arguments. The rows are appropriately
recycled in the <code>nsim</code> simulations.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_sigma2w">sigma2W</code></td>
<td>
<p>variance for the biomarker measurements</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_rho">rho</code></td>
<td>
<p>correlation between toxicity and biomarker measurements (default:
0)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_firstseparate">firstSeparate</code></td>
<td>
<p>enroll the first patient separately from the rest of
the cohort? (not default) If yes, the cohort will be closed if a DLT occurs
in this patient.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_mcmcoptions">mcmcOptions</code></td>
<td>
<p>object of class <code><a href="#topic+McmcOptions-class">McmcOptions</a></code>,
giving the MCMC options for each evaluation in the trial. By default,
the standard options are used</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_parallel">parallel</code></td>
<td>
<p>should the simulation runs be parallelized across the
clusters of the computer? (not default)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_ncores">nCores</code></td>
<td>
<p>how many cores should be used for parallel computing?
Defaults to the number of cores on the machine, maximum 5.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualDesign-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+DualSimulations-class">DualSimulations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        useLogDose=TRUE,
                        refDose=2,
                        rho = c(a=1, b=1),
                        smooth="RW1")

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping4 &lt;- StoppingTargetBiomarker(target=c(0.9, 1),
                                       prob=0.5)
myStopping &lt;- myStopping4 | StoppingMinPatients(10)

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- DualDesign(model = model,
                     data = emptydata,
                     nextBest = myNextBest,
                     stopping = myStopping,
                     increments = myIncrements,
                     cohortSize = mySize,
                     startingDose = 3)
  
# define scenarios for the TRUE toxicity and efficacy profiles
betaMod &lt;- function (dose, e0, eMax, delta1, delta2, scal)
{
  maxDens &lt;- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))
  dose &lt;- dose/scal
  e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2
}

trueBiomarker &lt;- function(dose)
{
  betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100)
}

trueTox &lt;- function(dose)
{
  pnorm((dose-60)/10)
}

# Draw the TRUE profiles
par(mfrow=c(1, 2))
curve(trueTox(x), from=0, to=80)
curve(trueBiomarker(x), from=0, to=80)

# Run the simulation on the desired design
# We only generate 1 trial outcome here for illustration, for the actual study 
# this should be increased of course, similarly for the McmcOptions - 
# they also need to be increased.
mySims &lt;- simulate(design,
                   trueTox=trueTox,
                   trueBiomarker=trueBiomarker,
                   sigma2W=0.01,
                   rho=0,
                   nsim=1,
                   parallel=FALSE,
                   seed=3,
                   startingDose=6,
                   mcmcOptions =
                     McmcOptions(burnin=100,
                                 step=1,
                                 samples=300))
  
</code></pre>

<hr>
<h2 id='simulate+2CDualResponsesDesign-method'>This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.
This is a method based on the <code><a href="#topic+DualResponsesDesign-class">DualResponsesDesign</a></code> where DLEmodel used are of
<code><a href="#topic+ModelTox-class">ModelTox</a></code> class object and efficacy model used are of <code><a href="#topic+ModelEff-class">ModelEff</a></code>
class object. In addition, no DLE and efficacy samples are involved or generated in the simulation 
process</h2><span id='topic+simulate+2CDualResponsesDesign-method'></span>

<h3>Description</h3>

<p>This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.
This is a method based on the <code><a href="#topic+DualResponsesDesign-class">DualResponsesDesign</a></code> where DLEmodel used are of
<code><a href="#topic+ModelTox-class">ModelTox</a></code> class object and efficacy model used are of <code><a href="#topic+ModelEff-class">ModelEff</a></code>
class object. In addition, no DLE and efficacy samples are involved or generated in the simulation 
process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DualResponsesDesign'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  trueDLE,
  trueEff,
  trueNu,
  args = NULL,
  firstSeparate = FALSE,
  parallel = FALSE,
  nCores = min(parallel::detectCores(), 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+DualResponsesDesign-class">DualResponsesDesign</a></code> object we want to simulate the data from</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations (default :1)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_seed">seed</code></td>
<td>
<p>see <code><a href="#topic+setSeed">setSeed</a></code></p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_truedle">trueDLE</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the true probability 
(vector) of the occurrence of a DLE. Additional arguments can be supplied in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_trueeff">trueEff</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the expected efficacy
responses (vector). Additional arguments can be supplied in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_truenu">trueNu</code></td>
<td>
<p>the precision, the inverse of the variance of the efficacy responses</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_args">args</code></td>
<td>
<p>data frame with arguments for the <code>trueDLE</code> and
<code>trueEff</code> function. The column names correspond to the argument
names, the rows to the values of the arguments. The rows are appropriately
recycled in the <code>nsim</code> simulations.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_firstseparate">firstSeparate</code></td>
<td>
<p>enroll the first patient separately from the rest of
the cohort? (not default) If yes, the cohort will be closed if a DLT occurs
in this patient.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_parallel">parallel</code></td>
<td>
<p>should the simulation runs be parallelized across the
clusters of the computer? (not default)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_ncores">nCores</code></td>
<td>
<p>how many cores should be used for parallel computing?
Defaults to the number of cores on the machine, maximum 5.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesDesign-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate dose-escalation procedure based on DLE and efficacy responses where no DLE 
## and efficacy samples are used
## we need a data object with doses &gt;= 1:
data &lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

##The efficacy model of 'ModelEff' (e.g 'Effloglog') class 
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),
                    nu=c(a=1,b=0.025),data=data,c=0)

##The escalation rule using the 'NextBestMaxGain' class
mynextbest&lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,
                            DLEEndOfTrialtarget=0.3)


##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 36 subjects are treated
myStopping &lt;- StoppingMinPatients(nPatients=36)
##Now specified the design with all the above information and starting with a dose of 25

##Specified the design(for details please refer to the 'DualResponsesDesign' example)
design &lt;- DualResponsesDesign(nextBest=mynextbest,
                              model=DLEmodel,
                              Effmodel=Effmodel,
                              stopping=myStopping,
                              increments=myIncrements,
                              cohortSize=mySize,
                              data=data,startingDose=25)
##Specify the true DLE and efficacy curves
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- function(dose)
{Effmodel@ExpEff(dose,theta1=-4.818429,theta2=3.653058)
}

##The true gain curve can also be seen
myTruthGain &lt;- function(dose)
{return((myTruthEff(dose))/(1+(myTruthDLE(dose)/(1-myTruthDLE(dose)))))}


## Then specified the simulations and generate the trial 
##For illustration purpose only 1 simulation is produced (nsim=1). 
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
mySim &lt;-simulate(object=design,
                 args=NULL,
                 trueDLE=myTruthDLE,
                 trueEff=myTruthEff,
                 trueNu=1/0.025,
                 nsim=1,
                 seed=819,
                 parallel=FALSE)
</code></pre>

<hr>
<h2 id='simulate+2CDualResponsesSamplesDesign-method'>This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.
This is a method based on the <code><a href="#topic+DualResponsesSamplesDesign-class">DualResponsesSamplesDesign</a></code> where DLEmodel 
used are of
<code><a href="#topic+ModelTox-class">ModelTox</a></code> class object and efficacy model used are of 
<code><a href="#topic+ModelEff-class">ModelEff</a></code>
class object (special case is <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class model object). 
In addition, DLE and efficacy samples are involved or generated in the simulation 
process</h2><span id='topic+simulate+2CDualResponsesSamplesDesign-method'></span>

<h3>Description</h3>

<p>This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.
This is a method based on the <code><a href="#topic+DualResponsesSamplesDesign-class">DualResponsesSamplesDesign</a></code> where DLEmodel 
used are of
<code><a href="#topic+ModelTox-class">ModelTox</a></code> class object and efficacy model used are of 
<code><a href="#topic+ModelEff-class">ModelEff</a></code>
class object (special case is <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class model object). 
In addition, DLE and efficacy samples are involved or generated in the simulation 
process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DualResponsesSamplesDesign'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  trueDLE,
  trueEff,
  trueNu = NULL,
  trueSigma2 = NULL,
  trueSigma2betaW = NULL,
  args = NULL,
  firstSeparate = FALSE,
  mcmcOptions = McmcOptions(),
  parallel = FALSE,
  nCores = min(parallel::detectCores(), 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+DualResponsesSamplesDesign-class">DualResponsesSamplesDesign</a></code> object we want to 
simulate the data from</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations (default :1)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_seed">seed</code></td>
<td>
<p>see <code><a href="#topic+setSeed">setSeed</a></code></p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_truedle">trueDLE</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the true probability
(vector) of the occurrence of a DLE. Additional arguments can be supplied in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_trueeff">trueEff</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the expected 
efficacy responses (vector). Additional arguments can be supplied in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_truenu">trueNu</code></td>
<td>
<p>(not with <code><a href="#topic+EffFlexi-class">EffFlexi</a></code>) the precision, the inverse of the 
variance of the efficacy responses</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_truesigma2">trueSigma2</code></td>
<td>
<p>(only with <code><a href="#topic+EffFlexi-class">EffFlexi</a></code>) the true variance of the efficacy 
responses which must be a single positive scalar.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_truesigma2betaw">trueSigma2betaW</code></td>
<td>
<p>(only with <code><a href="#topic+EffFlexi-class">EffFlexi</a></code>) the true variance for the 
random walk model used for smoothing. This must be a single postive scalar.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_args">args</code></td>
<td>
<p>data frame with arguments for the <code>trueDLE</code> and
<code>trueEff</code> function. The column names correspond to the argument
names, the rows to the values of the arguments. The rows are appropriately
recycled in the <code>nsim</code> simulations.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_firstseparate">firstSeparate</code></td>
<td>
<p>enroll the first patient separately from the rest of
the cohort? (not default) If yes, the cohort will be closed if a DLT occurs
in this patient.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_mcmcoptions">mcmcOptions</code></td>
<td>
<p>object of class <code><a href="#topic+McmcOptions-class">McmcOptions</a></code>,
giving the MCMC options for each evaluation in the trial. By default,
the standard options are used</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_parallel">parallel</code></td>
<td>
<p>should the simulation runs be parallelized across the
clusters of the computer? (not default)</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_ncores">nCores</code></td>
<td>
<p>how many cores should be used for parallel computing?
Defaults to the number of cores on the machine, maximum 5.</p>
</td></tr>
<tr><td><code id="simulate+2B2CDualResponsesSamplesDesign-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> or
<code><a href="#topic+PseudoDualFlexiSimulations-class">PseudoDualFlexiSimulations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate dose-escalation procedure based on DLE and efficacy responses where DLE 
## and efficacy samples are used

data &lt;- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

##The efficacy model of 'ModelEff' (e.g 'Effloglog') class 
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),
                    nu=c(a=1,b=0.025),data=data,c=0)


##The escalation rule using the 'NextBestMaxGainSamples' class
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})


##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 10 subjects are treated (only for illustration such a low 
##sample size)
myStopping &lt;- StoppingMinPatients(nPatients=10)
##Now specified the design with all the above information and starting with 
##a dose of 25


##Specified the design 
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##specified the true DLE and efficacy curve
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}


myTruthEff&lt;- function(dose)
{Effmodel@ExpEff(dose,theta1=-4.818429,theta2=3.653058)
}
##The true gain curve can also be seen
myTruthGain &lt;- function(dose)
{return((myTruthEff(dose))/(1+(myTruthDLE(dose)/(1-myTruthDLE(dose)))))}

##simulate the trial for 10 times involving samples
##for illustration purpose we use 10 burn-ins to generate 50 samples
options&lt;-McmcOptions(burnin=10,step=1,samples=50)
##For illustration purpose only 1 simulations are produced (nsim=1). 
mySim&lt;-simulate(design,
                 args=NULL,
                 trueDLE=myTruthDLE,
                 trueEff=myTruthEff,
                 trueNu=1/0.025,
                 nsim=1,
                 mcmcOptions=options,
                 seed=819,
                 parallel=FALSE)



##Simulate dose-escalation procedure based on DLE and efficacy responses where DLE 
## and efficacy samples are used
## when the efficacy model is of 'EffFlexi' class
Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)


##Specified the design 
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##specified the true DLE curve and the true expected efficacy values at all dose levels
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- c(-0.5478867, 0.1645417,  0.5248031,  0.7604467,  
               0.9333009  ,1.0687031,  1.1793942 , 1.2726408 , 
               1.3529598 , 1.4233411 , 1.4858613 , 1.5420182)
##The true gain curve can also be seen
d1 &lt;- data@doseGrid
myTruthGain &lt;- (myTruthEff)/(1+(myTruthDLE(d1)/(1-myTruthDLE(d1))))


mySim&lt;-simulate(object=design,
                args=NULL,
                trueDLE=myTruthDLE,
                trueEff=myTruthEff,
                trueSigma2=0.025,
                trueSigma2betaW=1,
                mcmcOptions=options,
                nsim=1,
                seed=819,
                parallel=FALSE)


</code></pre>

<hr>
<h2 id='simulate+2CRuleDesign-method'>Simulate outcomes from a rule-based design</h2><span id='topic+simulate+2CRuleDesign-method'></span>

<h3>Description</h3>

<p>Simulate outcomes from a rule-based design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RuleDesign'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  truth,
  args = NULL,
  parallel = FALSE,
  nCores = min(parallel::detectCores(), 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CRuleDesign-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+RuleDesign-class">RuleDesign</a></code> object we want to simulate
data from</p>
</td></tr>
<tr><td><code id="simulate+2B2CRuleDesign-method_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations (default: 1)</p>
</td></tr>
<tr><td><code id="simulate+2B2CRuleDesign-method_+3A_seed">seed</code></td>
<td>
<p>see <code><a href="#topic+setSeed">setSeed</a></code></p>
</td></tr>
<tr><td><code id="simulate+2B2CRuleDesign-method_+3A_truth">truth</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the
true probability (vector) for toxicity. Additional arguments can be supplied
in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CRuleDesign-method_+3A_args">args</code></td>
<td>
<p>data frame with arguments for the <code>truth</code> function. The
column names correspond to the argument names, the rows to the values of the
arguments. The rows are appropriately recycled in the <code>nsim</code>
simulations.</p>
</td></tr>
<tr><td><code id="simulate+2B2CRuleDesign-method_+3A_parallel">parallel</code></td>
<td>
<p>should the simulation runs be parallelized across the
clusters of the computer? (not default)</p>
</td></tr>
<tr><td><code id="simulate+2B2CRuleDesign-method_+3A_ncores">nCores</code></td>
<td>
<p>how many cores should be used for parallel computing?
Defaults to the number of cores on the machine, maximum 5.</p>
</td></tr>
<tr><td><code id="simulate+2B2CRuleDesign-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))

# inizialing a 3+3 design with constant cohort size of 3 and
# starting dose equal 5
myDesign &lt;- RuleDesign(nextBest = NextBestThreePlusThree(),
                       cohortSize = CohortSizeConst(size=3L),
                       data = emptydata,
                       startingDose = 5)

model &lt;- LogisticLogNormal(mean = c(-0.85, 1),
                           cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
                           refDose = 50)
  
## define the true function
myTruth &lt;- function(dose)
{
  model@prob(dose, alpha0=7, alpha1=8)
}

# Perform the simulation
##For illustration purpose only 10 simulation is produced (nsim=10). 
threeSims &lt;- simulate(myDesign,
                      nsim=10,
                      seed=35,
                      truth=myTruth,
                      parallel=FALSE)
</code></pre>

<hr>
<h2 id='simulate+2CTDDesign-method'>This is a methods to simulate dose escalation procedure only using the DLE responses.
This is a method based on the <code><a href="#topic+TDDesign-class">TDDesign</a></code> where model used are of
<code><a href="#topic+ModelTox-class">ModelTox</a></code> class object and no samples are involved.</h2><span id='topic+simulate+2CTDDesign-method'></span>

<h3>Description</h3>

<p>This is a methods to simulate dose escalation procedure only using the DLE responses.
This is a method based on the <code><a href="#topic+TDDesign-class">TDDesign</a></code> where model used are of
<code><a href="#topic+ModelTox-class">ModelTox</a></code> class object and no samples are involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TDDesign'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  truth,
  args = NULL,
  firstSeparate = FALSE,
  parallel = FALSE,
  nCores = min(parallel::detectCores(), 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+TDDesign-class">TDDesign</a></code> object we want to simulate the data from</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations (default :1)</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_seed">seed</code></td>
<td>
<p>see <code><a href="#topic+setSeed">setSeed</a></code></p>
</td></tr>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_truth">truth</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the true probability 
(vector) of the occurrence of a DLE. Additional arguments can be supplied in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_args">args</code></td>
<td>
<p>data frame with arguments for the <code>truth</code> function. The
column names correspond to the argument names, the rows to the values of the
arguments. The rows are appropriately recycled in the <code>nsim</code>
simulations. In order to produce outcomes from the posterior predictive
distribution, e.g, pass an <code>object</code> that contains the data observed so
far, <code>truth</code> contains the <code>prob</code> function from the model in
<code>object</code>, and <code>args</code> contains posterior samples from the model.</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_firstseparate">firstSeparate</code></td>
<td>
<p>enroll the first patient separately from the rest of
the cohort? (not default) If yes, the cohort will be closed if a DLT occurs
in this patient.</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_parallel">parallel</code></td>
<td>
<p>should the simulation runs be parallelized across the
clusters of the computer? (not default)</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_ncores">nCores</code></td>
<td>
<p>how many cores should be used for parallel computing?
Defaults to the number of cores on the machine, maximum 5.</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDDesign-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code>
</p>
<p>@export
@keywords methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate dose-escalation procedure based only on DLE responses and no DLE samples are used

##The design comprises a model, the escalation rule, starting data, 
##a cohort size and a starting dose
##Define your data set first using an empty data set 
## with dose levels from 25 to 300 with increments 25
data &lt;- Data(doseGrid=seq(25,300,25))

##The design only incorporate DLE responses and DLE samples are involved
##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##Then the escalation rule
tdNextBest &lt;- NextBestTD(targetDuringTrial=0.35,
                         targetEndOfTrial=0.3)
doseRecommendation&lt;-nextBest(tdNextBest,
                             doselimit=max(data@doseGrid),
                             model=model,
                             data=data)
##Then the starting data, an empty data set
emptydata&lt;-Data(doseGrid=seq(25,300,25))
## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=36)


##Specified the design(for details please refer to the 'TDDesign' example)
design &lt;- TDDesign(model=model,
                   nextBest=tdNextBest,
                   stopping=myStopping,
                   increments=myIncrements,
                   cohortSize=mySize,
                   data=data,startingDose=25)

##Specify the truth of the DLE responses
myTruth &lt;- function(dose)
{ model@prob(dose, phi1=-53.66584, phi2=10.50499)
}
##then plot the truth to see how the truth dose-DLE curve look like
curve(myTruth(x), from=0, to=300,ylim=c(0,1))


##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim &lt;- simulate(object=design,
                  args=NULL,
                  truth=myTruth,
                  nsim=1,
                  seed=819,
                  parallel=FALSE)
</code></pre>

<hr>
<h2 id='simulate+2CTDsamplesDesign-method'>This is a methods to simulate dose escalation procedure only using the DLE responses.
This is a method based on the <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code> where model used are of
<code><a href="#topic+ModelTox-class">ModelTox</a></code> class object DLE samples are also used</h2><span id='topic+simulate+2CTDsamplesDesign-method'></span>

<h3>Description</h3>

<p>This is a methods to simulate dose escalation procedure only using the DLE responses.
This is a method based on the <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code> where model used are of
<code><a href="#topic+ModelTox-class">ModelTox</a></code> class object DLE samples are also used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TDsamplesDesign'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  truth,
  args = NULL,
  firstSeparate = FALSE,
  mcmcOptions = McmcOptions(),
  parallel = FALSE,
  nCores = min(parallel::detectCores(), 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code> object we want to simulate the data from</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations (default :1)</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_seed">seed</code></td>
<td>
<p>see <code><a href="#topic+setSeed">setSeed</a></code></p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_truth">truth</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the true probability 
(vector) of the occurrence of a DLE. Additional arguments can be supplied in <code>args</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_args">args</code></td>
<td>
<p>data frame with arguments for the <code>truth</code> function. The
column names correspond to the argument names, the rows to the values of the
arguments. The rows are appropriately recycled in the <code>nsim</code>
simulations. In order to produce outcomes from the posterior predictive
distribution, e.g, pass an <code>object</code> that contains the data observed so
far, <code>truth</code> contains the <code>prob</code> function from the model in
<code>object</code>, and <code>args</code> contains posterior samples from the model.</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_firstseparate">firstSeparate</code></td>
<td>
<p>enroll the first patient separately from the rest of
the cohort? (not default) If yes, the cohort will be closed if a DLT occurs
in this patient.</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_mcmcoptions">mcmcOptions</code></td>
<td>
<p>object of class <code><a href="#topic+McmcOptions-class">McmcOptions</a></code>,
giving the MCMC options for each evaluation in the trial. By default,
the standard options are used</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_parallel">parallel</code></td>
<td>
<p>should the simulation runs be parallelized across the
clusters of the computer? (not default)</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_ncores">nCores</code></td>
<td>
<p>how many cores should be used for parallel computing?
Defaults to the number of cores on the machine, maximum 5.</p>
</td></tr>
<tr><td><code id="simulate+2B2CTDsamplesDesign-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code>
</p>
<p>@export
@keywords methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate dose-escalation procedure based only on DLE responses with DLE samples involved

##The design comprises a model, the escalation rule, starting data, 
##a cohort size and a starting dose
##Define your data set first using an empty data set 
## with dose levels from 25 to 300 with increments 25
data &lt;- Data(doseGrid=seq(25,300,25))

##The design only incorporate DLE responses and DLE samples are involved
##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##Then the escalation rule
tdNextBest&lt;-NextBestTDsamples(targetDuringTrial=0.35,
                              targetEndOfTrial=0.3,
                              derive=function(TDsamples){quantile(TDsamples,probs=0.3)})


## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=36)

##Specified the design(for details please refer to the 'TDsamplesDesign' example)
design &lt;- TDsamplesDesign(model=model,
                          nextBest=tdNextBest,
                          stopping=myStopping,
                          increments=myIncrements,
                          cohortSize=mySize,
                          data=data,startingDose=25)

##Specify the truth of the DLE responses
myTruth &lt;- function(dose)
{ model@prob(dose, phi1=-53.66584, phi2=10.50499)
}
##then plot the truth to see how the truth dose-DLE curve look like
curve(myTruth(x), from=0, to=300,ylim=c(0,1))

## Then specified the simulations and generate the trial
##options for MCMC
options&lt;-McmcOptions(burnin=100,step=2,samples=200)
##The simulations
##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim &lt;-  simulate(object=design,
                   args=NULL,
                   truth=myTruth,
                   nsim=1,
                   seed=819,
                   mcmcOptions=options,
                   parallel=FALSE)
</code></pre>

<hr>
<h2 id='Simulations'>Initialization function for the &quot;Simulations&quot; class</h2><span id='topic+Simulations'></span>

<h3>Description</h3>

<p>Initialization function for the &quot;Simulations&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Simulations(fit, stopReasons, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulations_+3A_fit">fit</code></td>
<td>
<p>see <code><a href="#topic+Simulations-class">Simulations</a></code></p>
</td></tr>
<tr><td><code id="Simulations_+3A_stopreasons">stopReasons</code></td>
<td>
<p>see <code><a href="#topic+Simulations-class">Simulations</a></code></p>
</td></tr>
<tr><td><code id="Simulations_+3A_...">...</code></td>
<td>
<p>additional parameters from <code><a href="#topic+GeneralSimulations">GeneralSimulations</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+Simulations-class">Simulations</a></code> object
</p>

<hr>
<h2 id='Simulations-class'>Class for the simulations output from model based designs</h2><span id='topic+Simulations-class'></span><span id='topic+.Simulations'></span>

<h3>Description</h3>

<p>This class captures the trial simulations from model based designs.
Additional slots fit and stopReasons compared to the general class
<code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fit</code></dt><dd><p>list with the final fits</p>
</dd>
<dt><code>stopReasons</code></dt><dd><p>list of stopping reasons for each simulation run</p>
</dd>
</dl>

<hr>
<h2 id='SimulationsSummary-class'>Class for the summary of model-based simulations output</h2><span id='topic+SimulationsSummary-class'></span><span id='topic+.SimulationsSummary'></span>

<h3>Description</h3>

<p>In addition to the slots in the parent class
<code><a href="#topic+GeneralSimulationsSummary-class">GeneralSimulationsSummary</a></code>, it contains two slots with
model fit information.
</p>


<h3>Details</h3>

<p>Note that objects should not be created by users, therefore no
initialization function is provided for this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fitAtDoseMostSelected</code></dt><dd><p>fitted toxicity rate at dose most often selected</p>
</dd>
<dt><code>meanFit</code></dt><dd><p>list with the average, lower (2.5
quantiles of the mean fitted toxicity at each dose level</p>
</dd>
</dl>

<hr>
<h2 id='size'>Determine the size of the next cohort</h2><span id='topic+size'></span><span id='topic+size+2CCohortSizeRange+2CANY+2CData-method'></span><span id='topic+size+2CCohortSizeDLT+2CANY+2CData-method'></span><span id='topic+size+2CCohortSizeMax+2CANY+2CData-method'></span><span id='topic+size+2CCohortSizeMin+2CANY+2CData-method'></span><span id='topic+size+2CCohortSizeConst+2CANY+2CData-method'></span><span id='topic+size+2CCohortSizeParts+2CANY+2CDataParts-method'></span>

<h3>Description</h3>

<p>This function determines the size of the next cohort.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(cohortSize, dose, data, ...)

## S4 method for signature 'CohortSizeRange,ANY,Data'
size(cohortSize, dose, data, ...)

## S4 method for signature 'CohortSizeDLT,ANY,Data'
size(cohortSize, dose, data, ...)

## S4 method for signature 'CohortSizeMax,ANY,Data'
size(cohortSize, dose, data, ...)

## S4 method for signature 'CohortSizeMin,ANY,Data'
size(cohortSize, dose, data, ...)

## S4 method for signature 'CohortSizeConst,ANY,Data'
size(cohortSize, dose, data, ...)

## S4 method for signature 'CohortSizeParts,ANY,DataParts'
size(cohortSize, dose, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_cohortsize">cohortSize</code></td>
<td>
<p>The rule, an object of class
<code><a href="#topic+CohortSize-class">CohortSize</a></code></p>
</td></tr>
<tr><td><code id="size_+3A_dose">dose</code></td>
<td>
<p>the next dose</p>
</td></tr>
<tr><td><code id="size_+3A_data">data</code></td>
<td>
<p>The data input, an object of class <code><a href="#topic+Data-class">Data</a></code></p>
</td></tr>
<tr><td><code id="size_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the size as integer value
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>size(cohortSize = CohortSizeRange, dose = ANY, data = Data)</code>: Determine the cohort size based on the range into which the
next dose falls into
</p>
</li>
<li> <p><code>size(cohortSize = CohortSizeDLT, dose = ANY, data = Data)</code>: Determine the cohort size based on the number of DLTs so
far
</p>
</li>
<li> <p><code>size(cohortSize = CohortSizeMax, dose = ANY, data = Data)</code>: Size based on maximum of multiple cohort size rules
</p>
</li>
<li> <p><code>size(cohortSize = CohortSizeMin, dose = ANY, data = Data)</code>: Size based on minimum of multiple cohort size rules
</p>
</li>
<li> <p><code>size(cohortSize = CohortSizeConst, dose = ANY, data = Data)</code>: Constant cohort size
</p>
</li>
<li> <p><code>size(cohortSize = CohortSizeParts, dose = ANY, data = DataParts)</code>: Cohort size based on the parts
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Rule for the cohort size: 
#   - having cohort of size 1 for doses &lt;10
#   - and having cohort of size 3 for doses &gt;=10
mySize &lt;- CohortSizeRange(intervals=c(0, 10),
                          cohortSize=c(1, 3))

# Determine the cohort size for the next cohort
size(mySize, dose=doseRecommendation$value, data = data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Rule for the cohort size: 
#   - having cohort of size 1 if no DLTs were yet observed
#   - and having cohort of size 3 if at least 1 DLT was already observed
mySize &lt;- CohortSizeDLT(DLTintervals = c(0, 1),
                        cohortSize = c(1, 3))

# Determine the cohort size for the next cohort
size(mySize, dose=doseRecommendation$value, data = data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Rule for having cohort of size 1 for doses &lt;30
#      and having cohort of size 3 for doses &gt;=30
mySize1 &lt;- CohortSizeRange(intervals = c(0, 10),
                           cohortSize = c(1, 3))

# Rule for having cohort of size 1 until no DLT were observed
#      and having cohort of size 3 as soon as 1 DLT is observed
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))

# Combining the two rules for cohort size by taking the maximum of the sample sizes
# of the single rules
mySize &lt;- maxSize(mySize1, mySize2)

# Determine the cohort size for the next cohort
size(mySize, dose=doseRecommendation$value, data = data)




# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Rule for having cohort of size 1 for doses &lt;30
#      and having cohort of size 3 for doses &gt;=30
mySize1 &lt;- CohortSizeRange(intervals = c(0, 30),
                           cohortSize = c(1, 3))

# Rule for having cohort of size 1 until no DLT were observed
#      and having cohort of size 3 as soon as 1 DLT is observed
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))

# Combining the two rules for cohort size by taking the minimum of the sample sizes
# of the single rules
mySize &lt;- minSize(mySize1, mySize2)

# Determine the cohort size for the next cohort
size(mySize, dose=doseRecommendation$value, data = data)




# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Rule for having cohorts with constant cohort size of 3
mySize &lt;- CohortSizeConst(size=3)

# Determine the cohort size for the next cohort
size(mySize, dose=doseRecommendation$value, data = data)




# create an object of class 'DataParts'
data &lt;- DataParts(x=c(0.1,0.5,1.5),
                  y=c(0,0,0),
                  doseGrid=c(0.1,0.5,1.5,3,6,
                             seq(from=10,to=80,by=2)),
                  part=c(1L,1L,1L),
                  nextPart=1L,
                  part1Ladder=c(0.1,0.5,1.5,3,6,10))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

myIncrements &lt;- IncrementsRelativeParts(dltStart=0,
                                        cleanStart=1)
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, 
                               model=model, 
                               data=data)

# Rule for the cohort size: 
mySize &lt;- CohortSizeParts(sizes=c(1,3))

# Determine the cohort size for the next cohort
size(mySize, dose=doseRecommendation$value, data = data)

</code></pre>

<hr>
<h2 id='Stopping-class'>The virtual class for stopping rules</h2><span id='topic+Stopping-class'></span>

<h3>Description</h3>

<p>The virtual class for stopping rules
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StoppingList-class">StoppingList</a></code>,
<code><a href="#topic+StoppingCohortsNearDose-class">StoppingCohortsNearDose</a></code>,
<code><a href="#topic+StoppingPatientsNearDose-class">StoppingPatientsNearDose</a></code>,
<code><a href="#topic+StoppingMinCohorts-class">StoppingMinCohorts</a></code>,
<code><a href="#topic+StoppingMinPatients-class">StoppingMinPatients</a></code>,
<code><a href="#topic+StoppingTargetProb-class">StoppingTargetProb</a></code>
<code><a href="#topic+StoppingMTDdistribution-class">StoppingMTDdistribution</a></code>,
<code><a href="#topic+StoppingTargetBiomarker-class">StoppingTargetBiomarker</a></code>,
<code><a href="#topic+StoppingHighestDose-class">StoppingHighestDose</a></code>
</p>

<hr>
<h2 id='StoppingAll'>Initialization function for &quot;StoppingAll&quot;</h2><span id='topic+StoppingAll'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingAll&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingAll(stopList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingAll_+3A_stoplist">stopList</code></td>
<td>
<p>see <code><a href="#topic+StoppingAll-class">StoppingAll</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingAll-class">StoppingAll</a></code> object
</p>

<hr>
<h2 id='StoppingAll-class'>Stop based on fullfillment of all multiple stopping rules</h2><span id='topic+StoppingAll-class'></span><span id='topic+.StoppingAll'></span>

<h3>Description</h3>

<p>This class can be used to combine multiple stopping rules with an AND
operator.
</p>


<h3>Details</h3>

<p><code>stopList</code> contains all stopping rules, which are again objects of
class <code><a href="#topic+Stopping-class">Stopping</a></code>. All stopping rules must be fulfilled in
order that the result of this rule is to stop.
</p>


<h3>Slots</h3>


<dl>
<dt><code>stopList</code></dt><dd><p>list of stopping rules</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define some stopping rules
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)

# Create a list of stopping rules (of class 'StoppingAll') which would then be
# summarized by the 'all' function, meaning that the study would be stopped only if
# 'all' the single stopping rules are TRUE
mystopping &lt;- StoppingAll(stopList=c(myStopping1,myStopping2,myStopping3))


</code></pre>

<hr>
<h2 id='StoppingAny'>Initialization function for &quot;StoppingAny&quot;</h2><span id='topic+StoppingAny'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingAny&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingAny(stopList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingAny_+3A_stoplist">stopList</code></td>
<td>
<p>see <code><a href="#topic+StoppingAny-class">StoppingAny</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingAny-class">StoppingAny</a></code> object
</p>

<hr>
<h2 id='StoppingAny-class'>Stop based on fullfillment of any stopping rule</h2><span id='topic+StoppingAny-class'></span><span id='topic+.StoppingAny'></span>

<h3>Description</h3>

<p>This class can be used to combine multiple stopping rules with an OR
operator.
</p>


<h3>Details</h3>

<p><code>stopList</code> contains all stopping rules, which are again objects of
class <code><a href="#topic+Stopping-class">Stopping</a></code>. Any of these rules must be fulfilled in
order that the result of this rule is to stop.
</p>


<h3>Slots</h3>


<dl>
<dt><code>stopList</code></dt><dd><p>list of stopping rules</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define some stopping rules
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)

# Create a list of stopping rules (of class 'StoppingAny') which will then be
# summarized with the 'any' function, meaning that the study would be stopped if
# 'any' of the single stopping rules is TRUE.
mystopping &lt;- StoppingAny(stopList=c(myStopping1,myStopping2,myStopping3))


</code></pre>

<hr>
<h2 id='StoppingCohortsNearDose'>Initialization function for &quot;StoppingCohortsNearDose&quot;</h2><span id='topic+StoppingCohortsNearDose'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingCohortsNearDose&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingCohortsNearDose(nCohorts, percentage)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingCohortsNearDose_+3A_ncohorts">nCohorts</code></td>
<td>
<p>see <code><a href="#topic+StoppingCohortsNearDose-class">StoppingCohortsNearDose</a></code></p>
</td></tr>
<tr><td><code id="StoppingCohortsNearDose_+3A_percentage">percentage</code></td>
<td>
<p>see <code><a href="#topic+StoppingCohortsNearDose-class">StoppingCohortsNearDose</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingCohortsNearDose-class">StoppingCohortsNearDose</a></code> object
</p>

<hr>
<h2 id='StoppingCohortsNearDose-class'>Stop based on number of cohorts near to next best dose</h2><span id='topic+StoppingCohortsNearDose-class'></span><span id='topic+.StoppingCohortsNearDose'></span>

<h3>Description</h3>

<p>Stop based on number of cohorts near to next best dose
</p>


<h3>Slots</h3>


<dl>
<dt><code>nCohorts</code></dt><dd><p>number of required cohorts</p>
</dd>
<dt><code>percentage</code></dt><dd><p>percentage (between 0 and 100) within the next best dose
the cohorts must lie</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#   stopping the study if at least 3 cohorts were dosed at a dose within (1 +/- 0.2) 
#   of the next best dose

myStopping &lt;- StoppingCohortsNearDose(nCohorts = 3,
                                      percentage = 0.2)

</code></pre>

<hr>
<h2 id='StoppingGstarCIRatio'>Initialization function for &quot;StoppingGstarCIRatio&quot;</h2><span id='topic+StoppingGstarCIRatio'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingGstarCIRatio&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingGstarCIRatio(targetRatio, targetEndOfTrial)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingGstarCIRatio_+3A_targetratio">targetRatio</code></td>
<td>
<p>please refer to <code><a href="#topic+StoppingGstarCIRatio-class">StoppingGstarCIRatio</a></code> class object</p>
</td></tr>
<tr><td><code id="StoppingGstarCIRatio_+3A_targetendoftrial">targetEndOfTrial</code></td>
<td>
<p>please refer to <code><a href="#topic+StoppingGstarCIRatio-class">StoppingGstarCIRatio</a></code> class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingGstarCIRatio-class">StoppingGstarCIRatio</a></code> class object
</p>

<hr>
<h2 id='StoppingGstarCIRatio-class'>Stop based on a target ratio, the ratio of the upper to the lower
95% credibility interval of the estimate of the minimum of the dose which gives the maximum gain (Gstar) and 
the TD end of trial, the dose with probability of DLE equals to the target 
probability of DLE used at the end of a trial.</h2><span id='topic+StoppingGstarCIRatio-class'></span><span id='topic+.StoppingGstarCIRatio'></span>

<h3>Description</h3>

<p>Stop based on a target ratio, the ratio of the upper to the lower
95% credibility interval of the estimate of the minimum of the dose which gives the maximum gain (Gstar) and 
the TD end of trial, the dose with probability of DLE equals to the target 
probability of DLE used at the end of a trial.
</p>


<h3>Slots</h3>


<dl>
<dt><code>targetRatio</code></dt><dd><p>the target ratio of the upper to the lower of the 95% credibility interval of the 
estimate that required to stop a trial</p>
</dd>
<dt><code>targetEndOfTrial</code></dt><dd><p>the target probability of DLE to be used at the end of a trial</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the target stopping ratio of 5 and 
##the target probability of DLE to be used at the end of a trial
##This is a ratio of the upper to the lower 95% credibility interval of the estimates
myStopping &lt;- StoppingGstarCIRatio(targetRatio=5,
                                   targetEndOfTrial=0.3)
</code></pre>

<hr>
<h2 id='StoppingHighestDose'>Initialization function for &quot;StoppingHighestDose&quot;</h2><span id='topic+StoppingHighestDose'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingHighestDose&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingHighestDose()
</code></pre>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingHighestDose-class">StoppingHighestDose</a></code> object
</p>

<hr>
<h2 id='StoppingHighestDose-class'>Stop when the highest dose is reached</h2><span id='topic+StoppingHighestDose-class'></span><span id='topic+.StoppingHighestDose'></span>

<h3>Description</h3>

<p>Stop when the highest dose is reached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for example this can be used in the following way:
## we would like to stop if:
## - next proposed dose is highest dose
## - there are already at least 3 patients on that dose
## - we are sure that this dose is safe, e.g. the
## probability to be in the interval (0%, 20%) of DLT
## rate is above 50%.
## This would be implemented as the following combination:

stopHigh &lt;-
  StoppingHighestDose() &amp;
  StoppingPatientsNearDose(nPatients=3, percentage=0) &amp;
  StoppingTargetProb(target=c(0, 0.2),
                     prob=0.5)

## of course this rule would then need to be combined
## with the other standard rules for when to stop
## when the MTD is found based on being near
## e.g. a 30% DLT probability or having reached maximal sample
## size, in the manner of:
## stopRule &lt;- stopHigh | stopLow | stopSamplesize
</code></pre>

<hr>
<h2 id='StoppingList'>Initialization function for &quot;StoppingList&quot;</h2><span id='topic+StoppingList'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingList&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingList(stopList, summary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingList_+3A_stoplist">stopList</code></td>
<td>
<p>see <code><a href="#topic+StoppingList-class">StoppingList</a></code></p>
</td></tr>
<tr><td><code id="StoppingList_+3A_summary">summary</code></td>
<td>
<p>see <code><a href="#topic+StoppingList-class">StoppingList</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingList-class">StoppingList</a></code> object
</p>

<hr>
<h2 id='StoppingList-class'>Stop based on multiple stopping rules</h2><span id='topic+StoppingList-class'></span><span id='topic+.StoppingList'></span>

<h3>Description</h3>

<p>This class can be used to combine multiple stopping rules.
</p>


<h3>Details</h3>

<p><code>stopList</code> contains all stopping rules, which are again objects of
class <code><a href="#topic+Stopping-class">Stopping</a></code>, and the <code>summary</code> is a function
taking a logical vector of the size of <code>stopList</code> and returning a
single logical value. For example, if the function <code>all</code> is given as
<code>summary</code> function, then this means that all stopping rules must be
fulfilled in order that the result of this rule is to stop.
</p>


<h3>Slots</h3>


<dl>
<dt><code>stopList</code></dt><dd><p>list of stopping rules</p>
</dd>
<dt><code>summary</code></dt><dd><p>the summary function to combine the results of the stopping
rules into a single result</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define some stopping rules
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)

# Create a list of stopping rules (of class 'StoppingList') which will then be
# summarized (in this specific example) with the 'any' function, meaning that the study 
# would be stopped if 'any' of the single stopping rules is TRUE.
mystopping &lt;- StoppingList(stopList=c(myStopping1,myStopping2,myStopping3),
                           summary=any)


</code></pre>

<hr>
<h2 id='StoppingMinCohorts'>Initialization function for &quot;StoppingMinCohorts&quot;</h2><span id='topic+StoppingMinCohorts'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingMinCohorts&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingMinCohorts(nCohorts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingMinCohorts_+3A_ncohorts">nCohorts</code></td>
<td>
<p>see <code><a href="#topic+StoppingMinCohorts-class">StoppingMinCohorts</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingMinCohorts-class">StoppingMinCohorts</a></code> object
</p>

<hr>
<h2 id='StoppingMinCohorts-class'>Stop based on minimum number of cohorts</h2><span id='topic+StoppingMinCohorts-class'></span><span id='topic+.StoppingMinCohorts'></span>

<h3>Description</h3>

<p>Stop based on minimum number of cohorts
</p>


<h3>Slots</h3>


<dl>
<dt><code>nCohorts</code></dt><dd><p>minimum required number of cohorts</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#   stopping the study if at least 6 cohorts were already dosed

myStopping &lt;- StoppingMinCohorts(nCohorts = 6)

</code></pre>

<hr>
<h2 id='StoppingMinPatients'>Initialization function for &quot;StoppingMinPatients&quot;</h2><span id='topic+StoppingMinPatients'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingMinPatients&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingMinPatients(nPatients)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingMinPatients_+3A_npatients">nPatients</code></td>
<td>
<p>see <code><a href="#topic+StoppingMinPatients-class">StoppingMinPatients</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingMinPatients-class">StoppingMinPatients</a></code> object
</p>

<hr>
<h2 id='StoppingMinPatients-class'>Stop based on minimum number of patients</h2><span id='topic+StoppingMinPatients-class'></span><span id='topic+.StoppingMinPatients'></span>

<h3>Description</h3>

<p>Stop based on minimum number of patients
</p>


<h3>Slots</h3>


<dl>
<dt><code>nPatients</code></dt><dd><p>minimum allowed number of patients</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#   stopping the study if at least 20 patients were already dosed

myStopping &lt;- StoppingMinPatients(nPatients = 20)

</code></pre>

<hr>
<h2 id='StoppingMTDdistribution'>Initialization function for &quot;StoppingMTDdistribution&quot;</h2><span id='topic+StoppingMTDdistribution'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingMTDdistribution&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingMTDdistribution(target, thresh, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingMTDdistribution_+3A_target">target</code></td>
<td>
<p>see <code><a href="#topic+StoppingMTDdistribution-class">StoppingMTDdistribution</a></code></p>
</td></tr>
<tr><td><code id="StoppingMTDdistribution_+3A_thresh">thresh</code></td>
<td>
<p>see <code><a href="#topic+StoppingMTDdistribution-class">StoppingMTDdistribution</a></code></p>
</td></tr>
<tr><td><code id="StoppingMTDdistribution_+3A_prob">prob</code></td>
<td>
<p>see <code><a href="#topic+StoppingMTDdistribution-class">StoppingMTDdistribution</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingMTDdistribution-class">StoppingMTDdistribution</a></code> object
</p>

<hr>
<h2 id='StoppingMTDdistribution-class'>Stop based on MTD distribution</h2><span id='topic+StoppingMTDdistribution-class'></span><span id='topic+.StoppingMTDdistribution'></span>

<h3>Description</h3>

<p>Has 90% probability above a threshold of 50% of the current
MTD been reached? This class is used for this question.
</p>


<h3>Slots</h3>


<dl>
<dt><code>target</code></dt><dd><p>the target toxicity probability (e.g. 0.33) defining the MTD</p>
</dd>
<dt><code>thresh</code></dt><dd><p>the threshold relative to the MTD (e.g. 0.5)</p>
</dd>
<dt><code>prob</code></dt><dd><p>required probability (e.g. 0.9)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#   stopping the study if there is at least 0.9 probability that MTD &gt; 0.5*next_dose.
#   Here MTD is defined as the dose for which prob(DLE)=0.33

myStopping &lt;- StoppingMTDdistribution(target = 0.33,
                                      thresh = 0.5,
                                      prob = 0.9)

</code></pre>

<hr>
<h2 id='StoppingPatientsNearDose'>Initialization function for &quot;StoppingPatientsNearDose&quot;</h2><span id='topic+StoppingPatientsNearDose'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingPatientsNearDose&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingPatientsNearDose(nPatients, percentage)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingPatientsNearDose_+3A_npatients">nPatients</code></td>
<td>
<p>see <code><a href="#topic+StoppingPatientsNearDose-class">StoppingPatientsNearDose</a></code></p>
</td></tr>
<tr><td><code id="StoppingPatientsNearDose_+3A_percentage">percentage</code></td>
<td>
<p>see <code><a href="#topic+StoppingPatientsNearDose-class">StoppingPatientsNearDose</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingPatientsNearDose-class">StoppingPatientsNearDose</a></code> object
</p>

<hr>
<h2 id='StoppingPatientsNearDose-class'>Stop based on number of patients near to next best dose</h2><span id='topic+StoppingPatientsNearDose-class'></span><span id='topic+.StoppingPatientsNearDose'></span>

<h3>Description</h3>

<p>Stop based on number of patients near to next best dose
</p>


<h3>Slots</h3>


<dl>
<dt><code>nPatients</code></dt><dd><p>number of required patients</p>
</dd>
<dt><code>percentage</code></dt><dd><p>percentage (between 0 and 100) within the next best dose
the patients must lie</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# As example, here is the rule for: 
#   stopping the study if at least 9 patients were dosed at a dose within (1 +/- 0.2) 
#   of the next best dose

myStopping &lt;- StoppingPatientsNearDose(nPatients = 9,
                                       percentage = 0.2)

</code></pre>

<hr>
<h2 id='StoppingTargetBiomarker'>Initialization function for &quot;StoppingTargetBiomarker&quot;</h2><span id='topic+StoppingTargetBiomarker'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingTargetBiomarker&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingTargetBiomarker(target, scale = c("relative", "absolute"), prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingTargetBiomarker_+3A_target">target</code></td>
<td>
<p>see <code><a href="#topic+StoppingTargetBiomarker-class">StoppingTargetBiomarker</a></code></p>
</td></tr>
<tr><td><code id="StoppingTargetBiomarker_+3A_scale">scale</code></td>
<td>
<p>see <code><a href="#topic+StoppingTargetBiomarker-class">StoppingTargetBiomarker</a></code></p>
</td></tr>
<tr><td><code id="StoppingTargetBiomarker_+3A_prob">prob</code></td>
<td>
<p>see <code><a href="#topic+StoppingTargetBiomarker-class">StoppingTargetBiomarker</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingTargetBiomarker-class">StoppingTargetBiomarker</a></code> object
</p>

<hr>
<h2 id='StoppingTargetBiomarker-class'>Stop based on probability of target biomarker</h2><span id='topic+StoppingTargetBiomarker-class'></span><span id='topic+.StoppingTargetBiomarker'></span>

<h3>Description</h3>

<p>Stop based on probability of target biomarker
</p>


<h3>Slots</h3>


<dl>
<dt><code>target</code></dt><dd><p>the biomarker target range, that
needs to be reached. For example, (0.8, 1.0) and <code>scale="relative"</code> 
means we target a dose with at least 80% of maximum biomarker level.</p>
</dd>
<dt><code>scale</code></dt><dd><p>either <code>relative</code> (default, then the <code>target</code> is interpreted 
relative to the maximum, so must be a probability range) or <code>absolute</code>
(then the <code>target</code> is interpreted as absolute biomarker range)</p>
</dd>
<dt><code>prob</code></dt><dd><p>required target probability for reaching sufficient precision</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># As example, here is the rule for: 
#   stopping the study if there is at least 0.5 probability that the biomarker 
#   (efficacy) is within the biomarker target range of [0.9, 1.0] (relative to the
#   maximum for the biomarker).

myStopping &lt;- StoppingTargetBiomarker(target = c(0.9, 1),
                                      prob = 0.5)

</code></pre>

<hr>
<h2 id='StoppingTargetProb'>Initialization function for &quot;StoppingTargetProb&quot;</h2><span id='topic+StoppingTargetProb'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingTargetProb&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingTargetProb(target, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingTargetProb_+3A_target">target</code></td>
<td>
<p>see <code><a href="#topic+StoppingTargetProb-class">StoppingTargetProb</a></code></p>
</td></tr>
<tr><td><code id="StoppingTargetProb_+3A_prob">prob</code></td>
<td>
<p>see <code><a href="#topic+StoppingTargetProb-class">StoppingTargetProb</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingTargetProb-class">StoppingTargetProb</a></code> object
</p>

<hr>
<h2 id='StoppingTargetProb-class'>Stop based on probability of target tox interval</h2><span id='topic+StoppingTargetProb-class'></span><span id='topic+.StoppingTargetProb'></span>

<h3>Description</h3>

<p>Stop based on probability of target tox interval
</p>


<h3>Slots</h3>


<dl>
<dt><code>target</code></dt><dd><p>the target toxicity interval, e.g. <code>c(0.2, 0.35)</code></p>
</dd>
<dt><code>prob</code></dt><dd><p>required target toxicity probability (e.g. <code>0.4</code>)
for reaching sufficient precision</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># As example, here is the rule for: 
#   stopping the study if the posterior probability that [0.2 =&lt; Prob(DLT | dose) &lt;= 0.35] 
#   for the next best dose is above 0.5

myStopping &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                 prob=0.5)
</code></pre>

<hr>
<h2 id='StoppingTDCIRatio'>Initialization function for &quot;StoppingTDCIRatio&quot;</h2><span id='topic+StoppingTDCIRatio'></span>

<h3>Description</h3>

<p>Initialization function for &quot;StoppingTDCIRatio&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoppingTDCIRatio(targetRatio, targetEndOfTrial)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoppingTDCIRatio_+3A_targetratio">targetRatio</code></td>
<td>
<p>please refer to <code><a href="#topic+StoppingTDCIRatio-class">StoppingTDCIRatio</a></code> class object</p>
</td></tr>
<tr><td><code id="StoppingTDCIRatio_+3A_targetendoftrial">targetEndOfTrial</code></td>
<td>
<p>please refer to <code><a href="#topic+StoppingTDCIRatio-class">StoppingTDCIRatio</a></code> class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+StoppingTDCIRatio-class">StoppingTDCIRatio</a></code> class object
</p>

<hr>
<h2 id='StoppingTDCIRatio-class'>Stop based on a target ratio, the ratio of the upper to the lower
95% credibility interval of the estimate of TD end of trial, the dose with probability of DLE equals to the target 
probability of DLE used at the end of a trial</h2><span id='topic+StoppingTDCIRatio-class'></span><span id='topic+.StoppingTDCIRatio'></span>

<h3>Description</h3>

<p>Stop based on a target ratio, the ratio of the upper to the lower
95% credibility interval of the estimate of TD end of trial, the dose with probability of DLE equals to the target 
probability of DLE used at the end of a trial
</p>


<h3>Slots</h3>


<dl>
<dt><code>targetRatio</code></dt><dd><p>the target ratio of the upper to the lower of the 95% credibility interval of the 
estimate that required to stop a trial</p>
</dd>
<dt><code>targetEndOfTrial</code></dt><dd><p>the target probability of DLE to be used at the end of a trial</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the target stopping ratio of 5 and 
##the target probability of DLE to be used at the end of a trial
##This is a ratio of the upper to the lower 95% credibility interval of the estimates
myStopping &lt;- StoppingTDCIRatio(targetRatio=5,
                                targetEndOfTrial=0.3)
</code></pre>

<hr>
<h2 id='stopTrial'>Stop the trial?</h2><span id='topic+stopTrial'></span><span id='topic+stopTrial+2CStoppingList+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+stopTrial+2CStoppingAll+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+stopTrial+2CStoppingAny+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+stopTrial+2CStoppingCohortsNearDose+2Cnumeric+2CANY+2CANY+2CData-method'></span><span id='topic+stopTrial+2CStoppingPatientsNearDose+2Cnumeric+2CANY+2CANY+2CData-method'></span><span id='topic+stopTrial+2CStoppingMinCohorts+2CANY+2CANY+2CANY+2CData-method'></span><span id='topic+stopTrial+2CStoppingMinPatients+2CANY+2CANY+2CANY+2CData-method'></span><span id='topic+stopTrial+2CStoppingTargetProb+2Cnumeric+2CSamples+2CModel+2CANY-method'></span><span id='topic+stopTrial+2CStoppingMTDdistribution+2Cnumeric+2CSamples+2CModel+2CANY-method'></span><span id='topic+stopTrial+2CStoppingTargetBiomarker+2Cnumeric+2CSamples+2CDualEndpoint+2CANY-method'></span><span id='topic+stopTrial+2CStoppingHighestDose+2Cnumeric+2CANY+2CANY+2CData-method'></span><span id='topic+stopTrial+2CStoppingTDCIRatio+2CANY+2CSamples+2CModelTox+2CANY-method'></span><span id='topic+stopTrial+2CStoppingTDCIRatio+2CANY+2Cmissing+2CModelTox+2CANY-method'></span><span id='topic+stopTrial+2CStoppingGstarCIRatio+2CANY+2CSamples+2CModelTox+2CDataDual-method'></span><span id='topic+stopTrial+2CStoppingGstarCIRatio+2CANY+2Cmissing+2CModelTox+2CDataDual-method'></span>

<h3>Description</h3>

<p>This function returns whether to stop the trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingList,ANY,ANY,ANY,ANY'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingAll,ANY,ANY,ANY,ANY'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingAny,ANY,ANY,ANY,ANY'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingCohortsNearDose,numeric,ANY,ANY,Data'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingPatientsNearDose,numeric,ANY,ANY,Data'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingMinCohorts,ANY,ANY,ANY,Data'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingMinPatients,ANY,ANY,ANY,Data'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingTargetProb,numeric,Samples,Model,ANY'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingMTDdistribution,numeric,Samples,Model,ANY'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 
## 'StoppingTargetBiomarker,numeric,Samples,DualEndpoint,ANY'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingHighestDose,numeric,ANY,ANY,Data'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingTDCIRatio,ANY,Samples,ModelTox,ANY'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingTDCIRatio,ANY,missing,ModelTox,ANY'
stopTrial(stopping, dose, samples, model, data, ...)

## S4 method for signature 'StoppingGstarCIRatio,ANY,Samples,ModelTox,DataDual'
stopTrial(
  stopping,
  dose,
  samples,
  model,
  data,
  TDderive,
  Effmodel,
  Effsamples,
  Gstarderive,
  ...
)

## S4 method for signature 'StoppingGstarCIRatio,ANY,missing,ModelTox,DataDual'
stopTrial(stopping, dose, model, data, Effmodel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopTrial_+3A_stopping">stopping</code></td>
<td>
<p>The rule, an object of class
<code><a href="#topic+Stopping-class">Stopping</a></code></p>
</td></tr>
<tr><td><code id="stopTrial_+3A_dose">dose</code></td>
<td>
<p>the recommended next best dose</p>
</td></tr>
<tr><td><code id="stopTrial_+3A_samples">samples</code></td>
<td>
<p>the <code><a href="#topic+Samples-class">Samples</a></code> object</p>
</td></tr>
<tr><td><code id="stopTrial_+3A_model">model</code></td>
<td>
<p>The model input, an object of class <code><a href="#topic+Model-class">Model</a></code></p>
</td></tr>
<tr><td><code id="stopTrial_+3A_data">data</code></td>
<td>
<p>The data input, an object of class <code><a href="#topic+Data-class">Data</a></code></p>
</td></tr>
<tr><td><code id="stopTrial_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="stopTrial_+3A_tdderive">TDderive</code></td>
<td>
<p>the function which derives from the input, a vector of the posterior samples called 
<code>TDsamples</code> of the dose
which has the probability of the occurrence of DLE equals to either the targetDuringTrial or
targetEndOfTrial, the final next best TDtargetDuringTrial (the dose with probability of the 
occurrence of DLE equals to the targetDuringTrial)and TDtargetEndOfTrial estimate.</p>
</td></tr>
<tr><td><code id="stopTrial_+3A_effmodel">Effmodel</code></td>
<td>
<p>the efficacy model of <code><a href="#topic+ModelEff-class">ModelEff</a></code> class object</p>
</td></tr>
<tr><td><code id="stopTrial_+3A_effsamples">Effsamples</code></td>
<td>
<p>the efficacy samples of <code><a href="#topic+Samples-class">Samples</a></code> class object</p>
</td></tr>
<tr><td><code id="stopTrial_+3A_gstarderive">Gstarderive</code></td>
<td>
<p>the function which derives from the input, a vector of the posterior Gstar (the dose
which gives the maximum gain value) samples 
called <code>Gstarsamples</code>, the final next best Gstar estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value: <code>TRUE</code> if the trial can be stopped, <code>FALSE</code>
otherwise. It should have an attribute <code>message</code> which gives the reason
for the decision.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stopTrial(
  stopping = StoppingList,
  dose = ANY,
  samples = ANY,
  model = ANY,
  data = ANY
)</code>: Stop based on multiple stopping rules
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingAll,
  dose = ANY,
  samples = ANY,
  model = ANY,
  data = ANY
)</code>: Stop based on fulfillment of all multiple stopping
rules
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingAny,
  dose = ANY,
  samples = ANY,
  model = ANY,
  data = ANY
)</code>: Stop based on fulfillment of any stopping rule
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingCohortsNearDose,
  dose = numeric,
  samples = ANY,
  model = ANY,
  data = Data
)</code>: Stop based on number of cohorts near to next best dose
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingPatientsNearDose,
  dose = numeric,
  samples = ANY,
  model = ANY,
  data = Data
)</code>: Stop based on number of patients near to next best
dose
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingMinCohorts,
  dose = ANY,
  samples = ANY,
  model = ANY,
  data = Data
)</code>: Stop based on minimum number of cohorts
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingMinPatients,
  dose = ANY,
  samples = ANY,
  model = ANY,
  data = Data
)</code>: Stop based on minimum number of patients
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingTargetProb,
  dose = numeric,
  samples = Samples,
  model = Model,
  data = ANY
)</code>: Stop based on probability of target tox interval
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingMTDdistribution,
  dose = numeric,
  samples = Samples,
  model = Model,
  data = ANY
)</code>: Stop based on MTD distribution
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingTargetBiomarker,
  dose = numeric,
  samples = Samples,
  model = DualEndpoint,
  data = ANY
)</code>: Stop based on probability of targeting biomarker
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingHighestDose,
  dose = numeric,
  samples = ANY,
  model = ANY,
  data = Data
)</code>: Stop when the highest dose is reached
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingTDCIRatio,
  dose = ANY,
  samples = Samples,
  model = ModelTox,
  data = ANY
)</code>: Stop based on 'StoppingTDCIRatio' class when 
reaching the target ratio of the upper to the lower 95
interval of the estimate (TDtargetEndOfTrial). This is a stopping rule which incorporate only 
DLE responses and DLE samples are given
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingTDCIRatio,
  dose = ANY,
  samples = missing,
  model = ModelTox,
  data = ANY
)</code>: Stop based on 'StoppingTDCIRatio' class
when reaching the target ratio of the upper to the lower 95
interval of the estimate (TDtargetEndOfTrial). This is a stopping rule which incorporate only 
DLE responses and no DLE samples are involved
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingGstarCIRatio,
  dose = ANY,
  samples = Samples,
  model = ModelTox,
  data = DataDual
)</code>: Stop based on reaching the target ratio of the upper to the lower 95
interval of the estimate (the minimum of Gstar and TDtargetEndOfTrial). This is a stopping rule which 
incorporate DLE and efficacy responses and DLE and efficacy samples are also used.
</p>
</li>
<li> <p><code>stopTrial(
  stopping = StoppingGstarCIRatio,
  dose = ANY,
  samples = missing,
  model = ModelTox,
  data = DataDual
)</code>: Stop based on reaching the target ratio of the upper to the lower 95
interval of the estimate (the minimum of Gstar and TDtargetEndOfTrial). This is a stopping rule which 
incorporate DLE and efficacy responses without DLE and efficacy samples involved.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example of combining stopping rules with '&amp;' and/or '|' operators

myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)

myStopping &lt;- (myStopping1 &amp; myStopping2) | myStopping3





# Create some data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rules
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)

# Create a list of stopping rules (of class 'StoppingList') which will then be
# summarized (in this specific example) with the 'any' function, meaning that the study 
# would be stopped if 'any' of the single stopping rules is TRUE.
mystopping &lt;- StoppingList(stopList=c(myStopping1,myStopping2,myStopping3),
                           summary=any)

# Evaluate if to stop the Trial
stopTrial(stopping=myStopping, dose=doseRecommendation$value,
          samples=samples, model=model, data=data)




# Create some data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rules
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)

# Combine the stopping rules, obtaining (in this specific example) a list of stopping 
# rules of class 'StoppingAll'
myStopping &lt;- (myStopping1 | myStopping2) &amp; myStopping3

# Evaluate if to stop the Trial
stopTrial(stopping=myStopping, dose=doseRecommendation$value,
          samples=samples, model=model, data=data)




# Create some data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rules
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)

# Combine the stopping rules, obtaining (in this specific example) a list of stopping 
# rules of class 'StoppingAny'
myStopping &lt;- (myStopping1 | myStopping2) | myStopping3

# Evaluate if to stop the Trial
stopTrial(stopping=myStopping, dose=doseRecommendation$value,
          samples=samples, model=model, data=data)




# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rule such that the study would be stopped if at least 3 
# cohorts were already dosed within 1 +/- 0.2 of the next best dose
myStopping &lt;- StoppingCohortsNearDose(nCohorts = 3,
                                      percentage = 0.2)

# Evaluate if to stop the trial
stopTrial(stopping=myStopping, 
          dose=doseRecommendation$value,
          data=data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rule such that the study would be stopped if at least 9 
# patients were already dosed within 1 +/- 0.2 of the next best dose
myStopping &lt;- StoppingPatientsNearDose(nPatients = 9,
                                       percentage = 0.2)

# Evaluate if to stop the trial
stopTrial(stopping=myStopping, 
          dose=doseRecommendation$value,
          data=data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rule such that the study would be stopped if at least 6 
# cohorts were already dosed 
myStopping &lt;- StoppingMinCohorts(nCohorts = 6)

# Evaluate if to stop the trial
stopTrial(stopping=myStopping, 
          dose=doseRecommendation$value,
          data=data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rule such that the study would be stopped if at least 20 
# patients were already dosed 
myStopping &lt;- StoppingMinPatients(nPatients = 20)

# Evaluate if to stop the trial
stopTrial(stopping=myStopping, 
          dose=doseRecommendation$value,
          data=data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rule such that the study would be stopped if there is at least 
# 0.5 posterior probability that [0.2 =&lt; Prob(DLT | next-best-dose) &lt;= 0.35] 
myStopping &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                 prob=0.5)

# Evaluate if to stop the trial
stopTrial(stopping=myStopping, 
          dose=doseRecommendation$value,
          samples=samples,
          model=model,
          data=data)


# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
             y=c(0, 0, 0, 0, 0, 0, 1, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rule such that the study would be stopped if there is at least 
# 0.9 probability that MTD &gt; 0.5*next_best_dose. Here MTD is defined as the dose for 
# which prob(DLE)=0.33
myStopping &lt;- StoppingMTDdistribution(target = 0.33,
                                      thresh = 0.5,
                                      prob = 0.9)

# Evaluate if to stop the trial
stopTrial(stopping=myStopping, 
          dose=doseRecommendation$value,
          samples=samples,
          model=model,
          data=data)


# Create the data
data &lt;- DataDual(
  x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,
      20, 20, 20, 40, 40, 40, 50, 50, 50),
  y=c(0, 0, 0, 0, 0, 0, 1, 0,
      0, 1, 1, 0, 0, 1, 0, 1, 1),
  w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,
      0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),
  doseGrid=c(0.1, 0.5, 1.5, 3, 6,
             seq(from=10, to=80, by=2)))

# Initialize the Dual-Endpoint model (in this case RW1)
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth = "RW1")

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=500)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# In this case target a dose achieving at least 0.9 of maximum biomarker level (efficacy)
# and with a probability below 0.25 that prob(DLT)&gt;0.35 (safety)
myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples,
                               model=model,
                               data=data)

# Define the stopping rule such that the study would be stopped if if there is at 
# least 0.5 posterior probability that the biomarker (efficacy) is within the 
# biomarker target range of [0.9, 1.0] (relative to the maximum for the biomarker). 
myStopping &lt;- StoppingTargetBiomarker(target = c(0.9, 1),
                                      prob = 0.5)

# Evaluate if to stop the trial
stopTrial(stopping=myStopping, 
          dose=doseRecommendation$value,
          samples=samples,
          model=model,
          data=data)

# Create the data
data &lt;- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40,
                 80, 80, 80),
             y=c(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
             cohort=c(0, 1, 2, 3, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8),
             doseGrid=
               c(0.1, 0.5, 1.5, 3, 6,
                 seq(from=10, to=80, by=2)))

# Initialize the CRM model used to model the data
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Set-up some MCMC parameters and generate samples from the posterior
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=2000)
set.seed(94)
samples &lt;- mcmc(data, model, options)

# Define the rule for dose increments and calculate the maximum dose allowed
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))
nextMaxDose &lt;- maxDose(myIncrements,
                       data=data)

# Define the rule which will be used to select the next best dose
# based on the class 'NextBestNCRM'
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Calculate the next best dose
doseRecommendation &lt;- nextBest(myNextBest,
                               doselimit=nextMaxDose,
                               samples=samples, model=model, data=data)

# Define the stopping rule such that the study would be stopped if there is at least 
# 0.5 posterior probability that [0.2 =&lt; Prob(DLT | next-best-dose) &lt;= 0.35] 
stopTarget &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                 prob=0.5)

## now use the StoppingHighestDose rule:
stopHigh &lt;-
  StoppingHighestDose() &amp;
  StoppingPatientsNearDose(nPatients=3, percentage=0) &amp;
  StoppingTargetProb(target=c(0, 0.2),
                     prob=0.5)

## and combine everything:
myStopping &lt;- stopTarget | stopHigh

# Then evaluate if to stop the trial
stopTrial(stopping=myStopping, 
          dose=doseRecommendation$value,
          samples=samples,
          model=model,
          data=data)



##define the stopping rules based on the 'StoppingTDCIRatio' class
##Using only DLE responses with samples
## we need a data object with doses &gt;= 1:
data&lt;-Data(x=c(25,50,50,75,150,200,225,300),
           y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(from=25,to=300,by=25))

##model can be specified of 'Model' or 'ModelTox' class
##For example, the 'logisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##define MCMC options
##for illustration purpose we use 10 burn-in and generate 50 samples
options&lt;-McmcOptions(burnin=10,step=2,samples=50)
##samples of 'Samples' class
samples&lt;-mcmc(data,model,options)
##define the 'StoppingTDCIRatio' class
myStopping &lt;- StoppingTDCIRatio(targetRatio=5,
                                       targetEndOfTrial=0.3)
##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples)
tdNextBest&lt;-NextBestTDsamples(targetDuringTrial=0.35,targetEndOfTrial=0.3,
                              derive=function(TDsamples){quantile(TDsamples,probs=0.3)})


RecommendDose&lt;-nextBest(tdNextBest,doselimit=max(data@doseGrid),samples=samples,
                        model=model,data=data)
##use 'stopTrial' to determine if the rule has been fulfilled
##use 0.3 as the target proability of DLE at the end of the trial

stopTrial(stopping=myStopping,dose=RecommendDose$nextdose,
          samples=samples,model=model,data=data)
## RecommendDose$nextdose refers to the next dose obtained in RecommendDose
##define the stopping rules based on the 'StoppingTDCIRatio' class
##Using only DLE responses 
## we need a data object with doses &gt;= 1:
data&lt;-Data(x=c(25,50,50,75,150,200,225,300),
           y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(from=25,to=300,by=25))

##model must be of 'ModelTox' class
##For example, the 'logisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##define the 'StoppingTDCIRatio' class
myStopping &lt;- StoppingTDCIRatio(targetRatio=5,
                                targetEndOfTrial=0.3)
##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples)
tdNextBest&lt;-NextBestTD(targetDuringTrial=0.35,targetEndOfTrial=0.3)


RecommendDose&lt;-nextBest(tdNextBest,doselimit=max(data@doseGrid),model=model,data=data)
##use 'stopTrial' to determine if the rule has been fulfilled
##use 0.3 as the target proability of DLE at the end of the trial

stopTrial(stopping=myStopping,dose=RecommendDose$nextdose,
          model=model,data=data)
## RecommendDose$nextdose refers to the next dose obtained in RecommendDose
##define the stopping rules based on the 'StoppingGstarCIRatio' class
##Using both DLE and efficacy responses
## we need a data object with doses &gt;= 1:
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
                y=c(0,0,0,0,0,1,1,0),
                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                doseGrid=seq(25,300,25),
                placebo=FALSE)

##DLEmodel must be of 'ModelTox' class
##For example, the 'logisticIndepBeta' class model
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

##Effmodel must be  of 'ModelEff' class
##For example, the 'Effloglog' class model
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)
##for illustration purpose we use 10 burn-in and generate 50 samples
options&lt;-McmcOptions(burnin=10,step=2,samples=50)
##DLE and efficacy samples must be of 'Samples' class
DLEsamples&lt;-mcmc(data,DLEmodel,options)
Effsamples&lt;-mcmc(data,Effmodel,options)

##define the 'StoppingGstarCIRatio' class
myStopping &lt;- StoppingGstarCIRatio(targetRatio=5,
                                          targetEndOfTrial=0.3)
##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples)
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})

RecommendDose&lt;-nextBest(mynextbest,doselimit=max(data@doseGrid),samples=DLEsamples,model=DLEmodel,
                        data=data,Effmodel=Effmodel,Effsamples=Effsamples)
##use 'stopTrial' to determine if the rule has been fulfilled
##use 0.3 as the target proability of DLE at the end of the trial 

stopTrial(stopping=myStopping,
          dose=RecommendDose$nextdose,
          samples=DLEsamples,
          model=DLEmodel,
          data=data,
          TDderive=function(TDsamples){
            quantile(TDsamples,prob=0.3)},
          Effmodel=Effmodel,
          Effsamples=Effsamples,
          Gstarderive=function(Gstarsamples){
            quantile(Gstarsamples,prob=0.5)})

## RecommendDose$nextdose refers to the next dose obtained in RecommendDose
##define the stopping rules based on the 'StoppingGstarCIRatio' class
##Using both DLE and efficacy responses
## we need a data object with doses &gt;= 1:
data &lt;-DataDual(x=c(25,50,25,50,75,300,250,150),
                y=c(0,0,0,0,0,1,1,0),
                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
                doseGrid=seq(25,300,25),
                placebo=FALSE)

##DLEmodel must be of 'ModelTox' class
##For example, the 'logisticIndepBeta' class model
DLEmodel&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

##Effmodel must be  of 'ModelEff' class
##For example, the 'Effloglog' class model
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)


##define the 'StoppingGstarCIRatio' class
myStopping &lt;- StoppingGstarCIRatio(targetRatio=5,
                                   targetEndOfTrial=0.3)
##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples)
mynextbest&lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,DLEEndOfTrialtarget=0.3)

RecommendDose&lt;-nextBest(mynextbest,doselimit=max(data@doseGrid),model=DLEmodel,
                        Effmodel=Effmodel,data=data)

##use 'stopTrial' to determine if the rule has been fulfilled
##use 0.3 as the target proability of DLE at the end of the trial


stopTrial(stopping=myStopping,dose=RecommendDose$nextdose,model=DLEmodel,
          data=data, Effmodel=Effmodel)


## RecommendDose$nextdose refers to the next dose obtained in RecommendDose
</code></pre>

<hr>
<h2 id='summary+2CDualSimulations-method'>Summarize the dual-endpoint design simulations, relative to given true
dose-toxicity and dose-biomarker curves</h2><span id='topic+summary+2CDualSimulations-method'></span>

<h3>Description</h3>

<p>Summarize the dual-endpoint design simulations, relative to given true
dose-toxicity and dose-biomarker curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DualSimulations'
summary(object, trueTox, trueBiomarker, target = c(0.2, 0.35), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CDualSimulations-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+DualSimulations-class">DualSimulations</a></code> object we want to
summarize</p>
</td></tr>
<tr><td><code id="summary+2B2CDualSimulations-method_+3A_truetox">trueTox</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the
true probability (vector) for toxicity.</p>
</td></tr>
<tr><td><code id="summary+2B2CDualSimulations-method_+3A_truebiomarker">trueBiomarker</code></td>
<td>
<p>a function which takes as input a dose (vector) and
returns the true biomarker level (vector).</p>
</td></tr>
<tr><td><code id="summary+2B2CDualSimulations-method_+3A_target">target</code></td>
<td>
<p>the target toxicity interval (default: 20-35%) used for the
computations</p>
</td></tr>
<tr><td><code id="summary+2B2CDualSimulations-method_+3A_...">...</code></td>
<td>
<p>Additional arguments can be supplied here for <code>trueTox</code>
and <code>trueBiomarker</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+DualSimulationsSummary-class">DualSimulationsSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- DualEndpointRW(mu = c(0, 1),
                        Sigma = matrix(c(1, 0, 0, 1), nrow=2),
                        sigma2betaW = 0.01,
                        sigma2W = c(a=0.1, b=0.1),
                        rho = c(a=1, b=1),
                        smooth="RW1")

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestDualEndpoint(target=c(0.9, 1),
                                   overdose=c(0.35, 1),
                                   maxOverdoseProb=0.25)

# Choose the rule for stopping
myStopping4 &lt;- StoppingTargetBiomarker(target=c(0.9, 1),
                                       prob=0.5)
# StoppingMinPatients will usually take a higher sample size,
# just for illustration here
myStopping &lt;- myStopping4 | StoppingMinPatients(6)

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- DualDesign(model = model,
                     data = emptydata,
                     nextBest = myNextBest,
                     stopping = myStopping,
                     increments = myIncrements,
                     cohortSize = CohortSizeConst(3),
                     startingDose = 3)
  
# define scenarios for the TRUE toxicity and efficacy profiles
betaMod &lt;- function (dose, e0, eMax, delta1, delta2, scal)
{
  maxDens &lt;- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))
  dose &lt;- dose/scal
  e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2
}

trueBiomarker &lt;- function(dose)
{
  betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100)
}

trueTox &lt;- function(dose)
{
  pnorm((dose-60)/10)
}

# Draw the TRUE profiles
par(mfrow=c(1, 2))
curve(trueTox(x), from=0, to=80)
curve(trueBiomarker(x), from=0, to=80)

# Run the simulation on the desired design
# We only generate 1 trial outcome here for illustration, for the actual study
# Also for illustration purpose, we will use 5 burn-ins to generate 20 samples
# this should be increased of course!
mySims &lt;- simulate(design,
                   trueTox=trueTox,
                   trueBiomarker=trueBiomarker,
                   sigma2W=0.01,
                   rho=0,
                   nsim=1,
                   parallel=FALSE,
                   seed=3,
                   startingDose=6,
                   mcmcOptions =
                     McmcOptions(burnin=5,
                                 step=1,
                                 samples=20))

# Summarize the Results of the Simulations
summary(mySims,
        trueTox = trueTox,
        trueBiomarker = trueBiomarker)



  
</code></pre>

<hr>
<h2 id='summary+2CGeneralSimulations-method'>Summarize the simulations, relative to a given truth</h2><span id='topic+summary+2CGeneralSimulations-method'></span>

<h3>Description</h3>

<p>Summarize the simulations, relative to a given truth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeneralSimulations'
summary(object, truth, target = c(0.2, 0.35), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CGeneralSimulations-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeneralSimulations-class">GeneralSimulations</a></code> object we want to
summarize</p>
</td></tr>
<tr><td><code id="summary+2B2CGeneralSimulations-method_+3A_truth">truth</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the
true probability (vector) for toxicity</p>
</td></tr>
<tr><td><code id="summary+2B2CGeneralSimulations-method_+3A_target">target</code></td>
<td>
<p>the target toxicity interval (default: 20-35%) used for the
computations</p>
</td></tr>
<tr><td><code id="summary+2B2CGeneralSimulations-method_+3A_...">...</code></td>
<td>
<p>Additional arguments can be supplied here for <code>truth</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+GeneralSimulationsSummary-class">GeneralSimulationsSummary</a></code>
</p>

<hr>
<h2 id='summary+2CPseudoDualFlexiSimulations-method'>Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model.</h2><span id='topic+summary+2CPseudoDualFlexiSimulations-method'></span>

<h3>Description</h3>

<p>Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoDualFlexiSimulations'
summary(
  object,
  trueDLE,
  trueEff,
  targetEndOfTrial = 0.3,
  targetDuringTrial = 0.35,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CPseudoDualFlexiSimulations-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+PseudoDualFlexiSimulations-class">PseudoDualFlexiSimulations</a></code> object we want to summarize</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualFlexiSimulations-method_+3A_truedle">trueDLE</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the true probability of DLE (vector)</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualFlexiSimulations-method_+3A_trueeff">trueEff</code></td>
<td>
<p>a vector which takes as input the true mean efficacy values at all dose levels (in order)</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualFlexiSimulations-method_+3A_targetendoftrial">targetEndOfTrial</code></td>
<td>
<p>the target probability of DLE that are used at the end of a trial. Default at 0.3.</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualFlexiSimulations-method_+3A_targetduringtrial">targetDuringTrial</code></td>
<td>
<p>the target probability of DLE that are used during the trial. Default at 0.35.</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualFlexiSimulations-method_+3A_...">...</code></td>
<td>
<p>Additional arguments can be supplied here for <code>trueDLE</code> and <code>trueEff</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+PseudoDualSimulationsSummary-class">PseudoDualSimulationsSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##If DLE and efficacy responses are considered in the simulations and the 'EffFlexi' class is used 
## we need a data object with doses &gt;= 1:
data &lt;- DataDual(doseGrid=seq(25,300,25))
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

## for the efficacy model
Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)


##specified the next best
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})

##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 10 subjects are treated:
## very low sample size is just for illustration here
myStopping &lt;- StoppingMinPatients(nPatients=10)

##Specified the design 
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##specified the true DLE curve and the true expected efficacy values at all dose levels
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- c(-0.5478867, 0.1645417,  0.5248031,  0.7604467,  
               0.9333009  ,1.0687031,  1.1793942 , 1.2726408 , 
               1.3529598 , 1.4233411 , 1.4858613 , 1.5420182)


##specify the options for MCMC
#For illustration purpose, we use 10 burn-in and generate 100 samples
options&lt;-McmcOptions(burnin=10,step=1,samples=100)
##The simulation
##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim&lt;-simulate(object=design,
                args=NULL,
                trueDLE=myTruthDLE,
                trueEff=myTruthEff,
                trueSigma2=0.025,
                trueSigma2betaW=1,
                nsim=1,
                seed=819,
                parallel=FALSE,
                mcmcOptions=options)
##summarize the simulation results
summary(mySim,
        trueDLE=myTruthDLE,
        trueEff=myTruthEff)
</code></pre>

<hr>
<h2 id='summary+2CPseudoDualSimulations-method'>Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model 
(except the EffFlexi class model)</h2><span id='topic+summary+2CPseudoDualSimulations-method'></span>

<h3>Description</h3>

<p>Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model 
(except the EffFlexi class model)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoDualSimulations'
summary(
  object,
  trueDLE,
  trueEff,
  targetEndOfTrial = 0.3,
  targetDuringTrial = 0.35,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CPseudoDualSimulations-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+PseudoDualSimulations-class">PseudoDualSimulations</a></code> object we want to summarize</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualSimulations-method_+3A_truedle">trueDLE</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the true probability (vector)
of DLE</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualSimulations-method_+3A_trueeff">trueEff</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the mean efficacy value(s) (vector).</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualSimulations-method_+3A_targetendoftrial">targetEndOfTrial</code></td>
<td>
<p>the target probability of DLE that are used at the end of a trial. Default at 0.3.</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualSimulations-method_+3A_targetduringtrial">targetDuringTrial</code></td>
<td>
<p>the target probability of DLE that are used during the trial. Default at 0.35.</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoDualSimulations-method_+3A_...">...</code></td>
<td>
<p>Additional arguments can be supplied here for <code>trueDLE</code> and <code>trueEff</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+PseudoDualSimulationsSummary-class">PseudoDualSimulationsSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##obtain the plot for the simulation results
##If DLE and efficacy responses are considered in the simulations
##Specified your simulations when no samples are used
data &lt;- DataDual(doseGrid=seq(25,300,25))
##First for the DLE model 
##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class 
DLEmodel &lt;- LogisticIndepBeta(binDLE=c(1.05,1.8),
                              DLEweights=c(3,3),
                              DLEdose=c(25,300),
                              data=data)

##The efficacy model of 'ModelEff' (e.g 'Effloglog') class 
Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),
                    nu=c(a=1,b=0.025),data=data)

##The escalation rule using the 'NextBestMaxGain' class
mynextbest&lt;-NextBestMaxGain(DLEDuringTrialtarget=0.35,
                            DLEEndOfTrialtarget=0.3)


##The increments (see Increments class examples) 
## 200% allowable increase for dose below 300 and 200% increase for dose above 300
myIncrements&lt;-IncrementsRelative(intervals=c(25,300),
                                 increments=c(2,2))
##cohort size of 3
mySize&lt;-CohortSizeConst(size=3)
##Stop only when 36 subjects are treated
myStopping &lt;- StoppingMinPatients(nPatients=36)
##Now specified the design with all the above information and starting with a dose of 25

##Specified the design(for details please refer to the 'DualResponsesDesign' example)
design &lt;- DualResponsesDesign(nextBest=mynextbest,
                              model=DLEmodel,
                              Effmodel=Effmodel,
                              stopping=myStopping,
                              increments=myIncrements,
                              cohortSize=mySize,
                              data=data,startingDose=25)
##Specify the true DLE and efficacy curves
myTruthDLE&lt;- function(dose)
{ DLEmodel@prob(dose, phi1=-53.66584, phi2=10.50499)
}

myTruthEff&lt;- function(dose)
{Effmodel@ExpEff(dose,theta1=-4.818429,theta2=3.653058)
}

## Then specified the simulations and generate the trial for 2 times
mySim &lt;-simulate(object=design,
                 args=NULL,
                 trueDLE=myTruthDLE,
                 trueEff=myTruthEff,
                 trueNu=1/0.025,
                 nsim=2,
                 seed=819,
                 parallel=FALSE)

##Then produce a summary of your simulations
summary(mySim,
        trueDLE=myTruthDLE,
        trueEff=myTruthEff)
##If DLE and efficacy samples are involved
##Please refer to design-method 'simulate DualResponsesSamplesDesign' examples for details
##specified the next best
mynextbest&lt;-NextBestMaxGainSamples(DLEDuringTrialtarget=0.35,
                                   DLEEndOfTrialtarget=0.3,
                                   TDderive=function(TDsamples){
                                     quantile(TDsamples,prob=0.3)},
                                   Gstarderive=function(Gstarsamples){
                                     quantile(Gstarsamples,prob=0.5)})
##specified the design
design &lt;- DualResponsesSamplesDesign(nextBest=mynextbest,
                                     cohortSize=mySize,
                                     startingDose=25,
                                     model=DLEmodel,
                                     Effmodel=Effmodel,
                                     data=data,
                                     stopping=myStopping,
                                     increments=myIncrements)
##options for MCMC
##For illustration purpose, we will use 50 burn-ins to generate 200 samples
options&lt;-McmcOptions(burnin=50,step=2,samples=200)
##The simulations
##For illustration purpose only 2 simulation is produced (nsim=2). 
mySim&lt;-simulate(design,
                args=NULL,
                trueDLE=myTruthDLE,
                trueEff=myTruthEff,
                trueNu=1/0.025,
                nsim=2,
                mcmcOptions=options,
                seed=819,
                parallel=FALSE)

##Then produce a summary of your simulations
summary(mySim,
        trueDLE=myTruthDLE,
        trueEff=myTruthEff)

</code></pre>

<hr>
<h2 id='summary+2CPseudoSimulations-method'>Summarize the simulations, relative to a given truth</h2><span id='topic+summary+2CPseudoSimulations-method'></span>

<h3>Description</h3>

<p>Summarize the simulations, relative to a given truth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoSimulations'
summary(object, truth, targetEndOfTrial = 0.3, targetDuringTrial = 0.35, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CPseudoSimulations-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+PseudoSimulations-class">PseudoSimulations</a></code> object we want to
summarize</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoSimulations-method_+3A_truth">truth</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the
true probability (vector) for toxicity</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoSimulations-method_+3A_targetendoftrial">targetEndOfTrial</code></td>
<td>
<p>the target probability of DLE wanted to achieve at the end of a trial</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoSimulations-method_+3A_targetduringtrial">targetDuringTrial</code></td>
<td>
<p>the target probability of DLE wanted to achieve during a trial</p>
</td></tr>
<tr><td><code id="summary+2B2CPseudoSimulations-method_+3A_...">...</code></td>
<td>
<p>Additional arguments can be supplied here for <code>truth</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+PseudoSimulationsSummary-class">PseudoSimulationsSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##If only DLE responses are considered in the simulations
##Specified your simulations when no DLE samples are used
## data set with dose levels from 25 to 300 with increments 25
data &lt;- Data(doseGrid=seq(25,300,25))

##The design only incorporate DLE responses and DLE samples are involved
##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##Then the escalation rule
tdNextBest &lt;- NextBestTD(targetDuringTrial=0.35,
                         targetEndOfTrial=0.3)

##Then the starting data, an empty data set
emptydata&lt;-Data(doseGrid=seq(25,300,25))
## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=36)


##Specified the design(for details please refer to the 'TDDesign' example)
design &lt;- TDDesign(model=model,
                   nextBest=tdNextBest,
                   stopping=myStopping,
                   increments=myIncrements,
                   cohortSize=mySize,
                   data=data,startingDose=25)

##Specify the truth of the DLE responses
myTruth &lt;- function(dose)
{ model@prob(dose, phi1=-53.66584, phi2=10.50499)
}



##(Please refer to desgin-method 'simulate TDDesign' examples for details)
##For illustration purpose only 1 simulation is produced (nsim=1). 
mySim &lt;- simulate(design,
                  args=NULL,
                  truth=myTruth,
                  nsim=1,
                  seed=819,
                  parallel=FALSE)
##Then produce a summary of your simulations
summary(mySim,
        truth=myTruth)





##If DLE samples are involved
##specify the next best
tdNextBest&lt;-NextBestTDsamples(targetDuringTrial=0.35,
                              targetEndOfTrial=0.3,
                             derive=function(TDsamples){quantile(TDsamples,probs=0.3)})
##The design
design &lt;- TDsamplesDesign(model=model,
                          nextBest=tdNextBest,
                          stopping=myStopping,
                          increments=myIncrements,
                          cohortSize=mySize,
                          data=data,startingDose=25)
##options for MCMC
##For illustration purpose, we will use 50 burn-ins to generate 200 samples
options&lt;-McmcOptions(burnin=50,step=2,samples=200)
##The simulations
## For illustration purpose we will only generate 2 trials (nsim=2)
mySim &lt;- simulate(design,
                  args=NULL,
                  truth=myTruth,
                  nsim=2,
                  seed=819,
                  mcmcOptions=options,
                  parallel=FALSE)
##Then produce a summary of your simulations
summary(mySim,
        truth=myTruth)
</code></pre>

<hr>
<h2 id='summary+2CSimulations-method'>Summarize the model-based design simulations, relative to a given truth</h2><span id='topic+summary+2CSimulations-method'></span>

<h3>Description</h3>

<p>Summarize the model-based design simulations, relative to a given truth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Simulations'
summary(object, truth, target = c(0.2, 0.35), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CSimulations-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+Simulations-class">Simulations</a></code> object we want to
summarize</p>
</td></tr>
<tr><td><code id="summary+2B2CSimulations-method_+3A_truth">truth</code></td>
<td>
<p>a function which takes as input a dose (vector) and returns the
true probability (vector) for toxicity</p>
</td></tr>
<tr><td><code id="summary+2B2CSimulations-method_+3A_target">target</code></td>
<td>
<p>the target toxicity interval (default: 20-35%) used for the
computations</p>
</td></tr>
<tr><td><code id="summary+2B2CSimulations-method_+3A_...">...</code></td>
<td>
<p>Additional arguments can be supplied here for <code>truth</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+SimulationsSummary-class">SimulationsSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define the dose-grid
emptydata &lt;- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model 
model &lt;- LogisticLogNormal(mean=c(-0.85, 1),
                           cov=
                             matrix(c(1, -0.5, -0.5, 1),
                                    nrow=2),
                           refDose=56)

# Choose the rule for selecting the next dose 
myNextBest &lt;- NextBestNCRM(target=c(0.2, 0.35),
                           overdose=c(0.35, 1),
                           maxOverdoseProb=0.25)

# Choose the rule for the cohort-size 
mySize1 &lt;- CohortSizeRange(intervals=c(0, 30),
                           cohortSize=c(1, 3))
mySize2 &lt;- CohortSizeDLT(DLTintervals=c(0, 1),
                         cohortSize=c(1, 3))
mySize &lt;- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping1 &lt;- StoppingMinCohorts(nCohorts=3)
myStopping2 &lt;- StoppingTargetProb(target=c(0.2, 0.35),
                                  prob=0.5)
myStopping3 &lt;- StoppingMinPatients(nPatients=20)
myStopping &lt;- (myStopping1 &amp; myStopping2) | myStopping3

# Choose the rule for dose increments
myIncrements &lt;- IncrementsRelative(intervals=c(0, 20),
                                   increments=c(1, 0.33))

# Initialize the design
design &lt;- Design(model=model,
                 nextBest=myNextBest,
                 stopping=myStopping,
                 increments=myIncrements,
                 cohortSize=mySize,
                 data=emptydata,
                 startingDose=3)

## define the true function
myTruth &lt;- function(dose)
{
  model@prob(dose, alpha0=7, alpha1=8)
}

# Run the simulation on the desired design
# We only generate 1 trial outcomes here for illustration, for the actual study 
# this should be increased of course
options &lt;- McmcOptions(burnin=100,
                       step=2,
                       samples=1000)
time &lt;- system.time(mySims &lt;- simulate(design,
                                       args=NULL,
                                       truth=myTruth,
                                       nsim=1,
                                       seed=819,
                                       mcmcOptions=options,
                                       parallel=FALSE))[3]

# Summarize the Results of the Simulations
summary(mySims,truth=myTruth)


</code></pre>

<hr>
<h2 id='TDDesign'>Initialization function for 'TDDesign' class</h2><span id='topic+TDDesign'></span>

<h3>Description</h3>

<p>Initialization function for 'TDDesign' class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TDDesign(model, stopping, increments, PLcohortSize = CohortSizeConst(0L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TDDesign_+3A_model">model</code></td>
<td>
<p>please refer to <code><a href="#topic+TDDesign-class">TDDesign</a></code> class object</p>
</td></tr>
<tr><td><code id="TDDesign_+3A_stopping">stopping</code></td>
<td>
<p>please refer to <code><a href="#topic+TDDesign-class">TDDesign</a></code> class object</p>
</td></tr>
<tr><td><code id="TDDesign_+3A_increments">increments</code></td>
<td>
<p>please refer to <code><a href="#topic+TDDesign-class">TDDesign</a></code> class object</p>
</td></tr>
<tr><td><code id="TDDesign_+3A_plcohortsize">PLcohortSize</code></td>
<td>
<p>see <code><a href="#topic+TDDesign-class">TDDesign</a></code></p>
</td></tr>
<tr><td><code id="TDDesign_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="#topic+RuleDesign-class">RuleDesign</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+TDDesign-class">TDDesign</a></code> class object
</p>

<hr>
<h2 id='TDDesign-class'>Design class using DLE responses only based on the pseudo DLE model without sample</h2><span id='topic+TDDesign-class'></span><span id='topic+.TDDesign'></span>

<h3>Description</h3>

<p>This is a class of design based only on DLE responses using the 'LogisticIndepBeta' class model
are used without samples.
In addition to the slots in the more simple <code><a href="#topic+RuleDesign-class">RuleDesign</a></code>,
objects of this class contain:
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>the pseudo DLE model to be used, an object class of 
<code><a href="#topic+ModelTox-class">ModelTox</a></code></p>
</dd>
<dt><code>stopping</code></dt><dd><p>stopping rule(s) for the trial, an object class of <code><a href="#topic+Stopping-class">Stopping</a></code></p>
</dd>
<dt><code>increments</code></dt><dd><p>how to control increments between dose levels, an object class of 
<code><a href="#topic+Increments-class">Increments</a></code></p>
</dd>
<dt><code>PLcohortSize</code></dt><dd><p>rules for the cohort sizes for placebo, if any planned
an object of class <code><a href="#topic+CohortSize-class">CohortSize</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Specified the design to run simulations
##The design comprises a model, the escalation rule, starting data, 
##a cohort size and a starting dose
##Define your data set first using an empty data set 
## with dose levels from 25 to 300 with increments 25
data &lt;- Data(doseGrid=seq(25,300,25))

##The design only incorporate DLE responses and no DLE samples are involved
##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##Then the escalation rule
tdNextBest &lt;- NextBestTD(targetDuringTrial=0.35,
                         targetEndOfTrial=0.3)

## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=36)
##Now specified the design with all the above information and starting with a dose of 25
design &lt;- TDDesign(model=model,
                   nextBest=tdNextBest,
                   stopping=myStopping,
                   increments=myIncrements,
                   cohortSize=mySize,
                   data=data,startingDose=25)
</code></pre>

<hr>
<h2 id='TDsamplesDesign'>Initialization function for 'TDsamplesDesign' class</h2><span id='topic+TDsamplesDesign'></span>

<h3>Description</h3>

<p>Initialization function for 'TDsamplesDesign' class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TDsamplesDesign(
  model,
  stopping,
  increments,
  PLcohortSize = CohortSizeConst(0L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TDsamplesDesign_+3A_model">model</code></td>
<td>
<p>see <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code></p>
</td></tr>
<tr><td><code id="TDsamplesDesign_+3A_stopping">stopping</code></td>
<td>
<p>see <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code></p>
</td></tr>
<tr><td><code id="TDsamplesDesign_+3A_increments">increments</code></td>
<td>
<p>see <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code></p>
</td></tr>
<tr><td><code id="TDsamplesDesign_+3A_plcohortsize">PLcohortSize</code></td>
<td>
<p>see <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code></p>
</td></tr>
<tr><td><code id="TDsamplesDesign_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="#topic+RuleDesign-class">RuleDesign</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+TDsamplesDesign-class">TDsamplesDesign</a></code> class object
</p>

<hr>
<h2 id='TDsamplesDesign-class'>This is a class of design based only on DLE responses using the 'LogisticIndepBeta' class model
and DLE samples are also used. 
In addition to the slots in the more simple <code><a href="#topic+RuleDesign-class">RuleDesign</a></code>,
objects of this class contain:</h2><span id='topic+TDsamplesDesign-class'></span><span id='topic+.TDsamplesDesign'></span>

<h3>Description</h3>

<p>This is a class of design based only on DLE responses using the 'LogisticIndepBeta' class model
and DLE samples are also used. 
In addition to the slots in the more simple <code><a href="#topic+RuleDesign-class">RuleDesign</a></code>,
objects of this class contain:
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>the pseudo DLE model to be used, an object class of 
<code><a href="#topic+ModelTox-class">ModelTox</a></code></p>
</dd>
<dt><code>stopping</code></dt><dd><p>stopping rule(s) for the trial, an object class of <code><a href="#topic+Stopping-class">Stopping</a></code></p>
</dd>
<dt><code>increments</code></dt><dd><p>how to control increments between dose levels, an object class of 
<code><a href="#topic+Increments-class">Increments</a></code></p>
</dd>
<dt><code>PLcohortSize</code></dt><dd><p>rules for the cohort sizes for placebo, if any planned
an object of class <code><a href="#topic+CohortSize-class">CohortSize</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>##Specified the design to run simulations
##The design comprises a model, the escalation rule, starting data, 
##a cohort size and a starting dose
##Define your data set first using an empty data set 
## with dose levels from 25 to 300 with increments 25
data &lt;- Data(doseGrid=seq(25,300,25))

##The design only incorporate DLE responses and DLE samples are involved
##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model
model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)

samples &lt;- mcmc(data=data, model=model, options=McmcOptions(burnin=100,step=2,samples=200))
##Then the escalation rule
tdNextBest&lt;-NextBestTDsamples(targetDuringTrial=0.35,targetEndOfTrial=0.3,
                              derive=function(TDsamples){quantile(TDsamples,probs=0.3)})
## The cohort size, size of 3 subjects
mySize &lt;-CohortSizeConst(size=3)
##Deifne the increments for the dose-escalation process
##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid
##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid
##This is to specified a maximum of 3-fold restriction in dose-esclation
myIncrements&lt;-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)), 
                                 increments=c(2,2))
##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached
myStopping &lt;- StoppingMinPatients(nPatients=36)
##Now specified the design with all the above information and starting with a dose of 25
design &lt;- TDsamplesDesign(model=model,
                          nextBest=tdNextBest,
                          stopping=myStopping,
                          increments=myIncrements,
                          cohortSize=mySize,
                          data=data,startingDose=25)




</code></pre>

<hr>
<h2 id='ThreePlusThreeDesign'>Creates a new 3+3 design object from a dose grid</h2><span id='topic+ThreePlusThreeDesign'></span>

<h3>Description</h3>

<p>Creates a new 3+3 design object from a dose grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreePlusThreeDesign(doseGrid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreePlusThreeDesign_+3A_dosegrid">doseGrid</code></td>
<td>
<p>the dose grid to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object of class <code><a href="#topic+RuleDesign-class">RuleDesign</a></code> with the
3+3 design
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove <a href="mailto:sabanesd@roche.com">sabanesd@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# inizialing a 3+3 design 
myDesign &lt;- ThreePlusThreeDesign(doseGrid=c(5, 10, 15, 25, 35, 50, 80))
  
  
</code></pre>

<hr>
<h2 id='update+2CData-method'>Update method for the &quot;Data&quot; class</h2><span id='topic+update+2CData-method'></span>

<h3>Description</h3>

<p>Add new data to the <code><a href="#topic+Data-class">Data</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Data'
update(
  object,
  x,
  y,
  ID = (if (length(object@ID)) max(object@ID) else 0L) + seq_along(y),
  newCohort = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CData-method_+3A_object">object</code></td>
<td>
<p>the old <code><a href="#topic+Data-class">Data</a></code> object</p>
</td></tr>
<tr><td><code id="update+2B2CData-method_+3A_x">x</code></td>
<td>
<p>the dose level (one level only!)</p>
</td></tr>
<tr><td><code id="update+2B2CData-method_+3A_y">y</code></td>
<td>
<p>the DLT vector (0/1 vector), for all patients in this cohort</p>
</td></tr>
<tr><td><code id="update+2B2CData-method_+3A_id">ID</code></td>
<td>
<p>the patient IDs</p>
</td></tr>
<tr><td><code id="update+2B2CData-method_+3A_newcohort">newCohort</code></td>
<td>
<p>logical: if TRUE (default) the new data are assigned
to a new cohort</p>
</td></tr>
<tr><td><code id="update+2B2CData-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new <code><a href="#topic+Data-class">Data</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data of class 'Data'
myData &lt;- Data(x=c(0.1,0.5,1.5,3,6,10,10,10),
               y=c(0,0,0,0,0,0,1,0),
               doseGrid=c(0.1,0.5,1.5,3,6,
                          seq(from=10,to=80,by=2)))

## update the data with a new cohort
myData &lt;- update(myData,
                 x=20,
                 y=c(0,1,1))


</code></pre>

<hr>
<h2 id='update+2CDataDual-method'>Update method for the &quot;DataDual&quot; class</h2><span id='topic+update+2CDataDual-method'></span>

<h3>Description</h3>

<p>Add new data to the <code><a href="#topic+DataDual-class">DataDual</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DataDual'
update(
  object,
  x,
  y,
  w,
  newCohort = TRUE,
  ID = (if (length(object@ID)) max(object@ID) else 0L) + seq_along(y),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CDataDual-method_+3A_object">object</code></td>
<td>
<p>the old <code><a href="#topic+DataDual-class">DataDual</a></code> object</p>
</td></tr>
<tr><td><code id="update+2B2CDataDual-method_+3A_x">x</code></td>
<td>
<p>the dose level (one level only!)</p>
</td></tr>
<tr><td><code id="update+2B2CDataDual-method_+3A_y">y</code></td>
<td>
<p>the DLT vector (0/1 vector), for all patients in this cohort</p>
</td></tr>
<tr><td><code id="update+2B2CDataDual-method_+3A_w">w</code></td>
<td>
<p>the biomarker vector, for all patients in this cohort</p>
</td></tr>
<tr><td><code id="update+2B2CDataDual-method_+3A_newcohort">newCohort</code></td>
<td>
<p>logical: if TRUE (default) the new data are assigned 
to a new cohort</p>
</td></tr>
<tr><td><code id="update+2B2CDataDual-method_+3A_id">ID</code></td>
<td>
<p>the patient IDs</p>
</td></tr>
<tr><td><code id="update+2B2CDataDual-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new <code><a href="#topic+DataDual-class">DataDual</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create some data of class 'DataDual'
myData &lt;- DataDual(x=c(0.1,0.5,1.5,3,6,10,10,10),
                   y=c(0,0,0,0,0,0,1,0),
                   w=rnorm(8),
                   doseGrid=c(0.1,0.5,1.5,3,6,
                              seq(from=10,to=80,by=2)))

## update the data with a new cohort
myData &lt;- update(myData,
                 x=20,
                 y=c(0,1,1),
                 w=c(0.4,1.2,2.2))

</code></pre>

<hr>
<h2 id='update+2CDataParts-method'>Update method for the &quot;DataParts&quot; class</h2><span id='topic+update+2CDataParts-method'></span>

<h3>Description</h3>

<p>Add new data to the <code><a href="#topic+DataParts-class">DataParts</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DataParts'
update(
  object,
  x,
  y,
  ID = (if (length(object@ID)) max(object@ID) else 0L) + seq_along(y),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CDataParts-method_+3A_object">object</code></td>
<td>
<p>the old <code><a href="#topic+DataParts-class">DataParts</a></code> object</p>
</td></tr>
<tr><td><code id="update+2B2CDataParts-method_+3A_x">x</code></td>
<td>
<p>the dose level (one level only!)</p>
</td></tr>
<tr><td><code id="update+2B2CDataParts-method_+3A_y">y</code></td>
<td>
<p>the DLT vector (0/1 vector), for all patients in this cohort</p>
</td></tr>
<tr><td><code id="update+2B2CDataParts-method_+3A_id">ID</code></td>
<td>
<p>the patient IDs</p>
</td></tr>
<tr><td><code id="update+2B2CDataParts-method_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new <code><a href="#topic+DataParts-class">DataParts</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create an object of class 'DataParts'
myData &lt;- DataParts(x=c(0.1,0.5,1.5),
                    y=c(0,0,0),
                    doseGrid=c(0.1,0.5,1.5,3,6,
                               seq(from=10,to=80,by=2)),
                    part=c(1L,1L,1L),
                    nextPart=1L,
                    part1Ladder=c(0.1,0.5,1.5,3,6,10))

# update the data with a new cohort
# to be noted that since we reached the last level from part1Ladder then
# nextPart is switched from '1' to '2'
myData &lt;- update(myData,
                 x=10,
                 y=c(0))


</code></pre>

<hr>
<h2 id='update+2CEffFlexi-method'>Update method for the 'EffFlexi' Model class. This is a method to update 
estimates both for the flexible form model and the random walk model (see details in
<code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class object) when new data 
or new observations of responses are available and added in.</h2><span id='topic+update+2CEffFlexi-method'></span>

<h3>Description</h3>

<p>Update method for the 'EffFlexi' Model class. This is a method to update 
estimates both for the flexible form model and the random walk model (see details in
<code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class object) when new data 
or new observations of responses are available and added in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EffFlexi'
update(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CEffFlexi-method_+3A_object">object</code></td>
<td>
<p>is the model which follow <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class object</p>
</td></tr>
<tr><td><code id="update+2B2CEffFlexi-method_+3A_data">data</code></td>
<td>
<p>all currently available data and responses of <code><a href="#topic+DataDual-class">DataDual</a></code>
class object</p>
</td></tr>
<tr><td><code id="update+2B2CEffFlexi-method_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new <code><a href="#topic+EffFlexi-class">EffFlexi</a></code> class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Update the 'EffFlexi' model with new data
## first define the data and the model
emptydata&lt;-DataDual(doseGrid=seq(25,300,25))
data&lt;-emptydata

Effmodel&lt;- EffFlexi(Eff=c(1.223, 2.513),Effdose=c(25,300),
                    sigma2=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),smooth="RW2",data=data)


##Then we have some new observations data
data&lt;-DataDual(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25))

##update the model to get new estimates
newEffModel &lt;- update(object=Effmodel,data=data)
</code></pre>

<hr>
<h2 id='update+2CEffloglog-method'>Update method for the 'Effloglog' Model class. This is a method to update the modal
estimates of the model parameters <code class="reqn">\theta_1</code> (theta1), <code class="reqn">\theta_2</code> (theta2)  and <code class="reqn">\nu</code> 
(nu, the precision of the efficacy responses) when new data 
or new observations of responses are available and added in.</h2><span id='topic+update+2CEffloglog-method'></span>

<h3>Description</h3>

<p>Update method for the 'Effloglog' Model class. This is a method to update the modal
estimates of the model parameters <code class="reqn">\theta_1</code> (theta1), <code class="reqn">\theta_2</code> (theta2)  and <code class="reqn">\nu</code> 
(nu, the precision of the efficacy responses) when new data 
or new observations of responses are available and added in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Effloglog'
update(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CEffloglog-method_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+Effloglog-class">Effloglog</a></code> class object</p>
</td></tr>
<tr><td><code id="update+2B2CEffloglog-method_+3A_data">data</code></td>
<td>
<p>all currently available data or responses of <code><a href="#topic+DataDual-class">DataDual</a></code>
class object</p>
</td></tr>
<tr><td><code id="update+2B2CEffloglog-method_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new <code><a href="#topic+Effloglog-class">Effloglog</a></code> class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Update the 'Effloglog' model with new data
## first define the data and the model
emptydata&lt;-DataDual(doseGrid=seq(25,300,25),placebo=FALSE)
data&lt;-emptydata

Effmodel&lt;-Effloglog(Eff=c(1.223,2.513),Effdose=c(25,300),nu=c(a=1,b=0.025),data=data,c=0)

##Then we have some new observations data
data&lt;-DataDual(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),
               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),
               doseGrid=seq(25,300,25))

##update the model to get new estimates
newEffModel &lt;- update(object=Effmodel,data=data)
</code></pre>

<hr>
<h2 id='update+2CLogisticIndepBeta-method'>Update method for the 'LogisticIndepBeta'Model class. This is a method to update the modal
estimates of the model parameters <code class="reqn">\phi_1</code> (phi1) and <code class="reqn">\phi_2</code> (phi2) when new data 
or new observations of responses are available and added in.</h2><span id='topic+update+2CLogisticIndepBeta-method'></span>

<h3>Description</h3>

<p>Update method for the 'LogisticIndepBeta'Model class. This is a method to update the modal
estimates of the model parameters <code class="reqn">\phi_1</code> (phi1) and <code class="reqn">\phi_2</code> (phi2) when new data 
or new observations of responses are available and added in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LogisticIndepBeta'
update(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CLogisticIndepBeta-method_+3A_object">object</code></td>
<td>
<p>the model of <code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code> class object</p>
</td></tr>
<tr><td><code id="update+2B2CLogisticIndepBeta-method_+3A_data">data</code></td>
<td>
<p>all currently availabvle of <code><a href="#topic+Data-class">Data</a></code> class object</p>
</td></tr>
<tr><td><code id="update+2B2CLogisticIndepBeta-method_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new <code><a href="#topic+LogisticIndepBeta-class">LogisticIndepBeta</a></code> class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Update the 'LogisticIndepBeta' model with new data
## first define the data and the model
emptydata&lt;-Data(doseGrid=seq(25,300,25))
data&lt;-emptydata

model&lt;-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)
##Then we have some new observations data
data&lt;-Data(x=c(25,50,50,75,100,100,225,300),
           y=c(0,0,0,0,1,1,1,1),
           doseGrid=seq(from=25,to=300,by=25))
##update the model to get new estimates
newModel &lt;- update(object=model,data=data)
</code></pre>

<hr>
<h2 id='Validate'>A Reference Class to help programming validation for new S4 classes</h2><span id='topic+Validate'></span>

<h3>Description</h3>

<p>Starting from an empty <code>msg</code> vector, with each check that is returning
FALSE the vector gets a new element - the string explaining the failure of
the validation
</p>


<h3>Fields</h3>


<dl>
<dt><code>msg</code></dt><dd><p>the message character vector</p>
</dd>
</dl>

<hr>
<h2 id='writeModel'>Creating a WinBUGS model file</h2><span id='topic+writeModel'></span>

<h3>Description</h3>

<p>Convert R function to a <span class="pkg">WinBUGS</span> model file. BUGS models follow
closely S syntax. It is therefore possible to write most BUGS models as R
functions.
As a difference, BUGS syntax allows truncation specification like this:
<code>dnorm(...) I(...)</code>  but this is illegal in R. To overcome this
incompatibility, use dummy operator <code>%_%</code> before <code>I(...)</code>:
<code>dnorm(...) %_% I(...)</code>. The dummy operator <code>%_%</code> will be
removed before the BUGS code is saved.
In S-PLUS, a warning is generated when the model function is defined if the
last statement in the model is an assignment. To avoid this warning, add the
line <code>invisible()</code> to the end of the model definition. This line will be
removed before the BUGS code is saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeModel(model, con = "model.bug", digits = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeModel_+3A_model">model</code></td>
<td>
<p>R function containing the BUGS model in the BUGS
model language, for minor differences see Section Details.</p>
</td></tr>
<tr><td><code id="writeModel_+3A_con">con</code></td>
<td>
<p>passed to <code><a href="base.html#topic+writeLines">writeLines</a></code> which actually writes the
model file</p>
</td></tr>
<tr><td><code id="writeModel_+3A_digits">digits</code></td>
<td>
<p>number of significant digits used for <span class="pkg">WinBUGS</span>
input, see <code><a href="base.html#topic+formatC">formatC</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, but as a side effect, the model file is written
</p>


<h3>Author(s)</h3>

<p>original idea by Jouni Kerman, modified by Uwe Ligges,
Daniel Sabanes Bove removed S-PLUS part
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
