<!DOCTYPE html><html><head><title>Help for package statisfactory</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {statisfactory}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#statisfactory'><p>statisfactory: Statistical and Geometrical Tools</p></a></li>
<li><a href='#.removeRedundantModels'><p>Remove redundant model forms from a list of models</p></a></li>
<li><a href='#.removeVerbotenVariableCombos'><p>Remove formula with unwanted combinations of variables.</p></a></li>
<li><a href='#art'><p>Aligned rank transform of non-parametric data for further analysis using ANOVA</p></a></li>
<li><a href='#backTransPCA'><p>&quot;Back-transform&quot; PCA scores to their original values</p></a></li>
<li><a href='#countConnected'><p>Count number of contiguous &quot;blocks&quot; of cells</p></a></li>
<li><a href='#euclid'><p>Euclidean distance</p></a></li>
<li><a href='#fuzzyJaccard'><p>Fuzzy Jaccard index</p></a></li>
<li><a href='#geoMean'><p>Geometric mean</p></a></li>
<li><a href='#hist2d'><p>Two-dimensional histogram</p></a></li>
<li><a href='#histOverlap'><p>Count number of values in overlapping bins</p></a></li>
<li><a href='#invLogitAdj'><p>Inverse logit is robust to cases that equal 0 or 1</p></a></li>
<li><a href='#logitAdj'><p>A logit() function robust to values that equal 0 or 1</p></a></li>
<li><a href='#makeFormulae'><p>Make all possible formula</p></a></li>
<li><a href='#mmode'><p>Calculate the mode of numeric, character, or factor data</p></a></li>
<li><a href='#nagelR2'><p>Nagelkerge's / Craig &amp; Uhler's R2</p></a></li>
<li><a href='#psum'><p>Element-by-element sum</p></a></li>
<li><a href='#rankMulti'><p>A multivariate adaptation of the rank() function</p></a></li>
<li><a href='#rmsd'><p>Root-mean-square deviation (error)</p></a></li>
<li><a href='#sampleAcross'><p>Permute values across two vectors or columns in two data frames or matrices</p></a></li>
<li><a href='#sampleStrat'><p>Stratified randomization</p></a></li>
<li><a href='#se'><p>Standard error</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical and Geometrical Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam B. Smith &lt;adam.smith@mobot.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of statistical and geometrical tools
	including the aligned rank transform (ART; Higgins et al.
	1990 &lt;<a href="https://doi.org/10.4148%2F2475-7772.1443">doi:10.4148/2475-7772.1443</a>&gt;; Peterson 2002
	&lt;<a href="https://doi.org/10.22237%2Fjmasm%2F1020255240">doi:10.22237/jmasm/1020255240</a>&gt;; Wobbrock et al. 2011
	&lt;<a href="https://doi.org/10.1145%2F1978942.1978963">doi:10.1145/1978942.1978963</a>&gt;), 2-D histograms and
	histograms with overlapping bins, a function for making all
	possible formulae within a set of constraints, amongst others.</td>
</tr>
<tr>
<td>Imports:</td>
<td>omnibus</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/adamlilith/statisfactory">https://github.com/adamlilith/statisfactory</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 18:00:59 UTC; ASmith</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam B. Smith <a href="https://orcid.org/0000-0002-6420-1659"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 22:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='statisfactory'>statisfactory: Statistical and Geometrical Tools</h2><span id='topic+statisfactory'></span><span id='topic+statisfactory-package'></span>

<h3>Description</h3>

<p>This package contains various statistical tools and helper functions.
</p>


<h3>Details</h3>

<p>Create an issue on <a href="https://github.com/adamlilith/statisfactory/issues">GitHub</a>.
</p>


<h3>Utilities</h3>

<p><code><a href="#topic+makeFormulae">makeFormulae</a></code>: Make all possible formula <br />
</p>


<h3>Calculations</h3>

<p><code><a href="#topic+geoMean">geoMean</a></code>: Geometric mean <br />
<code><a href="#topic+invLogitAdj">invLogitAdj</a></code>: Inverse logit transform robust to 0's or 1's <br />
<code><a href="#topic+logitAdj">logitAdj</a></code>: Logit transform robust to 0's and 1's <br />
<code><a href="#topic+psum">psum</a></code>: Element-wise sum (like pmin and pmax) <br />
<code><a href="#topic+se">se</a></code>: Standard error of the mean <br />
</p>


<h3>Distance measures</h3>

<p><code><a href="#topic+euclid">euclid</a></code>: Euclidean distance <br />
<code><a href="#topic+fuzzyJaccard">fuzzyJaccard</a></code>: Fuzzy Jaccard index <br />
</p>


<h3>Data transformation</h3>

<p><code><a href="#topic+art">art</a></code>: Aligned rank transform for using ANOVAs on rank data <br />
<code><a href="#topic+rankMulti">rankMulti</a></code>: Rank values by multiple tie-breaking criteria <br />
</p>


<h3>Principal component analysis (PCA)</h3>

<p><code><a href="#topic+backTransPCA">backTransPCA</a></code>: &quot;Back-transform&quot; PCA scores to their original values <br />
</p>


<h3>Geometry</h3>

<p><code><a href="#topic+countConnected">countConnected</a></code>: Count number of contiguous &quot;blocks&quot; of cells <br />
</p>


<h3>Sampling</h3>

<p><code><a href="#topic+sampleAcross">sampleAcross</a></code>: Permute values across two vectors or columns in two data frames or matrices <br />
<code><a href="#topic+sampleStrat">sampleStrat</a></code>: Sample values stratified by one or more other variables <br />
</p>


<h3>Statistics</h3>

<p><code><a href="#topic+nagelR2">nagelR2</a></code>: Nagelkerge's / Craig &amp; Uhler's R2 <br />
</p>


<h3>Histograms</h3>

<p><code><a href="#topic+histOverlap">histOverlap</a></code>: Histogram with overlapping or arbitrary bins <br />
<code><a href="#topic+hist2d">hist2d</a></code>: Two-dimensional histogram <br />
</p>


<h3>Author(s)</h3>

<p>Adam B. Smith
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/adamlilith/statisfactory">https://github.com/adamlilith/statisfactory</a>
</p>
</li></ul>


<hr>
<h2 id='.removeRedundantModels'>Remove redundant model forms from a list of models</h2><span id='topic+.removeRedundantModels'></span>

<h3>Description</h3>

<p>This function takes as an argument a list of character vectors. Each set of character vectors represents terms in a formula, and each element of a specific term in that formula. It returns a possibly shortened list with vectors culled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.removeRedundantModels(formList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".removeRedundantModels_+3A_formlist">formList</code></td>
<td>
<p>List of character variables each in formula format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List.
</p>

<hr>
<h2 id='.removeVerbotenVariableCombos'>Remove formula with unwanted combinations of variables.</h2><span id='topic+.removeVerbotenVariableCombos'></span>

<h3>Description</h3>

<p>This function takes as an argument a list of character strings representing formulae and returns a potentially shortened list without formulae containing certain combinations of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.removeVerbotenVariableCombos(forms, verbotenCombos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".removeVerbotenVariableCombos_+3A_forms">forms</code></td>
<td>
<p>List of characters each representing a formula.</p>
</td></tr>
<tr><td><code id=".removeVerbotenVariableCombos_+3A_verbotencombos">verbotenCombos</code></td>
<td>
<p>Either <code>NULL</code> (default) in which case <code>forms</code> is returned without any manipulation. Alternatively, this argument can be used to specify variables or terms that should not occur in the same formula. The argument <code>verbotenCombos</code> is composed of a list of lists. Each sublist comprises names of two variables or terms stated as characters followed by two logical values (<code>TRUE</code>/<code>FALSE</code>). The second variable/term is removed from the model if the first is in the model. If the first logical value is <code>TRUE</code> then the second variable/term is removed if the first variable appears alone in the formula (e.g., not in an interaction with another variable). If the first logical value is <code>FALSE</code> then the second variable/term is removed if the first variable/term appears in any term (e.g., as an interaction with another term). 
Examples: </p>

<ul>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', TRUE, TRUE))</code>: Removes <code>x2</code> if <code>x1</code> occurs in the model as a linear term.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', FALSE, TRUE))</code>: Removes the linear term <code>x2</code> if <code>x1</code> occurred in <em>any</em> term in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', TRUE, FALSE))</code>: Removes <em>any</em> term with <code>x2</code> if the linear term <code>x1</code> occurred in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', FALSE, FALSE))</code>: Removes any term with <code>x2</code> if any term had <code>x1</code>.
</p>
</li></ul>

<p>Quadratic terms and interaction terms can also be stated, so: </p>

<ul>
<li> <p><code>verbotenCombos=list(list('x1', 'x1:x2', TRUE, TRUE))</code>: Removes <code>x1:x2</code> if <code>x1</code> were in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'I(x2^2)', TRUE, TRUE))</code>: Removes <code>I(x2^2)</code>.
</p>
</li></ul>

<p>Note that inexact matching can remove terms incorrectly if inexact matches exist between names of terms or variables.  For example, if using an inexact match, then <code>verbotenCombos(list('x1', 'x2', FALSE, FALSE))</code> will find any term that has an <code>x1</code> (e.g., <code>x11</code>) and if it exists, remove any term with an <code>x2</code> (e.g., <code>x25</code>). Note that reciprocally removing predictors makes little sense since, for example <code>list(list('x1', 'x2', FALSE, FALSE), list('x2', 'x1', FALSE, FALSE))</code> removes all formulae with <code>x2</code> if <code>x1</code> appears then tries to find any models with <code>x2</code> that have <code>x1</code> (of which there are none).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character elements representing formulae.
</p>

<hr>
<h2 id='art'>Aligned rank transform of non-parametric data for further analysis using ANOVA</h2><span id='topic+art'></span>

<h3>Description</h3>

<p>This function performs the aligned rank transforms on non-parametric data which is useful for further analysis using parametric techniques like ANOVA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>art(
  x,
  response = names(x)[1],
  factors = names(x)[2:ncol(x)],
  subject = NULL,
  fun = function(x) mean(x, na.rm = TRUE),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="art_+3A_x">x</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="art_+3A_response">response</code></td>
<td>
<p>Character. Names of column of <code>x</code> that has response variable (default is to use the first column).</p>
</td></tr>
<tr><td><code id="art_+3A_factors">factors</code></td>
<td>
<p>Character list. Names of columns of <code>x</code> used to define factors and levels (default is to use all columns except for the first).</p>
</td></tr>
<tr><td><code id="art_+3A_subject">subject</code></td>
<td>
<p><code>NULL</code> or character. Name of column in <code>x</code> that has the subject variable. If <code>NULL</code> then this is ignored. If specified, residuals are calculated for each cell defined by factors, <em>not</em> by subject and factors, but aligning is done using both factors and subject.</p>
</td></tr>
<tr><td><code id="art_+3A_fun">fun</code></td>
<td>
<p>Function. Function used to calculate cell centering statistic (the default is to use: <code>mean</code> with <code>na.rm=TRUE</code>). The function can be any that handles a list of one or more elements.</p>
</td></tr>
<tr><td><code id="art_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE then display progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function successfully re-creates rankings given by <strong>ARTool</strong> (Wobbrock et al. 2011) of data in Higgins et al. (1990) for data with 2 and 3 factors.
If <code>response</code> is ranks and the set of ranks in each cell is the same (e.g., each cell has ranks 1, 2, and 3, but not necessarily in that order), then all values will be equal across the different ART variables.  This occurs because the center of each cell (e.g., the mean) is the same as the grand mean, so the aligned values are simply the residuals. An ANOVA on this data yields no variance across cells, so the F tests are invalid.
</p>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>References</h3>

<p>Higgins, J.J., Blair, R.C., and Tashtoush, S.  1990.  The aligned rank transform procedure.  <em>Proceedings of the Conference on Applied Statistics in Agriculture.</em>  Manhattan, Kansas: Kansas State University, pp. 185-195. <a href="https://doi.org/10.4148/2475-7772.1443">doi:10.4148/2475-7772.1443</a>
</p>
<p>Peterson, K.  2002.  Six modifications of the aligned rank transform test for interaction. <em>Journal of Modern Applied Statistical Methods</em> 1:100-109. <a href="https://doi.org/10.22237/jmasm/1020255240">doi:10.22237/jmasm/1020255240</a>
</p>
<p>Wobbrock, J.O., Findlater, L., Gergle, D., and Higgins, J.J.  2011. The aligned rank transform for nonparametric factorial analysis using only ANOVA procedures.  <em>Proceedings of the ACM Conference on Human Factors in Computing Systems (CHI 2011).</em> Vancouver, British Columbia (May 7-12, 2011). New York: ACM Press, pp. 143-146. <a href="https://doi.org/10.1145/1978942.1978963">doi:10.1145/1978942.1978963</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
   subject=c('a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c'),
   factor1=c('up', 'up', 'up', 'up', 'up', 'up', 'down', 'down', 'down', 'down',
      'down', 'down'),
   factor2=c('high', 'med', 'low', 'high', 'med', 'low', 'high', 'med', 'low', 'high',
      'med', 'low'),
   response=c(1, 17, 1, 1, 0, 4, 5, 6, 3, 7, 100, 70)
)
art(x=x, response='response', factors=c('factor1', 'factor2'))
</code></pre>

<hr>
<h2 id='backTransPCA'>&quot;Back-transform&quot; PCA scores to their original values</h2><span id='topic+backTransPCA'></span>

<h3>Description</h3>

<p>This function back-transforms principal component scores to their original values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backTransPCA(pca, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backTransPCA_+3A_pca">pca</code></td>
<td>
<p>Object of class <code>prcomp</code>.</p>
</td></tr>
<tr><td><code id="backTransPCA_+3A_x">x</code></td>
<td>
<p>Either <code>NULL</code> (default) or a vector of PC scores. If <code>NULL</code>, then the scores from the PCA object are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
	x1 = 1:20 + rnorm(20),
	x2 = 1:20 + rnorm(20, 0, 5),
	x3 = sample(20, 20)
)

pca1 &lt;- prcomp(x, center=FALSE, scale=FALSE)
pca2 &lt;- prcomp(x, center=TRUE, scale=FALSE)
pca3 &lt;- prcomp(x, center=TRUE, scale=TRUE)

backTransPCA(pca1)
backTransPCA(pca2)
backTransPCA(pca3)

</code></pre>

<hr>
<h2 id='countConnected'>Count number of contiguous &quot;blocks&quot; of cells</h2><span id='topic+countConnected'></span>

<h3>Description</h3>

<p>This function calculates the number of objects formed by one or more adjacent cells that touch on their edges (i.e., not just at a corner). One way to solve this (inefficiently) is using a &quot;ink-spreading&quot; algorithm that accumulates adjacent cells until all are accounted for, then counts this as a single component. This function uses an efficient solution based on the Euler characteristic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countConnected(x, count = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countConnected_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="countConnected_+3A_count">count</code></td>
<td>
<p>Value to count as a &quot;presence&quot; in the matrix. All other values will be assumed to be not part of a component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired by an answer by Alon Amit to the question on Quora, &quot;<em>What are some programming problems that look hard at a first glance but are actually easy?</em>&quot;.
</p>


<h3>Value</h3>

<p>An integer (the number of connected, non-conterminous components).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v &lt;- c(
1, 1, 0, 1,
1, 1, 0, 0,
1, 0, 0, 0,
0, 0, 0, 1,
0, 0, 1, 1,
1, 0, 0, 0,
0, 0, 0, 0)

x &lt;- matrix(v, ncol=4, byrow=TRUE)
x

countConnected(x)

## Not run: 
# will break because of connection at a vertex
v &lt;- c(
1, 1, 0, 1,
1, 1, 0, 0,
1, 0, 0, 0,
0, 0, 0, 1,
0, 0, 1, 1,
1, 0, 0, 0,
0, 1, 0, 0)

x &lt;- matrix(v, ncol=4, byrow=TRUE)
x

countConnected(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='euclid'>Euclidean distance</h2><span id='topic+euclid'></span>

<h3>Description</h3>

<p>Euclidian distance in one or more dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclid(a, b, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclid_+3A_a">a</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="euclid_+3A_b">b</code></td>
<td>
<p>Numeric vector of same length as <code>a</code>.</p>
</td></tr>
<tr><td><code id="euclid_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>TRUE</code>, calculation ignores <code>NA</code>'s in <code>a</code> and/or <code>b</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
euclid(0, 5)
euclid(c(0, 0), c(1, 1))
euclid(c(0, 0, 0), c(1, 1, 1))

</code></pre>

<hr>
<h2 id='fuzzyJaccard'>Fuzzy Jaccard index</h2><span id='topic+fuzzyJaccard'></span>

<h3>Description</h3>

<p>Calculates the fuzzy Jaccard index. The &quot;normal&quot; Jaccard index is given by <code>sum(A intersect B) / sum(A union B)</code>, where <code>A</code> and <code>B</code> are sets. Typically, <code>A</code> and <code>B</code> are binary outcomes, but the fuzzy version can accommodate values in [0, 1] and/or binary outcomes. The computationally efficient and equivalent method is <code>sum(pmin(A, B)) / (sum(A) + sum(B) - sum(pmin(A, B)))</code>. If <code>A</code> and <code>B</code> and both binary, the outcome is the same as the &quot;plain&quot; Jaccard index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzyJaccard(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzyJaccard_+3A_a">a</code>, <code id="fuzzyJaccard_+3A_b">b</code></td>
<td>
<p>Vectors of binary and/or values in the range [0, 1]. The vectors must be of the same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric in the range [0, 1].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(0.3, 0, 0.9, 0.5)
b &lt;- c(1, 1, 0, 0)
fuzzyJaccard(a, b)

</code></pre>

<hr>
<h2 id='geoMean'>Geometric mean</h2><span id='topic+geoMean'></span>

<h3>Description</h3>

<p>Geometric mean, with optional removal of <code>NA</code>'s and propagation of zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoMean(x, prop0 = FALSE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geoMean_+3A_x">x</code></td>
<td>
<p>Numeric list.</p>
</td></tr>
<tr><td><code id="geoMean_+3A_prop0">prop0</code></td>
<td>
<p>Logical, if <code>FALSE</code> (default) then if any value in <code>x</code> equals 0 then the output will be zero. If <code>TRUE</code>, then zero values will be removed before calculation of the geometric mean.</p>
</td></tr>
<tr><td><code id="geoMean_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code> then remove <code>NA</code> values first.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adapted from Paul McMurdie on <a href="https://stackoverflow.com/questions/2602583/geometric-mean-is-there-a-built-in">StackOverflow</a>.
</p>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0.01, 1, by=0.01)
mean(x)
geoMean(x)
x &lt;- seq(0, 1, by=0.01)
mean(x)
geoMean(x)
geoMean(x, prop0=TRUE)

</code></pre>

<hr>
<h2 id='hist2d'>Two-dimensional histogram</h2><span id='topic+hist2d'></span>

<h3>Description</h3>

<p>Two-dimensional histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist2d(x, breaks1 = "Sturges", breaks2 = "Sturges", right = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist2d_+3A_x">x</code></td>
<td>
<p>Data frame or matrix with at least two columns. Only first two columns are used to tally frequencies.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_breaks1">breaks1</code></td>
<td>
<p>One of the following describing how breaks for the first variable are calculated:
</p>

<ul>
<li><p> Numeric vector: Breakpoints for bins for the first variable.
</p>
</li>
<li><p> Single integer: The number of bins into which to tally values of the first variable.
</p>
</li>
<li><p> Function: To compute the vector of breakpoints.
</p>
</li>
<li><p> Function: To compute the number of cells. Used as a suggestion only (see <code><a href="graphics.html#topic+hist">hist</a></code>).
</p>
</li>
<li><p> Character: The name of a function to compute the number of cells (see the <em>Details</em> section in <code><a href="graphics.html#topic+hist">hist</a></code>). Used as a suggestion only (see <code><a href="graphics.html#topic+hist">hist</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="hist2d_+3A_breaks2">breaks2</code></td>
<td>
<p>Same as <code>breaks1</code> but for the second variable.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_right">right</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then use left-open and right-closed intervals.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>matrix</code> and <code>histogram2d</code>. Columns pertain to bins of <code>x1</code> and rows <code>x2</code>. Column names and row names are mid-points of bins.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 &lt;- rnorm(1000)
x2 &lt;- 0.5 * x1 * rnorm(1000)
x &lt;- data.frame(x1=x1, x2=x2)
hist2d(x)

</code></pre>

<hr>
<h2 id='histOverlap'>Count number of values in overlapping bins</h2><span id='topic+histOverlap'></span>

<h3>Description</h3>

<p>Histogram of number of values in overlapping bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histOverlap(x, breaks, right = TRUE, graph = TRUE, indices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histOverlap_+3A_x">x</code></td>
<td>
<p>Numeric values.</p>
</td></tr>
<tr><td><code id="histOverlap_+3A_breaks">breaks</code></td>
<td>
<p>One integer, three numeric values, or a matrix or data frame with at least two columns:
</p>

<ul>
<li><p> Single integer: The number of overlapping bins into which to enumerate values of <code>x</code>. The range of <code>x</code> covered by the bins bins will extend from the least value minus 2.5 percent of the range to the largest value plus 2.5 percent of the range.
</p>
</li>
<li><p> Three numeric values: The first two values are the range of covered by the bins (least and greatest). The third value is the number of bins.
</p>
</li>
<li><p> Matrix or data frame with at least two columns. Each row corresponds to a different bin.  The first column represents the minimum values of each bin and the second column the maximum value. Subsequent columns are ignored. Note that by using this option arbitrary bins can be used&ndash;they need not overlap or even be continuous in coverage.
</p>
</li></ul>
</td></tr>
<tr><td><code id="histOverlap_+3A_right">right</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), then use left-open and right-closed intervals.</p>
</td></tr>
<tr><td><code id="histOverlap_+3A_graph">graph</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), then plot frequencies.</p>
</td></tr>
<tr><td><code id="histOverlap_+3A_indices">indices</code></td>
<td>
<p>Logical, if <code>TRUE</code>, then the output will have an attribute which is a list item with one element per bin in the output, with the indices of <code>x</code> that fall in each bin. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
x &lt;- rnorm(1000)
histOverlap(x, breaks=10, graph=TRUE)
histOverlap(x, breaks=c(0, 1, 10), graph=TRUE)
mat &lt;- matrix(c(seq(0, 1, by=0.1), seq(0.3, 1.3, by=0.1)), ncol=2)
histOverlap(x, breaks=mat, graph=TRUE)
histOverlap(x, breaks=mat, indices=TRUE)

</code></pre>

<hr>
<h2 id='invLogitAdj'>Inverse logit is robust to cases that equal 0 or 1</h2><span id='topic+invLogitAdj'></span>

<h3>Description</h3>

<p>This function is the inverse of <code><a href="#topic+logitAdj">logitAdj</a></code>. That function calculates the logit of values but is robust to cases where the operand is 0 or 1. The adjusted inverse logit is equal to <code>(base^x + epsilon * base^x - epsilon) / (base^x + 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invLogitAdj(x, epsilon = 0.01, base = 10, auto = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invLogitAdj_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="invLogitAdj_+3A_epsilon">epsilon</code></td>
<td>
<p>Value or character. If a numeric value (typically ~0.01 or smaller), then this is added/subtracted from <code>x</code> to ensure log of 0 or 1 is not taken. If equal to <code>'auto'</code> then the value of <code>epsilon</code> is taken from the attributes of <code>x</code>. If <code>x</code> has no such attribute, a warning is given and a value of 0.01 is used.</p>
</td></tr>
<tr><td><code id="invLogitAdj_+3A_base">base</code></td>
<td>
<p>Base of logarithm. Use <code>base=exp(1)</code> for base <code>e</code>.</p>
</td></tr>
<tr><td><code id="invLogitAdj_+3A_auto">auto</code></td>
<td>
<p>If <code>TRUE</code> then if the attributes of <code>x</code> have slots named <code>epsilon</code> and <code>base</code> then use these instead of the user-supplied values of <code>epsilon</code> and <code>base</code>. If they do not appear as attributes of <code>x</code> but <code>auto</code> is <code>TRUE</code> then the function prints warnings and uses 0.01 and 10, respectively. If <code>FALSE</code> (default) then use the user-supplied values of <code>epsilon</code> and <code>base</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logitAdj">logitAdj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0, 1, by=0.1)
y &lt;- logitAdj(x)
xx &lt;- invLogitAdj(y, auto = TRUE)

</code></pre>

<hr>
<h2 id='logitAdj'>A logit() function robust to values that equal 0 or 1</h2><span id='topic+logitAdj'></span>

<h3>Description</h3>

<p>This function returns the logit value (<code>log(x / (1 - x))</code>) where a small value can be added to <code>x</code> to avoid problems of calculating the log when <code>x</code> equals 0 or 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logitAdj(x, epsilon = 0.01, base = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logitAdj_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="logitAdj_+3A_epsilon">epsilon</code></td>
<td>
<p>Value to add/subtract from x to ensure log of 0 or 1 is not taken (usually a small number). If <code>NULL</code>, then the smallest value of any <code>x</code> &gt; 0 and <code>1 - x</code> for all <code>x</code> &lt; 1 is used.</p>
</td></tr>
<tr><td><code id="logitAdj_+3A_base">base</code></td>
<td>
<p>Base of logarithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric equal to <code>log((x + epsilon)/(1 - x + epsilon), base=base)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invLogitAdj">invLogitAdj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
x &lt;- seq(0, 1, by=0.01)
logitAdj(x)
logitAdj(x, 0.001)
invLogitAdj(x, 0.001)
invLogitAdj(x, 0.001)
invLogitAdj(x, auto = TRUE)

</code></pre>

<hr>
<h2 id='makeFormulae'>Make all possible formula</h2><span id='topic+makeFormulae'></span>

<h3>Description</h3>

<p>This functions creates a list of formulae that contain all possible linear, quadratic, and two-way interaction terms from individual terms in an object of class <code>formula</code>. The formulae respect marginality conditions (i.e., they will always include lower-order terms if higher-order terms are included in a formula). Note that if there are more than several terms (i.e., &gt;=3) and interactions and/or quadratic terms are desired, then formula generation may take a long time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFormulae(
  formula,
  intercept = TRUE,
  interceptOnly = TRUE,
  linearOnly = TRUE,
  quad = TRUE,
  ia = TRUE,
  verboten = NULL,
  verbotenCombos = NULL,
  minTerms = NULL,
  maxTerms = NULL,
  returnFx = stats::as.formula,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFormulae_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object with <em>just</em> linear terms.</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_intercept">intercept</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then all models include an intercept.  If <code>FALSE</code> then then formula will specify that regression occurs through the origin (e.g., <code>y ~ -1 + etc.</code>)</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_interceptonly">interceptOnly</code></td>
<td>
<p>Logical, if <code>TRUE</code> then an intercept-only model is included in final set.</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_linearonly">linearOnly</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then models with only linear terms are included in final set (plus other kinds of models if desired).</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_quad">quad</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), then include quadratic terms.</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_ia">ia</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), then include 2-way interaction terms.</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_verboten">verboten</code></td>
<td>
<p>Character vector of terms that should not appear in the models. Ignored if <code>NULL</code> (default). Note that using this argument only makes sense if interaction or quadratic terms are specified (if you don't a particular term to appear anywhere in the model it will be faster to remove it from <code>formula</code>).</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_verbotencombos">verbotenCombos</code></td>
<td>
<p>List of lists, used to specify specific combinations of terms that should not occur together. See section <em>Details</em> below. Ignored if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_minterms">minTerms</code></td>
<td>
<p>Either a positive integer representing the minimum number of terms required to be in a model, <em>or</em> <code>NULL</code> (default) in which case the smallest model can have just one term.</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_maxterms">maxTerms</code></td>
<td>
<p>Either a positive integer representing the maximum number of terms allowed to be in a model, <em>or</em> <code>NULL</code> (default) in which case there is no practical limit on the number of terms in a model.</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_returnfx">returnFx</code></td>
<td>
<p>Function used to generate the class of the output objects. Sensible functions in include <code><a href="stats.html#topic+as.formula">as.formula</a></code> (default) or <code><a href="base.html#topic+as.character">as.character</a></code>.</p>
</td></tr>
<tr><td><code id="makeFormulae_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code> then display progress. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>verbotenCombos</code> can be used to specify variables or terms that should not occur in the same formula. The argument <code>verbotenCombos</code> is composed of a list of lists. Each sublist comprises names of two variables or terms stated as characters followed by two logical values (<code>TRUE</code>/<code>FALSE</code>). The second variable/term is removed from the model if the first is in the model. If the first logical value is <code>TRUE</code> then the second variable/term is removed if the first variable appears alone in the formula (e.g., not in an interaction with another variable). If the first logical value is <code>FALSE</code> then the second variable/term is removed if the first variable/term appears in any term (e.g., as an interaction with another term).
Examples: </p>

<ul>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', TRUE, TRUE))</code>: Removes <code>x2</code> if <code>x1</code> occurs in the model as a linear term.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', FALSE, TRUE))</code>: Removes the linear term <code>x2</code> if <code>x1</code> occurrs in <em>any</em> term in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', TRUE, FALSE))</code>: Removes <em>any</em> term with <code>x2</code> if the linear term <code>x1</code> occurrs in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', FALSE, FALSE))</code>: Removes any term with <code>x2</code> if any term has <code>x1</code>.
</p>
</li></ul>

<p>Quadratic terms and interaction terms can also be used, so: </p>

<ul>
<li> <p><code>verbotenCombos=list(list('x1', 'x1:x2', TRUE, TRUE))</code>: Removes <code>x1:x2</code> if <code>x1</code> were in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'I(x2^2)', TRUE, TRUE))</code>: Removes <code>I(x2^2)</code> if <code>x1</code> occurs in the model.
</p>
</li></ul>

<p>Note that inexact matching can remove terms incorrectly if inexact matches exist between names of terms or variables.  For example, if using an inexact match, then <code>verbotenCombos(list('x1', 'x2', FALSE, FALSE))</code> will find any term that has an <code>x1</code> (e.g., <code>x11</code>) and if it exists, remove any term with an <code>x2</code> (e.g., <code>x25</code>). Note that reciprocally removing predictors makes little sense since, for example <code>list(list('x1', 'x2', FALSE, FALSE), list('x2', 'x1', FALSE, FALSE))</code> removes all formulae with <code>x2</code> if <code>x1</code> appears then tries to find any models with <code>x2</code> that have <code>x1</code> (of which there will be none after the first set is removed).
</p>


<h3>Value</h3>

<p>A vector of formulae.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
makeFormulae(y ~ x1 + x2 + x3, maxTerms=3)
makeFormulae(y ~ x1 + x2 + x3, ia=FALSE, maxTerms=3)
verboten &lt;- c('x1:x2', 'I(x1^2)')
makeFormulae(y ~ x1 + x2 + x3, verboten=verboten, maxTerms=3)

makeFormulae(y ~ x1 + x2 + x3, maxTerms=3)
verbotenCombos &lt;- list(list('x1', 'x2', TRUE, TRUE))
makeFormulae(y ~ x1 + x2 + x3, verbotenCombos=verbotenCombos, maxTerms=3)

</code></pre>

<hr>
<h2 id='mmode'>Calculate the mode of numeric, character, or factor data</h2><span id='topic+mmode'></span>

<h3>Description</h3>

<p>Calculate the mode of numeric, character, or factor data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmode(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmode_+3A_x">x</code></td>
<td>
<p>Numeric, character, or factor vector.</p>
</td></tr>
<tr><td><code id="mmode_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>TRUE</code> then remove <code>NA</code>s first. Otherwise fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, character, or factor value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mmode(round(10 * rnorm(1000, 2)))
mmode(c('a', 'b', 'b', 'b', 'c', 'd', 'd'))

</code></pre>

<hr>
<h2 id='nagelR2'>Nagelkerge's / Craig &amp; Uhler's R2</h2><span id='topic+nagelR2'></span>

<h3>Description</h3>

<p>Nagelkerge's / Craig &amp; Uhler's R2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nagelR2(likeNull, likeFull, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nagelR2_+3A_likenull">likeNull</code></td>
<td>
<p>Likelihood (not log-likelihood) of the null model or an object of class <code>logLik</code> with log-likelihood of the null model (usually an intercept-only model).</p>
</td></tr>
<tr><td><code id="nagelR2_+3A_likefull">likeFull</code></td>
<td>
<p>Likelihood (not log-likelihood) of the &quot;full&quot; model or an object of class <code>logLik</code> with log-likelihood of the &quot;full&quot; model (usually a model with covariates).</p>
</td></tr>
<tr><td><code id="nagelR2_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create data
x &lt;- 1:100
y &lt;- 2 + 1.7 * x + rnorm(100, 0, 30)

# models
nullModel &lt;- lm(y ~ 1)
fullModel &lt;- lm(y ~ x)

# plot
plot(x, y)
abline(nullModel, col='red')
abline(fullModel, col='blue')
legend('bottomright', legend=c('Null', 'Full'), lwd=1, col=c('red', 'blue'))

# R2
likeNull &lt;- exp(as.numeric(logLik(nullModel)))
likeFull &lt;- exp(as.numeric(logLik(fullModel)))
nagelR2(likeNull, likeFull, 100)
</code></pre>

<hr>
<h2 id='psum'>Element-by-element sum</h2><span id='topic+psum'></span>

<h3>Description</h3>

<p>This function is similar to <code><a href="base.html#topic+pmax">pmax</a></code> or <code><a href="base.html#topic+pmin">pmin</a></code>, except that it returns the element-wise sum of values. If the input is a <code>matrix</code> or <code>data.frame</code>, the output is the same as <code><a href="base.html#topic+colSums">colSums</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psum(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psum_+3A_...">...</code></td>
<td>
<p>A set of vectors of the same length, a <code>matrix</code>, or a <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="psum_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (default), return <code>NA</code> if any element in a set is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adapted from answer by Ben Bolker on <a href="https://stackoverflow.com/questions/13123638/there-is-pmin-and-pmax-each-taking-na-rm-why-no-psum">StackOverflow</a>.
</p>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 &lt;- 1:10
x2 &lt;- runif(10)
psum(x1, x2)

x &lt;- cbind(x1, x2)
psum(x)

x2[3] &lt;- NA
psum(x1, x2)
psum(x1, x2, na.rm=TRUE)

</code></pre>

<hr>
<h2 id='rankMulti'>A multivariate adaptation of the rank() function</h2><span id='topic+rankMulti'></span>

<h3>Description</h3>

<p>This function ranks values in a data frame or matrix by more than one field, with ties in one field broken by subsequent fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankMulti(x, cols = 1:ncol(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankMulti_+3A_x">x</code></td>
<td>
<p>Data frame or matrix.</p>
</td></tr>
<tr><td><code id="rankMulti_+3A_cols">cols</code></td>
<td>
<p>Names or indices of columns by which to rank, with first one gaining preference over the second, second over the third, etc.</p>
</td></tr>
<tr><td><code id="rankMulti_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="base.html#topic+rank">rank</a></code>.  Note that if the <code>ties.method</code> argument is used the options <code>'first'</code> or <code>'random'</code> will rank by the first column uniquely such that there are no ties for subsequent columns to break.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of ranks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(x1=c('a', 'b', 'b', 'c', 'a', 'a'), x2=c(11, 2, 1, NA, 10, 11))
rankMulti(x)
rankMulti(x, c('x2', 'x1'))

</code></pre>

<hr>
<h2 id='rmsd'>Root-mean-square deviation (error)</h2><span id='topic+rmsd'></span>

<h3>Description</h3>

<p>Calculate the root-mean-square deviation (<code>sqrt(mean((x1 - x2)^2))</code>). If non-constant weights <code>w</code> are supplied, then the calculation is <code>sqrt(sum(w * (x1 - x2)^2) / sum(w))</code>. Alternatively, <code>w</code> can be a function, in which case the returned value is equal to <code>sqrt(mean(w((x1 - x2)^2)))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsd(x1, x2, w = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmsd_+3A_x1">x1</code></td>
<td>
<p>Numeric vector, matrix, or data frame.</p>
</td></tr>
<tr><td><code id="rmsd_+3A_x2">x2</code></td>
<td>
<p>Numeric vector the same length as <code>x1</code>, or a matrix or data frame the same dimensions as <code>x1</code>.</p>
</td></tr>
<tr><td><code id="rmsd_+3A_w">w</code></td>
<td>
<p>Weights or a function defining weights. If <code>x1</code> and <code>x2</code> are vectors, this can be a numeric vector the same length as <code>x1</code> or <code>x2</code>. If <code>x1</code> and <code>x2</code> are matrices or data frames then this can be either a matrix or data frame with the same dimensions as <code>x1</code> and <code>x2</code>. Alternatively, this can be a function to define weights. The function will be applied to each value of <code>(x1 - x2)^2</code>. The default value of <code>NULL</code> assigns each pair of values in <code>x1</code> and <code>x2</code> equal weight.</p>
</td></tr>
<tr><td><code id="rmsd_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code> then remove any elements in <code>x1</code> <em>and</em> <code>x2</code> where either <code>x1</code> or <code>x2</code> is <code>NA</code>. Default is <code>FALSE</code>, in which case any <code>NA</code> returns <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# numeric vectors
x1 &lt;- 1:20
x2 &lt;- 1:20 + rnorm(20)
rmsd(x1, x2)
x1[1] &lt;- NA
rmsd(x1, x2)
rmsd(x1, x2, na.rm=TRUE)

# matrices
x1 &lt;- matrix(1:20, ncol=5)
x2 &lt;- matrix(1:20 + rnorm(20), ncol=5)
rmsd(x1, x2)
x1[1, 1] &lt;- NA
rmsd(x1, x2)
rmsd(x1, x2, na.rm=TRUE)

# weights as values
x1 &lt;- matrix(1:20, ncol=5)
x2 &lt;- matrix(1:20 + rnorm(20, 0, 2), ncol=5)
w &lt;- matrix(1:20, ncol=5)
rmsd(x1, x2)
rmsd(x1, x2, w)

# weights as a function
x1 &lt;- matrix(1:20, ncol=5)
x2 &lt;- matrix(20:1, ncol=5)
w &lt;- function(x) 1 - exp(-x)
rmsd(x1, x2)
rmsd(x1, x2, w)

</code></pre>

<hr>
<h2 id='sampleAcross'>Permute values across two vectors or columns in two data frames or matrices</h2><span id='topic+sampleAcross'></span>

<h3>Description</h3>

<p>This function permutes values across two or more vectors or columns between two or more data frames or matrices. If vectors, then all values are swapped randomly and the output is a list object with vectors of the same length. If data frames or matrices, then values in selected columns are swapped across the data frames or matrices and the output is a list object with data frames or matrices of the same dimension as the originals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleAcross(..., by = NULL, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleAcross_+3A_...">...</code></td>
<td>
<p>One or more vectors, data frames, or matrices (all objects must be the same class).</p>
</td></tr>
<tr><td><code id="sampleAcross_+3A_by">by</code></td>
<td>
<p>Character list or list of integers. Names of columns or column numbers to permute (only used if <code>...</code> is data frames or matrices). If left as <code>NULL</code> (default) the all columns are permuted.</p>
</td></tr>
<tr><td><code id="sampleAcross_+3A_replace">replace</code></td>
<td>
<p>Logical. If <code>TRUE</code> then sample with replacement. If <code>FALSE</code> (default) then sample without replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with same number of elements as in <code>...</code> with the original dimensions. The order is the same as in <code>...</code> (e.g., so if the call is like <code>sampleAcross(a, b, c)</code> then the output will be a list with permuted versions of <code>a</code>, <code>b</code>, and <code>c</code> in that order).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 &lt;- 1:5
x2 &lt;- 6:10
x3 &lt;- 50:60
sampleAcross(x1, x2, x3)
sampleAcross(x1, x2, x3, replace=TRUE)

a &lt;- data.frame(x=1:10, y=letters[1:10])
b &lt;- data.frame(x=11:20, y=letters[11:20])
sampleAcross(a, b, by='y')
sampleAcross(a, b)

</code></pre>

<hr>
<h2 id='sampleStrat'>Stratified randomization</h2><span id='topic+sampleStrat'></span>

<h3>Description</h3>

<p>This function scrambles values of a given column of a data frame in a stratified manner with respect to one or more other &quot;covariate&quot; columns. The covariate columns can be specified, as well as the width of the range of each covariate around each focal value from which to sample candidates for swapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleStrat(
  x,
  col,
  w = function(x) stats::sd(x, na.rm = TRUE)/(max(x, na.rm = TRUE) - min(x, na.rm =
    TRUE)),
  d = 0.1,
  by = "all",
  permuteBy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleStrat_+3A_x">x</code></td>
<td>
<p>Data frame containing at least two columns, one with numeric values and at least one more with numeric or factor values.</p>
</td></tr>
<tr><td><code id="sampleStrat_+3A_col">col</code></td>
<td>
<p>Character or integer, name or number of column in <code>x</code> to swap values.</p>
</td></tr>
<tr><td><code id="sampleStrat_+3A_w">w</code></td>
<td>
<p>Function or numeric value &gt;0, sets window size of <em>non-factor</em> covariates as a <em>proportion</em> of their range. If using a function it must work on a list of values. It can be helpful if this function accepts the argument <code>'na.rm=T'</code> to avoid problems with <code>NA</code>s in the column specified by <code>col</code>. The default is the standard deviation divided by the range. This reduces the correlation between erstwhile perfectly correlated variables to ~0.80 (on average). Ignored for covariates that are factors.</p>
</td></tr>
<tr><td><code id="sampleStrat_+3A_d">d</code></td>
<td>
<p>Numeric &gt; 0, if no swappable value is found within <code>w * (max(col) - min(col))</code>, then <code>w</code> is expanded by <code>1 + d</code> iteratively until a value is found. Ignored for covariates that are factors.</p>
</td></tr>
<tr><td><code id="sampleStrat_+3A_by">by</code></td>
<td>
<p>Character vector or integers. Name(s) or columns numbers of covariates by which to stratify the target column. Can also specify <code>'all'</code> (default) to stratify by all columns with a numeric/integer/factor class except the target column.</p>
</td></tr>
<tr><td><code id="sampleStrat_+3A_permuteby">permuteBy</code></td>
<td>
<p>Logical, if <code>TRUE</code> then in each step scramble the order of values in <code>by</code>. If <code>FALSE</code> then strata are considered for each covariate in teh order listed by <code>by</code>. This argument has no effect if <code>by</code> has just one value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The script starts by randomly selecting a value <code>v_i</code> from the target column. It then finds the value of covariate <code>c_j</code>, that is associated with <code>v_i</code>. Call the particular value of <code>c_j</code> associated with <code>v_i</code> <code>c_j:i</code>. If <code>c_j</code> is a continuous variable it then finds all values <code>c_{v}</code> that fall within <code>c_j:i - w, c_j:i + w</code> where <code>w</code> is a proportion of the range of <code>c_j</code>. <br />
The function then randomly selects a value of <code>v_k</code> from those associated with this range of <code>c_j</code> and swaps <code>v_i</code> with this value. Depending on the random number generator, <code>v_i</code> can = <code>v_k</code> and in fact be the same value. If no values of <code>c_j</code> other than the one associated with <code>v_i</code> are found within this range, then the window is expanded iteratively by a factor of <code>w * (1 + d)</code> until at least one more values that have yet to be swapped have been found. The procedure then finds a window around <code>v_k</code> as described above (or randomly selects a new <code>v_i</code> if <code>v_i</code> was <code>v_k</code>) and continues. If there is an odd number of values then the last value is kept as is (not scrambled).
If <code>c_j</code> is a categorical variable (a factor), then the script finds all values of of <code>v</code> in same factor level as <code>v_i</code>. Swaps of <code>v</code> occur within this level of <code>c_j</code>. However, if there are &lt;2 of values in the level (including the value associated with <code>v_i</code>), then the script looks to the next factor level. The &quot;next&quot; is taken to be the factor level with the least difference between <code>v_i</code> and the average of values of <code>v</code> associated with the potential &quot;next&quot; factor level. The &quot;window&quot; for a factor level is thus the level plus one or more levels with the closest average values of <code>v</code> given that there is &gt;1 value of <code>v</code> within this group that has yet to be swapped. <br />
If there is more than one covariate, then these steps are repeated iteratively for each covariate (i.e., selecting values of <code>v</code> given the stratum identified in covariate <code>c_j</code>, then among these values those also in the stratum identified in covariate <code>c_k</code>, and so on). In this case the order in which the covariates are listed in <code>by</code> can affect the outcome. The order can be permuted each values of <code>v_i</code> if <code>permuteBy</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A data frame with one column swapped in a stratified manner relative another column or set of columns.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example #1: Scramble column 1 with respect to columns 2 and 3.
# Note in the output high values of "a" tend to be associated with
# high values of "b" and low values of "c". This tendency decreases as "w" increases.

x &lt;- data.frame(a=1:20, b=1:20, c=20:1, d=c(rep('a', 10), rep('b', 10)))
x$d &lt;- as.factor(x$d)
x

# scramble by all other columns
sampleStrat(x=x, col=1, w=0.2, by='all', d=0.1)

# scramble by column "d"
sampleStrat(x=x, col=1, w=0.2, by='d', d=0.1)

# Example #2: The target variable and covariate are equal
# (perfectly collinear). How wide must the window (set by
# argument "w'" be to reduce the average correlation
# between them to an arbitrary low level?

df &lt;- data.frame(a=1:100, b=1:100)
cor(df) # perfect correlation

corFrame &lt;- data.frame()
for (w in seq(0.1, 1, 0.1)) {
    for (countRep in 1:10) {
       df2 &lt;- sampleStrat(x=df, col=1, w=w)
       corFrame &lt;- rbind(corFrame, data.frame(w=w, cor=cor(df2)[1, 2]))
    }
}

boxplot(cor ~ w, data=corFrame, xlab='w', ylab='correlation coefficient')

</code></pre>

<hr>
<h2 id='se'>Standard error</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>Calculate the standard error of the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="se_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If TRUE then remove <code>NA</code>s before calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>See Also</h3>

<p><code>link[stats]{sd}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
se(1:100)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
