<!DOCTYPE html><html><head><title>Help for package qgraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qgraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.igraph.qgraph'>
<p>Converts qgraph object to igraph object.</p></a></li>
<li><a href='#averageLayout'>
<p>Computes an average layout over several graphs</p></a></li>
<li><a href='#big5'>
<p>Big 5 dataset</p></a></li>
<li><a href='#big5groups'>
<p>Big 5 groups list</p></a></li>
<li><a href='#centrality'>
<p>Centrality statistics of graphs</p></a></li>
<li><a href='#centrality and clustering plots'>
<p>Centrality and Clustering plots and tables</p></a></li>
<li><a href='#centrality_auto'>
<p>Automatic centrality statistics of graphs</p></a></li>
<li><a href='#clustcoef_auto'>
<p>Local clustering coefficients.</p></a></li>
<li><a href='#cor_auto'>
<p>Automatically compute an apppropriate correlation matrix</p></a></li>
<li><a href='#EBICglasso'>
<p>Compute Gaussian graphical model using graphical lasso based on extended BIC criterium.</p></a></li>
<li><a href='#FDRnetwork'>
<p>Model selection using local False Discovery Rate</p></a></li>
<li><a href='#flow'>
<p>Draws network as a flow diagram showing how one node is connected to all other nodes</p></a></li>
<li><a href='#getWmat'>
<p>Obtain a weights matrix</p></a></li>
<li><a href='#ggmFit'>
<p>Obtain fit measures of a Gaussian graphical model</p></a></li>
<li><a href='#ggmModSelect'>
<p>Unregularized GGM model search</p></a></li>
<li><a href='#makeBW'>
<p>A qgraph plot can be understood in black and white</p></a></li>
<li><a href='#mat2vec'>
<p>Weights matrix to vector</p></a></li>
<li><a href='#mutualInformation'>
<p>Computes the mutual information between nodes</p></a></li>
<li><a href='#pathways'>
<p>Highlight shortest pathways in a network</p></a></li>
<li><a href='#plot.qgraph'>
<p>Plot method for &quot;qgraph&quot;</p></a></li>
<li><a href='#print.qgraph'>
<p>Print edgelist</p></a></li>
<li><a href='#qgraph'><p>qgraph</p></a></li>
<li><a href='#qgraph.animate'>
<p>Animate a growing network</p></a></li>
<li><a href='#qgraph.layout.fruchtermanreingold'><p>qgraph.layout.fruchtermanreingold</p></a></li>
<li><a href='#qgraph.loadings'><p>qgraph.loadings</p></a></li>
<li><a href='#qgraphMixed'>
<p>Plots a mixed graph with both directed and undirected edges.</p></a></li>
<li><a href='#smallworldIndex'>
<p>Small-world index of unweighted graph</p></a></li>
<li><a href='#smallworldness'>
<p>Compute the small-worldness index.</p></a></li>
<li><a href='#summary.qgraph'>
<p>Summary method for &quot;qgraph&quot;</p></a></li>
<li><a href='#VARglm'>
<p>Computes a vector autoregressive lag-1 model using GLM</p></a></li>
<li><a href='#wi2net'>
<p>Converts precision matrix to partial correlation matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graph Plotting Methods, Psychometric Data Visualization and
Graphical Model Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), methods, grDevices, psych, lavaan, plyr,
Hmisc, igraph, jpeg, png, colorspace, Matrix, corpcor,
reshape2, ggplot2, glasso, fdrtool, gtools, parallel, pbapply,
abind</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Fork of qgraph - Weighted network visualization and analysis, as well as Gaussian graphical model computation. See Epskamp et al. (2012) &lt;<a href="https://doi.org/10.18637%2Fjss.v048.i04">doi:10.18637/jss.v048.i04</a>&gt;.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SachaEpskamp/qgraph">https://github.com/SachaEpskamp/qgraph</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BDgraph, huge</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-03 08:14:42 UTC; sachaepskamp</td>
</tr>
<tr>
<td>Author:</td>
<td>Sacha Epskamp [aut, cre],
  Giulio Costantini [aut],
  Jonas Haslbeck [aut],
  Adela Isvoranu [aut],
  Angelique O. J. Cramer [ctb],
  Lourens J. Waldorp [ctb],
  Verena D. Schmittmann [ctb],
  Denny Borsboom [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-03 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.igraph.qgraph'>
Converts qgraph object to igraph object.
</h2><span id='topic+as.igraph.qgraph'></span>

<h3>Description</h3>

<p>This function converts the output of <code><a href="#topic+qgraph">qgraph</a></code> to an 'igraph' object that can be used in the igraph package (Csardi &amp; Nepusz, 2006)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qgraph'
as.igraph(x, ..., attributes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.igraph.qgraph_+3A_x">x</code></td>
<td>

<p>A <code>"qgraph"</code> object
</p>
</td></tr>
<tr><td><code id="as.igraph.qgraph_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.igraph.qgraph_+3A_attributes">attributes</code></td>
<td>

<p>Logical, should graphical attributes also be transferred?
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Csardi G, Nepusz T (2006). The igraph software package for complex network research, InterJournal, Complex Systems 1695. http://igraph.sf.net
</p>

<hr>
<h2 id='averageLayout'>
Computes an average layout over several graphs
</h2><span id='topic+averageLayout'></span>

<h3>Description</h3>

<p>This function can be used to compute a joint layout over several graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>averageLayout(..., layout = "spring", repulsion = 1, layout.par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="averageLayout_+3A_...">...</code></td>
<td>

<p>Multiple graph objects such as <code>qgraph</code> objects or weights matrices.
</p>
</td></tr>
<tr><td><code id="averageLayout_+3A_layout">layout</code></td>
<td>

<p>Same as in <code><a href="#topic+qgraph">qgraph</a></code>
</p>
</td></tr>
<tr><td><code id="averageLayout_+3A_repulsion">repulsion</code></td>
<td>

<p>The repulsion parameter as used in  <code><a href="#topic+qgraph">qgraph</a></code>.
</p>
</td></tr>
<tr><td><code id="averageLayout_+3A_layout.par">layout.par</code></td>
<td>

<p>Same as in <code><a href="#topic+qgraph">qgraph</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A layout matrix
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='big5'>
Big 5 dataset
</h2><span id='topic+big5'></span>

<h3>Description</h3>

<p>This is a dataset of the Big 5 personality traits that will be used in talks and the paper. It is a measurement of the Dutch translation of the NEO-PI-R on 500 first year psychology students (Dolan, Oort, Stoel, Wicherts, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(big5)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:500, 1:240] 2 3 4 4 5 2 2 1 4 2 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : NULL
..$ : chr [1:240] &quot;N1&quot; &quot;E2&quot; &quot;O3&quot; &quot;A4&quot; ...
</p>


<h3>References</h3>

<p>Hoekstra, H. A., Ormel, J., &amp; De Fruyt, F. (2003). NEO-PI-R/NEO-FFI: Big 5 persoonlijkheidsvragenlijst. Handleiding [Manual of the Dutch version of the NEO-PI-R/NEO-FFI]. Lisse, The Netherlands: Swets and Zeitlinger.
</p>
<p>Dolan, C. V., Oort, F. J., Stoel, R. D., &amp; Wicherts, J. M. (2009). Testing measurement invariance in the target rotates multigroup exploratory factor model. Structural Equation Modeling, 16, 295&ndash;314.
</p>

<hr>
<h2 id='big5groups'>
Big 5 groups list
</h2><span id='topic+big5groups'></span>

<h3>Description</h3>

<p>This is the groups list of the big 5 data. It is a measurement of the Dutch translation of the NEO-PI-R on 500 first year psychology students (Dolan, Oort, Stoel, Wicherts, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(big5groups)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 5
$ Neuroticism      : num [1:48] 1 6 11 16 21 26 31 36 41 46 ...
$ Extraversion     : num [1:48] 2 7 12 17 22 27 32 37 42 47 ...
$ Openness         : num [1:48] 3 8 13 18 23 28 33 38 43 48 ...
$ Agreeableness    : num [1:48] 4 9 14 19 24 29 34 39 44 49 ...
$ Conscientiousness: num [1:48] 5 10 15 20 25 30 35 40 45 50 ...
</p>


<h3>References</h3>

<p>Hoekstra, H. A., Ormel, J., &amp; De Fruyt, F. (2003). NEO-PI-R/NEO-FFI: Big 5 persoonlijkheidsvragenlijst. Handleiding [Manual of the Dutch version of the NEO-PI-R/NEO-FFI]. Lisse, The Netherlands: Swets and Zeitlinger.
</p>
<p>Dolan, C. V., Oort, F. J., Stoel, R. D., &amp; Wicherts, J. M. (2009). Testing measurement invariance in the target rotates multigroup exploratory factor model. Structural Equation Modeling, 16, 295&ndash;314.
</p>

<hr>
<h2 id='centrality'>
Centrality statistics of graphs
</h2><span id='topic+centrality'></span>

<h3>Description</h3>

<p>This function can be used on the output of <code><a href="#topic+qgraph">qgraph</a></code> to compute the node centrality statistics for weighted graphs proposed by Opsahl, Agneessens and Skvoretz (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centrality(graph, alpha = 1, posfun = abs, pkg, all.shortest.paths = FALSE, 
           weighted = TRUE, signed = TRUE, R2 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centrality_+3A_graph">graph</code></td>
<td>

<p>A &quot;qgraph&quot; object obtained from <code><a href="#topic+qgraph">qgraph</a></code></p>
</td></tr>
<tr><td><code id="centrality_+3A_alpha">alpha</code></td>
<td>

<p>The tuning parameter. Defaults to 1. 
</p>
</td></tr>
<tr><td><code id="centrality_+3A_posfun">posfun</code></td>
<td>

<p>A function that converts positive and negative values to only positive. Defaults to the absolute value.
</p>
</td></tr>
<tr><td><code id="centrality_+3A_pkg">pkg</code></td>
<td>

<p>Package to use. Either <code>"qgraph"</code> or <code>"igraph"</code>. Defaults to <code>"qgraph"</code> for directed networks and  <code>"igraph"</code> for undirected networks.
</p>
</td></tr>
<tr><td><code id="centrality_+3A_all.shortest.paths">all.shortest.paths</code></td>
<td>

<p>Logical if all shortest paths should be returned. Defaults to <code>FALSE</code>. Setting this to true can greatly increase computing time if <code>pkg = "igraph"</code>.
</p>
</td></tr>
<tr><td><code id="centrality_+3A_weighted">weighted</code></td>
<td>
<p>Logical, set to <code>FALSE</code> to set all edge weights to 1 or -1</p>
</td></tr>
<tr><td><code id="centrality_+3A_signed">signed</code></td>
<td>
<p>Logical, set to <code>FALSE</code> to make all edge weights absolute</p>
</td></tr>
<tr><td><code id="centrality_+3A_r2">R2</code></td>
<td>
<p>Logical, should R-squared (predictability) be computed for GGM structures?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes and returns the in and out degrees, closeness and betweenness as well as the shortest path lengths and shortest paths between all pairs of nodes in the graph. For more information on these statistics, see Opsahl, Agneessens and Skvoretz (2010).
</p>
<p>Self-loops are ignored in computing centrality indices. These statistics are only defined for positive edge weights, and thus negative edge weights need to be transformed into positive edge weights. By default, this is done by taking the absolute value.
</p>
<p>The algorithm used for computing the shortest paths is the well known &quot;Dijkstra’s algorithm&quot; (Dijkstra, 1959). The algorithm has been implemented in R, which can make this function take several minutes to run for large graphs (over 100 nodes). A future version of qgraph will include a compiled version to greatly speed up this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>OutDegree</code></td>
<td>
<p>A vector containing the outward degree of each node.</p>
</td></tr>
<tr><td><code>InDegree</code></td>
<td>
<p>A vector containing the inward degree of each node.</p>
</td></tr>
<tr><td><code>Closeness</code></td>
<td>
<p>A vector containing the closeness of each node.</p>
</td></tr>
<tr><td><code>Betweenness</code></td>
<td>
<p>A vector containing the betweenness of each node</p>
</td></tr>
<tr><td><code>InExpectedInfluence</code></td>
<td>
<p>Expected incoming influence - sum of incomming edge weights connected to a node (not made absolute)</p>
</td></tr>
<tr><td><code>OutExpectedInfluence</code></td>
<td>
<p>Expected outgoing influence - sum of outgoing edge weights connected to a node (not made absolute)</p>
</td></tr>
<tr><td><code>ShortestPathLengths</code></td>
<td>
<p>A matrix containing the shortest path lengths of each pairs of nodes. These path lenghts are based on the inverse of the absolute edge weights raised to the power alpha.</p>
</td></tr>
<tr><td><code>ShortestPaths</code></td>
<td>
<p>A matrix of lists containing all shortest path lengths between all pairs of nodes. Use double square brackets to index. E.g., if the list is called 'res', res$ShortestPaths[[i,j]] gives a list containing all shortest paths between node i and j.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>References</h3>

<p>Opsahl, T., Agneessens, F., Skvoretz, J. (2010). Node centrality in weighted networks: generalizing degree and shortest paths. Soc Netw. 32:245–251.
</p>
<p>Dijkstra, E.W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik 1, 269–271.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgraph">qgraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
adj &lt;- matrix(sample(0:1,10^2,TRUE,prob=c(0.8,0.2)),nrow=10,ncol=10)
Q &lt;- qgraph(adj)

centrality(Q)
</code></pre>

<hr>
<h2 id='centrality+20and+20clustering+20plots'>
Centrality and Clustering plots and tables
</h2><span id='topic+centralityPlot'></span><span id='topic+centralityTable'></span><span id='topic+clusteringPlot'></span><span id='topic+clusteringTable'></span>

<h3>Description</h3>

<p>These functions can be used to facilitate interpreting centrality and clustering coefficients. The plot functions use ggplot2 (Wickham, 2009). The table functions create a long format table which can easilly be plotted in ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralityPlot(..., labels, scale = c("raw0", "raw", "z-scores", "relative"),
                 include =c("Degree","Strength","OutDegree","InDegree","OutStrength",
                 "InStrength"), theme_bw = TRUE, print = TRUE, verbose = TRUE, 
                 standardized, relative, weighted = TRUE,signed = TRUE, 
                 orderBy = "default", decreasing = FALSE)
clusteringPlot(..., scale = c("raw0", "raw", "z-scores", "relative"), labels, 
                  include , signed = FALSE, theme_bw = TRUE, print = TRUE,
                  verbose = TRUE, standardized, relative,orderBy = "default", 
                  decreasing = FALSE)
centralityTable(..., labels, standardized = TRUE,  relative = FALSE, weighted =
                 TRUE, signed = TRUE)
clusteringTable(..., labels,  standardized = TRUE, relative = FALSE, 
                signed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_...">...</code></td>
<td>

<p>Objects usuable in the <code><a href="#topic+getWmat">getWmat</a></code> generic, such as qgraph objects and weights matrices. Can also be lists containing these objects. Graphs in a list will be plotted in the same panel as different lines and graphs in seperate arguments will be plotted in seperate panels.
</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_scale">scale</code></td>
<td>
<p>Scale of the x-axis. <code>"z-scores"</code> to plot standardized coefficients, <code>"raw"</code> to plot raw coefficients, <code>"raw0"</code> to plot raw coefficients while including 0 on the x-axis and  <code>"relative"</code> to show values on a relative scale from 0 (lowest) to 1 (highest).</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_labels">labels</code></td>
<td>

<p>A vector overwriting the labels used. Can be missing.
</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_include">include</code></td>
<td>

<p>A vector of measures to include. if missing all measures available will be included. Not included by default are <code>"Closeness"</code>, <code>"Betweenness"</code>, <code>"ExpectedInfluence"</code>, <code>"OutExpectedInfluence"</code>, and <code>"InExpectedInfluence"</code>. Can also be <code>"all"</code> or <code>"All"</code> to include all available centrality measures.
</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_theme_bw">theme_bw</code></td>
<td>

<p>Adds the ggplot2 black and white theme to the plot
</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_print">print</code></td>
<td>

<p>If <code>TRUE</code>, the plot is sent to the print command and returned invisible, if <code>FALSE</code> the plot is returned normally. Needed to include plots in e.g., pdf files.
</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_verbose">verbose</code></td>
<td>

<p>Should messages be printed to the console?
</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_standardized">standardized</code></td>
<td>

<p>Logical, should all measures be standardized? Argument is deprecated and will be removed.
</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_relative">relative</code></td>
<td>

<p>Logical, should all measures be scaled relative to the largest value? Argument is deprecated and will be removed.
</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_weighted">weighted</code></td>
<td>
<p>Logical, set to <code>FALSE</code> to set all edge weights to 1 or -1</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_signed">signed</code></td>
<td>
<p>Logical, set to <code>FALSE</code> to make all edge weights absolute</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_orderby">orderBy</code></td>
<td>
<p>String indicating which measure to order by. Can be default (alphabetical), or one of the measures plotted (e.g., <code>"Strength"</code>)</p>
</td></tr>
<tr><td><code id="centrality+2B20and+2B20clustering+2B20plots_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical indicating if the nodes should be ordered increasing or decreasing</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt; and Jolanda Kossakowski
</p>


<h3>References</h3>

<p>H. Wickham. ggplot2: elegant graphics for data
analysis. Springer New York, 2009.
</p>

<hr>
<h2 id='centrality_auto'>
Automatic centrality statistics of graphs
</h2><span id='topic+centrality_auto'></span>

<h3>Description</h3>

<p>This function can be used on several kinds of graphs to compute several node centrality statistics and the edge-betweenness centrality. The input graph can be an adjacency matrix, a weight matrix, an edgelist (weighted or unweighted), a <code><a href="#topic+qgraph">qgraph</a></code> object or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centrality_auto(x, weighted = TRUE, signed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centrality_auto_+3A_x">x</code></td>
<td>

<p>A graph. Can be a <code>qgraph</code> object, an <code>igraph</code> object, an adjacency matrix, a weight matrix and an edgelist, or a weighted edgelist.
</p>
</td></tr>
<tr><td><code id="centrality_auto_+3A_weighted">weighted</code></td>
<td>
<p>Logical, set to <code>FALSE</code> to set all edge weights to 1 or -1</p>
</td></tr>
<tr><td><code id="centrality_auto_+3A_signed">signed</code></td>
<td>
<p>Logical, set to <code>FALSE</code> to make all edge weights absolute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function recognizes whether the network is unweighted vs. weighted, undirected vs. directed, and connected vs. disconnected and computes a set of centrality indices that is best suited for that particular kind of network. Edge signs are always disregarded, while edge weights and directions, if present, are considered in the computation of the indices. If the network is disconnected, closeness centrality is computed only considering the largest component (notice that this is different from what function <code><a href="#topic+centrality">centrality</a></code> does).
</p>
<p>If <code>x</code> is unweighted and directed, then the indegree, the outdegree, the node betweenness centrality, the closenes centrality, and the edge betweenness centrality are computed.
If <code>x</code> is unweighted and undirected, then the degree, the node betweenness centrality, the closenes centrality, and the edge betweenness centralities are computed.
If <code>x</code> is weighted and directed, then the instrength and the outstrength (same as indegree and outdegree, but considering weights), the node betweenness centrality, the closeness centrality, and edge betweenness centralities are computed
If <code>x</code> is weighted and undirected, then the strength, the node betweenness centrality, the closenes centrality, and edge betweenness centralities are computed.
Additionally, the shortest path length between each pair of nodes is also computed for all the kinds of networks.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>node.centrality</code></td>
<td>
<p>A dataframe that includes the node centrality statistics. A subset of the following centrality indices is included, depending on the input network: <code>Degree</code>, <code>InDegree</code>, <code>OutDegree</code>, <code>Strength</code>, <code>InStrength</code>, <code>OutStrength</code>, <code>Betweenness</code>, and <code>Closeness</code>.</p>
</td></tr>
<tr><td><code>ShortestPathLengths</code></td>
<td>
<p>A matrix containing the shortest path lengths of each pairs of nodes. These path lenghts are based on the inverse of the absolute edge weights.</p>
</td></tr>
<tr><td><code>edge.betweenness.centrality</code></td>
<td>
<p>The edge betweenness centrality statistic (Newman &amp; Girvan, 2004). Edges are ordered by their decreasing centrality.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giulio Costantini (giulio.costantini@unimib.it), Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>References</h3>

<p>Newman, M. E. J., Girvan, M. (2004). Finding and evaluating community structure in networks. Phisical Review E 69(026113).
</p>
<p>Costantini, G., Epskamp, S., Borsboom, D., Perugini, M., Mõttus, R., Waldorp, L., Cramer, A. O. J., State of the aRt personality research: A tutorial on network analysis of personality data in R. Manuscript submitted for publication.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgraph">qgraph</a></code>, <code><a href="#topic+centrality">centrality</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
adj &lt;- matrix(sample(0:1,10^2,TRUE,prob=c(0.8,0.2)),nrow=10,ncol=10)
Q &lt;- qgraph(adj)
centrality_auto(Q) 
# notice that a value NA is returned for the closeness centrality of nodes 3 and 9, which are not 
# strongly connected to the largest component of the network (3 cannot reach other nodes, 9 cannot 
# be reached).
</code></pre>

<hr>
<h2 id='clustcoef_auto'>
Local clustering coefficients.
</h2><span id='topic+clustcoef_auto'></span><span id='topic+clustWS'></span><span id='topic+clustZhang'></span><span id='topic+clustOnnela'></span>

<h3>Description</h3>

<p>Compute local clustering coefficients, both signed and unsigned and both for weighted and for unweighted networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustcoef_auto(x, thresholdWS = 0, thresholdON = 0)
clustWS(x, thresholdWS=0)
clustZhang(x)
clustOnnela(x, thresholdON=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustcoef_auto_+3A_x">x</code></td>
<td>
<p>An undirected graph. Can be a <code>qgraph</code> object, an <code>igraph</code> object, an adjacency matrix, a weight matrix and an edgelist, or a weighted edgelist.</p>
</td></tr>
<tr><td><code id="clustcoef_auto_+3A_thresholdws">thresholdWS</code></td>
<td>

<p>The threshold used to binarize a weighted network <code>x</code> to compute the binary clustering coefficients <code>clustWS</code> and <code>signed_clustWS</code>. Edges with weights lower than <code>thresholdWS</code> in absolute value are zeroed. For unweighted networks, <code>thresholdWS = 0</code> is the suggested value.
</p>
</td></tr>
<tr><td><code id="clustcoef_auto_+3A_thresholdon">thresholdON</code></td>
<td>

<p>In the computation of Onnela's clustering coefficient <code>clustOnnela</code>, edge of weights lower than <code>thresholdON</code> in absolute value are excluded. The value <code>thresholdON = 0</code> (i.e., no edge is excluded) is generally suggested also for weighted networks.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clustWS</code> computes the clustering coefficient for unweighted networks introduced by Watts &amp; Strogatz (1998) and the corresponding signed version (Costantini &amp; Perugini, in press).
<code>ClustZhang</code> computes the clustering coefficient for weighted networks introduced by Zhang &amp; Horvath (2005) and the corresponding signed version (Costantini &amp; Perugini, in press).
<code>clustOnnela</code> computes the clustering coefficient for weighted networks introduced by Onnela et al. (2005) and the corresponding signed version (Costantini &amp; Perugini, in press).
<code>clustering_auto</code> automatically recognizes the kind of the input network <code>x</code> (weighted vs. unweighted, signed vs. unsigned) and computes a subset of indices according to the kind of the network: signed indices are not computed for unsigned networks and weighted indices are not computed for unweighted networks. However the unsigned indices are computed for signed networks, by considering the absolute value of the weights, and the unweighted indices are computed for weighted networks, after a binarization according to the parameter <code>thresholdWS</code>. <code>clustering_auto</code> computes also the weighted clustering coefficient by Barrat et al. (2004), relying on function <code><a href="igraph.html#topic+transitivity">transitivity</a></code> from package <code><a href="igraph.html#topic+igraph">igraph</a></code>.
For the computation of the local clustering coefficient, a node must have at least two neighbors: for nodes with less than two neighbors <code>NaN</code> is returned.
</p>


<h3>Value</h3>

<p>A dataframe that includes one or more of the following indices.
</p>
<table>
<tr><td><code>clustWS</code></td>
<td>
<p>The Watts &amp; Strogatz's (1998) unweighted clustering coefficient</p>
</td></tr>
<tr><td><code>signed_clustWS</code></td>
<td>
<p>The signed version of the Watts &amp; Strogatz's clustering coefficient</p>
</td></tr>
<tr><td><code>clustZhang</code></td>
<td>
<p>The Zhang &amp; Horvath's (2005) weighted clustering coefficient</p>
</td></tr>
<tr><td><code>signed_clustZhang</code></td>
<td>
<p>The signed version of the Zhang &amp; Horvath's (2005) clustering coefficient</p>
</td></tr>
<tr><td><code>clustOnnela</code></td>
<td>
<p>The Onnela et al.'s (2005) clustering coefficient</p>
</td></tr>
<tr><td><code>signed_clustOnnela</code></td>
<td>
<p>The signed version of the Onnela et al.'s (2005) clustering coefficient</p>
</td></tr>
<tr><td><code>clustBarrat</code></td>
<td>
<p>The Barrat et al.'s (2004) weighted clustering coefficient</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The function requires an undirected network. To convert a directed network to undirected use for instance function <code><a href="base.html#topic+upper.tri">upper.tri</a></code> (see examples).
</p>


<h3>Note</h3>

<p>Part of the code has been adapted from package <code>WGCNA</code> (Langfelder &amp; Horvath, 2008).
</p>


<h3>Author(s)</h3>

<p>Giulio Costantini (giulio.costantini@unimib.it), Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>References</h3>

<p>Barrat, A., Barthelemy, M., Pastor-Satorras, R., &amp; Vespignani, A. (2004). The architecture of complex weighted networks. In Proc. Natl. Acad. Sci. USA 101 (pp. 3747-3752).
</p>
<p>Costantini, G., Perugini, M. (in press), Generalization of Clustering Coefficients to Signed Correlation Networks
</p>
<p>Langfelder, P., &amp; Horvath, S. (2008). WGCNA: an R package for weighted correlation network analysis. BMC Bioinformatics, 9, 559.
</p>
<p>Onnela, J. P., Saramaki, J., Kertesz, J., &amp; Kaski, K. (2005). Intensity and coherence of motifs in weighted complex networks. Physical Review E, 71(6), 065103.
</p>
<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of &quot;small-world&quot; networks. Nature, 393(6684), 440-442.
</p>
<p>Zhang, B., &amp; Horvath, S. (2005). A general framework for weighted gene co-expression network analysis. Statistical Applications in Genetics and Molecular Biology, 4(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centrality_auto">centrality_auto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# generate a random (directed) network:
net_ig &lt;- igraph::erdos.renyi.game(n=8, p.or.m=.4, type="gnp", directed=TRUE) 

# convert it to an adjacency matrix:
net &lt;- as.matrix(igraph:::get.adjacency(net_ig, type="both")) 

# convert it to a signed and weighted network:
net &lt;- net*matrix(rnorm(ncol(net)^2), ncol=ncol(net)) 

# make it undirected:
net[upper.tri(net)] &lt;- t(net)[upper.tri(net)] 
clustcoef_auto(net)
</code></pre>

<hr>
<h2 id='cor_auto'>
Automatically compute an apppropriate correlation matrix
</h2><span id='topic+cor_auto'></span>

<h3>Description</h3>

<p>This is mainly a wrapper around Lavaan function <code><a href="lavaan.html#topic+lavCor">lavCor</a></code> (Rosseel, 2012) to compute a correlation matrix based on pychoric, polyserial and/or Pearson correlations. The wrapper removes all factors and searches for possible ordinal variabes. A variable is classified as ordinal if it is either <code>ordered</code> or if it consist of at most 7 unique integer values. After computing the correlations an additional check will be performed to see if the correlation matrix is positive definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_auto(data, select, detectOrdinal = TRUE, ordinalLevelMax = 7, npn.SKEPTIC = FALSE, 
          forcePD = FALSE, missing = "pairwise", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_auto_+3A_data">data</code></td>
<td>

<p>A data frame
</p>
</td></tr>
<tr><td><code id="cor_auto_+3A_select">select</code></td>
<td>

<p>Variables to select from the data frame (as used in <code><a href="base.html#topic+subset">subset</a></code>)
</p>
</td></tr>
<tr><td><code id="cor_auto_+3A_detectordinal">detectOrdinal</code></td>
<td>

<p>Logical, should ordinal variables be detected? If <code>FALSE</code> only variables that are <code>ordered</code> are treated as ordinal variables
</p>
</td></tr>
<tr><td><code id="cor_auto_+3A_ordinallevelmax">ordinalLevelMax</code></td>
<td>

<p>Integer specyfying the amount of unique integer values a variable should have to be classified as ordinal
</p>
</td></tr>
<tr><td><code id="cor_auto_+3A_npn.skeptic">npn.SKEPTIC</code></td>
<td>

<p>Logical, should the Nonparanormal SKEPTIC from the huge package be applied if the data is continuous? See <code><a href="huge.html#topic+huge.npn">huge.npn</a></code> (Zhao, Liu, Roeder, Lafferty and Wasserman, 2014)
</p>
</td></tr>
<tr><td><code id="cor_auto_+3A_forcepd">forcePD</code></td>
<td>

<p>If <code>TRUE</code> the function checks if the correlation matrix is positive definite. If the matrix is not positive definite 
<code><a href="Matrix.html#topic+nearPD">nearPD</a></code> from the Matrix package will be used  (Bates and Maechler, 2014).
</p>
</td></tr>
<tr><td><code id="cor_auto_+3A_missing">missing</code></td>
<td>
<p>Corresponds to the <code>missing</code> argument in <code><a href="lavaan.html#topic+lavCor">lavCor</a></code></p>
</td></tr>
<tr><td><code id="cor_auto_+3A_verbose">verbose</code></td>
<td>
<p>Logical, should information be printed to the console?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation Modeling.
Journal of Statistical Software, 48(2), 1-36. URL
http://www.jstatsoft.org/v48/i02/.
</p>
<p>Tuo Zhao, Han Liu, Kathryn Roeder, John Lafferty and Larry Wasserman (2014). huge:
High-dimensional Undirected Graph Estimation. R package version 1.2.6.
http://CRAN.R-project.org/package=huge
</p>
<p>Douglas Bates and Martin Maechler (2014). Matrix: Sparse and Dense Matrix Classes and
Methods. R package version 1.1-3. http://CRAN.R-project.org/package=Matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Examples from lavCor (lavaan): ###

library("lavaan")

# Holzinger and Swineford (1939) example
HS9 &lt;- HolzingerSwineford1939[,c("x1","x2","x3","x4","x5",
                                 "x6","x7","x8","x9")]

# Pearson correlations
cor_auto(HS9)

# ordinal version, with three categories
HS9ord &lt;- as.data.frame( lapply(HS9, cut, 3, labels=FALSE) )

# polychoric correlations, two-stage estimation
cor_auto(HS9ord)

## End(Not run)
</code></pre>

<hr>
<h2 id='EBICglasso'>
Compute Gaussian graphical model using graphical lasso based on extended BIC criterium.
</h2><span id='topic+EBICglasso'></span>

<h3>Description</h3>

<p>This function uses the <code><a href="glasso.html#topic+glasso">glasso</a></code> package (Friedman, Hastie and Tibshirani, 2011) to compute a sparse gaussian graphical model with the graphical lasso (Friedman, Hastie and Tibshirani, 2008). The tuning parameter is chosen using the Extended Bayesian Information criterium  (EBIC). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBICglasso(S, n, gamma = 0.5, penalize.diagonal = FALSE, nlambda = 100, 
            lambda.min.ratio = 0.01, returnAllResults = FALSE, checkPD = TRUE, 
            penalizeMatrix, countDiagonal = FALSE, refit = FALSE, threshold = FALSE,
            verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EBICglasso_+3A_s">S</code></td>
<td>

<p>A covariance or correlation matrix
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_n">n</code></td>
<td>

<p>Sample size used in computing <code>S</code>
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_gamma">gamma</code></td>
<td>

<p>EBIC tuning parameter. 0.5 is generally a good choice. Setting to zero will cause regular BIC to be used.
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_penalize.diagonal">penalize.diagonal</code></td>
<td>

<p>Should the diagonal be penalized? 
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_nlambda">nlambda</code></td>
<td>

<p>Number of lambda values to test.
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>

<p>Ratio of lowest lambda value compared to maximal lambda
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_returnallresults">returnAllResults</code></td>
<td>

<p>If <code>TRUE</code> this function does not return a network but the results of the entire glasso path.
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_checkpd">checkPD</code></td>
<td>

<p>If <code>TRUE</code>, the function will check if <code>S</code> is positive definite and return an error if not. It is not advised to use a non-positive definite matrix as input as (a) that can not be a covariance matrix and (b) glasso can hang if the input is not positive definite.
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_penalizematrix">penalizeMatrix</code></td>
<td>

<p>Optional logical matrix to indicate which elements are penalized
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_countdiagonal">countDiagonal</code></td>
<td>

<p>Should diagonal be counted in EBIC computation? Defaults to <code>FALSE</code>. Set to <code>TRUE</code> to mimic qgraph &lt; 1.3 behavior (not recommended!).
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_refit">refit</code></td>
<td>

<p>Logical, should the optimal graph be refitted without LASSO regularization? Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_threshold">threshold</code></td>
<td>

<p>Logical, should elements of the precision matrix that are below (log(p*(p-1)/2)) / sqrt(n) be removed (both before EBIC computation and in final model)? Set to <code>TRUE</code> to ensure high specificity.
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should progress output be printed to the console?
</p>
</td></tr>
<tr><td><code id="EBICglasso_+3A_...">...</code></td>
<td>

<p>Arguments sent to <code><a href="glasso.html#topic+glasso">glasso</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The glasso is run for 100 values of the tuning parameter logarithmically spaced between the maximal value of the tuning parameter at which all edges are zero, lamba_max, and lambda_max/100. For each of these graphs the EBIC is computed and the graph with the best EBIC is selected. The partial correlation matrix is computed using <code><a href="#topic+wi2net">wi2net</a></code> and returned. When <code>threshold = TRUE</code>, elements of the inverse variance-covariance matrix are first thresholded using the theoretical bound (Jankova and van de Geer, 2018).
</p>


<h3>Value</h3>

<p>A partial correlation matrix
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Friedman, J., Hastie, T., &amp; Tibshirani, R. (2008). Sparse inverse covariance estimation with the graphical lasso. Biostatistics, 9(3), 432-441.
Chicago  
</p>
<p>Jerome Friedman, Trevor Hastie and Rob Tibshirani (2011). glasso: Graphical lasso-estimation of Gaussian graphical models. R package version 1.7.
http://CRAN.R-project.org/package=glasso
</p>
<p>Foygel, R., &amp; Drton, M. (2010, November). Extended Bayesian Information Criteria for Gaussian Graphical Models. In NIPS (pp. 604-612).
Chicago  
</p>
<p>Revelle, W. (2014) psych: Procedures for Personality and Psychological Research,
Northwestern University, Evanston, Illinois, USA,
http://CRAN.R-project.org/package=psych Version = 1.4.4.
</p>
<p>Bates, D., and Maechler, M. (2014). Matrix: Sparse and Dense Matrix Classes and
Methods. R package version 1.1-3. http://CRAN.R-project.org/package=Matrix
</p>
<p>Jankova, J., and van de Geer, S. (2018) Inference for high-dimensional graphical models. In: Handbook of graphical models (editors: Drton, M., Maathuis, M., Lauritzen, S., and Wainwright, M.). CRC Press: Boca Raton, Florida, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Using bfi dataset from psych ###
library("psych")
data(bfi)

# Compute correlations:
CorMat &lt;- cor_auto(bfi[,1:25])

# Compute graph with tuning = 0 (BIC):
BICgraph &lt;- EBICglasso(CorMat, nrow(bfi), 0, threshold = TRUE)

# Compute graph with tuning = 0.5 (EBIC)
EBICgraph &lt;- EBICglasso(CorMat, nrow(bfi), 0.5, threshold = TRUE)

# Plot both:
layout(t(1:2))
BICgraph &lt;- qgraph(BICgraph, layout = "spring", title = "BIC", details = TRUE)
EBICgraph &lt;- qgraph(EBICgraph, layout = "spring", title = "EBIC")

# Compare centrality and clustering:
layout(1)
centralityPlot(list(BIC = BICgraph, EBIC = EBICgraph))
clusteringPlot(list(BIC = BICgraph, EBIC = EBICgraph))

## End(Not run)
</code></pre>

<hr>
<h2 id='FDRnetwork'>
Model selection using local False Discovery Rate
</h2><span id='topic+FDRnetwork'></span>

<h3>Description</h3>

<p>This function is a wrapper arounf <code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code> to easilly compute a correlation or partial correlation network in which all nonsignificant edges are set to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FDRnetwork(net, cutoff = 0.1, method = c('lfdr', 'pval', 'qval'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FDRnetwork_+3A_net">net</code></td>
<td>

<p>A correlation or partial correlation matrix
</p>
</td></tr>
<tr><td><code id="FDRnetwork_+3A_cutoff">cutoff</code></td>
<td>

<p>The cutoff value to use. The edges of which the value of the first element of <code>method</code> are higher than the cutoff are removed. Thus, by default, edges with a local false discovery rate of higher than 0.1 are removed from the graph.
</p>
</td></tr>
<tr><td><code id="FDRnetwork_+3A_method">method</code></td>
<td>
<p>The method to use with the cutoff. Can be <code>'lfdr'</code> for the local false discobvery rate, <code>'pval'</code> for the p-value of <code>'qval'</code> for the q-value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method = 'lfdr'</code> could result in a very sparse network, so also looking at other values is advisable.
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Bernd Klaus and Korbinian Strimmer. (2014). fdrtool: Estimation of (Local) False Discovery Rates and Higher Criticism. R package version 1.2.12. http://CRAN.R-project.org/package=fdrtool
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Using bfi dataset from psych ###
library("psych")
data(bfi)

### CORRELATIONS ###
# Compute correlations:
CorMat &lt;- cor_auto(bfi[,1:25])

# Run local FDR:
CorMat_FDR &lt;- FDRnetwork(CorMat)

# Number of edges remaining:
mean(CorMat_FDR[upper.tri(CorMat_FDR,diag=FALSE)]!=0)

# None, so might use different criterion:
CorMat_FDR &lt;- FDRnetwork(CorMat, method = "pval")


# Compare:
L &lt;- averageLayout(CorMat, CorMat_FDR)

layout(t(1:2))
qgraph(CorMat, layout = L, title = "Correlation network", 
       maximum = 1, cut = 0.1, minimum = 0, esize = 20)
qgraph(CorMat_FDR, layout = L, title = "Local FDR correlation network", 
       maximum = 1, cut = 0.1, minimum = 0, esize = 20)

# Centrality:
centralityPlot(list(cor=CorMat, fdr = CorMat_FDR))


### PARTIAL CORRELATIONS ###
# Partial correlation matrix:
library("parcor")
PCorMat &lt;- cor2pcor(CorMat)

# Run local FDR:
PCorMat_FDR &lt;- FDRnetwork(PCorMat, cutoff = 0.1, method = "pval")

# Number of edges remaining:
mean(PCorMat_FDR[upper.tri(PCorMat_FDR,diag=FALSE)]!=0)

# Compare:
L &lt;- averageLayout(PCorMat, PCorMat_FDR)

layout(t(1:2))
qgraph(PCorMat, layout = L, title = "Partial correlation network", 
          maximum = 1, cut = 0.1, minimum = 0, esize = 20)
qgraph(PCorMat_FDR, layout = L, title = "Local FDR partial correlation network", 
          maximum = 1, cut = 0.1, minimum = 0, esize = 20)

# Centrality:
centralityPlot(list(cor=PCorMat, fdr = PCorMat_FDR))

## End(Not run)
</code></pre>

<hr>
<h2 id='flow'>
Draws network as a flow diagram showing how one node is connected to all other nodes
</h2><span id='topic+flow'></span>

<h3>Description</h3>

<p>This function will draw one node of interest on the left, then subsequently draw all other nodes in vertical levels to the right, in the order of direct (unweighted) connectiveness to the node of interest. Layout is based on the <code>layout_as_tree</code> function from the igraph package. This allows one to see how one node connects to other nodes in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flow(object, from, horizontal = TRUE, equalize = TRUE, minCurve = 1, maxCurve = 4, 
      unfadeFirst = FALSE, fade = TRUE, labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flow_+3A_object">object</code></td>
<td>

<p>A qgraph object
</p>
</td></tr>
<tr><td><code id="flow_+3A_from">from</code></td>
<td>

<p>Integer or character indicating the (label of the) node of interest.
</p>
</td></tr>
<tr><td><code id="flow_+3A_horizontal">horizontal</code></td>
<td>

<p>Logical, should the flow diagram be plotted horizontally or vertically
</p>
</td></tr>
<tr><td><code id="flow_+3A_equalize">equalize</code></td>
<td>

<p>Logical, should the placement of nodes be equalized per level.
</p>
</td></tr>
<tr><td><code id="flow_+3A_mincurve">minCurve</code></td>
<td>

<p>Minimum curve of edges on the same level
</p>
</td></tr>
<tr><td><code id="flow_+3A_maxcurve">maxCurve</code></td>
<td>

<p>Maximum curve of edges on the same level
</p>
</td></tr>
<tr><td><code id="flow_+3A_unfadefirst">unfadeFirst</code></td>
<td>

<p>Logical, should edges between the node of interest be unfaded?
</p>
</td></tr>
<tr><td><code id="flow_+3A_fade">fade</code></td>
<td>

<p>'fade' argument as used in <code><a href="#topic+qgraph">qgraph</a></code>
</p>
</td></tr>
<tr><td><code id="flow_+3A_labels">labels</code></td>
<td>

<p>'labels' argument as used in <code><a href="#topic+qgraph">qgraph</a></code>
</p>
</td></tr>
<tr><td><code id="flow_+3A_...">...</code></td>
<td>

<p>Arguments sent to qgraph
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load data:
library("psych")
data(bfi)

# Compute polychoric correlations:
corMat &lt;- cor_auto(bfi[,1:25])

# Glasso network:
g2 &lt;- qgraph(corMat,  cut = 0, graph = "glasso", sampleSize = nrow(bfi),
             threshold = TRUE)

# Flow from A2:
flow(g2, "A2", horizontal = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getWmat'>
Obtain a weights matrix
</h2><span id='topic+getWmat'></span><span id='topic+getWmat.matrix'></span><span id='topic+getWmat.data.frame'></span><span id='topic+getWmat.igraph'></span><span id='topic+getWmat.qgraph'></span>

<h3>Description</h3>

<p>This function extracts a weights matrix from various kinds of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
getWmat(x,nNodes,labels, directed = TRUE,...)
## S3 method for class 'data.frame'
getWmat(x,nNodes,labels, directed = TRUE,...)
## S3 method for class 'igraph'
getWmat(x,labels,...)
## S3 method for class 'qgraph'
getWmat(x,directed,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWmat_+3A_x">x</code></td>
<td>

<p>An input object
</p>
</td></tr>
<tr><td><code id="getWmat_+3A_nnodes">nNodes</code></td>
<td>

<p>Number of Nodes
</p>
</td></tr>
<tr><td><code id="getWmat_+3A_labels">labels</code></td>
<td>

<p>A vector specifying the labels of each node
</p>
</td></tr>
<tr><td><code id="getWmat_+3A_directed">directed</code></td>
<td>

<p>Logical indicating if the graph should be directed
</p>
</td></tr>
<tr><td><code id="getWmat_+3A_...">...</code></td>
<td>

<p>Ignored
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weights matrix
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='ggmFit'>
Obtain fit measures of a Gaussian graphical model
</h2><span id='topic+ggmFit'></span>

<h3>Description</h3>

<p>Obtain fit measures of a given Gaussian graphical model (GGM). Input can be either a partial correlation matrix, inverse covariance matrix or <code>qgraph</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggmFit(pcor, covMat, sampleSize, refit = TRUE, ebicTuning = 0.5, 
        nPar, invSigma, tol = sqrt(.Machine$double.eps), verbose = TRUE,
        countDiagonalPars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggmFit_+3A_pcor">pcor</code></td>
<td>

<p>Implied partial correlation matrix or <code>qgraph</code> object.
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_covmat">covMat</code></td>
<td>

<p>Observed variance-covariance matrix
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_samplesize">sampleSize</code></td>
<td>

<p>The sample size used in computing the variance-covariance matrix
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_refit">refit</code></td>
<td>

<p>Logical, should the network be refitted using <code><a href="glasso.html#topic+glasso">glasso</a></code>?
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_ebictuning">ebicTuning</code></td>
<td>

<p>EBIC tuning parameter.
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_invsigma">invSigma</code></td>
<td>

<p>Implied inverse variance-covariance matrix. If this object is assigned <code>pcor</code> is not used.
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_npar">nPar</code></td>
<td>

<p>Number of parameters, if not specified this is retrieved from the number of zeroes in the inverse variance&ndash;covariance matrix. Can be used to compute fit measures of any statistical model (e.g., SEM). 
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_tol">tol</code></td>
<td>

<p>Tolerance for setting an edge to zero.
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should progress reports be printed to the console?
</p>
</td></tr>
<tr><td><code id="ggmFit_+3A_countdiagonalpars">countDiagonalPars</code></td>
<td>

<p>Logical, should the diagonal of the precision matrix be counted as parameters?
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("psych")

# Load BFI data:
data(bfi)
bfi &lt;- bfi[,1:25]

# Covariance matrix:
CovMat &lt;- cov(bfi[,1:25], use="pairwise.complete.obs")

# Compute network:
EBICgraph &lt;- qgraph(CovMat, graph = "glasso", sampleSize = nrow(bfi),
                    tuning = 0.5, layout = "spring", title = "BIC", details = TRUE)

# Obtain fit measures:
fitNetwork &lt;- ggmFit(EBICgraph, CovMat, nrow(bfi))
fitNetwork
</code></pre>

<hr>
<h2 id='ggmModSelect'>
Unregularized GGM model search
</h2><span id='topic+ggmModSelect'></span>

<h3>Description</h3>

<p>This function will search for an optimal Gaussian graphical model by minimizing the (extended) Bayesian information criterion of unregularized GGM models. Selecting unregularized GGMs according to EBIC has been shown to converge to the true model (Foygel &amp; Drton, 2010). The algorithm starts with refitting models from the glassopath, and subsequently adds and removes edges until EBIC can no longer be improved (see details). Note, contrary to <code><a href="#topic+EBICglasso">EBICglasso</a></code>, the default for the EBIC hyperparameter gamma is set to 0, indicating BIC model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggmModSelect(S, n, gamma = 0, start = c("glasso", "empty", "full"), stepwise = TRUE, 
  considerPerStep = c("subset", "all"), verbose = TRUE, nCores = 1, checkPD = TRUE, 
  criterion = 'ebic', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggmModSelect_+3A_s">S</code></td>
<td>

<p>A covariance or correlation matrix
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_n">n</code></td>
<td>

<p>Sample size used in computing <code>S</code>
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_gamma">gamma</code></td>
<td>

<p>EBIC tuning parameter. 0 (default) leads to BIC model selection. 0.25 or 0.5 are typical choices for more conservative model selection.
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_start">start</code></td>
<td>

<p>What model should stepwise search start from? <code>"glasso"</code> to first run glasso to obtain the best fitting model, <code>"empty"</code> for an empty network, <code>"full"</code> for a saturated network, or a matrix encoding the starting network.
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_stepwise">stepwise</code></td>
<td>

<p>Logical indicating if stepwise model search should be used.
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_considerperstep">considerPerStep</code></td>
<td>

<p><code>"subet"</code> to only consider changing edges that previously indicated improvement in EBIC, unless changing no edge indicated an improvement to EBIC, in which case all edges are again considered (see details). <code>"all"</code> will consider changing all edges at every step.
</p>
</td></tr> 
<tr><td><code id="ggmModSelect_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should progress reports be printed to the console?
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores to use in testing models.
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_checkpd">checkPD</code></td>
<td>

<p>If <code>TRUE</code>, the function will check if <code>S</code> is positive definite and return an error if not. It is not advised to use a non-positive definite matrix as input as (a) that can not be a covariance matrix and (b) glasso can hang if the input is not positive definite.
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_criterion">criterion</code></td>
<td>

<p>String indicating an output of <code><a href="#topic+ggmFit">ggmFit</a></code> to be minimized
</p>
</td></tr>
<tr><td><code id="ggmModSelect_+3A_...">...</code></td>
<td>

<p>Arguments sent to <code><a href="glasso.html#topic+glasso">glasso</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The full algorithm is as follows:
</p>
<p>1. Run glasso to obtain 100 models
</p>
<p>2. Refit all models without regularization
</p>
<p>3. Choose the best according to EBIC
</p>
<p>4. Test all possible models in which one edge is changed (added or removed)
</p>
<p>5. If no edge can be added or changed to improve EBIC, stop here
</p>
<p>6. Change the edge that best improved EBIC, now test all other edges that would have also lead to an increase in EBIC again
</p>
<p>7. If no edge can be added or changed to improve EBIC, go to 4, else, go to 6.
</p>
<p>When <code>stepwise = FALSE</code>, steps 4 to 7 are ignored. When <code>considerPerStep = "all"</code>, all edges are considered at every step. Note that this algorithm is very slow in higher dimensions (e.g., above 30-40 nodes). Note that EBIC computation is slightly different as in <code><a href="#topic+EBICglasso">EBICglasso</a></code> and instead follows the implementation in Lavaan.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>The optimal partial correlation network</p>
</td></tr>
<tr><td><code>EBIC</code></td>
<td>
<p>EBIC corresponding to optimal network.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp
</p>


<h3>References</h3>

<p>Foygel, R., &amp; Drton, M. (2010). Extended Bayesian information criteria for Gaussian graphical models. In Advances in neural information processing systems (pp. 604-612).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load data:
library("psych")
data(bfi)

# Compute polychoric correlations:
corMat &lt;- cor_auto(bfi[,1:25])

# Optimize network:
Results &lt;- ggmModSelect(corMat, nrow(bfi), gamma = 0.5, nCores = 8)

# Plot results:
qgraph(Results$graph, layout = "spring", cut = 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeBW'>
A qgraph plot can be understood in black and white
</h2><span id='topic+makeBW'></span>

<h3>Description</h3>

<p>Plot a qgraph network that can be understood also in black and white or grayscale. Positive lines are full and negative ones are dashed. Nodes colors are associated to unique motifs. Up to 12 different motifs are supported at the moment.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBW(x, colorlist = NA,  plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBW_+3A_x">x</code></td>
<td>

<p>A qgraph object
</p>
</td></tr>
<tr><td><code id="makeBW_+3A_colorlist">colorlist</code></td>
<td>

<p>Optional: a vector of colors. See details. 
</p>
</td></tr>
<tr><td><code id="makeBW_+3A_plot">plot</code></td>
<td>

<p>logical: if FALSE, the network is not plotted. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no colorlist is specified, each color is randomly associated to one of the motifs. Specifying colorlist serves for (a) assigning colors to a specific motif, because the first color in the vector will always be associated to the first motif (this can be used e.g., for being consistent across plots), or (b) for associating motifs only to some of the colors, but not to others, since only in colors in the colorlist are associated to motifs if a colorlist is specified.
</p>


<h3>Value</h3>

<p>Silently returns a qgraph object &quot;x&quot; in which two new elements are present, &quot;$graphAttributes$Nodes$density&quot; and &quot;$graphAttributes$Nodes$angles&quot;, which affect how the nodes are plotted. Can also be further customized and then re-plotted using plot(x). 
</p>


<h3>Author(s)</h3>

<p>Giulio Costantini
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
x &lt;- cor(matrix(rnorm(25), nrow = 5))
colors &lt;- c("red", "red", "blue", "blue", "white")

# colored qgraph plot
qg &lt;- qgraph(x, colors = colors)

# randomly assing motifs to colors (notice that white nodes stay white)
makeBW(qg)
# associate a motif only to one of the colors
makeBW(qg, colorlist = c("blue"))
# define an order, which allows to choose motifs
makeBW(qg, colorlist = c("blue", "red"))
makeBW(qg, colorlist = c("red", "blue"))
</code></pre>

<hr>
<h2 id='mat2vec'>
Weights matrix to vector
</h2><span id='topic+mat2vec'></span>

<h3>Description</h3>

<p>Converts a weights matrix to a vector of weights. If the matrix is symmetrical only upper triangle values are returned in the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2vec(x, diag = FALSE, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2vec_+3A_x">x</code></td>
<td>

<p>A weights matrix
</p>
</td></tr>
<tr><td><code id="mat2vec_+3A_diag">diag</code></td>
<td>

<p>Logical: should diagonal values be included?
</p>
</td></tr>
<tr><td><code id="mat2vec_+3A_tol">tol</code></td>
<td>

<p>Tolerance level
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='mutualInformation'>
Computes the mutual information between nodes
</h2><span id='topic+mutualInformation'></span>

<h3>Description</h3>

<p>Computes the mutual information from one node to all other nodes, or between sets of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutualInformation(ggm, from, to = "all", covMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutualInformation_+3A_ggm">ggm</code></td>
<td>

<p>Partial correlation network. Can be missing if 'covMat' is supplied.
</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_from">from</code></td>
<td>

<p>Integer vector corresponding to one set of nodes. Defaults to all nodes.
</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_to">to</code></td>
<td>

<p>Integer vector corresponding to another set of nodes, or <code>'all'</code> to compute the mutual information of each node to all other nodes.
</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_covmat">covMat</code></td>
<td>

<p>Variance-covariance matrix. Can be missing if 'ggm' is supplied.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp
</p>

<hr>
<h2 id='pathways'>
Highlight shortest pathways in a network
</h2><span id='topic+pathways'></span>

<h3>Description</h3>

<p>This function highlights the shortest paths between nodes in a network made by <code><a href="#topic+qgraph">qgraph</a></code>. Based on Isvoranu et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathways(graph, from, to, fading = 0.25, lty = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathways_+3A_graph">graph</code></td>
<td>

<p>Output from <code><a href="#topic+qgraph">qgraph</a></code>.
</p>
</td></tr>
<tr><td><code id="pathways_+3A_from">from</code></td>
<td>

<p>A vector indicating the first set of nodes between which pathways should be highlighted. Can be numeric or characters corresponding to node labels.
</p>
</td></tr>
<tr><td><code id="pathways_+3A_to">to</code></td>
<td>

<p>A vector indicating the second set of nodes between which pathways should be highlighted. Can be numeric or characters corresponding to node labels.
</p>
</td></tr>
<tr><td><code id="pathways_+3A_fading">fading</code></td>
<td>

<p>The fading of the edges that are not part of shortest paths between 'from' and 'to'.
</p>
</td></tr>
<tr><td><code id="pathways_+3A_lty">lty</code></td>
<td>

<p>The line type of the edges that are not part of shortest paths between 'from' and 'to'. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp and Adela M. Isvoranu
</p>


<h3>References</h3>

<p>Isvoranu, A. M., van Borkulo, C. D., Boyette, L. L., Wigman, J. T., Vinkers, C. H., Borsboom, D., &amp; Group Investigators. (2016). A Network Approach to Psychosis: Pathways Between Childhood Trauma and Psychotic Symptoms. Schizophrenia bulletin, sbw055.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgraph">qgraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("qgraph")
library("psych")
data(bfi)

# Compute correlations:
CorMat &lt;- cor_auto(bfi[,1:25])

# Compute graph with tuning = 0 (BIC):
BICgraph &lt;- qgraph(CorMat, graph = "glasso", sampleSize = nrow(bfi),
                   tuning = 0, layout = "spring", title = "BIC", details = TRUE)

# All paths between Agreeableness and Neuroticism:
pathways(BICgraph, 
         from = c("A1","A2","A3","A4","A5"), 
         to = c("N1","N2","N3","N4","N5"))

</code></pre>

<hr>
<h2 id='plot.qgraph'>
Plot method for &quot;qgraph&quot;
</h2><span id='topic+plot.qgraph'></span>

<h3>Description</h3>

<p>Plots an object created by <code><a href="#topic+qgraph">qgraph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qgraph'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qgraph_+3A_x">x</code></td>
<td>

<p>A &quot;qgraph&quot; object
</p>
</td></tr>
<tr><td><code id="plot.qgraph_+3A_...">...</code></td>
<td>

<p>Not used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the result of <code><a href="#topic+qgraph">qgraph</a></code> is stored, such as <code>Graph &lt;- qgraph(...)</code>, the plot can be recreated in two ways. <code>qgraph(Graph, ...))</code> reruns <code>qgraph</code> with the same arguments used in the origina call except those restated in the dots. For example <code>qgraph(Graph, shape = "square")</code> will recreate the same plot but now use square nodes instead of circular. <code>plot(Graph)</code> will NOT rerun <code>qgraph</code> but simply plot the qgraph object. This means that now specific graph attributes can be changed before plotting.
</p>
<p>More specific, <code>qgraph(Graph)</code> will base the new plot on the <code>Arguments</code> element of the <code>qgraph</code> object and <code>plot(qgraph)</code> will base the new plot on the <code>graphAttributes</code> element of qgraph.
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp (mail@sachaepskamp.com)
</p>

<hr>
<h2 id='print.qgraph'>
Print edgelist
</h2><span id='topic+print.qgraph'></span>

<h3>Description</h3>

<p>This function prints the edgelist of a &quot;qgraph&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qgraph'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.qgraph_+3A_x">x</code></td>
<td>

<p>A &quot;qgraph&quot; object
</p>
</td></tr>
<tr><td><code id="print.qgraph_+3A_...">...</code></td>
<td>

<p>These arguments are not used
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgraph">qgraph</a></code>
</p>

<hr>
<h2 id='qgraph'>qgraph</h2><span id='topic+qgraph'></span>

<h3>Description</h3>

<p>This is the main function of qgraph which automatically creates an appropriate network and sends it to the plotting method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgraph( input, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgraph_+3A_input">input</code></td>
<td>
<p>Can be either a weights matrix or an edgelist. Can also be an object of class &quot;sem&quot; (sem), &quot;mod&quot; (sem), &quot;lavaan&quot; (lavaan), &quot;principal&quot; (psych), &quot;loadings&quot; (stats), &quot;factanal&quot; (stats), &quot;graphNEL&quot; (Rgraphviz), &quot;pcAlgo&quot; (pcalg),  <code>"huge"</code> (huge), <code>"select"</code> (huge) or the output of <code>glasso</code></p>
</td></tr> 
<tr><td><code id="qgraph_+3A_...">...</code></td>
<td>
<p>Any additional arguments described below. Also a list with class &quot;qgraph&quot; can be added that contains any of these arguments (this is returned invisibly by the function)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because of the amount of arguments the usage of the qgraph function has been reduced by using the ... method for clarity. This does mean that arguments need to be specified by using their exact name. For instance, to specify color=&quot;red&quot; you can not use col=&quot;red&quot;.
</p>
<p>Important to note is that qgraph needs to compute in many graphs where the border of nodes are in the plotting area. If the graph is manually rescaled (such as through the &quot;zoom&quot; option in RStudio) the plotting area is changed. This means that the computed location of the border of nodes is no longer valid if the nodes are to remain perfectly square or circular. To overcome this, the <code>usePCH</code> argument can be used. If this argument is set to <code>FALSE</code> nodes will be plotted as polygons meaning they will rescale with rescaling the graph (circles can become ovals) and not have perfect resolution in PDF files. If <code>usePCH</code> is set to <code>TRUE</code> a default plotting symbol is used meaning the graph can not be rescaled but the node will look good in PDF. By defaut, <code>qgraph</code> sets <code>usePCH</code> to <code>TRUE</code> if it detects the graph is stored in a file. 
</p>
<p>While the <code>usePCH</code> argument makes graphs rescalable it is not a perfect solution. It is highly recommended to NOT RESCALE PLOTTING AREAS when using qgraph, or to rerun qgraph after the plotting area is rescaled. This means using save graph option fro RStudio shoud be avoided in favor of the <code>filetype</code> argument in <code>qgraph</code>
</p>


<h3>Value</h3>

<p>qgraph returns (invisibly) a 'qgraph' object containing:
</p>
<table>
<tr><td><code>Edgelist</code></td>
<td>
<p>A list containing for each edge the node of origin, node of destination, weight en wether the edge is directed and bidirectional.</p>
</td></tr>
<tr><td><code>Arguments</code></td>
<td>
<p>A list containing the arguments used in the <code>qgraph</code> call.</p>
</td></tr>
<tr><td><code>plotOptions</code></td>
<td>
<p>A list containing numerous options used in the plotting method.</p>
</td></tr>
<tr><td><code>graphAttributes</code></td>
<td>
<p>A list containing numerous attributes for nodes, edges and the entire graph</p>
</td></tr>
<tr><td><code>layout</code></td>
<td>
<p>A matrix containing the layout used in the plot</p>
</td></tr>
<tr><td><code>layout.orig</code></td>
<td>
<p>A matrix containing the original (unscaled) layout.</p>
</td></tr>
</table>


<h3>Important additional arguments</h3>

	

<dl>
<dt>layout</dt><dd><p>This argument controls the layout of the graph. &quot;circle&quot; places all nodes in a single circle, &quot;groups&quot; gives a circular layout in which each group is put in separate circles and &quot;spring&quot; gives a force embedded layout. It also can be a matrix with a row for each node and x and y coordinates in the first and second column respectively. Defaults to &quot;circular&quot; in weighted graphs without a groups list, &quot;groups&quot; in weighted graphs with a groups list, and &quot;spring&quot; in unweighted graphs. Can also be a function from the igraph package.</p>
</dd>
<dt>groups</dt><dd><p>An object that indicates which nodes belong together. Can be a list in which each element is a vector of integers identifying the numbers of the nodes that belong together, or a factor.</p>
</dd>
<dt>minimum</dt><dd><p>Edges with absolute weights under this value are not shown (but not omitted). Defaults to 0. Can also be set to <code>"sig"</code> to only show significant edges for <code>graph = "cor"</code> and <code>graph = "pcor"</code>).  Significance level is controlled by <code>alpha</code> and <code>bonf</code> arguments</p>
</dd>
<dt>maximum</dt><dd><p>qgraph regards the highest of the maximum or highest absolute edge weight as the highest weight to scale the edge widths too. To compare several graphs, set this argument to a higher value than any edge weight in the graphs (typically 1 for correlations).</p>
</dd>
<dt>cut</dt><dd><p>In weighted graphs, this argument can be used to cut the scaling of edges in width and color saturation. Edges with absolute weights over this value will have the strongest color intensity and become wider the stronger they are, and edges with absolute weights under this value will have the smallest width and become vaguer the weaker the weight. If this is set to <code>0</code>, no cutoff is used and all edges vary in width and color. Defaults to 0 for graphs with less then 20 nodes. For larger graphs the <code>cut</code> value is automatically chosen to be equal to the maximum of the 75th quantile of absolute edge strengths or the edge strength corresponding to 2n-th edge strength (n being the number of nodes.)</p>
</dd>
<dt>details</dt><dd><p>Logical indicating if minimum, maximum and cutoff score should be printed under the graph. Defaults to FALSE.</p>
</dd>
<dt>threshold</dt><dd><p>A numeric value that defaults to 0. Edges with absolute weight that are not above this value are REMOVED from the network. This differs from <code>minimum</code> which simply changes the scaling of width and color so that edges with absolute weight under minimum are not plotted/invisible. Setting a threshold influences the spring layout and centrality measures obtained with the graph whereass setting a minimum does not. In the case of correlation (<code>graph = "cor"</code>) or partial correlation (<code>graph = "pcor"</code>) networks this argument can also be given a string to omit insignificant edges. See description of this argumet in the next section (Additional options for correlation/covariance matrices).</p>
</dd>
<dt>palette</dt><dd><p>The palette used for coloring nodes when the <code>groups</code> argument is used. Can be one of <code>"rainbow"</code> (default), <code>"colorblind"</code> (making use of http://jfly.iam.u-tokyo.ac.jp/color/), <code>"pastel"</code>, <code>"gray"</code>, <code>"R"</code> and <code>"ggplot2"</code>.</p>
</dd>
<dt>theme</dt><dd><p>This argument sets different defaults for various graphical arguments (most notably <code>posCol</code>, <code>negCol</code> and <code>palette</code>). Can be <code>"classic"</code>, <code>"colorblind"</code>, <code>"gray"</code>, <code>"Hollywood"</code>, <code>"Borkulo"</code>, <code>"gimme"</code>, <code>"TeamFortress"</code>, <code>"Reddit"</code>, <code>"Leuven"</code> or <code>"Fried"</code>.</p>
</dd>
</dl>



<h3>Additional options for correlation/covariance matrices</h3>


<dl>
<dt>graph</dt><dd><p>Type of graph to be made when a correlation or covariance matrix is used as input. Setting this to other values than 
<code>"default"</code> will check if the matrix is a correlation or covariance matrix; if the matrix is not positive definite <code><a href="Matrix.html#topic+nearPD">nearPD</a></code> from the Matrix package will be used. Options are:
</p>

<dl>
<dt>&quot;cor&quot;</dt><dd><p>Plots a correlation network. Runs <code><a href="stats.html#topic+cov2cor">cov2cor</a></code> if input is detected to be a covariance matrix and plots the input as is</p>
</dd>
<dt>&quot;pcor&quot;</dt><dd><p>Plots a partial correlation network, using <code>cor2pcor</code> from the parcor package (Kraemer, Schaefer and Boulesteix, 2009) on the input matrix</p>
</dd>
<dt>&quot;glasso&quot;</dt><dd><p>Will run <code><a href="#topic+EBICglasso">EBICglasso</a></code> to obtain an optimal sparse estimate of the partial correlation matrix using the glasso package (Friedman, Hastie and Tibshirani, 2011)</p>
</dd>
</dl>

<p>Outdated and limited supported options are <code>"factorial"</code>, which will create a graph based on an exploratory factor analysis, and <code>"sig"</code> will transform all correlations in p-values (using the fdrtool package; Korbinian Strimmer, 2014) and force mode=&quot;sig&quot;. &quot;sig2&quot; will do the same but show p-values based on negative statistics in shades of orange</p>
</dd>
<dt>threshold</dt><dd><p>In addition to a numeric value to omit edges this argument can also be assigned a string to omit insignficant edges. Note that this REMOVES edges from the network (which influences centrality measures and the spring layout). Can be <code>"sig"</code> to compute significance without correction for multiple testing, <code>"holm"</code>, <code>"hochberg"</code>, <code>"hommel"</code>, <code>"bonferroni"</code>, <code>"BH"</code>, <code>"BY"</code>, <code>"fdr"</code> or <code>"none"</code> which are used directly in the <code>adjust</code> argument in <code><a href="psych.html#topic+corr.p">corr.p</a></code> of the psych package (Revelle, 2014). In addition, this argument can be assigned <code>"locfdr"</code> in which edges are set to zero if the local FDR is below <code>FDRcutoff</code>. <code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code> from the fdrtool package (Klaus and Strimmer, 2014) is used to compute these measures, which is used inside <code><a href="#topic+FDRnetwork">FDRnetwork</a></code>.</p>
</dd>
<dt>sampleSize</dt><dd><p>The sample-size. Used when <code>graph = "glasso"</code> or <code>minimum = "sig"</code></p>
</dd>
<dt>tuning</dt><dd><p>A tuning parameter used in estimation. Currently only used when <code>graph = "glasso"</code> and corresponds to the <code>gamma</code> argument</p>
</dd>
<dt>lambda.min.ratio</dt><dd><p>The minimal lambda ratio used in <code><a href="#topic+EBICglasso">EBICglasso</a></code>, defaults to 0.01.</p>
</dd>
<dt>gamma</dt><dd><p>Alias for tuning (overwrites the tuning argument).</p>
</dd>
<dt>refit</dt><dd>
<p>Logical, should the optimal graph be refitted without LASSO regularization? Defaults to <code>FALSE</code> and only used if <code>graph = "glasso"</code>.
</p>
</dd>
<dt>countDiagonal</dt><dd>
<p>Should diagonal be counted in EBIC computation? Defaults to <code>FALSE</code>. Set to <code>TRUE</code> to mimic qgraph &lt; 1.3 behavior (not recommended!).
</p>
</dd>
<dt>alpha</dt><dd><p>The significance level (defaults to 0.05) to be used for not showing edges if <code>minimum = "sig"</code>.</p>
</dd>
<dt>bonf</dt><dd><p>Logical indicating if a bonferonni correction should be applied if <code>minimum = "sig"</code>.</p>
</dd>
<dt>FDRcutoff</dt><dd><p>Cutoff used in which partial correlations should be included if <code>graph = "fdr"</code>. Defaults to 0.9</p>
</dd>
</dl>



<h3>Output arguments</h3>


<dl>
<dt>mar</dt><dd><p>A vector of the form c(bottom, left, top, right) which gives the margins. Works similar to the argument in par(). Defaults to c(3,3,3,3)</p>
</dd>
<dt>filetype</dt><dd><p>A character containing the file type to save the output in. &quot;R&quot; outputs in a new R window, &quot;pdf&quot; creates a pdf file. &quot;svg&quot; creates a svg file (requires RSVGTipsDevice). &quot;tex&quot; creates LaTeX code for the graph (requires tikzDevice). 'jpg', 'tiff' and 'png' can also be used. If this is given any other string (e.g. filetype=&quot;&quot;) no device is opened. Defaults to 'R' if the current device is the NULL-device or no new device if there already is an open device. A function such as <code>x11</code> can also be used</p>
</dd>
<dt>filename</dt><dd><p>Name of the file without extension</p>
</dd>
<dt>width</dt><dd><p>Width of the plot, in inches</p>
</dd>
<dt>height</dt><dd><p>Height of the plot, in inches</p>
</dd>
<dt>normalize</dt><dd><p>Logical, should the plot be normalized to the plot size. If TRUE (default) border width, vertex size, edge width and arrow sizes are adjusted to look the same for all sizes of the plot, corresponding to what they would look in a 7 by 7 inches plot if normalize is FALSE.</p>
</dd>
<dt>DoNotPlot</dt><dd><p>Runs qgraph but does not plot. Useful for saving the output (i.e. layout) without plotting</p>
</dd>
<dt>plot</dt><dd><p>Logical. Should a new plot be made? Defaults to TRUE. Set to FALSE to add the graph to the existing plot.</p>
</dd>
<dt>rescale</dt><dd><p>Logical. Defines if the layout should be rescaled to fit the -1 to 1 x and y area. Defaults to TRUE. Can best be used in combination with plot=FALSE.</p>
</dd>
<dt>standAlone</dt><dd><p>Logical. If filetype=&quot;tex&quot; this argument can be used to choose between making the output a standalone LaTeX file or only the codes to include the graph.</p>
</dd>
</dl>


<h3>Graphical arguments</h3>

	


<h4>Nodes</h4>

<p>These arguments influence the plotting of nodes in qgraph. Most of them can be assigned a single value or a vector with a value for each node.
</p>

<dl>
<dt>color</dt><dd><p>A vector with a color for each element in the groups list, or a color for each node. Defaults to the background color (&quot;bg&quot; argument, which defaults to &quot;white&quot;) without groups list and rainbow(length(groups)) with a groups list.</p>
</dd>
<dt>vsize</dt><dd><p>A value indicating the size of the nodes (horizontal if shape is &quot;rectangle&quot;. Can also be a vector of length 2 (nodes are scaled to degree) or a size for each node. Defaults to 8*exp(-nNodes/80)+1</p>
</dd>
<dt>vsize2</dt><dd><p>A value indicating the vertical size of the nodes where the shape is &quot;rectangle&quot;. Can also be a vector of length 2 (nodes are scaled to degree) or a size for each node. Defaults to the value of 'vsize'. If 'vsize' is not assigned this value is used as a scalar to 'vsize' (e.g., <code>vsize2 = 1/2</code> would result in rectangled nodes where the height is half the default width)</p>
</dd>
<dt>node.width</dt><dd><p>Scalar on the default value of 'vsize'. Defaults to 1.</p>
</dd>
<dt>node.height</dt><dd><p>Scalar on the default value of 'vsize2'. Defaults to 1.</p>
</dd>
<dt>borders</dt><dd><p>Logical indicating if borders should be plotted, defaults to TRUE.</p>
</dd>
<dt>border.color</dt><dd><p>Color vector indicating colors of the borders. Is repeated if length is equal to 1. Defaults to &quot;black&quot;</p>
</dd>
<dt>border.width</dt><dd><p>Controls the width of the border. Defaults to 2 and is comparable to 'lwd' argument in 'points'.</p>
</dd>
<dt>shape</dt><dd><p>A character containing the shape of the nodes. <code>"circle"</code>, <code>"square"</code>, <code>"triangle"</code> and <code>"diamond"</code> are supported. In addition, can be a name of an element of <code>polygonList</code> to plot the corresponding polygon (not reccomended for large graphs), which by default includes shapes <code>"ellipse"</code> and <code>"heart"</code> Can also be a vector with a shape for each node. Defaults to &quot;circle&quot;.</p>
</dd>
<dt>polygonList</dt><dd><p> A list contaning named lists for each element to include polygons to lookup in the <code>shape</code> argument. Each element must be named as they are used in <code>shape</code> and contain a list with elements <code>x</code> and <code>y</code> contaning the coordinates of the polygon. By default <code>ellipse</code> and <code>heart</code> are added to this list. These polygons are scaled according to <code>vsize</code> and <code>vsize2</code></p>
</dd>
<dt>vTrans</dt><dd><p>Transparency of the nodes, must be an integer between 0 and 255, 255 indicating no transparency. Defaults to 255</p>
</dd>
<dt>subplots</dt><dd><p>A list with as elements R expressions or NULL for each node. If it is an R expression it is evaluated to create a plot for the node.</p>
</dd>
<dt>subpars</dt><dd><p>List of graphical parameters to be used in the subplots</p>
</dd>
<dt>subplotbg</dt><dd><p>Background to be used in the sublots. If missing inherits from 'background' argument.</p>
</dd>
<dt>images</dt><dd><p>A character vector of length 1 or the same length as the number of nodes indicating the file location of PNG or JPEG images to use as nodes. Can be NA to not plot an image as node and overwrites 'subplots'
</p>
</dd>
<dt>noPar</dt><dd><p>Set to <code>TRUE</code> to not have qgraph run the <code>par</code> function. Useful when sending qgraph plots as sublots using <code>subplots</code>.</p>
</dd>
<dt>pastel</dt><dd><p>Logical, should default colors (for groups or edge equality constraints) be chosen from pastel colors? If TRUE then <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code> is used.</p>
</dd>
<dt>rainbowStart</dt><dd><p>A number between 0 and 1 indicating the offset used in rainbow functions for default node coloring.</p>
</dd>
<dt>usePCH</dt><dd><p>Logical indicating if nodes should be drawn using polygons or base R plotting symbols. Defaults to <code>TRUE</code> if more than 50 nodes are used in the graph or if the graph is stored in a file. See details.</p>
</dd>
<dt>node.resolution</dt><dd><p>Resolution of the nodes if <code>usePCH=FALSE</code>. Defaults to 100</p>
</dd>
<dt>title</dt><dd><p>String with a title to be drawn in the topleft of the plot.</p>
</dd>
<dt>title.cex</dt><dd><p>Size of the title, defaults to 1.</p>
</dd>
<dt>preExpression</dt><dd><p>A parsable string containing R codes to be evaluated after opening a plot and before drawing the graph.</p>
</dd>
<dt>postExpression</dt><dd><p>A parsable string containing R codes to be evaluated just before closing the device.</p>
</dd>
<dt>diag</dt><dd><p>Should the diagonal also be plotted as edges? defaults to FALSE. Can also be &quot;col&quot; to plot diagonal values as vertex colors.</p>
</dd>
</dl>




<h4>Node labels</h4>

<p>These arguments influence the plotting of node labels in qgraph. Most of them can be assigned a single value or a vector with a value for each node.
</p>

<dl>
<dt>labels</dt><dd><p>If FALSE, no labels are plotted. If TRUE, order in weights matrix is used as labels. This can also be a vector with a label for each node. Defaults for graphs with less than 20 nodes to a 3 character abbreviation of the columnames and rownames if these are identical or else to TRUE. If a label contains an asterisk (e.g. &quot;x1*&quot;) then the asterisk will be omitted and the label will be printed in symbol font (use this for Greek letters). Can also be a list with a label as each element, which can be expressions for more advanced mathematical annotation.</p>
</dd>
<dt>label.cex</dt><dd><p>Scalar on the label size.</p>
</dd>
<dt>label.color</dt><dd><p>Character containing the color of the labels, defaults to &quot;black&quot;</p>
</dd>
<dt>label.prop</dt><dd><p>Controls the proportion of the width of the node that the label rescales to. Defaults to 0.
9.</p>
</dd>
<dt>label.norm</dt><dd><p>A single string that is used to normalize label size. If the width of the label is lower than the width of the hypothetical label given by this argument the width of label given by this argument is used instead. Defaults to &quot;OOO&quot; so that every label up to three characters has the same font size.</p>
</dd>
<dt>label.scale</dt><dd><p>Logical indicating if labels should be scaled to fit the node. Defaults to TRUE.</p>
</dd>
<dt>label.scale.equal</dt><dd><p>Logical, set to <code>TRUE</code> to make make the font size of all labels equal</p>
</dd>
<dt>label.font</dt><dd><p>Integer specifying the label font of nodes. Can be a vector with value for each node</p>
</dd>
<dt>label.fill.vertical</dt><dd>
<p>Scalar (0 - 1) indicating the maximum proportion a label may fill a node vertically.
</p>
</dd>
<dt>label.fill.horizontal</dt><dd>
<p>Scalar (0 - 1) indicating the maximum proportion a label may fill a node horizontally.
</p>
</dd>
<dt>node.label.offset</dt><dd>
<p>A vector of length two with the x and y offset coordinates of the node label (e.g., <code>c(0.5, 0.5)</code> is the default and centers the label with respect to the node area). The vector is passed to the <code>adj</code> argument of <code>graphics::text</code> function.
</p>
</dd>
<dt>node.label.position</dt><dd>
<p>Either a numeric vector of length 1 (i.e., it gets recycled) or of length equal to the number of nodes in the network, used to set the positions of the node labels. Takes values between 1 and 4 as follows: 1 - bottom; 2 - left; 3 - top; 4 - right. Overrides the <code>node.label.offset</code> argument and values are passed to the <code>pos</code> argument of <code>graphics::text</code> function. Defaults to <code>NULL</code>. 
</p>
</dd>
</dl>




<h4>Edges</h4>

<p>These arguments influence the plotting of edges qgraph. Most of them can be assigned a single value, a vector with a value per edge when an edgelist is used as input or a matrix containing values for each edge when a wheights matrix is used as input.
</p>

<dl>
<dt>esize</dt><dd><p>Size of the largest edge (or what it would be if there was an edge with weight maximum). Defaults to 15*exp(-nNodes/90)+1) for weighted graphs and 2 for unweighted graphs. In directed graphs these values are halved.</p>
</dd>
<dt>edge.width</dt><dd><p>Scalar on 'esize' and 'asize' arguments to make edges wider with a single argument. 'esize' is multiplied with this value and 'asize' with the square root of this value.</p>
</dd>
<dt>edge.color</dt><dd><p>Color of edges. Can be either a single value to make all edges the same color, a matrix with a color for each edge (when using a weights matrix) or a vector with a color for each edge (when using an edgelist). NA indicates that the default color should be used. Note that unless <code>fade=FALSE</code> colors still fade to white corresponding to their strength</p>
</dd>
<dt>posCol</dt><dd><p>Color of positive edges. Can be a vector of two to indicate color of edges under 'cut' value and color of edges over 'cut' value. If 'fade is set to TRUE the first color will be faded the weaker the edge weight is. If this is only one element this color will also be used for edges stronger than the 'cut' value. Defaults to c(&quot;#009900&quot;,&quot;darkgreen&quot;)</p>
</dd>
<dt>negCol</dt><dd><p>Color of negative edges. Can be a vector of two to indicate color of edges under 'cut' value and color of edges over 'cut' value. If 'fade is set to TRUE the first color will be faded the weaker the edge weight is. If this is only one element this color will also be used for edges stronger than the 'cut' value. Defaults to c(&quot;#BF0000&quot;,&quot;red&quot;)</p>
</dd>
<dt>unCol</dt><dd><p>Color to indicate the default edge color of unweighted graphs. Defaults to &quot;#808080&quot;.</p>
</dd>
<dt>probCol</dt><dd><p>Color of the probability edges. Defaults to <code>"blue"</code>. Only used when <code>probabilityEdges = TRUE</code></p>
</dd>
<dt>negDashed</dt><dd><p>Logical, set to <code>TRUE</code> to make negative edges dashed (overwrites <code>lty</code>).</p>
</dd>
<dt>probabilityEdges</dt><dd><p>Logical, do edges indicate probabilities? If this is set to <code>TRUE</code> <code>posCol</code> is overwritten by <code>probCol</code>. Mainly implemented for automatic generation of graphs</p>
</dd>
<dt>colFactor</dt><dd><p>Exponent of transformation in color intensity of relative strength. Defaults to 1 for linear behavior.</p>
</dd>
<dt>trans</dt><dd><p>In weighted graphs: logical indicating if the edges should fade to white (FALSE) or become more transparent (TRUE; use this only if you use a background). In directed graphs this is a value between 0 and 1 indicating the level of transparency. (also used as 'transparency')</p>
</dd>
<dt>fade</dt><dd><p>if TRUE (default) and if 'edge.color' is assigned, transparency will be added to edges that are not transparent (or for which no transparency has been assigned) relative to the edge strength, similar if 'trans' is set to TRUE.</p>
</dd>
<dt>loopRotation</dt><dd><p>A vector with an element for each node with either <code>NA</code> to let qgraph choose the rotation of the loop, or the rotation of the loop per node in radian</p>
</dd>
<dt>loop</dt><dd><p>If diag=TRUE, this can be used to scale the size of the loop. defaults to 1.</p>
</dd>
<dt>lty</dt><dd><p>Line type, see 'par'</p>
</dd>
<dt>edgeConnectPoints</dt><dd><p>This argument specifies the point for each edge to which it connects to a node, in radians. Can be either a matrix with a row for each edge and two columns: The first column indicates the connection point of the source of the edge and the second column specifies the connection point of the destination of the edge. Can also be an array with a row and column for each node two slices which indicate the source and destination of the edge connecting the two nodes.</p>
</dd>
</dl>




<h4>Edge Curvature</h4>

<p>These arguments control the curvature of edges.  Most of them can be assigned a single value, a vector with a value per edge when an edgelist is used as input or a matrix containing values for each edge when a wheights matrix is used as input.
</p>

<dl>
<dt>curve</dt><dd><p>A value indicating how strongly edges should be curved. Either a single value, a vector (edgelist input) with a value for each edge or a matrix (weights matrix input). NA indicates default curve behavior should be used, which only curves edges if there are multiple edges between two nodes.</p>
</dd>
<dt>curveAll</dt><dd><p>Logical, indicating if all edges should be curved with the value of the 'curve' or only edges between nodes that have share multiple edges.</p>
</dd>
<dt>curveDefault</dt><dd><p>The default curvature. Defaults to 1.</p>
</dd>
<dt>curveShape</dt><dd><p>The shape of the curve, as used in <code>xspline</code>. Defaults to <code>-1</code>.</p>
</dd>
<dt>curveScale</dt><dd><p>Logical, should curve scale with distance between nodes. Defaults to <code>TRUE</code>. If <code>FALSE</code>, the curve can be exactly determined. Recommended to set to <code>TRUE</code> for graphs and <code>FALSE</code> for diagrams. The curvature is corrected for the number of nodes and will be smaller if there are more nodes.</p>
</dd>
<dt>curveScaleNodeCorrection</dt><dd><p>Logical, set to <code>FALSE</code> to disable the node correction in <code>curveScale</code>. Defaults to <code>TRUE</code>. Not recommended. Set to <code>FALSE</code> ONLY if you know what you are doing.</p>
</dd>
<dt>curvePivot</dt><dd><p>Quantile to pivot curves on. This can be used to, rather than round edges, make straight edges as curves with &quot;knicks&quot; in them. Can be logical or numeric. <code>FALSE</code> (default) indicates no pivoting in the curved edges, a number indicates the quantile (and one minus this value as quantile) on which to pivot curved edges and <code>TRUE</code> indicates a value of 0.1.</p>
</dd>
<dt>curvePivotShape</dt><dd><p>The shape of the curve around the pivots, as used in <code>xspline</code>. Defaults to <code>0.25</code>.</p>
</dd>
<dt>parallelEdge</dt><dd><p>Logical, set to <code>TRUE</code> to draw parallel straight edges rather than curved edges when there are multiple edges between two nodes. Can be a vector with value per edge for edgelists or a matrix with a value per edge for weights marices.</p>
</dd>
<dt>parallelAngle</dt><dd><p>The distance in radians an edge is shifted if <code>parallel=TRUE</code>. Can be set to <code>NA</code> (default) to determine based on number of edges between two nodes. Can be a vector with value per edge for edgelists or a matrix with a value per edge for weights marices.</p>
</dd>
<dt>parallelAngleDefault</dt><dd><p>The default value for parallelAngle, indicating the angle of the edge furthest from the center. Defaults to <code>pi/6</code></p>
</dd>
</dl>




<h4>Edge Labels</h4>

<p>These arguments influence the plotting of edge labels qgraph. Most of them can be assigned a single value, a vector with a value per edge when an edgelist is used as input or a matrix containing values for each edge when a weights matrix is used as input.
</p>

<dl>
<dt>edge.labels</dt><dd><p>If FALSE, no edge labels are plotted. If TRUE, numerical edge weights are printed on the edges. This can also be a vector with a label for each edge. Defaults to FALSE. If a label contains an asterisk (e.g. &quot;y1*&quot;) then the asterisk will be omitted and the label will be printed in symbol font (use this for Greek letters). Can also be a list with a label as each element, which can be expressions for more advanced mathematical annotation.</p>
</dd>  
<dt>edge.label.cex</dt><dd><p>Either a single number or a number per edge used as a scalar of the edge label size. Defaults to 1.</p>
</dd>
<dt>edge.label.bg</dt><dd><p>Either a logical or character vector/matrix. Indicates the background behind edge labels. If TRUE (default) a white background is plotted behind each edge label. If FALSE no background is plotted behind edge labels. Can also be a single color character, a vector or matrix of color vectors for each edge.</p>
</dd>
<dt>edge.label.margin</dt><dd><p>Margin of the background box around the edge label. Defaults to zero.</p>
</dd>
<dt>edge.label.position</dt><dd><p>Vector of numbers between 0 and 1 controlling the relative position of each edge label. Defaults to 0.5 for placing edge labels at the middle of the edge.</p>
</dd>
<dt>edge.label.font</dt><dd><p>Integer specifying the label font of edges. Can be a vector or matrix with value for each node</p>
</dd>
<dt>edge.label.color</dt><dd><p>Character vector indicating the color of the edge labels. It can be either a vector of length equal to the number of edges in the network or a single character color that will be applied to all edges.</p>
</dd>
</dl>




<h4>Layout</h4>

<p>Arguments concerning the placement of nodes, in combination with 'layout'.
</p>

<dl>
<dt>repulsion</dt><dd><p>Scalar on the default repulse radius in the spring layout. Defaults to 1. Setting this argument to lower values (e.g., 0.5) will cause nodes in the spring layout to repulse each other less. This is especially useful if a few unconnected nodes cause the giant component to visually be clustered too much in the same place.</p>
</dd>
<dt>layout.par</dt><dd><p>A list of arguments passed to <code><a href="#topic+qgraph.layout.fruchtermanreingold">qgraph.layout.fruchtermanreingold</a></code> when <code>layout = "spring"</code> or to an igraph function when such a function is assigned to 'layout'. Defaults to <code> list(repulse.rad = nNodes^(repulsion * 3))</code> if <code>layout = "spring"</code> and <code>list()</code> otherwise.</p>
</dd>
<dt>layoutRound</dt><dd><p>Logical, should weights be rounded (default 10 digits) before computing layouts? This will hopefully make sure different machines result in the same layout. Defaults to <code>TRUE</code></p>
</dd>
<dt>layout.control</dt><dd><p>A scalar on the size of the circles created with the circular layout.</p>
</dd>
<dt>aspect</dt><dd><p>Should the original aspect ratio be maintained if rescale = TRUE? Defaults to FALSE. Set this to TRUE to keep the aspect ratio of the original layout (e.g. result from layout=&quot;spring&quot;).</p>
</dd>
<dt>rotation</dt><dd><p>A vector that can be used to rotate the circles created with the circular layout. Must contain the rotation in radian for each group of nodes. Defaults to zero for each group.</p>
</dd>
</dl>




<h4>Legend</h4>

<p>Arguments to control the legend placed on the right side of the graph.
</p>

<dl>
<dt>legend</dt><dd><p>Logical value indicating if a legend should be plotted. Defaults to TRUE if a groups object or nodeNames is supplied</p>
</dd>
<dt>legend.cex</dt><dd><p>Scalar of the legend. defaults to 1</p>
</dd>
<dt>legend.mode</dt><dd><p>Character string indicating the type of legend to be drawn. <code>"groups"</code> indicates the legend should be based on the <code>groups</code> object, <code>"names"</code> indicates the legend should be based on the <code>nodeNames</code> object, and <code>style1</code> and <code>style2</code> indicate the legend should be based on both. Defaults to <code>"style1"</code> if both <code>"groups"</code> and <code>"nodeNames"</code> arguments are used.</p>
</dd>
<dt>GLratio</dt><dd><p>Relative size of the graph compared to the layout. Defaults to 2.5</p>
</dd>
<dt>layoutScale</dt><dd><p>A vector with a scalar for respectively the x and y coordinates of the layout (which default plotting area is from -1 to 1 on both x and y axis). Setting this to e.g. c(2,2) would make the plot twice as big. Use this in combination with 'layoutOffset' and 'plot' arguments to define the graph placement on an existing plot.</p>
</dd>
<dt>layoutOffset</dt><dd><p>A vector with the offset to the x and  coordinates of the center of the graph (defaults to (0,0)). Use this in combination with 'layoutScale' and 'plot' arguments to define the graph placement on an existing plot.</p>
</dd>
<dt>nodeNames</dt><dd><p>Names for each node, can be used to plot a legend next to the plot that links the node labels to node names.</p>
</dd>
</dl>




<h4>Background</h4>

<p>These arguments control the background of the plot
</p>

<dl>
<dt>bg</dt><dd><p>If this is TRUE, a background is plotted in which node colors cast a light of that color on a black background. Can also be a character containing the color of the background Defaults to FALSE</p>
</dd>
<dt>bgcontrol</dt><dd><p>The higher this is, the less light each node gives if bg=TRUE. Defaults to 6.</p>
</dd>
<dt>bgres</dt><dd><p>square root of the number of pixels used in bg=TRUE, defaults to 100.</p>
</dd>
</dl>




<h4>General graphical arguments</h4>


<dl>
<dt>pty</dt><dd><p>See 'par'</p>
</dd>
<dt>gray</dt><dd><p>Logical, set to TRUE to plot the graph in grayscale colors</p>
</dd>



<dt>font</dt><dd><p>Integer specifying the default font for node and edge labels</p>
</dd>
</dl>




<h3>Arguments for directed graphs</h3>


<dl>
<dt>directed</dt><dd><p>Logical indicating if edges are directed or not. Can be TRUE or FALSE to indicate if all edges are directed, a logical vector (when using edgelists) or a logical matrix (when using weights matrix)</p>
</dd>
<dt>arrows</dt><dd><p>A logical indicating if arrows should be drawn, or a number indicating how much arrows should be drawn on each edge. If this is TRUE, a simple arrow is plotted, if this is a number, arrows are put in the middle of the edges.</p>
</dd>
<dt>arrowAngle</dt><dd><p>Angle of the arrowhead, in radians. Defaults to pi/8 for unweighted graphs and pi/4 for weighted graphs.</p>
</dd>
<dt>asize</dt><dd><p>Size of the arrowhead. Defaults to 2*exp(-nNodes/20)+2.</p>
</dd>
<dt>open</dt><dd><p>Logical indicating if open (TRUE) or closed (FALSE) arrowheads should be drawn.</p>
</dd>
<dt>bidirectional</dt><dd><p>If this is TRUE, Then directional edges between nodes that have two edges between them are not curved. Defaults to FALSE. Can also be a logical vector (when using edgelists) or a logical matrix (when using weights matrix)</p>
</dd>
</dl>


<h3>Arguments for graphs based on significance values</h3>


<dl>
<dt>mode</dt><dd><p>This argument defines the mode used for coloring the edges. The default, &quot;strength&quot; assumes each edge weight indicates the strength of connection centered around  and makes positive edges green and negative edges red. If this is set to &quot;sig&quot; then the edge weights are assumed to be significance values and colored accordingly. This can also include negative values, which will be interpreted as p-values based on negative statistics.</p>
</dd>
<dt>alpha</dt><dd><p>The significance level (defaults to 0.05) to be used for not showing edges if <code>minimum = "sig"</code>, or if <code>Graph = "sig"</code> a vector of max 4 elements indicating the alpha level cutoffs. Defaults to c(0.0001,0.001,0.01,0.05)</p>
</dd>
<dt>sigScale</dt><dd><p>The function used to scale the edges if mode=&quot;sig&quot;. Defaults to $function(x)0.8*(1-x)^(log(0.4/0.8,1-0.05))$</p>
</dd>
<dt>bonf</dt><dd><p>Logical indicating if a bonferonni correction should be applied if <code>minimum = "sig"</code> or <code>mode="sig"</code></p>
</dd>
</dl>


<h3>Arguments for plotting scores on nodes</h3>

	

<dl>
<dt>scores</dt><dd><p>This argument can be used to plot scores of an individual on the test. Should be a vector with the scores for each item. Currently this can only be integer values (e.g.\ LIKERT scales).</p>
</dd>
<dt>scores.range</dt><dd><p>Vector of length two indicating the range of the scores, if scores is assigned.</p>
</dd>
</dl>


<h3>Arguments for manually defining graphs</h3>


<dl>
<dt>mode</dt><dd><p>The mode argument (see section on significance graph arguments) can also be used to make the weights matrix correspond directly to the width of the edges (as in lwd of plot()). To do this, set mode to &quot;direct&quot;.</p>
</dd>
<dt>edge.color</dt><dd><p>This argument can be used to overwrite the colors. Can be either a single value to make all edges the same color, a matrix with a color for each edge (when using a weights matrix) or a vector with a color for each edge (when using an edgelist). NA indicates that the default color should be used. Note that unless <code>fade=FALSE</code> colors still fade to white corresponding to their strength</p>
</dd>
</dl>


<h3>Arguments for knots (tying together edges)</h3>


<dl>
<dt>knots</dt><dd><p>This argument can be used to tie edges together in their center, which can be useful to, for example, indicate interaction effects. This argument can be assigned a list where each element is a vector containing the edge numbers that should be knotted together. Another option is to assign the argument a integer vector (for edgelists) or a matrix (for weight matrices) with 0 indicating edges that should not be tied together, and increasing numbers indicating each knot.</p>
</dd>
<dt>knot.size</dt><dd><p>The size of the knots. Can be of length one or a vector with the size of each knot. Similar to 'vsize'. Defaults to 1.</p>
</dd>
<dt>knot.color</dt><dd><p>The color of the knots. Can be of length one or a vector with the size of each knot. Defaults to NA, which will result in a mix of the knotted edge colors.</p>
</dd>
<dt>knot.borders</dt><dd><p>Logical indicating if a border should be plotted around the knot. Can be of length one or a vector with the size of each knot. Works similar to 'borders'. Defaults to FALSE</p>
</dd>
<dt>knot.border.color</dt><dd><p>Color of the knot borders. Can be of length one or a vector with the size of each knot. Works similar to 'border.color'. Defaults to &quot;black&quot;</p>
</dd>
<dt>knot.border.width</dt><dd><p>Width of the knot borders. Can be of length one or a vector with the size of each knot. Works similar to 'border.width'. Defaults to 1</p>
</dd>
</dl>


<h3>Arguments for bars</h3>


<dl>
<dt>means</dt><dd>
<p>A vector with means for every node or <code>NA</code>. Will plot a vertical bar at the location of the mean between <code>meanRange</code> values. <code>NA</code> omits a bar.
</p>
</dd>
<dt>SDs</dt><dd>
<p>A vector with SDs for every node or <code>NA</code>. Will plot an error bar of 2 times this value around the <code>means</code> location. <code>NA</code> to omit.
</p>
</dd>
<dt>meanRange</dt><dd>
<p>The range of the <code>means</code> argument. Default to <code>range(means,na.rm=TRUE)</code>
</p>
</dd>
<dt>bars</dt><dd><p>A list with for each node containing either NULL or a vector with values between 0 and 1 indicating where bars should be placed inside the node.</p>
</dd>
<dt>barSide</dt><dd><p>Integer for each node indicating at which side the bars should be drawn. 1, 2, 3 or 4 indicating at bottom, left, top or right respectively.</p>
</dd>  
<dt>barColor</dt><dd><p>A vector with for each node indicating the color of bars. Defaults to the border color of the node.</p>
</dd>  
<dt>barLength</dt><dd><p>A Vector indicating the relative length of bars of each node compared to the node size. Defaults to 0.5.</p>
</dd>  
<dt>barsAtSide</dt><dd><p>Logical, should bars be drawn at the side of a node or at its center? Defaults to FALSE.</p>
</dd>  
</dl>


<h3>Arguments for pies</h3>


<dl>
<dt>pie</dt><dd>
<p>A vector with values between 0 and 1 for each node (or one value for all nodes). Supplying this argument will make the border of nodes a pie chart. Can also be a list with vectors to make pie charts of multiple parts.</p>
</dd>
<dt>pieBorder</dt><dd>
<p>The size of the pie chart in the border, between 0 and 1. Defaults to <code>0.15</code>. Set to 1 to make the whole node a pie chart. Can be a vector with a value for each node.
</p>
</dd>
<dt>pieColor</dt><dd>
<p>Colors of the pie plot parts. Can be a vector with a value for each node, or a list with multiple values if there are more parts.
</p>
</dd>
<dt>pieColor2</dt><dd>
<p>Final color of the pie chart. Only added if the values in the 'pie' argument do not add up to 1. Defaults to <code>'white'</code>. Can be a vector with a value for each node.
</p>
</dd>
<dt>pieStart</dt><dd>
<p>A vector with values between 0 and 1 for each node (or one value for all nodes), indicating the starting point of the pie chart. 
</p>
</dd>
<dt>pieDarken</dt><dd>
<p>A vector with values between 0 and 1 for each node (or one value for all nodes), indicating how much darker the pie border color is made than the node color in the default coloring scheme.
</p>
</dd>
<dt>piePastel</dt><dd>
<p>Should pastel colors be used to fill pie chart parts when more than 2 blocks are used?
</p>
</dd>
<dt>pieCImid</dt><dd>
<p>A vector with values between 0 and 1 for each node (or one value for all nodes), indicating the center point of the confidence region. Overwrites the <code>pie</code> argument
</p>
</dd>
<dt>pieCIlower</dt><dd>
<p>A vector with values between 0 and 1 for each node (or one value for all nodes), indicating the lower bound of the confidence region. Overwrites the <code>pie</code> argument
</p>
</dd>
<dt>pieCIupper</dt><dd>
<p>A vector with values between 0 and 1 for each node (or one value for all nodes), indicating the upper bound of the confidence region. Overwrites the <code>pie</code> argument
</p>
</dd>
<dt>pieCIpointcex</dt><dd>
<p>A vector with values between 0 and 1 for each node (or one value for all nodes), indicating the size of the point estimate of the confidence region. Overwrites the <code>pie</code> argument. Defaults to 0.01.
</p>
</dd>
<dt>pieCIpointcex</dt><dd>
<p>A vector with values between 0 and 1 for each node (or one value for all nodes), indicating the color of the point estimate of the confidence region. Overwrites the <code>pie</code> argument. Defaults to <code>"black"</code>.
</p>
</dd>
</dl>



<h3>Additional arguments</h3>

	

<dl>
<dt>edgelist</dt><dd><p>Logical, if TRUE 'input' is assumed to be an edgelist, else if FALSE input is assumed to be a weights matrix. By default this is chosen automatically based on the dimensions of 'input' and this argument is only needed if the dimensions are ambiguous (square matrix with 2 or 3 rows/columns)</p>
</dd>
<dt>weighted</dt><dd><p>Logical that can be used to force either a weighted graph (TRUE) or an unweighted graph(FALSE).</p>
</dd>
<dt>nNodes</dt><dd><p>The number of nodes, only needs to be specified if the first argument is an edge-list and some nodes have no edges</p>
</dd>
<dt>XKCD</dt><dd><p>If set to TRUE the graph is plotted in XKCD style based on http://stackoverflow.com/a/12680841/567015.</p>
</dd>
</dl>


<h3>Using qgraph to plot graphs</h3>

<p>The first argument of qgraph(), 'input', is the input. This can be a number of objects but is mainly either a weights matrix or an edgelist. Here we will assume a graph is made of n nodes connected by m edges. qgraph is mainly aimed at visualizing (statistical) relationships between variables as weighted edges. In these edge weights a zero indicates no connection and negative values are comparable in strength to positive values. Many (standardized) statistics follow these rules, the most important example being correlations. In the special case where all edge weights are either 0 or 1 the weights matrix is interpreted as an adjacency matrix and an unweighted graph is made.
</p>
<p>a weights matrix is a square n by n matrix in which each row and column represents a node. The element at row i and column j indicates the connection from node i to node j. If the weights matrix is symmetrical an undirected graph is made and if the matrix is asymmetrical a directed graph is made.
</p>
<p>Alternatively an edgelist can be used. This is a m by 2 matrix (not a list!) in which each row indicates an edge. The first column indicates the number of the start of the edge and the second column indicates the number of the end of the edge. The number of each node is a unique integer between 1 and n. The total number of nodes will be estimated by taking the highest value of the edgelist. If this is incorrect (there are nodes with no edges beyond the ones already specified) the 'nNodes' argument can be used. If an integer between 1 and n is missing in the edgelist it is assumed to be a node with no edges. To create a weighted graph edge weights can be added as a third column in the edgelist. By default using an edgelist creates a directed graph, but this can be set with the 'directed' argument.
</p>


<h3>Interpreting graphs</h3>

<p>In weighted graphs green edges indicate positive weights and red edges indicate negative weights. The color saturation and the width of the edges corresponds to the absolute weight and scale relative to the strongest weight in the graph. It is possible to set this strongest edge by using the 'maximum' argument. When 'maximum' is set to a value above any absolute weight in the graph that value is considered the strongest edge (this must be done to compare different graphs; a good value for correlations is 1). Edges with an absolute value under the 'minimum' argument are omitted (useful to keep filesizes from inflating in very large  graphs). 
</p>
<p>In larger graphs the above edge settings can become hard to interpret. With the 'cut' argument a cutoff value can be set which splits scaling of color and width. This makes the graphs much easier to interpret as you can see important edges and general trends in the same picture. Edges with absolute weights under the cutoff score will have the smallest width and become more colorful as they approach the cutoff score, and edges with absolute weights over the cutoff score will be full red or green and become wider the stronger they are. 
</p>


<h3>Specifying the layout</h3>

<p>The placement of the nodes (i.e. the layout) is specified with the 'layout' argument. It can be manually specified by entering a matrix for this argument. The matrix must have a row for each node and two columns indicating its X and Y coordinate respectively. qgraph plots the nodes on a (-1:1)(-1:1) plane, and the given coordinates will be rescaled to fit this plane unless 'rescale' is FALSE (not recommended).  Another option to manually specify the layout is by entering a matrix with more then two columns. This matrix must then consist of zeroes and a number (the order in the weights matrix) for each node indicating it's place. For example:
</p>
<p>0 0 2 0 0
</p>
<p>1 0 3 0 4
</p>
<p>will place node 2 at the top in the center, node 1 at the bottom left corner, node 3 at the bottom in the center and node 4 at the bottom right corner. It is recommended however that one of the integrated layouts is used. 'layout' can be given a character as argument to accomplish that. layout=&quot;circular&quot; will simply place all nodes in a circle if the groups argument is not used and in separate circles per group if the groups argument is used (see next section).
</p>
<p>The circular layout is convenient to see how well the data conforms to a model, but to show how the data clusters another layout is more appropriate. By specifying layout=&quot;spring&quot; the Fruchterman-reingold algorithm (Fruchterman &amp; Reingold, 1991), which has been ported from the SNA package (Butts, 2010), can be used to create a force-directed layout. In principle, what this function does is that each node (connected and unconnected) repulse each other, and connected nodes also attract each other. Then after a number of iterations (500 by default) in which the maximum displacement of each node becomes smaller a layout is achieved in which the distance between nodes correspond very well to the absolute edge weight between those nodes.
</p>
<p>A solution to use this function for weighted graphs has been taken from the igraph package (Csardi G &amp; Nepusz T, 2006) in which the same function was ported from the SNA package. New in qgraph are the option to include constraints on the nodes by fixing a coordinate for nodes or reducing the maximum allowed displacement per node. This can be done with the 'layout.par' argument. For more information see <code><a href="#topic+qgraph.layout.fruchtermanreingold">qgraph.layout.fruchtermanreingold</a></code>.
</p>
<p>By default, 'layout' is set to &quot;spring&quot; for unweighted and directed graphs and &quot;circular&quot; otherwise.
</p>


<h3>Grouping nodes</h3>

<p>Grouping nodes (e.g., according to a measurement model) can be specified with the 'groups' argument. This can be a factor or a list in which each element is a vector containing the numbers of nodes that belong together (numbers are taken from the order in the weights matrix). All numbers must be included. If a groups list is specified the &quot;groups&quot; layout can be used to place these nodes together, the nodes in each group will be given a color, and a legend can be plotted (by setting 'legend' to TRUE). The colors will be taken from the 'color' argument, or be generated with the <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> function.</p>


<h3>Output</h3>

<p>By default qgraph will plot the graph in a new R window. However the graphs are optimized to be plotted in a PDF file. To easily create a pdf file set the 'filetype' argument to &quot;pdf&quot;. 'filename' can be used to specify the filename and folder to output in. 'height' and 'width' can be used to specify the height and width of the image in inches. By default a new R window is opened if the current device is the NULL-device, otherwise the current device is used (note that when doing this 'width' and 'height' still optimize the image for those widths and heights, even though the output screen size isn't affected, this is especially important for directed graphs!).
</p>
<p>Furthermore filetype can also be set to numerous other values. Alternatively any output device in R can be used by simply opening the device before calling qgraph and closing it with dev.off() after calling qgraph.
</p>
<p>IMPORTANT NOTE: graphs made in qgraph must be exported programatically using device functions such as pdf() and png(). Manually resizing a graph and using export functions such as the one built into RStudio will give UNSTABLE RESULTS.</p>


<h3>Manual specification of color and width</h3>

<p>In qgraph the widths and colors of each edge can also be manually controlled. To directly specify the width of each edge set the 'mode&rdquo; argument to &quot;direct&quot;. This will then use the absolute edge weights as the width of each edge (negative values can still be used to make red edges). To manually set the color of each edge, set the 'edge.color' argument to a matrix with colors for each edge (when using a weights matrix) or a vector with a color for each edge (when using an edgelist).
</p>


<h3>Replotting graphs and reusing layouts</h3>

<p>If the result of <code><a href="#topic+qgraph">qgraph</a></code> is stored, such as <code>Graph &lt;- qgraph(...)</code>, the plot can be recreated in two ways. <code>qgraph(Graph, ...))</code> reruns <code>qgraph</code> with the same arguments used in the origina call except those restated in the dots. For example <code>qgraph(Graph, shape = "square")</code> will recreate the same plot but now use square nodes instead of circular. <code>plot(Graph)</code> will NOT rerun <code>qgraph</code> but simply plot the qgraph object. This means that now specific graph attributes can be changed before plotting.
</p>
<p>More specific, <code>qgraph(Graph)</code> will base the new plot only on the <code>Arguments</code> element of the <code>qgraph</code> object and <code>plot(qgraph)</code> will base the new plot on the <code>graphAttributes</code> and  <code>plotOptions</code> elements of the qgraph object.
</p>
<p>To reuse a layout, use the <code>layout</code> element. e.g., to plot a new graph with the same layout use <code>qgraph(..., layout = Graph$layout)</code>
</p>


<h3>Additional information</h3>

<p>By default, edges will be straight between two nodes unless there are two edges between two nodes. To overwrite this behavior the 'bidirectional' argument can be set to TRUE, which will turn two edges between two nodes into one bidirectional edge. 'bidirectional' can also be a vector with TRUE or FALSE for each edge.
</p>
<p>To specify the strength of the curve the argument 'curve' can be used (but only in directional graphs). 'curve' must be given a numerical value that represent an offset from the middle of the straight edge through where the curved edge must be drawn. 0 indicates no curve, and any other value  indicates a curve of that strength. A value of 0.3 is recommended for nice curves. This can be either one number or a vector with the curve of each edge.
</p>
<p>Nodes and edges can be given labels with the 'labels' and the 'edge.labels' arguments. 'labels' can be set to FALSE to omit labels, TRUE (default) to set labels equal to the node number (order in the weights matrix) or it can be a vector with the label for each node. Edge labels can also be set to FALSE to be omitted (default). If 'edge.labels' is TRUE then the weight of each label is printed. Finally, 'edge.labels' can also be a vector with the label for each edge. If a label (both for edges and nodes) contain an asterisk then the asterisk is omitted and that label is printed in the symbol font (useful to print Greek letters).
</p>
<p>A final two things to try: the 'scores' argument can be given a vector with the scores of a person on each variable, which will then be shown using colors of the nodes, And the 'bg' argument can be used to change the background of the graph to another color, or use bg=TRUE for a special background (do set transparency=TRUE when using  background colors other then white).</p>


<h3>Debugging</h3>

<p>If this function crashes for any reason with the filetype argument specified, run:
</p>
<p>dev.off()
</p>
<p>To shut down the output device!</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Carter T. Butts &lt;buttsc@uci.edu&gt; (2010). sna: Tools for Social Network Analysis. R package version 2.2-0. http://CRAN.R-project.org/package=sna
</p>
<p>Csardi G, Nepusz T (2006). The igraph software package for complex network research, InterJournal, Complex Systems 1695. http://igraph.sf.net
</p>
<p>Sacha Epskamp, Angelique O. J. Cramer, Lourens J. Waldorp, Verena D. Schmittmann, Denny Borsboom (2012). qgraph: Network Visualizations of Relationships in Psychometric Data. Journal of Statistical Software, 48(4), 1-18. URL http://www.jstatsoft.org/v48/i04/.
</p>
<p>Jerome Friedman, Trevor Hastie and Rob Tibshirani (2011). glasso: Graphical lasso-estimation of Gaussian graphical models. R package version 1.7. http://CRAN.R-project.org/package=glasso
</p>
<p>Bernd Klaus and Korbinian Strimmer. (2014). fdrtool: Estimation of (Local) False Discovery Rates and Higher Criticism. R package version 1.2.12. http://CRAN.R-project.org/package=
</p>
<p>Fruchterman, T. &amp; Reingold, E. (1991). Graph drawing by force-directed placement. Software - Pract. Exp. 21, 1129-1164.
</p>
<p>N. Kraemer, J. Schaefer. A.-L. Boulesteix (2009). Regularized Estimation of Large-Scale Gene Regulatory Networks using Gaussian Graphical Models BMC Bioinformatics 10:384
</p>
<p>Plate, T. &lt;tplate@acm.org&gt; and based on RSvgDevice by T Jake Luciani &lt;jakeluciani@yahoo.com&gt; (2009). RSVGTipsDevice: An R SVG graphics device with dynamic tips and hyperlinks. R package version 1.0-1.
</p>
<p>Revelle, W. (2014) psych: Procedures for Personality and Psychological Research, Northwestern University, Evanston, Illinois, USA, http://CRAN.R-project.org/package=psych Version = 1.4.4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_auto">cor_auto</a></code>
<code><a href="#topic+qgraph.animate">qgraph.animate</a></code>
<code><a href="#topic+qgraph.loadings">qgraph.loadings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
### Correlations ###
# Load big5 dataset:
data(big5)
data(big5groups)

# Compute correlation matrix:
big5_cors &lt;- cor_auto(big5, detectOrdinal = FALSE)

# Correlations:
big5Graph &lt;- qgraph(cor(big5),minimum=0.25,groups=big5groups,
            legend=TRUE,borders=FALSE, title = "Big 5 correlations")


  # Same graph with spring layout:
  qgraph(big5Graph,layout="spring")
  
  # Same graph with different color scheme:
  qgraph(big5Graph,posCol="blue",negCol="purple")
 
  ### Network analysis ###
  ### Using bfi dataset from psych ###
  library("psych")
  data(bfi)
  
  # Compute correlations:
  CorMat &lt;- cor_auto(bfi[,1:25])
  
  # Compute graph with tuning = 0 (BIC):
  BICgraph &lt;- qgraph(CorMat, graph = "glasso", sampleSize = nrow(bfi),
            tuning = 0, layout = "spring", title = "BIC", details = TRUE)
  
  # Compute graph with tuning = 0.5 (EBIC)
  EBICgraph &lt;- qgraph(CorMat, graph = "glasso", sampleSize = nrow(bfi),
            tuning = 0.5, layout = "spring", title = "BIC", details = TRUE)
  
  # Compare centrality and clustering:
  centralityPlot(list(BIC = BICgraph, EBIC = EBICgraph))
  clusteringPlot(list(BIC = BICgraph, EBIC = EBICgraph))

  # Compute centrality and clustering:
  centrality_auto(BICgraph)
  clustcoef_auto(BICgraph)
  
  ### Directed unweighted graphs ###
  set.seed(1)
  adj=matrix(sample(0:1,10^2,TRUE,prob=c(0.8,0.2)),nrow=10,ncol=10)
  qgraph(adj)
  title("Unweighted and directed graphs",line=2.5)
  
  # Save plot to nonsquare pdf file:
  qgraph(adj,filetype='pdf',height=5,width=10)
  
  #### EXAMPLES FOR EDGES UNDER DIFFERENT ARGUMENTS ###
  # Create edgelist:
  dat.3 &lt;- matrix(c(1:15*2-1,1:15*2),,2)
  dat.3 &lt;- cbind(dat.3,round(seq(-0.7,0.7,length=15),1))
  
  # Create grid layout:
  L.3 &lt;- matrix(1:30,nrow=2)
  
  # Different esize:
  qgraph(dat.3,layout=L.3,directed=FALSE,edge.labels=TRUE,esize=14)
  
  # Different esize, strongest edges omitted (note how 0.4 edge is now 
  # just as wide as 0.7 edge in previous graph):
  qgraph(dat.3[-c(1:3,13:15),],layout=L.3,nNodes=30,directed=FALSE,
         edge.labels=TRUE,esize=14)
  
  # Different esize, with maximum:
  qgraph(dat.3,layout=L.3,directed=FALSE,edge.labels=TRUE,esize=14,maximum=1)
  title("maximum=1",line=2.5)
  
  qgraph(dat.3[-c(1:3,13:15),],layout=L.3,nNodes=30,directed=FALSE,edge.labels=TRUE,
         esize=14,maximum=1)
  title("maximum=1",line=2.5)
  
  # Different minimum
  qgraph(dat.3,layout=L.3,directed=FALSE,edge.labels=TRUE,esize=14,minimum=0.1)
  title("minimum=0.1",line=2.5)
  
  # With cutoff score:
  qgraph(dat.3,layout=L.3,directed=FALSE,edge.labels=TRUE,esize=14,cut=0.4)
  title("cut=0.4",line=2.5)
  
  # With details:
  qgraph(dat.3,layout=L.3,directed=FALSE,edge.labels=TRUE,esize=14,minimum=0.1,
         maximum=1,cut=0.4,details=TRUE)
  title("details=TRUE",line=2.5)
  
  
  # Trivial example of manually specifying edge color and widths:
  E &lt;- as.matrix(data.frame(from=rep(1:3,each=3),to=rep(1:3,3),width=1:9))
  qgraph(E,mode="direct",edge.color=rainbow(9))
  
  
  ### Input based on other R objects ###

  
  ## pcalg
  # Example from pcalg vignette:
  library("pcalg")
  data(gmI)
  suffStat &lt;- list(C = cor(gmI$x), n = nrow(gmI$x))
  pc.fit &lt;- pc(suffStat, indepTest=gaussCItest,
               p = ncol(gmI$x), alpha = 0.01)
  
  qgraph(pc.fit)
  
  ## glasso:
  # Using bfi dataset from psych:
  library("psych")
  data(bfi)
  cor_bfi &lt;- cor_auto(bfi[,1:25])
  
  # Run qgraph:
  library("glasso")
  bfi_glasso &lt;- glasso(cor_bfi, 0.1)
  
  # Plot:
  qgraph(bfi_glasso, layout = "spring")
  

## End(Not run)

</code></pre>

<hr>
<h2 id='qgraph.animate'>
Animate a growing network
</h2><span id='topic+qgraph.animate'></span>

<h3>Description</h3>

<p>This function is meant to facilitate the creation of animations based on growing networks. Networks are created based on the Fruchterman Reingold algorithm, which is constraint by limiting the maximum displacement of nodes that are already in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgraph.animate(input, ind = NULL, ..., constraint = 10, growth = "order", 
  titles = NULL, sleep = 0, smooth = TRUE, plotGraphs = TRUE, progress = TRUE,
  initLayout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgraph.animate_+3A_input">input</code></td>
<td>

<p>A weights matrix of the graph or a list of weigths matrices with different weights of the same graph (see details). See <code><a href="#topic+qgraph">qgraph</a></code>. Edgelists are currently not supported.
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_ind">ind</code></td>
<td>

<p>An object that specifies which nodes ar included or excluded. See details.
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_...">...</code></td>
<td>

<p>Additional arguments sent to <code><a href="#topic+qgraph">qgraph</a></code>
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_constraint">constraint</code></td>
<td>

<p>The constraint factor of included nodes. See details. Defaults to 10 for an soft-constrained animation. Set to Inf for a hard-constrained animation.
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_growth">growth</code></td>
<td>

<p>The way nodes are added by default. Set to &quot;order&quot; to include nodes in the order they appear in the weigths matrix and to &quot;degree&quot; to include nodes based on their degree (high degree first)
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_titles">titles</code></td>
<td>

<p>Optional vector with a title for each plot
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_sleep">sleep</code></td>
<td>

<p>Optional value sent to Sys.sleep() for showing the animation in R
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_smooth">smooth</code></td>
<td>

<p>Logical. If set to <code>TRUE</code> smoothing via <a href="stats.html#topic+loess">loess</a> is performed on the layout of all frames.
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_plotgraphs">plotGraphs</code></td>
<td>

<p>Logical. If set to <code>FALSE</code> graphs are not plotted.
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_progress">progress</code></td>
<td>

<p>Logical. If set to <code>TRUE</code> progress bars are included.
</p>
</td></tr>
<tr><td><code id="qgraph.animate_+3A_initlayout">initLayout</code></td>
<td>
<p>An optional n by 2 matrix containing the initial placement of nodes in the animation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let n be the number of nodes in total in the graph.
</p>
<p>This function is designed to facilitate the production of animations by constraining the Fruchterman Reingold algorithm. Several frames are plotted of (a subset of) the same graph. If a node was already in the graph its maximum displacement per iteration of Fruchterman Reingold is equal to the number of nodes times the inverse of the constraint argument (so by default n/10). The higher this constraint value the stricter nodes stay in the same place between plots.
</p>
<p>How many and which plots are made are defined by the 'input' and 'ind' arguments. There are two ways to specify the 'input' argument, either by speficying one weigths matrix or by specifying a list of weights matrices. In the sections below is explained what both of these methods do and how they are used.
</p>
<p>This function, since it can be seen as an expression that makes several plots, works well in combination with the animation package for saving the animation to a wide variety of filetypes.
</p>


<h3>Value</h3>

<p>Invisibly returns a list of all graphs.
</p>


<h3>Single weigths matrix</h3>

<p>If 'input' is a single weigths matrix then in each frame a subset of the same graph is plotted. This is especially usefull for animating the growth of a network. Which nodes are in each frame is determined by the 'ind' argument.
</p>
<p>If 'int' is not specified an animation is created in which in each frame a single node is added. This node is either in order of apearance in the weigths matrix or by its degree, which is determined with the 'growth' argument.
</p>
<p>If 'ind' is a logical vector of length n than the first frame will contain the nodes specified with this vector and all other frames will grow in the same way as explained above (each step one node is added).
</p>
<p>If 'ind' is a numeric vector of length n which contains all integers between 1 and n ( a single entry per node) then the first frame starts with only the node specified in the first element of the vector and in frame i the ith element is added (each step one node is added).
</p>
<p>If 'ind' is a list with numeric vectors as elements containing integers between 1 and n then in frame i the nodes from the ith element of the list will be added. Node numbers that occur multiple times in the list are ignored (they are already added the first time).
</p>
<p>Finally, if 'ind' is a logical matrix with n columns and an arbitrary amount of rows, then in frame i only the nodes that are TRUE in row i are included. This is the only way to specify removal of nodes.
</p>


<h3>List of weigths matrices</h3>

<p>The 'input' argument can also be given a list of weigths matrices if all these matrices have the same dimension (i.e.\ only the weights differ). If this is done than in frame i the ith weigths matrix is used. This is especially usefull for animating the change in a graph.
</p>
<p>In this case, the 'ind' argument behaves differently. If this argument is not specified then in each frame all nodes are included.
</p>
<p>If 'ind' is a logical vector of length n then only one plot is made with the nodes specified with that vector, and only if the length of 'input' is one.
</p>
<p>Other methods woth in the same way as above. However, if the 'ind' argument indicates a different number of frames than the 'input' argument the function will stop and give an error.
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>References</h3>

<p>Sacha Epskamp, Angelique O. J. Cramer, Lourens J.
Waldorp, Verena D. Schmittmann, Denny Borsboom (2012).
qgraph: Network Visualizations of Relationships in
Psychometric Data. Journal of Statistical Software,
48(4), 1-18. URL http://www.jstatsoft.org/v48/i04/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgraph">qgraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## For these examples, first generate a scale free network using preferential attachment:

# Number of nodes:
n &lt;- 100
# Empty vector with Degrees:
Degs &lt;- rep(0, n)
# Empty Edgelist:
E &lt;- matrix(NA, n - 1, 2)
# Add and connect nodes 1 and 2:
E[1, ] &lt;- 1:2
Degs[1:2] &lt;- 1
# For each node, add it with probability proportional to degree:
for (i in 2:(n - 1))
{
E[i, 2] &lt;- i + 1
con &lt;- sample(1:i, 1, prob = Degs[1:i]/sum(Degs[1:i]),i)
Degs[c(con,i+1)] &lt;- Degs[c(con,i+1)] + 1
E[i, 1] &lt;- con
}

# Because this is an edgelist we need a function to convert this to an adjacency matrix:
E2adj &lt;- function(E,n)
{
  adj &lt;- matrix(0,n,n)
  for (i in 1:nrow(E))
  {
      adj[E[i,1],E[i,2]]  &lt;- 1
  }
  adj &lt;- adj + t(adj)
  return(adj)
}



### EXAMPLE 1: Animation of construction algorithm: ###
adjs &lt;- lapply(1:nrow(E),function(i) E2adj(E[1:i,,drop=FALSE],n))
qgraph.animate(adjs,color="black",labels=FALSE,sleep=0.1, smooth = FALSE)
rm(adjs)

### EXAMPLE 2: Add nodes by final degree: ###
adj &lt;- E2adj(E,n)
qgraph.animate(E2adj(E,n),color="black",labels=FALSE,constraint=100,sleep=0.1)

### EXAMPLE 3: Changing edge weights: ###
adjW &lt;- adj*rnorm(n^2)
adjW &lt;- (adjW + t(adjW))/2
adjs &lt;- list(adjW)
for (i in 2:100)
{
  adjW &lt;- adj*rnorm(n^2)
  adjW &lt;- (adjW + t(adjW))/2
  adjs[[i]] &lt;- adjs[[i-1]] + adjW
}
qgraph.animate(adjs,color="black",labels=FALSE,constraint=100,sleep=0.1)



## End(Not run)
</code></pre>

<hr>
<h2 id='qgraph.layout.fruchtermanreingold'>qgraph.layout.fruchtermanreingold</h2><span id='topic+qgraph.layout.fruchtermanreingold'></span>

<h3>Description</h3>

<p>This is a wrapper for the function that returns the x and y coordinates of the graph based on the Fruchterman 
Reingold algorithm (Fruchterman &amp; Reingold, 1991), which was ported from the SNA package (Butts, 2010).
This function is used in <code><a href="#topic+qgraph">qgraph</a></code> and is not designed to be used separately. See details for
using constraints in this layout.</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgraph.layout.fruchtermanreingold(edgelist, weights=NULL, vcount=NULL,
	niter=NULL, max.delta=NULL, area=NULL, cool.exp=NULL, repulse.rad=NULL,
	init=NULL, groups=NULL, rotation=NULL, layout.control=0.5, constraints=NULL, 
	round = TRUE, digits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_edgelist">edgelist</code></td>
<td>
<p>A matrix with on each row the nodes at the start and the node at the end of each edge.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_weights">weights</code></td>
<td>
<p>A vector containing the edge weights.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_vcount">vcount</code></td>
<td>
<p>The number of nodes.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_niter">niter</code></td>
<td>
<p>Number of iterations, default is 500.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_max.delta">max.delta</code></td>
<td>
<p>Maximum displacement, default is equal to the number of nodes.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_area">area</code></td>
<td>
<p>The area of the plot, default is the square of the number of nodes.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_cool.exp">cool.exp</code></td>
<td>
<p>Cooling exponent, default is 1.5.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_repulse.rad">repulse.rad</code></td>
<td>
<p>Repulse radius, defaults to the cube of the number of nodes.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_init">init</code></td>
<td>
<p>Matrix with two columns and a row for each node containing the initial X and Y positions.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_groups">groups</code></td>
<td>
<p>See <code><a href="#topic+qgraph">qgraph</a></code></p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_rotation">rotation</code></td>
<td>
<p>See <code><a href="#topic+qgraph">qgraph</a></code></p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_layout.control">layout.control</code></td>
<td>
<p>See <code><a href="#topic+qgraph">qgraph</a></code></p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_constraints">constraints</code></td>
<td>
<p>A constraints matrix with two columns and a row for each node containing a NA if the node is free or a fixed value for one of the coordinates.</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_round">round</code></td>
<td>
<p>Logical indicating if the initial input should be rounded</p>
</td></tr>
<tr><td><code id="qgraph.layout.fruchtermanreingold_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round initial input and displacement in the algorithm to. Defaults to 5. This helps prevent floating point disrepancies between different operating systems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All arguments for this function can be passed from <code><a href="#topic+qgraph">qgraph</a></code> to this function by using the 'layout.par' argument, 
which must be a list containing the arguments. This can be used to constrain the layout in two ways:
</p>


<h3>Hard constraints</h3>

<p>By using the 'constraints' argument the X and Y positions of each node can be fixed to a certain value. The 'constraint'
argument must be given a matrix with two columns and a row for each node. An NA means that that coordinate for that
node is free, and a value means it is fixed to that value.</p>


<h3>Soft constraints</h3>

<p>Soft constraining can be done by varying the 'max.delta' argument. This can be a single number, but also a 
vector containing the maximum displacement per step for each node. The default value is the number of nodes,
so by setting this to a lower value for some nodes the node won't move so much. Use this in combination with
the 'init' argument to make sure nodes don't move too much from their initial setup. This can be useful when
adding a new node to an existing network and if you don't want the network to completely change.</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>References</h3>

<p>Sacha Epskamp, Angelique O. J. Cramer, Lourens J.
Waldorp, Verena D. Schmittmann, Denny Borsboom (2012).
qgraph: Network Visualizations of Relationships in
Psychometric Data. Journal of Statistical Software,
48(4), 1-18. URL http://www.jstatsoft.org/v48/i04/.
</p>
<p>Carter T. Butts &lt;buttsc@uci.edu&gt; (2010). sna: Tools for Social Network Analysis. R package version 2.2-0. http://CRAN.R-project.org/package=sna
</p>
<p>Fruchterman, T. &amp; Reingold, E. (1991). Graph drawing by force-directed placement. Software - Pract. Exp. 21, 1129?1164.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgraph">qgraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example makes a multipage PDF that contains images
# Of a building network using soft constraints.

# Each step one node is added with one edge. The max.delta
# decreases the longer nodes are present in the network.

pdf("Soft Constraints.pdf",width=10,height=5)

adj=adjO=matrix(0,nrow=3,ncol=3)
adj[upper.tri(adj)]=1
Q=qgraph(adj,vsize=3,height=5,width=10,layout="spring",
	esize=1,filetype='',directed=T)
cons=Q$layout
for (i in 1:20)
{
	x=nrow(adj)
	adjN=matrix(0,nrow=x+1,ncol=x+1)
	adjN[1:x,1:x]=adj
	consN=matrix(NA,nrow=x+1,ncol=2)
	consN[1:x,]=cons[1:x,]
	layout.par=list(init=rbind(cons,c(0,0)),
	max.delta=10/(x+1):1,area=10^2,repulse.rad=10^3)
	y=sample(c(x,sample(1:(x),1)),1)
	adjN[y,x+1]=1
	Q=qgraph(adjN,Q,layout="spring",layout.par=layout.par)
	cons=Q$layout
	adj=adjN
} 
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='qgraph.loadings'>qgraph.loadings</h2><span id='topic+qgraph.loadings'></span>

<h3>Description</h3>

<p>This function is a wrapper function for <code><a href="#topic+qgraph">qgraph</a></code> designed to visualize factor loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgraph.loadings( fact, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgraph.loadings_+3A_fact">fact</code></td>
<td>
<p>A matrix containing factor loadings (items per row, factors per column) or an &quot;loadings&quot; object</p>
</td></tr>
<tr><td><code id="qgraph.loadings_+3A_...">...</code></td>
<td>
<p>Additional optional arguments passed to <code><a href="#topic+qgraph">qgraph</a></code> and special arguments used in this function (described below).</p>
</td></tr>
</table>


<h3>Additional optional arguments</h3>

	

<dl>
<dt>layout</dt><dd><p>If &quot;default&quot; a standard layout for factor models will be made. If this is &quot;circle&quot; the default layout is circled (factors in the centre, items at the edge). No other layouts are currently supported.</p>
</dd>
<dt>vsize</dt><dd><p>A vector where the first value indicates the size of manifest variables and the second value indicates the size of latent variables.</p>
</dd>
<dt>model</dt><dd><p>&quot;reflective&quot; to have arrows go to manifest variables, &quot;formative&quot; to have arrows go to latent variables or &quot;none&quot; (default) for no arrows</p>
</dd>
<dt>crossloadings</dt><dd><p>Logical, if TRUE then for each manifest variable the strongest loading is omitted (default to FALSE).</p>
</dd>
<dt>groups</dt><dd><p>An optional list containing the measurement model, see  <code><a href="#topic+qgraph">qgraph</a></code></p>
</dd>
<dt>Fname</dt><dd><p>When there is only one factor, this is it's name. If there are more factors, the names in the groups list are used only if the factors can be identified.</p>
</dd>
<dt>resid</dt><dd><p>Values for the residuals</p>
</dd>
<dt>residSize</dt><dd><p>Size of the residuals, defaults to 0.1</p>
</dd>
<dt>factorCors</dt><dd><p>Correlation matrix of the factors</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>References</h3>

<p>Sacha Epskamp, Angelique O. J. Cramer, Lourens J.
Waldorp, Verena D. Schmittmann, Denny Borsboom (2012).
qgraph: Network Visualizations of Relationships in
Psychometric Data. Journal of Statistical Software,
48(4), 1-18. URL http://www.jstatsoft.org/v48/i04/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgraph">qgraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load big5 dataset:
data(big5)
data(big5groups)

big5efa &lt;- factanal(big5,factors=5,rotation="promax",scores="regression")
big5loadings &lt;- loadings(big5efa)
qgraph.loadings(big5loadings,groups=big5groups,minimum=0.2,
				cut=0.4,vsize=c(1.5,15),borders=FALSE,vTrans=200,
				model = "reflective", resid = big5efa$uniquenesses)

# Tree layout:
qgraph.loadings(big5loadings,groups=big5groups,minimum=0.2,
				cut=0.4,vsize=c(1.5,15),borders=FALSE,vTrans=200,
				layout="tree",width=20,model = "reflective", 
				resid = big5efa$uniquenesses)

## End(Not run)
</code></pre>

<hr>
<h2 id='qgraphMixed'>
Plots a mixed graph with both directed and undirected edges.
</h2><span id='topic+qgraphMixed'></span>

<h3>Description</h3>

<p>This function can be used to plot a network in which each node is connected by at most 3 edges; one undirected edge and two directed edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgraphMixed(undirected, directed, parallel = TRUE, parallelAngle = pi/6, 
        diagUndirected = FALSE, diagDirected = TRUE, ltyUndirected = 1, ltyDirected = 1, 
        curve = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgraphMixed_+3A_undirected">undirected</code></td>
<td>

<p>The undirected network weights matrix.
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_directed">directed</code></td>
<td>

<p>The directed network weights matrix.
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating if edges should be plotted parallel or curved.
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_parallelangle">parallelAngle</code></td>
<td>

<p>See <code><a href="#topic+qgraph">qgraph</a></code>
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_diagundirected">diagUndirected</code></td>
<td>

<p>Logical indicating if the diagonal of the undirected edges should be included.
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_diagdirected">diagDirected</code></td>
<td>

<p>Logical indicating if the diagonal of the directed edges should be included.
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_ltyundirected">ltyUndirected</code></td>
<td>

<p>lty of undirected edges
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_ltydirected">ltyDirected</code></td>
<td>

<p>lty of directed edges
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_curve">curve</code></td>
<td>

<p>Curvature of directed edges
</p>
</td></tr>
<tr><td><code id="qgraphMixed_+3A_...">...</code></td>
<td>

<p>Arguments sent to <code><a href="#topic+qgraph">qgraph</a></code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='smallworldIndex'>
Small-world index of unweighted graph
</h2><span id='topic+smallworldIndex'></span>

<h3>Description</h3>

<p>Computes the small-world index of an unweighted graph. When the graph is weighted, weights are removed and every nonzero edge weight is set to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smallworldIndex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smallworldIndex_+3A_x">x</code></td>
<td>

<p>A qgraph object.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of 'small-world' networks. nature, 393(6684), 440-442.
</p>

<hr>
<h2 id='smallworldness'>
Compute the small-worldness index.
</h2><span id='topic+smallworldness'></span>

<h3>Description</h3>

<p>Compute the small-worldness index (Humphries &amp; Gurney, 2008) relying on the global transitity of the network (Newman, 2003) and on its average shortest path length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smallworldness(x, B = 1000, up = 0.995, lo = 0.005)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smallworldness_+3A_x">x</code></td>
<td>

<p>A graph. Can be a <code>qgraph</code> object object, an <code>igraph</code> object, an adjacency matrix, a weight matrix and an edgelist, or a weighted edgelist.
</p>
</td></tr>
<tr><td><code id="smallworldness_+3A_b">B</code></td>
<td>

<p>The number of random networks.
</p>
</td></tr>
<tr><td><code id="smallworldness_+3A_up">up</code></td>
<td>

<p>The upper quantile.
</p>
</td></tr>
<tr><td><code id="smallworldness_+3A_lo">lo</code></td>
<td>

<p>the lower quantile.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the transitivity of the target network and the average shortest path length. Then it computes the average of the same indices on <code>B</code> random networks. The small-worldness index is then computed as the transitivity (normalized by the random transitivity) over the average shortest path length (normalized by the random average shortest path length). The  <code>lo</code> and <code>up</code> quantiles of the distribution of the random networks are also returned for both the transitivity and the average shortest path length.
</p>
<p>A network can be said &quot;smallworld&quot; if its <code>smallworldness</code> is higher than one (a stricter rule is <code>smallworldness</code>&gt;=3; Humphries &amp; Gurney, 2008). To consider a network as &quot;smallworld&quot;, it is also suggested to inspect that the network has a transitivity substantially higher than comparable random networks and that its average shortest path length is similar or higher (but not many times higher) than that computed on random networks.
Edge weights, signs and directions are ignored in the computation of the indices.
</p>


<h3>Value</h3>

<table>
<tr><td><code>smallworldness</code></td>
<td>
<p>the &quot;small-worldness&quot; index proposed by Humphries &amp; Gurney (2008)</p>
</td></tr>
<tr><td><code>trans_target</code></td>
<td>
<p>the global transitivity of the target network (Newman, 2003)</p>
</td></tr>
<tr><td><code>averagelength_target</code></td>
<td>
<p>the average shortest path length in the target network</p>
</td></tr>
<tr><td><code>trans_rnd_M</code></td>
<td>
<p>the average transitivity in the <code>B</code> random networks</p>
</td></tr>
<tr><td><code>trans_rnd_lo</code></td>
<td>
<p>the <code>lo</code> quantile of the transitivity in the <code>B</code> random networks</p>
</td></tr>
<tr><td><code>trans_rnd_up</code></td>
<td>
<p>the <code>up</code> quantile of the transitivity in the <code>B</code> random networks</p>
</td></tr>
<tr><td><code>averagelength_rnd_M</code></td>
<td>
<p>the average shortest path length in the <code>B</code> random networks</p>
</td></tr>
<tr><td><code>averagelength_rnd_lo</code></td>
<td>
<p>the <code>lo</code> quantile of the shortest path length in the <code>B</code> random networks</p>
</td></tr>
<tr><td><code>averagelength_rnd_up</code></td>
<td>
<p>the <code>up</code> quantile of the shortest path length in the <code>B</code> random networks</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If a directed network is given as input, an edge between every two nodes i and j is considered present if there is an arrow either from i to j or from j to i or both.
</p>


<h3>Author(s)</h3>

<p>Giulio Costantini (giulio.costantini@unimib.it), Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>References</h3>

<p>Costantini, G., Epskamp, S., Borsboom, D., Perugini, M., Mottus, R., Waldorp, L., Cramer, A. O. J., State of the aRt personality research: A tutorial on network analysis of personality data in R. Manuscript submitted for publication.
</p>
<p>Humphries, M. D., &amp; Gurney, K. (2008). Network &quot;small-world-ness&quot;: a quantitative method for determining canonical network equivalence. PLoS One, 3(4), e0002051.
</p>
<p>Newman, M. E. J. (2003). The structure and function of complex networks*. SIAM Review, 45(3), 167–256.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# a regular lattice. Even if the small-worldness is higher than three, the average path length is 
# much higher than that of random networks.
regnet&lt;-igraph::watts.strogatz.game(dim=1, size=1000, nei=10, p=0, loops=FALSE, multiple=FALSE)
smallworldness(regnet, B=10)

## Not run: 
# a small-world network: the transitivity is much higher than random, the average path length is 
# close to that of random networks
swnet&lt;-igraph::watts.strogatz.game(dim=1, size=1000, nei=10, p=.1, loops=FALSE, multiple=FALSE)
smallworldness(swnet, B=10)

# a pseudorandom network: both the average path length and the transitivity are similar to random 
# networks.
rndnet&lt;-igraph::watts.strogatz.game(dim=1, size=1000, nei=10, p=1, loops=FALSE, multiple=FALSE)
smallworldness(rndnet, B=10)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.qgraph'>
Summary method for &quot;qgraph&quot;
</h2><span id='topic+summary.qgraph'></span>

<h3>Description</h3>

<p>This function creates a brief summary based on a &quot;qgraph&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qgraph'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.qgraph_+3A_object">object</code></td>
<td>

<p>A &quot;qgraph&quot; object
</p>
</td></tr>
<tr><td><code id="summary.qgraph_+3A_...">...</code></td>
<td>

<p>These arguments are not used
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp (mail@sachaepskamp.com)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgraph">qgraph</a></code>
</p>

<hr>
<h2 id='VARglm'>
Computes a vector autoregressive lag-1 model using GLM
</h2><span id='topic+VARglm'></span>

<h3>Description</h3>

<p>This function computes a VAR model using glm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VARglm(x, family, vars, adjacency, icfun = BIC, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VARglm_+3A_x">x</code></td>
<td>

<p>A data frame
</p>
</td></tr>
<tr><td><code id="VARglm_+3A_family">family</code></td>
<td>

<p>The family to be used. Defaults to <code>gaussian</code> if data is continuous or <code>binomial</code> if data is binary
</p>
</td></tr>
<tr><td><code id="VARglm_+3A_vars">vars</code></td>
<td>

<p>Vector of variables to predict. If missing all variables are predicted.
</p>
</td></tr>
<tr><td><code id="VARglm_+3A_adjacency">adjacency</code></td>
<td>

<p>Adjacency matrix. If missing full network is estimated
</p>
</td></tr>
<tr><td><code id="VARglm_+3A_icfun">icfun</code></td>
<td>

<p>Information criterium function to be included in the output
</p>
</td></tr>
<tr><td><code id="VARglm_+3A_...">...</code></td>
<td>

<p>Arguments used in the <code>icfun</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>The estimated graph</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The information criterium</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com
</p>

<hr>
<h2 id='wi2net'>
Converts precision matrix to partial correlation matrix
</h2><span id='topic+wi2net'></span>

<h3>Description</h3>

<p>A small function that converts a precision matrix (inverse of covariance matrix) to a partial correlatin matrix. This can be done by standardizing the precision matrix and changing the sign of the offdiagonal entries. Many methods exist for obtaining a precision matrix (Such as the glasso package; Friedman, Hastie and Tibshirani, 2011) but the partial correlation matrix is easier interpretable and better usuable in qgraph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wi2net(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wi2net_+3A_x">x</code></td>
<td>

<p>A precision matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A partial correlation matrix
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie and Rob Tibshirani (2011). glasso: Graphical lasso-estimation of Gaussian graphical models. R package version 1.7.
http://CRAN.R-project.org/package=glasso
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
