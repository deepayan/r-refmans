<!DOCTYPE html><html lang="en"><head><title>Help for package overtureR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {overtureR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_overture'><p>Convert a tbl_sql object to a overture_call object</p></a></li>
<li><a href='#collect.overture_call'><p>Convert dbplyr table to sf Object</p></a></li>
<li><a href='#config_extensions'><p>Check duckdb extension and config settings</p></a></li>
<li><a href='#open_curtain'><p>Retrieve (Spatially Filtered) Overture Datasets</p></a></li>
<li><a href='#record_overture'><p>Download Overture Maps Data to Local Directory</p></a></li>
<li><a href='#sf_as_dbplyr'><p>Registeran sf object as a DuckDB virtual table</p></a></li>
<li><a href='#stage_conn'><p>create a cachable duckdb connection. In dev</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Load 'Overture' Datasets as 'dbplyr' and 'sf'-Ready Data Frames</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>An integrated R interface to the 'Overture' API 
  (<a href="https://docs.overturemaps.org/">https://docs.overturemaps.org/</a>). Allows R users to return 'Overture' data as 
  'dbplyr' data frames or materialized 'sf' spatial data frames.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, duckdbfs, ggplot2, httr, jsonlite, knitr, rmarkdown,
spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/arthurgailes/overtureR">https://github.com/arthurgailes/overtureR</a>,
<a href="https://arthurgailes.github.io/overtureR/">https://arthurgailes.github.io/overtureR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/arthurgailes/overtureR/issues">https://github.com/arthurgailes/overtureR/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>DBI, dbplyr, dplyr (&ge; 1.0.0), duckdb (&ge; 1.0.0), glue, rlang,
sf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-10 21:09:24 UTC; Arthur.Gailes</td>
</tr>
<tr>
<td>Author:</td>
<td>Arthur Gailes <a href="https://orcid.org/0009-0006-8176-8653"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arthur Gailes &lt;agailes1@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-11 00:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_overture'>Convert a tbl_sql object to a overture_call object</h2><span id='topic+as_overture'></span>

<h3>Description</h3>

<p>This function adds the overture_call class to a tbl_sql object.  It is
primarily used internally#' by the open_curtain() function but can also be
used directly on tbl_sql #' objects representing Overture Maps data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_overture(x, type, theme = get_theme_from_type(type))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_overture_+3A_x">x</code></td>
<td>
<p>A tbl_sql object representing an Overture Maps dataset.</p>
</td></tr>
<tr><td><code id="as_overture_+3A_type">type</code></td>
<td>
<p>A string specifying the type of overture dataset to read.
Setting to &quot;*&quot; or <code>NULL</code> will read all types for a given theme.</p>
</td></tr>
<tr><td><code id="as_overture_+3A_theme">theme</code></td>
<td>
<p>Inferred from type by default. Must be set if type is &quot;*&quot; or NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function adds the overture_call class as the first class of the object
</p>


<h3>Value</h3>

<p>A tbl_sql object with the additional class overture_call and
attributes overture_type and overture_theme.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The open_curtain() function already uses as_overture() internally,
# but you can also use it directly:
conn &lt;- stage_conn()
division &lt;- open_curtain("division", tablename = "test")

class(division)

# views
division2 &lt;- tbl(conn, "test")
division2 &lt;- as_overture(division2)

exit_stage(conn)

</code></pre>

<hr>
<h2 id='collect.overture_call'>Convert dbplyr table to sf Object</h2><span id='topic+collect.overture_call'></span><span id='topic+collect_sf'></span>

<h3>Description</h3>

<p>Collects a lazy dbplyr view and materializes it as an
in-memory <code>sf</code> table. <code>collect_sf</code> is a deprecated alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'overture_call'
collect(x, ..., geom_col = "geometry", crs = 4326)

collect_sf(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect.overture_call_+3A_x">x</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="collect.overture_call_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code>.</p>
</td></tr>
<tr><td><code id="collect.overture_call_+3A_geom_col">geom_col</code></td>
<td>
<p>The name of the geometry column. Will auto-detect names
matching 'geom'.</p>
</td></tr>
<tr><td><code id="collect.overture_call_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system to use for the geometries, specified
by its EPSG code. The default is 4326 (WGS 84).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'sf' object with the dataset converted to spatial features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

bbox &lt;- c(xmin = -120.5, ymin = 35.5, xmax = -120.0, ymax = 36.0)
lazy_tbl &lt;- open_curtain("building", bbox)
collect(lazy_tbl)

</code></pre>

<hr>
<h2 id='config_extensions'>Check duckdb extension and config settings</h2><span id='topic+config_extensions'></span>

<h3>Description</h3>

<p>Check duckdb extension and config settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config_extensions(conn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="config_extensions_+3A_conn">conn</code></td>
<td>
<p>A connection to a duckdb database.</p>
</td></tr>
</table>

<hr>
<h2 id='open_curtain'>Retrieve (Spatially Filtered) Overture Datasets</h2><span id='topic+open_curtain'></span>

<h3>Description</h3>

<p>Fetches overture data from AWS.
If a bounding box is provided, it applies spatial filtering to only include
records within that area. The core code is copied from <code>duckdbfs</code>, which
deserves all credit for the implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>open_curtain(
  type,
  spatial_filter = NULL,
  theme = get_theme_from_type(type),
  conn = NULL,
  as_sf = FALSE,
  mode = "view",
  tablename = NULL,
  read_opts = list(),
  base_url = "s3://overturemaps-us-west-2/release/2024-11-13.0",
  bbox = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="open_curtain_+3A_type">type</code></td>
<td>
<p>A string specifying the type of overture dataset to read.
Setting to &quot;*&quot; or <code>NULL</code> will read all types for a given theme.</p>
</td></tr>
<tr><td><code id="open_curtain_+3A_spatial_filter">spatial_filter</code></td>
<td>
<p>An object to spatially filter the result.</p>
</td></tr>
<tr><td><code id="open_curtain_+3A_theme">theme</code></td>
<td>
<p>Inferred from type by default. Must be set if type is &quot;*&quot; or NULL</p>
</td></tr>
<tr><td><code id="open_curtain_+3A_conn">conn</code></td>
<td>
<p>A connection to a duckdb database.</p>
</td></tr>
<tr><td><code id="open_curtain_+3A_as_sf">as_sf</code></td>
<td>
<p>If TRUE, return an sf dataframe</p>
</td></tr>
<tr><td><code id="open_curtain_+3A_mode">mode</code></td>
<td>
<p>Either &quot;view&quot; (default) or &quot;table&quot;. If &quot;table&quot;, will download the
dataset into memory.</p>
</td></tr>
<tr><td><code id="open_curtain_+3A_tablename">tablename</code></td>
<td>
<p>The name of the table to create in the database.</p>
</td></tr>
<tr><td><code id="open_curtain_+3A_read_opts">read_opts</code></td>
<td>
<p>A named list of key-value pairs passed to
<a href="https://duckdb.org/docs/data/parquet/overview.html#parameters">DuckDB's read_parquet</a></p>
</td></tr>
<tr><td><code id="open_curtain_+3A_base_url">base_url</code></td>
<td>
<p>Allows user to download data from a different mirror, such
as a local directory, or a alternative release.</p>
</td></tr>
<tr><td><code id="open_curtain_+3A_bbox">bbox</code></td>
<td>
<p>alias for <code>spatial_filter</code>. may be deprecated in the future.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An dbplyr lazy dataframe, or an sf dataframe if as_sf is TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bbox &lt;- c(xmin = -120.5, ymin = 35.5, xmax = -120.0, ymax = 36.0)
open_curtain("building", bbox)

</code></pre>

<hr>
<h2 id='record_overture'>Download Overture Maps Data to Local Directory</h2><span id='topic+record_overture'></span><span id='topic+snapshot_overture'></span>

<h3>Description</h3>

<p>This function downloads Overture Maps data to a local directory, maintaining
the same partition structure as in S3. <code>snapshot_overture</code> defaults
'output_dir' to <code>tempdir()</code> and overwrite to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record_overture(curtain_call, output_dir, overwrite = FALSE, write_opts = NULL)

snapshot_overture(
  curtain_call,
  output_dir = tempdir(),
  overwrite = TRUE,
  write_opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="record_overture_+3A_curtain_call">curtain_call</code></td>
<td>
<p>A overture_call object.</p>
</td></tr>
<tr><td><code id="record_overture_+3A_output_dir">output_dir</code></td>
<td>
<p>The directory where the data will be saved.</p>
</td></tr>
<tr><td><code id="record_overture_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical, if FALSE (default), existing directories will not be
overwritten.</p>
</td></tr>
<tr><td><code id="record_overture_+3A_write_opts">write_opts</code></td>
<td>
<p>a character vector passed to DuckDB's COPY command.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another tbl_lazy. Use <code><a href="dplyr.html#topic+explain">dplyr::show_query()</a></code> to see the generated query, and
use <code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code> to execute the query and return data to R.
</p>
<p>An 'overture_call' for the downloaded data
</p>


<h3>See Also</h3>

<p><a href="https://duckdb.org/docs/data/partitioning/partitioned_writes">DuckDB documentation on partitioned writes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
broadway &lt;- c(xmin = -73.99, ymin = 40.76, xmax = -73.98, ymax = 40.76)
buildings &lt;- open_curtain("building", spatial_filter = bbox)
local_buildings &lt;- record_overture(buildings, tempdir(), overwrite = TRUE)

</code></pre>

<hr>
<h2 id='sf_as_dbplyr'>Registeran sf object as a DuckDB virtual table</h2><span id='topic+sf_as_dbplyr'></span>

<h3>Description</h3>

<p>A thin wrapper around <code>duckdb::duckdb_register()</code> that creates a virtual
table, then selects the geometry column to DuckDB.'s GEOMETRY type in the
returned <code>dbplyr</code> representation. Mostly useful for join and spatial
operations within DuckDB. No data is copied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_as_dbplyr(
  conn,
  name,
  sf_obj,
  geom_only = isFALSE(inherits(sf_obj, "sf")),
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_as_dbplyr_+3A_conn">conn</code></td>
<td>
<p>A DuckDB connection, created by <code>dbConnect()</code>.</p>
</td></tr>
<tr><td><code id="sf_as_dbplyr_+3A_name">name</code></td>
<td>
<p>The name for the virtual table that is registered or unregistered</p>
</td></tr>
<tr><td><code id="sf_as_dbplyr_+3A_sf_obj">sf_obj</code></td>
<td>
<p>sf object to be registered to duckdb</p>
</td></tr>
<tr><td><code id="sf_as_dbplyr_+3A_geom_only">geom_only</code></td>
<td>
<p>if TRUE, only the geometry column is registered. Always
FALSE for sfc or sfg objects</p>
</td></tr>
<tr><td><code id="sf_as_dbplyr_+3A_overwrite">overwrite</code></td>
<td>
<p>Should an existing registration be overwritten?</p>
</td></tr>
<tr><td><code id="sf_as_dbplyr_+3A_...">...</code></td>
<td>
<p>additional arguments passed to duckdb_register</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Behind the scenes, this function creates an initial view (<code>name</code>_init) with
the geometry stored as text via <code>sf::st_as_text</code>. It then creates the view
<code>name</code> which replaces the geometry column with DuckDB's internal geometry
type.
</p>


<h3>Value</h3>

<p>a <code>dbplyr</code> lazy table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sf)

con &lt;- stage_conn()
sf_obj &lt;- st_sf(a = 3, geometry = st_sfc(st_point(1:2)))
sf_as_dbplyr(con, "test", sf_obj)

DBI::dbDisconnect(con)

</code></pre>

<hr>
<h2 id='stage_conn'>create a cachable duckdb connection. In dev</h2><span id='topic+stage_conn'></span><span id='topic+strike_stage'></span>

<h3>Description</h3>

<p><code>stage_conn</code> is primarily intended for internal use by other
<code>overtureR</code> functions.  However, it can be called directly by
the user whenever it is desirable to have direct access to the
connection object. The core code is copied from <code>duckdbfs</code>, which deserves
all credit for the implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stage_conn(
  dbdir = ":memory:",
  read_only = FALSE,
  bigint = "numeric",
  config = list(),
  ...
)

strike_stage(conn = stage_conn())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stage_conn_+3A_dbdir">dbdir</code></td>
<td>
<p>Location for database files. Should be a path to an existing
directory in the file system. With the default (or <code>""</code>), all
data is kept in RAM.</p>
</td></tr>
<tr><td><code id="stage_conn_+3A_read_only">read_only</code></td>
<td>
<p>Set to <code>TRUE</code> for read-only operation.
For file-based databases, this is only applied when the database file is opened for the first time.
Subsequent connections (via the same <code>drv</code> object or a <code>drv</code> object pointing to the same path)
will silently ignore this flag.</p>
</td></tr>
<tr><td><code id="stage_conn_+3A_bigint">bigint</code></td>
<td>
<p>How 64-bit integers should be returned. There are two options: <code>"numeric"</code> and <code>"integer64"</code>.
If <code>"numeric"</code> is selected, bigint integers will be treated as double/numeric.
If <code>"integer64"</code> is selected, bigint integers will be set to bit64 encoding.</p>
</td></tr>
<tr><td><code id="stage_conn_+3A_config">config</code></td>
<td>
<p>Named list with DuckDB configuration flags, see
<a href="https://duckdb.org/docs/configuration/overview#configuration-reference">https://duckdb.org/docs/configuration/overview#configuration-reference</a> for the possible options.
These flags are only applied when the database object is instantiated.
Subsequent connections will silently ignore these flags.</p>
</td></tr>
<tr><td><code id="stage_conn_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="DBI.html#topic+dbConnect">DBI::dbConnect</a></p>
</td></tr>
<tr><td><code id="stage_conn_+3A_conn">conn</code></td>
<td>
<p>A <code>duckdb_connection</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When first called (by a user or internal function),
this function both creates a duckdb connection and places
that connection into a cache (<code>overturer_conn</code> option).
On subsequent calls, this function returns the cached connection,
rather than recreating a fresh connection.
</p>
<p>This frees the user from the responsibility of managing a
connection object, because functions needing access to the
connection can use this to create or access the existing connection.
At the close of the global environment, this function's finalizer
should gracefully shutdown the connection before removing the cache.
</p>
<p><code>strike_stage</code> closes the connection.
</p>


<h3>Value</h3>

<p>a <code><a href="duckdb.html#topic+duckdb">duckdb::duckdb()</a></code>connection object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- stage_conn()
strike_stage(con)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
