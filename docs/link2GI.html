<!DOCTYPE html><html><head><title>Help for package link2GI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {link2GI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add2Path'><p>Adds a defined variable and value to the global search path</p></a></li>
<li><a href='#findGDAL'><p>Search recursivly existing 'GDAL binaries' installation(s) at a given drive/mountpoint</p></a></li>
<li><a href='#findGRASS'><p>Return attributes of valid 'GRASS GIS' installation(s) on the system</p></a></li>
<li><a href='#findOTB'><p>Search recursivly existing 'Orfeo Toolbox' installation(s) at a given drive/mountpoint</p></a></li>
<li><a href='#findSAGA'><p>Search recursivly existing 'SAGA GIS' installation(s) at a given drive/mountpoint</p></a></li>
<li><a href='#getSpatialClass'><p>Checks if x is of type raster,terra,sf or sp</p></a></li>
<li><a href='#gvec2sf'><p>Converts from an existing 'GRASS' environment an arbitrary vector dataset  into a  sf object</p></a></li>
<li><a href='#initProj'><p>Defines and creates folders and variables</p></a></li>
<li><a href='#linkAll'><p>convenient function to establish all link2GI links</p></a></li>
<li><a href='#linkGDAL'><p>Locate and set up 'GDAL' API bindings</p></a></li>
<li><a href='#linkGRASS'><p>Locate and set up 'GRASS' API bindings</p></a></li>
<li><a href='#linkGRASS7'><p>Deprecated only for backwards compatibility Locate and set up 'GRASS' API bindings</p></a></li>
<li><a href='#linkOTB'><p>Locate and set up 'Orfeo ToolBox' API bindings</p></a></li>
<li><a href='#linkSAGA'><p>Identifies SAGA GIS Installations and returns linking Informations</p></a></li>
<li><a href='#makGlobalVar'><p>Generates a variable with a certain value in the R environment</p></a></li>
<li><a href='#manuallyBuild'><p>Build package manually</p></a></li>
<li><a href='#paramGRASSw'><p>Usually for internally usage get 'GRASS GIS' and <code>rgrass</code> parameters on 'Windows' OS</p></a></li>
<li><a href='#paramGRASSx'><p>Usually for internally usage, get 'GRASS GIS' and <code>rgrass</code> parameters on 'Linux' OS</p></a></li>
<li><a href='#parseOTBAlgorithms'><p>Get OTB modules</p></a></li>
<li><a href='#parseOTBFunction'><p>Get OTB function argument list</p></a></li>
<li><a href='#runOTB'><p>Execute the OTB command list via system call</p></a></li>
<li><a href='#searchGDALW'><p>Search recursively for valid 'GDAL' installation(s) on a 'Windows' OS</p></a></li>
<li><a href='#searchGDALX'><p>Search recursively for valid 'GDAL' installation(s) on a 'Windows' OS</p></a></li>
<li><a href='#searchGRASSW'><p>Search recursivly valid 'GRASS GIS' installation(s) on a given 'Windows' drive</p></a></li>
<li><a href='#searchGRASSX'><p>Return attributes of valid 'GRASS GIS' installation(s) in 'Linux'</p></a></li>
<li><a href='#searchOTBW'><p>Search recursively for valid 'OTB' installation(s) on a 'Windows' OS</p></a></li>
<li><a href='#searchOTBX'><p>Search recursively for valid 'OTB' installation(s) on a 'Linux' OS</p></a></li>
<li><a href='#searchSAGAW'><p>Searches recursively for existing 'Windows' 'SAGA GIS' installation(s)</p></a></li>
<li><a href='#searchSAGAX'><p>Searches recursively for existing 'Windows' 'SAGA GIS' installation(s)</p></a></li>
<li><a href='#setenvGDAL'><p>Usually for internally usage, initializes and set up  access to the 'GDAL' command line interface</p></a></li>
<li><a href='#setenvGRASSw'><p>Usually for internally usage, create valid 'GRASS GIS 7.xx' rsession environment settings according to the selected GRASS GIS 7.x and Windows Version</p></a></li>
<li><a href='#setenvOTB'><p>Usually for internally usage, initializes and set up  access to the 'OTB' command line interface</p></a></li>
<li><a href='#sf2gvec'><p>Write sf object directly to 'GRASS' vector utilising an existing or creating a new GRASS environment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linking Geographic Information Systems, Remote Sensing and Other
Command Line Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-30</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Reudenbach &lt;reudenbach@uni-marburg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to simplify the linking of open source GIS and remote sensing related command line interfaces.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-spatial/link2GI/">https://github.com/r-spatial/link2GI/</a>,
<a href="https://r-spatial.github.io/link2GI/">https://r-spatial.github.io/link2GI/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/link2GI/issues/">https://github.com/r-spatial/link2GI/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>devtools, R.utils, roxygen2, sf (&ge; 0.9), stringr, terra,
methods, utils, xml2, xfun</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, sp, rgrass, stars, curl, listviewer,
markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-30 19:52:59 UTC; creu</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Reudenbach [cre, aut],
  Tim Appelhans [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-30 20:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='add2Path'>Adds a defined variable and value to the global search path</h2><span id='topic+add2Path'></span>

<h3>Description</h3>

<p>Adds a variable to the global search path of the current environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add2Path(newPath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add2Path_+3A_newpath">newPath</code></td>
<td>
<p>the path that is added</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add path
add2Path("pathtosomewhere")

## End(Not run)
</code></pre>

<hr>
<h2 id='findGDAL'>Search recursivly existing 'GDAL binaries' installation(s) at a given drive/mountpoint</h2><span id='topic+findGDAL'></span>

<h3>Description</h3>

<p>Provides an  list of valid 'GDAL' installation(s) 
on your 'Windows' system. There is a major difference between osgeo4W and 
stand_alone installations. The functions trys to find all valid 
installations by analysing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findGDAL(searchLocation = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findGDAL_+3A_searchlocation">searchLocation</code></td>
<td>
<p>drive letter to be searched, for Windows systems default
is <code>C:</code>, for Linux systems default is <code>/usr</code>.</p>
</td></tr>
<tr><td><code id="findGDAL_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GDAL' root folder(s),  and command line executable(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# find recursively all existing 'GDAL' installations folders starting 
# at the default search location
findGDAL()
}
</code></pre>

<hr>
<h2 id='findGRASS'>Return attributes of valid 'GRASS GIS' installation(s) on the system</h2><span id='topic+findGRASS'></span>

<h3>Description</h3>

<p>Provides a list of valid 'GRASS GIS' installation(s) 
on your system. There is a major difference between osgeo4W and 
stand_alone installations. The functions tries to find all valid 
installations by analysing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findGRASS(searchLocation = "default", ver_select = FALSE, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findGRASS_+3A_searchlocation">searchLocation</code></td>
<td>
<p>location to be searched for the grass executable, 
i.e. one executable for each GRASS installation on the system.
For Windows systems
it is mandatory to include an uppercase Windows drive letter and a colon.
Default For Windows Systems 
is <code>C:</code>, for Linux systems default is <code>/usr/bin</code>.</p>
</td></tr>
<tr><td><code id="findGRASS_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean default is FALSE. If there is more than one 'SAGA GIS' installation and <code>ver_select</code> = TRUE the user can select interactively the preferred 'SAGA GIS' version</p>
</td></tr>
<tr><td><code id="findGRASS_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GRASS GIS' binary folder(s) (i.e. where the 
individual GRASS commands are installed), version name(s) and 
installation type code(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# find recursively all existing 'GRASS GIS' installation folders starting 
# at the default search location
findGRASS()

## End(Not run)
</code></pre>

<hr>
<h2 id='findOTB'>Search recursivly existing 'Orfeo Toolbox' installation(s) at a given drive/mountpoint</h2><span id='topic+findOTB'></span>

<h3>Description</h3>

<p>Provides an  list of valid 'OTB' installation(s) 
on your 'Windows' system. There is a major difference between osgeo4W and 
stand_alone installations. The functions trys to find all valid 
installations by analysing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findOTB(searchLocation = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findOTB_+3A_searchlocation">searchLocation</code></td>
<td>
<p>drive letter to be searched, for Windows systems default
is <code>C:</code>, for Linux systems default is <code>/usr</code>.</p>
</td></tr>
<tr><td><code id="findOTB_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'OTB' root folder(s),  and command line executable(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# find recursively all existing 'Orfeo Toolbox' installations folders starting 
# at the default search location
findOTB()

## End(Not run)
</code></pre>

<hr>
<h2 id='findSAGA'>Search recursivly existing 'SAGA GIS' installation(s) at a given drive/mountpoint</h2><span id='topic+findSAGA'></span>

<h3>Description</h3>

<p>Provides an  list of valid 'SAGA GIS' installation(s) 
on your 'Windows' system. There is a major difference between osgeo4W and 
stand_alone installations. The functions trys to find all valid 
installations by analysing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSAGA(searchLocation = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSAGA_+3A_searchlocation">searchLocation</code></td>
<td>
<p>drive letter to be searched, for Windows systems default
is <code>C:</code>, for Linux systems default is <code>/usr</code>.</p>
</td></tr>
<tr><td><code id="findSAGA_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'SAGA GIS' root folder(s), version name(s) and 
installation type code(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# find recursively all existing 'SAGA GIS' installation folders starting 
# at the default search location
findSAGA()

## End(Not run)
</code></pre>

<hr>
<h2 id='getSpatialClass'>Checks if x is of type raster,terra,sf or sp</h2><span id='topic+getSpatialClass'></span>

<h3>Description</h3>

<p>Checks if x is a raster or sp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpatialClass(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSpatialClass_+3A_obj">obj</code></td>
<td>
<p>R raster* or sp object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add path
getSpatialClass(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='gvec2sf'>Converts from an existing 'GRASS' environment an arbitrary vector dataset  into a  sf object</h2><span id='topic+gvec2sf'></span>

<h3>Description</h3>

<p>Converts from an existing 'GRASS' environment an arbitrary vector dataset  into a  sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvec2sf(x, obj_name, gisdbase, location, gisdbase_exist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gvec2sf_+3A_x">x</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> object corresponding to the settings of the corresponding GRASS container</p>
</td></tr>
<tr><td><code id="gvec2sf_+3A_obj_name">obj_name</code></td>
<td>
<p>name of GRASS layer</p>
</td></tr>
<tr><td><code id="gvec2sf_+3A_gisdbase">gisdbase</code></td>
<td>
<p>GRASS gisDbase folder</p>
</td></tr>
<tr><td><code id="gvec2sf_+3A_location">location</code></td>
<td>
<p>GRASS location name containing <code>obj_name)</code></p>
</td></tr>
<tr><td><code id="gvec2sf_+3A_gisdbase_exist">gisdbase_exist</code></td>
<td>
<p>logical switch if the GRASS gisdbase folder exist default is TRUE</p>
</td></tr>
</table>


<h3>Note</h3>

<p>have a look at the <code><a href="sf.html#topic+sf">sf</a></code> capabilities to read direct from sqlite
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
## example 
require(sf)
require(sp)
require(link2GI)
data(meuse)
meuse_sf = st_as_sf(meuse, 
                    coords = c("x", "y"), 
                    crs = 28992, 
                    agr = "constant")


# write data to GRASS and create gisdbase
sf2gvec(x = meuse_sf,
        obj_name = "meuse_R-G",
        gisdbase = "~/temp3/",
        location = "project1")

# read from existing GRASS          
gvec2sf(x = meuse_sf,
        obj_name = "meuse_r_g",
        gisdbase = "~/temp3",       
        location = "project1")

}
</code></pre>

<hr>
<h2 id='initProj'>Defines and creates folders and variables</h2><span id='topic+initProj'></span>

<h3>Description</h3>

<p>Defines and creates (if necessary) all folders variables. Returns a list with the project folder pathes. Optionally exports all pathes to a global sub environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initProj(
  projRootDir = tempdir(),
  GRASSlocation = "tmp/",
  projFolders = c("data/", "result/", "run/", "log/"),
  path_prefix = "",
  global = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initProj_+3A_projrootdir">projRootDir</code></td>
<td>
<p>project github root directory (your github name)</p>
</td></tr>
<tr><td><code id="initProj_+3A_grasslocation">GRASSlocation</code></td>
<td>
<p>folder for GRASS data</p>
</td></tr>
<tr><td><code id="initProj_+3A_projfolders">projFolders</code></td>
<td>
<p>list of subfolders in project</p>
</td></tr>
<tr><td><code id="initProj_+3A_path_prefix">path_prefix</code></td>
<td>
<p>character a prefix for the path variables names default is &quot;&quot;</p>
</td></tr>
<tr><td><code id="initProj_+3A_global">global</code></td>
<td>
<p>boolean esport path strings as global variables default is false</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

link2GI::initProj(projRootDir = tempdir(),
                 projFolders = c("data/",
                                 "data/level0/",
                                 "data/level1/",
                                  "output/",
                                  "run/",
                                  "fun/") )

## End(Not run)   
</code></pre>

<hr>
<h2 id='linkAll'>convenient function to establish all link2GI links</h2><span id='topic+linkAll'></span>

<h3>Description</h3>

<p>brute force search, find and linkl of all link2GI link functions. This is helpfull if yor system is well setup and the standard linkage procedure will provide the correct linkages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkAll(
  links = NULL,
  simple = TRUE,
  linkItems = c("saga", "grass", "otb", "gdal"),
  sagaArgs = "default",
  grassArgs = "default",
  otbArgs = "default",
  gdalArgs = "default",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkAll_+3A_links">links</code></td>
<td>
<p>character. links</p>
</td></tr>
<tr><td><code id="linkAll_+3A_simple">simple</code></td>
<td>
<p>logical. true  make all</p>
</td></tr>
<tr><td><code id="linkAll_+3A_linkitems">linkItems</code></td>
<td>
<p>character. list of c(&quot;saga&quot;,&quot;grass&quot;,&quot;otb&quot;,&quot;gdal&quot;)</p>
</td></tr>
<tr><td><code id="linkAll_+3A_sagaargs">sagaArgs</code></td>
<td>
<p>character. full string of sagaArgs</p>
</td></tr>
<tr><td><code id="linkAll_+3A_grassargs">grassArgs</code></td>
<td>
<p>character. grassArgs full string of grassArgs</p>
</td></tr>
<tr><td><code id="linkAll_+3A_otbargs">otbArgs</code></td>
<td>
<p>character. full string of otbArgs</p>
</td></tr>
<tr><td><code id="linkAll_+3A_gdalargs">gdalArgs</code></td>
<td>
<p>character. full string of gdalArgs</p>
</td></tr>
<tr><td><code id="linkAll_+3A_quiet">quiet</code></td>
<td>
<p>supress all messages default is FALSE</p>
</td></tr>
</table>


<h3>Note</h3>

<p>You may also use the full list of arguments that is made available from the <code>link2GI</code> package, but it is strongly recommended in this case to use directly the single linkage functions from  <code>link2GI</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# required packages
require(link2GI)

# search, find and create the links to all supported  GI software
giLinks&lt;-linkAll()

# makes the GDAL linkage verbose
giLinks&lt;-linkAll(gdalArgs= "quiet = TRUE") 


## End(Not run)
</code></pre>

<hr>
<h2 id='linkGDAL'>Locate and set up 'GDAL' API bindings</h2><span id='topic+linkGDAL'></span>

<h3>Description</h3>

<p>Locate and set up  <a href="https://gdal.org/">'GDAL - Geospatial Data Abstraction Librar'</a> API bindings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkGDAL(
  bin_GDAL = NULL,
  searchLocation = NULL,
  ver_select = FALSE,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkGDAL_+3A_bin_gdal">bin_GDAL</code></td>
<td>
<p>string contains path to where the gdal binaries are located</p>
</td></tr>
<tr><td><code id="linkGDAL_+3A_searchlocation">searchLocation</code></td>
<td>
<p>string hard drive letter default is <code>C:</code></p>
</td></tr>
<tr><td><code id="linkGDAL_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean default is FALSE. If there is more than one 'GDAL' installation and <code>ver_select</code> = TRUE the user can select interactively the preferred 'GDAL' version</p>
</td></tr>
<tr><td><code id="linkGDAL_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkGDAL_+3A_returnpaths">returnPaths</code></td>
<td>
<p>boolean if set to FALSE the pathes of the selected version are written 
to the PATH variable only, otherwise all paths and versions of the installed GRASS versions ae returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It looks for the <code>gdalinfo(.exe)</code> file. If the file is found in a <code>bin</code> folder it is assumed to be a valid 'GDAL' binary installation.
</p>
<p>if called without any parameter <code>linkGDAL()</code> it performs a full search over the hardrive <code>C:</code>. If it finds one or more 'GDAL' binaries it will take the first hit. You have to set <code>ver_select = TRUE</code> for an interactive selection of the preferred version.
</p>


<h3>Value</h3>

<p>add gdal pathes to the enviroment and creates global variables path_GDAL
</p>


<h3>Note</h3>

<p>You may also set the path manually. Using a 'OSGeo4W64' <a href="https://trac.osgeo.org/osgeo4w/">https://trac.osgeo.org/osgeo4w/</a> installation it is typically <code>C:/OSGeo4W64/bin/</code>
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# call if you do not have any idea if and where GDAL is installed
gdal&lt;-linkGDAL()
if (gdal$exist) {
# call it for a default OSGeo4W installation of the GDAL
print(gdal)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='linkGRASS'>Locate and set up 'GRASS' API bindings</h2><span id='topic+linkGRASS'></span>

<h3>Description</h3>

<p>Initializes the session environment and the system paths for an easy access to
<a href="https://grass.osgeo.org/">'GRASS GIS 7.x/8.x'</a>.  The correct setup of the spatial and
projection parameters is automatically performed by using either an existing and valid 
<code>raster</code>, <code>terra</code>, <code>sp</code> or <code>sf</code> object, 
or manually by providing a list containing the minimum parameters needed.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkGRASS(
  x = NULL,
  default_GRASS = NULL,
  search_path = NULL,
  ver_select = FALSE,
  gisdbase_exist = FALSE,
  gisdbase = NULL,
  use_home = FALSE,
  location = NULL,
  spatial_params = NULL,
  resolution = NULL,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkGRASS_+3A_x">x</code></td>
<td>
<p>raster/terra or sf/sp object</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_default_grass">default_GRASS</code></td>
<td>
<p>default is <code>NULL</code> If is <code>NULL</code> an automatic search for all installed versions is performed. 
If you provide a valid list the corresponding version is initialized. An example for OSGeo4W64 is:
<code>c("C:/OSGeo4W64","grass-7.0.5","osgeo4w")</code></p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_search_path">search_path</code></td>
<td>
<p>path or mounting point that will be searched</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean if TRUE you may choose interactively the binary version (if found  more than one),  by default FALSE</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_gisdbase_exist">gisdbase_exist</code></td>
<td>
<p>default is FALSE if set to TRUE the arguments gisdbase and location are expected to be an existing GRASS gisdbase</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_gisdbase">gisdbase</code></td>
<td>
<p>default is <code>NULL</code>, invoke <code>tempdir()</code> to the 'GRASS' database. Alternatively you can provide a individual path.</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_use_home">use_home</code></td>
<td>
<p>default is <code>FALSE</code>, set the GISRC path to tempdir(), if TRUE the HOME or USERPROFILE setting is used for writing the GISRC file</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_location">location</code></td>
<td>
<p>default is <code>NULL</code>, invoke <code>basename(tempfile())</code> for defining the 'GRASS' location. Alternatively you can provide a individual path.</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_spatial_params">spatial_params</code></td>
<td>
<p>default is <code>NULL</code>. Instead of a spatial object you may provide the geometry as a list. E.g. c(xmin,ymin,xmax,ymax,proj4_string)</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_resolution">resolution</code></td>
<td>
<p>resolution in map units for the GRASS raster cells</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_returnpaths">returnPaths</code></td>
<td>
<p>boolean if set to FALSE the pathes of the selected version are written 
to the PATH variable only, otherwise all paths and versions of the installed GRASS versions ae returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concept is straightforward but for an all days usage helpful. Either you need to 
provide a <code>raster</code> or <code>sp</code> <code>sf</code> spatial object
which has correct spatial and projection properties or you may link directlxy to an existing 'GRASS' gisdbase and mapset. 
If you choose an spatial object to initialize a correct 'GRASS' mapset it is used to create either a temporary or a permanent 
<a href="https://CRAN.R-project.org/package=rgrass">rgrass</a> environment including the correct 'GRASS ' structure.<br /><br />
The most time consuming part on 'Windows' Systems is the search process. This can easily take 10 or more minutes. 
To speed up this process you can also provide a correct parameter set. Best way to do so is to call <code>searchGRASSW</code> or for 'Linux' <code>searchGRASSX</code> manually. 
and call <code>linkGRASS</code> with the version arguments of your choice. linkGRASS initializes the usage of GRASS7.
</p>


<h3>Note</h3>

<p>'GRASS GIS' is excellently supported by the
<code>rgrass</code> wrapper package. Nevertheless 'GRASS GIS' is well known for
its high demands regarding the correct spatial and reference setup  
of work space and environment requirements. This becomes even worse on 'Windows' 
platforms or if several alternative 'GRASS GIS' installations are available.
If one knows what to do the <code>rgrass</code> package setup function 
<code>rgrass::initGRASS</code> works fine under Linux. 
This is also valid for well known configurations under the 'Windows' operation system. 
Nevertheless on university labs or on company computers with restricted privileges and/or using different releases
like the  <a href="https://trac.osgeo.org/osgeo4w/">'OSGeo4W'</a> distribution and the  
<a href="https://grass.osgeo.org/download/windows/">'GRASS ' stand-alone</a> installation, 
or different software releases (e.g. 'GRASS 7.0.5 and GRASS 8.1.0), it becomes often cumbersome or even 
impossible to get the correct linkages. <br /> 
The function <code>linkGRASS</code> tries to find all valid 'GRASS GIS' binaries by analyzing
the startup script files of 'GRASS GIS'. After identifying the 'GRASS GIS' binaries all
necessary system variables and settings will be generated and passed to a temporary R enviroment.
</p>
<p>If you have more than one valid installation and run <code>linkGRASS()</code> without arguments, you will be ask to select one.
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
library(link2GI)
require(sf)

# proj folders
projRootDir = tempdir()
paths = link2GI::initProj(projRootDir = projRootDir,
                         projFolders = c("project1/"))
                         
# get  data                         
nc = st_read(system.file("shape/nc.shp", package="sf"))

# Automatic search and find of GRASS binaries 
# using the nc sf data object for spatial referencing
# This is the highly recommended linking procedure for on the fly jobs
# NOTE: if more than one GRASS installation is found you have to choose. 
grass = linkGRASS(nc,returnPaths = TRUE)
if (grass$exist){

# CREATE and link to a permanent GRASS folder at "projRootDir", location named "project1" 
linkGRASS(nc, gisdbase = projRootDir, location = "project1")   

# ONLY LINK to a permanent GRASS folder at "projRootDir", location named "project1" 
linkGRASS(gisdbase = projRootDir, location = "project1", gisdbase_exist = TRUE )   


# setting up GRASS manually with spatial parameters of the nc data
proj4_string = as.character(sp::CRS("+init=epsg:28992"))
linkGRASS(spatial_params = c(178605,329714,181390,333611,proj4_string)) 

# creating a GRASS gisdbase manually with spatial parameters of the nc data 
# additionally using a peramanent directory "projRootDir" and the location "nc_spatial_params "
proj4_string = as.character(sp::CRS("+init=epsg:4267"))
linkGRASS(gisdbase = projRootDir,
           location = "nc_spatial_params",
           spatial_params = c(-84.32385, 33.88199,-75.45698,36.58965,proj4_string))
}

## Some more examples related to interactive selection or OS specific settings

# SELECT the GRASS installation and define the search location
linkGRASS(nc, ver_select = TRUE, search_path = "~")

# SELECT the GRASS installation 
linkGRASS(nc, ver_select = TRUE)

# Typical osge4W installation (QGIS), using the meuse sp data object for spatial referencing
linkGRASS(nc,c("C:/Program Files/QGIS 2.18","grass-7.2.1","osgeo4W")) 

# Typical osgeo4W installation (rootdir), using the meuse sp data object for spatial referencing 
linkGRASS(nc,c("C:/OSGeo4W64/","grass-7.2.2","osgeo4W"))

}

</code></pre>

<hr>
<h2 id='linkGRASS7'>Deprecated only for backwards compatibility Locate and set up 'GRASS' API bindings</h2><span id='topic+linkGRASS7'></span>

<h3>Description</h3>

<p>Initializes the session environment and the system paths for an easy access to 
<a href="https://grass.osgeo.org/">'GRASS GIS 7.x/8.x'</a>.  The correct setup of the spatial and projection parameters is
automatically performed by using either an existing and valid <code>raster</code>, <code>terra</code>, <code>sp</code> or <code>sf</code> object, 
or manually by providing a list containing the minimum parameters needed.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkGRASS7(
  x = NULL,
  default_GRASS = NULL,
  search_path = NULL,
  ver_select = FALSE,
  gisdbase_exist = FALSE,
  gisdbase = NULL,
  use_home = FALSE,
  location = NULL,
  spatial_params = NULL,
  resolution = NULL,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkGRASS7_+3A_x">x</code></td>
<td>
<p>raster/terra or sp/sf object</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_default_grass">default_GRASS</code></td>
<td>
<p>default is <code>NULL</code> If is <code>NULL</code> an automatic search for all installed versions is performed. 
If you provide a valid list the corresponding version is initialized. An example for OSGeo4W64 is: <code>c("C:/OSGeo4W64","grass-7.0.5","osgeo4w")</code></p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_search_path">search_path</code></td>
<td>
<p>path or mounting point that will be searched</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean if TRUE you may choose interactively the binary version (if found  more than one),  by default FALSE</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_gisdbase_exist">gisdbase_exist</code></td>
<td>
<p>default is FALSE if set to TRUE the arguments gisdbase and location are expected to be an existing GRASS gisdbase</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_gisdbase">gisdbase</code></td>
<td>
<p>default is <code>NULL</code>, invoke <code>tempdir()</code> to the 'GRASS' database. Alternativeley you can provide a individual path.</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_use_home">use_home</code></td>
<td>
<p>default is <code>FALSE</code>, set the GISRC path to tempdir(), if TRUE the HOME or USERPROFILE setting is used for writing the GISRC file</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_location">location</code></td>
<td>
<p>default is <code>NULL</code>, invoke <code>basename(tempfile())</code> for defining the 'GRASS' location. Alternativeley you can provide a individual path.</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_spatial_params">spatial_params</code></td>
<td>
<p>default is <code>NULL</code>. Instead of a spatial object you may provide the geometry as a list. E.g. c(xmin,ymin,xmax,ymax,proj4_string)</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_resolution">resolution</code></td>
<td>
<p>resolution in map units for the GRASS raster cells</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkGRASS7_+3A_returnpaths">returnPaths</code></td>
<td>
<p>boolean if set to FALSE the pathes of the selected version are written 
to the PATH variable only, otherwise all paths and versions of the installed GRASS versions ae returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concept is straightforward but for an all days usage helpful. Either you need to 
provide a <code>raster</code> or <code>sp</code> <code>sf</code> spatial object
which has correct spatial and projection properties or you may link directlxy to an existing 'GRASS' gisdbase and mapset. 
If you choose an spatial object to initialize a correct 'GRASS' mapset it is used to create either a temporary or a permanent 
<a href="https://CRAN.R-project.org/package=rgrass">rgrass</a> environment including the correct 'GRASS ' structure.<br /><br />
The most time consuming part on 'Windows' Systems is the search process. This can easily take 10 or more minutes. 
To speed up this process you can also provide a correct parameter set. Best way to do so is to call <code>searchGRASSW</code> or for 'Linux' <code>searchGRASSX</code> manually. 
and call <code>linkGRASS</code> with the version arguments of your choice. linkGRASS initializes the usage of GRASS.
</p>


<h3>Note</h3>

<p>'GRASS GIS ' is excellently supported by the
<code>rgrass</code> wrapper package. Nevertheless 'GRASS GIS' is well known for
its high demands regarding the correct spatial and reference setup  
of workspace and environment requirements. This becomes even worse on 'Windows' 
platforms or if several alternative 'GRASS GIS' installations are available.
If one knows what to do the <code>rgrass</code> package setup function <code>rgrass::initGRASS</code> works fine under Linux. 
This is also valid for well known configurations under the 'Windows' operation system. 
Nevertheless on university lab or on company computers with restriced privileges and/or using different releases
like the  <a href="https://trac.osgeo.org/osgeo4w/">'OSGeo4W'</a> distribution and the  
<a href="https://grass.osgeo.org/download/windows/">'GRASS ' stand-alone</a> installation, 
or different software releases (e.g. 'GRASS 7.0.5 and GRASS 8.1.0), it becomes often cumbersome or even impossible to get the correct linkages. <br /> 
The function <code>linkGRASS</code> tries to find all valid 'GRASS GIS' binaries by analyzing
the startup script files of 'GRASS GIS'. After identifying the 'GRASS GIS' binaries all
necessary system variables and settings will be generated and passed to a temporary R enviroment.
</p>
<p>If you have more than one valid installation and run <code>linkGRASS()</code> without arguments, you will be ask to select one.
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(link2GI)
require(sf)

# proj folders
projRootDir = tempdir()
paths = link2GI::initProj(projRootDir = projRootDir,
                         projFolders = c("project1/"))
                         
# get  data                         
nc = st_read(system.file("shape/nc.shp", package="sf"))

# Automatic search and find of GRASS binaries 
# using the nc sf data object for spatial referencing
# This is the highly recommended linking procedure for on the fly jobs
# NOTE: if more than one GRASS installation is found you have to choose. 
grass = linkGRASS(nc,returnPaths = TRUE)
if (grass$exist){

# CREATE and link to a permanent GRASS folder at "projRootDir", location named "project1" 
linkGRASS(nc, gisdbase = projRootDir, location = "project1")   

# ONLY LINK to a permanent GRASS folder at "projRootDir", location named "project1" 
linkGRASS(gisdbase = projRootDir, location = "project1", gisdbase_exist = TRUE )   


# setting up GRASS manually with spatial parameters of the nc data
proj4_string = as.character(sp::CRS("+init=epsg:28992"))
linkGRASS(spatial_params = c(178605,329714,181390,333611,proj4_string)) 

# creating a GRASS gisdbase manually with spatial parameters of the nc data 
# additionally using a peramanent directory "projRootDir" and the location "nc_spatial_params "
proj4_string = as.character(sp::CRS("+init=epsg:4267"))
linkGRASS(gisdbase = projRootDir,
           location = "nc_spatial_params",
           spatial_params = c(-84.32385, 33.88199,-75.45698,36.58965,proj4_string))
}

## Some more examples related to interactive selection or OS specific settings

# SELECT the GRASS installation and define the search location
linkGRASS(nc, ver_select = TRUE, search_path = "~")

# SELECT the GRASS installation 
linkGRASS(nc, ver_select = TRUE)

# Typical osge4W installation (QGIS), using the meuse sp data object for spatial referencing
linkGRASS(nc,c("C:/Program Files/QGIS 2.18","grass-7.2.1","osgeo4W")) 

# Typical osgeo4W installation (rootdir), using the meuse sp data object for spatial referencing 
linkGRASS(nc,c("C:/OSGeo4W64/","grass-7.2.2","osgeo4W"))


## End(Not run)
</code></pre>

<hr>
<h2 id='linkOTB'>Locate and set up 'Orfeo ToolBox' API bindings</h2><span id='topic+linkOTB'></span>

<h3>Description</h3>

<p>Locate and set up  <a href="https://www.orfeo-toolbox.org/">'Orfeo ToolBox'</a> API bindings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkOTB(
  bin_OTB = NULL,
  root_OTB = NULL,
  type_OTB = NULL,
  searchLocation = NULL,
  ver_select = FALSE,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkOTB_+3A_bin_otb">bin_OTB</code></td>
<td>
<p>string contains path to where the otb binaries are located</p>
</td></tr>
<tr><td><code id="linkOTB_+3A_root_otb">root_OTB</code></td>
<td>
<p>string provides the root folder of the <code>bin_OTB</code></p>
</td></tr>
<tr><td><code id="linkOTB_+3A_type_otb">type_OTB</code></td>
<td>
<p>string</p>
</td></tr>
<tr><td><code id="linkOTB_+3A_searchlocation">searchLocation</code></td>
<td>
<p>string hard drive letter (Windows) or mounting point (Linux) default for Windows is <code>C:</code>, default for Linux is <code>~</code></p>
</td></tr>
<tr><td><code id="linkOTB_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean default is FALSE. If there is more than one 'OTB' installation and <code>ver_select</code> = TRUE the user can select interactively the preferred 'OTB' version In opposite if FALSE the newest version is automatically choosen.</p>
</td></tr>
<tr><td><code id="linkOTB_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkOTB_+3A_returnpaths">returnPaths</code></td>
<td>
<p>boolean if set to FALSE the pathes of the selected version are written 
to the PATH variable only, otherwise all paths and versions of the installed GRASS versions ae returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It looks for the <code>otb_cli.bat</code> file. If the file is found in a <code>bin</code> folder it is assumed to be a valid 'OTB' binary installation.
</p>
<p>if called without any parameter <code>linkOTB()</code> it performs a full search over the hardrive <code>C:</code>. If it finds one or more 'OTB' binaries it will take the first hit. You have to set <code>ver_select = TRUE</code> for an interactive selection of the preferred version.
</p>


<h3>Value</h3>

<p>add otb pathes to the enviroment and creates global variables path_OTB
</p>


<h3>Note</h3>

<p>You may also set the path manually. Using a 'OSGeo4W64' <a href="https://trac.osgeo.org/osgeo4w/">https://trac.osgeo.org/osgeo4w/</a> installation it is typically <code>C:/OSGeo4W64/bin/</code>
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# call if you do not have any idea if and where OTB is installed
otb&lt;-linkOTB()
if (otb$exist) {
# call it for a default OSGeo4W installation of the OTB
print(otb)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='linkSAGA'>Identifies SAGA GIS Installations and returns linking Informations</h2><span id='topic+linkSAGA'></span>

<h3>Description</h3>

<p>Finds the existing <a href="https://saga-gis.sourceforge.io/">SAGA GIS</a> installation(s), 
generates and sets the necessary path and system variables for a seamless use of the command 
line calls of the 'SAGA GIS' CLI API, setup valid system variables for calling a default 
<code>rsaga.env</code> and by this makes available the <code>RSAGA</code> wrapper functions.<br />
All existing installation(s) means that it looks for the <code>saga_cmd</code> or <code>saga_cmd.exe</code> 
executables. If the file is found it is assumed to be a valid 'SAGA GIS' installation. If it is called without any argument the most recent (i.e. highest) SAGA GIS version will be linked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkSAGA(
  default_SAGA = NULL,
  searchLocation = "default",
  ver_select = FALSE,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkSAGA_+3A_default_saga">default_SAGA</code></td>
<td>
<p>string contains path to <code>RSAGA</code> binaries</p>
</td></tr>
<tr><td><code id="linkSAGA_+3A_searchlocation">searchLocation</code></td>
<td>
<p>drive letter to be searched, for Windows systems default
is <code>C:</code>, for Linux systems default is <code>/usr</code>.</p>
</td></tr>
<tr><td><code id="linkSAGA_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean default is FALSE. If there is more than one 'SAGA GIS' installation and <code>ver_select</code> = TRUE the user can select interactively the preferred 'SAGA GIS' version</p>
</td></tr>
<tr><td><code id="linkSAGA_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkSAGA_+3A_returnpaths">returnPaths</code></td>
<td>
<p>boolean if set to FALSE the pathes of the selected version are written 
to the PATH variable only, otherwise all paths and versions of the installed SAGA versions ae returned.#'@details If called without any parameter <code>linkSAGA()</code> it performs a full search over <code>C:</code>. If it finds one or more 'SAGA GIS' binaries it will take the first hit. You have to set <code>ver_select = TRUE</code> for an interactive selection of the preferred version. Additionally the selected SAGA pathes are added to the environment and the global variables <code>sagaPath</code>, <code>sagaModPath</code> and <code>sagaCmd</code> will be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the selected <code>RSAGA</code> path variables <code>$sagaPath</code>,<code>$sagaModPath</code>,<code>$sagaCmd</code> and potentially other installations <code>$installed</code>
</p>


<h3>Note</h3>

<p>The excellent 'SAGA GIS' wrapper <a href="https://CRAN.R-project.org/package=RSAGA">RSAGA</a> 
package was updated several times however it covers currently (Dec 2019) only 'SAGA GIS' 
versions from 2.3.1 - 6.3.0 The fast evolution of 'SAGA GIS' makes it highly impracticable
to keep the wrapper adaptions in line (currently 7.5). <code>RSAGA</code> will meet all linking needs perfectly if 
you use 'SAGA GIS' versions from 2.0.4 - 7.5.0. <br />  However you must call <code>rsaga.env</code> using the <code>rsaga.env(modules = saga$sagaModPath)</code> assuming that <code>saga</code> contains the returnPaths of <code>linkSAGA</code> 
In addition most recently  the very promising  <a href="https://github.com/stevenpawley/Rsagacmd">Rsagacmd</a> wrapper package is providing a new list oriented wrapping tool.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# call if you do not have any idea if and where SAGA GIS is installed
# it will return a list with the selected and available SAGA installations
# it prepares the system for running the selected SAGA version via RSAGA or CLI
linkSAGA()

# overriding the default environment of rsaga.env call 

saga&lt;-linkSAGA()
if (saga$exist) {
require(RSAGA)
RSAGA::rsaga.env(path = saga$installed$binDir[1],modules = saga$installed$moduleDir[1])
}

## End(Not run)
</code></pre>

<hr>
<h2 id='makGlobalVar'>Generates a variable with a certain value in the R environment</h2><span id='topic+makGlobalVar'></span>

<h3>Description</h3>

<p>Generates a variable with a certain value in the R environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makGlobalVar(name, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makGlobalVar_+3A_name">name</code></td>
<td>
<p>character string name of the variable</p>
</td></tr>
<tr><td><code id="makGlobalVar_+3A_value">value</code></td>
<td>
<p>character string value of the variable</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# creates the global var \code{pathToData} with the value \code{~/home/data}
makGlobalVar("pathToData","~/home/data") 


## End(Not run)

</code></pre>

<hr>
<h2 id='manuallyBuild'>Build package manually</h2><span id='topic+manuallyBuild'></span>

<h3>Description</h3>

<p>This function was specifically designed to build a package from local source 
files manually, i.e., without using the package building functionality 
offered e.g. by RStudio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manuallyBuild(dsn = getwd(), pkgDir = "H:/Dokumente", document = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manuallyBuild_+3A_dsn">dsn</code></td>
<td>
<p>'character'. Target folder containing source files; defaults to 
the current working directory.</p>
</td></tr>
<tr><td><code id="manuallyBuild_+3A_pkgdir">pkgDir</code></td>
<td>
<p>'character'. Target folder containing the result ing package of the invoked build process. According to Marburg University pools the default is set to pkgDir=&quot;H:/Dokumente&quot;. If you want to use it in a different setting you may set pkgDir to whatever you want.</p>
</td></tr>
<tr><td><code id="manuallyBuild_+3A_document">document</code></td>
<td>
<p>'logical'. Determines whether or not to invoke 
<code><a href="roxygen2.html#topic+roxygenize">roxygenize</a></code> with default roclets for documentation purposes.</p>
</td></tr>
<tr><td><code id="manuallyBuild_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="devtools.html#topic+build">build</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE the default setting are focussing HRZ environment at Marburg University
</p>


<h3>Author(s)</h3>

<p>Florian Detsch, Chris Reudenbach
</p>


<h3>See Also</h3>

<p><code><a href="roxygen2.html#topic+roxygenize">roxygenize</a></code>, <code><a href="devtools.html#topic+build">build</a></code>,<code><a href="utils.html#topic+install.packages">install.packages</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## when in a package directory, e.g. '~/link2GI' 
manuallyBuild()

## End(Not run)


</code></pre>

<hr>
<h2 id='paramGRASSw'>Usually for internally usage get 'GRASS GIS' and <code>rgrass</code> parameters on 'Windows' OS</h2><span id='topic+paramGRASSw'></span>

<h3>Description</h3>

<p>Initialize the enviroment variables on a 'Windows' OS for using 
'GRASS GIS' via <code>rgrass</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramGRASSw(
  set_default_GRASS = NULL,
  DL = "C:",
  ver_select = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramGRASSw_+3A_set_default_grass">set_default_GRASS</code></td>
<td>
<p>default = NULL forces a full search for 'GRASS GIS' binaries. You may
alternatively provide a vector containing pathes and keywords. c(&quot;C:/OSGeo4W64&quot;,&quot;grass-7.0.5&quot;,&quot;osgeo4w&quot;) is valid for a typical osgeo4w installation.</p>
</td></tr>
<tr><td><code id="paramGRASSw_+3A_dl">DL</code></td>
<td>
<p>character search location default = <code>C:</code></p>
</td></tr>
<tr><td><code id="paramGRASSw_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean default is FALSE. If there is more than one 'SAGA GIS' installation and <code>ver_select</code> = TRUE the user can select interactively the preferred 'SAGA GIS' version</p>
</td></tr>
<tr><td><code id="paramGRASSw_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concept is very straightforward but for an all days usage pretty
helpful. You need to provide a <code>terra</code> or a <code>sf</code> object. The derived properties are used to initialize a temporary but static
<a href="https://CRAN.R-project.org/package=rgrass">rgrass</a> environment. During the rsession you will have full access to
GRASS7 both via the wrapper package as well as the command line. paramGRASSw initializes the usage of GRASS7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# automatic retrieval of valid 'GRASS GIS' environment settings 
# if more than one is found the user has to choose.
paramGRASSw()

# typical OSGeo4W64 installation
paramGRASSw(c("C:/OSGeo4W64","grass-7.0.5","osgeo4W"))
}
</code></pre>

<hr>
<h2 id='paramGRASSx'>Usually for internally usage, get 'GRASS GIS' and <code>rgrass</code> parameters on 'Linux' OS</h2><span id='topic+paramGRASSx'></span>

<h3>Description</h3>

<p>Initialize and set up <code>rgrass</code>  for 'Linux'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramGRASSx(
  set_default_GRASS = NULL,
  MP = "/usr/bin",
  ver_select = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramGRASSx_+3A_set_default_grass">set_default_GRASS</code></td>
<td>
<p>default = NULL will force a search for 'GRASS GIS' You may provide a valid combination as 
c(&quot;/usr/lib/grass74&quot;,&quot;7.4.1&quot;,&quot;grass74&quot;)</p>
</td></tr>
<tr><td><code id="paramGRASSx_+3A_mp">MP</code></td>
<td>
<p>mount point to be searched. default is &quot;/usr/bin&quot;</p>
</td></tr>
<tr><td><code id="paramGRASSx_+3A_ver_select">ver_select</code></td>
<td>
<p>if TRUE you must interactivley selcect between alternative installations</p>
</td></tr>
<tr><td><code id="paramGRASSx_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During the rsession you will have full access to GRASS7 GIS via the <code>rgrass</code> wrappe. Additionally you may use also use the API calls of GRASS7 via the command line.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# automatic retrieval of the GRASS7 enviroment settings
paramGRASSx()


# typical stand_alone installation
paramGRASSx("/usr/bin/grass72")

# typical user defined installation (compiled sources)
paramGRASSx("/usr/local/bin/grass72")
}
</code></pre>

<hr>
<h2 id='parseOTBAlgorithms'>Get OTB modules</h2><span id='topic+parseOTBAlgorithms'></span>

<h3>Description</h3>

<p>retrieve the OTB module folder content and parses the module names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseOTBAlgorithms(gili = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseOTBAlgorithms_+3A_gili">gili</code></td>
<td>
<p>optional list of avalailable 'OTB' binaries if not provided 'linkOTB()' is called</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## link to the OTB binaries
otblink&lt;-link2GI::linkOTB()

 if (otblink$exist) {

 ## parse all modules
 moduleList&lt;-parseOTBAlgorithms(gili = otblink)

 ## print the list
 print(moduleList)
 
 } 

## End(Not run)

</code></pre>

<hr>
<h2 id='parseOTBFunction'>Get OTB function argument list</h2><span id='topic+parseOTBFunction'></span>

<h3>Description</h3>

<p>retrieve the choosen function and returns a full argument list with the default settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseOTBFunction(algo = NULL, gili = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseOTBFunction_+3A_algo">algo</code></td>
<td>
<p>either the number or the plain name of the 'OTB' algorithm that is wanted. Note the correct (of current/choosen version) information is probided by 'parseOTBAlgorithms()'</p>
</td></tr>
<tr><td><code id="parseOTBFunction_+3A_gili">gili</code></td>
<td>
<p>optional list of avalailable 'OTB' binaries if not provided 'linkOTB()' is called</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
otblink&lt;-link2GI::linkOTB()
if (otblink$exist) {

## parse all modules
algos&lt;-parseOTBAlgorithms(gili = otblink)


## take edge detection
cmdList&lt;-parseOTBFunction(algo = algos[27],gili = otblink)
## print the current command
print(cmdList)
}

## End(Not run)
##+##
</code></pre>

<hr>
<h2 id='runOTB'>Execute the OTB command list via system call</h2><span id='topic+runOTB'></span>

<h3>Description</h3>

<p>Wrapper function which paste the OTB command list into a system call compatible string and execute this command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runOTB(
  otbCmdList = NULL,
  gili = NULL,
  retRaster = TRUE,
  retCommand = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runOTB_+3A_otbcmdlist">otbCmdList</code></td>
<td>
<p>the OTB algorithm parameter list</p>
</td></tr>
<tr><td><code id="runOTB_+3A_gili">gili</code></td>
<td>
<p>optional list providing the linkage to OTB as done by 'linkOTB()'. If not provided the 'runOTB' function try to link automatically.</p>
</td></tr>
<tr><td><code id="runOTB_+3A_retraster">retRaster</code></td>
<td>
<p>boolean if TRUE a raster stack is returned default is FALSE</p>
</td></tr>
<tr><td><code id="runOTB_+3A_retcommand">retCommand</code></td>
<td>
<p>boolean if TRUE only the OTB API command is returned default is FALSE</p>
</td></tr>
<tr><td><code id="runOTB_+3A_quiet">quiet</code></td>
<td>
<p>boolean  if TRUE suppressing messages default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' Please NOTE: You must check the help to identify the correct input file argument codewort ($input_in or $input_il).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(link2GI)
require(terra)
require(listviewer)

## link to OTB
otblink&lt;-link2GI::linkOTB()

if (otblink$exist) {
 projRootDir&lt;-tempdir()
 fn &lt;- system.file("ex/elev.tif", package = "terra")

## for an image output example we use the Statistic Extraction, 
algoKeyword&lt;- "LocalStatisticExtraction"

## extract the command list for the choosen algorithm 
cmd&lt;-parseOTBFunction(algo = algoKeyword, gili = otblink)

## Please NOTE:
## You must check the help to identify the correct argument codewort ($input_in or $input_il)
listviewer::jsonedit(cmd$help)

## define the mandatory arguments all other will be default
cmd$input_in  &lt;- fn
cmd$out &lt;- file.path(tempdir(),"test_otb_stat.tif")
cmd$radius &lt;- 7

## run algorithm
retStack&lt;-runOTB(cmd,gili = otblink)

## plot image
terra::plot(retStack)

## for a data output example we use the 

algoKeyword&lt;- "ComputeImagesStatistics"

## extract the command list for the chosen algorithm 
cmd&lt;-parseOTBFunction(algo = algoKeyword, gili = otblink)

## get help using the convenient listviewer
listviewer::jsonedit(cmd$help)

## define the mandatory arguments all other will be default
cmd$input_il  &lt;- file.path(tempdir(),"test.tif")
cmd$ram &lt;- 4096
cmd$out.xml &lt;- file.path(tempdir(),"test_otb_stat.xml")
cmd$progress &lt;- 1

## run algorithm
ret &lt;- runOTB(cmd,gili = otblink, quiet = F)

## as vector
print(ret)

## as xml
XML::xmlParse(cmd$out)
 
}

## End(Not run)
</code></pre>

<hr>
<h2 id='searchGDALW'>Search recursively for valid 'GDAL' installation(s) on a 'Windows' OS</h2><span id='topic+searchGDALW'></span>

<h3>Description</h3>

<p>Search for valid 'GDAL' installations on a 'Windows' OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGDALW(DL = "C:", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGDALW_+3A_dl">DL</code></td>
<td>
<p>drive letter default is &quot;C:&quot;</p>
</td></tr>
<tr><td><code id="searchGDALW_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GDAL' root folder(s) the version name(s) and the installation type(s).
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# get all valid GDAL installation folders and params
searchGDALW()
}
</code></pre>

<hr>
<h2 id='searchGDALX'>Search recursively for valid 'GDAL' installation(s) on a 'Windows' OS</h2><span id='topic+searchGDALX'></span>

<h3>Description</h3>

<p>Search for valid 'GDAL' installations on a 'Windows' OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGDALX(MP = "/usr", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGDALX_+3A_mp">MP</code></td>
<td>
<p>drive letter default is &quot;C:&quot;</p>
</td></tr>
<tr><td><code id="searchGDALX_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GDAL' root folder(s) the version name(s) and the installation type(s).
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# get all valid GDAL installation folders and params
searchGDALX()
}
</code></pre>

<hr>
<h2 id='searchGRASSW'>Search recursivly valid 'GRASS GIS' installation(s) on a given 'Windows' drive</h2><span id='topic+searchGRASSW'></span>

<h3>Description</h3>

<p>Provides an  list of valid 'GRASS GIS' installation(s) on your 'Windows' system. There is a major difference between osgeo4W and stand_alone installations. The functions trys to find all valid installations by analysing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGRASSW(DL = "C:", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGRASSW_+3A_dl">DL</code></td>
<td>
<p>drive letter to be searched, default is &quot;C:&quot;</p>
</td></tr>
<tr><td><code id="searchGRASSW_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUEs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GRASS GIS' root folder(s), version name(s) and installation type code(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all valid 'GRASS GIS' installation folders and params at "C:"
searchGRASSW()

## End(Not run)
</code></pre>

<hr>
<h2 id='searchGRASSX'>Return attributes of valid 'GRASS GIS' installation(s) in 'Linux'</h2><span id='topic+searchGRASSX'></span>

<h3>Description</h3>

<p>Searches recursively for valid 'GRASS GIS' installations at a given 'Linux' mount point.
Returns attributes for each installation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGRASSX(MP = "/usr/bin", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGRASSX_+3A_mp">MP</code></td>
<td>
<p>default is /usr. This is the directory from which the grass executable file is searched, i.e. one executable for each GRASS installation on the system.</p>
</td></tr>
<tr><td><code id="searchGRASSX_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUEs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing 'GRASS GIS' binary folder(s) (i.e. where the individual GRASS commands are installed), version name(s) and installation type code(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all valid 'GRASS GIS' installation folders in the /usr/bin directory (typical location)
searchGRASSX("/usr/bin")

# get all valid 'GRASS GIS' installation folders in the home directory
searchGRASSX("~/")

## End(Not run)
</code></pre>

<hr>
<h2 id='searchOTBW'>Search recursively for valid 'OTB' installation(s) on a 'Windows' OS</h2><span id='topic+searchOTBW'></span>

<h3>Description</h3>

<p>Search for valid 'OTB' installations on a 'Windows' OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchOTBW(DL = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchOTBW_+3A_dl">DL</code></td>
<td>
<p>drive letter default is &quot;C:&quot;</p>
</td></tr>
<tr><td><code id="searchOTBW_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'OTB' root folder(s) the version name(s) and the installation type(s).
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all valid OTB installation folders and params
searchOTBW()

## End(Not run)
</code></pre>

<hr>
<h2 id='searchOTBX'>Search recursively for valid 'OTB' installation(s) on a 'Linux' OS</h2><span id='topic+searchOTBX'></span>

<h3>Description</h3>

<p>Search for valid 'OTB' installations on a 'Linux' OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchOTBX(MP = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchOTBX_+3A_mp">MP</code></td>
<td>
<p>default mount point is the home directory &quot;~&quot; (as suggested by the OTB team)</p>
</td></tr>
<tr><td><code id="searchOTBX_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'OTB' root folder(s) the version name(s) and the installation type(s).
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all valid OTB installation folders and params
searchOTBX()

## End(Not run)
</code></pre>

<hr>
<h2 id='searchSAGAW'>Searches recursively for existing 'Windows' 'SAGA GIS' installation(s)</h2><span id='topic+searchSAGAW'></span>

<h3>Description</h3>

<p>Searches recursivley for existing 'SAGA GIS' installation(s) on a given 'Windows' drive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchSAGAW(DL = "C:", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchSAGAW_+3A_dl">DL</code></td>
<td>
<p>drive letter default is &quot;C:&quot;</p>
</td></tr>
<tr><td><code id="searchSAGAW_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe contasining the 'SAGA GIS' root folder(s), the version name(s) and the installation type(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### Examples how to use searchSAGAW 

# get all valid SAGA installation folders and params
searchSAGAW()

## End(Not run)
</code></pre>

<hr>
<h2 id='searchSAGAX'>Searches recursively for existing 'Windows' 'SAGA GIS' installation(s)</h2><span id='topic+searchSAGAX'></span>

<h3>Description</h3>

<p>Search for valid 'GRASS GIS' installations at a given 'Linux' mount point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchSAGAX(MP = "/usr", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchSAGAX_+3A_mp">MP</code></td>
<td>
<p>default mount point is <code>/usr</code></p>
</td></tr>
<tr><td><code id="searchSAGAX_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe contasining the 'SAGA GIS' root folder(s), the version name(s) and the installation type(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### Examples how to use searchSAGAX

# get all valid SAGA installation folders and params
searchSAGAX()

## End(Not run)
</code></pre>

<hr>
<h2 id='setenvGDAL'>Usually for internally usage, initializes and set up  access to the 'GDAL' command line interface</h2><span id='topic+setenvGDAL'></span>

<h3>Description</h3>

<p>Initializes and set up  access to the 'GDAL' command line interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setenvGDAL(bin_GDAL = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setenvGDAL_+3A_bin_gdal">bin_GDAL</code></td>
<td>
<p>string contains the path to the 'GDAL' binaries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds 'GDAL' pathes to the enviroment and creates the variable global string variable <code>gdalCmd</code>, that contains the path to the 'GDAL' binaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
## example for the most common default OSGeo4W64 installation of GDAL
setenvGDAL(bin_GDAL = "C:/OSGeo4W64/bin/",
          root_GDAL = "C:/OSGeo4W64")
}
</code></pre>

<hr>
<h2 id='setenvGRASSw'>Usually for internally usage, create valid 'GRASS GIS 7.xx' rsession environment settings according to the selected GRASS GIS 7.x and Windows Version</h2><span id='topic+setenvGRASSw'></span>

<h3>Description</h3>

<p>Initializes and set up  access to 'GRASS GIS 7.xx' via the <code>rgrass</code> wrapper or command line packages. Set and returns all necessary environment variables and additionally returns the GISBASE directory as string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setenvGRASSw(
  root_GRASS = NULL,
  grass_version = NULL,
  installation_type = NULL,
  jpgmem = 1e+06,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setenvGRASSw_+3A_root_grass">root_GRASS</code></td>
<td>
<p>grass root directory i.e. &quot;C:\OSGEO4~1&quot;,</p>
</td></tr>
<tr><td><code id="setenvGRASSw_+3A_grass_version">grass_version</code></td>
<td>
<p>grass version name i.e. &quot;grass-7.0.5&quot;</p>
</td></tr>
<tr><td><code id="setenvGRASSw_+3A_installation_type">installation_type</code></td>
<td>
<p>two options &quot;osgeo4w&quot; as installed by the 'OSGeo4W'-installer and &quot;NSIS&quot; that is typical for a stand_alone installtion of 'GRASS GIS'.</p>
</td></tr>
<tr><td><code id="setenvGRASSw_+3A_jpgmem">jpgmem</code></td>
<td>
<p>jpeg2000 memory allocation size. Default is 1000000</p>
</td></tr>
<tr><td><code id="setenvGRASSw_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set choosen'GRASS GIS' installation folders 
setenvGRASSw(root_GRASS = "C:\\PROGRA~1\\QGIS2~1.18",
             grass_version =  "grass-7.2.1",
             installation_type =  "osgeo4W")

## End(Not run)
</code></pre>

<hr>
<h2 id='setenvOTB'>Usually for internally usage, initializes and set up  access to the 'OTB' command line interface</h2><span id='topic+setenvOTB'></span>

<h3>Description</h3>

<p>Initializes and set up  access to the 'OTB' command line interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setenvOTB(bin_OTB = NULL, root_OTB = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setenvOTB_+3A_bin_otb">bin_OTB</code></td>
<td>
<p>string contains the path to the 'OTB' binaries</p>
</td></tr>
<tr><td><code id="setenvOTB_+3A_root_otb">root_OTB</code></td>
<td>
<p>string contains the full string to the root folder
containing the 'OTB' installation'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds 'OTB' pathes to the enviroment and creates the variable global string variable <code>otbCmd</code>, that contains the path to the 'OTB' binaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## example for the most common default OSGeo4W64 installation of OTB
setenvOTB(bin_OTB = "C:\\OSGeo4W64\\bin\\",
          root_OTB = "C:\\OSGeo4W64")

## End(Not run)
</code></pre>

<hr>
<h2 id='sf2gvec'>Write sf object directly to 'GRASS' vector utilising an existing or creating a new GRASS environment</h2><span id='topic+sf2gvec'></span>

<h3>Description</h3>

<p>Write sf object directly to 'GRASS' vector utilising an existing or creating a new GRASS environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf2gvec(x, epsg, obj_name, gisdbase, location, gisdbase_exist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf2gvec_+3A_x">x</code></td>
<td>
<p><code>sf</code> object corresponding to the settings of the corresponding GRASS container</p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_epsg">epsg</code></td>
<td>
<p>numeric epsg code</p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_obj_name">obj_name</code></td>
<td>
<p>name of GRASS layer</p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_gisdbase">gisdbase</code></td>
<td>
<p>GRASS gisDbase folder</p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_location">location</code></td>
<td>
<p>GRASS location name containing <code>obj_name)</code></p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_gisdbase_exist">gisdbase_exist</code></td>
<td>
<p>logical switch if the GRASS gisdbase folder exist default is TRUE</p>
</td></tr>
</table>


<h3>Note</h3>

<p>have a look at the <code>sf</code> capabilities to write direct to sqlite
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
## example 
require(sf)
require(sp)
require(link2GI)
data(meuse)
meuse_sf = st_as_sf(meuse, 
                    coords = c("x", "y"), 
                    crs = 28992, 
                    agr = "constant")


# write data to GRASS and create gisdbase
sf2gvec(x = meuse_sf,
        obj_name = "meuse_R-G",
        gisdbase = "~/temp3/",
        location = "project1")

# read from existing GRASS          
gvec2sf(x = meuse_sf,
        obj_name = "meuse_r_g",
        gisdbase = "~/temp3",       
        location = "project1")

}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
