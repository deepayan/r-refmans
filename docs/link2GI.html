<!DOCTYPE html><html><head><title>Help for package link2GI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {link2GI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add2Path'><p>Adds a defined variable and value to the global search path</p></a></li>
<li><a href='#addGitFolders'><p>Extent folder list by git repository</p></a></li>
<li><a href='#createFolders'><p>Compile folder list and create folders</p></a></li>
<li><a href='#createMeta'><p>Create list of metadata from project environment.</p></a></li>
<li><a href='#createScript'><p>Create files or scripts from templates</p></a></li>
<li><a href='#findGDAL'><p>Search recursivly existing 'GDAL binaries' installation(s) at a given drive/mountpoint</p></a></li>
<li><a href='#findGRASS'><p>Returns attributes of valid 'GRASS GIS' installation(s) on the system.</p></a></li>
<li><a href='#findOTB'><p>Search recursivly existing 'Orfeo Toolbox' installation(s) at a given drive/mountpoint</p></a></li>
<li><a href='#findSAGA'><p>Search recursively existing 'SAGA GIS' installation(s) at a given drive/mount point</p></a></li>
<li><a href='#getSpatialClass'><p>Checks if x is of type raster,terra,sf or sp</p></a></li>
<li><a href='#gvec2sf'><p>Converts from an existing 'GRASS' environment an arbitrary vector dataset  into a  sf object</p></a></li>
<li><a href='#initProj'><p>Simple creation and reproduction of an efficient project environment</p></a></li>
<li><a href='#linkAll'><p>convenient function to establish all link2GI links</p></a></li>
<li><a href='#linkGDAL'><p>Locate and set up 'GDAL' API bindings</p></a></li>
<li><a href='#linkGRASS'><p>Locate and set up 'GRASS' API bindings</p></a></li>
<li><a href='#linkOTB'><p>Locate and set up 'Orfeo ToolBox' API bindings</p></a></li>
<li><a href='#linkSAGA'><p>Identifies SAGA GIS Installations and returns linking Informations</p></a></li>
<li><a href='#loadEnvi'><p>Load data from rds format and associated yaml metadata file.</p></a></li>
<li><a href='#loadLibraries'><p>Load libraries and try to install missing ones</p></a></li>
<li><a href='#makeGlobalVariable'><p>Generates a variable with a certain value in the R environment</p></a></li>
<li><a href='#makGlobalVar'><p>Generates a variable with a certain value in the R environment</p></a></li>
<li><a href='#manuallyBuild'><p>Build package manually</p></a></li>
<li><a href='#paramGRASSw'><p>Usually for internally usage get 'GRASS GIS' and <code>rgrass</code> parameters on 'Windows' OS</p></a></li>
<li><a href='#paramGRASSx'><p>Usually for internally usage, get 'GRASS GIS' and <code>rgrass</code> parameters on 'Linux' OS</p></a></li>
<li><a href='#parseOTBAlgorithms'><p>Retrieve available OTB modules</p></a></li>
<li><a href='#parseOTBFunction'><p>Retrieve the argument list from a selected OTB function</p></a></li>
<li><a href='#runOTB'><p>Execute the OTB command via system call</p></a></li>
<li><a href='#saveEnvi'><p>Saves data in rds format and adds a yaml metadata file.</p></a></li>
<li><a href='#searchGDALW'><p>Search recursively for valid 'GDAL' installation(s) on a 'Windows' OS</p></a></li>
<li><a href='#searchGDALX'><p>Search recursively for valid 'GDAL' installation(s) on a 'X-based' OS</p></a></li>
<li><a href='#searchGRASSW'><p>Search recursivly valid 'GRASS GIS' installation(s) on a given 'Windows' drive</p></a></li>
<li><a href='#searchGRASSX'><p>Return attributes of valid 'GRASS GIS' installation(s) in 'Linux'</p></a></li>
<li><a href='#searchOTBW'><p>Search recursively for valid 'OTB' installation(s) on a 'Windows' OS</p></a></li>
<li><a href='#searchOTBX'><p>Search recursively for valid 'OTB' installation(s) on a 'Linux' OS</p></a></li>
<li><a href='#searchSAGAW'><p>Searches recursively for existing 'Windows' 'SAGA GIS' installation(s)</p></a></li>
<li><a href='#searchSAGAX'><p>Searches recursively for existing 'Windows' 'SAGA GIS' installation(s)</p></a></li>
<li><a href='#setenvGDAL'><p>Usually for internally usage, initializes and set up  access to the 'GDAL' command line interface</p></a></li>
<li><a href='#setenvGRASSw'><p>Usually for internally usage, create valid 'GRASS GIS 7.xx' rsession environment settings according to the selected GRASS GIS 7.x and Windows Version</p></a></li>
<li><a href='#setenvOTB'><p>Usually for internally usage, initializes and set up  access to the 'OTB' command line interface</p></a></li>
<li><a href='#setup_default'><p>Define working environment default settings</p></a></li>
<li><a href='#setupProj'><p>Setup project folder structure</p></a></li>
<li><a href='#sf2gvec'><p>Write sf object directly to 'GRASS' vector utilising an existing or creating a new GRASS environment</p></a></li>
<li><a href='#sourceFunctions'><p>Source functions from standard or given directory</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linking Geographic Information Systems, Remote Sensing and Other
Command Line Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-03</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Reudenbach &lt;reudenbach@uni-marburg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and tools for using open GIS and remote sensing command-line interfaces in a reproducible environment.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-spatial/link2GI/">https://github.com/r-spatial/link2GI/</a>,
<a href="https://r-spatial.github.io/link2GI/">https://r-spatial.github.io/link2GI/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/link2GI/issues/">https://github.com/r-spatial/link2GI/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>devtools, R.utils, roxygen2, sf (&ge; 0.9), brew, yaml, terra,
methods, utils, xml2, xfun, rstudioapi, git2r, renv</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, sp, rgrass, stars, curl, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-01 14:11:53 UTC; creu</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Reudenbach [cre, aut],
  Tim Appelhans [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-01 15:12:50 UTC</td>
</tr>
</table>
<hr>
<h2 id='add2Path'>Adds a defined variable and value to the global search path</h2><span id='topic+add2Path'></span>

<h3>Description</h3>

<p>Adds a variable to the global search path of the current environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add2Path(newPath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add2Path_+3A_newpath">newPath</code></td>
<td>
<p>the path that is added</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add path
add2Path('pathtosomewhere')

## End(Not run)
</code></pre>

<hr>
<h2 id='addGitFolders'>Extent folder list by git repository</h2><span id='topic+addGitFolders'></span>

<h3>Description</h3>

<p>Extent folder list by git repository and create subdirectories
according to default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addGitFolders(folders, git_repository = NULL, git_subfolders = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addGitFolders_+3A_folders">folders</code></td>
<td>
<p>list of subfolders within the project directory.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
addGitFolders(folders = c('data', 'data/tmp'), git_repository = 'myproject')

## End(Not run)

</code></pre>

<hr>
<h2 id='createFolders'>Compile folder list and create folders</h2><span id='topic+createFolders'></span><span id='topic+createFolder'></span>

<h3>Description</h3>

<p>Compile folder list with absolut paths and create folders if
necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createFolders(root_folder, folders, create_folders = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createFolders_+3A_root_folder">root_folder</code></td>
<td>
<p>root directory of the project.</p>
</td></tr>
<tr><td><code id="createFolders_+3A_folders">folders</code></td>
<td>
<p>list of subfolders within the project directory.</p>
</td></tr>
<tr><td><code id="createFolders_+3A_create_folders">create_folders</code></td>
<td>
<p>create folders if not existing already.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with folder paths and names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 createFolders(root_folder = tempdir(), folders = c('data/', 'data/tmp/'))

## End(Not run)
# Create folder list and set variable names pointing to the path values
</code></pre>

<hr>
<h2 id='createMeta'>Create list of metadata from project environment.</h2><span id='topic+createMeta'></span>

<h3>Description</h3>

<p>Create list of metadata from project environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMeta(prj_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createMeta_+3A_prj_name">prj_name</code></td>
<td>
<p>name of the project</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
createMeta(tempdir())

## End(Not run)

</code></pre>

<hr>
<h2 id='createScript'>Create files or scripts from templates</h2><span id='topic+createScript'></span>

<h3>Description</h3>

<p>Create files or scripts from brew templates supplied with the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createScript(
  new_file = file.path(tempdir(), "tmp.R"),
  template = c("script_function", "script_control"),
  notes = TRUE,
  template_path = system.file(sprintf("templates/%s.brew", template[1]), package =
    "link2GI")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createScript_+3A_new_file">new_file</code></td>
<td>
<p>name of the file to be created</p>
</td></tr>
<tr><td><code id="createScript_+3A_template">template</code></td>
<td>
<p>template to be used for the new file ('script_function', 'script_control')</p>
</td></tr>
<tr><td><code id="createScript_+3A_notes">notes</code></td>
<td>
<p>logical: include notes from the template in the file</p>
</td></tr>
<tr><td><code id="createScript_+3A_template_path">template_path</code></td>
<td>
<p>path to template to be used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
createScript()

## End(Not run)

</code></pre>

<hr>
<h2 id='findGDAL'>Search recursivly existing 'GDAL binaries' installation(s) at a given drive/mountpoint</h2><span id='topic+findGDAL'></span>

<h3>Description</h3>

<p>Provides an  list of valid 'GDAL' installation(s) 
on your 'Windows' system. There is a major difference between osgeo4W and 
stand_alone installations. The functions trys to find all valid 
installations by analysing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findGDAL(searchLocation = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findGDAL_+3A_searchlocation">searchLocation</code></td>
<td>
<p>drive letter to be searched, for Windows systems default
is <code>C:/</code>, for Linux systems default is <code>/usr/bin</code>.</p>
</td></tr>
<tr><td><code id="findGDAL_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GDAL' root folder(s),  and command line executable(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# find recursively all existing 'GDAL' installations folders starting 
# at the default search location
findGDAL()
}
</code></pre>

<hr>
<h2 id='findGRASS'>Returns attributes of valid 'GRASS GIS' installation(s) on the system.</h2><span id='topic+findGRASS'></span>

<h3>Description</h3>

<p>Retrieve a list of valid 'GRASS GIS' installation(s) on your system. There is a big difference between osgeo4W and stand_alone installations. The function tries to find all valid installations by analyzing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findGRASS(searchLocation = "default", ver_select = FALSE, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findGRASS_+3A_searchlocation">searchLocation</code></td>
<td>
<p>Location to search for the grass executable, i.e. one executable for each GRASS installation on the system. For Windows systems it is mandatory to include an uppercase Windows drive letter and a colon.
Default for Windows systems 
is <code>C:/</code>, for Linux systems the default is <code>/usr/bin</code>.</p>
</td></tr>
<tr><td><code id="findGRASS_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean, Default is FALSE. If there is more than one 'GRASS GIS' installation and <code>ver_select</code> = TRUE, the user can interactively select the preferred 'GRASS GIS' version.</p>
</td></tr>
<tr><td><code id="findGRASS_+3A_quiet">quiet</code></td>
<td>
<p>boolean, default is TRUE. switch to suppress console messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with the 'GRASS GIS' binary folder(s) (i.e. where the individual 
individual GRASS commands are installed), version name(s) and 
installation type code(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# find recursively all existing 'GRASS GIS' installation folders starting 
# at the default search location
findGRASS()

## End(Not run)
</code></pre>

<hr>
<h2 id='findOTB'>Search recursivly existing 'Orfeo Toolbox' installation(s) at a given drive/mountpoint</h2><span id='topic+findOTB'></span>

<h3>Description</h3>

<p>Provides an  list of valid 'OTB' installation(s) 
on your 'Windows' system. There is a major difference between osgeo4W and 
stand_alone installations. The functions trys to find all valid 
installations by analysing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findOTB(searchLocation = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findOTB_+3A_searchlocation">searchLocation</code></td>
<td>
<p>drive letter to be searched, for Windows systems default is <code>C:/</code>, for Linux systems default is <code>/usr/bin</code>.</p>
</td></tr>
<tr><td><code id="findOTB_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'OTB' root folder(s),  and command line executable(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# find recursively all existing 'Orfeo Toolbox' installations folders starting 
# at the default search location
findOTB()

## End(Not run)
</code></pre>

<hr>
<h2 id='findSAGA'>Search recursively existing 'SAGA GIS' installation(s) at a given drive/mount point</h2><span id='topic+findSAGA'></span>

<h3>Description</h3>

<p>Provides an  list of valid 'SAGA GIS' installation(s) 
on your 'Windows' system. There is a major difference between osgeo4W and 
stand_alone installations. The functions tries to find all valid 
installations by analyzing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSAGA(searchLocation = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSAGA_+3A_searchlocation">searchLocation</code></td>
<td>
<p>drive letter to be searched, for Windows systems default
is <code>C:/</code>, for Linux systems default is <code>/usr/bin</code>.</p>
</td></tr>
<tr><td><code id="findSAGA_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for suppressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'SAGA GIS' root folder(s), version name(s) and 
installation type code(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# find recursively all existing 'SAGA GIS' installation folders starting 
# at the default search location
findSAGA()

## End(Not run)
</code></pre>

<hr>
<h2 id='getSpatialClass'>Checks if x is of type raster,terra,sf or sp</h2><span id='topic+getSpatialClass'></span>

<h3>Description</h3>

<p>Checks if x is a raster or sp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpatialClass(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSpatialClass_+3A_obj">obj</code></td>
<td>
<p>R raster* or sp object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add path
getSpatialClass(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='gvec2sf'>Converts from an existing 'GRASS' environment an arbitrary vector dataset  into a  sf object</h2><span id='topic+gvec2sf'></span>

<h3>Description</h3>

<p>Converts from an existing 'GRASS' environment an arbitrary vector dataset  into a  sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvec2sf(x, obj_name, gisdbase, location, gisdbase_exist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gvec2sf_+3A_x">x</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> object corresponding to the settings of the corresponding GRASS container</p>
</td></tr>
<tr><td><code id="gvec2sf_+3A_obj_name">obj_name</code></td>
<td>
<p>name of GRASS layer</p>
</td></tr>
<tr><td><code id="gvec2sf_+3A_gisdbase">gisdbase</code></td>
<td>
<p>GRASS gisDbase folder</p>
</td></tr>
<tr><td><code id="gvec2sf_+3A_location">location</code></td>
<td>
<p>GRASS location name containing <code>obj_name)</code></p>
</td></tr>
<tr><td><code id="gvec2sf_+3A_gisdbase_exist">gisdbase_exist</code></td>
<td>
<p>logical switch if the GRASS gisdbase folder exist default is TRUE</p>
</td></tr>
</table>


<h3>Note</h3>

<p>have a look at the <code><a href="sf.html#topic+sf">sf</a></code> capabilities to read direct from sqlite
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
## example 
require(sf)
require(sp)
require(link2GI)
data(meuse)
meuse_sf = st_as_sf(meuse, 
                    coords = c('x', 'y'), 
                    crs = 28992, 
                    agr = 'constant')


# write data to GRASS and create gisdbase
sf2gvec(x = meuse_sf,
        obj_name = 'meuse_R-G',
        gisdbase = '~/temp3/',
        location = 'project1')

# read from existing GRASS          
gvec2sf(x = meuse_sf,
        obj_name = 'meuse_r_g',
        gisdbase = '~/temp3',       
        location = 'project1')

}
</code></pre>

<hr>
<h2 id='initProj'>Simple creation and reproduction of an efficient project environment</h2><span id='topic+initProj'></span>

<h3>Description</h3>

<p>Set up the project environment with a defined folder structure, an RStudio project, initial scripts and configuration files and optionally with Git and Renv support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initProj(
  root_folder = ".",
  folders = NULL,
  init_git = NULL,
  init_renv = NULL,
  code_subfolder = c("src", "src/functions", "src/configs"),
  global = FALSE,
  openproject = NULL,
  newsession = TRUE,
  standard_setup = "baseSpatial",
  loc_name = NULL,
  ymlFN = NULL,
  appendlibs = NULL,
  OpenFiles = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initProj_+3A_root_folder">root_folder</code></td>
<td>
<p>root directory of the project.</p>
</td></tr>
<tr><td><code id="initProj_+3A_folders">folders</code></td>
<td>
<p>list of sub folders within the project directory that will be created.</p>
</td></tr>
<tr><td><code id="initProj_+3A_init_git">init_git</code></td>
<td>
<p>logical: init git repository in the project directory.</p>
</td></tr>
<tr><td><code id="initProj_+3A_init_renv">init_renv</code></td>
<td>
<p>logical: init renv in the project directory.</p>
</td></tr>
<tr><td><code id="initProj_+3A_code_subfolder">code_subfolder</code></td>
<td>
<p>sub folders for scripts and functions within the project directory that will be created. The
folders src, src/functions and src/config are mandatory.</p>
</td></tr>
<tr><td><code id="initProj_+3A_global">global</code></td>
<td>
<p>logical: export path strings as global variables?</p>
</td></tr>
<tr><td><code id="initProj_+3A_openproject">openproject</code></td>
<td>
<p>default NULL if TRUE the project is opened in a new session</p>
</td></tr>
<tr><td><code id="initProj_+3A_newsession">newsession</code></td>
<td>
<p>open project in a new session? default is FALSE</p>
</td></tr>
<tr><td><code id="initProj_+3A_standard_setup">standard_setup</code></td>
<td>
<p>select one of the predefined settings c('base', 'baseSpatial', 'advancedSpatial'). 
In this case, only the name of the base folder is required, but individual additional 
folders can be specified under 'folders' 
name of the git repository must be supplied to the function.</p>
</td></tr>
<tr><td><code id="initProj_+3A_loc_name">loc_name</code></td>
<td>
<p>NULL by default, defines the research area of the analysis in the data folder as a subfolder and serves as a code tag</p>
</td></tr>
<tr><td><code id="initProj_+3A_ymlfn">ymlFN</code></td>
<td>
<p>filename for a yaml file containing a non standard_setup</p>
</td></tr>
<tr><td><code id="initProj_+3A_appendlibs">appendlibs</code></td>
<td>
<p>vector with the  names of libraries that are required for the initial project.
settings required for the project, such as additional libraries, optional settings, 
colour schemes, etc. Important: It should not be used to control the runtime
parameters of the scripts.  This file is not read in automatically, even if 
it is located in the 'fcts_folder' folder.</p>
</td></tr>
<tr><td><code id="initProj_+3A_openfiles">OpenFiles</code></td>
<td>
<p>default NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses [setupProj] for setting up the folders. Once the project is creaeted, manage the overall
configuration of the project by the 'src/functions/000_settings.R script'. It is sourced at the begining of the
template scripts that are created by default. Define additional constans, required libraries etc. in the
000_settings.R at any time. If additonal folders are required later, just add them manually. They will be parsed as
part of the 000_settings.R and added to a variable called dirs that allows easy acces to any of the folders. Use
this variable to load/save data to avoid any hard coded links in the scripts except the top-level root folder which
is defined once in the main control script located at src/main.R.
</p>


<h3>Value</h3>

<p>dirs, i.e. a list containing the project paths.
</p>


<h3>Note</h3>

<p>For yaml based setup you need to use one of the default configurations 
c('base', 'baseSpatial','advancedSpatial') or you provide a yaml file this 
MUST contain the standard_setup arguments, where <code> mysetup</code> is the yaml root, all other items are mandatory keywords that can be filled in as needed.  
</p>
<pre>
mysetup:
  dataFolder:  
  docsFolder:  
  tmpFolder:   
  init_git: true/false 
  init_renv: true/false 
  code_subfolder: ['src', 'src/functions' , 'src/config'] 
  global: true/false 
  libs: 
  create_folders: true/false
  files:
</pre>
<p>Alternatively you may set default_setup to NULL and provide the arguments via command line.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
root_folder &lt;- tempdir() # Mandatory, variable must be in the R environment.
dirs &lt;- initProj(root_folder = root_folder, standard_setup = 'baseSpatial')

## End(Not run)

</code></pre>

<hr>
<h2 id='linkAll'>convenient function to establish all link2GI links</h2><span id='topic+linkAll'></span>

<h3>Description</h3>

<p>brute force search, find and linkl of all link2GI link functions. This is helpfull if yor system is well setup and the standard linkage procedure will provide the correct linkages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkAll(
  links = NULL,
  simple = TRUE,
  linkItems = c("saga", "grass", "otb", "gdal"),
  sagaArgs = "default",
  grassArgs = "default",
  otbArgs = "default",
  gdalArgs = "default",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkAll_+3A_links">links</code></td>
<td>
<p>character. links</p>
</td></tr>
<tr><td><code id="linkAll_+3A_simple">simple</code></td>
<td>
<p>logical. true  make all</p>
</td></tr>
<tr><td><code id="linkAll_+3A_linkitems">linkItems</code></td>
<td>
<p>character. list of c('saga','grass','otb','gdal')</p>
</td></tr>
<tr><td><code id="linkAll_+3A_sagaargs">sagaArgs</code></td>
<td>
<p>character. full string of sagaArgs</p>
</td></tr>
<tr><td><code id="linkAll_+3A_grassargs">grassArgs</code></td>
<td>
<p>character. grassArgs full string of grassArgs</p>
</td></tr>
<tr><td><code id="linkAll_+3A_otbargs">otbArgs</code></td>
<td>
<p>character. full string of otbArgs</p>
</td></tr>
<tr><td><code id="linkAll_+3A_gdalargs">gdalArgs</code></td>
<td>
<p>character. full string of gdalArgs</p>
</td></tr>
<tr><td><code id="linkAll_+3A_quiet">quiet</code></td>
<td>
<p>supress all messages default is FALSE</p>
</td></tr>
</table>


<h3>Note</h3>

<p>You may also use the full list of arguments that is made available from the <code>link2GI</code> package, but it is strongly recommended in this case to use directly the single linkage functions from  <code>link2GI</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# required packages
require(link2GI)

# search, find and create the links to all supported  GI software
giLinks&lt;-linkAll()

# makes the GDAL linkage verbose
giLinks&lt;-linkAll(gdalArgs= 'quiet = TRUE') 


## End(Not run)
</code></pre>

<hr>
<h2 id='linkGDAL'>Locate and set up 'GDAL' API bindings</h2><span id='topic+linkGDAL'></span>

<h3>Description</h3>

<p>Locate and set up  <a href="https://gdal.org/">'GDAL - Geospatial Data Abstraction Librar'</a> API bindings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkGDAL(
  bin_GDAL = NULL,
  searchLocation = NULL,
  ver_select = FALSE,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkGDAL_+3A_bin_gdal">bin_GDAL</code></td>
<td>
<p>string contains path to where the gdal binaries are located</p>
</td></tr>
<tr><td><code id="linkGDAL_+3A_searchlocation">searchLocation</code></td>
<td>
<p>string hard drive letter default is <code>C:/</code></p>
</td></tr>
<tr><td><code id="linkGDAL_+3A_ver_select">ver_select</code></td>
<td>
<p>Boolean default is FALSE. If there is more than one 'GDAL' installation and <code>ver_select</code> = TRUE the user can select interactively the preferred 'GDAL' version</p>
</td></tr>
<tr><td><code id="linkGDAL_+3A_quiet">quiet</code></td>
<td>
<p>Boolean  switch for suppressing messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkGDAL_+3A_returnpaths">returnPaths</code></td>
<td>
<p>Boolean if set to FALSE the paths of the selected version are written 
to the PATH variable only, otherwise all paths and versions of the installed GRASS versions ae returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It looks for the <code>gdalinfo(.exe)</code> file. If the file is found in a <code>bin</code> folder it is assumed to be a valid 'GDAL' binary installation.
</p>
<p>if called without any parameter <code>linkGDAL()</code> it performs a full search over the hard drive <code>C:</code>. If it finds one or more 'GDAL' binaries it will take the first hit. You have to set <code>ver_select = TRUE</code> for an interactive selection of the preferred version.
</p>


<h3>Value</h3>

<p>add gdal paths to the environment and creates global variables path_GDAL
</p>


<h3>Note</h3>

<p>You may also set the path manually. Using a 'OSGeo4W64' <a href="https://trac.osgeo.org/osgeo4w/">https://trac.osgeo.org/osgeo4w/</a> installation it is typically <code>C:/OSGeo4W64/bin/</code>
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# call if you do not have any idea if and where GDAL is installed
gdal&lt;-linkGDAL()
if (gdal$exist) {
# call it for a default OSGeo4W installation of the GDAL
print(gdal)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='linkGRASS'>Locate and set up 'GRASS' API bindings</h2><span id='topic+linkGRASS'></span><span id='topic+linkGRASS7'></span>

<h3>Description</h3>

<p>Initializes the session environment and the system paths for an easy access to
<a href="https://grass.osgeo.org/">'GRASS GIS 7.x/8.x'</a>.  The correct setup of the spatial and
projection parameters is automatically performed by using either an existing and valid 
<code>raster</code>, <code>terra</code>, <code>sp</code> or <code>sf</code> object, 
or manually by providing a list containing the minimum parameters needed.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkGRASS(
  x = NULL,
  epsg = NULL,
  default_GRASS = NULL,
  search_path = NULL,
  ver_select = FALSE,
  gisdbase_exist = FALSE,
  gisdbase = NULL,
  use_home = FALSE,
  location = NULL,
  spatial_params = NULL,
  resolution = NULL,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkGRASS_+3A_x">x</code></td>
<td>
<p>raster/terra or sf/sp object</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_epsg">epsg</code></td>
<td>
<p>manual epsg override</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_default_grass">default_GRASS</code></td>
<td>
<p>default is <code>NULL</code> If is <code>NULL</code> an automatic search for all installed versions is performed. 
If you provide a valid list the corresponding version is initialized. An example for OSGeo4W64 is:
<code>c('C:/OSGeo4W64','grass-7.0.5','osgeo4w')</code></p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_search_path">search_path</code></td>
<td>
<p>Path or mount point to search for.</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_ver_select">ver_select</code></td>
<td>
<p>Boolean if TRUE you may choose interactively the binary version (if found  more than one),  by default FALSE</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_gisdbase_exist">gisdbase_exist</code></td>
<td>
<p>default is FALSE if set to TRUE the arguments gisdbase and location are expected to be an existing GRASS gisdbase</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_gisdbase">gisdbase</code></td>
<td>
<p>default is <code>NULL</code>, invoke <code>tempdir()</code> to the 'GRASS' database. Alternatively you can provide a individual path.</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_use_home">use_home</code></td>
<td>
<p>default is <code>FALSE</code>, set the GISRC path to tempdir(), if TRUE the HOME or USERPROFILE setting is used for writing the GISRC file</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_location">location</code></td>
<td>
<p>default is <code>NULL</code>, invoke <code>basename(tempfile())</code> for defining the 'GRASS' location. Alternatively you can provide a individual path.</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_spatial_params">spatial_params</code></td>
<td>
<p>default is <code>NULL</code>. Instead of a spatial object you may provide the geometry as a list. E.g. c(xmin,ymin,xmax,ymax,proj4_string)</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_resolution">resolution</code></td>
<td>
<p>resolution in map units for the GRASS raster cells</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_quiet">quiet</code></td>
<td>
<p>Boolean  switch for suppressing console messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkGRASS_+3A_returnpaths">returnPaths</code></td>
<td>
<p>Boolean if set to FALSE the paths of the selected version are written 
to the PATH variable only, otherwise all paths and versions of the installed GRASS versions ae returned.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>GRASS GIS is excellently supported by the <code>rgrass</code> wrapper package. Nevertheless, 'GRASS GIS' is known for its
its high demands on the correct spatial and reference setup  and environment requirements. This becomes even worse on 'Windows 
platforms or when there are several alternative 'GRASS GIS' installations available.
If you know how to use the <code>rgrass</code> package setup function <code>rgrass::initGRASS</code> works fine on Linux. 
This is also true for known configurations under the 'Windows' operating system. 
However, on university labs or corporate machines with limited privileges and/or different releases
such as the <a href="https://trac.osgeo.org/osgeo4w/">'OSGeo4W'</a> distribution and the  <a href="https://grass.osgeo.org/download/windows/">'GRASS' stand-alone</a> installation, 
or different software releases (e.g. 'GRASS 7.0.5 and GRASS 8.1.0), it often becomes inconvenient or even 
to get the correct links. <br /> The function <code>linkGRASS</code> tries to find all valid 'GRASS GIS' binaries by #' analyzing the startup script files.
GRASS GIS' startup script files. After identifying the 'GRASS GIS' binaries, all #' necessary system variables and settings are
system variables and settings are generated and passed to a temporary R environment.
The concept is simple, but helpful for everyday use. You need to either 
provide a <code>raster</code> or <code>sp</code> <code>sf</code> spatial object
that has the correct spatial and projection properties, or you can link directly to an existing 'GRASS' gisdbase and mapset. 
If you choose a spatial object to initialize a correct 'GRASS' mapset, it will be used to create either a temporary or permanent mapset. 
<a href="https://CRAN.R-project.org/package=rgrass">rgrass</a> environment with the correct 'GRASS' structure.<br /><br />
The most time consuming part on Windows systems is the search process. This can easily take 10 minutes or more. 
To speed up this process, you can also provide a correct parameter set. The best way to do this is to manually call <code>searchGRASSW</code> or for 'Linux' <code>searchGRASSX</code>. 
and call <code>linkGRASS</code> with the version arguments of your choice. linkGRASS will initialize the use of GRASS.
If you have more than one valid installation and call <code>linkGRASS()</code> without arguments, you will be asked to select one.
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
library(link2GI)
require(sf)

# get  data                         
nc = st_read(system.file('shape/nc.shp', package='sf'))
# Automatic linking of GRASS binaries using the nc data object for spatial referencing
# This is the best practice linking procedure for on-the-fly jobs.
# NOTE: If more than one GRASS installation is found, you will have to select one. 
grass = linkGRASS(nc)

# Select the GRASS installation (if more than one)
linkGRASS(nc, ver_select = TRUE)

# Select the GRASS installation and define the search location
linkGRASS(nc, ver_select = TRUE, search_path = '~/')

# Set up GRASS manually with spatial parameters of the nc data
epsg = 28992
proj4_string &lt;- sp::CRS(paste0('+init=epsg:',epsg))

linkGRASS(spatial_params = c(178605,329714,181390,333611,proj4_string@projargs),epsg=epsg)


# create some temporary project folders for a permanent gisdbase
root_folder = tempdir()
grass_path = link2GI::createFolder(root_folder = root_folder,
                         folders = c('project1/'))
if (grass$exist){
# CREATE and link to a permanent GRASS folder at 'root_folder', location named 'project1' 
linkGRASS(nc, gisdbase = root_folder, location = 'project1')   

# ONLY LINK to a permanent GRASS folder in 'root_folder', location named 'project1' 
linkGRASS(gisdbase = root_folder, location = 'project1', gisdbase_exist = TRUE )   

# Manual creation of a GRASS gisdbase with the spatial parameters of the NC data. 
# additional use of a permanent directory 'root_folder' and the location 'nc_spatial_params'.
epsg = 4267
proj4_string = sp::CRS(paste0('+init=epsg:',epsg))
linkGRASS(gisdbase = root_folder,
           location = 'nc_spatial_params',
           spatial_params = c(-84.32385, 33.88199,-75.45698,36.58965,proj4_string),epsg = epsg)
}
}

</code></pre>

<hr>
<h2 id='linkOTB'>Locate and set up 'Orfeo ToolBox' API bindings</h2><span id='topic+linkOTB'></span>

<h3>Description</h3>

<p>Locate and set up  <a href="https://www.orfeo-toolbox.org/">'Orfeo ToolBox'</a> API bindings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkOTB(
  bin_OTB = NULL,
  root_OTB = NULL,
  type_OTB = NULL,
  searchLocation = NULL,
  ver_select = FALSE,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkOTB_+3A_bin_otb">bin_OTB</code></td>
<td>
<p>string contains path to where the otb binaries are located</p>
</td></tr>
<tr><td><code id="linkOTB_+3A_root_otb">root_OTB</code></td>
<td>
<p>string provides the root folder of the <code>bin_OTB</code></p>
</td></tr>
<tr><td><code id="linkOTB_+3A_type_otb">type_OTB</code></td>
<td>
<p>string</p>
</td></tr>
<tr><td><code id="linkOTB_+3A_searchlocation">searchLocation</code></td>
<td>
<p>string hard drive letter (Windows) or mounting point (Linux) default for Windows is <code>C:</code>, default for Linux is <code>~</code></p>
</td></tr>
<tr><td><code id="linkOTB_+3A_ver_select">ver_select</code></td>
<td>
<p>Boolean, default is FALSE. If there is more than one 'OTB' installation and <code>ver_select</code> = TRUE the user can interactively select the preferred 'OTB' version, conversely if FALSE the latest version is automatically selected.</p>
</td></tr>
<tr><td><code id="linkOTB_+3A_quiet">quiet</code></td>
<td>
<p>Boolean  switch for suppressing messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkOTB_+3A_returnpaths">returnPaths</code></td>
<td>
<p>Boolean, if set to FALSE the paths of the selected version are written. 
in the PATH variable only, otherwise all paths and versions of the installed OTB versions are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It looks for the <code>otb_cli.bat</code> file. If the file is found in a <code>bin</code> folder it is assumed to be a valid 'OTB' binary installation.
</p>
<p>if called without any parameter <code>linkOTB()</code> it performs a full search over the hard drive <code>C:</code>. If it finds one or more 'OTB' binaries it will take the first hit. You have to set <code>ver_select = TRUE</code> for an interactive selection of the preferred version.
</p>


<h3>Value</h3>

<p>add otb paths to the environment and creates global variables path_OTB
</p>


<h3>Note</h3>

<p>You may also set the path manually. Using a 'OSGeo4W64' <a href="https://trac.osgeo.org/osgeo4w/">https://trac.osgeo.org/osgeo4w/</a> installation it is typically <code>C:/OSGeo4W64/bin/</code>
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# call if you do not have any idea if and where OTB is installed
otb&lt;-linkOTB()
if (otb$exist) {
# call it for a default OSGeo4W installation of the OTB
print(otb)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='linkSAGA'>Identifies SAGA GIS Installations and returns linking Informations</h2><span id='topic+linkSAGA'></span>

<h3>Description</h3>

<p>Finds the existing <a href="https://saga-gis.sourceforge.io/">SAGA GIS</a> installation(s), 
generates and sets the necessary path and system variables for a seamless use of the command 
line calls of the 'SAGA GIS' CLI API, setup valid system variables for calling a default 
<code>rsaga.env</code> and by this makes available the <code>RSAGA</code> wrapper functions.<br />
All existing installation(s) means that it looks for the <code>saga_cmd</code> or <code>saga_cmd.exe</code> 
executables. If the file is found it is assumed to be a valid 'SAGA GIS' installation. If it is called without any argument the most recent (i.e. highest) SAGA GIS version will be linked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkSAGA(
  default_SAGA = NULL,
  searchLocation = "default",
  ver_select = FALSE,
  quiet = TRUE,
  returnPaths = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkSAGA_+3A_default_saga">default_SAGA</code></td>
<td>
<p>string contains path to <code>RSAGA</code> binaries</p>
</td></tr>
<tr><td><code id="linkSAGA_+3A_searchlocation">searchLocation</code></td>
<td>
<p>drive letter to be searched, for Windows systems default
is <code>C:</code>, for Linux systems default is <code>/usr/bin</code>.</p>
</td></tr>
<tr><td><code id="linkSAGA_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean default is FALSE. If there is more than one 'SAGA GIS' installation and <code>ver_select</code> = TRUE the user can select interactively the preferred 'SAGA GIS' version</p>
</td></tr>
<tr><td><code id="linkSAGA_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
<tr><td><code id="linkSAGA_+3A_returnpaths">returnPaths</code></td>
<td>
<p>boolean if set to FALSE the paths of the selected version are written 
to the PATH variable only, otherwise all paths and versions of the installed SAGA versions ae returned.#'@details If called without any parameter <code>linkSAGA()</code> it performs a full search over <code>C:</code>. If it finds one or more 'SAGA GIS' binaries it will take the first hit. You have to set <code>ver_select = TRUE</code> for an interactive selection of the preferred version. Additionally the selected SAGA paths are added to the environment and the global variables <code>sagaPath</code>, <code>sagaModPath</code> and <code>sagaCmd</code> will be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the selected <code>RSAGA</code> path variables <code>$sagaPath</code>,<code>$sagaModPath</code>,<code>$sagaCmd</code> and potentially other installations <code>$installed</code>
</p>


<h3>Note</h3>

<p>The 'SAGA GIS' wrapper <a href="https://CRAN.R-project.org/package=RSAGA">RSAGA</a> 
package was updated several times however it covers currently (May 2014) only 'SAGA GIS' 
versions from  2.3.1 LTS - 8.4.1 The fast evolution of 'SAGA GIS' makes it highly impracticable
to keep the wrapper adaptions in line (currently 9.4). <code>RSAGA</code> will meet all linking needs perfectly if 
you use 'SAGA GIS' versions from 2.0.4 - 7.5.0. <br />  However you must call <code>rsaga.env</code> using the <code>rsaga.env(modules = saga$sagaModPath)</code> assuming that <code>saga</code> contains the returnPaths of <code>linkSAGA</code> 
In addition the very promising  <a href="https://github.com/stevenpawley/Rsagacmd">Rsagacmd</a> wrapper package is providing a new list oriented wrapping tool.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# call if you do not have any idea if and where SAGA GIS is installed
# it will return a list with the selected and available SAGA installations
# it prepares the system for running the selected SAGA version via RSAGA or CLI
linkSAGA()

# overriding the default environment of rsaga.env call 

saga&lt;-linkSAGA()
if (saga$exist) {
require(RSAGA)
RSAGA::rsaga.env(path = saga$installed$binDir[1],modules = saga$installed$moduleDir[1])
}

## End(Not run)
</code></pre>

<hr>
<h2 id='loadEnvi'>Load data from rds format and associated yaml metadata file.</h2><span id='topic+loadEnvi'></span>

<h3>Description</h3>

<p>Load data from rds format and associated yaml metadata file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadEnvi(file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadEnvi_+3A_file_path">file_path</code></td>
<td>
<p>name and path of the rds file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2 containing data and metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
a &lt;- 1
meta &lt;- list(a = 'a is a variable')
saveEnvi(a, file.path(tempdir(), 'test.rds'), meta)
b &lt;- loadEnvi(file.path(tempdir(), 'test.rds'))

## End(Not run)

</code></pre>

<hr>
<h2 id='loadLibraries'>Load libraries and try to install missing ones</h2><span id='topic+loadLibraries'></span>

<h3>Description</h3>

<p>Load libaries in the R environment and try to install misssing
ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadLibraries(libs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadLibraries_+3A_libs">libs</code></td>
<td>
<p>vector with the  names of libraries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List indicating which library has been loaded successfully.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# loadLibraries(libs = C('link2GI'))

## End(Not run)
</code></pre>

<hr>
<h2 id='makeGlobalVariable'>Generates a variable with a certain value in the R environment</h2><span id='topic+makeGlobalVariable'></span>

<h3>Description</h3>

<p>Generates a variable with a certain value in the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGlobalVariable(names, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGlobalVariable_+3A_names">names</code></td>
<td>
<p>vector with the  names of the variable(s)</p>
</td></tr>
<tr><td><code id="makeGlobalVariable_+3A_values">values</code></td>
<td>
<p>vector with values of the variable(s)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# creates the global variable \code{path_data} with the value \code{~/data}
makeGlobalVariable(names = 'path_data', values = '~/data')

## End(Not run)

</code></pre>

<hr>
<h2 id='makGlobalVar'>Generates a variable with a certain value in the R environment</h2><span id='topic+makGlobalVar'></span>

<h3>Description</h3>

<p>Generates a variable with a certain value in the R environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makGlobalVar(name, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makGlobalVar_+3A_name">name</code></td>
<td>
<p>character string name of the variable</p>
</td></tr>
<tr><td><code id="makGlobalVar_+3A_value">value</code></td>
<td>
<p>character string value of the variable</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# creates the global var \code{pathToData} with the value \code{~/home/data}
makGlobalVar('pathToData','~/home/data') 


## End(Not run)

</code></pre>

<hr>
<h2 id='manuallyBuild'>Build package manually</h2><span id='topic+manuallyBuild'></span>

<h3>Description</h3>

<p>This function was specifically designed to build a package from local source 
files manually, i.e., without using the package building functionality 
offered e.g. by RStudio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manuallyBuild(dsn = getwd(), pkgDir = "H:/Dokumente", document = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manuallyBuild_+3A_dsn">dsn</code></td>
<td>
<p>'character'. Target folder containing source files; defaults to 
the current working directory.</p>
</td></tr>
<tr><td><code id="manuallyBuild_+3A_pkgdir">pkgDir</code></td>
<td>
<p>'character'. Target folder containing the result ing package of the invoked build process. According to Marburg University pools the default is set to pkgDir='H:/Dokumente'. If you want to use it in a different setting you may set pkgDir to whatever you want.</p>
</td></tr>
<tr><td><code id="manuallyBuild_+3A_document">document</code></td>
<td>
<p>'logical'. Determines whether or not to invoke 
<code><a href="roxygen2.html#topic+roxygenize">roxygenize</a></code> with default roclets for documentation purposes.</p>
</td></tr>
<tr><td><code id="manuallyBuild_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="devtools.html#topic+build">build</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE the default setting are focussing HRZ environment at Marburg University
</p>


<h3>Author(s)</h3>

<p>Florian Detsch, Chris Reudenbach
</p>


<h3>See Also</h3>

<p><code><a href="roxygen2.html#topic+roxygenize">roxygenize</a></code>, <code><a href="devtools.html#topic+build">build</a></code>,<code><a href="utils.html#topic+install.packages">install.packages</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## when in a package directory, e.g. '~/link2GI' 
manuallyBuild()

## End(Not run)


</code></pre>

<hr>
<h2 id='paramGRASSw'>Usually for internally usage get 'GRASS GIS' and <code>rgrass</code> parameters on 'Windows' OS</h2><span id='topic+paramGRASSw'></span>

<h3>Description</h3>

<p>Initialize the enviroment variables on a 'Windows' OS for using 
'GRASS GIS' via <code>rgrass</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramGRASSw(
  set_default_GRASS = NULL,
  DL = "C:/",
  ver_select = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramGRASSw_+3A_set_default_grass">set_default_GRASS</code></td>
<td>
<p>default = NULL forces a full search for 'GRASS GIS' binaries. You may
alternatively provide a vector containing paths and keywords. c('C:/OSGeo4W64','grass-7.0.5','osgeo4w') is valid for a typical osgeo4w installation.</p>
</td></tr>
<tr><td><code id="paramGRASSw_+3A_dl">DL</code></td>
<td>
<p>character search location default = <code>C:</code></p>
</td></tr>
<tr><td><code id="paramGRASSw_+3A_ver_select">ver_select</code></td>
<td>
<p>boolean default is FALSE. If there is more than one 'SAGA GIS' installation and <code>ver_select</code> = TRUE the user can select interactively the preferred 'SAGA GIS' version</p>
</td></tr>
<tr><td><code id="paramGRASSw_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concept is very straightforward but for an all days usage pretty
helpful. You need to provide a <code>terra</code> or a <code>sf</code> object. The derived properties are used to initialize a temporary but static
<a href="https://CRAN.R-project.org/package=rgrass">rgrass</a> environment. During the rsession you will have full access to
GRASS both via the wrapper package as well as the command line. paramGRASSw initializes the usage of GRASS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# automatic retrieval of valid 'GRASS GIS' environment settings 
# if more than one is found the user has to choose.
paramGRASSw()

# typical OSGeo4W64 installation
paramGRASSw(c('C:/OSGeo4','grass7.8','osgeo4W'))
}
</code></pre>

<hr>
<h2 id='paramGRASSx'>Usually for internally usage, get 'GRASS GIS' and <code>rgrass</code> parameters on 'Linux' OS</h2><span id='topic+paramGRASSx'></span>

<h3>Description</h3>

<p>Initialize and set up <code>rgrass</code>  for 'Linux'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramGRASSx(
  set_default_GRASS = NULL,
  MP = "/usr/bin",
  ver_select = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramGRASSx_+3A_set_default_grass">set_default_GRASS</code></td>
<td>
<p>default is NULL. will force a search for 'GRASS GIS' You may provide a valid combination as 
c('/usr/lib/grass74','7.4.1','grass74')</p>
</td></tr>
<tr><td><code id="paramGRASSx_+3A_mp">MP</code></td>
<td>
<p>default is '/usr/bin'. mount point to be searched.</p>
</td></tr>
<tr><td><code id="paramGRASSx_+3A_ver_select">ver_select</code></td>
<td>
<p>if TRUE you must interactively select between alternative installations</p>
</td></tr>
<tr><td><code id="paramGRASSx_+3A_quiet">quiet</code></td>
<td>
<p>boolean, default is TRUE.  switch for suppressing console messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During the rsession you will have full access to GRASS7 GIS via the <code>rgrass</code> wrapper. Additionally you may use also use the API calls of GRASS via the command line.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# automatic retrieval of the GRASS environment settings
paramGRASSx()


# typical stand_alone installation
paramGRASSx('/usr/bin/grass72')

# typical user defined installation (compiled sources)
paramGRASSx('/usr/local/bin/grass72')
}
</code></pre>

<hr>
<h2 id='parseOTBAlgorithms'>Retrieve available OTB modules</h2><span id='topic+parseOTBAlgorithms'></span>

<h3>Description</h3>

<p>Read in the selected OTB module folder and create a list of available functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseOTBAlgorithms(gili = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseOTBAlgorithms_+3A_gili">gili</code></td>
<td>
<p>optional list of available 'OTB' installations, if not specified, 
'linkOTB()' is called to automatically try to find a valid OTB installation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## link to the OTB binaries
otblink&lt;-link2GI::linkOTB()

 if (otblink$exist) {

 ## parse all modules
 moduleList&lt;-parseOTBAlgorithms(gili = otblink)

 ## print the list
 print(moduleList)
 
 } 

## End(Not run)

</code></pre>

<hr>
<h2 id='parseOTBFunction'>Retrieve the argument list from a selected OTB function</h2><span id='topic+parseOTBFunction'></span>

<h3>Description</h3>

<p>retrieve the selected function and returns a full argument list with the default settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseOTBFunction(algo = NULL, gili = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseOTBFunction_+3A_algo">algo</code></td>
<td>
<p>either the number or the plain name of the 'OTB' algorithm that is wanted. Note the correct (of current/selected version) information is provided by 'parseOTBAlgorithms()'</p>
</td></tr>
<tr><td><code id="parseOTBFunction_+3A_gili">gili</code></td>
<td>
<p>optional list of available 'OTB' installations, if not specified, 
'linkOTB()' is called to automatically try to find a valid OTB installation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
otblink&lt;-link2GI::linkOTB()
if (otblink$exist) {

## parse all modules
algos&lt;-parseOTBAlgorithms(gili = otblink)


## take edge detection
cmdList&lt;-parseOTBFunction(algo = algos[27],gili = otblink)
## print the current command
print(cmdList)
}

## End(Not run)
##+##
</code></pre>

<hr>
<h2 id='runOTB'>Execute the OTB command via system call</h2><span id='topic+runOTB'></span>

<h3>Description</h3>

<p>Wrapper function that inserts the OTB command list into a system call compatible string and executes that command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runOTB(
  otbCmdList = NULL,
  gili = NULL,
  retRaster = TRUE,
  retCommand = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runOTB_+3A_otbcmdlist">otbCmdList</code></td>
<td>
<p>the correctly populated OTB algorithm parameter list</p>
</td></tr>
<tr><td><code id="runOTB_+3A_gili">gili</code></td>
<td>
<p>optional list of available 'OTB' installations, if not specified, 
'linkOTB()' is called to automatically try to find a valid OTB installation</p>
</td></tr>
<tr><td><code id="runOTB_+3A_retraster">retRaster</code></td>
<td>
<p>boolean if TRUE a raster stack is returned default is FALSE</p>
</td></tr>
<tr><td><code id="runOTB_+3A_retcommand">retCommand</code></td>
<td>
<p>boolean if TRUE only the OTB API command is returned default is FALSE</p>
</td></tr>
<tr><td><code id="runOTB_+3A_quiet">quiet</code></td>
<td>
<p>boolean  if TRUE suppressing messages default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' Please NOTE: You must check the help to identify the correct input file argument ($input_in or $input_il).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(link2GI)
require(terra)
require(listviewer)

## link to OTB
otblink&lt;-link2GI::linkOTB()

if (otblink$exist) {
 root_folder&lt;-tempdir()
 fn &lt;- system.file('ex/elev.tif', package = 'terra')

## for an image output example we use the Statistic Extraction, 
algoKeyword&lt;- 'LocalStatisticExtraction'

## extract the command list for the choosen algorithm 
cmd&lt;-parseOTBFunction(algo = algoKeyword, gili = otblink)

## Please NOTE:
## You must check the help to identify the correct argument codewort ($input_in or $input_il)
listviewer::jsonedit(cmd$help)

## define the mandatory arguments all other will be default
cmd$input_in  &lt;- fn
cmd$out &lt;- file.path(tempdir(),'test_otb_stat.tif')
cmd$radius &lt;- 7

## run algorithm
retStack&lt;-runOTB(cmd,gili = otblink)

## plot image
terra::plot(retStack)

## for a data output example we use the 

algoKeyword&lt;- 'ComputeImagesStatistics'

## extract the command list for the chosen algorithm 
cmd&lt;-parseOTBFunction(algo = algoKeyword, gili = otblink)

## get help using the convenient listviewer
listviewer::jsonedit(cmd$help)

## define the mandatory arguments all other will be default
cmd$input_il  &lt;- file.path(tempdir(),'test.tif')
cmd$ram &lt;- 4096
cmd$out.xml &lt;- file.path(tempdir(),'test_otb_stat.xml')
cmd$progress &lt;- 1

## run algorithm
ret &lt;- runOTB(cmd,gili = otblink, quiet = F)

## as vector
print(ret)

## as xml
XML::xmlParse(cmd$out)
 
}

## End(Not run)
</code></pre>

<hr>
<h2 id='saveEnvi'>Saves data in rds format and adds a yaml metadata file.</h2><span id='topic+saveEnvi'></span>

<h3>Description</h3>

<p>Saves data in rds format and saves metadata in a corresponding yaml file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveEnvi(variable, file_path, meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveEnvi_+3A_variable">variable</code></td>
<td>
<p>name of the data variable to be saved.</p>
</td></tr>
<tr><td><code id="saveEnvi_+3A_file_path">file_path</code></td>
<td>
<p>name and path of the rds file.</p>
</td></tr>
<tr><td><code id="saveEnvi_+3A_meta">meta</code></td>
<td>
<p>name of the metadata list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
a &lt;- 1
meta &lt;- list(a = 'a is a variable')
saveEnvi(a, file.path(tempdir(), 'test.rds'), meta)

## End(Not run)

</code></pre>

<hr>
<h2 id='searchGDALW'>Search recursively for valid 'GDAL' installation(s) on a 'Windows' OS</h2><span id='topic+searchGDALW'></span>

<h3>Description</h3>

<p>Search for valid 'GDAL' installations on a 'Windows' OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGDALW(DL = "C:/", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGDALW_+3A_dl">DL</code></td>
<td>
<p>drive letter default is 'C:/'</p>
</td></tr>
<tr><td><code id="searchGDALW_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GDAL' root folder(s) the version name(s) and the installation type(s).
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# get all valid GDAL installation folders and params
searchGDALW()
}
</code></pre>

<hr>
<h2 id='searchGDALX'>Search recursively for valid 'GDAL' installation(s) on a 'X-based' OS</h2><span id='topic+searchGDALX'></span>

<h3>Description</h3>

<p>Search for valid 'GDAL' installations on a 'X-based' OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGDALX(MP = "/usr/bin", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGDALX_+3A_mp">MP</code></td>
<td>
<p>drive letter default is '/usr/bin'</p>
</td></tr>
<tr><td><code id="searchGDALX_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GDAL' root folder(s) the version name(s) and the installation type(s).
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
# get all valid GDAL installation folders and params
searchGDALX()
}
</code></pre>

<hr>
<h2 id='searchGRASSW'>Search recursivly valid 'GRASS GIS' installation(s) on a given 'Windows' drive</h2><span id='topic+searchGRASSW'></span>

<h3>Description</h3>

<p>Provides an  list of valid 'GRASS GIS' installation(s) on your 'Windows' system. There is a major difference between osgeo4W and stand_alone installations. The functions trys to find all valid installations by analysing the calling batch scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGRASSW(DL = "C:/", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGRASSW_+3A_dl">DL</code></td>
<td>
<p>drive letter to be searched, default is <code>C:/</code></p>
</td></tr>
<tr><td><code id="searchGRASSW_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUEs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'GRASS GIS' root folder(s), version name(s) and installation type code(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all valid 'GRASS GIS' installation folders and params at 'C:/'
searchGRASSW()

## End(Not run)
</code></pre>

<hr>
<h2 id='searchGRASSX'>Return attributes of valid 'GRASS GIS' installation(s) in 'Linux'</h2><span id='topic+searchGRASSX'></span>

<h3>Description</h3>

<p>Searches recursively for valid 'GRASS GIS' installations at a given 'Linux' mount point.
Returns attributes for each installation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGRASSX(MP = "/usr/bin", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGRASSX_+3A_mp">MP</code></td>
<td>
<p>default is /usr. This is the directory from which the grass executable file is searched, i.e. one executable for each GRASS installation on the system.</p>
</td></tr>
<tr><td><code id="searchGRASSX_+3A_quiet">quiet</code></td>
<td>
<p>boolean.  switch for suppressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing 'GRASS GIS' binary folder(s) (i.e. where the individual GRASS commands are installed), version name(s) and installation type code(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all valid 'GRASS GIS' installation folders in the /usr/bin directory (typical location)
searchGRASSX('/usr/bin')

# get all valid 'GRASS GIS' installation folders in the home directory
searchGRASSX('~/')

## End(Not run)
</code></pre>

<hr>
<h2 id='searchOTBW'>Search recursively for valid 'OTB' installation(s) on a 'Windows' OS</h2><span id='topic+searchOTBW'></span>

<h3>Description</h3>

<p>Search for valid 'OTB' installations on a 'Windows' OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchOTBW(DL = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchOTBW_+3A_dl">DL</code></td>
<td>
<p>drive letter default is <code>C:/</code></p>
</td></tr>
<tr><td><code id="searchOTBW_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'OTB' root folder(s) the version name(s) and the installation type(s).
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all valid OTB installation folders and params
searchOTBW()

## End(Not run)
</code></pre>

<hr>
<h2 id='searchOTBX'>Search recursively for valid 'OTB' installation(s) on a 'Linux' OS</h2><span id='topic+searchOTBX'></span>

<h3>Description</h3>

<p>Search for valid 'OTB' installations on a 'Linux' OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchOTBX(MP = "default", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchOTBX_+3A_mp">MP</code></td>
<td>
<p>default mount point is the home directory '~' (as suggested by the OTB team)</p>
</td></tr>
<tr><td><code id="searchOTBX_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for supressing messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the 'OTB' root folder(s) the version name(s) and the installation type(s).
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all valid OTB installation folders and params
searchOTBX()

## End(Not run)
</code></pre>

<hr>
<h2 id='searchSAGAW'>Searches recursively for existing 'Windows' 'SAGA GIS' installation(s)</h2><span id='topic+searchSAGAW'></span>

<h3>Description</h3>

<p>Searches recursively for existing 'SAGA GIS' installation(s) on a given 'Windows' drive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchSAGAW(DL = "C:/", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchSAGAW_+3A_dl">DL</code></td>
<td>
<p>drive letter default is <code>C:/</code></p>
</td></tr>
<tr><td><code id="searchSAGAW_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for suppressing messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the 'SAGA GIS' root folder(s), the version name(s) and the installation type(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### Examples how to use searchSAGAW 

# get all valid SAGA installation folders and params
searchSAGAW()

## End(Not run)
</code></pre>

<hr>
<h2 id='searchSAGAX'>Searches recursively for existing 'Windows' 'SAGA GIS' installation(s)</h2><span id='topic+searchSAGAX'></span>

<h3>Description</h3>

<p>Search for valid 'GRASS GIS' installations at a given 'Linux' mount point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchSAGAX(MP = "/usr/bin", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchSAGAX_+3A_mp">MP</code></td>
<td>
<p>default mount point is <code>/usr/bin</code></p>
</td></tr>
<tr><td><code id="searchSAGAX_+3A_quiet">quiet</code></td>
<td>
<p>Boolean  switch for suppressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the 'SAGA GIS' root folder(s), the version name(s) and the installation type(s)
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### Examples how to use searchSAGAX

# get all valid SAGA installation folders and params
searchSAGAX()

## End(Not run)
</code></pre>

<hr>
<h2 id='setenvGDAL'>Usually for internally usage, initializes and set up  access to the 'GDAL' command line interface</h2><span id='topic+setenvGDAL'></span>

<h3>Description</h3>

<p>Initializes and set up  access to the 'GDAL' command line interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setenvGDAL(bin_GDAL = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setenvGDAL_+3A_bin_gdal">bin_GDAL</code></td>
<td>
<p>string contains the path to the 'GDAL' binaries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds 'GDAL' paths to the environment and creates the variable global string variable <code>gdalCmd</code>, that contains the path to the 'GDAL' binaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
## example for the most common default OSGeo4W64 installation of GDAL
setenvGDAL(bin_GDAL = 'C:/OSGeo4W64/bin/',
          root_GDAL = 'C:/OSGeo4W64')
}
</code></pre>

<hr>
<h2 id='setenvGRASSw'>Usually for internally usage, create valid 'GRASS GIS 7.xx' rsession environment settings according to the selected GRASS GIS 7.x and Windows Version</h2><span id='topic+setenvGRASSw'></span>

<h3>Description</h3>

<p>Initializes and set up  access to 'GRASS GIS 7.xx' via the <code>rgrass</code> wrapper or command line packages. Set and returns all necessary environment variables and additionally returns the GISBASE directory as string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setenvGRASSw(
  root_GRASS = NULL,
  grass_version = NULL,
  installation_type = NULL,
  jpgmem = 1e+06,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setenvGRASSw_+3A_root_grass">root_GRASS</code></td>
<td>
<p>grass root directory i.e. 'C:\OSGEO4~1',</p>
</td></tr>
<tr><td><code id="setenvGRASSw_+3A_grass_version">grass_version</code></td>
<td>
<p>grass version name i.e. 'grass-7.0.5'</p>
</td></tr>
<tr><td><code id="setenvGRASSw_+3A_installation_type">installation_type</code></td>
<td>
<p>two options 'osgeo4w' as installed by the 'OSGeo4W'-installer and 'NSIS' that is typical for a stand_alone installation of 'GRASS GIS'.</p>
</td></tr>
<tr><td><code id="setenvGRASSw_+3A_jpgmem">jpgmem</code></td>
<td>
<p>jpeg2000 memory allocation size. Default is 1000000</p>
</td></tr>
<tr><td><code id="setenvGRASSw_+3A_quiet">quiet</code></td>
<td>
<p>boolean  switch for suppressing console messages default is TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set selected 'GRASS GIS' installation folders 
setenvGRASSw(root_GRASS = 'C:\\PROGRA~1\\QGIS2~1.18',
             grass_version =  'grass-7.2.1',
             installation_type =  'osgeo4W')

## End(Not run)
</code></pre>

<hr>
<h2 id='setenvOTB'>Usually for internally usage, initializes and set up  access to the 'OTB' command line interface</h2><span id='topic+setenvOTB'></span>

<h3>Description</h3>

<p>Initializes and set up  access to the 'OTB' command line interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setenvOTB(bin_OTB = NULL, root_OTB = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setenvOTB_+3A_bin_otb">bin_OTB</code></td>
<td>
<p>string contains the path to the 'OTB' binaries</p>
</td></tr>
<tr><td><code id="setenvOTB_+3A_root_otb">root_OTB</code></td>
<td>
<p>string contains the full string to the root folder
containing the 'OTB' installation'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds 'OTB' paths to the environment and creates the variable global string variable <code>otbCmd</code>, that contains the path to the 'OTB' binaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## example for the most common default OSGeo4W64 installation of OTB
setenvOTB(bin_OTB = 'C:\\OSGeo4W64\\bin\\',
          root_OTB = 'C:\\OSGeo4W64')

## End(Not run)
</code></pre>

<hr>
<h2 id='setup_default'>Define working environment default settings</h2><span id='topic+setup_default'></span>

<h3>Description</h3>

<p>Define working environment default settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_default(
  default = NULL,
  new_folder_list = NULL,
  new_folder_list_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_default_+3A_default">default</code></td>
<td>
<p>name of default list</p>
</td></tr>
<tr><td><code id="setup_default_+3A_new_folder_list">new_folder_list</code></td>
<td>
<p>containing a list of arbitrary folders to be generated</p>
</td></tr>
<tr><td><code id="setup_default_+3A_new_folder_list_name">new_folder_list_name</code></td>
<td>
<p>name of this list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After adding new project settings run [setup_default()] to update and savew the default settings. For compatibility reasons you may also run [lutUpdate()].
</p>


<h3>Value</h3>

<p>A list containing the default project settings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Standard setup for baseSpatial
setup_default()

## End(Not run)
</code></pre>

<hr>
<h2 id='setupProj'>Setup project folder structure</h2><span id='topic+setupProj'></span>

<h3>Description</h3>

<p>Defines folder structures and creates them if necessary, loads
libraries, and sets other project relevant parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupProj(
  root_folder = tempdir(),
  folders = c("data", "data/tmp"),
  code_subfolder = NULL,
  global = FALSE,
  libs = NULL,
  setup_script = "000_setup.R",
  fcts_folder = NULL,
  source_functions = !is.null(fcts_folder),
  standard_setup = NULL,
  create_folders = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupProj_+3A_root_folder">root_folder</code></td>
<td>
<p>root directory of the project.</p>
</td></tr>
<tr><td><code id="setupProj_+3A_folders">folders</code></td>
<td>
<p>list of sub folders within the project directory.</p>
</td></tr>
<tr><td><code id="setupProj_+3A_code_subfolder">code_subfolder</code></td>
<td>
<p>sub folders for scripts and functions within the 
project directory that will be created. The
folders src, src/functions and src/config are recommended.</p>
</td></tr>
<tr><td><code id="setupProj_+3A_global">global</code></td>
<td>
<p>logical: export path strings as global variables?</p>
</td></tr>
<tr><td><code id="setupProj_+3A_libs">libs</code></td>
<td>
<p>vector with the  names of libraries</p>
</td></tr>
<tr><td><code id="setupProj_+3A_setup_script">setup_script</code></td>
<td>
<p>Name of the installation script that contains all the 
settings required for the project, such as additional libraries, optional settings, 
colour schemes, etc. Important: It should not be used to control the runtime
parameters of the scripts.  This file is not read in automatically, even if 
it is located in the 'fcts_folder' folder.</p>
</td></tr>
<tr><td><code id="setupProj_+3A_fcts_folder">fcts_folder</code></td>
<td>
<p>path of the folder holding the functions. All files in
this folder will be sourced at project start.</p>
</td></tr>
<tr><td><code id="setupProj_+3A_source_functions">source_functions</code></td>
<td>
<p>logical: should functions be sourced? Default is TRUE if fcts_folder exists.</p>
</td></tr>
<tr><td><code id="setupProj_+3A_standard_setup">standard_setup</code></td>
<td>
<p>select one of the predefined settings c('base', 'baseSpatial', 'advancedSpatial'). 
In this case, only the name of the base folder is required, but individual additional 
folders can be specified under 'folders' 
name of the git repository must be supplied to the function.</p>
</td></tr>
<tr><td><code id="setupProj_+3A_create_folders">create_folders</code></td>
<td>
<p>default is TRUE  so create folders if not existing already.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the project settings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setupProj(
  root_folder = '~/edu', folders = c('data/', 'data/tmp/'),
  libs = c('link2GI')
)

## End(Not run)

</code></pre>

<hr>
<h2 id='sf2gvec'>Write sf object directly to 'GRASS' vector utilising an existing or creating a new GRASS environment</h2><span id='topic+sf2gvec'></span>

<h3>Description</h3>

<p>Write sf object directly to 'GRASS' vector utilising an existing or creating a new GRASS environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf2gvec(x, epsg, obj_name, gisdbase, location, gisdbase_exist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf2gvec_+3A_x">x</code></td>
<td>
<p><code>sf</code> object corresponding to the settings of the corresponding GRASS container</p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_epsg">epsg</code></td>
<td>
<p>numeric epsg code</p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_obj_name">obj_name</code></td>
<td>
<p>name of GRASS layer</p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_gisdbase">gisdbase</code></td>
<td>
<p>GRASS gisDbase folder</p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_location">location</code></td>
<td>
<p>GRASS location name containing <code>obj_name)</code></p>
</td></tr>
<tr><td><code id="sf2gvec_+3A_gisdbase_exist">gisdbase_exist</code></td>
<td>
<p>logical switch if the GRASS gisdbase folder exist default is TRUE</p>
</td></tr>
</table>


<h3>Note</h3>

<p>have a look at the <code>sf</code> capabilities to write direct to sqlite
</p>


<h3>Author(s)</h3>

<p>Chris Reudenbach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run = FALSE
if (run) {
## example 
require(sf)
require(sp)
require(link2GI)
data(meuse)
meuse_sf = st_as_sf(meuse, 
                    coords = c('x', 'y'), 
                    crs = 28992, 
                    agr = 'constant')


# write data to GRASS and create gisdbase
sf2gvec(x = meuse_sf,
        obj_name = 'meuse_R-G',
        gisdbase = '~/temp3/',
        location = 'project1')

# read from existing GRASS          
gvec2sf(x = meuse_sf,
        obj_name = 'meuse_r_g',
        gisdbase = '~/temp3',       
        location = 'project1')

}
</code></pre>

<hr>
<h2 id='sourceFunctions'>Source functions from standard or given directory</h2><span id='topic+sourceFunctions'></span>

<h3>Description</h3>

<p>Source functions into the R environment located in a specified
folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sourceFunctions(fcts_folder, setup_script)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sourceFunctions_+3A_fcts_folder">fcts_folder</code></td>
<td>
<p>path of the folder holding the functions. All files in
this folder will be sourced at project start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information if sourcing was successfull based on try function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# sourceFunctions(fcts_folder = '~/project/src/fcts')

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
