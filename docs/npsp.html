<!DOCTYPE html><html lang="en"><head><title>Help for package npsp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {npsp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#npsp-package'><p>npsp: Nonparametric spatial (geo)statistics</p></a></li>
<li><a href='#.cpu.time.ini'><p>npsp internal and secondary functions</p></a></li>
<li><a href='#aquifer'><p>Wolfcamp aquifer data</p></a></li>
<li><a href='#as.data.grid'><p>data.grid-class methods</p></a></li>
<li><a href='#as.sp'><p>Convert npsp object to sp object</p></a></li>
<li><a href='#bin.den'><p>Linear binning for density estimation</p></a></li>
<li><a href='#binning'><p>Linear binning</p></a></li>
<li><a href='#coords'><p>(spatial) coordinates</p></a></li>
<li><a href='#coordvalues'><p>Coordinate values</p></a></li>
<li><a href='#covar'><p>Covariance values</p></a></li>
<li><a href='#cpu.time'><p>Total and partial CPU time used</p></a></li>
<li><a href='#data.grid'><p>Gridded data (S3 class &quot;data.grid&quot;)</p></a></li>
<li><a href='#disc.sb'><p>Discretization nodes of a Shapiro-Botha variogram model</p></a></li>
<li><a href='#earthquakes'><p>Earthquake data</p></a></li>
<li><a href='#fitsvar.sb.iso'><p>Fit an isotropic Shapiro-Botha variogram model</p></a></li>
<li><a href='#grid.par'><p>Grid parameters (S3 class &quot;grid.par&quot;)</p></a></li>
<li><a href='#h.cv'><p>Cross-validation methods for bandwidth selection</p></a></li>
<li><a href='#interp'><p>Fast linear interpolation of a regular grid</p></a></li>
<li><a href='#kappasb'><p>Coefficients of an extended Shapiro-Botha variogram model</p></a></li>
<li><a href='#locpol'><p>Local polynomial estimation</p></a></li>
<li><a href='#mask'><p>Mask methods</p></a></li>
<li><a href='#np.den'><p>Local polynomial density estimation</p></a></li>
<li><a href='#np.fitgeo'><p>Fit a nonparametric geostatistical model</p></a></li>
<li><a href='#np.geo'><p>Nonparametric geostatistical model (S3 class &quot;np.geo&quot;)</p></a></li>
<li><a href='#np.kriging'><p>Nonparametric (residual) kriging</p></a></li>
<li><a href='#np.svar'><p>Local polynomial estimation of the semivariogram</p></a></li>
<li><a href='#npsp-geoR'><p>Interface to package &quot;geoR&quot;</p></a></li>
<li><a href='#npsp-gstat'><p>Interface to package &quot;gstat&quot;</p></a></li>
<li><a href='#npsp.tolerance'><p>npsp Tolerances</p></a></li>
<li><a href='#plot.fitgeo'><p>Plot a nonparametric geostatistical model</p></a></li>
<li><a href='#precipitation'><p>Precipitation data</p></a></li>
<li><a href='#rgraphics'><p>R Graphics for gridded data</p></a></li>
<li><a href='#rule'><p>npsp Rules</p></a></li>
<li><a href='#scattersplot'><p>Exploratory scatter plots</p></a></li>
<li><a href='#simage'><p>Image plot with a color scale</p></a></li>
<li><a href='#spersp'><p>Perspective plot with a color scale</p></a></li>
<li><a href='#splot'><p>Utilities for plotting with a color scale</p></a></li>
<li><a href='#spoints'><p>Scatter plot with a color scale</p></a></li>
<li><a href='#sv'><p>Evaluate a semivariogram model</p></a></li>
<li><a href='#svar.bin'><p>Linear binning of semivariances</p></a></li>
<li><a href='#svar.grid'><p>Discretize a (semi)variogram model</p></a></li>
<li><a href='#svar.plot'><p>Plot a semivariogram object</p></a></li>
<li><a href='#svarmod'><p>Define a (semi)variogram model</p></a></li>
<li><a href='#varcov'><p>Covariance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Spatial Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7-13</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ruben Fernandez-Casal &lt;rubenfcasal@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>sp, methods, quadprog, spam</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gstat, geoR, fields, DEoptim, knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Multidimensional nonparametric spatial (spatio-temporal) geostatistics.
    S3 classes and methods for multidimensional: linear binning,
    local polynomial kernel regression (spatial trend estimation), density and variogram estimation.
    Nonparametric methods for simultaneous inference on both spatial trend
    and variogram functions (for spatial processes).
    Nonparametric residual kriging (spatial prediction).
    For details on these methods see, for example, Fernandez-Casal and Francisco-Fernandez (2014) 
    &lt;<a href="https://doi.org/10.1007%2Fs00477-013-0817-8">doi:10.1007/s00477-013-0817-8</a>&gt; or Castillo-Paez et al. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2019.01.017">doi:10.1016/j.csda.2019.01.017</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rubenfcasal.github.io/npsp/">https://rubenfcasal.github.io/npsp/</a>,
<a href="https://github.com/rubenfcasal/npsp/">https://github.com/rubenfcasal/npsp/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rubenfcasal/npsp/issues/">https://github.com/rubenfcasal/npsp/issues/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-17 20:30:05 UTC; ruben.fcasal</td>
</tr>
<tr>
<td>Author:</td>
<td>Ruben Fernandez-Casal
    <a href="https://orcid.org/0000-0002-5785-3739"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-19 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='npsp-package'>npsp: Nonparametric spatial (geo)statistics</h2><span id='topic+npsp-package'></span><span id='topic+npsp'></span>

<h3>Description</h3>

<p>This package implements nonparametric methods 
for inference on multidimensional spatial (or spatio-temporal) processes,
which may be (especially) useful in (automatic) geostatistical modeling and interpolation.
</p>


<h3>Main functions</h3>

<p><strong>Nonparametric methods for inference on both spatial trend 
and variogram functions</strong>:
</p>
<p><code><a href="#topic+np.fitgeo">np.fitgeo</a></code> (automatically) fits an isotropic nonparametric geostatistical model
by estimating the trend and the variogram (using a bias-corrected estimator) iteratively
(by calling <code><a href="#topic+h.cv">h.cv</a></code>, <code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+np.svariso.corr">np.svariso.corr</a></code> and 
<code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code> at each iteration).
</p>
<p><code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+np.den">np.den</a></code> and <code><a href="#topic+np.svar">np.svar</a></code>
use local polynomial kernel methods to compute
nonparametric estimates of a multidimensional regression function,
a probability density function or a semivariogram (or their first
derivatives), respectively.
Estimates of these functions can be constructed for any dimension
(the amount of available memory is the only limitation).
To speed up computations, linear binning is used to discretize the data.
A full bandwidth matrix and a multiplicative triweight kernel is used
to compute the weights. Main calculations are performed in FORTRAN
using the LAPACK library.
</p>
<p><code><a href="#topic+np.svariso.corr">np.svariso.corr</a></code> computes a bias-corrected nonparametric semivariogram 
estimate using an iterative algorithm similar to that described in  
Fernandez-Casal and Francisco-Fernandez (2014). This procedure tries to correct
the bias due to the direct use of residuals, obtained from a 
nonparametric estimation of the trend function, in semivariogram estimation.
</p>
<p><code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code> fits a &lsquo;nonparametric&rsquo; isotropic Shapiro-Botha variogram
model by WLS. Currently, only isotropic semivariogram estimation is supported.
</p>
<p><strong>Nonparametric residual kriging</strong> (sometimes called external drift kriging):
</p>
<p><code>np.kriging</code> computes residual kriging predictions  
(and the corresponding simple kriging standard errors).
</p>
<p><code>kriging.simple</code> computes simple kriging predictions, standard errors  
</p>
<p>Currently, only global simple kriging is implemented in this package.  
Users are encouraged to use <code><a href="gstat.html#topic+krige">krige</a></code> (or <code><a href="gstat.html#topic+krige.cv">krige.cv</a></code>) 
utilities in <span class="pkg">gstat</span> package together with <code><a href="#topic+as.vgm">as.vgm</a></code> for local kriging.
</p>


<h3>Other functions</h3>

<p>Among the other functions intended for direct access by the user, the following 
(methods for multidimensional linear binning, local polynomial kernel regression, 
density or variogram estimation) could be emphasized: <code><a href="#topic+binning">binning</a></code>, <code><a href="#topic+bin.den">bin.den</a></code>,
<code><a href="#topic+svar.bin">svar.bin</a></code>, <code><a href="#topic+h.cv">h.cv</a></code> and <code><a href="#topic+interp">interp</a></code>.
</p>
<p>There are functions for plotting data joint with a legend representing a
continuous color scale. <code><a href="#topic+splot">splot</a></code> allows to combine a standard R plot 
with a legend. <code><a href="#topic+spoints">spoints</a></code>, <code><a href="#topic+simage">simage</a></code> and <code><a href="#topic+spersp">spersp</a></code> 
draw the corresponding high-level plot with a legend strip for the color scale.
These functions are based on <code><a href="fields.html#topic+image.plot">image.plot</a></code> of package <span class="pkg">fields</span>.
</p>
<p>There are also some functions which can be used to interact with other packages.
For instance, <code><a href="#topic+as.variogram">as.variogram</a></code> (<span class="pkg">geoR</span>) or <code><a href="#topic+as.vgm">as.vgm</a></code> (<span class="pkg">gstat</span>).
</p>


<h3>Acknowledgments</h3>

<p>Important suggestions and contributions to some techniques included here were
made by Sergio Castillo-Paez (Universidad de las Fuerzas Armadas ESPE, Ecuador) 
and Tomas Cotos-Yañez (Dep. Statistics, University of Vigo, Spain).
</p>


<h3>Author(s)</h3>

<p>Ruben Fernandez-Casal (Dep. Mathematics, University of A Coruña, Spain).
Please send comments, error reports or suggestions to <a href="mailto:rubenfcasal@gmail.com">rubenfcasal@gmail.com</a>.
</p>


<h3>References</h3>

<p>Castillo-Páez S., Fernández-Casal R. and García-Soidán P. (2019)
A nonparametric bootstrap method for spatial data, <b>137</b>, 
<em>Comput. Stat. Data Anal.</em>, 1-15, <a href="https://doi.org/10.1016/j.csda.2019.01.017">doi:10.1016/j.csda.2019.01.017</a>. 
</p>
<p>Fernandez-Casal R., Castillo-Paez S. and Francisco-Fernandez M. (2018)
Nonparametric geostatistical risk mapping, <em>Stoch. Environ. Res. Ris. Assess.</em>, 
<b>32</b>, 675-684, <a href="https://doi.org/10.1007/s00477-017-1407-y">doi:10.1007/s00477-017-1407-y</a>.
</p>
<p>Fernandez-Casal R., Castillo-Paez S. and Garcia-Soidan P. (2017)
Nonparametric estimation of the small-scale variability of heteroscedastic spatial processes, 
<em>Spa. Sta.</em>, <b>22</b>, 358-370, <a href="https://doi.org/10.1016/j.spasta.2017.04.001">doi:10.1016/j.spasta.2017.04.001</a>.
</p>
<p>Fernandez-Casal R. and Francisco-Fernandez M. (2014) 
Nonparametric bias-corrected variogram estimation under non-constant trend, 
<em>Stoch. Environ. Res. Ris. Assess.</em>, <b>28</b>, 1247-1259, <a href="https://doi.org/10.1007/s00477-013-0817-8">doi:10.1007/s00477-013-0817-8</a>.
</p>
<p>Fernandez-Casal R., Gonzalez-Manteiga W. and  Febrero-Bande M. (2003) 
Flexible Spatio-Temporal Stationary Variogram Models, 
<em>Statistics and Computing</em>, <b>13</b>, 127-136, <a href="https://doi.org/10.1023/A%3A1023204525046">doi:10.1023/A:1023204525046</a>.
</p>
<p>Rupert D. and Wand M.P. (1994) Multivariate locally weighted least squares regression.
<em>The Annals of Statistics</em>, <b>22</b>, 1346-1370.
</p>
<p>Shapiro A. and Botha J.D. (1991) Variogram fitting with a general class of
conditionally non-negative definite functions. <em>Computational Statistics
and Data Analysis</em>, <b>11</b>, 87-96.
</p>
<p>Wand M.P. (1994) Fast Computation of Multivariate Kernel Estimators.
<em>Journal of Computational and Graphical Statistics</em>, <b>3</b>, 433-445.
</p>
<p>Wand M.P. and Jones M.C. (1995) <em>Kernel Smoothing</em>. Chapman and Hall, London.
</p>

<hr>
<h2 id='.cpu.time.ini'>npsp internal and secondary functions</h2><span id='topic+.cpu.time.ini'></span><span id='topic+revdim'></span><span id='topic+.compute.masked'></span><span id='topic+.wloss'></span><span id='topic+residuals.locpol.bin'></span><span id='topic+.kriging.simple.solve'></span><span id='topic+residuals.np.geo'></span><span id='topic+npsp-internals'></span><span id='topic+print.grid.par'></span><span id='topic+internals'></span><span id='topic+dim.grid.par'></span><span id='topic+dimnames.grid.par'></span><span id='topic+as.data.frame.grid.par'></span><span id='topic+is.data.grid'></span><span id='topic+dim.data.grid'></span><span id='topic+dimnames.data.grid'></span><span id='topic+.rice.rule'></span><span id='topic+splot.plt'></span><span id='topic+.rev.colorRampPalette'></span>

<h3>Description</h3>

<p>Listed below are supporting functions for the major methods in npsp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cpu.time.ini()

revdim(a, d)

.compute.masked(bin, cov.bin = NULL, tol.mask = npsp.tolerance(2))

.wloss(est, teor, w, loss = c("MSE", "MRSE", "MAE", "MRAE"))

## S3 method for class 'locpol.bin'
residuals(object, ...)

.kriging.simple.solve(x, newx, svm)

## S3 method for class 'np.geo'
residuals(object, ...)

## S3 method for class 'grid.par'
print(x, ...)

## S3 method for class 'grid.par'
dim(x)

## S3 method for class 'grid.par'
dimnames(x)

## S3 method for class 'grid.par'
as.data.frame(x, row.names = dimnames(x), optional = FALSE, ...)

is.data.grid(x)

## S3 method for class 'data.grid'
dim(x)

## S3 method for class 'data.grid'
dimnames(x)

.rice.rule(x, a = 2, b = 3, ...)

splot.plt(
  horizontal = FALSE,
  legend.shrink = 0.9,
  legend.width = 1,
  legend.mar = ifelse(horizontal, 3.1, 5.1),
  bigplot = NULL,
  smallplot = NULL
)

.rev.colorRampPalette(colors, interpolate = "spline", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cpu.time.ini_+3A_a">a</code></td>
<td>
<p>scale values.</p>
</td></tr>
<tr><td><code id=".cpu.time.ini_+3A_cov.bin">cov.bin</code></td>
<td>
<p>(optional) covariance matrix of the binned data or semivariogram model
(<code><a href="#topic+svarmod">svarmod</a></code>-class) of the (unbinned) data.</p>
</td></tr>
<tr><td><code id=".cpu.time.ini_+3A_object">object</code></td>
<td>
<p>object used to select a method: 
local polynomial estimate of the trend (class <code><a href="#topic+locpol.bin">locpol.bin</a></code>) 
or nonparametric geostatistical model (class extending <code><a href="#topic+np.geo">np.geo</a></code>).</p>
</td></tr>
<tr><td><code id=".cpu.time.ini_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id=".cpu.time.ini_+3A_x">x</code></td>
<td>
<p>vector/matrix with data locations
(each component/row is an observation location).</p>
</td></tr>
<tr><td><code id=".cpu.time.ini_+3A_newx">newx</code></td>
<td>
<p>vector/matrix with the (irregular) locations to predict 
(each component/row is a prediction location). 
or an object extending <code><a href="#topic+grid.par">grid.par</a></code>-<code><a href="base.html#topic+class">class</a></code>
(<code><a href="#topic+data.grid">data.grid</a></code>).</p>
</td></tr>
<tr><td><code id=".cpu.time.ini_+3A_svm">svm</code></td>
<td>
<p>semivariogram model (of class extending <code><a href="#topic+svarmod">svarmod</a></code>).</p>
</td></tr>
<tr><td><code id=".cpu.time.ini_+3A_b">b</code></td>
<td>
<p>exponent values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.compute.masked</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>mask</code></td>
<td>
<p>logical vector <code>bin$binw &gt; tol.mask</code>.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p><code>x$binw[mask]</code>.</p>
</td></tr>
<tr><td><code>sw</code></td>
<td>
<p><code>sum(w)</code>.</p>
</td></tr>
<tr><td><code>hat</code></td>
<td>
<p>(optional) <code>bin$locpol$hat[mask, mask]</code>.</p>
</td></tr>
<tr><td><code>cov.bin</code></td>
<td>
<p>(optional) masked (aproximated) covariance matrix of the binned data.</p>
</td></tr>
</table>

<hr>
<h2 id='aquifer'>Wolfcamp aquifer data</h2><span id='topic+aquifer'></span>

<h3>Description</h3>

<p>The Deaf Smith County (Texas, bordering New Mexico) was selected as an alternate
site for a possible nuclear waste disposal repository in the 1980s.
This site was later dropped on grounds of contamination of the aquifer,
the source of much of the water supply for west Texas.
In a study conducted by the U.S. Department of Energy, piezometric-head data
were obtained at 85 locations (irregularly scattered over the Texas panhandle)
by drilling a narrow pipe through the aquifer.
</p>
<p>This data set has been used in numerous papers.
For instance, Cressie (1989) lists the data and uses it to illustrate kriging,
and Cressie (1993, section 4.1) gives a detailed description of the data
and results of different geostatistical analyses.
</p>


<h3>Format</h3>

<p>A data frame with 85 observations on the following 3 variables:
</p>

<dl>
<dt>lon</dt><dd><p>relative longitude position (miles).</p>
</dd>
<dt>lat</dt><dd><p>relative latitude position (miles).</p>
</dd>
<dt>head</dt><dd><p>piezometric-head levels (feet above sea level).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Harper, W.V. and Furr, J.M. (1986) Geostatistical analysis of
potentiometric data in the Wolfcamp Aquifer of the Palo Duro Basin, Texas.
<em>Technical Report BMI/ONWI-587</em>, Bettelle Memorial Institute, Columbus, OH.
</p>


<h3>References</h3>

<p>Cressie, N. (1989) Geostatistics. 
<em>The American Statistician</em>, <b>43</b>, 197-202. 
</p>
<p>Cressie, N. (1993) <em>Statistics for Spatial Data</em>. New York. Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(aquifer)
with(aquifer, spoints(lon, lat, head, main = "Wolfcamp aquifer"))
</code></pre>

<hr>
<h2 id='as.data.grid'>data.grid-class methods</h2><span id='topic+as.data.grid'></span><span id='topic+as.data.grid.SpatialGridDataFrame'></span><span id='topic+as.data.frame.data.grid'></span>

<h3>Description</h3>

<p>S3 class <code><a href="#topic+data.grid">data.grid</a></code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.data.grid(object, ...)

## S3 method for class 'SpatialGridDataFrame'
as.data.grid(object, data.ind = NULL, ...)

## S3 method for class 'data.grid'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  data.ind = NULL,
  coords = FALSE,
  sp = FALSE,
  check.names = coords,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.grid_+3A_object">object</code></td>
<td>
<p>(gridded data) used to select a method.</p>
</td></tr>
<tr><td><code id="as.data.grid_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+data.grid">data.grid</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.grid_+3A_data.ind">data.ind</code></td>
<td>
<p>integer or character vector with the indexes or names of the components.</p>
</td></tr>
<tr><td><code id="as.data.grid_+3A_x">x</code></td>
<td>
<p>a <code>data.grid</code> object.</p>
</td></tr>
<tr><td><code id="as.data.grid_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code>, column to be used as row names, or vector giving the row names for the data frame.</p>
</td></tr>
<tr><td><code id="as.data.grid_+3A_optional">optional</code></td>
<td>
<p>logical; Not currently used (see <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>).</p>
</td></tr>
<tr><td><code id="as.data.grid_+3A_coords">coords</code></td>
<td>
<p>logical; if <code>TRUE</code>, the (spatial) coordinates of the object are added.</p>
</td></tr>
<tr><td><code id="as.data.grid_+3A_sp">sp</code></td>
<td>
<p>logical; if <code>TRUE</code>, the second dimension of the data is reversed 
(as it is stored in <span class="pkg">sp</span> package).</p>
</td></tr>
<tr><td><code id="as.data.grid_+3A_check.names">check.names</code></td>
<td>
<p>logical; if <code>TRUE</code>, the names of the variables in the data 
frame are checked and adjusted if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.data.grid</code> returns a <code><a href="#topic+data.grid">data.grid</a></code> object.
</p>
<p><code>as.data.frame</code> returns a data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.grid">data.grid</a></code>.
</p>

<hr>
<h2 id='as.sp'>Convert npsp object to sp object</h2><span id='topic+as.sp'></span><span id='topic+as.sp.grid.par'></span><span id='topic+as.sp.data.grid'></span>

<h3>Description</h3>

<p>Converts a npsp object to a <a href="sp.html#topic+00sp">sp</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sp(obj, ...)

## S3 method for class 'grid.par'
as.sp(obj, ...)

## S3 method for class 'data.grid'
as.sp(obj, data.ind = NULL, proj4string = CRS(as.character(NA)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.sp_+3A_obj">obj</code></td>
<td>
<p>a <code><a href="#topic+npsp">npsp</a></code> object.</p>
</td></tr>
<tr><td><code id="as.sp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as.sp_+3A_data.ind">data.ind</code></td>
<td>
<p>integer or character; vector with indexes or names of the data components.</p>
</td></tr>
<tr><td><code id="as.sp_+3A_proj4string">proj4string</code></td>
<td>
<p>a <code><a href="sp.html#topic+CRS-class">CRS-class</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.sp.grid.par</code> returns a <code><a href="sp.html#topic+GridTopology-class">GridTopology-class</a></code> object.
</p>
<p><code>as.sp.data.grid</code> returns a <code><a href="sp.html#topic+SpatialGridDataFrame-class">SpatialGridDataFrame-class</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame.data.grid">as.data.frame.data.grid</a></code>
</p>

<hr>
<h2 id='bin.den'>Linear binning for density estimation</h2><span id='topic+bin.den'></span><span id='topic+bin.den-class'></span><span id='topic+as.bin.den'></span><span id='topic+as.bin.den.data.grid'></span><span id='topic+as.bin.den.bin.den'></span>

<h3>Description</h3>

<p>Creates a <code>bin.den</code>-<code><a href="base.html#topic+class">class</a></code> (gridded binned density) object 
with linear binning counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.den(x, nbin = NULL)

as.bin.den(object, ...)

## S3 method for class 'data.grid'
as.bin.den(object, weights.ind = 1, ...)

## S3 method for class 'bin.den'
as.bin.den(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin.den_+3A_x">x</code></td>
<td>
<p>vector or matrix of covariates (e.g. spatial coordinates). 
Columns correspond with dimensions and rows with observations.</p>
</td></tr>
<tr><td><code id="bin.den_+3A_nbin">nbin</code></td>
<td>
<p>vector with the number of bins on each dimension.</p>
</td></tr>
<tr><td><code id="bin.den_+3A_object">object</code></td>
<td>
<p>(gridded data) used to select a method.</p>
</td></tr>
<tr><td><code id="bin.den_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="bin.den_+3A_weights.ind">weights.ind</code></td>
<td>
<p>integer or character with the index or name of the component 
containing the bin counts/weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parameter <code>nbin</code> is not specified is set to <code>pmax(25, rule.binning(x))</code>.
</p>


<h3>Value</h3>

<p>Returns an S3 object of <code><a href="base.html#topic+class">class</a></code> <code>bin.den</code> (extends <code><a href="#topic+data.grid">data.grid</a></code>). 
A list with the following 3 components:
</p>
<table role = "presentation">
<tr><td><code>binw</code></td>
<td>
<p>vector or array (dimension <code>nbin</code>) with the bin counts (weights).</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>a <code><a href="#topic+grid.par">grid.par</a></code>-<code><a href="base.html#topic+class">class</a></code> object with the grid parameters.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list with a component <code>$x</code> with argument <code>x</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+np.den">np.den</a></code>, <code><a href="#topic+h.cv">h.cv</a></code>, <code><a href="#topic+bin.data">bin.data</a></code>, 
<code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+rule.binning">rule.binning</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binden &lt;- bin.den(earthquakes[, c("lon", "lat")], nbin = c(30,30))
bindat &lt;- binning(earthquakes[, c("lon", "lat")], earthquakes$mag, nbin = c(30,30))
all.equal(binden, as.bin.den(bindat))
</code></pre>

<hr>
<h2 id='binning'>Linear binning</h2><span id='topic+binning'></span><span id='topic+bin.data-class'></span><span id='topic+bin.data'></span><span id='topic+as.bin.data'></span><span id='topic+as.bin.data.data.grid'></span><span id='topic+as.bin.data.bin.data'></span><span id='topic+as.bin.data.SpatialGridDataFrame'></span>

<h3>Description</h3>

<p>Discretizes the data into a regular grid (computes a binned approximation) 
using the multivariate linear binning technique described in Wand (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binning(x, y = NULL, nbin = NULL, set.NA = FALSE, window = NULL, ...)

as.bin.data(object, ...)

## S3 method for class 'data.grid'
as.bin.data(object, data.ind = 1, weights.ind = NULL, ...)

## S3 method for class 'bin.data'
as.bin.data(object, ...)

## S3 method for class 'SpatialGridDataFrame'
as.bin.data(object, data.ind = 1, weights.ind = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binning_+3A_x">x</code></td>
<td>
<p>vector or matrix of covariates (e.g. spatial coordinates). 
Columns correspond with covariates (coordinate dimension) and rows with data.</p>
</td></tr>
<tr><td><code id="binning_+3A_y">y</code></td>
<td>
<p>vector of data (response variable).</p>
</td></tr>
<tr><td><code id="binning_+3A_nbin">nbin</code></td>
<td>
<p>vector with the number of bins on each dimension.</p>
</td></tr>
<tr><td><code id="binning_+3A_set.na">set.NA</code></td>
<td>
<p>logical. If <code>TRUE</code>, sets the bin averages corresponding
to cells without data to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="binning_+3A_window">window</code></td>
<td>
<p>spatial window (values outside this window will be masked), currently an sp-object of class 
extending <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a></code>.</p>
</td></tr>
<tr><td><code id="binning_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+mask.bin.data">mask.bin.data</a>()</code>.</p>
</td></tr>
<tr><td><code id="binning_+3A_object">object</code></td>
<td>
<p>(gridded data) used to select a method.</p>
</td></tr>
<tr><td><code id="binning_+3A_data.ind">data.ind</code></td>
<td>
<p>integer (or character) with the index (or name) of the component 
containing the bin averages.</p>
</td></tr>
<tr><td><code id="binning_+3A_weights.ind">weights.ind</code></td>
<td>
<p>integer (or character) with the index (or name) of the component 
containing the bin counts/weights (if not specified, they are set to 
<code>as.numeric( is.finite( object[[data.ind]] ))</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parameter <code>nbin</code> is not specified is set to <code>pmax(25, rule.binning(x))</code>.
</p>
<p>Setting <code>set.NA = TRUE</code> (equivalent to <code>biny[binw == 0] &lt;- NA</code>) 
may be useful for plotting the binned averages <code>$biny</code>
(the hat matrix should be handled with care when using <code><a href="#topic+locpol">locpol</a></code>).
</p>


<h3>Value</h3>

<p>If <code>y != NULL</code>, an S3 object of <code><a href="base.html#topic+class">class</a></code> <code>bin.data</code> 
(gridded binned data; extends <code><a href="#topic+bin.den">bin.den</a></code>) is returned. 
A <code><a href="#topic+data.grid">data.grid</a></code> object with the following 4 components:
</p>
<table role = "presentation">
<tr><td><code>biny</code></td>
<td>
<p>vector or array (dimension <code>nbin</code>) with the bin averages. </p>
</td></tr>
<tr><td><code>binw</code></td>
<td>
<p>vector or array (dimension <code>nbin</code>) with the bin counts (weights).</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>a <code><a href="#topic+grid.par">grid.par</a></code>-<code><a href="base.html#topic+class">class</a></code> object with the grid parameters.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list with 3 components:
</p>

<ul>
<li><p><code>x</code> argument <code>x</code>.
</p>
</li>
<li><p><code>y</code> argument <code>y</code>.
</p>
</li>
<li><p><code>med</code> (weighted) mean of the (binned) data.
</p>
</li></ul>
</td></tr>
</table>
<p>If <code>y == NULL</code>, <code><a href="#topic+bin.den">bin.den</a></code> is called and a  
<code><a href="#topic+bin.den">bin.den</a></code>-<code><a href="base.html#topic+class">class</a></code> object is returned.
</p>


<h3>References</h3>

<p>Wand M.P. (1994) Fast Computation of Multivariate Kernel Estimators.
<em>Journal of Computational and Graphical Statistics</em>, <b>3</b>, 433-445.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.grid">data.grid</a></code>, <code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+bin.den">bin.den</a></code>, 
<code><a href="#topic+h.cv">h.cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(earthquakes, spoints(lon, lat, mag, main = "Earthquake data"))

bin &lt;- binning(earthquakes[, c("lon", "lat")], earthquakes$mag, nbin = c(30,30), set.NA = TRUE)

simage(bin, main = "Binning averages")
with(earthquakes, points(lon, lat, pch = 20))
</code></pre>

<hr>
<h2 id='coords'>(spatial) coordinates</h2><span id='topic+coords'></span><span id='topic+coords.grid.par'></span><span id='topic+coords.data.grid'></span>

<h3>Description</h3>

<p>Retrieves the (spatial) coordinates of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords(x, ...)

## S3 method for class 'grid.par'
coords(x, ...)

## S3 method for class 'data.grid'
coords(x, masked = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coords_+3A_x">x</code></td>
<td>
<p>a (spatial) object used to select a method.</p>
</td></tr>
<tr><td><code id="coords_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="coords_+3A_masked">masked</code></td>
<td>
<p>logical; If <code>TRUE</code>, only the coordinates corresponding
to unmasked cells are returned (see <code><a href="#topic+mask">mask</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of coordinates (columns correspond with dimensions and rows with data).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coordvalues">coordvalues</a></code>.
</p>

<hr>
<h2 id='coordvalues'>Coordinate values</h2><span id='topic+coordvalues'></span><span id='topic+coordvalues.grid.par'></span><span id='topic+coordvalues.data.grid'></span>

<h3>Description</h3>

<p>Returns the coordinate values in each dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordvalues(x, ...)

## S3 method for class 'grid.par'
coordvalues(x, ...)

## S3 method for class 'data.grid'
coordvalues(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordvalues_+3A_x">x</code></td>
<td>
<p>a (spatial) object used to select a method.</p>
</td></tr>
<tr><td><code id="coordvalues_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the (unique) coordinates along each axis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>.
</p>

<hr>
<h2 id='covar'>Covariance values</h2><span id='topic+covar'></span><span id='topic+covar.svarmod'></span><span id='topic+covar.np.svar'></span>

<h3>Description</h3>

<p>Computes covariance values (or pseudo-covariances) given a variogram model
or covariance estimates given a semivariogram estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covar(x, h, ...)

## S3 method for class 'svarmod'
covar(x, h, sill = x$sill, discretize = FALSE, ...)

## S3 method for class 'np.svar'
covar(x, h, sill = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covar_+3A_x">x</code></td>
<td>
<p>variogram model (<code><a href="#topic+svarmod">svarmod</a></code> object) or semivariogram estimate.</p>
</td></tr>
<tr><td><code id="covar_+3A_h">h</code></td>
<td>
<p>vector (isotropic case) or matrix of lag values.</p>
</td></tr>
<tr><td><code id="covar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="covar_+3A_sill">sill</code></td>
<td>
<p>(theoretical or estimated) variance <code class="reqn">C(0) = \sigma^2</code> or pseudo-sill (unbounded variograms).</p>
</td></tr>
<tr><td><code id="covar_+3A_discretize">discretize</code></td>
<td>
<p>logical. If <code>TRUE</code> the variogram is previously discretized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of (pseudo) covariance values <code class="reqn">C(h_i) = \sigma^2 - \gamma(h_i)</code> or covariance estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sv">sv</a></code>, <code><a href="#topic+varcov">varcov</a></code>.
</p>

<hr>
<h2 id='cpu.time'>Total and partial CPU time used</h2><span id='topic+cpu.time'></span>

<h3>Description</h3>

<p>Returns and (optionally) prints the total and/or partial (since the last call to this function) 
real and CPU times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpu.time(..., reset = FALSE, total = TRUE, last = TRUE, flush = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpu.time_+3A_...">...</code></td>
<td>
<p>objects (describing the last operation) to be printed (using <code><a href="base.html#topic+cat">cat</a></code>), 
if <code>last == TRUE</code>.</p>
</td></tr>
<tr><td><code id="cpu.time_+3A_reset">reset</code></td>
<td>
<p>logical; if <code>TRUE</code>, time counters are initialized.</p>
</td></tr>
<tr><td><code id="cpu.time_+3A_total">total</code></td>
<td>
<p>logical; if <code>TRUE</code>, the total time used is printed.</p>
</td></tr>
<tr><td><code id="cpu.time_+3A_last">last</code></td>
<td>
<p>logical; if <code>TRUE</code>, the partial time used is printed.</p>
</td></tr>
<tr><td><code id="cpu.time_+3A_flush">flush</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code><a href="utils.html#topic+flush.console">flush.console</a></code> is called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a list with  the following 3 components 
(objects of class <code>"proc_time"</code>):
</p>
<table role = "presentation">
<tr><td><code>time</code></td>
<td>
<p>user, system, and total elapsed times for the currently running R process 
(result of a call to <code><a href="base.html#topic+proc.time">proc.time</a></code>). </p>
</td></tr>
<tr><td><code>last</code>, <code>total</code></td>
<td>
<p>differences between the corresponding <code><a href="base.html#topic+proc.time">proc.time</a></code> calls.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+proc.time">proc.time</a></code>, <code><a href="base.html#topic+system.time">system.time</a></code>, <code><a href="utils.html#topic+flush.console">flush.console</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cpu.time(reset=TRUE)
res &lt;- median(runif(100000))
cpu.time('\nSample median of', 100000, 'values =', res)
res &lt;- median(runif(1000))
cpu.time('\nSample median of', 1000, 'values =', res)
</code></pre>

<hr>
<h2 id='data.grid'>Gridded data (S3 class &quot;data.grid&quot;)</h2><span id='topic+data.grid'></span><span id='topic+data.grid-class'></span>

<h3>Description</h3>

<p>Defines data on a full regular (spatial) grid. 
Constructor function of the <code>data.grid</code>-<code><a href="base.html#topic+class">class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.grid(
  ...,
  grid = NULL,
  window = NULL,
  mask = NULL,
  set.NA = FALSE,
  warn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.grid_+3A_...">...</code></td>
<td>
<p>vectors or arrays of data with length equal to <code>prod(grid$n)</code>.</p>
</td></tr>
<tr><td><code id="data.grid_+3A_grid">grid</code></td>
<td>
<p>a <code><a href="#topic+grid.par">grid.par</a></code>-<code><a href="base.html#topic+class">class</a></code> object (optional).</p>
</td></tr>
<tr><td><code id="data.grid_+3A_window">window</code></td>
<td>
<p>spatial window (values outside this window will be masked), currently an sp-object of class 
extending <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a></code>.</p>
</td></tr>
<tr><td><code id="data.grid_+3A_mask">mask</code></td>
<td>
<p>logical; vector (or array) indicating the selected values (not masked).</p>
</td></tr>
<tr><td><code id="data.grid_+3A_set.na">set.NA</code></td>
<td>
<p>logical; If <code>TRUE</code>, the values corresponding
to masked cells are set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="data.grid_+3A_warn">warn</code></td>
<td>
<p>logical; If <code>TRUE</code> a warning message is generated when original data is masked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parameter <code>grid.par</code> is not specified it is set from first argument.
</p>
<p>S3 &quot;version&quot; of the <code><a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a></code>-<code><a href="base.html#topic+class">class</a></code> 
of the <span class="pkg">sp</span> package.
</p>


<h3>Value</h3>

<p>Returns an object of <code><a href="base.html#topic+class">class</a></code> <code>data.grid</code>, a list with 
the arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.grid">as.data.grid</a></code>, <code><a href="#topic+grid.par">grid.par</a></code>, <code><a href="#topic+mask">mask</a></code>, 
<code><a href="#topic+binning">binning</a></code>, <code><a href="#topic+locpol">locpol</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grid parameters
grid &lt;- grid.par(n = c(15,15), min = c(x = -1, y = -1), max = c(1, 1))
coordinates &lt;- coords(grid)
plot(coordinates)
coordvs &lt;- coordvalues(grid)
abline(v = coordvs[[1]], lty = 3)
abline(h = coordvs[[2]], lty = 3)
# Gridded data
y &lt;- apply(coordinates, 1, function(x) x[1]^2 - x[2]^2 )
datgrid &lt;- data.grid(y = y, grid = grid)
spersp(datgrid, main = 'f(x,y) = x^2 - y^2')
dim(datgrid)
all.equal(coordinates, coords(datgrid))
</code></pre>

<hr>
<h2 id='disc.sb'>Discretization nodes of a Shapiro-Botha variogram model</h2><span id='topic+disc.sb'></span>

<h3>Description</h3>

<p>Computes the discretization nodes of a &lsquo;nonparametric&rsquo; extended Shapiro-Botha 
variogram model, following Gorsich and Genton (2004), as the scaled roots of 
Bessel functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc.sb(nx, dk = 0, rmax = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc.sb_+3A_nx">nx</code></td>
<td>
<p>number of discretization nodes.</p>
</td></tr>
<tr><td><code id="disc.sb_+3A_dk">dk</code></td>
<td>
<p>dimension of the kappa function (<code>dk &gt;= 1</code>, see Details below).</p>
</td></tr>
<tr><td><code id="disc.sb_+3A_rmax">rmax</code></td>
<td>
<p>maximum lag considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>dk &gt;= 1</code>, the nodes are computed as: 
</p>
<p style="text-align: center;"><code class="reqn">x_i = q_i/rmax; i = 1,\ldots, nx,</code>
</p>
<p> where 
<code class="reqn">q_i</code> are the first <code class="reqn">n</code> roots of <code class="reqn">J_{(d-2)/2}</code>, <code class="reqn">J_p</code> 
is the Bessel function of order <code class="reqn">p</code> and <code class="reqn">rmax</code> 
is the maximum lag considered. The computation of the zeros of the Bessel  
function is done using the efficient algorithm developed by Ball (2000).
</p>
<p>If <code>dk == 0</code> (corresponding to a model valid in any spatial dimension), 
the nodes are computed so the gaussian variogram models involved have
practical ranges: 
</p>
<p style="text-align: center;"><code class="reqn">r_i = 2 ( 1 + (i-1) ) rmax/nx; i = 1,\ldots, nx.</code>
</p>



<h3>Value</h3>

<p>A vector with the discretization nodes.
</p>


<h3>References</h3>

<p>Ball, J.S. (2000) Automatic computation of zeros of Bessel functions and other
special functions. <em>SIAM Journal on Scientific Computing</em>, <b>21</b>, 
1458-1464.  
</p>
<p>Gorsich, D.J. and Genton, M.G. (2004) On the discretization of nonparametric 
covariogram estimators. <em>Statistics and Computing</em>, <b>14</b>, 99-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kappasb">kappasb</a></code>, <code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc.sb( 12, 1, 1.0)

nx &lt;- 1
dk &lt;- 0
x &lt;- disc.sb(nx, dk, 1.0)
h &lt;- seq(0, 1, length = 100)
plot(h, kappasb(x * h, 0), type="l", ylim = c(0, 1))
abline(h = 0.05, lty = 2)
</code></pre>

<hr>
<h2 id='earthquakes'>Earthquake data</h2><span id='topic+earthquakes'></span>

<h3>Description</h3>

<p>The data set consists of 1859 earthquakes (with magnitude above or equal to
2.0 in Richter's scale), which occurred from 25 November 1944 to 16 October
2013 in the northwest (NW) part of the Iberian Peninsula.
The area considered is limited by the coordinates 41N-44N and 6W-10W,
which contains the autonomic region of Galicia (Spain) and northern Portugal.
</p>


<h3>Format</h3>

<p>A data frame with 1859 observations on the following 6 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date and time (POSIXct format).</p>
</dd>
<dt>time</dt><dd><p>Time (years since first event).</p>
</dd>
<dt>lon</dt><dd><p>Longitude.</p>
</dd>
<dt>lat</dt><dd><p>Latitude.</p>
</dd>
<dt>depth</dt><dd><p>Depth (km).</p>
</dd>
<dt>mag</dt><dd><p>Magnitude (Richter's scale).</p>
</dd>
</dl>



<h3>Source</h3>

<p>National Geographic Institute (IGN) of Spain: <br />
<a href="https://www.ign.es/web/ign/portal/sis-area-sismicidad">https://www.ign.es/web/ign/portal/sis-area-sismicidad</a>.
</p>


<h3>References</h3>

<p>Francisco-Fernandez M., Quintela-del-Rio A. and Fernandez-Casal R. (2012)
Nonparametric methods for spatial regression. An application to seismic
events, <em>Environmetrics</em>, <b>23</b>, 85-93.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(earthquakes)
summary(earthquakes)
with(earthquakes, spoints(lon, lat, mag, main = "Earthquake data"))
</code></pre>

<hr>
<h2 id='fitsvar.sb.iso'>Fit an isotropic Shapiro-Botha variogram model</h2><span id='topic+fitsvar.sb.iso'></span><span id='topic+fitsvar'></span><span id='topic+fitsvar-class'></span>

<h3>Description</h3>

<p>Fits a &lsquo;nonparametric&rsquo; isotropic Shapiro-Botha variogram model by WLS through
quadratic programming.
Following Gorsich and Genton (2004), the nodes are selected as the scaled 
roots of Bessel functions (see <code><a href="#topic+disc.sb">disc.sb</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitsvar.sb.iso(
  esv,
  dk = 4 * ncol(esv$data$x),
  nx = NULL,
  rmax = esv$grid$max,
  min.contrib = 10,
  method = c("cressie", "equal", "npairs", "linear"),
  iter = 10,
  tol = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitsvar.sb.iso_+3A_esv">esv</code></td>
<td>
<p>pilot semivariogram estimate, a <code><a href="#topic+np.svar">np.svar</a></code>-<code><a href="base.html#topic+class">class</a></code> 
(or <code><a href="#topic+svar.bin">svar.bin</a></code>) object. Typically an output of the function
<code><a href="#topic+np.svariso">np.svariso</a></code>.</p>
</td></tr>
<tr><td><code id="fitsvar.sb.iso_+3A_dk">dk</code></td>
<td>
<p>dimension of the kappa function (<code>dk == 0</code> corresponds to a model 
valid in any dimension; if <code>dk &gt; 0</code>, it should be greater than 
or equal to the dimension of the spatial process <code>ncol(esv$data$x)</code>).</p>
</td></tr>
<tr><td><code id="fitsvar.sb.iso_+3A_nx">nx</code></td>
<td>
<p>number of discretization nodes. Defaults to <code>min(nesv - 1, 50)</code>,
where <code>nesv</code> is the number of semivariogram estimates.</p>
</td></tr>
<tr><td><code id="fitsvar.sb.iso_+3A_rmax">rmax</code></td>
<td>
<p>maximum lag considered in the discretization
(range of the fitted variogram on output).</p>
</td></tr>
<tr><td><code id="fitsvar.sb.iso_+3A_min.contrib">min.contrib</code></td>
<td>
<p>minimum number of (equivalent) contributing pairs 
(pilot estimates with a lower number are ignored, with a warning).</p>
</td></tr>
<tr><td><code id="fitsvar.sb.iso_+3A_method">method</code></td>
<td>
<p>string indicating the WLS fitting method to be used
(e.g. <code>method = "cressie"</code>). See &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="fitsvar.sb.iso_+3A_iter">iter</code></td>
<td>
<p>maximum number of interations of the WLS algorithm (used only
if <code>method == "cressie"</code>).</p>
</td></tr>
<tr><td><code id="fitsvar.sb.iso_+3A_tol">tol</code></td>
<td>
<p>absolute convergence tolerance (used only
if <code>method == "cressie"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fit is done using a (possibly iterated) weighted least squares criterion, minimizing: 
</p>
<p style="text-align: center;"><code class="reqn">WLS(\theta) = \sum_i w_i[(\hat{\gamma}(h_i)) -	\gamma(\theta; h_i)]^2.</code>
</p>

<p>The different options for the argument <code>method</code> define the WLS algorithm used:
</p>

<dl>
<dt><code>"cressie"</code></dt><dd><p>The default method. The procedure is
iterative, with <code class="reqn">w_i = 1</code> (OLS) used for the first step
and with the weights recalculated at each iteration,
following Cressie (1985), until convergence: </p>
<p style="text-align: center;"><code class="reqn">w_i =
 N(h_i)/\gamma(\hat{\theta}; h_i)^2,</code>
</p>
<p> where <code class="reqn">N(h_i)</code>
is the (equivalent) number of contributing pairs in the
estimation at lag <code class="reqn">h_i</code>.</p>
</dd>
<dt><code>"equal"</code></dt><dd><p>Ordinary least squares: <code class="reqn">w_i = 1</code>.</p>
</dd>
<dt><code>"npairs"</code></dt><dd><p><code class="reqn">w_i = N(h_i).</code></p>
</dd> 
<dt><code>"linear"</code></dt><dd><p><code class="reqn">w_i = N(h_i)/h_i^2</code> 
(default fitting method in <span class="pkg">gstat</span> package).</p>
</dd> 
</dl>
 
<p>Function <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> of <span class="pkg">quadprog</span> package is used
to solve a strictly convex quadratic program. To avoid problems, the Cholesky decomposition
of the matrix corresponding to the original problem is computed using <code><a href="base.html#topic+chol">chol</a></code> with <code>pivot = TRUE</code>.
If this matrix is only positive semi-definite (non-strictly convex QP),
the number of discretization nodes will be less than <code>nx</code>.
</p>


<h3>Value</h3>

<p>Returns the fitted variogram model, an object of <code><a href="base.html#topic+class">class</a></code> <code>fitsvar</code>.
A <code><a href="#topic+svarmod">svarmod</a></code> object
with additional components <code>esv</code> (pilot semivariogram estimate) and <code>fit</code> containing:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>vector of lags/distances.</p>
</td></tr>
<tr><td><code>sv</code></td>
<td>
<p>vector of pilot semivariogram estimates.</p>
</td></tr>
<tr><td><code>fitted.sv</code></td>
<td>
<p>vector of fitted semivariances.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>vector of (least squares) weights.</p>
</td></tr>
<tr><td><code>wls</code></td>
<td>
<p>value of the objective function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>string indicating the WLS fitting method used.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of WLS iterations (if <code>method == "cressie"</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ball, J.S. (2000) Automatic computation of zeros of Bessel functions and other
special functions. <em>SIAM Journal on Scientific Computing</em>, <b>21</b>, 
1458-1464.
</p>
<p>Cressie, N. (1985) Fitting variogram models by weighted least squares.
<em>Mathematical Geology</em>, <b>17</b>, 563-586. 
</p>
<p>Cressie, N. (1993) <em>Statistics for Spatial Data</em>. New York. Wiley.
</p>
<p>Fernandez Casal R., Gonzalez Manteiga W. and  Febrero Bande M. (2003) 
Flexible Spatio-Temporal Stationary Variogram Models, 
<em>Statistics and Computing</em>, <b>13</b>, 127-136.
</p>
<p>Gorsich, D.J. and Genton, M.G. (2004) On the discretization of nonparametric 
covariogram estimators. <em>Statistics and Computing</em>, <b>14</b>, 99-108.
</p>
<p>Shapiro, A. and Botha, J.D. (1991) Variogram fitting with a general class of 
conditionally non-negative definite functions. <em>Computational Statistics 
and Data Analysis</em>, <b>11</b>, 87-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svarmod.sb.iso">svarmod.sb.iso</a></code>, <code><a href="#topic+disc.sb">disc.sb</a></code>, <code><a href="#topic+plot.fitsvar">plot.fitsvar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Trend estimation
lp &lt;- locpol(aquifer[,1:2], aquifer$head, nbin = c(41,41),
             h = diag(100, 2), hat.bin = TRUE)
                               # 'np.svariso.corr()' requires a 'lp$locpol$hat' component

# Variogram estimation
esvar &lt;- np.svariso.corr(lp, maxlag = 150, nlags = 60, h = 60, plot = FALSE)

# Variogram fitting
svm2 &lt;- fitsvar.sb.iso(esvar)  # dk = 2
svm3 &lt;- fitsvar.sb.iso(esvar, dk = 0) # To avoid negative covariances...
svm4 &lt;- fitsvar.sb.iso(esvar, dk = 10) # To improve fit...

plot(svm4, main = "Nonparametric bias-corrected semivariogram and fitted models", legend = FALSE)
plot(svm3, add = TRUE)
plot(svm2, add = TRUE, lty = 3)
legend("bottomright", legend = c("NP estimates", "fitted model (dk = 10)", "dk = 0", "dk = 2"),
            lty = c(NA, 1, 1, 3), pch = c(1, NA, NA, NA), lwd = c(1, 2, 1, 1))
</code></pre>

<hr>
<h2 id='grid.par'>Grid parameters (S3 class &quot;grid.par&quot;)</h2><span id='topic+grid.par'></span><span id='topic+grid.par-class'></span>

<h3>Description</h3>

<p>Defines a full regular (spatial) grid. 
Constructor function of the <code>grid.par</code>-<code><a href="base.html#topic+class">class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.par(
  n,
  min,
  max = min + (n - 1) * lag,
  lag = (max - min)/(n - 1),
  dimnames = names(min)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.par_+3A_n">n</code></td>
<td>
<p>integer vector; number of nodes in each dimension.</p>
</td></tr>
<tr><td><code id="grid.par_+3A_min">min</code></td>
<td>
<p>vector; minimum values of the coordinates.</p>
</td></tr>
<tr><td><code id="grid.par_+3A_max">max</code></td>
<td>
<p>vector; maximum values of the coordinates (optional).</p>
</td></tr>
<tr><td><code id="grid.par_+3A_lag">lag</code></td>
<td>
<p>vector; lag in each dimension (optional).</p>
</td></tr>
<tr><td><code id="grid.par_+3A_dimnames">dimnames</code></td>
<td>
<p>character vector; names used to label the dimensions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parameters must have the same length. 
Only one of the arguments <code>max</code> or <code>lag</code> must be specified. 
</p>
<p>S3 'version' of the <code><a href="sp.html#topic+GridTopology-class">GridTopology</a></code>-<code><a href="base.html#topic+class">class</a></code> of the <span class="pkg">sp</span> package.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>grid.par</code>, a list with the arguments as components 
and an additional component <code>$nd = length(n)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.grid">data.grid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.par(n = c(100, 100), min = c(-10, 42), max = c(-7.5, 44))
grid.par(n = c(100, 100), min = c(-10, 42), lag = c(0.03, 0.02))
</code></pre>

<hr>
<h2 id='h.cv'>Cross-validation methods for bandwidth selection</h2><span id='topic+h.cv'></span><span id='topic+h.cv.bin.data'></span><span id='topic+h.cv.bin.den'></span><span id='topic+h.cv.svar.bin'></span><span id='topic+hcv.data'></span>

<h3>Description</h3>

<p>Selects the bandwidth of a local polynomial kernel (regression, density or
variogram) estimator using (standard or modified) CV, GCV or MASE criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h.cv(bin, ...)

## S3 method for class 'bin.data'
h.cv(
  bin,
  objective = c("CV", "GCV", "MASE"),
  h.start = NULL,
  h.lower = NULL,
  h.upper = NULL,
  degree = 1,
  ncv = ifelse(objective == "CV", 2, 0),
  cov.bin = NULL,
  DEalgorithm = FALSE,
  warn = TRUE,
  tol.mask = npsp.tolerance(2),
  ...
)

## S3 method for class 'bin.den'
h.cv(
  bin,
  h.start = NULL,
  h.lower = NULL,
  h.upper = NULL,
  degree = 1,
  ncv = 2,
  DEalgorithm = FALSE,
  ...
)

## S3 method for class 'svar.bin'
h.cv(
  bin,
  loss = c("MRSE", "MRAE", "MSE", "MAE"),
  h.start = NULL,
  h.lower = NULL,
  h.upper = NULL,
  degree = 1,
  ncv = 1,
  DEalgorithm = FALSE,
  warn = FALSE,
  ...
)

hcv.data(
  bin,
  objective = c("CV", "GCV", "MASE"),
  h.start = NULL,
  h.lower = NULL,
  h.upper = NULL,
  degree = 1,
  ncv = ifelse(objective == "CV", 1, 0),
  cov.dat = NULL,
  DEalgorithm = FALSE,
  warn = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h.cv_+3A_bin">bin</code></td>
<td>
<p>object used to select a method (binned data, binned density or binned semivariogram).</p>
</td></tr>
<tr><td><code id="h.cv_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods
(e.g. parameters of the optimization routine).</p>
</td></tr>
<tr><td><code id="h.cv_+3A_objective">objective</code></td>
<td>
<p>character; optimal criterion to be used (&quot;CV&quot;, &quot;GCV&quot; or &quot;MASE&quot;).</p>
</td></tr>
<tr><td><code id="h.cv_+3A_h.start">h.start</code></td>
<td>
<p>vector; initial values for the parameters (diagonal elements) to be optimized over.
If <code>DEalgorithm == FALSE</code> (otherwise not used), defaults to <code>(3 + ncv) * lag</code>,
where <code>lag = bin$grid$lag</code>.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_h.lower">h.lower</code></td>
<td>
<p>vector; lower bounds on each parameter (diagonal elements) to be optimized.
Defaults to <code>(1.5 + ncv) * bin$grid$lag</code>.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_h.upper">h.upper</code></td>
<td>
<p>vector; upper bounds on each parameter (diagonal elements) to be optimized.
Defaults to <code>1.5 * dim(bin) * bin$grid$lag</code>.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_degree">degree</code></td>
<td>
<p>degree of the local polynomial used. Defaults to 1 (local linear estimation).</p>
</td></tr>
<tr><td><code id="h.cv_+3A_ncv">ncv</code></td>
<td>
<p>integer; determines the number of cells leaved out in each dimension.
(0 to GCV considering all the data, <code class="reqn">&gt;0</code> to traditional or modified cross-validation).
See &quot;Details&quot; bellow.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_cov.bin">cov.bin</code></td>
<td>
<p>(optional) covariance matrix of the binned data or semivariogram model
(<code><a href="#topic+svarmod">svarmod</a></code>-class) of the (unbinned) data. Defaults to the identity matrix.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_dealgorithm">DEalgorithm</code></td>
<td>
<p>logical; if <code>TRUE</code>, the differential evolution optimization algorithm 
in package <span class="pkg">DEoptim</span> is used.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_warn">warn</code></td>
<td>
<p>logical; sets the handling of warning messages
(normally due to the lack of data in some neighborhoods).
If <code>FALSE</code> all warnings are ignored.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_tol.mask">tol.mask</code></td>
<td>
<p>tolerance used in the aproximations. Defaults to <code><a href="#topic+npsp.tolerance">npsp.tolerance</a>(2)</code>.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_loss">loss</code></td>
<td>
<p>character; CV error. See &quot;Details&quot; bellow.</p>
</td></tr>
<tr><td><code id="h.cv_+3A_cov.dat">cov.dat</code></td>
<td>
<p>covariance matrix of the data or semivariogram model
(of class extending <code><a href="#topic+svarmod">svarmod</a></code>). Defaults to the identity matrix
(uncorrelated data).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only diagonal bandwidths are supported.
</p>
<p><code>h.cv</code> methods use binning approximations to the objective function values 
(in almost all cases, an averaged squared error). 
If <code>ncv &gt; 0</code>, estimates are computed by leaving out binning cells with indexes within 
the intervals <code class="reqn">[x_i - ncv + 1, x_i + ncv - 1]</code>, at each dimension i, where <code class="reqn">x</code> 
denotes the index of the estimation location. <code class="reqn">ncv = 1</code> corresponds with
traditional cross-validation and <code class="reqn">ncv &gt; 1</code> with modified CV 
(it may be appropriate for dependent data; see e.g. Chu and Marron, 1991, for the one dimensional case). 
Setting <code>ncv &gt;= 2</code> would be recommended for sparse data (as linear binning is used).
For standard GCV, set <code>ncv = 0</code> (the whole data would be used).
For theoretical MASE, set <code>bin = binning(x, y = trend.teor)</code>, <code>cov = cov.teor</code> and <code>ncv = 0</code>.
</p>
<p>If <code>DEalgorithm == FALSE</code>, the <code>"L-BFGS-B"</code> method in <code><a href="stats.html#topic+optim">optim</a></code> is used.
</p>
<p>The different options for the argument <code>loss</code> in <code>h.cv.svar.bin()</code> define the CV error 
considered in semivariogram estimation:
</p>

<dl>
<dt><code>"MSE"</code></dt><dd><p>Mean squared error</p>
</dd>
<dt><code>"MRSE"</code></dt><dd><p>Mean relative squared error</p>
</dd>
<dt><code>"MAE"</code></dt><dd><p>Mean absolute error</p>
</dd>
<dt><code>"MRAE"</code></dt><dd><p>Mean relative absolute error</p>
</dd>
</dl>

<p><code>hcv.data</code> evaluates the objective function at the original data
(combining a binning approximation to the nonparametric estimates with a linear interpolation),
this can be very slow (and memory demanding; consider using <code>h.cv</code> instead).
If <code>ncv &gt; 1</code> (modified CV), a similar algorithm to that in <code>h.cv</code> is used,
estimates are computed by leaving out binning cells with indexes within
the intervals <code class="reqn">[x_i - ncv + 1, x_i + ncv - 1]</code>.
</p>


<h3>Value</h3>

<p>Returns a list containing the following 3 components:
</p>
<table role = "presentation">
<tr><td><code>h</code></td>
<td>
<p>the best (diagonal) bandwidth matrix found.</p>
</td></tr> 
<tr><td><code>value</code></td>
<td>
<p>the value of the objective function corresponding to <code>h</code>.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the criterion used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chu, C.K. and Marron, J.S. (1991) Comparison of Two Bandwidth Selectors
with Dependent Errors. <em>The Annals of Statistics</em>, <b>19</b>, 1906-1918.
</p>
<p>Francisco-Fernandez M. and Opsomer J.D. (2005) Smoothing parameter selection
methods for nonparametric regression with spatially correlated errors. 
<em>Canadian Journal of Statistics</em>, <b>33</b>, 539-558.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+locpolhcv">locpolhcv</a></code>, <code><a href="#topic+binning">binning</a></code>, 
<code><a href="#topic+np.den">np.den</a></code>, <code><a href="#topic+np.svar">np.svar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Trend estimation
bin &lt;- binning(earthquakes[, c("lon", "lat")], earthquakes$mag)
hcv &lt;- h.cv(bin, ncv = 2)
lp &lt;- locpol(bin, h = hcv$h)
# Alternatively, `locpolhcv()` could be called instead of the previous code. 

simage(lp, main = 'Smoothed magnitude')
contour(lp, add = TRUE)
with(earthquakes, points(lon, lat, pch = 20))

# Density estimation
hden &lt;- h.cv(as.bin.den(bin))
den &lt;- np.den(bin, h = hden$h)

plot(den, main = 'Estimated log(density)')
</code></pre>

<hr>
<h2 id='interp'>Fast linear interpolation of a regular grid</h2><span id='topic+interp'></span><span id='topic+interp.grid.par'></span><span id='topic+interp.data.grid'></span><span id='topic+predict.locpol.bin'></span><span id='topic+predict.np.den'></span>

<h3>Description</h3>

<p>Computes a linear interpolation of multidimensional regularly gridded data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp(object, ...)

## S3 method for class 'grid.par'
interp(object, data, newx, ...)

## S3 method for class 'data.grid'
interp(object, data.ind = 1, newx, ...)

## S3 method for class 'locpol.bin'
predict(object, newx = NULL, hat.data = FALSE, ...)

## S3 method for class 'np.den'
predict(object, newx = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp_+3A_object">object</code></td>
<td>
<p>(gridded data) object used to select a method.</p>
</td></tr>
<tr><td><code id="interp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="interp_+3A_data">data</code></td>
<td>
<p>vector or array of data values.</p>
</td></tr>
<tr><td><code id="interp_+3A_newx">newx</code></td>
<td>
<p>vector or matrix with the (irregular) locations to interpolate. 
Columns correspond with dimensions and rows with data.</p>
</td></tr>
<tr><td><code id="interp_+3A_data.ind">data.ind</code></td>
<td>
<p>integer (or character) with the index (or name) of the data component.</p>
</td></tr>
<tr><td><code id="interp_+3A_hat.data">hat.data</code></td>
<td>
<p>logical; if <code>TRUE</code> (and possible), the hat matrix corresponding 
to the (original) data is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>interp</code> methods are interfaces to the fortran routine <code>interp_data_grid</code>  
(in <code>grid_module.f90</code>).
</p>
<p><code>predict.locpol.bin</code> is an interface to the fortran routine 
<code>predict_lp</code> (in <code>lp_module.f90</code>).
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>interpolation locations.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>interpolated values.</p>
</td></tr>
</table>
<p>If <code>newx == NULL</code>, <code>predict.locpol.bin</code> returns the estimates 
(and optionally the hat matrix) corresponding to the data
(otherwise <code>interp.data.grid</code> is called).
</p>


<h3>Note</h3>

<p>Linear extrapolation is performed from the end nodes of the grid.
</p>
<p>WARNING: May fail with missing values (especially if <code>object$locpol$ncv &gt; 0</code>).
</p>


<h3>See Also</h3>

<p><code><a href="fields.html#topic+interp.surface">interp.surface</a></code>.
</p>

<hr>
<h2 id='kappasb'>Coefficients of an extended Shapiro-Botha variogram model</h2><span id='topic+kappasb'></span>

<h3>Description</h3>

<p>Computes the coefficients of an extended Shapiro-Botha variogram model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappasb(x, dk = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kappasb_+3A_x">x</code></td>
<td>
<p>numeric vector (on which the kappa function will be evaluated).</p>
</td></tr>
<tr><td><code id="kappasb_+3A_dk">dk</code></td>
<td>
<p>dimension of the kappa function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>dk &gt;= 1</code>, the coefficients are computed as: 
</p>
<p style="text-align: center;"><code class="reqn">\kappa_d(x) = (2/x)^{(d-2)/2} \Gamma(d/2) J_{(d-2)/2}(x)</code>
</p>
 
<p>where <code class="reqn">J_p</code> is the Bessel function of order <code class="reqn">p</code>. 
<br /> If <code>dk == 0</code>, the coefficients are computed as: 
</p>
<p style="text-align: center;"><code class="reqn">\kappa _\infty(x) = e^{-x^2}</code>
</p>

<p>(corresponding to a model valid in any spatial dimension). 
<br /> NOTE: some authors denote these functions as <code class="reqn">\Omega_d</code>.
</p>


<h3>Value</h3>

<p>A vector with the coefficients of an extended Shapiro-Botha variogram model.
</p>


<h3>References</h3>

<p>Shapiro, A. and Botha, J.D. (1991) Variogram fitting with a general class of 
conditionally non-negative definite functions. <em>Computational Statistics 
and Data Analysis</em>, <b>11</b>, 87-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svarmod.sb.iso">svarmod.sb.iso</a></code>, <code><a href="base.html#topic+besselJ">besselJ</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappasb(seq(0, 6*pi, len = 10), 2)
  
curve(kappasb(x/5, 0), xlim = c(0, 6*pi), ylim = c(-1, 1), lty = 2)
for (i in 1:10) curve(kappasb(x, i), col = gray((i-1)/10), add = TRUE)
abline(h = 0, lty = 3)
</code></pre>

<hr>
<h2 id='locpol'>Local polynomial estimation</h2><span id='topic+locpol'></span><span id='topic+locpol.bin-class'></span><span id='topic+locpol.bin'></span><span id='topic+locpol.default'></span><span id='topic+locpol.bin.data'></span><span id='topic+locpol.svar.bin'></span><span id='topic+locpol.bin.den'></span><span id='topic+locpolhcv'></span>

<h3>Description</h3>

<p>Estimates a multidimensional regression function (and its first derivatives) 
using local polynomial kernel smoothing (and linear binning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locpol(x, ...)

## Default S3 method:
locpol(
  x,
  y,
  h = NULL,
  nbin = NULL,
  degree = 1 + as.numeric(drv),
  drv = FALSE,
  hat.bin = FALSE,
  ncv = 0,
  set.NA = FALSE,
  ...
)

## S3 method for class 'bin.data'
locpol(
  x,
  h = NULL,
  degree = 1 + as.numeric(drv),
  drv = FALSE,
  hat.bin = FALSE,
  ncv = 0,
  ...
)

## S3 method for class 'svar.bin'
locpol(x, h = NULL, degree = 1, drv = FALSE, hat.bin = TRUE, ncv = 0, ...)

## S3 method for class 'bin.den'
locpol(x, h = NULL, degree = 1 + as.numeric(drv), drv = FALSE, ncv = 0, ...)

locpolhcv(
  x,
  y,
  nbin = NULL,
  objective = c("CV", "GCV", "MASE"),
  degree = 1 + as.numeric(drv),
  drv = FALSE,
  hat.bin = FALSE,
  set.NA = FALSE,
  ncv = ifelse(objective == "CV", 2, 0),
  cov.dat = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locpol_+3A_x">x</code></td>
<td>
<p>a (data) object used to select a method.</p>
</td></tr>
<tr><td><code id="locpol_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (e.g. to <code><a href="#topic+hcv.data">hcv.data</a></code>).</p>
</td></tr>
<tr><td><code id="locpol_+3A_y">y</code></td>
<td>
<p>vector of data (response variable).</p>
</td></tr>
<tr><td><code id="locpol_+3A_h">h</code></td>
<td>
<p>(full) bandwidth matrix (controls the degree of smoothing;
only the upper triangular part of h is used).</p>
</td></tr>
<tr><td><code id="locpol_+3A_nbin">nbin</code></td>
<td>
<p>vector with the number of bins on each dimension.</p>
</td></tr>
<tr><td><code id="locpol_+3A_degree">degree</code></td>
<td>
<p>degree of the local polynomial used. Defaults to 1 (local linear estimation).</p>
</td></tr>
<tr><td><code id="locpol_+3A_drv">drv</code></td>
<td>
<p>logical; if <code>TRUE</code>, the matrix of estimated first derivatives is returned.</p>
</td></tr>
<tr><td><code id="locpol_+3A_hat.bin">hat.bin</code></td>
<td>
<p>logical; if <code>TRUE</code>, the hat matrix of the binned data is returned.</p>
</td></tr>
<tr><td><code id="locpol_+3A_ncv">ncv</code></td>
<td>
<p>integer; determines the number of cells leaved out in each dimension.
Defaults to 0 (the full data is used) and it is not normally changed by the user
in this setting. See &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="locpol_+3A_set.na">set.NA</code></td>
<td>
<p>logical. If <code>TRUE</code>, sets the bin averages corresponding
to cells without data to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="locpol_+3A_objective">objective</code></td>
<td>
<p>character; optimal criterion to be used (&quot;CV&quot;, &quot;GCV&quot; or &quot;MASE&quot;).</p>
</td></tr>
<tr><td><code id="locpol_+3A_cov.dat">cov.dat</code></td>
<td>
<p>covariance matrix of the data or semivariogram model
(of class extending <code><a href="#topic+svarmod">svarmod</a></code>). Defaults to the identity matrix
(uncorrelated data).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard generic function with a default method (interface to the
fortran routine <code>lp_raw</code>), in which argument <code>x</code> 
is a vector or matrix of covariates (e.g. spatial coordinates).
</p>
<p>If parameter <code>nbin</code> is not specified is set to <code>pmax(25, rule.binning(x))</code>.
</p>
<p>A multiplicative triweight kernel is used to compute the weights.
</p>
<p>If <code>ncv &gt; 0</code>, estimates are computed by leaving out cells with indexes within 
the intervals <code class="reqn">[x_i - ncv + 1, x_i + ncv - 1]</code>, at each dimension i, where <code class="reqn">x</code> 
denotes the index of the estimation position. <code class="reqn">ncv = 1</code> corresponds with 
traditional cross-validation and <code class="reqn">ncv &gt; 1</code> with modified CV 
(see e.g. Chu and Marron, 1991, for the one dimensional case).
</p>
<p>Setting <code>set.NA = TRUE</code> (equivalent to <code>biny[binw == 0] &lt;- NA</code>) 
may be useful for plotting the binned averages <code>$biny</code>
(the hat matrix should be handled with care).
</p>
<p><code>locpolhcv</code> calls <code><a href="#topic+hcv.data">hcv.data</a></code> to obtain an &quot;optimal&quot; 
bandwith (additional arguments <code>...</code> are passed to this function). 
Argument <code>ncv</code> is only used here at the bandwith
selection stage (estimation is done with all the data).
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>locpol.bin</code> (locpol + bin data + grid par.). 
A <code><a href="#topic+bin.data">bin.data</a></code> object with the additional (some optional) 3 components:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>vector or array (dimension <code>nbin</code>) with the local polynomial estimates. </p>
</td></tr>
<tr><td><code>locpol</code></td>
<td>
<p>a list with 7 components:
</p>

<ul>
<li><p><code>degree</code> degree of the polinomial.
</p>
</li>
<li><p><code>h</code> bandwidth matrix.
</p>
</li>
<li><p><code>rm</code> residual mean.
</p>
</li>
<li><p><code>rss</code> sum of squared residuals.
</p>
</li>
<li><p><code>ncv</code> number of cells ignored in each direction.
</p>
</li>
<li><p><code>hat</code> (if requested) hat matrix of the binned data.
</p>
</li>
<li><p><code>nrl0</code> (if appropriate) number of cells with data (<code>binw &gt; 0</code>) 
and missing estimate (<code>est == NA</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code>deriv</code></td>
<td>
<p>(if requested) matrix of first derivatives.</p>
</td></tr>
</table>
<p><code>locpol.svar.bin</code> returns an S3 object of class <code><a href="#topic+np.svar">np.svar</a></code> 
(locpol semivar + bin semivar + grid par.).
</p>
<p><code>locpol.bin.den</code> returns an S3 object of class <code><a href="#topic+np.den">np.den</a></code> 
(locpol den + bin den + grid par.).
</p>


<h3>References</h3>

<p>Chu, C.K. and Marron, J.S. (1991) Comparison of Two Bandwidth Selectors
with Dependent Errors. <em>The Annals of Statistics</em>, <b>19</b>, 1906-1918.
</p>
<p>Rupert D. and Wand M.P. (1994) Multivariate locally weighted least squares regression.
<em>The Annals of Statistics</em>, <b>22</b>, 1346-1370.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binning">binning</a></code>, <code><a href="#topic+data.grid">data.grid</a></code>, 
<code><a href="#topic+np.svariso">np.svariso</a></code>, <code><a href="#topic+svar.bin">svar.bin</a></code>,
<code><a href="#topic+np.den">np.den</a></code>, <code><a href="#topic+bin.den">bin.den</a></code>, <code><a href="#topic+hcv.data">hcv.data</a></code>,
<code><a href="#topic+rule.binning">rule.binning</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lp &lt;- locpol(earthquakes[, c("lon", "lat")], earthquakes$mag, h = diag(2, 2), nbin = c(41,41))
simage(lp, main = "Smoothed magnitude")
contour(lp, add = TRUE)

bin &lt;- binning(earthquakes[, c("lon", "lat")], earthquakes$mag, nbin = c(41,41))
lp2 &lt;- locpol(bin, h = diag(2, 2))
all.equal(lp, lp2)

den &lt;- locpol(as.bin.den(bin), h = diag(1, 2))
plot(den, log = FALSE, main = 'Estimated density')
</code></pre>

<hr>
<h2 id='mask'>Mask methods</h2><span id='topic+mask'></span><span id='topic+mask.default'></span><span id='topic+mask.data.grid'></span><span id='topic+mask.bin.den'></span><span id='topic+mask.bin.data'></span><span id='topic+mask.locpol.bin'></span>

<h3>Description</h3>

<p>Filters the data that satisfy a condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask(x, ...)

## Default S3 method:
mask(x, tol.mask = 0, ...)

## S3 method for class 'data.grid'
mask(x, mask = NULL, window = NULL, set.NA = FALSE, warn = FALSE, ...)

## S3 method for class 'bin.den'
mask(
  x,
  mask = mask.default(x$binw, npsp.tolerance(2)),
  window = NULL,
  set.NA = FALSE,
  warn = TRUE,
  ...
)

## S3 method for class 'bin.data'
mask(
  x,
  mask = NULL,
  window = NULL,
  set.NA = FALSE,
  warn = FALSE,
  filter.lp = TRUE,
  ...
)

## S3 method for class 'locpol.bin'
mask(
  x,
  mask = mask.default(x$binw, npsp.tolerance(2)),
  window = NULL,
  set.NA = FALSE,
  warn = TRUE,
  filter.lp = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask_+3A_x">x</code></td>
<td>
<p>object used to select a method (binned data, ...).</p>
</td></tr>
<tr><td><code id="mask_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="mask_+3A_tol.mask">tol.mask</code></td>
<td>
<p>tolerance.</p>
</td></tr>
<tr><td><code id="mask_+3A_mask">mask</code></td>
<td>
<p>logical; vector (or array) indicating the selected values (not masked).</p>
</td></tr>
<tr><td><code id="mask_+3A_window">window</code></td>
<td>
<p>spatial window (values outside this window will be masked), currently an sp-object of class 
extending <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a></code>.</p>
</td></tr>
<tr><td><code id="mask_+3A_set.na">set.NA</code></td>
<td>
<p>logical; If <code>TRUE</code>, the values corresponding
to masked cells are set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="mask_+3A_warn">warn</code></td>
<td>
<p>logical; If <code>TRUE</code> a warning message is generated when original data is masked.</p>
</td></tr>
<tr><td><code id="mask_+3A_filter.lp">filter.lp</code></td>
<td>
<p>logical; If <code>TRUE</code>, masked nodes will be leaved out
in local polynomial estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mask.default</code> returns the logical vector <code>x &gt; tol.mask</code>.
</p>
<p><code>mask.bin.den</code>, <code>mask.bin.data</code> and <code>mask.locpol.bin</code>
return an object of the same class as <code>x</code> with the additional component <code>$mask</code>
and optionally <code>$window</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+locpolhcv">locpolhcv</a></code>, <code><a href="#topic+binning">binning</a></code>,
<code><a href="#topic+np.svar">np.svar</a></code>, <code><a href="#topic+npsp.tolerance">npsp.tolerance</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mask(1:10, 5)
bin &lt;- binning(aquifer[,1:2], aquifer$head, nbin = c(41,41), set.NA = TRUE)
str(mask(bin, mask(bin$binw), warn = TRUE))
str(mask(bin, mask(bin$binw, 1)))
</code></pre>

<hr>
<h2 id='np.den'>Local polynomial density estimation</h2><span id='topic+np.den'></span><span id='topic+np.den-class'></span><span id='topic+np.den.default'></span><span id='topic+np.den.bin.den'></span><span id='topic+np.den.bin.data'></span><span id='topic+np.den.svar.bin'></span>

<h3>Description</h3>

<p>Estimates a multidimensional probability density function (and its first derivatives) 
using local polynomial kernel smoothing of linearly binned data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.den(x, ...)

## Default S3 method:
np.den(
  x,
  nbin = NULL,
  h = NULL,
  degree = 1 + as.numeric(drv),
  drv = FALSE,
  ncv = 0,
  ...
)

## S3 method for class 'bin.den'
np.den(x, h = NULL, degree = 1 + as.numeric(drv), drv = FALSE, ncv = 0, ...)

## S3 method for class 'bin.data'
np.den(x, h = NULL, degree = 1 + as.numeric(drv), drv = FALSE, ncv = 0, ...)

## S3 method for class 'svar.bin'
np.den(x, h = NULL, degree = 1 + as.numeric(drv), drv = FALSE, ncv = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="np.den_+3A_x">x</code></td>
<td>
<p>a (data) object used to select a method.</p>
</td></tr>
<tr><td><code id="np.den_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="np.den_+3A_nbin">nbin</code></td>
<td>
<p>vector with the number of bins on each dimension.</p>
</td></tr>
<tr><td><code id="np.den_+3A_h">h</code></td>
<td>
<p>(full) bandwidth matrix (controls the degree of smoothing;
only the upper triangular part of h is used).</p>
</td></tr>
<tr><td><code id="np.den_+3A_degree">degree</code></td>
<td>
<p>degree of the local polynomial used. Defaults to 1 (local linear estimation).</p>
</td></tr>
<tr><td><code id="np.den_+3A_drv">drv</code></td>
<td>
<p>logical; if <code>TRUE</code>, the matrix of estimated first derivatives is returned.</p>
</td></tr>
<tr><td><code id="np.den_+3A_ncv">ncv</code></td>
<td>
<p>integer; determines the number of cells leaved out in each dimension.
Defaults to 0 (the full data is used) and it is not normally changed by the user
in this setting. See &quot;Details&quot; below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard generic function with a default method (interface to the 
fortran routine <code>lp_data_grid</code>), in which argument <code>x</code> 
is a vector or matrix of covariates (e.g. spatial coordinates).
In this case, the data are binned (calls <code><a href="#topic+bin.den">bin.den</a></code>) and the local fitting
procedure is applied to the scaled bin counts (calls <code><a href="#topic+np.den.bin.den">np.den.bin.den</a></code>).
</p>
<p>If parameter <code>nbim</code> is not specified is set to <code>rep(25, ncol(x))</code>. 
</p>
<p>A multiplicative triweight kernel is used to compute the weights.
</p>
<p>If <code>ncv &gt; 1</code>, estimates are computed by leaving out cells with indexes within 
the intervals <code class="reqn">[x_i - ncv + 1, x_i + ncv - 1]</code>, at each dimension i, where <code class="reqn">x</code> 
denotes the index of the estimation position.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>np.den</code> (locpol den + bin den + grid par.). 
A <code><a href="#topic+bin.den">bin.den</a></code> object with the additional (some optional) 3 components:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>vector or array (dimension <code>nbin</code>) with the local polynomial density estimates. </p>
</td></tr>
<tr><td><code>locpol</code></td>
<td>
<p>a list with 6 components:
</p>

<ul>
<li><p><code>degree</code> degree of the polinomial.
</p>
</li>
<li><p><code>h</code> bandwidth matrix.
</p>
</li>
<li><p><code>rm</code> residual mean (of the escaled bin counts).
</p>
</li>
<li><p><code>rss</code> sum of squared residuals (of the escaled bin counts).
</p>
</li>
<li><p><code>ncv</code> number of cells ignored (in each dimension).
</p>
</li></ul>
</td></tr>
<tr><td><code>deriv</code></td>
<td>
<p>(if requested) matrix of first derivatives.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wand, M.P. and Jones, M.C. (1995) <em>Kernel Smoothing</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bin.den">bin.den</a></code>, <code><a href="#topic+binning">binning</a></code>, <code><a href="#topic+h.cv">h.cv</a></code>, 
<code><a href="#topic+data.grid">data.grid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin.den &lt;- binning(earthquakes[, c("lon", "lat")], nbin = c(30,30))
h.den &lt;- h.cv(bin.den) 
den &lt;- np.den(bin.den, h = h.den$h)
plot(den, main = 'Estimated log(density)')
</code></pre>

<hr>
<h2 id='np.fitgeo'>Fit a nonparametric geostatistical model</h2><span id='topic+np.fitgeo'></span><span id='topic+np.fitgeo.default'></span><span id='topic+np.fitgeo.locpol.bin'></span><span id='topic+np.fitgeo.fitgeo'></span>

<h3>Description</h3>

<p>Fits a nonparametric (isotropic) geostatistical model 
(jointly estimates the trend and the variogram) by calling 
<code><a href="#topic+locpol">locpol</a></code>,  <code><a href="#topic+np.svariso.corr">np.svariso.corr</a></code> (or <code><a href="#topic+np.svariso">np.svariso</a></code> ) and 
<code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code> iteratively. 
At each iteration, the trend estimation bandwith is updated 
by a call to <code><a href="#topic+h.cv">h.cv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.fitgeo(x, ...)

## Default S3 method:
np.fitgeo(
  x,
  y,
  nbin = NULL,
  iter = 2,
  h = NULL,
  tol = 0.05,
  set.NA = FALSE,
  h.svar = NULL,
  corr.svar = iter &gt; 0,
  maxlag = NULL,
  nlags = NULL,
  dk = 0,
  svm.resid = FALSE,
  hat.bin = corr.svar,
  warn = FALSE,
  plot = FALSE,
  window = NULL,
  ...
)

## S3 method for class 'locpol.bin'
np.fitgeo(
  x,
  svm,
  iter = 1,
  tol = 0.05,
  h.svar = svm$esv$locpol$h,
  dk = 0,
  corr.svar = TRUE,
  svm.resid = FALSE,
  hat.bin = corr.svar,
  warn = FALSE,
  plot = FALSE,
  ...
)

## S3 method for class 'fitgeo'
np.fitgeo(
  x,
  iter = 1,
  tol = 0.05,
  h.svar = x$svm$esv$locpol$h,
  dk = x$svm$par$dk,
  corr.svar = TRUE,
  svm.resid = FALSE,
  hat.bin = corr.svar,
  warn = FALSE,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="np.fitgeo_+3A_x">x</code></td>
<td>
<p>a (data) object used to select a method.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+h.cv">h.cv</a></code>
(trend bandwidth selection parameters).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_y">y</code></td>
<td>
<p>vector of data (response variable).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_nbin">nbin</code></td>
<td>
<p>vector with the number of bins on each dimension.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations (of the whole algorithm).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_h">h</code></td>
<td>
<p>initial bandwidth matrix for trend estimation
(final bandwidth if <code>iter = 1</code>).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_tol">tol</code></td>
<td>
<p>relative convergence tolerance (semivariogram).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_set.na">set.NA</code></td>
<td>
<p>logical. If <code>TRUE</code>, sets the bin averages corresponding
to cells without data to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_h.svar">h.svar</code></td>
<td>
<p>bandwidth matrix for variogram estimation.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_corr.svar">corr.svar</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), a bias-corrected semivariogram estimate 
is computed (see <code><a href="#topic+np.svariso.corr">np.svariso.corr</a></code>). 
If <code>FALSE</code> the (uncorrected) residual variogram is computed
(the traditional approach in geostatistics).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_maxlag">maxlag</code></td>
<td>
<p>maximum lag. Defaults to 55% of largest lag.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_nlags">nlags</code></td>
<td>
<p>number of lags. Defaults to 101.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_dk">dk</code></td>
<td>
<p>dimension of the Shapiro-Botha variogram model (see <code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code>).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_svm.resid">svm.resid</code></td>
<td>
<p>logical; if <code>TRUE</code>, the fitted (uncorrected) residual semivariogram model
is computed and returned (this parameter has no effect when <code>corr.svar = FALSE</code>).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_hat.bin">hat.bin</code></td>
<td>
<p>logical; if <code>TRUE</code>, the hat matrix of the binned data is returned.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_warn">warn</code></td>
<td>
<p>logical; sets the handling of warning messages in bandwidth selection (<code><a href="#topic+h.cv">h.cv</a></code>).</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>TRUE</code>, semivariogram estimates obtained at each iteration are plotted.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_window">window</code></td>
<td>
<p>spatial window (values outside this window will be masked), currently an sp-object of class 
extending <code><a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a></code>.</p>
</td></tr>
<tr><td><code id="np.fitgeo_+3A_svm">svm</code></td>
<td>
<p>(fitted) variogram model (object of class 
<code><a href="#topic+fitsvar">fitsvar</a></code> or <code><a href="#topic+svarmod">svarmod</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only isotropic semivariogram estimation is supported.
</p>
<p>If parameter <code>h</code> is not specified,
<code><a href="#topic+h.cv">h.cv</a></code> is called with the default values (modified CV) to set it.
If parameter <code>h.svar</code> is not specified,
is set to <code>1.5*h.cv.svar.bin()$h</code>.
</p>
<p>Setting <code>corr.svar = TRUE</code> may be very slow (and memory demanding) when the number of data is large 
(note also that the bias in the residual variogram decreases when the sample size increases).
</p>


<h3>Value</h3>

<p>Returns an object of <code><a href="base.html#topic+class">class</a></code> <code>fitgeo</code> (extends 
<code><a href="#topic+np.geo">np.geo</a></code>). A <code><a href="#topic+locpol.bin">locpol.bin</a></code> object with the additional 
(some optional) 3 components:
</p>
<table role = "presentation">
<tr><td><code>svm</code></td>
<td>
<p>fitted variogram model (object of class 
<code><a href="#topic+fitsvar">fitsvar</a></code>).</p>
</td></tr>
<tr><td><code>svm0</code></td>
<td>
<p>(if requested) fitted residual variogram model (object of class 
<code><a href="#topic+fitsvar">fitsvar</a></code>).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>model residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code>, <code><a href="#topic+np.svar">np.svar</a></code>, 
<code><a href="#topic+np.svariso.corr">np.svariso.corr</a></code>, <code><a href="#topic+np.geo">np.geo</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
geomod &lt;- np.fitgeo(aquifer[,1:2], aquifer$head, svm.resid = TRUE)
plot(geomod)


# Uncorrected variogram estimator
geomod0 &lt;- np.fitgeo(aquifer[,1:2], aquifer$head, iter = 0, corr.svar = FALSE)
plot(geomod0)

# Additional iteration with bias-corrected variogram estimator
geomod1 &lt;- np.fitgeo(geomod0, corr.svar = TRUE, svm.resid = TRUE)
plot(geomod1)

</code></pre>

<hr>
<h2 id='np.geo'>Nonparametric geostatistical model (S3 class &quot;np.geo&quot;)</h2><span id='topic+np.geo'></span><span id='topic+np.geo-class+2C'></span><span id='topic+fitgeo-class'></span>

<h3>Description</h3>

<p>Defines a nonparametric geostatistical model 
(not intended to be used regularly; see <code><a href="#topic+np.fitgeo">np.fitgeo</a></code>). 
Constructor function of the <code>np.geo</code> and <code>fitgeo</code> S3 <code><a href="base.html#topic+class">class</a></code>es.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.geo(lp, svm, svm0 = NULL, nbin = lp$grid$n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="np.geo_+3A_lp">lp</code></td>
<td>
<p>local polynomial estimate of the trend function (object of class 
<code><a href="#topic+locpol.bin">locpol.bin</a></code>).</p>
</td></tr>
<tr><td><code id="np.geo_+3A_svm">svm</code></td>
<td>
<p>(fitted) variogram model (object of class 
<code><a href="#topic+fitsvar">fitsvar</a></code> or <code><a href="#topic+svarmod">svarmod</a></code>).</p>
</td></tr>
<tr><td><code id="np.geo_+3A_svm0">svm0</code></td>
<td>
<p>(fitted) residual variogram model (object of class 
<code><a href="#topic+fitsvar">fitsvar</a></code> or <code><a href="#topic+svarmod">svarmod</a></code>).</p>
</td></tr>
<tr><td><code id="np.geo_+3A_nbin">nbin</code></td>
<td>
<p>number of bins on each dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="base.html#topic+class">class</a></code> <code>np.geo</code>
(extends <code><a href="#topic+locpol.bin">locpol.bin</a></code>), the <code>lp</code> argument with 
the others and the vector of residuals as additional components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+np.fitgeo">np.fitgeo</a></code>, <code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code>.
</p>

<hr>
<h2 id='np.kriging'>Nonparametric (residual) kriging</h2><span id='topic+np.kriging'></span><span id='topic+kriging'></span><span id='topic+np.kriging.default'></span><span id='topic+np.kriging.np.geo'></span><span id='topic+kriging.simple'></span>

<h3>Description</h3>

<p>Compute simple kriging or residual kriging predictions 
(and also the corresponding simple kriging standard errors  
). Currently, only global (residual) simple kriging is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.kriging(object, ...)

## Default S3 method:
np.kriging(
  object,
  svm,
  lp.resid = NULL,
  ngrid = object$grid$n,
  intermediate = FALSE,
  ...
)

## S3 method for class 'np.geo'
np.kriging(object, ngrid = object$grid$n, intermediate = FALSE, ...)

kriging.simple(x, y, newx, svm, intermediate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="np.kriging_+3A_object">object</code></td>
<td>
<p>object used to select a method: 
local polynomial estimate of the trend (class <code><a href="#topic+locpol.bin">locpol.bin</a></code>) 
or nonparametric geostatistical model (class extending <code><a href="#topic+np.geo">np.geo</a></code>).</p>
</td></tr>
<tr><td><code id="np.kriging_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="np.kriging_+3A_svm">svm</code></td>
<td>
<p>semivariogram model (of class extending <code><a href="#topic+svarmod">svarmod</a></code>).</p>
</td></tr>
<tr><td><code id="np.kriging_+3A_lp.resid">lp.resid</code></td>
<td>
<p>residuals (defaults to <code>residuals(object)</code>).</p>
</td></tr>
<tr><td><code id="np.kriging_+3A_ngrid">ngrid</code></td>
<td>
<p>number of grid nodes in each dimension.</p>
</td></tr>
<tr><td><code id="np.kriging_+3A_intermediate">intermediate</code></td>
<td>
<p>logical, determines whether the intermediate computations 
are included in the output (component <code>kriging</code>; see Value). 
These calculations can be reused, e.g. for bootstrap.</p>
</td></tr>
<tr><td><code id="np.kriging_+3A_x">x</code></td>
<td>
<p>vector/matrix with data locations
(each component/row is an observation location).</p>
</td></tr>
<tr><td><code id="np.kriging_+3A_y">y</code></td>
<td>
<p>vector of data (response variable).</p>
</td></tr>
<tr><td><code id="np.kriging_+3A_newx">newx</code></td>
<td>
<p>vector/matrix with the (irregular) locations to predict 
(each component/row is a prediction location). 
or an object extending <code><a href="#topic+grid.par">grid.par</a></code>-<code><a href="base.html#topic+class">class</a></code>
(<code><a href="#topic+data.grid">data.grid</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>np.kriging()</code>, and <code>kriging.simple()</code> when <code>newx</code> defines 
gridded data (extends <code>grid.par</code> or <code>data.grid</code> classes),
returns an S3 object of class <code>krig.grid</code> (kriging results + grid par.). 
A <code><a href="#topic+data.grid">data.grid</a></code> object with the additional (some optional) components:
</p>
<table role = "presentation">
<tr><td><code>kpred</code></td>
<td>
<p>vector or array (dimension <code>$grid$n</code>) with the kriging predictions. </p>
</td></tr>
<tr><td><code>ksd</code></td>
<td>
<p>vector or array with the kriging standard deviations. </p>
</td></tr>
<tr><td><code>kriging</code></td>
<td>
<p>(if requested) a list with 4 components:
</p>

<ul>
<li><p><code>lambda</code> matrix of kriging weights (columns correspond with predictions 
and rows with data)).
</p>
</li>
<li><p><code>cov.est</code> (estimated) covariance matrix of the data.
</p>
</li>
<li><p><code>chol</code> Cholesky factorization of <code>cov.est</code>.
</p>
</li>
<li><p><code>cov.pred</code> matrix of (estimated) covariances between data (rows) 
and predictions (columns).
</p>
</li></ul>
</td></tr>
</table>
<p>When <code>newx</code> is a matrix of coordinates (where each row is a prediction location),
<code>kriging.simple()</code> returns a list with the previous components (<code>kpred</code>, <code>ksd</code> 
and, if requested, <code>kriging</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+np.fitgeo">np.fitgeo</a></code>, <code><a href="#topic+locpol">locpol</a></code>, <code><a href="#topic+np.svar">np.svar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geomod &lt;- np.fitgeo(aquifer[,1:2], aquifer$head)
krig.grid &lt;- np.kriging(geomod, ngrid = c(96, 96)) # 9216 locations
old.par &lt;- par(mfrow = c(1,2))
simage(krig.grid, 'kpred', main = 'Kriging predictions', 
       xlab = "Longitude", ylab = "Latitude", reset = FALSE )
simage(krig.grid, 'ksd', main = 'Kriging sd', xlab = "Longitude", 
       ylab = "Latitude" , col = hot.colors(256), reset = FALSE)
par(old.par)
</code></pre>

<hr>
<h2 id='np.svar'>Local polynomial estimation of the semivariogram</h2><span id='topic+np.svar'></span><span id='topic+np.svar-class'></span><span id='topic+np.svar.default'></span><span id='topic+iso.np.svar'></span><span id='topic+np.svar.svar.bin'></span><span id='topic+np.svariso'></span><span id='topic+np.svariso.hcv'></span><span id='topic+np.svariso.corr'></span>

<h3>Description</h3>

<p>Estimates a multidimensional semivariogram (and its first derivatives) 
using local polynomial kernel smoothing of linearly binned semivariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.svar(x, ...)

## Default S3 method:
np.svar(
  x,
  y,
  h = NULL,
  maxlag = NULL,
  nlags = NULL,
  minlag = maxlag/nlags,
  degree = 1,
  drv = FALSE,
  hat.bin = TRUE,
  ncv = 0,
  ...
)

## S3 method for class 'svar.bin'
np.svar(x, h = NULL, degree = 1, drv = FALSE, hat.bin = TRUE, ncv = 0, ...)

np.svariso(
  x,
  y,
  h = NULL,
  maxlag = NULL,
  nlags = NULL,
  minlag = maxlag/nlags,
  degree = 1,
  drv = FALSE,
  hat.bin = TRUE,
  ncv = 0,
  ...
)

np.svariso.hcv(
  x,
  y,
  maxlag = NULL,
  nlags = NULL,
  minlag = maxlag/nlags,
  degree = 1,
  drv = FALSE,
  hat.bin = TRUE,
  loss = c("MRSE", "MRAE", "MSE", "MAE"),
  ncv = 1,
  warn = FALSE,
  ...
)

np.svariso.corr(
  lp,
  x = lp$data$x,
  h = NULL,
  maxlag = NULL,
  nlags = NULL,
  minlag = maxlag/nlags,
  degree = 1,
  drv = FALSE,
  hat.bin = TRUE,
  tol = 0.05,
  max.iter = 10,
  plot = FALSE,
  verbose = plot,
  ylim = c(0, 2 * max(svar$biny, na.rm = TRUE))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="np.svar_+3A_x">x</code></td>
<td>
<p>object used to select a method. Usually a matrix with the 
coordinates of the data locations (columns correspond with dimensions and 
rows with data).</p>
</td></tr>
<tr><td><code id="np.svar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_y">y</code></td>
<td>
<p>vector of data (response variable).</p>
</td></tr>
<tr><td><code id="np.svar_+3A_h">h</code></td>
<td>
<p>(full) bandwidth matrix (controls the degree of smoothing;
only the upper triangular part of h is used).</p>
</td></tr>
<tr><td><code id="np.svar_+3A_maxlag">maxlag</code></td>
<td>
<p>maximum lag. Defaults to 55% of largest lag.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_nlags">nlags</code></td>
<td>
<p>number of lags. Defaults to 101.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_minlag">minlag</code></td>
<td>
<p>minimun lag.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_degree">degree</code></td>
<td>
<p>degree of the local polynomial used. Defaults to 1 (local linear estimation).</p>
</td></tr>
<tr><td><code id="np.svar_+3A_drv">drv</code></td>
<td>
<p>logical; if <code>TRUE</code>, the matrix of estimated first derivatives is returned.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_hat.bin">hat.bin</code></td>
<td>
<p>logical; if <code>TRUE</code>, the hat matrix of the binned semivariances is returned.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_ncv">ncv</code></td>
<td>
<p>integer; determines the number of cells leaved out in each dimension.
Defaults to 0 (the full data is used) and it is not normally changed by the user
in this setting. See &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_loss">loss</code></td>
<td>
<p>character; CV error. See &quot;Details&quot; bellow.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_warn">warn</code></td>
<td>
<p>logical; sets the handling of warning messages
(normally due to the lack of data in some neighborhoods).
If <code>FALSE</code> all warnings are ignored.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_lp">lp</code></td>
<td>
<p>local polynomial estimate of the trend function (object of class 
<code><a href="#topic+locpol.bin">locpol.bin</a></code>).</p>
</td></tr>
<tr><td><code id="np.svar_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance. The algorithm stops if the average of the 
relative squared diferences is less than <code>tol</code>. Defaults to 0.04.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations. Defaults to 10.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>TRUE</code>, the estimates obtained at each iteration 
are plotted.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, the errors (averages of the 
relative squared differences) at each iteration are printed.</p>
</td></tr>
<tr><td><code id="np.svar_+3A_ylim">ylim</code></td>
<td>
<p>y-limits of the plot (if <code>plot == TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only isotropic semivariogram estimation is supported.
</p>
<p>If parameter <code>nlags</code> is not specified is set to <code>101</code>.
</p>
<p>The computation of the hat matrix of the binned semivariances (<code>hat.bin = TRUE</code>)
allows for the computation of approximated estimation variances (e.g. in <code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code>).
</p>
<p>A multiplicative triweight kernel is used to compute the weights.
</p>
<p><code>np.svariso.hcv</code> calls <code><a href="#topic+h.cv">h.cv</a></code> to obtain an &quot;optimal&quot; 
bandwith (additional arguments <code>...</code> are passed to this function). 
Argument <code>ncv</code> is only used here at the bandwith selection stage 
(estimation is done with all the data).
</p>
<p><code>np.svariso.corr</code> computes a bias-corrected nonparametric semivariogram 
estimate using an iterative algorithm similar to that described in  
Fernandez-Casal and Francisco-Fernandez (2014). This procedure tries to correct
the bias due to the direct use of residuals (obtained in this case from a 
nonparametric estimation of the trend function) in semivariogram estimation.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>np.svar</code> (locpol svar + binned svar + grid par.), 
extends <code><a href="#topic+svar.bin">svar.bin</a></code>, with the additional (some optional) 3 components:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>vector or array with the 
local polynomial semivariogram estimates. </p>
</td></tr>
<tr><td><code>locpol</code></td>
<td>
<p>a list of 6 components:
</p>

<ul>
<li><p><code>degree</code> degree of the local polinomial used.
</p>
</li>
<li><p><code>h</code> smoothing matrix.
</p>
</li>
<li><p><code>rm</code> mean of residual semivariances.
</p>
</li>
<li><p><code>rss</code> sum of squared residual semivariances.
</p>
</li>
<li><p><code>ncv</code> number of cells ignored in each direction.
</p>
</li>
<li><p><code>hat</code> (if requested) hat matrix of the binned semivariances.
</p>
</li>
<li><p><code>nrl0</code> (if appropriate) number of cells with <code>binw &gt; 0</code> 
and <code>est == NA</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code>deriv</code></td>
<td>
<p>(if requested) matrix of estimated first semivariogram derivatives.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fernandez Casal R., Gonzalez Manteiga W. and  Febrero Bande M. (2003) 
Space-time dependency modeling using general classes of flexible stationary 
variogram models, <em>J. Geophys. Res.</em>, <b>108</b>, 8779, 
doi:10.1029/2002JD002909.
</p>
<p>Garcia-Soidan P.H., Gonzalez-Manteiga W. and Febrero-Bande M. (2003) 
Local linear regression estimation of the variogram, 
<em>Stat. Prob. Lett.</em>, <b>64</b>, 169-179.
</p>
<p>Fernandez-Casal R. and Francisco-Fernandez M. (2014) 
Nonparametric bias-corrected variogram estimation under non-constant trend, 
<em>Stoch. Environ. Res. Ris. Assess</em>, <b>28</b>, 1247-1259.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svar.bin">svar.bin</a></code>, <code><a href="#topic+data.grid">data.grid</a></code>, <code><a href="#topic+locpol">locpol</a></code>.
</p>

<hr>
<h2 id='npsp-geoR'>Interface to package &quot;geoR&quot;</h2><span id='topic+npsp-geoR'></span><span id='topic+as.variogram'></span><span id='topic+variogram'></span><span id='topic+as.variogram.svar.bin'></span><span id='topic+as.variogram.np.svar'></span><span id='topic+as.variomodel'></span><span id='topic+variomodel'></span><span id='topic+as.variomodel.svarmod'></span>

<h3>Description</h3>

<p>Utilities to interact with the <span class="pkg">geoR</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.variogram(x, ...)

## S3 method for class 'svar.bin'
as.variogram(x, ...)

## S3 method for class 'np.svar'
as.variogram(x, ...)

as.variomodel(m, ...)

## S3 method for class 'svarmod'
as.variomodel(m, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npsp-geoR_+3A_x">x</code></td>
<td>
<p>semivariogram estimate (e.g. <code><a href="#topic+svar.bin">svar.bin</a></code> or <code><a href="#topic+np.svar">np.svar</a></code> object).</p>
</td></tr>
<tr><td><code id="npsp-geoR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="npsp-geoR_+3A_m">m</code></td>
<td>
<p>variogram model (e.g. <code><a href="#topic+svarmod">svarmod</a></code> object).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.variogram</code> tries to convert a semivariogram estimate <code class="reqn">\hat{\gamma}(h_i)</code> 
to an object of the (not fully documented) <span class="pkg">geoR</span>-class <code>variogram</code> 
(see e.g. <code><a href="geoR.html#topic+variog">variog</a></code>).
</p>
<p><code>as.variomodel</code> tries to convert a semivariogram model <code class="reqn">\gamma(pars; h)</code> 
to an object of the <span class="pkg">geoR</span>-class <code>variomodel</code> 
(see e.g. <code><a href="geoR.html#topic+variofit">variofit</a></code>).
</p>


<h3>Value</h3>

<p><code>as.variogram()</code> returns an object of the (not fully documented) <span class="pkg">geoR</span>-class 
<code>variogram</code>.
</p>
<p><code>as.variomodel()</code> returns an object of the <span class="pkg">geoR</span>-class <code>variomodel</code>.
</p>


<h3>See Also</h3>

<p><code><a href="geoR.html#topic+variog">variog</a></code>, <code><a href="geoR.html#topic+variofit">variofit</a></code>, <code><a href="#topic+variomodel">variomodel</a></code>, 
<code><a href="#topic+svar.bin">svar.bin</a></code>, <code><a href="#topic+np.svar">np.svar</a></code>.
</p>

<hr>
<h2 id='npsp-gstat'>Interface to package &quot;gstat&quot;</h2><span id='topic+npsp-gstat'></span><span id='topic+as.vgm'></span><span id='topic+as.vgm.variomodel'></span><span id='topic+as.vgm.svarmod'></span><span id='topic+vgm.tab.svarmod'></span><span id='topic+as.vgm.sb.iso'></span>

<h3>Description</h3>

<p>Utilities to interact with the <span class="pkg">gstat</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.vgm(x, ...)

## S3 method for class 'variomodel'
as.vgm(x, ...)

## S3 method for class 'svarmod'
as.vgm(x, ...)

vgm.tab.svarmod(x, h = seq(0, x$range, length = 1000), sill = x$sill, ...)

## S3 method for class 'sb.iso'
as.vgm(x, h = seq(0, x$range, length = 1000), sill = x$sill, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npsp-gstat_+3A_x">x</code></td>
<td>
<p>variogram model object (used to select a method).</p>
</td></tr>
<tr><td><code id="npsp-gstat_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="npsp-gstat_+3A_h">h</code></td>
<td>
<p>vector of lags at which the covariogram is evaluated.</p>
</td></tr>
<tr><td><code id="npsp-gstat_+3A_sill">sill</code></td>
<td>
<p>sill of the covariogram (or pseudo-sill).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tries to convert a variogram object to <code><a href="gstat.html#topic+vgm">vgm</a></code> 
(<code>variogramModel</code>-<code><a href="base.html#topic+class">class</a></code> of <span class="pkg">gstat</span> package).
S3 generic function. 
</p>
<p><code>as.vgm.variomodel</code> tries to convert an object of class <code>variomodel</code>
defined in <span class="pkg">geoR</span> (interface to <code><a href="gstat.html#topic+vgm">as.vgm.variomodel</a></code>
defined in <span class="pkg">gstat</span>).
</p>
<p><code>vgm.tab.svarmod</code> converts a <code>svarmod</code> object to a 
<code>variogramModel</code>-<code><a href="base.html#topic+class">class</a></code> object of type <code>"Tab"</code> 
(one-dimensional covariance table).
</p>
<p><code>as.vgm.sb.iso</code> is an alias of <code>vgm.tab.svarmod</code>.
</p>


<h3>Value</h3>

<p>A <code>variogramModel</code>-<code><a href="base.html#topic+class">class</a></code> object of the <span class="pkg">gstat</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="gstat.html#topic+vgm">vgm</a></code>, <code><a href="#topic+svarmod">svarmod</a></code>.
</p>

<hr>
<h2 id='npsp.tolerance'>npsp Tolerances</h2><span id='topic+npsp.tolerance'></span>

<h3>Description</h3>

<p>Returns a (convergence, taper, approximation,...) tolerance.
Defaults to <code>.Machine$double.eps^(1/level)</code>, typically about <code>1e-8</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npsp.tolerance(level = 2, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npsp.tolerance_+3A_level">level</code></td>
<td>
<p>numerical,</p>
</td></tr>
<tr><td><code id="npsp.tolerance_+3A_warn">warn</code></td>
<td>
<p>logical; If <code>TRUE</code> (the default) a warning message is issued
when <code>level &lt; 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>.Machine$double.eps^(1/level)</code> if <code>level &gt;= 1</code>,
in other case <code>1 - .Machine$double.eps</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+.Machine">.Machine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(npsp.tolerance, 1, 1000)
abline(h = npsp.tolerance(0, FALSE), lty = 2)
</code></pre>

<hr>
<h2 id='plot.fitgeo'>Plot a nonparametric geostatistical model</h2><span id='topic+plot.fitgeo'></span>

<h3>Description</h3>

<p>Plots the trend estimates and the fitted variogram model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitgeo'
plot(x, y = NULL, main.trend = "Trend estimates", main.svar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fitgeo_+3A_x">x</code></td>
<td>
<p>a nonparametric geostatistical model object. 
Typically an output of <code><a href="#topic+np.fitgeo">np.fitgeo</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fitgeo_+3A_y">y</code></td>
<td>
<p>ignored argument.</p>
</td></tr>
<tr><td><code id="plot.fitgeo_+3A_main.trend">main.trend</code></td>
<td>
<p>title for the trend plot.</p>
</td></tr>
<tr><td><code id="plot.fitgeo_+3A_main.svar">main.svar</code></td>
<td>
<p>title for the semivariogram plot.</p>
</td></tr>
<tr><td><code id="plot.fitgeo_+3A_...">...</code></td>
<td>
<p>additional graphical parameters 
(to be passed to <code><a href="#topic+simage">simage</a></code> for trend plotting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects (generate the plot).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+np.fitgeo">np.fitgeo</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geomod &lt;- np.fitgeo(aquifer[,1:2], aquifer$head)
plot(geomod)
</code></pre>

<hr>
<h2 id='precipitation'>Precipitation data</h2><span id='topic+precipitation'></span>

<h3>Description</h3>

<p>The data set consists of total precipitations during March 2016
recorded over 1053 locations on the continental part of USA.
</p>


<h3>Format</h3>

<p>A <code><a href="sp.html#topic+SpatialGridDataFrame-class">SpatialPointsDataFrame</a></code> with 1053 observations on the 
following 6 variables:
</p>

<dl>
<dt>y</dt><dd><p>total precipitations (square-root of rainfall inches),</p>
</dd>
<dt>WBAN</dt><dd><p>five-digit Weather station identifier,</p>
</dd>
<dt>state</dt><dd><p>factor containing the U.S. state,</p>
</dd>
</dl>

<p>and the following <code><a href="base.html#topic+attributes">attributes</a></code>:
</p>

<dl>
<dt>labels</dt><dd><p>list with data and variable labels,</p>
</dd>
<dt>border</dt><dd><p><code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> with the boundary
of the continental part of USA,</p>
</dd>
<dt>interior</dt><dd><p><code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> with the U.S. state boundaries.</p>
</dd>
</dl>



<h3>Source</h3>

<p>National Climatic Data Center: <br />
<a href="https://www.ncdc.noaa.gov/cdo-web/datasets">https://www.ncdc.noaa.gov/cdo-web/datasets</a>.
</p>


<h3>References</h3>

<p>Fernandez-Casal R., Castillo-Paez S. and Francisco-Fernandez M. (2017)
Nonparametric geostatistical risk mapping, <em>Stoch. Environ. Res. Ris. Assess.</em>, 
<a href="https://doi.org/10.1007/s00477-017-1407-y">doi:10.1007/s00477-017-1407-y</a>.
</p>
<p>Fernandez-Casal R., Castillo-Paez S. and Garcia-Soidan P. (2017)
Nonparametric estimation of the small-scale variability of heteroscedastic spatial processes, 
<em>Spa. Sta.</em>, <a href="https://doi.org/10.1016/j.spasta.2017.04.001">doi:10.1016/j.spasta.2017.04.001</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(precipitation)
scattersplot(precipitation)
</code></pre>

<hr>
<h2 id='rgraphics'>R Graphics for gridded data</h2><span id='topic+rgraphics'></span><span id='topic+image.data.grid'></span><span id='topic+persp.data.grid'></span><span id='topic+contour.data.grid'></span>

<h3>Description</h3>

<p>Draw an image, perspective, contour or filled contour plot for data
on a bidimensional regular grid (S3 methods for class &quot;<code><a href="#topic+data.grid">data.grid</a></code>&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.grid'
image(
  x,
  data.ind = 1,
  xlab = NULL,
  ylab = NULL,
  useRaster = all(dim(x) &gt; dev.size("px")),
  ...
)

## S3 method for class 'data.grid'
persp(x, data.ind = 1, xlab = NULL, ylab = NULL, zlab = NULL, ...)

## S3 method for class 'data.grid'
contour(x, data.ind = 1, filled = FALSE, xlab = NULL, ylab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgraphics_+3A_x">x</code></td>
<td>
<p>a &quot;<code><a href="#topic+data.grid">data.grid</a></code>&quot;-class object.</p>
</td></tr>
<tr><td><code id="rgraphics_+3A_data.ind">data.ind</code></td>
<td>
<p>integer (or character) with the index (or name) of the component 
containing the values to be used for coloring the rectangles.</p>
</td></tr>
<tr><td><code id="rgraphics_+3A_xlab">xlab</code></td>
<td>
<p>label for the x axis, defaults to <code>dimnames(x)[1]</code>.</p>
</td></tr>
<tr><td><code id="rgraphics_+3A_ylab">ylab</code></td>
<td>
<p>label for the y axis, defaults to <code>dimnames(x)[2]</code>.</p>
</td></tr>
<tr><td><code id="rgraphics_+3A_useraster">useRaster</code></td>
<td>
<p>logical; if <code>TRUE</code> a bitmap raster is used to plot the 
image instead of polygons.</p>
</td></tr>
<tr><td><code id="rgraphics_+3A_...">...</code></td>
<td>
<p>additional graphical parameters (to be passed to main plot function).</p>
</td></tr>
<tr><td><code id="rgraphics_+3A_zlab">zlab</code></td>
<td>
<p>label for the z axis, defaults to <code>names(x)[data.ind]</code>.</p>
</td></tr>
<tr><td><code id="rgraphics_+3A_filled">filled</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), function <code><a href="graphics.html#topic+contour">contour</a></code>
is called, otherwise <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>image()</code> and <code>contour()</code> do not return any value, call for secondary 
effects (generate the corresponding plot).
<code>persp()</code> invisibly returns the viewing transformation matrix (see 
<code><a href="graphics.html#topic+persp">persp</a></code> for details), a 4 x 4 matrix that can be used to superimpose 
additional graphical elements using the function <code><a href="grDevices.html#topic+trans3d">trans3d</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>, <code><a href="#topic+data.grid">data.grid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regularly spaced 2D data
grid &lt;- grid.par(n = c(50, 50), min = c(-1, -1), max = c(1, 1))
f2d &lt;- function(x) x[1]^2 - x[2]^2
trend &lt;- apply(coords(grid), 1, f2d)
set.seed(1)
y &lt;- trend + rnorm(prod(dim(grid)), 0, 0.1)
gdata &lt;- data.grid(trend = trend, y = y, grid = grid)
# perspective plot
persp(gdata, main = 'Trend', theta = 40, phi = 20, ticktype = "detailed")
# filled contour plot
contour(gdata, main = 'Trend', filled = TRUE, color.palette = jet.colors)
# Multiple plots with a common legend:
scale.range &lt;- c(-1.2, 1.2)
scale.color &lt;- jet.colors(64)
# 1x2 plot with some room for the legend...
old.par &lt;- par(mfrow = c(1,2), omd = c(0.05, 0.85, 0.05, 0.95))
image(gdata, zlim = scale.range, main = 'Trend', col = scale.color)
contour(gdata, add = TRUE)
image(gdata, 'y', zlim = scale.range, main = 'Data', col = scale.color)
contour(gdata, 'y', add = TRUE)
par(old.par)
# the legend can be added to any plot...
splot(slim = scale.range, col = scale.color, add = TRUE)
</code></pre>

<hr>
<h2 id='rule'>npsp Rules</h2><span id='topic+rule'></span><span id='topic+rule.binning'></span><span id='topic+rule.binning.default'></span><span id='topic+rule.svar'></span><span id='topic+rule.svar.default'></span><span id='topic+rule.svar.bin.den'></span>

<h3>Description</h3>

<p>Compute the number of classes for a histogram,
the number of nodes of a binning grid, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule(x, d = 1, rule = c("Rice", "Sturges", "scott", "FD"), ...)

rule.binning(x, ...)

## Default S3 method:
rule.binning(x, d = ncol(x), a = 2, b = d + 1, ...)

rule.svar(x, ...)

## Default S3 method:
rule.svar(x, d = ncol(x), a = 2, b = d + 1, ...)

## S3 method for class 'bin.den'
rule.svar(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rule_+3A_x">x</code></td>
<td>
<p>data vector or object used to select a method.</p>
</td></tr>
<tr><td><code id="rule_+3A_d">d</code></td>
<td>
<p>(spatial) dimension.</p>
</td></tr>
<tr><td><code id="rule_+3A_rule">rule</code></td>
<td>
<p>character; rule to be used.</p>
</td></tr>
<tr><td><code id="rule_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="rule_+3A_a">a</code></td>
<td>
<p>scale values.</p>
</td></tr>
<tr><td><code id="rule_+3A_b">b</code></td>
<td>
<p>exponent values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rice Rule, <code class="reqn">m = \lceil 2 n^{1/3} \rceil,</code>
is a simple alternative to Sturges's rule (<code><a href="grDevices.html#topic+nclass.Sturges">nclass.Sturges</a></code>).
</p>


<h3>Value</h3>

<p>The rule values (vector or scalar).
</p>
<p><code>rule.binning</code> returns a vector with the suggested number of bins
on each dimension.
</p>
<p><code>rule.binning.default</code> returns <code>rep(ceiling(a * nrow(x) ^ (1 / b)), d)</code>.
</p>
<p><code>rule.svar</code> returns the suggested number of bins
for variogram estimation.
</p>
<p><code>rule.svar.default</code> returns <code>ceiling(a * (nrow(x)^2 / 4) ^ (1 / b))</code>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="grDevices.html#topic+nclass.Sturges">nclass.Sturges</a></code>, <code><a href="grDevices.html#topic+nclass.scott">nclass.scott</a></code>,
<code><a href="grDevices.html#topic+nclass.FD">nclass.FD</a></code>, 
<code><a href="#topic+binning">binning</a></code>, <code><a href="#topic+np.den">np.den</a></code>, <code><a href="#topic+bin.den">bin.den</a></code>.
</p>

<hr>
<h2 id='scattersplot'>Exploratory scatter plots</h2><span id='topic+scattersplot'></span><span id='topic+scattersplot.default'></span><span id='topic+scattersplot.SpatialPointsDataFrame'></span>

<h3>Description</h3>

<p>Draws (in a 2 by 2 layout) the following plots: 
a scatter plot with a color scale, the scatter plots of the response against the (first two) 
coordinates and the histogram of the response values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scattersplot(x, ...)

## Default S3 method:
scattersplot(
  x,
  z,
  main,
  xlab,
  ylab,
  zlab,
  col = hot.colors(128),
  lowess = TRUE,
  density = FALSE,
  omd = c(0.05, 0.95, 0.01, 0.95),
  ...
)

## S3 method for class 'SpatialPointsDataFrame'
scattersplot(
  x,
  data.ind = 1,
  main,
  xlab,
  ylab,
  zlab,
  col = hot.colors(128),
  lowess = TRUE,
  density = FALSE,
  omd = c(0.05, 0.95, 0.01, 0.95),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scattersplot_+3A_x">x</code></td>
<td>
<p>object used to select a method.</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_...">...</code></td>
<td>
<p>additional graphical parameters (to be passed to <code><a href="#topic+spoints">spoints</a></code>).</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_z">z</code></td>
<td>
<p>vector of data (response variable).</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_xlab">xlab</code></td>
<td>
<p>a title for the axis corresponding to the first coordinate.</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_ylab">ylab</code></td>
<td>
<p>a title for the axis corresponding to the second coordinate.</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_zlab">zlab</code></td>
<td>
<p>a title for the axis corresponding to the response.</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_col">col</code></td>
<td>
<p>color table used to set up the color scale (see <code><a href="#topic+spoints">spoints</a></code>).</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_lowess">lowess</code></td>
<td>
<p>logical. If <code>TRUE</code>, a <code><a href="stats.html#topic+lowess">lowess</a></code> smooth is added to 
the plots of the response against the coordinates.</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_density">density</code></td>
<td>
<p>logical. If <code>TRUE</code>, a kernel <code><a href="stats.html#topic+density">density</a></code> estimate
is added to the histogram.</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_omd">omd</code></td>
<td>
<p>a vector of the form <code>c(x1, x2, y1, y2)</code> giving the region inside outer margins 
in normalized device coordinates (i.e. fractions of the device region).</p>
</td></tr>
<tr><td><code id="scattersplot_+3A_data.ind">data.ind</code></td>
<td>
<p>integer (or character) with the index (or name) of the data component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard generic function with a default method, in which argument <code>x</code> 
is a matrix with the spatial coordinates (each row is a point).
</p>
<p><code>scattersplot.SpatialPointsDataFrame</code> sets default values for some of the arguments 
from attributes of the object <code>x</code> (if present; see e.g. <code>precipitation</code>).
</p>


<h3>Value</h3>

<p>No return value, called for side effects (generate the plot).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splot">splot</a></code>, <code><a href="#topic+spoints">spoints</a></code>, <code><a href="stats.html#topic+lowess">lowess</a></code>, 
<code><a href="stats.html#topic+density">density</a></code>
</p>

<hr>
<h2 id='simage'>Image plot with a color scale</h2><span id='topic+simage'></span><span id='topic+simage.default'></span><span id='topic+simage.data.grid'></span><span id='topic+plot.np.den'></span>

<h3>Description</h3>

<p><code>simage</code> (generic function) draws an image (a grid of colored rectangles) 
and (optionally) adds a legend strip with the color scale 
(calls <code><a href="#topic+splot">splot</a></code> and <code><a href="graphics.html#topic+image">image</a></code>).
</p>
<p><code>plot.np.den</code> calls <code>simage.data.grid</code> 
(<code><a href="graphics.html#topic+contour">contour</a></code> and <code><a href="graphics.html#topic+points">points</a></code> also by default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simage(x, ...)

## Default S3 method:
simage(
  x = seq(0, 1, len = nrow(s)),
  y = seq(0, 1, len = ncol(s)),
  s,
  slim = range(s, finite = TRUE),
  col = jet.colors(128),
  breaks = NULL,
  legend = TRUE,
  horizontal = FALSE,
  legend.shrink = 1,
  legend.width = 1.2,
  legend.mar = ifelse(horizontal, 3.1, 5.1),
  legend.lab = NULL,
  bigplot = NULL,
  smallplot = NULL,
  lab.breaks = NULL,
  axis.args = NULL,
  legend.args = NULL,
  reset = TRUE,
  xlab = NULL,
  ylab = NULL,
  asp = NA,
  ...
)

## S3 method for class 'data.grid'
simage(x, data.ind = 1, xlab = NULL, ylab = NULL, ...)

## S3 method for class 'np.den'
plot(
  x,
  y = NULL,
  log = TRUE,
  contour = TRUE,
  points = TRUE,
  col = hot.colors(128),
  tolerance = npsp.tolerance(),
  reset = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simage_+3A_x">x</code></td>
<td>
<p>grid values for <code>x</code> coordinate. If <code>x</code> is a list, 
its components <code>x$x</code> and <code>x$y</code> are used for <code>x</code>  
and <code>y</code>, respectively. For compatibility with <code><a href="graphics.html#topic+image">image</a></code>, if the 
list has component <code>z</code> this is used for <code>s</code>.</p>
</td></tr>
<tr><td><code id="simage_+3A_...">...</code></td>
<td>
<p>additional graphical parameters (to be passed to <code><a href="graphics.html#topic+image">image</a></code> 
or <code>simage.default</code>; e.g. <code>xlim, ylim,</code> ...). NOTE:
graphical arguments passed here will only have impact on the main plot. 
To change the graphical defaults for the legend use the <code><a href="graphics.html#topic+par">par</a></code> 
function beforehand (e.g. <code>par(cex.lab = 2)</code> to increase colorbar labels).</p>
</td></tr>
<tr><td><code id="simage_+3A_y">y</code></td>
<td>
<p>grid values for <code>y</code> coordinate.</p>
</td></tr>
<tr><td><code id="simage_+3A_s">s</code></td>
<td>
<p>matrix containing the values to be used for coloring the rectangles (NAs are allowed). 
Note that <code>x</code> can be used instead of <code>s</code> for convenience.</p>
</td></tr>
<tr><td><code id="simage_+3A_slim">slim</code></td>
<td>
<p>limits used to set up the color scale.</p>
</td></tr>
<tr><td><code id="simage_+3A_col">col</code></td>
<td>
<p>color table used to set up the color scale (see <code><a href="graphics.html#topic+image">image</a></code> for
details).</p>
</td></tr>
<tr><td><code id="simage_+3A_breaks">breaks</code></td>
<td>
<p>(optional) numeric vector with the breakpoints for the color scale: 
must have one more breakpoint than <code>col</code> and be in increasing order.</p>
</td></tr>
<tr><td><code id="simage_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the plotting region is splitted into two parts,
drawing the image plot in one and the legend with the color scale in the other.
If <code>FALSE</code> only the image plot is drawn and the arguments related 
to the legend are ignored (<code><a href="#topic+splot">splot</a></code> is not called).</p>
</td></tr>
<tr><td><code id="simage_+3A_horizontal">horizontal</code></td>
<td>
<p>logical; if <code>FALSE</code> (default) legend will be a vertical strip on the
right side. If <code>TRUE</code> the legend strip will be along the bottom.</p>
</td></tr>
<tr><td><code id="simage_+3A_legend.shrink">legend.shrink</code></td>
<td>
<p>amount to shrink the size of legend relative to the
full height or width of the plot.</p>
</td></tr>
<tr><td><code id="simage_+3A_legend.width">legend.width</code></td>
<td>
<p>width in characters of the legend strip. Default is
1.2, a little bigger that the width of a character.</p>
</td></tr>
<tr><td><code id="simage_+3A_legend.mar">legend.mar</code></td>
<td>
<p>width in characters of legend margin that has the axis.
Default is 5.1 for a vertical legend and 3.1 for a horizontal legend.</p>
</td></tr>
<tr><td><code id="simage_+3A_legend.lab">legend.lab</code></td>
<td>
<p>label for the axis of the color legend. Default is no
label as this is usual evident from the plot title.</p>
</td></tr>
<tr><td><code id="simage_+3A_bigplot">bigplot</code></td>
<td>
<p>plot coordinates for main plot. If not passed these will be 
determined within the function.</p>
</td></tr>
<tr><td><code id="simage_+3A_smallplot">smallplot</code></td>
<td>
<p>plot coordinates for legend strip. If not passed these
will be determined within the function.</p>
</td></tr>
<tr><td><code id="simage_+3A_lab.breaks">lab.breaks</code></td>
<td>
<p>if breaks are supplied these are text string labels to
put at each break value. This is intended to label axis on a transformed
scale such as logs.</p>
</td></tr>
<tr><td><code id="simage_+3A_axis.args">axis.args</code></td>
<td>
<p>additional arguments for the axis function used to create
the legend axis (see <code><a href="fields.html#topic+image.plot">image.plot</a></code> for details).</p>
</td></tr>
<tr><td><code id="simage_+3A_legend.args">legend.args</code></td>
<td>
<p>arguments for a complete specification of the legend
label. This is in the form of list and is just passed to the <code><a href="graphics.html#topic+mtext">mtext</a></code>
function. Usually this will not be needed (see <code><a href="fields.html#topic+image.plot">image.plot</a></code> 
for details).</p>
</td></tr>
<tr><td><code id="simage_+3A_reset">reset</code></td>
<td>
<p>logical; if <code>FALSE</code> the plotting region
(<code><a href="graphics.html#topic+par">par</a>("plt")</code>) will not be reset to make it possible to add more features
to the plot (e.g. using functions such as points or lines). If <code>TRUE</code> (default) 
the plot parameters will be reset to the values before entering the function.</p>
</td></tr>
<tr><td><code id="simage_+3A_xlab">xlab</code></td>
<td>
<p>label for the x axis, defaults to a description of <code>x</code>.</p>
</td></tr>
<tr><td><code id="simage_+3A_ylab">ylab</code></td>
<td>
<p>label for the y axis, defaults to a description of <code>y</code>.</p>
</td></tr>
<tr><td><code id="simage_+3A_asp">asp</code></td>
<td>
<p>the y/x aspect ratio, see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</td></tr>
<tr><td><code id="simage_+3A_data.ind">data.ind</code></td>
<td>
<p>integer (or character) with the index (or name) of the component 
containing the values to be used for coloring the rectangles.</p>
</td></tr>
<tr><td><code id="simage_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), <code>log(x$est)</code> is ploted.</p>
</td></tr>
<tr><td><code id="simage_+3A_contour">contour</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), contour lines are added.</p>
</td></tr>
<tr><td><code id="simage_+3A_points">points</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), points at <code>x$data$x</code> are drawn.</p>
</td></tr>
<tr><td><code id="simage_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance value (lower values are masked).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a list with the following 3 components:
</p>
<table role = "presentation">
<tr><td><code>bigplot</code></td>
<td>
<p>plot coordinates of the main plot. These values may be useful for 
drawing a plot without the legend that is the same size as the plots with legends.</p>
</td></tr>
<tr><td><code>smallplot</code></td>
<td>
<p>plot coordinates of the secondary plot (legend strip).</p>
</td></tr>
<tr><td><code>old.par</code></td>
<td>
<p>previous graphical parameters (<code>par(old.par)</code> 
will reset plot parameters to the values before entering the function).</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>After exiting, the plotting region may be changed 
(<code><a href="graphics.html#topic+par">par</a>("plt")</code>) to make it possible to add more features to the plot
(set <code>reset = FALSE</code> to avoid this).
</p>


<h3>Author(s)</h3>

<p>Based on <code><a href="fields.html#topic+image.plot">image.plot</a></code> function from package <span class="pkg">fields</span>:
fields, Tools for spatial data. 
Copyright 2004-2013, Institute for Mathematics Applied Geosciences. 
University Corporation for Atmospheric Research.
</p>
<p>Modified by Ruben Fernandez-Casal &lt;rubenfcasal@gmail.com&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splot">splot</a></code>, <code><a href="#topic+spoints">spoints</a></code>, <code><a href="#topic+spersp">spersp</a></code>, 
<code><a href="graphics.html#topic+image">image</a></code>, <code><a href="fields.html#topic+image.plot">image.plot</a></code>, <code><a href="#topic+data.grid">data.grid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regularly spaced 2D data
nx &lt;- c(40, 40) # ndata =  prod(nx)
x1 &lt;- seq(-1, 1, length.out = nx[1])
x2 &lt;- seq(-1, 1, length.out = nx[2])
trend &lt;- outer(x1, x2, function(x,y) x^2 - y^2) 
simage( x1, x2, trend, main = 'Trend')
# Multiple plots 
set.seed(1)
y &lt;- trend + rnorm(prod(nx), 0, 0.1)
x &lt;- as.matrix(expand.grid(x1 = x1, x2 = x2)) # two-dimensional grid
# local polynomial kernel regression
lp &lt;- locpol(x, y, nbin = nx, h =  diag(c(0.3, 0.3)))
# 1x2 plot
old.par &lt;- par(mfrow = c(1,2))
simage( x1, x2, y, main = 'Data', reset = FALSE)
simage(lp, main = 'Estimated trend', reset = FALSE)
par(old.par)
</code></pre>

<hr>
<h2 id='spersp'>Perspective plot with a color scale</h2><span id='topic+spersp'></span><span id='topic+spersp.default'></span><span id='topic+spersp.data.grid'></span>

<h3>Description</h3>

<p><code>spersp</code> (generic function) draws a perspective plot of a surface over 
the <code>x-y</code> plane with the facets being filled with different colors 
and (optionally) adds a legend strip with the color scale 
(calls <code><a href="#topic+splot">splot</a></code> and <code><a href="graphics.html#topic+persp">persp</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spersp(x, ...)

## Default S3 method:
spersp(
  x = seq(0, 1, len = nrow(z)),
  y = seq(0, 1, len = ncol(z)),
  z,
  s = z,
  slim = range(s, finite = TRUE),
  col = jet.colors(128),
  breaks = NULL,
  legend = TRUE,
  horizontal = FALSE,
  legend.shrink = 0.8,
  legend.width = 1.2,
  legend.mar = ifelse(horizontal, 3.1, 5.1),
  legend.lab = NULL,
  bigplot = NULL,
  smallplot = NULL,
  lab.breaks = NULL,
  axis.args = NULL,
  legend.args = NULL,
  reset = TRUE,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  theta = 40,
  phi = 20,
  ticktype = "detailed",
  cex.axis = 0.75,
  ...
)

## S3 method for class 'data.grid'
spersp(
  x,
  data.ind = 1,
  s = x[[data.ind]],
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spersp_+3A_x">x</code></td>
<td>
<p>grid values for <code>x</code> coordinate. If <code>x</code> is a list, 
its components <code>x$x</code> and <code>x$y</code> are used for <code>x</code>  
and <code>y</code>, respectively. If the list has component <code>z</code> this is used 
for <code>z</code>.</p>
</td></tr>
<tr><td><code id="spersp_+3A_...">...</code></td>
<td>
<p>additional graphical parameters (to be passed to <code><a href="graphics.html#topic+persp">persp</a></code> 
or <code>spersp.default</code>; e.g. <code>xlim, ylim, zlim,</code> ...). NOTE:
graphical arguments passed here will only have impact on the main plot. 
To change the graphical defaults for the legend use the <code><a href="graphics.html#topic+par">par</a></code> 
function beforehand (e.g. <code>par(cex.lab = 2)</code> to increase colorbar labels).</p>
</td></tr>
<tr><td><code id="spersp_+3A_y">y</code></td>
<td>
<p>grid values for <code>y</code> coordinate.</p>
</td></tr>
<tr><td><code id="spersp_+3A_z">z</code></td>
<td>
<p>matrix containing the values to be plotted (NAs are allowed).
Note that <code>x</code> can be used instead of <code>z</code> for convenience.</p>
</td></tr>
<tr><td><code id="spersp_+3A_s">s</code></td>
<td>
<p>matrix containing the values used for coloring the facets.</p>
</td></tr>
<tr><td><code id="spersp_+3A_slim">slim</code></td>
<td>
<p>limits used to set up the color scale.</p>
</td></tr>
<tr><td><code id="spersp_+3A_col">col</code></td>
<td>
<p>color table used to set up the color scale (see <code><a href="graphics.html#topic+image">image</a></code> for
details).</p>
</td></tr>
<tr><td><code id="spersp_+3A_breaks">breaks</code></td>
<td>
<p>(optional) numeric vector with the breakpoints for the color scale: 
must have one more breakpoint than <code>col</code> and be in increasing order.</p>
</td></tr>
<tr><td><code id="spersp_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the plotting region is splitted into two parts,
drawing the perspective plot in one and the legend with the color scale in the other.
If <code>FALSE</code> only the (coloured) perspective plot is drawn and the arguments related 
to the legend are ignored (<code><a href="#topic+splot">splot</a></code> is not called).</p>
</td></tr>
<tr><td><code id="spersp_+3A_horizontal">horizontal</code></td>
<td>
<p>logical; if <code>FALSE</code> (default) legend will be a vertical strip on the
right side. If <code>TRUE</code> the legend strip will be along the bottom.</p>
</td></tr>
<tr><td><code id="spersp_+3A_legend.shrink">legend.shrink</code></td>
<td>
<p>amount to shrink the size of legend relative to the
full height or width of the plot.</p>
</td></tr>
<tr><td><code id="spersp_+3A_legend.width">legend.width</code></td>
<td>
<p>width in characters of the legend strip. Default is
1.2, a little bigger that the width of a character.</p>
</td></tr>
<tr><td><code id="spersp_+3A_legend.mar">legend.mar</code></td>
<td>
<p>width in characters of legend margin that has the axis.
Default is 5.1 for a vertical legend and 3.1 for a horizontal legend.</p>
</td></tr>
<tr><td><code id="spersp_+3A_legend.lab">legend.lab</code></td>
<td>
<p>label for the axis of the color legend. Default is no
label as this is usual evident from the plot title.</p>
</td></tr>
<tr><td><code id="spersp_+3A_bigplot">bigplot</code></td>
<td>
<p>plot coordinates for main plot. If not passed these will be 
determined within the function.</p>
</td></tr>
<tr><td><code id="spersp_+3A_smallplot">smallplot</code></td>
<td>
<p>plot coordinates for legend strip. If not passed these
will be determined within the function.</p>
</td></tr>
<tr><td><code id="spersp_+3A_lab.breaks">lab.breaks</code></td>
<td>
<p>if breaks are supplied these are text string labels to
put at each break value. This is intended to label axis on a transformed
scale such as logs.</p>
</td></tr>
<tr><td><code id="spersp_+3A_axis.args">axis.args</code></td>
<td>
<p>additional arguments for the axis function used to create
the legend axis (see <code><a href="fields.html#topic+image.plot">image.plot</a></code> for details).</p>
</td></tr>
<tr><td><code id="spersp_+3A_legend.args">legend.args</code></td>
<td>
<p>arguments for a complete specification of the legend
label. This is in the form of list and is just passed to the <code><a href="graphics.html#topic+mtext">mtext</a></code>
function. Usually this will not be needed (see <code><a href="fields.html#topic+image.plot">image.plot</a></code> 
for details).</p>
</td></tr>
<tr><td><code id="spersp_+3A_reset">reset</code></td>
<td>
<p>logical; if <code>FALSE</code> the plotting region
(<code><a href="graphics.html#topic+par">par</a>("plt")</code>) will not be reset to make it possible to add more features
to the plot (e.g. using functions such as points or lines). If <code>TRUE</code> (default) 
the plot parameters will be reset to the values before entering the function.</p>
</td></tr>
<tr><td><code id="spersp_+3A_xlab">xlab</code></td>
<td>
<p>label for the x axis, defaults to a description of <code>x</code>.</p>
</td></tr>
<tr><td><code id="spersp_+3A_ylab">ylab</code></td>
<td>
<p>label for the y axis, defaults to a description of <code>y</code>.</p>
</td></tr>
<tr><td><code id="spersp_+3A_zlab">zlab</code></td>
<td>
<p>label for the z axis, defaults to a description of <code>z</code>.</p>
</td></tr>
<tr><td><code id="spersp_+3A_theta">theta</code></td>
<td>
<p>x-y rotation angle for perspective (azimuthal direction).</p>
</td></tr>
<tr><td><code id="spersp_+3A_phi">phi</code></td>
<td>
<p>z-angle for perspective (colatitude).</p>
</td></tr>
<tr><td><code id="spersp_+3A_ticktype">ticktype</code></td>
<td>
<p>character; <code>"simple"</code> draws just an arrow parallel to the axis 
to indicate direction of increase; <code>"detailed"</code> draws normal ticks as per 2D plots.</p>
</td></tr>
<tr><td><code id="spersp_+3A_cex.axis">cex.axis</code></td>
<td>
<p>magnification to be used for axis annotation (relative to the 
current setting of <code><a href="graphics.html#topic+par">par</a>("cex")</code>).</p>
</td></tr>
<tr><td><code id="spersp_+3A_data.ind">data.ind</code></td>
<td>
<p>integer (or character) with the index (or name) of the component 
containing the <code>z</code> values to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a list with the following 4 components:
</p>
<table role = "presentation">
<tr><td><code>pm</code></td>
<td>
<p>the viewing transformation matrix (see <code><a href="graphics.html#topic+persp">persp</a></code> for details), 
a 4 x 4 matrix that can be used to superimpose additional graphical elements 
using the function <code><a href="grDevices.html#topic+trans3d">trans3d</a></code>.</p>
</td></tr> 
<tr><td><code>bigplot</code></td>
<td>
<p>plot coordinates of the main plot. These values may be useful for 
drawing a plot without the legend that is the same size as the plots with legends.</p>
</td></tr>
<tr><td><code>smallplot</code></td>
<td>
<p>plot coordinates of the secondary plot (legend strip).</p>
</td></tr>
<tr><td><code>old.par</code></td>
<td>
<p>previous graphical parameters (<code>par(old.par)</code> 
will reset plot parameters to the values before entering the function).</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>After exiting, the plotting region may be changed 
(<code><a href="graphics.html#topic+par">par</a>("plt")</code>) to make it possible to add more features to the plot
(set <code>reset = FALSE</code> to avoid this).
</p>


<h3>Author(s)</h3>

<p>Based on <code><a href="fields.html#topic+image.plot">image.plot</a></code> function from package <span class="pkg">fields</span>:
fields, Tools for spatial data. 
Copyright 2004-2013, Institute for Mathematics Applied Geosciences. 
University Corporation for Atmospheric Research.
</p>
<p>Modified by Ruben Fernandez-Casal &lt;rubenfcasal@gmail.com&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splot">splot</a></code>, <code><a href="#topic+spoints">spoints</a></code>, <code><a href="#topic+simage">simage</a></code>, 
<code><a href="graphics.html#topic+image">image</a></code>, <code><a href="fields.html#topic+image.plot">image.plot</a></code>, <code><a href="#topic+data.grid">data.grid</a></code>, 
<code><a href="graphics.html#topic+persp">persp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regularly spaced 2D data
nx &lt;- c(40, 40) # ndata =  prod(nx)
x1 &lt;- seq(-1, 1, length.out = nx[1])
x2 &lt;- seq(-1, 1, length.out = nx[2])
trend &lt;- outer(x1, x2, function(x,y) x^2 - y^2) 
spersp( x1, x2, trend, main = 'Trend', zlab = 'y')
# Multiple plots 
set.seed(1)
y &lt;- trend + rnorm(prod(nx), 0, 0.1)
x &lt;- as.matrix(expand.grid(x1 = x1, x2 = x2)) # two-dimensional grid
# local polynomial kernel regression
lp &lt;- locpol(x, y, nbin = nx, h =  diag(c(0.3, 0.3)))
# 1x2 plot
old.par &lt;- par(mfrow = c(1,2))
spersp( x1, x2, y, main = 'Data', reset = FALSE)
spersp(lp, main = 'Estimated trend', zlab = 'y', reset = FALSE)
par(old.par)
</code></pre>

<hr>
<h2 id='splot'>Utilities for plotting with a color scale</h2><span id='topic+splot'></span><span id='topic+scolor'></span><span id='topic+jet.colors'></span><span id='topic+hot.colors'></span>

<h3>Description</h3>

<p><code>splot</code> is designed to combine a standard R plot with 
a legend representing a (continuous) color scale. This is done by splitting 
the plotting region into two parts. Keeping one for the main chart and 
putting the legend in the other.  
For instance, <code>sxxxx</code> functions (<code><a href="#topic+spoints">spoints</a></code>, <code><a href="#topic+simage">simage</a></code> 
and <code><a href="#topic+spersp">spersp</a></code>) draw the corresponding high-level plot (<code>xxxx</code>),
after calling <code>splot</code>, to include a legend strip for the color scale. 
</p>
<p>These functions are based on function <code><a href="fields.html#topic+image.plot">image.plot</a></code> of package
<span class="pkg">fields</span>, see its documentation for additional information.
</p>
<p><code>jet.colors</code> and <code>hot.colors</code> create a color table useful for contiguous 
color scales and <code>scolor</code> assigns colors to a numerical vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splot(
  slim = c(0, 1),
  col = jet.colors(128),
  breaks = NULL,
  horizontal = FALSE,
  legend.shrink = 0.9,
  legend.width = 1.2,
  legend.mar = ifelse(horizontal, 3.1, 5.1),
  legend.lab = NULL,
  bigplot = NULL,
  smallplot = NULL,
  lab.breaks = NULL,
  axis.args = NULL,
  legend.args = NULL,
  add = FALSE
)

scolor(s, col = jet.colors(128), slim = range(s, finite = TRUE))

jet.colors(n)

hot.colors(n, rev = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splot_+3A_slim">slim</code></td>
<td>
<p>limits used to set up the color scale.</p>
</td></tr>
<tr><td><code id="splot_+3A_col">col</code></td>
<td>
<p>color table used to set up the color scale (see <code><a href="graphics.html#topic+image">image</a></code> for
details).</p>
</td></tr>
<tr><td><code id="splot_+3A_breaks">breaks</code></td>
<td>
<p>(optional) numeric vector with the breakpoints for the color scale: 
must have one more breakpoint than <code>col</code> and be in increasing order.</p>
</td></tr>
<tr><td><code id="splot_+3A_horizontal">horizontal</code></td>
<td>
<p>logical; if <code>FALSE</code> (default) legend will be a vertical strip on the
right side. If <code>TRUE</code> the legend strip will be along the bottom.</p>
</td></tr>
<tr><td><code id="splot_+3A_legend.shrink">legend.shrink</code></td>
<td>
<p>amount to shrink the size of legend relative to the
full height or width of the plot.</p>
</td></tr>
<tr><td><code id="splot_+3A_legend.width">legend.width</code></td>
<td>
<p>width in characters of the legend strip. Default is
1.2, a little bigger that the width of a character.</p>
</td></tr>
<tr><td><code id="splot_+3A_legend.mar">legend.mar</code></td>
<td>
<p>width in characters of legend margin that has the axis.
Default is 5.1 for a vertical legend and 3.1 for a horizontal legend.</p>
</td></tr>
<tr><td><code id="splot_+3A_legend.lab">legend.lab</code></td>
<td>
<p>label for the axis of the color legend. Default is no
label as this is usual evident from the plot title.</p>
</td></tr>
<tr><td><code id="splot_+3A_bigplot">bigplot</code></td>
<td>
<p>plot coordinates for main plot. If not passed these will be 
determined within the function.</p>
</td></tr>
<tr><td><code id="splot_+3A_smallplot">smallplot</code></td>
<td>
<p>plot coordinates for legend strip. If not passed these
will be determined within the function.</p>
</td></tr>
<tr><td><code id="splot_+3A_lab.breaks">lab.breaks</code></td>
<td>
<p>if breaks are supplied these are text string labels to
put at each break value. This is intended to label axis on a transformed
scale such as logs.</p>
</td></tr>
<tr><td><code id="splot_+3A_axis.args">axis.args</code></td>
<td>
<p>additional arguments for the axis function used to create
the legend axis (see <code><a href="fields.html#topic+image.plot">image.plot</a></code> for details).</p>
</td></tr>
<tr><td><code id="splot_+3A_legend.args">legend.args</code></td>
<td>
<p>arguments for a complete specification of the legend
label. This is in the form of list and is just passed to the <code><a href="graphics.html#topic+mtext">mtext</a></code>
function. Usually this will not be needed (see <code><a href="fields.html#topic+image.plot">image.plot</a></code> 
for details).</p>
</td></tr>
<tr><td><code id="splot_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> the legend strip is just added 
to the existing plot (the graphical parameters are not changed).</p>
</td></tr>
<tr><td><code id="splot_+3A_s">s</code></td>
<td>
<p>values to be converted to the color scale.</p>
</td></tr>
<tr><td><code id="splot_+3A_n">n</code></td>
<td>
<p>number of colors (<code>&gt;= 1</code>) to be in the palette.</p>
</td></tr>
<tr><td><code id="splot_+3A_rev">rev</code></td>
<td>
<p>logical; if <code>TRUE</code>, the palette is reversed (decreasing overall luminosity).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scolor</code> converts a real valued vector to a color scale. The range 
<code>slim</code> is divided into <code>length(col) + 1</code> pieces of equal length.
Values which fall outside the range of the scale are coded as <code>NA</code>.
</p>
<p><code>jet.colors</code> generates a rainbow style color table similar to the MATLAB (TM) 
jet color scheme. It may be appropriate to distinguish between values above and 
below a central value (e.g. between positive and negative values).
</p>
<p><code>hot.colors</code> generates a color table similar to the MATLAB (TM) 
hot color scheme (reversed by default). It may be appropriate to represent values  
ranging from 0 to some maximum level (e.g. density estimation). 
The default value <code>rev = TRUE</code> may be adecuate to grayscale convertion.
</p>


<h3>Value</h3>

<p><code>splot</code> invisibly returns a list with the following 3 components:
</p>
<table role = "presentation">
<tr><td><code>bigplot</code></td>
<td>
<p>plot coordinates of the main plot. These values may be useful for 
drawing a plot without the legend that is the same size as the plots with legends.</p>
</td></tr>
<tr><td><code>smallplot</code></td>
<td>
<p>plot coordinates of the secondary plot (legend strip).</p>
</td></tr>
<tr><td><code>old.par</code></td>
<td>
<p>previous graphical parameters (<code>par(old.par)</code> 
will reset plot parameters to the values before entering the function).</p>
</td></tr>
</table>
<p><code>jet.colors</code> and <code>hot.colors</code> return a character vector of colors (similar to 
<code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code> or <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code>; see <code><a href="grDevices.html#topic+rgb">rgb</a></code>).
</p>


<h3>Side Effects</h3>

<p>After exiting <code>splot</code>, the plotting region may be changed 
(<code><a href="graphics.html#topic+par">par</a>("plt")</code>) to make it possible to add more features to the plot.
</p>


<h3>Author(s)</h3>

<p>Based on <code><a href="fields.html#topic+image.plot">image.plot</a></code> function from package <span class="pkg">fields</span>:
fields, Tools for spatial data. 
Copyright 2004-2013, Institute for Mathematics Applied Geosciences. 
University Corporation for Atmospheric Research.
</p>
<p>Modified by Ruben Fernandez-Casal &lt;rubenfcasal@gmail.com&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spoints">spoints</a></code>, <code><a href="#topic+simage">simage</a></code>, <code><a href="#topic+spersp">spersp</a></code>, 
<code><a href="graphics.html#topic+image">image</a></code>, <code><a href="fields.html#topic+image.plot">image.plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot equivalent to spoints():
scale.range &lt;- range(aquifer$head)
res &lt;- splot(slim = scale.range)
with( aquifer, plot(lon, lat, col = scolor(head, slim = scale.range), 
       pch = 16, cex = 1.5, main = "Wolfcamp aquifer data"))
par(res$old.par) # restore graphical parameters       
# Multiple plots with a common legend:
# regularly spaced 2D data...
set.seed(1)
nx &lt;- c(40, 40) # ndata =  prod(nx)
x1 &lt;- seq(-1, 1, length.out = nx[1])
x2 &lt;- seq(-1, 1, length.out = nx[2])
trend &lt;- outer(x1, x2, function(x,y) x^2 - y^2)
y &lt;- trend + rnorm(prod(nx), 0, 0.1)
scale.range &lt;- c(-1.2, 1.2)
scale.color &lt;- heat.colors(64)
# 1x2 plot with some room for the legend...
old.par &lt;- par(mfrow = c(1,2), omd = c(0.05, 0.85, 0.05, 0.95))
image( x1, x2, trend, zlim = scale.range, main = 'Trend', col = scale.color)
image( x1, x2, y, zlim = scale.range, main = 'Data', col = scale.color)
par(old.par)
# the legend can be added to any plot...
splot(slim = scale.range, col = scale.color, add = TRUE)
## note that argument 'zlim' in 'image' corresponds with 'slim' in 'sxxxx' functions. 
</code></pre>

<hr>
<h2 id='spoints'>Scatter plot with a color scale</h2><span id='topic+spoints'></span><span id='topic+spoints.default'></span><span id='topic+spoints.data.grid'></span><span id='topic+spoints.SpatialPointsDataFrame'></span>

<h3>Description</h3>

<p><code>spoints</code> (generic function) draws a scatter plot with points filled with different colors
and (optionally) adds a legend strip with the color scale
(calls <code><a href="#topic+splot">splot</a></code> and <code><a href="graphics.html#topic+plot.default">plot.default</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spoints(x, ...)

## Default S3 method:
spoints(
  x,
  y = NULL,
  s,
  slim = range(s, finite = TRUE),
  col = jet.colors(128),
  breaks = NULL,
  legend = TRUE,
  horizontal = FALSE,
  legend.shrink = 1,
  legend.width = 1.2,
  legend.mar = ifelse(horizontal, 3.1, 5.1),
  legend.lab = NULL,
  bigplot = NULL,
  smallplot = NULL,
  lab.breaks = NULL,
  axis.args = NULL,
  legend.args = NULL,
  add = FALSE,
  reset = TRUE,
  pch = 16,
  cex = 1.5,
  xlab = NULL,
  ylab = NULL,
  asp = NA,
  ...
)

## S3 method for class 'data.grid'
spoints(x, s = x[[1]], xlab = NULL, ylab = NULL, ...)

## S3 method for class 'SpatialPointsDataFrame'
spoints(x, data.ind = 1, main, xlab, ylab, legend.lab, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spoints_+3A_x">x</code></td>
<td>
<p>object used to select a method. In the default method, it provides the <code>x</code> 
coordinates for the plot (and optionally the <code>y</code> coordinates; 
any reasonable way of defining the coordinates is acceptable, 
see the function <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code> for details).</p>
</td></tr>
<tr><td><code id="spoints_+3A_...">...</code></td>
<td>
<p>additional graphical parameters (to be passed to the main plot function
or <code>sxxxx.default</code>; e.g. <code>xlim, ylim,</code> ...). NOTE:
graphical arguments passed here will only have impact on the main plot.
To change the graphical defaults for the legend use the <code><a href="graphics.html#topic+par">par</a></code>
function beforehand (e.g. <code>par(cex.lab = 2)</code> to increase colorbar labels).</p>
</td></tr>
<tr><td><code id="spoints_+3A_y">y</code></td>
<td>
<p>y coordinates. Alternatively, a single argument <code>x</code> can be provided.</p>
</td></tr>
<tr><td><code id="spoints_+3A_s">s</code></td>
<td>
<p>numerical vector containing the values used for coloring the points.</p>
</td></tr>
<tr><td><code id="spoints_+3A_slim">slim</code></td>
<td>
<p>limits used to set up the color scale.</p>
</td></tr>
<tr><td><code id="spoints_+3A_col">col</code></td>
<td>
<p>color table used to set up the color scale (see <code><a href="graphics.html#topic+image">image</a></code> for
details).</p>
</td></tr>
<tr><td><code id="spoints_+3A_breaks">breaks</code></td>
<td>
<p>(optional) numeric vector with the breakpoints for the color scale: 
must have one more breakpoint than <code>col</code> and be in increasing order.</p>
</td></tr>
<tr><td><code id="spoints_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the plotting region is splitted into two parts,
drawing the main plot in one and the legend with the color scale in the other.
If <code>FALSE</code> only the (coloured) main plot is drawn and the arguments related
to the legend are ignored (<code><a href="#topic+splot">splot</a></code> is not called).</p>
</td></tr>
<tr><td><code id="spoints_+3A_horizontal">horizontal</code></td>
<td>
<p>logical; if <code>FALSE</code> (default) legend will be a vertical strip on the
right side. If <code>TRUE</code> the legend strip will be along the bottom.</p>
</td></tr>
<tr><td><code id="spoints_+3A_legend.shrink">legend.shrink</code></td>
<td>
<p>amount to shrink the size of legend relative to the
full height or width of the plot.</p>
</td></tr>
<tr><td><code id="spoints_+3A_legend.width">legend.width</code></td>
<td>
<p>width in characters of the legend strip. Default is
1.2, a little bigger that the width of a character.</p>
</td></tr>
<tr><td><code id="spoints_+3A_legend.mar">legend.mar</code></td>
<td>
<p>width in characters of legend margin that has the axis.
Default is 5.1 for a vertical legend and 3.1 for a horizontal legend.</p>
</td></tr>
<tr><td><code id="spoints_+3A_legend.lab">legend.lab</code></td>
<td>
<p>label for the axis of the color legend. Default is no
label as this is usual evident from the plot title.</p>
</td></tr>
<tr><td><code id="spoints_+3A_bigplot">bigplot</code></td>
<td>
<p>plot coordinates for main plot. If not passed, and <code>legend</code>
is TRUE, these will be determined within the function.</p>
</td></tr>
<tr><td><code id="spoints_+3A_smallplot">smallplot</code></td>
<td>
<p>plot coordinates for legend strip. If not passed, and <code>legend</code>
is TRUE, these will be determined within the function.</p>
</td></tr>
<tr><td><code id="spoints_+3A_lab.breaks">lab.breaks</code></td>
<td>
<p>if breaks are supplied these are text string labels to
put at each break value. This is intended to label axis on a transformed
scale such as logs.</p>
</td></tr>
<tr><td><code id="spoints_+3A_axis.args">axis.args</code></td>
<td>
<p>additional arguments for the axis function used to create
the legend axis (see <code><a href="fields.html#topic+image.plot">image.plot</a></code> for details).</p>
</td></tr>
<tr><td><code id="spoints_+3A_legend.args">legend.args</code></td>
<td>
<p>arguments for a complete specification of the legend
label. This is in the form of list and is just passed to the <code><a href="graphics.html#topic+mtext">mtext</a></code>
function. Usually this will not be needed (see <code><a href="fields.html#topic+image.plot">image.plot</a></code> 
for details).</p>
</td></tr>
<tr><td><code id="spoints_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> the scatter plot is just added 
to the existing plot.</p>
</td></tr>
<tr><td><code id="spoints_+3A_reset">reset</code></td>
<td>
<p>logical; if <code>FALSE</code> the plotting region
(<code><a href="graphics.html#topic+par">par</a>("plt")</code>) will not be reset to make it possible to add more features
to the plot (e.g. using functions such as points or lines). If <code>TRUE</code> (default) 
the plot parameters will be reset to the values before entering the function.</p>
</td></tr>
<tr><td><code id="spoints_+3A_pch">pch</code></td>
<td>
<p>vector of plotting characters or symbols: see <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="spoints_+3A_cex">cex</code></td>
<td>
<p>numerical vector giving the amount by which plotting characters
and symbols should be scaled relative to the default. This works as a multiple
of <code><a href="graphics.html#topic+par">par</a>("cex")</code>.</p>
</td></tr>
<tr><td><code id="spoints_+3A_xlab">xlab</code></td>
<td>
<p>label for the x axis, defaults to a description of <code>x</code>.</p>
</td></tr>
<tr><td><code id="spoints_+3A_ylab">ylab</code></td>
<td>
<p>label for the y axis, defaults to a description of <code>y</code>.</p>
</td></tr>
<tr><td><code id="spoints_+3A_asp">asp</code></td>
<td>
<p>the y/x aspect ratio, see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</td></tr>
<tr><td><code id="spoints_+3A_data.ind">data.ind</code></td>
<td>
<p>integer (or character) with the index (or name) of the data component.</p>
</td></tr>
<tr><td><code id="spoints_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spoints.SpatialPointsDataFrame</code> sets default values for some of the arguments 
from attributes of the object <code>x</code> (if present; see e.g. <code>precipitation</code>).
</p>


<h3>Value</h3>

<p>Invisibly returns a list with the following 3 components:
</p>
<table role = "presentation">
<tr><td><code>bigplot</code></td>
<td>
<p>plot coordinates of the main plot. These values may be useful for 
drawing a plot without the legend that is the same size as the plots with legends.</p>
</td></tr>
<tr><td><code>smallplot</code></td>
<td>
<p>plot coordinates of the secondary plot (legend strip).</p>
</td></tr>
<tr><td><code>old.par</code></td>
<td>
<p>previous graphical parameters (<code>par(old.par)</code> 
will reset plot parameters to the values before entering the function).</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>After exiting, the plotting region may be changed 
(<code><a href="graphics.html#topic+par">par</a>("plt")</code>) to make it possible to add more features to the plot
(set <code>reset = FALSE</code> to avoid this).
</p>


<h3>Author(s)</h3>

<p>Based on <code><a href="fields.html#topic+image.plot">image.plot</a></code> function from package <span class="pkg">fields</span>:
fields, Tools for spatial data.
Copyright 2004-2013, Institute for Mathematics Applied Geosciences.
University Corporation for Atmospheric Research.
</p>
<p>Modified by Ruben Fernandez-Casal &lt;rubenfcasal@gmail.com&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splot">splot</a></code>, <code><a href="#topic+simage">simage</a></code>, <code><a href="#topic+spersp">spersp</a></code>, 
<code><a href="graphics.html#topic+image">image</a></code>, <code><a href="fields.html#topic+image.plot">image.plot</a></code>, <code><a href="#topic+data.grid">data.grid</a></code>, 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with( aquifer, spoints(lon, lat, head, main = "Wolfcamp aquifer data"))
</code></pre>

<hr>
<h2 id='sv'>Evaluate a semivariogram model</h2><span id='topic+sv'></span><span id='topic+sv.default'></span><span id='topic+sv.svarmod'></span><span id='topic+sv.svar.grid'></span><span id='topic+sv.sb.iso'></span>

<h3>Description</h3>

<p>Evaluates an <code>svarmod</code> object <code>x</code> at lags <code>h</code> (S3 generic function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv(x, h, ...)

## Default S3 method:
sv(x, h, ...)

## S3 method for class 'svarmod'
sv(x, h, ...)

## S3 method for class 'svar.grid'
sv(x, h, ...)

## S3 method for class 'sb.iso'
sv(x, h, discretize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sv_+3A_x">x</code></td>
<td>
<p>variogram model (<code><a href="#topic+svarmod">svarmod</a></code> object).</p>
</td></tr>
<tr><td><code id="sv_+3A_h">h</code></td>
<td>
<p>vector (isotropic case) or matrix of lag values.</p>
</td></tr>
<tr><td><code id="sv_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="sv_+3A_discretize">discretize</code></td>
<td>
<p>logical. If <code>TRUE</code> the variogram is previously discretized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of semivariance values <code class="reqn">\gamma(h_i)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covar">covar</a></code>
</p>

<hr>
<h2 id='svar.bin'>Linear binning of semivariances</h2><span id='topic+svar.bin'></span><span id='topic+svar.bin-class'></span><span id='topic+svar.bin.default'></span><span id='topic+iso.svar'></span><span id='topic+svariso'></span>

<h3>Description</h3>

<p>Creates a <code>svar.bin</code> (binned semivar. + grid parameters) object with 
linearly binned semivariances (i.e. computes a binned sample variogram).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svar.bin(x, ...)

## Default S3 method:
svar.bin(
  x,
  y,
  maxlag = NULL,
  nlags = NULL,
  minlag = maxlag/nlags,
  estimator = c("classical", "modulus"),
  ...
)

svariso(
  x,
  y,
  maxlag = NULL,
  nlags = NULL,
  minlag = maxlag/nlags,
  estimator = c("classical", "modulus"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svar.bin_+3A_x">x</code></td>
<td>
<p>object used to select a method. Usually a matrix with the 
coordinates of the data locations (columns correspond with dimensions and 
rows with data).</p>
</td></tr>
<tr><td><code id="svar.bin_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="svar.bin_+3A_y">y</code></td>
<td>
<p>vector of data (response variable).</p>
</td></tr>
<tr><td><code id="svar.bin_+3A_maxlag">maxlag</code></td>
<td>
<p>maximum lag. Defaults to 55% of largest lag.</p>
</td></tr>
<tr><td><code id="svar.bin_+3A_nlags">nlags</code></td>
<td>
<p>number of lags. Defaults to <code>max(12, <a href="#topic+rule.svar">rule.svar</a>(x))</code>.</p>
</td></tr>
<tr><td><code id="svar.bin_+3A_minlag">minlag</code></td>
<td>
<p>minimun lag.</p>
</td></tr>
<tr><td><code id="svar.bin_+3A_estimator">estimator</code></td>
<td>
<p>character, estimator name (e.g. &quot;classical&quot;). See &quot;Details&quot; below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only isotropic semivariogram estimation is supported.
</p>
<p>If parameter <code>nlags</code> is not specified is set to <code>max(12, <a href="#topic+rule.svar">rule.svar</a>(x))</code>.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>svar.bin</code> (extends <code><a href="#topic+bin.data">bin.data</a></code>),
a <code><a href="#topic+data.grid">data.grid</a></code> object with the following 4 components:
</p>
<table role = "presentation">
<tr><td><code>biny</code></td>
<td>
<p>array (dimension <code>nlags</code>) with the binned semivariances. </p>
</td></tr>
<tr><td><code>binw</code></td>
<td>
<p>array (dimension <code>nlags</code>) with the bin counts (weights).</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>a <code><a href="#topic+grid.par">grid.par</a></code>-<code><a href="base.html#topic+class">class</a></code> object with the grid parameters.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list with 3 components:
</p>

<ul>
<li><p><code>x</code> argument <code>x</code>.
</p>
</li>
<li><p><code>y</code> argument <code>y</code>.
</p>
</li>
<li><p><code>med</code> (weighted) mean of the (binned) semivariances.
</p>
</li></ul>
</td></tr>
<tr><td><code>svar</code></td>
<td>
<p>a list of 2 components:
</p>

<ul>
<li><p><code>type</code> character, type of estimation (e.g. &quot;isotropic&quot;).
</p>
</li>
<li><p><code>estimator</code> character, estimator name (e.g. &quot;classical&quot;).
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+np.svariso">np.svariso</a></code>, <code><a href="#topic+np.svar">np.svar</a></code>, 
<code><a href="#topic+data.grid">data.grid</a></code>, <code><a href="#topic+binning">binning</a></code>, <code><a href="#topic+locpol">locpol</a></code>,
<code><a href="#topic+rule.svar">rule.svar</a></code>.
</p>

<hr>
<h2 id='svar.grid'>Discretize a (semi)variogram model</h2><span id='topic+svar.grid'></span><span id='topic+svar.grid.svarmod'></span>

<h3>Description</h3>

<p>Discretizes a variogram model (to speed up variogram evaluation). 
Constructor function of the <code>svar.grid-<a href="base.html#topic+class">class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svar.grid(svar, log = TRUE, ...)

## S3 method for class 'svarmod'
svar.grid(
  svar,
  log = TRUE,
  n = 256,
  min = 10 * .Machine$double.eps,
  max = 1.1 * svar$range,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svar.grid_+3A_svar">svar</code></td>
<td>
<p>(fitted) variogram model (a <code><a href="#topic+svarmod">svarmod</a></code> 
or <code><a href="#topic+fitsvar">fitsvar</a></code> object).</p>
</td></tr>
<tr><td><code id="svar.grid_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, the variogram is discretized
in  (base 2) logarithmic scale.</p>
</td></tr>
<tr><td><code id="svar.grid_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="svar.grid_+3A_n">n</code></td>
<td>
<p>number of lags. Defaults to 256.</p>
</td></tr>
<tr><td><code id="svar.grid_+3A_min">min</code></td>
<td>
<p>minimun lag. Defaults to <code>10*.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="svar.grid_+3A_max">max</code></td>
<td>
<p>maximum lag. Defaults to <code>1.1*svar$range</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>svar.grid-<a href="base.html#topic+class">class</a></code> object extending <code>svarmod</code>,
<code>bin.den</code> and <code>data.grid</code> classes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svarmod">svarmod</a></code>, <code><a href="#topic+bin.den">bin.den</a></code>, <code><a href="#topic+data.grid">data.grid</a></code>.
</p>

<hr>
<h2 id='svar.plot'>Plot a semivariogram object</h2><span id='topic+svar.plot'></span><span id='topic+plot.fitsvar'></span><span id='topic+plot.svar.bin'></span><span id='topic+plot.np.svar'></span>

<h3>Description</h3>

<p>Utilities for plotting pilot semivariograms or fitted models.
</p>
<p><code>plot.fitsvar</code> plots a fitted variogram model.
</p>
<p><code>plot.svar.bin</code> plots the binned semivariances.
</p>
<p><code>plot.np.svar</code> plots a local polynomial estimate of the semivariogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitsvar'
plot(
  x,
  y = NULL,
  legend = TRUE,
  xlab = "distance",
  ylab = "semivariance",
  xlim = NULL,
  ylim = c(0, 1.25 * max(x$fit$sv, na.rm = TRUE)),
  lwd = c(1, 2),
  add = FALSE,
  ...
)

## S3 method for class 'svar.bin'
plot(
  x,
  y = NULL,
  xlab = "distance",
  ylab = "semivariance",
  xlim = NULL,
  ylim = c(0, max(x$biny, na.rm = TRUE)),
  add = FALSE,
  ...
)

## S3 method for class 'np.svar'
plot(
  x,
  y = NULL,
  xlab = "distance",
  ylab = "semivariance",
  xlim = NULL,
  ylim = c(0, max(x$biny, na.rm = TRUE)),
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svar.plot_+3A_x">x</code></td>
<td>
<p>a variogram object. Typically an output of functions
<code><a href="#topic+np.svariso">np.svariso</a></code> or <code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code>.</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_y">y</code></td>
<td>
<p>ignored argument.</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), a legend is added to the plot.</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_xlab">xlab</code></td>
<td>
<p>label for the x axis (defaults to &quot;distance&quot;).</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_ylab">ylab</code></td>
<td>
<p>label for the y axis (defaults to &quot;semivariance&quot;).</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_xlim">xlim</code></td>
<td>
<p>x-limits.</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_ylim">ylim</code></td>
<td>
<p>y-limits.</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_lwd">lwd</code></td>
<td>
<p>line widths for points (estimates) and lines (fitted model) respectively.</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> the semivariogram plot is just added 
to the existing plot.</p>
</td></tr>
<tr><td><code id="svar.plot_+3A_...">...</code></td>
<td>
<p>additional graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects (generate the plot).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svariso">svariso</a></code>, <code><a href="#topic+np.svariso">np.svariso</a></code>, <code><a href="#topic+fitsvar.sb.iso">fitsvar.sb.iso</a></code>.
</p>

<hr>
<h2 id='svarmod'>Define a (semi)variogram model</h2><span id='topic+svarmod'></span><span id='topic+svarmod.sb.iso'></span><span id='topic+sb.iso-class'></span><span id='topic+svarmodels'></span>

<h3>Description</h3>

<p>Defines a variogram model specifying the parameter values. 
Constructor function of the <code>svarmod</code>-<code><a href="base.html#topic+class">class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svarmod(
  model,
  type = "isotropic",
  par,
  nugget = NULL,
  sill = NULL,
  range = NULL
)

svarmod.sb.iso(dk, x, z, nu, range, sill = nu)

svarmodels(type = "isotropic")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svarmod_+3A_model">model</code></td>
<td>
<p>string indicating the variogram family (see Details below).</p>
</td></tr>
<tr><td><code id="svarmod_+3A_type">type</code></td>
<td>
<p>string indicating the type of variogram, e.g. &quot;isotropic&quot;.</p>
</td></tr>
<tr><td><code id="svarmod_+3A_par">par</code></td>
<td>
<p>vector of variogram parameters.</p>
</td></tr>
<tr><td><code id="svarmod_+3A_nugget">nugget</code></td>
<td>
<p>nugget value <code class="reqn">c_0</code>.</p>
</td></tr>
<tr><td><code id="svarmod_+3A_sill">sill</code></td>
<td>
<p>variance <code class="reqn">\sigma^2</code> or sill of the variogram (NA for unbounded variograms).</p>
</td></tr>
<tr><td><code id="svarmod_+3A_range">range</code></td>
<td>
<p>range (practical range or scale parameter) of the variogram 
(NA for unbounded variograms; maybe a vector for anisotropic variograms).</p>
</td></tr>
<tr><td><code id="svarmod_+3A_dk">dk</code></td>
<td>
<p>dimension of the kappa function.</p>
</td></tr>
<tr><td><code id="svarmod_+3A_x">x</code></td>
<td>
<p>discretization nodes.</p>
</td></tr>
<tr><td><code id="svarmod_+3A_z">z</code></td>
<td>
<p>jumps (of the spectral distibution) at the discretization nodes.</p>
</td></tr>
<tr><td><code id="svarmod_+3A_nu">nu</code></td>
<td>
<p>parameter <code class="reqn">\nu_0</code> (can be thought of as the sill).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>svarmod</code> returns an <code>svarmod</code>-<code><a href="base.html#topic+class">class</a></code> object, a list
with function arguments as components.
</p>
<p><code>svarmod.sb.iso</code> returns an S3 object of <code><a href="base.html#topic+class">class</a></code> <code>sb.iso</code> 
(extends <code>svarmod</code>) corresponding to a &lsquo;nonparametric&rsquo; isotropic Shapiro-Botha model.
</p>
<p><code>svarmodels</code> returns a named character vector with the available models 
of the corresponding <code>type</code> 
(when appropriate, component values could be used as <code>cov.model</code> argument in <span class="pkg">geoR</span> routines
and component names as <code>model</code> argument in <span class="pkg">gstat</span> routines).
</p>


<h3>Note</h3>

<p><code>svarmod</code> does not check the consistency of the parameter values.
</p>


<h3>References</h3>

<p>Shapiro, A. and Botha, J.D. (1991) Variogram fitting with a general class of 
conditionally non-negative definite functions. <em>Computational Statistics 
and Data Analysis</em>, <b>11</b>, 87-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sv">sv</a></code>, <code><a href="#topic+covar">covar</a></code>.
</p>

<hr>
<h2 id='varcov'>Covariance matrix</h2><span id='topic+varcov'></span><span id='topic+varcov.isotropic'></span><span id='topic+varcov.np.svar'></span>

<h3>Description</h3>

<p>Computes the covariance matrix a corresponding to a set of spatial locations 
given a variogram model or a semivariogram estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcov(x, coords, ...)

## S3 method for class 'isotropic'
varcov(
  x,
  coords,
  sill = x$sill,
  range.taper,
  discretize = nrow(coords) &gt; 256,
  ...
)

## S3 method for class 'np.svar'
varcov(x, coords, sill = max(x$est), range.taper = x$grid$max, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varcov_+3A_x">x</code></td>
<td>
<p>variogram model (<code><a href="#topic+svarmod">svarmod</a></code> object) or semivariogram estimate.</p>
</td></tr>
<tr><td><code id="varcov_+3A_coords">coords</code></td>
<td>
<p>matrix of coordinates (columns correspond with dimensions and rows with data).</p>
</td></tr>
<tr><td><code id="varcov_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="varcov_+3A_sill">sill</code></td>
<td>
<p>(theoretical or estimated) variance <code class="reqn">C(0) = \sigma^2</code> or pseudo-sill (unbounded variograms).</p>
</td></tr>
<tr><td><code id="varcov_+3A_range.taper">range.taper</code></td>
<td>
<p>(optional) if provided, covariances corresponding to 
distances larger than this value are set to 0.</p>
</td></tr>
<tr><td><code id="varcov_+3A_discretize">discretize</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the variogram is (previously) discretized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariance matrix of the data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sv">sv</a></code>, <code><a href="#topic+covar">covar</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
