<!DOCTYPE html><html><head><title>Help for package cobs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cobs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cobs'><p>COnstrained B-Splines Nonparametric Regression Quantiles</p></a></li>
<li><a href='#cobs-methods'><p>Methods for COBS Objects</p></a></li>
<li><a href='#conreg'><p>Convex / Concave Regression</p></a></li>
<li><a href='#conreg-methods'><p>Summary Methods for 'conreg' Objects</p></a></li>
<li><a href='#drqssbc2'><p>Regression Quantile Smoothing Spline with Constraints</p></a></li>
<li><a href='#DublinWind'><p>Daily Wind Speeds in Dublin</p></a></li>
<li><a href='#exHe'><p>Small Dataset Example of He</p></a></li>
<li><a href='#globtemp'><p>Annual Average Global Surface Temperature</p></a></li>
<li><a href='#interpSplineCon'><p>(Cubic) Interpolation Spline from &quot;conreg&quot;</p></a></li>
<li><a href='#mk.pt.constr'><p>COBS auxiliary for constructing pointwise constraint specifications</p></a></li>
<li><a href='#plot.cobs'><p>Plot Method for COBS Objects</p></a></li>
<li><a href='#predict.cobs'><p>Predict method for COBS Fits</p></a></li>
<li><a href='#qbsks2'><p>Quantile B-Spline with Fixed Knots</p></a></li>
<li><a href='#scobs-internal'><p>Internal COBS functions</p></a></li>
<li><a href='#USArmyRoofs'><p>Roof Quality in US Army Bases</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3-8</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Released 1.3-7 on 2024-02-03</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Constrained B-Splines (Sparse Matrix Based)</td>
</tr>
<tr>
<td>Description:</td>
<td>Qualitatively Constrained (Regression) Smoothing Splines via
        Linear Programming and Sparse Matrices.</td>
</tr>
<tr>
<td>Author:</td>
<td>Pin T. Ng &lt;Pin.Ng@nau.edu&gt; and Martin Maechler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>SparseM (&ge; 1.6), quantreg (&ge; 4.65), grDevices, graphics,
splines, stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://curves-etc.r-forge.r-project.org/">https://curves-etc.r-forge.r-project.org/</a>,
<a href="https://r-forge.r-project.org/R/?group_id=846">https://r-forge.r-project.org/R/?group_id=846</a>,
<a href="https://r-forge.r-project.org/scm/viewvc.php/pkg/cobs/?root=curves-etc">https://r-forge.r-project.org/scm/viewvc.php/pkg/cobs/?root=curves-etc</a>,
<a href="https://www2.nau.edu/PinNg/cobs.html">https://www2.nau.edu/PinNg/cobs.html</a>,
svn://svn.r-forge.r-project.org/svnroot/curves-etc/pkg/cobs</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/R/?group_id=846">https://r-forge.r-project.org/R/?group_id=846</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 22:24:30 UTC; maechler</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cobs'>COnstrained B-Splines Nonparametric Regression Quantiles</h2><span id='topic+cobs'></span>

<h3>Description</h3>

<p>Computes constrained quantile curves using linear or
quadratic splines.  The median spline (<code class="reqn">L_1</code> loss) is a robust
(constrained) smoother.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cobs(x, y, constraint = c("none", "increase", "decrease",
                          "convex", "concave", "periodic"),
     w = rep(1,n),
     knots, nknots = if(lambda == 0) 6 else 20,
     method = "quantile", degree = 2, tau = 0.5,
     lambda = 0, ic = c("AIC", "SIC", "BIC", "aic", "sic", "bic"),
     knots.add = FALSE, repeat.delete.add = FALSE, pointwise = NULL,
     keep.data = TRUE, keep.x.ps = TRUE,
     print.warn = TRUE, print.mesg = TRUE, trace = print.mesg,
     lambdaSet = exp(seq(log(lambda.lo), log(lambda.hi), length.out = lambda.length)),
     lambda.lo = f.lambda*1e-4, lambda.hi = f.lambda*1e3, lambda.length = 25,
     maxiter = 100,
     rq.tol = 1e-8, toler.kn = 1e-6, tol.0res = 1e-6, nk.start = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cobs_+3A_x">x</code></td>
<td>
<p>vector of covariate; missing values are omitted.</p>
</td></tr>
<tr><td><code id="cobs_+3A_y">y</code></td>
<td>
<p>vector of response variable.  It must have the same length as
<code>x</code>.</p>
</td></tr>
<tr><td><code id="cobs_+3A_constraint">constraint</code></td>
<td>
<p>character (string) specifying the kind of
constraint; must be one of the values in the default list above;
may be abbreviated.  More flexible constraints can be specified via
the <code>pointwise</code> argument (below).</p>
</td></tr>
<tr><td><code id="cobs_+3A_w">w</code></td>
<td>
<p>vector of weights the same length as <code>x</code> (y) assigned to
both <code>x</code> and <code>y</code>;  default to all weights being one.
</p>
</td></tr>
<tr><td><code id="cobs_+3A_knots">knots</code></td>
<td>
<p>vector of locations of the knot mesh; if missing,
<code>nknots</code> number of <code>knots</code> will be created using the
specified <code>method</code> and automatic knot selection will be carried
out for regression B-spline (<code>lambda=0</code>); if not missing and
<code>length(knots)==nknots</code>, the provided knot mesh will be used in
the fit and no automatic knot selection will be performed;
otherwise, automatic knots selection will be performed on the
provided <code>knots</code>.</p>
</td></tr>
<tr><td><code id="cobs_+3A_nknots">nknots</code></td>
<td>
<p>maximum number of knots; defaults to 6 for regression
B-splines, 20 for smoothing B-splines.</p>
</td></tr>
<tr><td><code id="cobs_+3A_method">method</code></td>
<td>
<p>character string specifying the method for generating
<code>nknots</code> number of <code>knots</code> when <code>knots</code> is not provided;
either <code>"quantile"</code> (equally spaced in percentile levels)
or <code>"uniform"</code> (equally spaced knots); defaults to &quot;quantile&quot;.</p>
</td></tr>
<tr><td><code id="cobs_+3A_degree">degree</code></td>
<td>
<p>degree of the splines; 1 for linear spline (equivalent
to <code class="reqn">L_1</code>-roughness) and 2 for quadratic
spline (corresponding to <code class="reqn">L_{\infty}</code>
roughness); defaults to 2.</p>
</td></tr>
<tr><td><code id="cobs_+3A_tau">tau</code></td>
<td>
<p>desired quantile level; defaults to 0.5 (median).</p>
</td></tr>
<tr><td><code id="cobs_+3A_lambda">lambda</code></td>
<td>
<p>penalty parameter <code class="reqn">\lambda</code><br />
<code class="reqn">\lambda = 0</code>: no penalty (regression B-spline);<br />
<code class="reqn">\lambda &gt; 0</code>: smoothing B-spline with the given <code class="reqn">\lambda</code>;<br />
<code class="reqn">\lambda &lt; 0</code>: smoothing B-spline with <code class="reqn">\lambda</code> chosen by a
Schwarz-type information criterion.</p>
</td></tr>
<tr><td><code id="cobs_+3A_ic">ic</code></td>
<td>
<p>string indicating the information  criterion used in knot
deletion and addition for the regression B-spline method, i.e., when
<code>lambda == 0</code>;<br />
<code>"AIC"</code> (Akaike-type, equivalently <code>"aic"</code>) or<br />
<code>"SIC"</code> (Schwarz-type, equivalently <code>"BIC"</code>, <code>"sic"</code>
or <code>"bic"</code>).  Defaults to <code>"AIC"</code>.
</p>
<p><em>Note that the default was <code>"SIC"</code> up to <span class="pkg">cobs</span> version 1.1-6
(dec.2008).</em></p>
</td></tr>
<tr><td><code id="cobs_+3A_knots.add">knots.add</code></td>
<td>
<p>logical indicating if an additional step of stepwise
knot addition should be performed for regression B-splines.</p>
</td></tr>
<tr><td><code id="cobs_+3A_repeat.delete.add">repeat.delete.add</code></td>
<td>
<p>logical indicating if an additional step of stepwise
knot deletion should be performed for regression B-splines.</p>
</td></tr>
<tr><td><code id="cobs_+3A_pointwise">pointwise</code></td>
<td>
<p>an optional three-column matrix with each row
specifies one of the following constraints:
</p>

<dl>
<dt><code>( 1,xi,yi)</code>:</dt><dd><p>fitted value at xi will be <code class="reqn">\ge</code> yi;</p>
</dd>
<dt><code>(-1,xi,yi)</code>:</dt><dd><p>fitted value at xi will be <code class="reqn">\le</code> yi;</p>
</dd>
<dt><code>( 0,xi,yi)</code>:</dt><dd><p>fitted value at xi will be <code class="reqn">=</code> yi;</p>
</dd>
<dt><code>( 2,xi,yi)</code>:</dt><dd><p>derivative of the fitted function at xi
will be yi.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="cobs_+3A_keep.data">keep.data</code></td>
<td>
<p>logical indicating if the <code>x</code> and <code>y</code> input
vectors <b>after</b> removing <code><a href="base.html#topic+NA">NA</a></code>s should be kept in
the result.</p>
</td></tr>
<tr><td><code id="cobs_+3A_keep.x.ps">keep.x.ps</code></td>
<td>
<p>logical indicating if the pseudo design matrix
<code class="reqn">\tilde{X}</code> should be returned (as <em>sparse</em> matrix).
That is needed for interval prediction, <code><a href="#topic+predict.cobs">predict.cobs</a>(*,
      interval=..)</code>.</p>
</td></tr>
<tr><td><code id="cobs_+3A_print.warn">print.warn</code></td>
<td>
<p>flag for printing of interactive warning messages;
true by default; set to <code>FALSE</code> if performing simulation.</p>
</td></tr>
<tr><td><code id="cobs_+3A_print.mesg">print.mesg</code></td>
<td>

<p>logical flag or integer for printing of intermediate messages; true
by default.  Probably needs to be set to <code>FALSE</code> in simulations.</p>
</td></tr>
<tr><td><code id="cobs_+3A_trace">trace</code></td>
<td>
<p>integer <code class="reqn">\ge 0</code> indicating how much diagnostics
the low-level code in <code><a href="#topic+drqssbc2">drqssbc2</a></code> should print;  defaults
to <code>print.mesg</code>.</p>
</td></tr>
<tr><td><code id="cobs_+3A_lambdaset">lambdaSet</code></td>
<td>
<p>numeric vector of lambda values to use for grid search;
in that case, defaults to a geometric sequence (a &ldquo;grid in
log scale&rdquo;) from <code>lambda.lo</code> to <code>lambda.hi</code> of length
<code>lambda.length</code>.</p>
</td></tr>
<tr><td><code id="cobs_+3A_lambda.lo">lambda.lo</code>, <code id="cobs_+3A_lambda.hi">lambda.hi</code></td>
<td>
<p>lower and upper bound of the grid search
for lambda (when <code>lambda &lt; 0</code>).  The defaults are meant to keep
everything scale-equivariant and are hence using the factor
<code class="reqn">f = \sigma_x^d</code>, i.e.,
<code>f.lambda &lt;- sd(x)^degree</code>.

Note however that currently the underlying algorithms in package
<span class="pkg">quantreg</span> are <em>not</em> scale equivariant yet.</p>
</td></tr>
<tr><td><code id="cobs_+3A_lambda.length">lambda.length</code></td>
<td>
<p>number of grid points in the grid search for
optimal lambda.</p>
</td></tr>
<tr><td><code id="cobs_+3A_maxiter">maxiter</code></td>
<td>
<p>upper bound of the number of iterations; defaults to 100.</p>
</td></tr>
<tr><td><code id="cobs_+3A_rq.tol">rq.tol</code></td>
<td>
<p>numeric convergence tolerance for the interior point
algorithm called from <code><a href="quantreg.html#topic+rq.fit.sfnc">rq.fit.sfnc</a>()</code> or
<code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a>()</code>.</p>
</td></tr>
<tr><td><code id="cobs_+3A_toler.kn">toler.kn</code></td>
<td>
<p>numeric tolerance for shifting the boundary knots
outside; defaults to <code class="reqn">10^{-6}</code>.</p>
</td></tr>
<tr><td><code id="cobs_+3A_tol.0res">tol.0res</code></td>
<td>
<p>tolerance for testing <code class="reqn">|r_i| = 0</code>,  passed to
<code><a href="#topic+qbsks2">qbsks2</a></code> and <code><a href="#topic+drqssbc2">drqssbc2</a></code>.</p>
</td></tr>
<tr><td><code id="cobs_+3A_nk.start">nk.start</code></td>
<td>
<p>number of starting knots used in automatic knot
selection. Defaults to the minimum of 2 knots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cobs()</code> computes the constraint quantile smoothing B-spline with
penalty when lambda is not zero.<br />
If lambda &lt; 0, an optimal lambda will be chosen using Schwarz type
information criterion. <br />
If lambda &gt; 0, the supplied lambda will be used.<br />
If lambda = 0, cobs computes the constraint quantile regression B-spline
with no penalty using the provided knots or those selected by Akaike or
Schwarz information criterion.
</p>


<h3>Value</h3>

<p>an object of class <code>cobs</code>, a list with components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the <code>cobs(..)</code> call used for creation.</p>
</td></tr>
<tr><td><code>tau</code>, <code>degree</code></td>
<td>
<p>same as input</p>
</td></tr>
<tr><td><code>constraint</code></td>
<td>
<p>as input (but no more abbreviated).</p>
</td></tr>
<tr><td><code>pointwise</code></td>
<td>
<p>as input.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>B-spline coefficients.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>the final set of knots used in the computation.</p>
</td></tr>
<tr><td><code>ifl</code></td>
<td>
<p>exit code := <code>1 + ierr</code> and <code>ierr</code> is the error
from <code><a href="quantreg.html#topic+rq.fit.sfnc">rq.fit.sfnc</a></code> (package <span class="pkg">quantreg</span>);
consequently, <code>ifl = 1</code> means &ldquo;success&rdquo;; all other
values point to algorithmic problems or failures.</p>
</td></tr>
<tr><td><code>icyc</code></td>
<td>
<p>length 2: number of cycles taken to achieve convergence
for final lambda, and total number of cycles for all lambdas.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the effective dimensionality of the final fit.</p>
</td></tr>
<tr><td><code>k0</code></td>
<td>
<p>(usually the same)</p>
</td></tr>
<tr><td><code>x.ps</code></td>
<td>
<p>the pseudo design matrix <code class="reqn">X</code> (as returned by
<code><a href="#topic+qbsks2">qbsks2</a></code>).</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>vector of residuals from the fit.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>vector of fitted values from the fit.</p>
</td></tr>
<tr><td><code>SSy</code></td>
<td>
<p>the sum of squares around centered <code>y</code> (e.g. for
computation of <code class="reqn">R^2</code>.)</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the penalty parameter used in the final fit.</p>
</td></tr>
<tr><td><code>pp.lambda</code></td>
<td>
<p>vector of all lambdas used for
lambda search when <code>lambda</code> &lt; 0 on input.</p>
</td></tr>
<tr><td><code>pp.sic</code></td>
<td>
<p>vector of Schwarz information criteria evaluated at
<code>pp.lambda</code>; note that it is not quite sure how good these are
for determining an optimal <code>lambda</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ng, P. and Maechler, M. (2007)
A Fast and Efficient Implementation of Qualitatively Constrained Quantile Smoothing Splines,
<em>Statistical Modelling</em> <b>7(4)</b>, 315-328.
</p>
<p>Koenker, R. and Ng, P. (2005)
Inequality Constrained Quantile Regression,
<em>Sankhya, The Indian Journal of Statistics</em> <b>67</b>, 418&ndash;440.
</p>
<p>He, X. and Ng, P. (1999)
COBS: Qualitatively Constrained Smoothing via Linear Programming;
<em>Computational Statistics</em> <b>14</b>, 315&ndash;337.
</p>
<p>Koenker, R. and Ng, P. (1996)
A Remark on Bartels and Conn's Linearly Constrained L1 Algorithm,
<em>ACM Transaction on Mathematical Software</em> <b>22</b>, 493&ndash;495.
</p>
<p>Ng, P. (1996)
An Algorithm for Quantile Smoothing Splines,
<em>Computational Statistics &amp; Data Analysis</em> <b>22</b>, 99&ndash;118.
</p>
<p>Bartels, R. and Conn A. (1980)
Linearly Constrained Discrete <code class="reqn">L_1</code> Problems,
<em>ACM Transaction on Mathematical Software</em> <b>6</b>, 594&ndash;608.
</p>
<p>A postscript version of the paper that describes the details of COBS
can be downloaded from <a href="https://www2.nau.edu/PinNg/cobs.html">https://www2.nau.edu/PinNg/cobs.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for unconstrained smoothing
splines; <code><a href="splines.html#topic+bs">bs</a></code> for unconstrained (regression)
B-splines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-1,3,,150)
y &lt;- (f.true &lt;- pnorm(2*x)) + rnorm(150)/10
## specify pointwise constraints (boundary conditions)
con &lt;- rbind(c( 1,min(x),0), # f(min(x)) &gt;= 0
             c(-1,max(x),1), # f(max(x)) &lt;= 1
             c(0,  0,   0.5))# f(0)      = 0.5

## obtain the median  REGRESSION  B-spline using automatically selected knots
Rbs &lt;- cobs(x,y, constraint= "increase", pointwise = con)
Rbs
plot(Rbs, lwd = 2.5)
lines(spline(x, f.true), col = "gray40")
lines(predict(cobs(x,y)), col = "blue")
mtext("cobs(x,y)   # completely unconstrained", 3, col= "blue")

## compute the median  SMOOTHING  B-spline using automatically chosen lambda
Sbs &lt;- cobs(x,y, constraint="increase", pointwise= con, lambda= -1)
summary(Sbs)
plot(Sbs) ## by default  includes  SIC ~ lambda

Sb1 &lt;- cobs(x,y, constraint="increase", pointwise= con, lambda= -1,
            degree = 1)
summary(Sb1)
plot(Sb1)

plot(Sb1, which = 2) # only the  data + smooth
rug(Sb1$knots, col = 4, lwd = 1.6)# (too many knots)
xx &lt;- seq(min(x) - .2, max(x)+ .2, len = 201)
pxx &lt;- predict(Sb1, xx, interval = "both")
lines(pxx, col = 2)
mtext(" + pointwise and simultaneous 95% - confidence intervals")
matlines(pxx[,1], pxx[,-(1:2)], col= rep(c("green3","blue"), c(2,2)), lty=2)
</code></pre>

<hr>
<h2 id='cobs-methods'>Methods for COBS Objects</h2><span id='topic+coef.cobs'></span><span id='topic+fitted.cobs'></span><span id='topic+knots.cobs'></span><span id='topic+print.cobs'></span><span id='topic+residuals.cobs'></span><span id='topic+summary.cobs'></span>

<h3>Description</h3>

<p>Print, summary and other methods for <code><a href="#topic+cobs">cobs</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cobs'
print(x, digits = getOption("digits"), ...)
## S3 method for class 'cobs'
summary(object, digits = getOption("digits"), ...)

## S3 method for class 'cobs'
coef(object, ...)
## S3 method for class 'cobs'
fitted(object, ...)
## S3 method for class 'cobs'
knots(Fn, ...)
## S3 method for class 'cobs'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cobs-methods_+3A_x">x</code>, <code id="cobs-methods_+3A_object">object</code>, <code id="cobs-methods_+3A_fn">Fn</code></td>
<td>
<p>object of class <code>cobs</code>.</p>
</td></tr>
<tr><td><code id="cobs-methods_+3A_digits">digits</code></td>
<td>
<p>number of digits to use for printing.</p>
</td></tr>
<tr><td><code id="cobs-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed from and to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for fitted COBS objects, as computed by
<code><a href="#topic+cobs">cobs</a></code>.
</p>


<h3>Value</h3>

<p><code>print.cobs()</code> returns its argument invisibly.
The <code>coef()</code>, <code>fitted()</code>, <code>knots()</code>, and
<code>residuals()</code> methods return a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.cobs">predict.cobs</a></code> for the <code><a href="stats.html#topic+predict">predict</a></code> method,
<code><a href="#topic+plot.cobs">plot.cobs</a></code> for the <code><a href="graphics.html#topic+plot">plot</a></code> method,
and <code><a href="#topic+cobs">cobs</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(cobs)
Sbs # uses print.*

summary(Sbs)

coef(Sbs)
knots(Sbs)
</code></pre>

<hr>
<h2 id='conreg'>Convex / Concave Regression</h2><span id='topic+conreg'></span>

<h3>Description</h3>

<p>Compute a univariate concave or convex regression, i.e.,
for given vectors, <code class="reqn">x,y,w</code> in <code class="reqn">R^n</code>, where <code class="reqn">x</code> has to be
strictly sorted (<code class="reqn">x_1 &lt; x_2 &lt; \ldots &lt; x_n</code>), compute an
<code class="reqn">n</code>-vector <code class="reqn">m</code> minimizing the weighted sum of squares
<code class="reqn">\sum_{i=1}^n {w_i (y_i - m_i)^2}</code>
under the constraints
</p>
<p style="text-align: center;"><code class="reqn">(m_i - m_{i-1})/(x_i - x_{i-1}) \ge (m_{i+1} - m_i)/(x_{i+1} - x_i),</code>
</p>

<p>for <code class="reqn">1 \le i \le n</code> and
<code class="reqn">m_0 := m_{n+1} := -\infty</code>,
for concavity.
For convexity (<code>convex=TRUE</code>), replace <code class="reqn">\ge</code> by
<code class="reqn">\le</code> and <code class="reqn">-\infty</code> by <code class="reqn">+\infty</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conreg(x, y = NULL, w = NULL, convex = FALSE,
       method = c("Duembgen06_R", "SR"),
       tol = c(1e-10, 1e-7), maxit = c(500, 20),
       adjTol = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conreg_+3A_x">x</code>, <code id="conreg_+3A_y">y</code></td>
<td>
<p>numeric vectors giving the values of the predictor and
response variable.  Alternatively a single &ldquo;plotting&rdquo;
structure (two-column matrix / y-values only / list, etc) can be
specified: see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.</p>
</td></tr>
<tr><td><code id="conreg_+3A_w">w</code></td>
<td>
<p>for <code>method</code> <code>"Duembgen06_R"</code> only: optional vector
of weights of the same length as <code>x</code>; defaults to all 1.</p>
</td></tr>
<tr><td><code id="conreg_+3A_convex">convex</code></td>
<td>
<p>logical indicating if convex or concave regression is
desired.</p>
</td></tr>
<tr><td><code id="conreg_+3A_method">method</code></td>
<td>
<p>a character string indicating the method used,
</p>

<dl>
<dt>&quot;Duembgen06_R&quot;</dt><dd><p>is an active set method written by Lutz
Duembgen (University of Berne, CH) in Matlab in 2006 and
translated to <span class="rlang"><b>R</b></span> by Martin Maechler.</p>
</dd>
<dt>&quot;SR&quot;</dt><dd><p>is an <span class="rlang"><b>R</b></span> interface to the C code of a <b>S</b>upport
<b>R</b>eduction algorithm written by Piet Groeneboom (TU Delft,
NL) and donated to the <span class="pkg">cobs</span> package in July 2012.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="conreg_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance(s); do not make this too small!</p>
</td></tr>
<tr><td><code id="conreg_+3A_maxit">maxit</code></td>
<td>
<p>maximal number of (outer and inner) iterations of knot
selection.</p>
</td></tr>
<tr><td><code id="conreg_+3A_adjtol">adjTol</code></td>
<td>
<p>(for <code>"Duembgen06_R"</code> only:) logical indicating if
the convergence test tolerance is to be adjusted (increased) in some cases.</p>
</td></tr>
<tr><td><code id="conreg_+3A_verbose">verbose</code></td>
<td>
<p>logical or integer indicating if (and how much) knot
placement and fitting iterations should be &ldquo;reported&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both algorithms need some numerical tolerances because of rounding
errors in computation of finite difference ratios.
The active-set <code>"Duembgen06_R"</code> method notably has two different
such tolerances which were both <code>1e-7</code><code class="reqn">= 10^{7}</code> up to March
2016.
</p>
<p>The two default tolerances (and the exact convergence checks) may
change in the future, possibly to become more adaptive.
</p>


<h3>Value</h3>

<p>an object of class <code>conreg</code> which is basically a list with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>sorted (and possibly aggregated) abscissa values <code>x</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>corresponding y values.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>corresponding weights, <b>only</b> for <code>"Duembgen06_R"</code>.</p>
</td></tr>
<tr><td><code>yf</code></td>
<td>
<p>corresponding fitted values.</p>
</td></tr>
<tr><td><code>convex</code></td>
<td>
<p>logical indicating if a convex or a concave fit has been
computed.</p>
</td></tr>
<tr><td><code>iKnots</code></td>
<td>
<p>integer vector giving indices of the <em>knots</em>,
i.e. locations where the fitted curve has kinks.
Formally, these are exactly those indices where the constraint is
fulfilled strictly, i.e., those <code class="reqn">i</code> where
</p>
<p style="text-align: center;"><code class="reqn">(m_i - m_{i-1})/(x_i-x_{i-1}) &gt; (m_{i+1} - m_i)/(x_{i+1}-x_i).</code>
</p>

</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+call">call</a></code> to <code>conreg()</code> used.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>integer (vector of length one or two) with the number of
iterations used (in the outer and inner loop for <code>"Duembgen06_R"</code>).</p>
</td></tr>



</table>
<p>Note that there are several methods defined for <code>conreg</code> objects,
see <code><a href="#topic+predict.conreg">predict.conreg</a></code> or <code><a href="utils.html#topic+methods">methods</a>(class = "conreg")</code>.
</p>
<p>Notably <code>print</code> and <code>plot</code>; also
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="stats.html#topic+knots">knots</a></code>.
</p>
<p>Also, <code><a href="#topic+interpSplineCon">interpSplineCon</a>()</code> to construct a more smooth
(<em>cubic</em>) spline, and <code><a href="#topic+isIsplineCon">isIsplineCon</a>()</code> which checks
if the int is strictly concave or convex the same as the
<code>conreg()</code> result from which it was constructed.
</p>


<h3>Author(s)</h3>

<p>Lutz Duembgen programmed the original Matlab code in July 2006;
Martin Maechler ported it to <span class="rlang"><b>R</b></span>, tested, catch infinite loops, added
more options, improved tolerance, etc;  from April 27, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+isoreg">isoreg</a></code> for isotone (monotone) regression;
CRAN packages <span class="pkg">ftnonpar</span>, <span class="pkg">cobs</span>, <span class="pkg">logcondens</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generated data :
N &lt;- 100
f &lt;- function(X) 4*X*(1 - X)

xx &lt;- seq(0,1, length=501)# for plotting true f()
set.seed(1)# -&gt; conreg does not give convex cubic

x &lt;- sort(runif(N))
y &lt;- f(x) + 0.2 * rnorm(N)
plot(x,y, cex = 0.6)
lines(xx, f(xx), col = "blue", lty=2)
rc &lt;- conreg(x,y)
lines(rc, col = 2, force.iSpl = TRUE)
 # 'force.iSpl': force the drawing of the cubic spline through the kinks
title("Concave Regression in R")

y2 &lt;- y


## Trivial cases work too:
(r.1 &lt;- conreg(1,7))
(r.2 &lt;- conreg(1:2,7:6))
(r.3  &lt;- conreg(1:3,c(4:5,1)))
</code></pre>

<hr>
<h2 id='conreg-methods'>Summary Methods for 'conreg' Objects</h2><span id='topic+fitted.conreg'></span><span id='topic+residuals.conreg'></span><span id='topic+knots.conreg'></span><span id='topic+lines.conreg'></span><span id='topic+plot.conreg'></span><span id='topic+predict.conreg'></span><span id='topic+print.conreg'></span>

<h3>Description</h3>

<p>Methods for <code><a href="#topic+conreg">conreg</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conreg'
fitted(object, ...)
## S3 method for class 'conreg'
residuals(object, ...)
## S3 method for class 'conreg'
knots(Fn, ...)

## S3 method for class 'conreg'
lines(x, type = "l", col = 2, lwd = 1.5, show.knots = TRUE,
      add.iSpline = TRUE, force.iSpl = FALSE, ...)

## S3 method for class 'conreg'
plot(x, type = "l", col = 2, lwd = 1.5, show.knots = TRUE,
    add.iSpline = TRUE, force.iSpl = FALSE,
    xlab = "x", ylab = expression(s[c](x)),
    sub = "simple concave regression", col.sub = col, ...)

## S3 method for class 'conreg'
predict(object, x, deriv = 0, ...)

## S3 method for class 'conreg'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conreg-methods_+3A_object">object</code>, <code id="conreg-methods_+3A_fn">Fn</code>, <code id="conreg-methods_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>conreg</code>, i.e., typically
the result of <code><a href="#topic+conreg">conreg</a>(..)</code>.   For <code>predict()</code>,
<code>x</code> is a numeric vector of abscissa values at which to evaluate
the concave/convex spline function.</p>
</td></tr>
<tr><td><code id="conreg-methods_+3A_type">type</code>, <code id="conreg-methods_+3A_col">col</code>, <code id="conreg-methods_+3A_lwd">lwd</code>, <code id="conreg-methods_+3A_xlab">xlab</code>, <code id="conreg-methods_+3A_ylab">ylab</code>, <code id="conreg-methods_+3A_sub">sub</code>, <code id="conreg-methods_+3A_col.sub">col.sub</code></td>
<td>
<p>plotting arguments as in
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="conreg-methods_+3A_show.knots">show.knots</code></td>
<td>
<p>logical indicating the spline knots should be marked
additionally.</p>
</td></tr>
<tr><td><code id="conreg-methods_+3A_add.ispline">add.iSpline</code></td>
<td>
<p>logical indicating if an <em>interpolation</em>
spline should be considered for plotting. This is only used when it
is itself concave/convex, <b>unless</b> <code>force.iSpl</code> is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conreg-methods_+3A_force.ispl">force.iSpl</code></td>
<td>
<p>logical indicating if an interpolating spline is drawn
even when it is not convex/concave.</p>
</td></tr>
<tr><td><code id="conreg-methods_+3A_deriv">deriv</code></td>
<td>
<p>for <code>predict</code>, integer specifying the derivate to be
computed; currently must be <code>0</code> or <code>1</code>.</p>
</td></tr>
<tr><td><code id="conreg-methods_+3A_digits">digits</code></td>
<td>
<p>number of significant digits for printing.</p>
</td></tr>
<tr><td><code id="conreg-methods_+3A_...">...</code></td>
<td>
<p>further arguments, potentially passed to methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+conreg">conreg</a></code>, ....
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(conreg, echo = FALSE)
class(rc) # "conreg"
rc # calls the print method
knots(rc)
plot(rc)
## and now _force_ the not-quite-concave cubic spline :
plot(rc, force.iSpl=TRUE)

xx &lt;- seq(-0.1, 1.1, length=201) # slightly extrapolate
## Get function s(x)  and first derivative  s'(x) :
yx &lt;- predict(rc, xx)
y1 &lt;- predict(rc, xx, deriv = 1)

op &lt;- par(las=1)
plot(xx, yx, type = "l",
     main="plot(xx,  predict( conreg(.), xx))")
par(new=TRUE) # draw the first derivative "on top"
plot(xx, y1, type = "l", col = "blue",
     axes = FALSE, ann = FALSE)
abline(h = 0, lty="1A", col="blue")
axis(4, col="blue", col.axis="blue", col.ticks="blue")
mtext("first derivative s'(.)", col="blue")
par(op)
</code></pre>

<hr>
<h2 id='drqssbc2'>Regression Quantile Smoothing Spline with Constraints</h2><span id='topic+drqssbc2'></span>

<h3>Description</h3>

<p>Estimate the B-spline coefficients for a regression quantile
<em>smoothing</em> spline with optional constraints, using Ng(1996)'s
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drqssbc2(x, y, w = rep.int(1,n), pw, knots, degree, Tlambda,
        constraint, ptConstr, maxiter = 100, trace = 0,
        nrq = length(x), nl1, neqc, niqc, nvar,
        tau = 0.5, select.lambda, give.pseudo.x = FALSE,
        rq.tol = 1e-8 * sc.y, tol.0res = 1e-6,
        print.warn = TRUE, rq.print.warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drqssbc2_+3A_x">x</code></td>
<td>
<p>numeric vector, sorted increasingly, the abscissa values</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_y">y</code></td>
<td>
<p>numeric, same length as <code>x</code>, the observations.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_w">w</code></td>
<td>
<p>numeric vector of weights, same length as <code>x</code>, as in
<code><a href="#topic+cobs">cobs</a></code>.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_pw">pw</code></td>
<td>
<p>penalty weights vector passed to <code><a href="#topic+l1.design2">l1.design2</a></code> or
<code><a href="#topic+loo.design2">loo.design2</a></code>. <b>FIXME</b>: This is currently unused.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_knots">knots</code></td>
<td>
<p>numeric vector of knots for the splines.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_degree">degree</code></td>
<td>
<p>integer, must be 1 or 2.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_tlambda">Tlambda</code></td>
<td>
<p>vector of smoothing parameter values <code class="reqn">\lambda</code>; if
it is longer than one, an &ldquo;optimal&rdquo; value will be selected
from these.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_constraint">constraint</code></td>
<td>
<p>see <code><a href="#topic+cobs">cobs</a></code> (but cannot be abbreviated here).</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_ptconstr">ptConstr</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> of <b>p</b>oin<b>t</b>wise constraints;
notably <code>equal</code>, <code>smaller</code>, <code>greater</code> and <code>gradient</code>
are 3-column matrices specifying the respective constraints.  May have
0 rows if there are no constraints of the corresponding kind.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number of iterations; defaults to 100.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_trace">trace</code></td>
<td>
<p>integer or logical indicating the tracing level of the
<em>underlying</em> algorithms; not much implemented (due to lack of trace
in quantreg ...)</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_nrq">nrq</code></td>
<td>
<p>integer, <code class="reqn">= n</code>, the number of observations.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_nl1">nl1</code></td>
<td>
<p>integer, number of observations in the l1 norm that
correspond to roughness measure (may be zero).</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_neqc">neqc</code></td>
<td>
<p>integer giving the number of equations.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_niqc">niqc</code></td>
<td>
<p>integer giving the number of <b>i</b>ne<b>q</b>uality
<b>c</b>onstraints; of the same length as <code>constraint</code>.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_nvar">nvar</code></td>
<td>
<p>integer giving the number of equations <em>and</em> constraints.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_tau">tau</code></td>
<td>
<p>desired quantile level; defaults to 0.5 (median).</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_select.lambda">select.lambda</code></td>
<td>
<p>logical indicating if an optimal lambda should be
selected from the vector of <code>Tlambda</code>.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_give.pseudo.x">give.pseudo.x</code></td>
<td>
<p>logical indicating if the pseudo design matrix
<code class="reqn">\tilde{X}</code> should be returned (as <em>sparse</em> matrix).</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_rq.tol">rq.tol</code></td>
<td>
<p>numeric convergence tolerance for the interior point
algorithm called from <code><a href="quantreg.html#topic+rq.fit.sfnc">rq.fit.sfnc</a>()</code> or
<code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a>()</code>.  Note that (for scale
invariance) this has to be in units of <code>y</code>, which the default
makes use of.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_tol.0res">tol.0res</code></td>
<td>
<p>tolerance used to check for zero residuals, i.e.,
<code class="reqn">|r_i| &lt; tol * mean(|r_i|)</code>.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_print.warn">print.warn</code></td>
<td>
<p>logical indicating if warnings should be printed,
when the algorithm seems to have behaved somewhat unexpectedly.</p>
</td></tr>
<tr><td><code id="drqssbc2_+3A_rq.print.warn">rq.print.warn</code></td>
<td>
<p>logical indicating if warnings should be printed
from inside the <code>rq.*</code> function calls, see below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an auxiliary function for <code><a href="#topic+cobs">cobs</a></code>, possibly
interesting on its own.  Depending on <code>degree</code>, either
<code><a href="#topic+l1.design2">l1.design2</a></code> or <code><a href="#topic+loo.design2">loo.design2</a></code> are
called for construction of the sparse design matrix.
</p>
<p>Subsequently, either <code><a href="quantreg.html#topic+rq.fit.sfnc">rq.fit.sfnc</a></code> or
<code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a></code> is called as the main &ldquo;work horse&rdquo;.
</p>
<p>This documentation is currently sparse; read the source code!
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>comp1</code></td>
<td>
<p>Description of &lsquo;comp1&rsquo;</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>Description of &lsquo;comp2&rsquo;</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p>Pin Ng; this help page: Martin Maechler.</p>


<h3>References</h3>

<p>Ng, P. (1996)
An Algorithm for Quantile Smoothing Splines,
<em>Computational Statistics &amp; Data Analysis</em> <b>22</b>, 99&ndash;118.
</p>


<h3>See Also</h3>

<p>The main function <code><a href="#topic+cobs">cobs</a></code> and its auxiliary
<code><a href="#topic+qbsks2">qbsks2</a></code> which calls <code>drqssbc2()</code> repeatedly.
</p>
<p><code><a href="#topic+l1.design2">l1.design2</a></code> and <code><a href="#topic+loo.design2">loo.design2</a></code>;
further <code><a href="quantreg.html#topic+rq.fit.sfnc">rq.fit.sfnc</a></code> and
<code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a></code> from package <span class="pkg">quantreg</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1243)
x  &lt;- 1:32
fx &lt;- (x-5)*(x-15)^2*(x-21)
y  &lt;- fx + round(rnorm(x,s = 0.25),2)
</code></pre>

<hr>
<h2 id='DublinWind'>Daily Wind Speeds in Dublin</h2><span id='topic+DublinWind'></span>

<h3>Description</h3>

<p>The <code>DublinWind</code> data frame is basically the time series of daily
average wind speeds from 1961 to 1978, measured in Dublin, Ireland.
These are 6574 observations (18 full years among which four leap years).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DublinWind)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>speed</dt><dd><p>numeric vector of average daily wind speed in knots</p>
</dd>
<dt>day</dt><dd><p>an integer vector giving the day number of the year,
i.e., one of 1:366.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The periodic pattern along the 18 years measured and the
autocorrelation are to be taken into account for analysis, see the
references.  This is Example 3 of the COBS paper.
</p>


<h3>Source</h3>

<p>From shar file available from <a href="https://www2.nau.edu/PinNg/cobs.html">https://www2.nau.edu/PinNg/cobs.html</a>
</p>
<p>Has also been available from Statlib; then, with more variables, e.g., in
<code>help(wind, package = "gstat")</code> from CRAN package <a href="https://CRAN.R-project.org/package=gstat"><span class="pkg">gstat</span></a>.
</p>


<h3>References</h3>

<p>Haslett, J. and Raftery, A. (1989)
Space-Time Modelling with Long-Memory Dependence: Assessing
Ireland's Wind Power Resource (with Discussion: 22-50).
<em>Applied Statistics</em> <b>38</b>, 1&ndash;50.
<a href="https://doi.org/10.2307/2347679">doi:10.2307/2347679</a>
</p>
<p>COBS: Qualitatively Constrained Smoothing via Linear Programming;
<em>Computational Statistics</em> <b>14</b>, 315&ndash;337.
</p>
<p>He, X. and Ng, P. (1999)
COBS: Qualitatively Constrained Smoothing via Linear Programming;
<em>Computational Statistics</em> <b>14</b>, 315&ndash;337.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DublinWind)
str(DublinWind)
plot(speed ~ day, data = DublinWind)# not so nice; want time scale

## transform 'day' to correct "Date" object; and then plot
Dday &lt;- seq(from = as.Date("1961-01-01"), by = 1,
            length = nrow(DublinWind))
plot(speed ~ Dday, data = DublinWind, type = "l",
     main = paste("DublinWind speed daily data, n=",
                  nrow(DublinWind)))

##--- ~ He &amp; Ng "Example 3" %% much more is in ../tests/wind.R
co.o50 &lt;-
 with(DublinWind, ## use nknots &gt; (default) 6 :
  cobs(day, speed, knots.add = TRUE, constraint= "periodic", nknots = 10,
       tau = .5, method = "uniform"))
summary(co.o50)
lines(Dday, fitted(co.o50), col=2, lwd = 2)

## the periodic "smooth" function - in one period
plot(predict(co.o50), type = "o", cex = 0.2, col=2,
     xlab = "day", ylim = c(0,20))
points(speed ~ day, data = DublinWind, pch = ".")
</code></pre>

<hr>
<h2 id='exHe'>Small Dataset Example of He</h2><span id='topic+exHe'></span>

<h3>Description</h3>

<p>The <code>exHe</code> data frame has 10 rows and 2 columns.  It is an
example for which <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> cannot be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exHe)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x</dt><dd><p>only values 0, 1, and 2.</p>
</dd>
<dt>y</dt><dd><p>10 randomly generated values</p>
</dd>
</dl>



<h3>Details</h3>

<p>Xuming He wrote about this
<b>JUST FOR FUN:</b><br />
I was testing COBS using the following &quot;data&quot;. For comparison, I tried
smooth.spline in S+. I never got an answer back! No warning messages either.
The point is that even the well-tested algorithm like
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> could leave you puzzled.
</p>
<p>To tell you the truth, the response values here were generated by white
noise.  An ideal fitted curve would be a flat line.  See for yourself what
COBS would do in this case.
</p>


<h3>Source</h3>

<p>Originally found at the bottom of
<code style="white-space: pre;">&#8288;http://ux6.cso.uiuc.edu/~x-he/ftp.html&#8288;</code>, the web resource
directory of Xuming He at the time, say 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cobs">cobs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exHe)
plot(exHe, main = "He's 10 point example and cobs() fits")
tm &lt;- tapply(exHe$y, exHe$x, mean)
lines(unique(exHe$x), tm, lty = 2)

cH. &lt;- with(exHe,
    cobs(x, y, degree=1, constraint = "increase"))
cH &lt;- with(exHe,
    cobs(x, y, lambda=0.2, degree=1, constraint = "increase"))
plot(exHe)
lines(predict(cH.), type = "o", col="tomato3", pch = "i")# constant
lines(predict(cH), type = "o", col=2, pch = "i")

cHn &lt;- cobs(exHe$x, exHe$y, degree=1, constraint = "none")
lines(predict(cHn), col= 3, type = "o", pch = "n")

cHd &lt;- cobs(exHe$x, exHe$y, degree=1, constraint = "decrease")
lines(predict(cHd), col= 4, type = "o", pch = "d")
</code></pre>

<hr>
<h2 id='globtemp'>Annual Average Global Surface Temperature</h2><span id='topic+globtemp'></span>

<h3>Description</h3>

<p>Time Series of length 113 of annual average global surface temperature
deviations from 1880 to 1992.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(globtemp)</code></pre>


<h3>Details</h3>

<p>This is Example 1 of the COBS paper, where the hypothesis of a
monotonely increasing trend is considered; Koenker and Schorfheide
(1994) consider modeling the autocorrelations.
</p>


<h3>Source</h3>

<p>&lsquo;<span class="file">temp.data</span>&rsquo; in file &lsquo;<span class="file">cobs.shar</span>&rsquo; available from
<a href="https://www2.nau.edu/PinNg/cobs.html">https://www2.nau.edu/PinNg/cobs.html</a>
</p>


<h3>References</h3>

<p>He, X. and Ng, P. (1999)
COBS: Qualitatively Constrained Smoothing via Linear Programming;
<em>Computational Statistics</em> <b>14</b>, 315&ndash;337.
</p>
<p>Koenker, R. and Schorfheide F. (1994)
Quantile Spline Models for Global Temperature Change;
<em>Climate Change</em> <b>28</b>, 395&ndash;404.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(globtemp)
plot(globtemp, main = "Annual Global Temperature Deviations")
str(globtemp)
## forget about time-series, just use numeric vectors:
year &lt;- as.vector(time(globtemp))
temp &lt;- as.vector(globtemp)

##---- Code for Figure 1a of He and Ng (1999) ----------

a50 &lt;- cobs(year, temp, knots.add = TRUE, degree = 1, constraint = "increase")
summary(a50)
## As suggested in the warning message, we increase the number of knots to 9
a50 &lt;- cobs(year, temp, nknots = 9, knots.add = TRUE, degree = 1,
            constraint = "increase")
summary(a50)
## Here, we use the same knots sequence chosen for the 50th percentile
a10 &lt;- cobs(year, temp, nknots = length(a50$knots), knots = a50$knot,
            degree = 1, tau = 0.1, constraint = "increase")
summary(a10)
a90 &lt;- cobs(year, temp, nknots = length(a50$knots), knots = a50$knot,
            degree = 1, tau = 0.9, constraint = "increase")
summary(a90)

which(hot.idx  &lt;- temp &gt;= a90$fit)
which(cold.idx &lt;- temp &lt;= a10$fit)
normal.idx &lt;- !hot.idx &amp; !cold.idx

plot(year, temp, type = "n", ylab = "Temperature (C)", ylim = c(-.7,.6))
lines(predict(a50, year, interval = "both"), col = 2)
lines(predict(a10, year, interval = "both"), col = 3)
lines(predict(a90, year, interval = "both"), col = 3)
points(year, temp, pch = c(1,3)[2 - normal.idx])

## label the "hot" and "cold" days
text(year[hot.idx], temp[hot.idx] + .03, labels = year[hot.idx])
text(year[cold.idx],temp[cold.idx]- .03, labels = year[cold.idx])
</code></pre>

<hr>
<h2 id='interpSplineCon'>(Cubic) Interpolation Spline from &quot;conreg&quot;</h2><span id='topic+interpSplineCon'></span><span id='topic+isIsplineCon'></span>

<h3>Description</h3>

<p>From a <code>"<a href="#topic+conreg">conreg</a>"</code> object representing a <em>linear</em>
spline,
</p>

<dl>
<dt><code>interpSplineCon()</code></dt><dd><p>produces the corresponding (cubic)
spline (via package <span class="pkg">splines</span>' <code><a href="splines.html#topic+interpSpline">interpSpline</a>()</code>)
by interpolating at the knots, thus &ldquo;smoothing the kinks&rdquo;.</p>
</dd>
<dt><code>isIsplineCon()</code></dt><dd><p>determines if the spline fulfills the
same convexity / concavity constraints as the underlying
<code>"<a href="#topic+conreg">conreg</a>"</code> object.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>interpSplineCon(object, ...)
isIsplineCon(object, isp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpSplineCon_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object as resulting from <code><a href="#topic+conreg">conreg</a>()</code>.</p>
</td></tr>
<tr><td><code id="interpSplineCon_+3A_isp">isp</code></td>
<td>
<p>optionally, the result of <code>interpSplineCon(object,
      ...)</code>; useful if that is already available in the caller.</p>
</td></tr>
<tr><td><code id="interpSplineCon_+3A_...">...</code></td>
<td>
<p>optional further arguments passed to
<code><a href="splines.html#topic+interpSpline">interpSpline</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>interpSplineCon()</code></dt><dd><p>returns the
<code><a href="splines.html#topic+interpSpline">interpSpline</a>()</code> interpolation spline object.</p>
</dd>
<dt><code>isIsplineCon()</code></dt><dd><p>is <code>TRUE</code> (or <code>FALSE</code>),
indicating if the convexity/concavity constraints are fulfilled (in
knot intervals).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+conreg">conreg</a></code>, <code><a href="splines.html#topic+interpSpline">interpSpline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cc &lt;- conreg(cars[,"speed"], cars[,"dist"], convex=TRUE)
iS &lt;- interpSplineCon(cc)
(isC &lt;- isIsplineCon(cc)) # FALSE: not strictly convex
## Passing the interpolation spline --- if you have it anyway ---
## is more efficient (faster) :
stopifnot(identical(isC,
                    isIsplineCon(cc, isp = iS)))

## the interpolation spline is not quite convex:
plot(cc)
with(cars, points(dist ~ speed, col = adjustcolor(1, 1/2)))
lines(predict(iS, seq(1,28, by=1/4)),
      col = adjustcolor("forest green", 3/4), lwd=2)
</code></pre>

<hr>
<h2 id='mk.pt.constr'>COBS auxiliary for constructing pointwise constraint specifications</h2><span id='topic+mk.pt.constr'></span>

<h3>Description</h3>

<p>COBS (<code><a href="#topic+cobs">cobs</a></code>) auxiliary function for constructing the
pointwise constraint specification list from the <code>pointwise</code>
3-column matrix (as used as argument in <code><a href="#topic+cobs">cobs</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk.pt.constr(pointwise)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mk.pt.constr_+3A_pointwise">pointwise</code></td>
<td>
<p>numeric 3-column matrix, see <code>pointwise</code> in <code><a href="#topic+cobs">cobs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>n.equal</code></td>
<td>
<p>number of equality constraints</p>
</td></tr>
<tr><td><code>n.greater</code></td>
<td>
<p>number of &ldquo;greater&rdquo; constraints</p>
</td></tr>
<tr><td><code>n.smaller</code></td>
<td>
<p>number of &ldquo;smaller&rdquo; constraints</p>
</td></tr>
<tr><td><code>n.gradient</code></td>
<td>
<p>number of gradient constraints</p>
</td></tr>
</table>
<p>Unless the input <code>pointwise</code> was <code>NULL</code>, the result also
has corresponding components:
</p>
<table>
<tr><td><code>equal</code></td>
<td>
<p>3-column matrix ofequality constraints</p>
</td></tr>
<tr><td><code>greater</code></td>
<td>
<p>3-column matrix of&ldquo;greater&rdquo; constraints</p>
</td></tr>
<tr><td><code>smaller</code></td>
<td>
<p>3-column matrix of&ldquo;smaller&rdquo; constraints</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>3-column matrix ofgradient constraints</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## from  ?cobs:
 x &lt;- seq(-1,3,,150)
 con &lt;- rbind(c( 1,min(x),0), # f(min(x)) &gt;= 0
              c(-1,max(x),1), # f(max(x)) &lt;= 1
              c(0,  0,   0.5))# f(0)      = 0.5
 r &lt;- mk.pt.constr(con)
 str(r)
</code></pre>

<hr>
<h2 id='plot.cobs'>Plot Method for COBS Objects</h2><span id='topic+plot.cobs'></span>

<h3>Description</h3>

<p>The <code><a href="graphics.html#topic+plot">plot</a></code> method for <code><a href="#topic+cobs">cobs</a></code> objects.
If there was <code>lambda</code> selection, it provides two plots by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cobs'
plot(x, which = if(x$select.lambda) 1:2 else 2,
     show.k = TRUE,
     col = par("col"), l.col = c("red","pink"), k.col = gray(c(0.6, 0.8)),
     lwd = 2, cex = 0.4, ylim = NULL,
     xlab = deparse(x$call[[2]]),
     ylab = deparse(x$call[[3]]),
     main = paste(deparse(x$call, width.cutoff = 100), collapse="\n"),
     subtit= c("choosing lambda", "data &amp; spline curve") , ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cobs_+3A_x">x</code></td>
<td>
<p>object of class <code>cobs</code>.</p>
</td></tr>
<tr><td><code id="plot.cobs_+3A_which">which</code></td>
<td>
<p>integer vector specifying <em>which</em> plots should be
drawn;</p>
</td></tr> 
<tr><td><code id="plot.cobs_+3A_show.k">show.k</code></td>
<td>
<p>logical indicating if the &ldquo;effective
dimensionality&rdquo; <code class="reqn">k</code> should also be shown.  Only applicable when
<code>which</code> contains 1.</p>
</td></tr>
<tr><td><code id="plot.cobs_+3A_col">col</code>, <code id="plot.cobs_+3A_l.col">l.col</code>, <code id="plot.cobs_+3A_k.col">k.col</code></td>
<td>
<p>colors for plotting; <code>k.col</code> only
applies when <code>show.k</code> is true in the first plot (<code>which
      == 1</code>) where <code>l.col[2]</code> and <code>k.col[2]</code> are only used as well,
for denoting &ldquo;doubtful&rdquo; points; <code>col</code> is only used for
the 2nd plot (<code>which == 2</code>).</p>
</td></tr>
<tr><td><code id="plot.cobs_+3A_lwd">lwd</code>, <code id="plot.cobs_+3A_cex">cex</code></td>
<td>
<p>line width and point size for the 2nd plot
(i.e. <code>which == 2</code>).</p>
</td></tr>
<tr><td><code id="plot.cobs_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits, see <code><a href="graphics.html#topic+axis">axis</a></code>, with a smart default.</p>
</td></tr>
<tr><td><code id="plot.cobs_+3A_xlab">xlab</code>, <code id="plot.cobs_+3A_ylab">ylab</code>, <code id="plot.cobs_+3A_main">main</code></td>
<td>
<p>axis annotation; see also <code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cobs_+3A_subtit">subtit</code></td>
<td>
<p>a vector of length 2, specifying a sub title for each
plot (according to <code>which</code>).</p>
</td></tr>
<tr><td><code id="plot.cobs_+3A_...">...</code></td>
<td>
<p>further arguments passed and to internal
<code><a href="graphics.html#topic+plot">plot</a></code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot(.)</code> produces two side-by-side plots in case there was a
search for the optimal lambda(<code>which = 1:2</code>), and only the
(second) data plus spline curve plot otherwise (<code>which = 2</code>).
</p>



<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p>There are several other methods for COBS objects, see, e.g.
<code><a href="#topic+summary.cobs">summary.cobs</a></code> or <code><a href="#topic+predict.cobs">predict.cobs</a></code>.
</p>
<p><code><a href="#topic+cobs">cobs</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(cobs)

plot(Sbs)
plot(fitted(Sbs), resid(Sbs),
     main = "Tukey-Anscombe plot for cobs()",
     sub = deparse(Sbs$call))
</code></pre>

<hr>
<h2 id='predict.cobs'>Predict method for COBS Fits</h2><span id='topic+predict.cobs'></span>

<h3>Description</h3>

<p>Compute predicted values and simultaneous or pointwise confidence
bounds for <code><a href="#topic+cobs">cobs</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cobs'
predict(object, z, deriv = 0L,
        minz = knots[1], maxz = knots[nknots], nz = 100,
        interval = c("none", "confidence", "simultaneous", "both"),
        level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cobs_+3A_object">object</code></td>
<td>
<p>object of class <code>cobs</code>.</p>
</td></tr>
<tr><td><code id="predict.cobs_+3A_z">z</code></td>
<td>
<p>vector of grid points at which the fitted values are
evaluated; defaults to an equally spaced grid with <code>nz</code> grid
points between <code>minz</code> and <code>maxz</code>.  Note that now <code>z</code>
may lie outside of the knots interval which was not allowed originally.</p>
</td></tr>
<tr><td><code id="predict.cobs_+3A_deriv">deriv</code></td>
<td>
<p>scalar integer specifying (the order of) the derivative
that should be computed.</p>
</td></tr>
<tr><td><code id="predict.cobs_+3A_minz">minz</code></td>
<td>
<p>numeric needed if <code>z</code> is not specified; defaults to
<code>min(x)</code> or the first knot if <code>knots</code> are given.</p>
</td></tr>
<tr><td><code id="predict.cobs_+3A_maxz">maxz</code></td>
<td>
<p>analogous to <code>minz</code>; defaults to <code>max(x)</code> or the
last knot if <code>knots</code> are given.</p>
</td></tr>
<tr><td><code id="predict.cobs_+3A_nz">nz</code></td>
<td>
<p>number of grid points in <code>z</code> if that is not given;
defaults to 100.</p>
</td></tr>
<tr><td><code id="predict.cobs_+3A_interval">interval</code></td>
<td>
<p>type of interval calculation, see below</p>
</td></tr>
<tr><td><code id="predict.cobs_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="predict.cobs_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of predictions and bounds if <code>interval</code> is set (not
&quot;none&quot;).  The columns are named <code>z</code>, <code>fit</code>, further
<code>cb.lo</code> and <code>cb.up</code> for the <code>simultaneous</code> confidence
band, and <code>ci.lo</code> and <code>ci.up</code> the pointwise
<code>confidence</code> intervals according to specified <code>level</code>.
</p>
<p>If <code>z</code> has been specified, it is unchanged in the result.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, based on He and Ng's code in <code>cobs()</code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+cobs">cobs</a></code> the model fitting function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(cobs) # continuing :
(pRbs &lt;- predict(Rbs))
#str(pSbs &lt;- predict(Sbs, xx, interval = "both"))
str(pSbs &lt;- predict(Sbs, xx, interval = "none"))

plot(x,y, xlim = range(xx), ylim = range(y, pSbs[,2], finite = TRUE),
     main = "COBS Median smoothing spline, automatical lambda")
lines(pSbs, col = "red")
lines(spline(x,f.true), col = "gray40")
#matlines(pSbs[,1], pSbs[,-(1:2)],
#         col= rep(c("green","blue"),c(2,2)), lty=2)
</code></pre>

<hr>
<h2 id='qbsks2'>Quantile B-Spline with Fixed Knots</h2><span id='topic+qbsks2'></span>

<h3>Description</h3>

<p>Compute B-spline coefficients for regression quantile B-spline with
stepwise knots selection and quantile B-spline with fixed knots
<b>regression spline</b>, using Ng (1996)'s algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qbsks2(x,y,w,pw, knots,nknots, degree,Tlambda, constraint, ptConstr,
      maxiter, trace, nrq,nl1, neqc, tau, select.lambda,
      ks, do.select, knots.add, repeat.delete.add, ic, print.mesg,
      give.pseudo.x = TRUE,
      rq.tol = 1e-8, tol.kn = 1e-6, tol.0res = 1e-6, print.warn, nk.start)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qbsks2_+3A_x">x</code></td>
<td>
<p>numeric vector, sorted increasingly, the abscissa values</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_y">y</code></td>
<td>
<p>numeric, same length as <code>x</code>, the observations.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_w">w</code></td>
<td>
<p>numeric vector of weights, same length as <code>x</code>, as in
<code><a href="#topic+cobs">cobs</a></code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_pw">pw</code></td>
<td>
<p>penalty weights vector ... ...</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_knots">knots</code></td>
<td>
<p>numeric vector of knots of which <code>nknots</code> will be used.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_nknots">nknots</code></td>
<td>
<p>number of <code>knots</code> to be used.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_degree">degree</code></td>
<td>
<p>integer specifying polynomial degree; must be 1 or 2.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_tlambda">Tlambda</code></td>
<td>
<p>(vector of) smoothing parameter(s) <code class="reqn">\lambda</code>, see
<code><a href="#topic+drqssbc2">drqssbc2</a></code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_constraint">constraint</code></td>
<td>
<p>string (or empty) specifying the global constraints;
see <code><a href="#topic+cobs">cobs</a></code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_ptconstr">ptConstr</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> of <b>p</b>oin<b>t</b>wise constraints.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_maxiter">maxiter</code></td>
<td>
<p>non-negative integer: maximal number of iterations,
passed to <code><a href="#topic+drqssbc2">drqssbc2</a></code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_trace">trace</code></td>
<td>
<p>integer or logical indicating the tracing level of the
<em>underlying</em> algorithms; not implemented (due to lack of trace
in quantreg ...)</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_nrq">nrq</code>, <code id="qbsks2_+3A_nl1">nl1</code>, <code id="qbsks2_+3A_neqc">neqc</code></td>
<td>
<p>integers specifying dimensionalities, directly
passed to <code><a href="#topic+drqssbc2">drqssbc2</a></code>, see there.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_tau">tau</code></td>
<td>
<p>desired quantile level (in interval <code class="reqn">(0,1)</code>).</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_select.lambda">select.lambda</code></td>
<td>
<p>passed to <code><a href="#topic+drqssbc2">drqssbc2</a></code>, see there.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_ks">ks</code></td>
<td>
<p>number used as offset in SIC/AIC/BIC.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_do.select">do.select</code></td>
<td>
<p>logical indicating if knots shall be selected
(instead of used as specified).</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_knots.add">knots.add</code>, <code id="qbsks2_+3A_repeat.delete.add">repeat.delete.add</code></td>
<td>
<p>logicals, see <code><a href="#topic+cobs">cobs</a></code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_ic">ic</code></td>
<td>
<p>information criterion to use, see <code><a href="#topic+cobs">cobs</a></code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_print.mesg">print.mesg</code></td>
<td>
<p>an integer indicating how <code>qbsks2()</code> should
print message about its current stages.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_give.pseudo.x">give.pseudo.x</code></td>
<td>
<p>logical indicating if the pseudo design matrix
<code class="reqn">\tilde{X}</code> should be returned (as <em>sparse</em> matrix).</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_rq.tol">rq.tol</code></td>
<td>
<p>numeric convergence tolerance for the interior point
algorithm called from <code><a href="quantreg.html#topic+rq.fit.sfnc">rq.fit.sfnc</a>()</code> or
<code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a>()</code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_tol.kn">tol.kn</code></td>
<td>
<p>&ldquo;tolerance&rdquo; for shifting the outer knots.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_tol.0res">tol.0res</code></td>
<td>
<p>tolerance passed to <code><a href="#topic+drqssbc2">drqssbc2</a></code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_print.warn">print.warn</code></td>
<td>
<p>flag indicating if and how much warnings and
information is to be printed; currently just passed to
<code><a href="#topic+drqssbc2">drqssbc2</a></code>.</p>
</td></tr>
<tr><td><code id="qbsks2_+3A_nk.start">nk.start</code></td>
<td>
<p>number of starting knots used in automatic knot selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an auxiliary function for <code><a href="#topic+cobs">cobs</a>(*, lambda = 0)</code>,
possibly interesting on its own.  This documentation is currently sparse; read
the source code!
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code>fidel</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>dimensionality of model fit.</p>
</td></tr>
<tr><td><code>ifl</code></td>
<td>
<p>integer &ldquo;flag&rdquo;; the return code.</p>
</td></tr>
<tr><td><code>icyc</code></td>
<td>
<p>integer of length 2, see <code><a href="#topic+cobs">cobs</a></code>.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>the vector of inner knots.</p>
</td></tr>
<tr><td><code>nknots</code></td>
<td>
<p>the number of inner knots.</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>the number of &ldquo;variables&rdquo;, i.e. unknowns including
constraints.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the penalty factor, chosen or given.</p>
</td></tr>
<tr><td><code>pseudo.x</code></td>
<td>
<p>the pseudo design matrix <code class="reqn">X</code>, as returned from
<code><a href="#topic+drqssbc2">drqssbc2</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pin Ng; this help page: Martin Maechler.</p>


<h3>References</h3>

<p>Ng, P. (1996)
An Algorithm for Quantile Smoothing Splines,
<em>Computational Statistics &amp; Data Analysis</em> <b>22</b>, 99&ndash;118.
</p>
<p>See also the <em>references</em> in <code><a href="#topic+cobs">cobs</a></code>.
</p>


<h3>See Also</h3>

<p>the main function <code><a href="#topic+cobs">cobs</a></code>; further
<code><a href="#topic+drqssbc2">drqssbc2</a></code> which is called from <code>qbsks2()</code>.
</p>

<hr>
<h2 id='scobs-internal'>Internal COBS functions</h2><span id='topic+getdim2'></span><span id='topic+l1.design2'></span><span id='topic+loo.design2'></span><span id='topic+dn'></span><span id='topic+shat'></span><span id='topic+.splBasis'></span><span id='topic+.splValue'></span>

<h3>Description</h3>

<p>Internal scobs functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dn(p, n, hs = FALSE, alpha)

getdim2(degree, nknots, constraint)

l1.design2(x, w, constraint, ptConstr,
          knots, pw, nrq, nl1, neqc, niqc, nvar, lambda)
loo.design2(x, w, constraint, ptConstr,
          knots, pw, nrq, nl1, neqc, niqc, nvar, lambda)

shat(residual, tau, alpha, hs)

.splValue(degree, knots, coef, xo, deriv = 0L)
.splBasis(ord, knots, ncoef, xo, derivs)

</code></pre>


<h3>Details</h3>

<p>These are not (yet?) to be called by the user and have not been
documented by the original COBS authors.
</p>

<hr>
<h2 id='USArmyRoofs'>Roof Quality in US Army Bases</h2><span id='topic+USArmyRoofs'></span>

<h3>Description</h3>

<p>The <code>USArmyRoofs</code> data frame has 153 observations of roof sections of US
Army bases and 2 columns, <code>age</code> and <code>fci</code>.  This is Example 2
of He &amp; Ng (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USArmyRoofs)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>age</dt><dd><p>numeric vector giving the roof's age in years.</p>
</dd>
<dt>fci</dt><dd><p>numeric, giving the FCI, the flash condition index, i.e.,
the percentage of flashing which is in good condition.</p>
</dd>
</dl>



<h3>Source</h3>

<p>From shar file available from <a href="https://www2.nau.edu/PinNg/cobs.html">https://www2.nau.edu/PinNg/cobs.html</a>
</p>


<h3>References</h3>

<p>He, X. and Ng, P. (1999)
COBS: Qualitatively Constrained Smoothing via Linear Programming;
<em>Computational Statistics</em> <b>14</b>, 315&ndash;337.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArmyRoofs)
plot(fci ~ age, data = USArmyRoofs, main = "US Army Roofs data")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
