<!DOCTYPE html><html><head><title>Help for package timeordered</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timeordered}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ants'><p>Ant interaction data</p></a></li>
<li><a href='#applynetworkfunction'>
<p>Applies a function (typically a descriptive statistic) to multiple time-aggregated networks</p></a></li>
<li><a href='#generatelatencies'>
<p>Generates vector-clock latencies for each individual at each time.</p></a></li>
<li><a href='#generatenetworkslices'>
<p>Generates multiple time-aggregated networks from a time-ordered network</p></a></li>
<li><a href='#generatetimeaggregatednetwork'>
<p>Constructs a weighted time-aggregated network from a time-ordered network by aggregating interactions occurring between a start and stop time. Weights are stored as E(g)$weight.</p></a></li>
<li><a href='#generatetimedeltas'>
<p>Constructs matrix of sequential time windows suitable for slicing time ordered networks</p></a></li>
<li><a href='#generatetimelags'>
<p>Constructs matrix of increasingly large time windows suitable for assessing how window size affects time aggregated networks</p></a></li>
<li><a href='#generatetonetwork'>
<p>Generates a time-ordered network from an interaction list.</p></a></li>
<li><a href='#generatetonetworkfromvel'>
<p>Generates a time-ordered network from a data frame listing all directed edges. An internal function.</p></a></li>
<li><a href='#generatevertexedgelist'>
<p>Generates a data frame listing all directed edges in a time-ordered network from an observed interaction list. An internal function.</p></a></li>
<li><a href='#maxpoints'>
<p>Determines the maximum value of each row of a matrix; used as a convenience function for plotting.</p></a></li>
<li><a href='#midpoints'>
<p>Determines the mean value of each row of a matrix; used as a convenience function for plotting.</p></a></li>
<li><a href='#plotnetworkslices'>
<p>Plots a time-aggregated network</p></a></li>
<li><a href='#plottanet'>
<p>Plots a time-aggregated network.</p></a></li>
<li><a href='#plottonet'>
<p>Plots a time-ordered network.</p></a></li>
<li><a href='#randomize_edges_helper'>
<p>Does all the work for <code>edge_randomization</code> and <code>randomized_edges</code>. An internal function.</p></a></li>
<li><a href='#randomizeidentities'>
<p>Resamples data based on vertex identity.</p></a></li>
<li><a href='#randomizetimes'>
<p>Resamples data based on event time.</p></a></li>
<li><a href='#randomly_permuted_times'>
<p>Randomize temporal networks</p></a></li>
<li><a href='#rarefy'>
<p>Simulates the effect of insufficient sampling by data rarefaction.</p></a></li>
<li><a href='#shortesthoppath'>
<p>Determines a path (shortest by the least number of unique vertices) between two vertices at two times.</p></a></li>
<li><a href='#shortesttimepath'>
<p>Determines a path (shortest by the least time) between a vertex at a start time and another vertex at any later time.</p>
</p></a></li>
<li><a href='#spreadanalysis'>
<p>Simulates the perfect spread of a resource on a time-ordered network.</p></a></li>
<li><a href='#swap'>
<p>Swaps two elements in a data frame. An internal function.</p></a></li>
<li><a href='#transformspreadbyindividual'>
<p>A helper function to assess differences in spreading potential by vertex.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time-Ordered and Time-Aggregated Network Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Blonder</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Blonder &lt;benjamin.blonder@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Approaches for incorporating time into network analysis. Methods include: construction of time-ordered networks (temporal graphs); shortest-time and shortest-path-length analyses; resource spread calculations; data resampling and rarefaction for null model construction; reduction to time-aggregated networks with variable window sizes; application of common descriptive statistics to these networks; vector clock latencies; and plotting functionalities. The package supports &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0020298">doi:10.1371/journal.pone.0020298</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph, plyr</td>
</tr>
<tr>
<td>BuildManual:</td>
<td>no</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 21:18:10 UTC; benjaminblonder</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ants'>Ant interaction data</h2><span id='topic+ants'></span>

<h3>Description</h3>

<p>From a recent study of information flow in ant colonies. In this study, ants were uniquely marked with paint and identified by a four letter code - e.g. WGWB denotes an ant with a red head, green thorax, white left gaster, and blue right gaster. Body positions with missing paint marks are denoted with underscores. 
</p>
<p>In-nest activity was recorded with a high definition video camera. The complete set of pairwise interactions between all individuals at all times was obtained by several undergraduates repeatedly watching each video. Interactions were defined as any touch between one ant's antenna and any body part of another ant.
</p>
<p>The dataset contains four columns: VertexFrom, VertexTo, TimeStart, and TimeStop. Each row is a unique interaction between two ants. Each interaction is directed, indicating that the VertexFrom ant has initiated a contact with the VertexTo ant. TimeStart and TimeStop characterize when the interaction began and finished. In this demo version of the data set, TimeStop = TimeStart + 1. Times are recorded in seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ants</code></pre>


<h3>Format</h3>

<p>A data frame containing 1911 observations over 24 minutes.</p>


<h3>Source</h3>

<p>Blonder &amp; Dornhaus (2011), Supplementary Information, Colony 1-1.</p>


<h3>References</h3>

<p>Blonder &amp; Dornhaus, <em>Time-ordered networks reveal limitations to information flow in ant colonies</em>. PLoS One (2011), in press.
</p>

<hr>
<h2 id='applynetworkfunction'>
Applies a function (typically a descriptive statistic) to multiple time-aggregated networks
</h2><span id='topic+applynetworkfunction'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applynetworkfunction(slices, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applynetworkfunction_+3A_slices">slices</code></td>
<td>

<p>A list of time-aggregated networks, of class igraph
</p>
</td></tr>
<tr><td><code id="applynetworkfunction_+3A_fun">fun</code></td>
<td>

<p>The function to be applied; takes a single argument
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose entries represent the function's value for each network
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatenetworkslices">generatenetworkslices</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
td100 &lt;- generatetimedeltas(0,1500,100)
ns100 &lt;- generatenetworkslices(g, td100)
md100 &lt;- applynetworkfunction(ns100, diameter)
tl100 &lt;- generatetimelags(0,1500,100)
nl100 &lt;- generatenetworkslices(g, tl100)
ml100 &lt;- applynetworkfunction(nl100, function(x){diameter(x)})
par(mfrow=c(1,2))
plot(midpoints(td100),unlist(md100),type="l",xlab="Time (window size = 100)",ylab="Diameter")
plot(maxpoints(tl100),unlist(ml100),type="l",xlab="Aggregation time",ylab="Diameter")
</code></pre>

<hr>
<h2 id='generatelatencies'>
Generates vector-clock latencies for each individual at each time.
</h2><span id='topic+generatelatencies'></span>

<h3>Description</h3>

<p>Vector clock latencies describe the minimum time delay between one individual broadcasting a signal and another individual receiving it, at a given time, through any causally permitted path in the time-ordered network. Smaller values indicate individuals that are connected by shorter causally-permitted paths at a given time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatelatencies(raw, allindivs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatelatencies_+3A_raw">raw</code></td>
<td>

<p>An event list, consisting of a data frame with four columns: VertexFrom, VertexTo, TimeStart, and TimeStop. Each row in this data frame represents a single directed interaction event between VertexFrom and VertexTo beginning at TimeStart and ending at TimeStop. Assumes that no event begins at a time less than zero.
</p>
</td></tr>
<tr><td><code id="generatelatencies_+3A_allindivs">allindivs</code></td>
<td>

<p>A list of all possible vertices including ones not observed interacting during the range of time reported in <code>raw</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A n x n x m array, where n is the number of vertices and m is the maximum start time in the raw event list. The [i,j,k] entry of the array describes the latency from i to j at time k. NA is returned if there is not causally permitted path between i and j by time k. 
</p>


<h3>Note</h3>

<p>Return value can require large memory allocation depending on the data set. Ensure that data contains no times &lt; 0 before running.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>References</h3>

<p>Kossinets et al. The structure of information pathways in a social communication network. KDD '08: Proceeding of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining (2008)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
l &lt;- generatelatencies(ants, allindivs)
image(l[,,1000],axes=FALSE,frame=TRUE,col=rainbow(100))
axis(1, at = (1:ncol(l))/ncol(l), labels=colnames(l),tick=FALSE,las=2,cex.axis=0.2)
axis(2, at = (1:nrow(l))/nrow(l), labels=rownames(l),tick=FALSE,las=2,cex.axis=0.2)
</code></pre>

<hr>
<h2 id='generatenetworkslices'>
Generates multiple time-aggregated networks from a time-ordered network
</h2><span id='topic+generatenetworkslices'></span>

<h3>Description</h3>

<p>Constructs weighted directed networks from all events occurring within certain time windows. Weight is equal to the number of interactions observed during the time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatenetworkslices(g, timedeltas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatenetworkslices_+3A_g">g</code></td>
<td>

<p>The time-ordered network to be sliced.
</p>
</td></tr>
<tr><td><code id="generatenetworkslices_+3A_timedeltas">timedeltas</code></td>
<td>

<p>A n x 2 matrix, where each row contains a set of start (first column) and stop (second column) times at which the network should be sliced.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing n time-aggregated networks corresponding to the n time windows.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotnetworkslices">plotnetworkslices</a></code>, <code><a href="#topic+generatetimedeltas">generatetimedeltas</a></code>, <code><a href="#topic+generatetimelags">generatetimelags</a></code>~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
td100 &lt;- generatetimedeltas(0,1500,100)
ns100 &lt;- generatenetworkslices(g, td100)
plotnetworkslices(ns100, td100)

</code></pre>

<hr>
<h2 id='generatetimeaggregatednetwork'>
Constructs a weighted time-aggregated network from a time-ordered network by aggregating interactions occurring between a start and stop time. Weights are stored as E(g)$weight.
</h2><span id='topic+generatetimeaggregatednetwork'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatetimeaggregatednetwork(g, starttime, stoptime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatetimeaggregatednetwork_+3A_g">g</code></td>
<td>

<p>The time-ordered network to be aggregated
</p>
</td></tr>
<tr><td><code id="generatetimeaggregatednetwork_+3A_starttime">starttime</code></td>
<td>

<p>The time at which to begin aggregating interactions.
</p>
</td></tr>
<tr><td><code id="generatetimeaggregatednetwork_+3A_stoptime">stoptime</code></td>
<td>

<p>The time at which to stop aggregating interactions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted time-aggregated network whose edge weights equal the number of interactions between those vertices in the time window.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatenetworkslices">generatenetworkslices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
tan500 &lt;- generatetimeaggregatednetwork(g, 0, 500)
plottanet(tan500)

</code></pre>

<hr>
<h2 id='generatetimedeltas'>
Constructs matrix of sequential time windows suitable for slicing time ordered networks
</h2><span id='topic+generatetimedeltas'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatetimedeltas(starttime, stoptime, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatetimedeltas_+3A_starttime">starttime</code></td>
<td>

<p>The starting time of the first time window.
</p>
</td></tr>
<tr><td><code id="generatetimedeltas_+3A_stoptime">stoptime</code></td>
<td>

<p>The stopping time of the last time window.
</p>
</td></tr>
<tr><td><code id="generatetimedeltas_+3A_delta">delta</code></td>
<td>

<p>The size of each time window.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A n x 2 matrix. Each row contains the start and stop time of a window with width delta.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatetimelags">generatetimelags</a></code> ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>td100 &lt;- generatetimedeltas(0,1500,100)
boxplot(t(td100))
</code></pre>

<hr>
<h2 id='generatetimelags'>
Constructs matrix of increasingly large time windows suitable for assessing how window size affects time aggregated networks
</h2><span id='topic+generatetimelags'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatetimelags(starttime, stoptime, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatetimelags_+3A_starttime">starttime</code></td>
<td>

<p>The starting time of the first time window.
</p>
</td></tr>
<tr><td><code id="generatetimelags_+3A_stoptime">stoptime</code></td>
<td>

<p>The stopping time of the last time window.
</p>
</td></tr>
<tr><td><code id="generatetimelags_+3A_delta">delta</code></td>
<td>

<p>The size by which to increase each time window.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A n x 2 matrix. Each row contains the start and stop time of a window with widths increasing by delta.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatetimedeltas">generatetimedeltas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tl100 &lt;- generatetimelags(0,1500,100)
boxplot(t(tl100))
</code></pre>

<hr>
<h2 id='generatetonetwork'>
Generates a time-ordered network from an interaction list.
</h2><span id='topic+generatetonetwork'></span>

<h3>Description</h3>

<p>Constructs a directed network describing the causally permitted paths between a set of vertices that interact at known times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatetonetwork(raw, allindivs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatetonetwork_+3A_raw">raw</code></td>
<td>

<p>An event list, consisting of a data frame with four columns: VertexFrom, VertexTo, TimeStart, and TimeStop. Each row in this data frame represents a single directed interaction event between VertexFrom and VertexTo beginning at TimeStart and ending at TimeStop.
</p>
</td></tr>
<tr><td><code id="generatetonetwork_+3A_allindivs">allindivs</code></td>
<td>

<p>A list of all possible vertices potentially including ones not observed interacting during the range of time reported in <code>raw</code>. Defaults to the vertices observed in raw.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted directed network of class 'igraph'. Each vertex represents an individual at a time during which an interaction occurred. Edges represent causally permitted paths of resource flow and have a TimeCost, describing the time between interactions for an individual, or is 0 if the edge represents an interaction, and a HopCost, which is 0 if the edge connects the same individual at multiple times and 1 if it connects different individuals at the same time.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>References</h3>

<p>Kostakos V. Temporal Graphs. arXiv (2008) vol. physics.soc-ph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
plottonet(g)
</code></pre>

<hr>
<h2 id='generatetonetworkfromvel'>
Generates a time-ordered network from a data frame listing all directed edges. An internal function.
</h2><span id='topic+generatetonetworkfromvel'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatetonetworkfromvel(vel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatetonetworkfromvel_+3A_vel">vel</code></td>
<td>

<p>A data frame listing all directed edges
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
</code></pre>

<hr>
<h2 id='generatevertexedgelist'>
Generates a data frame listing all directed edges in a time-ordered network from an observed interaction list. An internal function.
</h2><span id='topic+generatevertexedgelist'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatevertexedgelist(raw, allindivs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatevertexedgelist_+3A_raw">raw</code></td>
<td>

<p>A data frame of events
</p>
</td></tr>
<tr><td><code id="generatevertexedgelist_+3A_allindivs">allindivs</code></td>
<td>

<p>A vector of names
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>

<hr>
<h2 id='maxpoints'>
Determines the maximum value of each row of a matrix; used as a convenience function for plotting.
</h2><span id='topic+maxpoints'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxpoints(td)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxpoints_+3A_td">td</code></td>
<td>

<p>A n x 2 matrix describing a set of start and stop times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A maximum value for each of n rows of td
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatetimelags">generatetimelags</a></code>,<code><a href="#topic+generatetimedeltas">generatetimedeltas</a></code> ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tl100 &lt;- generatetimelags(0,1500,100)
boxplot(t(maxpoints(tl100)))
</code></pre>

<hr>
<h2 id='midpoints'>
Determines the mean value of each row of a matrix; used as a convenience function for plotting.
</h2><span id='topic+midpoints'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midpoints(td)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midpoints_+3A_td">td</code></td>
<td>

<p>A n x 2 matrix describing a set of start and stop times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mean value for each of n rows of td
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatetimelags">generatetimelags</a></code>,<code><a href="#topic+generatetimedeltas">generatetimedeltas</a></code> ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tl100 &lt;- generatetimelags(0,1500,100)
boxplot(t(midpoints(tl100)))
</code></pre>

<hr>
<h2 id='plotnetworkslices'>
Plots a time-aggregated network
</h2><span id='topic+plotnetworkslices'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotnetworkslices(slices, timedeltas, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotnetworkslices_+3A_slices">slices</code></td>
<td>

<p>A list of n time-aggregated networks
</p>
</td></tr>
<tr><td><code id="plotnetworkslices_+3A_timedeltas">timedeltas</code></td>
<td>

<p>A n x 2 matrix describing the start and stop times for each time-aggregated network
</p>
</td></tr>
<tr><td><code id="plotnetworkslices_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to <code>igraph</code>'s plotting functionality
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None; used for its side effect of producing a plot.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotnetworkslices">plotnetworkslices</a></code>, <code><a href="#topic+generatetimedeltas">generatetimedeltas</a></code>, <code><a href="#topic+generatetimelags">generatetimelags</a></code>~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
td100 &lt;- generatetimedeltas(0,1500,100)
ns100 &lt;- generatenetworkslices(g, td100)
plotnetworkslices(ns100, td100)
</code></pre>

<hr>
<h2 id='plottanet'>
Plots a time-aggregated network.
</h2><span id='topic+plottanet'></span>

<h3>Description</h3>

<p>Plots a time-aggregated network. See igraph.plotting for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plottanet(timeaggregatednetwork, layout = layout.circle, 
	vertex.label = V(timeaggregatednetwork)$name, vertex.size = 0, 
	vertex.label.cex = 0.5, edge.arrow.size = 0.5, 
	edge.width = E(timeaggregatednetwork)$Count/5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plottanet_+3A_timeaggregatednetwork">timeaggregatednetwork</code></td>
<td>

<p>The network to print, an object of the igraph class
</p>
</td></tr>
<tr><td><code id="plottanet_+3A_layout">layout</code></td>
<td>

<p>Graph layout function - see ?layout in igraph
</p>
</td></tr>
<tr><td><code id="plottanet_+3A_vertex.label">vertex.label</code></td>
<td>

<p>Vertex labels. Defaults to the name of each vertex.
</p>
</td></tr>
<tr><td><code id="plottanet_+3A_vertex.size">vertex.size</code></td>
<td>

<p>Size of each vertex.
</p>
</td></tr>
<tr><td><code id="plottanet_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>

<p>Label size factor.
</p>
</td></tr>
<tr><td><code id="plottanet_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>

<p>Arrow size.
</p>
</td></tr>
<tr><td><code id="plottanet_+3A_edge.width">edge.width</code></td>
<td>

<p>Arrow width, defaults to be proportional to edge weight.
</p>
</td></tr>
<tr><td><code id="plottanet_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to <code>igraph</code>'s plotting functionality
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None; used for its side effect of producing a plot.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatetimeaggregatednetwork">generatetimeaggregatednetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
tan &lt;- generatetimeaggregatednetwork(g, 0, 500)
plottanet(tan,layout=layout.kamada.kawai)
</code></pre>

<hr>
<h2 id='plottonet'>
Plots a time-ordered network.
</h2><span id='topic+plottonet'></span>

<h3>Description</h3>

<p>Plots a time-ordered network with vertices ordinated along the x-axis and time increasing along the y-axis. Interactions are drawn as horizontal lines; vertices are connected to themselves in time by vertical lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plottonet(g, path = NULL, edgecolor = "gray", 
	edgehighlightcolor = "red", vertex.size = 0.01, 
	edge.arrow.size = 0.1, edge.width = 0.2, 
	vertex.color = NA, vertex.label.cex = 0.1, 
	vertex.frame.color = NA, vertex.label.color = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plottonet_+3A_g">g</code></td>
<td>

<p>The time-ordered network to plot
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_path">path</code></td>
<td>

<p>If supplied, a particular list of vertices comprising a causally-permitted path that will be highlighted in the final illustration.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_edgecolor">edgecolor</code></td>
<td>

<p>The color of all edges in the graph.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_edgehighlightcolor">edgehighlightcolor</code></td>
<td>

<p>The color of the vertx path to be highlighted.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_vertex.size">vertex.size</code></td>
<td>

<p>Vertex size. See igraph.plotting for more details.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>

<p>Edge arrow size.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_edge.width">edge.width</code></td>
<td>

<p>Edge width.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_vertex.color">vertex.color</code></td>
<td>

<p>Vertex color.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>

<p>Vertex label size factor.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_vertex.frame.color">vertex.frame.color</code></td>
<td>

<p>Vertex frame color.
</p>
</td></tr>
<tr><td><code id="plottonet_+3A_vertex.label.color">vertex.label.color</code></td>
<td>

<p>Vertex label color.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None; used for its side-effect of producing a plot.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatetonetwork">generatetonetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
plottonet(g)


</code></pre>

<hr>
<h2 id='randomize_edges_helper'>
Does all the work for <code>edge_randomization</code> and <code>randomized_edges</code>. An internal function.
</h2><span id='topic+randomize_edges_helper'></span>

<h3>Description</h3>

<p>NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomize_edges_helper(edges, randomize_vertices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomize_edges_helper_+3A_edges">edges</code></td>
<td>

<p>A data frame for an edge list
</p>
</td></tr>
<tr><td><code id="randomize_edges_helper_+3A_randomize_vertices">randomize_vertices</code></td>
<td>

<p>A binary variable
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Gernat &lt;mail@timgernat.name&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (edges, randomize_vertices) 
{
    vertex_columns &lt;- c("VertexFrom", "VertexTo")
    unique_edges &lt;- unique(edges[, vertex_columns])
    unique_edge_count &lt;- nrow(unique_edges)
    edge_map &lt;- cbind(unique_edges, unique_edges[sample(unique_edge_count, 
        unique_edge_count), ])
    new_vertex_columns &lt;- c("NewVF", "NewVT")
    colnames(edge_map) &lt;- c(vertex_columns, new_vertex_columns)
    if (randomize_vertices) {
        edge_map[, new_vertex_columns] &lt;- sample(unlist(edge_map[, 
            new_vertex_columns]), unique_edge_count * 2)
        repeat {
            invalid &lt;- (edge_map$NewVF == edge_map$NewVT) | (duplicated(edge_map[, 
                new_vertex_columns]))
            if (sum(invalid) == 0) 
                break
            for (i in which(invalid)) edge_map &lt;- swap(edge_map, 
                i, sample(new_vertex_columns, 1), sample(unique_edge_count, 
                  1), sample(new_vertex_columns, 1))
        }
    }
    original_colnames &lt;- colnames(edges)
    attribute_columns &lt;- original_colnames[!(original_colnames %in% 
        vertex_columns)]
    edges &lt;- merge(edges, edge_map)
    edges &lt;- edges[, c(new_vertex_columns, attribute_columns)]
    colnames(edges)[1:length(new_vertex_columns)] &lt;- vertex_columns
    return(edges)
  }
</code></pre>

<hr>
<h2 id='randomizeidentities'>
Resamples data based on vertex identity.
</h2><span id='topic+randomizeidentities'></span>

<h3>Description</h3>

<p>Produces a new event list from an existing event list with resampled vertex identities given certain constraints on randomization. Effectively re-orders pairs of From/To vertices between different times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomizeidentities(raw, withinvertexfrom, byvertexfrom, withreplacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomizeidentities_+3A_raw">raw</code></td>
<td>

<p>A raw event list to be resampled. Contains four columns: VertexFrom, VertexTo, TimeStart, TimeStop
</p>
</td></tr>
<tr><td><code id="randomizeidentities_+3A_withinvertexfrom">withinvertexfrom</code></td>
<td>

<p>If true, resamples within data subsets where VertexFrom is fixed; otherwise resamples within all data.
</p>
</td></tr>
<tr><td><code id="randomizeidentities_+3A_byvertexfrom">byvertexfrom</code></td>
<td>

<p>If true, subsets of data for withinvertexfrom are obtained using VertexFrom; if false, using VertexTo.
</p>
</td></tr>
<tr><td><code id="randomizeidentities_+3A_withreplacement">withreplacement</code></td>
<td>

<p>Samples with or without replacement.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event list of the same size or smaller as raw. The returned event list will be smaller only if resampling produces events that connect a vertex to itself; these are removed.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomizetimes">randomizetimes</a></code>,<code><a href="#topic+rarefy">rarefy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
ri &lt;- randomizeidentities(ants,withinvertexfrom=TRUE,byvertexfrom=TRUE,withreplacement=TRUE)
g &lt;- generatetonetwork(ri, allindivs)
plottonet(g)

</code></pre>

<hr>
<h2 id='randomizetimes'>
Resamples data based on event time.
</h2><span id='topic+randomizetimes'></span>

<h3>Description</h3>

<p>Produces a new event list from an existing event list with resampled event times given certain constraints on randomization. Effectively re-orders pairs of start/stop times between different vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomizetimes(raw, withinvertexfrom, byvertexfrom, withreplacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomizetimes_+3A_raw">raw</code></td>
<td>

<p>A raw event list to be resampled. Contains four columns: VertexFrom, VertexTo, TimeStart, TimeStop
</p>
</td></tr>
<tr><td><code id="randomizetimes_+3A_withinvertexfrom">withinvertexfrom</code></td>
<td>

<p>If true, resamples within data subsets where VertexFrom is fixed; otherwise resamples within all data.
</p>
</td></tr>
<tr><td><code id="randomizetimes_+3A_byvertexfrom">byvertexfrom</code></td>
<td>

<p>If true, subsets of data for withinvertexfrom are obtained using VertexFrom; if false, using VertexTo.
</p>
</td></tr>
<tr><td><code id="randomizetimes_+3A_withreplacement">withreplacement</code></td>
<td>

<p>Samples with or without replacement.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event list of the same size as raw with event times resampled. Resampling does not break the relationship between start and stop time; i.e. resampled events will have the same duration as original events.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomizeidentities">randomizeidentities</a></code>,<code><a href="#topic+rarefy">rarefy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
rt &lt;- randomizetimes(ants,withinvertexfrom=TRUE,byvertexfrom=TRUE,withreplacement=TRUE)
g &lt;- generatetonetwork(rt, allindivs)
plottonet(g)


</code></pre>

<hr>
<h2 id='randomly_permuted_times'>
Randomize temporal networks
</h2><span id='topic+randomly_permuted_times'></span><span id='topic+vertex_randomization'></span><span id='topic+contact_randomization'></span><span id='topic+time_reversal'></span><span id='topic+randomly_permuted_times'></span><span id='topic+random_times'></span><span id='topic+randomized_contacts'></span><span id='topic+edge_randomization'></span><span id='topic+total_randomization'></span><span id='topic+randomized_edges'></span>

<h3>Description</h3>

<p>Take a data frame specifying the edges of a temporal network and create a 
randomized reference network which maintains certain properties of the original
network and destroys others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_randomization(edges)
randomly_permuted_times(edges)
vertex_randomization(edges)
contact_randomization(edges)
time_reversal(edges)
randomly_permuted_times(edges)
random_times(edges)
randomized_contacts(edges)
edge_randomization(edges)
randomized_edges(edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomly_permuted_times_+3A_edges">edges</code></td>
<td>

<p>A <code>data.frame</code> of contacts specifying a temporal network.
The <code>data.frame</code> has four columns: <code>VertexFrom</code>, <code>VertexTo</code>, 
<code>TimeStart</code>, and <code>TimeStop</code>. Each row represents a single directed 
contact between <code>VertexFrom</code> and <code>VertexTo</code>, beginning at 
<code>TimeStart</code> and ending at <code>TimeStop</code>. <code>TimeStart</code> and 
<code>TimeStop</code> may not be smaller than 0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>randomly_permuted_times</code> permutes the start time of contacts and
adjusts the end time to maintain contact duration.
</p>
<p><code>vertex_randomization</code> assigns vertices randomly and with equal 
probability to contacts.
</p>
<p><code>contact_randomization</code> randomly permutes vertices between contacts.
</p>
<p><code>time_reversal</code> reverses the temporal order of contacts while 
maintaining the temporal distance of contacts. 
</p>
<p><code>randomly_permuted_times</code> randomly permutes the start time of contacts
while maintaining contact duration.
</p>
<p><code>random_times</code> assigns to the start time of each contact a random time  
between <code>min(edges$TimeStart)</code> and <code>max(edges$TimeStop)</code>, 
maintaining the duration of each contact.
</p>
<p><code>randomized_contacts</code> redistributes contacts randomly among edges.
</p>
<p><code>edge_randomization</code> randomly exchanges whole contact sequences between 
edges.
</p>
<p><code>randomized_edges</code> randomly rewires edges. When an edge gets rewired,
the contact sequence associated with that edge follow the edge.
</p>
<p><code>total_randomization</code> assigns vertices randomly to contacts, assuming
that all vertices are equally likely participate in a contact
</p>
<p>Randomized reference networks returned by these functions contain no contacts
with self.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the same columns as the <code>edges</code>, specifying the
contacts of the randomized reference network.
</p>


<h3>Author(s)</h3>

<p>Tim Gernat &lt;mail@timgernat.name&gt;
</p>


<h3>References</h3>

<p>Holme &amp; Saramaki, Physics Reports 519 (2012), p. 116-118
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a temporal network
require(timeordered)
data(ants)

# randomly permute contact start timestamps while preserving contact duration
r1 &lt;- randomly_permuted_times(ants)

# randomly permute vertices between contacts and assign a random start 
# timestamp to each contact while preserving contact duration
r2 &lt;- contact_randomization(ants)
r2 &lt;- random_times(r1)
</code></pre>

<hr>
<h2 id='rarefy'>
Simulates the effect of insufficient sampling by data rarefaction.
</h2><span id='topic+rarefy'></span>

<h3>Description</h3>

<p>Randomly removes a fixed fraction of the event list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rarefy(raw, fraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rarefy_+3A_raw">raw</code></td>
<td>

<p>The event list to be rarefied.
</p>
</td></tr>
<tr><td><code id="rarefy_+3A_fraction">fraction</code></td>
<td>

<p>A fraction (between 0 and 1) of the events to be randomly deleted.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event list with floor(nrow(raw) * fraction) events remaining.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomizeidentities">randomizeidentities</a></code>,<code><a href="#topic+randomizetimes">randomizetimes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.


</code></pre>

<hr>
<h2 id='shortesthoppath'>
Determines a path (shortest by the least number of unique vertices) between two vertices at two times.
</h2><span id='topic+shortesthoppath'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortesthoppath(g, startvertexname, startvertextime, stopvertexname, stopvertextime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortesthoppath_+3A_g">g</code></td>
<td>

<p>The time-ordered network on which to find paths.
</p>
</td></tr>
<tr><td><code id="shortesthoppath_+3A_startvertexname">startvertexname</code></td>
<td>

<p>The name of the start vertex.
</p>
</td></tr>
<tr><td><code id="shortesthoppath_+3A_startvertextime">startvertextime</code></td>
<td>

<p>The time of the start vertex. Must be a time at which an interaction has occurred involving this vertex.
</p>
</td></tr>
<tr><td><code id="shortesthoppath_+3A_stopvertexname">stopvertexname</code></td>
<td>

<p>The name of the stop vertex.
</p>
</td></tr>
<tr><td><code id="shortesthoppath_+3A_stopvertextime">stopvertextime</code></td>
<td>

<p>The time of the stop vertex. Must be a time at which an interaction has occurred involving this vertex.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vertex list containing all the events on the shortest-hop path between the start and stop vertices/times.
</p>


<h3>Note</h3>

<p>Multiple shortest-hop paths may exist; returns only one of them.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+shortesttimepath">shortesttimepath</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
shp &lt;- shortesthoppath(g, "WBGG", 927, "GYGG", 1423)
plottonet(g, shp)
title(paste(length(unique(shp$Name))," hops"))


</code></pre>

<hr>
<h2 id='shortesttimepath'>
Determines a path (shortest by the least time) between a vertex at a start time and another vertex at any later time.
</h2><span id='topic+shortesttimepath'></span>

<h3>Description</h3>

<p>-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortesttimepath(g, startvertexname, startvertextime, stopvertexname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortesttimepath_+3A_g">g</code></td>
<td>

<p>The time-ordered network on which to find paths.
</p>
</td></tr>
<tr><td><code id="shortesttimepath_+3A_startvertexname">startvertexname</code></td>
<td>

<p>The name of the start vertex.
</p>
</td></tr>
<tr><td><code id="shortesttimepath_+3A_startvertextime">startvertextime</code></td>
<td>

<p>The time of the start vertex. Must be a time at which an interaction has occurred involving this vertex.
</p>
</td></tr>
<tr><td><code id="shortesttimepath_+3A_stopvertexname">stopvertexname</code></td>
<td>

<p>The name of the stop vertex.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vertex list containing all the events on the shortest-time path between the start vertex at the start time and the stop vertex at a later time.
</p>


<h3>Note</h3>

<p>May generate warning messages - don't worry!
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+shortesthoppath">shortesthoppath</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
stp &lt;- shortesttimepath(g, "WBGG", 927, "Q")
plottonet(g, stp)
title(paste(diff(range(stp$Time)), "time elapsed"))

</code></pre>

<hr>
<h2 id='spreadanalysis'>
Simulates the perfect spread of a resource on a time-ordered network.
</h2><span id='topic+spreadanalysis'></span>

<h3>Description</h3>

<p>Determines the number of unique vertices that can be causally linked to an interaction event after a certain time delay. This function determines the fraction of unique vertices reached after a certain time from a random sample of interaction events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spreadanalysis(g, timedelays, numsamples, normalizebyname=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spreadanalysis_+3A_g">g</code></td>
<td>

<p>The time-ordered network to be studied.
</p>
</td></tr>
<tr><td><code id="spreadanalysis_+3A_timedelays">timedelays</code></td>
<td>

<p>A vector time delays at which to determine the fraction of vertices reached.
</p>
</td></tr>
<tr><td><code id="spreadanalysis_+3A_numsamples">numsamples</code></td>
<td>

<p>The number of random events to sample (without replacement) as seeds for the spreading process.
</p>
</td></tr>
<tr><td><code id="spreadanalysis_+3A_normalizebyname">normalizebyname</code></td>
<td>

<p>If true, divides the number of vertices reached by the number of unique vertex names; if false, by the number of time-ordered vertices.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame whose columns are named for each time delay and contains the fraction of total vertices reached by a spreading process beginning from the seed vertices by the time delay.
</p>


<h3>Note</h3>

<p>Results can be aggregated by start vertex - see <code>transformspreadbyindividual</code>
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+transformspreadbyindividual">transformspreadbyindividual</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
sa &lt;- spreadanalysis(g, seq(0,1000,by=50), 20)
boxplot(sa[,-1],xlab="Time delay",ylab="Fraction reached")

</code></pre>

<hr>
<h2 id='swap'>
Swaps two elements in a data frame. An internal function.
</h2><span id='topic+swap'></span>

<h3>Description</h3>

<p>NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap(df, r1, c1, r2, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_+3A_df">df</code></td>
<td>

<p>A dataframe
</p>
</td></tr>
<tr><td><code id="swap_+3A_r1">r1</code></td>
<td>

<p>The first row to swap
</p>
</td></tr>
<tr><td><code id="swap_+3A_c1">c1</code></td>
<td>

<p>The first column to swap
</p>
</td></tr>
<tr><td><code id="swap_+3A_r2">r2</code></td>
<td>

<p>The second row to swap
</p>
</td></tr>
<tr><td><code id="swap_+3A_c2">c2</code></td>
<td>

<p>The second column to swap
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Gernat &lt;mail@timgernat.name&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (df, r1, c1, r2, c2) 
{
    tmp &lt;- df[r1, c1]
    df[r1, c1] &lt;- df[r2, c2]
    df[r2, c2] &lt;- tmp
    return(df)
  }
</code></pre>

<hr>
<h2 id='transformspreadbyindividual'>
A helper function to assess differences in spreading potential by vertex.
</h2><span id='topic+transformspreadbyindividual'></span>

<h3>Description</h3>

<p>Converts a data frame of spreading samples into a data frame that is grouped by vertex identity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformspreadbyindividual(sa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformspreadbyindividual_+3A_sa">sa</code></td>
<td>

<p>A data frame returned by <code>spreadanalysis</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame whose columns are the identities of vertices and whose rows are the mean fraction of vertices reached by the seed vertex at each time delay, averaged over all samples beginning at this vertex.
</p>


<h3>Author(s)</h3>

<p>Benjamin Blonder <a href="mailto:bblonder@email.arizona.edu">bblonder@email.arizona.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spreadanalysis">spreadanalysis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ants)
allindivs &lt;- c(union(ants$VertexFrom, ants$VertexTo), "NULL1", "NULL2")
g &lt;- generatetonetwork(ants, allindivs)
sa &lt;- spreadanalysis(g, seq(0,1000,by=50), 20)
b &lt;- transformspreadbyindividual(sa)
plot(ts(b),plot.type="single",col=rainbow(ncol(b)),xlab="Time",ylab="Fraction reached")
legend("bottomright",colnames(b),lwd=1,col=rainbow(ncol(b)),bg="white")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
