<!DOCTYPE html><html lang="en"><head><title>Help for package MOODE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MOODE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MOODE-package'><p>MOODE: Multi-Objective Optimal Design of Experiments</p></a></li>
<li><a href='#candidate_set_full'><p>Forms the full candidate set of treatments for all polynomial terms</p></a></li>
<li><a href='#candidate_set_orth'><p>Forms the orthonormalised full candidate set</p></a></li>
<li><a href='#candidate_trt_set'><p>Forms the labelled candidate set of treatments</p></a></li>
<li><a href='#criteria.GD'><p>Calculates the values of the Generalised Ds-criterion and its components</p></a></li>
<li><a href='#criteria.GDP'><p>Calculates the values of the Generalised DPs-criterion and its components</p></a></li>
<li><a href='#criteria.GL'><p>Calculates the values of the Generalised L-criterion and its components</p></a></li>
<li><a href='#criteria.GLP'><p>Calculates the values of the Generalised LP-criterion and its components</p></a></li>
<li><a href='#criteria.mseD'><p>Calculates the values of the MSE DPs-criterion and its components</p></a></li>
<li><a href='#criteria.mseL'><p>Calculates the values of the MSE LP-criterion and its components</p></a></li>
<li><a href='#criteria.mseP'><p>Calculates the values of the MSE DPs-criterion using the point prior for the MSE(D)-component estimation</p></a></li>
<li><a href='#criteria.values.G'><p>Evaluating individual criteria of the designs, from the Generalized compound criteria (Goos et al. 2005; Egorova,~O. 2017)</p></a></li>
<li><a href='#criteria.values.mse'><p>Evaluating individual criteria of the designs</p></a></li>
<li><a href='#mood'><p>Setting up the parameters of a factorial experiment to search for multi-objective optimal completely randomised design.</p></a></li>
<li><a href='#point.swap'><p>Swapping points between the current design and candidate set</p></a></li>
<li><a href='#print.settings'><p>S3 print method</p></a></li>
<li><a href='#Search'><p>Searching for a multi-objective optimal completely randomised design.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Objective Optimal Design of Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality to generate compound optimal designs for targeting the multiple experimental objectives directly, ensuring that the full set of research questions is answered as economically as possible. Designs can be found using point or coordinate exchange algorithms combining estimation, inference and lack-of-fit criteria that account for model inadequacy. Details and examples are given by Koutra et al. (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2412.17158">doi:10.48550/arXiv.2412.17158</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vkstats/MOODE">https://github.com/vkstats/MOODE</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vkstats/MOODE/issues">https://github.com/vkstats/MOODE/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, far, progressr, Rdpack, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doFuture, foreach</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-08 05:43:28 UTC; vallia</td>
</tr>
<tr>
<td>Author:</td>
<td>Vasiliki Koutra <a href="https://orcid.org/0000-0002-1117-4554"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Olga Egorova [aut, cph],
  Steven Gilmour [aut, cph],
  Luzia Trinca [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vasiliki Koutra &lt;vasiliki.koutra@kcl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-08 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MOODE-package'>MOODE: Multi-Objective Optimal Design of Experiments</h2><span id='topic+MOODE'></span><span id='topic+MOODE-package'></span>

<h3>Description</h3>

<p>Provides functionality to generate compound optimal designs for targeting the multiple experimental objectives directly, ensuring that the full set of research questions is answered as economically as possible. Designs can be found using point or coordinate exchange algorithms combining estimation, inference and lack-of-fit criteria that account for model inadequacy. Details and examples are given by Koutra et al. (2024) <a href="https://doi.org/10.48550/arXiv.2412.17158">doi:10.48550/arXiv.2412.17158</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Vasiliki Koutra <a href="mailto:vasiliki.koutra@kcl.ac.uk">vasiliki.koutra@kcl.ac.uk</a> (<a href="https://orcid.org/0000-0002-1117-4554">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Olga Egorova [copyright holder]
</p>
</li>
<li><p> Steven Gilmour [copyright holder]
</p>
</li>
<li><p> Luzia Trinca [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/vkstats/MOODE">https://github.com/vkstats/MOODE</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/vkstats/MOODE/issues">https://github.com/vkstats/MOODE/issues</a>
</p>
</li></ul>


<hr>
<h2 id='candidate_set_full'>Forms the full candidate set of treatments for all polynomial terms</h2><span id='topic+candidate_set_full'></span>

<h3>Description</h3>

<p>This function forms the full extended candidate set with all polynomial terms, with labels, not orthonormalised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>candidate_set_full(cand.trt, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="candidate_set_full_+3A_cand.trt">cand.trt</code></td>
<td>
<p>Candidate set of treatments, the first column contains treatment labels.
Usually obtained as output from the <a href="#topic+candidate_trt_set">candidate_trt_set</a> function.</p>
</td></tr>
<tr><td><code id="candidate_set_full_+3A_k">K</code></td>
<td>
<p>Number of factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full extended candidate set: the column of treatment labels, then named columns with polynomial terms up to the 4th order.
For example, &quot;x12&quot; stands for <code class="reqn">x_1^2</code>, and &quot;x1x2 stands for <code class="reqn">x_1x_2</code>, and &quot;x23x4&quot; for <code class="reqn">x_2^3x_4</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Full extended candidate set for two 3-level factors

K&lt;-2; Levels &lt;- rep(list(1:3),K);
candidate_set_full(candidate_trt_set(Levels, K), K)
</code></pre>

<hr>
<h2 id='candidate_set_orth'>Forms the orthonormalised full candidate set</h2><span id='topic+candidate_set_orth'></span>

<h3>Description</h3>

<p>This function forms the full extended orthonormalised candidate set of primary and potential terms, with an intercept column and labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>candidate_set_orth(cand.full, primary.terms, potential.terms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="candidate_set_orth_+3A_cand.full">cand.full</code></td>
<td>
<p>Candidate set containing terms up to 4th order, with labels in the first column.</p>
</td></tr>
<tr><td><code id="candidate_set_orth_+3A_primary.terms">primary.terms</code></td>
<td>
<p>Character vector identifying primary model terms.</p>
</td></tr>
<tr><td><code id="candidate_set_orth_+3A_potential.terms">potential.terms</code></td>
<td>
<p>Character vector identifying potential model terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The orthonormalised full candidate set containing primary and potential terms, with labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Full extended orthonormalised candidate set for two 4-level factors, 
# full quadratic polynomial model as primary model and all three-order terms as potential.

K&lt;-2; Levels &lt;- rep(list(1:4),K)
cand.trt &lt;- candidate_trt_set(Levels, K)
cand.full &lt;- candidate_set_full(cand.trt, K)
prime.terms &lt;- colnames(cand.full)[2:7]
poten.terms &lt;- colnames(cand.full)[8:11]
Parameters &lt;- c(1, rep(1,K), rep(1,K), K*(K-1)/2) 
candidate_set_orth(cand.full, prime.terms, poten.terms) 
</code></pre>

<hr>
<h2 id='candidate_trt_set'>Forms the labelled candidate set of treatments</h2><span id='topic+candidate_trt_set'></span>

<h3>Description</h3>

<p>This function forms the candidate set of treatments from the factors' levels,
adds labels, with optional spherical transformation of the coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>candidate_trt_set(Levels, K, Hypercube = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="candidate_trt_set_+3A_levels">Levels</code></td>
<td>
<p>Levels of each factor.</p>
</td></tr>
<tr><td><code id="candidate_trt_set_+3A_k">K</code></td>
<td>
<p>Number of factors.</p>
</td></tr>
<tr><td><code id="candidate_trt_set_+3A_hypercube">Hypercube</code></td>
<td>
<p>Indicates if the experimental region is a hypercube ('TRUE') or spherical ('FALSE').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of candidate set of treatments, with treatment labels contained in the first column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Candidate treatment set for five 3-level factors

K&lt;-5; Levels &lt;- rep(list(1:3),K);
candidate_trt_set(Levels, K) 
</code></pre>

<hr>
<h2 id='criteria.GD'>Calculates the values of the Generalised Ds-criterion and its components</h2><span id='topic+criteria.GD'></span>

<h3>Description</h3>

<p>This function evaluates the Generalised Ds-criterion (Goos et al. 2005) for given primary and potential model matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.GD(X1, X2, search.object, eps = 1e-23)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.GD_+3A_x1">X1</code></td>
<td>
<p>The primary model matrix, with the first column containing the labels of treatments, and the second &ndash; the intercept term.</p>
</td></tr>
<tr><td><code id="criteria.GD_+3A_x2">X2</code></td>
<td>
<p>The matrix of potential terms, with the first column containing the labels of treatments.</p>
</td></tr>
<tr><td><code id="criteria.GD_+3A_search.object">search.object</code></td>
<td>
<p>Object of class <code><a href="#topic+mood">mood()</a></code> specifying experiment parameters.</p>
</td></tr>
<tr><td><code id="criteria.GD_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, the default value is 10^-23</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values: indicator of whether the evaluation was successful (&quot;eval&quot;), Ds-criterion value &ndash; intercept excluded (&quot;Ds&quot;),
Lack-of-fit criterion value (&quot;LoF&quot;), the bias component value (&quot;bias&quot;), the number of pure error degrees of freedom (&quot;df&quot;)
and the value of the compound criterion (&quot;compound&quot;).
</p>


<h3>References</h3>

<p>Goos P, Kobilinsky A, O'Brien TE, Vandebroek M (2005).
&ldquo;Model-Robust and Model-Sensitive Designs.&rdquo;
<em>Computational Statistics and Data Analysis</em>, <b>49</b>, 201-216.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Experiment: one 5-level factor, primary model -- full quadratic, one potential (cubic) term
# setting up the example
ex.mood &lt;- mood(K = 1, Levels = 5, Nruns = 7, criterion.choice = "GDP", 
               kappa = list(kappa.Ds = 1./3, kappa.LoF = 1./3, kappa.bias = 1./3), 
               model_terms = list(primary.model = "second_order", potential.model = "cubic_terms"))
# Generating candidate set: orthonormalised
K &lt;- ex.mood$K
Levels &lt;- ex.mood$Levels 
cand.not.orth &lt;- candidate_set_full(candidate_trt_set(Levels, K), K)
cand.full.orth &lt;- candidate_set_orth(cand.not.orth, ex.mood$primary.terms, ex.mood$potential.terms)
# Choosing a design
index &lt;- c(rep(1, 2), 3, 4, rep(5, 3))
X.primary &lt;- cand.full.orth[index, c(1, match(ex.mood$primary.terms, colnames(cand.full.orth)))]
X.potential &lt;- cand.full.orth[index, 
(c(1, match(ex.mood$potential.terms, colnames(cand.full.orth))))]
# Evaluating a compound GD-criterion
criteria.GD(X1 = X.primary, X2 = X.potential, ex.mood)
# Output: eval = 1, Ds = 0.7334291, LoF = 0.7212544, bias = 1.473138, df = 3, compound = 0.9202307
</code></pre>

<hr>
<h2 id='criteria.GDP'>Calculates the values of the Generalised DPs-criterion and its components</h2><span id='topic+criteria.GDP'></span>

<h3>Description</h3>

<p>This function evaluates the Generalised DPs-criterion for given primary and potential model matrices.
Components: Ds-, DPs-, LoF(DP)- and Bias(D)-optimality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.GDP(X1, X2, search.object, eps = 10^-23)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.GDP_+3A_x1">X1</code></td>
<td>
<p>The primary model matrix, with the first column containing the labels of treatments, and the second &ndash; the intercept term.</p>
</td></tr>
<tr><td><code id="criteria.GDP_+3A_x2">X2</code></td>
<td>
<p>The matrix of potential terms, with the first column containing the labels of treatments.</p>
</td></tr>
<tr><td><code id="criteria.GDP_+3A_search.object">search.object</code></td>
<td>
<p>Object of class <code><a href="#topic+mood">mood()</a></code> specifying experiment parameters.</p>
</td></tr>
<tr><td><code id="criteria.GDP_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, the default value is 10^-23</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values: indicator of whether the evaluation was successful (&quot;eval&quot;), Ds-criterion value &ndash; intercept excluded (&quot;Ds&quot;),
DPs-criterion value &ndash; intercept excluded (&quot;DPs&quot;), Lack-of-fit(DP) criterion value (&quot;LoF&quot;), the bias component value (&quot;bias&quot;),
the number of pure error degrees of freedom (&quot;df&quot;) and the value of the compound criterion (&quot;compound&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Experiment: one 5-level factor, primary model -- full quadratic, X^3 and X^4 potential terms.
ex.mood &lt;- mood(K = 1, Levels = 5, Nruns = 8, criterion.choice = "GDP", 
               kappa = list(kappa.Ds = .25, kappa.LoF = .25, kappa.bias = .25, kappa.DP = .25), 
               model_terms = list(primary.model = "second_order", potential.terms = "x14"))
# Generating candidate sets: primary and full orthonormalised ones
K &lt;- ex.mood$K
Levels &lt;- ex.mood$Levels 
cand.not.orth &lt;- candidate_set_full(candidate_trt_set(Levels, K), K)
cand.full.orth &lt;- candidate_set_orth(cand.not.orth, ex.mood$primary.terms, ex.mood$potential.terms)
# Choosing a design
index &lt;- c(rep(1,2),3,rep(4,2),rep(5,3))
X.primary &lt;- cand.full.orth[index, c(1, match(ex.mood$primary.terms, colnames(cand.full.orth)))]
X.potential &lt;- cand.full.orth[index, 
(c(1, match(ex.mood$potential.terms, colnames(cand.full.orth))))]
# Evaluating a compound GDP-criterion
criteria.GDP(X1 = X.primary, X2 = X.potential, ex.mood)

# Output: eval = 1, Ds = 0.6884783, DP = 4.4538023, LoF = 3.895182, 
# bias = 1.03807, df = 4, compound = 2.465318

</code></pre>

<hr>
<h2 id='criteria.GL'>Calculates the values of the Generalised L-criterion and its components</h2><span id='topic+criteria.GL'></span>

<h3>Description</h3>

<p>This function evaluates the Generalised L-criterion (Goos et al. 2005) for given primary and potential model matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.GL(X1, X2, search.object, eps = 10^-23)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.GL_+3A_x1">X1</code></td>
<td>
<p>The primary model matrix, with the first column containing the labels of treatments, and the second &ndash; the intercept term.</p>
</td></tr>
<tr><td><code id="criteria.GL_+3A_x2">X2</code></td>
<td>
<p>The matrix of potential terms, with the first column containing the labels of treatments.</p>
</td></tr>
<tr><td><code id="criteria.GL_+3A_search.object">search.object</code></td>
<td>
<p>Object of class <code><a href="#topic+mood">mood()</a></code> specifying experiment parameters.</p>
</td></tr>
<tr><td><code id="criteria.GL_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, the default value is 10^-23</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values: indicator of whether the evaluation was successful (&quot;eval&quot;), Ls-criterion value &ndash; intercept excluded (&quot;Ls&quot;),
Lack-of-fit criterion value (&quot;LoF&quot;), the bias component value (&quot;bias&quot;), the number of pure error degrees of freedom (&quot;df&quot;)
and the value of the compound criterion (&quot;compound&quot;).
</p>


<h3>References</h3>

<p>Goos P, Kobilinsky A, O'Brien TE, Vandebroek M (2005).
&ldquo;Model-Robust and Model-Sensitive Designs.&rdquo;
<em>Computational Statistics and Data Analysis</em>, <b>49</b>, 201-216.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Experiment: one 5-level factor, primary model -- full quadratic, one potential (cubic) term
# setting up the example
ex.mood &lt;- mood(K = 1, Levels = 5, Nruns = 7, criterion.choice = "GL", 
               kappa = list(kappa.L = 1./3, kappa.LoF = 1./3, kappa.bias = 1./3), 
               model_terms = list(primary.model = "second_order", potential.model = "cubic_terms"))
# Generating candidate set: orthonormalised
K &lt;- ex.mood$K
Levels &lt;- ex.mood$Levels 
cand.not.orth &lt;- candidate_set_full(candidate_trt_set(Levels, K), K)
cand.full.orth &lt;- candidate_set_orth(cand.not.orth, ex.mood$primary.terms, ex.mood$potential.terms)
# Choosing a design
index &lt;- c(rep(1, 2), 3, 4, rep(5, 3))
X.primary &lt;- cand.full.orth[index, c(1, match(ex.mood$primary.terms, colnames(cand.full.orth)))]
X.potential &lt;- cand.full.orth[index, 
(c(1, match(ex.mood$potential.terms, colnames(cand.full.orth))))]
# Evaluating a compound GD-criterion
criteria.GL(X1 = X.primary, X2 = X.potential, ex.mood)
# Output: eval = 1, L = 0.3118626, LoF = 0.7212544, bias = 1.473138, df = 3, compound = 0.6919878

</code></pre>

<hr>
<h2 id='criteria.GLP'>Calculates the values of the Generalised LP-criterion and its components</h2><span id='topic+criteria.GLP'></span>

<h3>Description</h3>

<p>This function evaluates the Generalised LP-criterion for given primary and potential model matrices.
Components: L-, LP-, LoF(LP)- and Bias(L)-optimality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.GLP(X1, X2, search.object, eps = 1e-23)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.GLP_+3A_x1">X1</code></td>
<td>
<p>The primary model matrix, with the first column containing the labels of treatments, and the second &ndash; the intercept term.</p>
</td></tr>
<tr><td><code id="criteria.GLP_+3A_x2">X2</code></td>
<td>
<p>The matrix of potential terms, with the first column containing the labels of treatments.</p>
</td></tr>
<tr><td><code id="criteria.GLP_+3A_search.object">search.object</code></td>
<td>
<p>Object of class <code><a href="#topic+mood">mood()</a></code> specifying experiment parameters.</p>
</td></tr>
<tr><td><code id="criteria.GLP_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, the default value is 10^-23</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values: indicator of whether the evaluation was successful (&quot;eval&quot;), Ls-criterion value &ndash; intercept excluded (&quot;L&quot;),
LP-criterion value &ndash; intercept excluded (&quot;LP&quot;), Lack-of-fit(LP) criterion value (&quot;LoF&quot;), the bias component value (&quot;bias&quot;),
the number of pure error degrees of freedom (&quot;df&quot;) and the value of the compound criterion (&quot;compound&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Experiment: one 5-level factor, primary model -- full quadratic, X^3 and X^4 potential terms.
ex.mood &lt;- mood(K = 1, Levels = 5, Nruns = 8, criterion.choice = "GLP", 
               kappa = list(kappa.L = .25, kappa.LoF = .25, kappa.bias = .25, kappa.LP = .25), 
               model_terms = list(primary.model = "second_order", potential.terms = "x14"))
# Generating candidate sets: primary and full orthonormalised ones
K &lt;- ex.mood$K
Levels &lt;- ex.mood$Levels 
cand.not.orth &lt;- candidate_set_full(candidate_trt_set(Levels, K), K)
cand.full.orth &lt;- candidate_set_orth(cand.not.orth, ex.mood$primary.terms, ex.mood$potential.terms)
# Choosing a design
index &lt;- c(rep(1,2),3,rep(4,2),rep(5,3))
X.primary &lt;- cand.full.orth[index, c(1, match(ex.mood$primary.terms, colnames(cand.full.orth)))]
X.potential &lt;- cand.full.orth[index, 
(c(1, match(ex.mood$potential.terms, colnames(cand.full.orth))))]
# Evaluating a compound GDP-criterion
criteria.GLP(X1 = X.primary, X2 = X.potential, ex.mood)
# Output: eval = 1, L = 0.2952603, LP = 4.584705, LoF = 3.895182, 
# bias = 1.03807, df = 4, compound = 1.529564

</code></pre>

<hr>
<h2 id='criteria.mseD'>Calculates the values of the MSE DPs-criterion and its components</h2><span id='topic+criteria.mseD'></span>

<h3>Description</h3>

<p>This function evaluates the MSE DPs-criterion for given primary and potential model matrices. Candidate full model matrices do not have to be orthonormalised.
Components: DPs-, LoF(DP)- and MSE(D)-optimality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.mseD(X1, X2, search.object, eps = 1e-23)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.mseD_+3A_x1">X1</code></td>
<td>
<p>The primary model matrix, with the first column containing the labels of treatments, and the second &ndash; the intercept term.</p>
</td></tr>
<tr><td><code id="criteria.mseD_+3A_x2">X2</code></td>
<td>
<p>The matrix of potential terms, with the first column containing the labels of treatments.</p>
</td></tr>
<tr><td><code id="criteria.mseD_+3A_search.object">search.object</code></td>
<td>
<p>Object of class <code><a href="#topic+mood">mood()</a></code> specifying experiment parameters.</p>
</td></tr>
<tr><td><code id="criteria.mseD_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, the default value is 10^-23</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values: indicator of whether the evaluation was successful (&quot;eval&quot;), DPs-criterion value &ndash; intercept excluded (&quot;DP&quot;),
Lack-of-fit(DP) criterion value (&quot;LoF&quot;), the MSE(D) component value (&quot;mse&quot;),
the number of pure error degrees of freedom (&quot;df&quot;) and the value of the compound criterion (&quot;compound&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Experiment: one 5-level factor, primary model -- full quadratic, X^3 and X^4 potential terms.
set.seed(20210930)
ex.mood &lt;- mood(K = 1, Levels = 5, Nruns = 8, criterion.choice = "MSE.D", 
               kappa = list(kappa.DP = 1./3, kappa.LoF = 1./3, kappa.mse = 1./3), 
               control = list(Biter = 1000), 
               model_terms = list(primary.model = "second_order", potential.terms = "x14"))
# Generating candidate sets: primary and full orthonormalised ones
K &lt;- ex.mood$K
Levels &lt;- ex.mood$Levels 
cand.not.orth &lt;- candidate_set_full(candidate_trt_set(Levels, K), K)
cand.full.orth &lt;- candidate_set_orth(cand.not.orth, ex.mood$primary.terms, ex.mood$potential.terms)
# Choosing a design
index &lt;- c(rep(1,2),3,rep(4,2),rep(5,3))
X.primary &lt;- cand.full.orth[index, c(1, match(ex.mood$primary.terms, colnames(cand.full.orth)))]
X.potential &lt;- cand.full.orth[index, 
(c(1, match(ex.mood$potential.terms, colnames(cand.full.orth))))]
# Evaluating a compound GDP-criterion
criteria.mseD(X.primary, X.potential, ex.mood)
# Output: eval = 1, DP = 4.538023, LoF = 3.895182, mse = 0.6986903, df = 4, compound = 2.310728
</code></pre>

<hr>
<h2 id='criteria.mseL'>Calculates the values of the MSE LP-criterion and its components</h2><span id='topic+criteria.mseL'></span>

<h3>Description</h3>

<p>This function evaluates the MSE LP-criterion for given primary and potential model matrices. Candidate full model matrices do not have to be orthonormalised.
Components: LP-, LoF(LP)- and MSE(L)-optimality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.mseL(X1, X2, search.object, eps = 10^-23)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.mseL_+3A_x1">X1</code></td>
<td>
<p>The primary model matrix, with the first column containing the labels of treatments, and the second &ndash; the intercept term.</p>
</td></tr>
<tr><td><code id="criteria.mseL_+3A_x2">X2</code></td>
<td>
<p>The matrix of potential terms, with the first column containing the labels of treatments.</p>
</td></tr>
<tr><td><code id="criteria.mseL_+3A_search.object">search.object</code></td>
<td>
<p>Object of class <code><a href="#topic+mood">mood()</a></code> specifying experiment parameters.</p>
</td></tr>
<tr><td><code id="criteria.mseL_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, the default value is 10^-23</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values: indicator of whether the evaluation was successful (&quot;eval&quot;), LP-criterion value &ndash; intercept excluded (&quot;LP&quot;),
Lack-of-fit(LP) criterion value (&quot;LoF&quot;), the MSE(L) component value (&quot;mse&quot;),
the number of pure error degrees of freedom (&quot;df&quot;) and the value of the compound criterion (&quot;compound&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#'# Experiment: one 5-level factor, primary model -- full quadratic, X^3 and X^4 potential terms.
ex.mood &lt;- mood(K = 1, Levels = 5, Nruns = 8, criterion.choice = "MSE.L", 
               kappa = list(kappa.LP = 1./3, kappa.LoF = 1./3, kappa.mse = 1./3), 
               model_terms = list(primary.model = "second_order", potential.terms = "x14"))
# Generating candidate sets: primary and full orthonormalised ones
K &lt;- ex.mood$K
Levels &lt;- ex.mood$Levels 
cand.not.orth &lt;- candidate_set_full(candidate_trt_set(Levels, K), K)
cand.full.orth &lt;- candidate_set_orth(cand.not.orth, ex.mood$primary.terms, ex.mood$potential.terms)
# Choosing a design
index &lt;- c(rep(1,2),3,rep(4,2),rep(5,3))
X.primary &lt;- cand.full.orth[index, c(1, match(ex.mood$primary.terms, colnames(cand.full.orth)))]
X.potential &lt;- cand.full.orth[index, 
(c(1, match(ex.mood$potential.terms, colnames(cand.full.orth))))]
# Evaluating a compound GDP-criterion
criteria.mseL(X.primary, X.potential, ex.mood)
# Output: eval = 1, LP = 4.584705, LoF = 3.895182, mse = 0.3926842, df = 4, compound = 1.914084
</code></pre>

<hr>
<h2 id='criteria.mseP'>Calculates the values of the MSE DPs-criterion using the point prior for the MSE(D)-component estimation</h2><span id='topic+criteria.mseP'></span>

<h3>Description</h3>

<p>This function evaluates the MSE DPs-criterion for given primary and potential model matrices, using point MSE(D)-component estimation. Candidate full model matrices do not have to be orthonormalised.
Components: DPs-, LoF(DP)- and MSE(D)-optimality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.mseP(X1, X2, search.object, eps = 10^-23)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.mseP_+3A_x1">X1</code></td>
<td>
<p>The primary model matrix, with the first column containing the labels of treatments, and the second &ndash; the intercept term.</p>
</td></tr>
<tr><td><code id="criteria.mseP_+3A_x2">X2</code></td>
<td>
<p>The matrix of potential terms, with the first column containing the labels of treatments.</p>
</td></tr>
<tr><td><code id="criteria.mseP_+3A_search.object">search.object</code></td>
<td>
<p>Object of class <code><a href="#topic+mood">mood()</a></code> specifying experiment parameters.</p>
</td></tr>
<tr><td><code id="criteria.mseP_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, the default value is 10^-23</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values: indicator of whether the evaluation was successful (&quot;eval&quot;), DPs-criterion value &ndash; intercept excluded (&quot;DP&quot;),
Lack-of-fit(DP) criterion value (&quot;LoF&quot;), the MSE(D) component value (&quot;mse&quot;),
the number of pure error degrees of freedom (&quot;df&quot;) and the value of the compound criterion (&quot;compound&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Experiment: one 5-level factor, primary model -- full quadratic, X^3 and X^4 potential terms.
ex.mood &lt;- mood(K = 1, Levels = 5, Nruns = 8, criterion.choice = "MSE.P", 
               kappa = list(kappa.DP = 1./3, kappa.LoF = 1./3, kappa.mse = 1./3), 
               model_terms = list(primary.model = "second_order", potential.terms = "x14"))
# Generating candidate sets: primary and full orthonormalised
K &lt;- ex.mood$K
Levels &lt;- ex.mood$Levels 
cand.not.orth &lt;- candidate_set_full(candidate_trt_set(Levels, K), K)
cand.full.orth &lt;- candidate_set_orth(cand.not.orth, ex.mood$primary.terms, ex.mood$potential.terms)
# Choosing a design
index &lt;- c(rep(1,2),3,rep(4,2),rep(5,3))
X.primary &lt;- cand.full.orth[index, c(1, match(ex.mood$primary.terms, colnames(cand.full.orth)))]
X.potential &lt;- cand.full.orth[index, 
(c(1, match(ex.mood$potential.terms, colnames(cand.full.orth))))]
# Evaluating a compound GDP-criterion
criteria.mseP(X.primary, X.potential, ex.mood)
# Output: eval = 1, DP = 4.538023, LoF = 3.895182, mse = 0.6992699, df = 4, compound = 2.312135
</code></pre>

<hr>
<h2 id='criteria.values.G'>Evaluating individual criteria of the designs, from the Generalized compound criteria (Goos et al. 2005; Egorova,~O. 2017)</h2><span id='topic+criteria.values.G'></span>

<h3>Description</h3>

<p>Calculating values of determinant- and trace-based components of
Generalized D-, DP-, L- and LP- criteria for an output of a search object,
with model and control parameters set in a mood object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.values.G(search.obj, mood.obj, eps = 10^-23)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.values.G_+3A_search.obj">search.obj</code></td>
<td>
<p>Output of the &lsquo;Search&rsquo; function</p>
</td></tr>
<tr><td><code id="criteria.values.G_+3A_mood.obj">mood.obj</code></td>
<td>
<p>Output of the &lsquo;mood&rsquo; function</p>
</td></tr>
<tr><td><code id="criteria.values.G_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, default 10^-20</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the calculated values:
</p>

<ul>
<li> <p><code>df</code> pure error degrees of freedom
</p>
</li>
<li> <p><code>Ds</code> Ds-criterion value, intercept excluded
</p>
</li>
<li> <p><code>DP</code> DPs-criterion value, intercept excluded
</p>
</li>
<li> <p><code>LoFD</code> LoF(D)-criterion value from the GD-criterion
</p>
</li>
<li> <p><code>LoFDP</code> LoF(DP)-criterion value from the GDP-criterion
</p>
</li>
<li> <p><code>biasD</code> bias(D)-criterion value from the GD-criterion
</p>
</li>
<li> <p><code>Ls</code> Ls-criterion value, intercept excluded
</p>
</li>
<li> <p><code>LP</code> LPs-criterion value, intercept excluded
</p>
</li>
<li> <p><code>LoFL</code> LoF(L)-criterion value from the GL-criterion
</p>
</li>
<li> <p><code>LoFLP</code> LoF(LP)-criterion value from the GLP-criterion
</p>
</li>
<li> <p><code>biasL</code> bias(L)-criterion value from the GL-criterion
</p>
</li></ul>



<h3>References</h3>

<p>Egorova,~O. (2017).
<em>Optimal Design of Experiments for Multiple Objectives</em>.
Ph.D. thesis, University of Southampton.<br /><br /> Goos P, Kobilinsky A, O'Brien TE, Vandebroek M (2005).
&ldquo;Model-Robust and Model-Sensitive Designs.&rdquo;
<em>Computational Statistics and Data Analysis</em>, <b>49</b>, 201-216.
</p>

<hr>
<h2 id='criteria.values.mse'>Evaluating individual criteria of the designs</h2><span id='topic+criteria.values.mse'></span>

<h3>Description</h3>

<p>Calculating values of determinant- and trace-based components of
MSE(D)- and MSE(L)- criteria for an output of a search object,
with model and control parameters set in a mood object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.values.mse(search.obj, mood.obj, eps = 10^-20, Biter = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criteria.values.mse_+3A_search.obj">search.obj</code></td>
<td>
<p>Output of the &lsquo;Search&rsquo; function</p>
</td></tr>
<tr><td><code id="criteria.values.mse_+3A_mood.obj">mood.obj</code></td>
<td>
<p>Output of the &lsquo;mood&rsquo; function</p>
</td></tr>
<tr><td><code id="criteria.values.mse_+3A_eps">eps</code></td>
<td>
<p>Computational tolerance, default 10^-20</p>
</td></tr>
<tr><td><code id="criteria.values.mse_+3A_biter">Biter</code></td>
<td>
<p>MC sample size for evaluating the mse(D)-component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the calculated values:
</p>

<ul>
<li> <p><code>df</code> pure error degrees of freedom
</p>
</li>
<li> <p><code>Ds</code> Ds-criterion value, intercept excluded
</p>
</li>
<li> <p><code>DP</code> DPs-criterion value, intercept excluded
</p>
</li>
<li> <p><code>LoFDP</code> LoF(DP)-criterion value
</p>
</li>
<li> <p><code>mseD</code> mse(D)-criterion value, obtained via MC sampling
</p>
</li>
<li> <p><code>mseP</code> mse(D)-criterion value, obtained using point prior
</p>
</li>
<li> <p><code>L</code> L-criterion value, intercept excluded
</p>
</li>
<li> <p><code>LP</code> LP-criterion value, intercept excluded
</p>
</li>
<li> <p><code>LoFLP</code> LoF(LP)-criterion value
</p>
</li>
<li> <p><code>mseL</code> mse(L)-criterion value
</p>
</li></ul>


<hr>
<h2 id='mood'>Setting up the parameters of a factorial experiment to search for multi-objective optimal completely randomised design.</h2><span id='topic+mood'></span>

<h3>Description</h3>

<p>Creates an object containing the parameters of the experiment, compound optimality criterion with the
weights and parameters of the search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mood(
  K,
  Levels,
  Nruns,
  criterion.choice = c("GD", "GL", "GDP", "GLP", "MSE.D", "MSE.L", "MSE.P"),
  kappa = list(),
  control = list(),
  prob = list(),
  model_terms = list(primary.model = "first_order")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mood_+3A_k">K</code></td>
<td>
<p>Number of factors.</p>
</td></tr>
<tr><td><code id="mood_+3A_levels">Levels</code></td>
<td>
<p>Either (a) a common number of levels for each factor or (b) a list of length K of the vectors containing levels of each factor.</p>
</td></tr>
<tr><td><code id="mood_+3A_nruns">Nruns</code></td>
<td>
<p>Number of runs of the experiment.</p>
</td></tr>
<tr><td><code id="mood_+3A_criterion.choice">criterion.choice</code></td>
<td>
<p>Compound criterion to be used for the optimal design search or evaluation.
Possible values are:
</p>

<ul>
<li> <p><code>GL</code>, <code>GD</code> for Generalised D- and L-optimality (Goos et al. 2005)
</p>
</li>
<li> <p><code>GDP</code> and <code>GLP</code> for Generalised DP- and LP-optimality (Gilmour and Trinca 2012)
</p>
</li>
<li> <p><code>MSE.D</code>, <code>MSE.L</code> and <code>MSE.P</code> for compound criteria with MSE-component: determinant-based, trace-based and determinant-based but with point estimates for the MSE(D)-component
</p>
</li></ul>
</td></tr>
<tr><td><code id="mood_+3A_kappa">kappa</code></td>
<td>
<p>List specifying the weights used in the compound criterion. Each named entry must be between 0 and 1.
</p>

<ul>
<li> <p><code>kappa.Ds</code> Weight of the Ds-criterion (default = 1 if <code>criterion.choice = GD</code>)
</p>
</li>
<li> <p><code>kappa.DP</code> Weight of the DP-criterion (default = 1 if <code>criterion.choice = GDP</code>)
</p>
</li>
<li> <p><code>kappa.L</code> Weight of the L-criterion (default = 1 if <code>criterion.choice = GL</code>)
</p>
</li>
<li> <p><code>kappa.LP</code> Weight of the LP-criterion (default = 1 if <code>criterion.choice = GLP</code>)
</p>
</li>
<li> <p><code>kappa.LoF</code> Weight of the lack-of-fit criterion
</p>
</li>
<li> <p><code>kappa.bias</code> Weight of the bias criterion
</p>
</li>
<li> <p><code>kappa.mse</code> Weight of the MSE criterion (default = 1 if 'criterion.choice = MSE.*')
</p>
</li></ul>
</td></tr>
<tr><td><code id="mood_+3A_control">control</code></td>
<td>
<p>Named list specifying control parameters for the design search.
</p>

<ul>
<li> <p><code>Nstarts</code> The number of randomly generated start designs of the search algorithm (default = <code>10</code>).
</p>
</li>
<li> <p><code>Cubic</code> Indicator of whether the experimental region is cubic (<code>TRUE</code>, default) or spherical (<code>FALSE</code>).
</p>
</li>
<li> <p><code>tau2</code> The variance scaling parameter for the prior distribution of the potential terms (default = 1).
</p>
</li>
<li> <p><code>Biter</code> Number of samples for evaluating the MSE determinant-based component criterion (default = <code>50</code>).
</p>
</li>
<li> <p><code>MC</code> Indicator of whether to apply a multiple comparison (Bonferroni) correction for trace-based criteria (<code>TRUE</code>, default) or not (<code>FALSE</code>).
</p>
</li>
<li> <p><code>orth</code> Indicator of whether to orthonormalise the potential and primary terms (<code style="white-space: pre;">&#8288;TRUE', default) or not (&#8288;</code>FALSE').
</p>
</li></ul>
</td></tr>
<tr><td><code id="mood_+3A_prob">prob</code></td>
<td>
<p>Named list specifying confidence levels for DP- (<code>prob.DP</code>), LP- (<code>prob.LP</code>) and Lack-of-fit (<code>prob.LoF</code>) criteria (pre-Bonferroni correction).
All default to 0.95.</p>
</td></tr>
<tr><td><code id="mood_+3A_model_terms">model_terms</code></td>
<td>
<p>A list specifying the primary (fitted) and potential (biased) models with the following named elements (see Details).
</p>

<ul>
<li> <p><code>primary.model</code> The order of the fitted polynomial model. Alternatively polynomial terms can be directly specified through the <code>primary.terms</code> parameter.
</p>
</li>
<li> <p><code>potential.model</code> The order of the potential/extra polynomial terms. Alternatively can be specified through the <code>potential.terms</code> parameter.
</p>
</li>
<li> <p><code>primary.terms</code> Alternative specification of the primary model via character vector of the names of the primary terms.
</p>
</li>
<li> <p><code>potential.terms</code> Alternative specification of the potential model via character vector of the names of the potential terms.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides different ways of specifying the levels of the factors and the models. Although some default options are provided
for, e.g., <code>criterion.choice</code> and <code style="white-space: pre;">&#8288;kappa.*&#8288;</code> values, specification of these input parameters should be carefully chosen to reflect the aims of the experiment and available prior information.
</p>
<p>Specifying the factors and levels
</p>
<p>If all <code>K</code> factors have the same number of levels, <code>Levels</code> parameter is used to input that number.
Otherwise, <code>Levels</code> is set to be a list of vectors containing the values of the factors, e.g.
<code>list(1:3, 1:2, 1:4)</code> for 3 factors with equally spaced <code class="reqn">3, 2</code> and <code class="reqn">4</code> levels respectively.
</p>
<p>Specifying the fitted model and the potential terms
</p>
<p>There are two ways to describe the primary and potential sets of model terms via the <code>model_terms</code> list.
Named elements <code>primary.model</code> and <code>potential.model</code> can be used to specify the fitted model and the potential terms via a string form.
They are used to generate the sets of <code>primary.terms</code> and <code>potential.terms</code> which alternatively can be input directly.
Possible values of <code>primary.model</code> are:
</p>

<ul>
<li> <p><code>main_effects</code> &ndash; main effects for all the factors (default for all criteria)
</p>
</li>
<li> <p><code>first_order</code> &ndash; main effects and linear interactions
</p>
</li>
<li> <p><code>second_order</code> &ndash; full second order polynomial
</p>
</li>
<li> <p><code>third_order</code> &ndash; full second order polynomial model and all interactions of degree 3
</p>
</li>
<li> <p><code>cubic</code> &ndash; third order polynomial model with cubic terms
</p>
</li></ul>

<p>The intercept is always included as a primary term.
</p>
<p>Possible elements of the <code>potential.model</code> vector argument:
</p>

<ul>
<li> <p><code>linear_interactions</code> &ndash; linear interactions among the factors (default for MSE criteria)
</p>
</li>
<li> <p><code>quadratic_terms</code> &ndash; quadratic terms for all the factors
</p>
</li>
<li> <p><code>third_order_terms</code> &ndash;  all interactions of degree 3: linear-by-linear-by-linear and quadratic-by-linear terms
</p>
</li>
<li> <p><code>cubic_terms</code> &ndash; cubic terms for all the factors
</p>
</li>
<li> <p><code>fourth_order_terms</code> &ndash; all interactions of degree 4, similar to <code>third_order_terms</code>
</p>
</li></ul>

<p><code>primary.terms</code> and <code>potential.terms</code> arguments are used to specify the fitted model and the potential terms explicitly &ndash; up to the total power of 4.
</p>

<ul>
<li><p> Single factor powers,  are coded as a string starting with with &quot;x&quot; and followed by
the index of the factor and the power: <code>"x32"</code>.
For example, <code class="reqn">x_3^2</code> is coded as <code>"x32"</code>; <code>"x22"</code> stands for <code class="reqn">x_2^2</code>, and <code>"x4"</code> stands for the linear term <code class="reqn">x_4</code>.
</p>
</li>
<li><p> Interaction of factors' powers are coded by merging the individual factors'
powers, ordered by the factors' indexes. For example, <code class="reqn">x_2^2\times x_1</code> is coded as <code>"x1x22"</code>,
<code class="reqn">x_3x_12x_4</code> &ndash; as <code>"x12x3x4"</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>List of parameters of the experiment, compound criterion of choice, and primary and potential model terms.
</p>

<ul>
<li> <p><code>K</code> Number of factors.
</p>
</li>
<li> <p><code>Klev</code> Number of levels of each factor, if all factors have the same number of levels.
</p>
</li>
<li> <p><code>Levels</code> List of length K of the vectors containing values of the factors.
</p>
</li>
<li> <p><code>Nruns</code> Number of runs of the experiment.
</p>
</li>
<li> <p><code>criterion.choice</code> Compound criterion to be used for the optimal design search or evaluation.
</p>
</li>
<li> <p><code>Nstarts</code> The number of randomly generated start designs of the search algorithm.
</p>
</li>
<li> <p><code>Biter</code> Number of samples for evaluating the MSE determinant-based component criterion.
</p>
</li>
<li> <p><code>tau2</code> The variance scaling parameter for the prior distribution of the potential terms.
</p>
</li>
<li> <p><code>tau</code>  The square root of <code>tau2</code>
</p>
</li>
<li> <p><code>Cubic</code> Whether the experimental region is cubic (<code>TRUE</code>) or spherical (<code>FALSE</code>).
</p>
</li>
<li> <p><code>MC</code> Indicator of the multiple comparison (Bonferroni) correction for trace-based criteria.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;prob.DP, prob.LP, prob.LoF, prob.LoFL&#8288;</code> Confidence levels for the DP-, LP-, lack of fit determinant- and trace-based criteria.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;alpha.DP, alpha.LP, alpha.LoF, alpha.LoFL&#8288;</code> Significance levels for the DP-, LP-, lack of fit determinant- and trace-based criteria.
</p>
</li>
<li> <p><code>orth</code> Whether the candidate sets are orthonormalised (<code>TRUE</code>) or not (<code>FALSE</code>).
</p>
</li>
<li> <p><code>Z0</code> Z0 matrix.
</p>
</li>
<li> <p><code>W</code> Weight matrix for Ls criterion.
</p>
</li>
<li> <p><code>primary.terms</code> Fitted (primary) model terms.
</p>
</li>
<li> <p><code>potential.terms</code> Potential terms.
</p>
</li>
<li> <p><code>P</code> The number of terms in the fitted model (including intercept).
</p>
</li>
<li> <p><code>Q</code> The number of potential terms.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;kappa.Ds, kappa.DP, kappa.L, kappa.LP,  kappa.LoF, kappa.bias, kappa.mse&#8288;</code> Compound criterion weights.
</p>
</li>
<li> <p><code>warning.msg</code> Warning messages.
</p>
</li></ul>



<h3>References</h3>

<p>Gilmour SG, Trinca LA (2012).
&ldquo;Optimum Design of Experiments for Statistical Inference (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society C</em>, <b>61</b>, 345-401.<br /><br /> Goos P, Kobilinsky A, O'Brien TE, Vandebroek M (2005).
&ldquo;Model-Robust and Model-Sensitive Designs.&rdquo;
<em>Computational Statistics and Data Analysis</em>, <b>49</b>, 201-216.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example1 &lt;- mood(K = 5, Levels = 3, Nruns = 40, criterion.choice = "GDP", 
kappa = list(kappa.Ds = 1./3, kappa.DP = 1./3, kappa.LoF = 1./3), 
control = list(Nstarts = 50, tau2 = 0.1),
model_terms = list(primary.model = "second_order", 
potential.terms = c("x12x2", "x22x3", "x32x4", "x42x5")))
example1

example2 &lt;- mood(K = 3, Nruns = 12, Levels = list(1:3, 1:2, 1:2), criterion.choice = "MSE.L",
kappa = list(kappa.LP = 1./2, kappa.LoF = 1./4, kappa.mse = 1./4),
control = list(Nstarts = 50, tau2 = 1), 
model_terms = list(primary.terms = "first_order",
potential.terms = c("x12", "x12x2", "x12x3")))
example2

</code></pre>

<hr>
<h2 id='point.swap'>Swapping points between the current design and candidate set</h2><span id='topic+point.swap'></span>

<h3>Description</h3>

<p>Performing point-exchange algorithm, extensive swap of points procedure between the current design
and candidate set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point.swap(X1, X2, cand.full, search.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point.swap_+3A_x1">X1</code></td>
<td>
<p>Current fitted (primary) model matrix</p>
</td></tr>
<tr><td><code id="point.swap_+3A_x2">X2</code></td>
<td>
<p>Current potential terms matrix</p>
</td></tr>
<tr><td><code id="point.swap_+3A_cand.full">cand.full</code></td>
<td>
<p>Full candidate matrix</p>
</td></tr>
<tr><td><code id="point.swap_+3A_search.object">search.object</code></td>
<td>
<p>Object for the search</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>point.swap</code> is called within the <code>Search</code> function
</p>


<h3>Value</h3>

<p>A list of model matrices, criteria values and
whether the search needs to continue
</p>

<hr>
<h2 id='print.settings'>S3 print method</h2><span id='topic+print.settings'></span>

<h3>Description</h3>

<p>Prints a summary of the mood object, including parameters that define the
experiment and the (compound) criterion under which the design
will be sought.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'settings'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.settings_+3A_x">x</code></td>
<td>
<p>mood object</p>
</td></tr>
<tr><td><code id="print.settings_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, prints summary of object to output
</p>

<hr>
<h2 id='Search'>Searching for a multi-objective optimal completely randomised design.</h2><span id='topic+Search'></span>

<h3>Description</h3>

<p>Performing search for a (nearly) optimum factorial design, optimising with respect to a specified compound criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Search(
  mood.object,
  algorithm = c("ptex", "coordex"),
  parallel = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Search_+3A_mood.object">mood.object</code></td>
<td>
<p>The object generated by <code>mood</code> function, containing the parameters of the experiment, the compound criterion and search parameters</p>
</td></tr>
<tr><td><code id="Search_+3A_algorithm">algorithm</code></td>
<td>
<p>Parameter specifying the search algorithm. If <code>ptex</code> (default for <code class="reqn">K&lt;=4</code>), the point-exchange algorithm is used, and if <code>coordex</code> (default for <code class="reqn">K&gt;4</code>), the coordinate-exchange.</p>
</td></tr>
<tr><td><code id="Search_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> use the <code>doFuture</code> package to run independent iterations of the algorithm in parallel using <code>foreach</code>. Requires <code>doFuture</code> library to be installed and a <code>Future</code> <code>plan</code> to be specified. See examples.</p>
</td></tr>
<tr><td><code id="Search_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, progress messages through the search iterations are shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Search</code> takes the mood object as an input with all the parameters of the experiment. Runs a point-exchange or a coordinate-exchange algorithm, returns design and model matrices, computation time and criteria values.
See (Koutra et al. 2024) for examples of using <code>parallel = TRUE</code>.
</p>


<h3>Value</h3>

<p>List of the outputs generated by the search:
</p>

<ul>
<li> <p><code>X.design</code> Design matrix.
</p>
</li>
<li> <p><code>df</code> The number of pure error degrees of freedom.
</p>
</li>
<li> <p><code>X1</code> Primary model matrix for the found (nearly-) optimum design.
</p>
</li>
<li> <p><code>X2</code> Model matrix of potential terms for the found (nearly-) optimum design.
</p>
</li>
<li> <p><code>compound.value</code> The compound criterion value of the (nearly-) optimum design.
</p>
</li>
<li> <p><code>criteria.values</code> Component criteria values of the (nearly-) optimum design.
</p>
</li>
<li> <p><code>path</code> The &quot;path&quot; of compound criterion values of the optimum designs obtained after for each random start.
</p>
</li>
<li> <p><code>time</code> Computation time.
</p>
</li>
<li> <p><code>algorithm</code> Point exchange or coordinate exchange used to find the design?
</p>
</li>
<li> <p><code>parallel</code> Were different runs of the algorithm performed across different CPU cores (<code>TRUE</code>/<code>FALSE</code>)
</p>
</li></ul>



<h3>References</h3>

<p>Koutra V, Egorova O, Gilmour SG, Trinca LA (2024).
&ldquo;MOODE: An R Package for Multi-Objective Optimal Design of Experiments.&rdquo;
arXiv:2412.17158, <a href="https://arxiv.org/abs/2412.17158">https://arxiv.org/abs/2412.17158</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mood">mood</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example1 &lt;- mood(K = 2, Levels = 3, Nruns = 10, criterion.choice = "GDP", 
                kappa = list(kappa.Ds = 1./3, kappa.DP = 1./3, kappa.LoF = 1./3), 
                control = list(tau2 = 0.1), 
                model_terms = list(primary.model = "first_order", 
                potential.terms = c("x12", "x22", "x1x2")))
# Using point exchange
Search_point &lt;- Search(example1, algorithm = 'ptex')
Search_point
# Using coordinate exchange (the default for K&gt;4)
Search_coord &lt;- Search(example1)
Search_coord
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
