<!DOCTYPE html><html lang="en"><head><title>Help for package robsurvey</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robsurvey}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#robsurvey-package'><p>Package Overview</p></a></li>
<li><a href='#class_svyreg_rob'><p>Utility Functions for Objects of Class svyreg_rob</p></a></li>
<li><a href='#class_svystat_rob'><p>Utility Functions for Objects of Class svystat_rob</p></a></li>
<li><a href='#counties'><p>Data on a Simple Random Sample of 100 Counties in the U.S.</p></a></li>
<li><a href='#flour'><p>Measurement of Copper Content in Wholemeal Flour</p></a></li>
<li><a href='#huber2'><p>Weighted Huber Proposal 2 Estimator</p></a></li>
<li><a href='#losdata'><p>Length-of-Stay (LOS) Hospital Data</p></a></li>
<li><a href='#mer'><p>Minimum Estimated Risk (MER) M-Estimator</p></a></li>
<li><a href='#MU284pps'><p>PPS Sample From the MU284 Population</p></a></li>
<li><a href='#MU284strat'><p>Stratified Sample from the MU284 Population</p></a></li>
<li><a href='#pps'><p>Sampling with probability proportional to size (pps without replacement)</p></a></li>
<li><a href='#robsurvey-deprecated'><p>Deprecated Functions in Package 'robsurvey'</p></a></li>
<li><a href='#robsvyreg'><p>Internal Function for the Regression GM-Estimator</p></a></li>
<li><a href='#svymean_dalen'><p>Dalen's Estimators of the Population Mean and Total</p></a></li>
<li><a href='#svymean_ratio'><p>Robust Ratio Predictor of the Mean and Total</p></a></li>
<li><a href='#svymean_reg'><p>Robust Generalized Regression Predictor (GREG) of the Mean and Total</p></a></li>
<li><a href='#svymean_trimmed'><p>Weighted Trimmed Mean and Total</p></a></li>
<li><a href='#svymean_winsorized'><p>Weighted Winsorized Mean and Total</p></a></li>
<li><a href='#svymean-m-estimator'><p>Weighted Huber and Tukey Mean and Total (M-Estimator) &ndash; Robust</p>
Horvitz-Thompson Estimator</a></li>
<li><a href='#svyratio_huber'><p>Robust Survey Ratio M-Estimator</p></a></li>
<li><a href='#svyreg'><p>Survey Regression Estimator &ndash; Weighted Least Squares</p></a></li>
<li><a href='#svyreg_huber-deprecated'><p>Deprecated Huber Robust Survey Regression M-Estimator</p></a></li>
<li><a href='#svyreg_huberM'><p>Huber Robust Survey Regression M- and GM-Estimator</p></a></li>
<li><a href='#svyreg_tukey-deprecated'><p>Deprecated Tukey Biweight Robust Survey Regression M-Estimator</p></a></li>
<li><a href='#svyreg_tukeyM'><p>Tukey Biweight Robust Survey Regression M- and GM-Estimator</p></a></li>
<li><a href='#svysummary'><p>Weighted Five-Number Summary of a Variable</p></a></li>
<li><a href='#weighted_IQR'><p>Weighted Interquartile Range (IQR)</p></a></li>
<li><a href='#weighted_line'><p>Weighted Robust Line Fitting</p></a></li>
<li><a href='#weighted_mad'><p>Weighted Median Absolute Deviation from the Median (MAD)</p></a></li>
<li><a href='#weighted_mean'><p>Weighted Total and Mean (Horvitz-Thompson and Hajek Estimators)</p></a></li>
<li><a href='#weighted_mean_dalen'><p>Dalen Estimators of the Mean and Total</p></a></li>
<li><a href='#weighted_mean_trimmed'><p>Weighted Trimmed Mean and Total (bare-bone functions)</p></a></li>
<li><a href='#weighted_mean_winsorized'><p>Weighted Winsorized Mean and Total (bare-bone functions)</p></a></li>
<li><a href='#weighted_median'><p>Weighted Median</p></a></li>
<li><a href='#weighted_median_line'><p>Robust Simple Linear Regression Based on Medians</p></a></li>
<li><a href='#weighted_median_ratio'><p>Weighted Robust Ratio Estimator Based on Median</p></a></li>
<li><a href='#weighted_quantile'><p>Weighted Quantile</p></a></li>
<li><a href='#weighted-m-estimator'><p>Weighted Huber and Tukey Mean and Total (bare-bone functions)</p></a></li>
<li><a href='#wgt_functions'><p>Weight Functions (for the M- and GM-Estimators)</p></a></li>
<li><a href='#workplace'><p>(Modified) Canadian Workplace and Employee Survey</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Survey Statistics Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Robust (outlier-resistant) estimators of finite population
    characteristics like of means, totals, ratios, regression, etc. Available
    methods are M- and GM-estimators of regression, weight reduction,
    trimming, and winsorization. The package extends the 'survey'
    <a href="https://CRAN.R-project.org/package=survey">https://CRAN.R-project.org/package=survey</a> package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Classification/MSC-2010:</td>
<td>62D05, 62F35</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tobiasschoch/robsurvey">https://github.com/tobiasschoch/robsurvey</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tobiasschoch/robsurvey/issues">https://github.com/tobiasschoch/robsurvey/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, KernSmooth, stats, survey (&ge; 3.35-1), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>hexbin, knitr, MASS, rmarkdown, wbacon</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-21 17:54:28 UTC; tobias</td>
</tr>
<tr>
<td>Author:</td>
<td>Beat Hulliger <a href="https://orcid.org/0000-0001-5252-8606"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Tobias Schoch <a href="https://orcid.org/0000-0002-1640-3395"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Martin Sterchi [ctr, com],
  R-core [ctb, cph] (for zeroin2.c)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Schoch &lt;tobias.schoch@fhnw.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-22 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='robsurvey-package'>Package Overview</h2><span id='topic+robsurvey-package'></span><span id='topic+robsurvey'></span>

<h3>Description</h3>

<p>A key <em>design pattern</em> of the package is that the majority
of the estimating methods is available in two &quot;flavors&quot;:
</p>

<ul>
<li><p> bare-bone methods
</p>
</li>
<li><p> survey methods
</p>
</li></ul>

<p>Bare-bone methods are stripped-down versions of the survey methods in
terms of functionality and informativeness. These functions may serve
users and package developers as building blocks. In particular,
bare-bone functions <em>cannot compute</em> variances.
</p>
<p>The survey methods are much more capable and depend, for variance
estimation, on the <span class="pkg">survey</span> package.
</p>


<h3>Basic Robust Estimators</h3>



<h4>Trimming</h4>


<ul>
<li><p> Bare-bone methods: <code><a href="#topic+weighted_mean_trimmed">weighted_mean_trimmed</a></code> and
<code><a href="#topic+weighted_total_trimmed">weighted_total_trimmed</a></code>
</p>
</li>
<li><p> Survey methods: <code><a href="#topic+svymean_trimmed">svymean_trimmed</a></code> and
<code><a href="#topic+svytotal_trimmed">svytotal_trimmed</a></code>
</p>
</li></ul>




<h4>Winsorization</h4>


<ul>
<li><p> Bare-bone methods:
</p>

<ul>
<li> <p><code><a href="#topic+weighted_mean_winsorized">weighted_mean_winsorized</a></code> and
<code><a href="#topic+weighted_total_winsorized">weighted_total_winsorized</a></code>
</p>
</li>
<li> <p><code><a href="#topic+weighted_mean_k_winsorized">weighted_mean_k_winsorized</a></code> and
<code><a href="#topic+weighted_total_k_winsorized">weighted_total_k_winsorized</a></code>
</p>
</li></ul>

</li>
<li><p> Survey methods:
</p>

<ul>
<li> <p><code><a href="#topic+svymean_winsorized">svymean_winsorized</a></code> and
<code><a href="#topic+svytotal_winsorized">svytotal_winsorized</a></code>
</p>
</li>
<li> <p><code><a href="#topic+svymean_k_winsorized">svymean_k_winsorized</a></code> and
<code><a href="#topic+svytotal_k_winsorized">svytotal_k_winsorized</a></code>
</p>
</li></ul>

</li></ul>




<h4>Dalen's estimators (weight reduction methods)</h4>


<ul>
<li><p> Bare-bone methods: <code><a href="#topic+weighted_mean_dalen">weighted_mean_dalen</a></code> and
<code><a href="#topic+weighted_total_dalen">weighted_total_dalen</a></code>
</p>
</li>
<li><p> Survey methods: <code><a href="#topic+svymean_dalen">svymean_dalen</a></code> and
<code><a href="#topic+svytotal_dalen">svytotal_dalen</a></code>
</p>
</li></ul>




<h4>M-estimators</h4>


<ul>
<li><p> Bare-bone methods:
</p>

<ul>
<li> <p><code><a href="#topic+weighted_mean_huber">weighted_mean_huber</a></code> and
<code><a href="#topic+weighted_total_huber">weighted_total_huber</a></code>
</p>
</li>
<li> <p><code><a href="#topic+weighted_mean_tukey">weighted_mean_tukey</a></code> and
<code><a href="#topic+weighted_total_tukey">weighted_total_tukey</a></code>
</p>
</li>
<li> <p><code><a href="#topic+huber2">huber2</a></code> (weighted Huber Proposal 2
estimator)
</p>
</li></ul>

</li>
<li><p> Survey methods:
</p>

<ul>
<li> <p><code><a href="#topic+svymean_huber">svymean_huber</a></code> and
<code><a href="#topic+svytotal_huber">svytotal_huber</a></code>
</p>
</li>
<li> <p><code><a href="#topic+svymean_tukey">svymean_tukey</a></code> and
<code><a href="#topic+svytotal_tukey">svytotal_tukey</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mer">mer</a></code> (minimum estimated risk estimator)
</p>
</li></ul>

</li></ul>




<h3>Survey Regression (weighted least squares)</h3>

<p><code><a href="#topic+svyreg">svyreg</a></code>
</p>


<h3>Robust Regression and Ratio Estimation (weighted)</h3>


<ul>
<li><p> Regression M-estimators: <code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code> and
<code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code>
</p>
</li>
<li><p> Regression GM-estimators (Mallows and Schweppe):
<code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code> and <code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code>
</p>
</li>
<li><p> Ratio M-estimators:
<code><a href="#topic+svyratio_huber">svyratio_huber</a></code> and <code><a href="#topic+svyratio_tukey">svyratio_tukey</a></code>
</p>
</li></ul>

<p>Note: The functions <code><a href="#topic+svyreg_huber">svyreg_huber</a></code> and
<code><a href="#topic+svyreg_tukey">svyreg_tukey</a></code> are deprecated, use instead
<code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code> and <code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code>, respectively;
see also <a href="#topic+robsurvey-deprecated">robsurvey-deprecated</a>.
</p>


<h3>Robust Generalized Regression (GREG) and Ratio Prediction of the
Population Mean and Total</h3>


<ul>
<li><p> Regression predictors: <code><a href="#topic+svymean_reg">svymean_reg</a></code> and
<code><a href="#topic+svytotal_reg">svytotal_reg</a></code>
</p>
</li>
<li><p> Ratio predictors: <code><a href="#topic+svymean_ratio">svymean_ratio</a></code> and
<code><a href="#topic+svytotal_ratio">svytotal_ratio</a></code>
</p>
</li></ul>



<h3>Utility functions</h3>


<ul>
<li> <p><code><a href="#topic+weighted_quantile">weighted_quantile</a></code> and <code><a href="#topic+weighted_median">weighted_median</a></code>
</p>
</li>
<li> <p><code><a href="#topic+weighted_mad">weighted_mad</a></code> and <code><a href="#topic+weighted_IQR">weighted_IQR</a></code>
</p>
</li>
<li> <p><code><a href="#topic+weighted_mean">weighted_mean</a></code> and <code><a href="#topic+weighted_total">weighted_total</a></code>
</p>
</li>
<li> <p><code><a href="#topic+weighted_line">weighted_line</a></code>, <code><a href="#topic+weighted_median_line">weighted_median_line</a></code>,
and <code><a href="#topic+weighted_median_ratio">weighted_median_ratio</a></code>
</p>
</li></ul>


<hr>
<h2 id='class_svyreg_rob'>Utility Functions for Objects of Class svyreg_rob</h2><span id='topic+class_svyreg_rob'></span><span id='topic+svyreg_rob'></span><span id='topic+print.svyreg_rob'></span><span id='topic+summary.svyreg_rob'></span><span id='topic+coef.svyreg_rob'></span><span id='topic+vcov.svyreg_rob'></span><span id='topic+SE.svyreg_rob'></span><span id='topic+residuals.svyreg_rob'></span><span id='topic+fitted.svyreg_rob'></span><span id='topic+robweights.svyreg_rob'></span><span id='topic+plot.svyreg_rob'></span>

<h3>Description</h3>

<p>Methods and utility functions for objects of class <code>svyreg_rob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svyreg_rob'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'svyreg_rob'
summary(object, mode = c("design", "model", "compound"),
        digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'svyreg_rob'
coef(object, ...)

## S3 method for class 'svyreg_rob'
vcov(object, mode = c("design", "model", "compound"), ...)

## S3 method for class 'svyreg_rob'
SE(object, mode = c("design", "model", "compound"), ...)

## S3 method for class 'svyreg_rob'
residuals(object, ...)

## S3 method for class 'svyreg_rob'
fitted(object, ...)

## S3 method for class 'svyreg_rob'
robweights(object)

## S3 method for class 'svyreg_rob'
plot(x, which = 1L:4L,
     hex = FALSE, caption = c("Standardized residuals vs. Fitted Values",
     "Normal Q-Q", "Response vs. Fitted values",
     "Sqrt of abs(Residuals) vs. Fitted Values"),
	 panel = if (add.smooth) function(x, y, ...) panel.smooth(x, y,
     iter = iter.smooth, ...) else points, sub.caption = NULL, main = "",
	 ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), ...,
	 id.n = 3, labels.id = names(residuals(x)), cex.id = 0.75, qqline = TRUE,
	 add.smooth = getOption("add.smooth"), iter.smooth = 3,
	 label.pos = c(4, 2), cex.caption = 1, cex.oma.main = 1.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="class_svyreg_rob_+3A_x">x</code></td>
<td>
<p>object of class <code>svyreg_rob</code>.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_digits">digits</code></td>
<td>
<p><code>[integer]</code> minimal number of significant digits.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_object">object</code></td>
<td>
<p>object of class <code>svyreg_rob</code>.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_mode">mode</code></td>
<td>
<p><code>[character]</code> mode of variance estimator:
<code>"design"</code>, <code>"model"</code> or <code>"compound"</code> (default:
<code>"design"</code>).</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_which">which</code></td>
<td>
<p><code>[integer]</code> indicating which plots to be drawn; if
a subset of the plots is required, you can specify a subset of the
numbers <code>1:4</code>.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_hex">hex</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, a hexagonally binned plot
is shown in place of a scatterplot.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_caption">caption</code></td>
<td>
<p><code>[character]</code> captions to appear above the plots;
vector of valid graphics annotations. It can be set to <code>""</code>
or <code>NA</code> to suppress all captions.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_panel">panel</code></td>
<td>
<p>panel function. The useful alternative to
<code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+panel.smooth">panel.smooth</a></code> can be chosen
by <code>add.smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_sub.caption">sub.caption</code></td>
<td>
<p><code>[character]</code> common title&mdash;above the figures
if there are more than one; used as <code>sub</code> (s.<code><a href="graphics.html#topic+title">title</a></code>)
otherwise. If <code>NULL</code>, as by default, a possible abbreviated
version of <code>deparse(x$call)</code> is used.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_main">main</code></td>
<td>
<p><code>[character]</code> title to each plot&mdash;in addition
to <code>caption</code>.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_ask">ask</code></td>
<td>
<p><code>[logical]</code>; if <code>TRUE</code>, the user is <em>ask</em>ed
before each plot, see <code><a href="graphics.html#topic+par">par</a>(ask=.)</code>.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_id.n">id.n</code></td>
<td>
<p><code>[integer]</code> number of points to be labelled in each plot,
starting with the most extreme.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_labels.id">labels.id</code></td>
<td>
<p><code>[character]</code> vector of labels from which the
labels for extreme points will be chosen. <code>NULL</code> uses
observation numbers.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_cex.id">cex.id</code></td>
<td>
<p><code>[numeric]</code> magnification of point labels.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_qqline">qqline</code></td>
<td>
<p><code>[logical]</code> indicating if a <code><a href="stats.html#topic+qqline">qqline</a></code>
should be added to the normal Q-Q plot.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_add.smooth">add.smooth</code></td>
<td>
<p><code>[logical]</code> indicating if a smoother should be
added to most plots; see also <code>panel</code> above.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_iter.smooth">iter.smooth</code></td>
<td>
<p><code>[integer]</code> the number of robustness iterations,
the argument <code>iter</code> in <code><a href="graphics.html#topic+panel.smooth">panel.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_label.pos">label.pos</code></td>
<td>
<p><code>[numeric]</code> positioning of labels, for the left
half and right half of the graph respectively.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_cex.caption">cex.caption</code></td>
<td>
<p><code>[numeric]</code> controls the size of <code>caption</code>.</p>
</td></tr>
<tr><td><code id="class_svyreg_rob_+3A_cex.oma.main">cex.oma.main</code></td>
<td>
<p><code>[numeric]</code> controls the size of the
<code>sub.caption</code> only if that is <em>above</em> the figures when
there is more than one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>

<dl>
<dt>Variance</dt><dd>
<p>For variance estimation (<code>summary</code>, <code>vcov</code>, and
<code>SE</code>) three modes are available:
</p>

<ul>
<li> <p><code>"design"</code>: design-based variance estimator using
linearization; see Binder (1983)
</p>
</li>
<li> <p><code>"model"</code>: model-based weighted variance estimator
(the sampling design is ignored)
</p>
</li>
<li> <p><code>"compound"</code>: design-model-based variance
estimator; see Rubin-Bleuer and Schiopu-Kratina (2005)
and Binder and Roberts (2009)
</p>
</li></ul>

</dd>
<dt>Utility functions</dt><dd>
<p>The following utility functions are available:
</p>

<ul>
<li> <p><code>summary</code> gives a summary of the estimation
properties
</p>
</li>
<li> <p><code>plot</code> shows diagnostic plots for the estimated
regression model
</p>
</li>
<li> <p><code>robweights</code> extracts the robustness weights
(if available)
</p>
</li>
<li> <p><code>coef</code> extracts the estimated regression coefficients
</p>
</li>
<li> <p><code>vcov</code> extracts the (estimated) covariance matrix
</p>
</li>
<li> <p><code>residuals</code> extracts the residuals
</p>
</li>
<li> <p><code>fitted</code> extracts the fitted values
</p>
</li></ul>

</dd>
</dl>



<h3>References</h3>

<p>Binder, D. A. (1983). On the Variances of Asymptotically Normal Estimators
from Complex Surveys. <em>International Statistical Review</em> <b>51</b>,
279&ndash;292. <a href="https://doi.org/10.2307/1402588">doi:10.2307/1402588</a>
</p>
<p>Binder, D. A. and Roberts, G. (2009). Design- and Model-Based Inference for
Model Parameters. In: <em>Sample Surveys: Inference and Analysis</em>
ed. by Pfeffermann, D. and Rao, C. R. Volume 29B of
<em>Handbook of Statistics</em>, Amsterdam: Elsevier, Chap. 24, 33&ndash;54
<a href="https://doi.org/10.1016/S0169-7161%2809%2900224-7">doi:10.1016/S0169-7161(09)00224-7</a>
</p>
<p>Rubin-Bleuer, S. and Schiopu-Kratina, I. (2005). On the Two-phase
framework for joint model and design-based inference.
<em>The Annals of Statistics</em> <b>33</b>, 2789&ndash;2810.
<a href="https://doi.org/10.1214/009053605000000651">doi:10.1214/009053605000000651</a>
</p>


<h3>See Also</h3>

<p>Weighted least squares: <code><a href="#topic+svyreg">svyreg</a></code>; robust weighted regression
<code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>, <code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code>,
<code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code> and <code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Compute regression M-estimate with Huber psi-function
m &lt;- svyreg_huberM(payroll ~ employment, dn, k = 14)

# Diagnostic plots (e.g., standardized residuals against fitted values)
plot(m, which = 1L)

# Plot of the robustness weights of the M-estimate against its residuals
plot(residuals(m), robweights(m))

# Utility functions
summary(m)
coef(m)
SE(m)
vcov(m)
residuals(m)
fitted(m)
robweights(m)
</code></pre>

<hr>
<h2 id='class_svystat_rob'>Utility Functions for Objects of Class svystat_rob</h2><span id='topic+class_svystat_rob'></span><span id='topic+svystat_rob'></span><span id='topic+summary.svystat_rob'></span><span id='topic+coef.svystat_rob'></span><span id='topic+SE.svystat_rob'></span><span id='topic+vcov.svystat_rob'></span><span id='topic+residuals.svystat_rob'></span><span id='topic+fitted.svystat_rob'></span><span id='topic+robweights'></span><span id='topic+robweights.svystat_rob'></span><span id='topic+print.svystat_rob'></span><span id='topic+scale.svystat_rob'></span><span id='topic+mse'></span><span id='topic+mse.svystat_rob'></span><span id='topic+mse.svystat'></span>

<h3>Description</h3>

<p>Methods and utility functions for objects of class <code>svystat_rob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(object, ...)
## S3 method for class 'svystat_rob'
mse(object, ...)
## S3 method for class 'svystat'
mse(object, ...)
## S3 method for class 'svystat_rob'
summary(object, digits = max(3L,
        getOption("digits") - 3L), ...)
## S3 method for class 'svystat_rob'
coef(object, ...)
## S3 method for class 'svystat_rob'
SE(object, ...)
## S3 method for class 'svystat_rob'
vcov(object, ...)
## S3 method for class 'svystat_rob'
scale(x, ...)
## S3 method for class 'svystat_rob'
residuals(object, ...)
## S3 method for class 'svystat_rob'
fitted(object, ...)
robweights(object)
## S3 method for class 'svystat_rob'
robweights(object)
## S3 method for class 'svystat_rob'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="class_svystat_rob_+3A_object">object</code></td>
<td>
<p>object of class <code>svystat_rob</code>.</p>
</td></tr>
<tr><td><code id="class_svystat_rob_+3A_digits">digits</code></td>
<td>
<p><code>[integer]</code> minimal number of significant digits.</p>
</td></tr>
<tr><td><code id="class_svystat_rob_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method.</p>
</td></tr>
<tr><td><code id="class_svystat_rob_+3A_x">x</code></td>
<td>
<p>object of class <code>svystat_rob</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>
<p>Utility functions:
</p>

<ul>
<li> <p><code>mse</code> computes the estimated risk (mean square
error) in presence of representative outliers; see also
<code><a href="#topic+mer">mer</a></code>
</p>
</li>
<li> <p><code>summary</code> gives a summary of the estimation properties
</p>
</li>
<li> <p><code>robweights</code> extracts the robustness weights
</p>
</li>
<li> <p><code>coef</code> extracts the estimate of location
</p>
</li>
<li> <p><code>SE</code> extracts the (estimated) standard error
</p>
</li>
<li> <p><code>vcov</code> extracts the (estimated) covariance matrix
</p>
</li>
<li> <p><code>residuals</code> extracts the residuals
</p>
</li>
<li> <p><code>fitted</code> extracts the fitted values
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+svymean_dalen">svymean_dalen</a></code>, <code><a href="#topic+svymean_huber">svymean_huber</a></code>,
<code><a href="#topic+svymean_ratio">svymean_ratio</a></code>, <code><a href="#topic+svymean_reg">svymean_reg</a></code>,
<code><a href="#topic+svymean_tukey">svymean_tukey</a></code>, <code><a href="#topic+svymean_trimmed">svymean_trimmed</a></code>,
<code><a href="#topic+svymean_winsorized">svymean_winsorized</a></code>
</p>
<p><code><a href="#topic+svytotal_dalen">svytotal_dalen</a></code>, <code><a href="#topic+svytotal_huber">svytotal_huber</a></code>,
<code><a href="#topic+svytotal_ratio">svytotal_ratio</a></code>, <code><a href="#topic+svytotal_reg">svytotal_reg</a></code>,
<code><a href="#topic+svytotal_tukey">svytotal_tukey</a></code>, <code><a href="#topic+svytotal_trimmed">svytotal_trimmed</a></code>,
<code><a href="#topic+svytotal_winsorized">svytotal_winsorized</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Estimated one-sided k winsorized population total (i.e., k = 2 observations
# are winsorized at the top of the distribution)
wtot &lt;- svytotal_k_winsorized(~employment, dn, k = 2)

# Show summary statistic of the estimated total
summary(wtot)

# Estimated mean square error (MSE)
mse(wtot)

# Estimate, std. err., variance, and the residuals
coef(wtot)
SE(wtot)
vcov(wtot)
residuals(wtot)

# M-estimate of the total (Huber psi-function; tuning constant k = 3)
mtot &lt;- svytotal_huber(~employment, dn, k = 45)

# Plot of the robustness weights of the M-estimate against its residuals
plot(residuals(mtot), robweights(mtot))
</code></pre>

<hr>
<h2 id='counties'>Data on a Simple Random Sample of 100 Counties in the U.S.</h2><span id='topic+counties'></span>

<h3>Description</h3>

<p>Data from a simple random sample (without replacement) of 100 of the 3141
counties in the United Stated (U.S. Bureau of the Census, 1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(counties)</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 100 observations on the following variables:
</p>

<dl>
<dt><code>state</code></dt><dd><p>state, <code>[character]</code>.</p>
</dd>
<dt><code>county</code></dt><dd><p>county, <code>[character]</code>.</p>
</dd>
<dt><code>landarea</code></dt><dd><p>land area, 1990 (square miles),
<code>[double]</code>.</p>
</dd>
<dt><code>totpop</code></dt><dd><p>population total, 1992, <code>[double]</code>.</p>
</dd>
<dt><code>unemp</code></dt><dd><p>number of unemployed persons, 1991,
<code>[double]</code>.</p>
</dd>
<dt><code>farmpop</code></dt><dd><p>farm population, 1990, <code>[double]</code>.</p>
</dd>
<dt><code>numfarm</code></dt><dd><p>number of farms, 1987, <code>[double]</code>.</p>
</dd>
<dt><code>farmacre</code></dt><dd><p>acreage in farms, 1987, <code>[double]</code>.</p>
</dd>
<dt><code>weights</code></dt><dd><p>sampling weight, <code>[double]</code>.</p>
</dd>
<dt><code>fpc</code></dt><dd><p>finite population corretion, <code>[double]</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data (and 10 additional variables) are published in Lohr (1999,
Appendix C).
</p>


<h3>Source</h3>

<p>Lohr, S. L. (1999). <em>Sampling: Design and Analysis</em>,
Pacific Grove (CA): Duxbury Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(counties)

library(survey)
# Survey design for simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~1, fpc = ~fpc, weights = ~weights, data = counties,
                  calibrate.formula = ~1)
    } else {
        # legacy mode
        svydesign(ids = ~1, fpc = ~fpc, weights = ~weights, data = counties)
    }
</code></pre>

<hr>
<h2 id='flour'>Measurement of Copper Content in Wholemeal Flour</h2><span id='topic+flour'></span>

<h3>Description</h3>

<p>Measurement of copper content in wholemeal flour (measured in parts per
million).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flour)</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 24 observations (sorted in ascending order)
on the following variables:
</p>

<dl>
<dt><code>copper</code></dt><dd><p>copper content <code>[double]</code>.</p>
</dd>
<dt><code>weight</code></dt><dd><p>weight <code>[double]</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data are published in Maronna et al. (2019, p. 2).
</p>


<h3>Source</h3>

<p>Maronna, R. A., Martin, R. D., Yohai, V. J. and Salibián-Barrera, M.
(2019). <em>Robust Statistics: Theory and Methods (with R)</em>,
Hoboken (NJ): John Wiley and Sons, 2nd edition.
<a href="https://doi.org/10.1002/9781119214656">doi:10.1002/9781119214656</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(flour)
</code></pre>

<hr>
<h2 id='huber2'>Weighted Huber Proposal 2 Estimator</h2><span id='topic+huber2'></span>

<h3>Description</h3>

<p>Weighted Huber Proposal 2 estimator of location and scatter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huber2(x, w, k = 1.5, na.rm = FALSE, maxit = 50, tol = 1e-04, info = FALSE,
       k_Inf = 1e6, df_cor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="huber2_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="huber2_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="huber2_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="huber2_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="huber2_+3A_maxit">maxit</code></td>
<td>
<p><code>[integer]</code> maximum number of iterations to use
(default: <code>50</code>).</p>
</td></tr>
<tr><td><code id="huber2_+3A_tol">tol</code></td>
<td>
<p><code>[double]</code> numerical tolerance criterion to stop the
iterations (default: <code>1e-04</code>).</p>
</td></tr>
<tr><td><code id="huber2_+3A_info">info</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
should be returned (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="huber2_+3A_k_inf">k_Inf</code></td>
<td>
<p><code>[integer]</code> numerical value that represents <code>Inf</code>
(default: <code>1e+06</code>).</p>
</td></tr>
<tr><td><code id="huber2_+3A_df_cor">df_cor</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, the degrees of freedom of
the estimate of scale is adjusted (default: <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>huber2</code> computes the weighted Huber (1964) Proposal 2
estimates of location and scale.
</p>
<p>The method is initialized by the weighted median (location) and the
weighted interquartile range (scale).
</p>


<h3>Value</h3>

<p>The return value depends on <code>info</code>: </p>

<dl>
<dt><code>info = FALSE</code>:</dt><dd><p>estimate of mean or total <code>[double]</code></p>
</dd>
<dt><code>info = TRUE</code>:</dt><dd><p>a <code>[list]</code> with items:
</p>

<ul>
<li> <p><code>characteristic</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimator</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimate</code> <code>[double]</code>,
</p>
</li>
<li> <p><code>variance</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>robust</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>residuals</code> <code>[numeric vector]</code>,
</p>
</li>
<li> <p><code>model</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>design</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>[call]</code>
</p>
</li></ul>

</dd>
</dl>



<h3>Comparison</h3>

<p>The <code>huber2</code> estimator is initialized by the weighted median and
the weighted (scaled) interquartile range. For unweighted data, this
estimator <em>differs</em> from <code><a href="MASS.html#topic+hubers">hubers</a></code> in <span class="pkg">MASS</span>,
which is initialized by <code><a href="stats.html#topic+mad">mad</a></code>.
</p>
<p>The difference between the estimators is usually negligible (for
sufficiently small values of <code>tol</code>). See examples.
</p>


<h3>References</h3>

<p>Huber, P. J. (1964). Robust Estimation of a Location Parameter.
<em>Annals of Mathematical Statistics</em> <b>35</b>, 73&ndash;101.
<a href="https://doi.org/10.1214/aoms/1177703732">doi:10.1214/aoms/1177703732</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# Weighted "Proposal 2" estimator of the mean
huber2(workplace$employment, workplace$weight, k = 8)

# More information on the estimate, i.e., info = TRUE
m &lt;- huber2(workplace$employment, workplace$weight, k = 8, info = TRUE)

# Estimate of scale
m$scale

# Comparison with MASS::hubers (without weights). We make a copy of MASS::hubers
library(MASS)
hubers_mod &lt;- hubers

# Then we replace mad by the (scaled) IQR as initial scale estimator
body(hubers_mod)[[7]][[3]][[2]] &lt;- substitute(s0 &lt;- IQR(y, type = 2) * 0.7413)

# Define the numerical tolerance
TOLERANCE &lt;- 1e-8

# Comparison
m1 &lt;- huber2(workplace$payroll, rep(1, 142), tol = TOLERANCE)
m2 &lt;- hubers_mod(workplace$payroll, tol = TOLERANCE)$mu
m1 / m2 - 1

# The absolute relative difference is &lt; 4.0-09 (smaller than TOLERANCE)
</code></pre>

<hr>
<h2 id='losdata'>Length-of-Stay (LOS) Hospital Data</h2><span id='topic+losdata'></span>

<h3>Description</h3>

<p>A simple random sample of 70 patients in inpatient hospital treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(losdata)</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with data on the following variables:
</p>

<dl>
<dt><code>los</code></dt><dd><p>length of stay (days) <code>[integer]</code>.</p>
</dd>
<dt><code>weight</code></dt><dd><p>sampling weight <code>[double]</code>.</p>
</dd>
<dt><code>fpc</code></dt><dd><p>finite population correction <code>[double]</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The <code>losdata</code> are a simple random sample without replacement (SRSWOR)
of size <code class="reqn">n = 70</code> patients from the (fictive) population of
<code class="reqn">N = 2479</code> patients in inpatient hospital treatment. We have
constructed the <code>losdata</code> as a showcase; though, the LOS
measurements are real data that we have taken from the 201 observations
in Ruffieux et al.  (2000). The original LOS data of Ruffieux et al.
(2000) are available in the R package <span class="pkg">robustbase</span>; see
<code>robustbase::data(los)</code>.  Our <code>losdata</code> are a SRSWOR of
size <code class="reqn">n = 70</code> from the 201 original observations.
</p>
<p>Ruffieux et al. (2000) and data.frame <code>los</code> in the R
package <span class="pkg">robustbase</span>.
</p>


<h3>Source</h3>

<p>Ruffieux, C., Paccaud, F. and Marazzi, A. (2000). Comparing rules for
truncating hospital length of stay. <em>Casemix Quarterly</em> <b>2</b>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(losdata)

library(survey)
# Survey design for simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~1, fpc = ~fpc, weights = ~weight, data = losdata,
                  calibrate.formula = ~1)
    } else {
        # legacy mode
        svydesign(ids = ~1, fpc = ~fpc, weights = ~weight, data = losdata)
    }
</code></pre>

<hr>
<h2 id='mer'>Minimum Estimated Risk (MER) M-Estimator</h2><span id='topic+mer'></span>

<h3>Description</h3>

<p><code>mer</code> is an adaptive M-estimator of the weighted mean or total. It
is defined as the estimator that minimizes the estimated mean square error,
<code><a href="#topic+mse">mse</a></code>, of the estimator under consideration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mer(object, verbose = TRUE, max_k = 10, init = 1, method = "Brent",
    optim_args = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mer_+3A_object">object</code></td>
<td>
<p>an object of class <code>svystat_rob</code>.</p>
</td></tr>
<tr><td><code id="mer_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional
information is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="mer_+3A_init">init</code></td>
<td>
<p><code>[numeric]</code> determines the left boundary value of the
search interval and the initial value of the search; we must have
<code>init &lt; max_k</code>.</p>
</td></tr>
<tr><td><code id="mer_+3A_method">method</code></td>
<td>
<p><code>[character]</code> the method of <code><a href="stats.html#topic+optim">optim</a></code> to
be used.</p>
</td></tr>
<tr><td><code id="mer_+3A_max_k">max_k</code></td>
<td>
<p><code>[numeric vector]</code> defines the right boundary value of
the search interval (default: <code>max_k = 1000</code>)</p>
</td></tr>
<tr><td><code id="mer_+3A_optim_args">optim_args</code></td>
<td>
<p><code>[list]</code>: arguments passed on to
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>
<p>MER-estimators are available for the methods <code><a href="#topic+svymean_huber">svymean_huber</a></code>,
<code><a href="#topic+svytotal_huber">svytotal_huber</a></code>, <code><a href="#topic+svymean_tukey">svymean_tukey</a></code> and
<code><a href="#topic+svytotal_tukey">svytotal_tukey</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>
</p>


<h3>References</h3>

<p>Hulliger, B. (1995). Outlier Robust Horvitz-Thompson Estimators.
<em>Survey Methodology</em> <b>21</b>, 79&ndash;87.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(losdata)

library(survey)
# Survey design for simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~1, fpc = ~fpc, weights = ~weight, data = losdata,
                  calibrate.formula = ~1)
    } else {
        # legacy mode
        svydesign(ids = ~1, fpc = ~fpc, weights = ~weight, data = losdata)
    }

# M-estimator of the total with tuning constant k = 8
m &lt;- svymean_huber(~los, dn, type = "rhj", k = 8)

# MER estimator
mer(m)
</code></pre>

<hr>
<h2 id='MU284pps'>PPS Sample From the MU284 Population</h2><span id='topic+MU284pps'></span>

<h3>Description</h3>

<p>Probability-proportional-to-size sample (PPS) without replacement of
municipalities from the MU284 population in Särndal et al. (1992).
The sample inclusion probabilities are proportional to the
population size in 1975 (variable P75).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MU284pps)</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 60 observations on the following variables:
</p>

<dl>
<dt><code>LABEL</code></dt><dd><p>identifier variable, <code>[integer]</code>.</p>
</dd>
<dt><code>P85</code></dt><dd><p>1985 population size (in thousands),
<code>[double]</code>.</p>
</dd>
<dt><code>P75</code></dt><dd><p>1975 population size (in thousands),
<code>[double]</code>.</p>
</dd>
<dt><code>RMT85</code></dt><dd><p>Revenues from the 1985 municipal taxation
(in millions of kronor), <code>[double]</code>.</p>
</dd>
<dt><code>CS82</code></dt><dd><p>number of Conservative seats in municipal council,
<code>[double]</code>.</p>
</dd>
<dt><code>SS82</code></dt><dd><p>number of Social-Democrat seats in municipal
council (1982), <code>[double]</code>.</p>
</dd>
<dt><code>S82</code></dt><dd><p>total number of seats in municipal council (1982),
<code>[double]</code>.</p>
</dd>
<dt><code>ME84</code></dt><dd><p>number of municipal employees in 1984,
<code>[double]</code>.</p>
</dd>
<dt><code>REV84</code></dt><dd><p>real estate values according to 1984 assessment
(in millions of kronor), <code>[double]</code>.</p>
</dd>
<dt><code>REG</code></dt><dd><p>geographic region indicator, <code>[integer]</code>.</p>
</dd>
<dt><code>CL</code></dt><dd><p>cluster indicator (a cluster consists of a set of
neighbouring municipalities), <code>[integer]</code>.</p>
</dd>
<dt><code>weights</code></dt><dd><p>sampling weights, <code>[double]</code>.</p>
</dd>
<dt><code>pi</code></dt><dd><p>sample inclusion probability, <code>[double]</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The MU284 population of Särndal et al. (1992, Appendix B) is a
dataset with observations on the 284 municipalities in Sweden in the
late 1970s and early 1980s. The <code>MU284</code> <em>population</em> data
are available in the <span class="pkg">sampling</span> package of Tillé and Matei (2021).
</p>
<p>The data frame <code>MU284pps</code> is a probability-proportional-to-size
sample (PPS) without replacement from the MU284 population.
The sample inclusion probabilities are proportional to the
population size in 1975 (variable P75). The sample has been
selected by Brewer’s method; see Tillé (2006, Chap. 7).
The sampling weight (inclusion probabilities) are calibrated to
the population size and the population total of P75.
</p>


<h3>Source</h3>

<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, New York: Springer-Verlag.
</p>
<p>Tillé, Y. and Matei, A. (2021). <em>sampling: Survey Sampling</em>.
R package version 2.9. <a href="https://CRAN.R-project.org/package=sampling">https://CRAN.R-project.org/package=sampling</a>
</p>
<p>Tillé, Y. (2006). <em>Sampling Algorithms</em>. New York: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MU284strat">MU284strat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(MU284pps)

library(survey)
# Survey design with inclusion probabilities proportional to size
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~LABEL, fpc = ~pi, data = MU284pps, pps = "brewer",
                  calibrate.formula = ~1)
    } else {
        # legacy mode
        svydesign(ids = ~LABEL, fpc = ~pi, data = MU284pps, pps = "brewer")
    }
</code></pre>

<hr>
<h2 id='MU284strat'>Stratified Sample from the MU284 Population</h2><span id='topic+MU284strat'></span>

<h3>Description</h3>

<p>Stratified simple random sample (without replacement) of municipalities
from the MU284 population in Särndal et al. (1992). Stratification is by
geographic region and a take-all stratum (by 1975 population size), which
includes the big cities Stockholm, Göteborg, and Malmö.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MU284strat)</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 60 observations on the following variables:
</p>

<dl>
<dt><code>LABEL</code></dt><dd><p>identifier variable, <code>[integer]</code>.</p>
</dd>
<dt><code>P85</code></dt><dd><p>1985 population size (in thousands),
<code>[double]</code>.</p>
</dd>
<dt><code>P75</code></dt><dd><p>1975 population size (in thousands),
<code>[double]</code>.</p>
</dd>
<dt><code>RMT85</code></dt><dd><p>Revenues from the 1985 municipal taxation
(in millions of kronor), <code>[double]</code>.</p>
</dd>
<dt><code>CS82</code></dt><dd><p>number of Conservative seats in municipal council,
<code>[double]</code>.</p>
</dd>
<dt><code>SS82</code></dt><dd><p>number of Social-Democrat seats in municipal
council (1982), <code>[double]</code>.</p>
</dd>
<dt><code>S82</code></dt><dd><p>total number of seats in municipal council (1982),
<code>[double]</code>.</p>
</dd>
<dt><code>ME84</code></dt><dd><p>number of municipal employees in 1984,
<code>[double]</code>.</p>
</dd>
<dt><code>REV84</code></dt><dd><p>real estate values according to 1984 assessment
(in millions of kronor), <code>[double]</code>.</p>
</dd>
<dt><code>CL</code></dt><dd><p>cluster indicator (a cluster consists of a set of
neighbouring municipalities), <code>[integer]</code>.</p>
</dd>
<dt><code>REG</code></dt><dd><p>geographic region indicator, <code>[integer]</code>.</p>
</dd>
<dt><code>Stratum</code></dt><dd><p>stratum indicator, <code>[integer]</code>.</p>
</dd>
<dt><code>weights</code></dt><dd><p>sampling weights, <code>[double]</code>.</p>
</dd>
<dt><code>fpc</code></dt><dd><p>finite population correction, <code>[double]</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The MU284 population of Särndal et al. (1992, Appendix B) is a
dataset with observations on the 284 municipalities in Sweden in the
late 1970s and early 1980s. The <code>MU284</code> <em>population</em> data
are available in the <span class="pkg">sampling</span> package of Tillé and Matei (2021).
</p>
<p>The population is divided into two parts based on 1975 population
size (<code>P75</code>):
</p>

<ul>
<li><p> the MU281 population, which consists of the 281 smallest
municipalities;
</p>
</li>
<li><p> the MU3 population of the three biggest municipalities/
cities in Sweden (Stockholm, Göteborg, and Malmö).
</p>
</li></ul>

<p>The three biggest cities take exceedingly large values (representative
outliers) on almost all of the variables. To account for this, a stratified
sample has been drawn from the MU284 population using a take-all stratum.
The sample data, <code>MU284strat</code>, (of size <code class="reqn">n=60</code>) consists of
</p>

<ul>
<li><p> a stratified simple random sample (without replacement)
from the MU281 population, where stratification is by
geographic region (<code>REG</code>) with proportional sample
size allocation;
</p>
</li>
<li><p> a take-all stratum that includes the three biggest
cities/ municipalities (population M3).
</p>
</li></ul>



<h3>Source</h3>

<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, New York: Springer-Verlag.
</p>
<p>Tillé, Y. and Matei, A. (2021). <em>sampling: Survey Sampling</em>.
R package version 2.9. <a href="https://CRAN.R-project.org/package=sampling">https://CRAN.R-project.org/package=sampling</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MU284pps">MU284pps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(MU284strat)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~LABEL, strata = ~Stratum, fpc = ~fpc,
                  weights = ~weights, data = MU284strat,
                  calibrate.formula = ~-1 + Stratum)
    } else {
        # legacy mode
        svydesign(ids = ~LABEL, strata = ~Stratum, fpc = ~fpc,
                  weights = ~weights, data = MU284strat)
    }
</code></pre>

<hr>
<h2 id='pps'>Sampling with probability proportional to size (pps without replacement)</h2><span id='topic+pps_draw'></span><span id='topic+pps_probabilities'></span><span id='topic+print.prob_pps'></span>

<h3>Description</h3>

<p>Methods to compute the first-order sample inclusion probabilities (given
a measure of size) and sampling mechanisms to draw samples with
probabilities proportional to size (pps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pps_probabilities(size, n)
pps_draw(x, method = "brewer", sort = TRUE)

## S3 method for class 'prob_pps'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pps_+3A_size">size</code></td>
<td>
<p><code>[numeric vector]</code> measure of size.</p>
</td></tr>
<tr><td><code id="pps_+3A_n">n</code></td>
<td>
<p><code>[integer]</code> sample size.</p>
</td></tr>
<tr><td><code id="pps_+3A_x">x</code></td>
<td>
<p>object of class <code>prob_pps</code>.</p>
</td></tr>
<tr><td><code id="pps_+3A_method">method</code></td>
<td>
<p><code>[character]</code> currently only method <code>"brewer"</code>
is implemented.</p>
</td></tr>
<tr><td><code id="pps_+3A_sort">sort</code></td>
<td>
<p><code>[logical]</code> indicating whether the sampled indices
are sorted in ascending order (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="pps_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>pps_probabilities</code> computes the first-order sample inclusion
probabilities for a given sample size <code>n</code>; see e.g., Särndal et
al., 1992 (p. 90). The probabilities (and additional attributes) are
returned as a vector, more precisely as an object of class <code>prob_pps</code>.
</p>
<p>For an object of class <code>prob_pps</code> (inclusion probabilities and
additional attributes), function <code>pps_draw</code> draws a pps sample
without replacement and returns the indexes of the population elements.
Only the method of Brewer (1963, 1975) is currently implemented.
</p>


<h3>Value</h3>

<p>Function <code>pps_probabilities</code> returns the probabilities (an object
of class (<code>prob_pps</code>).
</p>
<p>Function <code>pps_draw</code> returns a pps sample of indexes from the
population elements.
</p>


<h3>References</h3>

<p>Brewer, K. W. R. (1963). A Model of Systematic Sampling with Unequal
Probabilities. <em>Australian Journal of Statistics</em> <b>5</b>, 93&ndash;105.
<a href="https://doi.org/10.1111/j.1467-842X.1963.tb00132.x">doi:10.1111/j.1467-842X.1963.tb00132.x</a>
</p>
<p>Brewer, K. W. R. (1975). A simple procedure for <code class="reqn">\pi</code>pswor,
<em>Australian Journal of Statistics</em> <b>17</b>, 166&ndash;172.
<a href="https://doi.org/10.1111/j.1467-842X.1975.tb00954.x">doi:10.1111/j.1467-842X.1975.tb00954.x</a>
</p>
<p>Särndal, C.-E., Swensson, B., Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, New York: Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We are going to pretend that the workplace sample is our population.
head(workplace)

# The population size is N = 142. We want to draw a pps sample (without
# replacement) of size n = 10, where the variable employment is the measure of
# size. The first-order sample inclusion probabilities are calculated as
# follows

p &lt;- pps_probabilities(workplace$employment, n = 10)

# Now, we draw a pps sample using Brewer's method.
pps_draw(p, method = "brewer")
</code></pre>

<hr>
<h2 id='robsurvey-deprecated'>Deprecated Functions in Package 'robsurvey'</h2><span id='topic+robsurvey-deprecated'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions
of the package only, and may be defunct as soon as the next release.
</p>

<ul>
<li> <p><code><a href="#topic+svyreg_huber">svyreg_huber</a></code>
</p>
</li>
<li> <p><code><a href="#topic+svyreg_tukey">svyreg_tukey</a></code>
</p>
</li></ul>

<p>Use instead:
</p>

<ul>
<li> <p><code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>
</p>
</li>
<li> <p><code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">robsurvey-package</a>
</p>

<hr>
<h2 id='robsvyreg'>Internal Function for the Regression GM-Estimator</h2><span id='topic+robsvyreg'></span><span id='topic+svyreg_control'></span>

<h3>Description</h3>

<p><strong>Internal</strong> function to call the robust survey regression
<em>GM</em>-estimator; this function is <strong>only</strong> intended for internal
use.  The function does <strong>not</strong> check or validate the arguments.
In particular, missing values in the data may make the function crash.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robsvyreg(x, y, w, k, psi, type, xwgt, var = NULL, verbose = TRUE, ...)
svyreg_control(tol = 1e-5, maxit = 100, k_Inf = 1e6, init = NULL,
               mad_center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robsvyreg_+3A_x">x</code></td>
<td>
<p><code>[numeric matrix]</code> design matrix (<code>NA</code> values not
allowed).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_y">y</code></td>
<td>
<p><code>[numeric vector]</code> dependent variable (<code>NA</code> values not
allowed).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (no <code>NA</code>'s allowed).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_psi">psi</code></td>
<td>
<p><code>[integer]</code> psi-functions: <code>0</code>: Huber, <code>1</code>:
asymmetric Huber, and <code>2</code>: Tukey biweight.</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_type">type</code></td>
<td>
<p><code>[integer]</code> type of estimator; <code>0</code>: M-estimator;
<code>1</code>: Mallows and <code>2</code>: Schweppe type GM-estimator.</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_xwgt">xwgt</code></td>
<td>
<p><code>[numeric vector]</code> weights for design space used in
GM-estimators (default: <code>NULL</code>, <code>NA</code> values not allowed).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_var">var</code></td>
<td>
<p><code>[numeric vector]</code> heteroscedastic variance
(default: <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_tol">tol</code></td>
<td>
<p><code>[double]</code> numerical tolerance criterion to stop the
iterations (default: <code>1e-05</code>).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_maxit">maxit</code></td>
<td>
<p><code>[integer]</code> maximum number of iterations to use
(default: <code>100</code>).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_k_inf">k_Inf</code></td>
<td>
<p><code>[integer]</code> numerical value that represents <code>Inf</code>
(default: <code>1e+06</code>).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_init">init</code></td>
<td>
<p>either <code>NULL</code> or <code>[numeric vector]</code>, if
<code>init = NULL</code> the regression estimator is initialized by
weighted least squares; otherwise, <code>init</code> can be specified as
the estimate (i.e., <em>p</em>-vector) to initialize the iteratively
re-weighted least squares method (default: <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_mad_center">mad_center</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, the weighted MAD is
centered about the (weighted) median, otherwise the weighted MAD is
centered about zero (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="robsvyreg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method
(see <code>svyreg_control</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not documented
</p>


<h3>Value</h3>

<p><code>[list]</code>
</p>

<hr>
<h2 id='svymean_dalen'>Dalen's Estimators of the Population Mean and Total</h2><span id='topic+svymean_dalen'></span><span id='topic+svytotal_dalen'></span>

<h3>Description</h3>

<p>Dalen's estimators Z2 and Z3 of the population mean and total; see
<code><a href="#topic+weighted_mean_dalen">weighted_mean_dalen</a></code> for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svymean_dalen(x, design, censoring, type = "Z2", na.rm = FALSE,
              verbose = TRUE, ...)
svytotal_dalen(x, design, censoring, type = "Z2", na.rm = FALSE,
               verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svymean_dalen_+3A_x">x</code></td>
<td>
<p>a one-sided <code>[formula]</code>, e.g., <code>~myVariable</code>.</p>
</td></tr>
<tr><td><code id="svymean_dalen_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svymean_dalen_+3A_censoring">censoring</code></td>
<td>
<p><code>[double]</code> cutoff threshold above which the
observations are censored.</p>
</td></tr>
<tr><td><code id="svymean_dalen_+3A_type">type</code></td>
<td>
<p><code>[character]</code> type of estimator; either <code>"Z2"</code> or
<code>"Z3"</code> (default: <code>"Z2"</code>).</p>
</td></tr>
<tr><td><code id="svymean_dalen_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svymean_dalen_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svymean_dalen_+3A_...">...</code></td>
<td>
<p>additional arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>

<dl>
<dt>Methods/ types</dt><dd><p><code>type = "Z2"</code> or <code>type = "Z3"</code>; see
<code><a href="#topic+weighted_mean_dalen">weighted_mean_dalen</a></code> for more details.</p>
</dd>
<dt>Utility functions</dt><dd><p><code><a href="#topic+svystat_rob">summary</a></code>,
<code><a href="#topic+svystat_rob">coef</a></code>, <code><a href="#topic+svystat_rob">SE</a></code>,
<code><a href="#topic+svystat_rob">vcov</a></code>,
<code><a href="#topic+svystat_rob">residuals</a></code>,
<code><a href="#topic+svystat_rob">fitted</a></code>,
<code><a href="#topic+svystat_rob">robweights</a></code>.</p>
</dd>
<dt>Bare-bone functions</dt><dd><p>See <code><a href="#topic+weighted_mean_dalen">weighted_mean_dalen</a></code> and
<code><a href="#topic+weighted_total_dalen">weighted_total_dalen</a></code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>
</p>


<h3>References</h3>

<p>Dalén, J. (1987). Practical Estimators of a Population Total Which Reduce
the Impact of Large Observations. R &amp; D Report U/STM 1987:32, Statistics
Sweden, Stockholm.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svymean_trimmed">svymean_trimmed</a></code>, <code><a href="#topic+svytotal_trimmed">svytotal_trimmed</a></code>,
<code><a href="#topic+svymean_winsorized">svymean_winsorized</a></code>, <code><a href="#topic+svytotal_winsorized">svytotal_winsorized</a></code>,
<code><a href="#topic+svymean_huber">svymean_huber</a></code> and <code><a href="#topic+svytotal_huber">svytotal_huber</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Dalen's estimator Z3 of the population total
svytotal_dalen(~employment, dn, censoring = 20000, type = "Z3")

# Dalen's estimator Z3 of the population mean
m &lt;- svymean_dalen(~employment, dn, censoring = 20000, type = "Z3")

# Summarize
summary(m)

# Extract estimate
coef(m)

# Extract estimated standard error
SE(m)
</code></pre>

<hr>
<h2 id='svymean_ratio'>Robust Ratio Predictor of the Mean and Total</h2><span id='topic+svymean_ratio'></span><span id='topic+svytotal_ratio'></span>

<h3>Description</h3>

<p>Robust ratio predictor (<em>M</em>-estimator) of the population mean and
total with Huber and Tukey biweight (bisquare) psi-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svytotal_ratio(object, total, variance = "wu", keep_object = TRUE, ...)
svymean_ratio(object, total, N = NULL, variance = "wu",
              keep_object = TRUE, N_unknown = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svymean_ratio_+3A_object">object</code></td>
<td>
<p>an object of class <code>[ratio]</code>, e.g., result of
the Huber ratio <code class="reqn">M</code>-estimator <code>svyratio_huber</code>.</p>
</td></tr>
<tr><td><code id="svymean_ratio_+3A_total">total</code></td>
<td>
<p><code>[numeric]</code> vector of population totals of the
auxiliary variables.</p>
</td></tr>
<tr><td><code id="svymean_ratio_+3A_n">N</code></td>
<td>
<p><code>[numeric]</code> population size (see also <code>N_unknown</code>.</p>
</td></tr>
<tr><td><code id="svymean_ratio_+3A_variance">variance</code></td>
<td>
<p><code>[character]</code> type of variance estimator (default:
&quot;wu&quot;); see Details Section.</p>
</td></tr>
<tr><td><code id="svymean_ratio_+3A_keep_object">keep_object</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, <code>object</code> is
returned as an additional slot of the return value (default:
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svymean_ratio_+3A_n_unknown">N_unknown</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, it is assumed that
the population size is unknown; thus, it is estimated
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svymean_ratio_+3A_...">...</code></td>
<td>
<p>additional arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>
<p>The (robust) ratio predictor of the population total or mean is
computed in two steps.
</p>

<ul>
<li><p> Step 1: Fit the ratio model associated with the predictor
by one of the functions <code><a href="#topic+svyratio_huber">svyratio_huber</a></code>
or <code><a href="#topic+svyratio_tukey">svyratio_tukey</a></code>. The fitted model is called
<code>object</code>.
</p>
</li>
<li><p> Step 2: Based on the fitted model obtained in the first step,
we predict the population total and mean, respectively, by
the predictors <code>svytotal_ratio</code> and <code>svymean_ratio</code>,
where <code>object</code> is the fitted ratio model.
</p>
</li></ul>


<dl>
<dt>Auxiliary data</dt><dd>
<p>Two types of auxiliary variables are distinguished: (1)
population size <code class="reqn">N</code> and (2) the population total of the
auxiliary variable (denominator) used in the ratio model.
</p>
<p>The option <code>N_unknown = TRUE</code> can be used in the predictor
of the population mean if <code class="reqn">N</code> is unknown.
</p>
</dd>
<dt>Variance estimation</dt><dd>
<p>Three variance estimators are implemented (argument
<code>variance</code>): <code>"base"</code>, <code>"wu"</code>, and <code>"hajek"</code>.
These estimators correspond to the estimators <code>v0</code>, <code>v1</code>,
and <code>v2</code> in Wu (1982).
</p>
</dd>
<dt>Utility functions</dt><dd>
<p>The return value is an object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>.
Thus, the utility functions <code><a href="#topic+svystat_rob">summary</a></code>,
<code><a href="#topic+svystat_rob">coef</a></code>,
<code><a href="#topic+svystat_rob">SE</a></code>,
<code><a href="#topic+svystat_rob">vcov</a></code>,
<code><a href="#topic+svystat_rob">residuals</a></code>,
<code><a href="#topic+svystat_rob">fitted</a></code>, and
<code><a href="#topic+svystat_rob">robweights</a></code> are available.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>
</p>


<h3>References</h3>

<p>Wu, C.-F. (1982). Estimation of Variance of the Ratio Estimator.
<em>Biometrika</em> <b>69</b>, 183&ndash;189.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svymean_reg">svymean_reg</a></code> and <code><a href="#topic+svytotal_reg">svytotal_reg</a></code> for (robust) GREG
regression predictors
</p>
<p><code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>, <code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code>,
<code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code> and <code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code> for robust
regression <code class="reqn">M</code>- and <code class="reqn">GM</code>-estimators
</p>
<p><code><a href="#topic+svymean_huber">svymean_huber</a></code>, <code><a href="#topic+svytotal_huber">svytotal_huber</a></code>,
<code><a href="#topic+svymean_tukey">svymean_tukey</a></code> and <code><a href="#topic+svytotal_tukey">svytotal_tukey</a></code> for
<code class="reqn">M</code>-estimators
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Robust ratio M-estimator with Huber psi-function
rat &lt;- svyratio_huber(~payroll, ~ employment, dn, k = 5)

# Summary of the ratio estimate
summary(rat)

# Diagnostic plots of the ration/regression M-estimate (e.g.,
# standardized residuals against fitted values)
plot(rat, which = 1L)

# Plot of the robustness weights of the ratio/regression M-estimate
# against its residuals
plot(residuals(rat), robweights(rat))

# Robust ratio predictor of the population mean
m &lt;- svymean_ratio(rat, total = 1001233, N = 90840)
m

# Summary of the ratio estimate of the population mean
summary(m)

# Extract estimate
coef(m)

# Extract estimate of scale
scale(m)

# Extract estimated standard error
SE(m)
</code></pre>

<hr>
<h2 id='svymean_reg'>Robust Generalized Regression Predictor (GREG) of the Mean and Total</h2><span id='topic+svymean_reg'></span><span id='topic+svytotal_reg'></span>

<h3>Description</h3>

<p>Generalized regression estimator (GREG) predictor of the mean and total,
and robust GREG <code class="reqn">M</code>-estimator predictor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svytotal_reg(object, totals, N = NULL, type, k = NULL, check.names = TRUE,
             keep_object = TRUE, ...)
svymean_reg(object, totals, N = NULL, type, k = NULL, check.names = TRUE,
            keep_object = TRUE, N_unknown = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svymean_reg_+3A_object">object</code></td>
<td>
<p>an object of class <code>[svyreg_rob]</code>, e.g., result of
the Huber regression <code class="reqn">M</code>-estimator <code>svyreg_huberM</code>.</p>
</td></tr>
<tr><td><code id="svymean_reg_+3A_totals">totals</code></td>
<td>
<p><code>[numeric]</code> vector of population totals of the
auxiliary variables.</p>
</td></tr>
<tr><td><code id="svymean_reg_+3A_n">N</code></td>
<td>
<p><code>[numeric]</code> population size (see also <code>N_unknown</code>.</p>
</td></tr>
<tr><td><code id="svymean_reg_+3A_type">type</code></td>
<td>
<p><code>[character]</code> type of predictor; see Details Section.</p>
</td></tr>
<tr><td><code id="svymean_reg_+3A_k">k</code></td>
<td>
<p><code>[numeric]</code> robustness tuning constant of the
<code>psi</code>-function used in the bias-correction term of the GREG.
The definition of <code>k</code> depends on the <code>type</code> of predictor
and is discussed in the Details Section.</p>
</td></tr>
<tr><td><code id="svymean_reg_+3A_check.names">check.names</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, the names of
<code>auxiliary</code> are checked against the names of the independent
variables of the fitted model <code>object</code> (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svymean_reg_+3A_keep_object">keep_object</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, <code>object</code> is
returned as an additional slot of the return value (default:
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svymean_reg_+3A_n_unknown">N_unknown</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, it is assumed that
the population size is unknown; thus, it is estimated
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svymean_reg_+3A_...">...</code></td>
<td>
<p>additional arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>
<p>The (robust) GREG predictor of the population total or mean is
computed in two steps.
</p>

<ul>
<li><p> Step 1: Fit the regression model associated with the GREG
predictor by one of the functions <code><a href="#topic+svyreg">svyreg</a></code>,
<code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>, <code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code>,
<code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code> or <code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code>.
The fitted model is called <code>object</code>.
</p>
</li>
<li><p> Step 2: Based on the fitted model obtained in the first step,
we predict the population total and mean, respectively, by
the predictors <code>svytotal_reg</code> and <code>svymean_reg</code>,
where <code>object</code> is the fitted regression model.
</p>
</li></ul>

<p>The following GREG predictors are available:
</p>

<dl>
<dt>GREG (not robust, <code>k = NULL</code>)</dt><dd>
<p>The following <em>non-robust</em> GREG predictors are available:
</p>

<ul>
<li> <p><code>type = "projective"</code> ignores the bias correction
term of the GREG predictor; see Särndal and Wright (1984).
</p>
</li>
<li> <p><code>type = "ADU"</code> is the &quot;standard&quot; GREG,
which is an asymptotically design unbiased (ADU)
predictor; see Särndal et al.(1992, Chapter 6).
</p>
</li></ul>

<p>If the fitted regression model (<code>object</code>) does include
a regression intercept, the predictor types <code>"projective"</code>
and <code>"ADU"</code> are identical because the bias correction
of the GREG is zero by design.
</p>
</dd>
<dt>Robust GREG</dt><dd>
<p>The following <em>robust</em> GREG predictors are available:
</p>

<ul>
<li> <p><code>type = "huber"</code> and <code>type = "tukey"</code> are,
respectively, the robust GREG predictors with Huber
and Tukey bisquare (biweight) psi-function. The tuning
constant must satisfy <code>0 &lt; k &lt;= Inf</code>.
We can use the Huber-type GREG predictor although the
model has been fitted by the regression estimator
with Tukey psi-function (and vice versa).
</p>
</li>
<li> <p><code>type = "BR"</code> is the bias-corrected robust GREG
predictor of Beaumont and Rivest (2009), which is
inspired by the bias-corrected robust predictor of
Chambers (1986). The tuning constant must satisfy
<code>0 &lt; k &lt;= Inf</code>.
</p>
</li>
<li> <p><code>type = "lee"</code> is the bias-corrected predictor
of Lee (1991; 1992). Tthe tuning constant <code>k</code> must
satisfy <code>0 &lt;= k &lt;= 1</code>.
</p>
</li>
<li> <p><code>type = "duchesne"</code> is the bias-corrected,
calibration-type estimator/ predictor of Duchesne (1999).
The tuning constant <code>k</code> must be specified as a
vector <code>k = c(a, b)</code>, where <code>a</code> and <code>b</code>
are the tuning constants of Duchesne's modified Huber
psi-function (default values: <code>a = 9</code> and
<code>b = 0.25</code>).
</p>
</li></ul>

</dd>
<dt>Auxiliary data</dt><dd>
<p>Two types of auxiliary variables are distinguished: (1)
population size <code class="reqn">N</code> and (2) population totals of the
auxiliary variables used in the regression model (i.e.,
non-constant explanatory variables).
</p>
<p>The option <code>N_unknown = TRUE</code> can be used in the predictor
of the population mean if <code class="reqn">N</code> is unknown.
</p>
<p>The names of the entries of <code>totals</code> are checked against
the names of the regression fit (<code>object</code>), unless we specify
<code>check.names = FALSE</code>.
</p>
</dd>
<dt>Utility functions</dt><dd>
<p>The return value is an object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>.
Thus, the utility functions <code><a href="#topic+svystat_rob">summary</a></code>,
<code><a href="#topic+svystat_rob">coef</a></code>,
<code><a href="#topic+svystat_rob">SE</a></code>,
<code><a href="#topic+svystat_rob">vcov</a></code>,
<code><a href="#topic+svystat_rob">residuals</a></code>,
<code><a href="#topic+svystat_rob">fitted</a></code>, and
<code><a href="#topic+svystat_rob">robweights</a></code> are available.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>
</p>


<h3>References</h3>

<p>Beaumont, J.-F. and Rivest, L.-P. (2009). Dealing with outliers in survey
data. In: <em>Sample Surveys: Theory, Methods and Inference</em>
ed. by Pfeffermann, D. and Rao, C. R. Volume 29A of
<em>Handbook of Statistics</em>, Amsterdam: Elsevier, Chap. 11, 247&ndash;280.
<a href="https://doi.org/10.1016/S0169-7161%2808%2900011-4">doi:10.1016/S0169-7161(08)00011-4</a>
</p>
<p>Chambers, R. (1986). Outlier Robust Finite Population Estimation.
<em>Journal of the American Statistical Association</em> <b>81</b>,
1063&ndash;1069. <a href="https://doi.org/10.1080/01621459.1986.10478374">doi:10.1080/01621459.1986.10478374</a>
</p>
<p>Duchesne, P. (1999). Robust calibration estimators, <em>Survey Methodology</em>
<b>25</b>, 43&ndash;56.
</p>
<p>Gwet, J.-P. and Rivest, L.-P. (1992). Outlier Resistant Alternatives to
the Ratio Estimator. <em>Journal of the American Statistical Association</em>
<b>87</b>, 1174&ndash;1182. <a href="https://doi.org/10.1080/01621459.1992.10476275">doi:10.1080/01621459.1992.10476275</a>
</p>
<p>Lee, H. (1991). Model-Based Estimators That Are Robust to Outliers,
in <em>Proceedings of the 1991 Annual Research Conference</em>,
Bureau of the Census, 178&ndash;202. Washington, DC, Department of Commerce.
</p>
<p>Lee, H. (1995). Outliers in business surveys. In:
<em>Business survey methods</em> ed. by Cox, B. G., Binder, D. A.,
Chinnappa, B. N., Christianson, A., Colledge, M. J. and Kott, P. S.
New York: John Wiley and Sons, Chap. 26, 503&ndash;526.
<a href="https://doi.org/10.1002/9781118150504.ch26">doi:10.1002/9781118150504.ch26</a>
</p>
<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, New York: Springer.
</p>
<p>Särndal, C.-E. and Wright, R. L. (1984). Cosmetic Form of Estimators
in Survey Sampling. <em>Scandinavian Journal of Statistics</em> <b>11</b>,
146&ndash;156.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svymean_ratio">svymean_ratio</a></code> and <code><a href="#topic+svytotal_ratio">svytotal_ratio</a></code> for (robust)
ratio predictors
</p>
<p><code><a href="#topic+svymean_huber">svymean_huber</a></code>, <code><a href="#topic+svytotal_huber">svytotal_huber</a></code>,
<code><a href="#topic+svymean_tukey">svymean_tukey</a></code> and <code><a href="#topic+svytotal_tukey">svytotal_tukey</a></code> for
<code class="reqn">M</code>-estimators
</p>
<p><code><a href="#topic+svyreg">svyreg</a></code>, <code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>, <code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code>,
<code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code> and <code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code> for robust
regression <code class="reqn">M</code>- and <code class="reqn">GM</code>-estimators
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Robust regression M-estimator with Huber psi-function
reg &lt;- svyreg_huberM(payroll ~ employment, dn, k = 3)

# Summary of the regression M-estimate
summary(reg)

# Diagnostic plots of the regression M-estimate (e.g., standardized
# residuals against fitted values)
plot(reg, which = 1L)

# Plot of the robustness weights of the regression M-estimate against
# its residuals
plot(residuals(reg), robweights(reg))

# ADU (asymptotically design unbiased) estimator
m &lt;- svytotal_reg(reg, totals = 1001233, 90840, type = "ADU")
m

# Robust GREG estimator of the mean; the population means of the auxiliary
# variables are from a register
m &lt;- svymean_reg(reg, totals = 1001233, 90840, type = "huber", k = 20)
m

# Summary of the robust GREG estimate
summary(m)

# Extract estimate
coef(m)

# Extract estimated standard error
SE(m)

# Approximation of the estimated mean square error
mse(m)
</code></pre>

<hr>
<h2 id='svymean_trimmed'>Weighted Trimmed Mean and Total</h2><span id='topic+svymean_trimmed'></span><span id='topic+svytotal_trimmed'></span>

<h3>Description</h3>

<p>Weighted trimmed population mean and total.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svymean_trimmed(x, design, LB = 0.05, UB = 1 - LB, na.rm = FALSE, ...)
svytotal_trimmed(x, design, LB = 0.05, UB = 1 - LB, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svymean_trimmed_+3A_x">x</code></td>
<td>
<p>a one-sided <code>[formula]</code>, e.g., <code>~myVariable</code>.</p>
</td></tr>
<tr><td><code id="svymean_trimmed_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svymean_trimmed_+3A_lb">LB</code></td>
<td>
<p><code>[double]</code> lower bound of trimming such that
<code class="reqn">0 \leq</code> <code>LB</code> <code class="reqn">&lt;</code> <code>UB</code> <code class="reqn">\leq 1</code>.</p>
</td></tr>
<tr><td><code id="svymean_trimmed_+3A_ub">UB</code></td>
<td>
<p><code>[double]</code> upper bound of trimming such that
<code class="reqn">0 \leq</code> <code>LB</code> <code class="reqn">&lt;</code> <code>UB</code> <code class="reqn">\leq 1</code>.</p>
</td></tr>
<tr><td><code id="svymean_trimmed_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svymean_trimmed_+3A_...">...</code></td>
<td>
<p>additional arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>

<dl>
<dt>Characteristic.</dt><dd><p>Population mean or total. Let <code class="reqn">\mu</code> denote
the estimated trimmed population mean; then, the estimated trimmed
total is given by <code class="reqn">\hat{N} \mu</code> with
<code class="reqn">\hat{N} =\sum w_i</code>, where
summation is over all observations in the sample.</p>
</dd>
<dt>Trimming.</dt><dd><p>The methods trims the <code>LB</code><code class="reqn">~\cdot 100\%</code>
of the smallest observations and the (1 - <code>UB</code>)<code class="reqn">~\cdot 100\%</code>
of the largest observations from the data.</p>
</dd>
<dt>Variance estimation.</dt><dd><p>Large-sample approximation based on the
influence function; see Huber and Ronchetti (2009, Chap. 3.3) and
Shao (1994).</p>
</dd>
<dt>Utility functions.</dt><dd><p><code><a href="#topic+svystat_rob">summary</a></code>,
<code><a href="#topic+svystat_rob">coef</a></code>, <code><a href="#topic+svystat_rob">SE</a></code>,
<code><a href="#topic+svystat_rob">vcov</a></code>, <code><a href="#topic+svystat_rob">residuals</a></code>,
<code><a href="#topic+svystat_rob">fitted</a></code>,
<code><a href="#topic+svystat_rob">robweights</a></code>.</p>
</dd>
<dt>Bare-bone functions.</dt><dd><p>See <code><a href="#topic+weighted_mean_trimmed">weighted_mean_trimmed</a></code> and
<code><a href="#topic+weighted_total_trimmed">weighted_total_trimmed</a></code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>
</p>


<h3>References</h3>

<p>Huber, P. J. and Ronchetti, E. (2009). <em>Robust Statistics</em>,
New York: John Wiley and Sons, 2nd edition.
<a href="https://doi.org/10.1002/9780470434697">doi:10.1002/9780470434697</a>
</p>
<p>Shao, J. (1994). L-Statistics in Complex Survey Problems.
<em>The Annals of Statistics</em> <b>22</b>, 976&ndash;967.
<a href="https://doi.org/10.1214/aos/1176325505">doi:10.1214/aos/1176325505</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+weighted_mean_trimmed">weighted_mean_trimmed</a></code> and <code><a href="#topic+weighted_total_trimmed">weighted_total_trimmed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Estimated trimmed population total (5% symmetric trimming)
svytotal_trimmed(~employment, dn, LB = 0.05, UB = 0.95)

# Estimated trimmed population mean (5% trimming at the top of the distr.)
svymean_trimmed(~employment, dn, UB = 0.95)
</code></pre>

<hr>
<h2 id='svymean_winsorized'>Weighted Winsorized Mean and Total</h2><span id='topic+svymean_winsorized'></span><span id='topic+svymean_k_winsorized'></span><span id='topic+svytotal_winsorized'></span><span id='topic+svytotal_k_winsorized'></span>

<h3>Description</h3>

<p>Weighted winsorized mean and total
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svymean_winsorized(x, design, LB = 0.05, UB = 1 - LB, na.rm = FALSE,
                   trim_var = FALSE, ...)
svymean_k_winsorized(x, design, k, na.rm = FALSE, trim_var = FALSE, ...)
svytotal_winsorized(x, design, LB = 0.05, UB = 1 - LB, na.rm = FALSE,
                    trim_var = FALSE, ...)
svytotal_k_winsorized(x, design, k, na.rm = FALSE, trim_var = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svymean_winsorized_+3A_x">x</code></td>
<td>
<p>a one-sided <code>[formula]</code>, e.g., <code>~myVariable</code>.</p>
</td></tr>
<tr><td><code id="svymean_winsorized_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svymean_winsorized_+3A_lb">LB</code></td>
<td>
<p><code>[double]</code> lower bound of winsorization such that
<code class="reqn">0 \leq</code> <code>LB</code> <code class="reqn">&lt;</code> <code>UB</code> <code class="reqn">\leq 1</code>.</p>
</td></tr>
<tr><td><code id="svymean_winsorized_+3A_ub">UB</code></td>
<td>
<p><code>[double]</code> upper bound of winsorization such that
<code class="reqn">0 \leq</code> <code>LB</code> <code class="reqn">&lt;</code> <code>UB</code> <code class="reqn">\leq 1</code>.</p>
</td></tr>
<tr><td><code id="svymean_winsorized_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svymean_winsorized_+3A_trim_var">trim_var</code></td>
<td>
<p><code>[logical]</code> indicating whether the variance
should be approximated by the variance estimator of the trimmed mean/
total (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svymean_winsorized_+3A_k">k</code></td>
<td>
<p><code>[integer]</code> number of observations to be winsorized at the
top of the distribution.</p>
</td></tr>
<tr><td><code id="svymean_winsorized_+3A_...">...</code></td>
<td>
<p>additional arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>

<dl>
<dt>Characteristic.</dt><dd><p>Population mean or total. Let <code class="reqn">\mu</code>
denote the estimated winsorized population mean; then, the
estimated winsorized total is given by
<code class="reqn">\hat{N} \mu</code> with
<code class="reqn">\hat{N} =\sum w_i</code>, where summation
is over all observations in the sample.</p>
</dd>
<dt>Modes of winsorization.</dt><dd><p>The amount of winsorization can be
specified in relative or absolute terms:
</p>

<ul>
<li> <p><em>Relative:</em> By specifying <code>LB</code> and <code>UB</code>,
the method winsorizes the <code>LB</code><code class="reqn">~\cdot 100\%</code>
of the smallest observations and the
(1 - <code>UB</code>)<code class="reqn">~\cdot 100\%</code> of the largest
observations from the data.
</p>
</li>
<li> <p><em>Absolute:</em> By specifying argument <code>k</code> in the
functions with the &quot;infix&quot; <code>_k_</code> in their name (e.g.,
<code>svymean_k_winsorized</code>), the
largest <code class="reqn">k</code> observations are winsorized, <code class="reqn">0&lt;k&lt;n</code>,
where <code class="reqn">n</code> denotes the sample size. E.g., <code>k = 2</code>
implies that the largest and the second largest observation
are winsorized.
</p>
</li></ul>

</dd>
<dt>Variance estimation.</dt><dd><p>Large-sample approximation based on the
influence function; see Huber and Ronchetti (2009, Chap. 3.3)
and Shao (1994). Two estimators are available:
</p>

<dl>
<dt><code>simple_var = FALSE</code></dt><dd><p>Variance estimator of
the winsorized mean/ total. The estimator depends on
the estimated probability density function evaluated at
the winsorization thresholds, which can be &ndash; depending
on the context &ndash; numerically unstable. As a remedy,
a simplified variance estimator is available by
setting <code>simple_var = TRUE</code>.</p>
</dd>
<dt><code>simple_var = TRUE</code></dt><dd><p>Variance is approximated
using the variance estimator of the trimmed mean/ total.</p>
</dd>
</dl>

</dd>
<dt>Utility functions.</dt><dd><p><code><a href="#topic+svystat_rob">summary</a></code>,
<code><a href="#topic+svystat_rob">coef</a></code>, <code><a href="#topic+svystat_rob">SE</a></code>,
<code><a href="#topic+svystat_rob">vcov</a></code>,
<code><a href="#topic+svystat_rob">residuals</a></code>,
<code><a href="#topic+svystat_rob">fitted</a></code> and
<code><a href="#topic+svystat_rob">robweights</a></code>.</p>
</dd>
<dt>Bare-bone functions.</dt><dd><p>See:
</p>

<ul>
<li> <p><code><a href="#topic+weighted_mean_winsorized">weighted_mean_winsorized</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+weighted_mean_k_winsorized">weighted_mean_k_winsorized</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+weighted_total_winsorized">weighted_total_winsorized</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+weighted_total_k_winsorized">weighted_total_k_winsorized</a></code>.</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>
</p>


<h3>References</h3>

<p>Huber, P. J. and Ronchetti, E. (2009). <em>Robust Statistics</em>,
New York: John Wiley and Sons, 2nd edition.
<a href="https://doi.org/10.1002/9780470434697">doi:10.1002/9780470434697</a>
</p>
<p>Shao, J. (1994). L-Statistics in Complex Survey Problems.
<em>The Annals of Statistics</em> <b>22</b>, 976&ndash;967.
<a href="https://doi.org/10.1214/aos/1176325505">doi:10.1214/aos/1176325505</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+weighted_mean_winsorized">weighted_mean_winsorized</a></code>,
<code><a href="#topic+weighted_mean_k_winsorized">weighted_mean_k_winsorized</a></code>,
<code><a href="#topic+weighted_total_winsorized">weighted_total_winsorized</a></code> and
<code><a href="#topic+weighted_total_k_winsorized">weighted_total_k_winsorized</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Estimated winsorized population mean (5% symmetric winsorization)
svymean_winsorized(~employment, dn, LB = 0.05)

# Estimated one-sided k winsorized population total (2 observations are
# winsorized at the top of the distribution)
svytotal_k_winsorized(~employment, dn, k = 2)
</code></pre>

<hr>
<h2 id='svymean-m-estimator'>Weighted Huber and Tukey Mean and Total (M-Estimator) &ndash; Robust
Horvitz-Thompson Estimator</h2><span id='topic+svymean_huber'></span><span id='topic+svytotal_huber'></span><span id='topic+svymean_tukey'></span><span id='topic+svytotal_tukey'></span>

<h3>Description</h3>

<p>Weighted Huber and Tukey <em>M</em>-estimator of the population mean and
total (robust Horvitz-Thompson estimator)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svymean_huber(x, design, k, type = "rwm", asym = FALSE, na.rm = FALSE,
              verbose = TRUE, ...)
svytotal_huber(x, design, k, type = "rwm", asym = FALSE, na.rm = FALSE,
               verbose = TRUE, ...)
svymean_tukey(x, design, k, type = "rwm", na.rm = FALSE, verbose = TRUE, ...)
svytotal_tukey(x, design, k, type = "rwm", na.rm = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svymean-m-estimator_+3A_x">x</code></td>
<td>
<p>a one-sided <code>[formula]</code>, e.g., <code>~myVariable</code>.</p>
</td></tr>
<tr><td><code id="svymean-m-estimator_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svymean-m-estimator_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="svymean-m-estimator_+3A_type">type</code></td>
<td>
<p><code>[character]</code> type of method: <code>"rwm"</code> or
<code>"rht"</code>.</p>
</td></tr>
<tr><td><code id="svymean-m-estimator_+3A_asym">asym</code></td>
<td>
<p><code>[logical]</code> if <code>TRUE</code>, an asymmetric Huber
psi-function is used (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svymean-m-estimator_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svymean-m-estimator_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svymean-m-estimator_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method (e.g., <code>maxit</code>:
maxit number of iterations, etc.; see <code><a href="#topic+svyreg_control">svyreg_control</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>

<dl>
<dt>Methods/ types</dt><dd><p><code>type = "rht"</code> or <code>type = "rwm"</code>; see
<code><a href="#topic+weighted_mean_huber">weighted_mean_huber</a></code> or
<code><a href="#topic+weighted_mean_tukey">weighted_mean_tukey</a></code> for more details.</p>
</dd>
<dt>Variance estimation.</dt><dd><p>Taylor linearization (residual variance
estimator).</p>
</dd>
<dt>Utility functions</dt><dd><p><code><a href="#topic+svystat_rob">summary</a></code>,
<code><a href="#topic+svystat_rob">coef</a></code>, <code><a href="#topic+svystat_rob">SE</a></code>,
<code><a href="#topic+svystat_rob">vcov</a></code>,
<code><a href="#topic+svystat_rob">residuals</a></code>,
<code><a href="#topic+svystat_rob">fitted</a></code>,
<code><a href="#topic+svystat_rob">robweights</a></code>.</p>
</dd>
<dt>Bare-bone functions</dt><dd><p>See <code><a href="#topic+weighted_mean_huber">weighted_mean_huber</a></code>
<code><a href="#topic+weighted_mean_tukey">weighted_mean_tukey</a></code>,
<code><a href="#topic+weighted_total_huber">weighted_total_huber</a></code>, and
<code><a href="#topic+weighted_total_tukey">weighted_total_tukey</a></code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code><a href="#topic+svystat_rob">svystat_rob</a></code>
</p>


<h3>Failure of convergence</h3>

<p>By default, the method assumes a maximum number of <code>maxit = 100</code>
iterations and a numerical tolerance criterion to stop the iterations of
<code>tol = 1e-05</code>. If the algorithm fails to converge, you may
consider changing the default values; see <code><a href="#topic+svyreg_control">svyreg_control</a></code>.
</p>


<h3>References</h3>

<p>Hulliger, B. (1995). Outlier Robust Horvitz-Thompson Estimators.
<em>Survey Methodology</em> <b>21</b>, 79&ndash;87.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Robust Horvitz-Thompson M-estimator of the population total
svytotal_huber(~employment, dn, k = 9, type = "rht")

# Robust weighted M-estimator of the population mean
m &lt;- svymean_huber(~employment, dn, k = 12, type = "rwm")

# Summary statistic
summary(m)

# Plot of the robustness weights of the M-estimate against its residuals
plot(residuals(m), robweights(m))

# Extract estimate
coef(m)

# Extract estimate of scale
scale(m)

# Extract estimated standard error
SE(m)
</code></pre>

<hr>
<h2 id='svyratio_huber'>Robust Survey Ratio M-Estimator</h2><span id='topic+svyratio_huber'></span><span id='topic+svyratio_tukey'></span>

<h3>Description</h3>

<p><code>svyratio_huber</code> and <code>svyratio_tukey</code> compute the robust
<code class="reqn">M</code>-estimator of the ratio of two variables with, respectively,
Huber and Tukey biweight (bisquare) psi-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyratio_huber(numerator, denominator, design, k, var = denominator,
               na.rm = FALSE, asym = FALSE, verbose = TRUE, ...)
svyratio_tukey(numerator, denominator, design, k, var = denominator,
               na.rm = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svyratio_huber_+3A_numerator">numerator</code></td>
<td>
<p>a one-sided <code>[formula]</code> object (i.e., symbolic
description, e.g., <code>~payroll</code>).</p>
</td></tr>
<tr><td><code id="svyratio_huber_+3A_denominator">denominator</code></td>
<td>
<p>a one-sided <code>[formula]</code> object (i.e., symbolic
description, e.g., <code>~employment</code>).</p>
</td></tr>
<tr><td><code id="svyratio_huber_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svyratio_huber_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="svyratio_huber_+3A_var">var</code></td>
<td>
<p>a <code>[formula]</code> object that defines the heteroscedastic
variance (default: <code>numerator</code>).</p>
</td></tr>
<tr><td><code id="svyratio_huber_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyratio_huber_+3A_asym">asym</code></td>
<td>
<p><code>[logical]</code> toggle for asymmetric Huber psi-function
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyratio_huber_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svyratio_huber_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method (e.g., <code>maxit</code>:
maxit number of iterations, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>
<p>The functions <code>svyratio_huber</code> and <code>svyratio_tukey</code> are
implemented as wrapper functions of the regression estimators
<code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code> and <code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code>. See
the help files of these functions (e.g., on how additional
parameters can be passed via <code>...</code> or on the usage of the
<code>var</code> argument).
</p>


<h3>Value</h3>

<p>Object of class <code>svyreg.rob</code> and <code>ratio</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svyreg_rob">summary</a></code>, <code><a href="#topic+svyreg_rob">coef</a></code>,
<code><a href="#topic+svyreg_rob">residuals</a></code>, <code><a href="#topic+svyreg_rob">fitted</a></code>,
<code><a href="#topic+svyreg_rob">SE</a></code> and <code><a href="#topic+svyreg_rob">vcov</a></code>
</p>
<p><code><a href="#topic+svyreg_rob">plot</a></code> for regression diagnostic plot methods
</p>
<p><code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>, <code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code>,
<code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code> and <code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code> for robust
regression estimators
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Compute regression M-estimate with Huber psi-function
m &lt;- svyratio_huber(~payroll, ~employment, dn, k = 8)

# Regression inference
summary(m)

# Extract the coefficients
coef(m)

# Extract estimated standard error
SE(m)

# Extract variance/ covariance matrix
vcov(m)

# Diagnostic plots (e.g., standardized residuals against fitted values)
plot(m, which = 1L)

# Plot of the robustness weights of the M-estimate against its residuals
plot(residuals(m), robweights(m))
</code></pre>

<hr>
<h2 id='svyreg'>Survey Regression Estimator &ndash; Weighted Least Squares</h2><span id='topic+svyreg'></span>

<h3>Description</h3>

<p>Weighted least squares estimator of regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyreg(formula, design, var = NULL, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svyreg_+3A_formula">formula</code></td>
<td>
<p>a <code>[formula]</code> object (i.e., symbolic description
of the model)</p>
</td></tr>
<tr><td><code id="svyreg_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svyreg_+3A_var">var</code></td>
<td>
<p>a one-sided <code>[formula]</code> object or variable name
(<code>[character]</code>) that defines the heteroscedastic variance
or <code>[NULL]</code> indicating homoscedastic variance (default:
<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="svyreg_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values
should be removed before the computation proceeds
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_+3A_...">...</code></td>
<td>
<p>additional arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>
<p><code>svyreg</code> computes the regression coefficients by weighted least
squares.
</p>
<p>Models for <code>svyreg_rob</code> are specified symbolically. A typical
model has the form <code>response ~ terms</code> where <code>response</code> is
the (numeric) response vector and <code>terms</code> is a series of terms
which specifies a linear predictor for <code>response</code>; see
<code><a href="stats.html#topic+formula">formula</a></code> and <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
<p>A formula has an implied intercept term. To remove this use either
<code>y ~ x - 1</code> or <code>y ~ 0 + x</code>; see <code><a href="stats.html#topic+formula">formula</a></code> for more
details of allowed formulae.
</p>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+svyreg_rob">svyreg_rob</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svyreg_rob">summary</a></code>, <code><a href="#topic+svyreg_rob">coef</a></code>,
<code><a href="#topic+svyreg_rob">residuals</a></code>, <code><a href="#topic+svyreg_rob">fitted</a></code>,
<code><a href="#topic+svyreg_rob">SE</a></code> and <code><a href="#topic+svyreg_rob">vcov</a></code>
</p>
<p><code><a href="#topic+svyreg_rob">plot</a></code> for regression diagnostic plot methods
</p>
<p>Robust estimating methods <code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>,
<code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code>, <code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code> and
<code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Compute the regression estimate (weighted least squares)
m &lt;- svyreg(payroll ~ employment, dn)

# Regression inference
summary(m)

# Extract the coefficients
coef(m)

# Extract variance/ covariance matrix
vcov(m)

# Diagnostic plots (e.g., Normal Q-Q-plot)
plot(m, which = 2L)
</code></pre>

<hr>
<h2 id='svyreg_huber-deprecated'>Deprecated Huber Robust Survey Regression M-Estimator</h2><span id='topic+svyreg_huber'></span>

<h3>Description</h3>

<p>The function <code>svyreg_huber</code> is <b>deprecated</b>; use instead
<code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyreg_huber(formula, design, k, var = NULL, na.rm = FALSE, asym = FALSE,
             verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svyreg_huber-deprecated_+3A_formula">formula</code></td>
<td>
<p>a <code>[formula]</code> object (i.e., symbolic description
of the model)</p>
</td></tr>
<tr><td><code id="svyreg_huber-deprecated_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svyreg_huber-deprecated_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huber-deprecated_+3A_var">var</code></td>
<td>
<p>a one-sided <code>[formula]</code> object or variable name
(<code>[character]</code>) that defines the heteroscedastic variance
or <code>[NULL]</code> indicating homoscedastic variance (default:
<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huber-deprecated_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huber-deprecated_+3A_asym">asym</code></td>
<td>
<p><code>[logical]</code> toggle for asymmetric Huber psi-function
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huber-deprecated_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huber-deprecated_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method (e.g., <code>maxit</code>:
maxit number of iterations, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>svyreg.rob</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-deprecated">robsurvey-deprecated</a>
</p>

<hr>
<h2 id='svyreg_huberM'>Huber Robust Survey Regression M- and GM-Estimator</h2><span id='topic+svyreg_huberM'></span><span id='topic+svyreg_huberGM'></span>

<h3>Description</h3>

<p><code>svyreg_huberM</code> and <code>svyreg_huberGM</code> compute, respectively,
a survey weighted <em>M</em>- and <em>GM</em>-estimator of regression using
the Huber psi-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyreg_huberM(formula, design, k, var = NULL, na.rm = FALSE, asym = FALSE,
              verbose = TRUE, ...)
svyreg_huberGM(formula, design, k, type = c("Mallows", "Schweppe"),
               xwgt, var = NULL, na.rm = FALSE, asym = FALSE, verbose = TRUE,
               ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svyreg_huberM_+3A_formula">formula</code></td>
<td>
<p>a <code>[formula]</code> object (i.e., symbolic description
of the model)</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_var">var</code></td>
<td>
<p>a one-sided <code>[formula]</code> object or variable name
(<code>[character]</code>) that defines the heteroscedastic variance
or <code>[NULL]</code> indicating homoscedastic variance (default:
<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_asym">asym</code></td>
<td>
<p><code>[logical]</code> toggle for asymmetric Huber psi-function
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_type">type</code></td>
<td>
<p><code>[character]</code> <code>"Mallows"</code> or <code>"Schweppe"</code>.</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_xwgt">xwgt</code></td>
<td>
<p><code>[numerical vector]</code> or <code>[NULL]</code> of weights in
the design space (default: <code>NULL</code>); <code>xwgt</code> is only
relevant for <code>type = "Mallows"</code> or <code>type = "Schweppe"</code>.</p>
</td></tr>
<tr><td><code id="svyreg_huberM_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method (e.g., <code>maxit</code>:
maxit number of iterations, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>
<p><code>svyreg_huberM</code> and <code>svyreg_huberGM</code> compute, respectively,
<em>M</em>- and <em>GM</em>-estimates of regression by iteratively re-weighted
least squares (IRWLS).  The estimate of regression scale is (by default)
computed as the (normalized) weighted median of absolute deviations
from the weighted median (MAD; see <code><a href="#topic+weighted_mad">weighted_mad</a></code>) for
each IRWLS iteration. If the weighted MAD is zero (or nearly so),
the scale is computed as the (normalized) weighted interquartile
range (IQR).
</p>

<dl>
<dt>M-estimator</dt><dd>
<p>The regression M-estimator <code>svyreg_huberM</code> is robust against
residual outliers (granted that the tuning constant <code>k</code> is
chosen appropriately).
</p>
</dd>
<dt>GM-estimator</dt><dd>
<p>Function <code>svyreg_huberGM</code> implements the Mallows and Schweppe
regression GM-estimator (see argument <code>type</code>).
The regression GM-estimators are robust against residual outliers
<em>and</em> outliers in the model's design space (leverage
observations; see argument <code>xwgt</code>).
</p>
</dd>
<dt>Numerical optimization</dt><dd>
<p>See <code><a href="#topic+svyreg_control">svyreg_control</a></code>.
</p>
</dd>
<dt>Models</dt><dd>
<p>Models for <code>svyreg_rob</code> are specified symbolically. A typical
model has the form <code>response ~ terms</code>, where <code>response</code>
is the (numeric) response vector and <code>terms</code> is a series of
terms which specifies a linear predictor for <code>response</code>; see
<code><a href="stats.html#topic+formula">formula</a></code> and <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
<p>A formula has an implied intercept term. To remove this use
either <code>y ~ x - 1</code> or <code>y ~ 0 + x</code>; see
<code><a href="stats.html#topic+formula">formula</a></code> for more details of allowed formulae.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code>svyreg.rob</code>
</p>


<h3>Failure of convergence</h3>

<p>By default, the method assumes a maximum number of <code>maxit = 100</code>
iterations and a numerical tolerance criterion to stop the iterations of
<code>tol = 1e-05</code>. If the algorithm fails to converge, you may
consider changing the default values; see <code><a href="#topic+svyreg_control">svyreg_control</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svyreg_rob">summary</a></code>, <code><a href="#topic+svyreg_rob">coef</a></code>,
<code><a href="#topic+svyreg_rob">residuals</a></code>, <code><a href="#topic+svyreg_rob">fitted</a></code>,
<code><a href="#topic+svyreg_rob">SE</a></code> and <code><a href="#topic+svyreg_rob">vcov</a></code>
</p>
<p><code><a href="#topic+svyreg_rob">plot</a></code> for regression diagnostic plot methods
</p>
<p>Other robust estimating methods <code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code> and
<code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Compute regression M-estimate with Huber psi-function
m &lt;- svyreg_huberM(payroll ~ employment, dn, k = 8)

# Regression inference
summary(m)

# Extract the coefficients
coef(m)

# Extract variance/ covariance matrix
vcov(m)

# Diagnostic plots (e.g., standardized residuals against fitted values)
plot(m, which = 1L)

# Plot of the robustness weights of the M-estimate against its residuals
plot(residuals(m), robweights(m))
</code></pre>

<hr>
<h2 id='svyreg_tukey-deprecated'>Deprecated Tukey Biweight Robust Survey Regression M-Estimator</h2><span id='topic+svyreg_tukey'></span>

<h3>Description</h3>

<p>The function <code>svyreg_tukey</code> is <b>deprecated</b>; use instead
<code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyreg_tukey(formula, design, k, var = NULL, na.rm = FALSE, verbose = TRUE,
             ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svyreg_tukey-deprecated_+3A_formula">formula</code></td>
<td>
<p>a <code>[formula]</code> object (i.e., symbolic description
of the model)</p>
</td></tr>
<tr><td><code id="svyreg_tukey-deprecated_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svyreg_tukey-deprecated_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="svyreg_tukey-deprecated_+3A_var">var</code></td>
<td>
<p>a one-sided <code>[formula]</code> object or variable name
(<code>[character]</code>) that defines the heteroscedastic variance
or <code>[NULL]</code> indicating homoscedastic variance (default:
<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="svyreg_tukey-deprecated_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_tukey-deprecated_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_tukey-deprecated_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method (e.g., <code>maxit</code>:
maxit number of iterations, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>svyreg.rob</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-deprecated">robsurvey-deprecated</a>
</p>

<hr>
<h2 id='svyreg_tukeyM'>Tukey Biweight Robust Survey Regression M- and GM-Estimator</h2><span id='topic+svyreg_tukeyM'></span><span id='topic+svyreg_tukeyGM'></span>

<h3>Description</h3>

<p><code>svyreg_tukeyM</code> and <code>svyreg_tukeyGM</code> compute, respectively,
a survey weighted <em>M</em>- and <em>GM</em>-estimator of regression using
the biweight Tukey psi-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyreg_tukeyM(formula, design, k, var = NULL, na.rm = FALSE, verbose = TRUE,
              ...)
svyreg_tukeyGM(formula, design, k, type = c("Mallows", "Schweppe"),
               xwgt, var = NULL, na.rm = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svyreg_tukeyM_+3A_formula">formula</code></td>
<td>
<p>a <code>[formula]</code> object (i.e., symbolic description
of the model)</p>
</td></tr>
<tr><td><code id="svyreg_tukeyM_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svyreg_tukeyM_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="svyreg_tukeyM_+3A_var">var</code></td>
<td>
<p>a one-sided <code>[formula]</code> object or variable name
(<code>[character]</code>) that defines the heteroscedastic variance
or <code>[NULL]</code> indicating homoscedastic variance (default:
<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="svyreg_tukeyM_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_tukeyM_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="svyreg_tukeyM_+3A_type">type</code></td>
<td>
<p><code>[character]</code> <code>"Mallows"</code> or <code>"Schweppe"</code>.</p>
</td></tr>
<tr><td><code id="svyreg_tukeyM_+3A_xwgt">xwgt</code></td>
<td>
<p><code>[numerical vector]</code> or <code>[NULL]</code> of weights in the
design space (default: <code>NULL</code>); <code>xwgt</code> is only relevant for
<code>type = "Mallows"</code> or <code>type = "Schweppe"</code>.</p>
</td></tr>
<tr><td><code id="svyreg_tukeyM_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method (e.g., <code>maxit</code>:
maxit number of iterations, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">survey</span> must be attached to the search path in order to use
the functions (see <code><a href="base.html#topic+library">library</a></code> or <code><a href="base.html#topic+require">require</a></code>).
</p>
<p><code>svyreg_tukeyM</code> and <code>svyreg_tukeyGM</code> compute, respectively,
M- and GM-estimates of regression by iteratively re-weighted least
squares (IRWLS).  The estimate of regression scale is (by default)
computed as the (normalized) weighted median of absolute deviations
from the weighted median (MAD; see <code><a href="#topic+weighted_mad">weighted_mad</a></code>) for
each IRWLS iteration. If the weighted MAD is zero (or nearly so),
the scale is computed as the (normalized) weighted
interquartile range (IQR).
</p>

<dl>
<dt>M-estimator</dt><dd>
<p>The regression M-estimator <code>svyreg_tukeyM</code> is robust against
residual outliers (granted that the tuning constant <code>k</code> is
chosen appropriately).
</p>
</dd>
<dt>GM-estimator</dt><dd>
<p>Function <code>svyreg_huberGM</code> implements the Mallows and Schweppe
regression GM-estimator (see argument <code>type</code>).
The regression GM-estimators are robust against residual outliers
<em>and</em> outliers in the model's design space (leverage
observations; see argument <code>xwgt</code>).
</p>
</dd>
<dt>Numerical optimization</dt><dd>
<p>See <code><a href="#topic+svyreg_control">svyreg_control</a></code>.
</p>
</dd>
<dt>Models</dt><dd>
<p>Models for <code>svyreg_rob</code> are specified symbolically. A typical
model has the form <code>response ~ terms</code>, where <code>response</code>
is the (numeric) response vector and <code>terms</code> is a series of
terms which specifies a linear predictor for <code>response</code>; see
<code><a href="stats.html#topic+formula">formula</a></code> and <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
<p>A formula has an implied intercept term. To remove this use
either <code>y ~ x - 1</code> or <code>y ~ 0 + x</code>; see
<code><a href="stats.html#topic+formula">formula</a></code> for more details of allowed formulae.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class <code>svyreg.rob</code>
</p>


<h3>Failure of convergence</h3>

<p>By default, the method assumes a maximum number of <code>maxit = 100</code>
iterations and a numerical tolerance criterion to stop the iterations of
<code>tol = 1e-05</code>. If the algorithm fails to converge, you may
consider changing the default values; see <code><a href="#topic+svyreg_control">svyreg_control</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svyreg_rob">summary</a></code>, <code><a href="#topic+svyreg_rob">coef</a></code>,
<code><a href="#topic+svyreg_rob">residuals</a></code>, <code><a href="#topic+svyreg_rob">fitted</a></code>,
<code><a href="#topic+svyreg_rob">SE</a></code> and <code><a href="#topic+svyreg_rob">vcov</a></code>
</p>
<p><code><a href="#topic+svyreg_rob">plot</a></code> for regression diagnostic plot methods.
</p>
<p>Other robust estimating methods <code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code> and
<code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

# Compute regression M-estimate with Tukey bisquare psi-function
m &lt;- svyreg_tukeyM(payroll ~ employment, dn, k = 8)

# Regression inference
summary(m)

# Extract the coefficients
coef(m)

# Extract variance/ covariance matrix
vcov(m)

# Diagnostic plots (e.g., standardized residuals against fitted values)
plot(m, which = 1L)

# Plot of the robustness weights of the M-estimate against its residuals
plot(residuals(m), robweights(m))
</code></pre>

<hr>
<h2 id='svysummary'>Weighted Five-Number Summary of a Variable</h2><span id='topic+svysummary'></span>

<h3>Description</h3>

<p>Weighted five-number summary used for <code>survey.design</code> and
<code>survey.design2</code> objects (similar to <code>base::summary</code>
for <code>[numeric vectors]</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svysummary(object, design, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svysummary_+3A_object">object</code></td>
<td>
<p>one-sided <code>[formula]</code> for which a summary is desired,
e.g., <code>~payroll</code>.</p>
</td></tr>
<tr><td><code id="svysummary_+3A_design">design</code></td>
<td>
<p>an object of class <code>survey.design</code>; see
<code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="svysummary_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="svysummary_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted five-number summary (numeric variable) or a frequency table
(factor variable).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library(survey)
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }

svysummary(~payroll, dn)
</code></pre>

<hr>
<h2 id='weighted_IQR'>Weighted Interquartile Range (IQR)</h2><span id='topic+weighted_IQR'></span>

<h3>Description</h3>

<p>Weighted (normalized) interquartile range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_IQR(x, w, na.rm = FALSE, constant = 0.7413)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_IQR_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted_IQR_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_IQR_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values
should be removed before the computation proceeds
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_IQR_+3A_constant">constant</code></td>
<td>
<p><code>[double]</code> constant scaling factor to make the
weighted IQR a consistent estimator of the scale
(default: <code>0.7413</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the weighted IQR is normalized to be an unbiased estimate of
scale at the Gaussian core model. If normalization is not wanted, put
<code>constant = 1</code>.
</p>


<h3>Value</h3>

<p>Weighted IQR
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# normalized weighted IQR (default)
weighted_IQR(workplace$employment, workplace$weight)

# weighted IQR (without normalization)
weighted_IQR(workplace$employment, workplace$weight, constant = 1)
</code></pre>

<hr>
<h2 id='weighted_line'>Weighted Robust Line Fitting</h2><span id='topic+weighted_line'></span><span id='topic+print.medline'></span><span id='topic+coef.medline'></span><span id='topic+residuals.medline'></span><span id='topic+fitted.medline'></span>

<h3>Description</h3>

<p><code>weighted_line</code> fits a robust line and allows weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_line(x, y = NULL, w, na.rm = FALSE, iter = 1)

## S3 method for class 'medline'
print(x, ...)
## S3 method for class 'medline'
coef(object, ...)
## S3 method for class 'medline'
residuals(object, ...)
## S3 method for class 'medline'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_line_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> explanatory variable.</p>
</td></tr>
<tr><td><code id="weighted_line_+3A_y">y</code></td>
<td>
<p><code>[numeric vector]</code> response variable (default: <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="weighted_line_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_line_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_line_+3A_iter">iter</code></td>
<td>
<p><code>[integer]</code> number of iterations to use (default:
<code>1</code>).</p>
</td></tr>
<tr><td><code id="weighted_line_+3A_object">object</code></td>
<td>
<p>object of class <code>medline</code>.</p>
</td></tr>
<tr><td><code id="weighted_line_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weighted_line</code> uses different quantiles for splitting the sample
than <code>stats::line()</code>.
</p>


<h3>Value</h3>

<p>intercept and slope of the fitted line
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="stats.html#topic+line">line</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(cars)

# compute weighted line
weighted_line(cars$speed, cars$dist, w = rep(1, length(cars$speed)))
m &lt;- weighted_line(cars$speed, cars$dist, w = rep(1:10, each = 5))
m
coef(m)
residuals(m)
fitted(m)
</code></pre>

<hr>
<h2 id='weighted_mad'>Weighted Median Absolute Deviation from the Median (MAD)</h2><span id='topic+weighted_mad'></span>

<h3>Description</h3>

<p>Weighted median of the absolute deviations from the weighted median
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mad(x, w, na.rm = FALSE, constant = 1.482602)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_mad_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted_mad_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_mad_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values
should be removed before the computation proceeds
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_mad_+3A_constant">constant</code></td>
<td>
<p><code>[double]</code> constant scaling factor to make the
MAD a consistent estimator of the scale (default: <code>1.4826</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weighted MAD is computed as the (normalized) weighted median of the
absolute deviation from the weighted median; see
<code><a href="#topic+weighted_median">weighted_median</a></code>.  The weighted MAD is normalized to be
an unbiased estimate of scale at the Gaussian core model. If
normalization is not wanted, put <code>constant = 1</code>.
</p>


<h3>Value</h3>

<p>Weighted median absolute deviation from the (weighted) median
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# normalized weighted MAD (default)
weighted_mad(workplace$employment, workplace$weight)

# weighted MAD (without normalization)
weighted_mad(workplace$employment, workplace$weight, constant = 1)
</code></pre>

<hr>
<h2 id='weighted_mean'>Weighted Total and Mean (Horvitz-Thompson and Hajek Estimators)</h2><span id='topic+weighted_mean'></span><span id='topic+weighted_total'></span>

<h3>Description</h3>

<p>Weighted total and mean (Horvitz-Thompson and Hajek estimators)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mean(x, w, na.rm = FALSE)
weighted_total(x, w, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_mean_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values
should be removed before the computation proceeds
(default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weighted_total</code> and <code>weighted_mean</code> compute, respectively,
the Horvitz-Thompson estimator of the population total and the Hajek
estimator of the population mean.
</p>


<h3>Value</h3>

<p>Estimated population mean or total
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# Horvitz-Thompson estimator of the total
weighted_total(workplace$employment, workplace$weight)

# Hajek estimator of the mean
weighted_mean(workplace$employment, workplace$weight)
</code></pre>

<hr>
<h2 id='weighted_mean_dalen'>Dalen Estimators of the Mean and Total</h2><span id='topic+weighted_mean_dalen'></span><span id='topic+weighted_total_dalen'></span>

<h3>Description</h3>

<p>Dalén's estimators of the population mean and the population total
(bare-bone functions with limited functionality).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mean_dalen(x, w, censoring, type = "Z2", info = FALSE,
                    na.rm = FALSE, verbose = TRUE)
weighted_total_dalen(x, w, censoring, type = "Z2", info = FALSE,
                     na.rm = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_mean_dalen_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted_mean_dalen_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_dalen_+3A_censoring">censoring</code></td>
<td>
<p><code>[double]</code> cutoff threshold above which the
observations are censored.</p>
</td></tr>
<tr><td><code id="weighted_mean_dalen_+3A_type">type</code></td>
<td>
<p><code>[character]</code> type of estimator; either <code>"Z2"</code> or
<code>"Z3"</code> (default: <code>"Z2"</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_dalen_+3A_info">info</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
should be returned (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_dalen_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should be
removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_dalen_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
should be printed to the console (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\sum_{i \in s} w_ix_i</code> denote the expansion
estimator of the <code class="reqn">x</code>-total (summation is over all elements <code class="reqn">i</code>
in sample <code class="reqn">s</code>). The estimators Z2 and Z3 of Dalén (1987) are
defined as follows.
</p>

<dl>
<dt>Estimator Z2</dt><dd>
<p>The estimator Z2 of the population total sums over
<code class="reqn">\min(c, w_ix_i)</code>; hence, it
censors the products <code class="reqn">w_ix_i</code> to the
censoring constant <code class="reqn">c</code> (<code>censoring</code>). The estimator of
the population <code class="reqn">x</code>-mean is is defined as the total divided
by the population size.
</p>
</dd>
<dt>Estimator Z3</dt><dd>
<p>The estimator Z3 of the population total is defined as the sum
over the elements <code class="reqn">z_i</code>, which is equal to
<code class="reqn">z_i = w_ix_i</code>
if <code class="reqn">w_iy_i \leq c</code> and
<code class="reqn">z_i = c + (y_i - c/w_i)</code>
otherwise.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>The return value depends on <code>info</code>:
</p>

<dl>
<dt><code>info = FALSE</code>:</dt><dd><p>estimate of mean or total <code>[double]</code></p>
</dd>
<dt><code>info = TRUE</code>:</dt><dd><p>a <code>[list]</code> with items:
</p>

<ul>
<li> <p><code>characteristic</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimator</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimate</code> <code>[double]</code>,
</p>
</li>
<li> <p><code>variance</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>robust</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>residuals</code> <code>[numeric vector]</code>,
</p>
</li>
<li> <p><code>model</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>design</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>[call]</code>
</p>
</li></ul>

</dd>
</dl>



<h3>References</h3>

<p>Dalén, J. (1987). Practical Estimators of a Population Total Which Reduce
the Impact of Large Observations. R &amp; D Report U/STM 1987:32, Statistics
Sweden, Stockholm.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# Dalen's estimator of the total (with censoring threshold: 100000)
weighted_total_dalen(workplace$employment, workplace$weight, 100000)
</code></pre>

<hr>
<h2 id='weighted_mean_trimmed'>Weighted Trimmed Mean and Total (bare-bone functions)</h2><span id='topic+weighted_mean_trimmed'></span><span id='topic+weighted_total_trimmed'></span>

<h3>Description</h3>

<p>Weighted trimmed mean and total (bare-bone functions with limited
functionality; see <code><a href="#topic+svymean_trimmed">svymean_trimmed</a></code> and
<code><a href="#topic+svytotal_trimmed">svytotal_trimmed</a></code> for more capable methods)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mean_trimmed(x, w, LB = 0.05, UB = 1 - LB, info = FALSE,
                      na.rm = FALSE)
weighted_total_trimmed(x, w, LB = 0.05, UB = 1 - LB, info = FALSE,
                       na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_mean_trimmed_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted_mean_trimmed_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_trimmed_+3A_lb">LB</code></td>
<td>
<p><code>[double]</code> lower bound of trimming such that
<code class="reqn">0 \leq</code> <code>LB</code> <code class="reqn">&lt;</code> <code>UB</code> <code class="reqn">\leq 1</code>.</p>
</td></tr>
<tr><td><code id="weighted_mean_trimmed_+3A_ub">UB</code></td>
<td>
<p><code>[double]</code> upper bound of trimming such that
<code class="reqn">0 \leq</code> <code>LB</code> <code class="reqn">&lt;</code> <code>UB</code> <code class="reqn">\leq 1</code>.</p>
</td></tr>
<tr><td><code id="weighted_mean_trimmed_+3A_info">info</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
should be returned (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_trimmed_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Characteristic.</dt><dd><p>Population mean or total. Let <code class="reqn">\mu</code> denote
the estimated trimmed population mean; then, the estimated trimmed
population total is given by <code class="reqn">\hat{N} \mu</code> with
<code class="reqn">\hat{N} =\sum w_i</code>, where
summation is over all observations in the sample.</p>
</dd>
<dt>Trimming.</dt><dd><p>The methods trims the <code>LB</code><code class="reqn">~\cdot 100\%</code>
of the smallest observations and the
(1 - <code>UB</code>)<code class="reqn">~\cdot 100\%</code> of the largest observations
from the data.</p>
</dd>
<dt>Variance estimation.</dt><dd><p>See survey methods:
</p>

<ul>
<li> <p><code><a href="#topic+svymean_trimmed">svymean_trimmed</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+svytotal_trimmed">svytotal_trimmed</a></code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>The return value depends on <code>info</code>:
</p>

<dl>
<dt><code>info = FALSE</code>:</dt><dd><p>estimate of mean or total <code>[double]</code></p>
</dd>
<dt><code>info = TRUE</code>:</dt><dd><p>a <code>[list]</code> with items:
</p>

<ul>
<li> <p><code>characteristic</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimator</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimate</code> <code>[double]</code>,
</p>
</li>
<li> <p><code>variance</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>robust</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>residuals</code> <code>[numeric vector]</code>,
</p>
</li>
<li> <p><code>model</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>design</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>[call]</code>
</p>
</li></ul>

</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svymean_trimmed">svymean_trimmed</a></code> and <code><a href="#topic+svytotal_trimmed">svytotal_trimmed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# Estimated trimmed population total (5% symmetric trimming)
weighted_total_trimmed(workplace$employment, workplace$weight, LB = 0.05,
    UB = 0.95)

# Estimated trimmed population mean (5% trimming at the top of the distr.)
weighted_mean_trimmed(workplace$employment, workplace$weight, UB = 0.95)
</code></pre>

<hr>
<h2 id='weighted_mean_winsorized'>Weighted Winsorized Mean and Total (bare-bone functions)</h2><span id='topic+weighted_mean_winsorized'></span><span id='topic+weighted_mean_k_winsorized'></span><span id='topic+weighted_total_winsorized'></span><span id='topic+weighted_total_k_winsorized'></span>

<h3>Description</h3>

<p>Weighted winsorized mean and total (bare-bone functions with limited
functionality; see <code><a href="#topic+svymean_winsorized">svymean_winsorized</a></code> and
<code><a href="#topic+svytotal_winsorized">svytotal_winsorized</a></code> for more capable methods)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mean_winsorized(x, w, LB = 0.05, UB = 1 - LB, info = FALSE,
                         na.rm = FALSE)
weighted_mean_k_winsorized(x, w, k, info = FALSE, na.rm = FALSE)
weighted_total_winsorized(x, w, LB = 0.05, UB = 1 - LB, info = FALSE,
                          na.rm = FALSE)
weighted_total_k_winsorized(x, w, k, info = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_mean_winsorized_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted_mean_winsorized_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_winsorized_+3A_lb">LB</code></td>
<td>
<p><code>[double]</code> lower bound of winsorization such that
<code class="reqn">0 \leq</code> <code>LB</code> <code class="reqn">&lt;</code> <code>UB</code> <code class="reqn">\leq 1</code>.</p>
</td></tr>
<tr><td><code id="weighted_mean_winsorized_+3A_ub">UB</code></td>
<td>
<p><code>[double]</code> upper bound of winsorization such that
<code class="reqn">0 \leq</code> <code>LB</code> <code class="reqn">&lt;</code> <code>UB</code> <code class="reqn">\leq 1</code>.</p>
</td></tr>
<tr><td><code id="weighted_mean_winsorized_+3A_info">info</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
should be returned (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_winsorized_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_mean_winsorized_+3A_k">k</code></td>
<td>
<p><code>[integer]</code> number of observations to be winsorized at the
top of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Characteristic.</dt><dd><p>Population mean or total. Let <code class="reqn">\mu</code>
denote the estimated winsorized population mean; then, the
estimated population total is given by <code class="reqn">\hat{N} \mu</code>
with <code class="reqn">\hat{N} =\sum w_i</code>, where summation
is over all observations in the sample.</p>
</dd>
<dt>Modes of winsorization.</dt><dd><p>The amount of winsorization can be
specified in relative or absolute terms:
</p>

<ul>
<li> <p><em>Relative:</em> By specifying <code>LB</code> and <code>UB</code>,
the methods winsorizes the <code>LB</code><code class="reqn">~\cdot 100\%</code>
of the smallest observations and the
(1 - <code>UB</code>)<code class="reqn">~\cdot 100\%</code> of the largest
observations from the data.
</p>
</li>
<li> <p><em>Absolute:</em> By specifying argument <code>k</code> in the
functions with the &quot;infix&quot; <code>_k_</code> in their name, the
largest <code class="reqn">k</code> observations are winsorized, <code class="reqn">0&lt;k&lt;n</code>,
where <code class="reqn">n</code> denotes the sample size. E.g., <code>k = 2</code>
implies that the largest and the second largest
observation are winsorized.
</p>
</li></ul>

</dd>
<dt>Variance estimation.</dt><dd><p>See survey methods:
</p>

<ul>
<li> <p><code><a href="#topic+svymean_winsorized">svymean_winsorized</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+svytotal_winsorized">svytotal_winsorized</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+svymean_k_winsorized">svymean_k_winsorized</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+svytotal_k_winsorized">svytotal_k_winsorized</a></code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>The return value depends on <code>info</code>:
</p>

<dl>
<dt><code>info = FALSE</code>:</dt><dd><p>estimate of mean or total <code>[double]</code></p>
</dd>
<dt><code>info = TRUE</code>:</dt><dd><p>a <code>[list]</code> with items:
</p>

<ul>
<li> <p><code>characteristic</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimator</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimate</code> <code>[double]</code>,
</p>
</li>
<li> <p><code>variance</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>robust</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>residuals</code> <code>[numeric vector]</code>,
</p>
</li>
<li> <p><code>model</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>design</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>[call]</code>
</p>
</li></ul>

</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svymean_winsorized">svymean_winsorized</a></code>, <code><a href="#topic+svymean_k_winsorized">svymean_k_winsorized</a></code>,
<code><a href="#topic+svytotal_winsorized">svytotal_winsorized</a></code> and <code><a href="#topic+svytotal_k_winsorized">svytotal_k_winsorized</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# Estimated winsorized population mean (5% symmetric winsorization)
weighted_mean_winsorized(workplace$employment, workplace$weight, LB = 0.05)

# Estimated one-sided k winsorized population total (2 observations are
# winsorized at the top of the distribution)
weighted_total_k_winsorized(workplace$employment, workplace$weight, k = 2)
</code></pre>

<hr>
<h2 id='weighted_median'>Weighted Median</h2><span id='topic+weighted_median'></span>

<h3>Description</h3>

<p>Weighted population median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_median(x, w, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_median_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted_median_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_median_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted sample median; see <code><a href="#topic+weighted_quantile">weighted_quantile</a></code> for more
information.
</p>


<h3>Value</h3>

<p>Weighted estimate of the population median
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+weighted_quantile">weighted_quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

weighted_median(workplace$employment, workplace$weight)
</code></pre>

<hr>
<h2 id='weighted_median_line'>Robust Simple Linear Regression Based on Medians</h2><span id='topic+weighted_median_line'></span>

<h3>Description</h3>

<p>Robust simple linear regression based on medians: two methods are available:
<code>"slopes"</code> and <code>"product"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_median_line(x, y = NULL, w, type = "slopes", na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_median_line_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> explanatory variable.</p>
</td></tr>
<tr><td><code id="weighted_median_line_+3A_y">y</code></td>
<td>
<p><code>[numeric vector]</code> response variable (default: <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="weighted_median_line_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_median_line_+3A_type">type</code></td>
<td>
<p><code>[character]</code> <code>"slopes"</code> or <code>"products"</code>
(default: <code>"slopes"</code>).</p>
</td></tr>
<tr><td><code id="weighted_median_line_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Overview.</dt><dd><p>Robust simple linear regression based on medians</p>
</dd>
<dt>Type.</dt><dd><p>Two methods/ types are available. Let <code class="reqn">m(x,w)</code>
denote the weighted median of variable <code>x</code> with weights
<code>w</code>:
</p>

<dl>
<dt><code>type = "slopes"</code>:</dt><dd><p>The slope is computed as
</p>
<p style="text-align: center;"><code class="reqn">b1 = m\left( \frac{y - m(y,w)}{x - m(x,w)}, w\right).
                        </code>
</p>

</dd>
<dt><code>type = "products"</code>:</dt><dd><p>The slope is computed as
</p>
<p style="text-align: center;"><code class="reqn">b1 = \frac{m\big([y - m(y,w)][x - m(x,w)], w\big)}
                        {m\big([x - m(x,w)]^2, w\big)}.</code>
</p>

</dd>
</dl>

</dd>
</dl>



<h3>Value</h3>

<p>A vector with two components: intercept and slope
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="stats.html#topic+line">line</a></code>, <code><a href="#topic+weighted_line">weighted_line</a></code> and
<code><a href="#topic+weighted_median_ratio">weighted_median_ratio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 4, 5)
y &lt;- c(3, 2, 7, 4)
weighted_line(y ~ x, w = rep(1, length(x)))
weighted_median_line(y ~ x, w = rep(1, length(x)))
m &lt;- weighted_median_line(y ~ x, w = rep(1, length(x)), type = "prod")
m
coef(m)
fitted(m)
residuals(m)

# cars data
head(cars)
with(cars, weighted_median_line(dist ~ speed, w = rep(1, length(dist))))
with(cars, weighted_median_line(dist ~ speed, w = rep(1, length(dist)),
type = "prod"))

# weighted
w &lt;- c(rep(1,20), rep(2,20), rep(5, 10))
with(cars, weighted_median_line(dist ~ speed, w = w))
with(cars, weighted_median_line(dist ~ speed, w = w, type = "prod"))

# outlier in y
cars$dist[49] &lt;- 360
with(cars, weighted_median_line(dist ~ speed, w = w))
with(cars, weighted_median_line(dist ~ speed, w = w, type = "prod"))

# outlier in x
data(cars)
cars$speed[49] &lt;- 72
with(cars, weighted_median_line(dist ~ speed, w = w))
with(cars, weighted_median_line(dist ~ speed, w = w, type = "prod"))
</code></pre>

<hr>
<h2 id='weighted_median_ratio'>Weighted Robust Ratio Estimator Based on Median</h2><span id='topic+weighted_median_ratio'></span>

<h3>Description</h3>

<p>A weighted median of the ratios y/x determines the slope of a regression
through the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_median_ratio(x, y = NULL, w, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_median_ratio_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> explanatory variable.</p>
</td></tr>
<tr><td><code id="weighted_median_ratio_+3A_y">y</code></td>
<td>
<p><code>[numeric vector]</code> response variable (default: <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="weighted_median_ratio_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_median_ratio_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with two components: intercept and slope
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="stats.html#topic+line">line</a></code>, <code><a href="#topic+weighted_line">weighted_line</a></code> and
<code><a href="#topic+weighted_median_line">weighted_median_line</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,2,4,5)
y &lt;- c(1,0,5,2)
m &lt;- weighted_median_ratio(y ~ x, w = rep(1, length(y)))
m
coef(m)
fitted(m)
residuals(m)
</code></pre>

<hr>
<h2 id='weighted_quantile'>Weighted Quantile</h2><span id='topic+weighted_quantile'></span>

<h3>Description</h3>

<p>Weighted population quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_quantile(x, w, probs, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_quantile_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_probs">probs</code></td>
<td>
<p><code>[numeric vector]</code> vector of probabilities with
values in <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values
should be removed before the computation proceeds
(default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Overview.</dt><dd><p><code>weighted_quantile</code> computes the weighted
sample quantiles; argument <code>probs</code> allows vector inputs.</p>
</dd>
<dt>Implementation.</dt><dd><p>The function is based on a weighted version
of the quickselect/Find algorithm with the Bentley and McIlroy
(1993) 3-way partitioning scheme. For very small arrays,
we use insertion sort.</p>
</dd>
<dt>Compatibility.</dt><dd><p>For equal weighting, i.e., when all elements in
<code>w</code> are equal, <code>weighted_quantile</code> is identical with
<code>type = 2</code> of <code>stats::quantile</code>; see also
Hyndman and Fan (1996).</p>
</dd>
</dl>



<h3>Value</h3>

<p>Weighted estimate of the population quantiles
</p>


<h3>References</h3>

<p>Bentley, J. L. and McIlroy, D. M. (1993). Engineering a Sort Function,
<em>Software - Practice and Experience</em> <b>23</b>, 1249&ndash;1265.
<a href="https://doi.org/10.1002/spe.4380231105">doi:10.1002/spe.4380231105</a>
</p>
<p>Hyndman, R.J. and Fan, Y. (1996). Sample Quantiles in Statistical Packages,
<em>The American Statistician</em> <b>50</b>, 361&ndash;365.
<a href="https://doi.org/10.1080/00031305.1996.10473566">doi:10.1080/00031305.1996.10473566</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+weighted_median">weighted_median</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# Weighted 25% quantile (1st quartile)
weighted_quantile(workplace$employment, workplace$weight, 0.25)
</code></pre>

<hr>
<h2 id='weighted-m-estimator'>Weighted Huber and Tukey Mean and Total (bare-bone functions)</h2><span id='topic+weighted_mean_huber'></span><span id='topic+weighted_total_huber'></span><span id='topic+weighted_mean_tukey'></span><span id='topic+weighted_total_tukey'></span>

<h3>Description</h3>

<p>Weighted Huber and Tukey <em>M</em>-estimator of the mean and total
(bare-bone function with limited functionality; see
<code><a href="#topic+svymean_huber">svymean_huber</a></code>,  <code><a href="#topic+svymean_tukey">svymean_tukey</a></code>,
<code><a href="#topic+svytotal_huber">svytotal_huber</a></code>, and <code><a href="#topic+svytotal_tukey">svytotal_tukey</a></code> for more
capable methods)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mean_huber(x, w, k, type = "rwm", asym = FALSE, info = FALSE,
                    na.rm = FALSE, verbose = TRUE, ...)
weighted_total_huber(x, w, k, type = "rwm", asym = FALSE, info = FALSE,
                     na.rm = FALSE, verbose = TRUE, ...)
weighted_mean_tukey(x, w, k, type = "rwm", info = FALSE, na.rm = FALSE,
                    verbose = TRUE, ...)
weighted_total_tukey(x, w, k, type = "rwm", info = FALSE, na.rm = FALSE,
                     verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted-m-estimator_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="weighted-m-estimator_+3A_w">w</code></td>
<td>
<p><code>[numeric vector]</code> weights (same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="weighted-m-estimator_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="weighted-m-estimator_+3A_type">type</code></td>
<td>
<p><code>[character]</code> type of method: <code>"rwm"</code> or
<code>"rht"</code>; see below (default: <code>"rwm"</code>).</p>
</td></tr>
<tr><td><code id="weighted-m-estimator_+3A_asym">asym</code></td>
<td>
<p><code>[logical]</code> toggle for asymmetric Huber psi-function
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted-m-estimator_+3A_info">info</code></td>
<td>
<p><code>[logical]</code> indicating whether additional information
should be returned (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted-m-estimator_+3A_na.rm">na.rm</code></td>
<td>
<p><code>[logical]</code> indicating whether <code>NA</code> values should
be removed before the computation proceeds (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted-m-estimator_+3A_verbose">verbose</code></td>
<td>
<p><code>[logical]</code> indicating whether additional
information is printed to the console (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="weighted-m-estimator_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method (e.g.,
<code>maxit</code>: maxit number of iterations, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Characteristic.</dt><dd><p>Population mean or total. Let <code class="reqn">\mu</code>
denote the estimated population mean; then, the estimated
total is given by <code class="reqn">\hat{N} \mu</code> with
<code class="reqn">\hat{N} =\sum w_i</code>, where
summation is over all observations in the sample.</p>
</dd>
<dt>Type.</dt><dd><p>Two methods/types are available for estimating the
location <code class="reqn">\mu</code>:
</p>

<dl>
<dt><code>type = "rwm" (default)</code>:</dt><dd><p>robust weighted
<em>M</em>-estimator of the population mean and total,
respectively. This estimator is recommended for sampling
designs whose inclusion probabilities are <em>not</em>
proportional to some measure of size. [Legacy note: In an
earlier version, the method <code>type = "rwm"</code> was called
<code>"rhj"</code>; the type <code>"rhj"</code> is now silently
converted to <code>"rwm"</code>]
</p>
</dd>
<dt><code>type = "rht"</code>:</dt><dd><p>robust Horvitz-Thompson
<em>M</em>-estimator of the population mean and total,
respectively. This estimator is recommended for
proportional-to-size sampling designs.</p>
</dd>
</dl>

</dd>
<dt>Variance estimation.</dt><dd><p>See the related but more capable
functions:
</p>

<ul>
<li> <p><code><a href="#topic+svymean_huber">svymean_huber</a></code> and
<code><a href="#topic+svymean_tukey">svymean_tukey</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+svytotal_huber">svytotal_huber</a></code> and
<code><a href="#topic+svytotal_tukey">svytotal_tukey</a></code>.
</p>
</li></ul>

</dd>
<dt>Psi-function.</dt><dd><p>By default, the <code>Huber</code> or <code>Tukey</code>
psi-function are used in the specification of the M-estimators. For
the Huber estimator, an asymmetric version of the Huber
psi-function can be used by setting the argument
<code>asym = TRUE</code> in the function call.</p>
</dd>
</dl>



<h3>Value</h3>

<p>The return value depends on <code>info</code>:
</p>

<dl>
<dt><code>info = FALSE</code>:</dt><dd><p>estimate of mean or total <code>[double]</code></p>
</dd>
<dt><code>info = TRUE</code>:</dt><dd><p>a <code>[list]</code> with items:
</p>

<ul>
<li> <p><code>characteristic</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimator</code> <code>[character]</code>,
</p>
</li>
<li> <p><code>estimate</code> <code>[double]</code>,
</p>
</li>
<li> <p><code>variance</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>robust</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>residuals</code> <code>[numeric vector]</code>,
</p>
</li>
<li> <p><code>model</code> <code>[list]</code>,
</p>
</li>
<li> <p><code>design</code> (default: <code>NA</code>),
</p>
</li>
<li> <p><code>[call]</code>
</p>
</li></ul>

</dd>
</dl>



<h3>Failure of convergence</h3>

<p>By default, the method assumes a maximum number of <code>maxit = 100</code>
iterations and a numerical tolerance criterion to stop the iterations of
<code>tol = 1e-05</code>. If the algorithm fails to converge, you may
consider changing the default values; see <code><a href="#topic+svyreg_control">svyreg_control</a></code>.
</p>


<h3>References</h3>

<p>Hulliger, B. (1995). Outlier Robust Horvitz-Thompson Estimators.
<em>Survey Methodology</em> <b>21</b>, 79&ndash;87.
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

# Robust Horvitz-Thompson M-estimator of the population total
weighted_total_huber(workplace$employment, workplace$weight, k = 9,
    type = "rht")

# Robust weighted M-estimator of the population mean
weighted_mean_huber(workplace$employment, workplace$weight, k = 12,
    type = "rwm")
</code></pre>

<hr>
<h2 id='wgt_functions'>Weight Functions (for the M- and GM-Estimators)</h2><span id='topic+huberWgt'></span><span id='topic+tukeyWgt'></span><span id='topic+simpsonWgt'></span>

<h3>Description</h3>

<p>Weight functions associated with the Huber and the Tukey biweight
psi-functions; and the weight function of Simpson et al. (1992)
for GM-estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huberWgt(x, k = 1.345)
tukeyWgt(x, k = 4.685)
simpsonWgt(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wgt_functions_+3A_x">x</code></td>
<td>
<p><code>[numeric vector]</code> data.</p>
</td></tr>
<tr><td><code id="wgt_functions_+3A_k">k</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; k \leq \infty</code>).</p>
</td></tr>
<tr><td><code id="wgt_functions_+3A_a">a</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 \leq a \leq \infty</code>); see details below.</p>
</td></tr>
<tr><td><code id="wgt_functions_+3A_b">b</code></td>
<td>
<p><code>[double]</code> robustness tuning constant
(<code class="reqn">0 &lt; b \leq \infty</code>; see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>huberWgt</code> and <code>tukeyWgt</code> return the weights
associated with the respective psi-function.
</p>
<p>The function <code>simpsonWgt</code> is used (in regression GM-estimators)
to downweight leverage observations (i.e., outliers in the model's design
space). Let <code class="reqn">d_i</code> denote the (robust) squared Mahalanobis
distance of the i-th observation. The Simpson et al. (1992) type of
weight is defined as
<code class="reqn">\min \{1, (b/d_i)^{a/2}\}</code>, where
<code>a</code> and <code>b</code> are tuning constants.
</p>

<ul>
<li><p> By default, <code>a = 1</code>; this choice implies that the weights
are computed on the basis of the robust Mahalanobis distances.
Alternative: <code>a = Inf</code> implies a weight of zero for all
observations whose (robust) squared Mahalanobis is larger than
<code>b</code>.
</p>
</li>
<li><p> The tuning constants <code>b</code> is a threshold on the distances.
</p>
</li></ul>



<h3>Value</h3>

<p>Numerical vector of weights
</p>


<h3>References</h3>

<p>Simpson, D. G., Ruppert, D. and Carroll, R.J. (1992). On One-Step GM
Estimates and Stability of Inferences in Linear Regression.
<em>Journal of the American Statistical Association</em> <b>87</b>, 439&ndash;450.
<a href="https://doi.org/10.2307/2290275">doi:10.2307/2290275</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+robsurvey-package">Overview</a> (of all implemented functions)
</p>
<p><code><a href="#topic+svyreg_huberM">svyreg_huberM</a></code>, <code><a href="#topic+svyreg_huberGM">svyreg_huberGM</a></code>,
<code><a href="#topic+svyreg_tukeyM">svyreg_tukeyM</a></code> and <code><a href="#topic+svyreg_tukeyGM">svyreg_tukeyGM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(flour)

# standardized distance from median (copper content in wholemeal flour)
x &lt;- flour$copper
z &lt;- abs(x - median(x)) / mad(x)

# plot of weight functions vs. distance
plot(z, huberWgt(z, k = 3), ylim = c(0, 1), xlab = "distance",
     ylab = "weight")
points(z, tukeyWgt(z, k = 6), pch = 2, col = 2)
points(z, simpsonWgt(z, a = Inf, b = 3), pch = 3, col = 4)
legend("topright", c("huberWgt(k = 3)", "tukeyWgt(k = 6)",
       "simpsonWgt(a = Inf, b = 3)"), pch = 1:3, col = c(1, 2, 4))
</code></pre>

<hr>
<h2 id='workplace'>(Modified) Canadian Workplace and Employee Survey</h2><span id='topic+workplace'></span>

<h3>Description</h3>

<p>The <code>workplace</code> data are from Fuller (2009, pp. 366&ndash;367).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(workplace)</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with a sample of 142 workplaces on the following
variables
</p>

<dl>
<dt><code>ID</code></dt><dd><p>identifier variable <code>[integer]</code>.</p>
</dd>
<dt><code>weight</code></dt><dd><p>sampling weight <code>[double]</code>.</p>
</dd>
<dt><code>employment</code></dt><dd><p>employment total <code>[double]</code>.</p>
</dd>
<dt><code>payroll</code></dt><dd><p>payroll total (1000 dollars)<code>[double]</code>.</p>
</dd>
<dt><code>strat</code></dt><dd><p>stratum identifier<code>[integer]</code>.</p>
</dd>
<dt><code>fpc</code></dt><dd><p>finite population correction <code>[integer]</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The <code>workplace</code> data represent a sample of workplaces in the
retail sector in a Canadian province. The data are <em>not</em> those
collected by Statistics Canada, but have been generated by Fuller
(2009, Example 3.1.1) to display similar characteristics to the
original 1999 Canadian Workplace and Employee Survey (WES).
</p>


<h4>Sampling design of the 1999 WES</h4>

<p>The WES target population is defined as all workplaces operating in
Canada with paid employees. The sampling frame is stratified by
industry, geographic region, and size (size is defined using
estimated employment). A sample of workplaces has been drawn
independently in each stratum using simple random sample without
replacement (the stratum-specific sample sizes are determined
by Neyman allocation).
Several strata containing very large workplaces were sampled
exhaustively; see Patak et al (1998). The original sampling weights
were adjusted for nonresponse.
</p>



<h4>Remarks by Fuller (2009, p. 365)</h4>

<p>The original weights of WES
were about 2200 for the stratum of small workplaces, about 750 for
medium-sized, and about 35 for large workspaces.</p>



<h3>Source</h3>

<p>The data <code>workplace</code> is from Table 6.3 in Fuller (2009, pp. 366&ndash;367).
</p>


<h3>References</h3>

<p>Fuller, W. A. (2009). <em>Sampling Statistics</em>,
Hoboken (NJ): John Wiley and Sons.
<a href="https://doi.org/10.1002/9780470523551">doi:10.1002/9780470523551</a>
</p>
<p>Patak, Z., Hidiroglou, M. and Lavallée, P. (1998). The methodology of the
Workplace and Employee Survey. <em>Proceedings of the Survey
Research Methods Section, American Statistical Association</em>, 83&ndash;91.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(workplace)

library("survey")
# Survey design for stratified simple random sampling without replacement
dn &lt;- if (packageVersion("survey") &gt;= "4.2") {
        # survey design with pre-calibrated weights
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace, calibrate.formula = ~-1 + strat)
    } else {
        # legacy mode
        svydesign(ids = ~ID, strata = ~strat, fpc = ~fpc, weights = ~weight,
                  data = workplace)
    }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
