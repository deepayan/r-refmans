<!DOCTYPE html><html lang="en"><head><title>Help for package bivrp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bivrp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bivrp-package'>
<p>Bivariate Residual Plots with Simulation Polygons</p></a></li>
<li><a href='#bivrp'><p>Bivariate Residual Plots with Simulation Polygons</p></a></li>
<li><a href='#is_point_inside'><p>Determine if point is inside or outside a simple polygon area</p></a></li>
<li><a href='#plot.bivrp'><p>Plot Method for bivrp Objects</p></a></li>
<li><a href='#polygon-operations'><p>Polygon operations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bivariate Residual Plots with Simulation Polygons</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Rafael de Andrade Moral [aut, cre],
  John Hinde [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rafael de Andrade Moral &lt;rafael.deandrademoral@mu.ie&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), MASS (&ge; 7.3-35), methods, graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm (&ge; 1.0-3), mrfDepth (&ge; 1.0.10)</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates bivariate residual plots with simulation polygons for any diagnostics and bivariate model from which functions to extract the desired diagnostics, simulate new data and refit the models are available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-01 12:27:57 UTC; rafael</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-01 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bivrp-package'>
Bivariate Residual Plots with Simulation Polygons
</h2><span id='topic+bivrp-package'></span>

<h3>Description</h3>

<p>Generates bivariate residual plots with simulation polygons for any diagnostics and bivariate model from which functions to extract the desired diagnostics, simulate new data and refit the models are available.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bivrp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Bivariate Residual Plots with Simulation Polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-04-01</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Rafael", "de Andrade Moral", role = c("aut", "cre"), email = "rafael.deandrademoral@mu.ie"), person("John", "Hinde", role = "aut"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Rafael de Andrade Moral [aut, cre], John Hinde [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Rafael de Andrade Moral &lt;rafael.deandrademoral@mu.ie&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0), MASS (&gt;= 7.3-35), methods, graphics, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> mvtnorm (&gt;= 1.0-3), mrfDepth (&gt;= 1.0.10)</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Generates bivariate residual plots with simulation polygons for any diagnostics and bivariate model from which functions to extract the desired diagnostics, simulate new data and refit the models are available.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
bivrp                   Bivariate Residual Plots with Simulation
                        Polygons
bivrp-package           Bivariate Residual Plots with Simulation
                        Polygons
is_point_inside         Determine if point is inside or outside a
                        simple polygon area
plot.bivrp              Plot Method for bivrp Objects
polygon_area            Polygon operations
</pre>


<h3>Author(s)</h3>

<p>Rafael de Andrade Moral [aut, cre], John Hinde [aut]
</p>
<p>Maintainer: Rafael de Andrade Moral &lt;rafael.deandrademoral@mu.ie&gt;
</p>

<hr>
<h2 id='bivrp'>Bivariate Residual Plots with Simulation Polygons</h2><span id='topic+bivrp'></span><span id='topic+print.bivrp'></span>

<h3>Description</h3>

<p>Produces a bivariate residual plot with simulation polygons to assess goodness-of-fit of bivariate statistical models, provided the user supplies three functions: one to obtain model diagnostics, one to simulate data from a fitted model object, and one to refit the model to simulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivrp(obj, sim = 99, conf = .95, diagfun, simfun, fitfun, verb = FALSE,
      sort.res = TRUE, closest.angle = TRUE, angle.ref = - pi,
      counter.clockwise = TRUE, xlab, ylab, main,
      clear.device = FALSE, point.col, point.pch, ...)
      
## S3 method for class 'bivrp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivrp_+3A_obj">obj</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="bivrp_+3A_sim">sim</code></td>
<td>
<p>number of simulations used to compute envelope. Default is 99</p>
</td></tr>
<tr><td><code id="bivrp_+3A_conf">conf</code></td>
<td>
<p>confidence level of the simulated polygons. Default is 0.95</p>
</td></tr>
<tr><td><code id="bivrp_+3A_diagfun">diagfun</code></td>
<td>
<p>user-defined function used to obtain the diagnostic measures from the fitted model object</p>
</td></tr>
<tr><td><code id="bivrp_+3A_simfun">simfun</code></td>
<td>
<p>user-defined function used to simulate a random sample from the model estimated parameters</p>
</td></tr>
<tr><td><code id="bivrp_+3A_fitfun">fitfun</code></td>
<td>
<p>user-defined function used to re-fit the model to simulated data</p>
</td></tr>
<tr><td><code id="bivrp_+3A_verb">verb</code></td>
<td>
<p>logical. If <code>TRUE</code>, prints each step of the simulation procedure</p>
</td></tr>
<tr><td><code id="bivrp_+3A_sort.res">sort.res</code></td>
<td>
<p>logical. If <code>TRUE</code>, points will be sorted using angles formed with the origin (type of ordering can be fine-tuned with arguments <code>closest.angle</code>, <code>angle.ref</code> and <code>counter.clockwise</code>).</p>
</td></tr>
<tr><td><code id="bivrp_+3A_closest.angle">closest.angle</code></td>
<td>
<p>logical. If <code>FALSE</code>, points will be sorted starting from the angle defined in <code>angle.ref</code>, if <code>TRUE</code>, points will be sorted starting from the closest angle to the observed bivariate sample ranked as first</p>
</td></tr>
<tr><td><code id="bivrp_+3A_angle.ref">angle.ref</code></td>
<td>
<p>the reference angle from which points will be sorted starting from the closest angle to the input (in radians). Defaults to <code>- pi</code></p>
</td></tr>
<tr><td><code id="bivrp_+3A_counter.clockwise">counter.clockwise</code></td>
<td>
<p>logical. Should the points be ordered counter-clockwise or clockwise from the reference angle?</p>
</td></tr>
<tr><td><code id="bivrp_+3A_xlab">xlab</code></td>
<td>
<p>argument passed to <code>par</code></p>
</td></tr>
<tr><td><code id="bivrp_+3A_ylab">ylab</code></td>
<td>
<p>argument passed to <code>par</code></p>
</td></tr>
<tr><td><code id="bivrp_+3A_main">main</code></td>
<td>
<p>argument passed to <code>par</code></p>
</td></tr>
<tr><td><code id="bivrp_+3A_clear.device">clear.device</code></td>
<td>
<p>logical. If <code>TRUE</code>, clears the plotting device after producing the bivariate residual plot with simulation polygons</p>
</td></tr>
<tr><td><code id="bivrp_+3A_point.col">point.col</code></td>
<td>
<p>a vector of length 2 with the colors of the points that are inside and outside of the simulated polygons</p>
</td></tr>
<tr><td><code id="bivrp_+3A_point.pch">point.pch</code></td>
<td>
<p>a vector of length 2 with the point characters of the points that are inside and outside of the simulated polygons</p>
</td></tr>
<tr><td><code id="bivrp_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+plot.bivrp">plot.bivrp</a></code></p>
</td></tr>
<tr><td><code id="bivrp_+3A_x">x</code></td>
<td>
<p>an object of class <code>bivrp</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This approach relies on the same strategy used for producing half-normal plots with simulation envelopes. Given a vector of bivariate model diagnostics, the angle each point makes with the origin is calculated to order them. This can be fine-tuned using the logical arguments <code>closest.angle</code>, <code>angle.ref</code>, and <code>counter.clockwise</code>, see the Arguments section above.
</p>
<p>Then, <code>sim</code> bivariate response variables are simulated from the fitted model, using the same model matrices, error distribution and fitted parameters, using the function defined as <code>simfun</code>. The model is refitted to each simulated sample, using the function defined as <code>fitfun</code>. Next, we obtain the same type of model diagnostics, using <code>diagfun</code>, again ordered the same way the original bivariate sample was. We have, for each bivariate diagnostic, <code>sim</code> simulated bivariate diagnostics forming the whole cloud of simulated diagnostics.
</p>
<p>By default, we then obtain the convex hulls of each set of the $s$ sets of points and obtain a reduced polygon whose area is (<code>conf * 100</code>)% of the original convex hull's area, forming the simulated polygon. This is equivalent to passing the argument <code>reduce.polygon = "proportional"</code> to <code><a href="#topic+plot.bivrp">plot.bivrp</a></code>. The argument <code>reduce.polygon = "bag"</code> can be used to obtain a (<code>conf * 100</code>)% bagplot as the simulated polygon instead of a convex hull. The points are then connected to the centroids of their respective simulated polygons and, if they lie outside the polygons, they are drawn in red. For the final display, the polygons are erased so as to ease visualization.
</p>
<p>There is no automatic implementation of a bivariate model in this function, and hence users must provide three functions for <code>bivrp</code>. The first function, <code>diagfun</code>, must extract the desired model diagnostics from a model fit object. The second function, <code>simfun</code>, must return the response variable, simulated using the same error distributions and estimated parameters from the fitted model. The third and final function, <code>fitfun</code>, must return a fitted model object. See the Examples section.
</p>
<p>This function produces a plot by passing the computed object to <code><a href="#topic+plot.bivrp">plot.bivrp</a></code>. The <code>print</code> method returns a <code>data.frame</code> containing all ordered simulated bivariate diagnostics. 
</p>


<h3>Value</h3>

<p>The function returns an object of class &quot;bivrp&quot;, which is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>reslist.ord</code></td>
<td>
<p>list of ordered diagnostics from model refitting to each simulated dataset</p>
</td></tr>
<tr><td><code>res.original.ord</code></td>
<td>
<p>original model diagnostics</p>
</td></tr>
<tr><td><code>res1</code></td>
<td>
<p>diagnostics from variable 1</p>
</td></tr>
<tr><td><code>res2</code></td>
<td>
<p>diagnostics from variable 2</p>
</td></tr>
<tr><td><code>res.original1</code></td>
<td>
<p>original model diagnostics for variable 1</p>
</td></tr>
<tr><td><code>res.original2</code></td>
<td>
<p>original model diagnostics for variable 2</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>confidence level of the simulated polygons</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rafael A. Moral &lt;rafael.deandrademoral@mu.ie&gt; and John Hinde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bivrp">plot.bivrp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulating a bivariate normal response variable

require(mvtnorm)

n &lt;- 40
beta1 &lt;- c(2, .4)
beta2 &lt;- c(.2, .2)
x &lt;- seq(1, 10, length = n)
X &lt;- model.matrix(~ x)
mu1 &lt;- X%*%beta1
mu2 &lt;- X%*%beta2
sig1 &lt;- 2
sig2 &lt;- 3
sig12 &lt;- -1.7
Sig1 &lt;- diag(rep(sig1), n)
Sig2 &lt;- diag(rep(sig2), n)
Sig12 &lt;- diag(rep(sig12), n)
V &lt;- rbind(cbind(Sig1, Sig12),
           cbind(Sig12, Sig2))

set.seed(2016)
Y &lt;- as.numeric(rmvnorm(1, c(mu1, mu2), V))

## code for fitting the model estimating covariance or not
bivnormfit &lt;- function(Y, X, covariance) {
  n &lt;- nrow(X)
  p &lt;- ncol(X)
  y &lt;- cbind(Y[1:n],Y[(n+1):(2*n)])
  XtXinv &lt;- solve(crossprod(X, X))
  beta.hat &lt;- XtXinv %*% crossprod(X, y)
  mu.hat &lt;- X%*%beta.hat
  sigma.hat &lt;- 1/n * t(y - mu.hat) %*% (y - mu.hat)
  if(!covariance) sigma.hat &lt;- diag(diag(sigma.hat))
  cov.betas &lt;- sigma.hat %x% XtXinv
  se.s1 &lt;- sqrt(2*sigma.hat[1]^2/(n-p+1))
  se.s2 &lt;- sqrt(2*sigma.hat[4]^2/(n-p+1))
  if(!covariance) se.s12 &lt;- NA else {
    rho &lt;- sigma.hat[2]/sqrt(sigma.hat[1]*sigma.hat[4])
    se.s12 &lt;- sqrt((1+rho^2)*sigma.hat[1]*sigma.hat[4]/(n-p+1))
  }
  se.betas &lt;- sqrt(diag(cov.betas))
  se.sigma &lt;- c(se.s1, se.s2, se.s12)
  coefs &lt;- c(beta.hat, sigma.hat[1], sigma.hat[4], sigma.hat[2])
  names(coefs) &lt;- c("beta1.0", "beta1.1", "beta2.0", "beta2.1", "sig1", "sig2", "sig12")
  fitted &lt;- c(mu.hat)
  resid &lt;- Y - fitted
  Sig1 &lt;- diag(rep(sigma.hat[1]), n)
  Sig2 &lt;- diag(rep(sigma.hat[4]), n)
  Sig12 &lt;- diag(rep(sigma.hat[2]), n)
  V &lt;- rbind(cbind(Sig1, Sig12),
             cbind(Sig12, Sig2))
  llik &lt;- dmvnorm(Y, c(mu.hat), V, log = TRUE)
  ret &lt;- list("coefs" = coefs, "covariance" = covariance, "n" = n, 
              "X" = X, "fitted" = fitted, "resid" = resid, "loglik" = llik,
              "Y" = Y, "se" = c(se.betas, se.sigma))
  class(ret) &lt;- "bivnormfit"
  return(ret)
}

## fitting bivariate models with and without estimating covariance
fit0 &lt;- bivnormfit(Y, X, covariance=FALSE)
fit1 &lt;- bivnormfit(Y, X, covariance=TRUE)
## likelihood-ratio test
2*(fit0$loglik - fit1$loglik)
pchisq(54.24, 1, lower=FALSE)

## function for extracting diagnostics (raw residuals)
dfun &lt;- function(obj) {
  r &lt;- obj$resid
  n &lt;- obj$n
  return(list(r[1:n], r[(n+1):(2*n)]))
}

## function for simulating new response variables
sfun &lt;- function(obj) {
  n &lt;- obj$n
  fitted &lt;- obj$fitted
  sig1 &lt;- obj$coefs[5]
  sig2 &lt;- obj$coefs[6]
  if(obj$covariance) sig12 &lt;- obj$coefs[7] else sig12 &lt;- 0
  Sig1 &lt;- diag(rep(sig1), n)
  Sig2 &lt;- diag(rep(sig2), n)
  Sig12 &lt;- diag(rep(sig12), n)
  V &lt;- rbind(cbind(Sig1, Sig12),
             cbind(Sig12, Sig2))
  Y &lt;- as.numeric(rmvnorm(1, c(mu1, mu2), V))
  return(list(Y[1:n], Y[(n+1):(2*n)], "X" = obj$X, 
              "covariance" = obj$covariance))
}

## function for refitting the model to simulated data
ffun &lt;- function(new.obj) {
  Ynew &lt;- c(new.obj[[1]], new.obj[[2]])
  bivnormfit(Ynew, new.obj$X, new.obj$covariance)
}

## Bivariate residual plot for model 1 (without estimating covariance)
plot1 &lt;- bivrp(fit0, diagfun=dfun, simfun=sfun, fitfun=ffun, verb=TRUE)
## without polygon area reduction
plot(plot1, conf=1)
## drawing polygons
plot(plot1, add.polygon=TRUE)
## without ordering
plot(plot1, theta.sort=FALSE, kernel=TRUE, add.dplots=TRUE, superpose=TRUE)

## Bivariate residual plot for model 2 (estimating covariance)
plot2 &lt;- bivrp(fit1, diagfun=dfun, simfun=sfun, fitfun=ffun, verb=TRUE)
## without polygon area reduction
plot(plot2, conf=1)
## drawing polygons
plot(plot2, add.polygon=TRUE, conf=1)
## without ordering
plot(plot2, theta.sort=FALSE, kernel=TRUE, add.dplots=TRUE, superpose=TRUE)
</code></pre>

<hr>
<h2 id='is_point_inside'>Determine if point is inside or outside a simple polygon area</h2><span id='topic+is_point_inside'></span>

<h3>Description</h3>

<p>Returns whether a point is inside or outside the convex polygon formed with the coordinates in a data frame or matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_point_inside(point, polyg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_point_inside_+3A_point">point</code></td>
<td>
<p>vector of two values for a point in the Cartesian plane</p>
</td></tr>
<tr><td><code id="is_point_inside_+3A_polyg">polyg</code></td>
<td>
<p>data frame or matrix with the coordinates forming the convex polygon</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm used here draws a ray from the point and counts the number of intersections made with the polygon. If the number of intersections is only one, then this means the point is inside the convex polygon.
</p>


<h3>Value</h3>

<p>This function returns <code>TRUE</code>, if the point is inside and <code>FALSE</code>, otherwise.
</p>


<h3>Author(s)</h3>

<p>Rafael A. Moral &lt;rafael.deandrademoral@mu.ie&gt; and John Hinde
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_polygon &lt;- data.frame(c(1, 2, 3, 4, 3),
                         c(1, 0, .5, 3, 4))
points_to_test &lt;- list(c(0, 0), c(2.5, 1), c(3.5, 4))

unlist(lapply(points_to_test, is_point_inside, my_polygon))

</code></pre>

<hr>
<h2 id='plot.bivrp'>Plot Method for bivrp Objects</h2><span id='topic+plot.bivrp'></span>

<h3>Description</h3>

<p>Plots the bivariate residual plot with simulation polygons from a <code>bivrp</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivrp'
plot(x, kernel, superpose.points, chp, add.dplots, 
     theta.sort, add.polygon, reduce.polygon, one.dim, pch = 16, cex = 0.8, 
     conf, xlab, ylab, main, point.col, point.pch, transparent.colors,
     density.bw, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bivrp_+3A_x">x</code></td>
<td>
<p>object of class <code>bivrp</code></p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_kernel">kernel</code></td>
<td>
<p>logical. If TRUE, instead of using polygons for each point, computes 2d kernels and plots the contours</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_superpose.points">superpose.points</code></td>
<td>
<p>only used if <code>kernel</code> or <code>chp</code> is TRUE. Logical argument, if <code>TRUE</code>, plots all simulated bivariate diagnostics</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_chp">chp</code></td>
<td>
<p>logical. If <code>TRUE</code>, instead of using polygons for each point, performs convex hull peeling over all simulated points</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_add.dplots">add.dplots</code></td>
<td>
<p>logical. If <code>TRUE</code>, adds the marginal density plots</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_theta.sort">theta.sort</code></td>
<td>
<p>logical. If <code>TRUE</code>, produces a simulated polygon for each point</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_add.polygon">add.polygon</code></td>
<td>
<p>logical. If <code>TRUE</code>, plots the simulated polygons as well</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_reduce.polygon">reduce.polygon</code></td>
<td>
<p>method used to reduce the polygon area. Defaults to <code>proportional</code>, see <code><a href="#topic+get_newpolygon">get_newpolygon</a></code> for details. If <code>reduce.polygon = "peel"</code>, performs convex hull peeling to reduce the area; if <code>reduce.polygon = "bag"</code>, computes a (<code>conf * 100</code>)% bagplot of the points</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_one.dim">one.dim</code></td>
<td>
<p>logical. If <code>TRUE</code>, plots only the marginal density plots (only works with <code>theta.sort = FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_pch">pch</code></td>
<td>
<p>argument passed to <code>par</code></p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_cex">cex</code></td>
<td>
<p>argument passed to <code>par</code></p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_conf">conf</code></td>
<td>
<p>confidence level of the simulated polygons. Default is 0.95</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_xlab">xlab</code></td>
<td>
<p>argument passed to <code>par</code></p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_ylab">ylab</code></td>
<td>
<p>argument passed to <code>par</code></p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_main">main</code></td>
<td>
<p>argument passed to <code>par</code></p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_point.col">point.col</code></td>
<td>
<p>a vector of length 2 with the colors of the points that are inside and outside of the simulated polygons</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_point.pch">point.pch</code></td>
<td>
<p>a vector of length 2 with the point characters of the points that are inside and outside of the simulated polygons</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_transparent.colors">transparent.colors</code></td>
<td>
<p>logical. If <code>TRUE</code>, adds transparency to the marginal density plots; if <code>FALSE</code>, only the border lines are drawn</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_density.bw">density.bw</code></td>
<td>
<p>the smoothing bandwidth to be used for the marginal densities. Defaults to <code>"SJ"</code> (see <code><a href="stats.html#topic+density">density</a></code>)</p>
</td></tr>
<tr><td><code id="plot.bivrp_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>par</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rafael A. Moral &lt;rafael_moral@yahoo.com.br&gt; and John Hinde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bivrp">bivrp</a></code>
</p>

<hr>
<h2 id='polygon-operations'>Polygon operations</h2><span id='topic+polygon_area'></span><span id='topic+get_k'></span><span id='topic+get_newpolygon'></span><span id='topic+get_reduced_bag'></span><span id='topic+compute_bagplot'></span>

<h3>Description</h3>

<p>Convex polygon operations - determination of area, centre of mass, and area reduction</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon_area(P)
get_k(P, conf)
get_newpolygon(conf, P, method)
get_reduced_bag(x, y, conf)
compute_bagplot(x, y, conf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polygon-operations_+3A_p">P</code></td>
<td>
<p>2-column <code>matrix</code> or <code>data.frame</code> with the coordinates of the vertices of the convex polygon</p>
</td></tr>
<tr><td><code id="polygon-operations_+3A_conf">conf</code></td>
<td>
<p>proportion of the area of polygon <code>P</code></p>
</td></tr>
<tr><td><code id="polygon-operations_+3A_method">method</code></td>
<td>
<p>method used to reduce the area of the polygon. Use <code>method = "proportional"</code> to scale the distances between the centroid and the vertices by <code>sqrt(conf)</code>; use <code>method = "get_k"</code> to subtract the same distance <code>k</code> from the centroid to each vertex.</p>
</td></tr>
<tr><td><code id="polygon-operations_+3A_x">x</code></td>
<td>
<p>x coordinates (of raw data) used to obtain the reduced bag</p>
</td></tr>
<tr><td><code id="polygon-operations_+3A_y">y</code></td>
<td>
<p>y coordinates (of raw data) used to obtain the reduced bag</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>compute_bagplot</code> uses an adapted version of the code written by P. Segaert to obtain the bagplot, that uses the Fortran subroutine written by P.J. Rousseeuw, I. Ruts and A. Struyf.
</p>


<h3>Author(s)</h3>

<p>Rafael A. Moral &lt;rafael.deandrademoral@mu.ie&gt; and John Hinde
</p>


<h3>References</h3>

<p>Rousseeuw P.J., Ruts I., Tukey J.W. (1999). The bagplot: A bivariate boxplot. The American Statistician, 53, 382–387.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_point_inside">is_point_inside</a></code>
<code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oldPolygon &lt;- data.frame(x=c(2,1,3,4.5,5), y=c(1,3,5,4.5,2))
  
  # area
  polygon_area(oldPolygon)$area
  # centre of mass
  polygon_area(oldPolygon)$centre
  
  # get a new polygon with 50% of the area of the old one
  newPolygon &lt;- get_newpolygon(conf=.5, P=oldPolygon, method="proportional")
  polygon_area(newPolygon)$area/polygon_area(oldPolygon)$area
  
  # second method
  newPolygon2 &lt;- get_newpolygon(conf=.5, P=oldPolygon, method="get.k")
  polygon_area(newPolygon2)$area/polygon_area(oldPolygon)$area
  
  # illustration
  plot(oldPolygon, xlim=c(0,6), ylim=c(0,6), main="(a)", pch=16)
  polygon(oldPolygon, lwd=2, col="#00000033")
  text(oldPolygon, c(expression(P[1]), expression(P[2]),
                     expression(P[3]), expression(P[4]),
                     expression(P[5])), pos=c(1,2,3,4,4), cex=2)
  polygon(newPolygon, border=4, lwd=2, col="#52A3E199")
  points(newPolygon, pch=16, col=4)
  text(newPolygon, c(expression(paste(P[1],minute)), expression(paste(P[2],minute)),
             expression(paste(P[3],minute)), expression(paste(P[4],minute)),
             expression(paste(P[5],minute))), pos=c(1,3,2,4,4), col=4, cex=2)

  C &lt;- polygon_area(oldPolygon)$centre
  text(C[1], C[2], "C", pos=4, cex=2)
  for(i in 1:5) lines(c(C[1], oldPolygon[i,1]), 
                      c(C[2], oldPolygon[i,2]), lty=2, lwd=2, type="b")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
