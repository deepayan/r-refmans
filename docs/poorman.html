<!DOCTYPE html><html lang="en-GB"><head><title>Help for package poorman</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poorman}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#poorman'><p>poorman: A Poor Man's Dependency Free Recreation of 'dplyr'</p></a></li>
<li><a href='#across'><p>Apply a function (or functions) across multiple columns</p></a></li>
<li><a href='#arrange'><p>Arrange rows by variables</p></a></li>
<li><a href='#between'><p>Do values in a numeric vector fall in specified range?</p></a></li>
<li><a href='#bind'><p>Efficiently bind multiple <code>data.frame</code>s by row and column</p></a></li>
<li><a href='#case_when'><p>A General Vetorised <code style="white-space: pre;">&#8288;if()&#8288;</code></p></a></li>
<li><a href='#coalesce'><p>Find first non-missing element</p></a></li>
<li><a href='#context'><p>Context dependent expressions</p></a></li>
<li><a href='#count'><p>Count observations by group</p></a></li>
<li><a href='#cummean'><p>Cumulative versions of any, all, and mean</p></a></li>
<li><a href='#desc'><p>Descending order</p></a></li>
<li><a href='#distinct'><p>Subset distinct/unique rows</p></a></li>
<li><a href='#fill'><p>Fill in missing values with previous or next value</p></a></li>
<li><a href='#filter'><p>Return rows with matching conditions</p></a></li>
<li><a href='#filter_joins'><p>Filtering joins filter rows from <code>x</code> based on the presence or absence of</p>
matches in <code>y</code>:</a></li>
<li><a href='#glimpse'><p>Get a glimpse of your data</p></a></li>
<li><a href='#group_by'><p>Group by one or more variables</p></a></li>
<li><a href='#group_by_drop_default'><p>Default value for .drop argument of group_by</p></a></li>
<li><a href='#group_cols'><p>Select Grouping Variables</p></a></li>
<li><a href='#group_metadata'><p>Grouping metadata</p></a></li>
<li><a href='#group_split'><p>Split data.frame by groups</p></a></li>
<li><a href='#if_else'><p>Vectorised if</p></a></li>
<li><a href='#lag'><p>Compute lagged or leading values</p></a></li>
<li><a href='#lst'><p>Build a list</p></a></li>
<li><a href='#mutate'><p>Create or transform variables</p></a></li>
<li><a href='#mutate_joins'><p>Mutating Joins</p></a></li>
<li><a href='#n_distinct'><p>Count the number of unique values in a set of vectors</p></a></li>
<li><a href='#na_if'><p>Convert values to NA</p></a></li>
<li><a href='#near'><p>Compare two numeric vectors</p></a></li>
<li><a href='#nest_by'><p>Nest By</p></a></li>
<li><a href='#nth'><p>Extract the first, last or nth value from a vector</p></a></li>
<li><a href='#peek_vars'><p>Peek at variables in the selection context</p></a></li>
<li><a href='#pipe'><p>Forward-pipe operator</p></a></li>
<li><a href='#pivot_longer'><p>Pivot data from wide to long</p></a></li>
<li><a href='#pivot_wider'><p>Pivot data from long to wide</p></a></li>
<li><a href='#pull'><p>Pull out a single variable</p></a></li>
<li><a href='#recode'><p>Recode values</p></a></li>
<li><a href='#relocate'><p>Change column order</p></a></li>
<li><a href='#rename'><p>Rename columns</p></a></li>
<li><a href='#replace_na'><p>Replace missing values</p></a></li>
<li><a href='#rownames'><p>Tools for working with row names</p></a></li>
<li><a href='#select'><p>Subset columns using their names and types</p></a></li>
<li><a href='#select_helpers'><p>Select Helpers</p></a></li>
<li><a href='#slice'><p>Subset rows by position</p></a></li>
<li><a href='#summarise'><p>Reduce multiple values down to a single value</p></a></li>
<li><a href='#union_all'><p>Union All</p></a></li>
<li><a href='#unite'><p>Unite Multiple Columns Into One</p></a></li>
<li><a href='#where'><p>Select variables with a function</p></a></li>
<li><a href='#window_rank'><p>Windowed Rank Functions</p></a></li>
<li><a href='#with_groups'><p>Perform an operation with temporary groups</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Poor Man's Dependency Free Recreation of 'dplyr'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathan Eastwood &lt;nathan.eastwood@icloud.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A replication of key functionality from 'dplyr' and the wider 'tidyverse' using only 'base'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nathaneastwood.github.io/poorman/">https://nathaneastwood.github.io/poorman/</a>,
<a href="https://github.com/nathaneastwood/poorman">https://github.com/nathaneastwood/poorman</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nathaneastwood/poorman/issues">https://github.com/nathaneastwood/poorman/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, roxygen2, tinytest</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-30 21:00:56 UTC; nathan</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathan Eastwood [aut, cre],
  Etienne Bacher <a href="https://orcid.org/0000-0002-9271-5075"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-30 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='poorman'>poorman: A Poor Man's Dependency Free Recreation of 'dplyr'</h2><span id='topic+poorman'></span><span id='topic+poorman-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A replication of key functionality from 'dplyr' and the wider 'tidyverse' using only 'base'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nathan Eastwood <a href="mailto:nathan.eastwood@icloud.com">nathan.eastwood@icloud.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Etienne Bacher <a href="mailto:etienne.bacher@protonmail.com">etienne.bacher@protonmail.com</a> (<a href="https://orcid.org/0000-0002-9271-5075">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://nathaneastwood.github.io/poorman/">https://nathaneastwood.github.io/poorman/</a>
</p>
</li>
<li> <p><a href="https://github.com/nathaneastwood/poorman">https://github.com/nathaneastwood/poorman</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nathaneastwood/poorman/issues">https://github.com/nathaneastwood/poorman/issues</a>
</p>
</li></ul>


<hr>
<h2 id='across'>Apply a function (or functions) across multiple columns</h2><span id='topic+across'></span><span id='topic+if_any'></span><span id='topic+if_all'></span>

<h3>Description</h3>

<p><code>across()</code> makes it easy to apply the same transformation to multiple columns, allowing you to use <code><a href="#topic+select">select()</a></code>
semantics inside in &quot;data-masking&quot; functions like <code><a href="#topic+summarise">summarise()</a></code> and <code><a href="#topic+mutate">mutate()</a></code>.
</p>
<p><code>if_any()</code> and <code>if_all()</code> are used to apply the same predicate function to a selection of columns and combine the
results into a single logical vector.
</p>
<p><code>across()</code> supersedes the family of <code>dplyr</code> &quot;scoped variants&quot; like <code>summarise_at()</code>, <code>summarise_if()</code>, and
<code>summarise_all()</code> and therefore these functions will not be implemented in <code>poorman</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>across(.cols = everything(), .fns = NULL, ..., .names = NULL)

if_any(.cols, .fns = NULL, ..., .names = NULL)

if_all(.cols, .fns = NULL, ..., .names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="across_+3A_.fns">.fns</code></td>
<td>
<p>Functions to apply to each of the selected columns.
Possible values are:
</p>

<ul>
<li> <p><code>NULL</code>, to returns the columns untransformed.
</p>
</li>
<li><p> A function, e.g. <code>mean</code>.
</p>
</li>
<li><p> A lambda, e.g. <code>~ mean(.x, na.rm = TRUE)</code>
</p>
</li>
<li><p> A list of functions/lambdas, e.g. <code style="white-space: pre;">&#8288;list(mean = mean, n_miss = ~ sum(is.na(.x))&#8288;</code>
</p>
</li></ul>

<p>Within these functions you can use <code><a href="#topic+cur_column">cur_column()</a></code> and <code><a href="#topic+cur_group">cur_group()</a></code> to access the current column and grouping keys
respectively.</p>
</td></tr>
<tr><td><code id="across_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function calls in <code>.fns</code>.</p>
</td></tr>
<tr><td><code id="across_+3A_.names">.names</code></td>
<td>
<p>A glue specification that describes how to name the output
columns. This can use <code>{.col}</code> to stand for the selected column name, and <code>{.fn}</code>
to stand for the name of the function being applied. The default (<code>NULL</code>) is
equivalent to &quot;<code>{.col}</code>&quot; for the single function case and &quot;<code style="white-space: pre;">&#8288;{.col}_{.fn}&#8288;</code>&quot; for
the case where a list is used for <code>.fns</code>.</p>
</td></tr>
<tr><td><code id="across_+3A_cols">cols</code>, <code id="across_+3A_.cols">.cols</code></td>
<td>
<p>&lt;<code><a href="#topic+select_helpers">poor-select</a></code>&gt; Columns to transform. Because <code>across()</code> is used within functions
like <code>summarise()</code> and <code>mutate()</code>, you can't select or compute upon grouping variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>across()</code> returns a <code>data.frame</code> with one column for each column in <code>.cols</code> and each function in <code>.fns</code>.
</p>
<p><code>if_any()</code> and <code>if_all()</code> return a logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># across() -----------------------------------------------------------------
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(starts_with("Sepal"), mean))
iris %&gt;%
  mutate(across(where(is.factor), as.character))

# Additional parameters can be passed to functions
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(starts_with("Sepal"), mean, na.rm = TRUE))

# A named list of functions
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd)))

# Use the .names argument to control the output names
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(
    across(starts_with("Sepal"),
    mean,
    .names = c("mean_sepal_length", "mean_sepal_width"))
  )

# if_any() and if_all() ----------------------------------------------------
iris %&gt;%
  filter(if_any(ends_with("Width"), ~ . &gt; 4))
iris %&gt;%
  filter(if_all(ends_with("Width"), ~ . &gt; 2))

</code></pre>

<hr>
<h2 id='arrange'>Arrange rows by variables</h2><span id='topic+arrange'></span>

<h3>Description</h3>

<p>Order rows of a <code>data.frame</code> by an expression involving its variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>A comma separated vector of unquoted name(s) to order the data by.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arrange(mtcars, mpg)
mtcars %&gt;% arrange(mpg)
mtcars %&gt;% arrange(cyl, mpg)

</code></pre>

<hr>
<h2 id='between'>Do values in a numeric vector fall in specified range?</h2><span id='topic+between'></span>

<h3>Description</h3>

<p>This is a shortcut for <code>x &gt;= left &amp; x &lt;= right</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>between(x, left, right)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="between_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> vector of values.</p>
</td></tr>
<tr><td><code id="between_+3A_left">left</code>, <code id="between_+3A_right">right</code></td>
<td>
<p>Boundary values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>between(1:12, 7, 9)

x &lt;- rnorm(1e2)
x[between(x, -1, 1)]

</code></pre>

<hr>
<h2 id='bind'>Efficiently bind multiple <code>data.frame</code>s by row and column</h2><span id='topic+bind'></span><span id='topic+bind_cols'></span><span id='topic+bind_rows'></span>

<h3>Description</h3>

<p>Efficiently bind multiple <code>data.frame</code>s by row and column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_cols(...)

bind_rows(..., .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p><code>data.frame</code>s to combine.
</p>
<p>Each argument can either be a <code>data.frame</code>, a <code>list</code> that could be a <code>data.frame</code>, or a <code>list</code> of <code>data.frame</code>s.
</p>
<p>When row-binding, columns are matched by name, and any missing columns will be filled with <code>NA</code>.
</p>
<p>When column-binding, rows are matched by position, so all <code>data.frame</code>s must have the same number of rows. To match
by value, not position, see <a href="#topic+mutate_joins">mutate_joins</a>.</p>
</td></tr>
<tr><td><code id="bind_+3A_.id">.id</code></td>
<td>
<p><code>character(1)</code>. <code>data.frame</code> identifier.
</p>
<p>When <code>.id</code> is supplied, a new column of identifiers is created to link each row to its original <code>data.frame</code>. The
labels are taken from the named arguments to <code>bind_rows()</code>. When a <code>list</code> of <code>data.frame</code>s is supplied, the labels
are taken from the names of the <code>list</code>. If no names are found a numeric sequence is used instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>one &lt;- mtcars[1:4, ]
two &lt;- mtcars[9:12, ]

# You can supply data frames as arguments:
bind_rows(one, two)

# The contents of lists are spliced automatically:
bind_rows(list(one, two))
bind_rows(split(mtcars, mtcars$cyl))
bind_rows(list(one, two), list(two, one))

# In addition to data frames, you can supply vectors. In the rows
# direction, the vectors represent rows and should have inner
# names:
bind_rows(
  c(a = 1, b = 2),
  c(a = 3, b = 4)
)

# You can mix vectors and data frames:
bind_rows(
  c(a = 1, b = 2),
  data.frame(a = 3:4, b = 5:6),
  c(a = 7, b = 8)
)

# When you supply a column name with the `.id` argument, a new
# column is created to link each row to its original data frame
bind_rows(list(one, two), .id = "id")
bind_rows(list(a = one, b = two), .id = "id")
bind_rows("group 1" = one, "group 2" = two, .id = "groups")

## Not run: 
# Rows need to match when column-binding
bind_cols(data.frame(x = 1:3), data.frame(y = 1:2))

# even with 0 columns
bind_cols(data.frame(x = 1:3), data.frame())

## End(Not run)

bind_cols(one, two)
bind_cols(list(one, two))

</code></pre>

<hr>
<h2 id='case_when'>A General Vetorised <code style="white-space: pre;">&#8288;if()&#8288;</code></h2><span id='topic+case_when'></span>

<h3>Description</h3>

<p>This function allows you to vectorise multiple <code><a href="#topic+if_else">if_else()</a></code> statements. It is an R equivalent of the SQL <code style="white-space: pre;">&#8288;CASE WHEN&#8288;</code>
statement. If no cases match, <code>NA</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_when(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="case_when_+3A_...">...</code></td>
<td>
<p>A sequence of two-sided formulas. The left hand side (LHS) determines which values match this case. The
right hand side (RHS) provides the replacement value.
</p>
<p>The LHS must evaluate to a logical vector. The RHS does not need to be logical, but all RHSs must evaluate to the
same type of vector.
</p>
<p>Both LHS and RHS may have the same length of either 1 or n. The value of n must be consistent across all cases. The
case of <code>n == 0</code> is treated as a variant of <code>n != 1</code>.
</p>
<p><code>NULL</code> inputs are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 1 or n, matching the length of the logical input or output vectors, with the type (and attributes)
of the first RHS. Inconsistent lengths or types will generate an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:50
case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  TRUE ~ as.character(x)
)

# Like an if statement, the arguments are evaluated in order, so you must
# proceed from the most specific to the most general. This won't work:
case_when(
  TRUE ~ as.character(x),
  x %%  5 == 0 ~ "fizz",
  x %%  7 == 0 ~ "buzz",
  x %% 35 == 0 ~ "fizz buzz"
)

# If none of the cases match, NA is used:
case_when(
  x %%  5 == 0 ~ "fizz",
  x %%  7 == 0 ~ "buzz",
  x %% 35 == 0 ~ "fizz buzz"
)

# Note that NA values in the vector x do not get special treatment. If you want
# to explicitly handle NA values you can use the `is.na` function:
x[2:4] &lt;- NA_real_
case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  is.na(x) ~ "nope",
  TRUE ~ as.character(x)
)

# All RHS values need to be of the same type. Inconsistent types will throw an error.
# This applies also to NA values used in RHS: NA is logical, use
# typed values like NA_real_, NA_complex, NA_character_, NA_integer_ as appropriate.
case_when(
  x %% 35 == 0 ~ NA_character_,
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  TRUE ~ as.character(x)
)
case_when(
  x %% 35 == 0 ~ 35,
  x %% 5 == 0 ~ 5,
  x %% 7 == 0 ~ 7,
  TRUE ~ NA_real_
)

# case_when() evaluates all RHS expressions, and then constructs its
# result by extracting the selected (via the LHS expressions) parts.
# In particular NaN are produced in this case:
y &lt;- seq(-2, 2, by = .5)
case_when(
  y &gt;= 0 ~ sqrt(y),
  TRUE   ~ y
)

## Not run: 
case_when(
  x %% 35 == 0 ~ 35,
  x %% 5 == 0 ~ 5,
  x %% 7 == 0 ~ 7,
  TRUE ~ NA
)

## End(Not run)

# case_when is particularly useful inside mutate when you want to
# create a new variable that relies on a complex combination of existing
# variables
mtcars %&gt;%
  mutate(
    efficient = case_when(
      mpg &gt; 25 ~ TRUE,
      TRUE ~ FALSE
    )
  )

</code></pre>

<hr>
<h2 id='coalesce'>Find first non-missing element</h2><span id='topic+coalesce'></span>

<h3>Description</h3>

<p>Given a set of vectors, <code>coalesce()</code> finds the first non-missing value at each position. This is inspired by the SQL
<code>COALESCE</code> function which does the same thing for <code>NULL</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coalesce_+3A_...">...</code></td>
<td>
<p>Vectors. Inputs should be recyclable (either be length <code>1L</code> or <code>n</code>) and coercible to a common type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code>coalesce()</code> type checking does not take place.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+na_if">na_if()</a></code> to replace specified values to a <code>NA</code>.
</p>
<p><code><a href="#topic+replace_na">replace_na()</a></code> to replace a <code>NA</code> with a value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use a single value to replace all missing vectors
x &lt;- sample(c(1:5, NA, NA, NA))
coalesce(x, 0L)

# Or match together a complete vector from missing pieces
y &lt;- c(1, 2, NA, NA, 5)
z &lt;- c(NA, NA, 3, 4, 5)
coalesce(y, z)

</code></pre>

<hr>
<h2 id='context'>Context dependent expressions</h2><span id='topic+context'></span><span id='topic+n'></span><span id='topic+cur_data'></span><span id='topic+cur_data_all'></span><span id='topic+cur_group'></span><span id='topic+cur_group_id'></span><span id='topic+cur_group_rows'></span><span id='topic+cur_column'></span>

<h3>Description</h3>

<p>These functions return information about the &quot;current&quot; group or &quot;current&quot; variable, so only work inside specific
contexts like <code><a href="#topic+summarise">summarise()</a></code> and <code><a href="#topic+mutate">mutate()</a></code>.
</p>

<ul>
<li> <p><code>n()</code> gives the number of observations in the current group.
</p>
</li></ul>


<ul>
<li> <p><code>cur_data()</code> gives the current data for the current group (excluding grouping variables).
</p>
</li></ul>


<ul>
<li> <p><code>cur_data_all()</code> gives the current data for the current group (including grouping variables).
</p>
</li></ul>


<ul>
<li> <p><code>cur_group()</code> gives the group keys, a single row <code>data.frame</code> containing a column for each grouping variable and
its value.
</p>
</li></ul>


<ul>
<li> <p><code>cur_group_id()</code> gives a unique numeric identifier for the current group.
</p>
</li></ul>


<ul>
<li> <p><code>cur_group_rows()</code> gives the rows the groups appear in the data.
</p>
</li></ul>


<ul>
<li> <p><code>cur_column()</code> gives the name of the current column (in <code><a href="#topic+across">across()</a></code> only).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>n()

cur_data()

cur_data_all()

cur_group()

cur_group_id()

cur_group_rows()

cur_column()
</code></pre>


<h3><code>data.table</code></h3>

<p>If you're familiar with <code>data.table</code>:
</p>

<ul>
<li> <p><code>cur_data()</code> &lt;-&gt; <code>.SD</code>
</p>
</li>
<li> <p><code>cur_group_id()</code> &lt;-&gt; <code>.GRP</code>
</p>
</li>
<li> <p><code>cur_group()</code> &lt;-&gt; <code>.BY</code>
</p>
</li>
<li> <p><code>cur_group_rows()</code> &lt;-&gt; <code>.I</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>See <code><a href="#topic+group_data">group_data()</a></code> for equivalent functions that return values for all groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  g = sample(rep(letters[1:3], 1:3)),
  x = runif(6),
  y = runif(6),
  stringsAsFactors = FALSE
)
gf &lt;- df %&gt;% group_by(g)

gf %&gt;% summarise(n = n())

gf %&gt;% mutate(id = cur_group_id())
gf %&gt;% summarise(row = cur_group_rows())
gf %&gt;% summarise(data = list(cur_group()))
gf %&gt;% summarise(data = list(cur_data()))
gf %&gt;% summarise(data = list(cur_data_all()))

gf %&gt;% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))

</code></pre>

<hr>
<h2 id='count'>Count observations by group</h2><span id='topic+count'></span><span id='topic+tally'></span><span id='topic+add_count'></span><span id='topic+add_tally'></span>

<h3>Description</h3>

<p><code>count()</code> lets you quickly count the unique values of one or more variables:
<code>df %&gt;% count(a, b)</code> is roughly equivalent to
<code>df %&gt;% group_by(a, b) %&gt;% summarise(n = n())</code>.
<code>count()</code> is paired with <code>tally()</code>, a lower-level helper that is equivalent to <code>df %&gt;% summarise(n = n())</code>. Supply
<code>wt</code> to perform weighted counts, switching the summary from from <code>n = n()</code> to <code>n = sum(wt)</code>.
<code>add_count()</code> and <code>add_tally()</code> are equivalent to <code>count()</code> and <code>tally()</code> but use <code>mutate()</code> instead of <code>summarise()</code>
so that they add a new column with group-wise counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(x, ..., wt = NULL, sort = FALSE, name = NULL)

tally(x, wt = NULL, sort = FALSE, name = NULL)

add_count(x, ..., wt = NULL, sort = FALSE, name = NULL)

add_tally(x, wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>Variables to group by.</p>
</td></tr>
<tr><td><code id="count_+3A_wt">wt</code></td>
<td>
<p>If omitted, will count the number of rows. If specified, will perform a &quot;weighted&quot; count by summing the
(non-missing) values of variable <code>wt</code>. If omitted, and column <code>n</code> exists, it will automatically be used as a
weighting variable, although you will have to specify <code>name</code> to provide a new name for the output.</p>
</td></tr>
<tr><td><code id="count_+3A_sort">sort</code></td>
<td>
<p><code>logical(1)</code>. If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count_+3A_name">name</code></td>
<td>
<p><code>character(1)</code>. The name of the new column in the output. If omitted, it will default to <code>n</code>. If there's
already a column called <code>n</code>, it will error, and require you to specify the name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>. <code>count()</code> and <code>add_count()</code> have the same groups as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># count() is a convenient way to get a sense of the distribution of
# values in a dataset
mtcars %&gt;% count(cyl)
mtcars %&gt;% count(cyl, sort = TRUE)
mtcars %&gt;% count(cyl, am, sort = TRUE)
# Note that if the data are already grouped, count() adds an additional grouping variable
# which is removed afterwards
mtcars %&gt;% group_by(gear) %&gt;% count(cyl)

# tally() is a lower-level function that assumes you've done the grouping
mtcars %&gt;% tally()
mtcars %&gt;% group_by(cyl) %&gt;% tally()

# both count() and tally() have add_ variants that work like mutate() instead of summarise
mtcars %&gt;% add_count(cyl, wt = am)
mtcars %&gt;% add_tally(wt = am)

</code></pre>

<hr>
<h2 id='cummean'>Cumulative versions of any, all, and mean</h2><span id='topic+cummean'></span><span id='topic+cumany'></span><span id='topic+cumall'></span>

<h3>Description</h3>

<p>poorman provides <code>cumall()</code>, <code>cumany()</code>, and <code>cummean()</code> to complete R's set of cumulative functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cummean(x)

cumany(x)

cumall(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cummean_+3A_x">x</code></td>
<td>
<p>For <code>cumall()</code> and <code>cumany()</code>, a logical vector; for <code>cummean()</code> an integer or numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>x</code>.
</p>


<h3>Cumulative logical functions</h3>

<p>These are particularly useful in conjunction with <code>filter()</code>:
</p>

<ul>
<li> <p><code>cumall(x)</code>: all cases until the first <code>FALSE</code>.
</p>
</li>
<li> <p><code>cumall(!x)</code>: all cases until the first <code>TRUE</code>.
</p>
</li>
<li> <p><code>cumany(x)</code>: all cases after the first <code>TRUE</code>.
</p>
</li>
<li> <p><code>cumany(!x)</code>: all cases after the first <code>FALSE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `cummean()` returns a numeric/integer vector of the same length
# as the input vector.
x &lt;- c(1, 3, 5, 2, 2)
cummean(x)
cumsum(x) / seq_along(x)

# `cumall()` and `cumany()` return logicals
cumall(x &lt; 5)
cumany(x == 3)

# `cumall()` vs. `cumany()`
df &lt;- data.frame(
  date = as.Date("2020-01-01") + 0:6,
  balance = c(100, 50, 25, -25, -50, 30, 120)
)
# all rows after first overdraft
df %&gt;% filter(cumany(balance &lt; 0))
# all rows until first overdraft
df %&gt;% filter(cumall(!(balance &lt; 0)))

</code></pre>

<hr>
<h2 id='desc'>Descending order</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>Transform a vector into a format that will be sorted in descending order. This is useful within <code><a href="#topic+arrange">arrange()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="desc_+3A_x">x</code></td>
<td>
<p>A vector to transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>desc(1:10)
desc(factor(letters))

first_day &lt;- seq(as.Date("1910/1/1"), as.Date("1920/1/1"), "years")
desc(first_day)

mtcars %&gt;% arrange(desc(mpg))

</code></pre>

<hr>
<h2 id='distinct'>Subset distinct/unique rows</h2><span id='topic+distinct'></span>

<h3>Description</h3>

<p>Select only distinct/unique rows from a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distinct_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="distinct_+3A_...">...</code></td>
<td>
<p>Optional variables to use when determining uniqueness. If there are multiple rows for a given combination
of inputs, only the first row will be preserved. If omitted, will use all variables.</p>
</td></tr>
<tr><td><code id="distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p><code>logical(1)</code>. If <code>TRUE</code>, keep all variables in <code>.data</code>. If a combination of <code>...</code> is not distinct,
this keeps the first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following properties:
</p>

<ul>
<li><p> Rows are a subset of the input but appear in the same order.
</p>
</li>
<li><p> Columns are not modified if <code>...</code> is empty or <code>.keep_all</code> is <code>TRUE</code>. Otherwise, <code>distinct()</code> first calls <code>mutate()</code>
to create new columns.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li> <p><code>data.frame</code> attributes are preserved.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = sample(10, 100, rep = TRUE),
  y = sample(10, 100, rep = TRUE)
)
nrow(df)
nrow(distinct(df))
nrow(distinct(df, x, y))

distinct(df, x)
distinct(df, y)

# You can choose to keep all other variables as well
distinct(df, x, .keep_all = TRUE)
distinct(df, y, .keep_all = TRUE)

# You can also use distinct on computed variables
distinct(df, diff = abs(x - y))

# The same behaviour applies for grouped data frames,
# except that the grouping variables are always included
df &lt;- data.frame(
  g = c(1, 1, 2, 2),
  x = c(1, 1, 2, 1)
) %&gt;% group_by(g)
df %&gt;% distinct(x)

</code></pre>

<hr>
<h2 id='fill'>Fill in missing values with previous or next value</h2><span id='topic+fill'></span>

<h3>Description</h3>

<p>Fills missing values in selected columns using the next or previous entry. This is useful in the common output format
where values are not repeated, and are only recorded when they change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill(data, ..., .direction = c("down", "up", "downup", "updown"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="fill_+3A_...">...</code></td>
<td>
<p>Columns to fill.</p>
</td></tr>
<tr><td><code id="fill_+3A_.direction">.direction</code></td>
<td>
<p>Direction in which to fill missing values. Currently either <code>"down"</code> (the default), <code>"up"</code>,
<code>"downup"</code> (i.e. first down and then up) or <code>"updown"</code> (first up and then down).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are replaced in atomic vectors; <code>NULL</code>s are replaced in lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Value (year) is recorded only when it changes
sales &lt;- data.frame(
  quarter = c(
    "Q1", "Q2", "Q3", "Q4", "Q1", "Q2", "Q3", "Q4", "Q1", "Q2",
    "Q3", "Q4", "Q1", "Q2", "Q3", "Q4"
  ),
  year = c(2000, NA, NA, NA, 2001, NA, NA, NA, 2002, NA, NA, NA, 2004, NA, NA, NA),
  sales = c(
    66013, 69182, 53175, 21001, 46036, 58842, 44568, 50197, 39113, 41668, 30144,
    52897, 32129, 67686, 31768, 49094
  )
)

# `fill()` defaults to replacing missing data from top to bottom
sales %&gt;% fill(year)

# Value (pet_type) is missing above
tidy_pets &lt;- data.frame(
  rank = c(1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L),
  pet_type = c(NA, NA, NA, NA, NA, "Dog", NA, NA, NA, NA, NA, "Cat"),
  breed = c(
    "Boston Terrier", "Retrievers (Labrador)", "Retrievers (Golden)",
    "French Bulldogs", "Bulldogs", "Beagles", "Persian", "Maine Coon",
    "Ragdoll", "Exotic", "Siamese", "American Short"
  )
)

# For values that are missing above you can use `.direction = "up"`
tidy_pets %&gt;%
  fill(pet_type, .direction = "up")

# Value (n_squirrels) is missing above and below within a group
squirrels &lt;- data.frame(
  group = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3),
  name = c(
    "Sam", "Mara", "Jesse", "Tom", "Mike", "Rachael", "Sydekea",
    "Gabriela", "Derrick", "Kara", "Emily", "Danielle"
  ),
  role = c(
    "Observer", "Scorekeeper", "Observer", "Observer", "Observer",
    "Observer", "Scorekeeper", "Observer", "Observer", "Scorekeeper",
    "Observer", "Observer"
  ),
  n_squirrels = c(NA, 8, NA, NA, NA, NA, 14, NA, NA, 9, NA, NA)
)

# The values are inconsistently missing by position within the group
# Use .direction = "downup" to fill missing values in both directions
squirrels %&gt;%
  group_by(group) %&gt;%
  fill(n_squirrels, .direction = "downup") %&gt;%
  ungroup()

# Using `.direction = "updown"` accomplishes the same goal in this example

</code></pre>

<hr>
<h2 id='filter'>Return rows with matching conditions</h2><span id='topic+filter'></span>

<h3>Description</h3>

<p>Use <code>filter()</code> to choose rows/cases where conditions are <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>Logical predicated defined in terms of the variables in <code>.data</code>. Multiple conditions are combined with
<code>&amp;</code>. Arguments within <code>...</code> are automatically quoted and evaluated within the context of the <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="filter_+3A_.preserve">.preserve</code></td>
<td>
<p><code>logical(1)</code>. Relevant when the .data input is grouped. If <code>.preserve = FALSE</code> (the default), the
grouping structure is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Useful filter functions</h3>


<ul>
<li> <p><code>==</code>, <code>&gt;</code>, <code>&gt;=</code>, etc.
</p>
</li>
<li> <p><code>&amp;</code>, <code>|</code>, <code>!</code>, <code>xor()</code>
</p>
</li>
<li> <p><code>is.na()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>filter(mtcars, am == 1)
mtcars %&gt;% filter(cyl == 4)
mtcars %&gt;% filter(cyl &lt;= 5 &amp; am &gt; 0)
mtcars %&gt;% filter(cyl == 4 | cyl == 8)
mtcars %&gt;% filter(!(cyl %in% c(4, 6)), am != 0)

</code></pre>

<hr>
<h2 id='filter_joins'>Filtering joins filter rows from <code>x</code> based on the presence or absence of
matches in <code>y</code>:</h2><span id='topic+filter_joins'></span><span id='topic+anti_join'></span><span id='topic+semi_join'></span>

<h3>Description</h3>


<ul>
<li> <p><code>semi_join()</code> return all rows from <code>x</code> with a match in <code>y</code>.
</p>
</li>
<li> <p><code>anti_join()</code> return all rows from <code>x</code> with<em>out</em> a match in <code>y</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>anti_join(x, y, by = NULL)

semi_join(x, y, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_joins_+3A_x">x</code>, <code id="filter_joins_+3A_y">y</code></td>
<td>
<p>The <code>data.frame</code>s to join.</p>
</td></tr>
<tr><td><code id="filter_joins_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by. If <code>NULL</code>, the default,
<code style="white-space: pre;">&#8288;*_join()&#8288;</code> will do a natural join, using all variables with common names
across the two tables. A message lists the variables so that you can check
they're right (to suppress the message, simply explicitly list the variables
that you want to join).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>table1 &lt;- data.frame(
  pupil = rep(1:3, each = 2),
  test = rep(c("A", "B"), 3),
  score = c(60, 70, 65, 80, 85, 70),
  stringsAsFactors = FALSE
)
table2 &lt;- table1[c(1, 3, 4), ]

table1 %&gt;% anti_join(table2, by = c("pupil", "test"))
table1 %&gt;% semi_join(table2, by = c("pupil", "test"))

</code></pre>

<hr>
<h2 id='glimpse'>Get a glimpse of your data</h2><span id='topic+glimpse'></span>

<h3>Description</h3>

<p><code>glimpse()</code> is like a transposed version of print(): columns run down the page, and data runs across. This makes it
possible to see every column in a <code>data.frame</code>. It is no more than a wrapper around <code><a href="utils.html#topic+str">utils::str()</a></code> only it returns
the input (invisibly) meaning it can be used within a data pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glimpse(x, width = getOption("width"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glimpse_+3A_x">x</code></td>
<td>
<p>An object to glimpse at.</p>
</td></tr>
<tr><td><code id="glimpse_+3A_width">width</code></td>
<td>
<p><code>integer(1)</code>. Width of the output.</p>
</td></tr>
<tr><td><code id="glimpse_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code><a href="utils.html#topic+str">utils::str()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>glimpse(mtcars)

</code></pre>

<hr>
<h2 id='group_by'>Group by one or more variables</h2><span id='topic+group_by'></span><span id='topic+ungroup'></span>

<h3>Description</h3>

<p>Determine the groups within a <code>data.frame</code> to perform operations on. <code><a href="#topic+ungroup">ungroup()</a></code> removes the grouping levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))

ungroup(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by_+3A_.data">.data</code></td>
<td>
<p><code>data.frame</code>. The data to group.</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>One or more unquoted column names to group/ungroup the data by.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.add">.add</code></td>
<td>
<p><code>logical(1)</code>. When <code>FALSE</code> (the default) <code>group_by()</code> will override existing groups. To add to existing
groups, use <code>.add = TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.drop">.drop</code></td>
<td>
<p><code>logical(1)</code>. Drop groups formed by factor levels that don't appear in the data? The default is <code>TRUE</code>
except when <code>.data</code> has been previously grouped with <code>.drop = FALSE</code>. See <code><a href="#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
<tr><td><code id="group_by_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When using <code><a href="#topic+group_by">group_by()</a></code>, a <code>data.frame</code>, grouped by the grouping variables.
</p>
<p>When using <code><a href="#topic+ungroup">ungroup()</a></code>, a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>group_by(mtcars, am, cyl)
ungroup(mutate(group_by(mtcars, am, cyl), sumMpg = sum(mpg)))
mtcars %&gt;%
  group_by(am, cyl) %&gt;%
  mutate(sumMpg = sum(mpg)) %&gt;%
  ungroup()
mtcars %&gt;%
  group_by(carb) %&gt;%
  filter(any(gear == 5))

# You can group by expressions: this is just short-hand for
# a mutate() followed by a group_by()
mtcars %&gt;% group_by(vsam = vs + am)

</code></pre>

<hr>
<h2 id='group_by_drop_default'>Default value for .drop argument of group_by</h2><span id='topic+group_by_drop_default'></span>

<h3>Description</h3>

<p>Default value for .drop argument of group_by
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by_drop_default(.tbl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by_drop_default_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> unless <code>.tbl</code> is a grouped <code>data.frame</code> that was previously obtained by <code>group_by(.drop = FALSE)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>group_by_drop_default(iris)

iris %&gt;%
  group_by(Species) %&gt;%
  group_by_drop_default()

iris %&gt;%
  group_by(Species, .drop = FALSE) %&gt;%
  group_by_drop_default()

</code></pre>

<hr>
<h2 id='group_cols'>Select Grouping Variables</h2><span id='topic+group_cols'></span>

<h3>Description</h3>

<p>This selection helper matches grouping variables. It can be used within <code><a href="#topic+select">select()</a></code> and <code><a href="#topic+relocate">relocate()</a></code> selections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_cols()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+groups">groups()</a></code> and <code><a href="#topic+group_vars">group_vars()</a></code> for retrieving the grouping variables outside selection contexts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% group_by(am, cyl) %&gt;% select(group_cols())

</code></pre>

<hr>
<h2 id='group_metadata'>Grouping metadata</h2><span id='topic+group_metadata'></span><span id='topic+group_data'></span><span id='topic+group_rows'></span><span id='topic+group_indices'></span><span id='topic+group_vars'></span><span id='topic+groups'></span><span id='topic+group_size'></span><span id='topic+n_groups'></span>

<h3>Description</h3>


<ul>
<li> <p><code>group_data()</code> returns a data frame that defines the grouping structure. The columns give the values of the
grouping variables. The last column, always called <code>.rows</code>, is a list of integer vectors that gives the location of
the rows in each group.
</p>
</li></ul>


<ul>
<li> <p><code>group_rows()</code> returns the rows which each group contains.
</p>
</li></ul>


<ul>
<li> <p><code>group_indices()</code> returns an integer vector the same length as <code>.data</code> that gives the group that each row belongs
to.
</p>
</li></ul>


<ul>
<li> <p><code>group_vars()</code> gives names of grouping variables as character vector.
</p>
</li></ul>


<ul>
<li> <p><code>groups()</code> gives the names as a list of symbols.
</p>
</li></ul>


<ul>
<li> <p><code>group_size()</code> gives the size of each group.
</p>
</li></ul>


<ul>
<li> <p><code>n_groups()</code> gives the total number of groups.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>group_data(.data)

group_rows(.data)

group_indices(.data)

group_vars(x)

groups(x)

group_size(x)

n_groups(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_metadata_+3A_.data">.data</code>, <code id="group_metadata_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <a href="#topic+context">context</a> for equivalent functions that return values for the current group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c(1,1,2,2))
group_vars(df)
group_rows(df)
group_data(df)

gf &lt;- group_by(df, x)
group_vars(gf)
group_rows(gf)
group_data(gf)

</code></pre>

<hr>
<h2 id='group_split'>Split data.frame by groups</h2><span id='topic+group_split'></span><span id='topic+group_keys'></span>

<h3>Description</h3>

<p><code>group_split()</code> works like <code><a href="base.html#topic+split">base::split()</a></code> but
</p>

<ul>
<li><p> it uses the grouping structure from <code><a href="#topic+group_by">group_by()</a></code> and is therefore subject to the data mask
</p>
</li>
<li><p> it does not name the elements of the list based on the grouping as this typically loses information and is
confusing
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>group_split(.data, ..., .keep = TRUE)

group_keys(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_split_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="group_split_+3A_...">...</code></td>
<td>
<p>Grouping specification, forwarded to <code><a href="#topic+group_by">group_by()</a></code>.</p>
</td></tr>
<tr><td><code id="group_split_+3A_.keep">.keep</code></td>
<td>
<p><code>logical(1)</code>. Should the grouping columns be kept (default: TRUE)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Grouped <code>data.frame</code>s:</strong>
</p>
<p>The primary use case for <code>group_split()</code> is with already groups <code>data.frame</code>s, typically a result of <code><a href="#topic+group_by">group_by()</a></code>. In
this case, <code>group_split()</code> only uses the first argument, the grouped <code>data.frame</code>, and warns when <code>...</code> is used.
</p>
<p>Because some of these groups may be empty, it is best paired with <code>group_keys()</code> which identifies the representatives
of each grouping variable for the group.
</p>
<p><strong>Ungrouped <code>data.frame</code>s:</strong>
</p>
<p>When used on ungrouped <code>data.frame</code>s, <code>group_split()</code> forwards the <code>...</code> to <code>group_by()</code> before the split, therefore
the <code>...</code> are subject to the data mask.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>group_split()</code> returns a list of <code>data.frame</code>s. Each <code>data.frame</code> contains the rows of <code>.data</code> with the associated
group and all the columns, including the grouping variables.
</p>
</li>
<li> <p><code>group_keys()</code> returns a <code>data.frame</code> with one row per group, and one column per grouping variable
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+group_by">group_by()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grouped data.frames:
mtcars %&gt;% group_by(cyl, am) %&gt;% group_split()
mtcars %&gt;% group_by(cyl, am) %&gt;% group_split(.keep = FALSE)
mtcars %&gt;% group_by(cyl, am) %&gt;% group_keys()

# Ungrouped data.frames:
mtcars %&gt;% group_split(am, cyl)

</code></pre>

<hr>
<h2 id='if_else'>Vectorised if</h2><span id='topic+if_else'></span>

<h3>Description</h3>

<p>This is a wrapper around <code>ifelse()</code> which checks that <code>true</code> and <code>false</code> are of the same type, making the output more
predictable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else(condition, true, false, missing = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if_else_+3A_condition">condition</code></td>
<td>
<p>A <code>logical(n)</code> vector.</p>
</td></tr>
<tr><td><code id="if_else_+3A_true">true</code>, <code id="if_else_+3A_false">false</code></td>
<td>
<p>Values to use for <code>TRUE</code> and <code>FALSE</code> in <code>condition</code>. They must either be the same length as
<code>condition</code> or be length 1. They must also be the same type.</p>
</td></tr>
<tr><td><code id="if_else_+3A_missing">missing</code></td>
<td>
<p>If not <code>NULL</code> (the default), this will replace any missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>condition</code> with values for <code>TRUE</code> and <code>FALSE</code> replaced by those specified in
<code>true</code> and <code>false</code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-5:5, NA)
if_else(x &lt; 0, NA_integer_, x)
if_else(x &lt; 0, "negative", "positive", "missing")

# Unlike ifelse, if_else preserves types
x &lt;- factor(sample(letters[1:5], 10, replace = TRUE))
ifelse(x %in% c("a", "b", "c"), x, factor(NA))
# Attributes are taken from the `true` vector
if_else(x %in% c("a", "b", "c"), x, factor(NA))

</code></pre>

<hr>
<h2 id='lag'>Compute lagged or leading values</h2><span id='topic+lag'></span><span id='topic+lead'></span>

<h3>Description</h3>

<p>Find the &quot;previous&quot; (<code>lag()</code>) or &quot;next&quot; (<code>lead()</code>) values in a vector. Useful for comparing values behind of or ahead
of the current values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag(x, n = 1L, default = NA)

lead(x, n = 1L, default = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lag_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of values</p>
</td></tr>
<tr><td><code id="lag_+3A_n">n</code></td>
<td>
<p>A positive <code>integer(1)</code>, giving the number of positions to lead or lag by.</p>
</td></tr>
<tr><td><code id="lag_+3A_default">default</code></td>
<td>
<p>The value used for non-existent rows (default: <code>NA</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>lag(1:5)
lead(1:5)

x &lt;- 1:5
data.frame(behind = lag(x), x, ahead = lead(x))

# If you want to look more rows behind or ahead, use `n`
lag(1:5, n = 1)
lag(1:5, n = 2)

lead(1:5, n = 1)
lead(1:5, n = 2)

# If you want to define a value for non-existing rows, use `default`
lag(1:5)
lag(1:5, default = 0)

lead(1:5)
lead(1:5, default = 6)

</code></pre>

<hr>
<h2 id='lst'>Build a list</h2><span id='topic+lst'></span>

<h3>Description</h3>

<p><code>lst()</code> constructs a list, similar to <code><a href="base.html#topic+list">base::list()</a></code>, but where components
are built sequentially. When defining a component, you can refer to components
created earlier in the call. <code>lst()</code> also generates missing names
automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lst(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lst_+3A_...">...</code></td>
<td>
<p>Named or unnamed elements of a list. If the element is unnamed, its
expression will be used as its name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the value of n can be used immediately in the definition of x
lst(n = 5, x = runif(n))

# missing names are constructed from user's input
lst(1:3, z = letters[4:6], runif(3))

a &lt;- 1:3
b &lt;- letters[4:6]
lst(a, b)
</code></pre>

<hr>
<h2 id='mutate'>Create or transform variables</h2><span id='topic+mutate'></span><span id='topic+mutate.data.frame'></span><span id='topic+transmute'></span>

<h3>Description</h3>

<p><code>mutate()</code> adds new variables and preserves existing ones; <code>transmute()</code> adds new variables and drops existing ones.
Both functions preserve the number of rows of the input. New variables overwrite existing variables of the same name.
Variables can be removed by setting their value to <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate(.data, ...)

## S3 method for class 'data.frame'
mutate(
  .data,
  ...,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)

transmute(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions, each with length <code>1L</code>. The name of each argument will be the name of a
new column and the value will be its corresponding value. Use a <code>NULL</code> value in <code>mutate</code> to drop a variable. New
variables overwrite existing variables of the same name.</p>
</td></tr>
<tr><td><code id="mutate_+3A_.keep">.keep</code></td>
<td>
<p>This argument allows you to control which columns from <code>.data</code> are retained in the output:
</p>

<ul>
<li> <p><code>"all"</code>, the default, retains all variables.
</p>
</li>
<li> <p><code>"used"</code> keeps any variables used to make new variables; it's useful for checking your work as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> keeps only existing variables <strong>not</strong> used to make new variables.
</p>
</li>
<li> <p><code>"none"</code>, only keeps grouping keys (like <code><a href="#topic+transmute">transmute()</a></code>).
</p>
</li></ul>

<p>Grouping variables are always kept, unconditional to <code>.keep</code>.</p>
</td></tr>
<tr><td><code id="mutate_+3A_.before">.before</code>, <code id="mutate_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="#topic+select_helpers">poor-select</a></code>&gt; Optionally, control where new columns should appear (the
default is to add to the right hand side). See <code><a href="#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Useful mutate functions</h3>


<ul>
<li> <p><code><a href="base.html#topic++2B">+</a></code>, <code><a href="base.html#topic+-">-</a></code>, <code><a href="base.html#topic+log">log()</a></code>, etc., for their usual mathematical meanings
</p>
</li>
<li> <p><code><a href="#topic+lead">lead()</a></code>, <code><a href="#topic+lag">lag()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dense_rank">dense_rank()</a></code>, <code><a href="#topic+min_rank">min_rank()</a></code>, <code><a href="#topic+percent_rank">percent_rank()</a></code>, <code><a href="#topic+row_number">row_number()</a></code>, <code><a href="#topic+cume_dist">cume_dist()</a></code>, <code><a href="#topic+ntile">ntile()</a></code>
</p>
</li>
<li> <p><code><a href="base.html#topic+cumsum">cumsum()</a></code>, <code><a href="base.html#topic+cummin">cummin()</a></code>, <code><a href="base.html#topic+cummax">cummax()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+na_if">na_if()</a></code>, <code><a href="#topic+coalesce">coalesce()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+if_else">if_else()</a></code>, <code><a href="#topic+recode">recode()</a></code>, <code><a href="#topic+case_when">case_when()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mutate(mtcars, mpg2 = mpg * 2)
mtcars %&gt;% mutate(mpg2 = mpg * 2)
mtcars %&gt;% mutate(mpg2 = mpg * 2, cyl2 = cyl * 2)

# Newly created variables are available immediately
mtcars %&gt;% mutate(mpg2 = mpg * 2, mpg4 = mpg2 * 2)

# You can also use mutate() to remove variables and modify existing variables
mtcars %&gt;% mutate(
  mpg = NULL,
  disp = disp * 0.0163871 # convert to litres
)

# By default, new columns are placed on the far right.
# You can override this with `.before` or `.after`.
df &lt;- data.frame(x = 1, y = 2)
df %&gt;% mutate(z = x + y)
df %&gt;% mutate(z = x + y, .before = 1)
df %&gt;% mutate(z = x + y, .after = x)

# By default, mutate() keeps all columns from the input data.
# You can override with `.keep`
df &lt;- data.frame(
  x = 1, y = 2, a = "a", b = "b",
  stringsAsFactors = FALSE
)
df %&gt;% mutate(z = x + y, .keep = "all") # the default
df %&gt;% mutate(z = x + y, .keep = "used")
df %&gt;% mutate(z = x + y, .keep = "unused")
df %&gt;% mutate(z = x + y, .keep = "none") # same as transmute()

# mutate() vs transmute --------------------------
# mutate() keeps all existing variables
mtcars %&gt;%
  mutate(displ_l = disp / 61.0237)

# transmute keeps only the variables you create
mtcars %&gt;%
  transmute(displ_l = disp / 61.0237)

</code></pre>

<hr>
<h2 id='mutate_joins'>Mutating Joins</h2><span id='topic+mutate_joins'></span><span id='topic+inner_join'></span><span id='topic+left_join'></span><span id='topic+right_join'></span><span id='topic+full_join'></span>

<h3>Description</h3>

<p>The mutating joins add columns from <code>y</code> to <code>x</code>, matching rows based on the keys:
</p>

<ul>
<li> <p><code>inner_join()</code>: includes all rows in <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>left_join()</code>: includes all rows in <code>x</code>.
</p>
</li>
<li> <p><code>right_join()</code>: includes all rows in <code>y</code>.
</p>
</li>
<li> <p><code>full_join()</code>: includes all rows in <code>x</code> or <code>y</code>.
</p>
</li></ul>

<p>If a row in <code>x</code> matches multiple rows in <code>y</code>, all the rows in <code>y</code> will be returned once for each matching row in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  ...,
  na_matches = c("na", "never")
)

left_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)

right_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)

full_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate_joins_+3A_x">x</code>, <code id="mutate_joins_+3A_y">y</code></td>
<td>
<p>The <code>data.frame</code>s to join.</p>
</td></tr>
<tr><td><code id="mutate_joins_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by. If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will do a natural join,
using all variables with common names across the two tables. A message lists the variables so that you can check
they're right (to suppress the message, simply explicitly list the variables that you want to join).
</p>
<p>To join by different variables on x and y use a named vector. For example, <code>by = c("a" = "b")</code> will match <code>x.a</code> to
<code>y.b</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1. For example, <code>by = c("a", "b")</code> will match <code>x$a</code> to
<code>y$a</code> and <code>x$b</code> to <code>y$b</code>. Use a named vector to match different variables in <code>x</code> and <code>y</code>. For example,
<code>by = c("a" = "b", "c" = "d")</code> will match <code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, use <code>by = character()</code>.</p>
</td></tr>
<tr><td><code id="mutate_joins_+3A_suffix">suffix</code></td>
<td>
<p><code>character(2)</code>. If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be
added to the output to disambiguate them.</p>
</td></tr>
<tr><td><code id="mutate_joins_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="base.html#topic+merge">merge()</a></code></p>
</td></tr>
<tr><td><code id="mutate_joins_+3A_na_matches">na_matches</code></td>
<td>
<p>Should <code>NA</code> and <code>NaN</code> values match one another?
</p>
<p>The default, <code>"na"</code>, treats two <code>NA</code> or <code>NaN</code> values as equal, like <code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
<p>Use <code>"never"</code> to always treat two <code>NA</code> or <code>NaN</code> values as different, like joins for database sources, similarly to
<code>merge(incomparables = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="mutate_joins_+3A_keep">keep</code></td>
<td>
<p><code>logical(1)</code>. Should the join keys from both <code>x</code> and <code>y</code> be preserved in the output? Only applies to
<code>left_join()</code>, <code>right_join()</code>, and <code>full_join()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>. The order of the rows and columns of <code>x</code> is preserved as much as possible. The output has the
following properties:
</p>

<ul>
<li><p> For <code>inner_join()</code>, a subset of <code>x</code> rows.
For <code>left_join()</code>, all <code>x</code> rows.
For <code>right_join()</code>, a subset of <code>x</code> rows, followed by unmatched <code>y</code> rows.
For <code>full_join()</code>, all <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li>
<li><p> For all joins, rows will be duplicated if one or more rows in <code>x</code> matches multiple rows in <code>y</code>.
</p>
</li>
<li><p> Output columns include all <code>x</code> columns and all <code>y</code> columns. If columns in <code>x</code> and <code>y</code> have the same name (and
aren't included in <code>by</code>), <code>suffix</code>es are added to disambiguate.
</p>
</li>
<li><p> Output columns included in <code>by</code> are coerced to common type across <code>x</code> and <code>y</code>.
</p>
</li>
<li><p> Groups are taken from <code>x</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># If a row in `x` matches multiple rows in `y`, all the rows in `y` will be
# returned once for each matching row in `x`
df1 &lt;- data.frame(x = 1:3)
df2 &lt;- data.frame(x = c(1, 1, 2), y = c("first", "second", "third"))
df1 %&gt;% left_join(df2)

# By default, NAs match other NAs so that there are two
# rows in the output of this join:
df1 &lt;- data.frame(x = c(1, NA), y = 2)
df2 &lt;- data.frame(x = c(1, NA), z = 3)
left_join(df1, df2)

# You can optionally request that NAs don't match, giving a
# a result that more closely resembles SQL joins
left_join(df1, df2, na_matches = "never")

</code></pre>

<hr>
<h2 id='n_distinct'>Count the number of unique values in a set of vectors</h2><span id='topic+n_distinct'></span>

<h3>Description</h3>

<p>This is the equivalent of <code>length(unique(x))</code> for multiple vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_distinct(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_distinct_+3A_...">...</code></td>
<td>
<p>Vectors of values.</p>
</td></tr>
<tr><td><code id="n_distinct_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical(1)</code>. If <code>TRUE</code> missing values don't count.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:10, 1e5, rep = TRUE)
length(unique(x))
n_distinct(x)

</code></pre>

<hr>
<h2 id='na_if'>Convert values to NA</h2><span id='topic+na_if'></span>

<h3>Description</h3>

<p>This is a translation of the SQL command <code>NULLIF</code>. It is useful if you want to convert an annoying value to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_if(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na_if_+3A_x">x</code></td>
<td>
<p>The vector to modify.</p>
</td></tr>
<tr><td><code id="na_if_+3A_y">y</code></td>
<td>
<p>The value to replace with <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of <code>x</code> that replaces any values that are equal to <code>y</code> with <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coalesce">coalesce()</a></code> to replace missing values within subsequent <code>vector</code>(s) of value(s). <code><a href="#topic+replace_na">replace_na()</a></code> to replace <code>NA</code> with
a value.
</p>
<p><code><a href="#topic+replace_na">replace_na()</a></code> to replace <code>NA</code> with a value.
</p>
<p><code><a href="#topic+recode">recode()</a></code> to more generally replace values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na_if(1:5, 5:1)

x &lt;- c(1, -1, 0, 10)
100 / x
100 / na_if(x, 0)

y &lt;- c("abc", "def", "", "ghi")
na_if(y, "")

# na_if() is particularly useful inside mutate(),
# and is meant for use with vectors rather than entire data.frames
mtcars %&gt;%
  mutate(cyl = na_if(cyl, 6))

</code></pre>

<hr>
<h2 id='near'>Compare two numeric vectors</h2><span id='topic+near'></span>

<h3>Description</h3>

<p>This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal.  This is safer than
using <code>==</code>, because it has a built in tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>near(x, y, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="near_+3A_x">x</code>, <code id="near_+3A_y">y</code></td>
<td>
<p>Numeric vectors to compare</p>
</td></tr>
<tr><td><code id="near_+3A_tol">tol</code></td>
<td>
<p>Tolerance of comparison.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sqrt(2) ^ 2 == 2
near(sqrt(2) ^ 2, 2)

</code></pre>

<hr>
<h2 id='nest_by'>Nest By</h2><span id='topic+nest_by'></span>

<h3>Description</h3>

<p><code>nest_by()</code> is similar to <code><a href="#topic+group_by">group_by()</a></code> however instead of storing the group structure in the metadata, it is made
explicit in the data. Each group key is given a single row within the <code>data.frame</code> and the group's data is stored
within a list-column of the <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_by(.data, ..., .key = "data", .keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nest_by_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="nest_by_+3A_...">...</code></td>
<td>
<p>Grouping specification, forwarded to <code><a href="#topic+group_by">group_by()</a></code>.</p>
</td></tr>
<tr><td><code id="nest_by_+3A_.key">.key</code></td>
<td>
<p><code>character(1)</code>. The name of the column in which to nest the data (default: &quot;data&quot;).</p>
</td></tr>
<tr><td><code id="nest_by_+3A_.keep">.keep</code></td>
<td>
<p><code>logical(1)</code>. Should the grouping columns be kept (default: TRUE)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently there is no pretty-printing provided for the results of <code>nest_by()</code> and they are not useable with other
functions such as <code><a href="#topic+mutate">mutate()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% nest_by(am, cyl)
# Or equivalently
mtcars %&gt;% group_by(am, cyl) %&gt;% nest_by()

</code></pre>

<hr>
<h2 id='nth'>Extract the first, last or nth value from a vector</h2><span id='topic+nth'></span><span id='topic+first'></span><span id='topic+last'></span>

<h3>Description</h3>

<p>These are straightforward wrappers around <code><a href="base.html#topic++5B+5B">[[</a></code>. The main advantage is that you can provide an optional
secondary vector that defines the ordering, and provide a default value to use when the input is shorter than
expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nth(x, n, order_by = NULL, default = default_missing(x))

first(x, order_by = NULL, default = default_missing(x))

last(x, order_by = NULL, default = default_missing(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nth_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="nth_+3A_n">n</code></td>
<td>
<p>For <code>nth()</code>, a single integer specifying the position. Negative integers index from the end (i.e. <code>-1L</code>
will return the last value in the vector).
</p>
<p>If a double is supplied, it will be silently truncated.</p>
</td></tr>
<tr><td><code id="nth_+3A_order_by">order_by</code></td>
<td>
<p>An optional vector used to determine the order</p>
</td></tr>
<tr><td><code id="nth_+3A_default">default</code></td>
<td>
<p>A default value to use if the position does not exist in the input. This is guessed by default for
base vectors, where a missing value of the appropriate type is returned, and for lists, where a <code>NULL</code> is return.
</p>
<p>For more complicated objects, you'll need to supply this value. Make sure it is the same type as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value. <code>[[</code> is used to do the subsetting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
y &lt;- 10:1

first(x)
last(y)

nth(x, 1)
nth(x, 5)
nth(x, -2)
nth(x, 11)

last(x)
# Second argument provides optional ordering
last(x, y)

# These functions always return a single value
first(integer())

</code></pre>

<hr>
<h2 id='peek_vars'>Peek at variables in the selection context</h2><span id='topic+peek_vars'></span>

<h3>Description</h3>

<p>Return the vector of column names of the data currently available for selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek_vars()
</code></pre>


<h3>Value</h3>

<p>A vector of column names.
</p>

<hr>
<h2 id='pipe'>Forward-pipe operator</h2><span id='topic+pipe'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe an object forward into a function or call expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_+3A_lhs">lhs</code></td>
<td>
<p>The result you are piping.</p>
</td></tr>
<tr><td><code id="pipe_+3A_rhs">rhs</code></td>
<td>
<p>Where you are piping the result to.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathan Eastwood and Antoine Fabri <a href="mailto:antoine.fabri@gmail.com">antoine.fabri@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic use:
iris %&gt;% head

# Use with lhs as first argument
iris %&gt;% head(10)

# Using the dot place-holder
"Ceci n'est pas une pipe" %&gt;% gsub("une", "un", .)

# When dot is nested, lhs is still placed first:
sample(1:10) %&gt;% paste0(LETTERS[.])

# This can be avoided:
rnorm(100) %&gt;% {c(min(.), mean(.), max(.))} %&gt;% floor

# Lambda expressions:
iris %&gt;%
  {
    size &lt;- sample(1:10, size = 1)
    rbind(head(., size), tail(., size))
  }

# renaming in lambdas:
iris %&gt;%
  {
    my_data &lt;- .
    size &lt;- sample(1:10, size = 1)
    rbind(head(my_data, size), tail(my_data, size))
  }

</code></pre>

<hr>
<h2 id='pivot_longer'>Pivot data from wide to long</h2><span id='topic+pivot_longer'></span>

<h3>Description</h3>

<p><code>pivot_longer()</code> &quot;lengthens&quot; data, increasing the number of rows and decreasing the number of columns. The inverse
transformation is <code><a href="#topic+pivot_wider">pivot_wider()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_longer(
  data,
  cols,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  values_to = "value",
  values_drop_na = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_longer_+3A_data">data</code></td>
<td>
<p><code>data.frame</code>. The data to pivot.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="#topic+select_helpers">poor-select</a></code>&gt;. Columns to pivot into longer format.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_to">names_to</code></td>
<td>
<p><code>character(n)</code>. The name of the new column(s) that will contain the column names.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_prefix">names_prefix</code></td>
<td>
<p><code>character(1)</code>. A regular expression used to remove matching text from the start of each variable
name.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_sep">names_sep</code>, <code id="pivot_longer_+3A_names_pattern">names_pattern</code></td>
<td>
<p><code>character(1)</code>. If <code>names_to</code> contains multiple values, this argument controls how the
column name is broken up. <code>names_pattern</code> takes a regular expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_values_to">values_to</code></td>
<td>
<p><code>character(n)</code>. The name of the new column(s) that will contain the values of the pivoted variables.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p><code>logical(1)</code>. If <code>TRUE</code>, will drop rows that contain only <code>NA</code> in the <code>values_to</code> column. This
effectively converts explicit missing values to implicit missing values, and should generally be used only when
missing values in data were created by its structure.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wide_data &lt;- data.frame(replicate(5, rnorm(10)))
# Customizing the names
pivot_longer(
  data = wide_data,
  cols = c(1, 2),
  names_to = "Column",
  values_to = "Numbers"
)

</code></pre>

<hr>
<h2 id='pivot_wider'>Pivot data from long to wide</h2><span id='topic+pivot_wider'></span>

<h3>Description</h3>

<p><code>pivot_wider()</code> &quot;widens&quot; data, increasing the number of columns and decreasing the number of rows. The inverse
transformation is <code><a href="#topic+pivot_longer">pivot_longer()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_wider(
  data,
  id_cols = NULL,
  values_from = "Value",
  names_from = "Name",
  names_sep = "_",
  names_prefix = "",
  names_glue = NULL,
  values_fill = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_wider_+3A_data">data</code></td>
<td>
<p><code>data.frame</code>. The data to pivot.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_id_cols">id_cols</code></td>
<td>
<p><code>character(1)</code>. The name of the column that identifies the rows. If <code>NULL</code>, it will use all the unique
rows.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_values_from">values_from</code></td>
<td>
<p><code>character(n)</code>. The name of the column that contains the values to be used as future variable
values.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_from">names_from</code></td>
<td>
<p><code>character(n)</code>. The name of the column(s) that contains the levels to be used as future column
names.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_sep">names_sep</code></td>
<td>
<p><code>character(1)</code>. If <code>names_from</code> or <code>values_from</code> contains multiple variables, this will be used to
join their values together into a single string to use as a column name.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_prefix">names_prefix</code></td>
<td>
<p><code>character(1)</code>. String added to the start of every variable name. This is particularly useful if
<code>names_from</code> is a numeric vector and you want to create syntactic variable names.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_glue">names_glue</code></td>
<td>
<p><code>character(1)</code>. Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply a
<a href="https://glue.tidyverse.org/index.html">glue specification</a> that uses the <code>names_from</code> columns to create custom
column names. Note that the only delimiters supported by <code>names_glue</code> are curly brackets, <code style="white-space: pre;">&#8288;{&#8288;</code> and <code style="white-space: pre;">&#8288;}&#8288;</code>.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_values_fill">values_fill</code></td>
<td>
<p><code>numeric(n)</code>. Optionally, a (scalar) value that will be used to replace missing values in the new
columns created.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_...">...</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a tibble was provided as input, <code>pivot_wider()</code> also returns a
tibble. Otherwise, it returns a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_long &lt;- read.table(header = TRUE, text = "
 subject sex condition measurement
       1   M   control         7.9
       1   M     cond1        12.3
       1   M     cond2        10.7
       2   F   control         6.3
       2   F     cond1        10.6
       2   F     cond2        11.1
       3   F   control         9.5
       3   F     cond1        13.1
       3   F     cond2        13.8
       4   M   control        11.5
       4   M     cond1        13.4
       4   M     cond2        12.9")


pivot_wider(
  data_long,
  id_cols = "subject",
  names_from = "condition",
  values_from = "measurement"
)

pivot_wider(
  data_long,
  id_cols = "subject",
  names_from = "condition",
  values_from = "measurement",
  names_prefix = "Var.",
  names_sep = "."
)

production &lt;- expand.grid(
  product = c("A", "B"),
  country = c("AI", "EI"),
  year = 2000:2014
) %&gt;%
  filter((product == "A" &amp; country == "AI") | product == "B") %&gt;%
  mutate(production = rnorm(nrow(.)))

pivot_wider(
  production,
  names_from = c("product", "country"),
  values_from = "production",
  names_glue = "prod_{product}_{country}"
)

</code></pre>

<hr>
<h2 id='pull'>Pull out a single variable</h2><span id='topic+pull'></span>

<h3>Description</h3>

<p>This is a direct replacement for <code style="white-space: pre;">&#8288;[[.data.frame&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull(.data, var = -1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="pull_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal variable name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right
</p>
</li></ul>

<p>The default returns the last column (on the assumption that's the column you've created most recently).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% pull(-1)
mtcars %&gt;% pull(1)
mtcars %&gt;% pull(cyl)
mtcars %&gt;% pull("cyl")

</code></pre>

<hr>
<h2 id='recode'>Recode values</h2><span id='topic+recode'></span><span id='topic+recode_factor'></span>

<h3>Description</h3>

<p>This is a vectorised version of <code><a href="base.html#topic+switch">switch()</a></code>: you can replace <code>numeric</code> values based on their position or their name,
and <code>character</code> or <code>factor</code> values only by their name. This is an S3 generic: <code>{poorman}</code> provides methods for
<code>numeric</code>,  <code>character</code>, and <code>factor</code>s. For <code>logical</code> vectors, use <code><a href="#topic+if_else">if_else()</a></code>. For more complicated criteria, use
<code><a href="#topic+case_when">case_when()</a></code>.
</p>
<p>You can use <code>recode()</code> directly with <code>factor</code>s; it will preserve the existing order of levels while changing the
values. Alternatively, you can use <code>recode_factor()</code>, which will change the order of levels to match the order of
replacements.
</p>
<p>This is a direct port of the <code>dplyr::recode()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(.x, ..., .default = NULL, .missing = NULL)

recode_factor(.x, ..., .default = NULL, .missing = NULL, .ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recode_+3A_.x">.x</code></td>
<td>
<p>A vector to modify</p>
</td></tr>
<tr><td><code id="recode_+3A_...">...</code></td>
<td>
<p>Replacements. For <code>character</code> and <code>factor</code> <code>.x</code>, these should be named and replacement is based only on
their name. For <code>numeric</code> <code>.x</code>, these can be named or not. If not named, the replacement is done based on position
i.e. <code>.x</code> represents positions to look for in replacements. See examples.
</p>
<p>When named, the argument names should be the current values to be replaced, and the argument values should be the new
(replacement) values.
</p>
<p>All replacements must be the same type, and must have either length one or the same length as <code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_.default">.default</code></td>
<td>
<p>If supplied, all values not otherwise matched will be given this value. If not supplied and if the
replacements are the same type as the original values in <code>.x</code>, unmatched values are not changed. If not supplied and
if the replacements are not compatible, unmatched values are replaced with <code>NA</code>.
</p>
<p><code>.default</code> must be either length 1 or the same length as <code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_.missing">.missing</code></td>
<td>
<p>If supplied, any missing values in <code>.x</code> will be replaced by this value. Must be either length 1 or
the same length as <code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_.ordered">.ordered</code></td>
<td>
<p><code>logical(1)</code>. If <code>TRUE</code>, <code>recode_factor()</code> creates an ordered <code>factor</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>.x</code>, and the same type as
the first of <code>...</code>, <code>.default</code>, or <code>.missing</code>.
<code>recode_factor()</code> returns a factor whose levels are in the same order as
in <code>...</code>. The levels in <code>.default</code> and <code>.missing</code> come last.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+na_if">na_if()</a></code> to replace specified values with a <code>NA</code>.
</p>
<p><code><a href="#topic+coalesce">coalesce()</a></code> to replace missing values with a specified value.
</p>
<p><code><a href="#topic+replace_na">replace_na()</a></code> to replace <code>NA</code> with a value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For character values, recode values with named arguments only. Unmatched
# values are unchanged.
char_vec &lt;- sample(c("a", "b", "c"), 10, replace = TRUE)
recode(char_vec, a = "Apple")
recode(char_vec, a = "Apple", b = "Banana")

# Use .default as replacement for unmatched values. Note that NA and
# replacement values need to be of the same type.
recode(char_vec, a = "Apple", b = "Banana", .default = NA_character_)

# Throws an error as NA is logical, not character.
## Not run: 
recode(char_vec, a = "Apple", b = "Banana", .default = NA)

## End(Not run)

# For numeric values, named arguments can also be used
num_vec &lt;- c(1:4, NA)
recode(num_vec, `2` = 20L, `4` = 40L)

# Or if you don't name the arguments, recode() matches by position.
# (Only works for numeric vector)
recode(num_vec, "a", "b", "c", "d")
# .x (position given) looks in (...), then grabs (... value at position)
# so if nothing at position (here 5), it uses .default or NA.
recode(c(1, 5, 3), "a", "b", "c", "d", .default = "nothing")

# Note that if the replacements are not compatible with .x,
# unmatched values are replaced by NA and a warning is issued.
recode(num_vec, `2` = "b", `4` = "d")
# use .default to change the replacement value
recode(num_vec, "a", "b", "c", .default = "other")
# use .missing to replace missing values in .x
recode(num_vec, "a", "b", "c", .default = "other", .missing = "missing")

# For factor values, use only named replacements
# and supply default with levels()
factor_vec &lt;- factor(c("a", "b", "c"))
recode(factor_vec, a = "Apple", .default = levels(factor_vec))

# Use recode_factor() to create factors with levels ordered as they
# appear in the recode call. The levels in .default and .missing
# come last.
recode_factor(num_vec, `1` = "z", `2` = "y", `3` = "x")
recode_factor(num_vec, `1` = "z", `2` = "y", `3` = "x", .default = "D")
recode_factor(num_vec, `1` = "z", `2` = "y", `3` = "x", .default = "D", .missing = "M")

# When the input vector is a compatible vector (character vector or
# factor), it is reused as default.
recode_factor(letters[1:3], b = "z", c = "y")
recode_factor(factor(letters[1:3]), b = "z", c = "y")

</code></pre>

<hr>
<h2 id='relocate'>Change column order</h2><span id='topic+relocate'></span>

<h3>Description</h3>

<p>Use <code>relocate()</code> to change column positions, using the same syntax as <code><a href="#topic+select">select()</a></code> to make it easy to move blocks of
columns at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relocate(.data, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relocate_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="relocate_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="#topic+select_helpers">poor-select</a></code>&gt; Columns to move.</p>
</td></tr>
<tr><td><code id="relocate_+3A_.before">.before</code>, <code id="relocate_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="#topic+select_helpers">poor-select</a></code>&gt; Destination of columns selected by <code>...</code>. Supplying neither
will move columns to the left-hand side; specifying both will result in an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> The same columns appear in the output, but (usually) in a different place.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are not affected.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  a = 1, b = 1, c = 1, d = "a", e = "a", f = "a",
  stringsAsFactors = FALSE
)
df %&gt;% relocate(f)
df %&gt;% relocate(a, .after = c)
df %&gt;% relocate(f, .before = b)
df %&gt;% relocate(a, .after = last_col())

# Can also select variables based on their type
df %&gt;% relocate(where(is.character))
df %&gt;% relocate(where(is.numeric), .after = last_col())
# Or with any other select helper
df %&gt;% relocate(any_of(c("a", "e", "i", "o", "u")))

# When .before or .after refers to multiple variables they will be
# moved to be immediately before/after the selected variables.
df2 &lt;- data.frame(
  a = 1, b = "a", c = 1, d = "a",
  stringsAsFactors = FALSE
)
df2 %&gt;% relocate(where(is.numeric), .after = where(is.character))
df2 %&gt;% relocate(where(is.numeric), .before = where(is.character))

</code></pre>

<hr>
<h2 id='rename'>Rename columns</h2><span id='topic+rename'></span><span id='topic+rename_with'></span>

<h3>Description</h3>

<p><code>rename()</code> changes the names of individual variables using <code>new_name = old_name</code> syntax.
<code>rename_with()</code> renames columns using a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename(.data, ...)

rename_with(.data, .fn, .cols = everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="rename_+3A_...">...</code></td>
<td>
<p>For <code>rename()</code>: comma separated key-value pairs in the form of <code>new_name = old_name</code> to rename selected variables.
</p>
<p>For <code>rename_with()</code>: additional arguments passed onto <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="rename_+3A_.fn">.fn</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;function()&#8288;</code> used to transform the selected <code>.cols</code>. Should return a character vector the same length as
the input.</p>
</td></tr>
<tr><td><code id="rename_+3A_.cols">.cols</code></td>
<td>
<p>Columns to rename; defaults to all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> Column names are changed; column order is preserved.
</p>
</li>
<li> <p><code>data.frame</code> attributes are preserved.
</p>
</li>
<li><p> Groups are updated to reflect new names.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>rename(mtcars, MilesPerGallon = mpg)
rename(mtcars, Cylinders = cyl, Gears = gear)
mtcars %&gt;% rename(MilesPerGallon = mpg)

rename_with(mtcars, toupper)
rename_with(mtcars, toupper, starts_with("c"))

</code></pre>

<hr>
<h2 id='replace_na'>Replace missing values</h2><span id='topic+replace_na'></span>

<h3>Description</h3>

<p>Replace missing values in a <code>data.frame</code> or <code>vector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na(data, replace, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_na_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="replace_na_+3A_replace">replace</code></td>
<td>
<p>If <code>data</code> is a <code>data.frame</code>, a named <code>list</code> giving the value to replace <code>NA</code> with for each column. If
<code>data</code> is a <code>vector</code>, a single value used for replacement.</p>
</td></tr>
<tr><td><code id="replace_na_+3A_...">...</code></td>
<td>
<p>Additional arguments passed onto methods; not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>data</code> is a <code>data.frame</code>, <code>replace_na()</code> returns a <code>data.frame</code>. If <code>data</code> is a <code>vector</code>, <code>replace_na()</code> returns a
<code>vector</code> of class determined by the union of <code>data</code> and <code>replace</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+na_if">na_if()</a></code> to replace specified values with a <code>NA</code>.
</p>
<p><code><a href="#topic+coalesce">coalesce()</a></code> to replace missing values within subsequent <code>vector</code>(s) of value(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c(1, 2, NA), y = c("a", NA, "b"), stringsAsFactors = FALSE)
df %&gt;% replace_na(list(x = 0, y = "unknown"))
df %&gt;% mutate(x = replace_na(x, 0))

df$x %&gt;% replace_na(0)
df$y %&gt;% replace_na("unknown")

</code></pre>

<hr>
<h2 id='rownames'>Tools for working with row names</h2><span id='topic+rownames'></span><span id='topic+rownames_to_column'></span><span id='topic+rowid_to_column'></span><span id='topic+column_to_rownames'></span><span id='topic+remove_rownames'></span><span id='topic+has_rownames'></span>

<h3>Description</h3>

<p>In some quarters, it is considered best to avoid row names, because they are effectively a character column with
different semantics than every other column.
These functions allow to you detect if a <code>data.frame</code> has row names (<code>has_rownames()</code>), remove them
(<code>remove_rownames()</code>), or convert them back-and-forth between an explicit column (<code>rownames_to_column()</code> and
<code>column_to_rownames()</code>). Also included is <code>rowid_to_column()</code>, which adds a column at the start of the dataframe of
ascending sequential row ids starting at 1. Note that this will remove any existing row names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rownames_to_column(.data, var = "rowname")

rowid_to_column(.data, var = "rowid")

column_to_rownames(.data, var = "rowname")

remove_rownames(.data)

has_rownames(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rownames_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="rownames_+3A_var">var</code></td>
<td>
<p><code>character(1)</code>. The name of the column to use for row names.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>column_to_rownames()</code> always returns a <code>data.frame</code>.
</p>
</li>
<li> <p><code>has_rownames()</code> returns a <code>logical(1)</code>.
</p>
</li>
<li><p> All other functions return an object of the same class as the input.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Detect row names
has_rownames(mtcars)
has_rownames(iris)

# Remove row names
remove_rownames(mtcars) %&gt;% has_rownames()

# Convert between row names and column
mtcars &lt;- rownames_to_column(mtcars, var = "car")
column_to_rownames(mtcars, var = "car") %&gt;% head()

# Adding rowid as a column
rowid_to_column(iris) %&gt;% head()

</code></pre>

<hr>
<h2 id='select'>Subset columns using their names and types</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>Select (and optionally rename) variables in a <code>data.frame</code>, using a concise mini-language that makes it easy to refer
to variables based on their name (e.g. <code>a:f</code> selects all columns from <code>a</code> on the left to <code>f</code> on the right). You can
also use predicate functions like <code><a href="base.html#topic+is.numeric">is.numeric()</a></code> to select variables based on their properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="#topic+select_helpers">poor-select</a></code>&gt; One or more unquoted expressions separated by commas. Variable names can
be used as if they were positions in the data frame, so expressions like <code>x:y</code> can be used to select a range of
variables.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Overview of selection features</h4>

<p>poorman selections implement a dialect of R where operators make it easy to select variables:
</p>

<ul>
<li> <p><code>:</code> for selecting a range of consecutive variables.
</p>
</li>
<li> <p><code>!</code> for taking the complement of a set of variables.
</p>
</li>
<li> <p><code>&amp;</code> and <code>|</code> for selecting the intersection or the union of two sets of variables.
</p>
</li>
<li> <p><code>c()</code> for combining selections.
</p>
</li></ul>

<p>In addition, you can use <strong>selection helpers</strong>. Some helpers select specific columns:
</p>

<ul>
<li> <p><code><a href="#topic+everything">everything()</a></code>: Matches all variables.
</p>
</li>
<li> <p><code><a href="#topic+last_col">last_col()</a></code>: Select last variable, possibly with an offset.
</p>
</li></ul>

<p>These helpers select variables by matching patterns in their names:
</p>

<ul>
<li> <p><code><a href="#topic+starts_with">starts_with()</a></code>: Starts with a prefix.
</p>
</li>
<li> <p><code><a href="#topic+ends_with">ends_with()</a></code>: Ends with a suffix.
</p>
</li>
<li> <p><code><a href="#topic+contains">contains()</a></code>: Contains a literal string.
</p>
</li>
<li> <p><code><a href="#topic+matches">matches()</a></code>: Matches a regular expression.
</p>
</li>
<li> <p><code><a href="#topic+num_range">num_range()</a></code>: Matches a numerical range like <code>x01</code>, <code>x02</code>, <code>x03</code>.
</p>
</li></ul>

<p>These helpers select variables from a character vector:
</p>

<ul>
<li> <p><code><a href="#topic+all_of">all_of()</a></code>: Matches variable names in a character vector. All names must be present, otherwise an out-of-bounds
error is thrown.
</p>
</li>
<li> <p><code><a href="#topic+any_of">any_of()</a></code>: Same as <code>all_of()</code>, except that no error is thrown for names that don't exist.
</p>
</li></ul>

<p>This helper selects variables with a function:
</p>

<ul>
<li> <p><code><a href="#topic+where">where()</a></code>: Applies a function to all variables and selects those for which the function returns <code>TRUE</code>.
</p>
</li></ul>




<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> Output columns are a subset of input columns, potentially with a different order. Columns will be renamed if
<code>new_name = old_name</code> form is used.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are maintained; you can't select off grouping variables.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Here we show the usage for the basic selection operators. See the
# specific help pages to learn about helpers like [starts_with()].

# Select variables by name:
mtcars %&gt;% select(mpg)

# Select multiple variables by separating them with commas. Note
# how the order of columns is determined by the order of inputs:
mtcars %&gt;% select(disp, gear, am)

# Rename variables:
mtcars %&gt;% select(MilesPerGallon = mpg, everything())

# The `:` operator selects a range of consecutive variables:
select(mtcars, mpg:cyl)

# The `!` operator negates a selection:
mtcars %&gt;% select(!(mpg:qsec))
mtcars %&gt;% select(!ends_with("p"))

# `&amp;` and `|` take the intersection or the union of two selections:
iris %&gt;% select(starts_with("Petal") &amp; ends_with("Width"))
iris %&gt;% select(starts_with("Petal") | ends_with("Width"))

# To take the difference between two selections, combine the `&amp;` and
# `!` operators:
iris %&gt;% select(starts_with("Petal") &amp; !ends_with("Width"))

</code></pre>

<hr>
<h2 id='select_helpers'>Select Helpers</h2><span id='topic+select_helpers'></span><span id='topic+starts_with'></span><span id='topic+ends_with'></span><span id='topic+contains'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+all_of'></span><span id='topic+any_of'></span><span id='topic+everything'></span><span id='topic+last_col'></span>

<h3>Description</h3>

<p>These functions allow you to select variables based on their names.
</p>

<ul>
<li> <p><code>starts_with()</code>: Starts with a prefix.
</p>
</li>
<li> <p><code>ends_with()</code>: Ends with a prefix.
</p>
</li>
<li> <p><code>contains()</code>: Contains a literal string.
</p>
</li>
<li> <p><code>matches()</code>: Matches a regular expression.
</p>
</li>
<li> <p><code>all_of()</code>: Matches variable names in a character vector. All names must be present, otherwise an error is thrown.
</p>
</li>
<li> <p><code>any_of()</code>: The same as <code>all_of()</code> except it doesn't throw an error.
</p>
</li>
<li> <p><code>everything()</code>: Matches all variables.
</p>
</li>
<li> <p><code>last_col()</code>: Select the last variable, possibly with an offset.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>starts_with(match, ignore.case = TRUE, vars = peek_vars())

ends_with(match, ignore.case = TRUE, vars = peek_vars())

contains(match, ignore.case = TRUE, vars = peek_vars())

matches(match, ignore.case = TRUE, perl = FALSE, vars = peek_vars())

num_range(prefix, range, width = NULL, vars = peek_vars())

all_of(x, vars = peek_vars())

any_of(x, vars = peek_vars())

everything(vars = peek_vars())

last_col(offset = 0L, vars = peek_vars())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_helpers_+3A_match">match</code></td>
<td>
<p><code>character(n)</code>. If length &gt; 1, the union of the matches is taken.</p>
</td></tr>
<tr><td><code id="select_helpers_+3A_ignore.case">ignore.case</code></td>
<td>
<p><code>logical(1)</code>. If <code>TRUE</code>, the default, ignores case when matching names.</p>
</td></tr>
<tr><td><code id="select_helpers_+3A_vars">vars</code></td>
<td>
<p><code>character(n)</code>. A character vector of variable names. When called from inside selecting functions such as
<code>select()</code>, these are automatically set to the names of the table.</p>
</td></tr>
<tr><td><code id="select_helpers_+3A_perl">perl</code></td>
<td>
<p><code>logical(1)</code>. Should Perl-compatible regexps be used?</p>
</td></tr>
<tr><td><code id="select_helpers_+3A_prefix">prefix</code></td>
<td>
<p>A prefix which starts the numeric range.</p>
</td></tr>
<tr><td><code id="select_helpers_+3A_range">range</code></td>
<td>
<p><code>integer(n)</code>. A sequence of integers, e.g. <code>1:5</code>.</p>
</td></tr>
<tr><td><code id="select_helpers_+3A_width">width</code></td>
<td>
<p><code>numeric(1)</code>. Optionally, the &quot;width&quot; of the numeric range. For example, a range of 2 gives &quot;01&quot;, a
range of three &quot;001&quot;, etc.</p>
</td></tr>
<tr><td><code id="select_helpers_+3A_x">x</code></td>
<td>
<p><code>character(n)</code>. A vector of column names.</p>
</td></tr>
<tr><td><code id="select_helpers_+3A_offset">offset</code></td>
<td>
<p><code>integer(1)</code>. Select the <code>n</code>th variable from the end of the <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector giving the position of the matched variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select()</a></code>, <code><a href="#topic+relocate">relocate()</a></code>, <code><a href="#topic+where">where()</a></code>, <code><a href="#topic+group_cols">group_cols()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% select(starts_with("c"))
mtcars %&gt;% select(starts_with(c("c", "h")))
mtcars %&gt;% select(ends_with("b"))
mtcars %&gt;% relocate(contains("a"), .before = mpg)
iris %&gt;% select(matches(".t."))
mtcars %&gt;% select(last_col())

# `all_of()` selects the variables in a character vector:
iris %&gt;% select(all_of(c("Petal.Length", "Petal.Width")))
# `all_of()` is strict and will throw an error if the column name isn't found
try({iris %&gt;% select(all_of(c("Species", "Genres")))})
# However `any_of()` allows missing variables
iris %&gt;% select(any_of(c("Species", "Genres")))

</code></pre>

<hr>
<h2 id='slice'>Subset rows by position</h2><span id='topic+slice'></span><span id='topic+slice_head'></span><span id='topic+slice_tail'></span><span id='topic+slice_min'></span><span id='topic+slice_max'></span><span id='topic+slice_sample'></span>

<h3>Description</h3>

<p>Subset rows by their original position in the <code>data.frame</code>. Grouped <code>data.frame</code>s use the position within each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(.data, ...)

slice_head(.data, ..., n, prop)

slice_tail(.data, ..., n, prop)

slice_min(.data, order_by, ..., n, prop, with_ties = TRUE)

slice_max(.data, order_by, ..., n, prop, with_ties = TRUE)

slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="slice_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop. The values provided must be either all positive
or negative. Indices beyond the number of rows in the input are silently ignored.</p>
</td></tr>
<tr><td><code id="slice_+3A_n">n</code>, <code id="slice_+3A_prop">prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the proportion of rows to select. If neither are
supplied, <code>n = 1</code> will be used.
</p>
<p>If <code>n</code> is greater than the number of rows in the group (or <code>prop &gt; 1</code>), the result will be silently truncated to the
group size. If the <code>prop</code>ortion of a group size is not an integer, it is rounded down.</p>
</td></tr>
<tr><td><code id="slice_+3A_order_by">order_by</code></td>
<td>
<p>The variable to order by.</p>
</td></tr>
<tr><td><code id="slice_+3A_with_ties">with_ties</code></td>
<td>
<p><code>logical(1)</code>. Should ties be kept together? The default, <code>TRUE</code>, may return more rows than you
request. Use <code>FALSE</code> to ignore ties, and return the first <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="slice_+3A_weight_by">weight_by</code></td>
<td>
<p>Sampling weights. This must evaluate to a vector of non-negative numbers the same length as the
input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="slice_+3A_replace">replace</code></td>
<td>
<p><code>logical(1)</code>. Should sampling be performed with (<code>TRUE</code>) or without (<code>FALSE</code>, the default)
replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following properties:
</p>

<ul>
<li><p> Each row may appear 0, 1, or many times in the output.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>slice(mtcars, c(1, 2, 3))
mtcars %&gt;% slice(1:3)

# Similar to head(mtcars, 1)
mtcars %&gt;% slice(1L)

# Similar to tail(mtcars, 1):
mtcars %&gt;% slice(n())
mtcars %&gt;% slice(5:n())
# Rows can be dropped with negative indices:
slice(mtcars, -(1:4))

# First and last rows based on existing order
mtcars %&gt;% slice_head(n = 5)
mtcars %&gt;% slice_tail(n = 5)

# Grouped operations:
mtcars %&gt;% group_by(am, cyl, gear) %&gt;% slice_head(n = 2)

</code></pre>

<hr>
<h2 id='summarise'>Reduce multiple values down to a single value</h2><span id='topic+summarise'></span><span id='topic+summarize'></span>

<h3>Description</h3>

<p>Create one or more scalar variables summarising the variables of an existing <code>data.frame</code>. Grouped <code>data.frame</code>s will
result in one row in the output for each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise(.data, ..., .groups = NULL)

summarize(.data, ..., .groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="summarise_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary functions. The name will be the name of the variable in the result.</p>
</td></tr>
<tr><td><code id="summarise_+3A_.groups">.groups</code></td>
<td>
<p><code>character(1)</code>. Grouping structure of the result.
</p>

<ul>
<li> <p><code>"drop_last"</code>: drops the last level of grouping.
</p>
</li>
<li> <p><code>"drop"</code>: all levels of grouping are dropped.
</p>
</li>
<li> <p><code>"keep"</code>: keeps the same grouping structure as <code>.data</code>.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it is chosen based on the number of rows of the results:
</p>

<ul>
<li><p> If all the results have 1 row, you get <code>"drop_last"</code>.
</p>
</li>
<li><p> If the number of rows varies, you get <code>"keep"</code>.
</p>
</li></ul>

<p>In addition, a message informs you of that choice, unless the result is ungrouped, the option
<code>"poorman.summarise.inform"</code> is set to <code>FALSE</code>.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length <code>1</code>, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A vector of length <code>n</code>, e.g. <code>quantile()</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summarise()</code> and <code>summarize()</code> are synonyms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A summary applied to ungrouped tbl returns a single row
mtcars %&gt;%
  summarise(mean = mean(disp), n = n())

# Usually, you'll want to group first
mtcars %&gt;%
  group_by(cyl) %&gt;%
  summarise(mean = mean(disp), n = n())

# You can summarise to more than one value:
mtcars %&gt;%
   group_by(cyl) %&gt;%
   summarise(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))

# You use a data frame to create multiple columns so you can wrap
# this up into a function:
my_quantile &lt;- function(x, probs) {
  data.frame(x = quantile(x, probs), probs = probs)
}
mtcars %&gt;%
  group_by(cyl) %&gt;%
  summarise(my_quantile(disp, c(0.25, 0.75)))

# Each summary call removes one grouping level (since that group
# is now just a single row)
mtcars %&gt;%
  group_by(cyl, vs) %&gt;%
  summarise(cyl_n = n()) %&gt;%
  group_vars()

</code></pre>

<hr>
<h2 id='union_all'>Union All</h2><span id='topic+union_all'></span>

<h3>Description</h3>

<p>Union all elements of R objects together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>union_all(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="union_all_+3A_x">x</code>, <code id="union_all_+3A_y">y</code></td>
<td>
<p>objects to union all elements of (ignoring order)</p>
</td></tr>
<tr><td><code id="union_all_+3A_...">...</code></td>
<td>
<p>other arguments passed on to methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>first &lt;- mtcars[1:20, ]
second &lt;- mtcars[10:32, ]
union_all(first, second)

# union_all does not remove duplicates
a &lt;- data.frame(column = c(1:10, 10))
b &lt;- data.frame(column = c(1:5, 5))
union_all(a, b)

</code></pre>

<hr>
<h2 id='unite'>Unite Multiple Columns Into One</h2><span id='topic+unite'></span>

<h3>Description</h3>

<p>Convenience function to paste together multiple columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unite_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="unite_+3A_col">col</code></td>
<td>
<p><code>character(1)</code> or <code>symbol(1)</code>. The name of the new column.</p>
</td></tr>
<tr><td><code id="unite_+3A_...">...</code></td>
<td>
<p>The columns to unite.</p>
</td></tr>
<tr><td><code id="unite_+3A_sep">sep</code></td>
<td>
<p><code>character(1)</code>. Separator to use between the values.</p>
</td></tr>
<tr><td><code id="unite_+3A_remove">remove</code></td>
<td>
<p><code>logical(1)</code>. If <code>TRUE</code>, remove the input columns from the output <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="unite_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical(1)</code>. If <code>TRUE</code>, missing values will be remove prior to uniting each value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the columns passed via <code>...</code> pasted together in a new column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c("a", "a", NA, NA), y = c("b", NA, "b", NA))
df

df %&gt;% unite("z", x:y, remove = FALSE)
# To remove missing values:
df %&gt;% unite("z", x:y, na.rm = TRUE, remove = FALSE)

</code></pre>

<hr>
<h2 id='where'>Select variables with a function</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>This selection helper selects the variables for which a function returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(fn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="where_+3A_fn">fn</code></td>
<td>
<p>A function that returns <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>integer</code> column positions which are the result of the <code>fn</code> evaluation.
</p>


<h3>See Also</h3>

<p><a href="#topic+select_helpers">select_helpers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% select(where(is.numeric))
iris %&gt;% select(where(function(x) is.numeric(x)))
iris %&gt;% select(where(function(x) is.numeric(x) &amp;&amp; mean(x) &gt; 3.5))

</code></pre>

<hr>
<h2 id='window_rank'>Windowed Rank Functions</h2><span id='topic+window_rank'></span><span id='topic+cume_dist'></span><span id='topic+dense_rank'></span><span id='topic+min_rank'></span><span id='topic+ntile'></span><span id='topic+percent_rank'></span><span id='topic+row_number'></span>

<h3>Description</h3>

<p>Six variations on ranking functions, mimicking the ranking functions described in SQL2003. They are currently
implemented using the built in <code><a href="base.html#topic+rank">rank()</a></code> function. All ranking functions map smallest inputs to smallest outputs. Use
<code>desc()</code> to reverse the direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cume_dist(x)

dense_rank(x)

min_rank(x)

ntile(x = row_number(), n)

percent_rank(x)

row_number(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window_rank_+3A_x">x</code></td>
<td>
<p>A vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or
largest values, replace with <code>Inf</code> or <code>-Inf</code> before ranking.</p>
</td></tr>
<tr><td><code id="window_rank_+3A_n">n</code></td>
<td>
<p><code>integer(1)</code>. The number of groups to split up into.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>cume_dist()</code>: a cumulative distribution function. Proportion of all values less than or equal to the current rank.
</p>
</li>
<li> <p><code>dense_rank()</code>: like <code>min_rank()</code>, but with no gaps between ranks
</p>
</li>
<li> <p><code>min_rank()</code>: equivalent to <code>rank(ties.method = "min")</code>
</p>
</li>
<li> <p><code>ntile()</code>: a rough rank, which breaks the input vector into <code>n</code> buckets. The size of the buckets may differ by up
to one, larger buckets have lower rank.
</p>
</li>
<li> <p><code>percent_rank()</code>: a number between <code>0</code> and <code>1</code> computed by rescaling <code>min_rank</code> to <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>
</p>
</li>
<li> <p><code>row_number()</code>: equivalent to <code>rank(ties.method = "first")</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(5, 1, 3, 2, 2, NA)
row_number(x)
min_rank(x)
dense_rank(x)
percent_rank(x)
cume_dist(x)

ntile(x, 2)
ntile(1:8, 3)

# row_number can be used with single table verbs without specifying x
# (for data frames and databases that support windowing)
mutate(mtcars, row_number() == 1L)
mtcars %&gt;% filter(between(row_number(), 1, 10))

</code></pre>

<hr>
<h2 id='with_groups'>Perform an operation with temporary groups</h2><span id='topic+with_groups'></span>

<h3>Description</h3>

<p>This function allows you to modify the grouping variables for a single operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_groups(.data, .groups, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_groups_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="with_groups_+3A_.groups">.groups</code></td>
<td>
<p>&lt;<code><a href="#topic+select_helpers">poor-select</a></code>&gt; One or more variables to group by. Unlike <code><a href="#topic+group_by">group_by()</a></code>, you can
only group by existing variables, and you can use <code>poor-select</code> syntax like <code>c(x, y, z)</code> to select multiple
variables.
</p>
<p>Use <code>NULL</code> to temporarily <strong>un</strong>group.</p>
</td></tr>
<tr><td><code id="with_groups_+3A_.f">.f</code></td>
<td>
<p>A <code>function</code> to apply to regrouped data. Supports lambda-style <code>~</code> syntax.</p>
</td></tr>
<tr><td><code id="with_groups_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(g = c(1, 1, 2, 2, 3), x = runif(5))
df %&gt;% with_groups(g, mutate, x_mean = mean(x))
df %&gt;% with_groups(g, ~ mutate(.x, x_mean = mean(x)))

df %&gt;%
  group_by(g) %&gt;%
  with_groups(NULL, mutate, x_mean = mean(x))

# NB: grouping can't be restored if you remove the grouping variables
df %&gt;%
  group_by(g) %&gt;%
  with_groups(NULL, mutate, g = NULL)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
