<!DOCTYPE html><html lang="en"><head><title>Help for package ao</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ao}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ao-package'><p>ao: Alternating Optimization</p></a></li>
<li><a href='#ao'><p>Alternating Optimization</p></a></li>
<li><a href='#ao_input_check'><p>Input checks</p></a></li>
<li><a href='#Procedure'><p>Procedure Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Alternating Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Alternating optimization is an iterative procedure that optimizes 
    a function by alternately performing restricted optimization over individual 
    parameter subsets. Instead of tackling joint optimization directly, it 
    breaks the problem down into simpler sub-problems. This approach can make 
    optimization feasible when joint optimization is too difficult.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://loelschlaeger.de/ao/">https://loelschlaeger.de/ao/</a>, <a href="https://github.com/loelschlaeger/ao/">https://github.com/loelschlaeger/ao/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/loelschlaeger/ao/issues">https://github.com/loelschlaeger/ao/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, cli, future.apply, oeli (&ge; 0.5.2), progressr, R6,
stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), optimizeR (&ge; 1.1.1)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-13 18:53:51 UTC; lennart</td>
</tr>
<tr>
<td>Author:</td>
<td>Lennart Oelschläger
    <a href="https://orcid.org/0000-0001-5421-9313"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Siddhartha Chib [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lennart Oelschläger &lt;oelschlaeger.lennart@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-13 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ao-package'>ao: Alternating Optimization</h2><span id='topic+ao-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Alternating optimization is an iterative procedure that optimizes a function by alternately performing restricted optimization over individual parameter subsets. Instead of tackling joint optimization directly, it breaks the problem down into simpler sub-problems. This approach can make optimization feasible when joint optimization is too difficult.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lennart Oelschläger <a href="mailto:oelschlaeger.lennart@gmail.com">oelschlaeger.lennart@gmail.com</a> (<a href="https://orcid.org/0000-0001-5421-9313">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Siddhartha Chib <a href="mailto:chib@wustl.edu">chib@wustl.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://loelschlaeger.de/ao/">https://loelschlaeger.de/ao/</a>
</p>
</li>
<li> <p><a href="https://github.com/loelschlaeger/ao/">https://github.com/loelschlaeger/ao/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/loelschlaeger/ao/issues">https://github.com/loelschlaeger/ao/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ao'>Alternating Optimization</h2><span id='topic+ao'></span>

<h3>Description</h3>

<p>Alternating optimization is an iterative procedure for optimizing a
real-valued function jointly over all its parameters by alternating
restricted optimization over parameter partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ao(
  f,
  initial,
  target = NULL,
  npar = NULL,
  gradient = NULL,
  ...,
  partition = "sequential",
  new_block_probability = 0.3,
  minimum_block_number = 2,
  minimize = TRUE,
  lower = -Inf,
  upper = Inf,
  iteration_limit = Inf,
  seconds_limit = Inf,
  tolerance_value = 1e-06,
  tolerance_parameter = 1e-06,
  tolerance_parameter_norm = function(x, y) sqrt(sum((x - y)^2)),
  tolerance_history = 1,
  base_optimizer = Optimizer$new("stats::optim", method = "L-BFGS-B"),
  verbose = FALSE,
  hide_warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ao_+3A_f">f</code></td>
<td>
<p>(<code>function</code>)<br />
A <code>function</code> to be optimized, returning a single <code>numeric</code> value.
</p>
<p>The first argument of <code>f</code> should be a <code>numeric</code> of the same length
as <code>initial</code>, optionally followed by any other arguments specified by
the <code>...</code> argument.
</p>
<p>If <code>f</code> is to be optimized over an argument other than the first, or more
than one argument, this has to be specified via the <code>target</code> argument.</p>
</td></tr>
<tr><td><code id="ao_+3A_initial">initial</code></td>
<td>
<p>(<code>numeric()</code> or <code>list()</code>)<br />
The starting parameter values for the target argument(s).
</p>
<p>This can also be a <code>list</code> of multiple starting parameter values, see details.</p>
</td></tr>
<tr><td><code id="ao_+3A_target">target</code></td>
<td>
<p>(<code>character()</code> or <code>NULL</code>)<br />
The name(s) of the argument(s) over which <code>f</code> gets optimized.
</p>
<p>This can only be <code>numeric</code> arguments.
</p>
<p>Can be <code>NULL</code> (default), then it is the first argument of <code>f</code>.</p>
</td></tr>
<tr><td><code id="ao_+3A_npar">npar</code></td>
<td>
<p>(<code>integer()</code>)<br />
The length of the target argument(s).
</p>
<p>Must be specified if more than two target arguments are specified via
the <code>target</code> argument.
</p>
<p>Can be <code>NULL</code> if there is only one target argument, in which case <code>npar</code> is
set to be <code>length(initial)</code>.</p>
</td></tr>
<tr><td><code id="ao_+3A_gradient">gradient</code></td>
<td>
<p>(<code>function</code> or <code>NULL</code>)<br />
A <code>function</code> that returns the gradient of <code>f</code>.
</p>
<p>The function call of <code>gradient</code> must be identical to <code>f</code>.
</p>
<p>Can be <code>NULL</code>, in which case a finite-difference approximation will be used.</p>
</td></tr>
<tr><td><code id="ao_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>f</code> (and <code>gradient</code>).</p>
</td></tr>
<tr><td><code id="ao_+3A_partition">partition</code></td>
<td>
<p>(<code>character(1)</code> or <code>list()</code>)<br />
Defines the parameter partition, and can be either
</p>

<ul>
<li> <p><code>"sequential"</code> for treating each parameter separately,
</p>
</li>
<li> <p><code>"random"</code> for a random partition in each iteration,
</p>
</li>
<li> <p><code>"none"</code> for no partition (which is equivalent to joint optimization),
</p>
</li>
<li><p> or a <code>list</code> of vectors of parameter indices, specifying a custom
partition for the alternating optimization process.
</p>
</li></ul>

<p>This can also be a <code>list</code> of multiple partition definitions, see details.</p>
</td></tr>
<tr><td><code id="ao_+3A_new_block_probability">new_block_probability</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Only relevant if <code>partition = "random"</code>.
</p>
<p>The probability for a new parameter block when creating a random
partitions.
</p>
<p>Values close to 0 result in larger parameter blocks, values close to 1
result in smaller parameter blocks.</p>
</td></tr>
<tr><td><code id="ao_+3A_minimum_block_number">minimum_block_number</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Only relevant if <code>partition = "random"</code>.
</p>
<p>The minimum number of blocks in random partitions.</p>
</td></tr>
<tr><td><code id="ao_+3A_minimize">minimize</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to minimize during the alternating optimization process.
</p>
<p>If <code>FALSE</code>, maximization is performed.</p>
</td></tr>
<tr><td><code id="ao_+3A_lower">lower</code>, <code id="ao_+3A_upper">upper</code></td>
<td>
<p>(<code>numeric()</code>)<br />
Optionally lower and upper parameter bounds.</p>
</td></tr>
<tr><td><code id="ao_+3A_iteration_limit">iteration_limit</code></td>
<td>
<p>(<code>integer(1)</code> or <code>Inf</code>)<br />
The maximum number of iterations through the parameter partition before
the alternating optimization process is terminated.
</p>
<p>Can also be <code>Inf</code> for no iteration limit.</p>
</td></tr>
<tr><td><code id="ao_+3A_seconds_limit">seconds_limit</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
The time limit in seconds before the alternating optimization process is
terminated.
</p>
<p>Can also be <code>Inf</code> for no time limit.
</p>
<p>Note that this stopping criteria is only checked <em>after</em> a sub-problem is
solved and not <em>within</em> solving a sub-problem, so the actual process time can
exceed this limit.</p>
</td></tr>
<tr><td><code id="ao_+3A_tolerance_value">tolerance_value</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
A non-negative tolerance value. The alternating optimization terminates
if the absolute difference between the current function value and the one
before <code>tolerance_history</code> iterations is smaller than
<code>tolerance_value</code>.
</p>
<p>Can be <code>0</code> for no value threshold.</p>
</td></tr>
<tr><td><code id="ao_+3A_tolerance_parameter">tolerance_parameter</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
A non-negative tolerance value. The alternating optimization terminates if
the distance between the current estimate and the before
<code>tolerance_history</code> iterations is smaller than
<code>tolerance_parameter</code>.
</p>
<p>Can be <code>0</code> for no parameter threshold.
</p>
<p>By default, the distance is measured using the euclidean norm, but another
norm can be specified via the <code>tolerance_parameter_norm</code> argument.</p>
</td></tr>
<tr><td><code id="ao_+3A_tolerance_parameter_norm">tolerance_parameter_norm</code></td>
<td>
<p>(<code>function</code>)<br />
The norm that measures the distance between the current estimate and the
one from the last iteration. If the distance is smaller than
<code>tolerance_parameter</code>, the procedure is terminated.
</p>
<p>It must be of the form <code>function(x, y)</code> for two vector inputs
<code>x</code> and <code>y</code>, and return a single <code>numeric</code> value.
By default, the euclidean norm <code>function(x, y) sqrt(sum((x - y)^2))</code>
is used.</p>
</td></tr>
<tr><td><code id="ao_+3A_tolerance_history">tolerance_history</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
The number of iterations to look back to determine whether
<code>tolerance_value</code> or <code>tolerance_parameter</code> has been reached.</p>
</td></tr>
<tr><td><code id="ao_+3A_base_optimizer">base_optimizer</code></td>
<td>
<p>(<code>Optimizer</code> or <code>list()</code>)<br />
An <code>Optimizer</code> object, which can be created via
<code><a href="optimizeR.html#topic+Optimizer">Optimizer</a></code>. It numerically solves the sub-problems.
</p>
<p>By default, the <code><a href="stats.html#topic+optim">optim</a></code> optimizer is used. If another
optimizer is specified, the arguments <code>gradient</code>, <code>lower</code>, and
<code>upper</code> are ignored.
</p>
<p>This can also be a <code>list</code> of multiple base optimizers, see details.</p>
</td></tr>
<tr><td><code id="ao_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to print tracing details during the alternating optimization
process.</p>
</td></tr>
<tr><td><code id="ao_+3A_hide_warnings">hide_warnings</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to hide warnings during the alternating optimization process.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Multiple threads</h4>

<p>Alternating optimization can suffer from local optima. To increase the
likelihood of reaching the global optimum, you can specify:
</p>

<ul>
<li><p> multiple starting parameters
</p>
</li>
<li><p> multiple parameter partitions
</p>
</li>
<li><p> multiple base optimizers
</p>
</li></ul>

<p>Use the <code>initial</code>, <code>partition</code>, and/or <code>base_optimizer</code> arguments to provide
a <code>list</code> of possible values for each parameter. Each combination of initial
values, parameter partitions, and base optimizers will create a separate
alternating optimization thread.
</p>


<h5>Output value</h5>

<p>In the case of multiple threads, the output changes slightly in comparison
to the standard case. It is still a <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>estimate</code> is the optimal parameter vector over all threads.
</p>
</li>
<li> <p><code>value</code> is the optimal function value over all threads.
</p>
</li>
<li> <p><code>details</code> combines details of the single threads and has an additional
column <code>thread</code> with an index for the different threads.
</p>
</li>
<li> <p><code>seconds</code> gives the computation time in seconds for each thread.
</p>
</li>
<li> <p><code>stopping_reason</code> gives the termination message for each thread.
</p>
</li>
<li> <p><code>threads</code> give details how the different threads were specified.
</p>
</li></ul>




<h5>Parallel computation</h5>

<p>By default, threads run sequentially. However, since they are independent,
they can be parallelized. To enable parallel computation, use the
<a href="https://future.futureverse.org/"><code>{future}</code> framework</a>. For example, run the
following <em>before</em> the <code>ao()</code> call:
</p>
<pre>
future::plan(future::multisession, workers = 4)
</pre>



<h5>Progress updates</h5>

<p>When using multiple threads, setting <code>verbose = TRUE</code> to print tracing
details during alternating optimization is not supported. However, you can
still track the progress of threads using the
<a href="https://progressr.futureverse.org/"><code>{progressr}</code> framework</a>. For example,
run the following <em>before</em> the <code>ao()</code> call:
</p>
<pre>
progressr::handlers(global = TRUE)
progressr::handlers(
  progressr::handler_progress(":percent :eta :message")
)
</pre>




<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>estimate</code> is the parameter vector at termination.
</p>
</li>
<li> <p><code>value</code> is the function value at termination.
</p>
</li>
<li> <p><code>details</code> is a <code>data.frame</code> with full information about the procedure:
For each iteration (column <code>iteration</code>) it contains the function value
(column <code>value</code>), parameter values (columns starting with <code>p</code> followed by
the parameter index), the active parameter block (columns starting with <code>b</code>
followed by the parameter index, where <code>1</code> stands for a parameter contained
in the active parameter block and <code>0</code> if not), and computation times in
seconds (column <code>seconds</code>)
</p>
</li>
<li> <p><code>seconds</code> is the overall computation time in seconds.
</p>
</li>
<li> <p><code>stopping_reason</code> is a message why the procedure has terminated.
</p>
</li></ul>

<p>In the case of multiple threads, the output changes slightly, see details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Minimization of Himmelblau's function --------------------------

himmelblau &lt;- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
ao(f = himmelblau, initial = c(0, 0))

# Example 2: Maximization of 2-class Gaussian mixture log-likelihood --------

# target arguments:
# - class means mu (2, unrestricted)
# - class standard deviations sd (2, must be non-negative)
# - class proportion lambda (only 1 for identification, must be in [0, 1])

normal_mixture_llk &lt;- function(mu, sd, lambda, data) {
  c1 &lt;- lambda * dnorm(data, mu[1], sd[1])
  c2 &lt;- (1 - lambda) * dnorm(data, mu[2], sd[2])
  sum(log(c1 + c2))
}

ao(
  f = normal_mixture_llk,
  initial = c(2, 4, 1, 1, 0.5),
  target = c("mu", "sd", "lambda"),
  npar = c(2, 2, 1),
  data = datasets::faithful$eruptions,
  partition = "random",
  minimize = FALSE,
  lower = c(-Inf, -Inf, 0, 0, 0),
  upper = c(Inf, Inf, Inf, Inf, 1)
)

</code></pre>

<hr>
<h2 id='ao_input_check'>Input checks</h2><span id='topic+ao_input_check'></span>

<h3>Description</h3>

<p>This helper function checks the inputs for the <code><a href="#topic+ao">ao</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ao_input_check(
  argument_name,
  check_result,
  error_message = check_result,
  prefix = "Input {.var {argument_name}} is bad:"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ao_input_check_+3A_argument_name">argument_name</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The name of the argument that is checked.</p>
</td></tr>
<tr><td><code id="ao_input_check_+3A_check_result">check_result</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
<code>TRUE</code> if the check was successful.</p>
</td></tr>
<tr><td><code id="ao_input_check_+3A_error_message">error_message</code></td>
<td>
<p>(<code>character(1)</code>)<br />
An error message to be printed.</p>
</td></tr>
<tr><td><code id="ao_input_check_+3A_prefix">prefix</code></td>
<td>
<p>(<code>character(1)</code>)<br />
A prefix before the error message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either throws an error, or invisible <code>TRUE</code>.
</p>

<hr>
<h2 id='Procedure'>Procedure Object</h2><span id='topic+Procedure'></span>

<h3>Description</h3>

<p>This object specifies alternating optimization procedure.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>npar</code></dt><dd><p>(<code>integer(1)</code>)<br />
The length of the target argument.</p>
</dd>
<dt><code>partition</code></dt><dd><p>(<code>character(1)</code> or <code>list()</code>)<br />
Defines the parameter partition, and can be either
</p>

<ul>
<li> <p><code>"sequential"</code> for treating each parameter separately,
</p>
</li>
<li> <p><code>"random"</code> for a random partition in each iteration,
</p>
</li>
<li> <p><code>"none"</code> for no partition (which is equivalent to joint optimization),
</p>
</li>
<li><p> or a <code>list</code> of vectors of parameter indices, specifying a custom
partition for the alternating optimization process.
</p>
</li></ul>
</dd>
<dt><code>new_block_probability</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Only relevant if <code>partition = "random"</code>.
The probability for a new parameter block when creating a random
partitions.
Values close to 0 result in larger parameter blocks, values close to 1
result in smaller parameter blocks.</p>
</dd>
<dt><code>minimum_block_number</code></dt><dd><p>(<code>integer(1)</code>)<br />
Only relevant if <code>partition = "random"</code>.
The minimum number of blocks in random partitions.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to print tracing details during the alternating optimization
process.</p>
</dd>
<dt><code>minimize</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to minimize during the alternating optimization process.
If <code>FALSE</code>, maximization is performed.</p>
</dd>
<dt><code>iteration_limit</code></dt><dd><p>(<code>integer(1)</code> or <code>Inf</code>)<br />
The maximum number of iterations through the parameter partition before
the alternating optimization process is terminated.
Can also be <code>Inf</code> for no iteration limit.</p>
</dd>
<dt><code>seconds_limit</code></dt><dd><p>(<code>numeric(1)</code>)<br />
The time limit in seconds before the alternating optimization process is
terminated.
Can also be <code>Inf</code> for no time limit.
Note that this stopping criteria is only checked <em>after</em>
a sub-problem is solved and not <em>within</em> solving a sub-problem, so the
actual process time can exceed this limit.</p>
</dd>
<dt><code>tolerance_value</code></dt><dd><p>(<code>numeric(1)</code>)<br />
A non-negative tolerance value. The alternating optimization terminates
if the absolute difference between the current function value and the one
before <code>tolerance_history</code> iterations is smaller than
<code>tolerance_value</code>.
</p>
<p>Can be <code>0</code> for no value threshold.</p>
</dd>
<dt><code>tolerance_parameter</code></dt><dd><p>(<code>numeric(1)</code>)<br />
A non-negative tolerance value. The alternating optimization terminates if
the distance between the current estimate and the before
<code>tolerance_history</code> iterations is smaller than <code>tolerance_parameter</code>.
</p>
<p>Can be <code>0</code> for no parameter threshold.
</p>
<p>By default, the distance is measured using the euclidean norm, but
another norm can be specified via the <code>tolerance_parameter_norm</code>
field.</p>
</dd>
<dt><code>tolerance_parameter_norm</code></dt><dd><p>(<code>function</code>)<br />
The norm that measures the distance between the current estimate and the
one from the last iteration. If the distance is smaller than
<code>tolerance_parameter</code>, the procedure is terminated.
</p>
<p>It must be of the form <code>function(x, y)</code> for two vector inputs
<code>x</code> and <code>y</code>, and return a single <code>numeric</code> value.
By default, the euclidean norm <code>function(x, y) sqrt(sum((x - y)^2))</code>
is used.</p>
</dd>
<dt><code>tolerance_history</code></dt><dd><p>(<code>integer(1)</code>)<br />
The number of iterations to look back to determine whether
<code>tolerance_value</code> or <code>tolerance_parameter</code> has been reached.</p>
</dd>
<dt><code>iteration</code></dt><dd><p>(<code>integer(1)</code>)<br />
The current iteration number.</p>
</dd>
<dt><code>block</code></dt><dd><p>(<code>integer()</code>)<br />
The currently active parameter block, represented as parameter indices.</p>
</dd>
<dt><code>output</code></dt><dd><p>(<code>list()</code>, read-only)<br />
The output of the alternating optimization procedure, which is a
<code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>estimate</code> is the parameter vector at termination.
</p>
</li>
<li> <p><code>value</code> is the function value at termination.
</p>
</li>
<li> <p><code>details</code> is a <code>data.frame</code> with full information about the procedure:
For each iteration (column <code>iteration</code>) it contains the function value
(column <code>value</code>), parameter values (columns starting with <code>p</code> followed by
the parameter index), the active parameter block (columns starting with <code>b</code>
followed by the parameter index, where <code>1</code> stands for a parameter contained
in the active parameter block and <code>0</code> if not), and computation times in seconds
(column <code>seconds</code>)
</p>
</li>
<li> <p><code>seconds</code> is the overall computation time in seconds.
</p>
</li>
<li> <p><code>stopping_reason</code> is a message why the procedure has terminated.
</p>
</li></ul>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Procedure-new"><code>Procedure$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-print_status"><code>Procedure$print_status()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-initialize_details"><code>Procedure$initialize_details()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-update_details"><code>Procedure$update_details()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_partition"><code>Procedure$get_partition()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_details"><code>Procedure$get_details()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_value"><code>Procedure$get_value()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_value_latest"><code>Procedure$get_value_latest()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_value_best"><code>Procedure$get_value_best()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_parameter"><code>Procedure$get_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_parameter_latest"><code>Procedure$get_parameter_latest()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_parameter_best"><code>Procedure$get_parameter_best()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_seconds"><code>Procedure$get_seconds()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-get_seconds_total"><code>Procedure$get_seconds_total()</code></a>
</p>
</li>
<li> <p><a href="#method-Procedure-check_stopping"><code>Procedure$check_stopping()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Procedure-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new object of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$new(
  npar = integer(),
  partition = "sequential",
  new_block_probability = 0.3,
  minimum_block_number = 2,
  verbose = FALSE,
  minimize = TRUE,
  iteration_limit = Inf,
  seconds_limit = Inf,
  tolerance_value = 1e-06,
  tolerance_parameter = 1e-06,
  tolerance_parameter_norm = function(x, y) sqrt(sum((x - y)^2)),
  tolerance_history = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npar</code></dt><dd><p>(<code>integer(1)</code>)<br />
The (total) length of the target argument(s).</p>
</dd>
<dt><code>partition</code></dt><dd><p>(<code>character(1)</code> or <code>list()</code>)<br />
Defines the parameter partition, and can be either
</p>

<ul>
<li> <p><code>"sequential"</code> for treating each parameter separately,
</p>
</li>
<li> <p><code>"random"</code> for a random partition in each iteration,
</p>
</li>
<li> <p><code>"none"</code> for no partition (which is equivalent to joint optimization),
</p>
</li>
<li><p> or a <code>list</code> of vectors of parameter indices, specifying a custom
partition for the alternating optimization process.
</p>
</li></ul>
</dd>
<dt><code>new_block_probability</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Only relevant if <code>partition = "random"</code>.
The probability for a new parameter block when creating a random
partitions.
Values close to 0 result in larger parameter blocks, values close to 1
result in smaller parameter blocks.</p>
</dd>
<dt><code>minimum_block_number</code></dt><dd><p>(<code>integer(1)</code>)<br />
Only relevant if <code>partition = "random"</code>.
The minimum number of blocks in random partitions.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to print tracing details during the alternating optimization
process.</p>
</dd>
<dt><code>minimize</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to minimize during the alternating optimization process.
If <code>FALSE</code>, maximization is performed.</p>
</dd>
<dt><code>iteration_limit</code></dt><dd><p>(<code>integer(1)</code> or <code>Inf</code>)<br />
The maximum number of iterations through the parameter partition before
the alternating optimization process is terminated.
Can also be <code>Inf</code> for no iteration limit.</p>
</dd>
<dt><code>seconds_limit</code></dt><dd><p>(<code>numeric(1)</code>)<br />
The time limit in seconds before the alternating optimization process is
terminated.
Can also be <code>Inf</code> for no time limit.
Note that this stopping criteria is only checked <em>after</em>
a sub-problem is solved and not <em>within</em> solving a sub-problem, so the
actual process time can exceed this limit.</p>
</dd>
<dt><code>tolerance_value</code></dt><dd><p>(<code>numeric(1)</code>)<br />
A non-negative tolerance value. The alternating optimization terminates
if the absolute difference between the current function value and the one
before <code>tolerance_history</code> iterations is smaller than
<code>tolerance_value</code>.
</p>
<p>Can be <code>0</code> for no value threshold.</p>
</dd>
<dt><code>tolerance_parameter</code></dt><dd><p>(<code>numeric(1)</code>)<br />
A non-negative tolerance value. The alternating optimization terminates if
the distance between the current estimate and the before
<code>tolerance_history</code> iterations is smaller than <code>tolerance_parameter</code>.
</p>
<p>Can be <code>0</code> for no parameter threshold.
</p>
<p>By default, the distance is measured using the euclidean norm, but
another norm can be specified via the <code>tolerance_parameter_norm</code>
field.</p>
</dd>
<dt><code>tolerance_parameter_norm</code></dt><dd><p>(<code>function</code>)<br />
The norm that measures the distance between the current estimate and the
one from the last iteration. If the distance is smaller than
<code>tolerance_parameter</code>, the procedure is terminated.
It must be of the form <code>function(x, y)</code> for two vector inputs
<code>x</code> and <code>y</code>, and return a single <code>numeric</code> value.
By default, the euclidean norm <code>function(x, y) sqrt(sum((x - y)^2))</code>
is used.</p>
</dd>
<dt><code>tolerance_history</code></dt><dd><p>(<code>integer(1)</code>)<br />
The number of iterations to look back to determine whether
<code>tolerance_value</code> or <code>tolerance_parameter</code> has been reached.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-print_status"></a>



<h4>Method <code>print_status()</code></h4>

<p>Prints a status message.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$print_status(message, message_type = 8, verbose = self$verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>message</code></dt><dd><p>(<code>character(1)</code>)<br />
The status message.</p>
</dd>
<dt><code>message_type</code></dt><dd><p>(<code>integer(1)</code>)<br />
The type of the message, one of the following:
</p>

<ul>
<li> <p><code>1</code> for <code>cli::cli_h1()</code>
</p>
</li>
<li> <p><code>2</code> for <code>cli::cli_h2()</code>
</p>
</li>
<li> <p><code>3</code> for <code>cli::cli_h3()</code>
</p>
</li>
<li> <p><code>4</code> for <code>cli::cli_alert_success()</code>
</p>
</li>
<li> <p><code>5</code> for <code>cli::cli_alert_info()</code>
</p>
</li>
<li> <p><code>6</code> for <code>cli::cli_alert_warning()</code>
</p>
</li>
<li> <p><code>7</code> for <code>cli::cli_alert_danger()</code>
</p>
</li>
<li> <p><code>8</code> for <code>cli::cat_line()</code>
</p>
</li></ul>
</dd>
<dt><code>verbose</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to print tracing details during the alternating optimization
process.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-initialize_details"></a>



<h4>Method <code>initialize_details()</code></h4>

<p>Initializes the <code>details</code> part of the output.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$initialize_details(initial_parameter, initial_value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>initial_parameter</code></dt><dd><p>(<code>numeric()</code>)<br />
The starting parameter values for the procedure.</p>
</dd>
<dt><code>initial_value</code></dt><dd><p>(<code>numeric(1)</code>)<br />
The function value at the initial parameters.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-update_details"></a>



<h4>Method <code>update_details()</code></h4>

<p>Updates the <code>details</code> part of the output.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$update_details(
  value,
  parameter_block,
  seconds,
  error,
  block = self$block
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>(<code>numeric(1)</code>)<br />
The updated function value.</p>
</dd>
<dt><code>parameter_block</code></dt><dd><p>(<code>numeric()</code>)<br />
The updated parameter values for the active parameter block.</p>
</dd>
<dt><code>seconds</code></dt><dd><p>(<code>numeric(1)</code>)<br />
The time in seconds for solving the sub-problem.</p>
</dd>
<dt><code>error</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether solving the sub-problem resulted in an error.</p>
</dd>
<dt><code>block</code></dt><dd><p>(<code>integer()</code>)<br />
The currently active parameter block, represented as parameter indices.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-get_partition"></a>



<h4>Method <code>get_partition()</code></h4>

<p>Get a parameter partition.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_partition()</pre></div>


<hr>
<a id="method-Procedure-get_details"></a>



<h4>Method <code>get_details()</code></h4>

<p>Get the <code>details</code> part of the output.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_details(
  which_iteration = NULL,
  which_block = NULL,
  which_column = c("iteration", "value", "parameter", "block", "seconds")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which_iteration</code></dt><dd><p>(<code>integer()</code>)<br />
Selects the iteration(s).
Can also be <code>NULL</code> to select all iterations.</p>
</dd>
<dt><code>which_block</code></dt><dd><p>(<code>character(1)</code> or <code>integer()</code>)<br />
Selects the parameter block in the partition and can be one of
</p>

<ul>
<li> <p><code>"first"</code> for the first parameter block,
</p>
</li>
<li> <p><code>"last"</code> for the last parameter block,
</p>
</li>
<li><p> an <code>integer</code> vector of parameter indices,
</p>
</li>
<li><p> or <code>NULL</code> for all parameter blocks.
</p>
</li></ul>
</dd>
<dt><code>which_column</code></dt><dd><p>(<code>character()</code>)<br />
Selects the columns in the <code>details</code> part of the output and can be one or
more of <code>"iteration"</code>, <code>"value"</code>, <code>"parameter"</code>, <code>"block"</code>, and <code>"seconds"</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-get_value"></a>



<h4>Method <code>get_value()</code></h4>

<p>Get the function value in different steps of the alternating optimization
procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_value(
  which_iteration = NULL,
  which_block = NULL,
  keep_iteration_column = FALSE,
  keep_block_columns = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which_iteration</code></dt><dd><p>(<code>integer()</code>)<br />
Selects the iteration(s).
Can also be <code>NULL</code> to select all iterations.</p>
</dd>
<dt><code>which_block</code></dt><dd><p>(<code>character(1)</code> or <code>integer()</code>)<br />
Selects the parameter block in the partition and can be one of
</p>

<ul>
<li> <p><code>"first"</code> for the first parameter block,
</p>
</li>
<li> <p><code>"last"</code> for the last parameter block,
</p>
</li>
<li><p> an <code>integer</code> vector of parameter indices,
</p>
</li>
<li><p> or <code>NULL</code> for all parameter blocks.
</p>
</li></ul>
</dd>
<dt><code>keep_iteration_column</code></dt><dd><p>(<code>logical()</code>)<br />
Whether to keep the column containing the information about the iteration
in the output.</p>
</dd>
<dt><code>keep_block_columns</code></dt><dd><p>(<code>logical()</code>)<br />
Whether to keep the column containing the information about the active
parameter block in the output.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-get_value_latest"></a>



<h4>Method <code>get_value_latest()</code></h4>

<p>Get the function value in the latest step of the alternating
optimization procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_value_latest()</pre></div>


<hr>
<a id="method-Procedure-get_value_best"></a>



<h4>Method <code>get_value_best()</code></h4>

<p>Get the optimum function value in the alternating optimization procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_value_best()</pre></div>


<hr>
<a id="method-Procedure-get_parameter"></a>



<h4>Method <code>get_parameter()</code></h4>

<p>Get the parameter values in different steps of the alternating
optimization procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_parameter(
  which_iteration = self$iteration,
  which_block = NULL,
  keep_iteration_column = FALSE,
  keep_block_columns = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which_iteration</code></dt><dd><p>(<code>integer()</code>)<br />
Selects the iteration(s).
Can also be <code>NULL</code> to select all iterations.</p>
</dd>
<dt><code>which_block</code></dt><dd><p>(<code>character(1)</code> or <code>integer()</code>)<br />
Selects the parameter block in the partition and can be one of
</p>

<ul>
<li> <p><code>"first"</code> for the first parameter block,
</p>
</li>
<li> <p><code>"last"</code> for the last parameter block,
</p>
</li>
<li><p> an <code>integer</code> vector of parameter indices,
</p>
</li>
<li><p> or <code>NULL</code> for all parameter blocks.
</p>
</li></ul>
</dd>
<dt><code>keep_iteration_column</code></dt><dd><p>(<code>logical()</code>)<br />
Whether to keep the column containing the information about the iteration
in the output.</p>
</dd>
<dt><code>keep_block_columns</code></dt><dd><p>(<code>logical()</code>)<br />
Whether to keep the column containing the information about the active
parameter block in the output.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-get_parameter_latest"></a>



<h4>Method <code>get_parameter_latest()</code></h4>

<p>Get the parameter value in the latest step of the alternating
optimization procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_parameter_latest(parameter_type = "full")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_type</code></dt><dd><p>(<code>character(1)</code>)<br />
Can be one of
</p>

<ul>
<li> <p><code>"full"</code> (default) to get the full parameter vector,
</p>
</li>
<li> <p><code>"block"</code> to get the parameter values for the current block,
i.e., the parameters with the indices <code>self$block</code>
</p>
</li>
<li> <p><code>"fixed"</code> to get the parameter values which are currently fixed,
i.e., all except for those with the indices <code>self$block</code>
</p>
</li></ul>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-get_parameter_best"></a>



<h4>Method <code>get_parameter_best()</code></h4>

<p>Get the optimum parameter value in the alternating optimization procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_parameter_best(parameter_type = "full")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_type</code></dt><dd><p>(<code>character(1)</code>)<br />
Can be one of
</p>

<ul>
<li> <p><code>"full"</code> (default) to get the full parameter vector,
</p>
</li>
<li> <p><code>"block"</code> to get the parameter values for the current block,
i.e., the parameters with the indices <code>self$block</code>
</p>
</li>
<li> <p><code>"fixed"</code> to get the parameter values which are currently fixed,
i.e., all except for those with the indices <code>self$block</code>
</p>
</li></ul>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-get_seconds"></a>



<h4>Method <code>get_seconds()</code></h4>

<p>Get the optimization time in seconds in different steps of the
alternating optimization procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_seconds(
  which_iteration = NULL,
  which_block = NULL,
  keep_iteration_column = FALSE,
  keep_block_columns = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which_iteration</code></dt><dd><p>(<code>integer()</code>)<br />
Selects the iteration(s).
Can also be <code>NULL</code> to select all iterations.</p>
</dd>
<dt><code>which_block</code></dt><dd><p>(<code>character(1)</code> or <code>integer()</code>)<br />
Selects the parameter block in the partition and can be one of
</p>

<ul>
<li> <p><code>"first"</code> for the first parameter block,
</p>
</li>
<li> <p><code>"last"</code> for the last parameter block,
</p>
</li>
<li><p> an <code>integer</code> vector of parameter indices,
</p>
</li>
<li><p> or <code>NULL</code> for all parameter blocks.
</p>
</li></ul>
</dd>
<dt><code>keep_iteration_column</code></dt><dd><p>(<code>logical()</code>)<br />
Whether to keep the column containing the information about the iteration
in the output.</p>
</dd>
<dt><code>keep_block_columns</code></dt><dd><p>(<code>logical()</code>)<br />
Whether to keep the column containing the information about the active
parameter block in the output.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Procedure-get_seconds_total"></a>



<h4>Method <code>get_seconds_total()</code></h4>

<p>Get the total optimization time in seconds of the alternating
optimization procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$get_seconds_total()</pre></div>


<hr>
<a id="method-Procedure-check_stopping"></a>



<h4>Method <code>check_stopping()</code></h4>

<p>Checks if the alternating optimization procedure can be terminated.
</p>


<h5>Usage</h5>

<div class="r"><pre>Procedure$check_stopping()</pre></div>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
