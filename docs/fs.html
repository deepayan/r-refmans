<!DOCTYPE html><html><head><title>Help for package fs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fs-package'><p>fs: Cross-Platform File System Operations Based on 'libuv'</p></a></li>
<li><a href='#copy'><p>Copy files, directories or links</p></a></li>
<li><a href='#create'><p>Create files, directories, or links</p></a></li>
<li><a href='#delete'><p>Delete files, directories, or links</p></a></li>
<li><a href='#dir_ls'><p>List files</p></a></li>
<li><a href='#dir_tree'><p>Print contents of directories in a tree-like format</p></a></li>
<li><a href='#file_access'><p>Query for existence and access permissions</p></a></li>
<li><a href='#file_chmod'><p>Change file permissions</p></a></li>
<li><a href='#file_chown'><p>Change owner or group of a file</p></a></li>
<li><a href='#file_info'><p>Query file metadata</p></a></li>
<li><a href='#file_move'><p>Move or rename files</p></a></li>
<li><a href='#file_show'><p>Open files or directories</p></a></li>
<li><a href='#file_temp'><p>Create names for temporary files</p></a></li>
<li><a href='#file_touch'><p>Change file access and modification times</p></a></li>
<li><a href='#fs_bytes'><p>Human readable file sizes</p></a></li>
<li><a href='#fs_path'><p>File paths</p></a></li>
<li><a href='#fs_perms'><p>Create, modify and view file permissions</p></a></li>
<li><a href='#id'><p>Lookup Users and Groups on a system</p></a></li>
<li><a href='#is_absolute_path'><p>Test if a path is an absolute path</p></a></li>
<li><a href='#is_file'><p>Functions to test for file types</p></a></li>
<li><a href='#link_path'><p>Read the value of a symbolic link</p></a></li>
<li><a href='#path'><p>Construct path to a file or directory</p></a></li>
<li><a href='#path_expand'><p>Finding the User Home Directory</p></a></li>
<li><a href='#path_file'><p>Manipulate file paths</p></a></li>
<li><a href='#path_filter'><p>Filter paths</p></a></li>
<li><a href='#path_math'><p>Path computations</p></a></li>
<li><a href='#path_package'><p>Construct a path to a location within an installed or development package</p></a></li>
<li><a href='#path_sanitize'><p>Sanitize a filename by removing directory paths and invalid characters</p></a></li>
<li><a href='#path_tidy'><p>Tidy paths</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cross-Platform File System Operations Based on 'libuv'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A cross-platform interface to file system operations, built
    on top of the 'libuv' C library.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fs.r-lib.org">https://fs.r-lib.org</a>, <a href="https://github.com/r-lib/fs">https://github.com/r-lib/fs</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/fs/issues">https://github.com/r-lib/fs/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, crayon, knitr, pillar (&ge; 1.0.0), rmarkdown, spelling,
testthat (&ge; 3.0.0), tibble (&ge; 1.1.0), vctrs (&ge; 0.3.0), withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file COPYRIGHTS</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-25 11:57:22 UTC; gaborcsardi</td>
</tr>
<tr>
<td>Author:</td>
<td>Jim Hester [aut],
  Hadley Wickham [aut],
  Gábor Csárdi [aut, cre],
  libuv project contributors [cph] (libuv library),
  Joyent, Inc. and other Node contributors [cph] (libuv library),
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gábor Csárdi &lt;csardi.gabor@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-25 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fs-package'>fs: Cross-Platform File System Operations Based on 'libuv'</h2><span id='topic+fs'></span><span id='topic+fs-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A cross-platform interface to file system operations, built on top of the 'libuv' C library.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gábor Csárdi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jim Hester
</p>
</li>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> libuv project contributors (libuv library) [copyright holder]
</p>
</li>
<li><p> Joyent, Inc. and other Node contributors (libuv library) [copyright holder]
</p>
</li>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://fs.r-lib.org">https://fs.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/fs">https://github.com/r-lib/fs</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/fs/issues">https://github.com/r-lib/fs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='copy'>Copy files, directories or links</h2><span id='topic+copy'></span><span id='topic+file_copy'></span><span id='topic+dir_copy'></span><span id='topic+link_copy'></span>

<h3>Description</h3>

<p><code>file_copy()</code> copies files.
</p>
<p><code>link_copy()</code> creates a new link pointing to the same location as the previous link.
</p>
<p><code>dir_copy()</code> copies the directory recursively at the new location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_copy(path, new_path, overwrite = FALSE)

dir_copy(path, new_path, overwrite = FALSE)

link_copy(path, new_path, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="copy_+3A_new_path">new_path</code></td>
<td>
<p>A character vector of paths to the new locations.</p>
</td></tr>
<tr><td><code id="copy_+3A_overwrite">overwrite</code></td>
<td>
<p>Overwrite files if they exist. If this is <code>FALSE</code> and the
file exists an error will be thrown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behavior of <code>dir_copy()</code> differs slightly than that of <code>file.copy()</code> when
<code>overwrite = TRUE</code>. The directory will always be copied to <code>new_path</code>, even
if the name differs from the basename of <code>path</code>.
</p>


<h3>Value</h3>

<p>The new path (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file_create("foo")
file_copy("foo", "bar")
try(file_copy("foo", "bar"))
file_copy("foo", "bar", overwrite = TRUE)
file_delete(c("foo", "bar"))

dir_create("foo")
# Create a directory and put a few files in it
files &lt;- file_create(c("foo/bar", "foo/baz"))
file_exists(files)

# Copy the directory
dir_copy("foo", "foo2")
file_exists(path("foo2", path_file(files)))

# Create a link to the directory
link_create(path_abs("foo"), "loo")
link_path("loo")
link_copy("loo", "loo2")
link_path("loo2")

# Cleanup
dir_delete(c("foo", "foo2"))
link_delete(c("loo", "loo2"))

</code></pre>

<hr>
<h2 id='create'>Create files, directories, or links</h2><span id='topic+create'></span><span id='topic+file_create'></span><span id='topic+dir_create'></span><span id='topic+link_create'></span>

<h3>Description</h3>

<p>The functions <code>file_create()</code> and <code>dir_create()</code> ensure that <code>path</code> exists;
if it already exists it will be left unchanged. That means that compared to
<code><a href="base.html#topic+file.create">file.create()</a></code>, <code>file_create()</code> will not truncate an existing file, and
compared to <code><a href="base.html#topic+dir.create">dir.create()</a></code>, <code>dir_create()</code> will silently ignore existing
directories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_create(path, ..., mode = "u=rw,go=r")

dir_create(path, ..., mode = "u=rwx,go=rx", recurse = TRUE, recursive)

link_create(path, new_path, symbolic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths. For <code>link_create()</code>,
this is the target.</p>
</td></tr>
<tr><td><code id="create_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+path">path()</a></code></p>
</td></tr>
<tr><td><code id="create_+3A_mode">mode</code></td>
<td>
<p>If file/directory is created, what mode should it have?
</p>
<p>Links do not have mode; they inherit the mode of the file they link to.</p>
</td></tr>
<tr><td><code id="create_+3A_recurse">recurse</code></td>
<td>
<p>should intermediate directories be created if they do not
exist?</p>
</td></tr>
<tr><td><code id="create_+3A_recursive">recursive</code></td>
<td>
<p>(Deprecated) If <code>TRUE</code> recurse fully.</p>
</td></tr>
<tr><td><code id="create_+3A_new_path">new_path</code></td>
<td>
<p>The path where the link should be created.</p>
</td></tr>
<tr><td><code id="create_+3A_symbolic">symbolic</code></td>
<td>
<p>Boolean value determining if the link should be a symbolic
(the default) or hard link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to the created object (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file_create("foo")
is_file("foo")
# dir_create applied to the same path will fail
try(dir_create("foo"))

dir_create("bar")
is_dir("bar")
# file_create applied to the same path will fail
try(file_create("bar"))

# Cleanup
file_delete("foo")
dir_delete("bar")

</code></pre>

<hr>
<h2 id='delete'>Delete files, directories, or links</h2><span id='topic+delete'></span><span id='topic+file_delete'></span><span id='topic+dir_delete'></span><span id='topic+link_delete'></span>

<h3>Description</h3>

<p><code>file_delete()</code> and <code>link_delete()</code> delete file and links. Compared to
<a href="base.html#topic+file.remove">file.remove</a> they always fail if they cannot delete the object rather than
changing return value or signalling a warning. If any inputs are
directories, they are passed to <code>dir_delete()</code>, so <code>file_delete()</code> can
therefore be used to delete any filesystem object.
</p>
<p><code>dir_delete()</code> will first delete the contents of the directory, then remove
the directory. Compared to <a href="base.html#topic+unlink">unlink</a> it will always throw an error if the
directory cannot be deleted rather than being silent or signalling a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_delete(path)

dir_delete(path)

link_delete(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The deleted paths (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a directory, with some files and a link to it
dir_create("dir")
files &lt;- file_create(path("dir", letters[1:5]))
link &lt;- link_create(path_abs("dir"), "link")

# All files created
dir_exists("dir")
file_exists(files)
link_exists("link")
file_exists(link_path("link"))

# Delete a file
file_delete(files[1])
file_exists(files[1])

# Delete the directory (which deletes the files as well)
dir_delete("dir")
file_exists(files)
dir_exists("dir")

# The link still exists, but what it points to does not.
link_exists("link")
dir_exists(link_path("link"))

# Delete the link
link_delete("link")
link_exists("link")

</code></pre>

<hr>
<h2 id='dir_ls'>List files</h2><span id='topic+dir_ls'></span><span id='topic+dir_map'></span><span id='topic+dir_walk'></span><span id='topic+dir_info'></span>

<h3>Description</h3>

<p><code>dir_ls()</code> is equivalent to the <code>ls</code> command. It returns filenames as a
named <code>fs_path</code> character vector. The names are equivalent to the values,
which is useful for passing onto functions like <code>purrr::map_dfr()</code>.
</p>
<p><code>dir_info()</code> is equivalent to <code>ls -l</code> and a shortcut for
<code>file_info(dir_ls())</code>.
</p>
<p><code>dir_map()</code> applies a function <code>fun()</code> to each entry in the path and returns
the result in a list.
</p>
<p><code>dir_walk()</code> calls <code>fun</code> for its side-effect and returns the input <code>path</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_ls(
  path = ".",
  all = FALSE,
  recurse = FALSE,
  type = "any",
  glob = NULL,
  regexp = NULL,
  invert = FALSE,
  fail = TRUE,
  ...,
  recursive
)

dir_map(
  path = ".",
  fun,
  all = FALSE,
  recurse = FALSE,
  type = "any",
  fail = TRUE
)

dir_walk(
  path = ".",
  fun,
  all = FALSE,
  recurse = FALSE,
  type = "any",
  fail = TRUE
)

dir_info(
  path = ".",
  all = FALSE,
  recurse = FALSE,
  type = "any",
  regexp = NULL,
  glob = NULL,
  fail = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dir_ls_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code> hidden files are also returned.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_recurse">recurse</code></td>
<td>
<p>If <code>TRUE</code> recurse fully, if a positive number the number of levels
to recurse.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_type">type</code></td>
<td>
<p>File type(s) to return, one or more of &quot;any&quot;, &quot;file&quot;, &quot;directory&quot;,
&quot;symlink&quot;, &quot;FIFO&quot;, &quot;socket&quot;, &quot;character_device&quot; or &quot;block_device&quot;.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_glob">glob</code></td>
<td>
<p>A wildcard aka globbing pattern (e.g. <code style="white-space: pre;">&#8288;*.csv&#8288;</code>) passed on to <code><a href="base.html#topic+grep">grep()</a></code> to filter paths.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_regexp">regexp</code></td>
<td>
<p>A regular expression (e.g. <code style="white-space: pre;">&#8288;[.]csv$&#8288;</code>) passed on to <code><a href="base.html#topic+grep">grep()</a></code> to filter paths.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_invert">invert</code></td>
<td>
<p>If <code>TRUE</code> return files which do <em>not</em> match</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_fail">fail</code></td>
<td>
<p>Should the call fail (the default) or warn if a file cannot be
accessed.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="base.html#topic+grep">grep</a>.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_recursive">recursive</code></td>
<td>
<p>(Deprecated) If <code>TRUE</code> recurse fully.</p>
</td></tr>
<tr><td><code id="dir_ls_+3A_fun">fun</code></td>
<td>
<p>A function, taking one parameter, the current path entry.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dir_ls(R.home("share"), type = "directory")

# Create a shorter link
link_create(system.file(package = "base"), "base")

dir_ls("base", recurse = TRUE, glob = "*.R")

# If you need the full paths input an absolute path
dir_ls(path_abs("base"))

dir_map("base", identity)

dir_walk("base", str)

dir_info("base")

# Cleanup
link_delete("base")

</code></pre>

<hr>
<h2 id='dir_tree'>Print contents of directories in a tree-like format</h2><span id='topic+dir_tree'></span>

<h3>Description</h3>

<p>Print contents of directories in a tree-like format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_tree(path = ".", recurse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dir_tree_+3A_path">path</code></td>
<td>
<p>A path to print the tree from</p>
</td></tr>
<tr><td><code id="dir_tree_+3A_recurse">recurse</code></td>
<td>
<p>If <code>TRUE</code> recurse fully, if a positive number the number of levels
to recurse.</p>
</td></tr>
<tr><td><code id="dir_tree_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+dir_ls">dir_ls</a></code>
</p>

<dl>
<dt><code>type</code></dt><dd><p>File type(s) to return, one or more of &quot;any&quot;, &quot;file&quot;, &quot;directory&quot;,
&quot;symlink&quot;, &quot;FIFO&quot;, &quot;socket&quot;, &quot;character_device&quot; or &quot;block_device&quot;.</p>
</dd>
<dt><code>recursive</code></dt><dd><p>(Deprecated) If <code>TRUE</code> recurse fully.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code> hidden files are also returned.</p>
</dd>
<dt><code>fail</code></dt><dd><p>Should the call fail (the default) or warn if a file cannot be
accessed.</p>
</dd>
<dt><code>glob</code></dt><dd><p>A wildcard aka globbing pattern (e.g. <code style="white-space: pre;">&#8288;*.csv&#8288;</code>) passed on to <code><a href="base.html#topic+grep">grep()</a></code> to filter paths.</p>
</dd>
<dt><code>regexp</code></dt><dd><p>A regular expression (e.g. <code style="white-space: pre;">&#8288;[.]csv$&#8288;</code>) passed on to <code><a href="base.html#topic+grep">grep()</a></code> to filter paths.</p>
</dd>
<dt><code>invert</code></dt><dd><p>If <code>TRUE</code> return files which do <em>not</em> match</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='file_access'>Query for existence and access permissions</h2><span id='topic+file_access'></span><span id='topic+file_exists'></span><span id='topic+dir_exists'></span><span id='topic+link_exists'></span>

<h3>Description</h3>

<p><code>file_exists(path)</code> is a shortcut for <code>file_access(x, "exists")</code>;
<code>dir_exists(path)</code> and <code>link_exists(path)</code> are similar but also check that
the path is a directory or link, respectively. (<code>file_exists(path)</code> returns
<code>TRUE</code> if <code>path</code> exists and it is a directory.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_access(path, mode = "exists")

file_exists(path)

dir_exists(path)

link_exists(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_access_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="file_access_+3A_mode">mode</code></td>
<td>
<p>A character vector containing one or more of 'exists', 'read',
'write', 'execute'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Cross-compatibility warning:</strong> There is no executable bit on
Windows. Checking a file for mode 'execute' on Windows, e.g.
<code>file_access(x, "execute")</code> will always return <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A logical vector, with names corresponding to the input <code>path</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file_access("/")
file_access("/", "read")
file_access("/", "write")

file_exists("WOMBATS")
</code></pre>

<hr>
<h2 id='file_chmod'>Change file permissions</h2><span id='topic+file_chmod'></span>

<h3>Description</h3>

<p>Change file permissions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_chmod(path, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_chmod_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="file_chmod_+3A_mode">mode</code></td>
<td>
<p>A character representation of the mode, in either hexidecimal or symbolic format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Cross-compatibility warning:</strong> File permissions differ on Windows
from POSIX systems. Windows does not use an executable bit, so attempting
to change this will have no effect. Windows also does not have user
groups, so only the user permissions (<code>u</code>) are relevant.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file_create("foo", mode = "000")
file_chmod("foo", "777")
file_info("foo")$permissions

file_chmod("foo", "u-x")
file_info("foo")$permissions

file_chmod("foo", "a-wrx")
file_info("foo")$permissions

file_chmod("foo", "u+wr")
file_info("foo")$permissions

# It is also vectorized
files &lt;- c("foo", file_create("bar", mode = "000"))
file_chmod(files, "a+rwx")
file_info(files)$permissions

file_chmod(files, c("644", "600"))
file_info(files)$permissions

</code></pre>

<hr>
<h2 id='file_chown'>Change owner or group of a file</h2><span id='topic+file_chown'></span>

<h3>Description</h3>

<p>Change owner or group of a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_chown(path, user_id = NULL, group_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_chown_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="file_chown_+3A_user_id">user_id</code></td>
<td>
<p>The user id of the new owner, specified as a numeric ID or
name. The R process must be privileged to change this.</p>
</td></tr>
<tr><td><code id="file_chown_+3A_group_id">group_id</code></td>
<td>
<p>The group id of the new owner, specified as a numeric ID or
name.</p>
</td></tr>
</table>

<hr>
<h2 id='file_info'>Query file metadata</h2><span id='topic+file_info'></span><span id='topic+file_size'></span>

<h3>Description</h3>

<p>Compared to <code><a href="base.html#topic+file.info">file.info()</a></code> the full results of a <code>stat(2)</code> system call are
returned and some columns are returned as S3 classes to make manipulation
more natural. On systems which do not support all metadata (such as Windows)
default values are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_info(path, fail = TRUE, follow = FALSE)

file_size(path, fail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_info_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="file_info_+3A_fail">fail</code></td>
<td>
<p>Should the call fail (the default) or warn if a file cannot be
accessed.</p>
</td></tr>
<tr><td><code id="file_info_+3A_follow">follow</code></td>
<td>
<p>If <code>TRUE</code>, symbolic links will be followed (recursively) and
the results will be that of the final file rather than the link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with metadata for each file. Columns returned are as follows.
</p>
<table>
<tr><td><code>path</code></td>
<td>
<p>The input path, as a <code><a href="#topic+fs_path">fs_path()</a></code> character vector.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The file type, as a factor of file types.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The file size, as a <code><a href="#topic+fs_bytes">fs_bytes()</a></code> numeric vector.</p>
</td></tr>
<tr><td><code>permissions</code></td>
<td>
<p>The file permissions, as a <code><a href="#topic+fs_perms">fs_perms()</a></code> integer vector.</p>
</td></tr>
<tr><td><code>modification_time</code></td>
<td>
<p>The time of last data modification, as a <a href="base.html#topic+POSIXct">POSIXct</a> datetime.</p>
</td></tr>
<tr><td><code>user</code></td>
<td>
<p>The file owner name - as a character vector.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>The file group name - as a character vector.</p>
</td></tr>
<tr><td><code>device_id</code></td>
<td>
<p>The file device id - as a numeric vector.</p>
</td></tr>
<tr><td><code>hard_links</code></td>
<td>
<p>The number of hard links to the file - as a numeric vector.</p>
</td></tr>
<tr><td><code>special_device_id</code></td>
<td>
<p>The special device id of the file - as a numeric vector.</p>
</td></tr>
<tr><td><code>inode</code></td>
<td>
<p>The inode of the file - as a numeric vector.</p>
</td></tr>
<tr><td><code>block_size</code></td>
<td>
<p>The optimal block for the file - as a numeric vector.</p>
</td></tr>
<tr><td><code>blocks</code></td>
<td>
<p>The number of blocks allocated for the file - as a numeric vector.</p>
</td></tr>
<tr><td><code>flags</code></td>
<td>
<p>The user defined flags for the file - as an integer vector.</p>
</td></tr>
<tr><td><code>generation</code></td>
<td>
<p>The generation number for the file - as a numeric vector.</p>
</td></tr>
<tr><td><code>access_time</code></td>
<td>
<p>The time of last access - as a <a href="base.html#topic+POSIXct">POSIXct</a> datetime.</p>
</td></tr>
<tr><td><code>change_time</code></td>
<td>
<p>The time of last file status change - as a <a href="base.html#topic+POSIXct">POSIXct</a> datetime.</p>
</td></tr>
<tr><td><code>birth_time</code></td>
<td>
<p>The time when the inode was created - as a <a href="base.html#topic+POSIXct">POSIXct</a> datetime.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dir_info">dir_info()</a></code> to display file information for files in a given
directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
write.csv(mtcars, "mtcars.csv")
file_info("mtcars.csv")

# Files in the working directory modified more than 20 days ago
files &lt;- file_info(dir_ls())
files$path[difftime(Sys.time(), files$modification_time, units = "days") &gt; 20]

# Cleanup
file_delete("mtcars.csv")

</code></pre>

<hr>
<h2 id='file_move'>Move or rename files</h2><span id='topic+file_move'></span>

<h3>Description</h3>

<p>Compared to <a href="base.html#topic+file.rename">file.rename</a> <code>file_move()</code> always fails if it is unable to move
a file, rather than signaling a Warning and returning an error code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_move(path, new_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_move_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="file_move_+3A_new_path">new_path</code></td>
<td>
<p>New file path. If <code>new_path</code> is existing directory, the file
will be moved into that directory; otherwise it will be moved/renamed to
the full path.
</p>
<p>Should either be the same length as <code>path</code>, or a single directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new path (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file_create("foo")
file_move("foo", "bar")
file_exists(c("foo", "bar"))
file_delete("bar")

</code></pre>

<hr>
<h2 id='file_show'>Open files or directories</h2><span id='topic+file_show'></span>

<h3>Description</h3>

<p>Open files or directories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_show(path = ".", browser = getOption("browser"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_show_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="file_show_+3A_browser">browser</code></td>
<td>
<p>a non-empty character string giving the name of the
program to be used as the HTML browser.  It should be in the PATH,
or a full path specified.  Alternatively, an <span class="rlang"><b>R</b></span> function to be
called to invoke the browser.
</p>
<p>Under Windows <code>NULL</code> is also allowed (and is the default), and
implies that the file association mechanism will be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The directories that were opened (invisibly).
</p>

<hr>
<h2 id='file_temp'>Create names for temporary files</h2><span id='topic+file_temp'></span><span id='topic+file_temp_push'></span><span id='topic+file_temp_pop'></span><span id='topic+path_temp'></span>

<h3>Description</h3>

<p><code>file_temp()</code> returns the name which can be used as a temporary file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_temp(pattern = "file", tmp_dir = tempdir(), ext = "")

file_temp_push(path)

file_temp_pop()

path_temp(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_temp_+3A_pattern">pattern</code></td>
<td>
<p>A character vector with the non-random portion of the name.</p>
</td></tr>
<tr><td><code id="file_temp_+3A_tmp_dir">tmp_dir</code></td>
<td>
<p>The directory the file will be created in.</p>
</td></tr>
<tr><td><code id="file_temp_+3A_ext">ext</code></td>
<td>
<p>The file extension of the temporary file.</p>
</td></tr>
<tr><td><code id="file_temp_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="file_temp_+3A_...">...</code></td>
<td>
<p>Additional paths appended to the temporary directory by <code>path()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>file_temp_push()</code> can be used to supply deterministic entries in the
temporary file stack. This can be useful for reproducibility in like example
documentation and vignettes.
</p>
<p><code>file_temp_pop()</code> can be used to explicitly remove an entry from the
internal stack, however generally this is done instead by calling
<code>file_temp()</code>.
</p>
<p><code>path_temp()</code> constructs a path within the session temporary directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

path_temp()
path_temp("does-not-exist")

file_temp()
file_temp(ext = "png")
file_temp("image", ext = "png")


# You can make the temp file paths deterministic
file_temp_push(letters)
file_temp()
file_temp()

# Or explicitly remove values
while (!is.null(file_temp_pop())) next
file_temp_pop()
</code></pre>

<hr>
<h2 id='file_touch'>Change file access and modification times</h2><span id='topic+file_touch'></span>

<h3>Description</h3>

<p>Unlike the touch POSIX utility this does not create the file if it does not
exist. Use <code><a href="#topic+file_create">file_create()</a></code> to do this if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_touch(path, access_time = Sys.time(), modification_time = access_time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_touch_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="file_touch_+3A_access_time">access_time</code>, <code id="file_touch_+3A_modification_time">modification_time</code></td>
<td>
<p>The times to set, inputs will be
coerced to <a href="base.html#topic+POSIXct">POSIXct</a> objects.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
file_create("foo")
file_touch("foo", "2018-01-01")
file_info("foo")[c("access_time", "modification_time", "change_time", "birth_time")]

</code></pre>

<hr>
<h2 id='fs_bytes'>Human readable file sizes</h2><span id='topic+fs_bytes'></span><span id='topic+as_fs_bytes'></span>

<h3>Description</h3>

<p>Construct, manipulate and display vectors of file sizes. These are numeric
vectors, so you can compare them numerically, but they can also be compared
to human readable values such as '10MB'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_fs_bytes(x)

fs_bytes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs_bytes_+3A_x">x</code></td>
<td>
<p>A numeric or character vector. Character representations can use
shorthand sizes (see examples).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fs_bytes("1")
fs_bytes("1K")
fs_bytes("1Kb")
fs_bytes("1Kib")
fs_bytes("1MB")

fs_bytes("1KB") &lt; "1MB"

sum(fs_bytes(c("1MB", "5MB", "500KB")))
</code></pre>

<hr>
<h2 id='fs_path'>File paths</h2><span id='topic+fs_path'></span><span id='topic+as_fs_path'></span>

<h3>Description</h3>

<p>Tidy file paths, character vectors which are coloured by file type on
capable terminals.
</p>
<p>Colouring can be customized by setting the <code>LS_COLORS</code> environment variable,
the format is the same as that read by GNU ls / dircolors.
</p>
<p>Colouring of file paths can be disabled by setting <code>LS_COLORS</code> to an empty
string e.g. <code>Sys.setenv(LS_COLORS = "")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_fs_path(x)

fs_path(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs_path_+3A_x">x</code></td>
<td>
<p>vector to be coerced to a fs_path object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://geoff.greer.fm/lscolors">https://geoff.greer.fm/lscolors</a>,
<a href="https://github.com/trapd00r/LS_COLORS">https://github.com/trapd00r/LS_COLORS</a>,
<a href="https://github.com/seebi/dircolors-solarized">https://github.com/seebi/dircolors-solarized</a> for some example colour
settings.
</p>

<hr>
<h2 id='fs_perms'>Create, modify and view file permissions</h2><span id='topic+fs_perms'></span><span id='topic+as_fs_perms'></span>

<h3>Description</h3>

<p><code>fs_perms()</code> objects help one create and modify file permissions easily.
They support both numeric input, octal and symbolic character
representations. Compared to <a href="base.html#topic+octmode">octmode</a> they support symbolic representations
and display the mode the same format as <code>ls</code> on POSIX systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_fs_perms(x, ...)

fs_perms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs_perms_+3A_x">x</code></td>
<td>
<p>An object which is to be coerced to a fs_perms object. Can be an
number or octal character representation, including symbolic
representations.</p>
</td></tr>
<tr><td><code id="fs_perms_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On POSIX systems the permissions are displayed as a 9 character string with
three sets of three characters. Each set corresponds to the permissions for
the user, the group and other (or default) users.
</p>
<p>If the first character of each set is a &quot;r&quot;, the file is readable for those
users, if a &quot;-&quot;, it is not readable.
</p>
<p>If the second character of each set is a &quot;w&quot;, the file is writable for those
users, if a &quot;-&quot;, it is not writable.
</p>
<p>The third character is more complex, and is the first of the following
characters which apply.
</p>

<ul>
<li><p> 'S' If the character is part of the owner permissions and the file is not
executable or the directory is not searchable by the owner, and the
set-user-id bit is set.
</p>
</li>
<li><p> 'S' If the character is part of the group permissions and the file is not
executable or the directory is not searchable by the group, and the
set-group-id bit is set.
</p>
</li>
<li><p> 'T' If the character is part of the other permissions and the file is not
executable or the directory is not searchable by others, and the 'sticky'
(S_ISVTX) bit is set.
</p>
</li>
<li><p> 's' If the character is part of the owner permissions and the file is
executable or the directory searchable by the owner, and the set-user-id bit
is set.
</p>
</li>
<li><p> 's' If the character is part of the group permissions and the file is
executable or the directory searchable by the group, and the set-group-id
bit is set.
</p>
</li>
<li><p> 't' If the character is part of the other permissions and the file is
executable or the directory searchable by others, and the &rdquo;sticky&rdquo;
(S_ISVTX) bit is set.
</p>
</li>
<li><p> 'x' The file is executable or the directory is searchable.
</p>
</li>
<li><p> '-' If none of the above apply.
Most commonly the third character is either 'x' or <code>-</code>.
</p>
</li></ul>

<p>On Windows the permissions are displayed as a 3 character string where the
third character is only <code>-</code> or <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Integer and numeric
fs_perms(420L)
fs_perms(c(511, 420))

# Octal
fs_perms("777")
fs_perms(c("777", "644"))

# Symbolic
fs_perms("a+rwx")
fs_perms(c("a+rwx", "u+rw,go+r"))

# Use the `&amp;` and `|`operators to check for certain permissions
(fs_perms("777") &amp; "u+r") == "u+r"
</code></pre>

<hr>
<h2 id='id'>Lookup Users and Groups on a system</h2><span id='topic+id'></span><span id='topic+group_ids'></span><span id='topic+user_ids'></span>

<h3>Description</h3>

<p>These functions use the GETPWENT(3) and GETGRENT(3) system calls to query
users and groups respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_ids()

user_ids()
</code></pre>


<h3>Value</h3>

<p>They return their results in a <code>data.frame</code>. On windows both
functions return an empty <code>data.frame</code> because windows does not have user
or group ids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># list first 6 groups
head(group_ids())

# list first 6 users
head(user_ids())
</code></pre>

<hr>
<h2 id='is_absolute_path'>Test if a path is an absolute path</h2><span id='topic+is_absolute_path'></span>

<h3>Description</h3>

<p>Test if a path is an absolute path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_absolute_path(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_absolute_path_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_absolute_path("/foo")
is_absolute_path("C:\\foo")
is_absolute_path("\\\\myserver\\foo\\bar")

is_absolute_path("foo/bar")
</code></pre>

<hr>
<h2 id='is_file'>Functions to test for file types</h2><span id='topic+is_file'></span><span id='topic+is_dir'></span><span id='topic+is_link'></span><span id='topic+is_file_empty'></span>

<h3>Description</h3>

<p>Functions to test for file types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_file(path, follow = TRUE)

is_dir(path, follow = TRUE)

is_link(path)

is_file_empty(path, follow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_file_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="is_file_+3A_follow">follow</code></td>
<td>
<p>If <code>TRUE</code>, symbolic links will be followed (recursively) and
the results will be that of the final file rather than the link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named logical vector, where the names give the paths. If the given
object does not exist, <code>NA</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+file_exists">file_exists()</a></code>, <code><a href="#topic+dir_exists">dir_exists()</a></code> and <code><a href="#topic+link_exists">link_exists()</a></code> if you want
to ensure that the path also exists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dir_create("d")

file_create("d/file.txt")
dir_create("d/dir")
link_create(path(path_abs("d"), "file.txt"), "d/link")

paths &lt;- dir_ls("d")
is_file(paths)
is_dir(paths)
is_link(paths)

# Cleanup
dir_delete("d")

</code></pre>

<hr>
<h2 id='link_path'>Read the value of a symbolic link</h2><span id='topic+link_path'></span>

<h3>Description</h3>

<p>Read the value of a symbolic link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_path(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_path_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy path to the object the link points to.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file_create("foo")
link_create(path_abs("foo"), "bar")
link_path("bar")

# Cleanup
file_delete(c("foo", "bar"))

</code></pre>

<hr>
<h2 id='path'>Construct path to a file or directory</h2><span id='topic+path'></span><span id='topic+path_wd'></span>

<h3>Description</h3>

<p><code>path()</code> constructs a relative path, <code>path_wd()</code> constructs an absolute path
from the current working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path(..., ext = "")

path_wd(..., ext = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_+3A_...">...</code></td>
<td>
<p>character vectors, if any values are NA, the result will also be
NA. The paths follow the recycling rules used in the tibble package,
namely that only length 1 arguments are recycled.</p>
</td></tr>
<tr><td><code id="path_+3A_ext">ext</code></td>
<td>
<p>An optional extension to append to the generated path.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+path_home">path_home()</a></code>, <code><a href="#topic+path_package">path_package()</a></code> for functions to construct paths
relative to the home and package directories respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path("foo", "bar", "baz", ext = "zip")

path("foo", letters[1:3], ext = "txt")
</code></pre>

<hr>
<h2 id='path_expand'>Finding the User Home Directory</h2><span id='topic+path_expand'></span><span id='topic+path_expand_r'></span><span id='topic+path_home'></span><span id='topic+path_home_r'></span>

<h3>Description</h3>


<ul>
<li> <p><code>path_expand()</code> performs tilde expansion on a path, replacing instances of
<code>~</code> or <code>~user</code> with the user's home directory.
</p>
</li>
<li> <p><code>path_home()</code> constructs a path within the expanded users home directory,
calling it with <em>no</em> arguments can be useful to verify what fs considers the
home directory.
</p>
</li>
<li> <p><code>path_expand_r()</code> and <code>path_home_r()</code> are equivalents which always use R's
definition of the home directory.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>path_expand(path)

path_expand_r(path)

path_home(...)

path_home_r(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_expand_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="path_expand_+3A_...">...</code></td>
<td>
<p>Additional paths appended to the home directory by <code><a href="#topic+path">path()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>path_expand()</code> differs from <code><a href="base.html#topic+path.expand">base::path.expand()</a></code> in the interpretation of
the home directory of Windows. In particular <code>path_expand()</code> uses the path
set in the <code>USERPROFILE</code> environment variable and, if unset, then uses
<code>HOMEDRIVE</code>/<code>HOMEPATH</code>.
</p>
<p>In contrast <code><a href="base.html#topic+path.expand">base::path.expand()</a></code> first checks for <code>R_USER</code> then <code>HOME</code>,
which in the default configuration of R on Windows are both set to the user's
document directory, e.g. <code style="white-space: pre;">&#8288;C:\\Users\\username\\Documents&#8288;</code>.
<code><a href="base.html#topic+path.expand">base::path.expand()</a></code> also does not support <code>~otheruser</code> syntax on Windows,
whereas <code>path_expand()</code> does support this syntax on all systems.
</p>
<p>This definition makes fs more consistent with the definition of home
directory used on Windows in other languages, such as
<a href="https://docs.python.org/3/library/os.path.html#os.path.expanduser">python</a>
and <a href="https://doc.rust-lang.org/std/env/fn.home_dir.html#windows">rust</a>. This
is also more compatible with external tools such as git and ssh, both of
which put user-level files in <code>USERPROFILE</code> by default. It also allows you to
write portable paths, such as <code style="white-space: pre;">&#8288;~/Desktop&#8288;</code> that points to the Desktop location
on Windows, macOS and (most) Linux systems.
</p>
<p>Users can set the <code>R_FS_HOME</code> environment variable to override the
definitions on any platform.
</p>


<h3>See Also</h3>

<p><a href="https://cran.r-project.org/bin/windows/base/rw-FAQ.html#What-are-HOME-and-working-directories_003f">R for Windows FAQ - 2.14</a>
for behavior of <code><a href="base.html#topic+path.expand">base::path.expand()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Expand a path
path_expand("~/bin")

# You can use `path_home()` without arguments to see what is being used as
# the home diretory.
path_home()
path_home("R")

# This will likely differ from the above on Windows
path_home_r()
</code></pre>

<hr>
<h2 id='path_file'>Manipulate file paths</h2><span id='topic+path_file'></span><span id='topic+path_dir'></span><span id='topic+path_ext'></span><span id='topic+path_ext_remove'></span><span id='topic+path_ext_set'></span><span id='topic+path_ext+3C-'></span>

<h3>Description</h3>

<p><code>path_file()</code> returns the filename portion of the path, <code>path_dir()</code> returns
the directory portion. <code>path_ext()</code> returns the last extension (if any) for a
path. <code>path_ext_remove()</code> removes the last extension and returns the rest of
the path. <code>path_ext_set()</code> replaces the extension with a new extension. If
there is no existing extension the new extension is appended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_file(path)

path_dir(path)

path_ext(path)

path_ext_remove(path)

path_ext_set(path, ext)

path_ext(path) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_file_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="path_file_+3A_ext">ext</code>, <code id="path_file_+3A_value">value</code></td>
<td>
<p>The new file extension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note because these are not full file paths they return regular character
vectors, not <code>fs_path()</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+basename">base::basename()</a></code>, <code><a href="base.html#topic+basename">base::dirname()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path_file("dir/file.zip")

path_dir("dir/file.zip")

path_ext("dir/file.zip")

path_ext("file.tar.gz")

path_ext_remove("file.tar.gz")

# Only one level of extension is removed
path_ext_set(path_ext_remove("file.tar.gz"), "zip")
</code></pre>

<hr>
<h2 id='path_filter'>Filter paths</h2><span id='topic+path_filter'></span>

<h3>Description</h3>

<p>Filter paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_filter(path, glob = NULL, regexp = NULL, invert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_filter_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="path_filter_+3A_glob">glob</code></td>
<td>
<p>A wildcard aka globbing pattern (e.g. <code style="white-space: pre;">&#8288;*.csv&#8288;</code>) passed on to <code><a href="base.html#topic+grep">grep()</a></code> to filter paths.</p>
</td></tr>
<tr><td><code id="path_filter_+3A_regexp">regexp</code></td>
<td>
<p>A regular expression (e.g. <code style="white-space: pre;">&#8288;[.]csv$&#8288;</code>) passed on to <code><a href="base.html#topic+grep">grep()</a></code> to filter paths.</p>
</td></tr>
<tr><td><code id="path_filter_+3A_invert">invert</code></td>
<td>
<p>If <code>TRUE</code> return files which do <em>not</em> match</p>
</td></tr>
<tr><td><code id="path_filter_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="base.html#topic+grep">grep</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>path_filter(c("foo", "boo", "bar"), glob = "*oo")
path_filter(c("foo", "boo", "bar"), glob = "*oo", invert = TRUE)

path_filter(c("foo", "boo", "bar"), regexp = "b.r")
</code></pre>

<hr>
<h2 id='path_math'>Path computations</h2><span id='topic+path_math'></span><span id='topic+path_real'></span><span id='topic+path_split'></span><span id='topic+path_join'></span><span id='topic+path_abs'></span><span id='topic+path_norm'></span><span id='topic+path_rel'></span><span id='topic+path_common'></span><span id='topic+path_has_parent'></span>

<h3>Description</h3>

<p>All functions apart from <code>path_real()</code> are purely path computations, so the
files in question do not need to exist on the filesystem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_real(path)

path_split(path)

path_join(parts)

path_abs(path, start = ".")

path_norm(path)

path_rel(path, start = ".")

path_common(path)

path_has_parent(path, parent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_math_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
<tr><td><code id="path_math_+3A_parts">parts</code></td>
<td>
<p>A character vector or a list of character vectors, corresponding
to split paths.</p>
</td></tr>
<tr><td><code id="path_math_+3A_start">start</code></td>
<td>
<p>A starting directory to compute the path relative to.</p>
</td></tr>
<tr><td><code id="path_math_+3A_parent">parent</code></td>
<td>
<p>The parent path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new path(s) in an <code>fs_path</code> object, which is a character vector
that also has class <code>fs_path</code>. Except <code>path_split()</code>, which returns a list
of character vectors of path components.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>path_real()</code>: returns the canonical path, eliminating any symbolic
links and the special references <code>~</code>, <code>~user</code>, <code>.</code>, and <code>..</code>, , i.e. it
calls <code>path_expand()</code> (literally) and <code>path_norm()</code> (effectively).
</p>
</li>
<li> <p><code>path_split()</code>: splits paths into parts.
</p>
</li>
<li> <p><code>path_join()</code>: joins parts together. The inverse of <code><a href="#topic+path_split">path_split()</a></code>.
See <code><a href="#topic+path">path()</a></code> to concatenate vectorized strings into a path.
</p>
</li>
<li> <p><code>path_abs()</code>: returns a normalized, absolute version of a path.
</p>
</li>
<li> <p><code>path_norm()</code>: eliminates <code>.</code> references and rationalizes up-level
<code>..</code> references, so <code>A/./B</code> and <code>A/foo/../B</code> both become <code>A/B</code>, but <code>../B</code>
is not changed. If one of the paths is a symbolic link, this may change the
meaning of the path, so consider using <code>path_real()</code> instead.
</p>
</li>
<li> <p><code>path_rel()</code>: computes the path relative to the <code>start</code> path,
which can be either an absolute or relative path.
</p>
</li>
<li> <p><code>path_common()</code>: finds the common parts of two (or more) paths.
</p>
</li>
<li> <p><code>path_has_parent()</code>: determine if a path has a given parent.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+path_expand">path_expand()</a></code> for expansion of user's home directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dir_create("a")
file_create("a/b")
link_create(path_abs("a"), "c")

# Realize the path
path_real("c/b")

# Split a path
parts &lt;- path_split("a/b")
parts

# Join it together
path_join(parts)

# Find the absolute path
path_abs("..")

# Normalize a path
path_norm("a/../b\\c/.")

# Compute a relative path
path_rel("/foo/abc", "/foo/bar/baz")

# Find the common path between multiple paths
path_common(c("/foo/bar/baz", "/foo/bar/abc", "/foo/xyz/123"))

# Cleanup
dir_delete("a")
link_delete("c")

</code></pre>

<hr>
<h2 id='path_package'>Construct a path to a location within an installed or development package</h2><span id='topic+path_package'></span>

<h3>Description</h3>

<p><code>path_package</code> differs from <code><a href="base.html#topic+system.file">system.file()</a></code> in that it always returns an
error if the package does not exist. It also returns a different error if
the file within the package does not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_package(package, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_package_+3A_package">package</code></td>
<td>
<p>Name of the package to in which to search</p>
</td></tr>
<tr><td><code id="path_package_+3A_...">...</code></td>
<td>
<p>Additional paths appended to the package path by <code><a href="#topic+path">path()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>path_package()</code> also automatically works with packages loaded with devtools
even if the <code>path_package()</code> call comes from a different package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path_package("base")
path_package("stats")
path_package("base", "INDEX")
path_package("splines", "help", "AnIndex")
</code></pre>

<hr>
<h2 id='path_sanitize'>Sanitize a filename by removing directory paths and invalid characters</h2><span id='topic+path_sanitize'></span>

<h3>Description</h3>

<p><code>path_sanitize()</code> removes the following:
</p>

<ul>
<li> <p><a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes">Control characters</a>
</p>
</li>
<li> <p><a href="https://web.archive.org/web/20230126161942/https://kb.acronis.com/content/39790">Reserved characters</a>
</p>
</li>
<li><p> Unix reserved filenames (<code>.</code> and <code>..</code>)
</p>
</li>
<li><p> Trailing periods and spaces (invalid on Windows)
</p>
</li>
<li><p> Windows reserved filenames (<code>CON</code>, <code>PRN</code>, <code>AUX</code>, <code>NUL</code>, <code>COM1</code>, <code>COM2</code>,
<code>COM3</code>, COM4, <code>COM5</code>, <code>COM6</code>, <code>COM7</code>, <code>COM8</code>, <code>COM9</code>, <code>LPT1</code>, <code>LPT2</code>,
<code>LPT3</code>, <code>LPT4</code>, <code>LPT5</code>, <code>LPT6</code>, LPT7, <code>LPT8</code>, and <code>LPT9</code>)
The resulting string is then truncated to <a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems#Limits">255 bytes in length</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>path_sanitize(filename, replacement = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_sanitize_+3A_filename">filename</code></td>
<td>
<p>A character vector to be sanitized.</p>
</td></tr>
<tr><td><code id="path_sanitize_+3A_replacement">replacement</code></td>
<td>
<p>A character vector used to replace invalid characters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://www.npmjs.com/package/sanitize-filename">https://www.npmjs.com/package/sanitize-filename</a>, upon which this
function is based.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># potentially unsafe string
str &lt;- "~/.\u0001ssh/authorized_keys"
path_sanitize(str)

path_sanitize("..")
</code></pre>

<hr>
<h2 id='path_tidy'>Tidy paths</h2><span id='topic+path_tidy'></span>

<h3>Description</h3>

<p>untidy paths are all different, tidy paths are all the same.
Tidy paths always use <code>/</code> to delimit directories, never have
multiple <code>/</code> or trailing <code>/</code> and have colourised output based on the file
type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_tidy(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_tidy_+3A_path">path</code></td>
<td>
<p>A character vector of one or more paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fs_path</code> object, which is a character vector that also has class
<code>fs_path</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
