<!DOCTYPE html><html lang="en"><head><title>Help for package island</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {island}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#island'><p>island: Stochastic Island Biogeography Theory Made Easy</p></a></li>
<li><a href='#akaikeic'><p>Akaike Information Criterion</p></a></li>
<li><a href='#all_environmental_fit'><p>Environmental fit for a single dataset</p></a></li>
<li><a href='#alonso15'><p>Lakshadweep Archipelago coral fish community reassembly</p></a></li>
<li><a href='#cetotrans'><p>From rates to probabilities</p></a></li>
<li><a href='#data_generation'><p>Data simulation of colonization-extinction dynamics</p></a></li>
<li><a href='#ibd_models'><p>Inmigration, birth, death- models</p></a></li>
<li><a href='#idaho'><p>Mapped plant community time series, Dubois, ID</p></a></li>
<li><a href='#irregular_multiple_datasets'><p>c/e rates for irregular samplings in multiple datasets</p></a></li>
<li><a href='#irregular_single_dataset'><p>c/e rates for irregular samplings in a dataset</p></a></li>
<li><a href='#lakshadweep'><p>Lakshadweep Archipelago coral fish community reassembly data (expanded)</p></a></li>
<li><a href='#lakshadweepPLUS'><p>Lakshadweep Archipelago coral fish community reassembly data in a single data frame</p></a></li>
<li><a href='#mss_cedp'><p>Likelihood approach for estimating colonization/extinction with perfect or imperfect detectability</p></a></li>
<li><a href='#r_squared'><p>Model prediction error</p></a></li>
<li><a href='#rates_calculator'><p>Colonization and extinction rates calculator for expressions.</p></a></li>
<li><a href='#regular_sampling_scheme'><p>c/e rates for a regular sampling scheme</p></a></li>
<li><a href='#simberloff'><p>Simberloff and Wilson original defaunation experiment data</p></a></li>
<li><a href='#sss_cedp'><p>MacKenzie etal (2003) likelihood approach for estimating colonization/extinction</p>
parameters (with imperfect detectability)</a></li>
<li><a href='#upgma_model_selection'><p>Model selection function based on a upgma grouping algorithm</p></a></li>
<li><a href='#weight_of_evidence'><p>Weight of evidence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stochastic Island Biogeography Theory Made Easy</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-29</td>
</tr>
<tr>
<td>Description:</td>
<td>Develops stochastic models based on the Theory of Island
    Biogeography (TIB) of MacArthur and Wilson (1967) &lt;<a href="https://doi.org/10.1023%2FA%3A1016393430551">doi:10.1023/A:1016393430551</a>&gt;
    and extensions. It implements methods to estimate colonization and
    extinction rates (including environmental variables) given presence-absence
    data, simulates community assembly, and performs model selection.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, rootSolve</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 08:01:18 UTC; vicente</td>
</tr>
<tr>
<td>Author:</td>
<td>Vicente Jimenez [aut, cre],
  David Alonso [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vicente Jimenez &lt;vicente.jimenez.ontiveros@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 11:20:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='island'>island: Stochastic Island Biogeography Theory Made Easy</h2><span id='topic+island'></span><span id='topic+island-package'></span>

<h3>Description</h3>

<p>Tools to develop stochastic models based on the Theory of Island Biogeography
(TIB) of MacArthur and Wilson (1967) and extensions. The package allows the
calculation of colonization and extinction rates (including environmental
variables) given presence-absence data, the simulation of community assembly
and model selection.
</p>


<h3>Details</h3>

<p>In the simplest stochastic model of Island Biogeography, there is a
pool of species that potentially can colonize a system of islands. When we
sample an island in time, we obtain a time-series of presence-absence
vectors for the different species of the pool, which allows us to estimate
colonization (<code class="reqn">c</code>) and extinction (<code class="reqn">e</code>) rates under perfect
detectability. These are actual rates (in <code class="reqn">T^{-1}</code> units). <br /> The
simplest stochastic model of island biogeography assumes a single
colonization-extinction pair for the whole community. This model implicitly
assumes: first, neutrality of the species in the community, that is, all
species in the community share the same values for those rates; and second,
all species colonize and become extinct independently from each other. The
&quot;species neutrality assumption&quot; can be relaxed easily, for example,
calculating different rates for different groups or on a per-species basis.
In addition, we can make these rates depend on environmental variables
measured at the same time that we took our samples. For more information of
the basic model, please see the references.
</p>


<h3>Data entry</h3>

<p>The data should be organized in dataframes with
consecutive presence-absence data of each sample ordered cronologically,
being the data associated with a single species in a row. Additional
columns can contain the filiations of every species to a group, i. e. a
phylogenetic group or a guild.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Vicente Jimenez <a href="mailto:vicente.jimenez.ontiveros@gmail.com">vicente.jimenez.ontiveros@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> David Alonso <a href="mailto:dalonso@ceab.csic.es">dalonso@ceab.csic.es</a>
</p>
</li></ul>



<h3>References</h3>

<p>Alonso, D., Pinyol-Gallemi, A., Alcoverro T. and Arthur, R..
(2015) Fish community reassembly after a coral mass mortality: higher
trophic groups are subject to increased rates of extinction. <em>Ecology
Letters</em>, <b>18</b>, 451&ndash;461. <br /> <br /> Simberloff, D. S., and Wilson, E.
O.. (1969). Experimental Zoogeography of Islands: The Colonization of Empty
Islands. <em>Ecology</em>, <b>50(2)</b>, 278&ndash;296.
<a href="https://doi.org/10.2307/1934856">doi:10.2307/1934856</a> <br /> <br /> Simberloff, D. S.. (1969).
Experimental Zoogeography of Islands: A Model for Insular Colonization.
<em>Ecology</em>, <b>50(2)</b>, 296&ndash;314.
<a href="https://doi.org/10.2307/1934857">doi:10.2307/1934857</a>
</p>

<hr>
<h2 id='akaikeic'>Akaike Information Criterion</h2><span id='topic+akaikeic'></span><span id='topic+akaikeicc'></span>

<h3>Description</h3>

<p><code>akaikeic</code> calculates the Akaike Information Criterion (AIC) of a model.
<br /> <code>akaikeicc</code> calculates the corrected Akaike Information Criterion
(AICc) for small samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>akaikeic(NLL, k)

akaikeicc(NLL, k, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="akaikeic_+3A_nll">NLL</code></td>
<td>
<p>Negative Log-Likelihood of the model.</p>
</td></tr>
<tr><td><code id="akaikeic_+3A_k">k</code></td>
<td>
<p>Number of parameters of the model.</p>
</td></tr>
<tr><td><code id="akaikeic_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AIC = 2 * k + 2 * NLL</code>
</p>
 <p style="text-align: center;"><code class="reqn">AICc = 2 * k - 2 * lnL + 2 * k *
  (k + 1) / (n - k - 1)</code>
</p>



<h3>Value</h3>

<p>A number with the AIC value for a model with k parameters and
negative log-likelihood NLL, or the AICc value for a model with k parameters,
negative log-likelihood NLL and sample size n.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weight_of_evidence">weight_of_evidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>akaikeic(1485.926, 3)
akaikeicc(736.47, 6, 15)
akaikeicc(736.47, 6, 100)
</code></pre>

<hr>
<h2 id='all_environmental_fit'>Environmental fit for a single dataset</h2><span id='topic+all_environmental_fit'></span><span id='topic+custom_environmental_fit'></span><span id='topic+NLL_env'></span><span id='topic+greedy_environmental_fit'></span>

<h3>Description</h3>

<p><code>all_environmental_fit</code> estimates the best expressions for colonization
and extinction rates given their dependency on environmental variables. <br />
<code>greedy_environmental_fit</code> estimates expressions for colonization and
extinction rates given their dependency on environmental variables using a
greedy algorithm. <br /> <code>custom_environmental_fit</code> estimates the m.l.e. of
the parameters describing the relationship between colonization and
extinction rates and environmental variables. <br /> <code>NLL_env</code> returns the
Negative Log-Likelihood of a pair of colonization and extinction rates for a
given dataset with an specific relationship with environmental variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_environmental_fit(dataset, vector, env, c, e, aic, verbose = FALSE)

custom_environmental_fit(dataset, vector, params, c_expression, e_expression)

NLL_env(dataset, vector, params, c_expression, e_expression)

greedy_environmental_fit(dataset, vector, env, c, e, aic, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_environmental_fit_+3A_dataset">dataset</code></td>
<td>
<p>A single dataset.</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_vector">vector</code></td>
<td>
<p>A vector indicating the columns with presence-absence data.</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_env">env</code></td>
<td>
<p>The names of the environmental variables to be considered.</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_c">c</code></td>
<td>
<p>Tentative colonization rate.</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_e">e</code></td>
<td>
<p>Tentative extinction rate.</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_aic">aic</code></td>
<td>
<p>Tentative AIC to be improved by the optimizer.</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Do you want to get the intermediate steps looking for
the best model?</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_params">params</code></td>
<td>
<p>A vector with priors of the parameters in c_expression and e_expression.</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_c_expression">c_expression</code></td>
<td>
<p>Expression for colonization.</p>
</td></tr>
<tr><td><code id="all_environmental_fit_+3A_e_expression">e_expression</code></td>
<td>
<p>Expression for extinction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>all_environmental_fit</code> calculates all the combinations of
parameters, that increase exponentially with the number of parameters. We
advise to keep low the number of parameters. <br />
<code>greedy_environmental_fit</code> adds sequentially environmental variables
to the expressions of colonization and extinction rates and fix one at a
time until termination, when only adding one variable does not improve the
AIC of the last accepted model.
</p>


<h3>Value</h3>

<p>A list with three components: a expression for colonization, a
expression for extinction and the output of the optimization function, or
the output of the optimization function in the custom environmental fit.
<br /> In the case of <code>NLL_env</code>, returns the NLL of an specific set or
parameters describing the relationship of environmental covariates with
colonizaiton and extinction.
</p>


<h3>Note</h3>

<p>AIC is recommended to be higher than the AIC of the most simple model
(i.e. not including environmental variables).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rates_calculator">rates_calculator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
all_environmental_fit(idaho[[1]],3:23,c("idaho[[2]]$TOTAL.ppt",
"idaho[[2]]$ANNUAL.temp"),0.13,0.19,100000)
greedy_environmental_fit(idaho[[1]],3:23,c("idaho[[2]]$TOTAL.ppt",
"idaho[[2]]$ANNUAL.temp"),0.13,0.19,100000)

custom_environmental_fit(idaho[[1]], 3:23, c(-0.00497925, -0.01729602,
0.19006501, 0.93486956), expression(params[1] * idaho[[2]]$TOTAL.ppt[i] +
params[3]), expression(params[2] * idaho[[2]]$ANNUAL.temp[i] + params[4]))
NLL_env(idaho[[1]], 3:23, c(-0.00497925, -0.01729602,
0.19006501, 0.93486956), expression(params[1] * idaho[[2]]$TOTAL.ppt[i] +
params[3]), expression(params[2] * idaho[[2]]$ANNUAL.temp[i] + params[4]))

</code></pre>

<hr>
<h2 id='alonso15'>Lakshadweep Archipelago coral fish community reassembly</h2><span id='topic+alonso15'></span>

<h3>Description</h3>

<p>A list with three datasets containing presence-absence data for the
reassembly proccess of coral fish communities in three atolls (Agatti, Kadmat
and Kavaratti) of the Lakshadweep Archipelago (India).
</p>


<h3>Format</h3>

<p>A list with 3 dataframes, each corresponding to the survey of a
different atoll. Dataframes have in columns: </p>
 <dl>
<dt>Species</dt><dd><p>Name
of the species found</p>
</dd> <dt>Trophic.Level</dt><dd><p>A number indicating the trophic
level of the surveyed species</p>
</dd> <dt>Presence-absence data</dt><dd><p>Several columns
with letters (indicating the atoll surveyed) and the year in which the
surveys were done</p>
</dd> <dt>Guild</dt><dd><p>Guild of the surveyed species</p>
</dd> </dl>



<h3>Details</h3>

<p>Surveys were conducted from 2000 to 2011 in order to follow community
reassembly after a coral mass mortality event in the relatively unfished
Lakshadweep Archipelago.  Results indicated that higher trophic groups suffer
an increased extinction rate even without fishing targeting them.
</p>


<h3>Note</h3>

<p>Kavaratti atoll was not surveyed in 2000 and 2010.
</p>


<h3>Source</h3>

<p>Alonso, D., Pinyol-Gallemi, A., Alcoverro T. and Arthur, R.. (2015)
Fish community reassembly after a coral mass mortality: higher trophic
groups are subject to increased rates of extinction. <em>Ecology
Letters</em>, <b>18</b>, 451&ndash;461.
</p>

<hr>
<h2 id='cetotrans'>From rates to probabilities</h2><span id='topic+cetotrans'></span>

<h3>Description</h3>

<p><code>cetotrans</code> calculates transition probabilities from colonization and
extinction rates for a determined interval of time, when provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cetotrans(c, e, dt = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cetotrans_+3A_c">c</code></td>
<td>
<p>Colonization rate.</p>
</td></tr>
<tr><td><code id="cetotrans_+3A_e">e</code></td>
<td>
<p>Extinction rate.</p>
</td></tr>
<tr><td><code id="cetotrans_+3A_dt">dt</code></td>
<td>
<p>Interval of time or a vector of time intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a pair of colonization and extinction rates, we can calculate
the transition probabilities with the following equations: </p>
<p style="text-align: center;"><code class="reqn">T_{01} = (e
  / (c + e)) * (1 - exp( - (c + e) * dt))</code>
</p>
 <p style="text-align: center;"><code class="reqn">T_{10} = (c / (c + e)) * (1 -
  exp( - (c + e) * dt))</code>
</p>



<h3>Value</h3>

<p>A matrix with the transition probabilities <code class="reqn">T_{01}</code> and <code class="reqn">T_{10}</code> of the Markov chain
associated with the specified colonization and extinction rates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cetotrans(0.13, 0.19)
cetotrans(0.2, 0.2, 2)
</code></pre>

<hr>
<h2 id='data_generation'>Data simulation of colonization-extinction dynamics</h2><span id='topic+data_generation'></span><span id='topic+PA_simulation'></span>

<h3>Description</h3>

<p><code>data_generation</code> simulates species richness data according to the
stochastic model of island biogeography <br /> <code>PA_simulation</code> simulates
presence-absence data according to the stochastic model of island
biogeography
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_generation(x, column, transitions, iter, times)

PA_simulation(x, column, transitions, times = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_generation_+3A_x">x</code></td>
<td>
<p>A dataframe with the vector of initial absences and presences.</p>
</td></tr>
<tr><td><code id="data_generation_+3A_column">column</code></td>
<td>
<p>A number indicating the column with the initial
presence-absence data.</p>
</td></tr>
<tr><td><code id="data_generation_+3A_transitions">transitions</code></td>
<td>
<p>A matrix with the transition probabilities of the
simulation, in the form (T01, T10), that can contain one single pair or
multiple pairs.</p>
</td></tr>
<tr><td><code id="data_generation_+3A_iter">iter</code></td>
<td>
<p>Number of times that the specified dynamics should be repeated.</p>
</td></tr>
<tr><td><code id="data_generation_+3A_times">times</code></td>
<td>
<p>Number of temporal steps to simulate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To simulate community assembly, we need an initial vector of
presence-absence, from which the subsequent assembly process will be
simulated. This initial vector is considered as <code>x[, column]</code>.
</p>


<h3>Value</h3>

<p>A matrix with species richness representing each row consecutive
samples and each column a replica of the specified dynamics  or a matrix
with presence-absence data for the specified dynamics, each row
representing a species and each column consecutive samplings.
</p>


<h3>Note</h3>

<p>You can simulate not only with a colonization and extinction pair, but
with the pairs obtained from the environmental fit. In this case, you still
have to indicate exactly the number of temporal steps that you are going to
simulate.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cetotrans">cetotrans</a></code> to obtain the transition probabilities
associated with a colonization-extinction pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_generation(as.data.frame(rep(0, 100)), 1,
matrix(c(0.5, 0.5), ncol = 2), 5, 25)
data_generation(alonso15[[1]], 3, matrix(c(0.5, 0.5), ncol = 2), 5, 25)
PA_simulation(as.data.frame(c(rep(0, 163), rep(1, 57))), 1, c(0.13, 0.19),
20)

</code></pre>

<hr>
<h2 id='ibd_models'>Inmigration, birth, death- models</h2><span id='topic+ibd_models'></span>

<h3>Description</h3>

<p><code>ibd_models</code> simulates population dynamics under three different
inmigration, birth and death models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibd_models(n0, beta, delta, mu, K = NULL, time_v, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibd_models_+3A_n0">n0</code></td>
<td>
<p>Initial number of individuals in the population.</p>
</td></tr>
<tr><td><code id="ibd_models_+3A_beta">beta</code></td>
<td>
<p>Birth rate, in time^(-1) units.</p>
</td></tr>
<tr><td><code id="ibd_models_+3A_delta">delta</code></td>
<td>
<p>Death rate, in time^(-1) units.</p>
</td></tr>
<tr><td><code id="ibd_models_+3A_mu">mu</code></td>
<td>
<p>Inmigration rate, in time^(-1) units.</p>
</td></tr>
<tr><td><code id="ibd_models_+3A_k">K</code></td>
<td>
<p>Carrying capacity.</p>
</td></tr>
<tr><td><code id="ibd_models_+3A_time_v">time_v</code></td>
<td>
<p>Vector of times to sample. Must start with 0.</p>
</td></tr>
<tr><td><code id="ibd_models_+3A_type">type</code></td>
<td>
<p>Type of inmigration, birth, death- model used to simulate the
dynamics. This must be <code>"Kendall"</code>, <code>"Alonso"</code> or <code>"Haegeman"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We have included three different stochastic models: Kendall (1948) seminal
work, Alonso &amp; McKane (2002) mainland-island model, and Haegeman &amp; Loreau
(2010) basic population model with denso-dependent deaths. These models are
different formulations of a population dynamics with three basic processes:
birth, death and inmigration of individuals. For the specifics, please refer
to the original articles.
</p>


<h3>Value</h3>

<p>A data.frame with two columns: one with the time vector and the other
with the number of individuals at those times.
</p>


<h3>Note</h3>

<p>Haegeman &amp; Loreau model specification breaks for high values of
<code>n0</code> when the birth rate is lower than the death rate.
</p>


<h3>References</h3>

<p>Kendall, D. G. (1948). On some modes of population growth leading
to R. A. Fishers logarithmic series distribution. <em>Biometrika</em>,
<b>35</b>, 6&ndash;15. <br /> <br /> Haegeman, B. and Loreau, M. (2010). A
mathematical synthesis of niche and neutral theories in community ecology.
<em>Journal of Theoretical Biology</em>, <b>269(1)</b>, 150&ndash;165. <br /> <br />
Alonso, D. and McKane, A (2002). Extinction Dynamics in Mainland&ndash;Island
Metapopulations: An N -patch Stochastic Model. <em>Bulletin of
Mathematical Biology</em>, <b>64</b>, 913&ndash;958.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ibd_models(n0 = 0, beta = 0.4, delta = 0.3, mu = 0.2,
time_v = 0:20, type = "Kendall")
ibd_models(n0 = 0, beta = 0.4, delta = 0.3, mu = 0.1, K = 30,
time_v = 0:20, type = "Alonso")

</code></pre>

<hr>
<h2 id='idaho'>Mapped plant community time series, Dubois, ID</h2><span id='topic+idaho'></span>

<h3>Description</h3>

<p>A list with two datasets containing presence-absence and environmental data
for a plant community of sagebrush steppe in Dubois, Idaho, USA
</p>


<h3>Format</h3>

<p>A list with 2 dataframes, one corresponding to the presence-absence
data and the other to the environmental variables. The first dataframe has
in columns: </p>
 <dl>
<dt>quad</dt><dd><p>Name of the quadrat surveyed</p>
</dd>
<dt>species</dt><dd><p>Name of the species found</p>
</dd> <dt>Presence-absence
data</dt><dd><p>Several columns with the year in which the surveys were conducted</p>
</dd></dl>

<p>The second dataframe has the following columns: </p>
 <dl>
<dt>YEAR</dt><dd><p>Year
in which surveys were conducted</p>
</dd> <dt>Environmental variables</dt><dd><p>Data of the
recorded environmental variables in the form XXX.YYY, where XXX denotes a
month (or a total) and YYY can refer to snow (in inches), temperature
(fahrenheit degrees) or precipitation (in inches)</p>
</dd></dl>



<h3>Details</h3>

<p>A historical dataset consisting of a series of permanent 1-<code class="reqn">m^2</code> quadrats
located on the sagebrush steppe in eastern Idaho, USA, between 1923 and 1973.
It also contains records of monthly precipitation, mean temperature and
snowfall. Total precipitation, total snowfall, and mean annual temperature
have been calculated from the original data.
</p>


<h3>Note</h3>

<p>Only quadrats Q1, Q2, Q3, Q4, Q5, Q6, Q25 and Q26 are included here.
The surveys were conducted annually from 1932 to 1955 with some gaps for
the quadrats included here.
</p>


<h3>Source</h3>

<p><a href="https://knb.ecoinformatics.org/#view/doi:10.5063/AA/lzachmann.6.36">https://knb.ecoinformatics.org/#view/doi:10.5063/AA/lzachmann.6.36</a>
</p>


<h3>References</h3>

<p>Zachmann, L., Moffet, C., and Adler, P.. (2010). Mapped quadrats
in sagebrush steppe long-term data for analyzing demographic rates and
plant-plant interactions. <em>Ecology</em>,  <b>91(11)</b>, 3427&ndash;3427.
<a href="https://doi.org/10.1890/10-0404.1">doi:10.1890/10-0404.1</a>
</p>

<hr>
<h2 id='irregular_multiple_datasets'>c/e rates for irregular samplings in multiple datasets</h2><span id='topic+irregular_multiple_datasets'></span><span id='topic+NLL_imd'></span>

<h3>Description</h3>

<p><code>irregular_multiple_datasets</code> estimates colonization and extinction
rates for data in several datasets. <br /> <code>NLL_imd</code> returns the Negative
Log-Likelihood of a pair of colonization and extinction rates for irregular
sampling schemes in several single dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irregular_multiple_datasets(
  list,
  vectorlist,
  c,
  e,
  column = NULL,
  n = NULL,
  step = NULL,
  assembly = FALSE,
  jacobian = FALSE,
  verbose = FALSE,
  CI = FALSE
)

NLL_imd(list, vectorlist, c, e, assembly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irregular_multiple_datasets_+3A_list">list</code></td>
<td>
<p>A list of dataframes.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_vectorlist">vectorlist</code></td>
<td>
<p>A list of vectors indicating the columns with
presence-absence data.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_c">c</code></td>
<td>
<p>Tentative colonization rate.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_e">e</code></td>
<td>
<p>Tentative extinction rate.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_column">column</code></td>
<td>
<p>The name of the column with groups to calculate their c_e pair.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_n">n</code></td>
<td>
<p>Minimal number of rows for each group.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_step">step</code></td>
<td>
<p>Accuracy to calculate the c_e pairs with.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_assembly">assembly</code></td>
<td>
<p>Logical indicating if the assembly starts from zero species
or not.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_jacobian">jacobian</code></td>
<td>
<p>Logical. Use the semianalytical method to estimate colonization
and extinction rates?</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, gives the output of the optimizer or the
numerical solver that finds the values of c and e.</p>
</td></tr>
<tr><td><code id="irregular_multiple_datasets_+3A_ci">CI</code></td>
<td>
<p>Logical. If TRUE, gives the confidence interval of the colonization
and extinction rates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>irregular_multiple_datasets</code> returns a dataframe with
colonization and extinction rates and their upper and lower confidence
interval, and if needed, the names of the groups to which colonization and
extinction rates have been calculated. <code>NLL_imd</code> gives the NLL for a
multiple datasets with irregular sampling schemes given a specific c and e.
</p>


<h3>Note</h3>

<p>The columns with the presence-absence data should have the day of that
sampling on the name of the column in order to calculate colonization and
extinction.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regular_sampling_scheme">regular_sampling_scheme</a></code>,
<code><a href="#topic+irregular_single_dataset">irregular_single_dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irregular_multiple_datasets(simberloff, list(3:17, 3:18, 3:17,
3:19, 3:17, 3:16), 0.001, 0.001)

irregular_multiple_datasets(simberloff, list(3:17, 3:18, 3:17, 3:19, 3:17,
 3:16), 0.001, 0.001, "Tax. Unit 1", n = 13)
irregular_multiple_datasets(simberloff, list(3:17, 3:18, 3:17, 3:19, 3:17,
 3:16), 0.001, 0.001, "Tax. Unit 1", n = 13, CI = TRUE)
 
 NLL_imd(simberloff, list(3:17, 3:18, 3:17, 3:19, 3:17, 3:16), 0.0051, 0.0117)
</code></pre>

<hr>
<h2 id='irregular_single_dataset'>c/e rates for irregular samplings in a dataset</h2><span id='topic+irregular_single_dataset'></span><span id='topic+NLL_isd'></span>

<h3>Description</h3>

<p><code>irregular_single_dataset</code> estimates colonization and extinction rates
in a single dataset with irregular sampling scheme. <br /> <code>NLL_isd</code> returns
the Negative Log-Likelihood of a pair of colonization and extinction rates
for an irregular sampling scheme in a single dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irregular_single_dataset(
  dataframe,
  vector,
  c,
  e,
  column = NULL,
  n = NULL,
  step = NULL,
  assembly = FALSE,
  jacobian = FALSE,
  verbose = FALSE,
  CI = FALSE
)

NLL_isd(dataframe, vector, c, e, assembly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irregular_single_dataset_+3A_dataframe">dataframe</code></td>
<td>
<p>A single dataframe.</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_vector">vector</code></td>
<td>
<p>A vector indicating the columns with presence-absence data.</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_c">c</code></td>
<td>
<p>Tentative colonization rate.</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_e">e</code></td>
<td>
<p>Tentative extinction rate.</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_column">column</code></td>
<td>
<p>The name of the column with groups to calculate their c_e pair.</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_n">n</code></td>
<td>
<p>Minimal number of rows for each group</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_step">step</code></td>
<td>
<p>Accuracy to calculate the c_e pairs with.</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_assembly">assembly</code></td>
<td>
<p>Logical indicating if the assembly starts from zero species
or not.</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_jacobian">jacobian</code></td>
<td>
<p>Logical. Use the semianalytical method to estimate colonization
and extinction rates?</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, gives the output of the optimizer or the
numerical solver that finds the values of c and e.</p>
</td></tr>
<tr><td><code id="irregular_single_dataset_+3A_ci">CI</code></td>
<td>
<p>Logical. If TRUE, gives the confidence interval of the colonization
and extinction rates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>irregular_single_dataset</code> returns a dataframe with colonization
and extinction rates and their upper and lower confidence interval, and if
needed, the names of the groups to which colonization and extinction rates
have been calculated. <code>NLL_isd</code> gives the NLL for a single dataset in
an irregular sampling scheme given a specific c and e.
</p>


<h3>Note</h3>

<p>The columns with the presence-absence data should have the day of that
sampling on the name of the column in order to calculate colonization and
extinction.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regular_sampling_scheme">regular_sampling_scheme</a></code>,
<code><a href="#topic+irregular_multiple_datasets">irregular_multiple_datasets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irregular_single_dataset(simberloff[[1]], 3:17, 0.001, 0.001)
irregular_single_dataset(simberloff[[1]], 3:17, column = "Tax. Unit 1",
0.001, 0.001, 3)

irregular_single_dataset(simberloff[[1]], 3:17, column = "Tax. Unit 1",
0.001, 0.001, 3, 0.00001)

NLL_isd(simberloff[[1]], 3:17, 0.0038, 0.0086)
</code></pre>

<hr>
<h2 id='lakshadweep'>Lakshadweep Archipelago coral fish community reassembly data (expanded)</h2><span id='topic+lakshadweep'></span>

<h3>Description</h3>

<p>A list with three data frames containing presence-absence data for the
reassembly proccess of coral fish communities in three atolls (Agatti, Kadmat
and Kavaratti) of the Lakshadweep Archipelago in India. These data contains a number of 
replicates (transects) per sampling time. It is in this respect that expands
<code>alonso</code> community data (see <code>island</code> R package).
</p>


<h3>Format</h3>

<p>A list with three dataframes from the 3 different 
atoll. The dataframe has in columns: </p>
 <dl>
<dt>Species</dt><dd><p>Name
of the species found</p>
</dd> <dt>Atoll</dt><dd><p>Atoll surveyed</p>
</dd> <dt>Guild</dt><dd><p>Feeding  
strategy of the surveyed species</p>
</dd> <dt>Presence-absence data</dt><dd><p>Several columns 
corresponding to the year in which the surveys were done. Year repetition means
repeated sampling of the same atoll at the same time. Presences are represented
by 1 and true absencestrue or undetected presences by 0.</p>
</dd> </dl>



<h3>Details</h3>

<p>Surveys were conducted from 2000 to 2013 in order to follow community
reassembly after a coral mass mortality event in the relatively unfished
Lakshadweep Archipelago. For most years, transects were taken in four 
locations per atoll. Although there might be some underlying heterogeneity, 
these transects are approximately taken as true replicates.
</p>


<h3>Note</h3>

<p>Detectability per transect results to be of about 0.5, which means that the 
parameter 'Detectability' per atoll goes up to almost 0.94 if four transects per 
sampling time are taken (1-0.5^4).
</p>


<h3>Source</h3>

<p>Alonso, D., Pinyol-Gallemi, A., Alcoverro T. and Arthur, R.. (2015)
Fish community reassembly after a coral mass mortality: higher trophic
groups are subject to increased rates of extinction. <em>Ecology
Letters</em>, <b>18</b>, 451&ndash;461.
</p>

<hr>
<h2 id='lakshadweepPLUS'>Lakshadweep Archipelago coral fish community reassembly data in a single data frame</h2><span id='topic+lakshadweepPLUS'></span>

<h3>Description</h3>

<p>A list with only one data frame containing presence-absence data for the
reassembly proccess of coral fish communities in three atolls (Agatti, Kadmat
and Kavaratti) of the Lakshadweep Archipelago in India. These data contains a number of 
replicates per sampling time. The data matrix marks missing data with a flag. It is in this
respect that differs from <code>lakshadweep</code>.
</p>


<h3>Format</h3>

<p>A list of a single dataframe with data from the 3 different 
atoll. The dataframe has in columns: </p>
 <dl>
<dt>Species</dt><dd><p>Name
of the species found</p>
</dd> <dt>Atoll</dt><dd><p>Atoll surveyed</p>
</dd> <dt>Guild</dt><dd><p>Feeding  
strategy of the surveyed species</p>
</dd> <dt>Presence-absence data</dt><dd><p>Several columns 
corresponding to the year in which the surveys were done. Year repetition means
repeated sampling of the same atoll at the same time. Presences are represented
by 1 and true absencestrue or undetected presences by 0.</p>
</dd> </dl>



<h3>Details</h3>

<p>Surveys were conducted from 2000 to 2013 in order to follow community
reassembly after a coral mass mortality event in the relatively unfished
Lakshadweep Archipelago. For most years, transects were taken in four 
locations per atoll. Although there might be some underlying heterogeneity, 
these transects are approximately taken here as true replicates.
</p>


<h3>Note</h3>

<p>Detectability per transect results to be of about 0.5, which means that the 
parameter 'Detectability' per atoll goes up to almost 0.94 if four transects per 
sampling time are taken (1-0.5^4). The sampling structure differs from atoll to
to atoll. Certain columns are filled with 0.1. This is the missing value flag.
</p>


<h3>Source</h3>

<p>Alonso, D., Pinyol-Gallemi, A., Alcoverro T. and Arthur, R.. (2015)
Fish community reassembly after a coral mass mortality: higher trophic
groups are subject to increased rates of extinction. <em>Ecology
Letters</em>, <b>18</b>, 451&ndash;461.
</p>

<hr>
<h2 id='mss_cedp'>Likelihood approach for estimating colonization/extinction with perfect or imperfect detectability</h2><span id='topic+mss_cedp'></span>

<h3>Description</h3>

<p><code>mss_cedp</code> conducts maximum likelihood estimation of colonization/extinction parameters
of different data sets. This function can handle imperfect detectability and missing data
defining a heterogeneous sampling structure across input data matrix rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mss_cedp(
  Data,
  Time,
  Factor,
  Tags,
  Colonization = 1,
  Extinction = 1,
  Detectability_Value = 0.5,
  Phi_Time_0_Value = 0.5,
  Tol = 1e-08,
  MIT = 100,
  C_MAX = 10,
  C_min = 0,
  E_MAX = 10,
  E_min = 0,
  D_MAX = 0.99,
  D_min = 0,
  P_MAX = 0.99,
  P_min = 0.01,
  I_0 = 0,
  I_1 = 1,
  I_2 = 2,
  I_3 = 3,
  z = 2,
  Minimization = 1,
  Verbose = 0,
  MV_FLAG = 0.1,
  PerfectDetectability = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mss_cedp_+3A_data">Data</code></td>
<td>
<p>data frame containing presence data per time (in cols) and sites (in rows)</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_time">Time</code></td>
<td>
<p>an array of length n containing increasing sampling times</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_factor">Factor</code></td>
<td>
<p>column number containing the 'data frame' factor used to split total data into level-based groups</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_tags">Tags</code></td>
<td>
<p>array of names (one short for each level of the factor analyzed)</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_colonization">Colonization</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_extinction">Extinction</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_detectability_value">Detectability_Value</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_phi_time_0_value">Phi_Time_0_Value</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_tol">Tol</code></td>
<td>
<p>stopping criteria of the search algorithm.</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_mit">MIT</code></td>
<td>
<p>max number of iterations of the search algorithm.</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_c_max">C_MAX</code></td>
<td>
<p>max value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_c_min">C_min</code></td>
<td>
<p>min value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_e_max">E_MAX</code></td>
<td>
<p>max value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_e_min">E_min</code></td>
<td>
<p>min value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_d_max">D_MAX</code></td>
<td>
<p>max value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_d_min">D_min</code></td>
<td>
<p>min value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_p_max">P_MAX</code></td>
<td>
<p>max value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_p_min">P_min</code></td>
<td>
<p>min value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_i_0">I_0</code></td>
<td>
<p>has to be 0 or 1. Defaults to 0</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_i_1">I_1</code></td>
<td>
<p>has to be 0 or 1. Defaults to 1</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_i_2">I_2</code></td>
<td>
<p>has to be 0, 1, 2, or 3. Defaults to 2</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_i_3">I_3</code></td>
<td>
<p>has to be 0, 1, 2, or 3. Defaults to 3</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_z">z</code></td>
<td>
<p>dimension of the parameter subspace for which the optimization process will take place. Defaults to 2</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_minimization">Minimization</code></td>
<td>
<p>1/0. If Minimization is 0, then no minimization is performed.</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_verbose">Verbose</code></td>
<td>
<p>more/less (1/0) information about the optimization algorithm will be printed out.</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_mv_flag">MV_FLAG</code></td>
<td>
<p>missing Value Flag (to specify sites and times where no sample exists)</p>
</td></tr>
<tr><td><code id="mss_cedp_+3A_perfectdetectability">PerfectDetectability</code></td>
<td>
<p>TRUE means 'Perfect Detectability'. Of course, FALSE means 'Imperfect Detectability'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is a data frame containing presence data per time (in cols).  Different factors (for instance,
OTU, location, etc) can slide the initial data frame accordingly. Model parameters will be estimated
for each of these groups independently that correspond to each level of the chosen factor. If Minimization
is 0, then no maximum likelihood estimation is performed and only the likelihood evaluation at the input model
parameter values is returned. Searches are based on the Nelder-Mead simplex method, but conducted in a
bounded parameter space which means that in case a neg loglikelihood (NLL) evaluation is called out from these
boundaries, the returned value for this NLL evaluation is artifically given as the maximum number the machine can
hold. Each group is named by a short-length-character label (ideally, 3 or 4 characters). All labels should
have the same character length to fulfill memmory alignment requirements of the shared object called by
.C(...) function. I_0, I_1, I_2, I_3 are model parameter keys. They are used to define a 4D-vector (Index). The
search will take place on the full parameter space defined by model parameters (I_0, I_1) if PefectDetectability
is <code>TRUE</code> or, alternatively, defined by (I_0, I_1, I_2, I_3) if PerfectDetectability is <code>FALSE</code>.
Model parameter keys correspond to colonization (0), extinction (1), detectability (2), and P_0 (3) model
parameters. For instance, if (I_0, I_1) is (1, 0), the search will take place whitin the paremeter space defined
by extinction, as the first axis, and colonization, as the second.
</p>


<h3>Value</h3>

<p>The function generates, as an output, either a 3-column matrix (Colonization, Extinction, Negative LogLikelihood) or
5-column matrix (Colonization, Extinction, Detectability, P_0, Negative LogLikelihood), depending
on the value of the input parameter PerfectDetectability (either <code>TRUE</code> or <code>FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Data &lt;- lakshadweepPLUS[[1]]
Guild_Tag = c("Alg", "Cor", "Mac", "Mic", "Omn", "Pis", "Zoo")
Time &lt;- as.vector(c(2000, 2000, 2001, 2001, 2001, 2001, 2002, 2002, 2002,
2002, 2003, 2003, 2003, 2003, 2010, 2010, 2011, 2011, 2011, 2011, 2012,
2012, 2012, 2012, 2013, 2013, 2013, 2013))
R &lt;- mss_cedp(Data, Time, Factor = 3, Tags = Guild_Tag,
PerfectDetectability = FALSE, z = 4)
Guild_Tag = c("Agt", "Kad", "Kvt")
R &lt;- mss_cedp(Data, Time, Factor = 2, Tags = Guild_Tag,
PerfectDetectability = FALSE, z = 4)


</code></pre>

<hr>
<h2 id='r_squared'>Model prediction error</h2><span id='topic+r_squared'></span><span id='topic+null_model'></span><span id='topic+simulated_model'></span>

<h3>Description</h3>

<p><code>r_squared</code> evaluates <code class="reqn">R^2</code> for our simulated dynamics. <br />
<code>simulated_model</code> Error of the stochastic model. <br /> <code>null_model</code>
Error of the null model. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_squared(observed, simulated, sp)

null_model(observed, sp)

simulated_model(observed, simulated)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_squared_+3A_observed">observed</code></td>
<td>
<p>A vector with the actual observed species richness.</p>
</td></tr>
<tr><td><code id="r_squared_+3A_simulated">simulated</code></td>
<td>
<p>A vector with the simulated species richness.</p>
</td></tr>
<tr><td><code id="r_squared_+3A_sp">sp</code></td>
<td>
<p>Number of species in the species pool.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The importance of assessing how well a model predicts new data is paramount.
The most used metric to assess this model error is <code class="reqn">R^2</code>.  <code class="reqn">R^2</code> is
always refered to a null model and is defined as follows: </p>
<p style="text-align: center;"><code class="reqn">R^{2} = 1 -
\epsilon^{2} / \epsilon^{2}_0</code>
</p>
<p> where
<code class="reqn">\epsilon^2</code> is the prediction error defined as the mean squared
deviation of model predictions from actual observations, and
<code class="reqn">\epsilon^2_0</code> is a null model error, in example, an average of squared
deviations evaluated with a null model.
</p>
<p>Our null model corresponds with a random species model with no time
correlations, in which we draw randomly from a uniform distribution a number
of species between 0 and number of species observed in the species pool. The
expectation of the sum of squared errors under the null model is evaluated
analytically in Alonso et al. (2015).
</p>


<h3>Value</h3>

<p><code>r_squared</code>  gives the value of <code class="reqn">R^2</code> for the predictions of
the model. <br /> <br /> <code>null_model</code> gives the average of squared
deviations of the null model predictions from actual observations,
<code class="reqn">\epsilon^2_0</code>. <br /> <br /> <code>simulated_model</code> gives the average of
squared deviations of the model predictions from the actual observations,
<code class="reqn">\epsilon^2</code>.
</p>


<h3>Note</h3>

<p>The value of <code class="reqn">R^2</code> depends critically on the definition of the null
model. Note that different definitions of the null model will lead to
different values of <code class="reqn">R^2</code>.
</p>


<h3>References</h3>

<p>Alonso, D., Pinyol-Gallemi, A., Alcoverro T. and Arthur, R..
(2015) Fish community reassembly after a coral mass mortality: higher
trophic groups are subject to increased rates of extinction. <em>Ecology
Letters</em>, <b>18</b>, 451&ndash;461.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idaho.sim &lt;- data_generation(as.data.frame(c(rep(0, 163),
rep(1, 57))), 1, matrix(c(0.162599, 0.111252), ncol = 2), 250, 20)
idaho.me &lt;- c(57, apply(idaho.sim, 1, quantile, 0.5))
r_squared(colSums(idaho[[1]][,3:23]), idaho.me, 220)

null_model(colSums(idaho[[1]][,3:23]), 220)

simulated_model(colSums(idaho[[1]][,3:23]), idaho.me)

</code></pre>

<hr>
<h2 id='rates_calculator'>Colonization and extinction rates calculator for expressions.</h2><span id='topic+rates_calculator'></span>

<h3>Description</h3>

<p><code>rates_calculator</code> Calculate colonization and extinction rates depending
of their expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rates_calculator(params, c_expression, e_expression, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rates_calculator_+3A_params">params</code></td>
<td>
<p>A vector with priors of the parameters in c_expression and e_expression.</p>
</td></tr>
<tr><td><code id="rates_calculator_+3A_c_expression">c_expression</code></td>
<td>
<p>Expression for colonization.</p>
</td></tr>
<tr><td><code id="rates_calculator_+3A_e_expression">e_expression</code></td>
<td>
<p>Expression for extinction.</p>
</td></tr>
<tr><td><code id="rates_calculator_+3A_t">t</code></td>
<td>
<p>Number of colonization and extinction pairs required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the colonization and extinction rates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+all_environmental_fit">all_environmental_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rates_calculator(c(-0.00497925, -0.01729602, 0.19006501,
0.93486956), expression(params[1] * idaho[[2]]$TOTAL.ppt[i] + params[3]),
expression(params[2] * idaho[[2]]$ANNUAL.temp[i] + params[4]), 21)

</code></pre>

<hr>
<h2 id='regular_sampling_scheme'>c/e rates for a regular sampling scheme</h2><span id='topic+regular_sampling_scheme'></span><span id='topic+NLL_rss'></span>

<h3>Description</h3>

<p><code>regular_sampling_scheme</code> estimates colonization and extinction rates
for a community or groups in a community. <br /> <code>NLL_rss</code> returns the Negative
Log-Likelihood of a pair of colonization and extinction rates for a regular
sampling scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regular_sampling_scheme(
  x,
  vector,
  level = NULL,
  n = NULL,
  step = NULL,
  CI = FALSE
)

NLL_rss(x, vector, c, e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regular_sampling_scheme_+3A_x">x</code></td>
<td>
<p>A single dataset.</p>
</td></tr>
<tr><td><code id="regular_sampling_scheme_+3A_vector">vector</code></td>
<td>
<p>A vector indicating the columns with presence-absence data.</p>
</td></tr>
<tr><td><code id="regular_sampling_scheme_+3A_level">level</code></td>
<td>
<p>The name of the column that contain groups used to subset them
and calculate their colonization and extinction rates.</p>
</td></tr>
<tr><td><code id="regular_sampling_scheme_+3A_n">n</code></td>
<td>
<p>Minimal number of rows for each group.</p>
</td></tr>
<tr><td><code id="regular_sampling_scheme_+3A_step">step</code></td>
<td>
<p>Accuracy to calculate the c_e pairs with.</p>
</td></tr>
<tr><td><code id="regular_sampling_scheme_+3A_ci">CI</code></td>
<td>
<p>Logical. Should confidence intervals be returned?</p>
</td></tr>
<tr><td><code id="regular_sampling_scheme_+3A_c">c</code></td>
<td>
<p>A colonization rate.</p>
</td></tr>
<tr><td><code id="regular_sampling_scheme_+3A_e">e</code></td>
<td>
<p>An extinction rate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence intervals are calculated with a binary search seeded
with the hessian of the estimated rates.
</p>


<h3>Value</h3>

<p><code>regular_sampling_scheme</code> returns a dataframe with colonization and extinction rates along with their
lower and upper confidence intervals (optional), for each group if
specified, and its number of rows and NLL.
<code>NLL_rss</code> gives the NLL for a dataframe given a specific c and e.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irregular_single_dataset">irregular_single_dataset</a></code>,
<code><a href="#topic+irregular_multiple_datasets">irregular_multiple_datasets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>regular_sampling_scheme(alonso15[[1]], 3:6)
regular_sampling_scheme(alonso15[[1]], 3:6, "Guild", n = 5)
regular_sampling_scheme(alonso15[[1]], 3:6, "Guild", n = 5, CI = TRUE)
NLL_rss(alonso15[[1]], 3:6, 0.52, 0.39)
</code></pre>

<hr>
<h2 id='simberloff'>Simberloff and Wilson original defaunation experiment data</h2><span id='topic+simberloff'></span>

<h3>Description</h3>

<p>A list of datasets containing the presence-absence data gathered originally
by Simberloff and Wilson in their defaunation experiment of six mangrove
islands in the Florida Keys.
</p>


<h3>Format</h3>

<p>A list with 6 dataframes, each corresponding to the survey of a
different island. Dataframes have in columns: </p>
 <dl>
<dt>Taxa</dt><dd><p>Taxa
considered</p>
</dd> <dt>PRE</dt><dd><p>Presence-absence before the defaunation process</p>
</dd>
<dt>Integers (e.g. 21, 40, 58...)</dt><dd><p>Several columns with presence-absence
data for the day specified</p>
</dd> <dt>Tax. Unit 1</dt><dd><p>Highest taxonomical unit
considered</p>
</dd> <dt>Tax. Unit 2</dt><dd><p>Second highest taxonomical unit considered</p>
</dd>
<dt>Genera</dt><dd><p>Genera of the identified taxon</p>
</dd> <dt>Island</dt><dd><p>Island of
identification of the taxon</p>
</dd> </dl>



<h3>Details</h3>

<p>The defaunation experiment of Simberloff and Wilson was aimed to test
experimentally the Theory of Island Biogeography.  The approach sought was
eliminating the fauna of several islands and following the recolonization
proccess.
</p>
<p>After some trials,  six red mangrove islets of Florida Bay were chosen for
the task.  These islets had to be stripped of all arthropofauna without
harming the vegetation and then all the colonists were identified.  The
result of these defaunation experiments supported the existence of species
equilibria and were consistent with the basic MacArthur-Wilson equilibrium
model.
</p>


<h3>Note</h3>

<p>The shaded entries in the original dataset, for taxa inferred to be
present from other evidence rather than direct observation, are considered
as present in these datasets.
</p>


<h3>Source</h3>

<p>Simberloff, D. S., &amp; Wilson, E. O.. (1969). Experimental Zoogeography
of Islands: The Colonization of Empty Islands. <em>Ecology</em>,
<b>50(2)</b>, 278&ndash;296. <a href="https://doi.org/10.2307/1934856">doi:10.2307/1934856</a>
</p>


<h3>References</h3>

<p>Wilson, E. O.. (2010). Island Biogeography in the 1960s: THEORY
AND EXPERIMENT. In J. B. Losos and R. E. Ricklefs (Eds.), <em>The Theory
of Island Biogeography Revisited</em> (pp. 1&ndash;12). Princeton University Press.
<br /> <br /> Simberloff, D. S., and Wilson, E. O.. (1969). Experimental
Zoogeography of Islands: The Colonization of Empty Islands. <em>Ecology</em>,
<b>50(2)</b>, 278&ndash;296. <a href="https://doi.org/10.2307/1934856">doi:10.2307/1934856</a> <br /> <br />
Wilson, E. O., and Simberloff, D. S.. (1969). Experimental Zoogeography of
Islands: Defaunation and Monitoring Techniques. <em>Ecology</em>,
<b>50(2)</b>, 267&ndash;278. <a href="https://doi.org/10.2307/1934855">doi:10.2307/1934855</a> <br /> <br />
Simberloff, D. S.. (1969). Experimental Zoogeography of Islands: A Model
for Insular Colonization. <em>Ecology</em>, <b>50(2)</b>, 296&ndash;314.
<a href="https://doi.org/10.2307/1934857">doi:10.2307/1934857</a>
</p>

<hr>
<h2 id='sss_cedp'>MacKenzie etal (2003) likelihood approach for estimating colonization/extinction
parameters (with imperfect detectability)</h2><span id='topic+sss_cedp'></span>

<h3>Description</h3>

<p><code>sss_cedp</code> conducts a maximum likelihood estimation of model parameters
(Colonization, Extinction, Detectability, and Phi_Time_0) of MacKenzie et al
(2003) colonization-extinction model. This function is an alternative to
<code>mss_cedp</code> that takes a different input (a 2D array), and requires the same
sampling structure for all input data matrix rows, this is, no missing data
defining a heterogeneous sampling structure across rows are allowed. As an advantage,
it may run faster than <code>mss_cedp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sss_cedp(
  Data,
  Time,
  Transects,
  Colonization = 0.1,
  Extinction = 0.1,
  Detectability = 0.99,
  Phi_Time_0 = 0.5,
  Tol = 1e-06,
  MIT = 100,
  C_MAX = 2,
  C_min = 0,
  E_MAX = 2,
  E_min = 0,
  D_MAX = 0.999,
  D_min = 0.001,
  P_MAX = 0.999,
  P_min = 0.001,
  I_0 = 0,
  I_1 = 1,
  I_2 = 2,
  I_3 = 3,
  z = 4,
  Verbose = 0,
  Minimization = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sss_cedp_+3A_data">Data</code></td>
<td>
<p>S x N matrix containing presence data per transect (in cols):</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_time">Time</code></td>
<td>
<p>an array of length n containing increasing sampling times (without repetitions)</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_transects">Transects</code></td>
<td>
<p>an integer array of length n containing the number of transects per sampling time</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_colonization">Colonization</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_extinction">Extinction</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_detectability">Detectability</code></td>
<td>
<p>guess value to initiate search / param
eter value</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_phi_time_0">Phi_Time_0</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_tol">Tol</code></td>
<td>
<p>Stopping criteria of the search algorithm</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_mit">MIT</code></td>
<td>
<p>max number of iterations of the search algorithm</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_c_max">C_MAX</code></td>
<td>
<p>max value of colonization values</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_c_min">C_min</code></td>
<td>
<p>min value of colonization values</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_e_max">E_MAX</code></td>
<td>
<p>max value of extinction values</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_e_min">E_min</code></td>
<td>
<p>min value of extinction values</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_d_max">D_MAX</code></td>
<td>
<p>max value of detectability values</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_d_min">D_min</code></td>
<td>
<p>min value of detectability values</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_p_max">P_MAX</code></td>
<td>
<p>max value for the initial presence probability on the site</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_p_min">P_min</code></td>
<td>
<p>min value for the initial presence probability on the site</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_i_0">I_0</code></td>
<td>
<p>parameter index of 1st parameter</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_i_1">I_1</code></td>
<td>
<p>parameter index of 2nd parameter</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_i_2">I_2</code></td>
<td>
<p>parameter index of 3rd parameter</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_i_3">I_3</code></td>
<td>
<p>parameter index of 4th parameter</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_z">z</code></td>
<td>
<p>dimension of the parameter subspace</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_verbose">Verbose</code></td>
<td>
<p>more/less (1/0) output information</p>
</td></tr>
<tr><td><code id="sss_cedp_+3A_minimization">Minimization</code></td>
<td>
<p>TRUE/FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximum likelihood parameter estimation is conducted through bounded searches.
This is the reason why the minimum and maximum values for each axis should be given
as input arguments. The optimization procedure is the simplex method. A bounded
parameter space implies that in case a neg loglikelihood (NLL) evaluation is
required outside from these boundaries, the returned value for this NLL evaluation
is artifically given as the maximum number the machine can hold.
The array Parameters (I_0, I_1, I_2, I_3) has to be a permutation of (0, 1, 3, 4).
This parameter indeces along with the imput parameter 'z' are used to define a
subparameter space where the search will be conducted. If z = 2, then the search
will take place on the plane defined by model parameters (I_0, I_1). These indeces
are model parameter keys: colonization (0), extinction (1), detectability (2), and
Phi_Time_0 (3). For instance, if (I_0, I_1, I_2, I_3) is (2, 3, 1, 0), and z = 2,
then the search will take place whithin the subparemeter space defined by the
detection probability (Detectability) and the probability of presence at time 0
(Phi_Time_0). If Minimization is TRUE (default value), then the whole mle is
conducted. If FALSE, the function only return the NLL value at the input model
parameter values. Likelihood evaluations are exact provided the number of 'absences'
corresponding to either true absences or undetected presences in the input data
matrix is not to high.
</p>


<h3>Value</h3>

<p>A list with five components (Colonization, Extinction, Detectability,
P_0, and Negative Log-Likelihood).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Data1 &lt;- lakshadweep[[1]]
Name_of_Factors &lt;- c("Species","Atoll","Guild")
Factors &lt;- Filter(is.factor, Data1)
No_of_Factors &lt;- length(Factors[1,])
n &lt;- No_of_Factors + 1
D1 &lt;- as.matrix(Data1[1:nrow(Data1),n:ncol(Data1)])
Time &lt;- as.double(D1[1,])
P1 &lt;- as.matrix(D1[2:nrow(D1),1:ncol(D1)])
# Dealing with time.
Time_Vector &lt;- as.numeric(names(table(Time)))
Transects   &lt;- as.numeric((table(Time)))
R1 &lt;- sss_cedp(P1, Time_Vector, Transects,
                       Colonization=0.5, Extinction=0.5, Detectability=0.5,
                       Phi_Time_0=0.5,
                       Tol=1.0e-8, Verbose = 1)

</code></pre>

<hr>
<h2 id='upgma_model_selection'>Model selection function based on a upgma grouping algorithm</h2><span id='topic+upgma_model_selection'></span>

<h3>Description</h3>

<p><code>upgma_model_selection</code> function conducts a model selection procedure intended to find an optimal
partition that mimimize AIC values. Maximum likelihood estimation of model parameters
(Colonization, Extinction) or (Colonization, Extinction, Detectability, P_0) is performed
assuming either perfect detectability or imperfect detectability, respectively. In the latter case,
the input data frame should contain multiple transects per sampling time. This function can handle
missing data defining a heterogeneous sampling structure across the rows of the input data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upgma_model_selection(
  Data,
  Time,
  Factor,
  Tags,
  Colonization = 1,
  Extinction = 1,
  Detectability_Value = 0.5,
  Phi_Time_0_Value = 0.5,
  Tol = 1e-08,
  MIT = 100,
  C_MAX = 10,
  C_min = 0,
  E_MAX = 10,
  E_min = 0,
  D_MAX = 0.99,
  D_min = 0,
  P_MAX = 0.99,
  P_min = 0.01,
  I_0 = 0,
  I_1 = 1,
  I_2 = 2,
  I_3 = 3,
  z = 2,
  Verbose = 0,
  MV_FLAG = 0.1,
  PerfectDetectability = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upgma_model_selection_+3A_data">Data</code></td>
<td>
<p>data frame containing presence data per time (in cols) and sites (in rows)</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_time">Time</code></td>
<td>
<p>an array of length n containing increasing sampling times</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_factor">Factor</code></td>
<td>
<p>column number containing the 'data frame' factor used to split total data into level-based groups</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_tags">Tags</code></td>
<td>
<p>array of factor level names: name[i] is the level tag (short name) for the i-th level.</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_colonization">Colonization</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_extinction">Extinction</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_detectability_value">Detectability_Value</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_phi_time_0_value">Phi_Time_0_Value</code></td>
<td>
<p>guess value to initiate search / parameter value</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_tol">Tol</code></td>
<td>
<p>stopping criteria of the search algorithm.</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_mit">MIT</code></td>
<td>
<p>max number of iterations of the search algorithm.</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_c_max">C_MAX</code></td>
<td>
<p>max value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_c_min">C_min</code></td>
<td>
<p>min value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_e_max">E_MAX</code></td>
<td>
<p>max value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_e_min">E_min</code></td>
<td>
<p>min value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_d_max">D_MAX</code></td>
<td>
<p>max value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_d_min">D_min</code></td>
<td>
<p>min value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_p_max">P_MAX</code></td>
<td>
<p>max value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_p_min">P_min</code></td>
<td>
<p>min value for the possible range of colonization values</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_i_0">I_0</code></td>
<td>
<p>has to be 0, 1, 2, or 3. Defaults to 0</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_i_1">I_1</code></td>
<td>
<p>has to be 0, 1, 2, or 3. Defaults to 1</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_i_2">I_2</code></td>
<td>
<p>has to be 0, 1, 2, or 3. Defaults to 2</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_i_3">I_3</code></td>
<td>
<p>has to be 0, 1, 2, or 3. Defaults to 3</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_z">z</code></td>
<td>
<p>dimension of the parameter subspace for which the optimization process will take place. Default is 2</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_verbose">Verbose</code></td>
<td>
<p>more/less (1/0) information about the optimization algorithm will be printed out.</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_mv_flag">MV_FLAG</code></td>
<td>
<p>missing value flag (to specify sites and times where no sample exists)</p>
</td></tr>
<tr><td><code id="upgma_model_selection_+3A_perfectdetectability">PerfectDetectability</code></td>
<td>
<p>TRUE means 'Perfect Detectability'. Of course, FALSE means 'Imperfect Detectability'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output matrix contains a row for the S different binary partitions of the set of S groups.
Searches are conducted using Nelder-Mead simplex method in a bounded parameter space which means that in case a
neg loglikelihood (NLL) evaluation is called out from these boundaries, the returned value for this NLL
evaluation is artifically given as the maximum number the machine can hold. The input is a data frame
containing presence data per time (in cols) and sites (in rows). Different factors (for instance, OTU,
location, etc) can slide the initial data frame in their different levels, accordingly. Each initial group
(usually, species, OUTs, factors, ...) is named by a short-length-character label (ideally, 3 or 4 characters).
The length of Tags array should match the number of levels in which the given factor is subdivided. All labels
should have the same character length to fulfill memmory alignment requriement of the shared object called by
.C(...) function. I_0, I_1, I_2, and I_3 are model parameter keys. They are used to define a 4D-vector (Index).
The model parameter keys correspond to the colonization (0), extinction (1), detectability (2), and Phi_0 (3) model
parameters in case detectability is imperfect or, alternatively, only colonization (0) and extinction (1)
in case detectability is perfect. For instance, if (I_0, I_1) is (1, 0), searches will take place within
the paremeter space defined by extinction, as the first axis, and colonization, as the second.
</p>


<h3>Value</h3>

<p>The function generates, as an output, a Sx6 matrix with the following 6 columns (for the S different partitions):
(No of Model Parameters, NLL, AIC, AIC_c, AIC_d, AIC_w) which compares all upgma-generarated
partitions. It also produces .tex code to generate a table of the best grouping and a summary of the model selection process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Data &lt;- lakshadweepPLUS[[1]]
Guild_Tag = c("Alg", "Cor", "Mac", "Mic", "Omn", "Pis", "Zoo")
Time &lt;- as.vector(c(2000, 2000, 2001, 2001, 2001, 2001, 2002, 2002, 2002,
2002, 2003, 2003, 2003, 2003, 2010, 2010, 2011, 2011, 2011, 2011, 2012,
2012, 2012, 2012, 2013, 2013, 2013, 2013))
R &lt;- upgma_model_selection(Data, Time, Factor = 3, Tags = Guild_Tag,
PerfectDetectability = FALSE, z = 4)
Guild_Tag = c("Agt", "Kad", "Kvt")
R &lt;- upgma_model_selection(Data, Time, Factor = 2, Tags = Guild_Tag,
PerfectDetectability = FALSE, z = 4)

## End(Not run)

</code></pre>

<hr>
<h2 id='weight_of_evidence'>Weight of evidence</h2><span id='topic+weight_of_evidence'></span>

<h3>Description</h3>

<p><code>weight_of_evidence</code> calculates the weight of evidence of a set of
nested models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_of_evidence(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weight_of_evidence_+3A_data">data</code></td>
<td>
<p>A dataframe with the names of the models in the first column and
their AIC values in the second column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the weight of evidence in favor of model i being the actual
Kullback-Leibler best model given a set of models R for your data.
</p>
<p style="text-align: center;"><code class="reqn">w_i = exp( - 1/2 * \Delta_i) / \Sigma exp( - 1/2 * \Delta_r)</code>
</p>

<p style="text-align: center;"><code class="reqn">r = 1, R</code>
</p>



<h3>Value</h3>

<p>A dataframe with the names of the analysed models, their AIC
differences with respect to the best model and the w_i of each one.
</p>


<h3>References</h3>

<p>K. P.  Burnham, D. R. Anderson. <em>Model selection and
multimodel inference: a practical information-theoretic approach</em> (New
York:Springer, ed. 2, 2002).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+akaikeic">akaikeic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>models &lt;- c("Best_3k", "Best_4k", "Best_5k", "Best_6k", "Best_7k",
  "Best_8k", "Best_9k")

  aks &lt;- c(2977.852, 2968.568, 2957.384, 2952.618,
  2949.128, 2947.038, 2943.480)

  weight_of_evidence(cbind(models, aks))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
