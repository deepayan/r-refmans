<!DOCTYPE html><html lang="en"><head><title>Help for package OLCPM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OLCPM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cv.table'><p>cv.table</p></a></li>
<li><a href='#gen.data'><p>generate data</p></a></li>
<li><a href='#gen.psi.tau.flat'><p>calculate eigenvalue series by &ldquo;flat&rdquo; method</p></a></li>
<li><a href='#gen.psi.tau.proj'><p>calculate eigenvalue series by projected method</p></a></li>
<li><a href='#getcv'><p>calculate critical values</p></a></li>
<li><a href='#impute.linear'><p>impute missing entries by linear interpolation</p></a></li>
<li><a href='#ITP_noproj'><p>testing the number of row factors- without projection</p></a></li>
<li><a href='#ITP_proj'><p>testing the number of row factors- with projection</p></a></li>
<li><a href='#kpe'><p>determine factor number - projected</p></a></li>
<li><a href='#KSTP'><p>determine row factor number - test</p></a></li>
<li><a href='#moment.determine'><p>determine the moment (largest) of the data samples</p></a></li>
<li><a href='#moment.test'><p>test whether the k-th moment exists</p></a></li>
<li><a href='#outlier.remove'><p>remove outliers</p></a></li>
<li><a href='#test.multiple.robust'><p>robust test of multiple change point for matrix-valued online time series</p></a></li>
<li><a href='#test.once.flat'><p>test single change point for matrix-valued online time series -&rdquo;flat&rdquo;</p>
version</a></li>
<li><a href='#test.once.flat.robust'><p>robust test of single change point for matrix-valued online time series</p>
-&quot;flat&quot; version</a></li>
<li><a href='#test.once.proj'><p>test single change point for matrix-valued online time series-projected</p>
version</a></li>
<li><a href='#test.once.proj.robust'><p>robust test of single change point for matrix-valued online time</p>
series-projected version</a></li>
<li><a href='#test.once.psi'><p>test single change point for matrix-valued online data given rolling</p>
eigenvalue series</a></li>
<li><a href='#test.once.psi.robust'><p>robust test of single change point for matrix-valued online data given</p>
rolling eigenvalue series</a></li>
<li><a href='#var.exp'><p>explanatory power of factors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Online Change Point Detection for Matrix-Valued Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Yong He [aut],
  Xinbing Kong [aut],
  Lorenzo Trapani [aut],
  Long Yu [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Long Yu &lt;fduyulong@163.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide two algorithms for monitoring change points with online matrix-valued time series, under the assumption of a two-way factor structure. The algorithms are based on different calculations of the second moment matrices. One is based on stacking the columns of matrix observations, while another is by a more delicate projected approach. A well-known fact is that, in the presence of a change point, a factor model can be rewritten as a model with a larger number of common factors. In turn, this entails that, in the presence of a change point, the number of spiked eigenvalues in the second moment matrix of the data increases. Based on this, we propose two families of procedures - one based on the fluctuations of partial sums, and one based on extreme value theory - to monitor whether the first non-spiked eigenvalue diverges after a point in time in the monitoring horizon, thereby indicating the presence of a change point. This package also provides some simple functions for detecting and removing outliers, imputing missing entries and testing moments. See more details in He et al. (2021)&lt;<a href="https://doi.org/10.48550%2FarXiv.2112.13479">doi:10.48550/arXiv.2112.13479</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>LaplacesDemon, RSpectra</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-29 01:45:53 UTC; hey12</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-30 07:10:17 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
</table>
<hr>
<h2 id='cv.table'>cv.table</h2><span id='topic+cv.table'></span>

<h3>Description</h3>

<p>A data matrix containing approximated critical values for the scaled
Wiener process. A supplement to Table 1 in Horvath et al. (2004). The
rows are for different gamma on a grid of 50 points in [0,0.49) with step
size equal to 0.01, while the columns are for different alpha on a grid
of 50 points in [0.001,0.5) with step size equal to 0.001. All the values are
based on 100000 replications of simulated Wiener process on an equal grid of
20000 points in [0,1], thus can be slightly different from those in Horvath et al. (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.table
</code></pre>


<h3>Format</h3>

<p>A matrix of size 50*500.
</p>

<dl>
<dt>gamma</dt><dd><p>the scaling parameter</p>
</dd>
<dt>alpha</dt><dd><p>significance level (1-alpha)-th quantile</p>
</dd>
</dl>



<h3>Details</h3>

<p>#' @references Horvath L, Huskova M, Kokoszka P, et al (2004). Monitoring
changes in linear models. <em>Journal of statistical Planning and
Inference</em>, 126(1): 225-251.
</p>

<hr>
<h2 id='gen.data'>generate data</h2><span id='topic+gen.data'></span>

<h3>Description</h3>

<p>This function generates matrix-valued time series under a two-way factor
structure with/without a change point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.data(
  Sample_T,
  p1,
  p2,
  k1,
  k2,
  tau = 0.5,
  change = 0,
  pp = 0.3,
  a = 0,
  cc = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.data_+3A_sample_t">Sample_T</code></td>
<td>
<p>positive integer indicating the length of series.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_p1">p1</code></td>
<td>
<p>positive integer indicating the row dimension.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_p2">p2</code></td>
<td>
<p>positive integer indicating the column dimension.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_k1">k1</code></td>
<td>
<p>positive integer indicating the number of row factors.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_k2">k2</code></td>
<td>
<p>positive integer indicating the number of column factors.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_tau">tau</code></td>
<td>
<p>a real number in <code class="reqn">(0,1)</code>, indicating the location of change
point, i.e., (<code class="reqn">\tau T</code>).</p>
</td></tr>
<tr><td><code id="gen.data_+3A_change">change</code></td>
<td>
<p>the type of change, taking 0 for no change point, taking 1 for
the case that the loading matrix <b>R</b> changes, taking other values for the case
that a new row factor occurs.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_pp">pp</code></td>
<td>
<p>a number in <code class="reqn">(0,1]</code>, indicating the magnitude of the break.
When <code class="reqn">change=1</code>, <em>pp</em> is the proportion of entries in <b>R</b> that changes;
when <em>change</em> is not equal to 0 or 1, <em>pp</em> is the proportion of non-zero entries in the new factor
loading.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_a">a</code></td>
<td>
<p>a number in <code class="reqn">[0,min(p_1,p_2))</code>, indicating the
cross-sectional correlations of the idiosyncratic errors.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_cc">cc</code></td>
<td>
<p>a number in <code class="reqn">[0,1)</code>, indicating the AR(1) coefficient of the
factor and error processes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper He et al. (2021).
</p>


<h3>Value</h3>

<p>a <code class="reqn">T\times p1 \times p2</code> array.
</p>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point
detection for matrix-valued time series with latent two-way factor
structure. <em>arXiv preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set parameters
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20


# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.3)
print("the dimension of Y is:")
print(dim(Y))

</code></pre>

<hr>
<h2 id='gen.psi.tau.flat'>calculate eigenvalue series by &ldquo;flat&rdquo; method</h2><span id='topic+gen.psi.tau.flat'></span>

<h3>Description</h3>

<p>This function calculates the rolling eigenvalue series for the monitoring
process, based on the &ldquo;flat&rdquo; version of sample covanriance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.psi.tau.flat(
  Y,
  k,
  m = ceiling(max(20, (dim(Y)[3])^(r/(r + 2)))),
  delta,
  r = 8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.psi.tau.flat_+3A_y">Y</code></td>
<td>
<p>the observed <code class="reqn">T\times p1\times p2</code> array. <code class="reqn">T</code> is the
sample size, <code class="reqn">p1</code> and <code class="reqn">p2</code> are the row and column dimensions,
respectively.</p>
</td></tr>
<tr><td><code id="gen.psi.tau.flat_+3A_k">k</code></td>
<td>
<p>a positive integer determining which eigenvalue to monitor.
<code class="reqn">k=1</code> for the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="gen.psi.tau.flat_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the
rolling window.</p>
</td></tr>
<tr><td><code id="gen.psi.tau.flat_+3A_delta">delta</code></td>
<td>
<p>a number in <code class="reqn">(0,1)</code> indicating the rescaling parameter for
the eigenvalue. The default approach to calculate delta is in the paper He
et al. (2021).</p>
</td></tr>
<tr><td><code id="gen.psi.tau.flat_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the order of the transformation
function <code class="reqn">g(x)=|x|^r</code>. Motivated by the paper, <code class="reqn">r</code> should be chosen
according to the moments of the data; see more details in He et al. (2021).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rolling eigenvalue series will start at the stage <code class="reqn">m+1</code>, with length
<code class="reqn">T-m</code>.
</p>


<h3>Value</h3>

<p>a <code class="reqn">(T-m)\times 3</code> matrix, whose three columns are the original,
rescaled, and transformed eigenvalue series, respectively.
</p>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point
detection for matrix-valued time series with latent two-way factor
structure. <em>arXiv preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate data
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20
kmax=8
r=8
m=p2

# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.3)

# calculate delta
temp=log(p1)/log(m*p2)
delta=epsilon*(temp&lt;=0.5)+(epsilon+1-1/(2*temp))*(temp&gt;0.5)

# calculate psi.tau
psi2=gen.psi.tau.flat(Y,k1+1,m,delta,r)
print(psi2)

</code></pre>

<hr>
<h2 id='gen.psi.tau.proj'>calculate eigenvalue series by projected method</h2><span id='topic+gen.psi.tau.proj'></span>

<h3>Description</h3>

<p>This function calculates the rolling eigenvalue series for the monitoring
process, based on the projected version of sample covanriance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.psi.tau.proj(
  Y,
  k,
  m = ceiling(max(20, (dim(Y)[3])^(r/(r + 2)))),
  delta,
  r = 8,
  kmax = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.psi.tau.proj_+3A_y">Y</code></td>
<td>
<p>the observed <code class="reqn">T\times p1\times p2</code> array. <code class="reqn">T</code> is the
sample size, <code class="reqn">p1</code> and <code class="reqn">p2</code> are the row and column dimensions,
respectively.</p>
</td></tr>
<tr><td><code id="gen.psi.tau.proj_+3A_k">k</code></td>
<td>
<p>a positive integer determining which eigenvalue to monitor.
<code class="reqn">k=1</code> for the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="gen.psi.tau.proj_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the
rolling windom.</p>
</td></tr>
<tr><td><code id="gen.psi.tau.proj_+3A_delta">delta</code></td>
<td>
<p>a number in <code class="reqn">(0,1)</code> indicating the rescaling parameter for
the eigenvalue. The default approach to calcualte delta is in the paper He
et al. (2021).</p>
</td></tr>
<tr><td><code id="gen.psi.tau.proj_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the order of the transformation
function <code class="reqn">g(x)=|x|^r</code>. Motivated by the paper, <code class="reqn">r</code> should be chosen
according to the moments of the data; see more details in He et al. (2021).</p>
</td></tr>
<tr><td><code id="gen.psi.tau.proj_+3A_kmax">kmax</code></td>
<td>
<p>a positive integer indicating the column number of the
projection matrix, should be larger than 0 but smaller than <code class="reqn">p2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rolling eigenvalue series will start at the stage <code class="reqn">m+1</code>, with length
<code class="reqn">T-m</code>.
</p>


<h3>Value</h3>

<p>a <code class="reqn">(T-m)\times 3</code> matrix, whose three columns are the original,
rescaled, and transformed eigenvalue series, respectively.
</p>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point
detection for matrix-valued time series with latent two-way factor
structure. <em>arXiv preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate data
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20
kmax=8
r=8
m=p2

# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.3)

# calculate delta
temp=log(p1)/log(m*p2)
delta=epsilon*(temp&lt;=0.5)+(epsilon+1-1/(2*temp))*(temp&gt;0.5)

# calculate psi.tau
psi2=gen.psi.tau.proj(Y,k1+1,m,delta,r,kmax)
print(psi2)

</code></pre>

<hr>
<h2 id='getcv'>calculate critical values</h2><span id='topic+getcv'></span>

<h3>Description</h3>

<p>This function calculates critical values for the partial-sum and worst-case
statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcv(alpha = 0.05, method = "ps", eta = 0.5, simul = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getcv_+3A_alpha">alpha</code></td>
<td>
<p>a number in <code class="reqn">(0,1)</code>, indicating the significance level of
the test.</p>
</td></tr>
<tr><td><code id="getcv_+3A_method">method</code></td>
<td>
<p>&ldquo;ps&rdquo; for the partial-sum staistic, others for the worst-case
statistic.</p>
</td></tr>
<tr><td><code id="getcv_+3A_eta">eta</code></td>
<td>
<p>a number in <code class="reqn">[0,1]</code>, a scaling parameter required for &quot;ps&quot;
method; see more details in He et al. (2021).</p>
</td></tr>
<tr><td><code id="getcv_+3A_simul">simul</code></td>
<td>
<p>logical value, woking only for &quot;ps&quot; method with
<code class="reqn">\eta</code> not equal to 0.5.  When <em>simul</em> is true, the
function will return approximated critical values based on 50000
replications of simulated Wiener process on a grid of 10000 points in
<code class="reqn">[0,1]</code>. Otherwise, the function first checks for the nearest pair of
<code class="reqn">(\eta,\alpha)</code> in the preserved <em>cv.table</em>, and
then returns the corresponding critical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the partial-sum statistic with <code class="reqn">\eta=0.5</code> or the worst-case
statistic, the critical value is simply <code class="reqn">-log(-log(1-alpha))</code>. For the
partial-sum statistic with <code class="reqn">\eta</code> not equal to 0.5, the critical
value of the scaled Wiener process is approximated by simulated data or from
our preserved table <em>cv.table</em>, covering <code class="reqn">\eta</code> in
<code class="reqn">[0.01,0.49]</code> with step size equal to 0.01 and <code class="reqn">\alpha</code> in
<code class="reqn">[0.001,0.500]</code> with step size equal to 0.001. See more details for the
test statistics in He et al. (2021).
</p>


<h3>Value</h3>

<p>a real number.
</p>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point
detection for matrix-valued time series with latent two-way factor
structure. <em>arXiv preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getcv(0.05,method="ps",eta=0.25)
getcv(0.05,method="ps",eta=0.25,simul=1)
getcv(0.10,method="wc")

## End(Not run)
</code></pre>

<hr>
<h2 id='impute.linear'>impute missing entries by linear interpolation</h2><span id='topic+impute.linear'></span>

<h3>Description</h3>

<p>This function imputes missing entries in a numeric vector by linear
interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.linear(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute.linear_+3A_x">x</code></td>
<td>
<p>a numeric data vector, where <code class="reqn">NA</code> indicates missing
entries. The vector should contain at least two non-missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A missing entry will be imputed by linear interpolation with the two nearest
values before and after it in the vector. When all the values before (after)
it are missing, use the two nearest values after (before) it, instead.
</p>


<h3>Value</h3>

<p>a new numeric vector, with the same size of the
original vector, while all the missing entries have been imputed.
</p>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a=c(NA,NA,3,NA,NA,6,NA,NA)
b=c(1,2,3,4.5,5,NA,6.5,7,NA)

impute.linear(a)
impute.linear(b)

</code></pre>

<hr>
<h2 id='ITP_noproj'>testing the number of row factors- without projection</h2><span id='topic+ITP_noproj'></span>

<h3>Description</h3>

<p>This function tests whether the number of row factors is equal or larger
than a given integer, under a two-way factor model, using flat version
of sample covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ITP_noproj(
  Y,
  k = 1,
  alpha = 0.05,
  epsilon = 0.05,
  r = 8,
  M = 100,
  S = 100,
  fq = 1/4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ITP_noproj_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="ITP_noproj_+3A_k">k</code></td>
<td>
<p>an positive integer indicating which eigenvalue to test.</p>
</td></tr>
<tr><td><code id="ITP_noproj_+3A_alpha">alpha</code></td>
<td>
<p>a number in (0,1), indicating the significance of the test.</p>
</td></tr>
<tr><td><code id="ITP_noproj_+3A_epsilon">epsilon</code></td>
<td>
<p>a small positive number in (0,1), indicating the size of scaling.</p>
</td></tr>
<tr><td><code id="ITP_noproj_+3A_r">r</code></td>
<td>
<p>a positive number indicating the order of the power function
for transforming the rescaled eigenvalue.</p>
</td></tr>
<tr><td><code id="ITP_noproj_+3A_m">M</code></td>
<td>
<p>a large integer for the number of Gaussian variables in the randomized test.</p>
</td></tr>
<tr><td><code id="ITP_noproj_+3A_s">S</code></td>
<td>
<p>another large integer for the number of replications in the strong rule. Usually <code class="reqn">M=S=T</code>.</p>
</td></tr>
<tr><td><code id="ITP_noproj_+3A_fq">fq</code></td>
<td>
<p>a number in (0,0.5), controlling the threshold function of the strong rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2023)
</p>


<h3>Value</h3>

<p>a logical value. 1 for &quot;the number of row factors is smaller than k&quot;.
0 for &quot;at least k row factors exists&quot;.
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L (2023).
One-way or two-way factor model for matrix sequences? <em>Journal of Econometrics</em>,
235(2), 1981-2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k1=3
k2=3
Sample_T=100
p1=40
p2=20

Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=0)
ITP_noproj(Y,k=1,M=Sample_T,S=Sample_T)
ITP_noproj(Y,k=4,M=Sample_T,S=Sample_T)

</code></pre>

<hr>
<h2 id='ITP_proj'>testing the number of row factors- with projection</h2><span id='topic+ITP_proj'></span>

<h3>Description</h3>

<p>This function tests whether the number of row factors is equal or larger
than a given integer, under a two-way factor model, using projected version
of sample covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ITP_proj(
  Y,
  k = 1,
  alpha = 0.05,
  kmax = 4,
  epsilon = 0.05,
  r = 8,
  M = 100,
  S = 100,
  fq = 1/4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ITP_proj_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="ITP_proj_+3A_k">k</code></td>
<td>
<p>an positive integer indicating which eigenvalue to test.</p>
</td></tr>
<tr><td><code id="ITP_proj_+3A_alpha">alpha</code></td>
<td>
<p>a number in (0,1), indicating the significance of the test.</p>
</td></tr>
<tr><td><code id="ITP_proj_+3A_kmax">kmax</code></td>
<td>
<p>a positive integer smaller than p2, indicating the
upper bound for the factor numbers, and the dimension of projection matrix.</p>
</td></tr>
<tr><td><code id="ITP_proj_+3A_epsilon">epsilon</code></td>
<td>
<p>a small positive number in (0,1), indicating the size of scaling.</p>
</td></tr>
<tr><td><code id="ITP_proj_+3A_r">r</code></td>
<td>
<p>a positive number indicating the order of the power function
for transforming the rescaled eigenvalue.</p>
</td></tr>
<tr><td><code id="ITP_proj_+3A_m">M</code></td>
<td>
<p>a large integer for the number of Gaussian variables in the randomized test.</p>
</td></tr>
<tr><td><code id="ITP_proj_+3A_s">S</code></td>
<td>
<p>another large integer for the number of replications in the strong rule. Usually <code class="reqn">M=S=T</code>.</p>
</td></tr>
<tr><td><code id="ITP_proj_+3A_fq">fq</code></td>
<td>
<p>a number in (0,0.5), controlling the threshold function of the strong rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2023)
</p>


<h3>Value</h3>

<p>a logical value. 1 for &quot;the number of row factors is smaller than k&quot;.
0 for &quot;at least k row factors exists&quot;.
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L (2023).
One-way or two-way factor model for matrix sequences? <em>Journal of Econometrics</em>,
235(2), 1981-2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k1=3
k2=3
Sample_T=100
p1=40
p2=20

Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=0)
ITP_proj(Y,k=1,M=Sample_T,S=Sample_T)
ITP_proj(Y,k=4,M=Sample_T,S=Sample_T)

</code></pre>

<hr>
<h2 id='kpe'>determine factor number - projected</h2><span id='topic+kpe'></span>

<h3>Description</h3>

<p>This function determined the numbers of row and column factors
for matrix variate data under a two-way factor model, using a projected method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kpe(Y, kmax = 4, c = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kpe_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="kpe_+3A_kmax">kmax</code></td>
<td>
<p>a positive integer smaller than p2, indicating the
upper bound for the factor numbers, and the dimension of projection matrix.</p>
</td></tr>
<tr><td><code id="kpe_+3A_c">c</code></td>
<td>
<p>a non-negative but small number, to ensure the
denominator of the eigenvalue ratio statistics is not 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-dimensional vector containing the estimated
number of row and column factors, respectively.
</p>


<h3>References</h3>

<p>Yu L, He Y, Kong X, &amp; Zhang X (2022). Projected estimation for
large-dimensional matrix factor models. <em>Journal of Econometrics</em>,
229(1),201-217.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k1=3
k2=3
Sample_T=100
p1=40
p2=20
kmax=8

Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=0)
kpe(Y,kmax)


</code></pre>

<hr>
<h2 id='KSTP'>determine row factor number - test</h2><span id='topic+KSTP'></span>

<h3>Description</h3>

<p>This function determines the number of row factors
under a two-way factor structure, using randomized test method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KSTP(
  Y,
  alpha = 0.05,
  type = "proj",
  kmax = 4,
  epsilon = 0.05,
  r = 8,
  M = 100,
  S = 100,
  fq = 1/4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KSTP_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="KSTP_+3A_alpha">alpha</code></td>
<td>
<p>a number in (0,1), indicating the significance of the test.</p>
</td></tr>
<tr><td><code id="KSTP_+3A_type">type</code></td>
<td>
<p>indicates how to calculate the sample covariance. &quot;flat&quot; for the
flat version, while others for the projected version.</p>
</td></tr>
<tr><td><code id="KSTP_+3A_kmax">kmax</code></td>
<td>
<p>a positive integer smaller than p2, indicating the
upper bound for the factor numbers, and the dimension of projection matrix.</p>
</td></tr>
<tr><td><code id="KSTP_+3A_epsilon">epsilon</code></td>
<td>
<p>a small positive number in (0,1), indicating the size of scaling.</p>
</td></tr>
<tr><td><code id="KSTP_+3A_r">r</code></td>
<td>
<p>a positive number indicating the order of the power function
for transforming the rescaled eigenvalue.</p>
</td></tr>
<tr><td><code id="KSTP_+3A_m">M</code></td>
<td>
<p>a large integer for the number of Gaussian variables in the randomized test.</p>
</td></tr>
<tr><td><code id="KSTP_+3A_s">S</code></td>
<td>
<p>another large integer for the number of replications in the strong rule. Usually <code class="reqn">M=S=T</code>.</p>
</td></tr>
<tr><td><code id="KSTP_+3A_fq">fq</code></td>
<td>
<p>a number in (0,0.5), controlling the threshold function of the strong rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2023)
</p>


<h3>Value</h3>

<p>an integer for the number of row factors. To determine the number of column
factors, just transpose the observation matrices.
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L (2023).
One-way or two-way factor model for matrix sequences? <em>Journal of Econometrics</em>,
235(2), 1981-2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k1=3
k2=3
Sample_T=100
p1=40
p2=20

Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=0)
KSTP(Y)
KSTP(aperm(Y,c(1,3,2)))

</code></pre>

<hr>
<h2 id='moment.determine'>determine the moment (largest) of the data samples</h2><span id='topic+moment.determine'></span>

<h3>Description</h3>

<p>This function reports the largest moment that exists for a collection of
data samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moment.determine(x, k.max = 8, alpha = 0.05, R = 400)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moment.determine_+3A_x">x</code></td>
<td>
<p>a numeric vector of data samples.</p>
</td></tr>
<tr><td><code id="moment.determine_+3A_k.max">k.max</code></td>
<td>
<p>a number indicating the upper bound, i.e., at most k.max-th
moment exists.</p>
</td></tr>
<tr><td><code id="moment.determine_+3A_alpha">alpha</code></td>
<td>
<p>a number in <code class="reqn">(0,1)</code>, indicating the significance level of
the test.</p>
</td></tr>
<tr><td><code id="moment.determine_+3A_r">R</code></td>
<td>
<p>the number of standard Gaussian variables generated in the
randomized test; see also <code><a href="#topic+moment.test">moment.test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure will sequentially test the existence of the <code class="reqn">4th, 6th,
8th, ... k.max-th</code> moment, using the function <code class="reqn">moment.test</code> in the same
package. As soon as the procedure finds that the <code class="reqn">k-th</code> moment does not
exist, it stops and reports at most <code class="reqn">(k-1)-th</code> moment.
</p>


<h3>Value</h3>

<p>an integer, indicating the largest moment that
exists for the data samples.
</p>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x=rt(10000,5)
moment.determine(x,10)

x=rt(10000,4)
moment.determine(x,10)


</code></pre>

<hr>
<h2 id='moment.test'>test whether the k-th moment exists</h2><span id='topic+moment.test'></span>

<h3>Description</h3>

<p>This function tests the existence of k-th moment by randomized method in
Trapani (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moment.test(x, k = 16, R = 400)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moment.test_+3A_x">x</code></td>
<td>
<p>a numeric vector of data samples.</p>
</td></tr>
<tr><td><code id="moment.test_+3A_k">k</code></td>
<td>
<p>a number no smaller than 4, indicating that the procedure will test
the existence of the k-th moment when k is even. Otherwise, the procedure
will test the existence of the <code class="reqn">k'</code>-th moment, with
<code class="reqn">k'=round(k/2,0)\times 2</code>.</p>
</td></tr>
<tr><td><code id="moment.test_+3A_r">R</code></td>
<td>
<p>the number of standard Gaussian variables generated in the
randomized test; see more details in Trapani (2016).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure is adapted from Trapani (2016) with <code class="reqn">\psi=2</code>, where
<code class="reqn">\psi</code> is a tuning parameter to scale the sample moments defined
in Section 3.1 of Trapani (2016). For simplicity, we only test the 4th, 6th,
... 2c-th moments.
</p>


<h3>Value</h3>

<p>a scalar in <code class="reqn">[0,1]</code>, indicating the p-value
of the test. The null hypothese is that the k-th moment doesn't exist.
Therefore, a small p-value indicates the existense of the k-th moment.
</p>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>Trapani, L. (2016). Testing for (in) finite moments.
<em>Journal of Econometrics</em>, 191(1), 57-68.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x=rt(10000,5)
moment.test(x,4)

x=rt(10000,4)
moment.test(x,4)

</code></pre>

<hr>
<h2 id='outlier.remove'>remove outliers</h2><span id='topic+outlier.remove'></span>

<h3>Description</h3>

<p>This function removes outliers in the data, which are far from the sample
median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier.remove(x, rg = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outlier.remove_+3A_x">x</code></td>
<td>
<p>a numeric data vector.</p>
</td></tr>
<tr><td><code id="outlier.remove_+3A_rg">rg</code></td>
<td>
<p>a positive number indicating how the outliers are defined; see
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An outlier is detected if it deviates from the sample median more than
<em>rg</em> times interquantile range.
</p>


<h3>Value</h3>

<p>a list containing the following: </p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>a new
data vector with outliers replaced with <code class="reqn">NA</code>. The original
missing values in the data are preserved.</p>
</td></tr> <tr><td><code>id</code></td>
<td>
<p>the locations of the
outliers in the data vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a=c(1:5,NA,10000)
outlier.remove(a,3)
</code></pre>

<hr>
<h2 id='test.multiple.robust'>robust test of multiple change point for matrix-valued online time series</h2><span id='topic+test.multiple.robust'></span>

<h3>Description</h3>

<p>This function tests multiple change points for matrix-valued online time
series, under a two-way factor structure. A change point will be reported
only when it's the majority vote in multiple replications. The function <code><a href="#topic+KSTP">KSTP</a></code>
is used to determine the initial number of factors in each regime. This function only outputs
the change points for row factors. For column factors, transpose the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.multiple.robust(
  Y,
  k = 1,
  m = ceiling(max(20, (dim(Y)[3])^(r/(r + 2)))),
  epsilon1 = 0.25,
  epsilon2 = 0.05,
  r = 8,
  kmax = 4,
  type = "proj",
  method = "ps",
  eta = 0.25,
  cv = 2.386,
  S = 100,
  pr = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.multiple.robust_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_k">k</code></td>
<td>
<p>a non-negative integer indicating the initial number of factors.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the rolling
windom.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_epsilon1">epsilon1</code></td>
<td>
<p>the rescaling parameter taking value in <code class="reqn">(0,1)</code>, for the
test of new factors or the change of loading space; see He et al. (2021).</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_epsilon2">epsilon2</code></td>
<td>
<p>the rescaling parameter taking value in <code class="reqn">(0,1)</code>, for the
test of vanishing factors; see He et al. (2021).</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the order of the transformation
function <code class="reqn">g(x)=|x|^r</code>; see also  <code><a href="#topic+gen.psi.tau.proj">gen.psi.tau.proj</a></code>.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_kmax">kmax</code></td>
<td>
<p>a positive number determining the column number of the projection
matrix, should be larger than 0 but smaller than <code class="reqn">p_2</code>, required when
<em>type</em> not being &quot;flat&quot;.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_type">type</code></td>
<td>
<p>indicates how to calculate the sample covariance. &quot;flat&quot; for the
flat version, while others for the projected version. See more details in He
et al. (2021).</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_method">method</code></td>
<td>
<p>indicating the test statistic, &ldquo;ps&rdquo; for the partial-sum
method; others for the worst-case method.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_eta">eta</code></td>
<td>
<p>a number between <code class="reqn">[0,1)</code>, indicating the parameter <code class="reqn">\eta</code>
used in the partial-sum statistic.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_cv">cv</code></td>
<td>
<p>critical value; see also <code><a href="#topic+test.once.psi">test.once.psi</a></code>.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_s">S</code></td>
<td>
<p>an integer indicating the number of replications.</p>
</td></tr>
<tr><td><code id="test.multiple.robust_+3A_pr">pr</code></td>
<td>
<p>an number in <code class="reqn">(0,1])</code>. The procedure reports a change point only
when the proportion of positive votes is over <em>pr</em> in the
<em>S</em> replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' See empirical study in He et al. (2021).
</p>


<h3>Value</h3>

<p>a matrix with two columns. The first column reports the locations
of change points. The second column reports the number of row factors
after each change point.
</p>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point detection for
matrix-valued time series with latent two-way factor structure. <em>arXiv
preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
k1=3
k2=3
Sample_T=100
p1=40
p2=40
kmax=8
r=8
m=p2

# generate data
Y1=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.5)
Y2=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=0)
Y=array(rbind(matrix(Y1,Sample_T,p1*p2),matrix(Y2,Sample_T,p1*p2)),c(Sample_T*2,p1,p2))

# calculate cv for "ps" with eta=0.45 and "wc"
cv1=getcv(0.05,method="ps",eta=0.45)
cv2=getcv(0.05,method="wc")

# test with Y
test.multiple.robust(Y,k1,m,epsilon1=0.25,epsilon2=0.05,r,type="proj",kmax,method="ps")

test.multiple.robust(Y,k1,m,epsilon1=0.25,epsilon2=0.05,r,type="proj",kmax,method="wc",cv=cv2)

test.multiple.robust(Y,k1,m,epsilon1=0.25,epsilon2=0.05,r,type="flat",method="wc",cv=cv2)

test.multiple.robust(Y,k1,m,epsilon1=0.25,epsilon2=0.05,r,type="flat",method="ps",eta=0.45,cv=cv1)


## End(Not run)
</code></pre>

<hr>
<h2 id='test.once.flat'>test single change point for matrix-valued online time series -&rdquo;flat&rdquo;
version</h2><span id='topic+test.once.flat'></span>

<h3>Description</h3>

<p>This function tests single change point for matrix-valued online time
series, under a two-way factor structure, using &rdquo;flat&rdquo; sample covariance
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.once.flat(
  Y,
  k = 1,
  m = ceiling(max(20, (dim(Y)[3])^(r/(r + 2)))),
  epsilon = 0.05,
  r = 8,
  decrease = 0,
  method = "ps",
  eta = 0.25,
  cv = 2.386
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.once.flat_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="test.once.flat_+3A_k">k</code></td>
<td>
<p>a positive integer indicating which eigenvalue to monitor.
<code class="reqn">k=1</code> for the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="test.once.flat_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the
rolling windom.</p>
</td></tr>
<tr><td><code id="test.once.flat_+3A_epsilon">epsilon</code></td>
<td>
<p>the rescaling parameter taking value in <code class="reqn">(0,1)</code>; see He
et al. (2021).</p>
</td></tr>
<tr><td><code id="test.once.flat_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the order of the transformation
function <code class="reqn">g(x)=|x|^r</code>; see also  <code><a href="#topic+gen.psi.tau.proj">gen.psi.tau.proj</a></code>.</p>
</td></tr>
<tr><td><code id="test.once.flat_+3A_decrease">decrease</code></td>
<td>
<p>a logical value. If <em>decrease=1</em>, testing the
decrease of factor number.</p>
</td></tr>
<tr><td><code id="test.once.flat_+3A_method">method</code></td>
<td>
<p>indicating the test statistic, &ldquo;ps&rdquo; for the partial-sum
method; others for the worst-case method.</p>
</td></tr>
<tr><td><code id="test.once.flat_+3A_eta">eta</code></td>
<td>
<p>a number between <code class="reqn">[0,1)</code>, indicating the parameter <code class="reqn">\eta</code>
used in the partial-sum statistic.</p>
</td></tr>
<tr><td><code id="test.once.flat_+3A_cv">cv</code></td>
<td>
<p>critical value; see also  <code><a href="#topic+test.once.psi">test.once.psi</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2021).
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>a logical value. 1 indicating the existence of change point, 0
indicating no change point.</p>
</td></tr> <tr><td><code>loc</code></td>
<td>
<p>an integer larger than m, indicating
the location of change point; or <code class="reqn">NA</code> when no change point is reported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point detection for
matrix-valued time series with latent two-way factor structure. <em>arXiv
preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20
r=8
m=p2

# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.5)

# calculate cv for "ps" with eta=0.45 and "wc"
cv1=getcv(0.05,method="ps",eta=0.45)
cv2=getcv(0.05,method="wc")


## test with Y, flat version
test.once.flat(Y,k1+1,m,epsilon,r,0,method="ps",eta=0.25)


test.once.flat(Y,k1+1,m,epsilon,r,0,method="ps",eta=0.45,cv1)


test.once.flat(Y,k1+1,m,epsilon,r,0,method="wc",eta=0.5,cv2)

</code></pre>

<hr>
<h2 id='test.once.flat.robust'>robust test of single change point for matrix-valued online time series
-&quot;flat&quot; version</h2><span id='topic+test.once.flat.robust'></span>

<h3>Description</h3>

<p>Based on <code><a href="#topic+test.once.flat">test.once.flat</a></code>, this function
repeats the randomized procedure multiple times and reports the majority
vote, thus more robust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.once.flat.robust(
  Y,
  k = 1,
  m = ceiling(max(20, (dim(Y)[3])^(r/(r + 2)))),
  epsilon = 0.05,
  r = 8,
  decrease = 0,
  method = "ps",
  eta = 0.25,
  cv = 2.386,
  S = 100,
  pr = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.once.flat.robust_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_k">k</code></td>
<td>
<p>a positive integer indicating which eigenvalue to monitor.
<code class="reqn">k=1</code> for the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the
rolling windom.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_epsilon">epsilon</code></td>
<td>
<p>the rescaling parameter taking value in <code class="reqn">(0,1)</code>; see He
et al. (2021).</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the order of the transformation
function <code class="reqn">g(x)=|x|^r</code>; see also  <code><a href="#topic+gen.psi.tau.proj">gen.psi.tau.proj</a></code>.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_decrease">decrease</code></td>
<td>
<p>a logical value. If <em>decrease=1</em>, testing the
decrease of factor number.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_method">method</code></td>
<td>
<p>indicating the test statistic, &ldquo;ps&rdquo; for the partial-sum
method; others for the worst-case method.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_eta">eta</code></td>
<td>
<p>a number between <code class="reqn">[0,1)</code>, indicating the parameter <code class="reqn">\eta</code>
used in the partial-sum statistic.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_cv">cv</code></td>
<td>
<p>critical value; see also  <code><a href="#topic+test.once.psi">test.once.psi</a></code>.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_s">S</code></td>
<td>
<p>an integer indicating the number of replications.</p>
</td></tr>
<tr><td><code id="test.once.flat.robust_+3A_pr">pr</code></td>
<td>
<p>an number in <code class="reqn">(0,1])</code>. The procedure reports a change point
only when the proportion of positive votes is over <em>pr</em> in the
<em>S</em> replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2021).
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>a logical value. 1 indicating the existence of change point, 0
indicating no change point.</p>
</td></tr> <tr><td><code>loc</code></td>
<td>
<p>an integer larger than m, indicating
the median location of the change point among the positive votes in the
<em>S</em> replications; or <code class="reqn">NA</code> when no change point is reported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point detection for
matrix-valued time series with latent two-way factor structure. <em>arXiv
preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20
kmax=8
r=8
m=p2

# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.5)

# calculate cv for "ps" with eta=0.45 and "wc"
cv1=getcv(0.05,method="ps",eta=0.45)
cv2=getcv(0.05,method="wc")


## test with Y, flat version
test.once.flat.robust(Y,k1+1,m,epsilon,r,0,method="ps",eta=0.25)


test.once.flat.robust(Y,k1+1,m,epsilon,r,0,method="ps",eta=0.45,cv1)


test.once.flat.robust(Y,k1+1,m,epsilon,r,0,method="wc",eta=0.5,cv2)


## End(Not run)
</code></pre>

<hr>
<h2 id='test.once.proj'>test single change point for matrix-valued online time series-projected
version</h2><span id='topic+test.once.proj'></span>

<h3>Description</h3>

<p>This function tests single change point for matrix-valued online time
series, under a two-way factor structure, using projected sample covariance
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.once.proj(
  Y,
  k = 1,
  m = ceiling(max(20, (dim(Y)[3])^(r/(r + 2)))),
  epsilon = 0.05,
  r = 8,
  kmax = 3,
  decrease = 0,
  method = "ps",
  eta = 0.25,
  cv = 2.386
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.once.proj_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_k">k</code></td>
<td>
<p>a positive integer indicating which eigenvalue to monitor.
<code class="reqn">k=1</code> for the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the
rolling window.</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_epsilon">epsilon</code></td>
<td>
<p>the rescaling parameter taking value in <code class="reqn">(0,1)</code>; see He
et al. (2021).</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the order of the transformation
function <code class="reqn">g(x)=|x|^r</code>; see also <code><a href="#topic+gen.psi.tau.proj">gen.psi.tau.proj</a></code>.</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_kmax">kmax</code></td>
<td>
<p>a positive number determining the column number of the
projection matrix, should be larger than 0 but smaller than <code class="reqn">p2</code>.</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_decrease">decrease</code></td>
<td>
<p>a logical value. If <em>decrease=1</em>, testing the
decrease of factor number.</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_method">method</code></td>
<td>
<p>indicating the test statistic, &ldquo;ps&rdquo; for the partial-sum
method; others for the worst-case method.</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_eta">eta</code></td>
<td>
<p>a number between <code class="reqn">[0,1)</code>, indicating the parameter <code class="reqn">\eta</code>
used in the partial-sum statistic.</p>
</td></tr>
<tr><td><code id="test.once.proj_+3A_cv">cv</code></td>
<td>
<p>critical value; see also <code><a href="#topic+test.once.psi">test.once.psi</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2021).
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>a logical value. 1 indicating the existence of change point, 0
indicating no change point.</p>
</td></tr> <tr><td><code>loc</code></td>
<td>
<p>an integer larger than m, indicating
the location of change point; or <code class="reqn">NA</code> when no change point is reported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point detection for
matrix-valued time series with latent two-way factor structure. <em>arXiv
preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20
kmax=8
r=8

# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.5)

# calculate cv for "ps" with eta=0.45 and "wc"
cv1=getcv(0.05,method="ps",eta=0.45)
cv2=getcv(0.05,method="wc")


## test with Y, projection
test.once.proj(Y,k1+1,kmax=8)

m=p2
test.once.proj(Y,k1+1,m,epsilon,r,kmax,0,method="ps",eta=0.45,cv1)


test.once.proj(Y,k1+1,m,epsilon,r,kmax,0,method="wc",eta=0.5,cv2)

</code></pre>

<hr>
<h2 id='test.once.proj.robust'>robust test of single change point for matrix-valued online time
series-projected version</h2><span id='topic+test.once.proj.robust'></span>

<h3>Description</h3>

<p>Based on <code><a href="#topic+test.once.proj">test.once.proj</a></code>, this function
repeats the randomized procedure multiple times and reports the majority
vote, thus more robust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.once.proj.robust(
  Y,
  k = 1,
  m = ceiling(max(20, (dim(Y)[3])^(r/(r + 2)))),
  epsilon = 0.05,
  r = 8,
  kmax = 3,
  decrease = 0,
  method = "ps",
  eta = 0.25,
  cv = 2.386,
  S = 100,
  pr = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.once.proj.robust_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_k">k</code></td>
<td>
<p>a positive integer indicating which eigenvalue to monitor.
<code class="reqn">k=1</code> for the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the
rolling windom.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_epsilon">epsilon</code></td>
<td>
<p>the rescaling parameter taking value in <code class="reqn">(0,1)</code>; see He
et al. (2021).</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the order of the transformation
function <code class="reqn">g(x)=|x|^r</code>; see also  <code><a href="#topic+gen.psi.tau.proj">gen.psi.tau.proj</a></code>.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_kmax">kmax</code></td>
<td>
<p>a positive number determining the column number of the
projection matrix, should be larger than 0 but smaller than <code class="reqn">p_2</code>.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_decrease">decrease</code></td>
<td>
<p>a logical value. If <em>decrease=1</em>, testing the
decrease of factor number.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_method">method</code></td>
<td>
<p>indicating the test statistic, &ldquo;ps&rdquo; for the partial-sum
method; others for the worst-case method.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_eta">eta</code></td>
<td>
<p>a number between <code class="reqn">[0,1)</code>, indicating the parameter <code class="reqn">\eta</code>
used in the partial-sum statistic.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_cv">cv</code></td>
<td>
<p>critical value; see also <code><a href="#topic+test.once.psi">test.once.psi</a></code>.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_s">S</code></td>
<td>
<p>an integer indicating the number of replications.</p>
</td></tr>
<tr><td><code id="test.once.proj.robust_+3A_pr">pr</code></td>
<td>
<p>an number in <code class="reqn">(0,1])</code>. The procedure reports a change point
only when the proportion of positive votes is over <em>pr</em> in the
<em>S</em> replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2021).
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>a logical value. 1 indicating the existence of change point, 0
indicating no change point.</p>
</td></tr> <tr><td><code>loc</code></td>
<td>
<p>an integer larger than m, indicating
the median location of the change point among the positive votes in the
<em>S</em> replications; or <code class="reqn">NA</code> when no change point is reported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point detection for
matrix-valued time series with latent two-way factor structure. <em>arXiv
preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20
kmax=8
r=8
m=p2

# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.5)

# calculate cv for "ps" with eta=0.45 and "wc"
cv1=getcv(0.05,method="ps",eta=0.45)
cv2=getcv(0.05,method="wc")


## test with Y, projection
test.once.proj.robust(Y,k1+1,m,epsilon,r,kmax,0,method="ps",eta=0.25)


test.once.proj.robust(Y,k1+1,m,epsilon,r,kmax,0,method="ps",eta=0.45,cv1)


test.once.proj.robust(Y,k1+1,m,epsilon,r,kmax,0,method="wc",eta=0.5,cv2)


## End(Not run)
</code></pre>

<hr>
<h2 id='test.once.psi'>test single change point for matrix-valued online data given rolling
eigenvalue series</h2><span id='topic+test.once.psi'></span>

<h3>Description</h3>

<p>This function tests single change point for matrix-valued online time
series, under a two-way factor structure, given the transformed eigenvalue
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.once.psi(m = 20, psi, method = "ps", eta = 0.25, cv = 2.386)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.once.psi_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the
rolling windom.</p>
</td></tr>
<tr><td><code id="test.once.psi_+3A_psi">psi</code></td>
<td>
<p>the transformed eigenvalue series, produced by gen.psi.tau.flat
or gen.psi.tau.proj, with length <code class="reqn">T-m</code>.</p>
</td></tr>
<tr><td><code id="test.once.psi_+3A_method">method</code></td>
<td>
<p>indicating the test statistic, &ldquo;ps&rdquo; for the partial-sum
method, while others for the worst-case method.</p>
</td></tr>
<tr><td><code id="test.once.psi_+3A_eta">eta</code></td>
<td>
<p>a number between <code class="reqn">[0,1)</code>, indicating the parameter <code class="reqn">\eta</code>
used in the partial-sum statistic.</p>
</td></tr>
<tr><td><code id="test.once.psi_+3A_cv">cv</code></td>
<td>
<p>critical value, related to the significance level and test
statistic. The default cv is from Horvath et al. (2004), and only works for
<code class="reqn">\eta=0.25</code> or <code class="reqn">\eta=0.75</code>. For other cases, generate the critical
value first by function <code><a href="#topic+getcv">getcv</a></code>. Note that for the partial-sum
statistic with <code class="reqn">\eta</code> not equal to 0.5, the critical values are
approximated by simulated data, thus can be slightly different from those in
Horvath et al. (2004).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2021).
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>a logical value. 1 indicating the existence of change point, 0
indicating no change point.</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>an integer larger than m, indicating
the location of change point; or <code class="reqn">NA</code> when no change point is reported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>Horvath L, Huskova M, Kokoszka P, et al (2004). Monitoring
changes in linear models. <em>Journal of statistical Planning and
Inference</em>, 126(1): 225-251.
</p>
<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point detection for
matrix-valued time series with latent two-way factor structure. <em>arXiv
preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20
kmax=8
r=8
m=p2

# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.5)

# calculate delta
temp=log(p1)/log(m*p2)
delta=epsilon*(temp&lt;=0.5)+(epsilon+1-1/(2*temp))*(temp&gt;0.5)

# calculate psi.tau
psi1=gen.psi.tau.proj(Y,k1+1,m,delta,r,kmax)
psi2=gen.psi.tau.flat(Y,k1+1,m,delta,r)

# calculate cv for "ps" with eta=0.45 and "wc"
cv1=getcv(0.05,method="ps",eta=0.45)
cv2=getcv(0.05,method="wc")


# test with psi1
test.once.psi(m,psi1[,3],method="ps",eta=0.45,cv1)

test.once.psi(m,psi1[,3],method="wc",eta=0.5,cv2)


# test with psi2
test.once.psi(m,psi2[,3],method="ps",eta=0.45,cv1)

test.once.psi(m,psi2[,3],method="wc",eta=0.5,cv2)


</code></pre>

<hr>
<h2 id='test.once.psi.robust'>robust test of single change point for matrix-valued online data given
rolling eigenvalue series</h2><span id='topic+test.once.psi.robust'></span>

<h3>Description</h3>

<p>Based on <code><a href="#topic+test.once.psi">test.once.psi</a></code>, this function
repeats the randomized procedure multiple times and reports the majority
vote, thus more robust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.once.psi.robust(
  m = 20,
  psi,
  method = "ps",
  eta = 0.25,
  cv = 2.386,
  S = 100,
  pr = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.once.psi.robust_+3A_m">m</code></td>
<td>
<p>a positive integer (<code class="reqn">&gt;1</code>) indicating the bandwidth of the
rolling windom.</p>
</td></tr>
<tr><td><code id="test.once.psi.robust_+3A_psi">psi</code></td>
<td>
<p>the transformed eigenvalue series, produced by gen.psi.tau.flat
or gen.psi.tau.proj, with length <code class="reqn">T-m</code>.</p>
</td></tr>
<tr><td><code id="test.once.psi.robust_+3A_method">method</code></td>
<td>
<p>indicating the test statistic, &ldquo;ps&rdquo; for the partial-sum
method, while others for the worst-case method.</p>
</td></tr>
<tr><td><code id="test.once.psi.robust_+3A_eta">eta</code></td>
<td>
<p>a number between <code class="reqn">[0,1)</code>, indicating the parameter <code class="reqn">\eta</code>
used in the partial-sum statistic.</p>
</td></tr>
<tr><td><code id="test.once.psi.robust_+3A_cv">cv</code></td>
<td>
<p>critical value; see also <code><a href="#topic+test.once.psi">test.once.psi</a></code>.</p>
</td></tr>
<tr><td><code id="test.once.psi.robust_+3A_s">S</code></td>
<td>
<p>an integer indicating the number of replications.</p>
</td></tr>
<tr><td><code id="test.once.psi.robust_+3A_pr">pr</code></td>
<td>
<p>an number in <code class="reqn">(0,1])</code>. The procedure reports a change point
only when the proportion of positive votes is over <em>pr</em> in the
<em>S</em> replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See He et al. (2021).
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>a logical value. 1 indicating the existence of change point, 0
indicating no change point.</p>
</td></tr> <tr><td><code>loc</code></td>
<td>
<p>an integer larger than m, indicating
the median location of the change point among the positive votes in the
<em>S</em> replications; or <code class="reqn">NA</code> when no change point is reported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong He, Xinbing Kong, Lorenzo Trapani, Long Yu
</p>


<h3>References</h3>

<p>He Y, Kong X, Trapani L, &amp; Yu L(2021). Online change-point detection for
matrix-valued time series with latent two-way factor structure. <em>arXiv
preprint</em>, arXiv:2112.13479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
k1=3
k2=3
epsilon=0.05
Sample_T=50
p1=40
p2=20
kmax=8
r=8
m=p2

# generate data
Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=1,pp=0.5)

# calculate delta
temp=log(p1)/log(m*p2)
delta=epsilon*(temp&lt;=0.5)+(epsilon+1-1/(2*temp))*(temp&gt;0.5)

# calculate psi.tau
psi1=gen.psi.tau.proj(Y,k1+1,m,delta,r,kmax)
psi2=gen.psi.tau.flat(Y,k1+1,m,delta,r)

# calculate cv for "ps" with eta=0.45 and "wc"
cv1=getcv(0.05,method="ps",eta=0.45)
cv2=getcv(0.05,method="wc")


# test with psi1
test.once.psi.robust(m,psi1[,3],method="ps",eta=0.45,cv1,S=100,pr=0.75)

test.once.psi.robust(m,psi1[,3],method="wc",eta=0.5,cv2,S=100,pr=0.75)


# test with psi2
test.once.psi.robust(m,psi2[,3],method="ps",eta=0.45,cv1,S=100,pr=0.75)

test.once.psi.robust(m,psi2[,3],method="wc",eta=0.5,cv2,S=100,pr=0.75)


</code></pre>

<hr>
<h2 id='var.exp'>explanatory power of factors</h2><span id='topic+var.exp'></span>

<h3>Description</h3>

<p>This function calculates the cumulative explanatory power of the
leading  row factors, in terms of the explained variance, under a
two-way factor structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.exp(Y, k = 2, type = "proj", kmax = 4, plot = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.exp_+3A_y">Y</code></td>
<td>
<p>data, a <code class="reqn">T\times p1\times p2</code> array.</p>
</td></tr>
<tr><td><code id="var.exp_+3A_k">k</code></td>
<td>
<p>a positive integer indicating the number of factors investigated, should be
smaller than p1.</p>
</td></tr>
<tr><td><code id="var.exp_+3A_type">type</code></td>
<td>
<p>indicates how to calculate the sample covariance. &quot;flat&quot; for the
flat version, while others for the projected version.</p>
</td></tr>
<tr><td><code id="var.exp_+3A_kmax">kmax</code></td>
<td>
<p>a positive integer smaller than p2, indicating the
upper bound for the factor numbers, and the dimension of projection matrix.</p>
</td></tr>
<tr><td><code id="var.exp_+3A_plot">plot</code></td>
<td>
<p>a logical value. When <em>plot=1</em>, a figure of the
cumulative explanatory power will be plotted, with x axis being the number of
factors, and y axis being the cumulative explained variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with k entries, corresponding to the cumulative explanatory power
of the leading k factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k1=3
k2=3
Sample_T=100
p1=40
p2=20

Y=gen.data(Sample_T,p1,p2,k1,k2,tau=0.5,change=0)
var.exp(Y,k=5,plot=1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
