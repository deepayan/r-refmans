<!DOCTYPE html><html><head><title>Help for package CausalGPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CausalGPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#absolute_corr_fun'><p>Check covariate balance using absolute approach</p></a></li>
<li><a href='#absolute_weighted_corr_fun'><p>Check  Weighted Covariate Balance Using Absolute Approach</p></a></li>
<li><a href='#autoplot.gpsm_erf'><p>A helper function for gpsm_erf object</p></a></li>
<li><a href='#autoplot.gpsm_pspop'><p>A helper function for gpsm_pspop object</p></a></li>
<li><a href='#CausalGPS-package'><p>The 'CausalGPS' package.</p></a></li>
<li><a href='#check_args'><p>Check additional arguments</p></a></li>
<li><a href='#check_args_compile_pseudo_pop'><p>Check compile_pseudo_pop function arguments</p></a></li>
<li><a href='#check_args_estimate_gps'><p>Check estimate_gps function arguments</p></a></li>
<li><a href='#check_args_use_cov_transformers'><p>Check Covariate Balance Transformers Argument</p></a></li>
<li><a href='#check_covar_balance'><p>Check covariate balance</p></a></li>
<li><a href='#check_kolmogorov_smirnov'><p>Check Kolmogorov-Smirnov (KS) statistics</p></a></li>
<li><a href='#compile_pseudo_pop'><p>Compile pseudo population</p></a></li>
<li><a href='#compute_closest_wgps'><p>Find the closest data in subset to the original data</p></a></li>
<li><a href='#compute_density'><p>Approximate density based on another vector</p></a></li>
<li><a href='#compute_min_max'><p>Compute minimum and maximum</p></a></li>
<li><a href='#compute_outer'><p>Computes distance on all possible combinations</p></a></li>
<li><a href='#compute_resid'><p>Compute residual</p></a></li>
<li><a href='#compute_risk'><p>Compute risk value</p></a></li>
<li><a href='#create_matching'><p>Create pseudo population using matching casual inference approach</p></a></li>
<li><a href='#create_weighting'><p>Create pseudo population using weighting casual inference approach</p></a></li>
<li><a href='#estimate_gps'><p>Estimate generalized propensity score (GPS) values</p></a></li>
<li><a href='#estimate_hat_vals'><p>Estimate hat (fitted) values</p></a></li>
<li><a href='#estimate_npmetric_erf'><p>Estimate smoothed exposure-response function (ERF) for pseudo population</p></a></li>
<li><a href='#estimate_pmetric_erf'><p>Estimate Parametric Exposure Response Function</p></a></li>
<li><a href='#estimate_semipmetric_erf'><p>Estimate semi-exposure-response function (semi-ERF).</p></a></li>
<li><a href='#gen_wrap_sl_lib'><p>Generate customized wrapper for SuperLearner libraries</p></a></li>
<li><a href='#generate_kernel'><p>Generate kernel function</p></a></li>
<li><a href='#generate_pseudo_pop'><p>Generate pseudo population</p></a></li>
<li><a href='#generate_syn_data'><p>Generate synthetic data for the CausalGPS package</p></a></li>
<li><a href='#get_logger'><p>Get Logger Settings</p></a></li>
<li><a href='#log_system_info'><p>Log system information</p></a></li>
<li><a href='#matching_fn'><p>Match observations</p></a></li>
<li><a href='#plot.gpsm_erf'><p>Extend generic plot functions for gpsm_erf class</p></a></li>
<li><a href='#plot.gpsm_pspop'><p>Extend generic plot functions for gpsm_erf class</p></a></li>
<li><a href='#preprocess_data'><p>Preprocess data</p></a></li>
<li><a href='#print.gpsm_erf'><p>Extend print function for gpsm_erf object</p></a></li>
<li><a href='#print.gpsm_pspop'><p>Extend print function for gpsm_pspop object</p></a></li>
<li><a href='#set_logger'><p>Set Logger Settings</p></a></li>
<li><a href='#smooth_erf'><p>Smooth exposure response function</p></a></li>
<li><a href='#smooth_erf_kernsmooth'><p>Compute smoothed erf with kernsmooth approach</p></a></li>
<li><a href='#smooth_erf_locpol'><p>Compute smoothed erf with locpol approach</p></a></li>
<li><a href='#summary.gpsm_erf'><p>print summary of gpsm_erf object</p></a></li>
<li><a href='#summary.gpsm_pspop'><p>print summary of gpsm_pspop object</p></a></li>
<li><a href='#synthetic_us_2010'><p>Public data set for air pollution and health studies,</p>
case study: 2010 county-Level data set for the contiguous United States</a></li>
<li><a href='#train_it'><p>Generate Prediction Model</p></a></li>
<li><a href='#transform_it'><p>Transform data</p></a></li>
<li><a href='#trim_gps'><p>Trim a gps object based on provided trimming quantiles</p></a></li>
<li><a href='#w_fun'><p>Helper function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matching on Generalized Propensity Scores with Continuous
Exposures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Naeem Khoshnevis &lt;nkhoshnevis@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework for estimating causal effects of a continuous 
    exposure using observational data, and implementing matching and weighting 
    on the generalized propensity score.
    Wu, X., Mealli, F., Kioumourtzoglou, M.A., Dominici, F. and Braun, D., 2022. 
    Matching on generalized propensity scores with continuous exposures. Journal 
    of the American Statistical Association, pp.1-29.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/NSAPH-Software/CausalGPS">https://github.com/NSAPH-Software/CausalGPS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NSAPH-Software/CausalGPS/issues">https://github.com/NSAPH-Software/CausalGPS/issues</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Harvard University</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, data.table, SuperLearner, xgboost, gam, MASS,
polycor, wCorr, stats, ggplot2, rlang, logger, Rcpp, gnm,
locpol, Ecume, KernSmooth, cowplot</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, ranger, earth, testthat, gridExtra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-29 23:27:12 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Naeem Khoshnevis <a href="https://orcid.org/0000-0003-4315-1426"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (HUIT),
  Xiao Wu <a href="https://orcid.org/0000-0002-4884-657X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]
    (HSPH),
  Danielle Braun <a href="https://orcid.org/0000-0002-5177-8598"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (HSPH)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-29 23:52:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='absolute_corr_fun'>Check covariate balance using absolute approach</h2><span id='topic+absolute_corr_fun'></span>

<h3>Description</h3>

<p>Checks covariate balance based on absolute correlations for given data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absolute_corr_fun(w, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absolute_corr_fun_+3A_w">w</code></td>
<td>
<p>A vector of observed continuous exposure variable.</p>
</td></tr>
<tr><td><code id="absolute_corr_fun_+3A_c">c</code></td>
<td>
<p>A data.frame of observed covariates variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list including:
</p>

<ul>
<li> <p><code>absolute_corr</code>: the absolute correlations for each pre-exposure
covariates;
</p>
</li>
<li> <p><code>mean_absolute_corr</code>: the average absolute correlations for all
pre-exposure covariates.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(291)
n &lt;- 100
mydata &lt;- generate_syn_data(sample_size=100)
year &lt;- sample(x=c("2001","2002","2003","2004","2005"),size = n,
 replace = TRUE)
region &lt;- sample(x=c("North", "South", "East", "West"),size = n,
 replace = TRUE)
mydata$year &lt;- as.factor(year)
mydata$region &lt;- as.factor(region)
mydata$cf5 &lt;- as.factor(mydata$cf5)
cor_val &lt;- absolute_corr_fun(mydata[,2], mydata[, 3:length(mydata)])
print(cor_val$mean_absolute_corr)

</code></pre>

<hr>
<h2 id='absolute_weighted_corr_fun'>Check  Weighted Covariate Balance Using Absolute Approach</h2><span id='topic+absolute_weighted_corr_fun'></span>

<h3>Description</h3>

<p>Checks covariate balance based on absolute weighted correlations for
given data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absolute_weighted_corr_fun(w, vw, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absolute_weighted_corr_fun_+3A_w">w</code></td>
<td>
<p>A vector of observed continuous exposure variable.</p>
</td></tr>
<tr><td><code id="absolute_weighted_corr_fun_+3A_vw">vw</code></td>
<td>
<p>A vector of weights.</p>
</td></tr>
<tr><td><code id="absolute_weighted_corr_fun_+3A_c">c</code></td>
<td>
<p>A data.table of observed covariates variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list saved the measure related to covariate balance
<code>absolute_corr</code>: the absolute correlations for each pre-exposure
covairates;
<code>mean_absolute_corr</code>: the average absolute correlations for all
pre-exposure covairates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(639)
n &lt;- 100
mydata &lt;- generate_syn_data(sample_size=100)
year &lt;- sample(x=c("2001","2002","2003","2004","2005"),size = n,
               replace = TRUE)
region &lt;- sample(x=c("North", "South", "East", "West"),size = n,
                 replace = TRUE)
mydata$year &lt;- as.factor(year)
mydata$region &lt;- as.factor(region)
mydata$cf5 &lt;- as.factor(mydata$cf5)
cor_val &lt;- absolute_weighted_corr_fun(mydata[,2],
                                      runif(n),
                                      mydata[, 3:length(mydata)])
print(cor_val$mean_absolute_corr)

</code></pre>

<hr>
<h2 id='autoplot.gpsm_erf'>A helper function for gpsm_erf object</h2><span id='topic+autoplot.gpsm_erf'></span>

<h3>Description</h3>

<p>A helper function to plot gpsm_erf object using ggplot2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpsm_erf'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.gpsm_erf_+3A_object">object</code></td>
<td>
<p>A gpsm_erf object.</p>
</td></tr>
<tr><td><code id="autoplot.gpsm_erf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object.
</p>

<hr>
<h2 id='autoplot.gpsm_pspop'>A helper function for gpsm_pspop object</h2><span id='topic+autoplot.gpsm_pspop'></span>

<h3>Description</h3>

<p>A helper function to plot gpsm_pspop object using ggplot2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpsm_pspop'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.gpsm_pspop_+3A_object">object</code></td>
<td>
<p>A gpsm_pspop object.</p>
</td></tr>
<tr><td><code id="autoplot.gpsm_pspop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object.
</p>

<hr>
<h2 id='CausalGPS-package'>The 'CausalGPS' package.</h2><span id='topic+CausalGPS-package'></span><span id='topic+CausalGPS'></span>

<h3>Description</h3>

<p>An R package for implementing matching and weighting on generalized
propensity scores with continuous exposures.
</p>


<h3>Details</h3>

<p>We developed an innovative approach for estimating causal effects using
observational data in settings with continuous exposures, and introduce a new
framework for GPS caliper matching.
</p>


<h3>Author(s)</h3>

<p>Naeem Khoshnevis
</p>
<p>Xiao Wu
</p>
<p>Danielle Braun
</p>


<h3>References</h3>

<p>Wu, X., Mealli, F., Kioumourtzoglou, M.A., Dominici, F. and Braun, D., 2022.
Matching on generalized propensity scores with continuous exposures.
Journal of the American Statistical Association, pp.1-29.
</p>
<p>Kennedy, E.H., Ma, Z., McHugh, M.D. and Small, D.S., 2017. Non-parametric
methods for doubly robust estimation of continuous treatment effects.
Journal of the Royal Statistical Society. Series B (Statistical Methodology),
79(4), pp.1229-1245.
</p>

<hr>
<h2 id='check_args'>Check additional arguments</h2><span id='topic+check_args'></span>

<h3>Description</h3>

<p>Checks additional arguments that user needs to provide for different
prediction models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_args(
  ci_appr,
  use_cov_transform,
  transformers,
  gps_density,
  trim_quantiles,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_args_+3A_ci_appr">ci_appr</code></td>
<td>
<p>The causal inference approach.</p>
</td></tr>
<tr><td><code id="check_args_+3A_use_cov_transform">use_cov_transform</code></td>
<td>
<p>A logical value (TRUE/FALSE) to use covariate
balance transforming.</p>
</td></tr>
<tr><td><code id="check_args_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformers.</p>
</td></tr>
<tr><td><code id="check_args_+3A_...">...</code></td>
<td>
<p>Additional named arguments passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if requirements are met. Raises error otherwise.
</p>

<hr>
<h2 id='check_args_compile_pseudo_pop'>Check compile_pseudo_pop function arguments</h2><span id='topic+check_args_compile_pseudo_pop'></span>

<h3>Description</h3>

<p>additional arguments are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_args_compile_pseudo_pop(ci_appr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_args_compile_pseudo_pop_+3A_ci_appr">ci_appr</code></td>
<td>
<p>The selected causal inference approach.</p>
</td></tr>
<tr><td><code id="check_args_compile_pseudo_pop_+3A_...">...</code></td>
<td>
<p>Additional arguments to successfully run the selected ci_appr.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns True if passes all checks, successfully. Otherwise raises ERROR.
</p>

<hr>
<h2 id='check_args_estimate_gps'>Check estimate_gps function arguments</h2><span id='topic+check_args_estimate_gps'></span>

<h3>Description</h3>

<p>Checks estimate_gps function arguments to make sure that the required
additional arguments are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_args_estimate_gps(gps_density, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_args_estimate_gps_+3A_gps_density">gps_density</code></td>
<td>
<p>Model type which is used for estimating GPS value, including
<code>normal</code> and <code>kernel</code>.</p>
</td></tr>
<tr><td><code id="check_args_estimate_gps_+3A_...">...</code></td>
<td>
<p>Additional arguments to successfully run the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns True if passes all checks, successfully. Otherwise raises ERROR.
</p>

<hr>
<h2 id='check_args_use_cov_transformers'>Check Covariate Balance Transformers Argument</h2><span id='topic+check_args_use_cov_transformers'></span>

<h3>Description</h3>

<p>Checks Covariate Balance Transformers in terms of using them and available
transformers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_args_use_cov_transformers(use_cov_transform, transformers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_args_use_cov_transformers_+3A_use_cov_transform">use_cov_transform</code></td>
<td>
<p>A logical value (TRUE/FALSE) to use covariate balance
transforming.</p>
</td></tr>
<tr><td><code id="check_args_use_cov_transformers_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if passes all tests.
</p>

<hr>
<h2 id='check_covar_balance'>Check covariate balance</h2><span id='topic+check_covar_balance'></span>

<h3>Description</h3>

<p>Checks the covariate balance of original population or pseudo population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_covar_balance(w, c, ci_appr, counter_weight = NULL, nthread = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_covar_balance_+3A_w">w</code></td>
<td>
<p>A vector of observed continuous exposure variable.</p>
</td></tr>
<tr><td><code id="check_covar_balance_+3A_c">c</code></td>
<td>
<p>A data.frame of observed covariates variable.</p>
</td></tr>
<tr><td><code id="check_covar_balance_+3A_ci_appr">ci_appr</code></td>
<td>
<p>The causal inference approach.</p>
</td></tr>
<tr><td><code id="check_covar_balance_+3A_counter_weight">counter_weight</code></td>
<td>
<p>A weight vector in different situations. If the
matching approach is selected, it is an integer data.table of counters.
In the case of the weighting approach, it is weight data.table.</p>
</td></tr>
<tr><td><code id="check_covar_balance_+3A_nthread">nthread</code></td>
<td>
<p>The number of available threads.</p>
</td></tr>
<tr><td><code id="check_covar_balance_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to different models.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Additional parameters</h4>


<ul>
<li><p> For ci_appr == matching:
</p>

<ul>
<li><p> covar_bl_method
</p>
</li>
<li><p> covar_bl_trs
</p>
</li></ul>

</li></ul>




<h3>Value</h3>

<p>output object:
</p>

<ul>
<li><p> corr_results
</p>

<ul>
<li><p> absolute_corr
</p>
</li>
<li><p> mean_absolute_corr
</p>
</li></ul>

</li>
<li><p> pass (TRUE,FALSE)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(422)
n &lt;- 100
mydata &lt;- generate_syn_data(sample_size=100)
year &lt;- sample(x=c("2001","2002","2003","2004","2005"),size = n,
              replace = TRUE)
region &lt;- sample(x=c("North", "South", "East", "West"),size = n,
                replace = TRUE)
mydata$year &lt;- as.factor(year)
mydata$region &lt;- as.factor(region)
mydata$cf5 &lt;- as.factor(mydata$cf5)



pseudo_pop &lt;- generate_pseudo_pop(mydata[, c("id", "w")],
                                 mydata[, c("id", "cf1", "cf2", "cf3",
                                            "cf4","cf5", "cf6", "year",
                                            "region")],
                                 ci_appr = "matching",
                                 gps_density = "kernel",
                                 exposure_trim_qtls = c(0.01,0.99),
                                 sl_lib = c("m_xgboost"),
                                 covar_bl_method = "absolute",
                                 covar_bl_trs = 0.1,
                                 covar_bl_trs_type = "mean",
                                 max_attempt = 1,
                                 dist_measure = "l1",
                                 delta_n = 1,
                                 scale = 0.5,
                                 nthread = 1)

adjusted_corr_obj &lt;- check_covar_balance(w = pseudo_pop$pseudo_pop[, c("w")],
                                        c = pseudo_pop$pseudo_pop[ ,
                                        pseudo_pop$covariate_cols_name],
                                        counter = pseudo_pop$pseudo_pop[,
                                                    c("counter_weight")],
                                        ci_appr = "matching",
                                        nthread = 1,
                                        covar_bl_method = "absolute",
                                        covar_bl_trs = 0.1,
                                        covar_bl_trs_type = "mean")

</code></pre>

<hr>
<h2 id='check_kolmogorov_smirnov'>Check Kolmogorov-Smirnov (KS) statistics</h2><span id='topic+check_kolmogorov_smirnov'></span>

<h3>Description</h3>

<p>Checks the Kolmogorov-Smirnov (KS) statistics for exposure and confounders in
the pseudo-population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_kolmogorov_smirnov(w, c, ci_appr, counter_weight = NULL, nthread = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_kolmogorov_smirnov_+3A_w">w</code></td>
<td>
<p>A vector of observed continuous exposure variable.</p>
</td></tr>
<tr><td><code id="check_kolmogorov_smirnov_+3A_c">c</code></td>
<td>
<p>A data.frame of observed covariates variable.</p>
</td></tr>
<tr><td><code id="check_kolmogorov_smirnov_+3A_ci_appr">ci_appr</code></td>
<td>
<p>The causal inference approach.</p>
</td></tr>
<tr><td><code id="check_kolmogorov_smirnov_+3A_counter_weight">counter_weight</code></td>
<td>
<p>A weight vector in different situations. If the
matching approach is selected, it is an integer data.table of counters.
In the case of the weighting approach, it is weight data.table.</p>
</td></tr>
<tr><td><code id="check_kolmogorov_smirnov_+3A_nthread">nthread</code></td>
<td>
<p>The number of available threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output object is list including:
</p>

<ul>
<li><p> ks_stat
</p>
</li>
<li><p> maximal_val
</p>
</li>
<li><p> mean_val
</p>
</li>
<li><p> median_val
</p>
</li></ul>


<hr>
<h2 id='compile_pseudo_pop'>Compile pseudo population</h2><span id='topic+compile_pseudo_pop'></span>

<h3>Description</h3>

<p>Compiles pseudo population based on the original population and estimated GPS
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_pseudo_pop(
  data_obj,
  ci_appr,
  gps_density,
  bin_seq,
  exposure_col_name,
  nthread,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile_pseudo_pop_+3A_data_obj">data_obj</code></td>
<td>
<p>A S3 object including the following:
</p>

<ul>
<li><p> Original data set + GPS values
</p>
</li>
<li><p> e_gps_pred
</p>
</li>
<li><p> e_gps_std_pred
</p>
</li>
<li><p> w_resid
</p>
</li>
<li><p> gps_mx (min and max of gps)
</p>
</li>
<li><p> w_mx (min and max of w).
</p>
</li></ul>
</td></tr>
<tr><td><code id="compile_pseudo_pop_+3A_ci_appr">ci_appr</code></td>
<td>
<p>Causal inference approach.</p>
</td></tr>
<tr><td><code id="compile_pseudo_pop_+3A_gps_density">gps_density</code></td>
<td>
<p>Model type which is used for estimating GPS value,
including <code>normal</code> and <code>kernel</code>.</p>
</td></tr>
<tr><td><code id="compile_pseudo_pop_+3A_bin_seq">bin_seq</code></td>
<td>
<p>Sequence of w (treatment) to generate pseudo population. If
NULL is passed the default value will be used, which is
<code>seq(min(w)+delta_n/2,max(w), by=delta_n)</code>.</p>
</td></tr>
<tr><td><code id="compile_pseudo_pop_+3A_exposure_col_name">exposure_col_name</code></td>
<td>
<p>Exposure data column name.</p>
</td></tr>
<tr><td><code id="compile_pseudo_pop_+3A_nthread">nthread</code></td>
<td>
<p>An integer value that represents the number of threads to be
used by internal packages.</p>
</td></tr>
<tr><td><code id="compile_pseudo_pop_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>compile_pseudo_pop</code> returns the pseudo population data that is compiled based
on the selected causal inference approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(112)
m_d &lt;- generate_syn_data(sample_size = 100)
data_with_gps &lt;- estimate_gps(m_d[, c("id", "w")],
                              m_d[, c("id", "cf1","cf2","cf3","cf4","cf5","cf6")],
                              gps_density = "normal",
                              params = list(xgb_max_depth = c(3,4,5),
                                       xgb_nrounds=c(10,20,30,40,50,60)),
                              nthread = 1,
                              sl_lib = c("m_xgboost")
                             )


pd &lt;- compile_pseudo_pop(data_obj = data_with_gps,
                         ci_appr = "matching",
                         gps_density = "normal",
                         bin_seq = NULL,
                         exposure_col_name = c("w"),
                         nthread = 1,
                         dist_measure = "l1",
                         covar_bl_method = 'absolute',
                         covar_bl_trs = 0.1,
                         covar_bl_trs_type= "mean",
                         delta_n = 0.5,
                         scale = 1)

</code></pre>

<hr>
<h2 id='compute_closest_wgps'>Find the closest data in subset to the original data</h2><span id='topic+compute_closest_wgps'></span>

<h3>Description</h3>

<p>A function to compute the closest data in subset of data to the original data
based on two attributes: vector and scalar (vector of size one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_closest_wgps(a, b, c, d, sc, nthread)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_closest_wgps_+3A_a">a</code></td>
<td>
<p>Vector of the first attribute values for subset of data.</p>
</td></tr>
<tr><td><code id="compute_closest_wgps_+3A_b">b</code></td>
<td>
<p>Vector of the first attribute values for all data.</p>
</td></tr>
<tr><td><code id="compute_closest_wgps_+3A_c">c</code></td>
<td>
<p>Vector of the second attribute values for subset of data.</p>
</td></tr>
<tr><td><code id="compute_closest_wgps_+3A_d">d</code></td>
<td>
<p>Vector of size one for the second attribute value.</p>
</td></tr>
<tr><td><code id="compute_closest_wgps_+3A_sc">sc</code></td>
<td>
<p>Scale parameter to give weight for two mentioned measurements.</p>
</td></tr>
<tr><td><code id="compute_closest_wgps_+3A_nthread">nthread</code></td>
<td>
<p>Number of available cores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns index of subset data that is closest to the original data
sample.
</p>

<hr>
<h2 id='compute_density'>Approximate density based on another vector</h2><span id='topic+compute_density'></span>

<h3>Description</h3>

<p>A function to impute missing values based on density estimation of another
vector or itself after removing the missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_density(x0, x1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_density_+3A_x0">x0</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="compute_density_+3A_x1">x1</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns approximation of density value of vector x1 based on vector x0.
</p>

<hr>
<h2 id='compute_min_max'>Compute minimum and maximum</h2><span id='topic+compute_min_max'></span>

<h3>Description</h3>

<p>Function to compute minimum and maximum of the input vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_min_max(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_min_max_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of length 2. The first element is min value, and the second
element is max value.
</p>

<hr>
<h2 id='compute_outer'>Computes distance on all possible combinations</h2><span id='topic+compute_outer'></span>

<h3>Description</h3>

<p>Computes the distance between all combination of elements in two vector. a is
vector of size n, and b is a vector of size m, the result, will be a matrix
of size(n,m)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_outer(a, b, op)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_outer_+3A_a">a</code></td>
<td>
<p>first vector (size n)</p>
</td></tr>
<tr><td><code id="compute_outer_+3A_b">b</code></td>
<td>
<p>second vector (size m)</p>
</td></tr>
<tr><td><code id="compute_outer_+3A_op">op</code></td>
<td>
<p>operator (e.g., '-', '+', '/', ...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A n by m matrix that includes abs difference between elements of vector a and b.
</p>

<hr>
<h2 id='compute_resid'>Compute residual</h2><span id='topic+compute_resid'></span>

<h3>Description</h3>

<p>Function to compute residual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_resid(a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_resid_+3A_a">a</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="compute_resid_+3A_b">b</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="compute_resid_+3A_c">c</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a residual values.
</p>

<hr>
<h2 id='compute_risk'>Compute risk value</h2><span id='topic+compute_risk'></span>

<h3>Description</h3>

<p>Calculates the cross-validated risk for the optimal bandwidth selection in
kernel smoothing approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_risk(h, matched_Y, matched_w, matched_cw, x_eval, w_vals, kernel_appr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_risk_+3A_h">h</code></td>
<td>
<p>A scalar representing the bandwidth value.</p>
</td></tr>
<tr><td><code id="compute_risk_+3A_matched_y">matched_Y</code></td>
<td>
<p>A vector of outcome variable in the matched set.</p>
</td></tr>
<tr><td><code id="compute_risk_+3A_matched_w">matched_w</code></td>
<td>
<p>A vector of continuous exposure variable in the matched set.</p>
</td></tr>
<tr><td><code id="compute_risk_+3A_matched_cw">matched_cw</code></td>
<td>
<p>A vector of counter or weight variable in the matched set.</p>
</td></tr>
<tr><td><code id="compute_risk_+3A_w_vals">w_vals</code></td>
<td>
<p>A vector of values that you want to calculate the values of
the ERF at.</p>
</td></tr>
<tr><td><code id="compute_risk_+3A_kernel_appr">kernel_appr</code></td>
<td>
<p>Internal kernel approach. Available options are <code>locpol</code>
and <code>kernsmooth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a cross-validated risk value for the input bandwidth
</p>

<hr>
<h2 id='create_matching'>Create pseudo population using matching casual inference approach</h2><span id='topic+create_matching'></span>

<h3>Description</h3>

<p>Generates pseudo population based on matching casual inference method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_matching(
  data_obj,
  exposure_col_name,
  bin_seq = NULL,
  gps_density = "normal",
  nthread = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_matching_+3A_data_obj">data_obj</code></td>
<td>
<p>A list of elements. Including An original dataset as well
as helper vectors from estimating GPS. See <code><a href="#topic+compile_pseudo_pop">compile_pseudo_pop()</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="create_matching_+3A_bin_seq">bin_seq</code></td>
<td>
<p>Sequence of w (treatment) to generate pseudo population. If
NULL is passed the default value will be used, which is
<code>seq(min(w)+delta_n/2,max(w), by=delta_n)</code>.</p>
</td></tr>
<tr><td><code id="create_matching_+3A_gps_density">gps_density</code></td>
<td>
<p>Model type which is used for estimating GPS value, including
<code>normal</code> (default) and <code>kernel</code>.</p>
</td></tr>
<tr><td><code id="create_matching_+3A_nthread">nthread</code></td>
<td>
<p>Number of available cores.</p>
</td></tr>
<tr><td><code id="create_matching_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data.table of matched set.
</p>

<hr>
<h2 id='create_weighting'>Create pseudo population using weighting casual inference approach</h2><span id='topic+create_weighting'></span>

<h3>Description</h3>

<p>Generates pseudo population based on weighting casual inference method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_weighting(dataset, exposure_col_name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_weighting_+3A_dataset">dataset</code></td>
<td>
<p>The study data set.</p>
</td></tr>
<tr><td><code id="create_weighting_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data table which includes the following columns:
</p>

<ul>
<li><p> Y
</p>
</li>
<li><p> w
</p>
</li>
<li><p> gps
</p>
</li>
<li><p> counter
</p>
</li>
<li><p> row_index
</p>
</li>
<li><p> ipw
</p>
</li>
<li><p> covariates
</p>
</li></ul>


<hr>
<h2 id='estimate_gps'>Estimate generalized propensity score (GPS) values</h2><span id='topic+estimate_gps'></span>

<h3>Description</h3>

<p>Estimates GPS value for each observation using normal or kernel
approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_gps(
  w,
  c,
  gps_density = "normal",
  params = list(),
  sl_lib = c("m_xgboost"),
  nthread = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_gps_+3A_w">w</code></td>
<td>
<p>A data frame of observed continuous exposure variable. Including
<code>id</code> and <code>w</code> columns.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_c">c</code></td>
<td>
<p>A data frame of observed covariates variable. Also includes <code>id</code>
column.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_gps_density">gps_density</code></td>
<td>
<p>Model type which is used for estimating GPS value,
including <code>normal</code> (default) and <code>kernel</code>.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_params">params</code></td>
<td>
<p>Includes list of parameters that are used internally. Unrelated
parameters will be ignored.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_sl_lib">sl_lib</code></td>
<td>
<p>A vector of prediction algorithms.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_nthread">nthread</code></td>
<td>
<p>An integer value that represents the number threads to be used
in a shared memory system.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a S3 object. Including the following:
</p>

<ul>
<li> <p><code>dataset </code>: <code>id</code>, <code>w</code>, <code>gps</code>
</p>
</li>
<li><p> e_gps_pred
</p>
</li>
<li><p> e_gps_std_pred
</p>
</li>
<li><p> w_resid
</p>
</li>
<li><p> gps_mx (min and max of gps)
</p>
</li>
<li><p> w_mx (min and max of w).
</p>
</li>
<li><p> used_params
</p>
</li></ul>



<h3>Note</h3>

<p>If <code>internal.use</code> is set to be FALSE, only original data set + GPS will
be returned.
</p>
<p>The outcome variable is not used in estimating the GPS value. However, it is
used in compiling the data set with GPS values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m_d &lt;- generate_syn_data(sample_size = 100)
data_with_gps &lt;- estimate_gps(m_d[, c("id", "w")],
                              m_d[, c("id", "cf1", "cf2", "cf3",
                                      "cf4", "cf5", "cf6")],
                              gps_density = "normal",
                              params = list(xgb_max_depth = c(3,4,5),
                                       xgb_nrounds=c(10,20,30,40,50,60)),
                              nthread = 1,
                              sl_lib = c("m_xgboost")
                             )

</code></pre>

<hr>
<h2 id='estimate_hat_vals'>Estimate hat (fitted) values</h2><span id='topic+estimate_hat_vals'></span>

<h3>Description</h3>

<p>Estimates the fitted values based on bandwidth value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_hat_vals(bw, matched_w, w_vals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_hat_vals_+3A_bw">bw</code></td>
<td>
<p>The bandwidth value.</p>
</td></tr>
<tr><td><code id="estimate_hat_vals_+3A_matched_w">matched_w</code></td>
<td>
<p>A vector of continuous exposure variable in the matched set.</p>
</td></tr>
<tr><td><code id="estimate_hat_vals_+3A_w_vals">w_vals</code></td>
<td>
<p>A vector of values that you want to calculate the values of the
ERF at.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns fitted values, or the prediction made by the model for each observation.
</p>

<hr>
<h2 id='estimate_npmetric_erf'>Estimate smoothed exposure-response function (ERF) for pseudo population</h2><span id='topic+estimate_npmetric_erf'></span>

<h3>Description</h3>

<p>Estimate smoothed exposure-response function (ERF) for matched and weighted
data set using non-parametric models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_npmetric_erf(
  m_Y,
  m_w,
  counter_weight,
  bw_seq,
  w_vals,
  nthread,
  kernel_appr = "locpol"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_npmetric_erf_+3A_m_y">m_Y</code></td>
<td>
<p>A vector of outcome variable in the matched set.</p>
</td></tr>
<tr><td><code id="estimate_npmetric_erf_+3A_m_w">m_w</code></td>
<td>
<p>A vector of continuous exposure variable in the matched set.</p>
</td></tr>
<tr><td><code id="estimate_npmetric_erf_+3A_counter_weight">counter_weight</code></td>
<td>
<p>A vector of counter or weight variable in the matched
set.</p>
</td></tr>
<tr><td><code id="estimate_npmetric_erf_+3A_bw_seq">bw_seq</code></td>
<td>
<p>A vector of bandwidth values.</p>
</td></tr>
<tr><td><code id="estimate_npmetric_erf_+3A_w_vals">w_vals</code></td>
<td>
<p>A vector of values that you want to calculate the values of
the ERF at.</p>
</td></tr>
<tr><td><code id="estimate_npmetric_erf_+3A_nthread">nthread</code></td>
<td>
<p>The number of available cores.</p>
</td></tr>
<tr><td><code id="estimate_npmetric_erf_+3A_kernel_appr">kernel_appr</code></td>
<td>
<p>Internal kernel approach. Available options are <code>locpol</code>
and <code>kernsmooth</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate Functions Using Local Polynomial kernel regression.
</p>


<h3>Value</h3>

<p>The function returns a gpsm_erf object. The object includes the following
attributes:
</p>

<ul>
<li><p> params
</p>
</li>
<li><p> m_Y
</p>
</li>
<li><p> m_w
</p>
</li>
<li><p> bw_seq
</p>
</li>
<li><p> w_vals
</p>
</li>
<li><p> erf
</p>
</li>
<li><p> fcall
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(697)
m_d &lt;- generate_syn_data(sample_size = 200)
pseudo_pop &lt;- generate_pseudo_pop(m_d[, c("id", "w")],
                                  m_d[, c("id", "cf1","cf2","cf3",
                                        "cf4","cf5","cf6")],
                                  ci_appr = "matching",
                                  pred_model = "sl",
                                  sl_lib = c("m_xgboost"),
                                  params = list(xgb_nrounds=c(10,20,30),
                                   xgb_eta=c(0.1,0.2,0.3)),
                                  nthread = 1,
                                  covar_bl_method = "absolute",
                                  covar_bl_trs = 0.1,
                                  covar_bl_trs_type="mean",
                                  max_attempt = 1,
                                  dist_measure = "l1",
                                  delta_n = 1,
                                  scale = 0.5)

data &lt;- merge(m_d[, c("id", "Y")], pseudo_pop$pseudo_pop, by = "id")
erf_obj &lt;- estimate_npmetric_erf(data$Y,
                                 data$w,
                                 data$counter_weight,
                                 bw_seq=seq(0.2,2,0.2),
                                 w_vals = seq(2,20,0.5),
                                 nthread = 1)

</code></pre>

<hr>
<h2 id='estimate_pmetric_erf'>Estimate Parametric Exposure Response Function</h2><span id='topic+estimate_pmetric_erf'></span>

<h3>Description</h3>

<p>Estimate a constant effect size for matched and weighted data set using
parametric models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_pmetric_erf(formula, family, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_pmetric_erf_+3A_formula">formula</code></td>
<td>
<p>a vector of outcome variable in matched set.</p>
</td></tr>
<tr><td><code id="estimate_pmetric_erf_+3A_family">family</code></td>
<td>
<p>a description of the error distribution (see ?gnm)</p>
</td></tr>
<tr><td><code id="estimate_pmetric_erf_+3A_data">data</code></td>
<td>
<p>dataset that formula is build upon (Note that there should be a
<code>counter_weight</code> column in this data.)</p>
</td></tr>
<tr><td><code id="estimate_pmetric_erf_+3A_...">...</code></td>
<td>
<p>Additional parameters for further fine tuning the gnm model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method uses generalized nonlinear model (gnm) from gnm package.
</p>


<h3>Value</h3>

<p>returns an object of class gnm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m_d &lt;- generate_syn_data(sample_size = 100)
pseudo_pop &lt;- generate_pseudo_pop(m_d[, c("id", "w")],
                                  m_d[, c("id", "cf1","cf2","cf3",
                                          "cf4","cf5","cf6")],
                                  ci_appr = "matching",
                                  sl_lib = c("m_xgboost"),
                                  params = list(xgb_nrounds=c(10,20,30),
                                  xgb_eta=c(0.1,0.2,0.3)),
                                  nthread = 1,
                                  covar_bl_method = "absolute",
                                  covar_bl_trs = 0.1,
                                  covar_bl_trs_type= "mean",
                                  max_attempt = 1,
                                  dist_measure = "l1",
                                  delta_n = 1,
                                  scale = 0.5)
data &lt;- merge(m_d[, c("id", "Y")], pseudo_pop$pseudo_pop, by = "id")
outcome_m &lt;- estimate_pmetric_erf(formula = Y ~ w,
                                  family = gaussian,
                                  data = data)

</code></pre>

<hr>
<h2 id='estimate_semipmetric_erf'>Estimate semi-exposure-response function (semi-ERF).</h2><span id='topic+estimate_semipmetric_erf'></span>

<h3>Description</h3>

<p>Estimates the smoothed exposure-response function using a generalized
additive model with splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_semipmetric_erf(formula, family, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_semipmetric_erf_+3A_formula">formula</code></td>
<td>
<p>a vector of outcome variable in matched set.</p>
</td></tr>
<tr><td><code id="estimate_semipmetric_erf_+3A_family">family</code></td>
<td>
<p>a description of the error distribution (see ?gam).</p>
</td></tr>
<tr><td><code id="estimate_semipmetric_erf_+3A_data">data</code></td>
<td>
<p>dataset that formula is build upon Note that there should be a
<code>counter_weight</code> column in this data.).</p>
</td></tr>
<tr><td><code id="estimate_semipmetric_erf_+3A_...">...</code></td>
<td>
<p>Additional parameters for further fine tuning the gam model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This approach uses Generalized Additive Model (gam) using mgcv package.
</p>


<h3>Value</h3>

<p>returns an object of class gam
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m_d &lt;- generate_syn_data(sample_size = 100)
pseudo_pop &lt;- generate_pseudo_pop(m_d[, c("id", "w")],
                                  m_d[, c("id", "cf1","cf2","cf3",
                                          "cf4","cf5","cf6")],
                                  ci_appr = "matching",
                                  sl_lib = c("m_xgboost"),
                                  params = list(xgb_nrounds=c(10,20,30),
                                   xgb_eta=c(0.1,0.2,0.3)),
                                  nthread = 1,
                                  covar_bl_method = "absolute",
                                  covar_bl_trs = 0.1,
                                  covar_bl_trs_type = "mean",
                                  max_attempt = 1,
                                  dist_measure = "l1",
                                  delta_n = 1,
                                  scale = 0.5)
data &lt;- merge(m_d[, c("id", "Y")], pseudo_pop$pseudo_pop, by = "id")
outcome_m &lt;- estimate_semipmetric_erf (formula = Y ~ w,
                                       family = gaussian,
                                       data = data)


</code></pre>

<hr>
<h2 id='gen_wrap_sl_lib'>Generate customized wrapper for SuperLearner libraries</h2><span id='topic+gen_wrap_sl_lib'></span>

<h3>Description</h3>

<p>The function generates customized wrapper in order to have access to the
external libraries hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_wrap_sl_lib(lib_name, params, nthread)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_wrap_sl_lib_+3A_lib_name">lib_name</code></td>
<td>
<p>The library name (e.g., <code>m_xgboost</code>).</p>
</td></tr>
<tr><td><code id="gen_wrap_sl_lib_+3A_params">params</code></td>
<td>
<p>A list that includes key-values for different parameters. Only
relevant parameters will be extracted, others will be ignored.</p>
</td></tr>
<tr><td><code id="gen_wrap_sl_lib_+3A_nthread">nthread</code></td>
<td>
<p>Number of threads available to be used by external libraries
(in case they can use it).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of TRUE and best used parameters, if the modified library for
the given library is implemented; otherwise, it returns a list of FALSE.
This function is also called for side effects.
</p>

<hr>
<h2 id='generate_kernel'>Generate kernel function</h2><span id='topic+generate_kernel'></span>

<h3>Description</h3>

<p>Generates a kernel function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_kernel(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_kernel_+3A_t">t</code></td>
<td>
<p>A standardized vector (z-score)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>probability distribution
</p>

<hr>
<h2 id='generate_pseudo_pop'>Generate pseudo population</h2><span id='topic+generate_pseudo_pop'></span>

<h3>Description</h3>

<p>Generates pseudo population data set based on user-defined causal inference
approach. The function uses an adaptive approach to satisfies covariate
balance requirements. The function terminates either by satisfying covariate
balance or completing the requested number of iteration, whichever comes
first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_pseudo_pop(
  w,
  c,
  ci_appr,
  gps_density = "normal",
  use_cov_transform = FALSE,
  transformers = list("pow2", "pow3"),
  bin_seq = NULL,
  exposure_trim_qtls = c(0.01, 0.99),
  gps_trim_qtls = c(0, 1),
  params = list(),
  sl_lib = c("m_xgboost"),
  nthread = 1,
  include_original_data = FALSE,
  gps_obj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_pseudo_pop_+3A_w">w</code></td>
<td>
<p>A data.frame comprised of two columns: one contains the observed
exposure variable, and the other is labeled as 'id'. The column for the
outcome variable can be assigned any name as per your requirements.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_c">c</code></td>
<td>
<p>A data.frame of includes observed covariate variables. It should
also consist of a column named 'id'.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_ci_appr">ci_appr</code></td>
<td>
<p>The causal inference approach. Possible values are:
</p>

<ul>
<li><p> &quot;matching&quot;: Matching by GPS
</p>
</li>
<li><p> &quot;weighting&quot;: Weighting by GPS
</p>
</li></ul>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_gps_density">gps_density</code></td>
<td>
<p>Model type which is used for estimating GPS value,
including <code>normal</code> (default) and <code>kernel</code>.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_use_cov_transform">use_cov_transform</code></td>
<td>
<p>If TRUE, the function uses transformer to meet the
covariate balance.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformers. Each transformer should be a
unary function. You can pass name of customized function in the quotes.
Available transformers:
</p>

<ul>
<li><p> pow2: to the power of 2
</p>
</li>
<li><p> pow3: to the power of 3
</p>
</li></ul>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_bin_seq">bin_seq</code></td>
<td>
<p>Sequence of w (treatment) to generate pseudo population. If
NULL is passed the default value will be used, which is
<code>seq(min(w)+delta_n/2,max(w), by=delta_n)</code>.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_exposure_trim_qtls">exposure_trim_qtls</code></td>
<td>
<p>A numerical vector of two. Represents the trim quantile
level for exposure values. Both numbers should be in the range of [0,1] and
in increasing order (default: c(0.01, 0.99)).</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_gps_trim_qtls">gps_trim_qtls</code></td>
<td>
<p>A numerical vector of two. Represents the trim quantile
level for the gps values. Both numbers should be in the range of [0,1] and
in increasing order (default: c(0.0, 1.0)).</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_params">params</code></td>
<td>
<p>Includes list of params that is used internally. Unrelated
parameters will be ignored.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_sl_lib">sl_lib</code></td>
<td>
<p>A vector of prediction algorithms.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_nthread">nthread</code></td>
<td>
<p>An integer value that represents the number of threads to be
used by internal packages.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_include_original_data">include_original_data</code></td>
<td>
<p>If TRUE, includes the original data in the
outcome.</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_gps_obj">gps_obj</code></td>
<td>
<p>A gps object that is generated with <code>estimate_gps</code> function.
If it is provided, the number of iteration will forced to 1 (Default: NULL).</p>
</td></tr>
<tr><td><code id="generate_pseudo_pop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to different models.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Additional parameters</h4>



<h5>Causal Inference Approach (ci_appr)</h5>


<ul>
<li><p> if ci_appr = 'matching':
</p>

<ul>
<li> <p><em>dist_measure</em>: Matching function. Available options:
</p>

<ul>
<li><p> l1: Manhattan distance matching
</p>
</li></ul>

</li>
<li> <p><em>delta_n</em>: caliper parameter.
</p>
</li>
<li> <p><em>scale</em>: a specified scale parameter to control the relative weight that
is attributed to the distance measures of the exposure versus the GPS.
</p>
</li>
<li> <p><em>covar_bl_method</em>: covariate balance method. Available options:
</p>

<ul>
<li><p> 'absolute'
</p>
</li></ul>

</li>
<li> <p><em>covar_bl_trs</em>: covariate balance threshold
</p>
</li>
<li> <p><em>covar_bl_trs_type</em>: covariate balance type (mean, median, maximal)
</p>
</li>
<li> <p><em>max_attempt</em>: maximum number of attempt to satisfy covariate balance.
</p>
</li>
<li><p> See <code><a href="#topic+create_matching">create_matching()</a></code> for more details about the parameters and default
values.
</p>
</li></ul>

</li>
<li><p> if ci_appr = 'weighting':
</p>

<ul>
<li> <p><em>covar_bl_method</em>: Covariate balance method.
</p>
</li>
<li> <p><em>covar_bl_trs</em>: Covariate balance threshold
</p>
</li>
<li> <p><em>max_attempt</em>: Maximum number of attempt to satisfy covariate balance.
</p>
</li></ul>

</li></ul>





<h3>Value</h3>

<p>Returns a pseudo population (gpsm_pspop) object that is generated
or augmented based on the selected causal inference approach (ci_appr). The
object includes the following objects:
</p>

<ul>
<li><p> params
</p>

<ul>
<li><p> ci_appr
</p>
</li>
<li><p> params
</p>
</li></ul>

</li>
<li><p> pseudo_pop
</p>
</li>
<li><p> adjusted_corr_results
</p>
</li>
<li><p> original_corr_results
</p>
</li>
<li><p> best_gps_used_params
</p>
</li>
<li><p> effect size of generated pseudo population
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
m_d &lt;- generate_syn_data(sample_size = 100)
pseuoo_pop &lt;- generate_pseudo_pop(m_d[, c("id", "w")],
                                  m_d[, c("id", "cf1","cf2","cf3","cf4","cf5","cf6")],
                                  ci_appr = "matching",
                                  gps_density = "normal",
                                  bin_seq = NULL,
                                  expos_trim_qlts = c(0.01,0.99),
                                  gps_trim_qlts = c(0.01,0.99),
                                  use_cov_transform = FALSE,
                                  transformers = list(),
                                  params = list(xgb_nrounds=c(10,20,30),
                                                xgb_eta=c(0.1,0.2,0.3)),
                                  sl_lib = c("m_xgboost"),
                                  nthread = 1,
                                  covar_bl_method = "absolute",
                                  covar_bl_trs = 0.1,
                                  covar_bl_trs_type= "mean",
                                  max_attempt = 1,
                                  dist_measure = "l1",
                                  delta_n = 1,
                                  scale = 0.5)

</code></pre>

<hr>
<h2 id='generate_syn_data'>Generate synthetic data for the CausalGPS package</h2><span id='topic+generate_syn_data'></span>

<h3>Description</h3>

<p>Generates synthetic data set based on different GPS models and covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_syn_data(
  sample_size = 1000,
  outcome_sd = 10,
  gps_spec = 1,
  cova_spec = 1,
  vectorized_y = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_syn_data_+3A_sample_size">sample_size</code></td>
<td>
<p>A positive integer number that represents a number of data
samples.</p>
</td></tr>
<tr><td><code id="generate_syn_data_+3A_outcome_sd">outcome_sd</code></td>
<td>
<p>A positive double number that represents standard deviation
used to generate the outcome in the synthetic data set.</p>
</td></tr>
<tr><td><code id="generate_syn_data_+3A_gps_spec">gps_spec</code></td>
<td>
<p>A numerical integer values ranging from 1 to 7. The
complexity and form of the relationship between covariates and treatment
variables are determined by the <code>gps_spec</code>. Below, you will find a concise
definition for each of these values:
</p>

<ul>
<li> <p><em>gps_spec: 1</em>: The treatment is generated using a normal distributionMay 24, 2023
(<code>stats::rnorm</code>) and a linear function of covariates (cf1 to cf6).
</p>
</li>
<li> <p><em>gps_spec: 2</em>: The treatment is generated using a Student's
t-distribution (<code>stats::rt</code>) and a linear function of covariates, but is
also truncated to be within a specific range (-5 to 25).
</p>
</li>
<li> <p><em>gps_spec: 3</em>: The treatment includes a quadratic term for the third
covariate.
</p>
</li>
<li> <p><em>gps_spec: 4</em>: The treatment is calculated using an exponential
function within a fraction, creating logistic-like model.
</p>
</li>
<li> <p><em>gps_spec: 5</em>: The treatment also uses logistic-like model but with
different parameters.
</p>
</li>
<li> <p><em>gps_spec: 6</em>: The treatment is calculated using the natural logarithm
of the absolute value of a linear combination of the covariates.
</p>
</li>
<li> <p><em>gps_spec: 7</em>: The treatment is generated similarly to <code>gps_spec = 2</code>,
but without truncation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="generate_syn_data_+3A_cova_spec">cova_spec</code></td>
<td>
<p>A numerical value (1 or 2) to modify the covariates. It
determines how the covariates in the synthetic data set are transformed.
If <code>cova_spec</code> equals 2, the function applies non-linear transformation to
the covariates, which can add complexity to the relationships between
covariates and outcomes in the synthetic data. See the code for more details.</p>
</td></tr>
<tr><td><code id="generate_syn_data_+3A_vectorized_y">vectorized_y</code></td>
<td>
<p>A Boolean value indicates how Y internally is generated.
(Default = <code>FALSE</code>). This parameter is introduced for backward compatibility.
vectorized_y = <code>TRUE</code> performs better.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>synthetic_data</code>: The function returns a data.frame saved the
constructed synthetic data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(298)
s_data &lt;- generate_syn_data(sample_size = 100,
                            outcome_sd = 10,
                            gps_spec = 1,
                            cova_spec = 1)

</code></pre>

<hr>
<h2 id='get_logger'>Get Logger Settings</h2><span id='topic+get_logger'></span>

<h3>Description</h3>

<p>Returns current logger settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_logger()
</code></pre>


<h3>Value</h3>

<p>Returns a list that includes <strong>logger_file_path</strong> and <strong>logger_level</strong>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set_logger("mylogger.log", "INFO")
log_meta &lt;- get_logger()

</code></pre>

<hr>
<h2 id='log_system_info'>Log system information</h2><span id='topic+log_system_info'></span>

<h3>Description</h3>

<p>Logs system related information into the log file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_system_info()
</code></pre>


<h3>Value</h3>

<p>No return value. This function is called for side effects.
</p>

<hr>
<h2 id='matching_fn'>Match observations</h2><span id='topic+matching_fn'></span>

<h3>Description</h3>

<p>Matching function using L1 distance on single exposure level w
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matching_fn(
  w,
  dataset,
  exposure_col_name,
  e_gps_pred,
  e_gps_std_pred,
  w_resid,
  gps_mx,
  w_mx,
  dist_measure = "l1",
  gps_density = "normal",
  delta_n = 1,
  scale = 0.5,
  nthread = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matching_fn_+3A_w">w</code></td>
<td>
<p>the targeted single exposure levels.</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_dataset">dataset</code></td>
<td>
<p>a completed observational data frame or matrix containing
(Y, w, gps, counter, row_index, c).</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_e_gps_pred">e_gps_pred</code></td>
<td>
<p>a vector of predicted gps values obtained by Machine
learning methods.</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_e_gps_std_pred">e_gps_std_pred</code></td>
<td>
<p>a vector of predicted std of gps obtained by
Machine learning methods.</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_w_resid">w_resid</code></td>
<td>
<p>the standardized residuals for w.</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_gps_mx">gps_mx</code></td>
<td>
<p>a vector with length 2, includes min(gps), max(gps)</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_w_mx">w_mx</code></td>
<td>
<p>a vector with length 2, includes min(w), max(w).</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_gps_density">gps_density</code></td>
<td>
<p>Model type which is used for estimating GPS value, including
<code>normal</code> (default) and <code>kernel</code>.</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_delta_n">delta_n</code></td>
<td>
<p>a specified caliper parameter on the exposure (Default is 1).</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_scale">scale</code></td>
<td>
<p>a specified scale parameter to control the relative weight
that is attributed to
the distance measures of the exposure versus the GPS estimates
(Default is 0.5).</p>
</td></tr>
<tr><td><code id="matching_fn_+3A_nthread">nthread</code></td>
<td>
<p>Number of available cores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dp</code>: The function returns a data.table saved the matched points on
by single exposure
level w by the proposed GPS matching approaches.
</p>

<hr>
<h2 id='plot.gpsm_erf'>Extend generic plot functions for gpsm_erf class</h2><span id='topic+plot.gpsm_erf'></span>

<h3>Description</h3>

<p>A wrapper function to extend generic plot functions for gpsm_erf class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpsm_erf'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gpsm_erf_+3A_x">x</code></td>
<td>
<p>A gpsm_erf object.</p>
</td></tr>
<tr><td><code id="plot.gpsm_erf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object, invisibly. This function is called for side effects.
</p>

<hr>
<h2 id='plot.gpsm_pspop'>Extend generic plot functions for gpsm_erf class</h2><span id='topic+plot.gpsm_pspop'></span>

<h3>Description</h3>

<p>A wrapper function to extend generic plot functions for gpsm_erf class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpsm_pspop'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gpsm_pspop_+3A_x">x</code></td>
<td>
<p>A gpsm_erf object.</p>
</td></tr>
<tr><td><code id="plot.gpsm_pspop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the plot.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Additional parameters</h4>


<ul>
<li> <p><em>include_details</em>: If set to TRUE, the plot will include run details (Default = FALSE).
</p>
</li></ul>




<h3>Value</h3>

<p>Returns a ggplot2 object, invisibly. This function is called for side effects.
</p>

<hr>
<h2 id='preprocess_data'>Preprocess data</h2><span id='topic+preprocess_data'></span>

<h3>Description</h3>

<p>Preprocess data to isolate extra details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_data(w, c, trim_quantiles, exposure_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_data_+3A_w">w</code></td>
<td>
<p>A data.frame comprised of two columns: one contains the observed
exposure variable, and the other is labeled as 'id'. The column for the
outcome variable can be assigned any name as per your requirements.</p>
</td></tr>
<tr><td><code id="preprocess_data_+3A_c">c</code></td>
<td>
<p>A data.frame of includes observed covariate variables. It should
also consist of a column named 'id'.</p>
</td></tr>
<tr><td><code id="preprocess_data_+3A_exposure_col">exposure_col</code></td>
<td>
<p>Column name that is used for exposure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with preprocessed and original data.
</p>

<hr>
<h2 id='print.gpsm_erf'>Extend print function for gpsm_erf object</h2><span id='topic+print.gpsm_erf'></span>

<h3>Description</h3>

<p>Extend print function for gpsm_erf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpsm_erf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gpsm_erf_+3A_x">x</code></td>
<td>
<p>A gpsm_erf object.</p>
</td></tr>
<tr><td><code id="print.gpsm_erf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function is called for side effects.
</p>

<hr>
<h2 id='print.gpsm_pspop'>Extend print function for gpsm_pspop object</h2><span id='topic+print.gpsm_pspop'></span>

<h3>Description</h3>

<p>Extend print function for gpsm_pspop object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpsm_pspop'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gpsm_pspop_+3A_x">x</code></td>
<td>
<p>A gpsm_pspop object.</p>
</td></tr>
<tr><td><code id="print.gpsm_pspop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function is called for side effects.
</p>

<hr>
<h2 id='set_logger'>Set Logger Settings</h2><span id='topic+set_logger'></span>

<h3>Description</h3>

<p>Updates logger settings, including log level and location of the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_logger(logger_file_path = "CausalGPS.log", logger_level = "INFO")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_logger_+3A_logger_file_path">logger_file_path</code></td>
<td>
<p>A path (including file name) to log the messages.
(Default: CausalGPS.log)</p>
</td></tr>
<tr><td><code id="set_logger_+3A_logger_level">logger_level</code></td>
<td>
<p>The log level. Available levels include:
</p>

<ul>
<li><p> TRACE
</p>
</li>
<li><p> DEBUG
</p>
</li>
<li><p> INFO (Default)
</p>
</li>
<li><p> SUCCESS
</p>
</li>
<li><p> WARN
</p>
</li>
<li><p> ERROR
</p>
</li>
<li><p> FATAL
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function is called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set_logger("Debug")

</code></pre>

<hr>
<h2 id='smooth_erf'>Smooth exposure response function</h2><span id='topic+smooth_erf'></span>

<h3>Description</h3>

<p>Smooths exposure response function based on bandwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_erf(matched_Y, bw, matched_w, matched_cw, x_eval, kernel_appr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_erf_+3A_matched_y">matched_Y</code></td>
<td>
<p>A vector of the outcome variable in the matched set.</p>
</td></tr>
<tr><td><code id="smooth_erf_+3A_bw">bw</code></td>
<td>
<p>The bandwidth value.</p>
</td></tr>
<tr><td><code id="smooth_erf_+3A_matched_w">matched_w</code></td>
<td>
<p>A vector of continuous exposure variable in the matched set.</p>
</td></tr>
<tr><td><code id="smooth_erf_+3A_matched_cw">matched_cw</code></td>
<td>
<p>A vector of counter or weight variable in the matched set.</p>
</td></tr>
<tr><td><code id="smooth_erf_+3A_kernel_appr">kernel_appr</code></td>
<td>
<p>Internal kernel approach. Available options are <code>locpol</code>
and <code>kernsmooth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Smoothed value of ERF
</p>

<hr>
<h2 id='smooth_erf_kernsmooth'>Compute smoothed erf with kernsmooth approach</h2><span id='topic+smooth_erf_kernsmooth'></span>

<h3>Description</h3>

<p>Compute smoothed erf with kernsmooth approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_erf_kernsmooth(matched_Y, matched_w, matched_cw, x_eval, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_erf_kernsmooth_+3A_matched_y">matched_Y</code></td>
<td>
<p>A vector of outcome value.</p>
</td></tr>
<tr><td><code id="smooth_erf_kernsmooth_+3A_matched_w">matched_w</code></td>
<td>
<p>A vector of treatment value.</p>
</td></tr>
<tr><td><code id="smooth_erf_kernsmooth_+3A_matched_cw">matched_cw</code></td>
<td>
<p>A vector of weight or count.</p>
</td></tr>
<tr><td><code id="smooth_erf_kernsmooth_+3A_bw">bw</code></td>
<td>
<p>A scaler number indicating the bandwidth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of smoothed ERF.
</p>

<hr>
<h2 id='smooth_erf_locpol'>Compute smoothed erf with locpol approach</h2><span id='topic+smooth_erf_locpol'></span>

<h3>Description</h3>

<p>Compute smoothed erf with locpol approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_erf_locpol(matched_Y, matched_w, matched_cw, x_eval, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_erf_locpol_+3A_matched_y">matched_Y</code></td>
<td>
<p>A vector of outcome value.</p>
</td></tr>
<tr><td><code id="smooth_erf_locpol_+3A_matched_w">matched_w</code></td>
<td>
<p>A vector of treatment value.</p>
</td></tr>
<tr><td><code id="smooth_erf_locpol_+3A_matched_cw">matched_cw</code></td>
<td>
<p>A vector of weight or count.</p>
</td></tr>
<tr><td><code id="smooth_erf_locpol_+3A_bw">bw</code></td>
<td>
<p>A scaler number indicating the bandwidth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of smoothed ERF.
</p>

<hr>
<h2 id='summary.gpsm_erf'>print summary of gpsm_erf object</h2><span id='topic+summary.gpsm_erf'></span>

<h3>Description</h3>

<p>print summary of gpsm_erf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpsm_erf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gpsm_erf_+3A_object">object</code></td>
<td>
<p>A gpsm_erf object.</p>
</td></tr>
<tr><td><code id="summary.gpsm_erf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns summary of data
</p>

<hr>
<h2 id='summary.gpsm_pspop'>print summary of gpsm_pspop object</h2><span id='topic+summary.gpsm_pspop'></span>

<h3>Description</h3>

<p>print summary of gpsm_pspop object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpsm_pspop'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gpsm_pspop_+3A_object">object</code></td>
<td>
<p>A gpsm_pspop object.</p>
</td></tr>
<tr><td><code id="summary.gpsm_pspop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns summary of data
</p>

<hr>
<h2 id='synthetic_us_2010'>Public data set for air pollution and health studies,
case study: 2010 county-Level data set for the contiguous United States</h2><span id='topic+synthetic_us_2010'></span>

<h3>Description</h3>

<p>A dataset containing exposure, confounders, and outcome for causal inference
studies. The dataset is hosted on Harvard dataverse <a href="https://doi.org/10.7910/DVN/L7YF2G">doi:10.7910/DVN/L7YF2G</a>.
This dataset was produced from five different resources. Please see
<a href="https://github.com/NSAPH-Projects/synthetic_data/">https://github.com/NSAPH-Projects/synthetic_data/</a> for the data processing
pipelines. In the following
</p>
<p><strong>Exposure Data</strong>
</p>
<p>The exposure parameter is PM2.5. Di et al. (2019) provided
daily, and annual PM2.5 estimates at 1 km×1 km grid cells in the entire
United States. The data can be downloaded from Di et al. (2021). Features in
this category starts with <em>qd_</em> prefix.
</p>
<p><strong>Census Data</strong>
</p>
<p>The main reference for getting the census data is the United States Census
Bureau. There are numerous studies and surveys for different geographical
resolutions. We use 2010 county level American County Survey at the county
level (<code>acs5</code>). Features in this category starts with <em>cs_</em> prefix.
</p>
<p><strong>CDC Data</strong>
</p>
<p>The Centers for Disease Control and Prevention (CDC), provides the Behavioral
Risk Factor Surveillance System (Centers for Disease Control and Prevention
(2021)), which is the nation’s premier system of health-related telephone
surveys that collect state data about U.S. residents regarding their
health-related risk behaviors.
</p>
<p><strong>GridMET Data</strong>
</p>
<p>Climatology Lab at the University of California, Merced, provides the GridMET
data (Abatzoglou (2013)). The data set is daily surface meteorological data
covering the contiguous United States.
</p>
<p><strong>CMS Data</strong>
</p>
<p>The Centers for Medicare and Medicaid Services(CMS) provides synthetic data
at the county level for 2008-2010
(Centers for Medicare &amp; Medicaid Services (2021)).
</p>
<p>The definition of each variables are provided below. All data are collected
for 2010 and aggregated into the county level and in the contiguous United
States.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(synthetic_us_2010)
</code></pre>


<h3>Format</h3>

<p>A data frame with 3109 rows and 46 variables:
</p>

<dl>
<dt>qd_mean_pm25</dt><dd><p>Mean PM2.5 (microgram/m3)</p>
</dd>
<dt>cs_poverty</dt><dd><p>The proportion of below poverty level population among
65+ years old.</p>
</dd>
<dt>cs_hispanic</dt><dd><p>The proportion of Hispanic or Latino population
among 65+ years old.</p>
</dd>
<dt>cs_black</dt><dd><p>The proportion of Black or African American population
among 65+ years old.</p>
</dd>
<dt>cs_white</dt><dd><p>The proportion of White population among 65 years and over.</p>
</dd>
<dt>cs_native</dt><dd><p>The proportion of American Indian or Alaska native
population among 65 years and over.</p>
</dd>
<dt>cs_asian</dt><dd><p>The proportion of Asian population among 65 years and over.</p>
</dd>
<dt>cs_other</dt><dd><p>The proportion of other races population among 65 years and over.</p>
</dd>
<dt>cs_ed_below_highschool</dt><dd><p>The proportion of the population with below
high school level education among 65 years and over.</p>
</dd>
<dt>cs_household_income</dt><dd><p>Median Household income in the past 12 months
(in 2010 inflation-adjusted  dollars) where householder is 65 years and over.</p>
</dd>
<dt>cs_median_house_value</dt><dd><p>Median house value (USD)</p>
</dd>
<dt>cs_total_population</dt><dd><p>Total Population</p>
</dd>
<dt>cs_area</dt><dd><p>Area of each county (square miles)</p>
</dd>
<dt>cs_population_density</dt><dd><p>The number of the population in one square mile.</p>
</dd>
<dt>cdc_mean_bmi</dt><dd><p>Body Mass Index.</p>
</dd>
<dt>cdc_pct_cusmoker</dt><dd><p>The proportion of current smokers.</p>
</dd>
<dt>cdc_pct_sdsmoker</dt><dd><p>The proportion of some days smokers.</p>
</dd>
<dt>cdc_pct_fmsmoker</dt><dd><p>The proportion of former smokers.</p>
</dd>
<dt>cdc_pct_nvsmoker</dt><dd><p>The proportion of never smokers.</p>
</dd>
<dt>cdc_pct_nnsmoker</dt><dd><p>The proportion of not known smokers.</p>
</dd>
<dt>gmet_mean_tmmn</dt><dd><p>Annual mean of daily minimum temperature (K)</p>
</dd>
<dt>gmet_mean_summer_tmmn</dt><dd><p>The mean of daily minimum temperature during summer (K)</p>
</dd>
<dt>gmet_mean_winter_tmmn</dt><dd><p>The mean of daily minimum temperature during winter (K)</p>
</dd>
<dt>gmet_mean_tmmx</dt><dd><p>Annual mean of daily maximum temperature (K)</p>
</dd>
<dt>gmet_mean_summer_tmmx</dt><dd><p>The mean of daily maximum temperature during summer (K)</p>
</dd>
<dt>gmet_mean_winter_tmmx</dt><dd><p>The mean of daily maximum temperature during winter (K)</p>
</dd>
<dt>gmet_mean_rmn</dt><dd><p>Annual mean of daily minimum relative humidity (%)</p>
</dd>
<dt>gmet_mean_summer_rmn</dt><dd><p>The mean of daily minimum relative humidity during summer (%)</p>
</dd>
<dt>gmet_mean_winter_rmn</dt><dd><p>The mean of daily minimum relative humidity during winter (%)</p>
</dd>
<dt>gmet_mean_rmx</dt><dd><p>Annual mean of daily maximum relative humidity (%)</p>
</dd>
<dt>gmet_mean_summer_rmx</dt><dd><p>The mean of daily maximum relative humidity during summer (%)</p>
</dd>
<dt>gmet_mean_winter_rmx</dt><dd><p>The mean of daily maximum relative humidity during winter (%)</p>
</dd>
<dt>gmet_mean_sph</dt><dd><p>Annual mean of daily mean specific humidity (kg/kg)</p>
</dd>
<dt>gmet_mean_summer_sph</dt><dd><p>The mean of daily mean specific humidity during summer(kg/kg)</p>
</dd>
<dt>gmet_mean_winter_sph</dt><dd><p>The mean of daily mean specific humidity during winter(kg/kg)</p>
</dd>
<dt>cms_mortality_pct</dt><dd><p>The proportion of deceased patients.</p>
</dd>
<dt>cms_white_pct</dt><dd><p>The proportion of White patients.</p>
</dd>
<dt>cms_black_pct</dt><dd><p>The proportion of Black patients.</p>
</dd>
<dt>cms_hispanic_pct</dt><dd><p>The proportion of Hispanic patients.</p>
</dd>
<dt>cms_others_pct</dt><dd><p>The proportion of Other patients.</p>
</dd>
<dt>cms_female_pct</dt><dd><p>The proportion of Female patients.</p>
</dd>
<dt>region</dt><dd><p>The region that the county is located in.
</p>
<div class="sourceCode"><pre>  NORTHEAST=("NY","MA","PA","RI","NH","ME","VT","CT","NJ")
  SOUTH=("DC","VA","NC","WV","KY","SC","GA","FL","AL","TN","MS","AR","MD","DE","OK","TX","LA")
  MIDWEST=c("OH","IN","MI","IA","MO","WI","MN","SD","ND","IL","KS","NE")
  WEST=c("MT","CO","WY","ID","UT","NV","CA","OR","WA","AZ","NM")
</pre></div>
</dd>
<dt>FIPS</dt><dd><p>Federal Information Processing Standards, a unique ID for each
county.</p>
</dd>
<dt>NAME</dt><dd><p>County, State name.</p>
</dd>
<dt>STATE</dt><dd><p>State abbreviation.</p>
</dd>
<dt>STATE_CODE</dt><dd><p>State numerical code.</p>
</dd>
</dl>



<h3>References</h3>

<p>Abatzoglou, John T. 2013. “Development of Gridded Surface Meteorological
Data for Ecological Applications and Modelling.” International Journal of
Climatology 33 (1): 121–31. <a href="https://doi.org/10.1002/joc.3413">doi:10.1002/joc.3413</a>.
</p>
<p>Centers for Disease Control and Prevention. 2021. “Behavioral Risk
Factor Surveillance System.”
<a href="https://www.cdc.gov/brfss/annual_data/annual_2010.htm/">https://www.cdc.gov/brfss/annual_data/annual_2010.htm/</a>.
</p>
<p>Centers for Medicare &amp; Medicaid Services. 2021. “CMS 2008-2010 Data
Entrepreneurs’ Synthetic Public Use File (DE-SynPUF).”
<a href="https://www.cms.gov/data-research/statistics-trends-and-reports/medicare-claims-synthetic-public-use-files/cms-2008-2010-data-entrepreneurs-synthetic-public-use-file-de-synpuf">https://www.cms.gov/data-research/statistics-trends-and-reports/medicare-claims-synthetic-public-use-files/cms-2008-2010-data-entrepreneurs-synthetic-public-use-file-de-synpuf</a>.
</p>
<p>Di, Qian, Heresh Amini, Liuhua Shi, Itai Kloog, Rachel Silvern, James Kelly,
M Benjamin Sabath, et al. 2019. “An Ensemble-Based Model of Pm2. 5
Concentration Across the Contiguous United States with High Spatiotemporal
Resolution.” Environment International 130: 104909.
<a href="https://doi.org/10.1016/j.envint.2019.104909">doi:10.1016/j.envint.2019.104909</a>.
</p>
<p>Di, Qian, Yaguang Wei, Alexandra Shtein, Carolynne Hultquist, Xiaoshi Xing,
Heresh Amini, Liuhua Shi, et al. 2021. “Daily and Annual Pm2.5
Concentrations for the Contiguous United States, 1-Km Grids, V1
(2000 - 2016).” NASA Socioeconomic Data; Applications Center (SEDAC).
<a href="https://doi.org/10.7927/0rvr-4538">doi:10.7927/0rvr-4538</a>.
</p>

<hr>
<h2 id='train_it'>Generate Prediction Model</h2><span id='topic+train_it'></span>

<h3>Description</h3>

<p>Function to develop prediction model based on user's preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_it(target, input, sl_lib_internal = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_it_+3A_target">target</code></td>
<td>
<p>A vector of target data.</p>
</td></tr>
<tr><td><code id="train_it_+3A_input">input</code></td>
<td>
<p>A vector, matrix, or dataframe of input data.</p>
</td></tr>
<tr><td><code id="train_it_+3A_sl_lib_internal">sl_lib_internal</code></td>
<td>
<p>The internal library to be used by SuperLearner</p>
</td></tr>
<tr><td><code id="train_it_+3A_...">...</code></td>
<td>
<p>Model related parameters should be provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prediction model
</p>

<hr>
<h2 id='transform_it'>Transform data</h2><span id='topic+transform_it'></span>

<h3>Description</h3>

<p>Transforms data into new values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_it(c_name, c_val, transformer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_it_+3A_c_name">c_name</code></td>
<td>
<p>column (attribute) name.</p>
</td></tr>
<tr><td><code id="transform_it_+3A_c_val">c_val</code></td>
<td>
<p>column value</p>
</td></tr>
<tr><td><code id="transform_it_+3A_transformer">transformer</code></td>
<td>
<p>transformer function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns transformed data.frame.
</p>

<hr>
<h2 id='trim_gps'>Trim a gps object based on provided trimming quantiles</h2><span id='topic+trim_gps'></span>

<h3>Description</h3>

<p>Trims a gps object based on provided trimming quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_gps(gps_obj, trim_quantiles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_gps_+3A_gps_obj">gps_obj</code></td>
<td>
<p>A gps S3 object.</p>
</td></tr>
<tr><td><code id="trim_gps_+3A_trim_quantiles">trim_quantiles</code></td>
<td>
<p>A vector of trimming quantiles with two min and max
values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trimmed gps_obj
</p>

<hr>
<h2 id='w_fun'>Helper function</h2><span id='topic+w_fun'></span>

<h3>Description</h3>

<p>Helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_fun(bw, matched_w, w_vals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_fun_+3A_bw">bw</code></td>
<td>
<p>bandwidth value</p>
</td></tr>
<tr><td><code id="w_fun_+3A_matched_w">matched_w</code></td>
<td>
<p>a vector of continuous exposure variable in matched set.</p>
</td></tr>
<tr><td><code id="w_fun_+3A_w_vals">w_vals</code></td>
<td>
<p>a vector of values that you want to calculate the values of
the ERF at.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value (TODO)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
