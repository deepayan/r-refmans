<!DOCTYPE html><html><head><title>Help for package qtlnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qtlnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acyclic'><p>Acyclic graph example</p></a></li>
<li><a href='#bic.qtlnet'>
<p>Pre-compute BIC values for qtlnet sampling.</p></a></li>
<li><a href='#cyclica'><p>Cyclic graph (a) example</p></a></li>
<li><a href='#cyclicb'><p>Cyclic graph (b) example</p></a></li>
<li><a href='#cyclicc'><p>Cyclic graph (c) example</p></a></li>
<li><a href='#dist.qtlnet'><p>QTL network diagnostic routines</p></a></li>
<li><a href='#generate.qtl'><p>Generate QTLs ane phenotypes from cross object</p></a></li>
<li><a href='#glxnet'><p>Generate and graph Glx network</p></a></li>
<li><a href='#igraph.qtlnet'><p>qtlnet plot using igraph</p></a></li>
<li><a href='#loci.qtlnet'><p>QTL architecture per node as list</p></a></li>
<li><a href='#mcmc.qtlnet'><p>Sample genetic architecture and QTL network</p></a></li>
<li><a href='#parallel.qtlnet'><p>Code to parallelize use of qtlnet</p></a></li>
<li><a href='#parents.qtlnet'>
<p>Determine and group node-parent combinations.</p></a></li>
<li><a href='#Pscdbp'>
<p>Cross and qtlnet objects with Ghazalpour et al. (2006) data.</p>
Only 13 phenotypes are included.</a></li>
<li><a href='#qdg'><p> Produces a directed graph using QDG algorithm</p></a></li>
<li><a href='#qdg.perm.test'><p> Conduct permutation test for LOD score of edge direction on</p>
directed graph</a></li>
<li><a href='#qdg.sem'><p>Score directed graphs outputed by qdg using structural equation models (SEM)</p></a></li>
<li><a href='#subset.qtlnet'>
<p>Catenate or subset qtlnet object(s).</p></a></li>
<li><a href='#summary.qtlnet'><p>summary of model average network and posterior table</p></a></li>
<li><a href='#write.qtlnet'><p>write qtlnet as text file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Elias Chaibub Neto &lt;echaibub@hotmail.com&gt; and Brian S. yandell &lt;brian.yandell@wisc.edu&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Causal Inference of QTL Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to Simultaneously Infer Causal Graphs and Genetic Architecture.
  Includes acyclic and cyclic graphs for data from an experimental cross with a modest number (&lt;10) of phenotypes driven by
  a few genetic loci (QTL).
  Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
  Causal Graphical Models in Systems Genetics: a unified framework for joint inference of causal network and genetic architecture for correlated phenotypes.
  Annals of Applied Statistics 4: 320-339.
  &lt;<a href="https://doi.org/10.1214%2F09-AOAS288">doi:10.1214/09-AOAS288</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian S. Yandell &lt;brian.yandell@wisc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>qtl,igraph,sem,graph,pcalg, R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.wisc.edu/~yandell/sysgen">http://www.stat.wisc.edu/~yandell/sysgen</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-12 21:55:28 UTC; brianyandell</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-13 04:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acyclic'>Acyclic graph example</h2><span id='topic+acyclic'></span><span id='topic+acyclic.data'></span><span id='topic+acyclic.DG'></span><span id='topic+acyclic.qdg'></span><span id='topic+acyclic.qtl'></span>

<h3>Description</h3>

<p>We generate synthetic data (sample size 300) according to a DAG composed
by 100 nodes and 107 edges (exactly as in Figure 1). 
Each phenotype node is affected by three 
QTLs, and we allow only additive genetic effects. The QTLs for each phenotype are 
randomly
selected among 200 markers, with 10 markers unevenly distributed on each of 20 autosomes. 
We allowed different 
phenotypes to potentially share common QTLs. For each phenotype, 
the regression coefficients with other phenotypes are 
chosen uniformly between 0.5 and 1; 
QTL effects are chosen between 0.2 to 0.6; and residual standard deviations are chosen 
from 0.1 to 0.5. For each realization we apply the QDG algorithm to infer causal 
directions for the edges of the skeleton 
obtained by the PC-skeleton algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(acyclic)</code></pre>


<h3>Details</h3>

<p>For cyclic graphs, the output of the qdg function computes the 
log-likelihood 
up to the normalization constant (un-normalized log-likelihood). We can 
use the un-normalized 
log-likelihood to compare cyclic graphs with reversed directions (since they 
have the same normalization constant). However we cannot compare cyclic and 
acyclic graphs.
</p>


<h3>References</h3>

<p>Chaibub Neto et al. (2008) Inferring causal phenotype networks from 
segregating populations. Genetics 179: 1089-1100.</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+sim.cross">sim.cross</a></code>, 
<code><a href="qtl.html#topic+sim.geno">sim.geno</a></code>,
<code><a href="qtl.html#topic+sim.map">sim.map</a></code>, 
<code><a href="pcalg.html#topic+skeleton">skeleton</a></code>,
<code><a href="#topic+qdg">qdg</a></code>,
<code><a href="#topic+graph.qdg">graph.qdg</a></code>,
<code><a href="#topic+generate.qtl.pheno">generate.qtl.pheno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This reproduces Figure 1 exactly.
set.seed(3456789)

tmp &lt;- options(warn=-1)
acyclic.DG &lt;- randomDAG(n = 100, prob = 2 / 99)

options(tmp)

## Simulate cross object using R/qtl routines.
n.ind &lt;- 300
mymap &lt;- sim.map(len=rep(100,20), n.mar=10, eq.spacing=FALSE, include.x=FALSE)
mycross &lt;- sim.cross(map=mymap, n.ind=n.ind, type="f2")
summary(mycross)
mycross &lt;- sim.geno(mycross,n.draws=1)


## Produce 100 QTL at three markers apiece.
acyclic.qtl &lt;- generate.qtl.markers(cross=mycross,n.phe=100)

## Generate data from directed graph.
bp &lt;- runif(100,0.5,1)
stdev &lt;- runif(100,0.1,0.5)
bq &lt;- matrix(0,100,3)
bq[,1] &lt;- runif(100,0.2,0.4)
bq[,2] &lt;- bq[,1]+0.1
bq[,3] &lt;- bq[,2]+0.1
## Generate phenotypes.
acyclic.data &lt;- generate.qtl.pheno("acyclic", cross = mycross,
  bp = bp, bq = bq, stdev = stdev, allqtl = acyclic.qtl$allqtl)

acyclic.qdg &lt;- qdg(cross=acyclic.data, 
		phenotype.names=paste("y",1:100,sep=""),
		marker.names=acyclic.qtl$markers, 
		QTL=acyclic.qtl$allqtl, 
		alpha=0.005, 
		n.qdg.random.starts=1,
		skel.method="pcskel")
save(acyclic.DG, acyclic.qtl, acyclic.data, acyclic.qdg,
  file = "acyclic.RData", compress = TRUE)

data(acyclic)

dims &lt;- dim(acyclic.data$pheno)
SuffStat &lt;- list(C = cor(acyclic.data$pheno), n = dims[1])
pc &lt;- skeleton(SuffStat, gaussCItest, p = dims[2], alpha = 0.005)
summary(pc)

summary(graph.qdg(acyclic.qdg))
gr &lt;- graph.qdg(acyclic.qdg, include.qtl = FALSE)
plot(gr)

## End(Not run)
</code></pre>

<hr>
<h2 id='bic.qtlnet'>
Pre-compute BIC values for qtlnet sampling.
</h2><span id='topic+bic.qtlnet'></span><span id='topic+bic.join'></span><span id='topic+Pscdbp.bic'></span>

<h3>Description</h3>

<p>Pre-compute BIC values for qtlnet sampling to speed up MCMC sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bic.qtlnet(cross, pheno.col, threshold, addcov = NULL, intcov = NULL,
  max.parents = 3, parents, verbose = TRUE, ...)
bic.join(cross, pheno.col, ..., max.parents = 3)
data(Pscdbp.bic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bic.qtlnet_+3A_cross">cross</code></td>
<td>

<p>Object of class <code>cross</code>. See <code><a href="qtl.html#topic+read.cross">read.cross</a></code>.
</p>
</td></tr>
<tr><td><code id="bic.qtlnet_+3A_pheno.col">pheno.col</code></td>
<td>

<p>Phenotype identifiers from <code>cross</code> object. May be numeric, logical
or character.
</p>
</td></tr>
<tr><td><code id="bic.qtlnet_+3A_threshold">threshold</code></td>
<td>

<p>Scalar or list of thresholds, one per each node.
</p>
</td></tr>
<tr><td><code id="bic.qtlnet_+3A_addcov">addcov</code></td>
<td>

<p>Additive covariates for each phenotype (<code>NULL</code> if not used).
If entered as scalar or vector (same format as <code>pheno.col</code>),
then the same <code>addcov</code> is used for all
phenotypes. Altenatively, may be a list of additive covariate identifiers.
</p>
</td></tr>
<tr><td><code id="bic.qtlnet_+3A_intcov">intcov</code></td>
<td>

<p>Interactive covariates, entered in the same manner as <code>addcov</code>.
</p>
</td></tr>
<tr><td><code id="bic.qtlnet_+3A_max.parents">max.parents</code></td>
<td>

<p>Maximum number of parents per node. This reduces the complexity of
graphs and shortens run time. Probably best to consider values of 3-5.
</p>
</td></tr>
<tr><td><code id="bic.qtlnet_+3A_parents">parents</code></td>
<td>

<p>List containing all possible parents up to <code>max.parents</code> in
size. May be a subset
</p>
</td></tr>
<tr><td><code id="bic.qtlnet_+3A_verbose">verbose</code></td>
<td>

<p>Print iteration and number of models fit.
</p>
</td></tr>
<tr><td><code id="bic.qtlnet_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to internal routines. In the case of
<code>bic.join</code>, these are a list of objects produced by
<code>bic.qtlnet</code> (see example below).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most expensive part of calculations is running
<code><a href="qtl.html#topic+scanone">scanone</a></code> on each phenotype with parent phenotypes as
covariates. One strategy is to pre-compute the BIC contributions using a
cluster and save them for later use.
</p>
<p>We divide the job into three steps: 1) determine parents and divide into
reasonable sized groups; 2) compute BIC scores using scanone on a grid
of computers; 3) compute multiple MCMC runs on a grid of computers. See
the example for details.
</p>


<h3>Value</h3>

<p>Matrix with columns:
</p>
<table>
<tr><td><code>code</code></td>
<td>
<p>Binary code as decimal for the parents of a phenotype
node, excluding the phenotype. Value is between 0 (no parents) and
<code>2 ^ (length(pheno.col) - 1)</code>.</p>
</td></tr>
<tr><td><code>pheno.col</code></td>
<td>
<p>Phenotype column in reduced set, in range
<code>1:length(pheno.col)</code>.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>BIC score for phenotype conditional on parents (and covariates).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://dx.doi.org/10.1214/09-AOAS288">http://dx.doi.org/10.1214/09-AOAS288</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>,
<code><a href="#topic+parents.qtlnet">parents.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pheno.col &lt;- 1:13
max.parents &lt;- 12
size.qtlnet(pheno.col, max.parents)

## Not run: 
## Compute all phenotype/parent combinations.
## This shows how to break up into many smaller jobs.

#########################################
## STEP 1: Preparation. Fast. Needed in steps 2 and 3.

pheno.col &lt;- 1:13
max.parents &lt;- 12
threshold &lt;- 3.83

## Load cross object. Here we use internal object.
data(Pscdbp)
## or: load("Pscdbp.RData")
cross &lt;- Pscdbp
## or: cross &lt;- read.cross("Pscdbp.csv", "csv")

## Break up into groups to run on several machines.
## ~53 groups of ~1000, for a total of 53248 scanone runs.
parents &lt;- parents.qtlnet(pheno.col, max.parents)
groups &lt;- group.qtlnet(parents = parents, group.size = 1000)

## Save all relevant objects for later steps.
save(cross, pheno.col, max.parents, threshold, parents, groups,
  file = "Step1.RData", compress = TRUE)

#########################################
## STEP 2: Compute BIC scores. Parallelize.

## NB: Configuration of parallelization determined using Step 1 results.
## Load Step 1 computations.
load("Step1.RData")

## Parallelize this:
for(i in seq(nrow(groups)))
{
  ## Pre-compute BIC scores for selected parents.
  bic &lt;- bic.qtlnet(cross, pheno.col, threshold,
    max.parents = max.parents,
    parents = parents[seq(groups[i,1], groups[i,2])])

  save(bic, file = paste("bic", i, ".RData", sep = ""), compress = TRUE)
}

#########################################
## STEP 3: Sample Markov chain (MCMC). Parallelize.

## NB: n.runs sets the number of parallel runs.
n.runs &lt;- 100

## Load Step 1 computations.
load("Step1.RData")

## Read in saved BIC scores and combine into one object.
bic.group &lt;- list()
for(i in seq(nrow(groups)))
{
  load(paste("bic", i, ".RData", sep = ""))
  bic.group[[i]] &lt;- bic
}
saved.scores &lt;- bic.join(cross, pheno.col, bic.group)


## Parallelize this:
for(i in seq(n.runs))
{
  ## Run MCMC with randomized initial network.
  mcmc &lt;- mcmc.qtlnet(cross, pheno.col, threshold = threshold,
    max.parents = max.parents, saved.scores = saved.scores, init.edges = NULL)

  save(mcmc, file = paste("mcmc", i, ".RData", sep = ""), compress = TRUE)
}

#########################################
## STEP 4: Combine results for post-processing.

## NB: n.runs needed from Step 3.
n.runs &lt;- 100

## Combine outputs together.
outs.qtlnet &lt;- list()
for(i in seq(n.runs))
{
  load(paste("mcmc", i, ".RData", sep = ""))
  outs.qtlnet[[i]] &lt;- mcmc
}
out.qtlnet &lt;- c.qtlnet(outs.qtlnet)
summary(out.qtlnet)
print(out.qtlnet)

## End of parallel example.
#########################################

## End(Not run)

dim(Pscdbp.bic)
</code></pre>

<hr>
<h2 id='cyclica'>Cyclic graph (a) example</h2><span id='topic+cyclica.data'></span><span id='topic+cyclica.qtl'></span><span id='topic+cyclica'></span>

<h3>Description</h3>

<p>We use a Gibbs sampling scheme to generate a data-set with
200 individuals (according with cyclic graph (a)). Each phenotype is
affected by 3 QTLs. We fixed the regression coefficients at 0.5, 
error variances at 0.025 and the QTL effects at 0.2, 0.3 
and 0.4 for the three F2 genotypes. We used 
a burn-in of 2000 for the Gibbs sampler.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cyclica)</code></pre>


<h3>Details</h3>

<p>For cyclic graphs, the output of the qdg function
computes the log-likelihood up to the normalization constant
(un-normalized log-likelihood). We can use the un-normalized
log-likelihood to compare cyclic graphs with reversed
directions (they have the same normalization constant). However 
we cannot compare cyclic and acyclic graphs.</p>


<h3>References</h3>

<p>Chaibub Neto et al. (2008) Inferring causal phenotype networks from 
segregating populations. Genetics 179: 1089-1100.</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+sim.cross">sim.cross</a></code>, 
<code><a href="qtl.html#topic+sim.geno">sim.geno</a></code>,
<code><a href="qtl.html#topic+sim.map">sim.map</a></code>, 
<code><a href="pcalg.html#topic+skeleton">skeleton</a></code>,
<code><a href="#topic+qdg">qdg</a></code>,
<code><a href="#topic+graph.qdg">graph.qdg</a></code>,
<code><a href="#topic+generate.qtl.pheno">generate.qtl.pheno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bp &lt;- matrix(0, 6, 6)
bp[2,1] &lt;- bp[4,2] &lt;- bp[4,3] &lt;- bp[5,4] &lt;- bp[2,5] &lt;- bp[6,5] &lt;- 0.5
stdev &lt;- rep(0.025, 6)

## Use R/qtl routines to simulate.
set.seed(3456789)
mymap &lt;- sim.map(len = rep(100,20), n.mar = 10, eq.spacing = FALSE,
  include.x = FALSE)
mycross &lt;- sim.cross(map = mymap, n.ind = 200, type = "f2")
mycross &lt;- sim.geno(mycross, n.draws = 1)

cyclica.qtl &lt;- generate.qtl.markers(cross = mycross, n.phe = 6)
mygeno &lt;- pull.geno(mycross)[, unlist(cyclica.qtl$markers)]

cyclica.data &lt;- generate.qtl.pheno("cyclica", cross = mycross, burnin = 2000,
  bq = c(0.2,0.3,0.4), bp = bp, stdev = stdev, geno = mygeno)
save(cyclica.qtl, cyclica.data, file = "cyclica.RData", compress = TRUE)

data(cyclica)
out &lt;- qdg(cross=cyclica.data, 
		phenotype.names=paste("y",1:6,sep=""),
		marker.names=cyclica.qtl$markers, 
		QTL=cyclica.qtl$allqtl, 
		alpha=0.005, 
		n.qdg.random.starts=10,
		skel.method="pcskel")


gr &lt;- graph.qdg(out)
gr
plot(gr)

## End(Not run)
</code></pre>

<hr>
<h2 id='cyclicb'>Cyclic graph (b) example</h2><span id='topic+cyclicb.data'></span><span id='topic+cyclicb.qtl'></span><span id='topic+cyclicb'></span>

<h3>Description</h3>

<p>We use a Gibbs sampling scheme to generate a data-set with
200 individuals (according with cyclic graph (b)). Each phenotype is
affected by 3 QTLs. We fixed the regression coefficients at 0.5, 
error variances at 0.025 and the QTL effects at 0.2, 0.3 
and 0.4 for the three F2 genotypes. We used 
a burn-in of 2000 for the Gibbs sampler.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cyclicb)</code></pre>


<h3>Details</h3>

<p>For cyclic graphs, the output of the qdg function
computes the log-likelihood up to the normalization constant
(un-normalized log-likelihood). We can use the un-normalized 
log-likelihood to compare cyclic graphs with reversed directions 
(since they have the same normalization constant). However we cannot 
compare cyclic and acyclic graphs.</p>


<h3>References</h3>

<p>Chaibub Neto et al. (2008) Inferring causal phenotype networks from 
segregating populations. Genetics 179: 1089-1100.</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+sim.cross">sim.cross</a></code>, 
<code><a href="qtl.html#topic+sim.geno">sim.geno</a></code>,
<code><a href="qtl.html#topic+sim.map">sim.map</a></code>, 
<code><a href="pcalg.html#topic+skeleton">skeleton</a></code>,
<code><a href="#topic+qdg">qdg</a></code>,
<code><a href="#topic+graph.qdg">graph.qdg</a></code>,
<code><a href="#topic+generate.qtl.pheno">generate.qtl.pheno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bp &lt;- matrix(0, 6, 6)
bp[2,1] &lt;- bp[1,5] &lt;- bp[3,1] &lt;- bp[4,2] &lt;- bp[5,4] &lt;- bp[5,6] &lt;- bp[6,3] &lt;- 0.5
stdev &lt;- rep(0.025, 6)

## Use R/qtl routines to simulate.
set.seed(3456789)
mymap &lt;- sim.map(len = rep(100,20), n.mar = 10, eq.spacing = FALSE,
  include.x = FALSE)
mycross &lt;- sim.cross(map = mymap, n.ind = 200, type = "f2")
mycross &lt;- sim.geno(mycross, n.draws = 1)

cyclicb.qtl &lt;- generate.qtl.markers(cross = mycross, n.phe = 6)
mygeno &lt;- pull.geno(mycross)[, unlist(cyclicb.qtl$markers)]

cyclicb.data &lt;- generate.qtl.pheno("cyclicb", cross = mycross, burnin = 2000,
  bq = c(0.2,0.3,0.4), bp = bp, stdev = stdev, geno = mygeno)
save(cyclicb.qtl, cyclicb.data, file = "cyclicb.RData", compress = TRUE)

data(cyclicb)
out &lt;- qdg(cross=cyclicb.data, 
		phenotype.names=paste("y",1:6,sep=""),
		marker.names=cyclicb.qtl$markers, 
		QTL=cyclicb.qtl$allqtl, 
		alpha=0.005, 
		n.qdg.random.starts=10,
		skel.method="pcskel")

gr &lt;- graph.qdg(out)
gr
plot(gr)

## End(Not run)
</code></pre>

<hr>
<h2 id='cyclicc'>Cyclic graph (c) example</h2><span id='topic+cyclicc.data'></span><span id='topic+cyclicc.qtl'></span><span id='topic+cyclicc'></span>

<h3>Description</h3>

<p>We use a Gibbs sampling scheme to generate a data-set with 200
individuals (according with cyclic graph (c)). Each phenotype is
affected by 3 QTLs. We fixed the regression coefficients at 0.5, (except
for beta[5,2]=0.8) error variances at 0.025 and the QTL effects at 0.2,
0.3 and 0.4 for the three F2 genotypes. We used a burn-in of 2000 for 
the Gibbs sampler. This example illustrates that even though our method
cannot detect reciprocal interactions (e.g. between phenotypes 2 and 5
in cyclic graph (c)), it can still infer the stronger direction, that
is, the direction corresponding to the higher regression
coefficient. Since beta[5,2] is greater than beta[2,5], the QDG method
should infer the direction from 2 to 5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cyclicc)</code></pre>


<h3>Details</h3>

<p>For cyclic graphs, the output of the qdg function computes the 
log-likelihood up to the normalization constant (un-normalized log-likelihood). We can use the un-normalized log-likelihood to compare cyclic graphs with reversed directions (since they have the same normalization constant). However we 
cannot compare cyclic and acyclic graphs.</p>


<h3>References</h3>

<p>Chaibub Neto et al. (2008) Inferring causal phenotype networks from 
segregating populations. Genetics 179: 1089-1100.</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+sim.cross">sim.cross</a></code>, 
<code><a href="qtl.html#topic+sim.geno">sim.geno</a></code>,
<code><a href="qtl.html#topic+sim.map">sim.map</a></code>, 
<code><a href="pcalg.html#topic+skeleton">skeleton</a></code>,
<code><a href="#topic+qdg">qdg</a></code>,
<code><a href="#topic+graph.qdg">graph.qdg</a></code>,
<code><a href="#topic+generate.qtl.pheno">generate.qtl.pheno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bp &lt;- matrix(0, 6, 6)
bp[2,5] &lt;- 0.5
bp[5,2] &lt;- 0.8
bp[2,1] &lt;- bp[3,2] &lt;- bp[5,4] &lt;- bp[6,5] &lt;- 0.5
stdev &lt;- rep(0.025, 6)

## Use R/qtl routines to simulate map and genotypes.
set.seed(34567899)
mymap &lt;- sim.map(len = rep(100,20), n.mar = 10, eq.spacing = FALSE,
  include.x = FALSE)
mycross &lt;- sim.cross(map = mymap, n.ind = 200, type = "f2")
mycross &lt;- sim.geno(mycross, n.draws = 1)

## Use R/qdg routines to produce QTL sample and generate phenotypes.
cyclicc.qtl &lt;- generate.qtl.markers(cross = mycross, n.phe = 6)
mygeno &lt;- pull.geno(mycross)[, unlist(cyclicc.qtl$markers)]

cyclicc.data &lt;- generate.qtl.pheno("cyclicc", cross = mycross, burnin = 2000,
  bq = c(0.2,0.3,0.4), bp = bp, stdev = stdev, geno = mygeno)
save(cyclicc.qtl, cyclicc.data, file = "cyclicc.RData", compress = TRUE)

data(cyclicc)
out &lt;- qdg(cross=cyclicc.data, 
		phenotype.names=paste("y",1:6,sep=""),
		marker.names=cyclicc.qtl$markers, 
		QTL=cyclicc.qtl$allqtl, 
		alpha=0.005, 
		n.qdg.random.starts=1,
		skel.method="pcskel")

gr &lt;- graph.qdg(out)
plot(gr)

## End(Not run)
</code></pre>

<hr>
<h2 id='dist.qtlnet'>QTL network diagnostic routines</h2><span id='topic+dist.qtlnet'></span><span id='topic+edgematch.qtlnet'></span><span id='topic+mds.qtlnet'></span><span id='topic+plotbic.qtlnet'></span>

<h3>Description</h3>

<p>Various QTLnet diagnostic routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.qtlnet(qtlnet.object, min.prob = 0.9, method = "manhattan", cex = 5)
edgematch.qtlnet(qtlnet.object, min.prob = 0.9, method = "manhattan", cex = 5)
mds.qtlnet(qtlnet.object, min.prob = 0.9, method = "manhattan", cex = 5)
plotbic.qtlnet(x, ..., smooth = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.qtlnet_+3A_qtlnet.object">qtlnet.object</code>, <code id="dist.qtlnet_+3A_x">x</code></td>
<td>
<p>Object of class <code>qtlnet</code>.</p>
</td></tr>
<tr><td><code id="dist.qtlnet_+3A_min.prob">min.prob</code></td>
<td>
<p>Minimum probability to include edge in network.</p>
</td></tr>
<tr><td><code id="dist.qtlnet_+3A_method">method</code></td>
<td>
<p>Distance method to be used between columns of connection
matrix. Used by <code><a href="stats.html#topic+dist">dist</a></code>. (Only used for <code>mds.qtlnet</code>.)</p>
</td></tr>
<tr><td><code id="dist.qtlnet_+3A_cex">cex</code></td>
<td>
<p>Character expansion. (Only used for <code>mds.qtlnet</code>,
scaled by range of BIC values.)</p>
</td></tr>
<tr><td><code id="dist.qtlnet_+3A_smooth">smooth</code></td>
<td>
<p>Use <code><a href="stats.html#topic+lowess">lowess</a></code> smoother if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dist.qtlnet_+3A_...">...</code></td>
<td>
<p>Additional unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing, for each phenotype in the network, a character vector
of the QTL names as <code>chr@pos</code>, or pseudomarker name if
<code>chr.pos</code> is <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf">http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loci.qtlnet(Pscdbp.qtlnet)
</code></pre>

<hr>
<h2 id='generate.qtl'>Generate QTLs ane phenotypes from cross object</h2><span id='topic+generate.qtl.pheno'></span><span id='topic+generate.qtl.markers'></span>

<h3>Description</h3>

<p>Generate QTLs ane phenotype data for individual examples from cross. These are utility routines to
illustrate the examples. They are not meant for users per se.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.qtl.markers(cross, n.phe, nqtl = 3)
generate.qtl.pheno(name, cross, bp, bq, stdev, allqtl,
    burnin = 2000, geno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.qtl_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code>; see
<code><a href="qtl.html#topic+read.cross">read.cross</a></code></p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_name">name</code></td>
<td>
<p>character string for example name</p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_bp">bp</code></td>
<td>
<p>vector or matrix of coefficients for dependencies between
phenotypes; see cyclic and acyclic examples</p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_bq">bq</code></td>
<td>
<p>vector or matrix of coefficients for QTL effects on
phenotypes; see cyclic and acyclic examples</p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_stdev">stdev</code></td>
<td>
<p>vector of standard deviations per phenotype</p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_allqtl">allqtl</code></td>
<td>
<p>list of objects of class <code>qtl</code> produced by
<code>generate.qtl.sample</code></p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_burnin">burnin</code></td>
<td>
<p>number of burnin cycles for MCMC; default is 2000</p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_geno">geno</code></td>
<td>
<p>genotypes at markers, typically extracted with
<code><a href="qtl.html#topic+pull.geno">pull.geno</a></code></p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_n.phe">n.phe</code></td>
<td>
<p>number of phenotypes</p>
</td></tr>
<tr><td><code id="generate.qtl_+3A_nqtl">nqtl</code></td>
<td>
<p>number of QTL</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+acyclic">acyclic</a></code>, 
<code><a href="#topic+cyclica">cyclica</a></code>, 
<code><a href="#topic+cyclicb">cyclicb</a></code>, 
<code><a href="#topic+cyclicc">cyclicc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
example(acyclic)
example(cyclica)
example(cyclicb)
example(cyclicc)

## End(Not run)
</code></pre>

<hr>
<h2 id='glxnet'>Generate and graph Glx network</h2><span id='topic+glxnet'></span><span id='topic+glxnet.cross'></span><span id='topic+glxnet.qtl'></span><span id='topic+glxnet.qdg'></span>

<h3>Description</h3>

<p>This is the Glx network reported in Chaibub Neto et al 2008 and in Ferrara et
al 2008. Age was used as an additive covariate and we allowed for sex by 
genotype interaction. The network differs slightly from the published network 
due to improved code.
</p>


<h3>References</h3>

<p>Chaibub Neto et al. 2008 Inferring causal phenotype networks 
from segregating populations. Genetics 179: 1089-1100.
</p>
<p>Ferrara et al. 2008 Genetic networks of liver metabolism revealed by 
integration of metabolomic and transcriptomic profiling. PLoS Genetics 4:
e1000034. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qdg">qdg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(glxnet)
glxnet.cross &lt;- calc.genoprob(glxnet.cross)
set.seed(1234)
glxnet.cross &lt;- sim.geno(glxnet.cross)

n.node &lt;- nphe(glxnet.cross) - 2 ## Last two are age and sex.
markers &lt;- glxnet.qtl &lt;- vector("list", n.node)
for(i in 1:n.node) {
    ac &lt;- model.matrix(~ age + sex, glxnet.cross$pheno)[, -1]
    ss &lt;- summary(scanone(glxnet.cross, pheno.col = i,
                          addcovar = ac, intcovar = ac[,2]),
                  threshold = 2.999)
    glxnet.qtl[[i]] &lt;- makeqtl(glxnet.cross, chr = ss$chr, pos = ss$pos)
    markers[[i]] &lt;- find.marker(glxnet.cross, chr = ss$chr, pos = ss$pos)
}
names(glxnet.qtl) &lt;- names(markers) &lt;- names(glxnet.cross$pheno)[seq(n.node)]

glxnet.qdg &lt;- qdg(cross=glxnet.cross, 
		phenotype.names = names(glxnet.cross$pheno[,seq(n.node)]), 
		marker.names = markers, 
		QTL = glxnet.qtl, 
		alpha = 0.05, 
		n.qdg.random.starts=10, 
		addcov="age", 
		intcov="sex", 
		skel.method="udgskel",
		udg.order=6)
glxnet.qdg

## Not run: 
gr &lt;- graph.qdg(glxnet.qdg)
plot(gr)

## Or use tkplot().
glxnet.cross &lt;- clean(glxnet.cross)
save(glxnet.cross, glxnet.qdg, glxnet.qtl, file = "glxnet.RData", compress = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='igraph.qtlnet'>qtlnet plot using igraph</h2><span id='topic+igraph.qtlnet'></span><span id='topic+graph.qtlnet'></span><span id='topic+plot.qtlnet'></span>

<h3>Description</h3>

<p>Plot inferred causal network using igraph package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.qtlnet(x, edges, loci.list,
  pheno.color = "green", qtl.color = "red", vertex.color,
  include.qtl = TRUE, ...)
## S3 method for class 'qtlnet'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph.qtlnet_+3A_x">x</code></td>
<td>

<p>Object of class <code>qtlnet</code>.
</p>
</td></tr>
<tr><td><code id="igraph.qtlnet_+3A_edges">edges</code></td>
<td>

<p>Data frame with first two columns being <code>cause</code> and <code>effect</code>
directed phenotype pairs. Typically determined as <code>averaged.net</code>
element from call to <code><a href="#topic+summary.qtlnet">summary.qtlnet</a></code>.
</p>
</td></tr>
<tr><td><code id="igraph.qtlnet_+3A_loci.list">loci.list</code></td>
<td>

<p>List of character names of loci by phenotype. Typically determined by
call to <code><a href="#topic+loci.qtlnet">loci.qtlnet</a></code>.
</p>
</td></tr>
<tr><td><code id="igraph.qtlnet_+3A_pheno.color">pheno.color</code>, <code id="igraph.qtlnet_+3A_qtl.color">qtl.color</code></td>
<td>

<p>Name of color to use for phenotypes and QTLs, respectively.
</p>
</td></tr>
<tr><td><code id="igraph.qtlnet_+3A_vertex.color">vertex.color</code></td>
<td>

<p>Vertex colors in order of pheno-pheno edged augmented by
<code>loci.list</code>, by default determined by <code>pheno.color</code> and <code>qtl.color</code>.
</p>
</td></tr>
<tr><td><code id="igraph.qtlnet_+3A_include.qtl">include.qtl</code></td>
<td>

<p>Include QTL in graph if <code>TRUE</code> and <code>loci.list</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="igraph.qtlnet_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to called routines.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the igraph package to create graph objects. These can be exported
to a variety of other modern graphics packages. <code>graph.qtlnet</code> is
synonymous with <code>igraph.qtlnet</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>graph</code> created using
<code><a href="igraph.html#topic+graph.data.frame">graph.data.frame</a></code>.
</p>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf">http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.qtlnet">summary.qtlnet</a></code>,
<code><a href="#topic+loci.qtlnet">loci.qtlnet</a></code>,
<code><a href="igraph.html#topic+graph.data.frame">graph.data.frame</a></code>,
<code><a href="igraph.html#topic+tkplot">tkplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Pscdbp.graph &lt;- igraph.qtlnet(Pscdbp.qtlnet)
Pscdbp.graph
## Not run: 
tkplot(Pscdbp.graph)

## End(Not run)
</code></pre>

<hr>
<h2 id='loci.qtlnet'>QTL architecture per node as list</h2><span id='topic+loci.qtlnet'></span><span id='topic+est.qtlnet'></span>

<h3>Description</h3>

<p>Determines QTL that affect each phenotype conditional on the model-averaged
network and on covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loci.qtlnet(qtlnet.object, chr.pos = TRUE, merge.qtl = 10, ...)
est.qtlnet(qtlnet.object, ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loci.qtlnet_+3A_qtlnet.object">qtlnet.object</code></td>
<td>
<p>Object of class <code>qtlnet</code>.</p>
</td></tr>
<tr><td><code id="loci.qtlnet_+3A_chr.pos">chr.pos</code></td>
<td>
<p>Include chromsome and position if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="loci.qtlnet_+3A_merge.qtl">merge.qtl</code></td>
<td>
<p>Merge QTL within <code>merge.qtl</code> cM of the mean QTL
per chromosome across all nodes. No merge if 0 or less. This can
reduce the number of QTL nodes to one per chr.</p>
</td></tr>
<tr><td><code id="loci.qtlnet_+3A_...">...</code></td>
<td>
<p>Additional unused arguments.</p>
</td></tr>
<tr><td><code id="loci.qtlnet_+3A_verbose">verbose</code></td>
<td>
<p>verbose output if <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing, for each phenotype in the network, a character vector
of the QTL names as <code>chr@pos</code>, or pseudomarker name if
<code>chr.pos</code> is <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf">http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loci.qtlnet(Pscdbp.qtlnet)
</code></pre>

<hr>
<h2 id='mcmc.qtlnet'>Sample genetic architecture and QTL network</h2><span id='topic+qtlnet'></span><span id='topic+mcmc.qtlnet'></span><span id='topic+init.qtlnet'></span>

<h3>Description</h3>

<p>Use MCMC to alternatively sample genetic architecture and QTL network as
directed acyclic graphs (DAGs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.qtlnet(cross, pheno.col, threshold, addcov = NULL, intcov = NULL,
  nSamples = 1000, thinning = 1, max.parents = 3, M0 = NULL,
  burnin = 0.1, method = "hk", random.seed = NULL, init.edges = 0,
  saved.scores = NULL, rev.method = c("nbhd", "node.edge", "single"),
  verbose = FALSE, ...)
init.qtlnet(pheno.col, max.parents, init.edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.qtlnet_+3A_cross">cross</code></td>
<td>

<p>Object of class <code>cross</code>. See <code><a href="qtl.html#topic+read.cross">read.cross</a></code>.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_pheno.col">pheno.col</code></td>
<td>

<p>Phenotype identifiers from <code>cross</code> object. May be numeric, logical
or character.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_threshold">threshold</code></td>
<td>

<p>Scalar or list of thresholds, one per each node.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_addcov">addcov</code></td>
<td>

<p>Additive covariates for each phenotype (<code>NULL</code> if not used).
If entered as scalar or vector (same format as <code>pheno.col</code>),
then the same <code>addcov</code> is used for all
phenotypes. Altenatively, may be a list of additive covariate identifiers.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_intcov">intcov</code></td>
<td>

<p>Interactive covariates, entered in the same manner as <code>addcov</code>.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_nsamples">nSamples</code></td>
<td>

<p>Number of samples to record.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_thinning">thinning</code></td>
<td>

<p>Thinning rate. Number of MCMC samples is <code>nSamples*thinning</code>.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_max.parents">max.parents</code></td>
<td>

<p>Maximum number of parents to a node. This reduces the complexity of
graphs and shortens run time. Probably best to consider values of 3-5.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_m0">M0</code></td>
<td>

<p>Matrix of 0s and 1s with initial directed graph of row-&gt;col if (row,col)
entry is 1. Cycles are forbidden (e.g. 1s on diagonal or symmetric 1s
across diagonal). Default (if <code>NULL</code>) is sampled by a call to <code>init.qtlnet</code>;
all 0s if <code>init.edges</code> = 0 (default).
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_burnin">burnin</code></td>
<td>

<p>Proportion of MCMC samples to use as burnin. Default is 0.1 if burnin
is <code>TRUE</code>. Must be between 0 and 1.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_method">method</code></td>
<td>

<p>Model fitting method for <code><a href="qtl.html#topic+scanone">scanone</a></code>.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_random.seed">random.seed</code></td>
<td>

<p>Initialization seed for random number generator. Must be <code>NULL</code>
(no reset) or positive numeric. Used in <code><a href="base.html#topic+Random">Random</a></code>.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_init.edges">init.edges</code></td>
<td>

<p>Initial number of edges for <code>M0</code>, to be sampled using
<code>{init.qtlnet}</code>. Chosen uniformly from 0 to the number of
possible edges if set to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_saved.scores">saved.scores</code></td>
<td>

<p>Updated scores, typically pre-computed by
<code><a href="#topic+bic.qtlnet">bic.qtlnet</a></code>.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_rev.method">rev.method</code></td>
<td>

<p>Method to use for reversing edges. See details.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_verbose">verbose</code></td>
<td>

<p>Print iteration and number of models fit.
</p>
</td></tr>
<tr><td><code id="mcmc.qtlnet_+3A_...">...</code></td>
<td>

<p>Additional arguments. Advanced users may want to supply pre-computed
<code>saved.scores</code> to speed up calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models are coded compactly as <code>(1)(2|1)(3|1,2,4,5)(4|2)(5|2)</code>. Each
parenthetical entry is a of form <code>(node|parents)</code>; these each
require a model fit, for now with <code><a href="qtl.html#topic+scanone">scanone</a></code>.
</p>
<p>The <code><a href="qtl.html#topic+scanone">scanone</a></code> routine is run on multiple
phenotypes in the network that could all have the same parents. For
instance, for 5 phenotypes, if <code>(1|2,4)</code> is sampled, then do
scanone of this model as well as <code>(3|2,4)</code> and <code>(5|2,4)</code>.
Setting the hidden parameter <code>scan.parents</code> to a value smaller
than <code>length(pheno.col) - 1</code> (default) disallows multiple
trait scanning with more than that number of parents.
</p>
<p>The <code>saved.scores</code> parameter can greatly reduce MCMC run time,
by supplying pre-computed BIC scores. See
<code><a href="#topic+bic.qtlnet">bic.qtlnet</a></code>. Another option is to capture
<code>saved.scores</code> from a previous <code>mcmc.qtlnet</code> run with the
same phenotypes (and covariates). Caution is advised as only a modest
amount of checking can be done.
</p>
<p>The <code>init.qtlnet</code> routine can be used to randomly find an initial
causal network <code>M0</code> with up to <code>init.edges</code> edges.
</p>
<p>MCMC updates include delete, add or reverse edge direction. The early
version of this method only considered the edge on its own
(<code>rev.method = "single"</code>), while the neighborhood method
(<code>rev.method = "nbhd"</code>) uses the update
</p>


<h3>Value</h3>

<p>List of class <code>qtlnet</code>
</p>
<table>
<tr><td><code>post.model</code></td>
<td>
<p>Model code (see details).</p>
</td></tr>
<tr><td><code>post.bic</code></td>
<td>
<p>Posterior BIC</p>
</td></tr>
<tr><td><code>Mav</code></td>
<td>
<p>Model average of <code>M</code> across MCMC samples.</p>
</td></tr>
<tr><td><code>freq.accept</code></td>
<td>
<p>Frequency of acceptance M-H proposals.</p>
</td></tr>
<tr><td><code>saved.scores</code></td>
<td>
<p>Saved LOD score for each phenotype and all
possible sets of the other phenotypes as parent nodes.</p>
</td></tr>
<tr><td><code>all.bic</code></td>
<td>
</td></tr>
<tr><td><code>cross</code></td>
<td>
<p>The <code>cross</code> object with calculated genotype
probabilities.</p>
</td></tr>
</table>
<p>In addition, a number of attributes are recorded:
</p>
<table>
<tr><td><code>M0</code></td>
<td>
<p>Initial network matrix.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>threshold list</p>
</td></tr>
<tr><td><code>nSamples</code></td>
<td>
<p>Number of samples saved</p>
</td></tr>
<tr><td><code>thinning</code></td>
<td>
<p>Thinning rate</p>
</td></tr>
<tr><td><code>pheno.col</code></td>
<td>
<p>Phenotype columns.</p>
</td></tr>
<tr><td><code>pheno.names</code></td>
<td>
<p>Phenotype names</p>
</td></tr>
<tr><td><code>addcov</code></td>
<td>
<p>Additive covariate columns.</p>
</td></tr>
<tr><td><code>intcov</code></td>
<td>
<p>Interactive covariate columns.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>Burnin proportion</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method used for <code><a href="qtl.html#topic+scanone">scanone</a></code>.</p>
</td></tr>
<tr><td><code>random.seed</code></td>
<td>
<p>Initial random number generator seed.</p>
</td></tr>
<tr><td><code>random.kind</code></td>
<td>
<p>Random number generator kind from <code><a href="base.html#topic+Random">Random</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chiabub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal graphical models in systems genetics: a unified framework
for joint inference of causal network and genetic archicecture
for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://dx.doi.org/10.1214/09-AOAS288">http://dx.doi.org/10.1214/09-AOAS288</a>
</p>
<p>Grzegorczyk and Husmeier (2008) Improving the structure MCMC sampler
for Bayesian networks by introducing a new edge reversal move.
Mach Learn 71: 265-305.
<a href="http://dx.doi.org/10.1007/s10994-008-5057-7">http://dx.doi.org/10.1007/s10994-008-5057-7</a>
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+read.cross">read.cross</a></code>,  <code><a href="qtl.html#topic+scanone">scanone</a></code>,
<code><a href="base.html#topic+Random">Random</a></code>,
<code><a href="#topic+bic.qtlnet">bic.qtlnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pscdbp)
## Not run: 
  ## Run of subset of traits. Still takes some time.
  Pscdbp.qtlnet &lt;- mcmc.qtlnet(Pscdbp, pheno.col = c(1,2,4,5,6),
                               threshold = 3.83,
                               nSamples = 1000, thinning = 20, 
                               random.seed = 92387475, verbose = TRUE)
  save(Pscdbp.qtlnet, file = "Pscdbp.qtlnet.RData", compress = TRUE)

## End(Not run)
data(Pscdbp.qtlnet)

## Not run: 
  out.qtlnet &lt;- mcmc.qtlnet(Pscdbp, pheno.col = 1:13,
                            threshold = 3.83,
                            nSamples = 1000, thinning = 20, 
                            random.seed = 92387475, verbose = TRUE,
                            saved.scores = Pscdbp.bic)

## End(Not run)
</code></pre>

<hr>
<h2 id='parallel.qtlnet'>Code to parallelize use of qtlnet</h2><span id='topic+parallel.qtlnet'></span>

<h3>Description</h3>

<p>This routine calls one of four phases in a parallelized version of qtlnet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel.qtlnet(phase, index = 1, ..., dirpath = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel.qtlnet_+3A_phase">phase</code></td>
<td>

<p>Phase of parallelization as number 1 through 4. See details.
</p>
</td></tr>
<tr><td><code id="parallel.qtlnet_+3A_index">index</code></td>
<td>

<p>Index for phase. Used in phases 2 and 4, and for error codes saved
in <code>RESULT.phase.index</code> file.
</p>
</td></tr>
<tr><td><code id="parallel.qtlnet_+3A_...">...</code></td>
<td>

<p>Additional arguments for phases. See details.
</p>
</td></tr>
<tr><td><code id="parallel.qtlnet_+3A_dirpath">dirpath</code></td>
<td>

<p>Character string for directory were user can read and write files. When
submitting to a cluster, this should remain the default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="http://www.stat.wisc.edu/~yandell/sysgen/qtlnet">http://www.stat.wisc.edu/~yandell/sysgen/qtlnet</a> for details of
implementation in progress. The plan is to run qtlnet via Condor
(<a href="https://research.cs.wisc.edu/htcondor/">https://research.cs.wisc.edu/htcondor/</a>) to scale up to larger networks, say up to
100 nodes. Most important information is passed in files. Phase 1
imports arguments from the <code>params.txt</code> file, which must have
parse-able assignments to the arguments of
<code>qtlnet:::qtlnet.phase1</code>. This first phase produces file
<code>Phase1.RData</code>, which included objects used by all other phases.
</p>
<p>Phase 1 also creates file <code>groups.txt</code>, which for each line has
begin and end indices for the <code>parents</code> that would result from a
call to <code><a href="#topic+parents.qtlnet">parents.qtlnet</a></code>. Phase 2 should be run the same
number of times as the number of lines in file <code>groups.txt</code>. Each
run produces a <code>bicN.RData</code> file containing BIC computations. These
computations are aggregated in Phase 3 to create <code>Phase3.RData</code>,
which contains the <code>saved.scores</code> used for
<code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code> runs in Phase 4, which each produce an
<code>mcmcN.RData</code> file. The number of runs of Phase 4
is an argument <code>nruns</code> stored in the <code>params.txt</code> file
processed in Phase 1. Finally, Phase 5 aggregates the MCMC results from
multiple independent runs into one <code>qtlnet</code> object.
</p>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf">http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf</a>
</p>
<p><a href="http://www.stat.wisc.edu/~yandell/sysgen/qtlnet">http://www.stat.wisc.edu/~yandell/sysgen/qtlnet</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>,
<code><a href="#topic+bic.qtlnet">bic.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    parallel.qtlnet("/u/y/a/yandell/public/html/sysgen/qtlnet/condor", 1)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='parents.qtlnet'>
Determine and group node-parent combinations.
</h2><span id='topic+parents.qtlnet'></span><span id='topic+summary.parents.qtlnet'></span><span id='topic+size.qtlnet'></span><span id='topic+group.qtlnet'></span>

<h3>Description</h3>

<p>Routines useful for examining the size of node-parent combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parents.qtlnet(pheno.col, max.parents = 3, codes.only = FALSE)
## S3 method for class 'parents.qtlnet'
summary(object, ...)
size.qtlnet(pheno.col, max.parents = 3)
group.qtlnet(pheno.col, max.parents = 3, n.groups = NULL,
  group.size = 50000, parents = parents.qtlnet(pheno.col, max.parents))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parents.qtlnet_+3A_pheno.col">pheno.col</code></td>
<td>

<p>Phenotype identifiers from <code>cross</code> object. May be numeric, logical
or character.
</p>
</td></tr>
<tr><td><code id="parents.qtlnet_+3A_max.parents">max.parents</code></td>
<td>

<p>Maximum number of parents per node. This reduces the complexity of
graphs and shortens run time. Probably best to consider values of 3-5.
</p>
</td></tr>
<tr><td><code id="parents.qtlnet_+3A_parents">parents</code></td>
<td>

<p>List containing all possible parents up to <code>max.parents</code> in
size. May be a subset
</p>
</td></tr>
<tr><td><code id="parents.qtlnet_+3A_codes.only">codes.only</code></td>
<td>

<p>Return only codes of parents if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="parents.qtlnet_+3A_n.groups">n.groups</code></td>
<td>

<p>Number of groups for parallel computation. Determined from
<code>group.size</code> if missing.
</p>
</td></tr>
<tr><td><code id="parents.qtlnet_+3A_group.size">group.size</code></td>
<td>

<p>Size of groups for parallel computation. See details.
</p>
</td></tr>
<tr><td><code id="parents.qtlnet_+3A_object">object</code></td>
<td>

<p>Object of class <code>parent.qtlnet</code>.
</p>
</td></tr>
<tr><td><code id="parents.qtlnet_+3A_...">...</code></td>
<td>

<p>Additional arguments ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most expensive part of calculations is running
<code><a href="qtl.html#topic+scanone">scanone</a></code> on each phenotype with parent phenotypes as
covariates. One strategy is to pre-compute the BIC contributions using a
cluster and save them for later use. The <code>parents.qtlnet</code> routine
creates a list of all possible parent sets (up to <code>max.parents</code> in
size). The <code>size.qtlnet</code> determines the number of
<code><a href="qtl.html#topic+scanone">scanone</a></code> calculations possible for a network with
nodes <code>pheno.col</code> and maximum parent size <code>max.parents</code>. The
<code>group.qtlnet</code> groups the parent sets into roughly equal size
groups for parallel computations. See <code><a href="#topic+bic.qtlnet">bic.qtlnet</a></code> for
further details.
</p>


<h3>Value</h3>

<p>The <code>size.qtlnet</code> returns the number of possible
<code><a href="qtl.html#topic+scanone">scanone</a></code> computations needed for BIC scores.
</p>
<p>The <code>group.qtlnet</code> produces and index into the parents list
created by <code>parents.qtlnet</code>. See details.
</p>
<p>The <code>parents.qtlnet</code> creates a list object with names being the
<code>code</code>.
</p>
<p>The <code>summary</code> method for such an object is a data
frame with row.names being the <code>code</code>, a binary code as decimal
for the parents of a phenotype node, excluding the phenotype. Value is
between 0 (no parents) and <code>2 ^ (length(pheno.col) - 1)</code>. The
columns are 
</p>
<table>
<tr><td><code>parents</code></td>
<td>
<p>Comma-separated string of parents to potential child node.</p>
</td></tr>
<tr><td><code>n.child</code></td>
<td>
<p>Number of possible child nodes to this parent set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://dx.doi.org/10.1214/09-AOAS288">http://dx.doi.org/10.1214/09-AOAS288</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bic.qtlnet">bic.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Restrict to at most 3 parents per node.
pheno.col &lt;- 1:6
max.parents &lt;- 3
size.qtlnet(pheno.col, max.parents)
parents &lt;- parents.qtlnet(pheno.col, max.parents)
summary(parents)

## Allow an arbitrary number (up to 12) of parents per node.
pheno.col &lt;- 1:13
max.parents &lt;- 12
size.qtlnet(pheno.col, max.parents)

## Make ~53 groups of ~1000, for a total of 53248 scanone runs.
parents &lt;- parents.qtlnet(pheno.col, max.parents)
n.child &lt;- summary(parents)$n.child
table(n.child)
groups &lt;- group.qtlnet(parents = parents, group.size = 1000)
apply(groups, 1,
      function(group, parents) sapply(parents[seq(group[1], group[2])], length),
      parents)
</code></pre>

<hr>
<h2 id='Pscdbp'>
Cross and qtlnet objects with Ghazalpour et al. (2006) data.
Only 13 phenotypes are included.
</h2><span id='topic+Pscdbp'></span><span id='topic+Pscdbp.qtlnet'></span>

<h3>Description</h3>

<p>The R/qtl <code>cross</code> object was created from data at source. The
<code>qtlnet</code> object was created using <code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Pscdbp)
data(Pscdbp.qtlnet)
</code></pre>


<h3>Source</h3>

<p><a href="https://horvath.genetics.ucla.edu/coexpressionnetwork/">https://horvath.genetics.ucla.edu/coexpressionnetwork/</a>
</p>


<h3>References</h3>

<p>Ghazalpour A, Doss S, Zhang B, Wang S, Plaisier C, Castellanos R,
Brozell A, Schadt EE, Drake TA, Lusis AJ, Horvath S (2006) Integrating
genetic and network analysis to characterize genes related to mouse
weight. PLoS Genetics 2: e130-NA.
<a href="http://dx.doi.org/10.1371/journal.pgen.0020130">http://dx.doi.org/10.1371/journal.pgen.0020130</a>
</p>
<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://dx.doi.org/10.1214/09-AOAS288">http://dx.doi.org/10.1214/09-AOAS288</a>
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+read.cross">read.cross</a></code>,
<code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(Pscdbp)
## Not run: 
summary(Pscdbp.qtlnet)

## End(Not run)
</code></pre>

<hr>
<h2 id='qdg'> Produces a directed graph using QDG algorithm </h2><span id='topic+qdg'></span><span id='topic+summary.qdg'></span><span id='topic+print.qdg'></span><span id='topic+graph.qdg'></span>

<h3>Description</h3>

<p>This function implements the QDG algorithm described in Chaibub Neto et al 2008. It
creates and scores QDGs. The computed scores (log-likelihood and BIC) are only 
valid for acyclic graphs. For cyclic networks qdgSEM should be used to compute the 
scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdg(cross, phenotype.names, marker.names, QTL, alpha, 
    n.qdg.random.starts, addcov = NULL, intcov = NULL, 
    skel.method = c("pcskel","udgskel"), udg.order = 2)
graph.qdg(x, ...)
## S3 method for class 'qdg'
print(x, ...)
## S3 method for class 'qdg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdg_+3A_cross">cross</code></td>
<td>
<p> object of class <code>cross</code> (see <code><a href="qtl.html#topic+read.cross">read.cross</a></code>). </p>
</td></tr>
<tr><td><code id="qdg_+3A_phenotype.names">phenotype.names</code></td>
<td>
<p> character string with names of phenotype nodes 
corresponding to phenotypes in <code>cross</code>. </p>
</td></tr>
<tr><td><code id="qdg_+3A_marker.names">marker.names</code></td>
<td>
<p> list of character strings, one for each of
<code>phenotype.names</code>. Each character string has the marker names
for that phenotype. </p>
</td></tr>
<tr><td><code id="qdg_+3A_qtl">QTL</code></td>
<td>
<p> object of class <code>qtl</code> (see <code><a href="qtl.html#topic+makeqtl">makeqtl</a></code>). </p>
</td></tr>
<tr><td><code id="qdg_+3A_alpha">alpha</code></td>
<td>
<p> significance level threshold for PC or UDG algorithms (for the 
inference of the graph skeleton. See step 1 of the QDG algorithm). Must be
between 0 and 1. </p>
</td></tr>
<tr><td><code id="qdg_+3A_n.qdg.random.starts">n.qdg.random.starts</code></td>
<td>
<p> number of random starts for the QDG algorithm (see 
step 3 of the QDG algorithm). </p>
</td></tr>
<tr><td><code id="qdg_+3A_addcov">addcov</code></td>
<td>
<p> names of additive covariates. Must be valid phenotype names in 
<code>cross</code>. Expanded to include all <code>intcov</code> names. </p>
</td></tr>
<tr><td><code id="qdg_+3A_intcov">intcov</code></td>
<td>
<p> names of additive covariates. Must be valid phenotype names in 
<code>cross</code>. </p>
</td></tr>
<tr><td><code id="qdg_+3A_skel.method">skel.method</code></td>
<td>
<p> Either &quot;pcskel&quot; for the PC skeleton algorithm
(<code><a href="pcalg.html#topic+skeleton">skeleton</a></code>) or &quot;udgskel&quot; for the UDG algorithm
(<code>approximate.UDG</code> routine defined internal to <code>qdg</code>). </p>
</td></tr>
<tr><td><code id="qdg_+3A_udg.order">udg.order</code></td>
<td>
<p> maximum allowed order of the UDG algorithm. Must be between zero 
and the number of variables minus 2. </p>
</td></tr>
<tr><td><code id="qdg_+3A_x">x</code>, <code id="qdg_+3A_object">object</code></td>
<td>
<p>object of class <code>qdg</code>.</p>
</td></tr>
<tr><td><code id="qdg_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood and BIC scores are computed based in the factorization of the 
joint distribution, and hence are only valid for acyclic networks. For cyclic 
networks these scores are relative to the unnormalized likelihoods. Models include
phenotypes and QTLs. The 'udgskel' method for the computation of the skeleton of 
the causal model should be used for small networks only (the UDG algorithm quickly 
becomes computationally infeasible as the number of nodes increases).
</p>


<h3>Value</h3>

<p>List object that inherits class &quot;qdg&quot; and &quot;qdg&quot; with components:
</p>
<table>
<tr><td><code>UDG</code></td>
<td>
<p>Undirected dependency graph from PC skeleton or UDG algorithms.</p>
</td></tr>
<tr><td><code>DG</code></td>
<td>
<p>Directed dependency graph before recheck step (output of the step 2 of the        QDG algorithm).</p>
</td></tr> 
<tr><td><code>best.lm</code></td>
<td>
<p>Solution with lowest BIC (best fit to the data).</p>
</td></tr>
<tr><td><code>Solutions</code></td>
<td>
<p>Solutions of dependency graph after recheck step (output of steps 3, 4
and 5 of the QDG algorithm.)</p>
</td></tr>
<tr><td><code>marker.names</code></td>
<td>
<p>List of character strings, one for each of
<code>phenotype.names</code>. 
Each character string has the marker names
for that phenotype.</p>
</td></tr>
<tr><td><code>phenotype.names</code></td>
<td>
<p>Character string with names of phenotype nodes
corresponding to phenotypes in <code>cross</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chaibub Neto et al. (2008) Inferring causal phenotype networks from 
segregating populations. Genetics 179: 1089-1100.</p>


<h3>See Also</h3>

 <p><code><a href="pcalg.html#topic+skeleton">skeleton</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a genetic map (20 autosomes, 10 not equaly spaced markers per 
## chromosome)
mymap &lt;- sim.map(len=rep(100,20), n.mar=10, eq.spacing=FALSE, include.x=FALSE)

## simulate an F2 cross object with n.ind (number of individuals)
n.ind &lt;- 200
mycross &lt;- sim.cross(map=mymap, n.ind=n.ind, type="f2")

## produce multiple imputations of genotypes using the 
## sim.geno function. The makeqtl function requires it,
## even though we are doing only one imputation (since 
## we don't have missing data and we are using the 
## genotypes in the markers, one imputation is enough)
mycross &lt;- sim.geno(mycross,n.draws=1)

## sample markers (2 per phenotype)
genotypes &lt;- pull.geno(mycross)
geno.names &lt;- dimnames(genotypes)[[2]]
m1 &lt;- sample(geno.names,2,replace=FALSE)
m2 &lt;- sample(geno.names,2,replace=FALSE)
m3 &lt;- sample(geno.names,2,replace=FALSE)
m4 &lt;- sample(geno.names,2,replace=FALSE)

## get marker genotypes
g11 &lt;- genotypes[,m1[1]]; g12 &lt;- genotypes[,m1[2]]
g21 &lt;- genotypes[,m2[1]]; g22 &lt;- genotypes[,m2[2]]
g31 &lt;- genotypes[,m3[1]]; g32 &lt;- genotypes[,m3[2]]
g41 &lt;- genotypes[,m4[1]]; g42 &lt;- genotypes[,m4[2]]

## generate phenotypes
y1 &lt;- runif(3,0.5,1)[g11] + runif(3,0.5,1)[g12] + rnorm(n.ind)
y2 &lt;- runif(3,0.5,1)[g21] + runif(3,0.5,1)[g22] + rnorm(n.ind)
y3 &lt;- runif(1,0.5,1) * y1 +  runif(1,0.5,1) * y2 + runif(3,0.5,1)[g31] +
      runif(3,0.5,1)[g32] + rnorm(n.ind)
y4 &lt;- runif(1,0.5,1) * y3 + runif(3,0.5,1)[g41] + runif(3,0.5,1)[g42] +
      rnorm(n.ind)

## incorporate phenotypes to cross object
mycross$pheno &lt;- data.frame(y1,y2,y3,y4)

## create markers list
markers &lt;- list(m1,m2,m3,m4)
names(markers) &lt;- c("y1","y2","y3","y4")

## create qtl object
allqtls &lt;- list()
m1.pos &lt;- find.markerpos(mycross, m1)
allqtls[[1]] &lt;- makeqtl(mycross, chr = m1.pos[,"chr"], pos = m1.pos[,"pos"])
m2.pos &lt;- find.markerpos(mycross, m2)
allqtls[[2]] &lt;- makeqtl(mycross, chr = m2.pos[,"chr"], pos = m2.pos[,"pos"])
m3.pos &lt;- find.markerpos(mycross, m3)
allqtls[[3]] &lt;- makeqtl(mycross, chr = m3.pos[,"chr"], pos = m3.pos[,"pos"])
m4.pos &lt;- find.markerpos(mycross, m4)
allqtls[[4]] &lt;- makeqtl(mycross, chr = m4.pos[,"chr"], pos = m4.pos[,"pos"])
names(allqtls) &lt;- c("y1","y2","y3","y4")

## infer QDG 
out &lt;- qdg(cross=mycross, 
		phenotype.names = c("y1","y2","y3","y4"), 
		marker.names = markers, 
		QTL = allqtls, 
		alpha = 0.005, 
		n.qdg.random.starts=10, 
		skel.method="pcskel")

out
## Not run: 
gr &lt;- graph.qdg(out)
gr
plot(gr)

## End(Not run)
</code></pre>

<hr>
<h2 id='qdg.perm.test'> Conduct permutation test for LOD score of edge direction on
directed graph </h2><span id='topic+qdg.perm.test'></span><span id='topic+summary.qdg.perm.test'></span><span id='topic+print.qdg.perm.test'></span>

<h3>Description</h3>

<p>Conduct permutation test for LOD score of edge direction on
directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdg.perm.test(cross, nperm, node1, node2, common.cov = NULL,
  DG, QTLs, addcov = NULL, intcov = NULL)
## S3 method for class 'qdg.perm.test'
summary(object, ...)
## S3 method for class 'qdg.perm.test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdg.perm.test_+3A_cross">cross</code></td>
<td>
<p> Object of class <code>cross</code> (see <code><a href="qtl.html#topic+read.cross">read.cross</a></code>). </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_nperm">nperm</code></td>
<td>
<p> Number of permutations. </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_node1">node1</code></td>
<td>
<p> Character string with name of a phenotype nodes. </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_node2">node2</code></td>
<td>
<p> Character string with name of a phenotype nodes. </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_common.cov">common.cov</code></td>
<td>
<p> Character string with name of common phenotype covariates. </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_dg">DG</code></td>
<td>
<p> Directed graph of class <code>QDG</code> </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_qtls">QTLs</code></td>
<td>
<p> List of objects of class <code>qtl</code>. </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_addcov">addcov</code></td>
<td>
<p> Names of additive covariates. Must be valid phenotype
names in <code>cross</code>. Expanded to include all <code>intcov</code> names. </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_intcov">intcov</code></td>
<td>
<p> Names of additive covariates. Must be valid phenotype
names in <code>cross</code>. </p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_x">x</code>, <code id="qdg.perm.test_+3A_object">object</code></td>
<td>
<p>Object of class <code>qdg.perm.test</code>.</p>
</td></tr>
<tr><td><code id="qdg.perm.test_+3A_...">...</code></td>
<td>
<p>Additional arguments ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qdg.perm.test</code> performs <code>nperm</code> permutation-based test
of LOD score for an 
edge of a directed graph.
</p>


<h3>Value</h3>

<p>List composed by:
</p>
<table>
<tr><td><code>pvalue</code></td>
<td>
<p>Permutation p-value.</p>
</td></tr>
<tr><td><code>obs.lod</code></td>
<td>
<p>Observed LOD score.</p>
</td></tr>
<tr><td><code>PermSample</code></td>
<td>
<p>Permutation LOD scores sample.</p>
</td></tr>
<tr><td><code>node1</code></td>
<td>
<p>Character string with name of a phenotype nodes.</p>
</td></tr>
<tr><td><code>node2</code></td>
<td>
<p>Character string with name of a phenotype nodes.</p>
</td></tr>
</table>


<h3>References</h3>

<p> Chaibub Neto et al. (2008) Inferring causal phenotype networks from 
segregating populations. Genetics 179: 1089-1100.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(glxnet)
glxnet.cross &lt;- calc.genoprob(glxnet.cross)
set.seed(1234)
glxnet.cross &lt;- sim.geno(glxnet.cross)
## Should really use nperm = 1000 here.
qdg.perm.test(glxnet.cross, nperm = 10, "Glx", "Slc1a2",
   DG = glxnet.qdg$DG, QTLs = glxnet.qtl)
</code></pre>

<hr>
<h2 id='qdg.sem'>Score directed graphs outputed by qdg using structural equation models (SEM)</h2><span id='topic+qdg.sem'></span><span id='topic+summary.qdg.sem'></span><span id='topic+print.qdg.sem'></span>

<h3>Description</h3>

<p>Score directed graphs (cyclic or acyclic) outputed by qdg function using the sem R
package.     
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdg.sem(qdgObject, cross)
## S3 method for class 'qdg.sem'
print(x, ...)
## S3 method for class 'qdg.sem'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdg.sem_+3A_qdgobject">qdgObject</code></td>
<td>
<p>list containing the output of <code><a href="#topic+qdg">qdg</a></code>.</p>
</td></tr>
<tr><td><code id="qdg.sem_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code> (see <code><a href="qtl.html#topic+read.cross">read.cross</a></code>).</p>
</td></tr>
<tr><td><code id="qdg.sem_+3A_x">x</code>, <code id="qdg.sem_+3A_object">object</code></td>
<td>
<p>object of class <code>qdg</code>.</p>
</td></tr>
<tr><td><code id="qdg.sem_+3A_...">...</code></td>
<td>
<p>extra arguments to print or summary (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits a SEM to the phenotypes network. QTLs are not included as
variables in the model. When additive covariates are used in qdg, qdg.sem
fits a SEM model to the residuals of the variables after adjustment of the 
additive covariates.
</p>


<h3>Value</h3>

<p>List object that inherits class &quot;qdg.sem&quot; and &quot;qdg&quot; composed by:
</p>
<table>
<tr><td><code>best.SEM</code></td>
<td>
<p>Solution with lowest SEM BIC (best fit to the data).</p>
</td></tr>
<tr><td><code>BIC.SEM</code></td>
<td>
<p>Vector with the BIC values of all solutions from qdg.</p>
</td></tr>
<tr><td><code>path.coeffs</code></td>
<td>
<p>Path coefficients associated with the best SEM solution.</p>
</td></tr>
<tr><td><code>Solutions</code></td>
<td>
<p>Solutions of dependency graph after recheck step
(output of steps 3, 4 and 5 of the QDG algorithm.)</p>
</td></tr>
<tr><td><code>marker.names</code></td>
<td>
<p>List of character strings, one for each of
<code>phenotype.names</code>. 
Each character string has the marker names
for that phenotype.</p>
</td></tr>
<tr><td><code>phenotype.names</code></td>
<td>
<p>Character string with names of phenotype nodes
corresponding to phenotypes in <code>cross</code>.</p>
</td></tr>
<tr><td><code>dropped</code></td>
<td>
<p>Indexes of solutions that were dropped (<code>NULL</code> if
none dropped).</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+qdg">qdg</a></code> <code><a href="sem.html#topic+sem">sem</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a genetic map (20 autosomes, 10 not equaly spaced markers per 
## chromosome)
mymap &lt;- sim.map(len=rep(100,20), n.mar=10, eq.spacing=FALSE, include.x=FALSE)

## simulate an F2 cross object with n.ind (number of individuals)
n.ind &lt;- 200
mycross &lt;- sim.cross(map=mymap, n.ind=n.ind, type="f2")

## produce multiple imputations of genotypes using the 
## sim.geno function. The makeqtl function requires it,
## even though we are doing only one imputation (since 
## we don't have missing data and we are using the 
## genotypes in the markers, one imputation is enough)
mycross &lt;- sim.geno(mycross,n.draws=1)

## sample markers (2 per phenotype)
genotypes &lt;- pull.geno(mycross)
geno.names &lt;- dimnames(genotypes)[[2]]
m1 &lt;- sample(geno.names,2,replace=FALSE)
m2 &lt;- sample(geno.names,2,replace=FALSE)
m3 &lt;- sample(geno.names,2,replace=FALSE)
m4 &lt;- sample(geno.names,2,replace=FALSE)

## get marker genotypes
g11 &lt;- genotypes[,m1[1]]; g12 &lt;- genotypes[,m1[2]]
g21 &lt;- genotypes[,m2[1]]; g22 &lt;- genotypes[,m2[2]]
g31 &lt;- genotypes[,m3[1]]; g32 &lt;- genotypes[,m3[2]]
g41 &lt;- genotypes[,m4[1]]; g42 &lt;- genotypes[,m4[2]]

## generate phenotypes
y1 &lt;- runif(3,0.5,1)[g11] + runif(3,0.5,1)[g12] + rnorm(n.ind)
y2 &lt;- runif(3,0.5,1)[g21] + runif(3,0.5,1)[g22] + rnorm(n.ind)
y3 &lt;- runif(1,0.5,1) * y1 +  runif(1,0.5,1) * y2 + runif(3,0.5,1)[g31] +
      runif(3,0.5,1)[g32] + rnorm(n.ind)
y4 &lt;- runif(1,0.5,1) * y3 + runif(3,0.5,1)[g41] + runif(3,0.5,1)[g42] +
      rnorm(n.ind)

## incorporate phenotypes to cross object
mycross$pheno &lt;- data.frame(y1,y2,y3,y4)

## create markers list
markers &lt;- list(m1,m2,m3,m4)
names(markers) &lt;- c("y1","y2","y3","y4")

## create qtl object
allqtls &lt;- list()
m1.pos &lt;- find.markerpos(mycross, m1)
allqtls[[1]] &lt;- makeqtl(mycross, chr = m1.pos[,"chr"], pos = m1.pos[,"pos"])
m2.pos &lt;- find.markerpos(mycross, m2)
allqtls[[2]] &lt;- makeqtl(mycross, chr = m2.pos[,"chr"], pos = m2.pos[,"pos"])
m3.pos &lt;- find.markerpos(mycross, m3)
allqtls[[3]] &lt;- makeqtl(mycross, chr = m3.pos[,"chr"], pos = m3.pos[,"pos"])
m4.pos &lt;- find.markerpos(mycross, m4)
allqtls[[4]] &lt;- makeqtl(mycross, chr = m4.pos[,"chr"], pos = m4.pos[,"pos"])

names(allqtls) &lt;- c("y1","y2","y3","y4")

## infer QDG 
out &lt;- qdg(cross=mycross, 
		phenotype.names = c("y1","y2","y3","y4"), 
		marker.names = markers, 
		QTL = allqtls, 
		alpha = 0.005, 
		n.qdg.random.starts=10, 
		skel.method="pcskel")
		
## Not run: 
gr &lt;- graph.qdg(out)
plot(gr)

## Following does not work. Not sure why.
out2 &lt;- qdg.sem(out, cross=mycross)
out2
gr2 &lt;- graph.qdg(out2)
plot(gr2)

## End(Not run)
</code></pre>

<hr>
<h2 id='subset.qtlnet'>
Catenate or subset qtlnet object(s).
</h2><span id='topic+subset.qtlnet'></span><span id='topic+c.qtlnet'></span><span id='topic+best.qtlnet'></span>

<h3>Description</h3>

<p>Multiple qtlnet objects can be catenated together or subsetted by run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtlnet'
subset(x, run, ...)
## S3 method for class 'qtlnet'
c(...)
best.qtlnet(x, burnin = attr(x, "burnin"), wh = which.min(meanbic(x, burnin)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.qtlnet_+3A_x">x</code></td>
<td>

<p>Object of class <code>qtlnet</code>. See <code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>.
</p>
</td></tr>
<tr><td><code id="subset.qtlnet_+3A_run">run</code></td>
<td>

<p>Numeric index to desired run. Must be between 0 and number of runs.
</p>
</td></tr>
<tr><td><code id="subset.qtlnet_+3A_burnin">burnin</code></td>
<td>

<p>Proportion of MCMC samples to be considered as burnin. Taken from
<code>qtlnet</code> object usually.
</p>
</td></tr>
<tr><td><code id="subset.qtlnet_+3A_wh">wh</code></td>
<td>
<p>Number identifying which model is best.</p>
</td></tr>
<tr><td><code id="subset.qtlnet_+3A_...">...</code></td>
<td>

<p>For <code>c.qtlnet</code>, objects of class <code>qtlnet</code> to be
joined. Ignored for <code>subset.qtlnet</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The catenation is used by <code><a href="#topic+parallel.qtlnet">parallel.qtlnet</a></code> in phase 5 to
join together multiple independent MCMC runs. Note that the averaged
network and the frequency of acceptance for a derived subset are only
based on the saved samples, while the original <code>qtlnet</code> objects
used all samples. Thus catenation and subset are not strictly reversible
functions.
</p>
<p>The <code>best.qtlnet</code> routine picks the run with the best (lowest) BIC
score on average and returns that run as a qtlnet object. It also
produces a trace plot of BIC for all the runs.
</p>


<h3>Value</h3>

<p>Both return an object of class <code>qtlnet</code>.
</p>


<h3>Author(s)</h3>

<p>Brian Yandell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
joined &lt;- c(qtlnet1, qtlnet2)
sub1 &lt;- subset(joined, 1)
best &lt;- best.qtlnet(joined)
## qtlnet1 and sub1 should be nearly identical.

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.qtlnet'>summary of model average network and posterior table</h2><span id='topic+check.qtlnet'></span><span id='topic+print.qtlnet'></span><span id='topic+summary.qtlnet'></span><span id='topic+print.summary.qtlnet'></span>

<h3>Description</h3>

<p>Print and summary methods for qtlnet objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtlnet'
print(x, cutoff = 0.01, digits = 3, ...)
## S3 method for class 'qtlnet'
summary(object, parent.patterns = FALSE, ...)
## S3 method for class 'summary.qtlnet'
print(x, ...)
check.qtlnet(object, min.prob = 0.9, correct = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.qtlnet_+3A_x">x</code>, <code id="summary.qtlnet_+3A_object">object</code></td>
<td>

<p>Object of class <code>qtlnet</code>.
</p>
</td></tr>
<tr><td><code id="summary.qtlnet_+3A_cutoff">cutoff</code></td>
<td>

<p>Frequency cutoff for model patterns to be displayed. Always shows at
least the most common pattern.
</p>
</td></tr>
<tr><td><code id="summary.qtlnet_+3A_digits">digits</code></td>
<td>

<p>Number of digits to display for posterior probabilities on directed edges.
</p>
</td></tr>
<tr><td><code id="summary.qtlnet_+3A_parent.patterns">parent.patterns</code></td>
<td>

<p>Include summary of parent patterns if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.qtlnet_+3A_min.prob">min.prob</code></td>
<td>

<p>Set the minimum posterior probability for inclusion of an edge.
</p>
</td></tr>
<tr><td><code id="summary.qtlnet_+3A_correct">correct</code></td>
<td>

<p>Correct <code>min.prob</code> if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.qtlnet_+3A_verbose">verbose</code></td>
<td>

<p>Print forbidden edges in model-averaged solution if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.qtlnet_+3A_...">...</code></td>
<td>

<p>Other hidden arguments. These include <code>min.prob</code>, which
can also be passed to other <code><a href="#topic+igraph.qtlnet">igraph.qtlnet</a></code> and
<code><a href="#topic+plot.qtlnet">plot.qtlnet</a></code> routines.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf">http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.qtlnet">mcmc.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pscdbp.qtlnet)
print(Pscdbp.qtlnet)
summary(Pscdbp.qtlnet)
</code></pre>

<hr>
<h2 id='write.qtlnet'>write qtlnet as text file</h2><span id='topic+write.qtlnet'></span>

<h3>Description</h3>

<p>Write resulting graph as text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.qtlnet(x, filename, edges, loci.list, include.qtl = TRUE,
    est.list, include.est = TRUE,
    digits = 3, col.names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.qtlnet_+3A_x">x</code></td>
<td>

<p>Object of class <code>qtlnet</code>.
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_filename">filename</code></td>
<td>

<p>Character string with name of text file (usually ends in <code>.txt</code>).
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_edges">edges</code></td>
<td>

<p>Data frame with first two columns being <code>cause</code> and <code>effect</code>
directed phenotype pairs. Typically determined as <code>averaged.net</code>
element from call to <code><a href="#topic+summary.qtlnet">summary.qtlnet</a></code>.
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_loci.list">loci.list</code></td>
<td>

<p>List of character names of loci by phenotype. Typically determined by
call to <code><a href="#topic+loci.qtlnet">loci.qtlnet</a></code>.
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_include.qtl">include.qtl</code></td>
<td>

<p>Include QTL in graph if <code>TRUE</code> and <code>loci.list</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_est.list">est.list</code></td>
<td>

<p>List of estimates from internal est.qtlnet?
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_include.est">include.est</code></td>
<td>

<p>Include estimate if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_digits">digits</code></td>
<td>

<p>Number of significant digits for <code>width</code>.
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_col.names">col.names</code></td>
<td>

<p>Character vector of column names.
</p>
</td></tr>
<tr><td><code id="write.qtlnet_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to called routines.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple write of causal network, for instance to use with Cytoscape.
</p>


<h3>Value</h3>

<p>Invisibly returns data frame that corresponds to saved file.
</p>


<h3>Author(s)</h3>

<p>Brian S. Yandell and Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Chaibub Neto E, Keller MP, Attie AD, Yandell BS (2010)
Causal Graphical Models in Systems Genetics: a unified
framework for joint inference of causal network and
genetic architecture for correlated phenotypes.
Ann Appl Statist 4: 320-339.
<a href="http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf">http://www.stat.wisc.edu/~yandell/doc/2010/92.AnnApplStat.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+igraph.qtlnet">igraph.qtlnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
write.qtlnet(Pscdbp.qtlnet, "Pscdbp.txt")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
