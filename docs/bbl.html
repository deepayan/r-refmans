<!DOCTYPE html><html><head><title>Help for package bbl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bbl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bbl'><p>Boltzmann Bayes Learning Inference</p></a></li>
<li><a href='#bbl.fit'><p>bbl Inference with model matrix</p></a></li>
<li><a href='#crossVal'><p>Cross-Validation of BB Learning</p></a></li>
<li><a href='#fitted.bbl'><p>Fitted Response Group Probabilities</p></a></li>
<li><a href='#formula.bbl'><p>Formula in BBL Fitting</p></a></li>
<li><a href='#freq2raw'><p>Convert Frequency Table into Raw Data</p></a></li>
<li><a href='#logLik.bbl'><p>Log likelihood for bbl object</p></a></li>
<li><a href='#mcSample'><p>Sample Predictor Distributions</p></a></li>
<li><a href='#mlestimate'><p>Maximum likelihood estimate</p></a></li>
<li><a href='#model.frame.bbl'><p>Model Frame for BBL</p></a></li>
<li><a href='#nobs.bbl'><p>Number of Observations in BBL Fit</p></a></li>
<li><a href='#plot.bbl'><p>Plot bbl object</p></a></li>
<li><a href='#plot.cv.bbl'><p>Plot Cross-validation Outcome</p></a></li>
<li><a href='#predict.bbl'><p>Predict Response Group Using <code>bbl</code> Model</p></a></li>
<li><a href='#predict.cv.bbl'><p>Predict using Cross-validation Object</p></a></li>
<li><a href='#print.bbl'><p>Print Boltzmann Bayes Learning Fits</p></a></li>
<li><a href='#print.cv.bbl'><p>Display Cross-validation Result</p></a></li>
<li><a href='#print.summary.bbl'><p>Print Summary of Boltzmann Bayes Learning</p></a></li>
<li><a href='#randompar'><p>Generate Random Parameters</p></a></li>
<li><a href='#randomsamp'><p>Generate Random Boltzmann Bayes Model Data</p></a></li>
<li><a href='#readFasta'><p>Read FASTA File</p></a></li>
<li><a href='#removeConst'><p>Remove Non-varying Predictors</p></a></li>
<li><a href='#residuals.bbl'><p>Residuals of BBL fit</p></a></li>
<li><a href='#sample_xi'><p>Generate Random Samples from Boltzmann Distribution</p></a></li>
<li><a href='#summary.bbl'><p>Naive Bayes Summary</p></a></li>
<li><a href='#weights.bbl'><p>Weights in BBL Fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Boltzmann Bayes Learner</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jun Woo &lt;junwoo035@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils, Rcpp (&ge; 0.12.16), pROC, RColorBrewer</td>
</tr>
<tr>
<td>Description:</td>
<td>Supervised learning using Boltzmann Bayes model inference, 
    which extends naive Bayes model to include interactions. Enables 
    classification of data into multiple response groups based on a large 
    number of discrete predictors that can take factor values of 
    heterogeneous levels. Either pseudo-likelihood or mean field 
    inference can be used with L2 regularization, cross-validation, and 
    prediction on new data. 
    &lt;<a href="https://doi.org/10.18637%2Fjss.v101.i05">doi:10.18637/jss.v101.i05</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glmnet, BiocManager, Biostrings</td>
</tr>
<tr>
<td>Author:</td>
<td>Jun Woo <a href="https://orcid.org/0000-0003-3220-2064"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-27 16:11:27 UTC; junwoo</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-27 23:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='bbl'>Boltzmann Bayes Learning Inference</h2><span id='topic+bbl'></span>

<h3>Description</h3>

<p>Main driver for bbl inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbl(
  formula,
  data,
  weights,
  xlevels = NULL,
  verbose = 1,
  method = "pseudo",
  novarOk = FALSE,
  testNull = TRUE,
  prior.count = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbl_+3A_formula">formula</code></td>
<td>
<p>Formula for modeling</p>
</td></tr>
<tr><td><code id="bbl_+3A_data">data</code></td>
<td>
<p>Data for fitting</p>
</td></tr>
<tr><td><code id="bbl_+3A_weights">weights</code></td>
<td>
<p>Vector of weights for each instance in data. Restricted to 
non-negative integer frequencies, recoding the number of times 
each row of data must be repeated. If <code>NULL</code>,
assumed to be all 1. Fractional weights are not supported. Can be
a named column in <code>data</code></p>
</td></tr>
<tr><td><code id="bbl_+3A_xlevels">xlevels</code></td>
<td>
<p>List of factor levels for predictors. If <code>NULL</code>,
will be inferred from data with factor levels ordered alphanumerically.</p>
</td></tr>
<tr><td><code id="bbl_+3A_verbose">verbose</code></td>
<td>
<p>Output verbosity level. Will be send to down-stream function
calls with one level lower</p>
</td></tr>
<tr><td><code id="bbl_+3A_method">method</code></td>
<td>
<p>BB inference algorithm; pseudo-likelihood inference (<code>'pseudo'</code>)
or mean field (<code>'mf'</code>)</p>
</td></tr>
<tr><td><code id="bbl_+3A_novarok">novarOk</code></td>
<td>
<p>If <code>TRUE</code>, will proceed with predictors having only one
level</p>
</td></tr>
<tr><td><code id="bbl_+3A_testnull">testNull</code></td>
<td>
<p>Repeat the inference for the &lsquo;pooled&rsquo; sample; i.e., under the
null hypothesis of all rows in data belonging to a single group</p>
</td></tr>
<tr><td><code id="bbl_+3A_prior.count">prior.count</code></td>
<td>
<p>Prior count for computing single predictor and pairwise
frequencies</p>
</td></tr>
<tr><td><code id="bbl_+3A_...">...</code></td>
<td>
<p>Other parameters to <code><a href="#topic+mlestimate">mlestimate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formula argument and data are used to tabulate xlevels unless explicitly
given as list. Data are expected to be factors or integers. This function
is a driver interepreting formula and calls <code>bbi.fit</code>. Will stop with
error if any predictor has only one level unless <code>novarOk='TRUE'</code>.
Use <code><a href="#topic+removeConst">removeConst</a></code> to remove the non-varying predictors before 
calling if this happens.
</p>


<h3>Value</h3>

<p>A list of class <code>bbl</code> with the following elements:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>List of inferred coefficients with elements
<code>h</code>, <code>J</code>, <code>h0</code>, and <code>J0</code>. The bias  
parameter <code>h</code> is a list of length equal to no. of 
response groups, each of which is a list of the same struture as 
<code>xlevels</code>: length equal to no. of predictors, containing vectors of 
length equal to each predictor factor levels:
<code class="reqn">h_i^{(y)}(x)</code> represented by <code>h[[y]][[i]][x]</code>.
The interaction parameter <code>J</code> is a list of lists of dimension
<code class="reqn">m \times m</code>, where <code class="reqn">m</code> is the number of predictors. Each
element is a matrix of dimension <code class="reqn">L_i \times L_j</code>, where <code class="reqn">L_i</code>
and <code class="reqn">L_j</code> are numbers of factor levels in predictor <code>i</code> and
<code>j</code>: <code class="reqn">J_{ij}^{(y)}(x_1,x_2)</code> represented by 
<code>J[[y]][[i]][[j]][x1,x2]</code>. All elements of lists are named.
The pooled parameters <code>h0</code> and <code>J0</code>, if computed,
are of one less dimension, omitting response group argument.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>List of vectors containing predictor levels.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The <code>terms</code> of <code>formula</code> input.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>Vector of response groups.</p>
</td></tr>
<tr><td><code>groupname</code></td>
<td>
<p>Name of the response variable.</p>
</td></tr>
<tr><td><code>qJ</code></td>
<td>
<p>Matrix of logicals whose elements record whether
<code>formula</code> includes interaction between the two predictors.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Model data frame derived from <code>formula</code> and <code>data</code>.</p>
</td></tr>
<tr><td><code>lkh</code></td>
<td>
<p>Log likelihood.</p>
</td></tr>
<tr><td><code>lz</code></td>
<td>
<p>Vector log partition function. Used in <code><a href="stats.html#topic+predict">predict</a></code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Vector of integral weights (frequencies).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Woo, <a href="mailto:junwoo035@gmail.com">junwoo035@gmail.com</a>
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.18637/jss.v101.i05">10.18637/jss.v101.i05</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- as.data.frame(Titanic)
b &lt;- bbl(Survived ~ (Class + Sex + Age)^2, data = titanic, weights = Freq)
b
</code></pre>

<hr>
<h2 id='bbl.fit'>bbl Inference with model matrix</h2><span id='topic+bbl.fit'></span>

<h3>Description</h3>

<p>Performs bbl inference using response vector and predictor matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbl.fit(
  x,
  y,
  qJ = NULL,
  weights = NULL,
  xlevels = NULL,
  verbose = 1,
  method = "pseudo",
  prior.count = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbl.fit_+3A_x">x</code></td>
<td>
<p>Data frame of factors with each predictor in columns.</p>
</td></tr>
<tr><td><code id="bbl.fit_+3A_y">y</code></td>
<td>
<p>Vector of response variables.</p>
</td></tr>
<tr><td><code id="bbl.fit_+3A_qj">qJ</code></td>
<td>
<p>Matrix of logicals indicating which predictor combinations
are interacting.</p>
</td></tr>
<tr><td><code id="bbl.fit_+3A_weights">weights</code></td>
<td>
<p>Vector of non-negative integer frequencies, recoding 
the number of times each row of data must be repeated. 
If <code>NULL</code>, assumed to be all 1. Fractional weights are not 
supported.</p>
</td></tr>
<tr><td><code id="bbl.fit_+3A_xlevels">xlevels</code></td>
<td>
<p>List of factor levels for predictors. If <code>NULL</code>,
will be inferred from data with factor levels ordered alphanumerically.</p>
</td></tr>
<tr><td><code id="bbl.fit_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity level of output. Will be propagated to 
<code><a href="#topic+mlestimate">mlestimate</a></code> with one level down.</p>
</td></tr>
<tr><td><code id="bbl.fit_+3A_method">method</code></td>
<td>
<p><code>c('pseudo','mf')</code>; inference method.</p>
</td></tr>
<tr><td><code id="bbl.fit_+3A_prior.count">prior.count</code></td>
<td>
<p>Prior count for computing single predictor and pairwise
frequencies</p>
</td></tr>
<tr><td><code id="bbl.fit_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+mlestimate">mlestimate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function would normally be called by <code><a href="#topic+bbl">bbl</a></code> rather than
directly. Expects the predictor data <code>x</code> and response vector <code>y</code>
instead of formula input to <code><a href="#topic+bbl">bbl</a></code>.
</p>


<h3>Value</h3>

<p>List of named components <code>h</code>, <code>J</code>, <code>lkh</code>, and
<code>lz</code>; see <code><a href="#topic+bbl">bbl</a></code> for information regarding these
components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- as.data.frame(Titanic)
freq &lt;- titanic$Freq
x &lt;- titanic[,1:3]
y &lt;- titanic$Survived
b &lt;- bbl.fit(x=x,y=y, weights=freq)
b
</code></pre>

<hr>
<h2 id='crossVal'>Cross-Validation of BB Learning</h2><span id='topic+crossVal'></span>

<h3>Description</h3>

<p>Run multiple fittings of <code>bbl</code> model with training/validation
division of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossVal(
  formula,
  data,
  weights,
  novarOk = FALSE,
  lambda = 1e-05,
  lambdah = 0,
  eps = 0.9,
  nfold = 5,
  method = "pseudo",
  use.auc = TRUE,
  verbose = 1,
  progress.bar = FALSE,
  storeOpt = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossVal_+3A_formula">formula</code></td>
<td>
<p>Formula for model. Note that intercept has no effect.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_data">data</code></td>
<td>
<p>Data frame of data. Column names must match <code>formula</code>.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_weights">weights</code></td>
<td>
<p>Frequency vector of how many times each row of <code>data</code> must
be repeated. If <code>NULL</code>, defaults to vector of 1s. 
Fractional values are not supported.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_novarok">novarOk</code></td>
<td>
<p>Proceed even when there are predictors with only one factor level.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_lambda">lambda</code></td>
<td>
<p>Vector of L2 penalizer values for <code>method = 'pseudo'</code>. Inferences
will be repeated for each value. Restricited to non-negative values.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_lambdah">lambdah</code></td>
<td>
<p>L2 penalizer in <code>method = 'pseudo'</code> applied to
parameter <code>h</code>. In contrast to <code>lambda</code>, 
only a single value is allowed.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_eps">eps</code></td>
<td>
<p>Vector of regularization parameters, <code class="reqn">\epsilon\in[0,1]</code>, 
for <code>method = 'mf'</code>. Inference will be repeated
for each value.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_nfold">nfold</code></td>
<td>
<p>Number of folds for training/validation split.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_method">method</code></td>
<td>
<p><code>c('pseudo','mf')</code> for pseudo-likelihood maximization or
mean field.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_use.auc">use.auc</code></td>
<td>
<p>Use AUC as the measure of prediction accuracy. Only works
if response groups are binary. If <code>FALSE</code>, mean prediction group
accuracy will be used as score.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity level. Downgraded when relayed into <code><a href="#topic+bbl">bbl</a></code>.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_progress.bar">progress.bar</code></td>
<td>
<p>Display progress bar in <code><a href="stats.html#topic+predict">predict</a></code>.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_storeopt">storeOpt</code></td>
<td>
<p>Store the optimal fitted object of class <code><a href="#topic+bbl">bbl</a></code>.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_...">...</code></td>
<td>
<p>Other parameters to <code><a href="#topic+mlestimate">mlestimate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>data</code> slot of <code>object</code> is split into training and validation 
subsets of (<code>nfold</code>-1):1 ratio. The model is trained with the
former and validated on the latter. Individual division/fold results are 
combined into validation result for all instances in the data set and
prediction score is evaluated using the known response group
identity.
</p>


<h3>Value</h3>

<p>Object of class <code>cv.bbl</code> extending <code><a href="#topic+bbl">bbl</a></code>, a list
with extra components:  
<code>regstar</code>, Value of regularization parameter, <code>lambda</code> and <code>eps</code> 
for <code>method='pseudo'</code> and <code>method='mf'</code>,respectively, 
at which the accuracy score is maximized; 
<code>maxscore</code>, Value of maximum accuracy; 
<code>cvframe</code>, Data frame of regularization parameters and scores scanned. 
If <code>use.auc=TRUE</code>, also contains 95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(513)
m &lt;- 5
n &lt;- 100
predictors &lt;- list()
for(i in 1:m) predictors[[i]] &lt;- c('a','c','g','t')
names(predictors) &lt;- paste0('v',1:m)
par &lt;- list(randompar(predictors), randompar(predictors, h0=0.1, J0=0.1))
dat &lt;- randomsamp(predictors, response=c('ctrl','case'), par=par, nsample=n)
cv &lt;- crossVal(y ~ .^2, data=dat, method='mf', eps=seq(0.1,0.9,0.1))
cv
</code></pre>

<hr>
<h2 id='fitted.bbl'>Fitted Response Group Probabilities</h2><span id='topic+fitted.bbl'></span><span id='topic+fitted.values'></span>

<h3>Description</h3>

<p>Response group probabilities from BBL fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bbl_+3A_object">object</code></td>
<td>
<p>Object of class <code>bbl</code>.</p>
</td></tr>
<tr><td><code id="fitted.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method returns predicted response group probabilities of trainig data
</p>


<h3>Value</h3>

<p>Matrix of response group probabities with data points in rows and
response groups in columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- as.data.frame(Titanic)
fit &lt;- bbl(Survived ~ Class + Sex + Age, data=titanic, weights=titanic$Freq)

</code></pre>

<hr>
<h2 id='formula.bbl'>Formula in BBL Fitting</h2><span id='topic+formula.bbl'></span>

<h3>Description</h3>

<p>Returns the formula used in BBL fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.bbl_+3A_x">x</code></td>
<td>
<p>Object of class <code>bbl</code></p>
</td></tr>
<tr><td><code id="formula.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formula object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- as.data.frame(Titanic)
fit &lt;- bbl(Survived ~ Class + Sex + Age, data=titanic, weights=titanic$Freq)
formula(fit)
</code></pre>

<hr>
<h2 id='freq2raw'>Convert Frequency Table into Raw Data</h2><span id='topic+freq2raw'></span>

<h3>Description</h3>

<p>Data with unique rows and a frequency column is converted into
data with duplicate rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq2raw(data, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq2raw_+3A_data">data</code></td>
<td>
<p>Data frame with factors in columns</p>
</td></tr>
<tr><td><code id="freq2raw_+3A_freq">freq</code></td>
<td>
<p>Vector of frequency of each row in <code>data</code>; can be a named column 
in <code>data</code>; if missing, the column <code>Freq</code> is looked for in <code>data</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ouput data frame can be used as input to <code><a href="#topic+bbl">bbl</a></code>.
</p>


<h3>Value</h3>

<p>Data frame with one row per instances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Titanic
x &lt;- as.data.frame(Titanic)
head(x)
titanic &lt;- freq2raw(data=x[,1:3], freq=x$Freq)
head(titanic)
</code></pre>

<hr>
<h2 id='logLik.bbl'>Log likelihood for bbl object</h2><span id='topic+logLik.bbl'></span>

<h3>Description</h3>

<p>Compute log likelihood from a fitted <code>bbl</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.bbl_+3A_object">object</code></td>
<td>
<p>Object of class <code>bbl</code></p>
</td></tr>
<tr><td><code id="logLik.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method uses inferred parameters from calls to <code>bbl</code> 
and data to compute the log likelihood.
</p>


<h3>Value</h3>

<p>An object of class <code>logLik</code>, the Log likelihood value
and the attribute &quot;df&quot; (degrees of freedom), the number of
parameters.
</p>

<hr>
<h2 id='mcSample'>Sample Predictor Distributions</h2><span id='topic+mcSample'></span>

<h3>Description</h3>

<p>Uses fitted BBL model to explore predictor distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcSample(object, nsteps = 1000, verbose = 1, progress.bar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcSample_+3A_object">object</code></td>
<td>
<p>Object of class <code>bbl</code></p>
</td></tr>
<tr><td><code id="mcSample_+3A_nsteps">nsteps</code></td>
<td>
<p>Total number of MC steps</p>
</td></tr>
<tr><td><code id="mcSample_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity level of output</p>
</td></tr>
<tr><td><code id="mcSample_+3A_progress.bar">progress.bar</code></td>
<td>
<p>Display progress bar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After <code>bbl</code> fit, the resulting model is used by this function to sample 
predictor distributions in each response group and find the most likely
preditor set using MCMC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- as.data.frame(Titanic)
b &lt;- bbl(Survived~., data=titanic[,1:4], weights=titanic$Freq)
pxy &lt;- mcSample(b)
pxy
</code></pre>

<hr>
<h2 id='mlestimate'>Maximum likelihood estimate</h2><span id='topic+mlestimate'></span>

<h3>Description</h3>

<p>Perform inference of bias and interaction parameters for a single response group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlestimate(
  xi,
  weights = NULL,
  qJ = NULL,
  method = "pseudo",
  L = NULL,
  lambda = 1e-05,
  lambdah = 0,
  symmetrize = TRUE,
  eps = 0.9,
  nprint = 100,
  itmax = 1e+05,
  tolerance = 1e-04,
  verbose = 1,
  prior.count = 1,
  naive = FALSE,
  lz.half = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlestimate_+3A_xi">xi</code></td>
<td>
<p>Data matrix; expected to be numeric with elements ranging from 
zero to positive integral upper bound <code>L-1</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_weights">weights</code></td>
<td>
<p>Frequency vector of number of times each row of <code>xi</code> 
is to be repeated. If <code>NULL</code>, defaults to 1. Expected
to be non-negative integers.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_qj">qJ</code></td>
<td>
<p>Matrix of logicals indicating which predictor pairs are
interacting. If <code>NULL</code>, all are allowed.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_method">method</code></td>
<td>
<p><code>c('pseudo','mf')</code> for pseudo-likelihood maximization or
mean field inference.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_l">L</code></td>
<td>
<p>Vector of number of factor levels in each predictor. If
<code>NULL</code>, will be inferred from <code>xi</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_lambda">lambda</code></td>
<td>
<p>Vector of L2 regularization parameters for 
<code>method = 'pseudo'</code>. Applies to interaction parameters <code>J</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_lambdah">lambdah</code></td>
<td>
<p>L2 parameters for <code>h</code> in <code>'pseudo'</code>.
If <code>NULL</code>, it is set equal to <code>lambda</code>.
<code>lambdah = 0</code> will free <code>h</code> from penalization.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_symmetrize">symmetrize</code></td>
<td>
<p>Enforce the symmetry of interaction parameters by
taking mean values of the matrix and its trace:
<code class="reqn">J_{ij}^{(y)}(x_1,x_2)=J_{ji}^{(y)}(x_2,x_1)</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_eps">eps</code></td>
<td>
<p>Vector of regularization parameters for <code>mf</code>. Must be
within the range of <code class="reqn">\epsilon \in [0,1]</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_nprint">nprint</code></td>
<td>
<p>Frequency of printing iteration progress under <code>'pseudo'</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations for <code>'pseudo'</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_tolerance">tolerance</code></td>
<td>
<p>Upper bound for fractional changes in pseduo-likelihood
values before termiating iteration in <code>'pseudo'</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity level.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_prior.count">prior.count</code></td>
<td>
<p>Prior count for <code>method = 'mf'</code> to reduce
numerical instability.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_naive">naive</code></td>
<td>
<p>Naive Bayes inference. Equivalent to <code>method = 'mf'</code> together
with <code>eps = 0</code>.</p>
</td></tr>
<tr><td><code id="mlestimate_+3A_lz.half">lz.half</code></td>
<td>
<p>Divide interaction term in approximation to <code class="reqn">\ln Z_{iy}</code>
in <code>'pseudo'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given numeric data matrix, either pseudo-likelihood
of mean-field theory is used to find the maximum likelihood estimate
of bias <code>h</code> and interaction <code>J</code> parameters. Normally
called by <code><a href="#topic+bbl">bbl</a></code> rather than directly.
</p>


<h3>Value</h3>

<p>List of inferred parameters <code>h</code> and <code>J</code>. See 
<code><a href="#topic+bbl">bbl</a></code> for parameter structures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(535)
predictors &lt;- list()
for(i in 1:5) predictors[[i]] &lt;- c('a','c','g','t')
par &lt;- randompar(predictors)
par
xi &lt;- sample_xi(nsample=5000, predictors=predictors, h=par$h, J=par$J,
                code_out=TRUE)
head(xi)
ps &lt;- mlestimate(xi=xi, method='pseudo', lambda=0)
ps$h
ps$J[[1]]
mf &lt;- mlestimate(xi=xi, method='mf', eps=0.9)
plot(x=unlist(par$h), y=unlist(ps$h), xlab='True', ylab='Inferred')
segments(x0=-2, x1=2, y0=-2, y1=2, lty=2)
points(x=unlist(par$J), y=unlist(ps$J), col='red')
points(x=unlist(par$h), y=unlist(mf$h), col='blue')
points(x=unlist(par$J), y=unlist(mf$J), col='green')
</code></pre>

<hr>
<h2 id='model.frame.bbl'>Model Frame for BBL</h2><span id='topic+model.frame.bbl'></span>

<h3>Description</h3>

<p>Returns the model frame used in BBL fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.bbl_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>bbl</code></p>
</td></tr>
<tr><td><code id="model.frame.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame used for fitting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- as.data.frame(Titanic)
fit &lt;- bbl(Survived ~ Class + Sex + Age, data=titanic[,1:4], weights=titanic$Freq)
head(model.frame(fit))
</code></pre>

<hr>
<h2 id='nobs.bbl'>Number of Observations in BBL Fit</h2><span id='topic+nobs.bbl'></span>

<h3>Description</h3>

<p>Returns the number of observations from a BBL fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.bbl_+3A_object">object</code></td>
<td>
<p>Object of class <code>bbl</code></p>
</td></tr>
<tr><td><code id="nobs.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer of number of observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- as.data.frame(Titanic)
fit &lt;- bbl(Survived ~ Class + Sex + Age, data=titanic[,1:4], weights=titanic$Freq)
nobs(fit)
</code></pre>

<hr>
<h2 id='plot.bbl'>Plot bbl object</h2><span id='topic+plot.bbl'></span>

<h3>Description</h3>

<p>Visualize bias and interaction parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
plot(x, layout = NULL, hcol = NULL, Jcol = NULL, npal = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bbl_+3A_x">x</code></td>
<td>
<p>Object of class <code>bbl</code></p>
</td></tr>
<tr><td><code id="plot.bbl_+3A_layout">layout</code></td>
<td>
<p>Matrix of layouts for arrangment of linear and interaction 
parameters. If <code>NULL</code>, the top half will be used for linear 
parameter barplot and bottom half will be divided into interaction 
heatmaps for each response group.</p>
</td></tr>
<tr><td><code id="plot.bbl_+3A_hcol">hcol</code></td>
<td>
<p>Color for linear barplots. Grayscale if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.bbl_+3A_jcol">Jcol</code></td>
<td>
<p>Color for interaction heatmaps. Default (<code>NULL</code>) is 
<code>RdBu</code> from <code>RColorBrewer</code>.</p>
</td></tr>
<tr><td><code id="plot.bbl_+3A_npal">npal</code></td>
<td>
<p>Number of color scales.</p>
</td></tr>
<tr><td><code id="plot.bbl_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method displays a barplot of bias parameters and heatmaps
(one per response group) of interaction parameters. All parameters are
offset by the pooled values (single group inference) unless missing.
</p>

<hr>
<h2 id='plot.cv.bbl'>Plot Cross-validation Outcome</h2><span id='topic+plot.cv.bbl'></span>

<h3>Description</h3>

<p>Plot cross-validation score as a function of regularization parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.bbl'
plot(
  x,
  type = "b",
  log = "x",
  pch = 21,
  bg = "white",
  xlab = NULL,
  ylab = NULL,
  las = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.bbl_+3A_x">x</code></td>
<td>
<p>Object of class <code>cv.bbl</code> from a call to 
<code><a href="#topic+crossVal">crossVal</a></code></p>
</td></tr>
<tr><td><code id="plot.cv.bbl_+3A_type">type</code></td>
<td>
<p>Symbol type in <code><a href="base.html#topic+plot">plot</a></code>, present here to set default.</p>
</td></tr>
<tr><td><code id="plot.cv.bbl_+3A_log">log</code></td>
<td>
<p>Log scale argument to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cv.bbl_+3A_pch">pch</code></td>
<td>
<p>Symbol type code in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cv.bbl_+3A_bg">bg</code></td>
<td>
<p>Symbol background color in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cv.bbl_+3A_xlab">xlab</code></td>
<td>
<p>X axis label</p>
</td></tr>
<tr><td><code id="plot.cv.bbl_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label</p>
</td></tr>
<tr><td><code id="plot.cv.bbl_+3A_las">las</code></td>
<td>
<p>Orientation of axis labels in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cv.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will plot accuracy score as a function of regularization parameter
from a call to <code><a href="#topic+crossVal">crossVal</a></code>.
</p>

<hr>
<h2 id='predict.bbl'>Predict Response Group Using <code>bbl</code> Model</h2><span id='topic+predict.bbl'></span>

<h3>Description</h3>

<p>Make prediction of response group identity based on trained model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
predict(object, newdata, type = "link", verbose = 1, progress.bar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bbl_+3A_object">object</code></td>
<td>
<p>Object of class <code>bbl</code> containing trained model</p>
</td></tr>
<tr><td><code id="predict.bbl_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of new data for which prediction is to
be made. Columns must contain all of those in <code>model@data</code>.
If column names are present, the columns will be matched 
based on them. Extra columns will be ignored. If column names
are not provided, the columns should exactly match 
<code>model@data</code> predictor parts. If <code>NULL</code>, replaced
by <code>model@data</code> (self-prediction).</p>
</td></tr>
<tr><td><code id="predict.bbl_+3A_type">type</code></td>
<td>
<p>Return value type. If <code>'link'</code>, 
the logit scale probabilities. If <code>'prob'</code> the probability itself.</p>
</td></tr>
<tr><td><code id="predict.bbl_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity level</p>
</td></tr>
<tr><td><code id="predict.bbl_+3A_progress.bar">progress.bar</code></td>
<td>
<p>Display progress of response group probability. Useful
for large samples.</p>
</td></tr>
<tr><td><code id="predict.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method uses a new data set for predictors and trained <code>bbl</code> model
parameters to compute posterior probabilities of response group 
identity.
</p>


<h3>Value</h3>

<p>Data frame of predicted posterior probabilities with samples in rows
and response groups in columns. The last column is the predicted
response group with maximum probability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(154)

m &lt;- 5
L &lt;- 3
n &lt;- 1000

predictors &lt;- list()
for(i in 1:m) predictors[[i]] &lt;- seq(0,L-1)
names(predictors) &lt;- paste0('v',1:m)
par &lt;- list(randompar(predictors=predictors, dJ=0.5),
            randompar(predictors=predictors, h0=0.1, J0=0.1, dJ=0.5))
dat &lt;- randomsamp(predictors=predictors, response=c('ctrl','case'), par=par, 
                 nsample=n)
dat &lt;- dat[sample(n),]
dtrain &lt;- dat[seq(n/2),]
dtest &lt;- dat[seq(n/2+1,n),]

model &lt;- bbl(y ~ .^2, data=dtrain)
pred &lt;- predict(model, newdata=dtest)
score &lt;- mean(dtest$y==pred$yhat)
score

auc &lt;- pROC::roc(response=dtest$y, predictor=pred$case, direction='&lt;')$auc
auc
</code></pre>

<hr>
<h2 id='predict.cv.bbl'>Predict using Cross-validation Object</h2><span id='topic+predict.cv.bbl'></span>

<h3>Description</h3>

<p>Use the optimal fitted model from cross-validation run to make prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.bbl'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.bbl_+3A_object">object</code></td>
<td>
<p>Object of class <code>cv.bbl</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.bbl_+3A_...">...</code></td>
<td>
<p>Other parameters to <code><a href="#topic+predict.bbl">predict.bbl</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method will use the fitted model with maximum accuracy score returned
by a call to <code><a href="#topic+crossVal">crossVal</a></code> to make prediction on new data
</p>


<h3>Value</h3>

<p>Data frame of prediction; see <code><a href="#topic+predict.bbl">predict.bbl</a></code>.
</p>

<hr>
<h2 id='print.bbl'>Print Boltzmann Bayes Learning Fits</h2><span id='topic+print.bbl'></span>

<h3>Description</h3>

<p>This method displays model structure and first elements of coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
print(x, showcoeff = TRUE, maxcoeff = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bbl_+3A_x">x</code></td>
<td>
<p>An object of class <code>bbl</code>, usually dervied from a call to
<code><a href="#topic+bbl">bbl</a></code>.</p>
</td></tr>
<tr><td><code id="print.bbl_+3A_showcoeff">showcoeff</code></td>
<td>
<p>Display first few fit coefficients</p>
</td></tr>
<tr><td><code id="print.bbl_+3A_maxcoeff">maxcoeff</code></td>
<td>
<p>Maximum number of coefficients to display</p>
</td></tr>
<tr><td><code id="print.bbl_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Displays the call to <code><a href="#topic+bbl">bbl</a></code>, response variable and its levels,
predictors and their levels, and the first few fit coefficients.
</p>

<hr>
<h2 id='print.cv.bbl'>Display Cross-validation Result</h2><span id='topic+print.cv.bbl'></span>

<h3>Description</h3>

<p>Print cross-validation optimal result and data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.bbl'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cv.bbl_+3A_x">x</code></td>
<td>
<p>Object of class <code>cv.bbl</code></p>
</td></tr>
<tr><td><code id="print.cv.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method prints <code><a href="#topic+crossVal">crossVal</a></code> object with the optimal
regularization condition and maximum accuracy score on top and
the entire score profile as a data frame below.
</p>

<hr>
<h2 id='print.summary.bbl'>Print Summary of Boltzmann Bayes Learning</h2><span id='topic+print.summary.bbl'></span>

<h3>Description</h3>

<p>This method prints the summary of <code>bbl</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.bbl'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.bbl_+3A_x">x</code></td>
<td>
<p>Object of class <code>summary.bbl</code></p>
</td></tr>
<tr><td><code id="print.summary.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The naive Bayes summary of <code>summary.bbl</code> object is displayed.
</p>

<hr>
<h2 id='randompar'>Generate Random Parameters</h2><span id='topic+randompar'></span>

<h3>Description</h3>

<p>Random values of bias and interaction parameters are generated
using either uniform or normal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randompar(predictors, distr = "unif", h0 = 0, dh = 1, J0 = 0, dJ = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randompar_+3A_predictors">predictors</code></td>
<td>
<p>List of predictor factor levels. See <code><a href="#topic+bbl">bbl</a></code>.</p>
</td></tr>
<tr><td><code id="randompar_+3A_distr">distr</code></td>
<td>
<p><code>c('unif','norm')</code> for uniform or normal distributions.</p>
</td></tr>
<tr><td><code id="randompar_+3A_h0">h0</code></td>
<td>
<p>Mean of bias parameters</p>
</td></tr>
<tr><td><code id="randompar_+3A_dh">dh</code></td>
<td>
<p><code>sd</code> of bias if <code>distr = 'unif'</code>. If <code>distr = 'norm'</code>,
<code class="reqn">h = [h_0-dh, h_0+dh]</code>.</p>
</td></tr>
<tr><td><code id="randompar_+3A_j0">J0</code></td>
<td>
<p>Mean of interaction parameters.</p>
</td></tr>
<tr><td><code id="randompar_+3A_dj">dJ</code></td>
<td>
<p><code>sd</code> of interactions if <code>distr = 'unif'</code>. 
If <code>distr = 'norm'</code>, <code class="reqn">J = [J_0-dJ, J_0+dJ]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input argument <code>predictors</code> is used to set up proper list 
structures of parameters.
</p>


<h3>Value</h3>

<p>List of parameters, <code>h</code> and <code>J</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(311)
predictors &lt;- list()
for(i in 1:5) predictors[[i]] &lt;- c('a','c')
par &lt;- randompar(predictors=predictors)
par
</code></pre>

<hr>
<h2 id='randomsamp'>Generate Random Boltzmann Bayes Model Data</h2><span id='topic+randomsamp'></span>

<h3>Description</h3>

<p>Predictor-response paired data are generated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomsamp(predictors, response, prob = NULL, par, nsample = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomsamp_+3A_predictors">predictors</code></td>
<td>
<p>List of vectors of predictor levels</p>
</td></tr>
<tr><td><code id="randomsamp_+3A_response">response</code></td>
<td>
<p>Vector of response variables</p>
</td></tr>
<tr><td><code id="randomsamp_+3A_prob">prob</code></td>
<td>
<p>Vector of probabilities for sampling each response group</p>
</td></tr>
<tr><td><code id="randomsamp_+3A_par">par</code></td>
<td>
<p>List of <code><a href="#topic+bbl">bbl</a></code> parameters for each response group;
e.g., generated from calls to <code><a href="#topic+randompar">randompar</a></code>.</p>
</td></tr>
<tr><td><code id="randomsamp_+3A_nsample">nsample</code></td>
<td>
<p>Sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>response</code> is used to set up all possible levels
of response groups and likewise for <code>predictors</code>. The parameter
argument <code><a href="graphics.html#topic+par">par</a></code> must have the appropriate structure 
consistent with <code>response</code> and <code>predictors</code>. This function
is a wrapper calling <code><a href="#topic+sample_xi">sample_xi</a></code> multiple times.
</p>


<h3>Value</h3>

<p>Data frame of response and predictor variables.
</p>

<hr>
<h2 id='readFasta'>Read FASTA File</h2><span id='topic+readFasta'></span>

<h3>Description</h3>

<p>Read nucleotide sequence files in FASTA format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFasta(file, rownames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFasta_+3A_file">file</code></td>
<td>
<p>File name of FASTA input.</p>
</td></tr>
<tr><td><code id="readFasta_+3A_rownames">rownames</code></td>
<td>
<p>Use the sequence annotation line in file (starts with
<code>'&gt;'</code>) as the row names. Will fail if there are duplicate items.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sequence data in FASTA files are converted into data frame
suitable as input to <code><a href="#topic+bbl">bbl</a></code>. If sequence lengths are different,
instances longer than those already read will be truncated. Empty sequences
are skipped.
</p>


<h3>Value</h3>

<p>Data frame of each sequence in rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- tempfile('data')
write('&gt;seq1', file)
write('atgcc', file, append=TRUE)
write('&gt;seq2', file, append=TRUE)
write('gccaa', file, append=TRUE)
system(paste0('cat ',file))
x &lt;- readFasta(file)
x
</code></pre>

<hr>
<h2 id='removeConst'>Remove Non-varying Predictors</h2><span id='topic+removeConst'></span>

<h3>Description</h3>

<p>Constant predictor is identified and removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeConst(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeConst_+3A_x">x</code></td>
<td>
<p>Data frame containing discrete factor variables in each column</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables with only one factor level is removed from data. Intended
for use before calling <code><a href="#topic+bbl">bbl</a></code>.
</p>


<h3>Value</h3>

<p>Data frame omitting non-varying variables from <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(351)
nt &lt;- c('a','c','g','t')
x &lt;- data.frame(v1=sample(nt,size=50,replace=TRUE),
                v2=rep('a',50),v3=sample(nt,size=50,replace=TRUE))
y &lt;- sample(c('case','ctrl'),size=50,replace=TRUE)
dat &lt;- cbind(data.frame(y=y), x)
summary(dat)
dat &lt;- removeConst(dat)
summary(dat)
</code></pre>

<hr>
<h2 id='residuals.bbl'>Residuals of BBL fit</h2><span id='topic+residuals.bbl'></span>

<h3>Description</h3>

<p>Binary-valued vector of fitted vs. true response group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.bbl_+3A_object">object</code></td>
<td>
<p>Object of class <code>bbl</code></p>
</td></tr>
<tr><td><code id="residuals.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discrete response group identity for each data point is compared with 
the fitted group and 0 (discordant) or 1 (concordant) is returned
</p>


<h3>Value</h3>

<p>Vector binary values for each data point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- as.data.frame(Titanic)
dat &lt;- freq2raw(titanic[,1:4], freq=titanic$Freq)
fit &lt;- bbl(Survived ~ .^2, data=dat)
x &lt;- residuals(fit)
table(x)
</code></pre>

<hr>
<h2 id='sample_xi'>Generate Random Samples from Boltzmann Distribution</h2><span id='topic+sample_xi'></span>

<h3>Description</h3>

<p>Random samples are drawn from Boltzmann distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_xi(nsample = 1, predictors = NULL, h, J, code_out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_xi_+3A_nsample">nsample</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="sample_xi_+3A_predictors">predictors</code></td>
<td>
<p>List of predictor factor levels.</p>
</td></tr>
<tr><td><code id="sample_xi_+3A_h">h</code></td>
<td>
<p>Bias parameter; see <code><a href="#topic+bbl">bbl</a></code>.</p>
</td></tr>
<tr><td><code id="sample_xi_+3A_j">J</code></td>
<td>
<p>Interaction parameters; see <code><a href="#topic+bbl">bbl</a></code>.</p>
</td></tr>
<tr><td><code id="sample_xi_+3A_code_out">code_out</code></td>
<td>
<p>Ouput in integer codes; <code class="reqn">a_i = 0, \cdots, L_i-1</code>.
If <code>FALSE</code>, output in factors in <code>predictors</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All possible factor states are enumerated exhaustively using
input argument <code>predictors</code>. If the number of predictors <code class="reqn">m</code>
or the number of factor levels <code class="reqn">L_i</code> for each predictor <code class="reqn">i</code>
are even moderately large (<code class="reqn">m\ge 10</code> or <code class="reqn">L_i\ge 5</code>), 
this function will likely hang because the number of all possible 
states grows exponentially.
</p>


<h3>Value</h3>

<p>Data frame of samples in rows and predictors in columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(512)
m &lt;- 5
n &lt;- 1000
predictors &lt;- list()
for(i in 1:m) predictors[[i]] &lt;- c('a','c','g','t')
par &lt;- randompar(predictors)
xi &lt;- sample_xi(nsample=n, predictors=predictors, h=par$h, J=par$J)
head(xi)
</code></pre>

<hr>
<h2 id='summary.bbl'>Naive Bayes Summary</h2><span id='topic+summary.bbl'></span>

<h3>Description</h3>

<p>Estimate significant of predictor-group association using naive Bayes model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
summary(object, prior.count = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bbl_+3A_object">object</code></td>
<td>
<p>Object of class <code>bbl</code></p>
</td></tr>
<tr><td><code id="summary.bbl_+3A_prior.count">prior.count</code></td>
<td>
<p>Prior count to be used for computing naive Bayes 
coefficients and test results. If <code>0</code>, will produce <code>NA</code>s 
for factor levels without data points.</p>
</td></tr>
<tr><td><code id="summary.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This <code>summary.bbl</code> method gives a rough overview of associations
within a <code>bbl</code> fit object via naive Bayes coefficients and test 
p-values. Note that naive Bayes results displayed ignore interactions 
even when interactions are present in the model being displayed. This
feature is because simple analytic results exist for naive Bayes 
coefficients and test p-values. The likelihood ratio test is with respect
to the null hypothesis that coefficients are identical for all response
groups.
</p>


<h3>Value</h3>

<p>Object of class <code>summary.bbl</code> extending <code>bbl</code> class; 
a list with extra components
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p>List of bias coefficients of response groups under naive 
Bayes approximation</p>
</td></tr>
<tr><td><code>h0</code></td>
<td>
<p>Bias coefficients of pooled group under naive Bayes</p>
</td></tr>
<tr><td><code>chisqNaive</code></td>
<td>
<p>Vector of chi-square statistics for likelihood ratio test
for each predictor</p>
</td></tr>
<tr><td><code>dfNaive</code></td>
<td>
<p>Vector of degrees of freedom for likelihood ratio test for
each predictor</p>
</td></tr>
<tr><td><code>pvNaive</code></td>
<td>
<p>Vector p-values for each predictor</p>
</td></tr>
</table>

<hr>
<h2 id='weights.bbl'>Weights in BBL Fit</h2><span id='topic+weights.bbl'></span>

<h3>Description</h3>

<p>This method returns weights used in BBL fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbl'
weights(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights.bbl_+3A_object">object</code></td>
<td>
<p>Object of class <code>bbl</code>.</p>
</td></tr>
<tr><td><code id="weights.bbl_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that weithts are integral
frequency values specifying repeat number of each instance in <code>bbl</code>.
If no weights were used (default of 1s), <code>NULL</code> is returned.
</p>


<h3>Value</h3>

<p>Vector of weights for each instance
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
