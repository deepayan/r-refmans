<!DOCTYPE html><html><head><title>Help for package Rdice</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rdice}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coin.flip'>
<p>Coin flip</p></a></li>
<li><a href='#dice.combinations'><p>Dice combinations</p></a></li>
<li><a href='#dice.roll'><p>Dice simulator</p></a></li>
<li><a href='#efron'><p>The standard set of Efron's dice</p></a></li>
<li><a href='#is.nonTransitive'>
<p>Checks truth value of non-transitive sets of dice.</p></a></li>
<li><a href='#miwin'><p>Miwin set of dice.</p></a></li>
<li><a href='#nonTransitive.generator'>
<p>Non-transitive dice generator.</p></a></li>
<li><a href='#oskar'><p>Oskar van Deventer set of dice.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Collection of Functions to Experiment Dice Rolls</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Gennaro Tedesco</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gennaro Tedesco: &lt;gennarotedesco@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to simulate
  dice rolls and the like. In particular, experiments and exercises can
  be performed looking at combinations and permutations of values in dice
  rolls and coin flips, together with the corresponding frequencies of
  occurrences. When applying each function, the user has to input the
  number of times (rolls, flips) to toss the dice. Needless to say, the more
  the tosses, the more the frequencies approximate the actual probabilities.
  Moreover, the package provides functions to generate non-transitive sets
  of dice (like Efron's) and to check whether a given set of dice is non-transitive
  with given probability.</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-09-23 20:26:15 UTC; gennaro</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-09-24 12:58:32</td>
</tr>
</table>
<hr>
<h2 id='coin.flip'>
Coin flip
</h2><span id='topic+coin.flip'></span>

<h3>Description</h3>

<p>Simulates a coin flip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coin.flip(coins = 5, flips = 100, weights = c(0.5, 0.5), getExact)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coin.flip_+3A_coins">coins</code></td>
<td>
<p> The number of coins to flip. If unspecified, it defaults to 5.</p>
</td></tr>
<tr><td><code id="coin.flip_+3A_flips">flips</code></td>
<td>
<p> The number of flips. If missing, it defaults to 100.</p>
</td></tr>
<tr><td><code id="coin.flip_+3A_weights">weights</code></td>
<td>
<p> A vector of probability weights to assign to each face of the coin; if unspecified, it defaults to a fair coin with equally likely faces. If specified, its lenght must obviously be a vector of length two whose values sum up to 1.</p>
</td></tr>
<tr><td><code id="coin.flip_+3A_getexact">getExact</code></td>
<td>
<p> A vector containing values to be matched <em>exactly</em>, namely the function returns only those combinations containing <em>all</em> the above mentioned variables. Since this is a coin flip, values must be specified in the form <code>c("H", "H", "T")</code> as head and tails (make sure to provide the labels in quotation marks).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a particular case of <code><a href="#topic+dice.roll">dice.roll</a></code>, namely a roll with 2 faces and 1 die.
</p>


<h3>Value</h3>

<p> A table containing the frequencies for each of the two occurrences (head and tail) after the specified number of flips.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coin.flip(coins = 5, flips = 100)
</code></pre>

<hr>
<h2 id='dice.combinations'>Dice combinations</h2><span id='topic+dice.combinations'></span>

<h3>Description</h3>

<p>Calculates all possible combinations as result of rolling a set of dice. Similar permutations are identified under the same combination and counted as many times as many occurrencies. Thee user can choose wheter to match exact values or to perform partial matches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dice.combinations(faces, dice, rolls, weights, getPartial, getExact, toSum = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dice.combinations_+3A_faces">faces</code></td>
<td>
<p> The number of faces the dice have; if unspecified, it defaults to 6.</p>
</td></tr>
<tr><td><code id="dice.combinations_+3A_dice">dice</code></td>
<td>
<p> The number of dice to roll; if unspecified, it defaults to 2.</p>
</td></tr>
<tr><td><code id="dice.combinations_+3A_rolls">rolls</code></td>
<td>
<p> The number of times to roll the die; if unspeciefid, it defaults to 5.</p>
</td></tr>
<tr><td><code id="dice.combinations_+3A_weights">weights</code></td>
<td>
<p> A vector of probability weights to assign to each face of the die; if unspecified, it defaults to a fair die with weights <code class="reqn">1/N</code>. If specified, its lenght must obviously be equals to the number of faces and all the single weights must sum up to 1.</p>
</td></tr>
<tr><td><code id="dice.combinations_+3A_getexact">getExact</code></td>
<td>
<p> A vector containing values to be matched <em>exactly</em>, namely the function returns only those combinations containing <em>all</em> the above mentioned variables.</p>
</td></tr>
<tr><td><code id="dice.combinations_+3A_getpartial">getPartial</code></td>
<td>
<p> A vector containing values to be matched <em>partially</em>, namely the function returns only those combinations containing <em>at least one</em> of the above mentioned variables. If missing, it defaults to c(1:faces), namemly the function returns all combinations.</p>
</td></tr>
<tr><td><code id="dice.combinations_+3A_tosum">toSum</code></td>
<td>
<p> A logical value, defaulting to FALSE. If TRUE, the function returns the sum of the frequencies of the matches (to be used together with getExact or getPartial)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns an object of class <em>diceRoll</em>, namely a list whose values are themselves <code>data.table</code> objects, in turn, so that one can directly apply any <code>data.table</code> function thereupon.
</p>


<h3>Value</h3>

<table>
<tr><td><code>values</code></td>
<td>
<p> If toSum = FALSE, a list of all possible combinations rolled, together with corresponding frequencies. If toSum = TRUE, the function returns the sum of all frequencies in correspondence of matched valules.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The case face = 2 corresponds to the <code><a href="#topic+coin.flip">coin.flip</a></code>.
</p>


<h3>See Also</h3>

<p>Makes use of <code><a href="#topic+dice.roll">dice.roll</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dice.combinations(faces = 6, dice = 4, rolls = 100,
    getExact = c(3,5), getPartial = c(1,2), toSum = TRUE)
</code></pre>

<hr>
<h2 id='dice.roll'>Dice simulator</h2><span id='topic+dice.roll'></span>

<h3>Description</h3>

<p>Simulates rolling of a set of dice.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dice.roll(faces, dice, rolls, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dice.roll_+3A_faces">faces</code></td>
<td>
<p> The number of faces the dice have; if unspecified, it defaults to 6.</p>
</td></tr>
<tr><td><code id="dice.roll_+3A_dice">dice</code></td>
<td>
<p> The number of dice to roll; if unspecified, it defaults to 2.</p>
</td></tr>
<tr><td><code id="dice.roll_+3A_rolls">rolls</code></td>
<td>
<p> The number of times to roll the die; if unspeciefid, it defaults to 5.</p>
</td></tr>
<tr><td><code id="dice.roll_+3A_weights">weights</code></td>
<td>
<p> A vector of probability weights to assign to each face of the die; if unspecified, it defaults to a fair die with weights <code class="reqn">1/N</code>. If specified, its lenght must obviously be equals to the number of faces and all the single weights must sum up to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns an object of class <em>diceRoll</em>, namely a list whose values are themselves <code>data.table</code> objects, in turn, so that one can directly apply any <code>data.table</code> function thereupon.
</p>


<h3>Value</h3>

<table>
<tr><td><code>results</code></td>
<td>
<p> The numerical results rolled.</p>
</td></tr>
<tr><td><code>frequencies</code></td>
<td>
<p> A table containing each single occurrency (permutation) of results and the corresponding frequencies.</p>
</td></tr>
<tr><td><code>sums_freq</code></td>
<td>
<p> A table containing the frequencies of the sums of the values obtained in each single roll by all the dice. A cumulative sum is provided too.</p>
</td></tr>
<tr><td><code>exp_value_sum</code></td>
<td>
<p> The expectation value of the sum of the values obtained.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dice.roll(faces = 6, dice = 3, rolls = 5)
</code></pre>

<hr>
<h2 id='efron'>The standard set of Efron's dice</h2><span id='topic+efron'></span>

<h3>Description</h3>

<p>A dataset containing the four standard Efron's dice, non-transitive
set of dice with winning probabilities of 2/3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(efron)
</code></pre>


<h3>Format</h3>

<p>A data table with 4 columns. Each column represents a die
with six faces.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efron)
is.nonTransitive(efron, prob = 2/3)
</code></pre>

<hr>
<h2 id='is.nonTransitive'>
Checks truth value of non-transitive sets of dice.
</h2><span id='topic+is.nonTransitive'></span>

<h3>Description</h3>

<p>Checks whether a given set of dice is non-transitive with given probability. If no probability is given, checks whether a given set of dice is generally non-transitive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.nonTransitive(df, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.nonTransitive_+3A_df">df</code></td>
<td>
<p> A <code>data.frame</code> containing the set of dice to be checked.</p>
</td></tr>
<tr><td><code id="is.nonTransitive_+3A_prob">prob</code></td>
<td>
<p> The non-transitive probability according to which to check for non-transitivity. If unspecified, the function checks for general non-transitivity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value: TRUE or FALSE.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+nonTransitive.generator">nonTransitive.generator</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  die1 = c(5,4,6,15),
  die2 = c(3,6,16,2),
  die3 = c(0,2,14,15),
  die4 = c(8,10,1,9)
)

is.nonTransitive(df, prob = 9/16)
</code></pre>

<hr>
<h2 id='miwin'>Miwin set of dice.</h2><span id='topic+miwin'></span>

<h3>Description</h3>

<p>A dataset containing the Miwin set of dice. This set is non-transitively losing, with losing probabilities of 17/36.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(miwin)
</code></pre>


<h3>Format</h3>

<p>A data table with 3 columns. Each column represents a die with six faces.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miwin)
is.nonTransitive(miwin, prob = 17/36)
</code></pre>

<hr>
<h2 id='nonTransitive.generator'>
Non-transitive dice generator.
</h2><span id='topic+nonTransitive.generator'></span>

<h3>Description</h3>

<p>This function generates <code class="reqn">Z</code> random non-transitive dice given the number faces and the corresponding non-transitive probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonTransitive.generator(dice, faces, max_value = faces, prob, error = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonTransitive.generator_+3A_dice">dice</code></td>
<td>
<p> The number <code class="reqn">Z</code> of non-transitive dice to generate.</p>
</td></tr>
<tr><td><code id="nonTransitive.generator_+3A_faces">faces</code></td>
<td>
<p> The number of faces of each die.</p>
</td></tr>
<tr><td><code id="nonTransitive.generator_+3A_max_value">max_value</code></td>
<td>
<p> The maximum integer allowed as nominal value for the faces. Standard choices are usually <code>max_value = faces</code> (default) or <code>max_value = faces^2</code>.</p>
</td></tr>
<tr><td><code id="nonTransitive.generator_+3A_prob">prob</code></td>
<td>
<p> The probability one wants the set of dice to be non-transitive. If unspecified, a set of dice with different non-transitive probabilities for each pairing will be generated.</p>
</td></tr>
<tr><td><code id="nonTransitive.generator_+3A_error">error</code></td>
<td>
<p> Computational error to check for machine precision equality. It defaults to 0.001: no need to be specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function randomly generates sets of dice and stops as soon as a non-transitive set of dice matching the specified conditions is found and only if so. As such, it might happen that it never returns any value, should the condition for non-transitive dice not be matched. One may need to manually interrupt the run (time delay is provided, one could set it as max threshold.)
</p>


<h3>Value</h3>

<p>A <code>data.table</code> containing the set of non-transitive dice matching the specified conditions.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+is.nonTransitive">is.nonTransitive</a></code>.
</p>

<hr>
<h2 id='oskar'>Oskar van Deventer set of dice.</h2><span id='topic+oskar'></span>

<h3>Description</h3>

<p>A dataset containing the Oskar van Deventer dice, non-transitive
set of dice where  A beats B,C,E; B beats C,D,F; C beats D,E,G; #' D beats A,E,F; E beats B,F,G; F beats A,C,G; G beats A,B,D. #' Consequently, for arbitrarily chosen two dice there is a third one
that beats both of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oskar)
</code></pre>


<h3>Format</h3>

<p>A data table with 6 columns. Each column represents a die
with six faces.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oskar)
is.nonTransitive(oskar)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
