<!DOCTYPE html><html><head><title>Help for package StructFDR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StructFDR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdjStats'><p>Prior Structure-Adjusted Statistic</p></a></li>
<li><a href='#alcohol'>
<p>Alcohol data set</p></a></li>
<li><a href='#EstHyper'><p>Estimate the Hyper-parameter Using Generalized Least Squares</p></a></li>
<li><a href='#MicrobiomeSeqTreeFDR'>
<p>False Discovery Rate (FDR) Control Integrating Prior Tree Structure for Microbiome Data Based on F-test and Residual Permutation.</p></a></li>
<li><a href='#SimulateData'>
<p>Data Simulation Function to Study the Performance of TreeFDR.</p></a></li>
<li><a href='#StructFDR'>
<p>False Discovery Rate (FDR) Control Integrating a General Prior Structure</p></a></li>
<li><a href='#throat.parameter'>
<p>Dirichlet parameters used for generating the artificial data sets.</p></a></li>
<li><a href='#TreeFDR'>
<p>False Discovery Rate (FDR) Control Integrating Prior Tree Structure for Microbiome Data</p></a></li>
<li><a href='#Ztransform'>
<p>Transform P-values to Z-values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>False Discovery Control Procedure Integrating the Prior
Structure Information</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Jun Chen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jun Chen &lt;chen.jun2@mayo.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform more powerful false discovery control (FDR) for microbiome data, taking into account the prior phylogenetic relationship among bacteria species.  As a general methodology, it is applicable to any type of (genomic) data with prior structure information.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), nlme, ape, cluster, dirmult, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, knitr, rmarkdown, ggplot2, reshape</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-14 23:07:38 UTC; m123485</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-14 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdjStats'>Prior Structure-Adjusted Statistic</h2><span id='topic+AdjStats'></span>

<h3>Description</h3>

<p>Produce the prior structure-adjusted statistic.</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdjStats(y, V, k, mu, fudge=0.005)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdjStats_+3A_y">y</code></td>
<td>
<p>a vector or a matrix of unadjusted z-values</p>
</td></tr>
<tr><td><code id="AdjStats_+3A_v">V</code></td>
<td>
<p>a correlation matrix defined based on the prior structure</p>
</td></tr>
<tr><td><code id="AdjStats_+3A_k">k</code></td>
<td>
<p>a numeric value representing the ratio of variance components</p>
</td></tr>
<tr><td><code id="AdjStats_+3A_mu">mu</code></td>
<td>
<p>a numeric value of the mean of the prior distribution</p>
</td></tr>
<tr><td><code id="AdjStats_+3A_fudge">fudge</code></td>
<td>
<p>a small numeric value added to the diagonal of the correlation matrix to improve stability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix of adjusted z-values</p>


<h3>Author(s)</h3>

<p>Jun Chen
</p>


<h3>References</h3>

<p>Xiao, J., Cao, H., Chen, J. (2017). False discovery rate control incorporating phylogenetic tree increases detection power in microbiome-wide multiple testing. Bioinformatics, 33(18), 2873-2881.
</p>

<hr>
<h2 id='alcohol'>
Alcohol data set
</h2><span id='topic+alcohol'></span>

<h3>Description</h3>

<p>The data set was taken from a study of the dietary association with the gut microbiome (Wu, 2011). Here we include the alcohol intake as the primary
phenotype. The OTU abundance data consists of 98 samples with 949 OTUs with prevalence &gt; 10%. The raw counts are normalized to account for variable
library sizes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(alcohol)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;alcohol&quot;
</p>


<h3>Details</h3>

<p>A list containing the normalized OTU data (<code>X</code>, counts divided by GMPR size factors), the taxonomic lineages of the OTUs (<code>otu.name</code>),
the alcohol intake phenotype (High and Low) (<code>Y</code>), the tree (<code>tree</code>).
</p>


<h3>Source</h3>

<p>Wu, Gary D., et al. &quot;Linking long-term dietary patterns with gut microbial enterotypes.&quot; Science 334.6052 (2011): 105-108.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(alcohol)
</code></pre>

<hr>
<h2 id='EstHyper'>Estimate the Hyper-parameter Using Generalized Least Squares</h2><span id='topic+EstHyper'></span>

<h3>Description</h3>

<p>Estimate the hyper-parameter by calling the <code>gls</code> function. The errors are allowed to be correlated and/or have unequal variances.</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstHyper(y, D, init.val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstHyper_+3A_y">y</code></td>
<td>
<p>a vector of z-values.</p>
</td></tr>
<tr><td><code id="EstHyper_+3A_d">D</code></td>
<td>
<p>a distance matrix defined based on the prior structure. Diagonal have to be zeros.</p>
</td></tr>
<tr><td><code id="EstHyper_+3A_init.val">init.val</code></td>
<td>
<p>initial values for the transformed hyper-parameter. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of estimated hyper-parameter values plus log likelihood.
</p>


<h3>Author(s)</h3>

<p>Jun Chen
</p>


<h3>References</h3>

<p>Xiao, J., Cao, H., Chen, J. (2017). False discovery rate control incorporating phylogenetic tree increases detection power in microbiome-wide multiple testing. Bioinformatics, 33(18), 2873-2881.
</p>

<hr>
<h2 id='MicrobiomeSeqTreeFDR'>
False Discovery Rate (FDR) Control Integrating Prior Tree Structure for Microbiome Data Based on F-test and Residual Permutation.
</h2><span id='topic+MicrobiomeSeqTreeFDR'></span>

<h3>Description</h3>

<p>The function is a wrapper of <code>TreeFDR</code> with a pre-defined test based on F-statistic and residual permutation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MicrobiomeSeqTreeFDR (otu.tab, tree, meta.dat, grp.name, adj.name = NULL, 
raw.count = FALSE, B = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MicrobiomeSeqTreeFDR_+3A_otu.tab">otu.tab</code></td>
<td>

<p>a data matrix, rows are the features and columns are the samples.
</p>
</td></tr>
<tr><td><code id="MicrobiomeSeqTreeFDR_+3A_tree">tree</code></td>
<td>

<p>an object of &quot;phylo&quot; class. The tree of OTUs.
</p>
</td></tr>
<tr><td><code id="MicrobiomeSeqTreeFDR_+3A_meta.dat">meta.dat</code></td>
<td>

<p>a data frame containing the variables specified by <code>grp.name</code> and <code>adj.name</code>.
</p>
</td></tr>
<tr><td><code id="MicrobiomeSeqTreeFDR_+3A_grp.name">grp.name</code></td>
<td>

<p>a character string indicating the variable of major interest. Can be categorical or numerical.
</p>
</td></tr>
<tr><td><code id="MicrobiomeSeqTreeFDR_+3A_adj.name">adj.name</code></td>
<td>

<p>a character vector indicating the variables to be adjusted. Can be categorical or numerical.
</p>
</td></tr>
<tr><td><code id="MicrobiomeSeqTreeFDR_+3A_raw.count">raw.count</code></td>
<td>

<p>a logical value indicating whether <code>X</code> are raw counts. If raw counts are supplied, internal normalization/transformation (GMPR/sqrt) will be performed. 
The default is FALSE. The user should be responsible for selecting the appropriate normalization/transformation methods.
</p>
</td></tr>
<tr><td><code id="MicrobiomeSeqTreeFDR_+3A_b">B</code></td>
<td>

<p>the number of permutations.  The default is 100 since the permutation test is very fast.
</p>
</td></tr>
<tr><td><code id="MicrobiomeSeqTreeFDR_+3A_...">...</code></td>
<td>

<p>further arguments such as covariates to be passed to <code>TreeFDR</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.adj</code></td>
<td>
<p>TreeFDR adjusted p-values.</p>
</td></tr>
<tr><td><code>p.unadj</code></td>
<td>
<p>raw p-values.</p>
</td></tr>
<tr><td><code>z.adj</code></td>
<td>
<p>moderated z-values. The scale may be different from the raw z-values.</p>
</td></tr>
<tr><td><code>z.unadj</code></td>
<td>
<p>raw z-values.</p>
</td></tr>
<tr><td><code>k</code>, <code>rho</code></td>
<td>
<p>the estimates of the hyperparameters.  The values indicate the informativeness of the prior structure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Chen
</p>


<h3>References</h3>

<p>Xiao, J., Cao, H., Chen, J. (2017). False discovery rate control incorporating phylogenetic tree increases detection power in microbiome-wide multiple testing. Bioinformatics, 33(18), 2873-2881.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TreeFDR">TreeFDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(StructFDR)

# Generate data
data(throat.parameter)
data.obj &lt;- SimulateData(nCases = 50, nControls = 50, nOTU = 400, nCluster = 20, 
		depth = 10000, p.est = throat.parameter$p.est, theta = throat.parameter$theta,
        scene = 'S2', signal.strength = 4)
meta.dat &lt;- data.frame(group = factor(data.obj$y), sex = sample(gl(2, 50)))
beta.true &lt;- data.obj$beta.true

# Call TreeFDR
tree.fdr.obj &lt;- MicrobiomeSeqTreeFDR(data.obj$X, data.obj$tree, meta.dat, 'group', 'sex', B = 20)
tree.p.adj &lt;- tree.fdr.obj$p.adj

# Empirical power and FDR
(tree.emp.pwr &lt;- sum(tree.p.adj &lt;= 0.05 &amp; beta.true != 0) / sum(beta.true != 0)) 
(tree.emp.fdr &lt;- sum(tree.p.adj &lt;= 0.05 &amp; beta.true == 0) / sum(tree.p.adj &lt;= 0.05)) 

</code></pre>

<hr>
<h2 id='SimulateData'>
Data Simulation Function to Study the Performance of TreeFDR.
</h2><span id='topic+SimulateData'></span>

<h3>Description</h3>

<p>We include five scenarios ('S1-S5'). S1-S3 are phylogeny-informative/clade-consistent scenarios while S4-S5 are
phylogeny-noninformative/clade-inconsistent scenarios. In 'S1', we simulate two large clusters of differentially
abundant OTUs. The fold changes (effect sizes) for OTUs from the same cluster are the same. In 'S2', we weaken the
assumption, and generate variable fold changes for OTUs from the same cluster. In 'S3', we simulate many small
clusters (10) of differentially abundant OTUs with the same effect sizes. In 'S4', we still simulate two large 
clusters of differentially abundant OTUs but we allow opposite effects for OTUs from the same cluster. This violates
the assumption of similar effects for closely related OTUs. In 'S5', we pick 10% random OTUs without respect to 
the underlying phyologeny. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateData(nCases = 50, nControls = 50, nOTU = 400, nCluster = 20, depth = 10000,
		     p.est, theta, scene, signal.strength = 4, otu.no.min = 40, 
		     otu.no.max = 80, zero.pct = 0, balanced = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateData_+3A_ncases">nCases</code>, <code id="SimulateData_+3A_ncontrols">nControls</code></td>
<td>

<p>the number of case and control samples.
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_notu">nOTU</code></td>
<td>

<p>the number of OTUs simulated.
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_ncluster">nCluster</code></td>
<td>

<p>the number of clusters to be clustered. 
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_depth">depth</code></td>
<td>

<p>mean library sizes/sequencing depth. The library sizes are simulated from negative binomial distribution of size=25.
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_p.est">p.est</code>, <code id="SimulateData_+3A_theta">theta</code></td>
<td>

<p>the parameters (proportion vector and dispersion parameter) of the Dirichlet distribution.
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_scene">scene</code></td>
<td>

<p>simulation scenarios. 'S1', 'S2', 'S3', 'S4', 'S5' denote five scenarios, respectively. 
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_signal.strength">signal.strength</code></td>
<td>

<p>the strength of signal (related to the mean and sd of the log fold change). 
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_otu.no.min">otu.no.min</code>, <code id="SimulateData_+3A_otu.no.max">otu.no.max</code></td>
<td>

<p>the minimum and maximum numbers of differentially abundant OTUs. Defaults are 40 and 80.
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_zero.pct">zero.pct</code></td>
<td>

<p>the percentage of non-differential OTUs within the cluster/clade. Applicable to 'S1' and 'S2'
</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_balanced">balanced</code></td>
<td>

<p>a logical value indicating whether the fold changes should be multiplied to cases samples (FALSE, increase/decrease in cases, 
no change for controls) only or to both case and control samples (TRUE, increase in case and control samples). Balanced design will
have similar power for all OTUs.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>y</code></td>
<td>
<p>a vector of group membership. 0 = control, 1 = case.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a matrix of normalized OTU counts. row: OTUs; column: samples.</p>
</td></tr>
<tr><td><code>beta.true</code></td>
<td>
<p>a vector of the true log fold changes for all OTUs. 0s for non-differential OTUs.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>a matrix of the cophenetic distances among the simulated OTUs.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>a simulated coalescent tree of the 'phylo' class.</p>
</td></tr>
<tr><td><code>clustering</code></td>
<td>
<p>a vector of cluster memberships for the OTUs based on PAM.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Chen
</p>


<h3>References</h3>

<p>Xiao, J., Cao, H., Chen, J. (2017). False discovery rate control incorporating phylogenetic tree increases detection power in microbiome-wide multiple testing. Bioinformatics, 33(18), 2873-2881.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data set for different scenarios S1-S5
require(StructFDR)
data(throat.parameter)
# Scene 1
data.obj &lt;- SimulateData(nCases = 50, nControls = 50, nOTU = 400, nCluster = 20, 
		depth = 10000, p.est = throat.parameter$p.est, theta = throat.parameter$theta,
        scene = 'S1', signal.strength = 4)
# Scene 2
data.obj &lt;- SimulateData(nCases = 50, nControls = 50, nOTU = 400, nCluster = 20, 
		depth = 10000, p.est = throat.parameter$p.est, theta = throat.parameter$theta,
        scene = 'S2', signal.strength = 4)
# Scene 3
data.obj &lt;- SimulateData(nCases = 50, nControls = 50, nOTU = 400, nCluster = 100, 
		depth = 10000, p.est = throat.parameter$p.est, theta = throat.parameter$theta,
        scene = 'S3', signal.strength = 4)
# Scene 4
data.obj &lt;- SimulateData(nCases = 50, nControls = 50, nOTU = 400, nCluster = 20, 
		depth = 10000, p.est = throat.parameter$p.est, theta = throat.parameter$theta,
        scene = 'S4', signal.strength = 2)
# Scene 5
data.obj &lt;- SimulateData(nCases = 50, nControls = 50, nOTU = 400, nCluster = 20, 
		depth = 10000, p.est = throat.parameter$p.est, theta = throat.parameter$theta,
        scene = 'S5', signal.strength = 4)       
</code></pre>

<hr>
<h2 id='StructFDR'>
False Discovery Rate (FDR) Control Integrating a General Prior Structure
</h2><span id='topic+StructFDR'></span>

<h3>Description</h3>

<p>The procedure is based on an empirical Bayes hierarchical model, where a structure-based prior distribution is designed to utilize the prior structure information. A moderated
statistic based on posterior mean is used for permutation-based FDR control. By borrowing information from neighboring features defined based a distance metric, it is able to 
improve the statistical power of detecting associated features while controlling the FDR at desired levels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StructFDR(X, Y, D, test.func, perm.func, eff.sign = TRUE, B = 20, q.cutoff = 0.5,
          alpha = 1, adaptive = c('Fisher', 'Overlap'), alt.FDR = c('BH', 'Permutation'),
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StructFDR_+3A_x">X</code></td>
<td>

<p>a data matrix, rows are the features and columns are the samples.
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_y">Y</code></td>
<td>

<p>a vector of the phenotypic values, where association tests are being assessed
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_d">D</code></td>
<td>

<p>a matrix of pairwise distances between features. It determines how the features are related and the neighborhood for information borrowing.
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_test.func">test.func</code></td>
<td>

<p>a function that performs the actual tests. It takes <code>X</code>, <code>Y</code> and ... as the inputs, and returns a list with two slots <code>p.value</code> and <code>e.sign</code>, which are vectors of p-values 
and signs of the effects.
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_perm.func">perm.func</code></td>
<td>

<p>a function that performs the permutation tests. It takes <code>X</code>, <code>Y</code> and ... as the inputs, and returns a list with two slots <code>X</code> and <code>Y</code>, which contain the permuted data.
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_eff.sign">eff.sign</code></td>
<td>

<p>a logical value indicating whether the direction of the effects should be considered. If it is true (default), negative and positive effects provide conflicting 
information. 
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_b">B</code></td>
<td>

<p>the number of permutations.  The default is 20. If computation time is not a big concern, <code>B=100</code> is suggested to achieve excellent reproducibility between different runs.
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_q.cutoff">q.cutoff</code></td>
<td>

<p>the quantile cutoff to determine the feature sets to estimate the number of false positives under the null. This cutoff is to protect the signal part of the distributions. The default is 0.5.
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_alpha">alpha</code></td>
<td>

<p>the exponent applied to the distance matrix. Large values have more smoothing effects for closely related species. The default is 1. If the underlying structure assumption is considered to be very strong, robustness
can be improved by decreasing the value to 0.5.
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_adaptive">adaptive</code></td>
<td>

<p>the proposed procedure is most powerful when the signal structure conforms to the prior structure.  When this assumption is seriously violated, it loses power.  We provide two heuristic adaptive approaches
to compensate the power loss in such situations. 'Fisher' approach compares the number of hits by our method to the alternative FDR approach at an FDR of 20% and uses the alternative FDR approach 
if the number of hits is significantly less based on Fisher's exact test; 'Overlap' method selects the alternative approach when it fails to identify half of the hits from the alternative approach 
at an FDR of 20%. The default is 'Fisher'.
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_alt.fdr">alt.FDR</code></td>
<td>

<p>the alternative FDR control used when the proposed approach is powerless. The default is 'BH' procedure and another option is the permutation-based FDR control ('Permutation')
</p>
</td></tr>
<tr><td><code id="StructFDR_+3A_...">...</code></td>
<td>

<p>further arguments such as covariates to be passed to <code>test.func</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.adj</code></td>
<td>
<p>StructFDR adjusted p-values.</p>
</td></tr>
<tr><td><code>p.unadj</code></td>
<td>
<p>raw p-values.</p>
</td></tr>
<tr><td><code>z.adj</code></td>
<td>
<p>moderated z-values. The scale may be different from the raw z-values.</p>
</td></tr>
<tr><td><code>z.unadj</code></td>
<td>
<p>raw z-values.</p>
</td></tr>
<tr><td><code>k</code>, <code>rho</code></td>
<td>
<p>the estimates of the hyperparameters.  The values indicate the informativeness of the prior structure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Chen
</p>


<h3>References</h3>

<p>Xiao, J., Cao, H., Chen, J. (2017). False discovery rate control incorporating phylogenetic tree increases detection power in microbiome-wide multiple testing. Bioinformatics, 33(18), 2873-2881.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TreeFDR">TreeFDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ape) 
require(nlme)
require(cluster)
require(StructFDR)

# Generate a caelescence tree and partition into 10 clusters
set.seed(1234)
n &lt;- 20
p &lt;- 200
tree &lt;- rcoal(p)
# Pairwise distance matrix. 
D &lt;- cophenetic(tree)
clustering &lt;- pam(D, k=10)$clustering

# Simulate case-control data, assuming cluster 2 is differential  
X.control &lt;- matrix(rnorm(n*p), p, n)
X.case &lt;- matrix(rnorm(n*p), p, n)
eff.size &lt;- rnorm(sum(clustering == 2), 0.5, 0.2)     
X.case[clustering == 2, ] &lt;- X.case[clustering == 2, ] + eff.size
X &lt;- cbind(X.control, X.case)
Y &lt;- gl(2, n) 

# Define testing and permutation function
test.func &lt;- function (X, Y) {
	obj &lt;- apply(X, 1, function(x) {
				ttest.obj &lt;- t.test(x ~ Y)
				c(ttest.obj$p.value, sign(ttest.obj$statistic))
			})
    return(list(p.value=obj[1, ], e.sign=obj[2, ]))
}

perm.func &lt;- function (X, Y) {
	return(list(X=X, Y=sample(Y)))
}

# Call StructFDR
tree.fdr.obj &lt;- StructFDR(X, Y, D, test.func, perm.func)

# Compare StructFDR and BH
tree.fdr.obj$p.adj
tree.fdr.obj$p.adj[clustering == 2]
BH.p.adj &lt;- p.adjust(tree.fdr.obj$p.unadj, 'fdr')
BH.p.adj[clustering == 2]

# Adjusted statistics vs clustering
par(mfrow=c(1, 2))
plot(clustering, tree.fdr.obj$z.unadj)
plot(clustering, tree.fdr.obj$z.adj)

</code></pre>

<hr>
<h2 id='throat.parameter'>
Dirichlet parameters used for generating the artificial data sets.
</h2><span id='topic+throat.parameter'></span>

<h3>Description</h3>

<p>These parameters were derived based on a microbiome data set for studying the effect of
smoking on  the upper respiratory tract microbiome. The left throat microbiome 
was used to estimate the relative proportions of 778 most abundant OTUs. The dispersion parameter was selected
to achieve medium level of zeroinflation (around 50% zeros).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(throat.parameter)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;throat.parameter&quot;
</p>


<h3>Details</h3>

<p>A list containing the proportion vector (<code>throat.p.est</code>) and the dispersion (<code>throat.theta</code>).
</p>


<h3>Source</h3>

<p>Charlson ES, Chen J, Custers-Allen R, Bittinger K, Li H, et al. (2010) 
Disordered Microbial Communities in the Upper Respiratory Tract of 
Cigarette Smokers. PLoS ONE 5(12): e15216. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(throat.parameter)
</code></pre>

<hr>
<h2 id='TreeFDR'>
False Discovery Rate (FDR) Control Integrating Prior Tree Structure for Microbiome Data
</h2><span id='topic+TreeFDR'></span>

<h3>Description</h3>

<p>The procedure is based on an empirical Bayes hierarchical model, where a structure-based prior distribution is designed to utilize the phylogenetic tree. A moderated
statistic based on posterior mean is used for permutation-based FDR control. By borrowing information from neighboring bacterial species, it is able to 
improve the statistical power of detecting associated  bacterial species while controlling the FDR at desired levels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TreeFDR(X, Y, tree, test.func, perm.func, eff.sign = TRUE, B = 20, q.cutoff = 0.5,
       alpha = 1, adaptive = c('Fisher', 'Overlap'), alt.FDR = c('BH', 'Permutation'), 
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreeFDR_+3A_x">X</code></td>
<td>

<p>a data matrix, rows are the features and columns are the samples.
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_y">Y</code></td>
<td>

<p>a vector of the phenotypic values, where association tests are being assessed
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_tree">tree</code></td>
<td>

<p>an object of &quot;phylo&quot; class 
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_test.func">test.func</code></td>
<td>

<p>a function that performs the actual tests. It takes <code>X</code>, <code>Y</code> and ... as the inputs, and returns a list with two slots <code>p.value</code> and <code>e.sign</code>, which are vectors of p-values 
and signs of the effects.
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_perm.func">perm.func</code></td>
<td>

<p>a function that performs the permutation tests. It takes <code>X</code>, <code>Y</code> and ... as the inputs, and returns a list with two slots <code>X</code> and <code>Y</code>, which contain the permuted data.
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_eff.sign">eff.sign</code></td>
<td>

<p>a logical value indicating whether the direction of the effects should be considered. If it is true (default), negative and positive effects provide conflicting 
information. 
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_b">B</code></td>
<td>

<p>the number of permutations.  The default is 20. If computation time is not a big concern, <code>B=100</code> is suggested to achieve excellent reproducibility between different runs.
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_q.cutoff">q.cutoff</code></td>
<td>

<p>the quantile cutoff to determine the feature sets to estimate the number of false positives under the null. This cutoff is to protect the signal part of the distributions. The default is 0.5.
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_alpha">alpha</code></td>
<td>

<p>the exponent applied to the distance matrix. Large values have more smoothing effects for closely related species. The default is 1. If the underlying structure assumption is considered to be very strong, robustness
can be improved by decreasing the value to 0.5.
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_adaptive">adaptive</code></td>
<td>

<p>the proposed procedure is most powerful when the signal is clustered on the tree.  When this assumption is seriously violated, it loses power.  We provide two heuristic adaptive approaches
to compensate the power loss in such situations. 'Fisher' approach compares the number of hits by our method to the alternative FDR approach at an FDR of 20% and uses the alternative FDR approach 
if the number of hits is significantly less based on Fisher's exact test; 'Overlap' method selects the alternative approach when it fails to identify half of the hits from the alternative approach 
at an FDR of 20%. The default is 'Fisher'.
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_alt.fdr">alt.FDR</code></td>
<td>

<p>the alternative FDR control used when the proposed approach is powerless. The default is 'BH' procedure and another option is the permutation-based FDR control ('Permutation')
</p>
</td></tr>
<tr><td><code id="TreeFDR_+3A_...">...</code></td>
<td>

<p>further arguments such as covariates to be passed to <code>test.func</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.adj</code></td>
<td>
<p>TreeFDR adjusted p-values.</p>
</td></tr>
<tr><td><code>p.unadj</code></td>
<td>
<p>raw p-values.</p>
</td></tr>
<tr><td><code>z.adj</code></td>
<td>
<p>moderated z-values. The scale may be different from the raw z-values.</p>
</td></tr>
<tr><td><code>z.unadj</code></td>
<td>
<p>raw z-values.</p>
</td></tr>
<tr><td><code>k</code>, <code>rho</code></td>
<td>
<p>the estimates of the hyperparameters.  The values indicate the informativeness of the prior structure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Chen
</p>


<h3>References</h3>

<p>Xiao, J., Cao, H., Chen, J. (2017). False discovery rate control incorporating phylogenetic tree increases detection power in microbiome-wide multiple testing. Bioinformatics, 33(18), 2873-2881.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StructFDR">StructFDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ape) 
require(nlme)
require(cluster)
require(StructFDR)

# Generate a caelescence tree and partition into 10 clusters
set.seed(1234)
n &lt;- 20
p &lt;- 200
tree &lt;- rcoal(p)
D &lt;- cophenetic(tree)
clustering &lt;- pam(D, k=10)$clustering

# Simulate case-control data, assuming cluster 2 is differential  
X.control &lt;- matrix(rnorm(n*p), p, n)
X.case &lt;- matrix(rnorm(n*p), p, n)
eff.size &lt;- rnorm(sum(clustering == 2), 0.5, 0.2)     
X.case[clustering == 2, ] &lt;- X.case[clustering == 2, ] + eff.size
X &lt;- cbind(X.control, X.case)
Y &lt;- gl(2, n) 

# Define testing and permutation function
test.func &lt;- function (X, Y) {
	obj &lt;- apply(X, 1, function(x) {
				ttest.obj &lt;- t.test(x ~ Y)
				c(ttest.obj$p.value, sign(ttest.obj$statistic))
			})
    return(list(p.value=obj[1, ], e.sign=obj[2, ]))
}

perm.func &lt;- function (X, Y) {
	return(list(X=X, Y=sample(Y)))
}

# Call TreeFDR
tree.fdr.obj &lt;- TreeFDR(X, Y, tree, test.func, perm.func)

# Compare TreeFDR and BH
tree.fdr.obj$p.adj
tree.fdr.obj$p.adj[clustering == 2]
BH.p.adj &lt;- p.adjust(tree.fdr.obj$p.unadj, 'fdr')
BH.p.adj[clustering == 2]

# Adjusted statistics vs clustering
par(mfrow=c(1, 2))
plot(clustering, tree.fdr.obj$z.unadj)
plot(clustering, tree.fdr.obj$z.adj)
</code></pre>

<hr>
<h2 id='Ztransform'>
Transform P-values to Z-values
</h2><span id='topic+Ztransform'></span>

<h3>Description</h3>

<p>Transform the p-values to z-values. Both two-sided and one-sided transformations are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ztransform(p.value, e.sign, eff.sign = TRUE, tol = 1e-15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ztransform_+3A_p.value">p.value</code></td>
<td>

<p>a vector of p-values
</p>
</td></tr>
<tr><td><code id="Ztransform_+3A_e.sign">e.sign</code></td>
<td>

<p>a vector of signs of the effects, taken on value -1 and 1. (In effects when 'eff.sign = TRUE')
</p>
</td></tr>
<tr><td><code id="Ztransform_+3A_eff.sign">eff.sign</code></td>
<td>

<p>a logical value indicating whether the direction/sign of the effect should be considered
</p>
</td></tr>
<tr><td><code id="Ztransform_+3A_tol">tol</code></td>
<td>

<p>a numeric value at which the p-value (both ends) will truncate. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of z-values
</p>


<h3>Author(s)</h3>

<p>Jun Chen
</p>


<h3>References</h3>

<p>Xiao, J., Cao, H., Chen, J. (2017). False discovery rate control incorporating phylogenetic tree increases detection power in microbiome-wide multiple testing. Bioinformatics, 33(18), 2873-2881.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
