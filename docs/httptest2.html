<!DOCTYPE html><html><head><title>Help for package httptest2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {httptest2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#httptest2'><p><code>httptest2</code>: A Test Environment for HTTP Requests</p></a></li>
<li><a href='#.mockPaths'><p>Set an alternate directory for mock API fixtures</p></a></li>
<li><a href='#as.redactor'><p>Wrap a redacting expression as a proper function</p></a></li>
<li><a href='#build_mock_url'><p>Convert a request to a mock file path</p></a></li>
<li><a href='#capture_requests'><p>Record API responses as mock files</p></a></li>
<li><a href='#change_state'><p>Handle a change of server state</p></a></li>
<li><a href='#expect_request_header'><p>Test that an HTTP request is made with a header</p></a></li>
<li><a href='#expect_verb'><p>Expectations for mocked HTTP requests</p></a></li>
<li><a href='#find_mock_file'><p>Go through mock paths to find the local mock file location</p></a></li>
<li><a href='#get_current_redactor'><p>Fetch the active redacting function</p></a></li>
<li><a href='#gsub_response'><p>Find and replace within a response object</p></a></li>
<li><a href='#redact'><p>Remove sensitive content from HTTP responses</p></a></li>
<li><a href='#save_response'><p>Write out a captured response</p></a></li>
<li><a href='#set_redactor'><p>Set a response redactor</p></a></li>
<li><a href='#start_vignette'><p>Set mocking/capturing state for a vignette</p></a></li>
<li><a href='#use_httptest2'><p>Use 'httptest2' in your tests</p></a></li>
<li><a href='#with_mock_api'><p>Serve a mock API from files</p></a></li>
<li><a href='#with_mock_dir'><p>Use or create mock files depending on their existence</p></a></li>
<li><a href='#with_trace'><p>Wrapper around 'trace' to untrace when finished</p></a></li>
<li><a href='#without_internet'><p>Make all HTTP requests raise an error</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Test Helpers for 'httr2'</td>
</tr>
<tr>
<td>Description:</td>
<td>Testing and documenting code that communicates with remote servers
    can be painful. This package helps with writing tests for packages that
    use 'httr2'. It enables testing all of the logic
    on the R sides of the API without requiring access to the
    remote service, and it also allows recording real API responses to use as
    test fixtures. The ability to save responses and load them offline also
    enables writing vignettes and other dynamic documents that can be
    distributed without access to a live server.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://enpiar.com/httptest2/">https://enpiar.com/httptest2/</a>,
<a href="https://github.com/nealrichardson/httptest2">https://github.com/nealrichardson/httptest2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nealrichardson/httptest2/issues">https://github.com/nealrichardson/httptest2/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, httr2, jsonlite, rlang, stats, testthat, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>curl, knitr, pkgload, rmarkdown, spelling, webfakes, xml2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-07 18:31:50 UTC; npr</td>
</tr>
<tr>
<td>Author:</td>
<td>Neal Richardson <a href="https://orcid.org/0009-0002-7992-3520"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jonathan Keane [ctb],
  Maëlle Salmon <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Neal Richardson &lt;neal.p.richardson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-07 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='httptest2'><code>httptest2</code>: A Test Environment for HTTP Requests</h2><span id='topic+httptest2'></span><span id='topic+httptest2-package'></span>

<h3>Description</h3>

<p>The <code>httptest2</code> package lets you test R code that wraps an API without
requiring access to the remote service. It provides multiple test contexts
that mock the network connection in different ways. <code><a href="#topic+with_mock_api">with_mock_api()</a></code> lets
you provide custom fixtures as responses to requests, stored as plain-text
files in your test directory. <code><a href="#topic+without_internet">without_internet()</a></code> converts HTTP requests
into errors that print the request method, URL, and body payload, if
provided, allowing you to assert that a function call would make a
correctly-formed HTTP request or assert that a function does not make a
request (because if it did, it would raise an error in this context).
</p>


<h3>Details</h3>

<p>The package also includes <code><a href="#topic+capture_requests">capture_requests()</a></code>, a context that collects the
responses from requests you make and stores them as mock files. This enables
you to perform a series of requests against a live server once and then build
your test suite using those mocks, running your tests in <code>with_mock_api()</code>.
For a context that combines both recording and mocking, use
<code><a href="#topic+with_mock_dir">with_mock_dir()</a></code>: it records the first time it is run, and subsequent
runs use the mocks for offline testing.
</p>
<p><code>httptest2</code> also includes expectations to assert that HTTP requests
were&mdash;or were not&mdash;made. <code><a href="#topic+expect_GET">expect_GET()</a></code>, <code><a href="#topic+expect_PUT">expect_PUT()</a></code>, <code><a href="#topic+expect_PATCH">expect_PATCH()</a></code>,
<code><a href="#topic+expect_POST">expect_POST()</a></code>, and <code><a href="#topic+expect_DELETE">expect_DELETE()</a></code> assert that the specified HTTP request
is made within one of the test contexts. They catch the error or message
raised by the mocked HTTP service and check that the request URL and optional
body match the expectation. <code><a href="#topic+expect_no_request">expect_no_request()</a></code> is the inverse of those: it
asserts that no error or message from a mocked HTTP service is raised.
<code><a href="#topic+expect_request_header">expect_request_header()</a></code> asserts that an HTTP request, mocked or not,
contains a request header.
</p>
<p>For an overview of testing with <code>httptest2</code>, see <code>vignette("httptest2")</code>.
</p>
<p>When recording requests, by default <code>httptest2</code> looks for and redacts the
standard ways that auth credentials are passed in requests. This prevents you
from accidentally publishing your personal tokens. The redacting behavior is
fully customizable, either by providing a <code>function (response) {...}</code> to
<code>set_redactor()</code>, or by placing a function in your package's
<code>inst/httptest2/redact.R</code> that will be used automatically any time you record
requests with your package loaded. See <code>vignette("redacting")</code> for details.
</p>
<p><code>httptest2</code> also enables you to write package vignettes and other R Markdown
documents that communicate with a remote API. By adding as little as
<code><a href="#topic+start_vignette">start_vignette()</a></code> to the beginning of your vignette, you can safely record
API responses from a live session, using your secret credentials. These API
responses are scrubbed of sensitive personal information and stored in a
subfolder in your <code>vignettes</code> directory. Subsequent vignette builds,
including on continuous-integration services, CRAN, and your package users'
computers, use these recorded responses, allowing the document to regenerate
without a network connection or API credentials. To record fresh API
responses, delete the subfolder of cached responses and re-run. See
<code>vignette("vignettes")</code> for more discussion and links to examples.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Neal Richardson <a href="mailto:neal.p.richardson@gmail.com">neal.p.richardson@gmail.com</a> (<a href="https://orcid.org/0009-0002-7992-3520">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jonathan Keane <a href="mailto:jkeane@gmail.com">jkeane@gmail.com</a> [contributor]
</p>
</li>
<li><p> Maëlle Salmon <a href="mailto:maelle.salmon@yahoo.se">maelle.salmon@yahoo.se</a> (<a href="https://orcid.org/0000-0002-2815-0399">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://enpiar.com/httptest2/">https://enpiar.com/httptest2/</a>
</p>
</li>
<li> <p><a href="https://github.com/nealrichardson/httptest2">https://github.com/nealrichardson/httptest2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nealrichardson/httptest2/issues">https://github.com/nealrichardson/httptest2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.mockPaths'>Set an alternate directory for mock API fixtures</h2><span id='topic+.mockPaths'></span>

<h3>Description</h3>

<p>By default, <code>with_mock_api()</code> will look for and <code>capture_requests()</code> will
write mocks to your package's <code>tests/testthat</code> directory, or else the current
working directory if that path does not exist. If you want to look in or
write to other places, call <code>.mockPaths()</code> to add directories to the search
path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mockPaths(new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".mockPaths_+3A_new">new</code></td>
<td>
<p>Either a character vector of path(s) to add, or <code>NULL</code> to reset
to the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It works like <code><a href="base.html#topic+libPaths">base::.libPaths()</a></code>: any directories you specify will be added
to the list and searched first. The default directory will be searched last.
Only unique values are kept: if you provide a path that is already found in
<code>.mockPaths()</code>, the result effectively moves that path to the first position.
</p>
<p>For finer-grained control, or to completely override the default behavior
of searching in the current working directory, you can set the option
&quot;httptest2.mock.paths&quot; directly.
</p>


<h3>Value</h3>

<p>If <code>new</code> is omitted, the function returns the current search paths, a
a character vector. If <code>new</code> is provided, the updated value will be returned
invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.mockPaths()
.mockPaths("/var/somewhere/else")
.mockPaths()
.mockPaths(NULL)
.mockPaths()
</code></pre>

<hr>
<h2 id='as.redactor'>Wrap a redacting expression as a proper function</h2><span id='topic+as.redactor'></span>

<h3>Description</h3>

<p>Redactors take a <code>httr2_response</code> or <code>httr2_request</code> as their first argument, and some take additional
arguments: <code>redact_headers()</code>, for example, requires that you specify
<code>headers</code>. This function allows you to take a simplified expression via a
formula, similar to what <code>purrr</code> does, so that you can provide the function
to <code>capture_requests()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.redactor(fmla)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.redactor_+3A_fmla">fmla</code></td>
<td>
<p>Partial expression (a <code>formula</code>) to turn into a function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, <code>as.redactor(~ redact_headers(., "X-Custom-Header"))</code> is equivalent
to <code>function (response) redact_headers(response, "X-Custom-Header")</code>. This
allows you to do
<code>set_redactor(~ redact_headers(., "X-Custom-Header"))</code>.
</p>


<h3>Value</h3>

<p>A <code>function</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capture_requests">capture_requests()</a></code>
</p>

<hr>
<h2 id='build_mock_url'>Convert a request to a mock file path</h2><span id='topic+build_mock_url'></span>

<h3>Description</h3>

<p>Requests are translated to mock file paths according to several rules that
incorporate the request method, URL, query parameters, and body.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_mock_url(req)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_mock_url_+3A_req">req</code></td>
<td>
<p>A <code>httr2_request</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the request protocol, such as &quot;https://&quot;, is removed from the URL.
Second, if the request URL contains a query string, it will be popped off,
hashed by <code><a href="digest.html#topic+digest">digest::digest()</a></code>, and the first six characters appended to the
file being read. Third, request bodies are similarly hashed and
appended. Finally, if a request method other than GET is used it will be
appended to the end of the end of the file name.
</p>
<p>Mock file paths also have a file extension appended, based on the
<code>Content-Type</code> of the response, though this function, which is only concerned
with the request, does not add the extension. In an
HTTP API, a &quot;directory&quot; itself is a resource,
so the extension allows distinguishing directories and files in the file
system. That is, a mocked <code style="white-space: pre;">&#8288;GET http://example.com/api/&#8288;</code> may read a
&quot;example.com/api.json&quot; file, while
<code style="white-space: pre;">&#8288;GET http://example.com/api/object1/&#8288;</code> reads &quot;example.com/api/object1.json&quot;.
</p>
<p>Other examples:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;GET http://example.com/api/object1/?a=1&#8288;</code> may read
&quot;example.com/api/object1-b64371.xml&quot;.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;POST http://example.com/api/object1/?a=1&#8288;</code> may read
&quot;example.com/api/object1-b64371-POST.json&quot;.
</p>
</li></ul>

<p>Note that if you are trying to guess the mock file paths corresponding to a
test for which you intend to create a mock file manually,
instead of trying to build the URL, you should run the test
with <code>with_mock_api()</code> as the error message will contain the mock file path.
</p>


<h3>Value</h3>

<p>A file path and name, without an extension. The file, or a file with
some extension appended, may or may not
exist: existence is not a concern of this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with_mock_api">with_mock_api()</a></code> <code><a href="#topic+capture_requests">capture_requests()</a></code>
</p>

<hr>
<h2 id='capture_requests'>Record API responses as mock files</h2><span id='topic+capture_requests'></span><span id='topic+start_capturing'></span><span id='topic+stop_capturing'></span>

<h3>Description</h3>

<p><code>capture_requests()</code> is a context that collects the responses from requests
you make and stores them as mock files. This enables you to perform a series
of requests against a live server once and then build your test suite using
those mocks, running your tests in <code><a href="#topic+with_mock_api">with_mock_api()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_requests(expr, simplify = TRUE)

start_capturing(simplify = TRUE)

stop_capturing()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capture_requests_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the context</p>
</td></tr>
<tr><td><code id="capture_requests_+3A_simplify">simplify</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), plain-text responses with status 200
will be written as just the text of the response body. In all other cases,
and when <code>simplify</code> is <code>FALSE</code>, the <code>httr2_response</code> object will be written out to
a .R file using <code><a href="base.html#topic+dput">base::dput()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>start_capturing()</code> and <code>stop_capturing()</code> allow you to turn on/off request
recording for more convenient use in an interactive session.
</p>
<p>Recorded responses are written out as plain-text files. By storing fixtures
as plain-text files, you can
more easily confirm that your mocks look correct, and you can more easily
maintain them without having to re-record them. If the API changes subtly,
such as when adding an additional attribute to an object, you can just touch
up the mocks.
</p>
<p>If the response has status <code style="white-space: pre;">&#8288;200 OK&#8288;</code> and the <code>Content-Type</code>
maps to a supported file extension&mdash;currently <code>.json</code>,
<code>.html</code>, <code>.xml</code>, <code>.txt</code>, <code>.csv</code>, and <code>.tsv</code>&mdash;just the response body will be
written out, using the appropriate extension. <code style="white-space: pre;">&#8288;204 No Content&#8288;</code> status
responses will be stored as an empty file with extension <code>.204</code>. Otherwise,
the response will be written as a <code>.R</code> file containing syntax that, when
executed, recreates the <code>httr2_response</code> object.
</p>
<p>Files are saved to the first directory in <code><a href="#topic+.mockPaths">.mockPaths()</a></code>, which if not
otherwise specified is either &quot;tests/testthat&quot; if it exists
(as it should if you are in the root directory of your package),
else the current working directory.
If you have trouble when recording responses, or are unsure where the files
are being written, set <code>options(httptest2.verbose = TRUE)</code> to print a message
for every file that is written containing the absolute path of the file.
</p>


<h3>Value</h3>

<p><code>capture_requests()</code> returns the result of <code>expr</code>. <code>start_capturing()</code>
invisibly returns the destination directory.
<code>stop_capturing()</code> returns nothing; it is called for its side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_mock_url">build_mock_url()</a></code> for how requests are translated to file paths.
And see <code>vignette("redacting", package = "httptest2")</code>
for details on how to prune sensitive content from responses when recording.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setup so that our examples clean up after themselves
tmp &lt;- tempfile()
.mockPaths(tmp)
on.exit(unlink(tmp, recursive = TRUE))

library(httr2)
capture_requests({
  request("http://httpbin.org/get") %&gt;% req_perform()
  request("http://httpbin.org/response-headers") %&gt;%
    req_headers(`Content-Type` = "application/json") %&gt;%
    req_perform()
})
# Or:
start_capturing()
request("http://httpbin.org/get") %&gt;% req_perform()
request("http://httpbin.org/response-headers") %&gt;%
  req_headers(`Content-Type` = "application/json") %&gt;%
  req_perform()
stop_capturing()

</code></pre>

<hr>
<h2 id='change_state'>Handle a change of server state</h2><span id='topic+change_state'></span>

<h3>Description</h3>

<p>In a vignette, put a call to <code>change_state()</code> before any code block that
makes a change on
the server, or rather, before any code block that might repeat the same
request previously done and expect a different result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_state()
</code></pre>


<h3>Details</h3>

<p><code>change_state()</code> works by layering a new directory on top of the existing
<code><a href="#topic+.mockPaths">.mockPaths()</a></code>, so fixtures are recorded/loaded there, masking rather than
overwriting previously recorded responses for the same request. In
vignettes, these mock layers are subdirectories with integer names.
</p>


<h3>Value</h3>

<p>Invisibly, the return of <code>.mockPaths()</code> with the new path added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_vignette">start_vignette()</a></code>;
<code>vignette("vignettes", package = "httptest2")</code> for an overview of all
</p>

<hr>
<h2 id='expect_request_header'>Test that an HTTP request is made with a header</h2><span id='topic+expect_request_header'></span>

<h3>Description</h3>

<p>This expectation checks that HTTP headers (and potentially header values)
are present in a request. It works both in the mock HTTP contexts and on
&quot;live&quot; HTTP requests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_request_header(
  expr,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  perl = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_request_header_+3A_expr">expr</code></td>
<td>
<p>Code to evaluate</p>
</td></tr>
<tr><td><code id="expect_request_header_+3A_...">...</code></td>
<td>
<p>Named headers to match. Values should either be a string (length-1
character), which will be passed to <code><a href="testthat.html#topic+expect_match">testthat::expect_match()</a></code>, or <code>NULL</code> to
assert that the named header is not present in the request. To assert that a
header is merely present in the request, without asserting anything about its
contents, provide an empty string (<code>""</code>). Header names are always
case-insensitive; header values will be matched using the following
parameters:</p>
</td></tr>
<tr><td><code id="expect_request_header_+3A_fixed">fixed</code></td>
<td>
<p>logical.  If <code>TRUE</code>, <code>pattern</code> is a string to be
matched as is.  Overrides all conflicting arguments.</p>
</td></tr>
<tr><td><code id="expect_request_header_+3A_ignore.case">ignore.case</code></td>
<td>
<p>if <code>FALSE</code>, the pattern matching is <em>case
sensitive</em> and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
<tr><td><code id="expect_request_header_+3A_perl">perl</code></td>
<td>
<p>logical.  Should Perl-compatible regexps be used?</p>
</td></tr>
<tr><td><code id="expect_request_header_+3A_usebytes">useBytes</code></td>
<td>
<p>logical.  If <code>TRUE</code> the matching is done
byte-by-byte rather than character-by-character.  See
&lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code>expr</code> if there are no expectation failures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(httr2)
expect_request_header(
  request("http://httpbin.org") %&gt;%
    req_headers(Accept = "image/png") %&gt;%
    req_perform(),
  accept = "image/png",
  `x-fake-header` = NULL
)
expect_request_header(
  request("http://httpbin.org") %&gt;%
    req_headers(Accept = "image/png") %&gt;%
    req_perform(),
  accept = ""
)

</code></pre>

<hr>
<h2 id='expect_verb'>Expectations for mocked HTTP requests</h2><span id='topic+expect_verb'></span><span id='topic+expect_GET'></span><span id='topic+expect_POST'></span><span id='topic+expect_PUT'></span><span id='topic+expect_PATCH'></span><span id='topic+expect_DELETE'></span><span id='topic+expect_no_request'></span>

<h3>Description</h3>

<p>The mock contexts in <code>httptest2</code> can raise errors or messages when requests
are made, and those (error) messages have three
elements, separated by space: (1) the request
method (e.g. &quot;GET&quot;); (2) the request URL; and
(3) the request body, if present.
These verb-expectation functions look for this message shape. <code>expect_PUT</code>,
for instance, looks for a request message that starts with &quot;PUT&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_GET(object, url = "", ...)

expect_POST(object, url = "", ...)

expect_PATCH(object, url = "", ...)

expect_PUT(object, url = "", ...)

expect_DELETE(object, url = "", ...)

expect_no_request(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_verb_+3A_object">object</code></td>
<td>
<p>Code to execute that may cause an HTTP request</p>
</td></tr>
<tr><td><code id="expect_verb_+3A_url">url</code></td>
<td>
<p>character: the URL you expect a request to be made to. Default is
an empty string, meaning that you can just assert that a request is made with
a certain method without asserting anything further.</p>
</td></tr>
<tr><td><code id="expect_verb_+3A_...">...</code></td>
<td>
<p>character segments of a request payload you expect to be included
in the request body, to be joined together by <code>paste0()</code>. You may also pass
any of the following named logical arguments, which will be passed to
<code><a href="base.html#topic+grep">base::grepl()</a></code>:
</p>

<ul>
<li> <p><code>fixed</code>: Should matching take the pattern as is or treat it as a regular
expression. Default: <code>TRUE</code>, and note that this default is the opposite of
the default in <code>grepl</code>. (The rest of the arguments follow its defaults.)
</p>
</li>
<li> <p><code>ignore.case</code>: Should matching be done case insensitively? Default:
<code>FALSE</code>, meaning matches are case sensitive.
</p>
</li>
<li> <p><code>perl</code>: Should Perl-compatible regular expressions be used? Default: <code>FALSE</code>
</p>
</li>
<li> <p><code>useBytes</code>: Should matching be done byte-by-byte rather than
character-by-character? Default: <code>FALSE</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>testthat</code> 'expectation'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(httr2)
without_internet({
  expect_GET(
    request("http://httpbin.org/get") %&gt;% req_perform(),
    "http://httpbin.org/get"
  )
  expect_GET(
    request("http://httpbin.org/get") %&gt;% req_perform(),
    "http://httpbin.org/[a-z]+",
    fixed = FALSE # For regular expression matching
  )
  expect_PUT(
    request("http://httpbin.org/put") %&gt;%
      req_method("PUT") %&gt;%
      req_body_json(list(a = 1)) %&gt;%
      req_perform(),
    "http://httpbin.org/put",
    '{"a":1}'
  )
  # Don't need to assert the request body, or even the URL
  expect_PUT(
    request("http://httpbin.org/put") %&gt;%
      req_method("PUT") %&gt;%
      req_body_json(list(a = 1)) %&gt;%
      req_perform()
  )
  expect_no_request(rnorm(5))
})
</code></pre>

<hr>
<h2 id='find_mock_file'>Go through mock paths to find the local mock file location</h2><span id='topic+find_mock_file'></span>

<h3>Description</h3>

<p>Go through mock paths to find the local mock file location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_mock_file(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_mock_file_+3A_file">file</code></td>
<td>
<p>A file path, as generated by <code><a href="#topic+build_mock_url">build_mock_url()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A path to a file that exists, or <code>NULL</code> if none found.
</p>

<hr>
<h2 id='get_current_redactor'>Fetch the active redacting function</h2><span id='topic+get_current_redactor'></span>

<h3>Description</h3>

<p>Called inside <code><a href="#topic+capture_requests">capture_requests()</a></code>. If using the default redactor, it checks
each time it is called to see if any new packages have been attached, in case
there are package redactors in them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_current_redactor()
</code></pre>


<h3>Value</h3>

<p>A redacting function.
</p>

<hr>
<h2 id='gsub_response'>Find and replace within a response object</h2><span id='topic+gsub_response'></span>

<h3>Description</h3>

<p>This function passes its arguments to <code><a href="base.html#topic+grep">base::gsub()</a></code> in order to find and
replace string patterns (regular expressions) within
the URL and the response body of <code>httr2_response</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsub_response(response, pattern, replacement, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsub_response_+3A_response">response</code></td>
<td>
<p>An <code>httr2_response</code> or <code>http2_request</code> object to sanitize.</p>
</td></tr>
<tr><td><code id="gsub_response_+3A_pattern">pattern</code></td>
<td>
<p>From <code><a href="base.html#topic+grep">base::gsub()</a></code>: &quot;character string containing a regular
expression (or character string for <code>fixed = TRUE</code>) to be matched in the
given character vector.&quot; Passed to <code>gsub()</code>. See the docs for <code>gsub()</code> for
further details.</p>
</td></tr>
<tr><td><code id="gsub_response_+3A_replacement">replacement</code></td>
<td>
<p>A replacement for the matched pattern, possibly including
regular expression backreferences. Passed to <code>gsub()</code>. See the docs for
<code>gsub()</code> for further details.</p>
</td></tr>
<tr><td><code id="gsub_response_+3A_...">...</code></td>
<td>
<p>Additional logical arguments passed to <code>gsub()</code>: <code>ignore.case</code>,
<code>perl</code>, <code>fixed</code>, and <code>useBytes</code> are the possible options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, unlike <code>gsub()</code>, the first argument of the function is <code>response</code>,
not <code>pattern</code>, while the equivalent argument in <code>gsub()</code>, &quot;<code>x</code>&quot;, is placed
third. This difference is to maintain consistency with the other redactor
functions in <code>httptest2</code>, which all take <code>response</code> as the first argument.
</p>
<p>This function also can be applied to an <code>http2_request</code> object to replace
patterns inside the request URL.
</p>


<h3>Value</h3>

<p>An <code>httr2_response</code> object, same as was passed in, with the
pattern replaced in the URLs and bodies.
</p>

<hr>
<h2 id='redact'>Remove sensitive content from HTTP responses</h2><span id='topic+redact'></span><span id='topic+redact_cookies'></span><span id='topic+redact_headers'></span><span id='topic+within_body_text'></span>

<h3>Description</h3>

<p>When recording requests for use as test fixtures, you don't want to include
secrets like authentication tokens and personal ids. These functions provide
a means for redacting this kind of content, or anything you want, from
responses that <code><a href="#topic+capture_requests">capture_requests()</a></code> saves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redact_cookies(response)

redact_headers(response, headers = c())

within_body_text(response, FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redact_+3A_response">response</code></td>
<td>
<p>An <code>httr2_response</code> or <code>httr2_request</code> object to sanitize.</p>
</td></tr>
<tr><td><code id="redact_+3A_headers">headers</code></td>
<td>
<p>For <code>redact_headers()</code>, a character vector of header names to
sanitize.</p>
</td></tr>
<tr><td><code id="redact_+3A_fun">FUN</code></td>
<td>
<p>For <code>within_body_text()</code>, a function that takes as its argument a
character vector and returns a modified version of that. This function will
be applied to the text of the response's body.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>redact_cookies()</code> removes cookies from <code>httr2_response</code> objects
and is the default redactor in <code>capture_requests()</code>.
<code>redact_headers()</code> lets you target selected request and response headers for
redaction.
<code>within_body_text()</code> lets you manipulate the text of the response body
and manages the parsing of the raw (binary) data in the <code>httr_response</code> object.
</p>
<p>Note that if you set a redacting function, it will also be applied to requests when loading mocks. This allows you to sanitize and/or shorten URLs in your mock files.
</p>


<h3>Value</h3>

<p>All redacting functions return a well-formed <code>httr2_response</code>
or <code>httr2_request</code> object.
</p>


<h3>See Also</h3>

<p><code>vignette("redacting", package = "httptest2")</code> for a detailed discussion of what these functions do and how to customize them. <code><a href="#topic+gsub_response">gsub_response()</a></code> is another redactor.
</p>

<hr>
<h2 id='save_response'>Write out a captured response</h2><span id='topic+save_response'></span>

<h3>Description</h3>

<p>Write out a captured response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_response(response, file, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_response_+3A_response">response</code></td>
<td>
<p>An <code>httr2_response</code> object</p>
</td></tr>
<tr><td><code id="save_response_+3A_file">file</code></td>
<td>
<p>String file path to write to</p>
</td></tr>
<tr><td><code id="save_response_+3A_simplify">simplify</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), JSON responses with status 200
and a supported <code>Content-Type</code>
will be written as just the text of the response body. In all other cases,
and when <code>simplify</code> is <code>FALSE</code>, the <code>httr2_response</code> object will be written
out to a .R file using <code><a href="base.html#topic+dput">base::dput()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The character file name that was written out
</p>

<hr>
<h2 id='set_redactor'>Set a response redactor</h2><span id='topic+set_redactor'></span>

<h3>Description</h3>

<p>A redactor is a function that alters the response content being written
out in the <code><a href="#topic+capture_requests">capture_requests()</a></code> context, allowing you to remove sensitive
values, such as authentication tokens,
as well as any other modification or truncation of the response body. By
default, the <code><a href="#topic+redact_cookies">redact_cookies()</a></code> function will be used to purge standard
auth methods, but <code>set_redactor()</code> allows you to provide a different one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_redactor(FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_redactor_+3A_fun">FUN</code></td>
<td>
<p>A function or expression that modifies <code>httr2_response</code> objects.
Specifically, a valid input is one of:
</p>

<ul>
<li><p> A function taking a single argument, the <code>httr2_response</code>,
and returning a valid <code>httr2_response</code> object.
</p>
</li>
<li><p> A formula as shorthand for an anonymous function with <code>.</code> as the
&quot;response&quot; argument, as in the <code>purrr</code> package. That is, instead of
<code>function (response) redact_headers(response, "X-Custom-Header")</code>, you can
use <code>~ redact_headers(., "X-Custom-Header")</code>
</p>
</li>
<li><p> A list of redacting functions/formulas, which will be executed
in sequence on the response
</p>
</li>
<li> <p><code>NULL</code>, to override the default <code>redact_cookies()</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternatively, you can put a redacting function in <code>inst/httptest2/redact.R</code>
in your package, and
any time your package is loaded (as in when running tests or building
vignettes), the function will be used automatically.
</p>


<h3>Value</h3>

<p>Invisibly, the redacting function, validated and perhaps modified.
Formulas and function lists are turned into proper functions. <code>NULL</code> as input
returns the <code>force()</code> function.
</p>


<h3>See Also</h3>

<p>For further details on how to redact responses, see <code>vignette("redacting", package = "httptest2")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Shorten UUIDs in response body/URLs to their first 6 digits:
set_redactor(function(resp) gsub_response(resp, "([0-9a-f]{6}[0-9a-f]{26}", "\\1"))
# Restore the default
set_redactor(redact_cookies)
</code></pre>

<hr>
<h2 id='start_vignette'>Set mocking/capturing state for a vignette</h2><span id='topic+start_vignette'></span><span id='topic+end_vignette'></span>

<h3>Description</h3>

<p>Use <code>start_vignette()</code> to either use previously recorded responses, if they
exist, or capture real responses for future use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_vignette(dir, ...)

end_vignette()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_vignette_+3A_dir">dir</code></td>
<td>
<p>Root file path for the mocks for this vignette. A good idea is
to use the file name of the vignette itself.</p>
</td></tr>
<tr><td><code id="start_vignette_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>start_capturing()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a vignette or other R Markdown or Sweave document, place
<code>start_vignette()</code> in an R code block at the beginning,
before the first API request is made, and put
<code>end_vignette()</code> in a R code chunk at the end. You may
want to make those R code chunks have <code>echo=FALSE</code> in order to hide the fact
that you're calling them.
</p>
<p>As in <code><a href="#topic+with_mock_dir">with_mock_dir()</a></code>, the behavior changes based on the existence of the <code>dir</code> directory. The
first time you build the vignette, the directory won't exist yet, so it will
make real requests and record them inside of <code>dir</code>. On subsequent runs, the
mocks will be used. To record fresh responses from the server, delete the
<code>dir</code> directory, and the responses will be recorded again the next time the
vignette runs.
</p>
<p>If you have additional setup code that you'd like available across all of
your package's vignettes, put it in <code>inst/httptest2/start-vignette.R</code> in your
package, and it will be called in <code>start_vignette()</code> before the mock/record
context is set. Similarly, teardown code can go in
<code>inst/httptest2/end-vignette.R</code>, evaluated in <code>end_vignette()</code> after mocking
is stopped.
</p>


<h3>Value</h3>

<p>Nothing; called for its side effect of starting/ending
response recording or mocking.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_capturing">start_capturing()</a></code> for how requests are recorded; <code><a href="#topic+use_mock_api">use_mock_api()</a></code>
for how previously recorded requests are loaded; <code><a href="#topic+change_state">change_state()</a></code> for how to
handle recorded requests when the server state is changing;
<code>vignette("vignettes", package = "httptest2")</code> for an overview of all
</p>

<hr>
<h2 id='use_httptest2'>Use 'httptest2' in your tests</h2><span id='topic+use_httptest2'></span>

<h3>Description</h3>

<p>This function adds <code>httptest2</code> to Suggests in the package DESCRIPTION and
loads it in <code>tests/testthat/setup.R</code>. Call it once when you're setting up
a new package test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_httptest2(path = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_httptest2_+3A_path">path</code></td>
<td>
<p>character path to the package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is idempotent: if <code>httptest2</code> is already added to these files,
no additional changes will be made.
</p>


<h3>Value</h3>

<p>Nothing: called for file system side effects.
</p>

<hr>
<h2 id='with_mock_api'>Serve a mock API from files</h2><span id='topic+with_mock_api'></span><span id='topic+use_mock_api'></span><span id='topic+stop_mocking'></span>

<h3>Description</h3>

<p>In this context, HTTP requests attempt to load API response fixtures from
files. This allows test code to proceed evaluating code that expects
HTTP requests to return meaningful responses. Requests that do not have a
corresponding fixture file raise errors, like how <code><a href="#topic+without_internet">without_internet()</a></code>
does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_mock_api(expr)

use_mock_api()

stop_mocking()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_mock_api_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the mock context</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>use_mock_api()</code> and <code>stop_mocking()</code> allow you to turn on/off request
mocking for more convenient use in an interactive session.
</p>
<p>Requests are translated to mock file paths according to several rules that
incorporate the request method, URL, query parameters, and body. See
<code><a href="#topic+build_mock_url">build_mock_url()</a></code> for details.
</p>
<p>File paths for API fixture files may be relative to the 'tests/testthat'
directory, i.e. relative to the .R test files themselves. This is the default
location for storing and retrieving mocks, but you can put them anywhere you
want as long as you set the appropriate location with <code><a href="#topic+.mockPaths">.mockPaths()</a></code>.
</p>


<h3>Value</h3>

<p><code>with_mock_api()</code> returns the result of <code>expr</code>. <code>use_mock_api()</code> and
<code>stop_mocking()</code> return nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(httr2)
with_mock_api({
  # There are no mocks recorded in this example, so catch this request with
  # expect_GET()
  expect_GET(
    request("https://cran.r-project.org") %&gt;% req_perform(),
    "https://cran.r-project.org"
  )
  # For examples with mocks, see the tests and vignettes
})
</code></pre>

<hr>
<h2 id='with_mock_dir'>Use or create mock files depending on their existence</h2><span id='topic+with_mock_dir'></span>

<h3>Description</h3>

<p>This context will switch the <code><a href="#topic+.mockPaths">.mockPaths()</a></code> to <code>tests/testthat/dir</code>
(and then resets it to what it was before).
If the <code>tests/testthat/dir</code> folder doesn't exist, <code><a href="#topic+capture_requests">capture_requests()</a></code> will
be run to create mocks.
If it exists, <code><a href="#topic+with_mock_api">with_mock_api()</a></code> will be run.
To re-record mock files, simply delete <code>tests/testthat/dir</code> and run the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_mock_dir(dir, expr, simplify = TRUE, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_mock_dir_+3A_dir">dir</code></td>
<td>
<p>character string, unique folder name that will be used or created
under <code style="white-space: pre;">&#8288;tests/testthat/&#8288;</code></p>
</td></tr>
<tr><td><code id="with_mock_dir_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the context</p>
</td></tr>
<tr><td><code id="with_mock_dir_+3A_simplify">simplify</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), plain-text responses with status 200
will be written as just the text of the response body. In all other cases,
and when <code>simplify</code> is <code>FALSE</code>, the <code>httr2_response</code> object will be written out to
a .R file using <code><a href="base.html#topic+dput">base::dput()</a></code>.</p>
</td></tr>
<tr><td><code id="with_mock_dir_+3A_replace">replace</code></td>
<td>
<p>Logical: should <code>dir</code> replace the contents of <code>.mockPaths()</code>
(default) or be added in front of the existing paths? The default behavior
here is the opposite of <code>.mockPaths()</code> so that the tests inside of
<code>with_mock_dir()</code> are fully isolated.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>vignette("httptest2")</code> for usage examples.
</p>

<hr>
<h2 id='with_trace'>Wrapper around 'trace' to untrace when finished</h2><span id='topic+with_trace'></span>

<h3>Description</h3>

<p>Wrapper around 'trace' to untrace when finished
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_trace(
  x,
  where = topenv(parent.frame()),
  print = getOption("httptest2.debug.trace", FALSE),
  ...,
  expr
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_trace_+3A_x">x</code></td>
<td>
<p>Name of function to trace. See <code><a href="base.html#topic+trace">base::trace()</a></code>.</p>
</td></tr>
<tr><td><code id="with_trace_+3A_where">where</code></td>
<td>
<p>where to look for the function to be traced.</p>
</td></tr>
<tr><td><code id="with_trace_+3A_print">print</code></td>
<td>
<p>Logical: print a message every time the traced function is hit?
Default is <code>FALSE</code>; note that in <code>trace</code>, the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="with_trace_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>trace</code>. At minimum, must include
either <code>tracer</code> or <code>exit</code>.</p>
</td></tr>
<tr><td><code id="with_trace_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the context</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of <code>expr</code>
</p>

<hr>
<h2 id='without_internet'>Make all HTTP requests raise an error</h2><span id='topic+without_internet'></span><span id='topic+block_requests'></span>

<h3>Description</h3>

<p><code>without_internet()</code> simulates the situation when any network request will
fail, as in when you are without an internet connection. Any HTTP request
through <code>httr2</code> will raise an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>without_internet(expr)

block_requests()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="without_internet_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the mock context</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>block_requests()</code> and <code>stop_mocking()</code> allow you to turn on/off request
blocking for more convenient use in an interactive session.
</p>
<p>The error message raised has a well-defined shape, made of three
elements, separated by space: (1) the request
method (e.g. &quot;GET&quot;); (2) the request URL; and
(3) the request body, if present. The verb-expectation functions,
such as <code><a href="#topic+expect_GET">expect_GET()</a></code> and <code><a href="#topic+expect_POST">expect_POST()</a></code>, look for this shape.
</p>


<h3>Value</h3>

<p>The result of <code>expr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(httr2)
library(testthat, warn.conflicts = FALSE)
without_internet({
  expect_error(
    request("http://httpbin.org/get") %&gt;% req_perform(),
    "GET http://httpbin.org/get"
  )
  expect_error(
    request("http://httpbin.org/put") %&gt;%
      req_method("PUT") %&gt;%
      req_body_json(list(a = 1)) %&gt;%
      req_perform(),
    'PUT http://httpbin.org/put {"a":1}',
    fixed = TRUE
  )
})
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
