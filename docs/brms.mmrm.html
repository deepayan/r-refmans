<!DOCTYPE html><html><head><title>Help for package brms.mmrm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {brms.mmrm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brms.mmrm-package'><p>brms.mmrm: Bayesian MMRMs using <code>brms</code></p></a></li>
<li><a href='#brm_archetype_average_cells'><p>Cell-means-like time-averaged archetype</p></a></li>
<li><a href='#brm_archetype_average_effects'><p>Treatment effect time-averaged archetype</p></a></li>
<li><a href='#brm_archetype_cells'><p>Cell means archetype</p></a></li>
<li><a href='#brm_archetype_effects'><p>Treatment effect archetype</p></a></li>
<li><a href='#brm_archetype_successive_cells'><p>Cell-means-like successive differences archetype</p></a></li>
<li><a href='#brm_archetype_successive_effects'><p>Treatment-effect-like successive differences archetype</p></a></li>
<li><a href='#brm_data'><p>Create and preprocess an MMRM dataset.</p></a></li>
<li><a href='#brm_data_change'><p>Convert to change from baseline.</p></a></li>
<li><a href='#brm_formula'><p>Model formula</p></a></li>
<li><a href='#brm_formula_sigma'><p>Formula for standard deviation parameters</p></a></li>
<li><a href='#brm_marginal_data'><p>Marginal summaries of the data.</p></a></li>
<li><a href='#brm_marginal_draws'><p>MCMC draws from the marginal posterior of an MMRM</p></a></li>
<li><a href='#brm_marginal_draws_average'><p>Average marginal MCMC draws across time points.</p></a></li>
<li><a href='#brm_marginal_probabilities'><p>Marginal probabilities on the treatment effect for an MMRM.</p></a></li>
<li><a href='#brm_marginal_summaries'><p>Summary statistics of the marginal posterior of an MMRM.</p></a></li>
<li><a href='#brm_model'><p>Fit an MMRM.</p></a></li>
<li><a href='#brm_plot_compare'><p>Visually compare the marginals of multiple models and/or datasets.</p></a></li>
<li><a href='#brm_plot_draws'><p>Visualize posterior draws of marginals.</p></a></li>
<li><a href='#brm_prior_archetype'><p>Informative priors for fixed effects in archetypes</p></a></li>
<li><a href='#brm_prior_label'><p>Label a prior with levels in the data.</p></a></li>
<li><a href='#brm_prior_simple'><p>Simple prior for a <code>brms</code> MMRM</p></a></li>
<li><a href='#brm_prior_template'><p>Label template for informative prior archetypes</p></a></li>
<li><a href='#brm_recenter_nuisance'><p>Recenter nuisance variables</p></a></li>
<li><a href='#brm_simulate'><p>Deprecated: simulate an MMRM.</p></a></li>
<li><a href='#brm_simulate_categorical'><p>Append simulated categorical covariates</p></a></li>
<li><a href='#brm_simulate_continuous'><p>Append simulated continuous covariates</p></a></li>
<li><a href='#brm_simulate_outline'><p>Start a simulated dataset</p></a></li>
<li><a href='#brm_simulate_prior'><p>Prior predictive draws.</p></a></li>
<li><a href='#brm_simulate_simple'><p>Simple MMRM simulation.</p></a></li>
<li><a href='#brm_transform_marginal'><p>Marginal mean transformation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian MMRMs using 'brms'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The mixed model for repeated measures (MMRM) is a popular
  model for longitudinal clinical trial data with continuous endpoints,
  and 'brms' is a powerful and versatile package for fitting Bayesian
  regression models.  The 'brms.mmrm' R package leverages 'brms' to run
  MMRMs, and it supports a simplified interfaced to reduce difficulty
  and align with the best practices of the life sciences.  References:
  Bürkner (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v080.i01">doi:10.18637/jss.v080.i01</a>&gt;, Mallinckrodt (2008)
  &lt;<a href="https://doi.org/10.1177%2F009286150804200402">doi:10.1177/009286150804200402</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://openpharma.github.io/brms.mmrm/">https://openpharma.github.io/brms.mmrm/</a>,
<a href="https://github.com/openpharma/brms.mmrm">https://github.com/openpharma/brms.mmrm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/openpharma/brms.mmrm/issues">https://github.com/openpharma/brms.mmrm/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brms (&ge; 2.19.0), dplyr, ggplot2, ggridges, MASS, posterior,
purrr, rlang, stats, tibble, tidyr, tidyselect, trialr, utils,
zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BH, emmeans (&ge; 1.8.7), fst, gt, gtsummary, knitr (&ge; 1.30),
markdown (&ge; 1.1), mmrm, parallel, Rcpp, RcppEigen,
RcppParallel, rmarkdown (&ge; 2.4), rstan, StanHeaders, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-25 18:39:47 UTC; C240390</td>
</tr>
<tr>
<td>Author:</td>
<td>William Michael Landau
    <a href="https://orcid.org/0000-0003-1878-3253"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Kevin Kunzmann <a href="https://orcid.org/0000-0002-1140-7143"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Yoni Sidi [aut],
  Christian Stock <a href="https://orcid.org/0000-0002-3493-3234"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Eli Lilly and Company [cph, fnd],
  Boehringer Ingelheim Pharma GmbH &amp; Co. KG [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Michael Landau &lt;will.landau.oss@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-25 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='brms.mmrm-package'>brms.mmrm: Bayesian MMRMs using <code>brms</code></h2><span id='topic+brms.mmrm-package'></span>

<h3>Description</h3>

<p>The mixed model for repeated measures (MMRM) is a
popular model for longitudinal clinical trial data with
continuous endpoints, and <code>brms</code> a is powerful and versatile
package for fitting Bayesian regression models.
The <code>brms.mmrm</code> R package leverages <code>brms</code> to run MMRMs, and
it supports a simplified interfaced to reduce difficulty
and align with the best practices of the life sciences.
</p>


<h3>References</h3>


<ul>
<li><p> Bürkner, P.-C. (2017), &quot;brms: An R package for Bayesian
multilevel models using Stan,&quot;
Journal of Statistical Software, 80, 1–28.
https://doi.org/10.18637/jss.v080.i01.
</p>
</li>
<li><p> Holzhauer, B., and Weber, S. (2024),
&quot;Bayesian mixed effects model for repeated measures,&quot;
in Applied Modeling in Drug Development, Novartis AG.
<a href="https://opensource.nibr.com/bamdd/src/02h_mmrm.html">https://opensource.nibr.com/bamdd/src/02h_mmrm.html</a>.
</p>
</li>
<li><p> Mallinckrodt, C. H., Lane, P. W., Schnell, D., and others (2008),
&quot;Recommendations for the primary analysis of continuous endpoints
in longitudinal clinical trials,&quot;
Therapeutic Innovation and Regulatory Science, 42, 303–319.
https://doi.org/10.1177/009286150804200402.
</p>
</li>
<li><p> Mallinckrodt, C. H., and Lipkovich, I. (2017),
Analyzing longitudinal clinical trial data: A practical guide,
CRC Press, Taylor &amp; Francis Group.
</p>
</li></ul>


<hr>
<h2 id='brm_archetype_average_cells'>Cell-means-like time-averaged archetype</h2><span id='topic+brm_archetype_average_cells'></span>

<h3>Description</h3>

<p>Create a cell-means-like informative prior archetype
with a special fixed effect to represent the average across time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_archetype_average_cells(
  data,
  covariates = TRUE,
  prefix_interest = "x_",
  prefix_nuisance = "nuisance_",
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_archetype_average_cells_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_cells_+3A_covariates">covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
<code>FALSE</code> to omit.
For informative prior archetypes, this option is set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_cells_+3A_prefix_interest">prefix_interest</code></td>
<td>
<p>Character string to prepend to the new columns
of generated fixed effects of interest (relating to group, subgroup,
and/or time).
In rare cases, you may need to set a non-default prefix to prevent
name conflicts with existing columns in the data, or rename
the columns in your data.
<code>prefix_interest</code> must not be the same value as <code>prefix_nuisance</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_cells_+3A_prefix_nuisance">prefix_nuisance</code></td>
<td>
<p>Same as <code>prefix_interest</code>, but relating to
generated fixed effects NOT of interest (not relating to group,
subgroup, or time). Must not be the same value as <code>prefix_interest</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_cells_+3A_baseline">baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_cells_+3A_baseline_subgroup">baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_cells_+3A_baseline_subgroup_time">baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared baseline
and subgroup variables in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_cells_+3A_baseline_time">baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This archetype has a special fixed effect for each treatment group
to represent the mean response averaged across all the time points.
</p>
<p>To illustrate, suppose the dataset has two treatment groups A and B,
time points 1, 2, and 3, and no other covariates.
Let <code>mu_gt</code> be the marginal mean of the response at group
<code>g</code> time <code>t</code> given data and hyperparameters.
The model has fixed effect parameters <code>beta_1</code>, <code>beta_2</code>, ..., <code>beta_6</code>
which express the marginal means <code>mu_gt</code> as follows:
</p>
<div class="sourceCode"><pre>  `mu_A1 = 3 * beta_1 - beta_2 - beta_3`
  `mu_A2 = beta_2`
  `mu_A3 = beta_3`

  `mu_B1 = 3 * beta_4 - beta_5 - beta_6`
  `mu_B2 = beta_5`
  `mu_B3 = beta_6`
</pre></div>
<p>For group A, <code>beta_1</code> is the average response in group A
averaged across time points. You can confirm this yourself
by expressing the average across time
<code>(mu_A1 + mu_A2 + mu_A3) / 3</code> in terms of the <code style="white-space: pre;">&#8288;beta_*&#8288;</code> parameters
and confirming that the expression simplifies down to just <code>beta_1</code>.
<code>beta_2</code> represents the mean response in group A at time 2, and
<code>beta_3</code> represents the mean response in group A at time 3.
<code>beta_4</code>, <code>beta_5</code>, and <code>beta_6</code> are analogous for group B.
</p>


<h3>Value</h3>

<p>A special classed <code>tibble</code> with data tailored to
the cell-means-like time-averaged archetype. The dataset is augmented
with extra columns with the <code>"archetype_"</code> prefix, as well as special
attributes to tell downstream functions like <code><a href="#topic+brm_formula">brm_formula()</a></code> what to
do with the object.
</p>


<h3>Prior labeling for <code><a href="#topic+brm_archetype_average_cells">brm_archetype_average_cells()</a></code></h3>

<p>Within each treatment group, the initial time point represents
the average, and each successive time point represents the response
within that actual time.
To illustrate, consider the example in the Details section.
In the labeling scheme for <code><a href="#topic+brm_archetype_average_cells">brm_archetype_average_cells()</a></code>,
you can label the prior on <code>beta_1</code> using
<code>brm_prior_label(code = "normal(1.2, 5)", group = "A", time = "1")</code>.
Similarly, you cal label the prior on <code>beta_5</code> with
<code>brm_prior_label(code = "normal(1.3, 7)", group = "B", time = "2")</code>.
To confirm that you set the prior correctly, compare the <code>brms</code> prior
with the output of <code>summary(your_archetype)</code>.
See the examples for details.
</p>


<h3>Nuisance variables</h3>

<p>In the presence of covariate adjustment, functions like
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> convert nuisance factors into binary
dummy variables, then center all those dummy variables and any
continuous nuisance variables at their means in the data.
This ensures that the main model coefficients
of interest are not implicitly conditional on a subset of the data.
In other words, preprocessing nuisance variables this way preserves
the interpretations of the fixed effects of interest, and it ensures
informative priors can be specified correctly.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other informative prior archetypes: 
<code><a href="#topic+brm_archetype_average_effects">brm_archetype_average_effects</a>()</code>,
<code><a href="#topic+brm_archetype_cells">brm_archetype_cells</a>()</code>,
<code><a href="#topic+brm_archetype_effects">brm_archetype_effects</a>()</code>,
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells</a>()</code>,
<code><a href="#topic+brm_archetype_successive_effects">brm_archetype_successive_effects</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
dplyr::select(
  data,
  group,
  time,
  patient,
  starts_with("biomarker"),
  starts_with("status")
)
archetype &lt;- brm_archetype_average_cells(data)
archetype
summary(archetype)
formula &lt;- brm_formula(archetype)
formula
prior &lt;- brm_prior_label(
  code = "normal(1, 2.2)",
  group = "group_1",
  time = "time_2"
) |&gt;
  brm_prior_label("normal(1, 3.3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(1, 4.4)", group = "group_1", time = "time_4") |&gt;
  brm_prior_label("normal(2, 2.2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3.3)", group = "group_2", time = "time_3") |&gt;
  brm_prior_label("normal(2, 4.4)", group = "group_2", time = "time_4") |&gt;
  brm_prior_archetype(archetype)
prior
class(prior)
if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = archetype,
        formula = formula,
        prior = prior,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
suppressWarnings(print(model))
brms::prior_summary(model)
draws &lt;- brm_marginal_draws(
  data = archetype,
  formula = formula,
  model = model
)
summaries_model &lt;- brm_marginal_summaries(draws)
summaries_data &lt;- brm_marginal_data(data)
brm_plot_compare(model = summaries_model, data = summaries_data)
}
</code></pre>

<hr>
<h2 id='brm_archetype_average_effects'>Treatment effect time-averaged archetype</h2><span id='topic+brm_archetype_average_effects'></span>

<h3>Description</h3>

<p>Create a treatment effect informative prior archetype
with a special fixed effect to represent the average across time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_archetype_average_effects(
  data,
  covariates = TRUE,
  prefix_interest = "x_",
  prefix_nuisance = "nuisance_",
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_archetype_average_effects_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_effects_+3A_covariates">covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
<code>FALSE</code> to omit.
For informative prior archetypes, this option is set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_effects_+3A_prefix_interest">prefix_interest</code></td>
<td>
<p>Character string to prepend to the new columns
of generated fixed effects of interest (relating to group, subgroup,
and/or time).
In rare cases, you may need to set a non-default prefix to prevent
name conflicts with existing columns in the data, or rename
the columns in your data.
<code>prefix_interest</code> must not be the same value as <code>prefix_nuisance</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_effects_+3A_prefix_nuisance">prefix_nuisance</code></td>
<td>
<p>Same as <code>prefix_interest</code>, but relating to
generated fixed effects NOT of interest (not relating to group,
subgroup, or time). Must not be the same value as <code>prefix_interest</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_effects_+3A_baseline">baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_effects_+3A_baseline_subgroup">baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_effects_+3A_baseline_subgroup_time">baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared baseline
and subgroup variables in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_average_effects_+3A_baseline_time">baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This archetype has a special fixed effect for each treatment group
to represent the mean response averaged across all the time points,
and treatment effects are explicitly parameterized.
</p>
<p>To illustrate, suppose the dataset has two treatment groups A
(placebo/reference group) and B (active/non-reference group),
time points 1, 2, and 3, and no other covariates.
Let <code>mu_gt</code> be the marginal mean of the response at group
<code>g</code> time <code>t</code> given data and hyperparameters.
The model has fixed effect parameters <code>beta_1</code>, <code>beta_2</code>, ..., <code>beta_6</code>
which express the marginal means <code>mu_gt</code> as follows:
</p>
<div class="sourceCode"><pre>`mu_A1 = 3 * beta_1 - beta_2 - beta_3`
`mu_A2 = beta_2`
`mu_A3 = beta_3`

`mu_B1 = 3 * beta_1 - beta_2 - beta_3 + 3 * beta_4 - beta_5 - beta_6`
`mu_B2 = beta_2 + beta_5`
`mu_B3 = beta_3 + beta_6`
</pre></div>
<p>For group A, <code>beta_1</code> is the average response in group A
averaged across time points. You can confirm this yourself
by expressing the average across time
<code>(mu_A1 + mu_A2 + mu_A3) / 3</code> in terms of the <code style="white-space: pre;">&#8288;beta_*&#8288;</code> parameters
and confirming that the expression simplifies down to just <code>beta_1</code>.
<code>beta_2</code> represents the mean response in group A at time 2, and
<code>beta_3</code> represents the mean response in group A at time 3.
<code>beta_4</code> is the treatment effect of group B relative to group A,
averaged across time points. <code>beta_5</code> is the treatment effect of B vs A
at time 2, and <code>beta_6</code> is analogous for time 3.
</p>


<h3>Value</h3>

<p>A special classed <code>tibble</code> with data tailored to
the treatment effect time-averaged archetype. The dataset is augmented
with extra columns with the <code>"archetype_"</code> prefix, as well as special
attributes to tell downstream functions like <code><a href="#topic+brm_formula">brm_formula()</a></code> what to
do with the object.
</p>


<h3>Prior labeling for <code><a href="#topic+brm_archetype_average_effects">brm_archetype_average_effects()</a></code></h3>

<p>Within each treatment group, the initial time point represents
the average, and each successive time point represents the response
within that actual time.
To illustrate, consider the example in the Details section.
In the labeling scheme for <code><a href="#topic+brm_archetype_average_effects">brm_archetype_average_effects()</a></code>,
you can label the prior on <code>beta_1</code> using
<code>brm_prior_label(code = "normal(1.2, 5)", group = "A", time = "1")</code>.
Similarly, you cal label the prior on <code>beta_5</code> with
<code>brm_prior_label(code = "normal(1.3, 7)", group = "B", time = "2")</code>.
To confirm that you set the prior correctly, compare the <code>brms</code> prior
with the output of <code>summary(your_archetype)</code>.
See the examples for details.
</p>


<h3>Nuisance variables</h3>

<p>In the presence of covariate adjustment, functions like
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> convert nuisance factors into binary
dummy variables, then center all those dummy variables and any
continuous nuisance variables at their means in the data.
This ensures that the main model coefficients
of interest are not implicitly conditional on a subset of the data.
In other words, preprocessing nuisance variables this way preserves
the interpretations of the fixed effects of interest, and it ensures
informative priors can be specified correctly.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other informative prior archetypes: 
<code><a href="#topic+brm_archetype_average_cells">brm_archetype_average_cells</a>()</code>,
<code><a href="#topic+brm_archetype_cells">brm_archetype_cells</a>()</code>,
<code><a href="#topic+brm_archetype_effects">brm_archetype_effects</a>()</code>,
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells</a>()</code>,
<code><a href="#topic+brm_archetype_successive_effects">brm_archetype_successive_effects</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
dplyr::select(
  data,
  group,
  time,
  patient,
  starts_with("biomarker"),
  starts_with("status")
)
archetype &lt;- brm_archetype_average_effects(data)
archetype
summary(archetype)
formula &lt;- brm_formula(archetype)
formula
prior &lt;- brm_prior_label(
  code = "normal(1, 2.2)",
  group = "group_1",
  time = "time_2"
) |&gt;
  brm_prior_label("normal(1, 3.3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(1, 4.4)", group = "group_1", time = "time_4") |&gt;
  brm_prior_label("normal(2, 2.2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3.3)", group = "group_2", time = "time_3") |&gt;
  brm_prior_label("normal(2, 4.4)", group = "group_2", time = "time_4") |&gt;
  brm_prior_archetype(archetype)
prior
class(prior)
if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = archetype,
        formula = formula,
        prior = prior,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
suppressWarnings(print(model))
brms::prior_summary(model)
draws &lt;- brm_marginal_draws(
  data = archetype,
  formula = formula,
  model = model
)
summaries_model &lt;- brm_marginal_summaries(draws)
summaries_data &lt;- brm_marginal_data(data)
brm_plot_compare(model = summaries_model, data = summaries_data)
}
</code></pre>

<hr>
<h2 id='brm_archetype_cells'>Cell means archetype</h2><span id='topic+brm_archetype_cells'></span>

<h3>Description</h3>

<p>Create an informative prior archetype for cell means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_archetype_cells(
  data,
  covariates = TRUE,
  prefix_interest = "x_",
  prefix_nuisance = "nuisance_",
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_archetype_cells_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_cells_+3A_covariates">covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
<code>FALSE</code> to omit.
For informative prior archetypes, this option is set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_cells_+3A_prefix_interest">prefix_interest</code></td>
<td>
<p>Character string to prepend to the new columns
of generated fixed effects of interest (relating to group, subgroup,
and/or time).
In rare cases, you may need to set a non-default prefix to prevent
name conflicts with existing columns in the data, or rename
the columns in your data.
<code>prefix_interest</code> must not be the same value as <code>prefix_nuisance</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_cells_+3A_prefix_nuisance">prefix_nuisance</code></td>
<td>
<p>Same as <code>prefix_interest</code>, but relating to
generated fixed effects NOT of interest (not relating to group,
subgroup, or time). Must not be the same value as <code>prefix_interest</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_cells_+3A_baseline">baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_cells_+3A_baseline_subgroup">baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_archetype_cells_+3A_baseline_subgroup_time">baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared baseline
and subgroup variables in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_cells_+3A_baseline_time">baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this archetype, each fixed effect is a cell mean: the group
mean for a given value of treatment group and discrete time
(and subgroup level, if applicable).
</p>


<h3>Value</h3>

<p>A special classed <code>tibble</code> with data tailored to
the successive differences archetype. The dataset is augmented with
extra columns with the <code>"archetype_"</code> prefix, as well as special
attributes to tell downstream functions like <code><a href="#topic+brm_formula">brm_formula()</a></code> what to
do with the object.
</p>


<h3>Prior labeling for <code><a href="#topic+brm_archetype_cells">brm_archetype_cells()</a></code></h3>

<p>Within each treatment group, each model parameter is a cell mean,
and the labeling scheme in <code><a href="#topic+brm_prior_label">brm_prior_label()</a></code> and
<code><a href="#topic+brm_prior_archetype">brm_prior_archetype()</a></code> translate easily. For example,
<code>brm_prior_label(code = "normal(1.2, 5)", group = "B", time = "VISIT2")</code>
declares a <code>normal(1.2, 5)</code> prior on the cell mean of treatment
group <code>B</code> at discrete time point <code>VISIT2</code>.
To confirm that you set the prior correctly, compare the <code>brms</code> prior
with the output of <code>summary(your_archetype)</code>.
See the examples for details.
</p>


<h3>Nuisance variables</h3>

<p>In the presence of covariate adjustment, functions like
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> convert nuisance factors into binary
dummy variables, then center all those dummy variables and any
continuous nuisance variables at their means in the data.
This ensures that the main model coefficients
of interest are not implicitly conditional on a subset of the data.
In other words, preprocessing nuisance variables this way preserves
the interpretations of the fixed effects of interest, and it ensures
informative priors can be specified correctly.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other informative prior archetypes: 
<code><a href="#topic+brm_archetype_average_cells">brm_archetype_average_cells</a>()</code>,
<code><a href="#topic+brm_archetype_average_effects">brm_archetype_average_effects</a>()</code>,
<code><a href="#topic+brm_archetype_effects">brm_archetype_effects</a>()</code>,
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells</a>()</code>,
<code><a href="#topic+brm_archetype_successive_effects">brm_archetype_successive_effects</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
dplyr::select(
  data,
  group,
  time,
  patient,
  starts_with("biomarker"),
  starts_with("status")
)
archetype &lt;- brm_archetype_cells(data)
archetype
summary(archetype)
formula &lt;- brm_formula(archetype)
formula
prior &lt;- brm_prior_label(
  code = "normal(1, 2.2)",
  group = "group_1",
  time = "time_2"
) |&gt;
  brm_prior_label("normal(1, 3.3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(1, 4.4)", group = "group_1", time = "time_4") |&gt;
  brm_prior_label("normal(2, 2.2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3.3)", group = "group_2", time = "time_3") |&gt;
  brm_prior_label("normal(2, 4.4)", group = "group_2", time = "time_4") |&gt;
  brm_prior_archetype(archetype)
prior
class(prior)
if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = archetype,
        formula = formula,
        prior = prior,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
suppressWarnings(print(model))
brms::prior_summary(model)
draws &lt;- brm_marginal_draws(
  data = archetype,
  formula = formula,
  model = model
)
summaries_model &lt;- brm_marginal_summaries(draws)
summaries_data &lt;- brm_marginal_data(data)
brm_plot_compare(model = summaries_model, data = summaries_data)
}
</code></pre>

<hr>
<h2 id='brm_archetype_effects'>Treatment effect archetype</h2><span id='topic+brm_archetype_effects'></span>

<h3>Description</h3>

<p>Create an informative prior archetype for a simple treatment
effect parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_archetype_effects(
  data,
  covariates = TRUE,
  prefix_interest = "x_",
  prefix_nuisance = "nuisance_",
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_archetype_effects_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_effects_+3A_covariates">covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
<code>FALSE</code> to omit.
For informative prior archetypes, this option is set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_effects_+3A_prefix_interest">prefix_interest</code></td>
<td>
<p>Character string to prepend to the new columns
of generated fixed effects of interest (relating to group, subgroup,
and/or time).
In rare cases, you may need to set a non-default prefix to prevent
name conflicts with existing columns in the data, or rename
the columns in your data.
<code>prefix_interest</code> must not be the same value as <code>prefix_nuisance</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_effects_+3A_prefix_nuisance">prefix_nuisance</code></td>
<td>
<p>Same as <code>prefix_interest</code>, but relating to
generated fixed effects NOT of interest (not relating to group,
subgroup, or time). Must not be the same value as <code>prefix_interest</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_effects_+3A_baseline">baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_effects_+3A_baseline_subgroup">baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_archetype_effects_+3A_baseline_subgroup_time">baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared baseline
and subgroup variables in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_effects_+3A_baseline_time">baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this archetype, each fixed effect is either a placebo response
or a treatment effect.
</p>
<p>To illustrate, suppose the dataset has two treatment groups A and B,
time points 1, 2, and 3, and no other covariates. Assume group A
is the reference group (e.g. placebo).
Let <code>mu_gt</code> be the marginal mean of the response at group
<code>g</code> time <code>t</code> given data and hyperparameters.
The model has fixed effect parameters <code>beta_1</code>, <code>beta_2</code>, ..., <code>beta_6</code>
which express the marginal means <code>mu_gt</code> as follows:
</p>
<div class="sourceCode"><pre>  `mu_A1 = beta_1`
  `mu_A2 = beta_2`
  `mu_A3 = beta_3`

  `mu_B1 = beta_1 + beta_4`
  `mu_B2 = beta_2 + beta_5`
  `mu_B3 = beta_3 + beta_6`
</pre></div>
<p>Above, <code>beta_2</code> is the group mean of treatment group A at time 2,
and <code>beta_5</code> is the treatment effect of B relative to A at time 2.
</p>


<h3>Value</h3>

<p>A special classed <code>tibble</code> with data tailored to
the successive differences archetype. The dataset is augmented with
extra columns with the <code>"archetype_"</code> prefix, as well as special
attributes to tell downstream functions like <code><a href="#topic+brm_formula">brm_formula()</a></code> what to
do with the object.
</p>


<h3>Prior labeling for <code><a href="#topic+brm_archetype_effects">brm_archetype_effects()</a></code></h3>

<p>In the reference group (e.g. placebo) each fixed effect is a cell
mean at a time point. In each non-reference group, each fixed effect
is the treatment effect relative to the reference (at a time point).
The labeling scheme in <code><a href="#topic+brm_prior_label">brm_prior_label()</a></code> and
<code><a href="#topic+brm_prior_archetype">brm_prior_archetype()</a></code> translate straightforwardly. For example,
<code>brm_prior_label(code = "normal(1.2, 5)", group = "A", time = "2")</code>
declares a <code>normal(1.2, 5)</code> on <code>beta_2</code> (cell mean of the reference
group at time 2). Similarly,
<code>brm_prior_label(code = "normal(1.3, 6)", group = "B", time = "2")</code>
declares a <code>normal(1.3, 6)</code> prior on the treatment effect of group
<code>B</code> relative to group <code>A</code> at discrete time point <code>2</code>.
To confirm that you set the prior correctly, compare the <code>brms</code> prior
with the output of <code>summary(your_archetype)</code>.
See the examples for details.
</p>


<h3>Nuisance variables</h3>

<p>In the presence of covariate adjustment, functions like
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> convert nuisance factors into binary
dummy variables, then center all those dummy variables and any
continuous nuisance variables at their means in the data.
This ensures that the main model coefficients
of interest are not implicitly conditional on a subset of the data.
In other words, preprocessing nuisance variables this way preserves
the interpretations of the fixed effects of interest, and it ensures
informative priors can be specified correctly.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other informative prior archetypes: 
<code><a href="#topic+brm_archetype_average_cells">brm_archetype_average_cells</a>()</code>,
<code><a href="#topic+brm_archetype_average_effects">brm_archetype_average_effects</a>()</code>,
<code><a href="#topic+brm_archetype_cells">brm_archetype_cells</a>()</code>,
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells</a>()</code>,
<code><a href="#topic+brm_archetype_successive_effects">brm_archetype_successive_effects</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
dplyr::select(
  data,
  group,
  time,
  patient,
  starts_with("biomarker"),
  starts_with("status")
)
archetype &lt;- brm_archetype_effects(data)
archetype
summary(archetype)
formula &lt;- brm_formula(archetype)
formula
prior &lt;- brm_prior_label(
  code = "normal(1, 2.2)",
  group = "group_1",
  time = "time_2"
) |&gt;
  brm_prior_label("normal(1, 3.3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(1, 4.4)", group = "group_1", time = "time_4") |&gt;
  brm_prior_label("normal(2, 2.2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3.3)", group = "group_2", time = "time_3") |&gt;
  brm_prior_label("normal(2, 4.4)", group = "group_2", time = "time_4") |&gt;
  brm_prior_archetype(archetype)
prior
class(prior)
if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = archetype,
        formula = formula,
        prior = prior,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
suppressWarnings(print(model))
brms::prior_summary(model)
draws &lt;- brm_marginal_draws(
  data = archetype,
  formula = formula,
  model = model
)
summaries_model &lt;- brm_marginal_summaries(draws)
summaries_data &lt;- brm_marginal_data(data)
brm_plot_compare(model = summaries_model, data = summaries_data)
}
</code></pre>

<hr>
<h2 id='brm_archetype_successive_cells'>Cell-means-like successive differences archetype</h2><span id='topic+brm_archetype_successive_cells'></span>

<h3>Description</h3>

<p>Create an informative prior archetype where the fixed effects
are successive differences between adjacent time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_archetype_successive_cells(
  data,
  covariates = TRUE,
  prefix_interest = "x_",
  prefix_nuisance = "nuisance_",
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_archetype_successive_cells_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_cells_+3A_covariates">covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
<code>FALSE</code> to omit.
For informative prior archetypes, this option is set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_cells_+3A_prefix_interest">prefix_interest</code></td>
<td>
<p>Character string to prepend to the new columns
of generated fixed effects of interest (relating to group, subgroup,
and/or time).
In rare cases, you may need to set a non-default prefix to prevent
name conflicts with existing columns in the data, or rename
the columns in your data.
<code>prefix_interest</code> must not be the same value as <code>prefix_nuisance</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_cells_+3A_prefix_nuisance">prefix_nuisance</code></td>
<td>
<p>Same as <code>prefix_interest</code>, but relating to
generated fixed effects NOT of interest (not relating to group,
subgroup, or time). Must not be the same value as <code>prefix_interest</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_cells_+3A_baseline">baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_cells_+3A_baseline_subgroup">baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_cells_+3A_baseline_subgroup_time">baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared baseline
and subgroup variables in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_cells_+3A_baseline_time">baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this archetype, each fixed effect is either an intercept
on the first time point or the difference between two adjacent time
points, and each treatment group has its own set of fixed effects
independent of the other treatment groups.
</p>
<p>To illustrate, suppose the dataset has two treatment groups A and B,
time points 1, 2, and 3, and no other covariates.
Let <code>mu_gt</code> be the marginal mean of the response at group
<code>g</code> time <code>t</code> given data and hyperparameters.
The model has fixed effect parameters <code>beta_1</code>, <code>beta_2</code>, ..., <code>beta_6</code>
which express the marginal means <code>mu_gt</code> as follows:
</p>
<div class="sourceCode"><pre>  `mu_A1 = beta_1`
  `mu_A2 = beta_1 + beta_2`
  `mu_A3 = beta_1 + beta_2 + beta_3`

  `mu_B1 = beta_4`
  `mu_B2 = beta_4 + beta_5`
  `mu_B3 = beta_4 + beta_5 + beta_6`
</pre></div>
<p>For group A, <code>beta_1</code> is the time 1 intercept, <code>beta_2</code> represents
time 2 minus time 1, and <code>beta_3</code> represents time 3 minus time 2.
<code>beta_4</code>, <code>beta_5</code>, and <code>beta_6</code> represent the analogous roles.
</p>


<h3>Value</h3>

<p>A special classed <code>tibble</code> with data tailored to
the successive differences archetype. The dataset is augmented with
extra columns with the <code>"archetype_"</code> prefix, as well as special
attributes to tell downstream functions like <code><a href="#topic+brm_formula">brm_formula()</a></code> what to
do with the object.
</p>


<h3>Nuisance variables</h3>

<p>In the presence of covariate adjustment, functions like
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> convert nuisance factors into binary
dummy variables, then center all those dummy variables and any
continuous nuisance variables at their means in the data.
This ensures that the main model coefficients
of interest are not implicitly conditional on a subset of the data.
In other words, preprocessing nuisance variables this way preserves
the interpretations of the fixed effects of interest, and it ensures
informative priors can be specified correctly.
</p>


<h3>Prior labeling for <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code></h3>

<p>Within each treatment group, each intercept is labeled by the earliest
time point, and each successive difference term gets the successive
time point as the label.
To illustrate, consider the example in the Details section.
In the labeling scheme for <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>,
you can label the prior on <code>beta_1</code> using
<code>brm_prior_label(code = "normal(1.2, 5)", group = "A", time = "1")</code>.
Similarly, you cal label the prior on <code>beta_5</code> with
<code>brm_prior_label(code = "normal(1.3, 7)", group = "B", time = "2")</code>.
To confirm that you set the prior correctly, compare the <code>brms</code> prior
with the output of <code>summary(your_archetype)</code>.
See the examples for details.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other informative prior archetypes: 
<code><a href="#topic+brm_archetype_average_cells">brm_archetype_average_cells</a>()</code>,
<code><a href="#topic+brm_archetype_average_effects">brm_archetype_average_effects</a>()</code>,
<code><a href="#topic+brm_archetype_cells">brm_archetype_cells</a>()</code>,
<code><a href="#topic+brm_archetype_effects">brm_archetype_effects</a>()</code>,
<code><a href="#topic+brm_archetype_successive_effects">brm_archetype_successive_effects</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
dplyr::select(
  data,
  group,
  time,
  patient,
  starts_with("biomarker"),
  starts_with("status")
)
archetype &lt;- brm_archetype_successive_cells(data)
archetype
summary(archetype)
formula &lt;- brm_formula(archetype)
formula
prior &lt;- brm_prior_label(
  code = "normal(1, 2.2)",
  group = "group_1",
  time = "time_2"
) |&gt;
  brm_prior_label("normal(1, 3.3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(1, 4.4)", group = "group_1", time = "time_4") |&gt;
  brm_prior_label("normal(2, 2.2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3.3)", group = "group_2", time = "time_3") |&gt;
  brm_prior_label("normal(2, 4.4)", group = "group_2", time = "time_4") |&gt;
  brm_prior_archetype(archetype)
prior
class(prior)
if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = archetype,
        formula = formula,
        prior = prior,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
suppressWarnings(print(model))
brms::prior_summary(model)
draws &lt;- brm_marginal_draws(
  data = archetype,
  formula = formula,
  model = model
)
summaries_model &lt;- brm_marginal_summaries(draws)
summaries_data &lt;- brm_marginal_data(data)
brm_plot_compare(model = summaries_model, data = summaries_data)
}
</code></pre>

<hr>
<h2 id='brm_archetype_successive_effects'>Treatment-effect-like successive differences archetype</h2><span id='topic+brm_archetype_successive_effects'></span>

<h3>Description</h3>

<p>Create an informative prior archetype where the fixed effects
are successive differences between adjacent time points and terms
in non-reference groups are treatment effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_archetype_successive_effects(
  data,
  covariates = TRUE,
  prefix_interest = "x_",
  prefix_nuisance = "nuisance_",
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_archetype_successive_effects_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_effects_+3A_covariates">covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
<code>FALSE</code> to omit.
For informative prior archetypes, this option is set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_effects_+3A_prefix_interest">prefix_interest</code></td>
<td>
<p>Character string to prepend to the new columns
of generated fixed effects of interest (relating to group, subgroup,
and/or time).
In rare cases, you may need to set a non-default prefix to prevent
name conflicts with existing columns in the data, or rename
the columns in your data.
<code>prefix_interest</code> must not be the same value as <code>prefix_nuisance</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_effects_+3A_prefix_nuisance">prefix_nuisance</code></td>
<td>
<p>Same as <code>prefix_interest</code>, but relating to
generated fixed effects NOT of interest (not relating to group,
subgroup, or time). Must not be the same value as <code>prefix_interest</code>.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_effects_+3A_baseline">baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_effects_+3A_baseline_subgroup">baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_effects_+3A_baseline_subgroup_time">baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared baseline
and subgroup variables in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_archetype_successive_effects_+3A_baseline_time">baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within the reference treatment group (e.g. placebo),
each fixed effect is either an intercept
on the first time point or the difference between two adjacent time
points. In each non-reference treatment group,
each model parameter is defined as an effect relative to the
reference group.
</p>
<p>To illustrate, suppose the dataset has two treatment groups A and B,
time points 1, 2, and 3, and no other covariates.
Say group A is the reference group (e.g. placebo).
Let <code>mu_gt</code> be the marginal mean of the response at group
<code>g</code> time <code>t</code> given data and hyperparameters.
The model has fixed effect parameters <code>beta_1</code>, <code>beta_2</code>, ..., <code>beta_6</code>
which express the marginal means <code>mu_gt</code> as follows:
</p>
<div class="sourceCode"><pre>  `mu_A1 = beta_1`
  `mu_A2 = beta_1 + beta_2`
  `mu_A3 = beta_1 + beta_2 + beta_3`

  `mu_B1 = beta_1 + beta_4`
  `mu_B2 = beta_1 + beta_2 + beta_4 + beta_5`
  `mu_B3 = beta_1 + beta_2 + beta_3 + beta_4 + beta_5 + beta_6`
</pre></div>
<p>For group A, <code>beta_1</code> is the time 1 intercept, <code>beta_2</code> represents
time 2 minus time 1, and <code>beta_3</code> represents time 3 minus time 2.
<code>beta_4</code> is the treatment effect of group B relative to group A at
time 1. <code>beta_5</code> is the treatment effect of the difference between
times 2 and 1, relative to treatment group A.
Similarly, <code>beta_6</code> is the treatment effect of the difference between
times 3 and 2, relative to treatment group A.
</p>


<h3>Value</h3>

<p>A special classed <code>tibble</code> with data tailored to
the successive differences archetype. The dataset is augmented with
extra columns with the <code>"archetype_"</code> prefix, as well as special
attributes to tell downstream functions like <code><a href="#topic+brm_formula">brm_formula()</a></code> what to
do with the object.
</p>


<h3>Prior labeling for <code><a href="#topic+brm_archetype_successive_effects">brm_archetype_successive_effects()</a></code></h3>

<p>Within each treatment group, each intercept is labeled by the earliest
time point, and each successive difference term gets the successive
time point as the label.
To illustrate, consider the example in the Details section.
In the labeling scheme for <code><a href="#topic+brm_archetype_successive_effects">brm_archetype_successive_effects()</a></code>,
you can label the prior on <code>beta_1</code> using
<code>brm_prior_label(code = "normal(1.2, 5)", group = "A", time = "1")</code>.
Similarly, you cal label the prior on <code>beta_5</code> with
<code>brm_prior_label(code = "normal(1.3, 7)", group = "B", time = "2")</code>.
To confirm that you set the prior correctly, compare the <code>brms</code> prior
with the output of <code>summary(your_archetype)</code>.
See the examples for details.
</p>


<h3>Nuisance variables</h3>

<p>In the presence of covariate adjustment, functions like
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> convert nuisance factors into binary
dummy variables, then center all those dummy variables and any
continuous nuisance variables at their means in the data.
This ensures that the main model coefficients
of interest are not implicitly conditional on a subset of the data.
In other words, preprocessing nuisance variables this way preserves
the interpretations of the fixed effects of interest, and it ensures
informative priors can be specified correctly.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other informative prior archetypes: 
<code><a href="#topic+brm_archetype_average_cells">brm_archetype_average_cells</a>()</code>,
<code><a href="#topic+brm_archetype_average_effects">brm_archetype_average_effects</a>()</code>,
<code><a href="#topic+brm_archetype_cells">brm_archetype_cells</a>()</code>,
<code><a href="#topic+brm_archetype_effects">brm_archetype_effects</a>()</code>,
<code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
dplyr::select(
  data,
  group,
  time,
  patient,
  starts_with("biomarker"),
  starts_with("status")
)
archetype &lt;- brm_archetype_successive_effects(data)
archetype
summary(archetype)
formula &lt;- brm_formula(archetype)
formula
prior &lt;- brm_prior_label(
  code = "normal(1, 2.2)",
  group = "group_1",
  time = "time_2"
) |&gt;
  brm_prior_label("normal(1, 3.3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(1, 4.4)", group = "group_1", time = "time_4") |&gt;
  brm_prior_label("normal(2, 2.2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3.3)", group = "group_2", time = "time_3") |&gt;
  brm_prior_label("normal(2, 4.4)", group = "group_2", time = "time_4") |&gt;
  brm_prior_archetype(archetype)
prior
class(prior)
if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = archetype,
        formula = formula,
        prior = prior,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
suppressWarnings(print(model))
brms::prior_summary(model)
draws &lt;- brm_marginal_draws(
  data = archetype,
  formula = formula,
  model = model
)
summaries_model &lt;- brm_marginal_summaries(draws)
summaries_data &lt;- brm_marginal_data(data)
brm_plot_compare(model = summaries_model, data = summaries_data)
}
</code></pre>

<hr>
<h2 id='brm_data'>Create and preprocess an MMRM dataset.</h2><span id='topic+brm_data'></span>

<h3>Description</h3>

<p>Create a dataset to analyze with an MMRM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_data(
  data,
  outcome = "CHG",
  role = "change",
  baseline = NULL,
  group = "TRT01P",
  subgroup = NULL,
  time = "AVISIT",
  patient = "USUBJID",
  covariates = character(0L),
  missing = NULL,
  reference_group = "Placebo",
  level_control = NULL,
  reference_subgroup = NULL,
  reference_time = NULL,
  level_baseline = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_data_+3A_data">data</code></td>
<td>
<p>Data frame or tibble with longitudinal data.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_outcome">outcome</code></td>
<td>
<p>Character of length 1, name of the outcome variable.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_role">role</code></td>
<td>
<p>Character of length 1. Either <code>"response"</code> if <code>outcome</code>
is the raw response variable (e.g. AVAL) or <code>"change"</code> if <code>outcome</code>
is change from baseline (e.g. CHG).</p>
</td></tr>
<tr><td><code id="brm_data_+3A_baseline">baseline</code></td>
<td>
<p>Character of length 1,
name of the baseline response variable.
Only relevant if the response variable is change from baseline.
Supply <code>NULL</code> to ignore or omit.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_group">group</code></td>
<td>
<p>Character of length 1, name of the treatment group variable.
Must point to a character vector in the data. Factors are converted
to characters.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_subgroup">subgroup</code></td>
<td>
<p>Character of length 1, optional name of the a
discrete subgroup variable. Set to <code>NULL</code> to omit the subgroup (default).</p>
</td></tr>
<tr><td><code id="brm_data_+3A_time">time</code></td>
<td>
<p>Character of length 1, name of the discrete time variable.
Must point to a character vector in the data. Factors are converted
to characters.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_patient">patient</code></td>
<td>
<p>Character of length 1, name of the patient ID variable.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_covariates">covariates</code></td>
<td>
<p>Character vector of names of other covariates.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_missing">missing</code></td>
<td>
<p>Character of length 1, name of an optional variable
in a simulated dataset to indicate which outcome values should be missing.
Set to <code>NULL</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_reference_group">reference_group</code></td>
<td>
<p>Character of length 1, Level of the <code>group</code> column
to indicate the control group.
<code>reference_group</code> only applies to the post-processing that happens
in functions like <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code> downstream of the model.
It does not control the fixed effect mapping in the
model matrix that <code>brms</code> derives from the formula from <code>brm_formula()</code>.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_level_control">level_control</code></td>
<td>
<p>Deprecated on 2024-01-11 (version 0.2.0.9002).
Use <code>reference_group</code> instead.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_reference_subgroup">reference_subgroup</code></td>
<td>
<p>Character of length 1,
level of the <code>subgroup</code> column
to use as a reference for pairwise differences in when computing
marginal means downstream of the model.
It does not control the fixed effect mapping in the
model matrix that <code>brms</code> derives from the formula from <code>brm_formula()</code>.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_reference_time">reference_time</code></td>
<td>
<p>Character of length 1 or <code>NULL</code>,
level of the <code>time</code> column to indicate the baseline time point.
This value should not be present in the data if the outcome
variable is change from baseline, but it must be in the data
if the outcome variable is the raw response so that <code>brms.mmrm</code>
can produce model-based marginal estimates of change from baseline.
In other words, set <code>reference_time</code> to <code>NULL</code> if <code>role</code> is <code>"change"</code>,
and set <code>reference_time</code> to a non-null value in <code>data[[time]]</code>
if <code>role</code> is <code>"response"</code>.
</p>
<p>Note: <code>reference_time</code> only applies to the post-processing that happens
in functions like <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code> downstream of the model.
It does not control the fixed effect mapping in the
model matrix that <code>brms</code> derives from the formula from <code>brm_formula()</code>.</p>
</td></tr>
<tr><td><code id="brm_data_+3A_level_baseline">level_baseline</code></td>
<td>
<p>Deprecated on 2024-01-11 (version 0.2.0.9002).
Use <code>reference_time</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A classed tibble with attributes which denote features of
the data such as the treatment group and discrete time variables.
</p>


<h3>Preprocessing</h3>

<p>The preprocessing steps in <code>brm_data()</code> are as follows:
</p>

<ul>
<li><p> Perform basic assertions to make sure the data and other arguments
are properly formatted.
</p>
</li>
<li><p> Convert the group and time columns to character vectors.
</p>
</li>
<li><p> Sanitize the levels of the group and time columns using
<code>make.names(unique = FALSE, allow_ = TRUE)</code> to ensure agreement
between the data and the output of <code>brms</code>.
</p>
</li>
<li><p> For each implicitly missing outcome observation, add explicit row
with the outcome variable equal to <code>NA_real_</code>.
</p>
</li>
<li><p> Arrange the rows of the data by group, then patient, then discrete time.
</p>
</li>
<li><p> Select only the columns of the data relevant to an MMRM analysis.
</p>
</li></ul>



<h3>Separation string</h3>

<p>Post-processing in <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code> names each of the
group-by-time marginal means with the delimiting character string
from <code>Sys.getenv("BRM_SEP", unset = "|")</code>. Neither the column names
nor element names of the group and time variables can contain
this string. To set a custom string yourself, use
<code>Sys.setenv(BRM_SEP = "YOUR_CUSTOM_STRING")</code>.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+brm_data_change">brm_data_change</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
data &lt;- brm_simulate_simple()$data
colnames(data) &lt;- paste0("col_", colnames(data))
data
brm_data(
  data = data,
  outcome = "col_response",
  role = "response",
  group = "col_group",
  time = "col_time",
  patient = "col_patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
</code></pre>

<hr>
<h2 id='brm_data_change'>Convert to change from baseline.</h2><span id='topic+brm_data_change'></span>

<h3>Description</h3>

<p>Convert a dataset from raw response to change from baseline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_data_change(data, name_change = "change", name_baseline = "baseline")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_data_change_+3A_data">data</code></td>
<td>
<p>A classed <code>tibble</code> (e.g. from <code><a href="#topic+brm_data">brm_data()</a></code>) with raw response
as the outcome variable (role = <code>"response"</code> in <code><a href="#topic+brm_data">brm_data()</a></code>).</p>
</td></tr>
<tr><td><code id="brm_data_change_+3A_name_change">name_change</code></td>
<td>
<p>Character of length 1, name of the new outcome column
for change from baseline.</p>
</td></tr>
<tr><td><code id="brm_data_change_+3A_name_baseline">name_baseline</code></td>
<td>
<p>Character of length 1, name of the new column for
the original baseline response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A classed <code>tibble</code> with change from baseline as the outcome variable
and the internal attributes modified accordingly. A special baseline
column is also created, and the original raw response column is removed.
The new baseline column is comprised of the elements of the response
variable corresponding to the <code>reference_time</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>.
</p>
<p>If there is a column to denote missing values for simulation purposes,
e.g. the <code>"missing"</code> column generated by <code>brm_simulate_outline()</code>,
then missing baseline values are propagated accordingly such that
change from baseline will be missing if either the post-baseline response
is missing or the baseline response is missing.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+brm_data">brm_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
data &lt;- brm_data(
  data = dplyr::rename(brm_simulate_simple()$data, y_values = response),
  outcome = "y_values",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
data
attr(data, "brm_role")
attr(data, "brm_outcome")
attr(data, "brm_baseline")
attr(data, "brm_reference_time")
changed &lt;- brm_data_change(data = data, name_change = "delta")
changed
attr(changed, "brm_role")
attr(changed, "brm_outcome")
attr(changed, "brm_baseline")
attr(data, "brm_reference_time")
</code></pre>

<hr>
<h2 id='brm_formula'>Model formula</h2><span id='topic+brm_formula'></span><span id='topic+brm_formula.default'></span><span id='topic+brm_formula.brms_mmrm_archetype'></span>

<h3>Description</h3>

<p>Build a model formula for an MMRM, either for a generic
<code><a href="#topic+brm_data">brm_data()</a></code> dataset or an informative prior archetype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_formula(
  data,
  check_rank = TRUE,
  sigma = brms.mmrm::brm_formula_sigma(data = data, check_rank = check_rank),
  correlation = "unstructured",
  autoregressive_order = 1L,
  moving_average_order = 1L,
  residual_covariance_arma_estimation = FALSE,
  ...
)

## Default S3 method:
brm_formula(
  data,
  check_rank = TRUE,
  sigma = brms.mmrm::brm_formula_sigma(data = data, check_rank = check_rank),
  correlation = "unstructured",
  autoregressive_order = 1L,
  moving_average_order = 1L,
  residual_covariance_arma_estimation = FALSE,
  intercept = TRUE,
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) &amp;&amp; !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline")),
  covariates = TRUE,
  group = TRUE,
  group_subgroup = !is.null(attr(data, "brm_subgroup")),
  group_subgroup_time = !is.null(attr(data, "brm_subgroup")),
  group_time = TRUE,
  subgroup = !is.null(attr(data, "brm_subgroup")),
  subgroup_time = !is.null(attr(data, "brm_subgroup")),
  time = TRUE,
  ...,
  effect_baseline = NULL,
  effect_group = NULL,
  effect_time = NULL,
  interaction_baseline = NULL,
  interaction_group = NULL
)

## S3 method for class 'brms_mmrm_archetype'
brm_formula(
  data,
  check_rank = TRUE,
  sigma = brms.mmrm::brm_formula_sigma(data = data, check_rank = check_rank),
  correlation = "unstructured",
  autoregressive_order = 1L,
  moving_average_order = 1L,
  residual_covariance_arma_estimation = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_formula_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_check_rank">check_rank</code></td>
<td>
<p><code>TRUE</code> to check the rank of the model matrix and
throw an error if rank deficiency is detected. <code>FALSE</code> to skip
this check. Rank-deficient models may have non-identifiable
parameters and it is recommended to choose a full-rank mapping.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_sigma">sigma</code></td>
<td>
<p>A formula produced by <code><a href="#topic+brm_formula_sigma">brm_formula_sigma()</a></code>.
The formula is a base R formula with S3 class
<code>"brms_mmrm_formula_sigma"</code>, and it controls
the parameterization of the residual standard deviations <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_correlation">correlation</code></td>
<td>
<p>Character of length 1, name of the correlation
structure. The correlation matrix is a square <code style="white-space: pre;">&#8288;T x T&#8288;</code> matrix, where
<code>T</code> is the number of discrete time points in the data.
This matrix describes the correlations between time points in the same
patient, as modeled in the residuals. Different patients are modeled
as independent. The <code>correlation</code> argument controls how this matrix
is parameterized, and the choices given by <code>brms</code> are listed at
<a href="https://paul-buerkner.github.io/brms/reference/autocor-terms.html">https://paul-buerkner.github.io/brms/reference/autocor-terms.html</a>,
and the choice is ultimately encoded in the main body of the
output formula through terms like <code>unstru()</code> and <code>arma()</code>, some
of which are configurable through arguments
<code>autoregressive_order</code>, <code>moving_average_order</code>, and
<code>residual_covariance_arma_estimation</code> of <code><a href="#topic+brm_formula">brm_formula()</a></code>.
Choices in <code>brms.mmrm</code>:
</p>

<ul>
<li> <p><code>"unstructured"</code>: the default/recommended option, a fully parameterized
covariance matrix with a unique scalar parameter for each unique pair
of discrete time points. C.f.
<a href="https://paul-buerkner.github.io/brms/reference/unstr.html">https://paul-buerkner.github.io/brms/reference/unstr.html</a>.
</p>
</li>
<li> <p><code>"autoregressive_moving_average"</code>: autoregressive moving
average (ARMA), c.f.
<a href="https://paul-buerkner.github.io/brms/reference/arma.html">https://paul-buerkner.github.io/brms/reference/arma.html</a>.
</p>
</li>
<li> <p><code>"autoregressive"</code>: autoregressive (AR), c.f.
<a href="https://paul-buerkner.github.io/brms/reference/ar.html">https://paul-buerkner.github.io/brms/reference/ar.html</a>.
</p>
</li>
<li> <p><code>"moving_average"</code>: moving average (MA), c.f.
<a href="https://paul-buerkner.github.io/brms/reference/ma.html">https://paul-buerkner.github.io/brms/reference/ma.html</a>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"compound_symmetry&#8288;</code>: compound symmetry, c.f.
<a href="https://paul-buerkner.github.io/brms/reference/cosy.html">https://paul-buerkner.github.io/brms/reference/cosy.html</a>.
</p>
</li>
<li> <p><code>"diagonal"</code>: declare independent time points within patients.
</p>
</li></ul>
</td></tr>
<tr><td><code id="brm_formula_+3A_autoregressive_order">autoregressive_order</code></td>
<td>
<p>Nonnegative integer,
autoregressive order for the <code>"autoregressive_moving_average"</code>
and <code>"autoregressive"</code> correlation structures.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_moving_average_order">moving_average_order</code></td>
<td>
<p>Nonnegative integer,
moving average order for the <code>"autoregressive_moving_average"</code>
and <code>"moving_average"</code> correlation structures.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_residual_covariance_arma_estimation">residual_covariance_arma_estimation</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>,
whether to estimate ARMA effects using residual covariance matrices.
Directly supplied to the <code>cov</code> argument in <code>brms</code> for
<code>"autoregressive_moving_average"</code>, <code>"autoregressive"</code>, and
<code>"moving_average"</code> correlation structures. C.f.
<a href="https://paul-buerkner.github.io/brms/reference/arma.html">https://paul-buerkner.github.io/brms/reference/arma.html</a>.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_...">...</code></td>
<td>
<p>Named arguments to specific <code><a href="#topic+brm_formula">brm_formula()</a></code> methods.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_intercept">intercept</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include an intercept, <code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_baseline">baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_baseline_subgroup">baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_baseline_subgroup_time">baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared baseline
and subgroup variables in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_baseline_time">baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a baseline
variable in the dataset.
Ignored for informative prior archetypes.
For informative prior archetypes, this option should be set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_covariates">covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
<code>FALSE</code> to omit.
For informative prior archetypes, this option is set in
functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code> rather than in
<code><a href="#topic+brm_formula">brm_formula()</a></code> in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_group">group</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include additive effects for
treatment groups, <code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_group_subgroup">group_subgroup</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include group-by-subgroup interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a subgroup
variable in the dataset.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_group_subgroup_time">group_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include group-by-subgroup-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a subgroup
variable in the dataset.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_group_time">group_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include group-by-time interaction, <code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_subgroup">subgroup</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include additive fixed effects for subgroup levels,
<code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a subgroup
variable in the dataset.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_subgroup_time">subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include subgroup-by-time interaction, <code>FALSE</code> to omit.
Default is <code>TRUE</code> if <code><a href="#topic+brm_data">brm_data()</a></code> previously declared a subgroup
variable in the dataset.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_time">time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include a additive effect for discrete time,
<code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_effect_baseline">effect_baseline</code></td>
<td>
<p>Deprecated on 2024-01-16 (version 0.0.2.9002).
Use <code>baseline</code> instead.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_effect_group">effect_group</code></td>
<td>
<p>Deprecated on 2024-01-16 (version 0.0.2.9002).
Use <code>group</code> instead.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_effect_time">effect_time</code></td>
<td>
<p>Deprecated on 2024-01-16 (version 0.0.2.9002).
Use <code>time</code> instead.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_interaction_baseline">interaction_baseline</code></td>
<td>
<p>Deprecated on 2024-01-16 (version 0.0.2.9002).
Use <code>baseline_time</code> instead.</p>
</td></tr>
<tr><td><code id="brm_formula_+3A_interaction_group">interaction_group</code></td>
<td>
<p>Deprecated on 2024-01-16 (version 0.0.2.9002).
Use <code>group_time</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"brmsformula"</code> returned from
<code>brms::brmsformula()</code>. It contains the fixed effect mapping,
correlation structure, and residual variance structure.
</p>


<h3><code><a href="#topic+brm_data">brm_data()</a></code> formulas</h3>

<p>For a <code><a href="#topic+brm_data">brm_data()</a></code> dataset,
<code><a href="#topic+brm_formula">brm_formula()</a></code> builds an R formula for an MMRM based on
the details in the data and your choice of mapping.
Customize your mapping by toggling on or off
the various <code>TRUE</code>/<code>FALSE</code> arguments of <code><a href="#topic+brm_formula">brm_formula()</a></code>,
such as <code>intercept</code>, <code>baseline</code>, and <code>group_time</code>.
All plausible additive effects, two-way interactions, and
three-way interactions can be specified. The following interactions
are not supported:
</p>

<ul>
<li><p> Any interactions with the concomitant covariates you specified in the
<code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>.
</p>
</li>
<li><p> Any interactions which include baseline response and treatment
group together. Rationale: in a randomized controlled experiment,
baseline and treatment group assignment should be uncorrelated.
</p>
</li></ul>



<h3>Formulas for informative prior archetypes</h3>

<p>Functions like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>
tailor datasets to informative prior archetypes. For these specialized
tailored datasets, <code><a href="#topic+brm_formula">brm_formula()</a></code> works differently. It still applies
the variance and correlation structure of your choosing, and it still
lets you choose whether to adjust for nuisance covariates,
but it no longer lets you toggle on/off individual terms in the model,
such as <code>intercept</code>, <code>baseline</code>, or <code>group</code>. Instead, to ensure the
correct interpretation of the parameters, <code><a href="#topic+brm_formula">brm_formula()</a></code> uses
the <code style="white-space: pre;">&#8288;x_*&#8288;</code> and <code style="white-space: pre;">&#8288;nuisance_*&#8288;</code> columns generated by
<code>brm_archetype_successive_cells( prefix_interest = "x_", prefix_nuisance = "nuisance_")</code>.
</p>


<h3>Parameterization</h3>

<p>For a formula on a <code><a href="#topic+brm_data">brm_data()</a></code> dataset,
the formula is not the only factor
that determines the fixed effect mapping.
The ordering of the categorical variables in the data,
as well as the <code>contrast</code> option in R, affect the
construction of the model matrix. To see the model
matrix that will ultimately be used in <code><a href="#topic+brm_model">brm_model()</a></code>,
run <code><a href="brms.html#topic+standata">brms::make_standata()</a></code> and examine the <code>X</code> element
of the returned list. See the examples below for a
demonstration.
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+brm_formula_sigma">brm_formula_sigma</a>()</code>,
<code><a href="#topic+brm_model">brm_model</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
brm_formula(data)
brm_formula(data = data, intercept = FALSE, baseline = FALSE)
formula &lt;- brm_formula(
  data = data,
  intercept = FALSE,
  baseline = FALSE,
  group = FALSE
)
formula
# Standard deviations of residuals are distributional parameters that can
# regress on variables in the data.
homogeneous &lt;- brm_formula_sigma(data, time = FALSE)
by_group &lt;- brm_formula_sigma(data, group = TRUE, intercept = TRUE)
homogeneous
by_group
brm_formula(data, sigma = homogeneous)
brm_formula(data, sigma = by_group)
# Optional: set the contrast option, which determines the model matrix.
options(contrasts = c(unordered = "contr.SAS", ordered = "contr.poly"))
# See the fixed effect mapping you get from the data:
head(brms::make_standata(formula = formula, data = data)$X)
# Specify a different contrast method to use an alternative
# mapping when fitting the model with brm_model():
options(
  contrasts = c(unordered = "contr.treatment", ordered = "contr.poly")
)
# different model matrix than before:
head(brms::make_standata(formula = formula, data = data)$X)
# Formula on an informative prior archetype:
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = "biomarker3",
    levels = c("present", "absent")
  )
archetype &lt;- brm_archetype_successive_cells(data)
formula &lt;- brm_formula(data = archetype)
formula
</code></pre>

<hr>
<h2 id='brm_formula_sigma'>Formula for standard deviation parameters</h2><span id='topic+brm_formula_sigma'></span>

<h3>Description</h3>

<p>Parameterize standard deviations using
a formula for the <code>sigma</code> argument of <code><a href="#topic+brm_formula">brm_formula()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_formula_sigma(
  data,
  check_rank = TRUE,
  intercept = FALSE,
  baseline = FALSE,
  baseline_subgroup = FALSE,
  baseline_subgroup_time = FALSE,
  baseline_time = FALSE,
  covariates = FALSE,
  group = FALSE,
  group_subgroup = FALSE,
  group_subgroup_time = FALSE,
  group_time = FALSE,
  subgroup = FALSE,
  subgroup_time = FALSE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_formula_sigma_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_check_rank">check_rank</code></td>
<td>
<p><code>TRUE</code> to check the rank of the model matrix
for <code>sigma</code> and throw an error if rank deficiency is detected.
<code>FALSE</code> to skip this check.
Rank-deficiency may cause <code>sigma</code> to be non-identifiable,
may prevent the MCMC from converging.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_intercept">intercept</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include an intercept, <code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_baseline">baseline</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include an additive effect for baseline
response, <code>FALSE</code> to omit.
If <code>TRUE</code>, then effect size will be omitted from the output of
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_baseline_subgroup">baseline_subgroup</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_baseline_subgroup_time">baseline_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-subgroup-by-time interaction,
<code>FALSE</code> to omit.
If <code>TRUE</code>, then effect size will be omitted from the output of
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_baseline_time">baseline_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include baseline-by-time interaction, <code>FALSE</code> to omit.
If <code>TRUE</code>, then effect size will be omitted from the output of
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_covariates">covariates</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include any additive covariates declared with
the <code>covariates</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
<code>FALSE</code> to omit.
If <code>TRUE</code>, then effect size will be omitted from the output of
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_group">group</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> (default) to include additive effects for
treatment groups, <code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_group_subgroup">group_subgroup</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include group-by-subgroup interaction, <code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_group_subgroup_time">group_subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include group-by-subgroup-by-time interaction, <code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_group_time">group_time</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_subgroup">subgroup</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include additive fixed effects for subgroup levels,
<code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_subgroup_time">subgroup_time</code></td>
<td>
<p>Logical of length 1.
<code>TRUE</code> to include subgroup-by-time interaction, <code>FALSE</code> to omit.</p>
</td></tr>
<tr><td><code id="brm_formula_sigma_+3A_time">time</code></td>
<td>
<p>Logical of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>brms</code>, the standard deviations of the residuals are
modeled through a parameter vector called <code>sigma</code>. <code>brms.mmrm</code>
always treats <code>sigma</code> as a distributional parameter
(<a href="https://paul-buerkner.github.io/brms/articles/brms_distreg.html">https://paul-buerkner.github.io/brms/articles/brms_distreg.html</a>).
<code><a href="#topic+brm_formula_sigma">brm_formula_sigma()</a></code> lets you control the parameterization of <code>sigma</code>.
The output of <code><a href="#topic+brm_formula_sigma">brm_formula_sigma()</a></code> serves as input to the <code>sigma</code>
argument of <code><a href="#topic+brm_formula">brm_formula()</a></code>.
</p>
<p>The default <code>sigma</code> formula is <code>sigma ~ 0 + time</code>, where <code>time</code>
is the discrete time variable in the data. This is the usual
heterogeneous variance structure which declares
one standard deviation parameter for each time point in the data.
Alternatively, you could write
<code>brm_formula_sigma(data, intercept = TRUE, time = FALSE)</code>.
This will produce <code>sigma ~ 1</code>, which yields a single scalar variance
(a structure termed &quot;homogeneous variance&quot;).
</p>
<p>With arguments like <code>baseline</code> and <code>covariates</code>, you can
specify extremely complicated variance structures. However,
if baseline or covariates are used, then the output of
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code> omit effect size due to the statistical
challenges of calculating marginal means of draws of <code>sigma</code>
for this uncommon scenario.
</p>


<h3>Value</h3>

<p>A base R formula with S3 class <code>"brms_mmrm_formula_sigma"</code>.
This formula controls the parameterization of <code>sigma</code>, the linear-scale
<code>brms</code> distributional parameters which represent standard deviations.
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+brm_formula">brm_formula</a>()</code>,
<code><a href="#topic+brm_model">brm_model</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
homogeneous &lt;- brm_formula_sigma(data, time = FALSE, intercept = TRUE)
by_group &lt;- brm_formula_sigma(data, group = TRUE, intercept = TRUE)
homogeneous
by_group
brm_formula(data, sigma = homogeneous)
brm_formula(data, sigma = by_group)
</code></pre>

<hr>
<h2 id='brm_marginal_data'>Marginal summaries of the data.</h2><span id='topic+brm_marginal_data'></span>

<h3>Description</h3>

<p>Marginal summaries of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_marginal_data(
  data,
  level = 0.95,
  use_subgroup = !is.null(attr(data, "brm_subgroup"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_marginal_data_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_data_+3A_level">level</code></td>
<td>
<p>Numeric of length 1 from 0 to 1, level of the confidence
intervals.</p>
</td></tr>
<tr><td><code id="brm_marginal_data_+3A_use_subgroup">use_subgroup</code></td>
<td>
<p>Logical of length 1, whether to summarize the data by
each subgroup level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with one row per summary statistic and the following
columns:
</p>

<ul>
<li> <p><code>group</code>: treatment group.
</p>
</li>
<li> <p><code>subgroup</code>: subgroup level. Only included if the <code>subgroup</code>
argument of <code><a href="#topic+brm_marginal_data">brm_marginal_data()</a></code> is <code>TRUE</code>.
</p>
</li>
<li> <p><code>time</code>: discrete time point.
</p>
</li>
<li> <p><code>statistic</code>: type of summary statistic.
</p>
</li>
<li> <p><code>value</code>: numeric value of the estimate.
</p>
</li></ul>

<p>The <code>statistic</code> column has the following possible values:
</p>

<ul>
<li> <p><code>mean</code>: observed mean response after removing missing values.
</p>
</li>
<li> <p><code>median</code>: observed median response after removing missing values.
</p>
</li>
<li> <p><code>sd</code>: observed standard deviation of the response after
removing missing values.
</p>
</li>
<li> <p><code>lower</code>: lower bound of a normal equal-tailed confidence interval
with confidence level determined by the <code>level</code> argument.
</p>
</li>
<li> <p><code>upper</code>: upper bound of a normal equal-tailed confidence interval
with confidence level determined by the <code>level</code> argument.
</p>
</li>
<li> <p><code>n_observe</code>: number of non-missing values in the response.
</p>
</li>
<li> <p><code>n_total</code>: number of total records in the data for the given
group/time combination, including both observed and missing values.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other marginals: 
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws</a>()</code>,
<code><a href="#topic+brm_marginal_draws_average">brm_marginal_draws_average</a>()</code>,
<code><a href="#topic+brm_marginal_probabilities">brm_marginal_probabilities</a>()</code>,
<code><a href="#topic+brm_marginal_summaries">brm_marginal_summaries</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
brm_marginal_data(data = data)
</code></pre>

<hr>
<h2 id='brm_marginal_draws'>MCMC draws from the marginal posterior of an MMRM</h2><span id='topic+brm_marginal_draws'></span>

<h3>Description</h3>

<p>Get marginal posterior draws from a fitted MMRM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_marginal_draws(
  data,
  formula,
  model,
  transform = brms.mmrm::brm_transform_marginal(data, formula),
  effect_size = TRUE,
  use_subgroup = NULL,
  control = NULL,
  baseline = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_marginal_draws_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>"brmsformula"</code> from <code><a href="#topic+brm_formula">brm_formula()</a></code>
or <code>brms::brmsformula()</code>. Should include the full mapping
of the model, including fixed effects, residual correlation,
and heterogeneity in the discrete-time-specific residual variance
components.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+brm_model">brm_model()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_+3A_transform">transform</code></td>
<td>
<p>Matrix with one row per marginal mean and one column
per model parameter. <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code> uses this matrix
to map posterior draws of model parameters to posterior draws of
marginal means using matrix multiplication. Please use
<code><a href="#topic+brm_transform_marginal">brm_transform_marginal()</a></code> to compute this matrix and then modify
only if necessary. See the methods vignettes for details on this
matrix, as well as how <code>brms.mmrm</code> computes marginal means more
generally.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_+3A_effect_size">effect_size</code></td>
<td>
<p>Logical, <code>TRUE</code> to derive posterior samples
of effect size (treatment effect divided by residual standard
deviation). <code>FALSE</code> to omit. <code>brms.mmrm</code> does not support
effect size when baseline or covariates are included
in the <code><a href="#topic+brm_formula_sigma">brm_formula_sigma()</a></code> formula. If <code>effect_size</code> is <code>TRUE</code>
in this case, then <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code> will automatically
omit effect size and throw an informative warning.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_+3A_use_subgroup">use_subgroup</code></td>
<td>
<p>Deprecated. No longer used. <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>
no longer marginalizes over the subgroup declared
in <code><a href="#topic+brm_data">brm_data()</a></code>. To marginalize over the subgroup, declare
that variable in <code>covariates</code> instead.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_+3A_control">control</code></td>
<td>
<p>Deprecated. Set the control group level in <code><a href="#topic+brm_data">brm_data()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_+3A_baseline">baseline</code></td>
<td>
<p>Deprecated. Set the control group level in <code><a href="#topic+brm_data">brm_data()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of tibbles of MCMC draws of the marginal posterior
distribution of each treatment group and time point. These marginals
are also subgroup-specific if <code><a href="#topic+brm_formula">brm_formula()</a></code> included fixed effects
that use the <code>subgroup</code> variable originally declared in <code><a href="#topic+brm_data">brm_data()</a></code>.
In each tibble, there is 1 row per posterior sample and one column for
each type of marginal distribution (i.e. each combination of treatment
group and discrete time point. The specific <code>tibble</code>s in the returned
list are described below:
</p>

<ul>
<li> <p><code>response</code>: on the scale of the response variable.
</p>
</li>
<li> <p><code>difference_time</code>: change from baseline: the
<code>response</code> at a particular time minus the <code>response</code> at baseline
(<code>reference_time</code>).
Only returned if the <code>role</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code> was
<code>"response"</code>. (If <code>role</code> is <code>"change"</code>, then <code>response</code> already
represents change from baseline.)
</p>
</li>
<li> <p><code>difference_group</code>: treatment effect: the
the <code>difference_time</code> at each active group minus the <code>difference_time</code>
at the control group (<code>reference_group</code>).
If <code>role</code> is <code>"change"</code>, then treatment group
is instead the difference between <code>response</code> at each active group minus
the <code>response</code> at the control group.
</p>
</li>
<li> <p><code>difference_subgroup</code>: subgroup differences: the <code>difference_group</code>
at each subgroup level minus the <code>difference_group</code> at the subgroup
reference level (<code>reference_subgroup</code>).
</p>
</li>
<li> <p><code>effect</code>: effect size, defined as the treatment difference
divided by the residual standard deviation. Omitted if
the <code>effect_size</code> argument is <code>FALSE</code> or if the
<code><a href="#topic+brm_formula_sigma">brm_formula_sigma()</a></code> includes baseline or covariates.
</p>
</li></ul>



<h3>Separation string</h3>

<p>Post-processing in <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code> names each of the
group-by-time marginal means with the delimiting character string
from <code>Sys.getenv("BRM_SEP", unset = "|")</code>. Neither the column names
nor element names of the group and time variables can contain
this string. To set a custom string yourself, use
<code>Sys.setenv(BRM_SEP = "YOUR_CUSTOM_STRING")</code>.
</p>


<h3>See Also</h3>

<p>Other marginals: 
<code><a href="#topic+brm_marginal_data">brm_marginal_data</a>()</code>,
<code><a href="#topic+brm_marginal_draws_average">brm_marginal_draws_average</a>()</code>,
<code><a href="#topic+brm_marginal_probabilities">brm_marginal_probabilities</a>()</code>,
<code><a href="#topic+brm_marginal_summaries">brm_marginal_summaries</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = data,
        formula = formula,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
brm_marginal_draws(data = data, formula = formula, model = model)
}
</code></pre>

<hr>
<h2 id='brm_marginal_draws_average'>Average marginal MCMC draws across time points.</h2><span id='topic+brm_marginal_draws_average'></span>

<h3>Description</h3>

<p>Simple un-weighted arithmetic mean of
marginal MCMC draws across time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_marginal_draws_average(data, draws, times = NULL, label = "average")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_marginal_draws_average_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_average_+3A_draws">draws</code></td>
<td>
<p>List of posterior draws from <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_average_+3A_times">times</code></td>
<td>
<p>Character vector of discrete time point levels
over which to average the MCMC samples within treatment group levels.
Set to <code>NULL</code> to average across all time points. Levels are automatically
sanitized with <code>make.names(unique = FALSE, allow_ = TRUE)</code> to ensure
agreement with <code>brms</code> variable names in downstream computations.</p>
</td></tr>
<tr><td><code id="brm_marginal_draws_average_+3A_label">label</code></td>
<td>
<p>Character of length 1, time point label for the averages.
Automatically sanitized with <code>make.names(unique = FALSE, allow_ = TRUE)</code>.
Must not conflict with any existing time point labels in the data
after the label and time points are sanitized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of tibbles of MCMC draws of the marginal posterior
distribution of each treatment group and time point
(or group-by-subgroup-by-time, if applicable).
In each tibble, there is 1 row per posterior sample sand one column for
each type of marginal distribution (i.e. each combination of treatment
group and discrete time point. The specific <code>tibble</code>s in the returned
list are described below:
</p>

<ul>
<li> <p><code>response</code>: on the scale of the response variable.
</p>
</li>
<li> <p><code>difference_time</code>: change from baseline: the
<code>response</code> at a particular time minus the <code>response</code> at baseline
(<code>reference_time</code>).
Only returned if the <code>role</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code> was
<code>"response"</code>. (If <code>role</code> is <code>"change"</code>, then <code>response</code> already
represents change from baseline.)
</p>
</li>
<li> <p><code>difference_group</code>: treatment effect: the
the <code>difference_time</code> at each active group minus the <code>difference_time</code>
at the control group (<code>reference_group</code>).
If <code>role</code> is <code>"change"</code>, then treatment group
is instead the difference between <code>response</code> at each active group minus
the <code>response</code> at the control group.
</p>
</li>
<li> <p><code>difference_subgroup</code>: subgroup differences: the <code>difference_group</code>
at each subgroup level minus the <code>difference_group</code> at the subgroup
reference level (<code>reference_subgroup</code>).
</p>
</li></ul>



<h3>Separation string</h3>

<p>Post-processing in <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code> names each of the
group-by-time marginal means with the delimiting character string
from <code>Sys.getenv("BRM_SEP", unset = "|")</code>. Neither the column names
nor element names of the group and time variables can contain
this string. To set a custom string yourself, use
<code>Sys.setenv(BRM_SEP = "YOUR_CUSTOM_STRING")</code>.
</p>


<h3>See Also</h3>

<p>Other marginals: 
<code><a href="#topic+brm_marginal_data">brm_marginal_data</a>()</code>,
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws</a>()</code>,
<code><a href="#topic+brm_marginal_probabilities">brm_marginal_probabilities</a>()</code>,
<code><a href="#topic+brm_marginal_summaries">brm_marginal_summaries</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = data,
        formula = formula,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
draws &lt;- brm_marginal_draws(data = data, formula = formula, model = model)
brm_marginal_draws_average(draws = draws, data = data)
brm_marginal_draws_average(
  draws = draws,
  data = data,
  times = c("time_1", "time_2"),
  label = "mean"
)
}
</code></pre>

<hr>
<h2 id='brm_marginal_probabilities'>Marginal probabilities on the treatment effect for an MMRM.</h2><span id='topic+brm_marginal_probabilities'></span>

<h3>Description</h3>

<p>Marginal probabilities on the treatment effect for an MMRM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_marginal_probabilities(draws, direction = "greater", threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_marginal_probabilities_+3A_draws">draws</code></td>
<td>
<p>Posterior draws of the marginal posterior
obtained from <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_probabilities_+3A_direction">direction</code></td>
<td>
<p>Character vector of the same length as <code>threshold</code>.
<code>"greater"</code> to compute the marginal posterior probability that the
treatment effect is greater than the threshold,
<code>"less"</code> to compute the marginal posterior probability that the
treatment effect is less than the threshold.
Each element <code>direction[i]</code> corresponds to <code>threshold[i]</code>
for all <code>i</code> from 1 to <code>length(direction)</code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_probabilities_+3A_threshold">threshold</code></td>
<td>
<p>Numeric vector of the same length as <code>direction</code>,
treatment effect threshold for computing posterior probabilities.
Each element <code>direction[i]</code> corresponds to <code>threshold[i]</code> for
all <code>i</code> from 1 to <code>length(direction)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of probabilities of the form
<code style="white-space: pre;">&#8288;Prob(treatment effect &gt; threshold | data)&#8288;</code> and/or
<code style="white-space: pre;">&#8288;Prob(treatment effect &lt; threshold | data)&#8288;</code>. It has one row per
probability and the following columns:
* <code>group</code>: treatment group.
* <code>subgroup</code>: subgroup level, if applicable.
* <code>time</code>: discrete time point,
* <code>direction</code>: direction of the comparison in the marginal probability:
<code>"greater"</code> for <code>&gt;</code>, <code>"less"</code> for <code>&lt;</code>
* <code>threshold</code>: treatment effect threshold in the probability statement.
* <code>value</code>: numeric value of the estimate of the probability.
</p>


<h3>See Also</h3>

<p>Other marginals: 
<code><a href="#topic+brm_marginal_data">brm_marginal_data</a>()</code>,
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws</a>()</code>,
<code><a href="#topic+brm_marginal_draws_average">brm_marginal_draws_average</a>()</code>,
<code><a href="#topic+brm_marginal_summaries">brm_marginal_summaries</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = data,
        formula = formula,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
draws &lt;- brm_marginal_draws(data = data, formula = formula, model = model)
brm_marginal_probabilities(draws, direction = "greater", threshold = 0)
}
</code></pre>

<hr>
<h2 id='brm_marginal_summaries'>Summary statistics of the marginal posterior of an MMRM.</h2><span id='topic+brm_marginal_summaries'></span>

<h3>Description</h3>

<p>Summary statistics of the marginal posterior of an MMRM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_marginal_summaries(draws, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_marginal_summaries_+3A_draws">draws</code></td>
<td>
<p>Posterior draws of the marginal posterior
obtained from <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_marginal_summaries_+3A_level">level</code></td>
<td>
<p>Numeric of length 1 between 0 and 1, credible level
for the credible intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with one row per summary statistic and the following
columns:
</p>

<ul>
<li> <p><code>marginal</code>: type of marginal distribution. If <code>outcome</code> was <code>"response"</code>
in <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>, then possible values include
<code>"response"</code> for the response on the raw scale, <code>"change"</code> for
change from baseline, and <code>"difference"</code> for treatment difference
in terms of change from baseline. If <code>outcome</code> was <code>"change"</code>,
then possible values include <code>"response"</code> for the response one the
change from baseline scale and <code>"difference"</code> for treatment difference.
</p>
</li>
<li> <p><code>statistic</code>: type of summary statistic. <code>"lower"</code> and <code>"upper"</code>
are bounds of an equal-tailed quantile-based credible interval.
</p>
</li>
<li> <p><code>group</code>: treatment group.
</p>
</li>
<li> <p><code>subgroup</code>: subgroup level, if applicable.
</p>
</li>
<li> <p><code>time</code>: discrete time point.
</p>
</li>
<li> <p><code>value</code>: numeric value of the estimate.
</p>
</li>
<li> <p><code>mcse</code>: Monte Carlo standard error of the estimate.
The <code>statistic</code> column has the following possible values:
</p>
</li>
<li> <p><code>mean</code>: posterior mean.
</p>
</li>
<li> <p><code>median</code>: posterior median.
</p>
</li>
<li> <p><code>sd</code>: posterior standard deviation of the mean.
</p>
</li>
<li> <p><code>lower</code>: lower bound of an equal-tailed credible interval of the mean,
with credible level determined by the <code>level</code> argument.
</p>
</li>
<li> <p><code>upper</code>: upper bound of an equal-tailed credible interval
with credible level determined by the <code>level</code> argument.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other marginals: 
<code><a href="#topic+brm_marginal_data">brm_marginal_data</a>()</code>,
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws</a>()</code>,
<code><a href="#topic+brm_marginal_draws_average">brm_marginal_draws_average</a>()</code>,
<code><a href="#topic+brm_marginal_probabilities">brm_marginal_probabilities</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = data,
        formula = formula,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
draws &lt;- brm_marginal_draws(data = data, formula = formula, model = model)
suppressWarnings(brm_marginal_summaries(draws))
}
</code></pre>

<hr>
<h2 id='brm_model'>Fit an MMRM.</h2><span id='topic+brm_model'></span>

<h3>Description</h3>

<p>Fit an MMRM model using <code>brms</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_model(
  data,
  formula,
  ...,
  prior = NULL,
  family = brms::brmsfamily(family = "gaussian")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_model_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_model_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>"brmsformula"</code> from <code><a href="#topic+brm_formula">brm_formula()</a></code>
or <code>brms::brmsformula()</code>. Should include the full mapping
of the model, including fixed effects, residual correlation,
and heterogeneity in the discrete-time-specific residual variance
components.</p>
</td></tr>
<tr><td><code id="brm_model_+3A_...">...</code></td>
<td>
<p>Arguments to <code>brms::brm()</code> other than <code>data</code>, <code>formula</code>,
and <code>prior</code>.</p>
</td></tr>
<tr><td><code id="brm_model_+3A_prior">prior</code></td>
<td>
<p>Either <code>NULL</code> for default priors
or a <code>"brmsprior"</code> object from <code>brms::prior()</code>.</p>
</td></tr>
<tr><td><code id="brm_model_+3A_family">family</code></td>
<td>
<p>A <code>brms</code> family object generated by <code><a href="brms.html#topic+brmsfamily">brms::brmsfamily()</a></code>.
Must fit a continuous outcome variable and have the identity link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted model object from <code>brms</code>.
</p>


<h3>Parameterization</h3>

<p>For a formula on a <code><a href="#topic+brm_data">brm_data()</a></code> dataset,
the formula is not the only factor
that determines the fixed effect mapping.
The ordering of the categorical variables in the data,
as well as the <code>contrast</code> option in R, affect the
construction of the model matrix. To see the model
matrix that will ultimately be used in <code><a href="#topic+brm_model">brm_model()</a></code>,
run <code><a href="brms.html#topic+standata">brms::make_standata()</a></code> and examine the <code>X</code> element
of the returned list. See the examples below for a
demonstration.
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+brm_formula">brm_formula</a>()</code>,
<code><a href="#topic+brm_formula_sigma">brm_formula_sigma</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
# Optional: set the contrast option, which determines the model matrix.
options(contrasts = c(unordered = "contr.SAS", ordered = "contr.poly"))
# See the fixed effect mapping you get from the data:
head(brms::make_standata(formula = formula, data = data)$X)
# Specify a different contrast method to use an alternative
# mapping when fitting the model with brm_model():
options(
  contrasts = c(unordered = "contr.treatment", ordered = "contr.poly")
)
# different model matrix than before:
head(brms::make_standata(formula = formula, data = data)$X)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = data,
        formula = formula,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
# The output model is a brms model fit object.
suppressWarnings(print(model))
# The `prior_summary()` function shows the full prior specification
# which reflects the fully realized fixed effects mapping.
brms::prior_summary(model)
}
</code></pre>

<hr>
<h2 id='brm_plot_compare'>Visually compare the marginals of multiple models and/or datasets.</h2><span id='topic+brm_plot_compare'></span>

<h3>Description</h3>

<p>Visually compare the marginals of multiple models
and/or datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_plot_compare(
  ...,
  marginal = "response",
  compare = "source",
  axis = "time",
  facet = c("group", "subgroup")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_plot_compare_+3A_...">...</code></td>
<td>
<p>Named <code>tibble</code>s of marginals posterior summaries
from <code><a href="#topic+brm_marginal_summaries">brm_marginal_summaries()</a></code> and/or <code><a href="#topic+brm_marginal_data">brm_marginal_data()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_plot_compare_+3A_marginal">marginal</code></td>
<td>
<p>Character of length 1, which kind of marginal
to visualize. Must be a value in the <code>marginal</code> column of the supplied
<code>tibble</code>s in the <code>...</code> argument.
Only applies to MCMC output, the data is always on the scale of the
response variable.</p>
</td></tr>
<tr><td><code id="brm_plot_compare_+3A_compare">compare</code></td>
<td>
<p>Character of length 1 identifying the variable to display
using back-to-back interval plots of different colors. This is
the primary comparison of interest. Must be one of
<code>"source"</code> (the source of the marginal summaries,
e.g. a model or dataset), <code>"time"</code> or <code>"group"</code>
(in the non-subgroup case). Can also be <code>"subgroup"</code>
if all the marginal summaries are subgroup-specific.
The value must not be in <code>axis</code> or <code>facet</code>.</p>
</td></tr>
<tr><td><code id="brm_plot_compare_+3A_axis">axis</code></td>
<td>
<p>Character of length 1 identifying the quantity to put
on the horizontal axis. Must be be one of <code>"source"</code>
(the source of the marginal summaries,
e.g. a model or dataset), <code>"time"</code>,
or <code>"group"</code> (in the non-subgroup case). If the marginals
are subgroup-specific, then <code>axis</code> can also be <code>"subgroup"</code>.
The value must not be in <code>compare</code> or <code>facet</code>.</p>
</td></tr>
<tr><td><code id="brm_plot_compare_+3A_facet">facet</code></td>
<td>
<p>Character vector of length 1 or 2 with quantities to
generate facets. Each element must be <code>"source"</code>
(the source of the marginal summaries,
e.g. a model or dataset), <code>"time"</code>, <code>"group"</code>,
or <code>"subgroup"</code>, and <code>c(axis, facet)</code> must all have unique elements.
<code>"subgroup"</code> is automatically removed if not all the marginal summaries
have a subgroup column. If <code>facet</code> has length 1, then faceting is wrapped.
If <code>facet</code> has length 2, then faceting is in a grid,
and the first element is horizontal facet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code><a href="#topic+brm_plot_compare">brm_plot_compare()</a></code> compares multiple models
and/or datasets side-by-side. The <code>compare</code> argument selects the primary
comparison of interest, and arguments <code>axis</code> and <code>facet</code> control
the arrangement of various other components of the plot.
The subgroup variable is automatically included if and only if
all the supplied marginal summaries have a subgroup column.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p>Other visualization: 
<code><a href="#topic+brm_plot_draws">brm_plot_draws</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = data,
        formula = formula,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
draws &lt;- brm_marginal_draws(data = data, formula = formula, model = model)
suppressWarnings(summaries_draws &lt;- brm_marginal_summaries(draws))
summaries_data &lt;- brm_marginal_data(data)
brm_plot_compare(
  model1 = summaries_draws,
  model2 = summaries_draws,
  data = summaries_data
)
brm_plot_compare(
  model1 = summaries_draws,
  model2 = summaries_draws,
  marginal = "difference"
)
}
</code></pre>

<hr>
<h2 id='brm_plot_draws'>Visualize posterior draws of marginals.</h2><span id='topic+brm_plot_draws'></span>

<h3>Description</h3>

<p>Visualize posterior draws of marginals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_plot_draws(draws, axis = "time", facet = c("group", "subgroup"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_plot_draws_+3A_draws">draws</code></td>
<td>
<p>A data frame of draws from an element of
the output list of <code><a href="#topic+brm_marginal_summaries">brm_marginal_summaries()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_plot_draws_+3A_axis">axis</code></td>
<td>
<p>Character of length 1 identifying the quantity to put
on the horizontal axis. Must be be one of <code>"time"</code> or <code>"group"</code> if
the marginal summaries are not subgroup-specific. If the marginals
are subgroup-specific, then <code>axis</code> must be one of
<code>"time"</code>, <code>"group"</code>, or <code>"subgroup"</code>.</p>
</td></tr>
<tr><td><code id="brm_plot_draws_+3A_facet">facet</code></td>
<td>
<p>Character vector of length 1 or 2 with quantities to
generate facets. Each element must be <code>"time"</code>, <code>"group"</code>,
or <code>"subgroup"</code>, and <code>c(axis, facet)</code> must all have unique elements.
<code>"subgroup"</code> is automatically removed if the marginals have no
subgroup. If <code>facet</code> has length 1, then faceting is wrapped.
If <code>facet</code> has length 2, then faceting is in a grid,
and the first element is horizontal facet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p>Other visualization: 
<code><a href="#topic+brm_plot_compare">brm_plot_compare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      model &lt;- brm_model(
        data = data,
        formula = formula,
        chains = 1,
        iter = 100,
        refresh = 0
      )
    )
  )
)
draws &lt;- brm_marginal_draws(data = data, formula = formula, model = model)
brm_plot_draws(draws = draws$difference_time)
}
</code></pre>

<hr>
<h2 id='brm_prior_archetype'>Informative priors for fixed effects in archetypes</h2><span id='topic+brm_prior_archetype'></span>

<h3>Description</h3>

<p>Create a <code>brms</code> prior for fixed effects in an archetype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_prior_archetype(label, archetype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_prior_archetype_+3A_label">label</code></td>
<td>
<p>A data frame with one row per model parameter in the
archetype and columns to indicate the mapping between priors
and labels. Generate using <code><a href="#topic+brm_prior_label">brm_prior_label()</a></code> or manually.
See the examples and the informative prior archetypes vignette
for details.</p>
</td></tr>
<tr><td><code id="brm_prior_archetype_+3A_archetype">archetype</code></td>
<td>
<p>An informative prior archetype generated by a function
like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brms</code> prior object that you can supply to the <code>prior</code>
argument of <code><a href="#topic+brm_model">brm_model()</a></code>.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other priors: 
<code><a href="#topic+brm_prior_label">brm_prior_label</a>()</code>,
<code><a href="#topic+brm_prior_simple">brm_prior_simple</a>()</code>,
<code><a href="#topic+brm_prior_template">brm_prior_template</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 3,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
archetype &lt;- brm_archetype_successive_cells(data)
dplyr::distinct(data, group, time)
prior &lt;- NULL |&gt;
  brm_prior_label("normal(1, 1)", group = "group_1", time = "time_1") |&gt;
  brm_prior_label("normal(1, 2)", group = "group_1", time = "time_2") |&gt;
  brm_prior_label("normal(1, 3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(2, 1)", group = "group_2", time = "time_1") |&gt;
  brm_prior_label("normal(2, 2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3)", group = "group_2", time = "time_3") |&gt;
  brm_prior_archetype(archetype = archetype)
prior
class(prior)
</code></pre>

<hr>
<h2 id='brm_prior_label'>Label a prior with levels in the data.</h2><span id='topic+brm_prior_label'></span>

<h3>Description</h3>

<p>Label an informative prior for a parameter
using a collection of levels in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_prior_label(label = NULL, code, group, subgroup = NULL, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_prior_label_+3A_label">label</code></td>
<td>
<p>A <code>tibble</code> with the prior labeling scheme so far,
with one row per model parameter and columns for the
Stan code, treatment group, subgroup, and discrete time point
of each parameter.</p>
</td></tr>
<tr><td><code id="brm_prior_label_+3A_code">code</code></td>
<td>
<p>Character of length 1, Stan code for the prior. Could be
a string like <code>"normal(1, 2.2)"</code>. The full set of priors is given
in the Stan Function Reference at
<a href="https://mc-stan.org/docs/functions-reference/">https://mc-stan.org/docs/functions-reference/</a> in the
&quot;Unbounded Continuous Distributions&quot; section.
See the documentation <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="brm_prior_label_+3A_group">group</code></td>
<td>
<p>Value of length 1, level of the treatment group column
in the data to label the prior. The treatment group column
is the one you identified with the <code>group</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_prior_label_+3A_subgroup">subgroup</code></td>
<td>
<p>Value of length 1, level of the subgroup column
in the data to label the prior. The subgroup column
is the one you identified with the <code>subgroup</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>,
if applicable. Not every dataset has a subgroup variable.
If yours does not, please either ignore this argument or set it to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="brm_prior_label_+3A_time">time</code></td>
<td>
<p>Value of length 1, level of the discrete time column
in the data to label the prior. The discrete time column
is the one you identified with the <code>time</code> argument of <code><a href="#topic+brm_data">brm_data()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with one row per model parameter and columns for the
Stan code, treatment group, subgroup, and discrete time point
of each parameter. You can supply this <code>tibble</code> to the <code>label</code>
argument of <code><a href="#topic+brm_prior_archetype">brm_prior_archetype()</a></code>.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other priors: 
<code><a href="#topic+brm_prior_archetype">brm_prior_archetype</a>()</code>,
<code><a href="#topic+brm_prior_simple">brm_prior_simple</a>()</code>,
<code><a href="#topic+brm_prior_template">brm_prior_template</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 3,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
archetype &lt;- brm_archetype_successive_cells(data)
dplyr::distinct(data, group, time)
label &lt;- NULL |&gt;
  brm_prior_label("normal(1, 1)", group = "group_1", time = "time_1") |&gt;
  brm_prior_label("normal(1, 2)", group = "group_1", time = "time_2") |&gt;
  brm_prior_label("normal(1, 3)", group = "group_1", time = "time_3") |&gt;
  brm_prior_label("normal(2, 1)", group = "group_2", time = "time_1") |&gt;
  brm_prior_label("normal(2, 2)", group = "group_2", time = "time_2") |&gt;
  brm_prior_label("normal(2, 3)", group = "group_2", time = "time_3")
label
</code></pre>

<hr>
<h2 id='brm_prior_simple'>Simple prior for a <code>brms</code> MMRM</h2><span id='topic+brm_prior_simple'></span>

<h3>Description</h3>

<p>Generate a simple prior for a <code>brms</code> MMRM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_prior_simple(
  data,
  formula,
  intercept = "student_t(3, 0, 2.5)",
  coefficients = "student_t(3, 0, 2.5)",
  sigma = "student_t(3, 0, 2.5)",
  unstructured = "lkj(1)",
  autoregressive = "",
  moving_average = "",
  compound_symmetry = "",
  correlation = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_prior_simple_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>"brmsformula"</code> from <code><a href="#topic+brm_formula">brm_formula()</a></code>
or <code>brms::brmsformula()</code>. Should include the full mapping
of the model, including fixed effects, residual correlation,
and heterogeneity in the discrete-time-specific residual variance
components.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_intercept">intercept</code></td>
<td>
<p>Character of length 1, Stan code for the prior
to set on the intercept parameter.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_coefficients">coefficients</code></td>
<td>
<p>Character of length 1, Stan code for the prior
to set independently on each of the non-intercept model coefficients.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_sigma">sigma</code></td>
<td>
<p>Character of length 1, Stan code for the prior
to set independently on each of the log-scale standard deviation
parameters. Should be a symmetric prior in most situations.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_unstructured">unstructured</code></td>
<td>
<p>Character of length 1,
Stan code for an unstructured correlation prior.
Supply the empty string <code>""</code> to set a flat prior (default).
Applies to the <code style="white-space: pre;">&#8288;"cortime&#8288;</code> parameter class in <code>brms</code> priors.
Used for formulas created with
<code>brm_formula(correlation = "unstructured")</code>. LKJ is recommended.
See also <code><a href="brms.html#topic+unstr">brms::unstr()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_autoregressive">autoregressive</code></td>
<td>
<p>Character of length 1,
Stan code for a prior on autoregressive correlation parameters.
Supply the empty string <code>""</code> to set a flat prior (default).
Applies to the <code style="white-space: pre;">&#8288;"ar&#8288;</code> parameter class in <code>brms</code> priors.
Used for formulas created with
<code>brm_formula(correlation = "autoregressive")</code> and
<code>brm_formula(correlation = "autoregressive_moving_average")</code>.
See also <code><a href="brms.html#topic+ar">brms::ar()</a></code> and <code><a href="brms.html#topic+arma">brms::arma()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_moving_average">moving_average</code></td>
<td>
<p>Character of length 1,
Stan code for a prior on moving average correlation parameters.
Supply the empty string <code>""</code> to set a flat prior (default).
Applies to the <code style="white-space: pre;">&#8288;"ma&#8288;</code> parameter class in <code>brms</code> priors.
Used for formulas created with
<code>brm_formula(correlation = "moving_average")</code> and
<code>brm_formula(correlation = "autoregressive_moving_average")</code>.
See also <code><a href="brms.html#topic+ma">brms::ma()</a></code> and <code><a href="brms.html#topic+arma">brms::arma()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_compound_symmetry">compound_symmetry</code></td>
<td>
<p>Character of length 1,
Stan code for a prior on compound symmetry correlation parameters.
Supply the empty string <code>""</code> to set a flat prior (default).
Applies to the <code style="white-space: pre;">&#8288;"cosy&#8288;</code> parameter class in <code>brms</code> priors.
Used for formulas created with
<code>brm_formula(correlation = "compound_symmetry")</code>.
See also <code><a href="brms.html#topic+cosy">brms::cosy()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_prior_simple_+3A_correlation">correlation</code></td>
<td>
<p>Deprecated on 2024-04-22
(version 0.1.0.9004). Please use arguments like <code>"unstructured"</code>,
and/or <code>"autoregressive"</code> to supply correlation-specific priors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="#topic+brm_prior_simple">brm_prior_simple()</a></code>, you can separately choose priors for
the intercept, model coefficients, log-scale standard deviations,
and pairwise correlations between time points within patients.
However, each class of parameters is set as a whole. In other words,
<code><a href="#topic+brm_prior_simple">brm_prior_simple()</a></code> cannot assign different priors
to different fixed effect parameters.
</p>


<h3>Value</h3>

<p>A classed data frame with the <code>brms</code> prior.
</p>


<h3>See Also</h3>

<p>Other priors: 
<code><a href="#topic+brm_prior_archetype">brm_prior_archetype</a>()</code>,
<code><a href="#topic+brm_prior_label">brm_prior_label</a>()</code>,
<code><a href="#topic+brm_prior_template">brm_prior_template</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline()
data &lt;- brm_simulate_continuous(data, names = c("age", "biomarker"))
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE,
  check_rank = FALSE
)
brm_prior_simple(
  data = data,
  formula = formula,
  intercept = "student_t(3, 0, 2.5)",
  coefficients = "normal(0, 10)",
  sigma = "student_t(2, 0, 4)",
  unstructured = "lkj(2.5)"
)
</code></pre>

<hr>
<h2 id='brm_prior_template'>Label template for informative prior archetypes</h2><span id='topic+brm_prior_template'></span>

<h3>Description</h3>

<p>Template for the <code>label</code> argument of <code><a href="#topic+brm_prior_archetype">brm_prior_archetype()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_prior_template(archetype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_prior_template_+3A_archetype">archetype</code></td>
<td>
<p>An informative prior archetype generated by a function
like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>label</code> argument of <code><a href="#topic+brm_prior_archetype">brm_prior_archetype()</a></code> is a
<code>tibble</code> which maps Stan code for univariate priors
to fixed effect parameters in the model. Usually this <code>tibble</code> is
built gradually using multiple calls to <code><a href="#topic+brm_prior_label">brm_prior_label()</a></code>,
but occasionally it is more convenient to begin with a full template
and manually write Stan code in the <code>code</code> column.
<code><a href="#topic+brm_prior_template">brm_prior_template()</a></code> creates this template.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with one row per fixed effect parameter and columns
to map Stan code to each parameter. After manually writing Stan code in
the <code>code</code> column of the template, you can supply the result
to the <code>label</code> argument of <code><a href="#topic+brm_prior_archetype">brm_prior_archetype()</a></code> to build a
<code>brms</code> prior for your model.
</p>


<h3>Prior labeling</h3>

<p>Informative prior archetypes use a labeling scheme to assign priors
to fixed effects. How it works:
</p>
<div class="sourceCode"><pre>1. First, assign the prior of each parameter a collection
  of labels from the data. This can be done manually or with
  successive calls to [brm_prior_label()].
2. Supply the labeling scheme to [brm_prior_archetype()].
  [brm_prior_archetype()] uses attributes of the archetype
  to map labeled priors to their rightful parameters in the model.
</pre></div>
<p>For informative prior archetypes, this process is much more convenient
and robust than manually calling <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>.
However, it requires an understanding of how the labels of the priors
map to parameters in the model. This mapping varies from archetype
to archetype, and it is documented in the help pages of
archetype-specific functions such as <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.
</p>


<h3>See Also</h3>

<p>Other priors: 
<code><a href="#topic+brm_prior_archetype">brm_prior_archetype</a>()</code>,
<code><a href="#topic+brm_prior_label">brm_prior_label</a>()</code>,
<code><a href="#topic+brm_prior_simple">brm_prior_simple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 3,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
archetype &lt;- brm_archetype_successive_cells(data)
label &lt;- brm_prior_template(archetype)
label$code &lt;- c(
  "normal(1, 1)",
  "normal(1, 2)",
  "normal(1, 3)",
  "normal(2, 1)",
  "normal(2, 2)",
  "normal(2, 3)"
)
brm_prior_archetype(label = label, archetype = archetype)
</code></pre>

<hr>
<h2 id='brm_recenter_nuisance'>Recenter nuisance variables</h2><span id='topic+brm_recenter_nuisance'></span>

<h3>Description</h3>

<p>Change the center of a nuisance variable of an
informative prior archetype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_recenter_nuisance(data, nuisance, center)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_recenter_nuisance_+3A_data">data</code></td>
<td>
<p>An informative prior archetype data frame output from
<code><a href="#topic+brm_archetype_cells">brm_archetype_cells()</a></code> or similar.</p>
</td></tr>
<tr><td><code id="brm_recenter_nuisance_+3A_nuisance">nuisance</code></td>
<td>
<p>Character of length 1, name of the nuisance column
in the data to shift the center.</p>
</td></tr>
<tr><td><code id="brm_recenter_nuisance_+3A_center">center</code></td>
<td>
<p>Numeric of length 1, value of the center to shift
the column in <code>nuisance</code>. The affected column in the returned
archetype data frame will look as if it were centered by this
value to begin with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By &quot;centering vector y at scalar x&quot;, we mean taking
the difference <code>z = y - x</code>. If <code>x</code> is the mean, then <code>mean(z)</code> is
0. Informative prior archetypes center nuisance variables
at their means so the parameters can be interpreted correctly
for setting informative priors. This is appropriate most of the time,
but sometimes it is better to center a column at a pre-specified
scientifically meaningful fixed number. If you want a nuisance column
to be centered at a fixed value other than its mean,
use <code><a href="#topic+brm_recenter_nuisance">brm_recenter_nuisance()</a></code> to shift the center. This function
can handle any nuisance variable
</p>


<h3>Value</h3>

<p>An informative prior archetype data frame with one of the
variables re-centered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
data &lt;- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |&gt;
  dplyr::mutate(response = rnorm(n = dplyr::n())) |&gt;
  brm_data_change() |&gt;
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |&gt;
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
archetype &lt;- brm_archetype_cells(data)
mean(archetype$nuisance_biomarker1) # after original centering
center &lt;- mean(data$biomarker1)
center # original center, before the centering from brm_archetype_cells()
attr(archetype$nuisance_biomarker1, "brm_center") # original center
max(abs((data$biomarker1 - center) - archetype$nuisance_biomarker1))
# Re-center nuisance_biomarker1 at 0.75.
archetype &lt;- brm_recenter_nuisance(
  data = archetype,
  nuisance = "nuisance_biomarker1",
  center = 0.75
)
attr(archetype$nuisance_biomarker1, "brm_center") # new center
mean(archetype$nuisance_biomarker1) # no longer equal to the center
# nuisance_biomarker1 is now as though we centered it at 0.75.
max(abs((data$biomarker1 - 0.75) - archetype$nuisance_biomarker1))
</code></pre>

<hr>
<h2 id='brm_simulate'>Deprecated: simulate an MMRM.</h2><span id='topic+brm_simulate'></span>

<h3>Description</h3>

<p>Deprecated on 2023-09-01 (version 0.0.2.9001). Use
<code><a href="#topic+brm_simulate_simple">brm_simulate_simple()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_simulate(
  n_group = 2L,
  n_patient = 100L,
  n_time = 4L,
  hyper_beta = 1,
  hyper_sigma = 1,
  hyper_correlation = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_simulate_+3A_n_group">n_group</code></td>
<td>
<p>Positive integer of length 1, number of treatment groups.</p>
</td></tr>
<tr><td><code id="brm_simulate_+3A_n_patient">n_patient</code></td>
<td>
<p>Positive integer of length 1, number of patients
per treatment group.</p>
</td></tr>
<tr><td><code id="brm_simulate_+3A_n_time">n_time</code></td>
<td>
<p>Positive integer of length 1, number of discrete
time points (e.g. scheduled study visits) per patient.</p>
</td></tr>
<tr><td><code id="brm_simulate_+3A_hyper_beta">hyper_beta</code></td>
<td>
<p>Positive numeric of length 1, hyperparameter.
Prior standard deviation of the fixed effect parameters.</p>
</td></tr>
<tr><td><code id="brm_simulate_+3A_hyper_sigma">hyper_sigma</code></td>
<td>
<p>Positive numeric of length 1, hyperparameter.
Uniform prior upper bound of the time-specific residual
standard deviation parameters.</p>
</td></tr>
<tr><td><code id="brm_simulate_+3A_hyper_correlation">hyper_correlation</code></td>
<td>
<p>Positive numeric of length 1, hyperparameter.
LKJ shape parameter of the correlation matrix among repeated
measures within each patient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three objects:
</p>

<ul>
<li> <p><code>data</code>: A tidy dataset with one row per patient per discrete
time point and columns for the response and covariates.
</p>
</li>
<li> <p><code>model_matrix</code>: A matrix with one row per row of <code>data</code> and columns
that represent levels of the covariates.
</p>
</li>
<li> <p><code>parameters</code>: A named list of parameter values sampled from the prior.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
simulation &lt;- suppressWarnings(brm_simulate())
simulation$data
</code></pre>

<hr>
<h2 id='brm_simulate_categorical'>Append simulated categorical covariates</h2><span id='topic+brm_simulate_categorical'></span>

<h3>Description</h3>

<p>Simulate and append non-time-varying
categorical covariates to an existing <code><a href="#topic+brm_data">brm_data()</a></code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_simulate_categorical(data, names, levels, probabilities = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_simulate_categorical_+3A_data">data</code></td>
<td>
<p>Classed <code>tibble</code> as from <code><a href="#topic+brm_data">brm_data()</a></code>
or <code><a href="#topic+brm_simulate_outline">brm_simulate_outline()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_simulate_categorical_+3A_names">names</code></td>
<td>
<p>Character vector with the names of the new covariates
to simulate and append. Names must all be unique and
must not already be column names of <code>data</code>.</p>
</td></tr>
<tr><td><code id="brm_simulate_categorical_+3A_levels">levels</code></td>
<td>
<p>Character vector of unique levels of the
simulated categorical covariates.</p>
</td></tr>
<tr><td><code id="brm_simulate_categorical_+3A_probabilities">probabilities</code></td>
<td>
<p>Either <code>NULL</code> or a
numeric vector of length <code>length(levels)</code> with levels between 0 and 1
where all elements sum to 1.
If <code>NULL</code>, then all levels are equally likely to be drawn. If not <code>NULL</code>,
then <code>probabilities</code> is a vector of sampling probabilities corresponding
to each respective level of <code>levels</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each covariate is a new column of the dataset with one independent
random categorical draw for each patient, using a fixed set of levels
(via <code>base::sample()</code> with <code>replace = TRUE</code>).
All covariates simulated this way are
independent of everything else in the data, including other covariates
(to the extent that the random number generators in R work as intended).
</p>


<h3>Value</h3>

<p>A classed <code>tibble</code>, like from <code><a href="#topic+brm_data">brm_data()</a></code> or
<code><a href="#topic+brm_simulate_outline">brm_simulate_outline()</a></code>, but with new categorical covariate columns
and with the names of the new covariates appended to the
<code>brm_covariates</code> attribute. Each new categorical covariate column
is a character vector, not the factor type in base R.
</p>


<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+brm_simulate_continuous">brm_simulate_continuous</a>()</code>,
<code><a href="#topic+brm_simulate_outline">brm_simulate_outline</a>()</code>,
<code><a href="#topic+brm_simulate_prior">brm_simulate_prior</a>()</code>,
<code><a href="#topic+brm_simulate_simple">brm_simulate_simple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- brm_simulate_outline()
brm_simulate_categorical(
  data = data,
  names = c("site", "region"),
  levels = c("area1", "area2")
)
brm_simulate_categorical(
  data = data,
  names = c("site", "region"),
  levels = c("area1", "area2"),
  probabilities = c(0.1, 0.9)
)
</code></pre>

<hr>
<h2 id='brm_simulate_continuous'>Append simulated continuous covariates</h2><span id='topic+brm_simulate_continuous'></span>

<h3>Description</h3>

<p>Simulate and append non-time-varying continuous
covariates to an existing <code><a href="#topic+brm_data">brm_data()</a></code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_simulate_continuous(data, names, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_simulate_continuous_+3A_data">data</code></td>
<td>
<p>Classed <code>tibble</code> as from <code><a href="#topic+brm_data">brm_data()</a></code>
or <code><a href="#topic+brm_simulate_outline">brm_simulate_outline()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_simulate_continuous_+3A_names">names</code></td>
<td>
<p>Character vector with the names of the new covariates
to simulate and append. Names must all be unique and
must not already be column names of <code>data</code>.</p>
</td></tr>
<tr><td><code id="brm_simulate_continuous_+3A_mean">mean</code></td>
<td>
<p>Numeric of length 1,
mean of the normal distribution for simulating each covariate.</p>
</td></tr>
<tr><td><code id="brm_simulate_continuous_+3A_sd">sd</code></td>
<td>
<p>Positive numeric of length 1,
standard deviation of the normal distribution
for simulating each covariate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each covariate is a new column of the dataset with one independent
random univariate normal draw for each patient.
All covariates simulated this way are
independent of everything else in the data, including other covariates
(to the extent that the random number generators in R work as intended).
</p>


<h3>Value</h3>

<p>A classed <code>tibble</code>, like from <code><a href="#topic+brm_data">brm_data()</a></code> or
<code><a href="#topic+brm_simulate_outline">brm_simulate_outline()</a></code>, but with new numeric covariate columns
and with the names of the new covariates appended to the
<code>brm_covariates</code> attribute.
</p>


<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+brm_simulate_categorical">brm_simulate_categorical</a>()</code>,
<code><a href="#topic+brm_simulate_outline">brm_simulate_outline</a>()</code>,
<code><a href="#topic+brm_simulate_prior">brm_simulate_prior</a>()</code>,
<code><a href="#topic+brm_simulate_simple">brm_simulate_simple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- brm_simulate_outline()
brm_simulate_continuous(
  data = data,
  names = c("age", "biomarker")
)
brm_simulate_continuous(
  data = data,
  names = c("biomarker1", "biomarker2"),
  mean = 1000,
  sd = 100
)
</code></pre>

<hr>
<h2 id='brm_simulate_outline'>Start a simulated dataset</h2><span id='topic+brm_simulate_outline'></span>

<h3>Description</h3>

<p>Begin creating a simulated dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_simulate_outline(
  n_group = 2L,
  n_subgroup = NULL,
  n_patient = 100L,
  n_time = 4L,
  rate_dropout = 0.1,
  rate_lapse = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_simulate_outline_+3A_n_group">n_group</code></td>
<td>
<p>Positive integer of length 1, number of treatment groups.</p>
</td></tr>
<tr><td><code id="brm_simulate_outline_+3A_n_subgroup">n_subgroup</code></td>
<td>
<p>Positive integer of length 1, number of subgroup levels.
Set to <code>NULL</code> to omit the subgroup entirely.</p>
</td></tr>
<tr><td><code id="brm_simulate_outline_+3A_n_patient">n_patient</code></td>
<td>
<p>Positive integer of length 1.
If <code>n_subgroup</code> is <code>NULL</code>, then <code>n_patient</code> is the number of patients
per treatment group. Otherwise, <code>n_patient</code> is the number of patients
per treatment group <em>per subgroup</em>. In both cases, the total number of
patients in the whole simulated dataset is usually much greater than the
<code>n_patients</code> argument of <code><a href="#topic+brm_simulate_outline">brm_simulate_outline()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_simulate_outline_+3A_n_time">n_time</code></td>
<td>
<p>Positive integer of length 1, number of discrete
time points (e.g. scheduled study visits) per patient.</p>
</td></tr>
<tr><td><code id="brm_simulate_outline_+3A_rate_dropout">rate_dropout</code></td>
<td>
<p>Numeric of length 1 between 0 and 1,
post-baseline dropout rate.
A dropout is an intercurrent event when data
collection for a patient stops permanently,
causing the outcomes for that patient to be missing during and after
the dropout occurred. The first time point is assumed to be baseline,
so dropout is there. Dropouts are equally likely to occur at each of
the post-baseline time points.</p>
</td></tr>
<tr><td><code id="brm_simulate_outline_+3A_rate_lapse">rate_lapse</code></td>
<td>
<p>Numeric of length 1, expected proportion of post-baseline
outcomes that are missing. Missing outcomes of this type are independent
and uniformly distributed across the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame from <code><a href="#topic+brm_data">brm_data()</a></code> with attributes to define roles
for various columns in the dataset. The data frame has one row per
patient per time point and the following columns:
</p>

<ul>
<li> <p><code>group</code>: integer index of the treatment group.
</p>
</li>
<li> <p><code>patient</code>: integer index of the patient.
</p>
</li>
<li> <p><code>time</code>: integer index of the discrete time point.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+brm_simulate_categorical">brm_simulate_categorical</a>()</code>,
<code><a href="#topic+brm_simulate_continuous">brm_simulate_continuous</a>()</code>,
<code><a href="#topic+brm_simulate_prior">brm_simulate_prior</a>()</code>,
<code><a href="#topic+brm_simulate_simple">brm_simulate_simple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>brm_simulate_outline()
</code></pre>

<hr>
<h2 id='brm_simulate_prior'>Prior predictive draws.</h2><span id='topic+brm_simulate_prior'></span>

<h3>Description</h3>

<p>Simulate the outcome variable from the prior
predictive distribution of an MMRM using <code>brms</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_simulate_prior(
  data,
  formula,
  prior = brms.mmrm::brm_prior_simple(data = data, formula = formula),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_simulate_prior_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_simulate_prior_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>"brmsformula"</code> from <code><a href="#topic+brm_formula">brm_formula()</a></code>
or <code>brms::brmsformula()</code>. Should include the full mapping
of the model, including fixed effects, residual correlation,
and heterogeneity in the discrete-time-specific residual variance
components.</p>
</td></tr>
<tr><td><code id="brm_simulate_prior_+3A_prior">prior</code></td>
<td>
<p>A valid <code>brms</code> prior object with proper priors for parameters
<code>b</code> (model coefficients), <code>b_sigma</code> (log residual standard deviations
for each time point), and <code>cortime</code> (residual correlations among
time points within patients). See the
<code><a href="#topic+brm_prior_simple">brm_prior_simple()</a></code> function for an example.</p>
</td></tr>
<tr><td><code id="brm_simulate_prior_+3A_...">...</code></td>
<td>
<p>Arguments to <code>brms::brm()</code> other than <code>data</code>, <code>formula</code>,
and <code>prior</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>brm_simulate_prior()</code> calls <code>brms::brm()</code> with
<code>sample_prior = "only"</code>, which sets the default intercept prior
using the outcome variable and requires at least some elements of the
outcome variable to be non-missing in advance. So to provide feasible and
consistent output, <code>brm_simulate_prior()</code> temporarily sets the
outcome variable to all zeros before invoking <code>brms::brm()</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>data</code>: a classed <code>tibble</code> with the outcome variable simulated as a draw
from the prior predictive distribution (the final row of <code>outcome</code> in
the output). If you simulated a missingness pattern
with <code><a href="#topic+brm_simulate_outline">brm_simulate_outline()</a></code>, then that missingness pattern is applied
so that the appropriate values of the outcome variable are set to <code>NA</code>.
</p>
</li>
<li> <p><code>model</code>: the <code>brms</code> model fit object.
</p>
</li>
<li> <p><code>model_matrix</code>: the model matrix of the fixed effects, obtained from
<code>brms::make_standata()</code>.
</p>
</li>
<li> <p><code>outcome</code>: a numeric matrix with one column per row of <code>data</code> and one
row per saved prior predictive draw.
</p>
</li>
<li> <p><code>parameters</code>: a <code>tibble</code> of saved parameter draws from the prior
predictive distribution.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+brm_simulate_categorical">brm_simulate_categorical</a>()</code>,
<code><a href="#topic+brm_simulate_continuous">brm_simulate_continuous</a>()</code>,
<code><a href="#topic+brm_simulate_outline">brm_simulate_outline</a>()</code>,
<code><a href="#topic+brm_simulate_simple">brm_simulate_simple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_simulate_outline()
data &lt;- brm_simulate_continuous(data, names = c("age", "biomarker"))
data$response &lt;- rnorm(nrow(data))
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
tmp &lt;- utils::capture.output(
  suppressMessages(
    suppressWarnings(
      out &lt;- brm_simulate_prior(
        data = data,
        formula = formula
      )
    )
  )
)
out$data
}
</code></pre>

<hr>
<h2 id='brm_simulate_simple'>Simple MMRM simulation.</h2><span id='topic+brm_simulate_simple'></span>

<h3>Description</h3>

<p>Simple function to simulate a dataset from a simple
specialized MMRM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_simulate_simple(
  n_group = 2L,
  n_patient = 100L,
  n_time = 4L,
  hyper_beta = 1,
  hyper_tau = 0.1,
  hyper_lambda = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_simulate_simple_+3A_n_group">n_group</code></td>
<td>
<p>Positive integer of length 1, number of treatment groups.</p>
</td></tr>
<tr><td><code id="brm_simulate_simple_+3A_n_patient">n_patient</code></td>
<td>
<p>Positive integer of length 1, number of patients
per treatment group.</p>
</td></tr>
<tr><td><code id="brm_simulate_simple_+3A_n_time">n_time</code></td>
<td>
<p>Positive integer of length 1, number of discrete
time points (e.g. scheduled study visits) per patient.</p>
</td></tr>
<tr><td><code id="brm_simulate_simple_+3A_hyper_beta">hyper_beta</code></td>
<td>
<p>Positive numeric of length 1, hyperparameter.
Prior standard deviation of the fixed effect parameters <code>beta</code>.</p>
</td></tr>
<tr><td><code id="brm_simulate_simple_+3A_hyper_tau">hyper_tau</code></td>
<td>
<p>Positive numeric of length 1, hyperparameter.
Prior standard deviation parameter of the residual log standard
deviation parameters <code>tau</code></p>
</td></tr>
<tr><td><code id="brm_simulate_simple_+3A_hyper_lambda">hyper_lambda</code></td>
<td>
<p>Positive numeric of length 1, hyperparameter.
Prior shape parameter of the LKJ correlation matrix of the residuals
among discrete time points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to the methods vignette for a full model specification.
The <code><a href="#topic+brm_simulate_simple">brm_simulate_simple()</a></code> function simulates a dataset from a
simple pre-defined MMRM. It assumes a cell means structure for fixed
effects, which means there is one fixed effect scalar parameter
(element of vector <code>beta</code>) for each unique combination of levels of
treatment group and discrete time point.
The elements of <code>beta</code> have independent univariate normal
priors with mean 0 and standard deviation <code>hyper_beta</code>.
The residual log standard deviation parameters (elements of vector <code>tau</code>)
have normal priors with mean 0 and standard deviation <code>hyper_tau</code>.
The residual correlation matrix parameter <code>lambda</code> has an LKJ correlation
prior with shape parameter <code>hyper_lambda</code>.
</p>


<h3>Value</h3>

<p>A list of three objects:
</p>

<ul>
<li> <p><code>data</code>: A tidy dataset with one row per patient per discrete
time point and columns for the outcome and ID variables.
</p>
</li>
<li> <p><code>model_matrix</code>: A matrix with one row per row of <code>data</code> and columns
that represent levels of the covariates.
</p>
</li>
<li> <p><code>parameters</code>: A named list of parameter draws sampled from the prior:
</p>

<ul>
<li> <p><code>beta</code>: numeric vector of fixed effects.
</p>
</li>
<li> <p><code>tau</code>: numeric vector of residual log standard parameters for each
time point.
</p>
</li>
<li> <p><code>sigma</code>: numeric vector of residual standard parameters for each
time point. <code>sigma</code> is equal to <code>exp(tau)</code>.
</p>
</li>
<li> <p><code>lambda</code>: correlation matrix of the residuals among the time points
within each patient.
</p>
</li>
<li> <p><code>covariance</code>: covariance matrix of the residuals among the time points
within each patient. <code>covariance</code> is equal to
<code>diag(sigma) %*% lambda %*% diag(sigma)</code>.
</p>
</li></ul>

</li></ul>



<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+brm_simulate_categorical">brm_simulate_categorical</a>()</code>,
<code><a href="#topic+brm_simulate_continuous">brm_simulate_continuous</a>()</code>,
<code><a href="#topic+brm_simulate_outline">brm_simulate_outline</a>()</code>,
<code><a href="#topic+brm_simulate_prior">brm_simulate_prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0L)
simulation &lt;- brm_simulate_simple()
simulation$data
</code></pre>

<hr>
<h2 id='brm_transform_marginal'>Marginal mean transformation</h2><span id='topic+brm_transform_marginal'></span>

<h3>Description</h3>

<p>Transformation from model parameters to marginal means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_transform_marginal(
  data,
  formula,
  average_within_subgroup = NULL,
  prefix = "b_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_transform_marginal_+3A_data">data</code></td>
<td>
<p>A classed data frame from <code><a href="#topic+brm_data">brm_data()</a></code>, or an informative
prior archetype from a function like <code><a href="#topic+brm_archetype_successive_cells">brm_archetype_successive_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="brm_transform_marginal_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>"brmsformula"</code> from <code><a href="#topic+brm_formula">brm_formula()</a></code>
or <code>brms::brmsformula()</code>. Should include the full mapping
of the model, including fixed effects, residual correlation,
and heterogeneity in the discrete-time-specific residual variance
components.</p>
</td></tr>
<tr><td><code id="brm_transform_marginal_+3A_average_within_subgroup">average_within_subgroup</code></td>
<td>
<p><code>TRUE</code> to average concomitant covariates
proportionally within subgroup levels, <code>FALSE</code> to average these
covariates across the whole dataset. If <code>average_within_subgroup</code> is
<code>NULL</code> (default), and if the model has a subgroup and nuisance variables,
then <code><a href="#topic+brm_transform_marginal">brm_transform_marginal()</a></code> prints and informative message
(once per session) and sets <code>average_within_subgroup</code> to <code>FALSE</code>.
If you see this message, please read
<a href="https://openpharma.github.io/brms.mmrm/articles/inference.html">https://openpharma.github.io/brms.mmrm/articles/inference.html</a>,
decide whether to set <code>average_within_subgroup</code> to <code>TRUE</code> or <code>FALSE</code>
in <code><a href="#topic+brm_transform_marginal">brm_transform_marginal()</a></code>, and then manually supply the output of
<code><a href="#topic+brm_transform_marginal">brm_transform_marginal()</a></code> to the <code>transform</code> argument of
<code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.
</p>
<p>To create marginal means, <code>brms.mmrm</code> conditions the nuisance covariates
on their averages across the whole dataset
(<code>average_within_subgroup = FALSE</code> or <code>NULL</code>
in <code><a href="#topic+brm_transform_marginal">brm_transform_marginal()</a></code>).
This may be reasonable in some cases,
and it mitigates the kind of hidden confounding between the subgroup
and other variables which may otherwise cause Simpson's paradox.
However, for subgroup-specific marginal means, it may not be realistic
to condition on a single point estimate for all levels of the reference
grid
(for example, if the subgroup is female vs male, but all marginal
means condition on a single overall observed pregnancy rate of 5%).
In these situations, it may be appropriate to instead condition on
subgroup-specific averages of nuisance variables
(<code>average_within_subgroup = TRUE</code> in <code><a href="#topic+brm_transform_marginal">brm_transform_marginal()</a></code>).
But if you do this,
it is your responsibility to investigate and understand the
hidden interactions and confounding in your dataset.
For more information, please visit
<a href="https://openpharma.github.io/brms.mmrm/articles/inference.html">https://openpharma.github.io/brms.mmrm/articles/inference.html</a>
and
<a href="https://cran.r-project.org/package=emmeans/vignettes/interactions.html">https://cran.r-project.org/package=emmeans/vignettes/interactions.html</a>.</p>
</td></tr>
<tr><td><code id="brm_transform_marginal_+3A_prefix">prefix</code></td>
<td>
<p>Character of length 1, prefix to add to
the model matrix (<code>"X"</code>) from <code><a href="brms.html#topic+standata">brms::make_standata()</a></code> in order to
reconstruct the <code>brms</code> model parameter names. This argument should
only be modified for testing purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix from <code><a href="#topic+brm_transform_marginal">brm_transform_marginal()</a></code> is passed to
the <code>transform_marginal</code> argument of <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>,
and it transforms posterior draws of model parameters to
posterior draws of marginal means. You may customize the output of
<code><a href="#topic+brm_transform_marginal">brm_transform_marginal()</a></code> before passing it to <code><a href="#topic+brm_marginal_draws">brm_marginal_draws()</a></code>.
However, please do not modify the dimensions, row names, or column
names.
</p>


<h3>Value</h3>

<p>A matrix to transform model parameters (columns) into
marginal means (rows).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data &lt;- brm_data(
  data = brm_simulate_simple()$data,
  outcome = "response",
  role = "response",
  group = "group",
  time = "time",
  patient = "patient",
  reference_group = "group_1",
  reference_time = "time_1"
)
formula &lt;- brm_formula(
  data = data,
  baseline = FALSE,
  baseline_time = FALSE
)
transform &lt;- brm_transform_marginal(data = data, formula = formula)
print(transform)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
