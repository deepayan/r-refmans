<!DOCTYPE html><html lang="en"><head><title>Help for package evitaicossa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {evitaicossa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#evitaicossa-package'>
<p>Antiassociative Algebra</p></a></li>
<li><a href='#aaa'>
<p>Function to create objects of class <code>aaa</code></p></a></li>
<li><a href='#aaa-class'><p>Class <code>"aaa"</code></p></a></li>
<li><a href='#allsymbols'><p>All symbols in an aaa object</p></a></li>
<li><a href='#Arith-methods'><p>Arithmetic methods for <code>aaa</code> objects</p></a></li>
<li><a href='#Compare-methods'><p>Comparison methods for antiassociative algebra</p></a></li>
<li><a href='#Extract'><p>Extract or Replace Parts of <code>aaa</code> objects</p></a></li>
<li><a href='#linear'><p>Linear functions</p></a></li>
<li><a href='#raaa'><p>Random elements of the free antiassociative algebra</p></a></li>
<li><a href='#show'><p>Print method for antiassociative algebra objects</p></a></li>
<li><a href='#zero'><p>The additive zero in antiassociative algebras</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Antiassociative Algebra</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to deal with the free antiassociative algebra
      over the reals with an arbitrary number of indeterminates.
      Antiassociativity means that (xy)z = -x(yz).  Antiassociative
      algebras are nilpotent with nilindex four (Remm, 2022,
      &lt;<a href="https://doi.org/10.48550%2FarXiv.2202.10812">doi:10.48550/arXiv.2202.10812</a>&gt;) and this drives the design and
      philosophy of the package.  Methods are defined to create and
      manipulate arbitrary elements of the antiassociative algebra,
      and to extract and replace coefficients.  A vignette is
      provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, testthat, mvtnorm, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0-7), disordR (&ge; 0.9-8-2), methods, Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/evitaicossa">https://github.com/RobinHankin/evitaicossa</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/evitaicossa/issues">https://github.com/RobinHankin/evitaicossa/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-26 19:36:19 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 09:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='evitaicossa-package'>
Antiassociative Algebra
</h2><span id='topic+evitaicossa-package'></span><span id='topic+evitaicossa'></span>

<h3>Description</h3>

<p>Methods to deal with the free antiassociative algebra
      over the reals with an arbitrary number of indeterminates.
      Antiassociativity means that (xy)z = -x(yz).  Antiassociative
      algebras are nilpotent with nilindex four (Remm, 2022,
      &lt;doi:10.48550/arXiv.2202.10812&gt;) and this drives the design and
      philosophy of the package.  Methods are defined to create and
      manipulate arbitrary elements of the antiassociative algebra,
      and to extract and replace coefficients.  A vignette is
      provided.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> evitaicossa</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Antiassociative Algebra</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Methods to deal with the free antiassociative algebra
      over the reals with an arbitrary number of indeterminates.
      Antiassociativity means that (xy)z = -x(yz).  Antiassociative
      algebras are nilpotent with nilindex four (Remm, 2022,
      &lt;doi:10.48550/arXiv.2202.10812&gt;) and this drives the design and
      philosophy of the package.  Methods are defined to create and
      manipulate arbitrary elements of the antiassociative algebra,
      and to extract and replace coefficients.  A vignette is
      provided.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, markdown, rmarkdown, testthat, mvtnorm, covr</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0-7), disordR (&gt;= 0.9-8-2), methods, Rdpack</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/evitaicossa</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/evitaicossa/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> Rdpack</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
aaa                     Function to create objects of class 'aaa'
aaa-class               Class '"aaa"'
allsymbols              All symbols in an aaa object
Arith-methods           Arithmetic methods for 'aaa' objects
Compare-methods         Comparison methods for antiassociative algebra
evitaicossa-package     Antiassociative Algebra
linear                  Linear functions
raaa                    Random elements of the free antiassociative
                        algebra
s1                      Extract or Replace Parts of 'aaa' objects
show                    Print method for antiassociative algebra
                        objects
zero                    The additive zero in antiassociative algebras
</pre>
<p>Functionality to work with the free antiassociative algebra in R.  The
hex sticker features an image taken from
Hoffnung (1959) in which musical concepts
[pizzicato, crescendo, etc] are given whimsical visual form.  The
character on the hex sticker is captioned &ldquo;A Discord&rdquo;: Hoffnung's
interpretation of the musical concept of dissonance.  In the book, the
preceding image was a &ldquo;<em>chord</em>&rdquo;, evoking harmony.  The
discord, on the other hand, embodies&ndash;for me at
least&ndash;antiassociativity: everything is wrong, wrong, wrong.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>

<p>Hoffnung G (1959).
<em>Hoffnung's Acoustics</em>.
Dobson.</p>


<h3>See Also</h3>

<p><code><a href="#topic+aaa">aaa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- raaa()
x
y &lt;- raaa()

x+y
x*y

</code></pre>

<hr>
<h2 id='aaa'>
Function to create objects of class <code>aaa</code>
</h2><span id='topic+aaa'></span><span id='topic+aaa_single'></span><span id='topic+aaa_double'></span><span id='topic+aaa_triple'></span><span id='topic+aaa_identity'></span><span id='topic+as.aaa'></span><span id='topic+lavter'></span><span id='topic+thing_to_aaa'></span>

<h3>Description</h3>

<p>Objects of class <code>aaa</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aaa(s1 = character(0), sc = numeric(0), d1 = character(0), d2 =
character(0), dc = numeric(0), t1 = character(0), t2 = character(0), t3
= character(0), tc = numeric(0))
lavter(cout)
as.aaa(s)
thing_to_aaa(L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aaa_+3A_s1">s1</code>, <code id="aaa_+3A_d1">d1</code>, <code id="aaa_+3A_d2">d2</code>, <code id="aaa_+3A_t1">t1</code>, <code id="aaa_+3A_t2">t2</code>, <code id="aaa_+3A_t3">t3</code></td>
<td>
<p>single, double, triple symbols</p>
</td></tr>
<tr><td><code id="aaa_+3A_sc">sc</code>, <code id="aaa_+3A_dc">dc</code>, <code id="aaa_+3A_tc">tc</code></td>
<td>
<p>single, double, triple coefficients</p>
</td></tr>
<tr><td><code id="aaa_+3A_l">L</code></td>
<td>
<p>A list with elements <code>s1</code> etc</p>
</td></tr>
<tr><td><code id="aaa_+3A_cout">cout</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="aaa_+3A_s">s</code></td>
<td>
<p>Object that function <code>as.aaa()</code> will coerce to an
<code>aaa</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>lavter()</code> is the formal creation method for <code>aaa</code>
objects; it is the only place that <code>new()</code> is called.  It takes a
single argument <code>cout</code>, which is a list as returned by
C function <code>retval()</code>.  But it is a little awkward to
use and the user should use other functions for creation, which are
more user-friendly and have sensible defaults:
</p>

<ul>
<li><p> Function <code>aaa()</code> takes named arguments <code>s1</code> etc,
with defaults corresponding to &ldquo;not present&rdquo;
</p>
</li>
<li><p> Function <code>thing_to_aaa()</code> takes a list with names
<code>s1</code> etc
</p>
</li>
<li><p> Function <code>as.aaa()</code>
tries hard to coerce its argument to an <code>aaa</code> object
</p>
</li></ul>



<h3>Value</h3>

<p>Return objects of class <code>aaa</code></p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aaa(s1 = "x", sc = 13)
aaa(d1 = "z", d2 = "w", dc = 14)
aaa(t1 = "x", t2 = "y", t3 = "z", tc = 15)

aaa(
    s1 = c("a","d"),
    sc = c( 4 , 2 ),
    d1 = c("a", "a", "a", "b"),
    d2 = c("a", "b", "d", "a"),
    dc = c( 3 ,  4 ,  4 ,  3 ),
    t1 = c("a", "a", "a", "b", "b"),
    t2 = c("c", "d", "d", "c", "c"),
    t3 = c("a", "c", "d", "a", "b"),
    tc = c(-4 , -1 , -4 , 11 , 20 )
)


aaa() # the zero object

aaa(s1=letters,sc=seq_along(letters))
aaa(d1=state.abb,d2=rev(state.abb),dc=seq_along(state.abb))

as.aaa(state.abb)


evita &lt;- aaa(s1=letters[1:5],sc=1:5)
icossa &lt;- aaa(d1=c("fish","chips"),d2=c("x","y"),dc=c(6,7))

evita
evita + icossa
evita * icossa
evita^2

f &lt;- function(o){aaa(state.abb[o],seq_along(o))}
f(8:9) - (f(1:2) - f(6:8)^2)^2

</code></pre>

<hr>
<h2 id='aaa-class'>Class <code>"aaa"</code></h2><span id='topic+aaa-class'></span>

<h3>Description</h3>

<p>Class <code>aaa</code> is for elements of the free antiassociative algebra
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("aaa", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>single_indeterminate_name1</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>single_indeterminate_coeff</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>double_indeterminate_name1</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>double_indeterminate_name2</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>double_indeterminate_coeff</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>triple_indeterminate_name1</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>triple_indeterminate_name2</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>triple_indeterminate_name3</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>triple_indeterminate_coeff</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("aaa")
</code></pre>

<hr>
<h2 id='allsymbols'>All symbols in an aaa object</h2><span id='topic+allsymbols'></span>

<h3>Description</h3>

<p>Function <code>allsymbols()</code> returns a character vector whose entries
include all symbols of its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allsymbols(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allsymbols_+3A_a">a</code></td>
<td>
<p>Object of class <code>aaa</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- raaaa()
a
allsymbols(a)

a[cbind(allsymbols(a))] == single(a)

</code></pre>

<hr>
<h2 id='Arith-methods'>Arithmetic methods for <code>aaa</code> objects</h2><span id='topic+Arith-methods'></span><span id='topic+Arith+2Caaa+2Caaa-method'></span><span id='topic+Arith+2Caaa+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2Caaa-method'></span><span id='topic+-+2Caaa+2Cmissing-method'></span><span id='topic++2B+2Caaa+2Cmissing-method'></span><span id='topic+aaa_arith_aaa'></span><span id='topic+aaa_arith_numeric'></span><span id='topic+aaa_negative'></span><span id='topic+numeric_arith_aaa'></span><span id='topic+aaa_plus_aaa'></span><span id='topic+aaa_prod_aaa'></span><span id='topic+aaa_plus_numeric'></span><span id='topic+aaa_prod_numeric'></span><span id='topic+aaa_power_numeric'></span><span id='topic+c_aaa_add'></span><span id='topic+c_aaa_prod'></span>

<h3>Description</h3>

<p>Arithmetic methods for objects of class <code>aaa</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(e1 = "aaa", e2 = "aaa")</code></dt><dd>
<p>Dispatches to <code>aaa_arith_aaa()</code>
</p>
</dd>
<dt><code>signature(e1 = "aaa", e2 = "numeric")</code></dt><dd>
<p>Dispatches to <code>aaa_arith_numeric()</code>
</p>
</dd>
<dt><code>signature(e1 = "numeric", e2 = "aaa")</code></dt><dd>
<p>Dispatches to <code>numeric_arith_aaa()</code>
</p>
</dd>
</dl>

<p>The S4 methods call lower-level functions
<code>aaa_plus_aaa()</code>, <code>aaa_prod_aaa()</code>, <code>aaa_prod_numeric()</code>,
<code>aaa_negative()</code>, and <code>aaa_plus_numeric()</code>.
</p>
<p>These functions call the Rcpp functions
<code>aaa_identity()</code>, <code>c_aaa_add()</code>, and <code>c_aaa_prod()</code>.
</p>

<hr>
<h2 id='Compare-methods'>Comparison methods for antiassociative algebra</h2><span id='topic+Compare-methods'></span><span id='topic+Compare+2Caaa+2Caaa-method'></span><span id='topic+Compare+2Caaa+2CANY-method'></span><span id='topic+Compare+2Caaa+2Cnumeric-method'></span><span id='topic+Compare+2CANY+2Caaa-method'></span><span id='topic+Compare+2Cnumeric+2Caaa-method'></span><span id='topic+aaa_compare_aaa'></span><span id='topic+aaa_compare_error'></span><span id='topic+aaa_equal_aaa'></span><span id='topic+c_aaa_equal'></span>

<h3>Description</h3>

<p>Comparison methods generally do not make sense for elements of an
antiassociative algebra.  The only exception is equality: <code>x == y</code>
returns <code>TRUE</code> if <code>aaa</code> objects <code>x</code> and <code>y</code> are
identical.
</p>
<p>The test for equality follows the <a href="https://CRAN.R-project.org/package=frab"><span class="pkg">frab</span></a> package: go through
the keys of <code>x</code>, compare the corresponding values of <code>y</code>, and
return <code>FALSE</code> when any difference is detected.  This is faster
than <code>is.zero(x-y)</code>.  
</p>
<p>Technically, <code>x==0</code> makes sense but I thought consistency was more
important: in the package, numeric values cannot be compared with
<code>aaa</code> objects.
</p>
<p>Functions <code>aaa_compare_aaa()</code> etc. are used in S4
dispatch; <code>c_aaa_equal()</code> is a low-level helper function that uses
Rcpp to call the appropriate C routine.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(e1 = "aaa", e2 = "aaa")</code></dt><dd></dd>
<dt><code>signature(e1 = "aaa", e2 = "ANY")</code></dt><dd></dd>
<dt><code>signature(e1 = "aaa", e2 = "numeric")</code></dt><dd></dd>
<dt><code>signature(e1 = "ANY", e2 = "aaa")</code></dt><dd></dd>
<dt><code>signature(e1 = "numeric", e2 = "aaa")</code></dt><dd></dd>
</dl>

<hr>
<h2 id='Extract'>Extract or Replace Parts of <code>aaa</code> objects</h2><span id='topic+s1'></span><span id='topic+sc'></span><span id='topic+d1'></span><span id='topic+d2'></span><span id='topic+dc'></span><span id='topic+t1'></span><span id='topic+t2'></span><span id='topic+t3'></span><span id='topic+tc'></span><span id='topic+s1+2Caaa-method'></span><span id='topic+sc+2Caaa-method'></span><span id='topic+d1+2Caaa-method'></span><span id='topic+d2+2Caaa-method'></span><span id='topic+dc+2Caaa-method'></span><span id='topic+t1+2Caaa-method'></span><span id='topic+t2+2Caaa-method'></span><span id='topic+t3+2Caaa-method'></span><span id='topic+tc+2Caaa-method'></span><span id='topic+single'></span><span id='topic+double'></span><span id='topic+triple'></span><span id='topic+single+3C-'></span><span id='topic+double+3C-'></span><span id='topic+triple+3C-'></span><span id='topic+getthings'></span><span id='topic+coeffs'></span><span id='topic+extracter'></span><span id='topic+overwriter'></span><span id='topic+extracter+3C-'></span><span id='topic+c_aaa_extract'></span><span id='topic+c_aaa_overwriter'></span><span id='topic++5B+2Caaa+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Caaa+2Ccharacter+2CANY+2CANY-method'></span><span id='topic++5B+2Caaa+2Cmatrix+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Caaa+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Caaa+2Ccharacter+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Caaa+2Cmatrix+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Caaa+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Caaa+2Cdisord+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Extraction methods for <code>aaa</code> objects.  The names of the
two-letter functions and arguments follow a pattern: the initial
letter (s, d, t) stands for &ldquo;single&rdquo;, &ldquo;double&rdquo;, or
&ldquo;triple&rdquo;; the second symbol is c for &ldquo;coefficients&rdquo;, or
a number (1, 2, 3) denoting first, second, or third.  Thus
&ldquo;<code>dc()</code>&rdquo; gets the coefficients of the double-symbol
components, and &ldquo;<code>t2()</code>&rdquo; gets the second symbol of the
triple-symbol components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'aaa'
s1(a)
## S4 method for signature 'aaa'
sc(a)
## S4 method for signature 'aaa'
d1(a)
## S4 method for signature 'aaa'
d2(a)
## S4 method for signature 'aaa'
dc(a)
## S4 method for signature 'aaa'
t1(a)
## S4 method for signature 'aaa'
t2(a)
## S4 method for signature 'aaa'
t3(a)
## S4 method for signature 'aaa'
tc(a)
single(a)
double(a)
triple(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extract_+3A_a">a</code></td>
<td>
<p>Object of class <code>aaa</code></p>
</td></tr></table>


<h3>Details</h3>

<p>An <code>aaa</code> object is a list of 9 vectors, three numeric and six
character, which are extractd by functions <code>s1()</code> etc.
</p>
<p>Functions <code>single()</code>, <code>double()</code> and
<code>triple()</code> extract the single, double, and triple components
of their argument, and return the corresponding <code>aaa</code> object.
</p>
<p>There is no function <code>evitaicossa::coeffs()</code> because the three
types of elements are qualitatively different; use <code>sc()</code>,
<code>dc()</code>, and <code>tc()</code> to get the coefficients in <code>disord</code>
format.
</p>
<p>Functions <code>getthings()</code>, <code>extracter()</code> and
<code>overwriter()</code> are lower-level methods, not really intended for
the end-user.  Function <code>getthings()</code> takes an <code>aaa</code> object
and returns a named list with elements being <code>disord</code> objects
corresponding to components <code>s1</code>,<code>sc</code>,<code>d1</code> etc.
Function extracter() takes an <code>aaa</code> object and arguments
<code>s1</code>, <code>d1</code>,<code>d2</code>,<code>t1</code> etc. and returns the
<code>aaa</code> object corresponding to the specified index elements.
Function <code>overwriter</code> takes
</p>
<p>Functions <code>single()</code>, <code>double()</code>, and <code>triple()</code> return
the index-1, index-2, and index-3 components of their arguments
respectively.  Functions <code>single&lt;-()</code> <em>et seq.</em> are the
corresponding setting methods which overwrite the index-1 (resp. 2,3)
components with the right hand side.  The right hand side must be
purely the correct compponent otherwise an error is returned; thus in
<code>double(a) &lt;- x</code>, for example, the single-symbol and
triple-symbol components of <code>x</code> must be zero.
</p>
<p>Square bracket extraction and replacement methods are more
user-friendly.  These operate in two distinct modes.  If given named
arguments (<code>s1</code>, <code>d1</code>,<code>d2</code>, <em>et seq.</em>) then these
are interpreted as symbols and coefficients of the different orders.
If given an unnamed argument, this is interpreted as a character
vector of length one, two, or three specifying a particular term in
the object.  See examples.
</p>


<h3>Value</h3>

<p>Return disord or <code>aaa</code> objects</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- linear1(1:3) + (linear1(1:2) + linear2(1:3))^2
x
x[d1=c("a","a"),d2=c("a","b")]
x[s1="a", t1="b", t2="c", t3="c"]


x[s1="a", t1="b", t2="c", t3="c"] &lt;- 88
x
x[c("c","c","b")] &lt;- -777
x


a &lt;- raaaa()
sc(a)
t2(a)
single(a)

single(a) + double(a) + triple(a) == a  # should be TRUE

aaa(d1=d1(a),d2=d2(a), dc=dc(a)) == double(a)

x &lt;- raaaa()
single(x) &lt;- 0
double(x) &lt;- double(raaa())

</code></pre>

<hr>
<h2 id='linear'>Linear functions</h2><span id='topic+linear'></span><span id='topic+linear1'></span><span id='topic+linear2'></span><span id='topic+linear3'></span>

<h3>Description</h3>

<p>Linear functions returning single, double, or triple-symbol <code>aaa</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear1(x)
linear2(x)
linear3(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr></table>


<h3>Details</h3>

<p>These functions return an antiassociative algebra element with the
specified coefficients.  Given a numeric vector <code>v</code> with elements
<code class="reqn">v_1,v_2,\ldots, v_n</code> then
</p>
<p><code>linear1(v)</code> returns <code class="reqn">v_1\mathbf{a} + v_2\mathbf{b}+\cdots+
v_n\mathbf{L_n}</code>, where <code class="reqn">\mathbf{L_n}</code> is the
<code class="reqn">n^\mathrm{th}</code> letter of the alphabet.  Similarly,
<code>linear2(v)</code> returns <code class="reqn">v_1\mathbf{a}\mathbf{a}+\cdots+
v_n\mathbf{L_n}\mathbf{L_n}</code>, and <code>linear3(v)</code> returns
<code class="reqn">v_1(\mathbf{a}\mathbf{a})\mathbf{a}+\cdots+
v_n(\mathbf{L_n}\mathbf{L_n})\mathbf{L_n}</code>. They are linear in
the sense that
</p>
<p style="text-align: center;"><code class="reqn">
  f(\alpha\mathbf{x}+\beta\mathbf{y})=
\alpha f(\mathbf{x})+\beta f(\mathbf{y})</code>
</p>

<p>where <code class="reqn">\alpha,\beta\in\mathbb{R}</code> and
<code class="reqn">\mathbf{x},\mathbf{y}\in\mathbb{R}^n</code>.
</p>


<h3>Value</h3>

<p>These functions return an object of class <code>aaa</code>.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
linear1(sample(8))
linear2(sample(8))
linear3(sample(8))

a &lt;- 3
b &lt;- 7
x &lt;- sample(9)
y &lt;- sample(9)

linear1(a*x + b*y) == a*linear1(x) + b*linear1(y)
linear2(a*x + b*y) == a*linear2(x) + b*linear2(y)
linear3(a*x + b*y) == a*linear3(x) + b*linear3(y)
</code></pre>

<hr>
<h2 id='raaa'>Random elements of the free antiassociative algebra</h2><span id='topic+raaa'></span><span id='topic+raaaa'></span>

<h3>Description</h3>

<p>Random elements of the free antiassociative algebra, intended as quick
&ldquo;get you going&rdquo; examples of <code>aaa</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raaa(n = 4, s = 3)
raaaa(n = 10, s = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raaa_+3A_n">n</code></td>
<td>
<p>Number of terms to generate</p>
</td></tr>
<tr><td><code id="raaa_+3A_s">s</code></td>
<td>
<p>Number of symbols to use in the alphabet</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>raaa()</code> returns a random  <code>aaa</code> object.
Function <code>raaaa()</code> returns, by default,
a more complicated <code>aaa</code> object.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>aaa</code></p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>raaa()
raaaa()
</code></pre>

<hr>
<h2 id='show'>Print method for antiassociative algebra objects</h2><span id='topic+show'></span><span id='topic+print'></span><span id='topic+print.aaa'></span><span id='topic+aaa_show'></span><span id='topic+putsign'></span><span id='topic+single_string'></span><span id='topic+double_string'></span><span id='topic+triple_string'></span><span id='topic+show+2Caaa-method'></span>

<h3>Description</h3>

<p>Show methods for <code>aaa</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'aaa'
show(object)
aaa_show(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_+3A_a">a</code>, <code id="show_+3A_object">object</code></td>
<td>
<p>Object of class <code>aaa</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bunch of functionality to print <code>aaa</code> objects.
</p>
<p>Function <code>putsign()</code> is a low-level helper function that puts the
sign (that is, <code>+</code> or <code>-</code>) before each element of a numeric
vector.  Functions <code>single_string()</code>, <code>double_string()</code>, and
<code>triple_string()</code> process the 1,2, and 3- symbols for printing.
</p>


<h3>Value</h3>

<p>No return value, called for side-effects</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>aaa_show(raaa())
aaa_show(aaa())
</code></pre>

<hr>
<h2 id='zero'>The additive zero in antiassociative algebras</h2><span id='topic+zero'></span><span id='topic+is.zero'></span>

<h3>Description</h3>

<p>Function <code>is.zero()</code> tests for its argument being the additive
zero.
</p>
<p>Package idiom to create the zero element of the antiassociative algebra
is <code>aaa()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.zero(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero_+3A_x">x</code></td>
<td>
<p>Object of class <code>aaa</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Boolean.</p>


<h3>Note</h3>

<p>In any antiassociative algebra, the only scalar is zero.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.zero(raaa())
is.zero(raaa()*0)
is.zero(aaa())

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
