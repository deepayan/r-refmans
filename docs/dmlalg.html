<!DOCTYPE html><html lang="en"><head><title>Help for package dmlalg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dmlalg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.regsdml'><p>Accessing the coefficients of regsdml fits</p></a></li>
<li><a href='#confint.mmdml'><p>Confidence Intervals for coefficient estimates of mmdml fits</p></a></li>
<li><a href='#confint.regsdml'><p>Confidence Intervals for coefficient estimates of regsdml fits</p></a></li>
<li><a href='#dmlalg'><p>dmlalg: double machine learning algorithms</p></a></li>
<li><a href='#example_data_mmdml'><p>Generate data from partially linear mixed-effects model</p></a></li>
<li><a href='#lme4-extractors'><p>Extract Components from 'mmdml' Fits Imported from 'lme4'</p></a></li>
<li><a href='#mmdml'><p>Estimating linear coefficients in partially linear mixed-effects models with repeated measurements using double machine learning.</p></a></li>
<li><a href='#print.mmdml'><p>Printing mmdml fits</p></a></li>
<li><a href='#print.regsdml'><p>Printing regsdml fits</p></a></li>
<li><a href='#regsdml'><p>Estimating linear coefficients with double machine learning (DML)</p></a></li>
<li><a href='#residuals.mmdml'><p>Confidence Intervals for coefficient estimates of regsDML fits</p></a></li>
<li><a href='#sigma.mmdml'><p>Extract Residual Standard Deviation 'Sigma' from mmdml Fits</p></a></li>
<li><a href='#summary.mmdml'><p>Summarizing mmdml fits</p></a></li>
<li><a href='#summary.regsdml'><p>Summarizing regsdml fits</p></a></li>
<li><a href='#vcov.regsdml'><p>Accessing the variance-covariance matrices of regsdml fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Double Machine Learning Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of double machine learning (DML) algorithms in R, 
    based on Emmenegger and Buehlmann (2021) "Regularizing Double Machine Learning 
    in Partially Linear Endogenous Models" &lt;<a href="https://doi.org/10.48550/arXiv.2101.12525">doi:10.48550/arXiv.2101.12525</a>&gt; and Emmenegger and
    Buehlmann (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2108.13657">doi:10.48550/arXiv.2108.13657</a>&gt; "Double Machine Learning for Partially 
    Linear Mixed-Effects Models with Repeated Measurements". 
    First part: our goal is to perform inference for the linear parameter in partially
    linear models with confounding variables.
    The standard DML estimator of the linear parameter has a two-stage least
    squares interpretation, which can lead to a large variance and overwide
    confidence intervals.
    We apply regularization to reduce the variance of the estimator,
    which produces narrower confidence intervals that are approximately valid.
    Nuisance terms can be flexibly estimated with machine learning algorithms.
    Second part: our goal is to estimate and perform inference for the linear 
    coefficient in a partially linear mixed-effects model
    with DML. Machine learning algorithms allows us to incorporate more
    complex interaction structures and high-dimensional variables. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.math.ethz.ch/ecorinne/dmlalg.git">https://gitlab.math.ethz.ch/ecorinne/dmlalg.git</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, lme4, matrixcalc, methods, splines, randomForest</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-03 12:20:14 UTC; Corinne</td>
</tr>
<tr>
<td>Author:</td>
<td>Corinne Emmenegger
    <a href="https://orcid.org/0000-0003-0353-8888"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Peter Buehlmann <a href="https://orcid.org/0000-0002-1782-6015"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Corinne Emmenegger &lt;emmenegger@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-03 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.regsdml'>Accessing the coefficients of regsdml fits</h2><span id='topic+coef.regsdml'></span>

<h3>Description</h3>

<p>This is a method for the class <code>regsdml</code>. It returns the estimated
coefficients from
objects of class <code>regsdml</code>, which typically result from a function
call to <code><a href="#topic+regsdml">regsdml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regsdml'
coef(object,
    print_regsDML = NULL,
    print_safety = NULL,
    print_DML = NULL,
    print_regDML = NULL,
    print_regDML_all_gamma = !is.null(parm),
    parm = NULL,
    print_gamma = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.regsdml_+3A_object">object</code></td>
<td>
<p>An object of class <code>regsdml</code>. This object usually
results from a function call to <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</td></tr>
<tr><td><code id="coef.regsdml_+3A_print_regsdml">print_regsDML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>regsDML</code> method are returned.</p>
</td></tr>
<tr><td><code id="coef.regsdml_+3A_print_safety">print_safety</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the safety device are returned.</p>
</td></tr>
<tr><td><code id="coef.regsdml_+3A_print_dml">print_DML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>DML</code> method are returned.</p>
</td></tr>
<tr><td><code id="coef.regsdml_+3A_print_regdml">print_regDML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>regDML</code> method with the optimal choice of <code>gamma</code>
(including the factor <code>a_N</code>) are returned.</p>
</td></tr>
<tr><td><code id="coef.regsdml_+3A_print_regdml_all_gamma">print_regDML_all_gamma</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
specified by <code>parm</code> below are returned.</p>
</td></tr>
<tr><td><code id="coef.regsdml_+3A_parm">parm</code></td>
<td>
<p>A vector containing the indices for which <code>gamma</code>-values
the results of the regularized DML estimator, whose results
are stored in the list <code>regDML_all_gamma_statistics</code> of <code>object</code>,
should be included in the output. If <code>parm</code> is specified,
it is not necessary to specify <code>print_regDML_all_gamma</code>.</p>
</td></tr>
<tr><td><code id="coef.regsdml_+3A_print_gamma">print_gamma</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the <code>gamma</code>-values
are printed in an extra row where the respective regularization methods
achieved their optimum.</p>
</td></tr>
<tr><td><code id="coef.regsdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients of the methods <code>regsDML</code>, the <code>safety</code> device,
<code>DML</code>, <code>regDML</code> with the optimal
choice of <code class="reqn">\gamma</code> (including the factor <code>a_N</code>),
and <code>regDML</code>
with prespecified <code class="reqn">\gamma</code>-values are returned by setting the
respective arguments. It is possible to return the respective
<code>gamma</code>-values.
</p>
<p>If none of the printing arguments are set, only the results of regsDML
are returned if they are available. If they are not available and none of
the printing arguments are set, the results from all available methods
are returned. If <code>print_regsDML = FALSE</code>, only the results from
those methods are returned that are explicitly specified by the printing
arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regsdml">regsdml</a></code>,
<code><a href="#topic+summary.regsdml">summary.regsdml</a></code>,
<code><a href="#topic+confint.regsdml">confint.regsdml</a></code>,
<code><a href="#topic+vcov.regsdml">vcov.regsdml</a></code>
<code><a href="#topic+print.regsdml">print.regsdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(regsdml) for examples
</code></pre>

<hr>
<h2 id='confint.mmdml'>Confidence Intervals for coefficient estimates of mmdml fits</h2><span id='topic+confint.mmdml'></span>

<h3>Description</h3>

<p>This is a method for the class <code>mmdml</code>.
It computes two-sided
confidence intervals for testing the two-sided component-wise
null hypotheses
<code class="reqn">H_0: \beta_j = 0</code>
with the (approximate) asymptotic Gaussian distribution of the coefficient
estimator. The method can be applied to objects
of class <code>mmdml</code> that typically result from a function
call to <code><a href="#topic+mmdml">mmdml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmdml'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.mmdml_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmdml</code>. This object usually results
from a function call to <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</td></tr>
<tr><td><code id="confint.mmdml_+3A_parm">parm</code></td>
<td>
<p>A vector containing the indices for which <code class="reqn">\beta_0</code>-entries
confidence intervals should be computed. By default, it is set to
<code>NULL</code>, in which case confidence intervals for all entries of
<code class="reqn">\beta_0</code> are computed.</p>
</td></tr>
<tr><td><code id="confint.mmdml_+3A_level">level</code></td>
<td>
<p>A number between 0 and 1 representing
the confidence level. The default is <code>level = 0.95</code>.</p>
</td></tr>
<tr><td><code id="confint.mmdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns giving the lower and upper confidence limits for each
entry of <code class="reqn">\beta_0</code>.
The columns are labelled as
These will be labelled as <code>(1-level)/2</code>% and
<code>1 - (1-level)/2</code>%, by default 2.5% and 97.5%.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmdml">mmdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(mmdml) for examples
</code></pre>

<hr>
<h2 id='confint.regsdml'>Confidence Intervals for coefficient estimates of regsdml fits</h2><span id='topic+confint.regsdml'></span>

<h3>Description</h3>

<p>This is a method for the class <code>regsdml</code>.
It computes two-sided
confidence intervals for testing the two-sided component-wise
null hypotheses that tests if a component equals zero
with the (approximate) asymptotic Gaussian distribution of the
coefficient estimator. The method can be applied to objects
of class <code>regsdml</code>, which typically result from a function
call to <code><a href="#topic+regsdml">regsdml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regsdml'
confint(object,
    parm = NULL,
    level = 0.95,
    print_regsDML = NULL,
    print_safety = NULL,
    print_DML = NULL,
    print_regDML = NULL,
    print_regDML_all_gamma = !is.null(parm),
    print_gamma = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.regsdml_+3A_object">object</code></td>
<td>
<p>An object of class <code>regsdml</code>. This object usually
results from a function call to <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_parm">parm</code></td>
<td>
<p>A vector containing the indices for which <code>gamma</code>-values
the results of the regularized DML estimator, whose results
are stored in the list <code>regDML_all_gamma_statistics</code> of <code>object</code>,
should be included in the output. If <code>parm</code> is specified,
it is not necessary to specify <code>print_regDML_all_gamma</code>.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_level">level</code></td>
<td>
<p>A number between 0 and 1 representing
the confidence level. The default is <code>level = 0.95</code>.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_print_regsdml">print_regsDML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>regsDML</code> method are returned.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_print_safety">print_safety</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the safety device are returned.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_print_dml">print_DML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>DML</code> method are returned.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_print_regdml">print_regDML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>regDML</code> method with the optimal choice of <code>gamma</code>
(including the factor <code>a_N</code>) are returned.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_print_regdml_all_gamma">print_regDML_all_gamma</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
specified by <code>parm</code> below are returned.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_print_gamma">print_gamma</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the <code>gamma</code>-values
are printed in brackets where the respective regularization methods
achieved their optimum.</p>
</td></tr>
<tr><td><code id="confint.regsdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Confidence intervals for the methods <code>regsDML</code>, the <code>safety</code> device,
<code>DML</code>, <code>regDML</code> with the optimal
choice of <code class="reqn">\gamma</code> (including the factor <code>a_N</code>),
and <code>regDML</code>
with prespecified <code class="reqn">\gamma</code>-values are returned by setting the
respective arguments.
</p>
<p>If none of the printing arguments are set, only the results of regsDML
are returned if they are available. If they are not available and none of
the printing arguments are set, the results from all available methods
are returned. If <code>print_regsDML = FALSE</code>, only the results from
those methods are returned that are explicitly specified by the printing
arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regsdml">regsdml</a></code>,
<code><a href="#topic+summary.regsdml">summary.regsdml</a></code>,
<code><a href="#topic+coef.regsdml">coef.regsdml</a></code>,
<code><a href="#topic+vcov.regsdml">vcov.regsdml</a></code>
<code><a href="#topic+print.regsdml">print.regsdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(regsdml) for examples.
</code></pre>

<hr>
<h2 id='dmlalg'>dmlalg: double machine learning algorithms</h2><span id='topic+dmlalg'></span>

<h3>Description</h3>

<p>The <code>dmlalg</code> package contains implementations of
double machine learning (DML) algorithms in <code>R</code>.
</p>


<h3>Partially linear models with confounding variables</h3>

<p>Our goal is to perform inference for the linear parameter in partially
linear models with confounding variables.
The standard DML estimator of the linear parameter has a two-stage least
squares interpretation, which can lead to a large variance and overwide
confidence intervals.
We apply regularization to reduce the variance of the estimator,
which produces narrower confidence intervals that are approximately valid.
Nuisance terms can be flexibly estimated with machine learning algorithms.
</p>

<dl>
<dt><code><a href="#topic+regsdml">regsdml</a></code></dt><dd><p>Estimates the
linear parameter in a partially linear model with
confounding variables with regularized and standard
DML methods.</p>
</dd>
<dt><code><a href="#topic+summary.regsdml">summary.regsdml</a></code></dt><dd><p>A <code>summary</code> method for objects
fitted with <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+confint.regsdml">confint.regsdml</a></code></dt><dd><p>A <code>confint</code> method for objects
fitted with <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+coef.regsdml">coef.regsdml</a></code></dt><dd><p>A <code>coef</code> method for objects
fitted with <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+vcov.regsdml">vcov.regsdml</a></code></dt><dd><p>A <code>vcov</code> method for objects
fitted with <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+print.regsdml">print.regsdml</a></code></dt><dd><p>A <code>print</code> method for objects
fitted with <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</dd>
</dl>



<h3>Partially linear mixed-effects models with repeated measurements</h3>

<p>Our goal is to estimate and perform inference for the linear
coefficient in a partially linear mixed-effects model
with DML. Machine learning algorithms allows us to incorporate more
complex interaction structures and high-dimensional variables.
</p>

<dl>
<dt><code><a href="#topic+mmdml">mmdml</a></code></dt><dd><p>Estimates the
linear parameter in a PLMM with repeated
measurements using
double machine learning.</p>
</dd>
<dt><code><a href="#topic+confint.mmdml">confint.mmdml</a></code></dt><dd><p>A <code>confint</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+fixef.mmdml">fixef.mmdml</a></code></dt><dd><p>A <code>fixef</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+print.mmdml">print.mmdml</a></code></dt><dd><p>A <code>print</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+ranef.mmdml">ranef.mmdml</a></code></dt><dd><p>A <code>ranef</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+residuals.mmdml">residuals.mmdml</a></code></dt><dd><p>A <code>residuals</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+sigma.mmdml">sigma.mmdml</a></code></dt><dd><p>A <code>sigma</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+summary.mmdml">summary.mmdml</a></code></dt><dd><p>A <code>summary</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+vcov.mmdml">vcov.mmdml</a></code></dt><dd><p>A <code>vcov</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
<dt><code><a href="#topic+VarCorr.mmdml">VarCorr.mmdml</a></code></dt><dd><p>A <code>VarCorr</code> method for objects
fitted with <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>C. Emmenegger and P. Bühlmann.
Regularizing Double Machine Learning in Partially Linear Endogenous
Models, 2021. Preprint arXiv:2101.12525.
</p>
<p>C. Emmenegger and P. Bühlmann.
Double Machine Learning for Partially Linear Mixed-Effects Models with Repeated Measurements. Preprint arXiv:2108.13657.
</p>

<hr>
<h2 id='example_data_mmdml'>Generate data from partially linear mixed-effects model</h2><span id='topic+example_data_mmdml'></span>

<h3>Description</h3>

<p>Generate data from a partially linear mixed-effects model with one or two
fixed effects, 2 random effects, and 3 nonparametric variables.
The true underlying function of the nonparametric variables are step
functions.
The random effects and error terms are from a Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data_mmdml(beta0, N = 10L, n = 5L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="example_data_mmdml_+3A_beta0">beta0</code></td>
<td>
<p>Numeric vector of length 1 or 2 representing the linear
coefficient/fixed effects of the model.</p>
</td></tr>
<tr><td><code id="example_data_mmdml_+3A_n">N</code></td>
<td>
<p>Number of experimental units. Equals 10 per default.</p>
</td></tr>
<tr><td><code id="example_data_mmdml_+3A_n">n</code></td>
<td>
<p>Expected number of observations per experimental unit,
needs to be at least 5. Equals 5 per default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the columns <code>resp</code> (the response), <code>id</code> and
<code>cask</code> (random effects), <code>w1</code>, <code>w2</code>, and <code>w3</code>
(nonparametric confounders), and <code>x1</code> if <code>beta0</code> is of length
1 and <code>x1</code> and <code>x2</code> if <code>beta0</code> is of length 2.
The random effects are modelled with <code>"(1|id) + (1|cask:id)"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmdml">mmdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(mmdml) for examples
</code></pre>

<hr>
<h2 id='lme4-extractors'>Extract Components from 'mmdml' Fits Imported from 'lme4'</h2><span id='topic+fixef'></span><span id='topic+fixef.mmdml'></span><span id='topic+ranef'></span><span id='topic+ranef.mmdml'></span><span id='topic+VarCorr'></span><span id='topic+VarCorr.mmdml'></span><span id='topic+vcov'></span><span id='topic+vcov.mmdml'></span>

<h3>Description</h3>

<p>Methods for the class <code>mmdml</code> for generics from <a href="https://CRAN.R-project.org/package=lme4"><span class="pkg">lme4</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixef(object, ...)
## S3 method for class 'mmdml'
fixef(object, ...)

ranef(object, ...)
## S3 method for class 'mmdml'
ranef(object, ...)

VarCorr(x, sigma = 1, ...)
## S3 method for class 'mmdml'
VarCorr(x, ...)

vcov(object, ...)
## S3 method for class 'mmdml'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lme4-extractors_+3A_object">object</code>, <code id="lme4-extractors_+3A_x">x</code></td>
<td>
<p>An object of class <code>mmdml</code>. This object usually results
from a function call to <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</td></tr>
<tr><td><code id="lme4-extractors_+3A_sigma">sigma</code></td>
<td>
<p>See <code><a href="lme4.html#topic+lmer">lmer</a></code> from package <a href="https://CRAN.R-project.org/package=lme4"><span class="pkg">lme4</span></a>.</p>
</td></tr>
<tr><td><code id="lme4-extractors_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fixef.mmdml</code>:
Extracts the estimator of the linear coefficient <code class="reqn">\beta_0</code>, which
is a named and numeric vector.
</p>
<p><code>ranef.mmdml</code>:
Extracts the <code>random_eff</code> entry from <code>object</code>.
</p>
<p><code>VarCorr.mmdml</code>:
The variance and correlation components are computed with the
<code>sigma</code> and the <code>theta</code> entries of <code>x</code> as in
<code><a href="lme4.html#topic+lmer">lmer</a></code>.
For each of the <code>S</code> repetitions, <code>sigma</code> and <code>theta</code>
computed
on the <code>K</code> sample splits are aggregated by taking the mean.
Then, the <code>S</code> mean-aggregated estimates are aggregated by
the median.
The variance and correlation components are computed with these
median-aggregated estimates.
</p>
<p><code>vcov.mmdml</code>:
It returns the variance-covariance matrix of the estimator of the linear
coefficient is extracted.
It is computed based on the asymptotic Gaussian distribution
of the estimator.
First, for each of the <code>S</code> repetitions, the variance-covariance
matrices computed
on the <code>K</code> sample splits are aggregated by taking the mean.
Second, the <code>S</code> mean-aggregated estimates are aggregated by
adding a term correcting for the randomness in the sample splits
and by taking the median of these corrected terms.
This final corrected and median-aggregated matrix is returned.
</p>


<h3>Value</h3>

<p>See <code><a href="lme4.html#topic+lmer">lmer</a></code> from package <a href="https://CRAN.R-project.org/package=lme4"><span class="pkg">lme4</span></a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmdml">mmdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(mmdml) for examples
</code></pre>

<hr>
<h2 id='mmdml'>Estimating linear coefficients in partially linear mixed-effects models with repeated measurements using double machine learning.</h2><span id='topic+mmdml'></span><span id='topic+dmlmixed'></span><span id='topic+mixed_dml'></span><span id='topic+dml_mixed'></span>

<h3>Description</h3>

<p>Our goal is to perform inference for the linear parameter in partially
linear mixed-effects models (PLMMs) with
repeated measurements using double machine learning (DML).
</p>
<p>The function <code>mmdml</code> estimates the linear parameter <code class="reqn">\beta_0</code>
in the PLMM
</p>
<p style="text-align: center;"><code class="reqn">Y_i = X_i\beta_0 + g(W_i) + Z_ib_i + \epsilon_{Y_i},
    (i = 1, \ldots, N)</code>
</p>

<p>for the continuous response <code class="reqn">Y_i</code>
with linear covariates
<code class="reqn">X_i</code>, nonlinear covariates <code class="reqn">W_i</code>,  unobserved random effects
<code class="reqn">b_i</code>, and the error term <code class="reqn">\epsilon_{Y_i}</code>.
For each <code class="reqn">i</code>, there are <code class="reqn">n_i</code> repeated observations available.
That is, <code class="reqn">Y_i</code> is an <code class="reqn">n_i</code>-dimensional vector.
The matrix <code class="reqn">Z_i</code> is fixed. The random effects <code class="reqn">b_i</code> and the
error terms <code class="reqn">\epsilon_{Y_i}</code> are Gaussian distributed, independent,
and independent of <code class="reqn">b_j</code> and <code class="reqn">\epsilon_{Y_j}</code>, respectively,
for <code class="reqn">i\neq j</code>. The linear and nonlineare covariates <code class="reqn">X_i</code> and
<code class="reqn">W_i</code> are random and independent of all random effects and error terms.
</p>
<p>The linear parameter <code class="reqn">\beta_0</code> can be estimated with
a linear mixed-effects modeling approach with maximum likelihood
after regressing out <code class="reqn">W_i</code>
nonparametrically from <code class="reqn">Y_i</code> and <code class="reqn">X_i</code> using machine learning
algorithms.
A linear mixed-effects model is estimated on the partialled-out data
</p>
<p style="text-align: center;"><code class="reqn">Y_i - E[Y_i|W_i] = (X_i - E[X_i|W_i])\beta_0 + Z_ib_i
    + \epsilon_{Y_i}.</code>
</p>

<p>The conditional expectations are estimated with machine learning algorithms
and sample splitting, and cross-fitting is used to regain full efficiency
of the estimator of <code class="reqn">beta_0</code>. This estimator
is asymptotically Gaussian distributed and efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmdml(
  w, x, y, z, data = NULL,
  z_formula = NULL, group = "group",
  K = 2L, S = 100L,
  cond_method = rep("forest", 2),
  params = NULL,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1L, cl = NULL,
  nr_random_eff = if (S &gt; 5) 1L else S,
  nr_res = nr_random_eff
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmdml_+3A_w">w</code></td>
<td>
<p>A vector, matrix, or data frame. Its columns contain observations
of the nonlinear predictors. Alternatively, if the data is
provided in the data frame <code>data</code>, <code>w</code> is a character vector
whose entries specify the columns of <code>data</code> acting as <code class="reqn">W</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_x">x</code></td>
<td>
<p>A vector, matrix, or data frame. This is the linear predictor.
Alternatively, if the data is provided in the data frame
<code>data</code>, <code>x</code> is a character vector whose entries specify
the columns of <code>data</code> acting as <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_y">y</code></td>
<td>
<p>A vector, matrix, or data frame. This is the response.
Alternatively, if the data is provided in the data frame
<code>data</code>, <code>y</code> is a character vector whose entries specify
the columns of <code>data</code> acting as <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_z">z</code></td>
<td>
<p>A vector, matrix, or data frame. It acts as the fixed matrix
assigning the random effects.
Alternatively, if the data is
provided in the data frame <code>data</code>, <code>z</code> is a character vector
whose entries specify the columns of <code>data</code> acting as <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_z_formula">z_formula</code></td>
<td>
<p>A string specifying the structure of the random effect
using the notation as in <code><a href="lme4.html#topic+lmer">lmer</a></code>
from package <a href="https://CRAN.R-project.org/package=lme4"><span class="pkg">lme4</span></a>, e.g.,
<code>(1|id) + (1|cask:id)</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_group">group</code></td>
<td>
<p>A string containing the name of the grouping variable in
<code>zz</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_data">data</code></td>
<td>
<p>An optional data frame. If it is specified, its column names
need to coincide with the character vectors specified in <code>a</code>,
<code>w</code>, <code>x</code>, and <code>y</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_k">K</code></td>
<td>
<p>The number of sample splits used for cross-fitting.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_s">S</code></td>
<td>
<p>Number of replications to correct for the random
splitting of the sample. It is set to <code>100L</code> by default.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_cond_method">cond_method</code></td>
<td>
<p>A character vector of length 2 specifying the estimation
methods used to fit the conditional
expectations <code class="reqn">E[X|W]</code> and <code class="reqn">E[Y|W]</code>.
Its components are from
from <code>"spline"</code>, <code>"forest"</code>,
<code>"ols"</code>, <code>"lasso"</code>, <code>"ridge"</code>, and <code>"elasticnet"</code>,
or it is a list of length 2 with components from <code>"spline"</code>,
<code>"forest"</code>,
<code>"ols"</code>, <code>"lasso"</code>, <code>"ridge"</code>, and <code>"elasticnet"</code>,
and where some components of the list are functions to estimate
the conditional expectations.
These functions have the input arguments
<code>(yy_fit, ww_fit, ww_predict, params = NULL)</code> and output the
conditional expectation of <code class="reqn">E[Y|W]</code> estimated with <code>yy_fit</code>
and <code>ww_fit</code> and predicted with <code>ww_predict</code>.
The argument <code>params</code> is described below. The functions
return a matrix where the columns correspond to the component-wise
estimated conditional expectations.
Here, <code>yy</code> symbolically stands for either
<code>x</code> or <code>y</code>.
Please see below for the default arguments
of the <code>"spline"</code>, <code>"forest"</code>, <code>"ols"</code>, <code>"lasso"</code>,
<code>"ridge"</code>, and <code>"elasticnet"</code> methods.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_params">params</code></td>
<td>
<p>An optional list of length 2. The 2 elements of this list
are lists themselves. These lists specify additional input arguments for
estimating the conditional expectations <code class="reqn">E[X|W]</code>
and <code class="reqn">E[Y|W]</code>, respectively.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_parallel">parallel</code></td>
<td>
<p>One out of <code>"no"</code>, <code>"multicore"</code>, or <code>"snow"</code>
specifying the parallelization method used to compute the <code>S</code>
replications. The default is <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer specifying the number of cores used if
<code>parallel</code> is not set to <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster if <code>parallel = "snow"</code>.
The argument <code>ncpus</code> does not have to be specified if the
argument <code>cl</code>
is specified.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_nr_random_eff">nr_random_eff</code></td>
<td>
<p>An integer specifying the number of unaggregated sets
of random effect estimates among the <code>S</code> repetitions that should be
returned.</p>
</td></tr>
<tr><td><code id="mmdml_+3A_nr_res">nr_res</code></td>
<td>
<p>An integer specifying the number of unaggregated sets
of residual estimates among the <code>S</code> repetitions that should be
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimator of <code class="reqn">\beta_0</code> is computed using sample splitting and
cross-fitting.
The subject-specific data (over <code class="reqn">i = 1, \ldots, N</code>) is split
into <code>K</code> sets that are equally large
if possible. For each such set, the nuisance parameters
(that is, the conditional expectations <code class="reqn">E[Y_i|W_i]</code> and
<code class="reqn">E[X_i|W_i]</code>) are estimated on its complement and evaluated on the
set itself.
Estimators of <code class="reqn">\beta_0</code> and the variance parameters are computed
for each
of the <code>K</code> data sets and are then averaged.
If <code>K = 1</code>, no sample splitting
is performed. In this case, the nuisance parameters are estimated and
predicted on the full sample.
</p>
<p>The whole estimation procedure is repeated <code>S</code> times to
account for the randomness introduced by the random sample splits.
The <code>S</code> repetitions can be run in parallel by specifying the
arguments <code>parallel</code> and <code>ncpus</code>.
The <code>S</code> estimators of <code class="reqn">\beta_0</code> and the variance components
are aggregated by taking the
median of them. The <code>S</code> variance-covariance matrices of the estimator
of <code class="reqn">\beta_0</code> are aggregated
by first adding a correction term to them that accounts for the random
splitting and by afterwards taking the median of the corrected
variance-covariance matrices. If <code class="reqn">d &gt; 1</code>, it can happen that this
final matrix is not positive definite anymore, in which case the mean
is considered instead.
Estimates of the conditional random effects and the residuals are computed
in each of the <code>S</code> repetitions. A total number of <code>nr_random_eff</code>
and <code>nr_res</code> of them, respectively, is returned.
Additionally, the random effects estimates from all <code>S</code> repetitions
are aggregated using the mean and returned.
</p>
<p>If the design in at least <code>0.5 * S</code> of the <code>S</code> repetitions is
singular, an error message is displayed.
If the designs in some but less than <code>0.5 * S</code> of the <code>S</code>
repetitions are singular, another <code>S</code> repetitions are performed.
If, in total, at least <code>S</code> repetitions result in a nonsingular design,
the results are returned together with a warning message.
</p>
<p>The default options of the <code>"spline"</code>, <code>"forest"</code>,
<code>"ols"</code>, <code>"lasso"</code>, <code>"ridge"</code>, and <code>"elasticnet"</code>
methods are as follows. With the <code>"spline"</code> method,
the function <code>bs</code> from the package <code>splines</code> is employed
with <code>degree = 3</code> and <code>df = ceiling(N ^ (1 / 5)) + 2</code> if
<code>N</code> satisfies <code>(df + 1) * v + 1 &gt; N</code>, where <code>v</code> denotes
the number of columns of <code>w</code> and <code>N</code> denotes the sample size.
Otherwise, <code>df</code> is consecutively
reduced by <code>1</code> until this condition is satisfied.
The splines are fitted and predicted on different data sets.
If they are extrapolated, a warning message is displayed.
With the <code>"forest"</code> method, the function <code>randomForest</code> from
the package <code>randomForest</code> is employed with <code>nodesize = 5</code>,
<code>ntree = 500</code>, <code>na.action = na.omit</code>, and <code>replace = TRUE</code>.
With the <code>"ols"</code> method, the default arguments are used and no
additional arguments are specified.
With the <code>"lasso"</code> and <code>"ridge"</code> methods,
the function <code>cv.glmnet</code> from the package <code>glmnet</code> performs
10-fold cross validation by default (argument <code>nfolds</code>)
to find the one-standard-error-rule <code class="reqn">\lambda</code>-parameter.
With the <code>"elasticnet"</code> method, the function <code>cv.glmnet</code> from
the package <code>glmnet</code> performs 10-fold cross validation
(argument <code>nfolds</code>) with <code>alpha = 0.5</code> by default
to find the one-standard-error-rule <code class="reqn">\lambda</code>-parameter.
All default values of the mentioned parameters can be adapted by
specifying the argument <code>params</code>.
</p>
<p>There are three possibilities to set the argument <code>parallel</code>, namely
<code>"no"</code> for serial evaluation (default),
<code>"multicore"</code> for parallel evaluation using forking,
and <code>"snow"</code> for parallel evaluation using a parallel
socket cluster. It is recommended to select <code><a href="base.html#topic+RNGkind">RNGkind</a></code>
(<code>"L'Ecuyer-CMRG"</code>) and to set a seed to ensure that the parallel
computing of the package <code>dmlalg</code> is reproducible.
This ensures that each processor receives a different substream of the
pseudo random number generator stream.
Thus, the results reproducible if the arguments remain unchanged.
There is an optional argument <code>cl</code> to specify a custom cluster
if <code>parallel = "snow"</code>.
</p>
<p>The response <code>y</code> needs to be continuous.
The covariate <code>w</code> may contain factor variables in its columns.
If the variable <code>x</code> contains factor variables,
the factors should not be included as factor columns of <code>x</code>.
Instead, dummy encoding should be used for all individual levels of the
factor.
That is, a factor with 4 levels should be encoded with 4 columns where each
column consists of 1 and 0 entries indicating the presence of the
respective level of the factor.
</p>
<p>There are <code>confint</code>, <code>fixef</code>, <code>print</code>, <code>ranef</code>,
<code>residuals</code>, <code>sigma</code>, <code>summary</code>, <code>vcov</code>,
and <code>VarCorr</code> methods available
for objects fitted with <code>mmdml</code>. They are called
<code><a href="#topic+confint.mmdml">confint.mmdml</a></code>,
<code><a href="#topic+fixef.mmdml">fixef.mmdml</a></code>,
<code><a href="#topic+print.mmdml">print.mmdml</a></code>,
<code><a href="#topic+ranef.mmdml">ranef.mmdml</a></code>,
<code><a href="#topic+residuals.mmdml">residuals.mmdml</a></code>,
<code><a href="#topic+sigma.mmdml">sigma.mmdml</a></code>,
<code><a href="#topic+summary.mmdml">summary.mmdml</a></code>,
<code><a href="#topic+vcov.mmdml">vcov.mmdml</a></code>, and
<code><a href="#topic+VarCorr.mmdml">VarCorr.mmdml</a></code>, respectively.
</p>


<h3>Value</h3>

<p>A list similar to the output of <code><a href="lme4.html#topic+lmer">lmer</a></code>
from package <a href="https://CRAN.R-project.org/package=lme4"><span class="pkg">lme4</span></a> containing
the following entries.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>Estimator of the linear coefficient <code class="reqn">\beta_0</code>.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Variance-covariance matrix of <code>beta</code>.
Also see <code><a href="lme4.html#topic+lmer">lmer</a></code>. The <code>S</code> individual variance-covariance
matrices are aggregated by first adding a correction term to them
correcting for the randomness of the sample splits and by subsequently
taking the median of the corrected variance-covariance matrices.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Please see <code><a href="lme4.html#topic+lmer">lmer</a></code> for its meaning.
It is computed by averaging over the <code>K</code> sample splits and by
aggregating the <code>S</code> repetitions using the median.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Please see <code><a href="lme4.html#topic+lmer">lmer</a></code> for its meaning.
It is computed by averaging over the <code>K</code> sample splits and by
aggregating the <code>S</code> repetitions using the median.</p>
</td></tr>
<tr><td><code>varcor</code></td>
<td>
<p>Variance correlation components computed with
<code>theta</code>. Please also see <code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code>random_eff</code></td>
<td>
<p>Conditional estimates of the random effects
similarly to <code><a href="lme4.html#topic+lmer">lmer</a></code>.
The individual sets of <code>S</code> random effects estimates are aggregated
using the mean.</p>
</td></tr>
<tr><td><code>random_eff_all</code></td>
<td>
<p>The first <code>nr_random_eff</code> sets of the
<code>S</code> sets of random effects estimates.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The first <code>nr_res</code> sets of the
<code>S</code> sets of residuals.
Each set of residuals is computed with parameters and data that is
aggregated over the <code>K</code> sample splits.</p>
</td></tr>
</table>
<p>The other elements <code>ngrps</code>, <code>nobs</code>, <code>fitMsgs</code>, <code>cnms</code>,
<code>nc</code>, <code>nms</code>, <code>useSc</code>, <code>optinfo</code>, and <code>methTitle</code>
are as in <code><a href="lme4.html#topic+lmer">lmer</a></code>.
The gradient and Hessian information of <code>optinfo</code> is computed
by aggregating the respective information over the <code>S</code> repetitions
with the median.
</p>


<h3>References</h3>

<p>C. Emmenegger and P. Bühlmann.
Double Machine Learning for Partially Linear Mixed-Effects Models with Repeated Measurements. Preprint arXiv:2108.13657.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">confint</a></code>,
<code><a href="#topic+fixef">fixef</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+ranef">ranef</a></code>,
<code><a href="stats.html#topic+residuals">residuals</a></code>,
<code><a href="stats.html#topic+sigma">sigma</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+vcov">vcov</a></code>,
<code><a href="#topic+VarCorr">VarCorr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
RNGkind("L'Ecuyer-CMRG")
set.seed(19)
data1 &lt;- example_data_mmdml(beta0 = 0.2)
data2 &lt;- example_data_mmdml(beta0 = c(0.2, 0.2))

## fit models
## Caveat: Warning messages are displayed because the small number of
## observations results in a singular random effects model
fit1 &lt;-
  mmdml(w = c("w1", "w2", "w3"), x = "x1", y = "resp", z = c("id", "cask"),
        data = data1, z_formula = "(1|id) + (1|cask:id)", group = "id", S = 3)

fit2 &lt;-
  mmdml(w = c("w1", "w2", "w3"), x = c("x1", "x2"), y = "resp", z = c("id", "cask"),
        data = data2, z_formula = "(1|id) + (1|cask:id)", group = "id", S = 3)

## apply methods
confint(fit2)
fixef(fit2)
print(fit2)
ranef(fit2)
residuals(fit2)
sigma(fit2)
summary(fit2)
vcov(fit2)
VarCorr(fit2)
</code></pre>

<hr>
<h2 id='print.mmdml'>Printing mmdml fits</h2><span id='topic+print.mmdml'></span>

<h3>Description</h3>

<p>This is a method for the class <code>mmdml</code>.
It prints
objects of class <code>mmdml</code> that typically result from a function
call to <code><a href="#topic+mmdml">mmdml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmdml'
print(x, digits = max(3, getOption("digits") - 3),
    ranef.comp = "Std.Dev.", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mmdml_+3A_x">x</code></td>
<td>
<p>An object of class <code>mmdml</code>. This object usually results
from a function call to <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</td></tr>
<tr><td><code id="print.mmdml_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits for printing;
also see <code><a href="lme4.html#topic+lmer">lmer</a></code> from package <a href="https://CRAN.R-project.org/package=lme4"><span class="pkg">lme4</span></a>.</p>
</td></tr>
<tr><td><code id="print.mmdml_+3A_ranef.comp">ranef.comp</code></td>
<td>
<p>A character vector of length one or two
indicating if random-effects parameters should be reported
on the variance and/or standard deviation scale; also see
<code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="print.mmdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="lme4.html#topic+lmer">lmer</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmdml">mmdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(mmdml) for examples
</code></pre>

<hr>
<h2 id='print.regsdml'>Printing regsdml fits</h2><span id='topic+print.regsdml'></span>

<h3>Description</h3>

<p>This is a method for the class <code>regsdml</code>.
It prints
objects of class <code>regsdml</code>, which typically result from a function
call to <code><a href="#topic+regsdml">regsdml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regsdml'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.regsdml_+3A_x">x</code></td>
<td>
<p>An object of class <code>regsdml</code>. This object usually results
from a function call to <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</td></tr>
<tr><td><code id="print.regsdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, <code>summary(x)</code> is called. Please see
<code><a href="#topic+summary.regsdml">summary.regsdml</a></code> for further details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regsdml">regsdml</a></code>,
<code><a href="#topic+summary.regsdml">summary.regsdml</a></code>,
<code><a href="#topic+confint.regsdml">confint.regsdml</a></code>,
<code><a href="#topic+coef.regsdml">coef.regsdml</a></code>,
<code><a href="#topic+vcov.regsdml">vcov.regsdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data:
set.seed(19)
# true linear parameter
beta0 &lt;- 1
n &lt;- 40
# observed confounder
w &lt;- pi * runif(n, -1, 1)
# instrument
a &lt;- 3 * tanh(2 * w) + rnorm(n, 0, 1)
# unobserved confounder
h &lt;- 2 * sin(w) + rnorm(n, 0, 1)
# linear covariate
x &lt;- -1 * abs(a) - h - 2 * tanh(w) + rnorm(n, 0, 1)
# response
y &lt;- beta0 * x - 3 * cos(pi * 0.25 * h) + 0.5 * w ^ 2 + rnorm(n, 0, 1)

## Estimate the linear coefficient from x to y
## (The parameters are chosen small enough to make estimation fast):
## Caveat: A spline estimator is extrapolated, which raises a warning message.
## Extrapolation lies in the nature of our method. To omit the warning message
## resulting from the spline estimator, another estimator may be used.
fit &lt;- regsdml(a, w, x, y,
               gamma = exp(seq(-4, 1, length.out = 4)),
               S = 3,
               do_regDML_all_gamma = TRUE,
               cond_method = c("forest",  # for E[A|W]
                               "spline",  # for E[X|W]
                               "spline"), # for E[Y|W]
               params = list(list(ntree = 1), NULL, NULL))
print(fit)
</code></pre>

<hr>
<h2 id='regsdml'>Estimating linear coefficients with double machine learning (DML)</h2><span id='topic+regsdml'></span><span id='topic+regdml'></span>

<h3>Description</h3>

<p>Our goal is to perform inference for the linear parameter in partially
linear models with confounding variables.
The standard double machine learning (DML) estimator of the linear
parameter has a two-stage least
squares interpretation, which can lead to a large variance and overwide
confidence intervals.
We apply regularization to reduce the variance of the estimator,
which produces narrower confidence intervals that remain approximately valid.
</p>
<p>The function <code>regsdml</code> estimates the linear parameter <code class="reqn">\beta_0</code>
in the partially linear model
</p>
<p style="text-align: center;"><code class="reqn">Y = X^T\beta_0 + g(W) + h(H) + \epsilon_Y</code>
</p>

<p>of the continuous response <code class="reqn">Y</code>
with linear covariates
<code class="reqn">X</code>, nonlinear covariates <code class="reqn">W</code>,  unobserved confounding
variables <code class="reqn">H</code>, and the error term <code class="reqn">\epsilon_Y</code>. An additional
variable <code class="reqn">A</code> is required that is not part of the right-hand side
defining <code class="reqn">Y</code>. The variable <code class="reqn">A</code> acts as an instrument after
<code class="reqn">W</code> is regressed out of it.
</p>
<p>The linear parameter <code class="reqn">\beta_0</code> can be estimated with
a two-stage least squares (TSLS) approach (&quot;standard&quot; DML) or with
regularized approaches (regDML, regsDML).
All approaches use double
machine learning.
The TSLS approach regresses the residual <code class="reqn">Y - E[Y|W]</code> on
<code class="reqn">X - E[X|W]</code> using the instrument <code class="reqn">A - E[A|W]</code>.
The regularized approaches
minimize an objective function that equals <code class="reqn">\gamma</code> times
the objective function
of TSLS plus an objective function that partials out <code class="reqn">A - E[A|W]</code>
from the residual quantity <code class="reqn">Y - E[Y|W] - (X - E[X|W])^T\beta</code>.
The different regularization approaches choose different regularization
parameters <code class="reqn">\gamma</code>.
The conditional expectations act as nuisance parameters and are estimated
with machine learning algorithms.
All approaches use sample splitting and cross-fitting to
estimate <code class="reqn">\beta_0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regsdml(
  a, w, x, y, data = NULL,
  DML = c("DML2", "DML1"),
  K = 2L,
  gamma = exp(seq(-4, 10, length.out = 100)),
  aN = NULL,
  do_regsDML = TRUE,
  do_safety = FALSE,
  do_DML = do_regDML || do_regsDML || do_safety,
  do_regDML = FALSE,
  do_regDML_all_gamma = FALSE,
  safety_factor = 0.7,
  cond_method = rep("spline", 3),
  params = NULL,
  level = 0.95,
  S = 100L,
  parallel = c("no", "multicore", "snow"),
  ncpus = 1L,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regsdml_+3A_a">a</code></td>
<td>
<p>A vector, matrix, or data frame. It acts as an instrument after
regressing out <code>w</code> of it.
Alternatively, if the data is
provided in the data frame <code>data</code>, <code>a</code> is a character vector
whose entries specify the columns of <code>data</code> acting as
&quot;instrument&quot; <code class="reqn">A</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_w">w</code></td>
<td>
<p>A vector, matrix, or data frame. Its columns contain observations
of the nonlinear predictors. Alternatively, if the data is
provided in the data frame <code>data</code>, <code>w</code> is a character vector
whose entries specify the columns of <code>data</code> acting as <code class="reqn">W</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_x">x</code></td>
<td>
<p>A vector, matrix, or data frame. This is the linear predictor.
Alternatively, if the data is provided in the data frame
<code>data</code>, <code>x</code> is a character vector whose entries specify
the columns of <code>data</code> acting as <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_y">y</code></td>
<td>
<p>A vector, matrix, or data frame. This is the response.
Alternatively, if the data is provided in the data frame
<code>data</code>, <code>y</code> is a character vector whose entries specify
the columns of <code>data</code> acting as <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_data">data</code></td>
<td>
<p>An optional data frame. If it is specified, its column names
need to coincide with the character vectors specified in <code>a</code>,
<code>w</code>, <code>x</code>, and <code>y</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_dml">DML</code></td>
<td>
<p>Either <code>"DML2"</code> or <code>"DML1"</code> depending on which DML
method should be used. The default is <code>"DML2"</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_k">K</code></td>
<td>
<p>The number of sample splits used for cross-fitting.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_gamma">gamma</code></td>
<td>
<p>A vector specifying the grid of regularization parameters
over which to optimize.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_an">aN</code></td>
<td>
<p>The <code class="reqn">N</code>th element of a sequence of non-negative
real numbers diverging to <code class="reqn">+ \infty</code> as the sample size
<code class="reqn">N</code> tends to <code class="reqn">+ \infty</code>. By default, it equals
<code>max(log(sqrt(N)), 1)</code>, where <code>N</code> denotes the sample size.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_do_regsdml">do_regsDML</code></td>
<td>
<p>A boolean that specifies whether the regsDML estimator
is computed. It is set to <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_do_safety">do_safety</code></td>
<td>
<p>A boolean that specifies whether a safety device is employed.
The safety device chooses the regularization parameter <code class="reqn">\gamma</code>
such that the variance of the regularized estimator
is at least (100 * <code>safety_factor</code>)% of the variance of standard DML.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_do_dml">do_DML</code></td>
<td>
<p>A boolean that specifies whether the standard DML estimator is
computed. It is set to <code>TRUE</code> by default if at least one of
<code>do_regsDML</code>, <code>do_safety</code>, or <code>do_regDML</code> is set to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_do_regdml">do_regDML</code></td>
<td>
<p>A boolean that specifies whether the regularized DML
estimator regDML with the regularization parameter equal to <code>a_N</code>
times the <code class="reqn">\gamma</code> leading to the lowest mean
squared error is computed. It is set to <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_do_regdml_all_gamma">do_regDML_all_gamma</code></td>
<td>
<p>A boolean that specifies whether the regularized
estimators for all values <code class="reqn">\gamma</code> of the grid <code>gamma</code> are
returned. It is set to <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_safety_factor">safety_factor</code></td>
<td>
<p>The factor of the safety method. It is set to <code>0.7</code>
by default.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_cond_method">cond_method</code></td>
<td>
<p>A character vector of length 3 specifying the estimation
methods used to fit the conditional
expectations <code class="reqn">E[A|W]</code>, <code class="reqn">E[X|W]</code>, and <code class="reqn">E[Y|W]</code>.
Its components are from
from <code>"spline"</code>, <code>"forest"</code>,
<code>"ols"</code>, <code>"lasso"</code>, <code>"ridge"</code>, and <code>"elasticnet"</code>,
or it is a list of length 3 with components from <code>"spline"</code>,
<code>"forest"</code>,
<code>"ols"</code>, <code>"lasso"</code>, <code>"ridge"</code>, and <code>"elasticnet"</code>,
and where some components of the list are functions to estimate
the conditional expectations.
These functions have the input arguments
<code>(yy_fit, ww_fit, ww_predict, params = NULL)</code> and output the
conditional expectation of <code class="reqn">E[Y|W]</code> estimated with <code>yy_fit</code>
and <code>ww_fit</code> and predicted with <code>ww_predict</code>.
The argument <code>params</code> is described below. The functions
return a matrix where the columns correspond to the component-wise
estimated conditional expectations.
Here, <code>yy</code> symbolically stands for either <code>a</code>,
<code>x</code>, or <code>y</code>.
Please see below for the default arguments
of the <code>"spline"</code>, <code>"forest"</code>, <code>"ols"</code>, <code>"lasso"</code>,
<code>"ridge"</code>, and <code>"elasticnet"</code> methods.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_params">params</code></td>
<td>
<p>An optional list of length 3. All 3 elements of this list
are lists themselves. These lists specify additional input arguments for
estimating the conditional expectations <code class="reqn">E[A|W]</code>, <code class="reqn">E[X|W]</code>,
and <code class="reqn">E[Y|W]</code>, respectively.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_level">level</code></td>
<td>
<p>Level for computing
confidence intervals for testing the two-sided component-wise
null hypotheses that test if a component equals zero
with the (approximate) asymptotic Gaussian distribution. The default is
<code>0.95</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_s">S</code></td>
<td>
<p>Number of replications to correct for the random
splitting of the sample. It is set to <code>100L</code> by default.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_parallel">parallel</code></td>
<td>
<p>One out of <code>"no"</code>, <code>"multicore"</code>, or <code>"snow"</code>
specifying the parallelization method used to compute the <code>S</code>
replications. The default is <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer specifying the number of cores used if
<code>parallel</code> is not set to <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="regsdml_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster if <code>parallel = "snow"</code>.
The argument <code>ncpus</code> does not have to be specified if the
argument <code>cl</code>
is specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimator of <code class="reqn">\beta_0</code> is computed using sample splitting and
cross-fitting.
Irrespective of which methods are performed,
the data is split into <code>K</code> sets that are equally large
if possible. For each such set, the nuisance parameters
(that is, the conditional expectations <code class="reqn">E[A|W]</code>, <code class="reqn">E[X|W]</code>,
and <code class="reqn">E[Y|W]</code>) are estimated on its complement and evaluated on the
set itself. If <code>DML = "DML1"</code>, then <code>K</code> individual
estimators are computed for each
of the <code>K</code> data sets and are then averaged. If <code>DML = "DML2"</code>,
the nuisance parameter matrices are first assembled before the estimator
of <code class="reqn">\beta_0</code> is computed. This enhances stability of the coefficient
estimator compared to <code>"DML1"</code>. If <code>K = 1</code>, no sample splitting
is performed. In this case, the nuisance parameters are estimated and
predicted on the full sample.
</p>
<p>The whole estimation procedure can be repeated <code>S</code> times to
account for the randomness introduced by the random sample splits.
The <code>S</code> repetitions can be run in parallel by specifying the
arguments <code>parallel</code> and <code>ncpus</code>.
The <code>S</code> estimators of <code class="reqn">\beta_0</code> are aggregated by taking the
median of them. The <code>S</code> variance-covariance matrices are aggregated
by first adding a correction term to them that accounts for the random
splitting and by afterwards taking the median of the corrected
variance-covariance matrices. If <code class="reqn">d &gt; 1</code>, it can happen that this
final matrix is not positive definite anymore, in which case the mean
is considered instead.
</p>
<p>If the design in at least <code>0.5 * S</code> of the <code>S</code> repetitions is
singular, an error message is displayed.
If the designs in some but less than <code>0.5 * S</code> of the <code>S</code>
repetitions are singular, another <code>S</code> repetitions are performed.
If, in total, at least <code>S</code> repetitions result in a nonsingular design,
the results are returned together with a warning message.
</p>
<p>The regularized estimators and their associated mean squared errors
(MSEs) are computed for the regularization parameters <code class="reqn">\gamma</code> of
the grid <code>gamma</code>. These estimators are returned if the argument
<code>do_regDML_all_gamma</code> is set to <code>TRUE</code>.
The <code class="reqn">\gamma</code>-value whose corresponding regularized estimator
from the <code>do_regDML_all_gamma</code> method achieves
the smallest MSE
is multiplied by <code>aN</code>, leading to <code class="reqn">\gamma'</code>.
The <code>do_regDML_all_gamma</code> estimator with regularization parameter
<code class="reqn">\gamma'</code> is called regDML.
The regsDML estimator equals regDML or DML depending on whose variance
is smaller.
If <code class="reqn">\beta_0</code> is of larger dimension than 1, the MSE computations and
the variance comparison step are performed with the sum of the diagonal
entries of the respective variance-covariance matrices.
</p>
<p>If <code>do_safety = TRUE</code>, a <code class="reqn">\gamma</code> value is chosen such that the
regularized estimator among <code>do_regDML_all_gamma</code>
with this value of <code class="reqn">\gamma</code> has a variance
that is just not smaller than <code>safety_factor</code> times the variance of
DML.
If <code class="reqn">\beta_0</code> is of larger dimension than 1, the sum of the diagonal
entries of the respective variance-covariance matrices is taken as
a measure of variance.
If the regularization scheme leads to considerable variance
reductions, it is possible that this safety device cannot be applied.
In this case, a respective message is returned.
</p>
<p>The default options of the <code>"spline"</code>, <code>"forest"</code>,
<code>"ols"</code>, <code>"lasso"</code>, <code>"ridge"</code>, and <code>"elasticnet"</code>
methods are as follows. With the <code>"spline"</code> method,
the function <code>bs</code> from the package <code>splines</code> is employed
with <code>degree = 3</code> and <code>df = ceiling(N ^ (1 / 5)) + 2</code> if
<code>N</code> satisfies <code>(df + 1) * v + 1 &gt; N</code>, where <code>v</code> denotes
the number of columns of <code>w</code> and <code>N</code> denotes the sample size.
Otherwise, <code>df</code> is consecutively
reduced by <code>1</code> until this condition is satisfied.
The splines are fitted and predicted on different data sets.
If they are extrapolated, a warning message is displayed.
With the <code>"forest"</code> method, the function <code>randomForest</code> from
the package <code>randomForest</code> is employed with <code>nodesize = 5</code>,
<code>ntree = 500</code>, <code>na.action = na.omit</code>, and <code>replace = TRUE</code>.
With the <code>"ols"</code> method, the default arguments are used and no
additional arguments are specified.
With the <code>"lasso"</code> and <code>"ridge"</code> methods,
the function <code>cv.glmnet</code> from the package <code>glmnet</code> performs
10-fold cross validation by default (argument <code>nfolds</code>)
to find the one-standard-error-rule <code class="reqn">\lambda</code>-parameter.
With the <code>"elasticnet"</code> method, the function <code>cv.glmnet</code> from
the package <code>glmnet</code> performs 10-fold cross validation
(argument <code>nfolds</code>) with <code>alpha = 0.5</code> by default
to find the one-standard-error-rule <code class="reqn">\lambda</code>-parameter.
All default values of the mentioned parameters can be adapted by
specifying the argument <code>params</code>.
</p>
<p>There are three possibilities to set the argument <code>parallel</code>, namely
<code>"no"</code> for serial evaluation (default),
<code>"multicore"</code> for parallel evaluation using forking,
and <code>"snow"</code> for parallel evaluation using a parallel
socket cluster. It is recommended to select <a href="base.html#topic+RNGkind">RNGkind</a>
(<code>"L'Ecuyer-CMRG"</code>) and to set a seed to ensure that the parallel
computing of the package <code>dmlalg</code> is reproducible.
This ensures that each processor receives a different substream of the
pseudo random number generator stream.
Thus, the results reproducible if the arguments remain unchanged.
There is an optional argument <code>cl</code> to specify a custom cluster
if <code>parallel = "snow"</code>.
</p>
<p>The response <code>y</code> needs to be continuous.
The covariate <code>w</code> may contain factor variables in its columns.
If the variables <code>a</code> and <code>x</code> contain factor variables,
the factors should not be included as factor columns of <code>a</code> or
<code>x</code>.
Instead, dummy encoding should be used for all individual levels of the
factor.
That is, a factor with 4 levels should be encoded with 4 columns where each
column consists of 1 and 0 entries indicating the presence of the
respective level of the factor.
</p>
<p>There are <code>summary</code>, <code>confint</code>, <code>coef</code>, <code>vcov</code>,
and <code>print</code> methods available
for objects fitted with <code>regsdml</code>. They are called
<code><a href="#topic+summary.regsdml">summary.regsdml</a></code>,
<code><a href="#topic+confint.regsdml">confint.regsdml</a></code>,
<code><a href="#topic+coef.regsdml">coef.regsdml</a></code>,
<code><a href="#topic+vcov.regsdml">vcov.regsdml</a></code>, and
<code><a href="#topic+print.regsdml">print.regsdml</a></code>, respectively.
</p>


<h3>Value</h3>

<p>A list containing some of the lists
<code>regsDML_statistics</code>,
<code>regDML_safety_statistics</code>,
<code>DML_statistics</code>, <code>regDML_statistics</code>, and
<code>regDML_all_gamma_statistics</code> is returned.
The individual sublists contain the following arguments supplemented
by an additional suffix specifying the method they correspond to.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>Estimator of the linear coefficient <code class="reqn">\beta_0</code>.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Standard error estimates of the respective entries
of <code>beta</code>.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Variance-covariance matrix of <code>beta</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-values for the respective entries of <code>beta</code>.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>Two-sided confidence intervals
for <code class="reqn">\beta_0</code> where the <code class="reqn">j</code>th row of <code>CI</code>
corresponds to the two-sided testing of <code class="reqn">H_0: (\beta_0)_j=0</code>
at level <code>level</code>. They are computed with the (approximate) asymptotic
Gaussian distribution of the coefficient estimates.</p>
</td></tr>
</table>
<p>The list <code>regsDML_statistics</code> contains the following additional entries:
</p>
<table role = "presentation">
<tr><td><code>message_regsDML</code></td>
<td>
<p>Specifies if regsDML selects
the regularized estimator or DML.</p>
</td></tr>
<tr><td><code>gamma_aN</code></td>
<td>
<p>Chosen optimal regularization parameter if
regsDML equals the regularized estimator.
This entry is not present if DML is selected.</p>
</td></tr>
</table>
<p>If the safety device is applicable, the list <code>regDML_safety_statistics</code>
contains the following additional entries:
</p>
<table role = "presentation">
<tr><td><code>message_safety</code></td>
<td>
<p>Specifies whether the safety device was
applicable.</p>
</td></tr>
<tr><td><code>gamma_safety</code></td>
<td>
<p>Chosen regularization parameter of the
safety device.</p>
</td></tr>
</table>
<p>If the safety device is not applicable, the list
<code>regDML_safety_statistics</code> contains <code>message_safety</code>
as its only entry.
</p>
<p>The list <code>regDML_statistics</code> contains the
following additional entry:
</p>
<table role = "presentation">
<tr><td><code>gamma_opt</code></td>
<td>
<p>Chosen optimal regularization parameter.</p>
</td></tr>
</table>
<p>The list <code>regDML_all_gamma_statistics</code> is a list of the same
length as the grid <code>gamma</code>, where each individual list is of the
structure just described.
</p>


<h3>References</h3>

<p>C. Emmenegger and P. Bühlmann.
Regularizing Double Machine Learning in Partially Linear Endogenous
Models, 2021. Preprint arXiv:2101.12525.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.regsdml">summary.regsdml</a></code>,
<code><a href="#topic+confint.regsdml">confint.regsdml</a></code>,
<code><a href="#topic+coef.regsdml">coef.regsdml</a></code>,
<code><a href="#topic+vcov.regsdml">vcov.regsdml</a></code>
<code><a href="#topic+print.regsdml">print.regsdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data:
RNGkind("L'Ecuyer-CMRG")
set.seed(19)
# true linear parameter
beta0 &lt;- 1
n &lt;- 40
# observed confounder
w &lt;- pi * runif(n, -1, 1)
# instrument
a &lt;- 3 * tanh(2 * w) + rnorm(n, 0, 1)
# unobserved confounder
h &lt;- 2 * sin(w) + rnorm(n, 0, 1)
# linear covariate
x &lt;- -1 * abs(a) - h - 2 * tanh(w) + rnorm(n, 0, 1)
# response
y &lt;- beta0 * x - 3 * cos(pi * 0.25 * h) + 0.5 * w ^ 2 + rnorm(n, 0, 1)

## Estimate the linear coefficient from x to y
## (The parameters are chosen small enough to make estimation fast):
## Caveat: A spline estimator is extrapolated, which raises a warning message.
## Extrapolation lies in the nature of our method. To omit the warning message
## resulting from the spline estimator, another estimator may be used.
fit &lt;- regsdml(a, w, x, y,
               gamma = exp(seq(-4, 1, length.out = 4)),
               S = 3,
               do_regDML_all_gamma = TRUE,
               cond_method = c("forest",  # for E[A|W]
                               "spline",  # for E[X|W]
                               "spline"), # for E[Y|W]
               params = list(list(ntree = 1), NULL, NULL))
## parm = c(2, 3) prints an additional summary for the 2nd and 3rd gamma-values
summary(fit, parm = c(2, 3),
        correlation = TRUE,
        print_gamma = TRUE)
confint(fit, parm = c(2, 3),
        print_gamma = TRUE)
coef(fit) # coefficients
vcov(fit) # variance-covariance matrices

## Alternatively, provide the data in a single data frame
## (see also caveat above):
data &lt;- data.frame(a = a, w = w, x = x, y = y)
fit &lt;- regsdml(a = "a", w = "w", x = "x", y = "y", data = data,
               gamma = exp(seq(-4, 1, length.out = 4)),
               S = 3)

## With more realistic parameter choices:
if (FALSE) {
  fit &lt;- regsdml(a, w, x, y,
                 cond_method = c("forest",  # for E[A|W]
                                 "spline",  # for E[X|W]
                                 "spline")) # for E[Y|W]
  summary(fit)
  confint(fit)

  ## Alternatively, provide the data in a single data frame:
  ## (see also caveat above):
  data &lt;- data.frame(a = a, w = w, x = x, y = y)
  fit &lt;- regsdml(a = "a", w = "w", x = "x", y = "y", data = data)
}
</code></pre>

<hr>
<h2 id='residuals.mmdml'>Confidence Intervals for coefficient estimates of regsDML fits</h2><span id='topic+residuals.mmdml'></span><span id='topic+resid.mmdml'></span>

<h3>Description</h3>

<p>A list whose elements correspond to the potentially scaled first
<code>nr_res</code> sets of
residuals of the <code>S</code> residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmdml'
residuals(object, scaled = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.mmdml_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmdml</code>. This object usually results
from a function call to <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.mmdml_+3A_scaled">scaled</code></td>
<td>
<p>A boolean specifying whether scaled residuals should be returned.
It is set to FALSE by default.</p>
</td></tr>
<tr><td><code id="residuals.mmdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose elements correspond to the first <code>nr_res</code> sets of
residuals of the <code>S</code> residuals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmdml">mmdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(mmdml) for examples
</code></pre>

<hr>
<h2 id='sigma.mmdml'>Extract Residual Standard Deviation 'Sigma' from mmdml Fits</h2><span id='topic+sigma.mmdml'></span>

<h3>Description</h3>

<p>Extract the estimated standard deviation of the errors,
the “residual standard deviation”,
from a fitted <code>mmdml</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmdml'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma.mmdml_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmdml</code>. This object usually results
from a function call to <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</td></tr>
<tr><td><code id="sigma.mmdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number representing the estimated standard deviation.
First, for each of the <code>S</code> repetitions, the standard deviations computed
on the <code>K</code> sample splits are aggregated by taking the mean.
Second, the <code>S</code> mean-aggregated estimates are aggregated by
the median. This final value is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmdml">mmdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(mmdml) for examples
</code></pre>

<hr>
<h2 id='summary.mmdml'>Summarizing mmdml fits</h2><span id='topic+summary.mmdml'></span>

<h3>Description</h3>

<p>This is a method for the class <code>mmdml</code>. It summarizes
objects of class <code>mmdml</code> that typically result from a function
call to <code><a href="#topic+mmdml">mmdml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmdml'
summary(object,
    correlation = (p &lt;= getOption("lme4.summary.cor.max")),
    nr_res = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mmdml_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmdml</code>. This object usually
results
from a function call to <code><a href="#topic+mmdml">mmdml</a></code>.</p>
</td></tr>
<tr><td><code id="summary.mmdml_+3A_correlation">correlation</code></td>
<td>
<p>Boolean indicating if the variance and correlation
components (<code>vcov</code>, <code><a href="#topic+VarCorr">VarCorr</a></code>) should be printed.</p>
</td></tr>
<tr><td><code id="summary.mmdml_+3A_nr_res">nr_res</code></td>
<td>
<p>Boolean indicating how many sets of residuals among the <code>S</code>
should be used to compute the residual information.
By default, all available sets, that is, <code>nr_res</code> many that
are saved in <code>object</code> resulting from <code><a href="#topic+mmdml">mmdml</a></code>
are used.</p>
</td></tr>
<tr><td><code id="summary.mmdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary output similar to <code><a href="lme4.html#topic+lmer">lmer</a></code>
from package <a href="https://CRAN.R-project.org/package=lme4"><span class="pkg">lme4</span></a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmdml">mmdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(mmdml) for examples
</code></pre>

<hr>
<h2 id='summary.regsdml'>Summarizing regsdml fits</h2><span id='topic+summary.regsdml'></span>

<h3>Description</h3>

<p>This is a method for the class <code>regsdml</code>. It summarizes
objects of class <code>regsdml</code>, which typically result from a function
call to <code><a href="#topic+regsdml">regsdml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regsdml'
summary(object,
    print_regsDML = NULL,
    print_safety = NULL,
    print_DML = NULL,
    print_regDML = NULL,
    print_regDML_all_gamma = !is.null(parm),
    parm = NULL,
    correlation = FALSE,
    print_gamma = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.regsdml_+3A_object">object</code></td>
<td>
<p>An object of class <code>regsdml</code>. This object usually
results from a function call to <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_print_regsdml">print_regsDML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>regsDML</code> method are returned.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_print_safety">print_safety</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the safety device are returned.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_print_dml">print_DML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>DML</code> method are returned.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_print_regdml">print_regDML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>regDML</code> method with the optimal choice of <code>gamma</code>
(including the factor <code>a_N</code>)
are returned.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_print_regdml_all_gamma">print_regDML_all_gamma</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
specified by <code>parm</code> below are returned.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_parm">parm</code></td>
<td>
<p>A vector containing the indices for which <code>gamma</code>-values
the results of the regularized DML estimator, whose results
are stored in the list <code>regDML_all_gamma_statistics</code> of <code>object</code>,
should be included in the summary output. If <code>parm</code> is specified,
it is not necessary to specify <code>print_regDML_all_gamma</code>.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_correlation">correlation</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the variance-covariance
matrices of the coefficient estimates are displayed.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_print_gamma">print_gamma</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the <code>gamma</code>-values
are printed in brackets where the respective regularization methods
achieved their optimum.</p>
</td></tr>
<tr><td><code id="summary.regsdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary statistics of the methods <code>regsDML</code>, the <code>safety</code> device,
<code>DML</code>, <code>regDML</code> with the optimal
choice of <code class="reqn">\gamma</code> (including the factor <code>a_N</code>),
and <code>regDML</code>
with prespecified <code class="reqn">\gamma</code>-values are returned by setting the
respective arguments. It is possible to return the respective
<code>gamma</code>-values and variance-covariance matrices.
</p>
<p>If none of the printing arguments are set, only the results of regsDML
are returned if they are available. If they are not available and none of
the printing arguments are set, the results from all available methods
are returned. If <code>print_regsDML = FALSE</code>, only the results from
those methods are returned that are explicitly specified by the printing
arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regsdml">regsdml</a></code>,
<code><a href="#topic+confint.regsdml">confint.regsdml</a></code>,
<code><a href="#topic+coef.regsdml">coef.regsdml</a></code>,
<code><a href="#topic+vcov.regsdml">vcov.regsdml</a></code>
<code><a href="#topic+print.regsdml">print.regsdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(regsdml) for examples
</code></pre>

<hr>
<h2 id='vcov.regsdml'>Accessing the variance-covariance matrices of regsdml fits</h2><span id='topic+vcov.regsdml'></span>

<h3>Description</h3>

<p>This is a method for the class <code>regsdml</code>. It returns the
variance-covariance matrices of the coefficients from
objects of class <code>regsdml</code>, which typically result from a function
call to <code><a href="#topic+regsdml">regsdml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regsdml'
vcov(object,
    print_regsDML = NULL,
    print_safety = NULL,
    print_DML = NULL,
    print_regDML = NULL,
    print_regDML_all_gamma = !is.null(parm),
    parm = NULL,
    print_gamma = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.regsdml_+3A_object">object</code></td>
<td>
<p>An object of class <code>regsdml</code>. This object usually
results from a function call to <code><a href="#topic+regsdml">regsdml</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.regsdml_+3A_print_regsdml">print_regsDML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>regsDML</code> method are returned.</p>
</td></tr>
<tr><td><code id="vcov.regsdml_+3A_print_safety">print_safety</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the safety device are returned.</p>
</td></tr>
<tr><td><code id="vcov.regsdml_+3A_print_dml">print_DML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>DML</code> method are returned.</p>
</td></tr>
<tr><td><code id="vcov.regsdml_+3A_print_regdml">print_regDML</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
of the <code>regDML</code> method with the optimal choice of <code>gamma</code>
(including the factor <code>a_N</code>) are returned.</p>
</td></tr>
<tr><td><code id="vcov.regsdml_+3A_print_regdml_all_gamma">print_regDML_all_gamma</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the results
specified by <code>parm</code> below are returned.</p>
</td></tr>
<tr><td><code id="vcov.regsdml_+3A_parm">parm</code></td>
<td>
<p>A vector containing the indices for which <code>gamma</code>-values
the results of the regularized DML estimator, whose results
are stored in the list <code>regDML_all_gamma_statistics</code> of <code>object</code>,
should be included in the output. If <code>parm</code> is specified,
it is not necessary to specify <code>print_regDML_all_gamma</code>.</p>
</td></tr>
<tr><td><code id="vcov.regsdml_+3A_print_gamma">print_gamma</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the <code>gamma</code>-values
are printed in an extra row where the respective regularization methods
achieved their optimum.</p>
</td></tr>
<tr><td><code id="vcov.regsdml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance-covariance matrices of the methods <code>regsDML</code>,
the <code>safety</code> device, <code>DML</code>, <code>regDML</code> with the optimal
choice of <code class="reqn">\gamma</code> (including the factor <code>a_N</code>),
and <code>regDML</code>
with prespecified <code class="reqn">\gamma</code>-values are returned by setting the
respective arguments. It is possible to return the respective
<code>gamma</code>-values.
</p>
<p>If none of the printing arguments are set, only the results of regsDML
are returned if they are available. If they are not available and none of
the printing arguments are set, the results from all available methods
are returned. If <code>print_regsDML = FALSE</code>, only the results from
those methods are returned that are explicitly specified by the printing
arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regsdml">regsdml</a></code>,
<code><a href="#topic+summary.regsdml">summary.regsdml</a></code>,
<code><a href="#topic+confint.regsdml">confint.regsdml</a></code>,
<code><a href="#topic+coef.regsdml">coef.regsdml</a></code>
<code><a href="#topic+print.regsdml">print.regsdml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example(regsdml) for examples
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
