<!DOCTYPE html><html lang="en"><head><title>Help for package SHELF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SHELF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SHELF-package'><p>SHELF: Tools to Support the Sheffield Elicitation Framework</p></a></li>
<li><a href='#cdffeedback'><p>Feedback for the elicited distribution of the population CDF</p></a></li>
<li><a href='#cdfplot'><p>Plot distribution of CDF</p></a></li>
<li><a href='#compareGroupRIO'><p>Compare individual elicited distributions with linear pool and RIO distribution</p></a></li>
<li><a href='#compareIntervals'><p>Plot fitted intervals for each expert</p></a></li>
<li><a href='#copulaSample'><p>Generate correlated samples from elicited marginal distributions using a multivariate normal copula</p></a></li>
<li><a href='#elicit'><p>Elicit judgements and fit distributions interactively</p></a></li>
<li><a href='#elicitBivariate'><p>Elicit a bivariate distribution using a Gaussian copula</p></a></li>
<li><a href='#elicitDirichlet'><p>Elicit a Dirichlet distribution interactively</p></a></li>
<li><a href='#elicitExtension'><p>Elicitation with the extension method</p></a></li>
<li><a href='#elicitHeterogen'><p>Elicit a prior distribution for a random effects variance parameter</p></a></li>
<li><a href='#elicitMixture'><p>Elicit a mixture distribution using the extension method</p></a></li>
<li><a href='#elicitMultiple'><p>Elicit individual judgements and fit distributions for multiple experts</p></a></li>
<li><a href='#elicitSurvivalExtrapolation'><p>Elicitation for survival extrapolation</p></a></li>
<li><a href='#feedback'><p>Report quantiles and probabilities from the fitted probability distributions</p></a></li>
<li><a href='#feedbackDirichlet'><p>Calculate quantiles for the marginal distributions of a Dirichlet distribution</p></a></li>
<li><a href='#fitDirichlet'><p>Fit a Dirichlet distribution to elicited marginal distributions for proportions</p></a></li>
<li><a href='#fitdist'><p>Fit distributions to elicited probabilities</p></a></li>
<li><a href='#fitprecision'><p>Fit a distribution to judgements about a population precision</p></a></li>
<li><a href='#generateReport'><p>Generate a report to show the fitted distributions</p></a></li>
<li><a href='#linearPoolDensity'><p>Obtain points on the density function of a linear pool</p></a></li>
<li><a href='#makeCDFPlot'><p>Plot the elicited cumulative probabilities</p></a></li>
<li><a href='#makeSurvivalTable'><p>Tabulate Summary Data for Survival Extrapolation</p></a></li>
<li><a href='#pdfplots'><p>Plot fitted population pdfs</p></a></li>
<li><a href='#plinearpool'><p>Probabilities quantiles and samples from a (weighted) linear pool</p></a></li>
<li><a href='#plotConditionalDensities'><p>Plot density of the target variable, conditional on the extension variable</p></a></li>
<li><a href='#plotConditionalMedianFunction'><p>Plot the conditional median function</p></a></li>
<li><a href='#plotfit'><p>Plot the fitted density function for one or more experts</p></a></li>
<li><a href='#plotQuartiles'><p>Plot elicited quartiles, median and plausible range for each expert</p></a></li>
<li><a href='#plotTertiles'><p>Plot elicted tertiles, median and plausible range for each expert</p></a></li>
<li><a href='#sampleFit'><p>Sample from the elicited distributions</p></a></li>
<li><a href='#sampleMarginalFit'><p>Sample from the marginal distribution of the target variable</p></a></li>
<li><a href='#survivalExtrapolatePlot'><p>Plot survival data and elicited extrapolated intervals</p></a></li>
<li><a href='#survivalModelExtrapolations'><p>Compare Multiple Fitted Models for Survival Extrapolation</p></a></li>
<li><a href='#survivalScenario'><p>Scenario Testing for Survival Extrapolation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools to Support the Sheffield Elicitation Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>1.12.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various methods for eliciting a probability
    distribution for a single parameter from an expert or a group of
    experts. The expert provides a small number of probability judgements,
    corresponding to points on his or her cumulative distribution
    function. A range of parametric distributions can then be fitted and
    displayed, with feedback provided in the form of fitted probabilities
    and percentiles. For multiple experts, a weighted linear pool can be
    calculated. Also includes functions for eliciting beliefs about
    population distributions; eliciting multivariate distributions using a
    Gaussian copula; eliciting a Dirichlet distribution; eliciting
    distributions for variance parameters in a random effects
    meta-analysis model; survival extrapolation. R Shiny apps for most of the methods are
    included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/OakleyJ/SHELF">https://github.com/OakleyJ/SHELF</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OakleyJ/SHELF/issues">https://github.com/OakleyJ/SHELF/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>flexsurv, ggExtra, ggplot2, ggridges, graphics, grDevices,
grid, Hmisc, rmarkdown, scales, shiny, shinyMatrix, sn, stats,
survival, survminer, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>GGally, knitr, testthat, vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-01 16:13:56 UTC; st1jeo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy Oakley [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-01 16:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='SHELF-package'>SHELF: Tools to Support the Sheffield Elicitation Framework</h2><span id='topic+SHELF'></span><span id='topic+SHELF-package'></span>

<h3>Description</h3>

<p>Implements various methods for eliciting a probability distribution for a single parameter from an expert or a group of experts. The expert provides a small number of probability judgements, corresponding to points on his or her cumulative distribution function. A range of parametric distributions can then be fitted and displayed, with feedback provided in the form of fitted probabilities and percentiles. For multiple experts, a weighted linear pool can be calculated. Also includes functions for eliciting beliefs about population distributions; eliciting multivariate distributions using a Gaussian copula; eliciting a Dirichlet distribution; eliciting distributions for variance parameters in a random effects meta-analysis model; survival extrapolation. R Shiny apps for most of the methods are included.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jeremy Oakley <a href="mailto:j.oakley@sheffield.ac.uk">j.oakley@sheffield.ac.uk</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/OakleyJ/SHELF">https://github.com/OakleyJ/SHELF</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OakleyJ/SHELF/issues">https://github.com/OakleyJ/SHELF/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cdffeedback'>Feedback for the elicited distribution of the population CDF</h2><span id='topic+cdffeedback'></span>

<h3>Description</h3>

<p>Report the median and 100(1-alpha)% credible interval for point on the population CDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdffeedback(
  medianfit,
  precisionfit,
  quantiles = c(0.05, 0.95),
  vals = NA,
  alpha = 0.05,
  median.dist = "best",
  precision.dist = "gamma",
  n.rep = 10000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdffeedback_+3A_medianfit">medianfit</code></td>
<td>
<p>The output of a <a href="#topic+fitdist">fitdist</a> command following elicitation
of the expert's beliefs about the population median.</p>
</td></tr>
<tr><td><code id="cdffeedback_+3A_precisionfit">precisionfit</code></td>
<td>
<p>The output of a <a href="#topic+fitprecision">fitprecision</a> command following elicitation
of the expert's beliefs about the population precision.</p>
</td></tr>
<tr><td><code id="cdffeedback_+3A_quantiles">quantiles</code></td>
<td>
<p>A vector of quantiles <code class="reqn">q_1, \ldots,q_n</code> required for feedback</p>
</td></tr>
<tr><td><code id="cdffeedback_+3A_vals">vals</code></td>
<td>
<p>A vector of population values <code class="reqn">x_1,\ldots,x_n</code> required for feedback</p>
</td></tr>
<tr><td><code id="cdffeedback_+3A_alpha">alpha</code></td>
<td>
<p>The size of the 100(1-alpha)% credible interval</p>
</td></tr>
<tr><td><code id="cdffeedback_+3A_median.dist">median.dist</code></td>
<td>
<p>The fitted distribution for the population median. Can be one of <code>"normal"</code>,
<code>"lognormal"</code> or <code>"best"</code>, where <code>"best"</code> will select the best fitting out of 
normal and lognormal.</p>
</td></tr>
<tr><td><code id="cdffeedback_+3A_precision.dist">precision.dist</code></td>
<td>
<p>The fitted distribution for the population precision. Can either be <code>"gamma"</code>
or <code>"lognormal"</code>.</p>
</td></tr>
<tr><td><code id="cdffeedback_+3A_n.rep">n.rep</code></td>
<td>
<p>The number of randomly sampled CDFs used to estimated the median
and credible interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote the uncertain population CDF by </p>
<p style="text-align: center;"><code class="reqn">P(X \le x | \mu, \sigma^2),</code>
</p>
<p>where <code class="reqn">\mu</code>
is the uncertain population median and <code class="reqn">\sigma^(-2)</code> is the uncertain population precision.
Feedback can be reported in the form of the median and 100(1-alpha)% credible interval for
(a) an uncertain probability <code class="reqn">P(X \le x | \mu, \sigma^2)</code>, where <code class="reqn">x</code> is a specified 
population value and (b) an uncertain quantile <code class="reqn">x_q</code> defined by <code class="reqn">P(X \le x_q | \mu, \sigma^2) = q</code>, where <code class="reqn">q</code> is a specified 
population probability.
</p>


<h3>Value</h3>

<p>Fitted median and 100(1-alpha)% credible interval for population 
quantiles and probabilities.
</p>
<table role = "presentation">
<tr><td><code>$quantiles</code></td>
<td>
<p>Each row gives the fitted median 
and 100(1-alpha)% credible interval for each uncertain population quantile 
specified in <code>quantiles</code>: the fitted median 
and 100(1-alpha)% credible interval for the value of <code class="reqn">x_{q_i}</code> where 
<code class="reqn">P(X\le x_{q_i} | \mu, \sigma^2) = q_i.</code></p>
</td></tr> 
<tr><td><code>$probs</code></td>
<td>
<p>Each row gives the fitted median 
and 100(1-alpha)% credible interval for each uncertain population probability 
specified in <code>probs</code>: the fitted median 
and 100(1-alpha)% credible interval for the value of
<code class="reqn">P(X\le x_i | \mu, \sigma^2).</code> </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
prfit &lt;- fitprecision(interval = c(60, 70), propvals = c(0.2, 0.4), trans = "log")
medianfit &lt;- fitdist(vals = c(50, 60, 70), probs = c(0.05, 0.5,  0.95), lower = 0)
cdffeedback(medianfit, prfit, quantiles = c(0.01, 0.99),
            vals = c(65, 75), alpha = 0.05, n.rep = 10000)
 
## End(Not run)  
</code></pre>

<hr>
<h2 id='cdfplot'>Plot distribution of CDF</h2><span id='topic+cdfplot'></span>

<h3>Description</h3>

<p>Plot the elicited pointwise median and credible interval for an uncertain population CDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdfplot(
  medianfit,
  precisionfit,
  lower = NA,
  upper = NA,
  ql = 0.025,
  qu = 0.975,
  median.dist = "best",
  precision.dist = "gamma",
  n.rep = 10000,
  n.X = 100,
  fontsize = 18
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdfplot_+3A_medianfit">medianfit</code></td>
<td>
<p>The output of a <code>fitdist</code> command following elicitation
of the expert's beliefs about the population median.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_precisionfit">precisionfit</code></td>
<td>
<p>The output of a <code>fitdist</code> command following elicitation
of the expert's beliefs about the population precision.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_lower">lower</code></td>
<td>
<p>lower limit on the x-axis for plotting.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_upper">upper</code></td>
<td>
<p>upper limit on the x-axis for plotting.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_ql">ql</code></td>
<td>
<p>lower quantile for the plotted pointwise credible interval.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_qu">qu</code></td>
<td>
<p>upper quantile for the plotted pointwise credible interval.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_median.dist">median.dist</code></td>
<td>
<p>The fitted distribution for the population median. Can be one of <code>"normal"</code>,
<code>"lognormal"</code> or <code>"best"</code>, where <code>"best"</code> will select the best fitting out of 
normal and lognormal.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_precision.dist">precision.dist</code></td>
<td>
<p>The fitted distribution for the population precision. Can either be <code>"gamma"</code>
or <code>"lognormal"</code>.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_n.rep">n.rep</code></td>
<td>
<p>The number of randomly sampled CDFs used to estimated the median
and credible interval.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_n.x">n.X</code></td>
<td>
<p>The number of points on the x-axis at which the CDF is evaluated.</p>
</td></tr>
<tr><td><code id="cdfplot_+3A_fontsize">fontsize</code></td>
<td>
<p>Font size used in the plots.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
prfit &lt;- fitprecision(interval = c(60, 70), propvals = c(0.2, 0.4), trans = "log")
medianfit &lt;- fitdist(vals = c(50, 60, 70), probs = c(0.05, 0.5,  0.95), lower = 0)
cdfplot(medianfit, prfit)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='compareGroupRIO'>Compare individual elicited distributions with linear pool and RIO distribution</h2><span id='topic+compareGroupRIO'></span>

<h3>Description</h3>

<p>Produce one of three plots to compare the individual elicited judgements with the final
elicited distribution, chosen to represent the views of a &quot;Rational Impartatial Observer&quot; (RIO)
as part of the SHELF process. A linear pool of fitted distributions from the individually elicited
judgements is also obtained. The plot choices are a display of the quartiles, a display of the tertiles,
and a plot of the various density functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareGroupRIO(
  groupFit,
  RIOFit,
  type = "density",
  dLP = "best",
  dRIO = "best",
  xlab = "x",
  ylab = expression(f[X](x)),
  fs = 12
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareGroupRIO_+3A_groupfit">groupFit</code></td>
<td>
<p>either an object of class <code>elicitation</code>, or the file path
for a .csv file exported from the elicitMultiple() app. This should contain 
the individually elicited judgements from the experts</p>
</td></tr>
<tr><td><code id="compareGroupRIO_+3A_riofit">RIOFit</code></td>
<td>
<p>an object of class <code>elicitation</code> containing a single set of 
of probability judgements corresponding to the &quot;Rational Impartial Observer (RIO)&quot;.</p>
</td></tr>
<tr><td><code id="compareGroupRIO_+3A_type">type</code></td>
<td>
<p>the plot used to show the comparison: one of &quot;quartiles&quot;, &quot;tertiles&quot; or &quot;density&quot;.</p>
</td></tr>
<tr><td><code id="compareGroupRIO_+3A_dlp">dLP</code></td>
<td>
<p>the distribution fitted to each expert's judgements and to the linear pool. Options are 
Options are &quot;normal&quot;, &quot;t&quot;, &quot;gamma&quot;, &quot;lognormal&quot;, &quot;logt&quot;,&quot;beta&quot;, &quot;mirrorgamma&quot;,
&quot;mirrorlognormal&quot;, &quot;mirrorlogt&quot; &quot;hist&quot; (for a histogram fit), and &quot;best&quot; (for best fitting).</p>
</td></tr>
<tr><td><code id="compareGroupRIO_+3A_drio">dRIO</code></td>
<td>
<p>the distribution fitted to RIO's judgements. Options are the same as for <code>dLP</code>.</p>
</td></tr>
<tr><td><code id="compareGroupRIO_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label in plot</p>
</td></tr>
<tr><td><code id="compareGroupRIO_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label in plot</p>
</td></tr>
<tr><td><code id="compareGroupRIO_+3A_fs">fs</code></td>
<td>
<p>font size used in plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
l &lt;- c(2, 1, 5, 1)
u &lt;- c(95, 90, 65, 40)
v &lt;- matrix(c(15, 25, 40,
 10, 20, 40,
 10, 15, 25,
 5, 10, 20),
 3, 4)
p &lt;- c(0.25, 0.5, 0.75)
group &lt;- fitdist(vals = v, probs = p, lower = l, upper = u)
rio &lt;- fitdist(vals = c(12, 20, 25), probs = p, lower = 1, upper = 100)
compareGroupRIO(groupFit = group, RIOFit = rio, dRIO = "gamma")

## End(Not run)
</code></pre>

<hr>
<h2 id='compareIntervals'>Plot fitted intervals for each expert</h2><span id='topic+compareIntervals'></span>

<h3>Description</h3>

<p>Following elicitation of distributions from individual experts, plot fitted probability 
intervals for each expert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareIntervals(
  fit,
  interval = 0.95,
  dist = "best",
  fs = 12,
  xlab = "x",
  ylab = "expert",
  showDist = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareIntervals_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>elicitation</code></p>
</td></tr>
<tr><td><code id="compareIntervals_+3A_interval">interval</code></td>
<td>
<p>The probability p for each interval (i.e. the fitted probability for each expert 
that the displayed interval contains the uncertain quantity will be p)</p>
</td></tr>
<tr><td><code id="compareIntervals_+3A_dist">dist</code></td>
<td>
<p>The distribution fitted to each expert's probabilities. Options are
<code>"normal"</code>, <code>"t"</code>, <code>"skewnormal"</code>, <code>"gamma"</code>, <code>"lognormal"</code>,
<code>"logt"</code>,<code>"beta"</code>, <code>"mirrorgamma"</code>,
<code>"mirrorlognormal"</code>, <code>"mirrorlogt"</code> <code>"hist"</code> (for a histogram fit), and
<code>"best"</code> (for best fitting). Can be a vector if different distributions are desired for each expert.</p>
</td></tr>
<tr><td><code id="compareIntervals_+3A_fs">fs</code></td>
<td>
<p>font size used in the plot.</p>
</td></tr>
<tr><td><code id="compareIntervals_+3A_xlab">xlab</code></td>
<td>
<p>A string or expression giving the x-axis label.</p>
</td></tr>
<tr><td><code id="compareIntervals_+3A_ylab">ylab</code></td>
<td>
<p>A string or expression giving the y-axis label.</p>
</td></tr>
<tr><td><code id="compareIntervals_+3A_showdist">showDist</code></td>
<td>
<p>TRUE/FALSE for reporting distributions used for each expert</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
v &lt;- matrix(c(30, 40, 50, 20, 25, 35, 40, 50, 60, 35, 40, 50), 3, 4)
p &lt;- c(0.25, 0.5, 0.75)
myfit &lt;- fitdist(vals = v, probs = p, lower = 0, upper = 100)
compareIntervals(myfit, interval = 0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='copulaSample'>Generate correlated samples from elicited marginal distributions using a multivariate normal copula</h2><span id='topic+copulaSample'></span>

<h3>Description</h3>

<p>Takes elicited marginal distributions and elicited concordance probabilities: pairwise
probabilities of two uncertain quantities being greater than their medians, and generates
a correlated sample, assuming the elicited marginal distributions and a multivariate
normal copula. A vignette explaining this method is available at <a href="https://oakleyj.github.io/SHELF/Multivariate-normal-copula.html">https://oakleyj.github.io/SHELF/Multivariate-normal-copula.html</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copulaSample(..., cp, n, d = NULL, ex = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copulaSample_+3A_...">...</code></td>
<td>
<p>A list of objects of class <code>elicitation</code>.
command, one per marginal distribution, separated by commas.</p>
</td></tr>
<tr><td><code id="copulaSample_+3A_cp">cp</code></td>
<td>
<p>A matrix of pairwise concordance probabilities, with element i,j the elicited probability
P(X_i &gt; m_i, X_j &gt; m_j or X_i &lt; m_i, X_j &lt; m_j), where m_i and m_j are the elicited medians of the uncertain quantities X_i and X_j.
Only the upper triangular elements in the matrix need to be specified; the remaining elements can be set at 0.</p>
</td></tr>
<tr><td><code id="copulaSample_+3A_n">n</code></td>
<td>
<p>The sample size to be generated</p>
</td></tr>
<tr><td><code id="copulaSample_+3A_d">d</code></td>
<td>
<p>A vector of distributions to be used for each elicited quantity: a string with elements chosen from
<code>"normal", "t", "gamma", "lognormal", "logt", "beta", "mirrorgamma", "mirrorlognormal", "mirrorlogt"</code>. The default is to use
the best fitting distribution in each case.</p>
</td></tr>
<tr><td><code id="copulaSample_+3A_ex">ex</code></td>
<td>
<p>If separate judgements have been elicited from multiple experts and stored
in the <code>elicitation</code> objects, use this argument to select a single expert's judgements
for sampling. Note that this function will not simultaneously generate samples for all experts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of sampled values, one row per sample.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley <a href="mailto:j.oakley@sheffield.ac.uk">j.oakley@sheffield.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p1 &lt;- c(0.25, 0.5, 0.75)
v1 &lt;- c(0.5, 0.55, 0.6)
v2 &lt;- c(0.22, 0.3, 0.35)
v3 &lt;- c(0.11, 0.15, 0.2)
myfit1 &lt;- fitdist(v1, p1, 0, 1)
myfit2 &lt;- fitdist(v2, p1, 0, 1)
myfit3 &lt;- fitdist(v3, p1, 0, 1)
quad.probs &lt;- matrix(0, 3, 3)
quad.probs[1, 2] &lt;- 0.4
quad.probs[1, 3] &lt;- 0.4
quad.probs[2, 3] &lt;- 0.3
copulaSample(myfit1, myfit2, myfit3, cp=quad.probs, n=100, d=NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='elicit'>Elicit judgements and fit distributions interactively</h2><span id='topic+elicit'></span><span id='topic+roulette'></span><span id='topic+elicitQuartiles'></span><span id='topic+elicitTertiles'></span>

<h3>Description</h3>

<p>Opens up a web browser (using the shiny package), from which you can specify
judgements, fit distributions and plot the fitted density functions with
additional feedback. Probabilities can be specified directly, or the roulette 
elicitation method can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicit(lower = 0, upper = 100, gridheight = 10, nbins = 10, method = "general")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elicit_+3A_lower">lower</code></td>
<td>
<p>A lower limit for the uncertain quantity X. 
Will be ignored when fitting distributions that are not bounded below. Also sets 
the lower limit for the grid in the roulette method.</p>
</td></tr>
<tr><td><code id="elicit_+3A_upper">upper</code></td>
<td>
<p>An upper limit for the uncertain quantity X. 
Will be ignored when fitting distributions that are not bounded above. Also sets 
the upper limit for the grid in the roulette method.</p>
</td></tr>
<tr><td><code id="elicit_+3A_gridheight">gridheight</code></td>
<td>
<p>The number of grid cells for each bin in the roulette method.</p>
</td></tr>
<tr><td><code id="elicit_+3A_nbins">nbins</code></td>
<td>
<p>The number of bins used in the rouletted method.</p>
</td></tr>
<tr><td><code id="elicit_+3A_method">method</code></td>
<td>
<p>Set to &quot;roulette&quot; for the app to display the roulette method by default.
Any other string will display the general method by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All input arguments are optional, and can be set/changed within the app itself.
Click on the &quot;Help&quot; tab for instructions. Click the &quot;Quit&quot; button to exit the app and return
the results from the <code>fitdist</code> command. Click &quot;Download report&quot; to generate a report
of all the fitted distributions.
</p>


<h3>Value</h3>

<p>An object of class <code>elicitation</code>, which is returned once the 
Quit button has been clicked. See <code><a href="#topic+fitdist">fitdist</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

elicit()


## End(Not run)
</code></pre>

<hr>
<h2 id='elicitBivariate'>Elicit a bivariate distribution using a Gaussian copula</h2><span id='topic+elicitBivariate'></span><span id='topic+elicitConcProb'></span>

<h3>Description</h3>

<p>Opens up a web browser (using the shiny package), from which you can specify
judgements, fit distributions, plot the fitted density functions, and plot samples 
from the joint distributions. A joint distribution is constructed using a Gaussian
copula, whereby the correlation parameter is determined via the elicitation of a 
concordance probability (a probability that the two uncertain quantities are either
both greater than their medians, or both less than their medians.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicitBivariate()
</code></pre>


<h3>Details</h3>

<p>Click on the &quot;Help&quot; tab for instructions. Click the &quot;Quit&quot; button to exit the app and return
the results from the <code>fitdist</code> command. Click &quot;Download report&quot; to generate a report
of all the fitted distributions for each uncertain quantity, and &quot;Download sample&quot; to
generate a csv file with a sample from the joint distribution.
</p>


<h3>Value</h3>

<p>A list, with two objects of class <code>elicitation</code>, and the 
elicited concordance probability. See <code><a href="#topic+fitdist">fitdist</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

elicitBivariate()


## End(Not run)
</code></pre>

<hr>
<h2 id='elicitDirichlet'>Elicit a Dirichlet distribution interactively</h2><span id='topic+elicitDirichlet'></span><span id='topic+condDirichlet'></span>

<h3>Description</h3>

<p>Opens up a web browser (using the shiny package), from which you can elicit a
Dirichlet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicitDirichlet()
</code></pre>


<h3>Details</h3>

<p>Click on the &quot;Help&quot; tab for instructions. Click the &quot;Quit&quot; button to exit the app and return
the results from the <code>fitdist</code> command. Click &quot;Download report&quot; to generate a report
of all the fitted distributions.
</p>


<h3>Value</h3>

<p>The parameters of the fitted Dirichlet distribution, which are 
returned once the Quit button has been clicked.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

elicitDirichlet()


## End(Not run)
</code></pre>

<hr>
<h2 id='elicitExtension'>Elicitation with the extension method</h2><span id='topic+elicitExtension'></span>

<h3>Description</h3>

<p>Opens up a web browser (using the shiny package), from which you can specify
judgements, fit distributions, and produce various plots. Judgements are 
specified for the distribution of the conditioning variable Y, the median 
function (median of X given Y), and the distribution of X given that Y takes
its median value. Plots are provided for the two elicited distributions, the
median function, the conditional distribution of X for any specified Y, and
the marginal distribution of X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicitExtension()
</code></pre>


<h3>Details</h3>

<p>Click the &quot;Quit&quot; button to exit the app and return
the results from the <code>fitdist</code> command. Click &quot;Download report&quot; to generate a report
of all the fitted distributions for each uncertain quantity, and &quot;Download sample&quot; to
generate a csv file with a sample from the marginal distribution of X.
</p>


<h3>Value</h3>

<p>A list, with two objects of class <code>elicitation</code>.
See <code><a href="#topic+fitdist">fitdist</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

elicitExtension()


## End(Not run)
</code></pre>

<hr>
<h2 id='elicitHeterogen'>Elicit a prior distribution for a random effects variance parameter</h2><span id='topic+elicitHeterogen'></span>

<h3>Description</h3>

<p>Opens a shiny app for the roulette elicitation method. The user clicks in the
grid to allocate 'probs' to 'bins'. The elicited probability inside each
bin is the proportion of probs in each bin. This will fit a distribution to the ratio R
of the 'largest' (97.5th percentile) to 'smallest' (2.5th percentile) treatment effect. 
A distribution for the variance effects variance parameter is inferred from the distribution 
of R, assuming that the random effects are normally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicitHeterogen(
  lower = 1,
  upper = 10,
  gridheight = 10,
  nbins = 9,
  scale.free = TRUE,
  sigma = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elicitHeterogen_+3A_lower">lower</code></td>
<td>
<p>The lower limit on the x-axis of the roulette grid.</p>
</td></tr>
<tr><td><code id="elicitHeterogen_+3A_upper">upper</code></td>
<td>
<p>The upper limit on the x-axis of the roulette grid.</p>
</td></tr>
<tr><td><code id="elicitHeterogen_+3A_gridheight">gridheight</code></td>
<td>
<p>The maximum number of probs that can be allocated to a
single bin.</p>
</td></tr>
<tr><td><code id="elicitHeterogen_+3A_nbins">nbins</code></td>
<td>
<p>The number of equally sized bins drawn between <code>lower</code> and
<code>upper</code>.</p>
</td></tr>
<tr><td><code id="elicitHeterogen_+3A_scale.free">scale.free</code></td>
<td>
<p>Logical. Default is <code>TRUE</code> for a scale free treatment effect,
such as an odds ratio, hazard ratio or relative risk. Set to <code>FALSE</code> for a treatment effect
that is scale dependent, or is on the probit scale. An approximation to the treatment effect
on the logit scale will be used (assuming a dichotomised response).</p>
</td></tr>
<tr><td><code id="elicitHeterogen_+3A_sigma">sigma</code></td>
<td>
<p>Individual observation standard deviation, required if <code>scale.free</code> is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BUGS code for incorporating the prior within a BUGS model. Additionally, a list with outputs 
</p>
<table role = "presentation">
<tr><td><code>allocation</code></td>
<td>
<p>table of bins, with number of probs allocated to each bin.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>parameters of the fitted gamma distribution.</p>
</td></tr>
<tr><td><code>Log.normal</code></td>
<td>
<p>parameters of the fitted lognormal distribution.</p>
</td></tr>
<tr><td><code>sumsq</code></td>
<td>
<p>sum of squares of elicited - fitted probabilities for each distribution.</p>
</td></tr>
<tr><td><code>best.fitting</code></td>
<td>
<p>the distribution with the lowest sum of squares.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Regarding the option &ldquo;spread end probs over empty bins&rdquo; 
(unchecked as the default): suppose for example, the leftmost and rightmost non-empty
bins are [10,20] and [70,80], and each contain one prob, with 20 probs used in total. If the option
is unchecked, it is assumed P(X&lt;20) = P(X&gt;70) = 0.05 and P(X&lt;10) = P(X&gt;80) = 0. If the option
is checked, it is assumed P(X&lt;20) = P(X&gt;70) = 0.05 only.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
elicitHeterogen()

## End(Not run)
</code></pre>

<hr>
<h2 id='elicitMixture'>Elicit a mixture distribution using the extension method</h2><span id='topic+elicitMixture'></span>

<h3>Description</h3>

<p>Opens up a web browser (using the shiny package), from which you can specify
judgements, fit distributions and plot the fitted density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicitMixture()
</code></pre>


<h3>Details</h3>

<p>Click the &quot;Quit&quot; button to exit the app and return
the fitted distributions. Click &quot;Download report&quot; to generate a report
of all the fitted distributions.
</p>


<h3>Value</h3>

<p>When the Quit button is clicked, a list, with elements
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>an object of class <code>elicitation</code>. See <code><a href="#topic+fitdist">fitdist</a></code> for details.</p>
</td></tr>
<tr><td><code>extensionProbs</code></td>
<td>
<p>the probability mass function for the extension variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

elicitMixture()


## End(Not run)
</code></pre>

<hr>
<h2 id='elicitMultiple'>Elicit individual judgements and fit distributions for multiple experts</h2><span id='topic+elicitMultiple'></span>

<h3>Description</h3>

<p>Opens up a web browser (using the shiny package), from which you can specify
judgements, fit distributions and plot the fitted density functions and a 
(weighted) linear pool with additional feedback.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicitMultiple()
</code></pre>


<h3>Details</h3>

<p>Click the &quot;Quit&quot; button to exit the app and return
the results from the <code>fitdist</code> command. Click &quot;Download report&quot; to generate a report
of all the fitted distributions.
</p>


<h3>Value</h3>

<p>An object of class <code>elicitation</code>, which is returned once the 
Finish button has been clicked. See <code><a href="#topic+fitdist">fitdist</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

elicitMultiple()


## End(Not run)
</code></pre>

<hr>
<h2 id='elicitSurvivalExtrapolation'>Elicitation for survival extrapolation</h2><span id='topic+elicitSurvivalExtrapolation'></span>

<h3>Description</h3>

<p>Opens up a web browser in which you can implement the SHELF protocol for survival extrapolation.
Start with uploading a .csv file of individual patient survival data (time, event to indicate censoring, and
treatment group). Then elicit individual judgements, perform scenario testing as required, and elicit a RIO distribution.
Judgements for two treatment groups can be elicited in the same session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicitSurvivalExtrapolation()
</code></pre>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# make a suitable csv file using a built in data set from the survival package
sdf &lt;- survival::veteran[, c("time", "status", "trt")]
colnames(sdf) &lt;- c("time", "event", "treatment")
sdf$treatment &lt;- factor(sdf$treatment, labels = c("standard", "test"))

# write the data frame sdf to a .csv file in the current working directory
write.csv(sdf, file = "testFile.csv", row.names = FALSE)

# Run the app and upload testFile.csv in the first tab, and change unit of time to "days"

elicitSurvivalExtrapolation()


## End(Not run)
</code></pre>

<hr>
<h2 id='feedback'>Report quantiles and probabilities from the fitted probability distributions</h2><span id='topic+feedback'></span>

<h3>Description</h3>

<p>Having fitted appropriate distributions to one or more expert's judgements
individually using the <code><a href="#topic+fitdist">fitdist</a></code> command, use this command to
get quantiles and probabilities from the fitted distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feedback(fit, quantiles = NA, values = NA, dist = "best", ex = NA, sf = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feedback_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>elicitation</code>.</p>
</td></tr>
<tr><td><code id="feedback_+3A_quantiles">quantiles</code></td>
<td>
<p>A vector of desired quantiles for feedback. If this
argument is left out, the default is to use the same quantiles that were
elicited from the experts.</p>
</td></tr>
<tr><td><code id="feedback_+3A_values">values</code></td>
<td>
<p>A vector of desired probabilities; desired values of a for
reporting back fitted values of P(X&lt;a). If this argument is left out, the
default is to use the same values provided by the experts.</p>
</td></tr>
<tr><td><code id="feedback_+3A_dist">dist</code></td>
<td>
<p>If <code>fit</code> contains judgements from multiple experts,
<code>dist</code> is distribution to be used for calculating probabilities and
quantiles. Options are <code>"normal"</code>, <code>"t"</code>, <code>"gamma"</code>,
<code>"lognormal"</code>, <code>"logt"</code>, <code>"beta"</code>, or <code>"best"</code>. The
default option, <code>"best"</code>, uses the best fitting distribution for each
expert.</p>
</td></tr>
<tr><td><code id="feedback_+3A_ex">ex</code></td>
<td>
<p>If <code>fit</code> contains judgements from multiple experts,
specifying a value for <code>ex</code> will select a single expert for feedback.
Note that for a single expert, feedback is given for all suitable types of
distribution, but for multiple experts, feedback is given for one type of
distribution only.</p>
</td></tr>
<tr><td><code id="feedback_+3A_sf">sf</code></td>
<td>
<p>The number of significant figures to be displayed in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fitted.quantiles</code></td>
<td>
<p>Fitted quantiles for each expert</p>
</td></tr>
<tr><td><code>fitted.probabilities</code></td>
<td>
<p>Fitted probabilities for each expert</p>
</td></tr>
<tr><td><code>distributions</code></td>
<td>
<p>The distribution used to calculate fitted
probabilities/quantiles for each expert, if feedback is given for multiple
experts.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Two experts
# Expert 1 states P(X&lt;30)=0.25, P(X&lt;40)=0.5, P(X&lt;50)=0.75
# Expert 2 states P(X&lt;20)=0.25, P(X&lt;25)=0.5, P(X&lt;35)=0.75
# Both experts state 0&lt;X&lt;100.

v &lt;- matrix(c(30, 40, 50, 20, 25, 35), 3, 2)
p &lt;- c(0.25, 0.5, 0.75)
myfit &lt;- fitdist(vals = v, probs = p, lower = 0, upper = 100)

feedback(myfit)

# Feedback P(X&lt;60) and the tertiles
feedback(myfit, values=60, quantiles=c(0.33,0.66))

# Compare fitted tertiles for different distributions, expert 2 only
feedback(myfit, quantiles=c(0.33,0.66), ex=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='feedbackDirichlet'>Calculate quantiles for the marginal distributions of a Dirichlet distribution</h2><span id='topic+feedbackDirichlet'></span>

<h3>Description</h3>

<p>Given a (elicited) Dirichlet distribution, calculate quantiles for each marginal
beta distribution corresponding to the elicited quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feedbackDirichlet(d, quantiles = c(0.1, 0.9), sf = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feedbackDirichlet_+3A_d">d</code></td>
<td>
<p>A vector of parameters of the Dirichlet distribution</p>
</td></tr>
<tr><td><code id="feedbackDirichlet_+3A_quantiles">quantiles</code></td>
<td>
<p>The desired quantiles for feedback</p>
</td></tr>
<tr><td><code id="feedbackDirichlet_+3A_sf">sf</code></td>
<td>
<p>The number of significant figures displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quantiles for each marginal distribution
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
feedbackDirichlet(d = c(20, 10, 5),
                  quantiles = c(0.1, 0.33, 0.66, 0.9))

## End(Not run)
</code></pre>

<hr>
<h2 id='fitDirichlet'>Fit a Dirichlet distribution to elicited marginal distributions for proportions</h2><span id='topic+fitDirichlet'></span>

<h3>Description</h3>

<p>Takes elicited beta distributions for a set of proportions as inputs,
and fits a Dirichlet distribution. The beta parameters are adjusted 
so that the expectations sum to 1, and then the sum of the Dirichlet
parameters is chosen based on the sums of the beta parameters for each elicited marginal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDirichlet(
  ...,
  categories = NULL,
  n.fitted = "opt",
  plotBeta = TRUE,
  xlab = "x",
  ylab = expression(f[X](x)),
  fs = 12,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitDirichlet_+3A_...">...</code></td>
<td>
<p>Multiple arguments, each an objects of class <code>elicitation</code>, 
one per marginal proportion, separated by commas. The sequence can be 
specified as a single argument by containing all the <code>elicitation</code>
objects within a single <code>list</code> object.</p>
</td></tr>
<tr><td><code id="fitDirichlet_+3A_categories">categories</code></td>
<td>
<p>A vector of strings labelling the marginal proportions.</p>
</td></tr>
<tr><td><code id="fitDirichlet_+3A_n.fitted">n.fitted</code></td>
<td>
<p>The method used to determine the sum of the Dirichlet parameters.
Use <code>"opt"</code> for best fitting, derived by matching standard deviations from the elicited marginals
and the fitted Dirichlet; <code>"min"</code> for a conservative choice based 
on the smallest equivalent sample size (sum of the beta parameters) from the 
elicited marginals; <code>"med"</code> for the median of the smallest and largest largest equivalent sample size
from the 
elicited marginals; <code>"mean"</code> for the mean of all the equivalent sample sizes
from the 
elicited marginals.</p>
</td></tr>
<tr><td><code id="fitDirichlet_+3A_plotbeta">plotBeta</code></td>
<td>
<p>logical. Plot the original elicited marginals and the fitted marginals from the 
Dirichlet fit.</p>
</td></tr>
<tr><td><code id="fitDirichlet_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label on the marginal distribution plot.</p>
</td></tr>
<tr><td><code id="fitDirichlet_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label on the marginal distribution plot.</p>
</td></tr>
<tr><td><code id="fitDirichlet_+3A_fs">fs</code></td>
<td>
<p>The font size used in the plot.</p>
</td></tr>
<tr><td><code id="fitDirichlet_+3A_silent">silent</code></td>
<td>
<p>Set to <code>TRUE</code> to suppress printing of results to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the fitted Dirichlet distribution.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>References</h3>

<p>Zapata-Vazquez, R., O'Hagan, A. and Bastos, L. S. (2014). Eliciting expert judgements about a set of proportions. Journal of Applied Statistics 41, 1919-1933.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p1 &lt;- c(0.25, 0.5, 0.75)
v1 &lt;- c(0.5, 0.55, 0.6)
v2 &lt;- c(0.22, 0.3, 0.35)
v3 &lt;- c(0.11, 0.15, 0.2)
myfit1 &lt;- fitdist(v1, p1, 0, 1)
myfit2 &lt;- fitdist(v2, p1, 0, 1)
myfit3 &lt;- fitdist(v3, p1, 0, 1)
d &lt;- fitDirichlet(myfit1, myfit2, myfit3,
                  categories = c("A","B","C"),
                  n.fitted = "opt")

# Note that this will also work:
d &lt;- fitDirichlet(list(myfit1, myfit2, myfit3),
                  categories = c("A","B","C"),
                  n.fitted = "opt")


## End(Not run)
</code></pre>

<hr>
<h2 id='fitdist'>Fit distributions to elicited probabilities</h2><span id='topic+fitdist'></span>

<h3>Description</h3>

<p>Takes elicited probabilities as inputs, and fits parametric distributions
using least squares on the cumulative distribution function. If separate
judgements from multiple experts are specified, the function will fit one
set of distributions per expert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitdist(
  vals,
  probs,
  lower = -Inf,
  upper = Inf,
  weights = 1,
  tdf = 3,
  expertnames = NULL,
  excludelogt = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitdist_+3A_vals">vals</code></td>
<td>
<p>A vector of elicited values for one expert, or a matrix of
elicited values for multiple experts (one column per expert). Note that the
an elicited judgement about X should be of the form P(X&lt;= vals[i,j]) =
probs[i,j]</p>
</td></tr>
<tr><td><code id="fitdist_+3A_probs">probs</code></td>
<td>
<p>A vector of elicited probabilies for one expert, or a matrix of
elicited values for multiple experts (one column per expert). A single
vector can be used if the probabilities are the same for each expert. For
each expert, there should be at least one non-zero probability less than 0.4, and
at least one elicited probability less and 1 and greater than 0.6. Exponential distributions 
can be fitted by specifying one limit (<code>lower</code> or <code>upper</code>) and one probability between 0 and 1.</p>
</td></tr>
<tr><td><code id="fitdist_+3A_lower">lower</code></td>
<td>
<p>A single lower limit for the uncertain quantity X, or a vector
of different lower limits for each expert. Specifying a lower limit will
allow the fitting of distributions bounded below.</p>
</td></tr>
<tr><td><code id="fitdist_+3A_upper">upper</code></td>
<td>
<p>A single upper limit for the uncertain quantity X, or a vector
of different lower limits for each expert. Specifying both a lower limit and
an upper limit will allow the fitting of a Beta distribution.</p>
</td></tr>
<tr><td><code id="fitdist_+3A_weights">weights</code></td>
<td>
<p>A vector or matrix of weights corresponding to vals if
weighted least squares is to be used in the parameter fitting.</p>
</td></tr>
<tr><td><code id="fitdist_+3A_tdf">tdf</code></td>
<td>
<p>The number of degrees of freedom to be used when fitting a
t-distribution.</p>
</td></tr>
<tr><td><code id="fitdist_+3A_expertnames">expertnames</code></td>
<td>
<p>Vector of names to use for each expert.</p>
</td></tr>
<tr><td><code id="fitdist_+3A_excludelogt">excludelogt</code></td>
<td>
<p>Set to TRUE to exclude log-t and mirror log-t when identifying
best fitting distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>elicitation</code>. This is a list containing the elements
</p>
<table role = "presentation">
<tr><td><code>Normal</code></td>
<td>
<p>Parameters of the fitted normal distributions.</p>
</td></tr>
<tr><td><code>Student.t</code></td>
<td>
<p>Parameters of the fitted t distributions. Note that (X -
location) / scale has a standard t distribution. The degrees of freedom is
not fitted; it is specified as an argument to <code>fitdist</code>.</p>
</td></tr>
<tr><td><code>Skewnormal</code></td>
<td>
<p>Parameters of the fitted skew-normal distribution. The skew-normal
distribution is implemented using the sn package. See sn::dsn for details. This distribution
requires at least three elicited probabilities, including at least one in each interval (0, 0.4)
and (0.6, 1).</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>Parameters of the fitted gamma distributions. Note that E(X - <code>lower</code>) =
shape / rate.</p>
</td></tr> 
<tr><td><code>Log.normal</code></td>
<td>
<p>Parameters of the fitted log normal
distributions: the mean and standard deviation of log (X - <code>lower</code>).</p>
</td></tr>
<tr><td><code>Log.Student.t</code></td>
<td>
<p>Parameters of the fitted log student t distributions.
Note that (log(X- <code>lower</code>) - location) / scale has a standard t distribution. The
degrees of freedom is not fitted; it is specified as an argument to
<code>fitdist</code>.</p>
</td></tr> 
<tr><td><code>Beta</code></td>
<td>
<p>Parameters of the fitted beta distributions. X
is scaled to the interval [0,1] via Y = (X - <code>lower</code>)/(<code>upper</code> -
<code>lower</code>), and E(Y) = shape1 / (shape1 + shape2).</p>
</td></tr> 
<tr><td><code>mirrorgamma</code></td>
<td>
<p>Parameters of ('mirror') gamma distributions fitted to Y = <code>upper</code> - X. Note that E(Y) =
shape / rate.</p>
</td></tr>
<tr><td><code>mirrorlognormal</code></td>
<td>
<p>Parameters of ('mirror') log normal distributions
fitted to Y = <code>upper</code> - X.</p>
</td></tr> 
<tr><td><code>mirrorlogt</code></td>
<td>
<p>Parameters of ('mirror') log Student-t distributions fitted to Y = <code>upper</code> - X. 
Note that (log(Y) - location) / scale has a standard t distribution. The
degrees of freedom is not fitted; it is specified as an argument to
<code>fitdist</code>.</p>
</td></tr> 
<tr><td><code>ssq</code></td>
<td>
<p>Sum of
squared errors for each fitted distribution and expert. Each error is the
difference between an elicited cumulative probability and the corresponding
fitted cumulative probability.</p>
</td></tr> 
<tr><td><code>best.fitting</code></td>
<td>
<p>The best fitting
distribution for each expert, determined by the smallest sum of squared
errors. Note that with three judgements only, this is likely to be the skew-normal, as this is a three parameter distribution. </p>
</td></tr> 
<tr><td><code>vals</code></td>
<td>
<p>The elicited values used to fit the distributions.</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>The elicited probabilities used to fit the distributions.</p>
</td></tr>
<tr><td><code>limits</code></td>
<td>
<p>The lower and upper limits specified by each expert (+/- Inf
if not specified).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The least squares parameter values are found numerically using the
<code>optim</code> command. Starting values for the distribution parameters are
chosen based on a simple normal approximation: linear interpolation is used
to estimate the 0.4, 0.5 and 0.6 quantiles, and starting parameter values
are chosen by setting E(X) equal to the 0.5th quantile, and Var(X) = (0.6
quantile - 0.4 quantile)^2 / 0.25. Note that the arguments <code>lower</code> and
<code>upper</code> are not included as elicited values on the cumulative
distribution function. To include a judgement such as P(X&lt;=a)=0, the values
a and 0 must be included in <code>vals</code> and <code>probs</code> respectively.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# One expert, with elicited probabilities
# P(X&lt;20)=0.25, P(X&lt;30)=0.5, P(X&lt;50)=0.75
# and X&gt;0.
v &lt;- c(20,30,50)
p &lt;- c(0.25,0.5,0.75)
fitdist(vals=v, probs=p, lower=0)

# Now add a second expert, with elicited probabilities
# P(X&lt;55)=0.25, P(X&lt;60=0.5), P(X&lt;70)=0.75
v &lt;- matrix(c(20,30,50,55,60,70),3,2)
p &lt;- c(0.25,0.5,0.75)
fitdist(vals=v, probs=p, lower=0)

# Two experts, different elicited quantiles and limits.
# Expert A: P(X&lt;50)=0.25, P(X&lt;60=0.5), P(X&lt;65)=0.75, and provides bounds 10&lt;X&lt;100
# Expert B: P(X&lt;40)=0.33, P(X&lt;50=0.5), P(X&lt;60)=0.66, and provides bounds 0&lt;X
v &lt;- matrix(c(50,60,65,40,50,60),3,2)
p &lt;- matrix(c(.25,.5,.75,.33,.5,.66),3,2)
l &lt;- c(10,0)
u &lt;- c(100, Inf)
fitdist(vals=v, probs=p, lower=l, upper=u)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitprecision'>Fit a distribution to judgements about a population precision</h2><span id='topic+fitprecision'></span>

<h3>Description</h3>

<p>Takes elicited probabilities about proportion of a population
lying in a specfied interval as inputs, converts the judgements into probability
judgements about the population precision, and fits gamma and lognormal distributions
to these judgements using the <a href="#topic+fitdist">fitdist</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitprecision(
  interval,
  propvals,
  propprobs = c(0.05, 0.95),
  med = interval[1],
  trans = "identity",
  pplot = TRUE,
  tdf = 3,
  fontsize = 12
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitprecision_+3A_interval">interval</code></td>
<td>
<p>A vector specifying the endpoints of an interval <code class="reqn">[k_1, k_2]</code>.</p>
</td></tr>
<tr><td><code id="fitprecision_+3A_propvals">propvals</code></td>
<td>
<p>A vector specifying two values <code class="reqn">\theta_1, \theta_2</code> for the proportion.</p>
</td></tr>
<tr><td><code id="fitprecision_+3A_propprobs">propprobs</code></td>
<td>
<p>A vector specifying two probabilities <code class="reqn">p_1, p_2</code>.</p>
</td></tr>
<tr><td><code id="fitprecision_+3A_med">med</code></td>
<td>
<p>The hypothetical value of the population median.</p>
</td></tr>
<tr><td><code id="fitprecision_+3A_trans">trans</code></td>
<td>
<p>A string variable taking the value <code>"identity"</code>, <code>"log"</code> or
<code>"logit"</code> corresponding to whether the population distribution is normal, lognormal
or logit-normal respectively.</p>
</td></tr>
<tr><td><code id="fitprecision_+3A_pplot">pplot</code></td>
<td>
<p>Plot the population distributions with median set at <code class="reqn">k_1</code>
and precision fixed at the two elicited quantiles implied by <code>propvals</code> 
and <code>propprobs</code>.</p>
</td></tr>
<tr><td><code id="fitprecision_+3A_tdf">tdf</code></td>
<td>
<p>Degrees of freedom in the fitted log Student-t distribution.</p>
</td></tr>
<tr><td><code id="fitprecision_+3A_fontsize">fontsize</code></td>
<td>
<p>Font size used in the plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expert provides a pair of probability judgements
</p>
<p style="text-align: center;"><code class="reqn">P(\theta &lt; \theta_1 ) = p_1,</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">P(\theta &lt; \theta_2) = p_2,</code>
</p>

<p>where <code class="reqn">\theta</code> is the proportion of the population that lies in the interval
<code class="reqn">[k_1, k_2]</code>, conditional on the population median taking some hypothetical value (<code class="reqn">k_1</code>
by default). <code class="reqn">k_1</code> can be set to <code>-Inf</code>, or <code class="reqn">k_2</code> can be set to <code>Inf</code>;
in either case, the hypothetical median value must be specified. If both <code class="reqn">k_1</code>
and <code class="reqn">k_2</code> are finite, the hypothetical median must be one of the interval endpoints.
Note that, unlike the <a href="#topic+fitdist">fitdist</a> command, a 'best fitting'
distribution is not reported, as the distributions are fitted to two elicited
probabilities only.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Gamma</code></td>
<td>
<p>Parameters of the fitted gamma distribution. Note that E(precision) =
shape / rate.</p>
</td></tr> 
<tr><td><code>Log.normal</code></td>
<td>
<p>Parameters of the fitted log normal
distribution: the mean and standard deviation of log precision.</p>
</td></tr>
<tr><td><code>Log.Student.t</code></td>
<td>
<p>Parameters of the fitted log student t distributions.
Note that (log(X- <code>lower</code>) - location) / scale has a standard t distribution. The
degrees of freedom is not fitted: it is specified as an input argument.</p>
</td></tr> 
<tr><td><code>vals</code></td>
<td>
<p>The elicited values <code class="reqn">\theta_1, \theta_2</code></p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>The elicited probabilities <code class="reqn">p_1, p_2</code></p>
</td></tr>
<tr><td><code>limits</code></td>
<td>
<p>The lower and upper limits specified by each expert (+/- Inf
if not specified).</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p>Transformation used for a normal population distribution.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fitprecision(interval=c(60, 70), propvals=c(0.2, 0.4), trans = "log")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='generateReport'>Generate a report to show the fitted distributions</h2><span id='topic+generateReport'></span>

<h3>Description</h3>

<p>Renders an Rmarkdown document to display the density function of each fitted distribution, 
the parameter values, and the R command required to sample from each distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateReport(
  fit,
  output_format = "html_document",
  sf = 3,
  expert = 1,
  view = TRUE,
  clean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateReport_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>'elicitation'</code>.</p>
</td></tr>
<tr><td><code id="generateReport_+3A_output_format">output_format</code></td>
<td>
<p>the output format for the document. One of <code>"html_document"</code>,
<code>"pdf_document"</code> (requires LaTeX to be installed), or <code>"word_document"</code>
(requires Word to be installed).</p>
</td></tr>
<tr><td><code id="generateReport_+3A_sf">sf</code></td>
<td>
<p>number of significant figures to be displayed for the fitted parameters.</p>
</td></tr>
<tr><td><code id="generateReport_+3A_expert">expert</code></td>
<td>
<p>if the <code>fit</code> object contains judgements from multiple experts, the 
single expert's distributions to be displayed.</p>
</td></tr>
<tr><td><code id="generateReport_+3A_view">view</code></td>
<td>
<p>set to <code>TRUE</code> to open the document after it has been compiled.</p>
</td></tr>
<tr><td><code id="generateReport_+3A_clean">clean</code></td>
<td>
<p>set to <code>TRUE</code> to clean intermediate files that are created during rendering.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# One expert, with elicited probabilities
# P(X&lt;20)=0.25, P(X&lt;30)=0.5, P(X&lt;50)=0.75
# and X&gt;0.
v &lt;- c(20,30,50)
p &lt;- c(0.25,0.5,0.75)
myfit &lt;- fitdist(vals=v, probs=p, lower=0)

generateReport(myfit)

## End(Not run)
</code></pre>

<hr>
<h2 id='linearPoolDensity'>Obtain points on the density function of a linear pool</h2><span id='topic+linearPoolDensity'></span>

<h3>Description</h3>

<p>Takes an object of class <code>elicitation</code>, evaluates a (weighted) linear pool, 
and returns points on the density function at a sequence of values of the elicited 
parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearPoolDensity(fit, xl = -Inf, xu = Inf, d = "best", lpw = 1, nx = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linearPoolDensity_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>elicitation</code>.</p>
</td></tr>
<tr><td><code id="linearPoolDensity_+3A_xl">xl</code></td>
<td>
<p>The lower limit in the sequence of parameter values. The default is the 0.001 quantile
of the fitted distribution (or the 0.001 quantile of a fitted normal
distribution, if a histogram fit is chosen).</p>
</td></tr>
<tr><td><code id="linearPoolDensity_+3A_xu">xu</code></td>
<td>
<p>The upper limit in the sequence of parameter values. The default is the 0.999 quantile
of the fitted distribution (or the 0.999 quantile of a fitted normal
distribution, if a histogram fit is chosen).</p>
</td></tr>
<tr><td><code id="linearPoolDensity_+3A_d">d</code></td>
<td>
<p>The distribution fitted to each expert's probabilities. Options are
<code>"normal"</code>, <code>"t"</code>, <code>"gamma"</code>, <code>"lognormal"</code>,
<code>"logt"</code>,<code>"beta"</code>, <code>"hist"</code> (for a histogram fit), and
<code>"best"</code> (for best fitting)</p>
</td></tr>
<tr><td><code id="linearPoolDensity_+3A_lpw">lpw</code></td>
<td>
<p>A vector of weights to be used in linear pool, if unequal
weighting is desired.</p>
</td></tr>
<tr><td><code id="linearPoolDensity_+3A_nx">nx</code></td>
<td>
<p>The number of points in the sequence from <code>xl</code> to <code>xu</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with elements
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>a sequence of values for the uncertain parameter</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>the density function of the linear pool, evaluated at each element in <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Two experts
# Expert 1 states P(X&lt;30)=0.25, P(X&lt;40)=0.5, P(X&lt;50)=0.75
# Expert 2 states P(X&lt;20)=0.25, P(X&lt;25)=0.5, P(X&lt;35)=0.75
# Both experts state 0&lt;X&lt;100. 

v &lt;- matrix(c(30, 40, 50, 20, 25, 35), 3, 2)
p &lt;- c(0.25, 0.5, 0.75)
myfit &lt;- fitdist(vals = v, probs = p, lower = 0, upper = 100)
linearPoolDensity(myfit)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeCDFPlot'>Plot the elicited cumulative probabilities</h2><span id='topic+makeCDFPlot'></span>

<h3>Description</h3>

<p>Plots the elicited cumulative probabilities and, optionally,
a fitted CDF. Elicited are shown as filled circles, and
limits are shown as clear circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCDFPlot(
  lower,
  v,
  p,
  upper,
  fontsize = 12,
  fit = NULL,
  dist = NULL,
  showFittedCDF = FALSE,
  showQuantiles = FALSE,
  ql = 0.05,
  qu = 0.95,
  ex = 1,
  sf = 3,
  xaxisLower = lower,
  xaxisUpper = upper,
  xlab = "x",
  ylab = expression(P(X &lt;= x))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeCDFPlot_+3A_lower">lower</code></td>
<td>
<p>lower limit for the uncertain quantity</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_v">v</code></td>
<td>
<p>vector of values, for each value x in Pr(X&lt;=x) = p
in the set of elicited probabilities</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_p">p</code></td>
<td>
<p>vector of probabilities, for each value p in Pr(X&lt;=x) = p
in the set of elicited probabilities</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_upper">upper</code></td>
<td>
<p>upper limit for the uncertain quantity</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_fontsize">fontsize</code></td>
<td>
<p>font size to be used in the plot</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_fit">fit</code></td>
<td>
<p>object of class <code>elicitation</code></p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_dist">dist</code></td>
<td>
<p>the fitted distribution to be plotted. Options are
<code>"normal"</code>, <code>"t"</code>, <code>"skewnormal"</code>, <code>"gamma"</code>, <code>"lognormal"</code>,
<code>"logt"</code>,<code>"beta"</code>, <code>"mirrorgamma"</code>,
<code>"mirrorlognormal"</code>, <code>"mirrorlogt"</code> <code>"hist"</code> (for a histogram fit)</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_showfittedcdf">showFittedCDF</code></td>
<td>
<p>logical. Should a fitted distribution function
be displayed?</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_showquantiles">showQuantiles</code></td>
<td>
<p>logical. Should quantiles from the fitted distribution function
be displayed?</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_ql">ql</code></td>
<td>
<p>a lower quantile to be displayed.</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_qu">qu</code></td>
<td>
<p>an upper quantile to be displayed.</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_ex">ex</code></td>
<td>
<p>if the object <code>fit</code> contains judgements from multiple experts,
which (single) expert's judgements to show.</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_sf">sf</code></td>
<td>
<p>number of significant figures to be displayed.</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_xaxislower">xaxisLower</code></td>
<td>
<p>lower limit for the x-axis.</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_xaxisupper">xaxisUpper</code></td>
<td>
<p>upper limit for the x-axis.</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label.</p>
</td></tr>
<tr><td><code id="makeCDFPlot_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
vQuartiles &lt;- c(30, 35, 45)
pQuartiles&lt;- c(0.25, 0.5, 0.75)
myfit &lt;- fitdist(vals = vQuartiles, probs = pQuartiles, lower = 0)
makeCDFPlot(lower = 0, v = vQuartiles, p = pQuartiles,
 upper = 100, fit = myfit, dist = "gamma",
 showFittedCDF = TRUE, showQuantiles = TRUE)



## End(Not run)

</code></pre>

<hr>
<h2 id='makeSurvivalTable'>Tabulate Summary Data for Survival Extrapolation</h2><span id='topic+makeSurvivalTable'></span>

<h3>Description</h3>

<p>Tabulates the Kaplan Meier survivor function and within interval hazard at discrete equally spaced time points t_1,...,t_n
&quot;Within interval hazard&quot; is defined as (1-S(t_[n+1])) / S_(t_n), using the Kaplan Meier estimate of S().
The table is intended to be included on a summary sheet provided to experts when eliciting judgements about
extrapolated survival probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSurvivalTable(
  survDf,
  breakTime,
  truncationTime,
  timeUnit,
  useWeights = FALSE,
  dp = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeSurvivalTable_+3A_survdf">survDf</code></td>
<td>
<p>data frame with individual patient data. Needs three columns with names
&quot;time&quot;, &quot;event&quot; and &quot;treatment&quot; (in that order). For weighted observations (e.g. 
using propensity scores), include a fourth column &quot;weights&quot;.
Values in the &quot;event&quot; column should be 0 for a censored observation, and 1 otherwise.
The &quot;treatment&quot; column should be included even if there is only one treatment group.</p>
</td></tr>
<tr><td><code id="makeSurvivalTable_+3A_breaktime">breakTime</code></td>
<td>
<p>duration of each time interval</p>
</td></tr>
<tr><td><code id="makeSurvivalTable_+3A_truncationtime">truncationTime</code></td>
<td>
<p>time point for the end of the last interval</p>
</td></tr>
<tr><td><code id="makeSurvivalTable_+3A_timeunit">timeUnit</code></td>
<td>
<p>string variable to give unit of time</p>
</td></tr>
<tr><td><code id="makeSurvivalTable_+3A_useweights">useWeights</code></td>
<td>
<p>set to TRUE if survDf includes column of weights, as described in specification 
of survDf. This column is passed on to survival::survfit() as the case weights.</p>
</td></tr>
<tr><td><code id="makeSurvivalTable_+3A_dp">dp</code></td>
<td>
<p>number of decimal places to display</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with survivor function estimates, 95
and within interval hazard estimates for each time interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sdf &lt;- survival::veteran[, c("time", "status", "trt")]
colnames(sdf) &lt;- c("time", "event", "treatment")
sdf$treatment &lt;- factor(sdf$treatment, labels = c("standard", "test"))
makeSurvivalTable(sdf, breakTime = 50, truncationTime = 250, timeUnit = "months")

## End(Not run)
</code></pre>

<hr>
<h2 id='pdfplots'>Plot fitted population pdfs</h2><span id='topic+pdfplots'></span>

<h3>Description</h3>

<p>Plot fitted population pdfs at combinations of two different values of the population mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdfplots(
  medianfit,
  precisionfit,
  alpha = 0.05,
  tails = 0.05,
  lower = NA,
  upper = NA,
  n.x = 100,
  d = "best",
  fontsize = 18
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdfplots_+3A_medianfit">medianfit</code></td>
<td>
<p>The output of a <code>fitdist</code> command following elicitation
of the expert's beliefs about the population median.</p>
</td></tr>
<tr><td><code id="pdfplots_+3A_precisionfit">precisionfit</code></td>
<td>
<p>The output of a <code>fitdist</code> command following elicitation
of the expert's beliefs about the population precision.</p>
</td></tr>
<tr><td><code id="pdfplots_+3A_alpha">alpha</code></td>
<td>
<p>Value between 0 and 1 to determine choice of means and variances used in plots</p>
</td></tr>
<tr><td><code id="pdfplots_+3A_tails">tails</code></td>
<td>
<p>Value between 0 and 1 to determine the tail area shown in the pdf plots</p>
</td></tr>
<tr><td><code id="pdfplots_+3A_lower">lower</code></td>
<td>
<p>lower limit on the x-axis for plotting.</p>
</td></tr>
<tr><td><code id="pdfplots_+3A_upper">upper</code></td>
<td>
<p>upper limit on the x-axis for plotting.</p>
</td></tr>
<tr><td><code id="pdfplots_+3A_n.x">n.x</code></td>
<td>
<p>The number of points on the x-axis at which the pdf is plotted.</p>
</td></tr>
<tr><td><code id="pdfplots_+3A_d">d</code></td>
<td>
<p>The fitted distribution for the population median. Can be one of &quot;normal&quot;,
&quot;lognormal&quot; or &quot;best&quot;, where &quot;best&quot; will select the best fitting out of 
normal and lognormal.</p>
</td></tr>
<tr><td><code id="pdfplots_+3A_fontsize">fontsize</code></td>
<td>
<p>Font size used in the plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four pdfs are plotted, using each combination of the <code>alpha</code>/2 and 1-<code>alpha</code>/2
quantiles of the fitted distributions for the population median and standard deviation
</p>


<h3>Value</h3>

<p>A plot and a list, containing
</p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>The two population mean values used in the plots.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The two population standard deviation values used in the plots.</p>
</td></tr>
</table>


<h3>References</h3>

<p><code>multiplot</code> function obtained from
<a href="http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/">http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
prfit &lt;- fitprecision(interval = c(60, 70), propvals = c(0.2, 0.4), trans = "log")
medianfit &lt;- fitdist(vals = c(50, 60, 70), probs = c(0.05, 0.5,  0.95), lower = 0)
pdfplots(medianfit, prfit, alpha = 0.01)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='plinearpool'>Probabilities quantiles and samples from a (weighted) linear pool</h2><span id='topic+plinearpool'></span><span id='topic+qlinearpool'></span><span id='topic+rlinearpool'></span>

<h3>Description</h3>

<p>Calculates a linear pool given a set of elicited judgements in a <code>fit</code>
object. Then calculates required probabilities or quantiles from the pooled
cumulative distribution function, or generates a random sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plinearpool(fit, x, d = "best", w = 1)
qlinearpool(fit, q, d = "best", w = 1)
rlinearpool(fit, n, d = "best", w = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plinearpool_+3A_fit">fit</code></td>
<td>
<p>The output of a <code>fitdist</code> command.</p>
</td></tr>
<tr><td><code id="plinearpool_+3A_x">x</code></td>
<td>
<p>A vector of required cumulative probabilities P(X&lt;=x)</p>
</td></tr>
<tr><td><code id="plinearpool_+3A_d">d</code></td>
<td>
<p>Scalar or vector of distributions to use for each expert.
Options for each vector element are <code>"hist"</code>, <code>"normal"</code>, <code>"t"</code>,
<code>"gamma"</code>, <code>"lognormal"</code>, <code>"logt"</code>,<code>"beta"</code>,
<code>"best"</code>. If given as a scalar, same choice is used for all experts.</p>
</td></tr>
<tr><td><code id="plinearpool_+3A_w">w</code></td>
<td>
<p>A vector of weights to be used in the weighted linear pool.</p>
</td></tr>
<tr><td><code id="plinearpool_+3A_q">q</code></td>
<td>
<p>A vector of required quantiles</p>
</td></tr>
<tr><td><code id="plinearpool_+3A_n">n</code></td>
<td>
<p>Number of random samples from the linear pool</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantiles are calculate by first calculating the pooled cumulative
distribution function at 100 points, and then using linear interpolation to
invert the CDF.
</p>


<h3>Value</h3>

<p>A probability or quantile, calculate from a (weighted) linear pool
(arithmetic mean) of the experts' individual fitted probability.
</p>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Expert 1 states P(X&lt;30)=0.25, P(X&lt;40)=0.5, P(X&lt;50)=0.75
# Expert 2 states P(X&lt;20)=0.25, P(X&lt;25)=0.5, P(X&lt;35)=0.75
# Both experts state 0&lt;X&lt;100.

v &lt;- matrix(c(30, 40, 50, 20, 25, 35), 3, 2)
p &lt;- c(0.25, 0.5, 0.75)
myfit &lt;- fitdist(vals = v, probs = p, lower = 0, upper = 100)

plinearpool(myfit, x=c(20, 50, 80))
qlinearpool(myfit, q=c(0.05, 0.5, 0.95))

# give more weight to first expert
plinearpool(myfit, x=c(20, 50, 80), w=c(0.7, 0.3)) 

# force the use of gamma distributions for each expert
qlinearpool(myfit, q=c(0.05, 0.5, 0.95), d="gamma") 

## End(Not run)
</code></pre>

<hr>
<h2 id='plotConditionalDensities'>Plot density of the target variable, conditional on the extension variable</h2><span id='topic+plotConditionalDensities'></span>

<h3>Description</h3>

<p>Plots kernel density estimates of the target variable, conditional on 
each of a set of specified values of the extension variable. The plot
makes use of the function <code>ggridges::geom_density_ridges()</code>, and so
uses kernel density estimates rather than the exact conditional density 
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConditionalDensities(
  y,
  fitX,
  yCP,
  xMed,
  medianY,
  link = "identity",
  dist = "best",
  N = 1e+05,
  xLimits = NULL,
  fs = 12
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotConditionalDensities_+3A_y">y</code></td>
<td>
<p>vector of values for the extension variable
at which to condition on.</p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_fitx">fitX</code></td>
<td>
<p>an object of class <code>elicitation</code> specifying the
c-distribution: the distribution of the target variable, conditional on the
extension variable taking its median value.</p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_ycp">yCP</code></td>
<td>
<p>vector of conditioning points for the extension variable.</p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_xmed">xMed</code></td>
<td>
<p>vector of medians of the target variable, corresponding to
each value of the extension variable in <code>yCP</code>.</p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_mediany">medianY</code></td>
<td>
<p>the median value of the extension variable.</p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_link">link</code></td>
<td>
<p>link in the median function. One of <code>"identity"</code>,
<code>"log"</code> or <code>"logit"</code></p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_dist">dist</code></td>
<td>
<p>choice of parametric distribution for the c-distribution. Options are
<code>"normal"</code>, <code>"t"</code>, <code>"gamma"</code>, <code>"lognormal"</code>,
<code>"logt"</code>,<code>"beta"</code>, <code>"hist"</code> (for a histogram fit), and
<code>"best"</code> (for best fitting).</p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_n">N</code></td>
<td>
<p>sample size used in the kernel density estimate</p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_xlimits">xLimits</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
<tr><td><code id="plotConditionalDensities_+3A_fs">fs</code></td>
<td>
<p>font size</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

myfitX &lt;- fitdist(vals = c(5.5, 9, 14),
 probs = c(0.25, 0.5, 0.75),
 lower = 0)

plotConditionalDensities(y = c(2, 6, 10),
 fitX = myfitX,
 yCP = c(3, 5, 7, 9.5, 13.5),
 xMed = c(2, 6.5, 9, 13, 20),
 medianY = 7,
 link = "log",
 dist = "lognormal",
 xLimits = c(0, 60))

  
# Example with the logit link

myfitXlogit &lt;- fitdist(vals = c(0.2, 0.25, 0.3),
 probs = c(0.25, 0.5, 0.75),
 lower = 0, 
 upper = 1)
 
 plotConditionalDensities(y = c(2, 6, 10),
  fitX = myfitXlogit, 
  yCP = c(2, 4, 6, 8, 10),
  xMed = c(0.1, 0.3, 0.5, 0.7, 0.9),
  medianY = 6,
  link = "logit",
  dist = "beta")
 

## End(Not run)

</code></pre>

<hr>
<h2 id='plotConditionalMedianFunction'>Plot the conditional median function</h2><span id='topic+plotConditionalMedianFunction'></span>

<h3>Description</h3>

<p>Produces a plot of the conditional median function, given a set of 
conditioning points for the extension variable, a set of corresponding
medians of the target variable, given the extension variable, and a choice
of link. The identity link is the default, a log link can be used for 
non-negative target variables, and a logit link can be used for target 
variables constrained to lie between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConditionalMedianFunction(
  yCP,
  xMed,
  yLimits = NULL,
  link = "identity",
  xlab = "Y",
  ylab = "median of X given Y",
  fs = 12,
  ybreaks = NULL,
  xbreaks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotConditionalMedianFunction_+3A_ycp">yCP</code></td>
<td>
<p>vector of conditioning points for the extension variable.</p>
</td></tr>
<tr><td><code id="plotConditionalMedianFunction_+3A_xmed">xMed</code></td>
<td>
<p>vector of medians of the target variable, corresponding to
each value of the extension variable in <code>yCP</code>.</p>
</td></tr>
<tr><td><code id="plotConditionalMedianFunction_+3A_ylimits">yLimits</code></td>
<td>
<p>limits for the extension variable, used to set the axis limits
in the plot</p>
</td></tr>
<tr><td><code id="plotConditionalMedianFunction_+3A_link">link</code></td>
<td>
<p>link in the median function. One of <code>"identity"</code>,
<code>"log"</code> or <code>"logit"</code>.</p>
</td></tr>
<tr><td><code id="plotConditionalMedianFunction_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plotConditionalMedianFunction_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="plotConditionalMedianFunction_+3A_fs">fs</code></td>
<td>
<p>font size</p>
</td></tr>
<tr><td><code id="plotConditionalMedianFunction_+3A_ybreaks">ybreaks</code></td>
<td>
<p>tick marks on the y-axis</p>
</td></tr>
<tr><td><code id="plotConditionalMedianFunction_+3A_xbreaks">xbreaks</code></td>
<td>
<p>tick marks on the axis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plotConditionalMedianFunction(yCP = c(3, 5, 7, 9.5, 13.5),
 xMed = c(2, 6.5, 9, 13, 20),
 yLimits = c(0, 20),
 link = "log")
 
plotConditionalMedianFunction(yCP = c(2, 4, 6, 8, 10),
 xMed = c(0.1, 0.3, 0.5, 0.7, 0.9),
 yLimits = c(0, 15),
 link = "logit")
 

## End(Not run)

</code></pre>

<hr>
<h2 id='plotfit'>Plot the fitted density function for one or more experts</h2><span id='topic+plotfit'></span>

<h3>Description</h3>

<p>Plots the fitted density function for one or more experts. Can also plot a
fitted linear pool if more than one expert. If plotting the density function
of one expert, or the linear pool only, can also indicated desired lower and
upper fitted quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotfit(
  fit,
  d = "best",
  xl = -Inf,
  xu = Inf,
  yl = 0,
  yu = NA,
  ql = NA,
  qu = NA,
  lp = FALSE,
  ex = NA,
  sf = 3,
  ind = TRUE,
  lpw = 1,
  fs = 12,
  lwd = 1,
  xlab = "x",
  ylab = expression(f[X](x)),
  legend_full = TRUE,
  percentages = FALSE,
  returnPlot = FALSE,
  showPlot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotfit_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>elicitation</code>.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_d">d</code></td>
<td>
<p>The distribution fitted to each expert's probabilities. Options are
<code>"normal"</code>, <code>"t"</code>, <code>"skewnormal"</code>, <code>"gamma"</code>, <code>"lognormal"</code>,
<code>"logt"</code>,<code>"beta"</code>, <code>"mirrorgamma"</code>,
<code>"mirrorlognormal"</code>, <code>"mirrorlogt"</code> <code>"hist"</code> (for a histogram fit), and
<code>"best"</code> (for best fitting)</p>
</td></tr>
<tr><td><code id="plotfit_+3A_xl">xl</code></td>
<td>
<p>The lower limit for the x-axis. The default is the 0.001 quantile
of the fitted distribution (or the 0.001 quantile of a fitted normal
distribution, if a histogram fit is chosen).</p>
</td></tr>
<tr><td><code id="plotfit_+3A_xu">xu</code></td>
<td>
<p>The upper limit for the x-axis. The default is the 0.999 quantile
of the fitted distribution (or the 0.999 quantile of a fitted normal
distribution, if a histogram fit is chosen).</p>
</td></tr>
<tr><td><code id="plotfit_+3A_yl">yl</code></td>
<td>
<p>The lower limit for the y-axis. Default value is 0.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_yu">yu</code></td>
<td>
<p>The upper limit for the y-axis. Will be set automatically if not specified.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_ql">ql</code></td>
<td>
<p>A lower quantile to be indicated on the density function plot.
Only displayed when plotting the density function for a single expert.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_qu">qu</code></td>
<td>
<p>An upper quantile to be indicated on the density function plot.
Only displayed when plotting the density function for a single expert.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_lp">lp</code></td>
<td>
<p>For multiple experts, set <code>lp = TRUE</code> to plot a linear pool.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_ex">ex</code></td>
<td>
<p>If judgements have been elicited from multiple experts, but a
density plot for one expert only is required, the expert to be used in the
plot.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_sf">sf</code></td>
<td>
<p>The number of significant figures to be displayed for the
parameter values.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_ind">ind</code></td>
<td>
<p>If plotting a linear pool, set <code>ind = FALSE</code> to suppress
plotting of the individual density functions.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_lpw">lpw</code></td>
<td>
<p>A vector of weights to be used in linear pool, if unequal
weighting is desired.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_fs">fs</code></td>
<td>
<p>The font size used in the plot.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_lwd">lwd</code></td>
<td>
<p>The line width used in the plot.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_xlab">xlab</code></td>
<td>
<p>A string or expression giving the x-axis label.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_ylab">ylab</code></td>
<td>
<p>A string or expression giving the y-axis label.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_legend_full">legend_full</code></td>
<td>
<p>If plotting a linear pool, set <code>ind = TRUE</code> for each expert
to be plotted with a different colour, and <code>ind = FALSE</code> for each expert to be 
plotted with the same colour, reducing the legend size.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_percentages">percentages</code></td>
<td>
<p>Set to <code>TRUE</code> to use percentages on the x-axis.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_returnplot">returnPlot</code></td>
<td>
<p>Set to <code>TRUE</code> to return the plot as a ggplot object.</p>
</td></tr>
<tr><td><code id="plotfit_+3A_showplot">showPlot</code></td>
<td>
<p>Set to <code>FALSE</code> to suppress displaying the plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Two experts
# Expert 1 states P(X&lt;30)=0.25, P(X&lt;40)=0.5, P(X&lt;50)=0.75
# Expert 2 states P(X&lt;20)=0.25, P(X&lt;25)=0.5, P(X&lt;35)=0.75
# Both experts state 0&lt;X&lt;100. 

v &lt;- matrix(c(30, 40, 50, 20, 25, 35), 3, 2)
p &lt;- c(0.25, 0.5, 0.75)
myfit &lt;- fitdist(vals = v, probs = p, lower = 0, upper = 100)

# Plot both fitted densities, using the best fitted distribution
plotfit(myfit)

# Plot a fitted beta distribution for expert 2, and show 5th and 95th percentiles
plotfit(myfit, d = "beta", ql = 0.05, qu = 0.95, ex = 2)


# Plot a linear pool, giving double weight to expert 1
plotfit(myfit,  lp = T, lpw = c(2,1))


# Plot a linear pool, giving double weight to expert 1, 
# show 5th and 95th percentiles, surpress plotting of individual distributions, 
# and force use of Beta distributions
plotfit(myfit, d = "beta",  lp = T, lpw = c(2,1), ql = 0.05, qu = 0.95, ind=FALSE )

## End(Not run)
</code></pre>

<hr>
<h2 id='plotQuartiles'>Plot elicited quartiles, median and plausible range for each expert</h2><span id='topic+plotQuartiles'></span>

<h3>Description</h3>

<p>Displays a horizontal bar for each expert, to represent the expert's plausible range.
The coloured sections indicate the experts' quartiles: four intervals judged by the expert
to be equally likely. The experts' medians are shown as dashed lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQuartiles(
  vals,
  lower,
  upper,
  fs = 12,
  expertnames = NULL,
  xl = NULL,
  xlabel = "X"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotQuartiles_+3A_vals">vals</code></td>
<td>
<p>a matrix of elicited quartiles and medians: one column per expert, first 
row is the 25th percentile, 2nd row is the median, last row is the 75th percentile.</p>
</td></tr>
<tr><td><code id="plotQuartiles_+3A_lower">lower</code></td>
<td>
<p>a vector of lower plausible limits: one per expert</p>
</td></tr>
<tr><td><code id="plotQuartiles_+3A_upper">upper</code></td>
<td>
<p>a vector of upper plausible limits: one per expert</p>
</td></tr>
<tr><td><code id="plotQuartiles_+3A_fs">fs</code></td>
<td>
<p>font size to be used in the plot</p>
</td></tr>
<tr><td><code id="plotQuartiles_+3A_expertnames">expertnames</code></td>
<td>
<p>vector of experts' names</p>
</td></tr>
<tr><td><code id="plotQuartiles_+3A_xl">xl</code></td>
<td>
<p>vector of limits for x-axis</p>
</td></tr>
<tr><td><code id="plotQuartiles_+3A_xlabel">xlabel</code></td>
<td>
<p>x-axis label</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
l &lt;- c(2, 1, 5, 1)
u &lt;- c(95, 90, 65, 40)
v &lt;- matrix(c(15, 25, 40,
 10, 20, 40,
 10, 15, 25,
 5, 10, 20),
 3, 4)
plotQuartiles(vals = v, lower = l, upper  = u)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotTertiles'>Plot elicted tertiles, median and plausible range for each expert</h2><span id='topic+plotTertiles'></span>

<h3>Description</h3>

<p>Displays a horizontal bar for each expert, to represent the expert's plausible range.
The coloured sections indicate the experts' tertiles: three intervals judged by the expert
to be equally likely. The experts' medians are shown as dashed lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTertiles(
  vals,
  lower,
  upper,
  fs = 12,
  percentages = FALSE,
  expertnames = NULL,
  xl = NULL,
  xlabel = "X"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTertiles_+3A_vals">vals</code></td>
<td>
<p>a matrix of elicited tertiles and medians: one column per expert, first 
row is the 33rd percentile, 2nd row is the median, last row is the 66th percentile.</p>
</td></tr>
<tr><td><code id="plotTertiles_+3A_lower">lower</code></td>
<td>
<p>a vector of lower plausible limits: one per expert</p>
</td></tr>
<tr><td><code id="plotTertiles_+3A_upper">upper</code></td>
<td>
<p>a vector of upper plausible limits: one per expert</p>
</td></tr>
<tr><td><code id="plotTertiles_+3A_fs">fs</code></td>
<td>
<p>font size to be used in the plot</p>
</td></tr>
<tr><td><code id="plotTertiles_+3A_percentages">percentages</code></td>
<td>
<p>set to <code>TRUE</code> to use percentages on the x-axis</p>
</td></tr>
<tr><td><code id="plotTertiles_+3A_expertnames">expertnames</code></td>
<td>
<p>vector of experts' names</p>
</td></tr>
<tr><td><code id="plotTertiles_+3A_xl">xl</code></td>
<td>
<p>vector of limits for x-axis</p>
</td></tr>
<tr><td><code id="plotTertiles_+3A_xlabel">xlabel</code></td>
<td>
<p>x-axis label</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy Oakley &lt;j.oakley@sheffield.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
l &lt;- c(-5, 0, 5, -10)
u &lt;- c(15, 35, 50, 35)
v &lt;- matrix(c(5, 8, 10,
 10, 15, 20,
 15, 18, 25,
 10, 20, 30),
 3, 4)
plotTertiles(vals = v, lower = l, upper  = u)

## End(Not run)
</code></pre>

<hr>
<h2 id='sampleFit'>Sample from the elicited distributions</h2><span id='topic+sampleFit'></span>

<h3>Description</h3>

<p>Generates a random sample from all distributions specified
within an object of class <code>elicitation</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleFit(fit, n, expert = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleFit_+3A_fit">fit</code></td>
<td>
<p>An object of class elicitation</p>
</td></tr>
<tr><td><code id="sampleFit_+3A_n">n</code></td>
<td>
<p>The required sample size for each elicitation</p>
</td></tr>
<tr><td><code id="sampleFit_+3A_expert">expert</code></td>
<td>
<p>Specify which expert's distributions to sample 
from, if multiple experts' judgements have been elicited.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of sampled values, one column per distribution.
Column names are given to label the distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
v &lt;- c(20,30,50)
p &lt;- c(0.25,0.5,0.75)
myfit &lt;- fitdist(vals = v, probs = p, lower = 0, upper = 100)
sampleFit(myfit, n = 10)

## End(Not run)

</code></pre>

<hr>
<h2 id='sampleMarginalFit'>Sample from the marginal distribution of the target variable</h2><span id='topic+sampleMarginalFit'></span>

<h3>Description</h3>

<p>As part of the Extension Method, this function will generate a random 
sample from the marginal distribution of the target variable, using
a sample from the marginal distribution of the extension variable, 
the specified c-distribution, and the appropriate judgements used to
construct the median model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleMarginalFit(
  fitX,
  sampleY,
  medianY,
  yCP,
  xMed,
  dist = "best",
  link = "identity"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleMarginalFit_+3A_fitx">fitX</code></td>
<td>
<p>an object of class <code>elicitation</code> specifying the
c-distribution: the distribution of the target variable, conditional on the
extension variable taking its median value.</p>
</td></tr>
<tr><td><code id="sampleMarginalFit_+3A_sampley">sampleY</code></td>
<td>
<p>a sample from the marginal distribution of the extension 
variable.</p>
</td></tr>
<tr><td><code id="sampleMarginalFit_+3A_mediany">medianY</code></td>
<td>
<p>the median value of the extension variable.</p>
</td></tr>
<tr><td><code id="sampleMarginalFit_+3A_ycp">yCP</code></td>
<td>
<p>vector of conditioning points for the extension variable.</p>
</td></tr>
<tr><td><code id="sampleMarginalFit_+3A_xmed">xMed</code></td>
<td>
<p>vector of medians of the target variable, corresponding to
each value of the extension variable in <code>yCP</code>.</p>
</td></tr>
<tr><td><code id="sampleMarginalFit_+3A_dist">dist</code></td>
<td>
<p>choice of parametric distribution for the c-distribution. Options are
<code>"normal"</code>, <code>"t"</code>, <code>"gamma"</code>, <code>"lognormal"</code>,
<code>"logt"</code>,<code>"beta"</code>, <code>"hist"</code> (for a histogram fit), and
<code>"best"</code> (for best fitting).</p>
</td></tr>
<tr><td><code id="sampleMarginalFit_+3A_link">link</code></td>
<td>
<p>link in the median function. One of <code>"identity"</code>,
<code>"log"</code> or <code>"logit"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing a sample from the marginal distribution of 
the target variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

myfitX &lt;- fitdist(vals = c(5.5, 9, 14),
 probs = c(0.25, 0.5, 0.75),
 lower = 0)
ry &lt;- rgamma(10, 5.19, 0.694)
sampleMarginalFit(fitX = myfitX, 
 sampleY = ry,
 medianY = 7,
 yCP = c(3, 5, 7, 9.5, 13.5),
 xMed = c(2, 6.5, 9, 13, 20),
 dist = "lognormal",
 link = "log")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='survivalExtrapolatePlot'>Plot survival data and elicited extrapolated intervals</h2><span id='topic+survivalExtrapolatePlot'></span>

<h3>Description</h3>

<p>Show Kaplan-Meier plot of available data, and credible
interval for extrapolated survivor function value S(T)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survivalExtrapolatePlot(
  survDf,
  myfit1,
  myfit2 = NULL,
  fqDist1 = "best",
  fqDist2 = NULL,
  tTruncate = max(survDf$time),
  tTarget,
  alpha = 0.95,
  useWeights = FALSE,
  groups = levels(survDf$treatment),
  xl = "Time (t)",
  fontsize = 12,
  breakTime = NULL,
  showPlot = TRUE,
  returnPlot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survivalExtrapolatePlot_+3A_survdf">survDf</code></td>
<td>
<p>data frame with individual patient data. Needs three columns with names
&quot;time&quot;, &quot;event&quot; and &quot;treatment&quot; (in that order). For weighted observations (e.g. 
using propensity scores), include a fourth column &quot;weights&quot;.
Values in the &quot;event&quot; column should be 0 for a censored observation, and 1 otherwise.
The &quot;treatment&quot; column should be included even if there is only one treatment group, and defined
as a factor variable.</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_myfit1">myfit1</code></td>
<td>
<p>object of class <code>elicitation</code>, obtained from <code>fitdist</code> function with
elicited judgements for the first treatment group.</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_myfit2">myfit2</code></td>
<td>
<p>object of class <code>elicitation</code>, obtained from <code>fitdist</code> function with
elicited judgements for the second treatment group, if there is on.</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_fqdist1">fqDist1</code></td>
<td>
<p>fitted distribution family for first treatment group. Options are
<code>"normal"</code>, <code>"t"</code>, <code>"skewnormal"</code>, <code>"gamma"</code>, <code>"lognormal"</code>,
<code>"logt"</code>,<code>"beta"</code>, <code>"mirrorgamma"</code>,
<code>"mirrorlognormal"</code>, <code>"mirrorlogt"</code> <code>"hist"</code> (for a histogram fit), and
<code>"best"</code> (for best fitting)</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_fqdist2">fqDist2</code></td>
<td>
<p>fitted distribution family for second treatment group if there is one. Options are
<code>"normal"</code>, <code>"t"</code>, <code>"skewnormal"</code>, <code>"gamma"</code>, <code>"lognormal"</code>,
<code>"logt"</code>,<code>"beta"</code>, <code>"mirrorgamma"</code>,
<code>"mirrorlognormal"</code>, <code>"mirrorlogt"</code> <code>"hist"</code> (for a histogram fit), and
<code>"best"</code> (for best fitting)</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_ttruncate">tTruncate</code></td>
<td>
<p>Optional argument to censor all observations at this time point.</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_ttarget">tTarget</code></td>
<td>
<p>Target time for extrapolation: judgements are elicited at S(t = tTarget)</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_alpha">alpha</code></td>
<td>
<p>Size of probability interval to plot (100*<code>alpha</code>% interval).</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_useweights">useWeights</code></td>
<td>
<p>set to TRUE if survDf includes column of weights, as described in specification 
of survDf. This column is passed on to survival::survfit() as the case weights.</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_groups">groups</code></td>
<td>
<p>Vector of strings for the group labels. Will be extracted from factor levels of
<code>treatment</code> column in <code>survDf</code>.</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_xl">xl</code></td>
<td>
<p>x-axis label in plot</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_fontsize">fontsize</code></td>
<td>
<p>font size in plot</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_breaktime">breakTime</code></td>
<td>
<p>Optional argument to specify tick mark spacing on x-axis</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_showplot">showPlot</code></td>
<td>
<p>set to TRUE to display the plot</p>
</td></tr>
<tr><td><code id="survivalExtrapolatePlot_+3A_returnplot">returnPlot</code></td>
<td>
<p>set to TRUE to return the plot as a ggplot object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object, if returnPlot is TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sdf &lt;- survival::veteran[, c("time", "status", "trt")]
colnames(sdf) &lt;- c("time", "event", "treatment")
sdf$treatment &lt;- factor(sdf$treatment, labels = c("standard", "test"))

sdf &lt;- survival::veteran[, c("time", "status", "trt")]
colnames(sdf) &lt;- c("time", "event", "treatment")
sdf$treatment &lt;- factor(sdf$treatment, labels = c("standard", "test"))
groupStandardElicitation &lt;- fitdist(vals = c(0.15, 0.2, 0.25),
                                    probs = c(0.25, 0.5, 0.75),
                                    lower = 0,
                                    upper = 1)

groupTestElicitation &lt;- fitdist(vals = c(0.1, 0.15, 0.2),
                                probs = c(0.25, 0.5, 0.75),
                                lower = 0,
                                upper = 1)

survivalExtrapolatePlot(sdf,
                        myfit1 = groupStandardElicitation,
                        myfit2 = groupTestElicitation,
                        fqDist1 = "beta",
                        fqDist2 = "beta",
                        tTruncate = 150,
                        tTarget=200,
                        alpha = 0.95)

## End(Not run)
</code></pre>

<hr>
<h2 id='survivalModelExtrapolations'>Compare Multiple Fitted Models for Survival Extrapolation</h2><span id='topic+survivalModelExtrapolations'></span>

<h3>Description</h3>

<p>Fits seven parametric models to an individual patient survival data set (using the <code>flexsurv</code>
package), 
displays extrapolations, and report the time point at which there is the
widest range in estimated extrapolated survival probabilities. This function is intended to be used
only as an informal exploratory tool to support elicitation for survival extrapolation,
specifically, to inform the choice of target extrapolation time. The fitted models 
are exponential, weibull, gamma, gompertz, log logistic, log normal and geneneralised gamma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survivalModelExtrapolations(
  survDf,
  tOffset = 0,
  tEnd,
  group,
  tTruncate = NULL,
  dists = c("exp", "weibull", "gamma", "gompertz", "llogis", "lnorm", "gengamma"),
  nModels = length(dists),
  showPlot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survivalModelExtrapolations_+3A_survdf">survDf</code></td>
<td>
<p>data frame with individual patient data. Require to be a .csv file with
three columns: &quot;time&quot;, &quot;event&quot; and &quot;treatment&quot; (in that order).
Values in the &quot;event&quot; column should be 0 for a censored observation, and 1 otherwise.
The&quot;treatment&quot; column should be included even if there is only one treatment group.'</p>
</td></tr>
<tr><td><code id="survivalModelExtrapolations_+3A_toffset">tOffset</code></td>
<td>
<p>discard observations with time less than this value, and fit survival 
distributions to <code>survDf$time - tOffset</code>.</p>
</td></tr>
<tr><td><code id="survivalModelExtrapolations_+3A_tend">tEnd</code></td>
<td>
<p>the maximum time point for extrapolation</p>
</td></tr>
<tr><td><code id="survivalModelExtrapolations_+3A_group">group</code></td>
<td>
<p>character variable to select treatment group: one of the levels in the
factor variable survDf$treatment</p>
</td></tr>
<tr><td><code id="survivalModelExtrapolations_+3A_ttruncate">tTruncate</code></td>
<td>
<p>optional argument: time point at which to censor all observations</p>
</td></tr>
<tr><td><code id="survivalModelExtrapolations_+3A_dists">dists</code></td>
<td>
<p>character vector of distributions to fit. Default is <code>c("exp", "weibull",
"gamma", "gompertz", "llogis", "lnorm", "gengamma")</code> corresponding to the distributions listed
above; can choose a subset of this.</p>
</td></tr>
<tr><td><code id="survivalModelExtrapolations_+3A_nmodels">nModels</code></td>
<td>
<p>how many fitted models to plot, up to a maximum of 7, chosen by lowest AIC
value. Default is <code>length(dists)</code>.</p>
</td></tr>
<tr><td><code id="survivalModelExtrapolations_+3A_showplot">showPlot</code></td>
<td>
<p>whether to display the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the elements
</p>
<table role = "presentation">
<tr><td><code>KMplot</code></td>
<td>
<p>a ggplot2 plot object;</p>
</td></tr>
<tr><td><code>tMaxRange</code></td>
<td>
<p>the time point at which there is the greatest difference between the largest
and smallest extrapolated survival probability (if more than one distribution fitted);</p>
</td></tr>
<tr><td><code>modelAIC</code></td>
<td>
<p>the AIC for each fitted model.</p>
</td></tr> 
<tr><td><code>lclExtrapolate; uclExtrapolate</code></td>
<td>
<p>pointwise 95 percent confidence interval for extrapolated survivor functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Make a data frame using the survival::veteran data frame
sdf &lt;- survival::veteran[, c("time", "status", "trt")]
colnames(sdf) &lt;- c("time", "event", "treatment")
sdf$treatment &lt;- factor(sdf$treatment, labels = c("standard", "test"))

survivalModelExtrapolations(sdf, tEnd = 1000, group = "test", tTruncate = 100)

## End(Not run)
</code></pre>

<hr>
<h2 id='survivalScenario'>Scenario Testing for Survival Extrapolation</h2><span id='topic+survivalScenario'></span>

<h3>Description</h3>

<p>Provides a plot and approximate 95
extrapolated surival time, based on a assumption of constant hazard 
after some specified time. Intended to be used as part of the SHELF protocol
for elicitation for survival extrapolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survivalScenario(
  tLower = 0,
  tUpper,
  expLower,
  expUpper,
  tTarget,
  survDf,
  groups = unique(survDf$treatment),
  expGroup = unique(survDf$treatment)[1],
  useWeights = FALSE,
  xl = "Time",
  fontsize = 12,
  showPlot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survivalScenario_+3A_tlower">tLower</code></td>
<td>
<p>lower limit for x-axis.</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_tupper">tUpper</code></td>
<td>
<p>upper limit for x-axis.</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_explower">expLower</code></td>
<td>
<p>start time at which constant hazard is assumed.</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_expupper">expUpper</code></td>
<td>
<p>end time for using data to estimate constant hazard;
data after this time will be censored.</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_ttarget">tTarget</code></td>
<td>
<p>target extrapolation time.</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_survdf">survDf</code></td>
<td>
<p>data frame with individual patient data. Needs three columns with names
&quot;time&quot;, &quot;event&quot; and &quot;treatment&quot; (in that order). For weighted observations (e.g. 
using propensity scores), include a fourth column &quot;weights&quot;.
Values in the &quot;event&quot; column should be 0 for a censored observation, and 1 otherwise.
The &quot;treatment&quot; column should be included even if there is only one treatment group.</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_groups">groups</code></td>
<td>
<p>character vector of names of the treatment group. Extracted from survDF by default.</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_expgroup">expGroup</code></td>
<td>
<p>selected treatment group for extrapolating</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_useweights">useWeights</code></td>
<td>
<p>set to TRUE if survDf includes column of weights, as described in specification 
of survDf. This column is passed on to survival::survreg() and survival::survfit() as the case weights.</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_xl">xl</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_fontsize">fontsize</code></td>
<td>
<p>plot fontsize</p>
</td></tr>
<tr><td><code id="survivalScenario_+3A_showplot">showPlot</code></td>
<td>
<p>whether to display the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the elements
</p>
<table role = "presentation">
<tr><td><code>KMplot</code></td>
<td>
<p>a ggplot2 plot object;</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>an approximate 95
at the target extrapolation time.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sdf &lt;- survival::veteran[, c("time", "status", "trt")]
colnames(sdf) &lt;- c("time", "event", "treatment")
sdf$treatment &lt;- factor(sdf$treatment, labels = c("standard", "test"))
survivalScenario(tLower = 0,tUpper = 150, expLower = 100, expUpper = 150,
tTarget = 250, survDf = sdf,
expGroup = "standard")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
