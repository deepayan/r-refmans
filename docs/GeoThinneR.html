<!DOCTYPE html><html lang="en-US"><head><title>Help for package GeoThinneR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeoThinneR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assign_coords_to_grid'><p>Assign Geographic Coordinates to Grid Cells</p></a></li>
<li><a href='#brute_force_thinning'><p>Perform Brute Force Thinning</p></a></li>
<li><a href='#caretta'><p>Loggerhead Sea Turtle (<em>Caretta caretta</em>) Occurrences in the Mediterranean Sea</p></a></li>
<li><a href='#grid_thinning'><p>Perform Grid-Based Thinning of Spatial Points</p></a></li>
<li><a href='#kd_tree_thinning'><p>Perform K-D Tree ANN Thinning</p></a></li>
<li><a href='#long_lat_to_cartesian'><p>Convert Geographic Coordinates to Cartesian Coordinates</p></a></li>
<li><a href='#max_thinning_algorithm'><p>Thinning Algorithm for Spatial Data</p></a></li>
<li><a href='#precision_thinning'><p>Precision Thinning of Spatial Points</p></a></li>
<li><a href='#rounding_hashing_thinning'><p>Rounding Hashing Thinning</p></a></li>
<li><a href='#thin_points'><p>Spatial Thinning of Points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simple Spatial Thinning for Ecological and Spatial Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides efficient geospatial thinning algorithms to reduce
    the density of coordinate data while maintaining spatial
    relationships. Implements K-D Tree and brute-force distance-based
    thinning, as well as grid-based and precision-based thinning methods.
    For more information on the methods, see Elseberg et al. (2012)
    <a href="https://hdl.handle.net/10446/86202">https://hdl.handle.net/10446/86202</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmestret/GeoThinneR">https://github.com/jmestret/GeoThinneR</a>,
<a href="https://jmestret.github.io/GeoThinneR/">https://jmestret.github.io/GeoThinneR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmestret/GeoThinneR/issues">https://github.com/jmestret/GeoThinneR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, fields, matrixStats, nabor, Rcpp, stats, terra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, rmarkdown, sf, testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-03 13:23:51 UTC; jorge</td>
</tr>
<tr>
<td>Author:</td>
<td>Jorge Mestre-Tomás
    <a href="https://orcid.org/0000-0002-8983-3417"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jorge Mestre-Tomás &lt;jorge.mestre.tomas@csic.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-03 23:10:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='assign_coords_to_grid'>Assign Geographic Coordinates to Grid Cells</h2><span id='topic+assign_coords_to_grid'></span>

<h3>Description</h3>

<p>This function assigns a set of geographic coordinates (longitude and latitude) to grid cells based on a specified cell size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_coords_to_grid(coords, cell_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_coords_to_grid_+3A_coords">coords</code></td>
<td>
<p>A data frame or matrix with two columns: longitude and latitude.</p>
</td></tr>
<tr><td><code id="assign_coords_to_grid_+3A_cell_size">cell_size</code></td>
<td>
<p>Numeric value representing the size of each grid cell, typically in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of grid cell identifiers, where each identifier is formatted as &quot;x_y&quot;, representing the grid cell coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords &lt;- data.frame(long = c(-122.4194, 0), lat = c(37.7749, 0))
cell_size &lt;- 1
assign_coords_to_grid(coords, cell_size)
</code></pre>

<hr>
<h2 id='brute_force_thinning'>Perform Brute Force Thinning</h2><span id='topic+brute_force_thinning'></span>

<h3>Description</h3>

<p>This function applies a brute force algorithm to thin a set of spatial coordinates, attempting to maximize the number of points retained while ensuring a minimum distance ('thin_dist') between any two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brute_force_thinning(
  coordinates,
  thin_dist = 10,
  trials = 10,
  all_trials = FALSE,
  target_points = NULL,
  euclidean = FALSE,
  R = 6371
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brute_force_thinning_+3A_coordinates">coordinates</code></td>
<td>
<p>A numeric matrix or data frame with two columns representing longitude and latitude (or XY coordinates if 'euclidean = TRUE').</p>
</td></tr>
<tr><td><code id="brute_force_thinning_+3A_thin_dist">thin_dist</code></td>
<td>
<p>Numeric value representing the thinning distance in kilometers (default: 10 km).</p>
</td></tr>
<tr><td><code id="brute_force_thinning_+3A_trials">trials</code></td>
<td>
<p>Integer specifying the number of trials to run for thinning (default: 10).</p>
</td></tr>
<tr><td><code id="brute_force_thinning_+3A_all_trials">all_trials</code></td>
<td>
<p>Logical value indicating whether to return the results of all trials ('TRUE') or just the best attempt with the most points retained ('FALSE', default).</p>
</td></tr>
<tr><td><code id="brute_force_thinning_+3A_target_points">target_points</code></td>
<td>
<p>Optional integer specifying the number of points to retain. If 'NULL' (default), the function tries to maximize the number of points retained.</p>
</td></tr>
<tr><td><code id="brute_force_thinning_+3A_euclidean">euclidean</code></td>
<td>
<p>Logical value indicating whether to compute the Euclidean distance ('TRUE') or Haversine distance ('FALSE', default).</p>
</td></tr>
<tr><td><code id="brute_force_thinning_+3A_r">R</code></td>
<td>
<p>Numeric value representing the Earth's radius in kilometers (default: 6371 km). Only used if 'euclidean = FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating which points are kept in the best trial if 'all_trials = FALSE'; otherwise, a list of logical vectors for each trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with geographic coordinates (Haversine distance)
coords &lt;- data.frame(
  long = c(-122.4194, -122.4195, -122.4196),
  lat = c(37.7749, 37.7740, 37.7741)
)
coords &lt;- as.matrix(coords)

result &lt;- brute_force_thinning(coords, thin_dist = 0.1, trials = 5)
print(result)

# Example computing Euclidean distance
result_euclidean &lt;- brute_force_thinning(coords, thin_dist = 1, trials = 5, euclidean = TRUE)
print(result_euclidean)
</code></pre>

<hr>
<h2 id='caretta'>Loggerhead Sea Turtle (<em>Caretta caretta</em>) Occurrences in the Mediterranean Sea</h2><span id='topic+caretta'></span>

<h3>Description</h3>

<p>This dataset contains a subset of global occurrences of the Loggerhead Sea Turtle (<em>Caretta caretta</em>), filtered for records in the Mediterranean Sea. The data were sourced from the Global Biodiversity Information Facility (GBIF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("caretta")
</code></pre>


<h3>Format</h3>

<p>A data frame with 6785 rows and 5 columns:
</p>

<dl>
<dt>decimalLongitude</dt><dd><p>Numeric. Longitude coordinates (WGS84).</p>
</dd>
<dt>decimalLatitude</dt><dd><p>Numeric. Latitude coordinates (WGS84).</p>
</dd>
<dt>year</dt><dd><p>Integer. The year in which the occurrence was recorded.</p>
</dd>
<dt>species</dt><dd><p>Character. The scientific name of the species, i.e., <em>Caretta caretta</em>.</p>
</dd>
<dt>coordinateUncertaintyInMeters</dt><dd><p>Numeric. The uncertainty of the coordinates in meters.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset has been filtered to include only records within the Mediterranean Sea. The occurrence data cover multiple years, which provides information on the temporal distribution of the species in this region.
</p>


<h3>Source</h3>

<p>Global Biodiversity Information Facility (GBIF), <a href="https://www.gbif.org/species/8894817">https://www.gbif.org/species/8894817</a>
</p>

<hr>
<h2 id='grid_thinning'>Perform Grid-Based Thinning of Spatial Points</h2><span id='topic+grid_thinning'></span>

<h3>Description</h3>

<p>This function performs thinning of spatial points by assigning them to grid cells based on a specified resolution or thinning distance. It can either create a new raster grid or use an existing raster object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_thinning(
  coordinates,
  thin_dist = NULL,
  resolution = NULL,
  origin = NULL,
  raster_obj = NULL,
  trials = 10,
  all_trials = FALSE,
  crs = "epsg:4326",
  priority = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_thinning_+3A_coordinates">coordinates</code></td>
<td>
<p>A numeric matrix or data frame with two columns representing the x (longitude) and y (latitude) coordinates of the points.</p>
</td></tr>
<tr><td><code id="grid_thinning_+3A_thin_dist">thin_dist</code></td>
<td>
<p>A numeric value representing the thinning distance in kilometers. It will be converted to degrees if 'resolution' is not provided.</p>
</td></tr>
<tr><td><code id="grid_thinning_+3A_resolution">resolution</code></td>
<td>
<p>A numeric value representing the resolution (in degrees) of the raster grid. If provided, this takes priority over 'thin_dist'.</p>
</td></tr>
<tr><td><code id="grid_thinning_+3A_origin">origin</code></td>
<td>
<p>A numeric vector of length 2 (for example, 'c(0, 0)'), specifying the origin of the raster grid (optional).</p>
</td></tr>
<tr><td><code id="grid_thinning_+3A_raster_obj">raster_obj</code></td>
<td>
<p>An optional 'terra' SpatRaster object to use for grid thinning. If provided, the raster object will be used instead of creating a new one.</p>
</td></tr>
<tr><td><code id="grid_thinning_+3A_trials">trials</code></td>
<td>
<p>An integer specifying the number of trials to perform for thinning (default: 10).</p>
</td></tr>
<tr><td><code id="grid_thinning_+3A_all_trials">all_trials</code></td>
<td>
<p>A logical value indicating whether to return results for all trials ('TRUE') or just the first trial ('FALSE', default).</p>
</td></tr>
<tr><td><code id="grid_thinning_+3A_crs">crs</code></td>
<td>
<p>An optional CRS (Coordinate Reference System) to project the coordinates and raster (default WGS84). This can be an EPSG code, a PROJ.4 string, or a 'terra::crs' object.</p>
</td></tr>
<tr><td><code id="grid_thinning_+3A_priority">priority</code></td>
<td>
<p>A of the same length as the number of points with numerical values indicating the priority of each point. Instead of eliminating points randomly, the points are preferred according to these values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of logical vectors indicating which points to keep for each trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Grid thinning using thin_dist
coordinates &lt;- matrix(c(-122.4194, 37.7749,
                        -122.4195, 37.7740,
                        -122.4196, 37.7741), ncol = 2, byrow = TRUE)

result &lt;- grid_thinning(coordinates, thin_dist = 10, trials = 5, all_trials = TRUE)
print(result)

# Example: Grid thinning using a custom resolution
result_res &lt;- grid_thinning(coordinates, resolution = 0.01, trials = 5)
print(result_res)

# Example: Using a custom raster object
library(terra)
rast_obj &lt;- terra::rast(nrows = 100, ncols = 100, xmin = -123, xmax = -121, ymin = 36, ymax = 38)
result_raster &lt;- grid_thinning(coordinates, raster_obj = rast_obj, trials = 5)
print(result_raster)

</code></pre>

<hr>
<h2 id='kd_tree_thinning'>Perform K-D Tree ANN Thinning</h2><span id='topic+kd_tree_thinning'></span>

<h3>Description</h3>

<p>This function applies the K-D tree Approximate Nearest Neighbors (ANN) thinning algorithm on a set of spatial coordinates.
It can optionally use space partitioning to improve the thinning process, which is particularly useful for large datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kd_tree_thinning(
  coordinates,
  thin_dist = 10,
  trials = 10,
  all_trials = FALSE,
  space_partitioning = FALSE,
  euclidean = FALSE,
  R = 6371
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kd_tree_thinning_+3A_coordinates">coordinates</code></td>
<td>
<p>A matrix of coordinates to thin, with two columns representing longitude and latitude.</p>
</td></tr>
<tr><td><code id="kd_tree_thinning_+3A_thin_dist">thin_dist</code></td>
<td>
<p>A numeric value representing the thinning distance in kilometers. Points closer than this distance to each other are considered redundant and may be removed.</p>
</td></tr>
<tr><td><code id="kd_tree_thinning_+3A_trials">trials</code></td>
<td>
<p>An integer specifying the number of trials to run for thinning. Multiple trials can help achieve a better result by randomizing the thinning process. Default is 10.</p>
</td></tr>
<tr><td><code id="kd_tree_thinning_+3A_all_trials">all_trials</code></td>
<td>
<p>A logical value indicating whether to return results of all attempts ('TRUE') or only the best attempt with the most points retained ('FALSE'). Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="kd_tree_thinning_+3A_space_partitioning">space_partitioning</code></td>
<td>
<p>A logical value indicating whether to use space partitioning to divide the coordinates into grid cells before thinning. This can improve efficiency in large datasets. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="kd_tree_thinning_+3A_euclidean">euclidean</code></td>
<td>
<p>Logical value indicating whether to compute the Euclidean distance ('TRUE') or Haversine distance ('FALSE', default).</p>
</td></tr>
<tr><td><code id="kd_tree_thinning_+3A_r">R</code></td>
<td>
<p>A numeric value representing the radius of the Earth in kilometers. The default is 6371 km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. If 'all_trials' is 'FALSE', the list contains a single logical vector indicating which points are kept in the best trial. If 'all_trials' is 'TRUE', the list contains a logical vector for each trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate sample coordinates
set.seed(123)
coordinates &lt;- matrix(runif(20, min = -180, max = 180), ncol = 2) # 10 random points

# Perform K-D Tree thinning without space partitioning
result &lt;- kd_tree_thinning(coordinates, thin_dist = 10, trials = 5, all_trials = FALSE)
print(result)

# Perform K-D Tree thinning with space partitioning
result_partitioned &lt;- kd_tree_thinning(coordinates, thin_dist = 5000, trials = 5,
                                       space_partitioning = TRUE, all_trials = TRUE)
print(result_partitioned)

# Perform K-D Tree thinning with Cartesian coordinates
cartesian_coordinates &lt;- long_lat_to_cartesian(coordinates[, 1], coordinates[, 2])
result_cartesian &lt;- kd_tree_thinning(cartesian_coordinates, thin_dist = 10, trials = 5,
                                     euclidean = TRUE)
print(result_cartesian)

</code></pre>

<hr>
<h2 id='long_lat_to_cartesian'>Convert Geographic Coordinates to Cartesian Coordinates</h2><span id='topic+long_lat_to_cartesian'></span>

<h3>Description</h3>

<p>This function converts geographic coordinates, given as longitude and latitude in degrees, to Cartesian coordinates (x, y, z) assuming a spherical Earth model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long_lat_to_cartesian(long, lat, R = 6371)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="long_lat_to_cartesian_+3A_long">long</code></td>
<td>
<p>Numeric vector of longitudes in degrees.</p>
</td></tr>
<tr><td><code id="long_lat_to_cartesian_+3A_lat">lat</code></td>
<td>
<p>Numeric vector of latitudes in degrees.</p>
</td></tr>
<tr><td><code id="long_lat_to_cartesian_+3A_r">R</code></td>
<td>
<p>Radius of the Earth in kilometers (default: 6371 km).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with three columns (x, y, z) representing Cartesian coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>long &lt;- c(-122.4194, 0)
lat &lt;- c(37.7749, 0)
long_lat_to_cartesian(long, lat)
</code></pre>

<hr>
<h2 id='max_thinning_algorithm'>Thinning Algorithm for Spatial Data</h2><span id='topic+max_thinning_algorithm'></span>

<h3>Description</h3>

<p>This function performs the core thinning algorithm used to reduce the density of points
in spatial data while maintaining spatial representation. It works by iteratively removing
points with the most neighbors until no points with neighbors remain. The algorithm
supports multiple trials to find the optimal thinning solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_thinning_algorithm(neighbor_indices, n, trials, all_trials = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_thinning_algorithm_+3A_neighbor_indices">neighbor_indices</code></td>
<td>
<p>A list of integer vectors where each element contains the indices
of the neighboring points for each point in the dataset.</p>
</td></tr>
<tr><td><code id="max_thinning_algorithm_+3A_n">n</code></td>
<td>
<p>The number of points in the dataset.</p>
</td></tr>
<tr><td><code id="max_thinning_algorithm_+3A_trials">trials</code></td>
<td>
<p>The number of thinning trials to run.</p>
</td></tr>
<tr><td><code id="max_thinning_algorithm_+3A_all_trials">all_trials</code></td>
<td>
<p>If TRUE, returns the results of all trials; if FALSE, returns the best
trial with the most points retained (default: FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of logical vectors indicating which points are kept in each trial if
all_trials is TRUE; otherwise, a single logical vector indicating the points kept
in the best trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage within a larger thinning function
neighbor_indices &lt;- list(c(2, 3), c(1, 3), c(1, 2))
n &lt;- 3
trials &lt;- 5
all_trials &lt;- FALSE
keep_points &lt;- max_thinning_algorithm(neighbor_indices, n, trials, all_trials)
print(keep_points)
</code></pre>

<hr>
<h2 id='precision_thinning'>Precision Thinning of Spatial Points</h2><span id='topic+precision_thinning'></span>

<h3>Description</h3>

<p>This function performs thinning of spatial points by rounding their coordinates to a specified precision and removing duplicates.
It can perform multiple trials of this process and return the results for all or just the best trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision_thinning(
  coordinates,
  precision = 4,
  trials = 10,
  all_trials = FALSE,
  priority = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision_thinning_+3A_coordinates">coordinates</code></td>
<td>
<p>A numeric matrix or data frame with two columns representing the longitude and latitude of points.</p>
</td></tr>
<tr><td><code id="precision_thinning_+3A_precision">precision</code></td>
<td>
<p>An integer specifying the number of decimal places to which coordinates should be rounded. Default is 4.</p>
</td></tr>
<tr><td><code id="precision_thinning_+3A_trials">trials</code></td>
<td>
<p>An integer specifying the number of thinning trials to perform. Default is 10.</p>
</td></tr>
<tr><td><code id="precision_thinning_+3A_all_trials">all_trials</code></td>
<td>
<p>A logical value indicating whether to return results for all trials ('TRUE') or just the first/best trial ('FALSE'). Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="precision_thinning_+3A_priority">priority</code></td>
<td>
<p>A of the same length as the number of points with numerical values indicating the priority of each point. Instead of eliminating points randomly, the points are preferred accoridng to these values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs multiple trials to account for randomness in the order of point selection. By default, it returns the first trial,
but setting 'all_trials = TRUE' will return the results of all trials.
</p>


<h3>Value</h3>

<p>If 'all_trials' is 'FALSE', returns a logical vector indicating which points were kept in the first trial.
If 'all_trials' is 'TRUE', returns a list of logical vectors, one for each trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage
coordinates &lt;- matrix(c(-123.3656, 48.4284, -123.3657, 48.4285, -123.3658, 48.4286), ncol = 2)
result &lt;- precision_thinning(coordinates, precision = 3, trials = 5, all_trials = TRUE)
print(result)

# Example with a single trial and lower precision
result_single &lt;- precision_thinning(coordinates, precision = 2, trials = 1, all_trials = FALSE)
print(result_single)

</code></pre>

<hr>
<h2 id='rounding_hashing_thinning'>Rounding Hashing Thinning</h2><span id='topic+rounding_hashing_thinning'></span>

<h3>Description</h3>

<p>Performs thinning of geographical coordinates using a hashing approach and rounds the coordinates to create a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rounding_hashing_thinning(
  coordinates,
  thin_dist = 10,
  trials = 10,
  all_trials = FALSE,
  euclidean = FALSE,
  R = 6371,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rounding_hashing_thinning_+3A_coordinates">coordinates</code></td>
<td>
<p>A numeric matrix of size (n x 2) containing the longitude and latitude of points, where each row represents a coordinate pair.</p>
</td></tr>
<tr><td><code id="rounding_hashing_thinning_+3A_thin_dist">thin_dist</code></td>
<td>
<p>A numeric value specifying the distance (in kilometers) within which points should be considered for thinning.</p>
</td></tr>
<tr><td><code id="rounding_hashing_thinning_+3A_trials">trials</code></td>
<td>
<p>An integer indicating the number of trials to run for the thinning process. More trials may yield better results.</p>
</td></tr>
<tr><td><code id="rounding_hashing_thinning_+3A_all_trials">all_trials</code></td>
<td>
<p>A logical value indicating whether to return all trials ('TRUE') or only the best trial ('FALSE').</p>
</td></tr>
<tr><td><code id="rounding_hashing_thinning_+3A_euclidean">euclidean</code></td>
<td>
<p>Logical value indicating whether to compute the Euclidean distance ('TRUE') or Haversine distance ('FALSE', default).</p>
</td></tr>
<tr><td><code id="rounding_hashing_thinning_+3A_r">R</code></td>
<td>
<p>A numeric value representing the radius of the Earth in kilometers. Default is set to 6371.0 km.</p>
</td></tr>
<tr><td><code id="rounding_hashing_thinning_+3A_seed">seed</code></td>
<td>
<p>Optional; an integer seed for reproducibility of results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a hashing technique to group coordinates into grid cells, allowing for efficient thinning based on a specified distance.
It can run multiple trials to determine the best set of points to keep, or return all trials if specified.
</p>


<h3>Value</h3>

<p>A logical vector indicating which points are kept after the thinning process. If 'all_trials' is 'TRUE', a list of logical vectors will be returned, one for each trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random coordinates
set.seed(123)
coordinates &lt;- matrix(runif(20, min = -180, max = 180), ncol = 2) # 10 random points

# Perform rounding hashing thinning
result &lt;- rounding_hashing_thinning(coordinates, thin_dist = 10, trials = 5)
print(result)

# Perform thinning with all trials
all_results &lt;- rounding_hashing_thinning(coordinates, thin_dist = 5000, trials = 5,
                                         all_trials = TRUE)
print(all_results)

# Perform thinning with euclidean distance
result_euclidean &lt;- rounding_hashing_thinning(coordinates, thin_dist = 10,
                                              trials = 5, euclidean = TRUE)
print(result_euclidean)
</code></pre>

<hr>
<h2 id='thin_points'>Spatial Thinning of Points</h2><span id='topic+thin_points'></span>

<h3>Description</h3>

<p>This function performs spatial thinning of geographic points to reduce
point density while maintaining spatial representation. Points are thinned
based on a specified distance, grid, or precision, and multiple trials can be
performed to identify the best thinned dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_points(
  data,
  long_col = NULL,
  lat_col = NULL,
  group_col = NULL,
  method = c("brute_force", "kd_tree", "round_hash", "grid", "precision"),
  trials = 10,
  all_trials = FALSE,
  target_points = NULL,
  seed = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thin_points_+3A_data">data</code></td>
<td>
<p>A data frame or tibble containing the points to thin. Must contain longitude and latitude columns.</p>
</td></tr>
<tr><td><code id="thin_points_+3A_long_col">long_col</code></td>
<td>
<p>Name of the column with longitude coordinates (default: &quot;decimalLongitude&quot;).</p>
</td></tr>
<tr><td><code id="thin_points_+3A_lat_col">lat_col</code></td>
<td>
<p>Name of the column with latitude coordinates (default: &quot;decimalLatitude&quot;).</p>
</td></tr>
<tr><td><code id="thin_points_+3A_group_col">group_col</code></td>
<td>
<p>Name of the column for grouping points (e.g., species name, year). If NULL, no grouping is applied.</p>
</td></tr>
<tr><td><code id="thin_points_+3A_method">method</code></td>
<td>
<p>Thinning method to use 'c(&quot;brute_force&quot;, &quot;kd_tree&quot;, &quot;round_hash&quot;, &quot;grid&quot;, &quot;precision&quot;)'.</p>
</td></tr>
<tr><td><code id="thin_points_+3A_trials">trials</code></td>
<td>
<p>Number of thinning iterations to perform (default: 10).</p>
</td></tr>
<tr><td><code id="thin_points_+3A_all_trials">all_trials</code></td>
<td>
<p>If TRUE, returns results of all attempts; if FALSE, returns the best attempt with the most points retained (default: FALSE).</p>
</td></tr>
<tr><td><code id="thin_points_+3A_target_points">target_points</code></td>
<td>
<p>Optional; a numeric value specifying the exact number of points to keep. If NULL (default), maximizes the number of kept points.</p>
</td></tr>
<tr><td><code id="thin_points_+3A_seed">seed</code></td>
<td>
<p>Optional; an integer seed for reproducibility of results.</p>
</td></tr>
<tr><td><code id="thin_points_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, prints progress messages (default: FALSE).</p>
</td></tr>
<tr><td><code id="thin_points_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to specific thinning methods (e.g., thin_dist, precision, resolution, origin, R).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The thinning methods available are:
- 'brute_force': Uses a brute force approach to thin points.
- 'kd_tree': Uses K-D trees for thinning.
- 'round_hash': Uses rounding and hashing for efficient thinning.
- 'grid': Applies a grid-based thinning method.
- 'precision': Utilizes precision-based thinning.
</p>
<p>For more information on specific thinning methods and inputs, refer to their respective documentation:
- 'brute_force_thinning()'
- 'grid_thinning()'
- 'kd_tree_thinning()'
- 'rounding_hashing_thinning()'
- 'precision_thinning()'
</p>


<h3>Value</h3>

<p>A tibble of thinned points, or a combined result of all attempts if 'all_trials' is TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate sample data
set.seed(123)
sample_data &lt;- data.frame(
  decimalLongitude = runif(100, -180, 180),
  decimalLatitude = runif(100, -90, 90)
)

# Perform thinning using K-D tree method
thinned_data &lt;- thin_points(sample_data,
                             long_col = "decimalLongitude",
                             lat_col = "decimalLatitude",
                             method = "kd_tree",
                             trials = 5,
                             verbose = TRUE)

# Perform thinning with grouping
sample_data$species &lt;- sample(c("species_A", "species_B"), 100, replace = TRUE)
thinned_grouped_data &lt;- thin_points(sample_data,
                                     long_col = "decimalLongitude",
                                     lat_col = "decimalLatitude",
                                     group_col = "species",
                                     method = "kd_tree",
                                     trials = 10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
