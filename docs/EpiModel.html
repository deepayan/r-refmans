<!DOCTYPE html><html><head><title>Help for package EpiModel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EpiModel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_vertices'><p>Fast Version of network::add.vertices for Edgelist-formatted Network</p></a></li>
<li><a href='#apportion_lr'><p>Apportion Using the Largest Remainder Method</p></a></li>
<li><a href='#arrivals.2g.net'><p>Arrivals: netsim Module</p></a></li>
<li><a href='#arrivals.icm'><p>Arrivals: icm Module</p></a></li>
<li><a href='#arrivals.icm.bip'><p>Arrivals: Bipartite icm Module</p></a></li>
<li><a href='#arrivals.net'><p>Arrivals: netsim Module</p></a></li>
<li><a href='#arrive_nodes'><p>Arrive New Nodes to the netsim_dat Object</p></a></li>
<li><a href='#as.data.frame.dcm'><p>Extract Model Data for Deterministic Compartmental Models</p></a></li>
<li><a href='#as.data.frame.icm'><p>Extract Model Data for Stochastic Models</p></a></li>
<li><a href='#as.data.frame.netdx'><p>Extract Timed Edgelists for netdx Objects</p></a></li>
<li><a href='#as.network.transmat'><p>Convert transmat Infection Tree into a network Object</p></a></li>
<li><a href='#as.phylo.transmat'><p>Convert transmat Infection Tree into a phylo Object</p></a></li>
<li><a href='#auto_update_attr'><p>Update Vertex Attributes for Incoming Vertices</p></a></li>
<li><a href='#brewer_ramp'><p>RColorBrewer Color Ramp for EpiModel Plots</p></a></li>
<li><a href='#check_attr_lengths'><p>Check that All Attributes in the Main <code>netsim_dat</code> Object are of Equal</p>
Length</a></li>
<li><a href='#check_degdist_bal'><p>Check Degree Distribution for Balance in Target Statistics</p></a></li>
<li><a href='#check_end_horizon_control'><p>Check the format of the end.horizon control</p></a></li>
<li><a href='#color_tea'><p>Create a TEA Variable for Infection Status for <code>ndtv</code> Animations</p></a></li>
<li><a href='#common_updater'><p>Update Either the &quot;param&quot; or &quot;control&quot; List</p></a></li>
<li><a href='#comp_plot'><p>Plot Compartment Diagram for Epidemic Models</p></a></li>
<li><a href='#control.dcm'><p>Control Settings for Deterministic Compartmental Models</p></a></li>
<li><a href='#control.icm'><p>Control Settings for Stochastic Individual Contact Models</p></a></li>
<li><a href='#control.net'><p>Control Settings for Stochastic Network Models</p></a></li>
<li><a href='#copy_datattr_to_nwattr'><p>Copy Vertex Attributes from the <code>netsim_dat</code> List to the Network</p>
Objects</a></li>
<li><a href='#copy_nwattr_to_datattr'><p>Copy Vertex Attributes From Network to <code>netsim_dat</code> List</p></a></li>
<li><a href='#create_dat_object'><p>Create a Minimal netsim_dat Main List Object for a Network Model</p></a></li>
<li><a href='#create_scenario_list'><p>Make a list of EpiModel scenarios from a data.frame of scenarios</p></a></li>
<li><a href='#crosscheck.dcm'><p>Cross Checking of Inputs for Deterministic Compartmental Models</p></a></li>
<li><a href='#crosscheck.icm'><p>Cross Checking of Inputs for Stochastic Individual Contact Models</p></a></li>
<li><a href='#crosscheck.net'><p>Cross Checking of Inputs for Stochastic Network Models</p></a></li>
<li><a href='#dcm'><p>Deterministic Compartmental Models</p></a></li>
<li><a href='#dcm.mods'><p>Deterministic Compartmental Model Functions</p></a></li>
<li><a href='#delete_attr'><p>Delete Elements from Attribute List</p></a></li>
<li><a href='#delete_edges'><p>Remove Edges That Include Specified Vertices</p></a></li>
<li><a href='#delete_vertices'><p>Fast Version of network::delete.vertices for Edgelist-formatted</p>
Network</a></li>
<li><a href='#deleteAttr'><p>Delete Elements from Attribute List</p></a></li>
<li><a href='#depart_nodes'><p>Depart Nodes from the netsim_dat Object</p></a></li>
<li><a href='#departures.2g.net'><p>Departures: netsim Module</p></a></li>
<li><a href='#departures.icm'><p>Departure: icm Module</p></a></li>
<li><a href='#departures.icm.bip'><p>Departure: Bipartite icm Module</p></a></li>
<li><a href='#departures.net'><p>Departures: netsim Module</p></a></li>
<li><a href='#discord_edgelist'><p>Discordant Edgelist</p></a></li>
<li><a href='#dissolution_coefs'><p>Dissolution Coefficients for Stochastic Network Models</p></a></li>
<li><a href='#edgelist_censor'><p>Table of Edge Censoring</p></a></li>
<li><a href='#edges_correct'><p>Adjustment for the Edges Coefficient with Changing Network Size</p></a></li>
<li><a href='#epi_trackers'><p>Function to run the user-provided epi trackers</p></a></li>
<li><a href='#EpiModel-package'><p>Mathematical Modeling of Infectious Disease Dynamics</p></a></li>
<li><a href='#epiweb'><p>EpiModel Web</p></a></li>
<li><a href='#format_param'><p>Format One Parameter for Printing with the <code>print.param.xxx</code></p>
Functions</a></li>
<li><a href='#generate_random_params'><p>Generate Values for Random Parameters</p></a></li>
<li><a href='#geom_bands'><p>ggplot2 Geom for Quantile Bands</p></a></li>
<li><a href='#get_args'><p>Get Arguments from EpiModel Parameterization Functions</p></a></li>
<li><a href='#get_attr_history'><p>Extract the Attributes History from Network Simulations</p></a></li>
<li><a href='#get_attr_prop'><p>Proportional Table of Vertex Attributes</p></a></li>
<li><a href='#get_cumulative_degree'><p>Return the Cumulative Degree of a Set of Index Nodes</p></a></li>
<li><a href='#get_cumulative_edgelist'><p>Get a Cumulative Edgelist From a Specified Network</p></a></li>
<li><a href='#get_cumulative_edgelists_df'><p>Get the Cumulative Edgelists of a Model</p></a></li>
<li><a href='#get_current_timestep'><p>Return the Current Timestep</p></a></li>
<li><a href='#get_degree'><p>Get Individual Degree from Network or Edgelist</p></a></li>
<li><a href='#get_edgelist'><p>Get an Edgelist From the Specified Network</p></a></li>
<li><a href='#get_formula_term_attr'><p>Output ERGM Formula Attributes into a Character Vector</p></a></li>
<li><a href='#get_modules'><p>Get the List of Modules</p></a></li>
<li><a href='#get_network'><p>Extract Network Objects from Network Simulations</p></a></li>
<li><a href='#get_network_attributes'><p>Get Network Attributes from a Network Object</p></a></li>
<li><a href='#get_network_term_attr'><p>Output Network Attributes into a Character Vector</p></a></li>
<li><a href='#get_nwparam'><p>Extract Network Model Parameters</p></a></li>
<li><a href='#get_nwstats'><p>Extract Network Statistics from netsim or netdx Object</p></a></li>
<li><a href='#get_param_set'><p>Extract the Parameter Set from Network Simulations</p></a></li>
<li><a href='#get_partners'><p>Return the Historical Contacts (Partners) of a Set of Index Nodes</p></a></li>
<li><a href='#get_sims'><p>Extract Network Simulations</p></a></li>
<li><a href='#get_vertex_attribute'><p>Get Vertex Attribute on Network Object</p></a></li>
<li><a href='#icm'><p>Stochastic Individual Contact Models</p></a></li>
<li><a href='#idgroup'><p>Group Numbers for Two-Group Network</p></a></li>
<li><a href='#increment_timestep'><p>Increment the Current Timestep</p></a></li>
<li><a href='#infection.2g.net'><p>Primary Infection Module for netsim</p></a></li>
<li><a href='#infection.icm'><p>Primary Infection Module for icm</p></a></li>
<li><a href='#infection.icm.bip'><p>Primary Infection Module for icm</p></a></li>
<li><a href='#infection.net'><p>Primary Infection Module for netsim</p></a></li>
<li><a href='#init_nets'><p>Network Data and Stats Initialization</p></a></li>
<li><a href='#init_status.icm'><p>Disease Status Initialization Module for icm</p></a></li>
<li><a href='#init_status.net'><p>Disease Status Initialization Module for netsim</p></a></li>
<li><a href='#init.dcm'><p>Initial Conditions for Deterministic Compartmental Models</p></a></li>
<li><a href='#init.icm'><p>Initial Conditions for Stochastic Individual Contact Models</p></a></li>
<li><a href='#init.net'><p>Initial Conditions for Stochastic Network Models</p></a></li>
<li><a href='#InitErgmTerm.absdiffby'><p>Definition for absdiffby ERGM Term</p></a></li>
<li><a href='#InitErgmTerm.absdiffnodemix'><p>Definition for absdiffnodemix ERGM Term</p></a></li>
<li><a href='#InitErgmTerm.fuzzynodematch'><p>Definition for fuzzynodematch ERGM Term</p></a></li>
<li><a href='#initialize.icm'><p>Initialization: icm Module</p></a></li>
<li><a href='#initialize.net'><p>Initialization: netsim Module</p></a></li>
<li><a href='#is_active_posit_ids'><p>Are These Nodes Active (Positional IDs)</p></a></li>
<li><a href='#is_active_unique_ids'><p>Are These Nodes Active (Unique IDs)</p></a></li>
<li><a href='#is.transmat'><p>Extract Transmissions Matrix from Network Epidemic Model</p></a></li>
<li><a href='#make_module_list'><p>Populate the Module List After the Initialization Module is run</p></a></li>
<li><a href='#make_stats_table'><p>Create a Summary Table of Simulation Statistics</p></a></li>
<li><a href='#mcat'><p>Write Out Test Progress to Console</p></a></li>
<li><a href='#merge.icm'><p>Merge Data across Stochastic Individual Contact Model Simulations</p></a></li>
<li><a href='#merge.netsim'><p>Merge Model Simulations across netsim Objects</p></a></li>
<li><a href='#modules.icm'><p>Modules for Stochastic Individual Contact Models</p></a></li>
<li><a href='#modules.net'><p>Modules for Stochastic Network Models</p></a></li>
<li><a href='#multilayer'><p>Specify Controls by Network</p></a></li>
<li><a href='#mutate_epi'><p>Add New Epidemiology Variables</p></a></li>
<li><a href='#net-accessor'><p>Functions to Access and Edit the Main netsim_dat Object in Network Models</p></a></li>
<li><a href='#netdx'><p>Dynamic Network Model Diagnostics</p></a></li>
<li><a href='#netest'><p>Dynamic Network Model Estimation</p></a></li>
<li><a href='#netsim'><p>Stochastic Network Models</p></a></li>
<li><a href='#netsim_cond_msg'><p>Message to Find in Which Module a <code>condition</code> Occurred</p></a></li>
<li><a href='#netsim_error_logger'><p>Handle the Logging of Traceback and Dumping of Frames on Error</p></a></li>
<li><a href='#network_initialize'><p>Initialize Network Object</p></a></li>
<li><a href='#nwupdate.net'><p>Dynamic Network Updates</p></a></li>
<li><a href='#padded_vector'><p>Grow a Vector to a Given Size, Padding it With Empty Elements</p></a></li>
<li><a href='#param_random'><p>Create a Value Sampler for Random Parameters</p></a></li>
<li><a href='#param.dcm'><p>Epidemic Parameters for Deterministic Compartmental Models</p></a></li>
<li><a href='#param.icm'><p>Epidemic Parameters for Stochastic Individual Contact Models</p></a></li>
<li><a href='#param.net'><p>Epidemic Parameters for Stochastic Network Models</p></a></li>
<li><a href='#param.net_from_table'><p>Parameters List for Stochastic Network Models from a Formatted</p>
Data Frame</a></li>
<li><a href='#plot.dcm'><p>Plot Data from a Deterministic Compartmental Epidemic Model</p></a></li>
<li><a href='#plot.icm'><p>Plot Data from a Stochastic Individual Contact Epidemic Model</p></a></li>
<li><a href='#plot.netdx'><p>Plot Dynamic Network Model Diagnostics</p></a></li>
<li><a href='#plot.netsim'><p>Plot Data from a Stochastic Network Epidemic Model</p></a></li>
<li><a href='#plot.transmat'><p>Plot transmat Infection Tree in Three Styles</p></a></li>
<li><a href='#prevalence.icm'><p>Get Epidemic Output from icm Model</p></a></li>
<li><a href='#prevalence.icm.bip'><p>Get Epidemic Output from icm Model</p></a></li>
<li><a href='#prevalence.net'><p>Get Epidemic Output from netsim Model</p></a></li>
<li><a href='#print_nwstats_table'><p>Print Helper For Network Stats Tables</p></a></li>
<li><a href='#print.netdx'><p>Utility Function for Printing netdx Object</p></a></li>
<li><a href='#process_out.net'><p>Save a List of netsim Data to Output List Format</p></a></li>
<li><a href='#record_attr_history'><p>Record Attribute History</p></a></li>
<li><a href='#record_raw_object'><p>Record an Arbitrary Object During a Simulation</p></a></li>
<li><a href='#recovery.2g.net'><p>Recovery: netsim Module</p></a></li>
<li><a href='#recovery.icm'><p>Recovery: icm Module</p></a></li>
<li><a href='#recovery.icm.bip'><p>Recovery: icm Module</p></a></li>
<li><a href='#recovery.net'><p>Recovery: netsim Module</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove_modules'><p>Remove a Set of Modules From the Module List</p></a></li>
<li><a href='#resim_nets'><p>Resimulate Dynamic Network at Time 2+</p></a></li>
<li><a href='#saveout.dcm'><p>Save dcm Data to Output List Format</p></a></li>
<li><a href='#saveout.icm'><p>Save icm Data to Output List Format</p></a></li>
<li><a href='#saveout.net'><p>Save netsim Data to Output List Format</p></a></li>
<li><a href='#set_current_timestep'><p>Set the Current Timestep</p></a></li>
<li><a href='#set_modules'><p>Set the List of Modules</p></a></li>
<li><a href='#set_network'><p>Set Network State During netsim Simulation</p></a></li>
<li><a href='#set_transmat'><p>Save Transmission Matrix</p></a></li>
<li><a href='#set_vertex_attribute'><p>Set Vertex Attribute on Network Object</p></a></li>
<li><a href='#sim_nets_t1'><p>Initialize Networks Used in netsim</p></a></li>
<li><a href='#simulate_dat'><p>Simulate a Network for a Specified Number of Time Steps</p></a></li>
<li><a href='#ssample'><p>Stable Sampling Function</p></a></li>
<li><a href='#summary_nets'><p>Extract Summary Statistics of Networks Used in netsim</p></a></li>
<li><a href='#summary.dcm'><p>Summary Model Statistics</p></a></li>
<li><a href='#summary.icm'><p>Summary Model Statistics</p></a></li>
<li><a href='#summary.netest'><p>Summary for Network Model Fit</p></a></li>
<li><a href='#summary.netsim'><p>Summary Model Statistics</p></a></li>
<li><a href='#tedgelist_to_toggles'><p>Convert Timed Edgelist to Matrix of Toggles</p></a></li>
<li><a href='#test_icm'><p>Test the Model Output from a Stochastic Individual Contact Model</p></a></li>
<li><a href='#test_net'><p>Test the Model Output from a Network Model</p></a></li>
<li><a href='#toggles_to_diss_stats'><p>Convert Matrix of Toggles to Dissolution and Duration Statistics</p></a></li>
<li><a href='#trigger_end_horizon'><p>Function to Trigger the End Horizon</p></a></li>
<li><a href='#trim_netest'><p>Function to Reduce the Size of a <code>netest</code> Object</p></a></li>
<li><a href='#truncate_sim'><p>Truncate Simulation Time Series</p></a></li>
<li><a href='#unique_id-tools'><p>Convert Unique Identifiers to/from Positional Identifiers</p></a></li>
<li><a href='#update_cumulative_edgelist'><p>Update a Cumulative Edgelist of the Specified Network</p></a></li>
<li><a href='#update_dissolution'><p>Adjust Dissolution Component of Network Model Fit</p></a></li>
<li><a href='#update_list'><p>Update List <code>x</code> Using the Elements of List <code>new.x</code>.</p></a></li>
<li><a href='#update_params'><p>Update Model Parameters for Stochastic Network Models</p></a></li>
<li><a href='#update_unique_ids'><p>Create the Unique Identifiers for New Nodes</p></a></li>
<li><a href='#use_scenario'><p>Apply a scenario object to a param.net object</p></a></li>
<li><a href='#verbose.dcm'><p>Progress Print Module for Deterministic Compartmental Models</p></a></li>
<li><a href='#verbose.icm'><p>Progress Print Module for Stochastic Individual Contact Models</p></a></li>
<li><a href='#verbose.net'><p>Progress Print Module for Stochastic Network Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-20</td>
</tr>
<tr>
<td>Title:</td>
<td>Mathematical Modeling of Infectious Disease Dynamics</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for simulating mathematical models of infectious disease dynamics.
    Epidemic model classes include deterministic compartmental models, stochastic
    individual-contact models, and stochastic network models. Network models use the
    robust statistical methods of exponential-family random graph models (ERGMs)
    from the Statnet suite of software packages in R. Standard templates for epidemic
    modeling include SI, SIR, and SIS disease types. EpiModel features an API for
    extending these templates to address novel scientific research aims. Full
    methods for EpiModel are detailed in Jenness et al. (2018, &lt;<a href="https://doi.org/10.18637%2Fjss.v084.i08">doi:10.18637/jss.v084.i08</a>&gt;).</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel Jenness &lt;samuel.m.jenness@emory.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.epimodel.org/">http://www.epimodel.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EpiModel/EpiModel/issues">https://github.com/EpiModel/EpiModel/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1), deSolve (&ge; 1.21), networkDynamic (&ge; 0.11.3),
tergm (&ge; 4.2.0), statnet.common (&ge; 4.8.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils, doParallel, ergm (&ge;
4.5.0), ergm.ego (&ge; 1.1.0), egor, foreach, network (&ge;
1.18.1), RColorBrewer, ape, lazyeval, ggplot2, tibble, methods,
rlang, dplyr, coda, networkLite (&ge; 1.0.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ndtv, rmarkdown, shiny, testthat, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, ergm</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-20 17:48:32 UTC; sjennes</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel Jenness [cre, aut],
  Steven M. Goodreau [aut],
  Martina Morris [aut],
  Adrien Le Guillou [aut],
  Chad Klumb [aut],
  Skye Bender-deMoll [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-20 18:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_vertices'>Fast Version of network::add.vertices for Edgelist-formatted Network</h2><span id='topic+add_vertices'></span>

<h3>Description</h3>

<p>This function performs a simple operation of updating the
edgelist attribute <code>n</code> that tracks the total network
size implicit in an edgelist representation of the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_vertices(el, nv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_vertices_+3A_el">el</code></td>
<td>
<p>A two-column matrix of current edges (edgelist) with an attribute
variable <code>n</code> containing the total current network size.</p>
</td></tr>
<tr><td><code id="add_vertices_+3A_nv">nv</code></td>
<td>
<p>A integer equal to the number of nodes to add to the network
size at the given time step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in <code>EpiModel</code> modules to add vertices (nodes) to
the edgelist object to account for entries into the population (e.g., births
and in-migration).
</p>


<h3>Value</h3>

<p>Returns the matrix of current edges, <code>el</code>, with the population size
attribute updated based on the number of new vertices specified in <code>nv</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("EpiModel")
nw &lt;- network_initialize(100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
x &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

param &lt;- param.net(inf.prob = 0.3)
init &lt;- init.net(i.num = 10)
control &lt;- control.net(type = "SI", nsteps = 100, nsims = 5,
                       tergmLite = TRUE)

# networkLite representation after initialization
dat &lt;- crosscheck.net(x, param, init, control)
dat &lt;- initialize.net(x, param, init, control)

# Check current network size
attributes(dat$el[[1]])$n

# Add 10 vertices
dat$el[[1]] &lt;- add_vertices(dat$el[[1]], 10)

# Check new network size
attributes(dat$el[[1]])$n

## End(Not run)

</code></pre>

<hr>
<h2 id='apportion_lr'>Apportion Using the Largest Remainder Method</h2><span id='topic+apportion_lr'></span>

<h3>Description</h3>

<p>Apportions a vector of values given a specified frequency
distribution of those values such that the length of the output
is robust to rounding and other instabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apportion_lr(vector.length, values, proportions, shuffled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apportion_lr_+3A_vector.length">vector.length</code></td>
<td>
<p>Length for the output vector.</p>
</td></tr>
<tr><td><code id="apportion_lr_+3A_values">values</code></td>
<td>
<p>Values for the output vector.</p>
</td></tr>
<tr><td><code id="apportion_lr_+3A_proportions">proportions</code></td>
<td>
<p>Proportion distribution with one number for each value.
This must sum to 1.</p>
</td></tr>
<tr><td><code id="apportion_lr_+3A_shuffled">shuffled</code></td>
<td>
<p>If <code>TRUE</code>, randomly shuffle the order of the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>vector.length</code> containing the apportioned
values from <code>values</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1: Without rounding
apportioned_vec_1 &lt;- apportion_lr(4, c(1, 2, 3, 4, 5),
                                     c(0.25, 0, 0.25, 0.25, 0.25))

## Example 2: With rounding
apportioned_vec_2 &lt;- apportion_lr(5, c(1, 2, 3, 4, 5),
                                     c(0.21, 0, 0.29, 0.25, 0.25))

## End(Not run)

</code></pre>

<hr>
<h2 id='arrivals.2g.net'>Arrivals: netsim Module</h2><span id='topic+arrivals.2g.net'></span>

<h3>Description</h3>

<p>This function simulates new arrivals into the network
for use in <code><a href="#topic+netsim">netsim</a></code> simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrivals.2g.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrivals.2g.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="arrivals.2g.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsim">netsim</a></code>
</p>

<hr>
<h2 id='arrivals.icm'>Arrivals: icm Module</h2><span id='topic+arrivals.icm'></span>

<h3>Description</h3>

<p>This function simulates arrival for use in <code><a href="#topic+icm">icm</a></code>
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrivals.icm(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrivals.icm_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="arrivals.icm_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icm">icm</a></code>
</p>

<hr>
<h2 id='arrivals.icm.bip'>Arrivals: Bipartite icm Module</h2><span id='topic+arrivals.icm.bip'></span>

<h3>Description</h3>

<p>This function simulates arrival for use in <code><a href="#topic+icm">icm</a></code>
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrivals.icm.bip(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrivals.icm.bip_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="arrivals.icm.bip_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icm">icm</a></code>
</p>

<hr>
<h2 id='arrivals.net'>Arrivals: netsim Module</h2><span id='topic+arrivals.net'></span>

<h3>Description</h3>

<p>This function simulates new arrivals into the network
for use in <code><a href="#topic+netsim">netsim</a></code> simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrivals.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrivals.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="arrivals.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsim">netsim</a></code>
</p>

<hr>
<h2 id='arrive_nodes'>Arrive New Nodes to the netsim_dat Object</h2><span id='topic+arrive_nodes'></span>

<h3>Description</h3>

<p>Arrive New Nodes to the netsim_dat Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrive_nodes(dat, nArrivals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrive_nodes_+3A_dat">dat</code></td>
<td>
<p>the <code>netsim_dat</code> object</p>
</td></tr>
<tr><td><code id="arrive_nodes_+3A_narrivals">nArrivals</code></td>
<td>
<p>number of new nodes to arrive</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nArrivals</code> new nodes are added to the network data stored on
the <code>netsim_dat</code> object. If <code>tergmLite</code> is <code>FALSE</code>, these
nodes are activated from the current timestep onward. Attributes for the new
nodes must be set separately.
</p>
<p>Note that this function only supports arriving new nodes; returning to an
active state nodes that were previously active in the network is not
supported.
</p>


<h3>Value</h3>

<p>the updated <code>netsim_dat</code> object with <code>nArrivals</code> new nodes
added
</p>

<hr>
<h2 id='as.data.frame.dcm'>Extract Model Data for Deterministic Compartmental Models</h2><span id='topic+as.data.frame.dcm'></span>

<h3>Description</h3>

<p>This function extracts a model run from an object of class
<code>dcm</code> into a data frame using the generic
<code>as.data.frame</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcm'
as.data.frame(x, row.names = NULL, optional = FALSE, run, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.dcm_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+dcm">dcm</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.dcm_+3A_row.names">row.names</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.dcm_+3A_optional">optional</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.dcm_+3A_run">run</code></td>
<td>
<p>Run number for model; used for multiple-run sensitivity models. If
not specified, will output data from all runs in a stacked data frame.</p>
</td></tr>
<tr><td><code id="as.data.frame.dcm_+3A_...">...</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model output from <code><a href="#topic+dcm">dcm</a></code> simulations are available as a data
frame with this helper function. The output data frame will include
columns for time, the size of each compartment, the overall population
size (the sum of compartment sizes), and the size of each flow.
</p>
<p>For models with multiple runs (i.e., varying parameters - see example below),
the default with the <code>run</code> parameter not specified will output all runs
in a single stacked data frame.
</p>


<h3>Value</h3>

<p>A data frame containing the data from <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: One-group SIS model with varying act.rate
param &lt;- param.dcm(inf.prob = 0.2, act.rate = seq(0.05, 0.5, 0.05),
                   rec.rate = 1/50)
init &lt;- init.dcm(s.num = 500, i.num = 1)
control &lt;- control.dcm(type = "SIS", nsteps = 10)
mod1 &lt;- dcm(param, init, control)
as.data.frame(mod1)
as.data.frame(mod1, run = 1)
as.data.frame(mod1, run = 10)

## Example 2: Two-group SIR model with vital dynamics
param &lt;- param.dcm(inf.prob = 0.2, inf.prob.g2 = 0.1,
                   act.rate = 3, balance = "g1",
                   rec.rate = 1/50, rec.rate.g2 = 1/50,
                   a.rate = 1/100, a.rate.g2 = NA,
                   ds.rate = 1/100, ds.rate.g2 = 1/100,
                   di.rate = 1/90, di.rate.g2 = 1/90,
                   dr.rate = 1/100, dr.rate.g2 = 1/100)
init &lt;- init.dcm(s.num = 500, i.num = 1, r.num = 0,
                 s.num.g2 = 500, i.num.g2 = 1, r.num.g2 = 0)
control &lt;- control.dcm(type = "SIR", nsteps = 10)
mod2 &lt;- dcm(param, init, control)
as.data.frame(mod2)

</code></pre>

<hr>
<h2 id='as.data.frame.icm'>Extract Model Data for Stochastic Models</h2><span id='topic+as.data.frame.icm'></span><span id='topic+as.data.frame.netsim'></span>

<h3>Description</h3>

<p>This function extracts model simulations for objects of classes
<code>icm</code> and <code>netsim</code> into a data frame using
the generic <code>as.data.frame</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icm'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  out = "vals",
  sim,
  qval,
  ...
)

## S3 method for class 'netsim'
as.data.frame(x, row.names = NULL, optional = FALSE, out = "vals", sim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.icm_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>icm</code> or <code>netsim</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.icm_+3A_row.names">row.names</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.icm_+3A_optional">optional</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.icm_+3A_out">out</code></td>
<td>
<p>Data output to data frame: <code>"mean"</code> for row means across
simulations, <code>"sd"</code> for row standard deviations across
simulations, <code>"qnt"</code> for row quantiles at the level specified in
<code>qval</code>, or <code>"vals"</code> for values from individual simulations.</p>
</td></tr>
<tr><td><code id="as.data.frame.icm_+3A_sim">sim</code></td>
<td>
<p>If <code>out="vals"</code>, the simulation number to output. If not
specified, then data from all simulations will be output.</p>
</td></tr>
<tr><td><code id="as.data.frame.icm_+3A_qval">qval</code></td>
<td>
<p>Quantile value required when <code>out="qnt"</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.icm_+3A_...">...</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods work for both <code>icm</code> and <code>netsim</code> class models. The
available output includes time-specific means, standard deviations,
quantiles, and simulation values (compartment and flow sizes) from these
stochastic model classes. Means, standard deviations, and quantiles are
calculated by taking the row summary (i.e., each row of data is corresponds
to a time step) across all simulations in the model output.
</p>


<h3>Value</h3>

<p>A data frame containing the data from <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Stochastic ICM SIS model
param &lt;- param.icm(inf.prob = 0.8, act.rate = 2, rec.rate = 0.1)
init &lt;- init.icm(s.num = 500, i.num = 1)
control &lt;- control.icm(type = "SIS", nsteps = 10,
                       nsims = 3, verbose = FALSE)
mod &lt;- icm(param, init, control)

# Default output all simulation runs, default to all in stacked data.frame
as.data.frame(mod)
as.data.frame(mod, sim = 2)

# Time-specific means across simulations
as.data.frame(mod, out = "mean")

# Time-specific standard deviations across simulations
as.data.frame(mod, out = "sd")

# Time-specific quantile values across simulations
as.data.frame(mod, out = "qnt", qval = 0.25)
as.data.frame(mod, out = "qnt", qval = 0.75)

## Not run: 
## Stochastic SI Network Model
nw &lt;- network_initialize(n = 100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

param &lt;- param.net(inf.prob = 0.5)
init &lt;- init.net(i.num = 10)
control &lt;- control.net(type = "SI", nsteps = 10, nsims = 3, verbose = FALSE)
mod &lt;- netsim(est, param, init, control)

# Same data extraction methods as with ICMs
as.data.frame(mod)
as.data.frame(mod, sim = 2)
as.data.frame(mod, out = "mean")
as.data.frame(mod, out = "sd")
as.data.frame(mod, out = "qnt", qval = 0.25)
as.data.frame(mod, out = "qnt", qval = 0.75)

## End(Not run)

</code></pre>

<hr>
<h2 id='as.data.frame.netdx'>Extract Timed Edgelists for netdx Objects</h2><span id='topic+as.data.frame.netdx'></span>

<h3>Description</h3>

<p>This function extracts timed edgelists for objects of class
<code>netdx</code> into a data frame using the generic
<code>as.data.frame</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netdx'
as.data.frame(x, row.names = NULL, optional = FALSE, sim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.netdx_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>netdx</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.netdx_+3A_row.names">row.names</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.netdx_+3A_optional">optional</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.netdx_+3A_sim">sim</code></td>
<td>
<p>The simulation number to output. If not specified, then data from
all simulations will be output.</p>
</td></tr>
<tr><td><code id="as.data.frame.netdx_+3A_...">...</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the data from <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initialize and parameterize the network model
nw &lt;- network_initialize(n = 100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)

# Model estimation
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Simulate the network with netdx
dx &lt;- netdx(est, nsims = 3, nsteps = 10, keep.tedgelist = TRUE,
            verbose = FALSE)

# Extract data from the first simulation
as.data.frame(dx, sim = 1)

# Extract data from all simulations
as.data.frame(dx)

</code></pre>

<hr>
<h2 id='as.network.transmat'>Convert transmat Infection Tree into a network Object</h2><span id='topic+as.network.transmat'></span>

<h3>Description</h3>

<p>Converts a transmission matrix from the <code>get_transmat</code>
function into a <a href="network.html#topic+network">network</a> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transmat'
as.network(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.network.transmat_+3A_x">x</code></td>
<td>
<p>An object of class <code>transmat</code> to be converted into a
<code>network</code> class object.</p>
</td></tr>
<tr><td><code id="as.network.transmat_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When converting from a <code>transmat</code> to a <code>network</code> object, this
functions copies the edge attributes within the transmission matrix
(<code>'at'</code>, <code>'infDur'</code>, <code>'transProb'</code>, <code>'actRate'</code>, and
<code>'finalProb'</code>) into edge attributes on the network.
</p>


<h3>Value</h3>

<p>A <code><a href="network.html#topic+network">network</a></code> object.
</p>

<hr>
<h2 id='as.phylo.transmat'>Convert transmat Infection Tree into a phylo Object</h2><span id='topic+as.phylo.transmat'></span>

<h3>Description</h3>

<p>Converts a transmission matrix from the <code>get_transmat</code>
function into a <code>phylo</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transmat'
as.phylo(x, vertex.exit.times, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.phylo.transmat_+3A_x">x</code></td>
<td>
<p>An object of class <code>transmat</code>, the output from
<code><a href="#topic+get_transmat">get_transmat</a></code>.</p>
</td></tr>
<tr><td><code id="as.phylo.transmat_+3A_vertex.exit.times">vertex.exit.times</code></td>
<td>
<p>Optional numeric vector providing the time of
departure of vertices, to be used to scale the lengths of branches
reaching to the tips. Index position on vector corresponds to network
id. NA indicates no departure, so branch will extend to the end of the
tree.</p>
</td></tr>
<tr><td><code id="as.phylo.transmat_+3A_...">...</code></td>
<td>
<p>Further arguments (unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a <code><a href="#topic+transmat">transmat</a></code> object containing information about the
history of a simulated infection into a <code><a href="ape.html#topic+phylo">phylo</a></code> object
representation suitable for plotting as a tree with
<code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>. Each infection event becomes a 'node'
(horizontal branch) in the resulting <code>phylo</code> tree, and each network
vertex becomes a 'tip' of the tree. The infection events are labeled with the
vertex ID of the infector to make it possible to trace the path of infection.
</p>
<p>The infection timing information is included to position the phylo-nodes,
with the lines to the tips drawn to the max time value +1 (unless
<code>vertex.exit.times</code> are passed in it effectively assumes all vertices
are active until the end of the simulation).
</p>
<p>If the <code>transmat</code> contains multiple infection seeds (there are multiple
trees with separate root nodes), this function will return a list of class
<code>multiPhylo</code>, each element of which is a <code>phylo</code> object. See
<code><a href="ape.html#topic+read.tree">read.tree</a></code>.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)

# Fit a random mixing TERGM with mean degree of 1 and mean edge
# duration of 20 time steps
nw &lt;- network_initialize(n = 100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Parameterize the epidemic model as SI with one infected seed
param &lt;- param.net(inf.prob = 0.5)
init &lt;- init.net(i.num = 1)
control &lt;- control.net(type = "SI", nsteps = 40, nsims = 1, verbose = FALSE)

# Simulate the model
mod1 &lt;- netsim(est, param, init, control)

# Extract the transmission matrix
tm &lt;- get_transmat(mod1)
head(tm, 15)

# Convert to phylo object and plot
tmPhylo &lt;- as.phylo.transmat(tm)
par(mar = c(1,1,1,1))
plot(tmPhylo, show.node.label = TRUE,
              root.edge = TRUE,
              cex = 0.75)

</code></pre>

<hr>
<h2 id='auto_update_attr'>Update Vertex Attributes for Incoming Vertices</h2><span id='topic+auto_update_attr'></span>

<h3>Description</h3>

<p>Updates the vertex attributes on a network for new nodes
incoming into that network, based on a set of rules for each
attribute that the user specifies in <code><a href="#topic+control.net">control.net</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_update_attr(dat, newNodes, curr.tab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_update_attr_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="auto_update_attr_+3A_newnodes">newNodes</code></td>
<td>
<p>Vector of nodal IDs for incoming nodes at the current time
step.</p>
</td></tr>
<tr><td><code id="auto_update_attr_+3A_curr.tab">curr.tab</code></td>
<td>
<p>Current proportional distribution of all vertex attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copy_nwattr_to_datattr">copy_nwattr_to_datattr</a></code>, <code><a href="#topic+get_attr_prop">get_attr_prop</a></code>,
<code><a href="#topic+auto_update_attr">auto_update_attr</a></code>.
</p>

<hr>
<h2 id='brewer_ramp'>RColorBrewer Color Ramp for EpiModel Plots</h2><span id='topic+brewer_ramp'></span>

<h3>Description</h3>

<p>Returns a vector of colors consistent with a high-brightness set
of colors from an <code>RColorBrewer</code> palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brewer_ramp(n, plt, delete.lights = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brewer_ramp_+3A_n">n</code></td>
<td>
<p>Number of colors to return.</p>
</td></tr>
<tr><td><code id="brewer_ramp_+3A_plt">plt</code></td>
<td>
<p><code>RColorBrewer</code> palette from <code><a href="RColorBrewer.html#topic+brewer.pal">brewer.pal</a></code>.</p>
</td></tr>
<tr><td><code id="brewer_ramp_+3A_delete.lights">delete.lights</code></td>
<td>
<p>If TRUE, delete the lightest colors from the color
palette; this helps with plotting in many high-contrast palettes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RColorBrewer</code> provides easy access to helpful color palettes, but the
built-in palettes are limited to the set of colors in the existing palette.
This function expands the palette size to any number of colors by filling
in the gaps. Also, colors within the &quot;div&quot; and &quot;seq&quot; set of palettes whose
colors are very light (close to white) are deleted by default for better
visualization of plots.
</p>


<h3>Value</h3>

<p>A vector of length equal to <code>n</code> with a range of color values consistent
with an RColorBrewer color palette.
</p>


<h3>See Also</h3>

<p><code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Shows a 100-color ramp for 4 RColorBrewer palettes
par(mfrow = c(2, 2), mar=c(1, 1, 2, 1))
pals &lt;- c("Spectral", "Greys", "Blues", "Set1")
for (i in seq_along(pals)) {
 plot(1:100, 1:100, type = "n", axes = FALSE, main = pals[i])
 abline(v = 1:100, lwd = 6, col = brewer_ramp(100, pals[i]))
}

</code></pre>

<hr>
<h2 id='check_attr_lengths'>Check that All Attributes in the Main <code>netsim_dat</code> Object are of Equal
Length</h2><span id='topic+check_attr_lengths'></span>

<h3>Description</h3>

<p>Check that All Attributes in the Main <code>netsim_dat</code> Object are of Equal
Length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_attr_lengths(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_attr_lengths_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(TRUE) if everything is correct; an error if not.
</p>

<hr>
<h2 id='check_degdist_bal'>Check Degree Distribution for Balance in Target Statistics</h2><span id='topic+check_degdist_bal'></span>

<h3>Description</h3>

<p>Checks for consistency in the implied network statistics
of a two-group network in which the group size and
group-specific degree distributions are specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_degdist_bal(num.g1, num.g2, deg.dist.g1, deg.dist.g2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_degdist_bal_+3A_num.g1">num.g1</code></td>
<td>
<p>Number of nodes in group 1.</p>
</td></tr>
<tr><td><code id="check_degdist_bal_+3A_num.g2">num.g2</code></td>
<td>
<p>Number of nodes in group 2.</p>
</td></tr>
<tr><td><code id="check_degdist_bal_+3A_deg.dist.g1">deg.dist.g1</code></td>
<td>
<p>Vector with fractional degree distribution for group 1.</p>
</td></tr>
<tr><td><code id="check_degdist_bal_+3A_deg.dist.g2">deg.dist.g2</code></td>
<td>
<p>Vector with fractional degree distribution for group 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function outputs the number of nodes of degree 0 to g, where g is the
length of a fractional degree distribution vector, given that vector and the
size of the group. This utility is used to check for balance in implied
degree given that fractional distribution within two-group network
simulations, in which the degree-constrained counts must be equal across
groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An unbalanced distribution
check_degdist_bal(num.g1 = 500, num.g2 = 500,
                  deg.dist.g2 = c(0.40, 0.55, 0.03, 0.02),
                  deg.dist.g1 = c(0.48, 0.41, 0.08, 0.03))

# A balanced distribution
check_degdist_bal(num.g1 = 500, num.g2 = 500,
                  deg.dist.g1 = c(0.40, 0.55, 0.04, 0.01),
                  deg.dist.g2 = c(0.48, 0.41, 0.08, 0.03))

</code></pre>

<hr>
<h2 id='check_end_horizon_control'>Check the format of the end.horizon control</h2><span id='topic+check_end_horizon_control'></span>

<h3>Description</h3>

<p>Check the format of the end.horizon control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_end_horizon_control(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_end_horizon_control_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE invisibly on succes, errors otherwise
</p>

<hr>
<h2 id='color_tea'>Create a TEA Variable for Infection Status for <code>ndtv</code> Animations</h2><span id='topic+color_tea'></span>

<h3>Description</h3>

<p>Creates a new color-named temporally-extended attribute (TEA)
variable in a <code>networkDynamic</code> object containing a disease
status TEA in numeric format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_tea(
  nd,
  old.var = "testatus",
  old.sus = "s",
  old.inf = "i",
  old.rec = "r",
  new.var = "ndtvcol",
  new.sus,
  new.inf,
  new.rec,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_tea_+3A_nd">nd</code></td>
<td>
<p>An object of class <code>networkDynamic</code>.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_old.var">old.var</code></td>
<td>
<p>Old TEA variable name.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_old.sus">old.sus</code></td>
<td>
<p>Status value for susceptible in old TEA variable.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_old.inf">old.inf</code></td>
<td>
<p>Status value for infected in old TEA variable.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_old.rec">old.rec</code></td>
<td>
<p>Status value for recovered in old TEA variable.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_new.var">new.var</code></td>
<td>
<p>New TEA variable name to be stored in <code>networkDynamic</code>
object.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_new.sus">new.sus</code></td>
<td>
<p>Status value for susceptible in new TEA variable.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_new.inf">new.inf</code></td>
<td>
<p>Status value for infected in new TEA variable.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_new.rec">new.rec</code></td>
<td>
<p>Status value for recovered in new TEA variable.</p>
</td></tr>
<tr><td><code id="color_tea_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print progress to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ndtv</code> package (<a href="https://cran.r-project.org/package=ndtv">https://cran.r-project.org/package=ndtv</a>)
produces animated visuals for dynamic networks with evolving edge structures
and nodal attributes. Nodal attribute dynamics in <code>ndtv</code> movies require
a temporally extended attribute (TEA) containing a standard R color for each
node at each time step. By default, the <code>EpiModel</code> package uses TEAs to
store disease status history in network model simulations run in
<code><a href="#topic+netsim">netsim</a></code>. But that status TEA is in numeric format (0, 1, 2).
The <code>color_tea</code> function transforms those numeric values of that disease
status TEA into a TEA with color values in order to visualize status changes
in <code>ndtv</code>.
</p>
<p>The convention in <code><a href="#topic+plot.netsim">plot.netsim</a></code> is to color the susceptible
nodes as blue, infected nodes as red, and recovered nodes as green. Alternate
colors may be specified using the <code>new.sus</code>, <code>new.inf</code>, and
<code>new.rec</code> parameters, respectively.
</p>
<p>Using the <code>color_tea</code> function with a <code>netsim</code> object requires that
TEAs for disease status be used and that the <code>networkDynamic</code> object be
saved in the output: <code>tergmListe</code> must be  set to <code>FALSE</code> in
<code><a href="#topic+control.net">control.net</a></code>.
</p>


<h3>Value</h3>

<p>The updated object of class <code>networkDynamic</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsim">netsim</a></code> and the <code>ndtv</code> package documentation.
</p>

<hr>
<h2 id='common_updater'>Update Either the &quot;param&quot; or &quot;control&quot; List</h2><span id='topic+common_updater'></span>

<h3>Description</h3>

<p>Update Either the &quot;param&quot; or &quot;control&quot; List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_updater(dat, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="common_updater_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="common_updater_+3A_type">type</code></td>
<td>
<p>Either <code>"param"</code> or <code>"control"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='comp_plot'>Plot Compartment Diagram for Epidemic Models</h2><span id='topic+comp_plot'></span><span id='topic+comp_plot.dcm'></span><span id='topic+comp_plot.icm'></span><span id='topic+comp_plot.netsim'></span>

<h3>Description</h3>

<p>Plots a compartment flow diagram for deterministic compartmental
models, stochastic individual contact models, and stochastic
network models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_plot(x, at, digits, ...)

## S3 method for class 'dcm'
comp_plot(x, at = 1, digits = 3, run = 1, ...)

## S3 method for class 'icm'
comp_plot(x, at = 1, digits = 3, ...)

## S3 method for class 'netsim'
comp_plot(x, at = 1, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_plot_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>dcm</code>, <code>icm</code>, or
<code>netsim</code>.</p>
</td></tr>
<tr><td><code id="comp_plot_+3A_at">at</code></td>
<td>
<p>Time step for model statistics.</p>
</td></tr>
<tr><td><code id="comp_plot_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="comp_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to plot (not currently used).</p>
</td></tr>
<tr><td><code id="comp_plot_+3A_run">run</code></td>
<td>
<p>Model run number, for <code>dcm</code> class models with multiple runs
(sensitivity analyses).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>comp_plot</code> function provides a visual summary of an epidemic model
at a specific time step. The information contained in <code>comp_plot</code> is the
same as in the <code>summary</code> functions for a model, but presented
graphically as a compartment flow diagram.
</p>
<p>For <code>dcm</code> class plots, specify the model run number if the model
contains multiple runs, as in a sensitivity analysis. For <code>icm</code> and
<code>netsim</code> class plots, the <code>run</code> argument is not used; the plots
show the means and standard deviations across simulations at the specified
time step.
</p>
<p>These plots are currently limited to one-group models for each of the three
model classes. That functionality may be expanded in future software
releases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: DCM SIR model with varying act.rate
param &lt;- param.dcm(inf.prob = 0.2, act.rate = 5:7,
                   rec.rate = 1/3, a.rate = 1/90, ds.rate = 1/100,
                   di.rate = 1/35, dr.rate = 1/100)
init &lt;- init.dcm(s.num = 1000, i.num = 1, r.num = 0)
control &lt;- control.dcm(type = "SIR", nsteps = 25, verbose = FALSE)
mod1 &lt;- dcm(param, init, control)
comp_plot(mod1, at = 25, run = 3)

## Example 2: ICM SIR model with 3 simulations
param &lt;- param.icm(inf.prob = 0.2, act.rate = 3, rec.rate = 1/50,
                   a.rate = 1/100, ds.rate = 1/100,
                   di.rate = 1/90, dr.rate = 1/100)
init &lt;- init.icm(s.num = 500, i.num = 1, r.num = 0)
control &lt;- control.icm(type = "SIR", nsteps = 25,
                       nsims = 3, verbose = FALSE)
mod2 &lt;- icm(param, init, control)
comp_plot(mod2, at = 25, digits = 1)

</code></pre>

<hr>
<h2 id='control.dcm'>Control Settings for Deterministic Compartmental Models</h2><span id='topic+control.dcm'></span>

<h3>Description</h3>

<p>Sets the controls for deterministic compartmental models
simulated with <code><a href="#topic+dcm">dcm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.dcm(
  type,
  nsteps,
  dt = 1,
  odemethod = "rk4",
  dede = FALSE,
  new.mod = NULL,
  sens.param = TRUE,
  print.mod = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.dcm_+3A_type">type</code></td>
<td>
<p>Disease type to be modeled, with the choice of <code>"SI"</code> for
Susceptible-Infected diseases, <code>"SIR"</code> for
Susceptible-Infected-Recovered diseases, and <code>"SIS"</code> for
Susceptible-Infected-Susceptible diseases.</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_nsteps">nsteps</code></td>
<td>
<p>Number of time steps to solve the model over or vector of times
to solve the model over. If the number of time steps, then this must
be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_dt">dt</code></td>
<td>
<p>Time unit for model solutions, with the default of 1. Model
solutions for fractional time steps may be obtained by setting this to
a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_odemethod">odemethod</code></td>
<td>
<p>Ordinary differential equation (ODE) integration method,
with the default of the &quot;Runge-Kutta 4&quot; method (see <code><a href="deSolve.html#topic+ode">ode</a></code>
for other options).</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_dede">dede</code></td>
<td>
<p>If <code>TRUE</code>, use the delayed differential equation solver,
which allows for time-lagged variables.</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_new.mod">new.mod</code></td>
<td>
<p>If not running a base model type, a function with a new
model to be simulated (see details).</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_sens.param">sens.param</code></td>
<td>
<p>If <code>TRUE</code>, evaluate arguments in parameters with
length greater than 1 as sensitivity analyses, with one model run per
value of the parameter. If <code>FALSE</code>, one model will be run with
parameters of arbitrary length (the model may error unless the model
function is designed to accomodate parameter vectors).</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_print.mod">print.mod</code></td>
<td>
<p>If <code>TRUE</code>, print the model form to the console.</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print model progress to the console.</p>
</td></tr>
<tr><td><code id="control.dcm_+3A_...">...</code></td>
<td>
<p>additional control settings passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>control.dcm</code> sets the required control settings for any deterministic
compartmental models solved with the <code><a href="#topic+dcm">dcm</a></code> function. Controls are
required for both base model types and original models. For an overview of
control settings for base DCM class models, consult the
<a href="http://www.epimodel.org/tut.html">Basic DCMs</a> tutorial.
For all base models, the <code>type</code> argument is a necessary parameter
and it has no default.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code>control.dcm</code>.
</p>


<h3>New Model Functions</h3>

<p>The form of the model function for base models may be displayed with the
<code>print.mod</code> argument set to <code>TRUE</code>. In this case, the model will
not be run. These model forms may be used as templates to write original
model functions.
</p>
<p>These new models may be input and solved with <code><a href="#topic+dcm">dcm</a></code> using the
<code>new.mod</code> argument, which requires as input a model function. Details
and examples are found in the
<a href="http://www.epimodel.org/tut.html">New DCMs</a> tutorial.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+param.dcm">param.dcm</a></code> to specify model parameters and
<code><a href="#topic+init.dcm">init.dcm</a></code> to specify the initial conditions. Run the
parameterized model with <code><a href="#topic+dcm">dcm</a></code>.
</p>

<hr>
<h2 id='control.icm'>Control Settings for Stochastic Individual Contact Models</h2><span id='topic+control.icm'></span>

<h3>Description</h3>

<p>Sets the controls for stochastic individual contact models
simulated with <code><a href="#topic+icm">icm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.icm(
  type,
  nsteps,
  nsims = 1,
  initialize.FUN = initialize.icm,
  infection.FUN = NULL,
  recovery.FUN = NULL,
  departures.FUN = NULL,
  arrivals.FUN = NULL,
  prevalence.FUN = NULL,
  verbose = FALSE,
  verbose.int = 0,
  skip.check = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.icm_+3A_type">type</code></td>
<td>
<p>Disease type to be modeled, with the choice of <code>"SI"</code> for
Susceptible-Infected diseases, <code>"SIR"</code> for
Susceptible-Infected-Recovered diseases, and <code>"SIS"</code> for
Susceptible-Infected-Susceptible diseases.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_nsteps">nsteps</code></td>
<td>
<p>Number of time steps to solve the model over. This must be a
positive integer.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_nsims">nsims</code></td>
<td>
<p>Number of simulations to run.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_initialize.fun">initialize.FUN</code></td>
<td>
<p>Module to initialize the model at the outset, with the
default function of <code><a href="#topic+initialize.icm">initialize.icm</a></code>.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_infection.fun">infection.FUN</code></td>
<td>
<p>Module to simulate disease infection, with the default
function of <code><a href="#topic+infection.icm">infection.icm</a></code>.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_recovery.fun">recovery.FUN</code></td>
<td>
<p>Module to simulate disease recovery, with the default
function of <code><a href="#topic+recovery.icm">recovery.icm</a></code>.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_departures.fun">departures.FUN</code></td>
<td>
<p>Module to simulate departures or exits, with the
default function of <code><a href="#topic+departures.icm">departures.icm</a></code>.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_arrivals.fun">arrivals.FUN</code></td>
<td>
<p>Module to simulate arrivals or entries, with the default
function of <code><a href="#topic+arrivals.icm">arrivals.icm</a></code>.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_prevalence.fun">prevalence.FUN</code></td>
<td>
<p>Module to calculate disease prevalence at each time
step, with the default function of <code><a href="#topic+prevalence.icm">prevalence.icm</a></code>.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print model progress to the console.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_verbose.int">verbose.int</code></td>
<td>
<p>Time step interval for printing progress to console, where
0 (the default) prints completion status of entire simulation and
positive integer <code>x</code> prints progress after every <code>x</code> time
steps.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_skip.check">skip.check</code></td>
<td>
<p>If <code>TRUE</code>, skips the default error checking for the
structure and consistency of the parameter values, initial conditions,
and control settings before running base epidemic models. Setting
this to <code>FALSE</code> is recommended when running models with new
modules specified.</p>
</td></tr>
<tr><td><code id="control.icm_+3A_...">...</code></td>
<td>
<p>Additional control settings passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>control.icm</code> sets the required control settings for any stochastic
individual contact model solved with the <code><a href="#topic+icm">icm</a></code> function. Controls
are required for both base model types and when passing original process
modules. For an overview of control settings for base ICM class models,
consult the <a href="http://www.epimodel.org/tut.html">Basic ICMs</a> tutorial. For
all base models, the <code>type</code> argument is a necessary parameter and it has
no default.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code>control.icm</code>.
</p>


<h3>New Modules</h3>

<p>Base ICM models use a set of module functions that specify
how the individual agents in the population are subjected to infection,
recovery, demographics, and other processes. Core modules are those listed in
the <code>.FUN</code> arguments. For each module, there is a default function used
in the simulation. The default infection module, for example, is contained in
the <code><a href="#topic+infection.icm">infection.icm</a></code> function.
</p>
<p>For original models, one may substitute replacement module functions for any
of the default functions. New modules may be added to the workflow at each
time step by passing a module function via the <code>...</code> argument.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+param.icm">param.icm</a></code> to specify model parameters and
<code><a href="#topic+init.icm">init.icm</a></code> to specify the initial conditions. Run the
parameterized model with <code><a href="#topic+icm">icm</a></code>.
</p>

<hr>
<h2 id='control.net'>Control Settings for Stochastic Network Models</h2><span id='topic+control.net'></span>

<h3>Description</h3>

<p>Sets the controls for stochastic network models simulated with
<code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.net(
  type,
  nsteps,
  start = 1,
  nsims = 1,
  ncores = 1,
  resimulate.network = FALSE,
  tergmLite = FALSE,
  cumulative.edgelist = FALSE,
  truncate.el.cuml = 0,
  attr.rules,
  epi.by,
  initialize.FUN = initialize.net,
  resim_nets.FUN = resim_nets,
  summary_nets.FUN = summary_nets,
  infection.FUN = NULL,
  recovery.FUN = NULL,
  departures.FUN = NULL,
  arrivals.FUN = NULL,
  nwupdate.FUN = nwupdate.net,
  prevalence.FUN = prevalence.net,
  verbose.FUN = verbose.net,
  module.order = NULL,
  save.nwstats = TRUE,
  nwstats.formula = "formation",
  save.transmat = TRUE,
  save.network,
  save.other,
  verbose = TRUE,
  verbose.int = 1,
  skip.check = FALSE,
  raw.output = FALSE,
  tergmLite.track.duration = FALSE,
  set.control.ergm = control.simulate.formula(MCMC.burnin = 2e+05),
  set.control.tergm = control.simulate.formula.tergm(),
  save.diss.stats = TRUE,
  dat.updates = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.net_+3A_type">type</code></td>
<td>
<p>Disease type to be modeled, with the choice of <code>"SI"</code> for Susceptible-Infected
diseases, <code>"SIR"</code> for Susceptible-Infected-Recovered diseases, and <code>"SIS"</code> for
Susceptible-Infected-Susceptible diseases.</p>
</td></tr>
<tr><td><code id="control.net_+3A_nsteps">nsteps</code></td>
<td>
<p>Number of time steps to simulate the model over. This must be a positive integer
that is equal to the final step of a simulation. If a simulation is restarted with <code>start</code>
argument, this number must be at least one greater than that argument's value.</p>
</td></tr>
<tr><td><code id="control.net_+3A_start">start</code></td>
<td>
<p>For models with network resimulation, time point to start up the simulation. For
restarted simulations, this must be one greater than the final time step in the prior
simulation and must be less than the value in <code>nsteps</code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_nsims">nsims</code></td>
<td>
<p>The total number of disease simulations.</p>
</td></tr>
<tr><td><code id="control.net_+3A_ncores">ncores</code></td>
<td>
<p>Number of processor cores to run multiple simulations on, using the <code>foreach</code> and
<code>doParallel</code> implementations.</p>
</td></tr>
<tr><td><code id="control.net_+3A_resimulate.network">resimulate.network</code></td>
<td>
<p>If <code>TRUE</code>, resimulate the network at each time step. This is required
when the epidemic or demographic processes impact the network structure (e.g., vital
dynamics).</p>
</td></tr>
<tr><td><code id="control.net_+3A_tergmlite">tergmLite</code></td>
<td>
<p>Logical indicating usage of either <code>tergm</code> (<code>tergmLite = FALSE</code>), or <code>tergmLite</code>
(<code>tergmLite = TRUE</code>). Default of <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_cumulative.edgelist">cumulative.edgelist</code></td>
<td>
<p>If <code>TRUE</code>, calculates a cumulative edgelist within the network
simulation module. This is used when tergmLite is used and the entire networkDynamic
object is not used.</p>
</td></tr>
<tr><td><code id="control.net_+3A_truncate.el.cuml">truncate.el.cuml</code></td>
<td>
<p>Number of time steps of the cumulative edgelist to retain. See help for
<code><a href="#topic+update_cumulative_edgelist">update_cumulative_edgelist</a></code> for options.</p>
</td></tr>
<tr><td><code id="control.net_+3A_attr.rules">attr.rules</code></td>
<td>
<p>A list containing the  rules for setting the attributes of incoming nodes, with
one list element per attribute to be set (see details below).</p>
</td></tr>
<tr><td><code id="control.net_+3A_epi.by">epi.by</code></td>
<td>
<p>A character vector of length 1 containing a nodal attribute for which subgroup
stratified prevalence summary statistics are calculated. This nodal attribute must be
contained in the network model formation formula, otherwise it is ignored.</p>
</td></tr>
<tr><td><code id="control.net_+3A_initialize.fun">initialize.FUN</code></td>
<td>
<p>Module to initialize the model at time 1, with the default function of
<code><a href="#topic+initialize.net">initialize.net</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_resim_nets.fun">resim_nets.FUN</code></td>
<td>
<p>Module to resimulate the network at each time step, with the default
function of <code><a href="#topic+resim_nets">resim_nets</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_summary_nets.fun">summary_nets.FUN</code></td>
<td>
<p>Module to extract summary statistics of the network
at each time step, with the default function of <code><a href="#topic+summary_nets">summary_nets</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_infection.fun">infection.FUN</code></td>
<td>
<p>Module to simulate disease infection, with the default function of
<code><a href="#topic+infection.net">infection.net</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_recovery.fun">recovery.FUN</code></td>
<td>
<p>Module to simulate disease recovery, with the default function of
<code><a href="#topic+recovery.net">recovery.net</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_departures.fun">departures.FUN</code></td>
<td>
<p>Module to simulate departure or exit, with the default function of
<code><a href="#topic+departures.net">departures.net</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_arrivals.fun">arrivals.FUN</code></td>
<td>
<p>Module to simulate arrivals or entries, with the default function of
<code><a href="#topic+arrivals.net">arrivals.net</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_nwupdate.fun">nwupdate.FUN</code></td>
<td>
<p>Module to handle updating of network structure and nodal attributes due to
exogenous epidemic model processes, with the default function of <code><a href="#topic+nwupdate.net">nwupdate.net</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_prevalence.fun">prevalence.FUN</code></td>
<td>
<p>Module to calculate disease prevalence at each time step, with the default
function of <code><a href="#topic+prevalence.net">prevalence.net</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_verbose.fun">verbose.FUN</code></td>
<td>
<p>Module to print simulation progress to screen, with the default function of
<code><a href="#topic+verbose.net">verbose.net</a></code>.</p>
</td></tr>
<tr><td><code id="control.net_+3A_module.order">module.order</code></td>
<td>
<p>A character vector of module names that lists modules in the order in which
they should be evaluated within each time step. If <code>NULL</code>, the modules will be evaluated
as follows: first any new modules supplied through <code>...</code> in the order in which they are
listed, then the built-in modules in the order in which they are listed as arguments
above. <code>initialize.FUN</code> will always be run first and <code>verbose.FUN</code> will always be run last.</p>
</td></tr>
<tr><td><code id="control.net_+3A_save.nwstats">save.nwstats</code></td>
<td>
<p>If <code>TRUE</code>, save network statistics in a data frame. The statistics to be
saved are specified in the <code>nwstats.formula</code> argument.</p>
</td></tr>
<tr><td><code id="control.net_+3A_nwstats.formula">nwstats.formula</code></td>
<td>
<p>A right-hand sided ERGM formula that includes network statistics of
interest, with the default to the formation formula terms. Supports <code><a href="#topic+multilayer">multilayer</a></code>
specification.</p>
</td></tr>
<tr><td><code id="control.net_+3A_save.transmat">save.transmat</code></td>
<td>
<p>If <code>TRUE</code>, complete transmission matrix is saved at simulation end.</p>
</td></tr>
<tr><td><code id="control.net_+3A_save.network">save.network</code></td>
<td>
<p>If <code>TRUE</code>, networkDynamic or networkLite object is saved at simulation end.</p>
</td></tr>
<tr><td><code id="control.net_+3A_save.other">save.other</code></td>
<td>
<p>A character vector of elements on the <code>netsim_dat</code> main data list to save out
after each simulation. One example for base models is the attribute list, <code>"attr"</code>, at
the final time step.</p>
</td></tr>
<tr><td><code id="control.net_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print model progress to the console.</p>
</td></tr>
<tr><td><code id="control.net_+3A_verbose.int">verbose.int</code></td>
<td>
<p>Time step interval for printing progress to console, where <code>0</code> prints
completion status of entire simulation and positive integer <code>x</code> prints progress after
every <code>x</code> time steps. The default is to print progress after each time step.</p>
</td></tr>
<tr><td><code id="control.net_+3A_skip.check">skip.check</code></td>
<td>
<p>If <code>TRUE</code>, skips the default error checking for the structure and consistency
of the parameter values, initial conditions, and control settings before running base
epidemic models. Setting this to <code>FALSE</code> is recommended when running models with new
modules specified.</p>
</td></tr>
<tr><td><code id="control.net_+3A_raw.output">raw.output</code></td>
<td>
<p>If <code>TRUE</code>, <code>netsim</code> will output a list of raw data (one per simulation) instead
of a cleaned and formatted <code>netsim</code> object.</p>
</td></tr>
<tr><td><code id="control.net_+3A_tergmlite.track.duration">tergmLite.track.duration</code></td>
<td>
<p>If <code>TRUE</code>, track duration information for models in <code>tergmLite</code>
simulations. Supports <code><a href="#topic+multilayer">multilayer</a></code> specification.</p>
</td></tr>
<tr><td><code id="control.net_+3A_set.control.ergm">set.control.ergm</code></td>
<td>
<p>Control arguments passed to <code>ergm::simulate_formula.network</code>. In <code>netsim</code>,
this is only used when initializing the network with <code>edapprox = TRUE</code>. All other
simulations in <code>netsim</code> use <code>tergm</code>. Supports <code><a href="#topic+multilayer">multilayer</a></code> specification.</p>
</td></tr>
<tr><td><code id="control.net_+3A_set.control.tergm">set.control.tergm</code></td>
<td>
<p>Control arguments passed to <code>tergm::simulate_formula.network</code>. See the
help file for <code><a href="#topic+netdx">netdx</a></code> for details and examples on specifying this parameter. Supports
<code><a href="#topic+multilayer">multilayer</a></code> specification.</p>
</td></tr>
<tr><td><code id="control.net_+3A_save.diss.stats">save.diss.stats</code></td>
<td>
<p>If <code>TRUE</code>, <code>netsim</code> will compute and save duration and dissolution
statistics for plotting and printing, provided <code>save.network</code> is <code>TRUE</code>, <code>tergmLite</code> is
<code>FALSE</code>, and the dissolution model is homogeneous.</p>
</td></tr>
<tr><td><code id="control.net_+3A_dat.updates">dat.updates</code></td>
<td>
<p>Either <code>NULL</code>, a single function taking arguments <code>dat</code>,
<code>at</code>, and <code>network</code>, or a list of functions of length one greater
than the number of networks being simulated, with each function in
the list taking arguments <code>dat</code> and <code>at</code>. Here <code>dat</code> is the main
<code>netsim_dat</code> class object, <code>at</code> is the current timestep, and <code>network</code>
is an index indicating the current position within the sequence of
network (re)simulations on each time step. If a single function is
passed, it will be called before the first network is simulated and
after each network is simulated, with <code>network = 0L</code> before the first
network is simulated and with <code>network = i</code> after the <code>i</code>th network
is simulated. If a list of functions is passed, the first function
will be called before the first network is simulated, and the
<code>i + 1</code>th function will be called after the <code>i</code>th network is
simulated. (Note that <code>at = 0L</code> is used for initial cross-sectional
simulations in <code><a href="#topic+sim_nets_t1">sim_nets_t1</a></code>.) The function(s) should return the
<code>netsim_dat</code> object with any updates needed to correctly represent the
network states for calls to <code>simulate</code> and/or <code>summary</code>. This can be
useful if nodal attributes appearing in one network model depend on
nodal degrees in a different network.</p>
</td></tr>
<tr><td><code id="control.net_+3A_...">...</code></td>
<td>
<p>Additional control settings passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>control.net</code> sets the required control settings for any network model solved with the <code><a href="#topic+netsim">netsim</a></code>
function. Controls are required for both base model types and when passing original process
modules. For an overview of control settings for base models, consult the
<a href="http://www.epimodel.org/tut.html">Basic Network Models</a> tutorials. For all base models, the
<code>type</code> argument is a necessary parameter and it has no default.
</p>


<h3>Value</h3>

<p>An EpiModel object of class <code>control.net</code>.
</p>


<h3>The attr.rules Argument</h3>

<p>The <code>attr.rules</code> parameter is used to specify the rules for how nodal attribute values for
incoming nodes should be set. These rules are only necessary for models in which there are
incoming nodes (i.e., arrivals). There are three rules available for each attribute value:
</p>

<ul>
<li> <p><strong><code>current</code></strong>: new nodes will be assigned this attribute in proportion to the distribution of
that attribute among existing nodes at that current time step.
</p>
</li>
<li> <p><strong><code>t1</code></strong>: new nodes will be assigned this attribute in proportion to the distribution of that
attribute among nodes at time 1 (that is, the proportions set in the original network for
<code><a href="#topic+netest">netest</a></code>).
</p>
</li>
<li> <p><strong><code>Value</code></strong>: all new nodes will be assigned this specific value, with no variation.
For example, the rules list <code>attr.rules = list(race = "t1", sex = "current", status = "s")</code>
specifies how the race, sex, and status attributes should be set for incoming nodes. By default,
the rule is <code>"current"</code> for all attributes except status, in which case it is <code>"s"</code> (that is, all
incoming nodes are susceptible).
</p>
</li></ul>



<h3>Checkpointing Simulations</h3>

<p><code>netsim</code> has a built-in checkpoint system to prevent losing computation work if the function is
interrupted (SIGINT, power loss, time limit exceeded on a computation cluster). When enabled,
each simulation will be saved every <code>.checkpoint.steps</code> time steps. Then, if a checkpoint enabled
simulation is launched again with <code>netsim</code>, it will restart at the last checkpoint available in
the saved data.
</p>
<p>To enable the checkpoint capabilities of <code>netsim</code>, two control arguments have to be set:
<code>.checkpoint.steps</code>, which is a positive number of time steps to be run between each file save;
and <code>.checkpoint.dir</code>, which is the path to a directory to save the checkpointed data. If
<code>.checkpoint.dir</code> directory does not exist, <code>netsim</code> will attempt to create it on the first
checkpoint save. With these two controls defined, one can simply re-run <code>netsim</code> with the same
arguments to restart a set of simulations that were interrupted.
</p>
<p>Simulations are checkpointed individually: for example, if 3 simulations are run on a single core,
the first 2 are finished, then the interruption occurs during the third, <code>netsim</code> will only
restart the third one from the last checkpoint.
</p>
<p>A <code>.checkpoint.compress</code> argument can be set to overwrite the <code>compress</code> argument in <code>saveRDS</code>
used to save the checkpointed data. The current default for <code>saveRDS</code> is <code>gunzip (gz)</code>, which
provides fast compression that usually works well on <code>netsim</code> objects.
</p>
<p>By default, if <code>netsim</code> reaches the end of all simulations, the checkpoint data directory and its
content are removed before returning the <code>netsim</code> object. The <code>.checkpoint.keep</code> argument can be
set to <code>TRUE</code> to prevent this removal to inspect the raw simulation objects.
</p>


<h3>New Modules</h3>

<p>Base network models use a set of module functions that specify how the individual nodes in the
network are subjected to infection, recovery, demographics, and other processes. Core modules are
those listed in the <code>.FUN</code> arguments. For each module, there is a default function used in
the simulation. The default infection module, for example, is contained in the <code><a href="#topic+infection.net">infection.net</a></code>
function.
</p>
<p>For original models, one may substitute replacement module functions for any of the default
functions. New modules may be added to the workflow at each time step by passing a module function
via the <code>...</code> argument. Consult the <a href="http://www.epimodel.org/tut.html">New Network Models</a>
tutorials. One may remove existing modules, such as <code>arrivals.FUN</code>, from the workflow by setting
the parameter value for that argument to <code>NULL</code>.
</p>


<h3>End Horizon</h3>

<p><code>netsim</code> implements an &quot;End Horizon&quot; mechanism, where a set of modules are
removed from the simulation at a specific time step. This is enabled through
the <code>end.horizon</code> parameter to <code>control.net</code>.
</p>
<p>This parameter must receive a <code>list</code> with fields <code>at</code>, the time step at which
the end horizon occurs, and <code>modules</code>, a character vector with the names of
the modules to remove. (e.g 'list(at = 208, modules = c(&quot;arrivals.FUN&quot;,
&quot;infections.FUN&quot;)))
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+param.net">param.net</a></code> to specify model parameters and <code><a href="#topic+init.net">init.net</a></code> to specify the initial conditions.
Run the parameterized model with <code><a href="#topic+netsim">netsim</a></code>.
</p>

<hr>
<h2 id='copy_datattr_to_nwattr'>Copy Vertex Attributes from the <code>netsim_dat</code> List to the Network
Objects</h2><span id='topic+copy_datattr_to_nwattr'></span>

<h3>Description</h3>

<p>Copies the vertex attributes stored on the main <code>attr</code> list
of the <code>netsim_dat</code> object to each of the network objects
stored on the <code>netsim_dat</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_datattr_to_nwattr(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_datattr_to_nwattr_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_formula_term_attr">get_formula_term_attr</a></code>, <code><a href="#topic+get_attr_prop">get_attr_prop</a></code>,
<code><a href="#topic+auto_update_attr">auto_update_attr</a></code>, and
<code><a href="#topic+copy_nwattr_to_datattr">copy_nwattr_to_datattr</a></code>.
</p>

<hr>
<h2 id='copy_nwattr_to_datattr'>Copy Vertex Attributes From Network to <code>netsim_dat</code> List</h2><span id='topic+copy_nwattr_to_datattr'></span>

<h3>Description</h3>

<p>Copies the vertex attributes stored on the network object to the
main <code>attr</code> list in the <code>netsim_dat</code> data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_nwattr_to_datattr(dat, nw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_nwattr_to_datattr_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="copy_nwattr_to_datattr_+3A_nw">nw</code></td>
<td>
<p>Network from which to copy vertex attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_formula_term_attr">get_formula_term_attr</a></code>, <code><a href="#topic+get_attr_prop">get_attr_prop</a></code>,
<code><a href="#topic+auto_update_attr">auto_update_attr</a></code>, and
<code><a href="#topic+copy_datattr_to_nwattr">copy_datattr_to_nwattr</a></code>.
</p>

<hr>
<h2 id='create_dat_object'>Create a Minimal netsim_dat Main List Object for a Network Model</h2><span id='topic+create_dat_object'></span>

<h3>Description</h3>

<p>This helper function populates a <code>netsim_dat</code> main list
object with the minimal required elements. All parameters are
optional. When none are given the resulting object is only a
shell list of class <code>netsim_dat</code> with the different named
elements defined as empty lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_dat_object(param = list(), init = list(), control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_dat_object_+3A_param">param</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+param.net">param.net</a></code>.</p>
</td></tr>
<tr><td><code id="create_dat_object_+3A_init">init</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+init.net">init.net</a></code>.</p>
</td></tr>
<tr><td><code id="create_dat_object_+3A_control">control</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+control.net">control.net</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='create_scenario_list'>Make a list of EpiModel scenarios from a data.frame of scenarios</h2><span id='topic+create_scenario_list'></span>

<h3>Description</h3>

<p>An EpiModel scenario allows one or multiple set of parameters to be applied
to a model a predefined timesteps. They are usually used by a researcher who
wants to model counterfactuals using a pre calibrated model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_scenario_list(scenarios.df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_scenario_list_+3A_scenarios.df">scenarios.df</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of EpiModel scenarios
</p>


<h3>scenarios.df</h3>

<p>The <code>scenarios.df</code> is a <code>data.frame</code> of values to be used as
parameters.
</p>
<p>It must contain a &quot;.at&quot; column, specifying when the changes should occur.
It requires the &quot;updater&quot; module of EpiModel. <em>See, vignette</em>. If the &quot;.at&quot;
value of a row is less than two, the changes will be applied to the
parameter list iteself. The second mandatory column is &quot;.scenario.id&quot;. It
is used to distinguish the different scenarios. If multiple rows share the
same &quot;.scenario.id&quot;, the resulting scenario will contain one updater per row.
This permits modifying parameters at multiple points in time. (e.g. an
intervention limited in time).
</p>
<p>The other column names must correspond either to:
the name of one parameter if this parameter is of size 1 or the name of the
parameter with &quot;_1&quot;, &quot;_2&quot;, &quot;<em>N&quot; with the second part being the position of
the value for a parameter of size &gt; 1. This means that the parameter names
cannot contain any underscore &quot;</em>&quot;. (e.g &quot;a.rate&quot;, &quot;d.rate_1&quot;, &quot;d.rate_2&quot;)
</p>

<hr>
<h2 id='crosscheck.dcm'>Cross Checking of Inputs for Deterministic Compartmental Models</h2><span id='topic+crosscheck.dcm'></span>

<h3>Description</h3>

<p>This function checks that the three parameter lists from
<code><a href="#topic+param.dcm">param.dcm</a></code>, <code><a href="#topic+init.dcm">init.dcm</a></code>, and
<code><a href="#topic+control.dcm">control.dcm</a></code> are consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosscheck.dcm(param, init, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosscheck.dcm_+3A_param">param</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+param.dcm">param.dcm</a></code>.</p>
</td></tr>
<tr><td><code id="crosscheck.dcm_+3A_init">init</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+init.dcm">init.dcm</a></code>.</p>
</td></tr>
<tr><td><code id="crosscheck.dcm_+3A_control">control</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+control.dcm">control.dcm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns no objects.
</p>

<hr>
<h2 id='crosscheck.icm'>Cross Checking of Inputs for Stochastic Individual Contact Models</h2><span id='topic+crosscheck.icm'></span>

<h3>Description</h3>

<p>This function checks that the three parameter lists from
<code><a href="#topic+param.icm">param.icm</a></code>, <code><a href="#topic+init.icm">init.icm</a></code>, and
<code><a href="#topic+control.icm">control.icm</a></code> are consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosscheck.icm(param, init, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosscheck.icm_+3A_param">param</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+param.icm">param.icm</a></code>.</p>
</td></tr>
<tr><td><code id="crosscheck.icm_+3A_init">init</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+init.icm">init.icm</a></code>.</p>
</td></tr>
<tr><td><code id="crosscheck.icm_+3A_control">control</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+control.icm">control.icm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns no objects.
</p>

<hr>
<h2 id='crosscheck.net'>Cross Checking of Inputs for Stochastic Network Models</h2><span id='topic+crosscheck.net'></span>

<h3>Description</h3>

<p>This function checks that the estimation object from
<code><a href="#topic+netest">netest</a></code> and the three parameter lists from
<code><a href="#topic+param.net">param.net</a></code>, <code><a href="#topic+init.net">init.net</a></code>, and
<code><a href="#topic+control.net">control.net</a></code> are consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosscheck.net(x, param, init, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosscheck.net_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+netest">netest</a></code>.</p>
</td></tr>
<tr><td><code id="crosscheck.net_+3A_param">param</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+param.net">param.net</a></code>.</p>
</td></tr>
<tr><td><code id="crosscheck.net_+3A_init">init</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+init.net">init.net</a></code>.</p>
</td></tr>
<tr><td><code id="crosscheck.net_+3A_control">control</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+control.net">control.net</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns no objects.
</p>

<hr>
<h2 id='dcm'>Deterministic Compartmental Models</h2><span id='topic+dcm'></span>

<h3>Description</h3>

<p>Solves deterministic compartmental epidemic models for
infectious disease.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcm(param, init, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcm_+3A_param">param</code></td>
<td>
<p>Model parameters, as an object of class <code><a href="#topic+param.dcm">param.dcm</a></code>.</p>
</td></tr>
<tr><td><code id="dcm_+3A_init">init</code></td>
<td>
<p>Initial conditions, as an object of class <code><a href="#topic+init.dcm">init.dcm</a></code>.</p>
</td></tr>
<tr><td><code id="dcm_+3A_control">control</code></td>
<td>
<p>Control settings, as an object of class
<code><a href="#topic+control.dcm">control.dcm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dcm</code> function uses the ordinary differential equation solver in
the <code>deSolve</code> package to model disease as a deterministic compartmental
system. The parameterization for these models follows the standard approach
in <code>EpiModel</code>, with epidemic parameters, initial conditions, and control
settings. A description of solving DCMs with the <code>dcm</code> function may be
found in the <a href="http://www.epimodel.org/tut.html">Basic DCMs</a> tutorial.
</p>
<p>The <code>dcm</code> function performs  modeling of both base model types and
original models with new structures. Base model types include one-group
and two-group models with disease types for Susceptible-Infected (SI),
Susceptible-Infected-Recovered (SIR), and Susceptible-Infected-Susceptible
(SIS). New model types may be written and input into <code>dcm</code> following the
steps outlined in the <a href="http://www.epimodel.org/tut.html">New DCMs</a>
tutorial. Both base and original models require the <code>param</code>,
<code>init</code>, and <code>control</code> inputs.
</p>


<h3>Value</h3>

<p>A list of class <code>dcm</code> with the following elements:
</p>

<ul>
<li> <p><strong>param:</strong> the epidemic parameters passed into the model through
<code>param</code>, with additional parameters added as necessary.
</p>
</li>
<li> <p><strong>control:</strong> the control settings passed into the model through
<code>control</code>, with additional controls added as necessary.
</p>
</li>
<li> <p><strong>epi:</strong> a list of data frames, one for each epidemiological
output from the model. Outputs for base models always include the
size of each compartment, as well as flows in, out of, and between
compartments.
</p>
</li></ul>



<h3>References</h3>

<p>Soetaert K, Petzoldt T, Setzer W. Solving Differential Equations in
R: Package deSolve. Journal of Statistical Software. 2010; 33(9): 1-25.
<a href="https://doi.org/10.18637/jss.v033.i09">doi:10.18637/jss.v033.i09</a>.
</p>


<h3>See Also</h3>

<p>Extract the model results with <code><a href="#topic+as.data.frame.dcm">as.data.frame.dcm</a></code>.
Summarize the time-specific model results with <code><a href="#topic+summary.dcm">summary.dcm</a></code>.
Plot the model results with <code><a href="#topic+plot.dcm">plot.dcm</a></code>. Plot a compartment flow
diagram with <code><a href="#topic+comp_plot">comp_plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: SI Model (One-Group)
# Set parameters
param &lt;- param.dcm(inf.prob = 0.2, act.rate = 0.25)
init &lt;- init.dcm(s.num = 500, i.num = 1)
control &lt;- control.dcm(type = "SI", nsteps = 500)
mod1 &lt;- dcm(param, init, control)
mod1
plot(mod1)

## Example 2: SIR Model with Vital Dynamics (One-Group)
param &lt;- param.dcm(inf.prob = 0.2, act.rate = 5,
                   rec.rate = 1/3, a.rate = 1/90, ds.rate = 1/100,
                   di.rate = 1/35, dr.rate = 1/100)
init &lt;- init.dcm(s.num = 500, i.num = 1, r.num = 0)
control &lt;- control.dcm(type = "SIR", nsteps = 500)
mod2 &lt;- dcm(param, init, control)
mod2
plot(mod2)

## Example 3: SIS Model with act.rate Sensitivity Parameter
param &lt;- param.dcm(inf.prob = 0.2, act.rate = seq(0.1, 0.5, 0.1),
                   rec.rate = 1/50)
init &lt;- init.dcm(s.num = 500, i.num = 1)
control &lt;- control.dcm(type = "SIS", nsteps = 500)
mod3 &lt;- dcm(param, init, control)
mod3
plot(mod3)

## Example 4: SI Model with Vital Dynamics (Two-Group)
param &lt;- param.dcm(inf.prob = 0.4,  inf.prob.g2 = 0.1,
                   act.rate = 0.25, balance = "g1",
                   a.rate = 1/100, a.rate.g2 = NA,
                   ds.rate = 1/100, ds.rate.g2 = 1/100,
                   di.rate = 1/50, di.rate.g2 = 1/50)
init &lt;- init.dcm(s.num = 500, i.num = 1,
                 s.num.g2 = 500, i.num.g2 = 0)
control &lt;- control.dcm(type = "SI", nsteps = 500)
mod4 &lt;- dcm(param, init, control)
mod4
plot(mod4)

</code></pre>

<hr>
<h2 id='dcm.mods'>Deterministic Compartmental Model Functions</h2><span id='topic+dcm.mods'></span><span id='topic+mod_SI_1g_cl'></span><span id='topic+mod_SI_1g_op'></span><span id='topic+mod_SI_2g_cl'></span><span id='topic+mod_SI_2g_op'></span><span id='topic+mod_SIR_1g_cl'></span><span id='topic+mod_SIR_1g_op'></span><span id='topic+mod_SIR_2g_cl'></span><span id='topic+mod_SIR_2g_op'></span><span id='topic+mod_SIS_1g_cl'></span><span id='topic+mod_SIS_1g_op'></span><span id='topic+mod_SIS_2g_cl'></span><span id='topic+mod_SIS_2g_op'></span>

<h3>Description</h3>

<p>These functions parameterize the base deterministic
compartmental models solved using the <code><a href="#topic+dcm">dcm</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_SI_1g_cl(t, t0, parms)

mod_SI_1g_op(t, t0, parms)

mod_SI_2g_cl(t, t0, parms)

mod_SI_2g_op(t, t0, parms)

mod_SIR_1g_cl(t, t0, parms)

mod_SIR_1g_op(t, t0, parms)

mod_SIR_2g_cl(t, t0, parms)

mod_SIR_2g_op(t, t0, parms)

mod_SIS_1g_cl(t, t0, parms)

mod_SIS_1g_op(t, t0, parms)

mod_SIS_2g_cl(t, t0, parms)

mod_SIS_2g_op(t, t0, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcm.mods_+3A_t">t</code></td>
<td>
<p>Time vector, passed into model function internally through
<code><a href="#topic+dcm">dcm</a></code> via the control settings in
<code><a href="#topic+control.dcm">control.dcm</a></code>.</p>
</td></tr>
<tr><td><code id="dcm.mods_+3A_t0">t0</code></td>
<td>
<p>Initial conditions for model, passed into model function internally
through <code><a href="#topic+dcm">dcm</a></code> via the initial conditions in
<code><a href="#topic+init.dcm">init.dcm</a></code>.</p>
</td></tr>
<tr><td><code id="dcm.mods_+3A_parms">parms</code></td>
<td>
<p>Model parameters, passed into model function internally through
<code><a href="#topic+dcm">dcm</a></code> via the parameter settings in
<code><a href="#topic+param.dcm">param.dcm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This help page shows the names of all the base deterministic compartmental
model functions supported in EpiModel. Base models are those already
programmed interally within the software. The model functions may be printed
to see their internal structure, either directly on the console or by using
the <code>print.mod</code> argument in <code><a href="#topic+control.dcm">control.dcm</a></code>.
</p>
<p>The naming convention for the models listed here follows the format:
<code>mod_&lt;disease type&gt;_&lt;number of groups&gt;_&lt;vital dynamics&gt;</code>. The supported
disease types are SI, SIS, and SIR; the number of groups are 1 or 2; and the
vital dynamic options are closed (fixed population composition) or open (with
arrivals and departures).
</p>

<hr>
<h2 id='delete_attr'>Delete Elements from Attribute List</h2><span id='topic+delete_attr'></span>

<h3>Description</h3>

<p>Deletes elements from the main attribute list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_attr(dat, ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_attr_+3A_dat">dat</code></td>
<td>
<p>Either the <code>netsim_dat</code> class object passed through
<code>netsim</code> simulations, or the main data object passed through
<code>icm</code> simulations.</p>
</td></tr>
<tr><td><code id="delete_attr_+3A_ids">ids</code></td>
<td>
<p>ID numbers to delete from the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='delete_edges'>Remove Edges That Include Specified Vertices</h2><span id='topic+delete_edges'></span>

<h3>Description</h3>

<p>Given a current two-column matrix of edges and a vector of
vertex IDs, this function removes any rows of the edgelist in
which the IDs are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_edges(el, vid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_edges_+3A_el">el</code></td>
<td>
<p>A two-column matrix of current edges (edgelist).</p>
</td></tr>
<tr><td><code id="delete_edges_+3A_vid">vid</code></td>
<td>
<p>A vector of vertex IDs whose edges are to be deleted from the
edgelist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an updated edgelist object, with any edges including the specified
vertices removed.
</p>

<hr>
<h2 id='delete_vertices'>Fast Version of network::delete.vertices for Edgelist-formatted
Network</h2><span id='topic+delete_vertices'></span>

<h3>Description</h3>

<p>Given a current two-column matrix of edges and a vector of IDs
to delete from the matrix, this function first removes any rows
of the edgelist in which the IDs are present and then permutes
downward the index of IDs on the edgelist that were numerically
larger than the IDs deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_vertices(el, vid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_vertices_+3A_el">el</code></td>
<td>
<p>A two-column matrix of current edges (edgelist) with an attribute
variable <code>n</code> containing the total current network size.</p>
</td></tr>
<tr><td><code id="delete_vertices_+3A_vid">vid</code></td>
<td>
<p>A vector of IDs to delete from the edgelist.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in <code>EpiModel</code> modules to remove vertices (nodes)
from the edgelist object to account for exits from the population (e.g.,
deaths and out-migration).
</p>


<h3>Value</h3>

<p>Returns an updated edgelist object, <code>el</code>, with the edges of deleted
vertices removed from the edgelist and the ID numbers of the remaining edges
permuted downward.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("EpiModel")
set.seed(12345)
nw &lt;- network_initialize(100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
x &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

param &lt;- param.net(inf.prob = 0.3)
init &lt;- init.net(i.num = 10)
control &lt;- control.net(type = "SI", nsteps = 100, nsims = 5,
                       tergmLite = TRUE)

# Set seed for reproducibility
set.seed(123456)

# networkLite representation structure after initialization
dat &lt;- crosscheck.net(x, param, init, control)
dat &lt;- initialize.net(x, param, init, control)

# Current edges
head(dat$el[[1]], 20)

# Remove nodes 1 and 2
nodes.to.delete &lt;- 1:2
dat$el[[1]] &lt;- delete_vertices(dat$el[[1]], nodes.to.delete)

# Newly permuted edges
head(dat$el[[1]], 20)

## End(Not run)

</code></pre>

<hr>
<h2 id='deleteAttr'>Delete Elements from Attribute List</h2><span id='topic+deleteAttr'></span>

<h3>Description</h3>

<p>Deletes elements from the main attribute list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteAttr(attrList, ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteAttr_+3A_attrlist">attrList</code></td>
<td>
<p>Attribute list.</p>
</td></tr>
<tr><td><code id="deleteAttr_+3A_ids">ids</code></td>
<td>
<p>ID numbers to delete from the list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is deprecated; use <code><a href="#topic+delete_attr">delete_attr</a></code> instead.
</p>


<h3>Value</h3>

<p>The updated attribute list.
</p>

<hr>
<h2 id='depart_nodes'>Depart Nodes from the netsim_dat Object</h2><span id='topic+depart_nodes'></span>

<h3>Description</h3>

<p>Depart Nodes from the netsim_dat Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depart_nodes(dat, departures)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depart_nodes_+3A_dat">dat</code></td>
<td>
<p>the <code>netsim_dat</code> object</p>
</td></tr>
<tr><td><code id="depart_nodes_+3A_departures">departures</code></td>
<td>
<p>the vertex ids of nodes to depart</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>tergmLite</code> is <code>FALSE</code>, the vertex ids
<code>departures</code> are deactivated (from the current timestep onward) in each
<code>networkDynamic</code> stored in <code>dat$nw</code>. If <code>tergmLite</code> is
<code>TRUE</code>, the vertex ids <code>departures</code> are deleted from <code>dat$el</code>,
<code>dat$attr</code>, and <code>dat$net_attr</code>.
</p>


<h3>Value</h3>

<p>the updated <code>netsim_dat</code> object with the nodes in
<code>departures</code> departed
</p>

<hr>
<h2 id='departures.2g.net'>Departures: netsim Module</h2><span id='topic+departures.2g.net'></span>

<h3>Description</h3>

<p>This function simulates departure for use in <a href="#topic+netsim">netsim</a>
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departures.2g.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="departures.2g.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="departures.2g.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsim">netsim</a></code>
</p>

<hr>
<h2 id='departures.icm'>Departure: icm Module</h2><span id='topic+departures.icm'></span>

<h3>Description</h3>

<p>This function simulates departure for use in <code><a href="#topic+icm">icm</a></code>
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departures.icm(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="departures.icm_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="departures.icm_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icm">icm</a></code>
</p>

<hr>
<h2 id='departures.icm.bip'>Departure: Bipartite icm Module</h2><span id='topic+departures.icm.bip'></span>

<h3>Description</h3>

<p>This function simulates departure for use in <code><a href="#topic+icm">icm</a></code>
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departures.icm.bip(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="departures.icm.bip_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="departures.icm.bip_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icm">icm</a></code>
</p>

<hr>
<h2 id='departures.net'>Departures: netsim Module</h2><span id='topic+departures.net'></span>

<h3>Description</h3>

<p>This function simulates departure for use in <a href="#topic+netsim">netsim</a>
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departures.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="departures.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="departures.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsim">netsim</a></code>
</p>

<hr>
<h2 id='discord_edgelist'>Discordant Edgelist</h2><span id='topic+discord_edgelist'></span>

<h3>Description</h3>

<p>This function returns a <code>data.frame</code> with a discordant
edgelist, defined as the set of edges in which the status of the
two partners is one susceptible and one infected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discord_edgelist(dat, at, network = 1, infstat = "i", include.network = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discord_edgelist_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="discord_edgelist_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
<tr><td><code id="discord_edgelist_+3A_network">network</code></td>
<td>
<p>In case of models with multiple networks, the network to pull
the current edgelist from. Default of <code>network = 1</code>.</p>
</td></tr>
<tr><td><code id="discord_edgelist_+3A_infstat">infstat</code></td>
<td>
<p>Character vector of disease status values that are considered
infectious, defining the SI pairs.</p>
</td></tr>
<tr><td><code id="discord_edgelist_+3A_include.network">include.network</code></td>
<td>
<p>Should the <code>network</code> value be included as the
final column of the discordant edgelist?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal function works within the parent <code><a href="#topic+infection.net">infection.net</a></code>
function to pull the current edgelist from the dynamic network object, look
up the disease status of the head and tails on the edge, and subset the list
to those edges with one susceptible and one infected node.
</p>
<p>EpiModel v2.0.3 extended the function by allowing flexibility in the
definition what disease status counts as infectious, with the <code>infstat</code>
parameter. For extension models with multiple infectious states, this can be
a vector of length greater than 1: <code>infstat = c("i", "a")</code>.
</p>


<h3>Value</h3>

<p>This function returns a <code>data.frame</code> with the following columns:
</p>

<ul>
<li> <p><strong>time:</strong> time step queried.
</p>
</li>
<li> <p><strong>sus:</strong> ID number for the susceptible partner.
</p>
</li>
<li> <p><strong>inf:</strong> ID number for the infectious partner.
</p>
</li></ul>

<p>The output from this function is added to the transmission <code>data.frame</code>
object that is requested as output in <code>netsim</code> simulations with
the <code>save.trans=TRUE</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsim">netsim</a></code>, <code><a href="#topic+infection.net">infection.net</a></code>
</p>

<hr>
<h2 id='dissolution_coefs'>Dissolution Coefficients for Stochastic Network Models</h2><span id='topic+dissolution_coefs'></span>

<h3>Description</h3>

<p>Calculates dissolution coefficients, given a dissolution model
and average edge duration, to pass as offsets to an ERGM/TERGM
model fit in <code>netest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissolution_coefs(dissolution, duration, d.rate = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissolution_coefs_+3A_dissolution">dissolution</code></td>
<td>
<p>Right-hand sided STERGM dissolution formula
(see <code><a href="#topic+netest">netest</a></code>). See below for list of supported
dissolution models.</p>
</td></tr>
<tr><td><code id="dissolution_coefs_+3A_duration">duration</code></td>
<td>
<p>A vector of mean edge durations in arbitrary time units.</p>
</td></tr>
<tr><td><code id="dissolution_coefs_+3A_d.rate">d.rate</code></td>
<td>
<p>Departure or exit rate from the population, as a single
homogeneous rate that applies to the entire population.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs two calculations for dissolution coefficients
used in a network model estimated with <code><a href="#topic+netest">netest</a></code>:
</p>

<ol>
<li> <p><strong>Transformation:</strong> the mean durations of edges in a network are
mathematically transformed to logit coefficients.
</p>
</li>
<li> <p><strong>Adjustment:</strong> in a dynamic network simulation in an open
population (in which there are departures), it is further necessary to
adjust these coefficients; this upward adjustment accounts for
departure as a competing risk to edge dissolution.
</p>
</li></ol>

<p>The current dissolution models supported by this function and in network
model estimation in <code><a href="#topic+netest">netest</a></code> are as follows:
</p>

<ul>
<li> <p><code>~offset(edges)</code>: a homogeneous dissolution model in which the
edge duration is the same for all partnerships. This requires
specifying one duration value.
</p>
</li>
<li> <p><code>~offset(edges) + offset(nodematch("&lt;attr&gt;"))</code>: a heterogeneous
model in which the edge duration varies by whether the nodes in the
dyad have similar values of a specified attribute. The duration
vector should now contain two values: the first is the mean edge
duration of non-matched dyads, and the second is the duration of the
matched dyads.
</p>
</li>
<li> <p><code>~offset(edges) + offset(nodemix("&lt;attr&gt;"))</code>: a heterogeneous
model that extends the nodematch model to include non-binary
attributes for homophily. The duration vector should first contain
the base value, then the values for every other possible combination
in the term.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class <code>disscoef</code> with the following elements:
</p>

<ul>
<li> <p><strong>dissolution:</strong> right-hand sided STERGM dissolution formula
passed in the function call.
</p>
</li>
<li> <p><strong>duration:</strong> mean edge durations passed into the function.
</p>
</li>
<li> <p><strong>coef.crude:</strong> mean durations transformed into logit
coefficients.
</p>
</li>
<li> <p><strong>coef.adj:</strong> crude coefficients adjusted for the risk of
departure on edge persistence, if the <code>d.rate</code> argument is
supplied.
</p>
</li>
<li> <p><strong>coef.form.corr:</strong> corrections to be subtracted from formation
coefficients.
</p>
</li>
<li> <p><strong>d.rate:</strong> the departure rate.
</p>
</li>
<li> <p><strong>diss.model.type:</strong> the form of the dissolution model; options
include <code>edgesonly</code>, <code>nodematch</code>, and <code>nodemix</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Homogeneous dissolution model with no departures
dissolution_coefs(dissolution = ~offset(edges), duration = 25)

## Homogeneous dissolution model with departures
dissolution_coefs(dissolution = ~offset(edges), duration = 25,
                  d.rate = 0.001)

## Heterogeneous dissolution model in which same-race edges have
## shorter duration compared to mixed-race edges, with no departures
dissolution_coefs(dissolution = ~offset(edges) + offset(nodematch("race")),
                  duration = c(20, 10))

## Heterogeneous dissolution model in which same-race edges have
## shorter duration compared to mixed-race edges, with departures
dissolution_coefs(dissolution = ~offset(edges) + offset(nodematch("race")),
                  duration = c(20, 10), d.rate = 0.001)

## Not run: 
## Extended example for differential homophily by age group
# Set up the network with nodes categorized into 5 age groups
nw &lt;- network_initialize(n = 1000)
age.grp &lt;- sample(1:5, 1000, TRUE)
nw &lt;- set_vertex_attribute(nw, "age.grp", age.grp)

# durations = non-matched, age.grp1 &amp; age.grp1, age.grp2 &amp; age.grp2, ...
# TERGM will include differential homophily by age group with nodematch term
# Target stats for the formation model are overall edges, and then the number
# matched within age.grp 1, age.grp 2, ..., age.grp 5
form &lt;- ~edges + nodematch("age.grp", diff = TRUE)
target.stats &lt;- c(450, 100, 125, 40, 80, 100)

# Target stats for the dissolution model are duration of non-matched edges,
# then duration of edges matched within age.grp 1, age.grp 2, ..., age.grp 5
durs &lt;- c(60, 30, 80, 100, 125, 160)
diss &lt;- dissolution_coefs(~offset(edges) +
                            offset(nodematch("age.grp", diff = TRUE)),
                          duration = durs)

# Fit the TERGM
fit &lt;- netest(nw, form, target.stats, diss)

# Full diagnostics to evaluate model fit
dx &lt;- netdx(fit, nsims = 10, ncores = 4, nsteps = 300)
print(dx)

# Simulate one long time series to examine timed edgelist
dx &lt;- netdx(fit, nsims = 1, nsteps = 5000, keep.tedgelist = TRUE)

# Extract timed-edgelist
te &lt;- as.data.frame(dx)
head(te)

# Limit to non-censored edges
te &lt;- te[which(te$onset.censored == FALSE &amp; te$terminus.censored == FALSE),
         c("head", "tail", "duration")]
head(te)

# Look up the age group of head and tail nodes
te$ag.head &lt;- age.grp[te$head]
te$ag.tail &lt;- age.grp[te$tail]
head(te)

# Recover average edge durations for age-group pairing
mean(te$duration[te$ag.head != te$ag.tail])
mean(te$duration[te$ag.head == 1 &amp; te$ag.tail == 1])
mean(te$duration[te$ag.head == 2 &amp; te$ag.tail == 2])
mean(te$duration[te$ag.head == 3 &amp; te$ag.tail == 3])
mean(te$duration[te$ag.head == 4 &amp; te$ag.tail == 4])
mean(te$duration[te$ag.head == 5 &amp; te$ag.tail == 5])
durs

## End(Not run)

</code></pre>

<hr>
<h2 id='edgelist_censor'>Table of Edge Censoring</h2><span id='topic+edgelist_censor'></span>

<h3>Description</h3>

<p>Outputs a table of the number and percent of edges that are
left-censored, right-censored, both-censored, or uncensored for
a <code>networkDynamic</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist_censor(el)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgelist_censor_+3A_el">el</code></td>
<td>
<p>A timed edgelist with start and end times extracted from a
<code>networkDynamic</code> object using the
<code>as.data.frame.networkDynamic</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a STERGM simulation over a specified number of time steps, the edges
within that simulation may be left-censored (started before the first step),
right-censored (continued after the last step), right and left-censored, or
uncensored. The amount of censoring will increase when the average edge
duration approaches the length of the simulation.
</p>


<h3>Value</h3>

<p>A 4 x 2 table containing the number and percent of edges in <code>el</code>
that are left-censored, right-censored, both-censored, or uncensored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initialize and parameterize network model
nw &lt;- network_initialize(n = 100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)

# Model estimation
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Simulate the network and extract a timed edgelist
dx &lt;- netdx(est, nsims = 1, nsteps = 100, keep.tedgelist = TRUE,
      verbose = FALSE)
el &lt;- as.data.frame(dx)

# Calculate censoring
edgelist_censor(el)

</code></pre>

<hr>
<h2 id='edges_correct'>Adjustment for the Edges Coefficient with Changing Network Size</h2><span id='topic+edges_correct'></span>

<h3>Description</h3>

<p>Adjusts the edges coefficient in a dynamic network model
simulated in <code><a href="#topic+netsim">netsim</a></code> to preserve the mean
degree of nodes in the network. Requires <code>at &gt;= 2</code>.
Maintains the <code>sim.num(.g2)</code> epi fields (initialized in
<code><a href="#topic+sim_nets_t1">sim_nets_t1</a></code>) for computing the coefficient
adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_correct(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_correct_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="edges_correct_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='epi_trackers'>Function to run the user-provided epi trackers</h2><span id='topic+epi_trackers'></span>

<h3>Description</h3>

<p>see the &quot;Working with Custom Attributes and Summary Statistics in EpiModel&quot;
vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epi_trackers(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epi_trackers_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>The <code>tracker.list</code> list</h3>

<p><code>.tracker.list</code> is a list of NAMED functions stored in the
<code>control</code> list of the main <code>netsim_dat</code> class object.
</p>


<h3>Tracker Functions</h3>

<p>This function will apply the tracker functions present in the control list
<code>.tracker.list</code>. Each tracker must be a function with EXACTLY one
argument: the <code>netsim_dat</code> main list object. They must return a VALUE of
length one (numeric, logical or character).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsim">netsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Create some trackers
epi_prop_infected &lt;- function(dat) {
  # we need two attributes for our calculation: `status` and `active`
  needed_attributes &lt;- c("status", "active")
  # we use `with` to simplify code
  output &lt;- with(EpiModel::get_attr_list(dat, needed_attributes), {
    pop &lt;- active == 1             # we only look at active nodes
    cond &lt;- status == "i"   # which are infected
    # how many are `infected` among the `active`
    sum(cond &amp; pop, na.rm = TRUE) / sum(pop, na.rm = TRUE)
  })
  return(output)
}

epi_s_num &lt;- function(dat) {
  needed_attributes &lt;- c("status")
  output &lt;- with(get_attr_list(dat, needed_attributes), {
    sum(status == "s", na.rm = TRUE)
  })
  return(output)
}

# Store the trackers in a named list. The names will be used as column names
# for in the `epi` list
some.trackers &lt;- list(
  prop_infected = epi_prop_infected,
  s_num         = epi_s_num
)

# Make a simple SI model with custom trackers
control &lt;- EpiModel::control.net(
  type = "SI",
  nsims = 1,
  nsteps = 50,
  verbose = FALSE,
  .tracker.list = some.trackers
)

param &lt;- EpiModel::param.net(
  inf.prob = 0.3,
  act.rate = 0.1
)

nw &lt;- network_initialize(n = 50)
nw &lt;- set_vertex_attribute(nw, "race", rbinom(50, 1, 0.5))
est &lt;- EpiModel::netest(
  nw,
  formation = ~edges,
  target.stats = 25,
  coef.diss = dissolution_coefs(~offset(edges), 10, 0),
  verbose = FALSE
)

init &lt;- EpiModel::init.net(i.num = 10)
sim &lt;- EpiModel::netsim(est, param, init, control)

d &lt;- as.data.frame(sim)
d

## End(Not run)

</code></pre>

<hr>
<h2 id='EpiModel-package'>Mathematical Modeling of Infectious Disease Dynamics</h2><span id='topic+EpiModel-package'></span><span id='topic+EpiModel'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> EpiModel</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.4.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-06-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>The EpiModel software package provides tools for building, solving, and
visualizing mathematical models of infectious disease dynamics. These tools
allow users to simulate epidemic models in multiple frameworks for both
pedagogical purposes (&quot;base models&quot;) and novel research purposes
(&quot;extension models&quot;).
</p>


<h3>Model Classes and Infectious Disease Types</h3>

<p>EpiModel provides functionality for three classes of epidemic models:
</p>

<ul>
<li> <p><strong>Deterministic Compartmental Models:</strong> these continuous-time
models are solved using ordinary differential equations. EpiModel
allows for easy specification of sensitivity analyses to compare
multiple scenarios of the same model across different parameter
values.
</p>
</li>
<li> <p><strong>Stochastic Individual Contact Models:</strong> a novel class of
individual-based, microsimulation models that were developed to add
random variation in all components of the transmission system, from
infection to recovery to vital dynamics (arrivals and departures).
</p>
</li>
<li> <p><strong>Stochastic Network Models:</strong> with the underlying statistical
framework of temporal exponential random graph models (ERGMs) recently
developed in the <strong>Statnet</strong> suite of software in R, network
models over epidemics simulate edge (e.g., partnership) formation and
dissolution stochastically according to a specified statistical model,
with disease spread across that network.
</p>
</li></ul>

<p>EpiModel supports three infectious disease types to be run across all of the
three classes.
</p>

<ul>
<li> <p><strong>Susceptible-Infectious (SI):</strong> a two-state disease in which
there is life-long infection without recovery. HIV/AIDS is one
example, although for this case it is common to model infection
stages as separate compartments.
</p>
</li>
<li> <p><strong>Susceptible-Infectious-Recovered (SIR):</strong> a three-stage
disease in which one has life-long recovery with immunity after
infection. Measles is one example, but modern models for the disease
also require consideration of vaccination patterns in the population.
</p>
</li>
<li> <p><strong>Susceptible-Infectious-Susceptible (SIS):</strong> a two-stage
disease in which one may transition back and forth from the
susceptible to infected states throughout life. Examples include
bacterial sexually transmitted diseases like gonorrhea.
</p>
</li></ul>

<p>These basic disease types may be extended in any arbitrarily complex way to
simulate specific diseases for research questions.
</p>


<h3>Model Parameterization and Simulation</h3>

<p>EpiModel uses three model setup functions for each model class to input the
necessary parameters, initial conditions, and control settings:
</p>

<ul>
<li> <p><code><a href="#topic+param.dcm">param.dcm</a></code>, <code><a href="#topic+param.icm">param.icm</a></code>, and
<code><a href="#topic+param.net">param.net</a></code> are used to input epidemic parameters for each
of the three model classes. Parameters include the rate of contacts or
acts between actors, the probability of transmission per contact, and
recovery and demographic rates for models that include those
transitions.
</p>
</li>
<li> <p><code><a href="#topic+init.dcm">init.dcm</a></code>, <code><a href="#topic+init.icm">init.icm</a></code>, and
<code><a href="#topic+init.net">init.net</a></code> are used to input the initial conditions for
each class. The main conditions are limited to the numbers or, if
applicable, the specific agents in the population who are infected or
recovered at the simulation outset.
</p>
</li>
<li> <p><code><a href="#topic+control.dcm">control.dcm</a></code>, <code><a href="#topic+control.icm">control.icm</a></code>, and
<code><a href="#topic+control.net">control.net</a></code> are used to specify the remaining control
settings for each simulation. The core controls for base model
types include the disease type, number of time steps, and number of
simulations. Controls are also used to input new model functions (for
DCMs) and new model modules (for ICMs and network models) to allow the
user to simulate fully original epidemic models in EpiModel. See the
documentation for the specific control functions help pages.
</p>
</li></ul>

<p>With the models parameterized, the functions for simulating epidemic models
are:
</p>

<ul>
<li> <p><code><a href="#topic+dcm">dcm</a></code> for deterministic compartmental models.
</p>
</li>
<li> <p><code><a href="#topic+icm">icm</a></code> for individual contact models.
</p>
</li>
<li><p> Network models are simulated in a three-step process:
</p>

<ol>
<li> <p><code><a href="#topic+netest">netest</a></code> estimates the statistical model for the network
structure itself (i.e., how partnerships form and dissolve over time
given the parameterization of those processes). This function is a
wrapper around the <code>ergm</code> and <code>tergm</code> functions in the
<code>ergm</code> and <code>tergm</code> packages. The current statistical
framework for model simulation is called &quot;egocentric inference&quot;:
target statistics summarizing these formation and dissolution
processes collected from an egocentric sample of the population.
</p>
</li>
<li> <p><code><a href="#topic+netdx">netdx</a></code> runs diagnostics on the dynamic model fit by
simulating the base network over time to ensure the model fits the
targets for formation and dissolution.
</p>
</li>
<li> <p><code><a href="#topic+netsim">netsim</a></code> simulates the stochastic network epidemic
models, with a given network model fit in <code><a href="#topic+netest">netest</a></code>. Here
the function requires this model fit object along with the
parameters, initial conditions, and control settings as defined
above.
</p>
</li></ol>

</li></ul>



<h3>References</h3>

<p>The EpiModel website is at <a href="http://www.epimodel.org/">http://www.epimodel.org/</a>, and the source
code is at <a href="https://github.com/EpiModel/EpiModel">https://github.com/EpiModel/EpiModel</a>. Bug reports and
feature requests are welcome.
</p>
<p>Our primary methods paper on EpiModel is published in the <strong>Journal of
Statistical Software</strong>. If you use EpiModel for any research or teaching
purposes, please cite this reference:
</p>
<p>Jenness SM, Goodreau SM, and Morris M. EpiModel: An R Package for
Mathematical Modeling of Infectious Disease over Networks. Journal of
Statistical Software. 2018; 84(8): 1-47. <a href="https://doi.org/10.18637/jss.v084.i08">doi:10.18637/jss.v084.i08</a>.
</p>
<p>We have also developed two extension packages for modeling specific disease
dynamics. For HIV and bacterial sexually transmitted infections, we have
developed <code>EpiModelHIV</code>, which is available on Github at
<a href="https://github.com/EpiModel/EpiModelHIV">https://github.com/EpiModel/EpiModelHIV</a>. For COVID-19, we have
developed <code>EpiModelCOVID</code>, which is available at
<a href="https://github.com/EpiModel/EpiModelCOVID">https://github.com/EpiModel/EpiModelCOVID</a>.
</p>

<hr>
<h2 id='epiweb'>EpiModel Web</h2><span id='topic+epiweb'></span>

<h3>Description</h3>

<p>Runs a web browser-based GUI of deterministic compartmental
models, stochastic individual contact models, and basic network
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epiweb(class, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epiweb_+3A_class">class</code></td>
<td>
<p>Model class, with options of <code>"dcm"</code>, <code>"icm"</code>, and <code>"net"</code>.</p>
</td></tr>
<tr><td><code id="epiweb_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>shiny::runApp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>epiweb</code> runs a web-based GUI of one-group deterministic compartmental
models, stochastic individual contact models, and stochastic network models
with user input on model type, state sizes, and parameters. Model output may
be plotted, summarized, and saved as raw data using the core <code>EpiModel</code>
functionality for these model classes. These applications are built using
the <code>shiny</code> package framework.
</p>


<h3>References</h3>

<p>RStudio. shiny: Web Application Framework for R. R package version 1.0.5.
2015. <a href="https://shiny.posit.co/">https://shiny.posit.co/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcm">dcm</a></code>, <code><a href="#topic+icm">icm</a></code>, <code><a href="#topic+netsim">netsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Deterministic compartmental models
epiweb(class = "dcm")

## Stochastic individual contact models
epiweb(class = "icm")

## Stochastic network models
epiweb(class = "net")

## End(Not run)

</code></pre>

<hr>
<h2 id='format_param'>Format One Parameter for Printing with the <code>print.param.xxx</code>
Functions</h2><span id='topic+format_param'></span>

<h3>Description</h3>

<p>Format One Parameter for Printing with the <code>print.param.xxx</code>
Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_param(param_name, param_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_param_+3A_param_name">param_name</code></td>
<td>
<p>The name of the parameter to print.</p>
</td></tr>
<tr><td><code id="format_param_+3A_param_value">param_value</code></td>
<td>
<p>The value of the parameter to print.</p>
</td></tr>
</table>

<hr>
<h2 id='generate_random_params'>Generate Values for Random Parameters</h2><span id='topic+generate_random_params'></span>

<h3>Description</h3>

<p>This function uses the generative functions in the
<code>random.params</code> list to create values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_params(param, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_params_+3A_param">param</code></td>
<td>
<p>The <code>param</code> argument received by the <code>netsim</code>
functions.</p>
</td></tr>
<tr><td><code id="generate_random_params_+3A_verbose">verbose</code></td>
<td>
<p>Should the function output the generated values
(default = FALSE)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fully instantiated <code>param</code> list.
</p>


<h3><code>random.params</code></h3>

<p>The <code>random.params</code> argument to the <code><a href="#topic+param.net">param.net</a></code> function
must be a named list of functions that each return a value that can be used
as the argument with the same name. In the example below, <code>param_random</code>
is a function factory provided by EpiModel for <code>act.rate</code> and
for <code>tx.halt.part.prob</code> we provide bespoke functions. A function factory
is a function that returns a new function
(see https://adv-r.hadley.nz/function-factories.html).
</p>


<h3>Generator Functions</h3>

<p>The functions used inside <code>random_params</code> must be 0 argument functions
returning a valid value for the parameter with the same name.
</p>


<h3><code>param_random_set</code></h3>

<p>The <code>random_params</code> list can optionally contain a
<code>param_random_set</code> element. It must be a <code>data.frame</code> of possible
values to be used as parameters.
</p>
<p>The column names must correspond either to:
the name of one parameter, if this parameter is of size 1; or the name of one
parameter with &quot;_1&quot;, &quot;<em>2&quot;, etc. appended, with the number representing the
position of the value, if this parameter is of size &gt; 1. This means that the
parameter names cannot contain any underscores &quot;</em>&quot; if you intend to use
<code>param_random_set</code>.
</p>
<p>The point of the <code>param.random.set</code> <code>data.frame</code> is to allow the
random parameters to be correlated. To achieve this, a whole row of the
<code>data.frame</code> is selected for each simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Example with only the generator function

# Define random parameter list
my_randoms &lt;- list(
  act.rate = param_random(c(0.25, 0.5, 0.75)),
  tx.prob = function() rbeta(1, 1, 2),
  stratified.test.rate = function() c(
    rnorm(1, 0.05, 0.01),
    rnorm(1, 0.15, 0.03),
    rnorm(1, 0.25, 0.05)
  )
)

# Parameter model with fixed and random parameters
param &lt;- param.net(inf.prob = 0.3, random.params = my_randoms)

# Below, `tx.prob` is set first to 0.3 then assigned a random value using
# the function from `my_randoms`. A warning notifying of this overwrite is
# therefore produced.
param &lt;- param.net(tx.prob = 0.3, random.params = my_randoms)


# Parameters are drawn automatically in netsim by calling the function
# within netsim_loop. Demonstrating draws here but this is not used by
# end user.
paramDraw &lt;- generate_random_params(param, verbose = TRUE)
paramDraw


## Addition of the `param.random.set` `data.frame`

# This function will generate sets of correlated parameters
 generate_correlated_params &lt;- function() {
   param.unique &lt;- runif(1)
   param.set.1 &lt;- param.unique + runif(2)
   param.set.2 &lt;- param.unique * rnorm(3)

   return(list(param.unique, param.set.1, param.set.2))
 }

 # Data.frame set of random parameters :
 correlated_params &lt;- t(replicate(10, unlist(generate_correlated_params())))
 correlated_params &lt;- as.data.frame(correlated_params)
 colnames(correlated_params) &lt;- c(
   "param.unique",
   "param.set.1_1", "param.set.1_2",
   "param.set.2_1", "param.set.2_2", "param.set.2_3"
 )

# Define random parameter list with the `param.random.set` element
my_randoms &lt;- list(
  act.rate = param_random(c(0.25, 0.5, 0.75)),
  param.random.set = correlated_params
)

# Parameter model with fixed and random parameters
param &lt;- param.net(inf.prob = 0.3, random.params = my_randoms)

# Parameters are drawn automatically in netsim by calling the function
# within netsim_loop. Demonstrating draws here but this is not used by
# end user.
paramDraw &lt;- generate_random_params(param, verbose = TRUE)
paramDraw


## End(Not run)
</code></pre>

<hr>
<h2 id='geom_bands'>ggplot2 Geom for Quantile Bands</h2><span id='topic+geom_bands'></span>

<h3>Description</h3>

<p>Plots quantile bands given a data.frame with stochastic model
results from <code><a href="#topic+icm">icm</a></code> or <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_bands(mapping, lower = 0.25, upper = 0.75, alpha = 0.25, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_bands_+3A_mapping">mapping</code></td>
<td>
<p>Standard aesthetic mapping <code>aes()</code> input for ggplot2.</p>
</td></tr>
<tr><td><code id="geom_bands_+3A_lower">lower</code></td>
<td>
<p>Lower quantile for the time series.</p>
</td></tr>
<tr><td><code id="geom_bands_+3A_upper">upper</code></td>
<td>
<p>Upper quantile for the time series.</p>
</td></tr>
<tr><td><code id="geom_bands_+3A_alpha">alpha</code></td>
<td>
<p>Transparency of the ribbon fill.</p>
</td></tr>
<tr><td><code id="geom_bands_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stat_summary</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper around <code>ggplot::stat_summary</code> with a ribbon geom as
aesthetic output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- param.icm(inf.prob = 0.2, act.rate = 0.25)
init &lt;- init.icm(s.num = 500, i.num = 1)
control &lt;- control.icm(type = "SI", nsteps = 250, nsims = 5)
mod1 &lt;- icm(param, init, control)
df &lt;- as.data.frame(mod1)
df.mean &lt;- as.data.frame(mod1, out = "mean")

library(ggplot2)
ggplot() +
   geom_line(data = df, mapping = aes(time, i.num, group = sim),
   alpha = 0.25, lwd = 0.25, color = "firebrick") +
   geom_bands(data = df, mapping = aes(time, i.num),
              lower = 0.1, upper = 0.9, fill = "firebrick") +
   geom_line(data = df.mean, mapping = aes(time, i.num)) +
   theme_minimal()

</code></pre>

<hr>
<h2 id='get_args'>Get Arguments from EpiModel Parameterization Functions</h2><span id='topic+get_args'></span>

<h3>Description</h3>

<p>Returns a list of argument names and values for use for
parameter processing functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_args(formal.args, dot.args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_args_+3A_formal.args">formal.args</code></td>
<td>
<p>The output of <code>formals(sys.function())</code>.</p>
</td></tr>
<tr><td><code id="get_args_+3A_dot.args">dot.args</code></td>
<td>
<p>The output of <code>list(...)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument names and values.
</p>

<hr>
<h2 id='get_attr_history'>Extract the Attributes History from Network Simulations</h2><span id='topic+get_attr_history'></span>

<h3>Description</h3>

<p>Extract the Attributes History from Network Simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attr_history(sims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_attr_history_+3A_sims">sims</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>netsim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.frame</code>s, one for each &quot;measure&quot; recorded in the
simulation by the <code>record_attr_history</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# With `sims` the result of a `netsim` call
get_attr_history(sims)


## End(Not run)

</code></pre>

<hr>
<h2 id='get_attr_prop'>Proportional Table of Vertex Attributes</h2><span id='topic+get_attr_prop'></span>

<h3>Description</h3>

<p>Calculates the proportional distribution of each vertex
attribute contained in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attr_prop(dat, nwterms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_attr_prop_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="get_attr_prop_+3A_nwterms">nwterms</code></td>
<td>
<p>Vector of attributes on the network object, usually as
output of <code><a href="#topic+get_formula_term_attr">get_formula_term_attr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table containing the proportional distribution of each attribute in
<code>nwterms</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_formula_term_attr">get_formula_term_attr</a></code>,
<code><a href="#topic+copy_nwattr_to_datattr">copy_nwattr_to_datattr</a></code>,
<code><a href="#topic+auto_update_attr">auto_update_attr</a></code>.
</p>

<hr>
<h2 id='get_cumulative_degree'>Return the Cumulative Degree of a Set of Index Nodes</h2><span id='topic+get_cumulative_degree'></span>

<h3>Description</h3>

<p>Return the Cumulative Degree of a Set of Index Nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cumulative_degree(
  dat,
  index_posit_ids,
  networks = NULL,
  truncate = Inf,
  only.active.nodes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cumulative_degree_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="get_cumulative_degree_+3A_index_posit_ids">index_posit_ids</code></td>
<td>
<p>The positional IDs of the indexes of interest.</p>
</td></tr>
<tr><td><code id="get_cumulative_degree_+3A_networks">networks</code></td>
<td>
<p>Numerical indexes of the networks to extract the partnerships from. (May be &gt; 1
for models with multi-layer networks.) If <code>NULL</code>, extract from all networks.</p>
</td></tr>
<tr><td><code id="get_cumulative_degree_+3A_truncate">truncate</code></td>
<td>
<p>After how many time steps a partnership that is no longer
active should be removed from the output.</p>
</td></tr>
<tr><td><code id="get_cumulative_degree_+3A_only.active.nodes">only.active.nodes</code></td>
<td>
<p>If <code>TRUE</code>, then inactive (e.g., deceased) partners will be removed from
the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with 2 columns:
</p>

<ul>
<li> <p><code>index_pid</code>: the positional ID (see <code>get_posit_ids</code>) of the
indexes.
</p>
</li>
<li> <p><code>degree</code>: the cumulative degree of the index.
</p>
</li></ul>



<h3>Cumulative Degree</h3>

<p>The cumulative degree of a node is the number of edges connected to this
node at during the time window. The time window is by default all the steps
stored in the <code>cumulative_edgelist</code> or set by the <code>truncate</code> parameter.
</p>

<hr>
<h2 id='get_cumulative_edgelist'>Get a Cumulative Edgelist From a Specified Network</h2><span id='topic+get_cumulative_edgelist'></span>

<h3>Description</h3>

<p>Get a Cumulative Edgelist From a Specified Network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cumulative_edgelist(dat, network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cumulative_edgelist_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="get_cumulative_edgelist_+3A_network">network</code></td>
<td>
<p>Numerical index of the network from which the cumulative
edgelist should be extracted. (May be &gt; 1 for models with
multiple overlapping networks.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cumulative edgelist in <code>data.frame</code> form with 4 columns:
</p>

<ul>
<li> <p><code>head</code>: the unique ID (see <code>get_unique_ids</code>) of the
head node on the edge.
</p>
</li>
<li> <p><code>tail</code>: the unique ID (see <code>get_unique_ids</code>) of the
tail node on the edge.
</p>
</li>
<li> <p><code>start</code>: the time step in which the edge started.
</p>
</li>
<li> <p><code>stop</code>: the time step in which the edge stopped; if ongoing,
then <code>NA</code> is returned.
</p>
</li></ul>


<hr>
<h2 id='get_cumulative_edgelists_df'>Get the Cumulative Edgelists of a Model</h2><span id='topic+get_cumulative_edgelists_df'></span>

<h3>Description</h3>

<p>Get the Cumulative Edgelists of a Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cumulative_edgelists_df(dat, networks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cumulative_edgelists_df_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="get_cumulative_edgelists_df_+3A_networks">networks</code></td>
<td>
<p>Numerical indexes of the networks to extract the partnerships
from. (May be &gt; 1 for models with multiple overlapping
networks.) If <code>NULL</code>, extract from all networks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with 5 columns:
</p>

<ul>
<li> <p><code>index</code>: the unique ID (see <code>get_unique_ids</code>) of the
indexes.
</p>
</li>
<li> <p><code>partner</code>: the unique ID (see <code>get_unique_ids</code>) of the
partners/contacts.
</p>
</li>
<li> <p><code>start</code>: the time step in which the edge started.
</p>
</li>
<li> <p><code>stop</code>: the time step in which the edge stopped; if ongoing,
then <code>NA</code> is returned.
</p>
</li>
<li> <p><code>network</code>: the numerical index for the network on which the
partnership/contact is located.
</p>
</li></ul>


<hr>
<h2 id='get_current_timestep'>Return the Current Timestep</h2><span id='topic+get_current_timestep'></span>

<h3>Description</h3>

<p>Return the Current Timestep
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_current_timestep(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_current_timestep_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current timestep.
</p>

<hr>
<h2 id='get_degree'>Get Individual Degree from Network or Edgelist</h2><span id='topic+get_degree'></span>

<h3>Description</h3>

<p>A fast method for querying the current degree of all individuals
within a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_degree(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_degree_+3A_x">x</code></td>
<td>
<p>Either an object of class <code>network</code> or <code>edgelist</code>
generated from a network. If <code>x</code> is an edgelist, then it must
contain an attribute for the total network size, <code>n</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Individual-level data on the current degree of nodes within a network is
often useful for summary statistics. Given a <code>network</code> class object,
<code>net</code>, one way to look up the current degree is to get a summary of the
ERGM term, <code>sociality</code>, as in:
<code>summary(net ~ sociality(nodes = NULL))</code>. But that is computationally
inefficient for a number of reasons. This function provides a fast method for
generating the vector of degrees using a query of the edgelist. It is even
faster if the parameter <code>x</code> is already transformed into an edgelist.
</p>


<h3>Value</h3>

<p>A vector of length equal to the total network size, containing the
current degree of each node in the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- network_initialize(n = 500)

set.seed(1)
fit &lt;- ergm(nw ~ edges, target.stats = 250)
sim &lt;- simulate(fit)

# Slow ERGM-based method
ergm.method &lt;- unname(summary(sim ~ sociality(nodes = NULL)))
ergm.method

# Fast tabulate method with network object
deg.net &lt;- get_degree(sim)
deg.net

# Even faster if network already transformed into an edgelist
el &lt;- as.edgelist(sim)
deg.el &lt;- get_degree(el)
deg.el

identical(as.integer(ergm.method), deg.net, deg.el)

</code></pre>

<hr>
<h2 id='get_edgelist'>Get an Edgelist From the Specified Network</h2><span id='topic+get_edgelist'></span>

<h3>Description</h3>

<p>This function outputs an edgelist from the specified network,
selecting the method depending on the stored network type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edgelist(dat, network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_edgelist_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="get_edgelist_+3A_network">network</code></td>
<td>
<p>Numerical index of the network from which the edgelist should
be extracted. (May be &gt; 1 for models with multiple overlapping
networks.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edgelist in matrix form with two columns. Each column contains the
posit_ids (see <code>get_posit_ids</code>) of the nodes in each edge.
</p>

<hr>
<h2 id='get_formula_term_attr'>Output ERGM Formula Attributes into a Character Vector</h2><span id='topic+get_formula_term_attr'></span>

<h3>Description</h3>

<p>Given a formation formula for a network model, outputs a
character vector of vertex attributes to be used in
<code><a href="#topic+netsim">netsim</a></code> simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formula_term_attr(form, nw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_formula_term_attr_+3A_form">form</code></td>
<td>
<p>An ERGM model formula.</p>
</td></tr>
<tr><td><code id="get_formula_term_attr_+3A_nw">nw</code></td>
<td>
<p>A network object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of vertex attributes.
</p>

<hr>
<h2 id='get_modules'>Get the List of Modules</h2><span id='topic+get_modules'></span>

<h3>Description</h3>

<p>Get the List of Modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_modules(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_modules_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of modules to be run by the model
</p>

<hr>
<h2 id='get_network'>Extract Network Objects from Network Simulations</h2><span id='topic+get_network'></span><span id='topic+get_network.netdx'></span><span id='topic+get_network.netsim'></span><span id='topic+get_network.netsim_dat'></span>

<h3>Description</h3>

<p>Extracts the network object from either a network epidemic model
object generated with <code>netsim</code>, a network diagnostic
simulation generated with <code>netdx</code>, or a <code>netsim_dat</code>
object used internally in <code>netsim</code>. For <code>netdx</code> or
<code>netsim</code> with <code>tergmLite == FALSE</code>, the extracted
network object is a <code>networkDynamic</code>, which can be
collapsed down to a static <code>network</code> object with the
<code>collapse</code> and <code>at</code> arguments. For <code>netsim</code> with
<code>tergmLite == TRUE</code>, the extracted network object is the
final <code>networkLite</code>, the <code>collapse</code> argument should be
<code>FALSE</code>, and the <code>at</code> argument should be missing. For
<code>netsim_dat</code>, the <code>collapse</code> and <code>at</code> arguments
are not supported, and the network object is either the current
<code>networkLite</code> (if <code>tergmLite == TRUE</code>) or the current
<code>networkDynamic</code> (if <code>tergmLite == FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_network(x, ...)

## S3 method for class 'netdx'
get_network(x, sim = 1, collapse = FALSE, at, ...)

## S3 method for class 'netsim'
get_network(x, sim = 1, network = 1, collapse = FALSE, at, ...)

## S3 method for class 'netsim_dat'
get_network(x, network = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_network_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+netsim">netsim</a></code>,
<code><a href="#topic+netdx">netdx</a></code>, or <code>netsim_dat</code>.</p>
</td></tr>
<tr><td><code id="get_network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="get_network_+3A_sim">sim</code></td>
<td>
<p>Simulation number of extracted network, for <code>netdx</code> and
<code>netsim</code>.</p>
</td></tr>
<tr><td><code id="get_network_+3A_collapse">collapse</code></td>
<td>
<p>If <code>TRUE</code>, collapse the <code>networkDynamic</code> object to
a static <code>network</code> object at a specified time step. Applicable to
<code>netdx</code> objects and <code>netsim</code> objects with
<code>tergmLite == FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_network_+3A_at">at</code></td>
<td>
<p>If <code>collapse</code> is <code>TRUE</code>, the time step at which the
extracted network should be collapsed. Applicable to <code>netdx</code>
objects and <code>netsim</code> objects with <code>tergmLite == FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_network_+3A_network">network</code></td>
<td>
<p>Network number, for <code>netsim</code> or <code>netsim_dat</code> objects
with multiple overlapping networks (advanced use, and not applicable
to <code>netdx</code> objects).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires that the network object is saved during the network
simulation while running either <code><a href="#topic+netsim">netsim</a></code> or <code><a href="#topic+netdx">netdx</a></code>.
For the former, that is specified by setting the <code>save.network</code>
parameter in <code><a href="#topic+control.net">control.net</a></code> to <code>TRUE</code>. For the latter, that
is specified with the <code>keep.tnetwork</code> parameter directly in
<code><a href="#topic+netdx">netdx</a></code>.
</p>


<h3>Value</h3>

<p>For <code>netdx</code> or <code>netsim</code> with <code>tergmLite == FALSE</code>, a
<code>networkDynamic</code> object (if <code>collapse = FALSE</code>) or a
static <code>network</code> object (if <code>collapse = TRUE</code>). For
<code>netsim</code> with <code>tergmLite == TRUE</code> or <code>netsim_dat</code> with
<code>tergmLite == TRUE</code>, a <code>networkLite</code> object. For
<code>netsim_dat</code> with <code>tergmLite == FALSE</code>, a
<code>networkDynamic</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network and TERGM formula
nw &lt;- network_initialize(n = 100)
nw &lt;- set_vertex_attribute(nw, "group", rep(1:2, each = 50))
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)

# Estimate the model
est &lt;- netest(nw, formation, target.stats, coef.diss)

# Run diagnostics, saving the networkDynamic objects
dx &lt;- netdx(est, nsteps = 10, nsims = 3, keep.tnetwork = TRUE,
            verbose = FALSE)

# Extract the network for simulation 2 from dx object
get_network(dx, sim = 2)

# Extract and collapse the network from simulation 1 at time step 5
get_network(dx, collapse = TRUE, at = 5)

# Parameterize the epidemic model, and simulate it
param &lt;- param.net(inf.prob = 0.3, inf.prob.g2 = 0.15)
init &lt;- init.net(i.num = 10, i.num.g2 = 10)
control &lt;- control.net(type = "SI", nsteps = 10, nsims = 3, verbose = FALSE)
mod &lt;- netsim(est, param, init, control)

# Extract the network for simulation 2 from mod object
get_network(mod, sim = 2)

## Extract and collapse the network from simulation 1 at time step 5
get_network(mod, collapse = TRUE, at = 5)

</code></pre>

<hr>
<h2 id='get_network_attributes'>Get Network Attributes from a Network Object</h2><span id='topic+get_network_attributes'></span>

<h3>Description</h3>

<p>Gets all network attributes except <code>"mnext"</code> from its
network argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_network_attributes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_network_attributes_+3A_x">x</code></td>
<td>
<p>An object of class <code>network</code> or <code>networkLite</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in <code>EpiModel</code> workflows to copy relevant network
attributes from the network object to the <code>netsim_dat</code> object when
initializing <code>netsim</code> runs.
</p>


<h3>Value</h3>

<p>Returns the named list of network attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- network_initialize(100)
get_network_attributes(nw)

</code></pre>

<hr>
<h2 id='get_network_term_attr'>Output Network Attributes into a Character Vector</h2><span id='topic+get_network_term_attr'></span>

<h3>Description</h3>

<p>Given a simulated network, outputs a character vector of vertex
attributes to be used in <code><a href="#topic+netsim">netsim</a></code> simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_network_term_attr(nw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_network_term_attr_+3A_nw">nw</code></td>
<td>
<p>A network object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of vertex attributes.
</p>

<hr>
<h2 id='get_nwparam'>Extract Network Model Parameters</h2><span id='topic+get_nwparam'></span>

<h3>Description</h3>

<p>Extracts a list of network model parameters saved in the
initialization module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nwparam(x, network = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nwparam_+3A_x">x</code></td>
<td>
<p>Main <code>netsim_dat</code> data object used in <code>netsim</code> simulations.</p>
</td></tr>
<tr><td><code id="get_nwparam_+3A_network">network</code></td>
<td>
<p>Network number, for simulations with multiple networks
representing the population.</p>
</td></tr>
</table>

<hr>
<h2 id='get_nwstats'>Extract Network Statistics from netsim or netdx Object</h2><span id='topic+get_nwstats'></span>

<h3>Description</h3>

<p>Extracts network statistics from a network epidemic model
simulated with <code>netsim</code> or a network diagnostics object
simulated with <code>netdx</code>. Statistics can be returned either
as a single data frame or as a list of matrices (one matrix
for each simulation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nwstats(x, sim, network = 1, mode = c("data.frame", "list"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nwstats_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+netsim">netsim</a></code> or
<code><a href="#topic+netdx">netdx</a></code>.</p>
</td></tr>
<tr><td><code id="get_nwstats_+3A_sim">sim</code></td>
<td>
<p>A vector of simulation numbers from the extracted object.</p>
</td></tr>
<tr><td><code id="get_nwstats_+3A_network">network</code></td>
<td>
<p>Network number, for <code>netsim</code> objects with multiple
overlapping networks (advanced use, and not applicable to <code>netdx</code>
objects).</p>
</td></tr>
<tr><td><code id="get_nwstats_+3A_mode">mode</code></td>
<td>
<p>Either <code>"data.frame"</code> or <code>"list"</code>, indicating the
desired output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or list of matrices containing the network statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two-group Bernoulli random graph TERGM
nw &lt;- network_initialize(n = 100)
nw &lt;- set_vertex_attribute(nw, "group", rep(1:2, each = 50))
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

dx &lt;- netdx(est, nsim = 3, nsteps = 10, verbose = FALSE,
            nwstats.formula = ~edges + isolates)
get_nwstats(dx)
get_nwstats(dx, sim = 1)

# SI epidemic model
param &lt;- param.net(inf.prob = 0.3, inf.prob.g2 = 0.15)
init &lt;- init.net(i.num = 10, i.num.g2 = 10)
control &lt;- control.net(type = "SI", nsteps = 10, nsims = 3,
                       nwstats.formula = ~edges + meandeg + degree(0:5),
                       verbose = FALSE)
mod &lt;- netsim(est, param, init, control)

# Extract the network statistics from all or sets of simulations
get_nwstats(mod)
get_nwstats(mod, sim = 2)
get_nwstats(mod, sim = c(1, 3))

# On the fly summary stats
summary(get_nwstats(mod))
colMeans(get_nwstats(mod))

</code></pre>

<hr>
<h2 id='get_param_set'>Extract the Parameter Set from Network Simulations</h2><span id='topic+get_param_set'></span>

<h3>Description</h3>

<p>Extract the Parameter Set from Network Simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_param_set(sims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_param_set_+3A_sims">sims</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>netsim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row per simulation and one column per
parameter or parameter element where the parameters are of size &gt; 1.
</p>


<h3>Output Format</h3>

<p>The outputted <code>data.frame</code> has one row per simulation and the columns
correspond to the parameters used in this simulation.
</p>
<p>The column name will match the parameter name if it is a size 1 parameter or
if the parameter is of size &gt; 1, there will be N columns (with N being the
size of the parameter) named <code>parameter.name_1</code>,
<code>parameter.name_2</code>, ..., <code>parameter.name_N</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setup network
nw &lt;- network_initialize(n = 50)

est &lt;- netest(
  nw, formation = ~edges,
  target.stats = c(25),
  coef.diss = dissolution_coefs(~offset(edges), 10, 0),
  verbose = FALSE
)

init &lt;- init.net(i.num = 10)

n &lt;- 5

related.param &lt;- data.frame(
  dummy.param = rbeta(n, 1, 2)
)

 my.randoms &lt;- list(
   act.rate = param_random(c(0.25, 0.5, 0.75)),
   dummy.param = function() rbeta(1, 1, 2),
   dummy.strat.param = function() c(
     rnorm(1, 0, 10),
     rnorm(1, 10, 1)
   )
 )

param &lt;- param.net(
  inf.prob = 0.3,
  dummy = c(0, 1, 2),
  random.params = my.randoms
)

control &lt;- control.net(type = "SI", nsims = 3, nsteps = 5, verbose = FALSE)
mod &lt;- netsim(est, param, init, control)

get_param_set(mod)
</code></pre>

<hr>
<h2 id='get_partners'>Return the Historical Contacts (Partners) of a Set of Index Nodes</h2><span id='topic+get_partners'></span>

<h3>Description</h3>

<p>From a full cumulative edgelist that contains the history of contacts (both persistent and
one-time), this function returns a data frame containing details of the index (head) and partner
(tail) nodes, along with start and stop time steps for the partnership and the network location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_partners(
  dat,
  index_posit_ids,
  networks = NULL,
  truncate = Inf,
  only.active.nodes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_partners_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="get_partners_+3A_index_posit_ids">index_posit_ids</code></td>
<td>
<p>The positional IDs of the indexes of interest.</p>
</td></tr>
<tr><td><code id="get_partners_+3A_networks">networks</code></td>
<td>
<p>Numerical indexes of the networks to extract the partnerships from. (May be &gt; 1
for models with multi-layer networks.) If <code>NULL</code>, extract from all networks.</p>
</td></tr>
<tr><td><code id="get_partners_+3A_truncate">truncate</code></td>
<td>
<p>After how many time steps a partnership that is no longer
active should be removed from the output.</p>
</td></tr>
<tr><td><code id="get_partners_+3A_only.active.nodes">only.active.nodes</code></td>
<td>
<p>If <code>TRUE</code>, then inactive (e.g., deceased) partners will be removed from
the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>get_partners</code> takes as input the positional IDs of the indexes of interest but returns
the unique IDs. That is by design, because while <code>get_partners</code> would be expected to be called
for active nodes, some partners (contacts) of nodes may be inactive in the network history.
Therefore, both index and partner IDs are returned as unique IDs for consistency. To convert
between a positional to a unique ID, you may use <code><a href="#topic+get_posit_ids">get_posit_ids</a></code>; to convert between a
unique ID to a positional ID, you may use <code><a href="#topic+get_unique_ids">get_unique_ids</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with 5 columns:
</p>

<ul>
<li> <p><code>index</code>: the unique IDs of the indexes.
</p>
</li>
<li> <p><code>partner</code>: the unique IDs of the partners/contacts.
</p>
</li>
<li> <p><code>start</code>: the time step at which the edge started.
</p>
</li>
<li> <p><code>stop</code>: the time step in which the edge stopped; if ongoing, then <code>NA</code> is returned.
</p>
</li>
<li> <p><code>network</code>: the numerical index for the network on which the partnership/contact is located.
</p>
</li></ul>


<hr>
<h2 id='get_sims'>Extract Network Simulations</h2><span id='topic+get_sims'></span>

<h3>Description</h3>

<p>Subsets the entire <code>netsim</code> object to a subset of
simulations, essentially functioning like a reverse of
<code>merge</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sims(x, sims, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sims_+3A_x">x</code></td>
<td>
<p>An object of class <code>netsim</code>.</p>
</td></tr>
<tr><td><code id="get_sims_+3A_sims">sims</code></td>
<td>
<p>Either a numeric vector of simulation numbers to retain in the
output object, or <code>"mean"</code>, which selects the one simulation with
the value of the variable specified in <code>var</code> closest to the mean
of <code>var</code> across all simulations.</p>
</td></tr>
<tr><td><code id="get_sims_+3A_var">var</code></td>
<td>
<p>A character vector of variables to retain from <code>x</code> if
<code>sims</code> is a numeric vector, or a single variable name for
selecting the average simulation from the set if <code>sims = "mean"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated object of class <code>netsim</code> containing only the
simulations specified in <code>sims</code> and the variables specified in
<code>var</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Network model estimation
nw &lt;- network_initialize(n = 100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
est1 &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Epidemic model
param &lt;- param.net(inf.prob = 0.3)
init &lt;- init.net(i.num = 10)
control &lt;- control.net(type = "SI", nsteps = 10, nsims = 3, verbose.int = 0)
mod1 &lt;- netsim(est1, param, init, control)

# Get sim 2
s.g2 &lt;- get_sims(mod1, sims = 2)

# Get sims 2 and 3 and keep only a subset of variables
s.g2.small &lt;- get_sims(mod1, sims = 2:3, var = c("i.num", "si.flow"))

# Extract the mean simulation for the variable i.num
sim.mean &lt;- get_sims(mod1, sims = "mean", var = "i.num")

</code></pre>

<hr>
<h2 id='get_vertex_attribute'>Get Vertex Attribute on Network Object</h2><span id='topic+get_vertex_attribute'></span>

<h3>Description</h3>

<p>Gets a vertex attribute from an object of class <code>network</code>.
This functions simplifies the related function in the
<code>network</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vertex_attribute(x, attrname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_vertex_attribute_+3A_x">x</code></td>
<td>
<p>An object of class network.</p>
</td></tr>
<tr><td><code id="get_vertex_attribute_+3A_attrname">attrname</code></td>
<td>
<p>The name of the attribute to get.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in <code>EpiModel</code> workflows to query vertex
attributes on an initialized empty network object (see
<code><a href="#topic+network_initialize">network_initialize</a></code>).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>network</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- network_initialize(100)
nw &lt;- set_vertex_attribute(nw, "age", runif(100, 15, 65))
get_vertex_attribute(nw, "age")

</code></pre>

<hr>
<h2 id='icm'>Stochastic Individual Contact Models</h2><span id='topic+icm'></span>

<h3>Description</h3>

<p>Simulates stochastic individual contact epidemic models for
infectious disease.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icm(param, init, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icm_+3A_param">param</code></td>
<td>
<p>Model parameters, as an object of class <code><a href="#topic+param.icm">param.icm</a></code>.</p>
</td></tr>
<tr><td><code id="icm_+3A_init">init</code></td>
<td>
<p>Initial conditions, as an object of class <code><a href="#topic+init.icm">init.icm</a></code>.</p>
</td></tr>
<tr><td><code id="icm_+3A_control">control</code></td>
<td>
<p>Control settings, as an object of class
<code><a href="#topic+control.icm">control.icm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Individual contact models are intended to be the stochastic microsimulation
analogs to deterministic compartmental models. ICMs simulate disease spread
on individual agents in discrete time as a function of processes with
stochastic variation. The stochasticity is inherent in all transition
processes: infection, recovery, and demographics. A detailed description of
these models  may be found in the
<a href="http://www.epimodel.org/tut.html">Basic ICMs</a> tutorial.
</p>
<p>The <code>icm</code> function performs  modeling of both the base model types
and original models. Base model types include one-group and two-group
models with disease types for Susceptible-Infected (SI),
Susceptible-Infected-Recovered (SIR), and Susceptible-Infected-Susceptible
(SIS). Original models may be built by writing new process modules that
either take the place of existing modules (for example, disease recovery),
or supplement the set of existing processes with a new one contained in an
original module.
</p>


<h3>Value</h3>

<p>A list of class <code>icm</code> with the following elements:
</p>

<ul>
<li> <p><strong>param:</strong> the epidemic parameters passed into the model through
<code>param</code>, with additional parameters added as necessary.
</p>
</li>
<li> <p><strong>control:</strong> the control settings passed into the model through
<code>control</code>, with additional controls added as necessary.
</p>
</li>
<li> <p><strong>epi:</strong> a list of data frames, one for each epidemiological
output from the model. Outputs for base models always include the
size of each compartment, as well as flows in, out of, and between
compartments.
</p>
</li></ul>



<h3>See Also</h3>

<p>Extract the model results with <code><a href="#topic+as.data.frame.icm">as.data.frame.icm</a></code>.
Summarize the time-specific model results with <code><a href="#topic+summary.icm">summary.icm</a></code>.
Plot the model results with <code><a href="#topic+plot.icm">plot.icm</a></code>. Plot a compartment flow
diagram with <code><a href="#topic+comp_plot">comp_plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1: SI Model
param &lt;- param.icm(inf.prob = 0.2, act.rate = 0.25)
init &lt;- init.icm(s.num = 500, i.num = 1)
control &lt;- control.icm(type = "SI", nsteps = 500, nsims = 10)
mod1 &lt;- icm(param, init, control)
mod1
plot(mod1)

## Example 2: SIR Model
param &lt;- param.icm(inf.prob = 0.2, act.rate = 0.25, rec.rate = 1/50)
init &lt;- init.icm(s.num = 500, i.num = 1, r.num = 0)
control &lt;- control.icm(type = "SIR", nsteps = 500, nsims = 10)
mod2 &lt;- icm(param, init, control)
mod2
plot(mod2)

## Example 3: SIS Model
param &lt;- param.icm(inf.prob = 0.2, act.rate = 0.25, rec.rate = 1/50)
init &lt;- init.icm(s.num = 500, i.num = 1)
control &lt;- control.icm(type = "SIS", nsteps = 500, nsims = 10)
mod3 &lt;- icm(param, init, control)
mod3
plot(mod3)

## Example 4: SI Model with Vital Dynamics (Two-Group)
param &lt;- param.icm(inf.prob = 0.4,  inf.prob.g2 = 0.1,
                   act.rate = 0.25, balance = "g1",
                   a.rate = 1/100, a.rate.g2 = NA,
                   ds.rate = 1/100, ds.rate.g2 = 1/100,
                   di.rate = 1/50, di.rate.g2 = 1/50)
init &lt;- init.icm(s.num = 500, i.num = 1,
                 s.num.g2 = 500, i.num.g2 = 0)
control &lt;- control.icm(type = "SI", nsteps = 500, nsims = 10)
mod4 &lt;- icm(param, init, control)
mod4
plot(mod4)

## End(Not run)

</code></pre>

<hr>
<h2 id='idgroup'>Group Numbers for Two-Group Network</h2><span id='topic+idgroup'></span>

<h3>Description</h3>

<p>Outputs group numbers given ID numbers for a two-group network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idgroup(nw, ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idgroup_+3A_nw">nw</code></td>
<td>
<p>Object of class <code>network</code> or <code>networkDynamic</code>.</p>
</td></tr>
<tr><td><code id="idgroup_+3A_ids">ids</code></td>
<td>
<p>Vector of ID numbers for which the group number
should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the group number for each of the specified nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- network_initialize(n = 10)
nw &lt;- set_vertex_attribute(nw, "group", rep(1:2, each = 5))
idgroup(nw)
idgroup(nw, ids = c(3, 6))

</code></pre>

<hr>
<h2 id='increment_timestep'>Increment the Current Timestep</h2><span id='topic+increment_timestep'></span>

<h3>Description</h3>

<p>This function adds 1 to the timestep counter stored in the
<code>netsim_dat</code> main list object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increment_timestep(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="increment_timestep_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>Mutability</h3>

<p>This DOES NOT modify the <code>netsim_dat</code> object in place. The result must
be assigned back to <code>dat</code> in order to be registered:
<code>dat &lt;- increment_timestep(dat)</code>.
</p>

<hr>
<h2 id='infection.2g.net'>Primary Infection Module for netsim</h2><span id='topic+infection.2g.net'></span>

<h3>Description</h3>

<p>This function simulates the main infection process given the
current state of the partnerships and disease in the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infection.2g.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infection.2g.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="infection.2g.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main steps in this infection module are as follows:
</p>

<ol>
<li><p> Get IDs for current infected and susceptibles given the current
disease status.
</p>
</li>
<li><p> Call <code><a href="#topic+discord_edgelist">discord_edgelist</a></code> to get the current discordant
edgelist given step 1.
</p>
</li>
<li><p> Determine the transmission rates (e.g., as a function of group).
</p>
</li>
<li><p> Pull the number of acts per partnership in a time step from the
<code>act.rate</code> parameter.
</p>
</li>
<li><p> Calculate the final transmission probabilities given the transmission
rates and act rates.
</p>
</li>
<li><p> Randomly transmit on the discordant edgelist.
</p>
</li>
<li><p> Conduct bookkeeping for new infections to update status on the nodes
and calculate disease incidence.
</p>
</li></ol>



<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discord_edgelist">discord_edgelist</a></code> is used within <code>infection.net</code>
to obtain a discordant edgelist.
</p>

<hr>
<h2 id='infection.icm'>Primary Infection Module for icm</h2><span id='topic+infection.icm'></span>

<h3>Description</h3>

<p>This function simulates the main infection process given the
current state of the actors in the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infection.icm(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infection.icm_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="infection.icm_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>

<hr>
<h2 id='infection.icm.bip'>Primary Infection Module for icm</h2><span id='topic+infection.icm.bip'></span>

<h3>Description</h3>

<p>This function simulates the main infection process given the
current state of the actors in the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infection.icm.bip(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infection.icm.bip_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="infection.icm.bip_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>

<hr>
<h2 id='infection.net'>Primary Infection Module for netsim</h2><span id='topic+infection.net'></span>

<h3>Description</h3>

<p>This function simulates the main infection process given the
current state of the partnerships and disease in the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infection.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infection.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="infection.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main steps in this infection module are as follows:
</p>

<ol>
<li><p> Get IDs for current infected and susceptible nodes given the current
disease status.
</p>
</li>
<li><p> Call <code><a href="#topic+discord_edgelist">discord_edgelist</a></code> to get the current discordant
edgelist given step 1.
</p>
</li>
<li><p> Determine the transmission rates (e.g., as a function of group).
</p>
</li>
<li><p> Pull the number of acts per partnership in a time step from the
<code>act.rate</code> parameter.
</p>
</li>
<li><p> Calculate the final transmission probabilities given the transmission
rates and act rates.
</p>
</li>
<li><p> Randomly transmit on the discordant edgelist.
</p>
</li>
<li><p> Conduct bookkeeping for new infections to update status on the nodes
and calculate disease incidence.
</p>
</li></ol>



<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discord_edgelist">discord_edgelist</a></code> is used within <code>infection.net</code>
to obtain a discordant edgelist.
</p>

<hr>
<h2 id='init_nets'>Network Data and Stats Initialization</h2><span id='topic+init_nets'></span>

<h3>Description</h3>

<p>This function initializes the network data and stats on the main
<code>netsim_dat</code> class data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_nets(dat, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_nets_+3A_dat">dat</code></td>
<td>
<p>A main data object of class <code>netsim_dat</code> obtained from
<code><a href="#topic+create_dat_object">create_dat_object</a></code>, including the <code>control</code>
argument.</p>
</td></tr>
<tr><td><code id="init_nets_+3A_x">x</code></td>
<td>
<p>Either a fitted network model object of class <code>netest</code>, or a
list of such objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>netsim_dat</code> class main data object with network data and
stats initialized.
</p>

<hr>
<h2 id='init_status.icm'>Disease Status Initialization Module for icm</h2><span id='topic+init_status.icm'></span>

<h3>Description</h3>

<p>This function sets the initial disease status on the
network given the specified initial conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_status.icm(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_status.icm_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>


<h3>See Also</h3>

<p>This is an initialization module for <code><a href="#topic+icm">icm</a></code>.
</p>

<hr>
<h2 id='init_status.net'>Disease Status Initialization Module for netsim</h2><span id='topic+init_status.net'></span>

<h3>Description</h3>

<p>This function sets the initial disease status on the
network given the specified initial conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_status.net(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_status.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal function sets, either randomly or deterministically, the nodes
that are infected at <code class="reqn">t_1</code>, the starting time of network simulations. If
the number to be initially infected is passed, this function sets the initial
number infected based on the number specified, either as a set of random
draws from a binomial distribution or as the exact number specified. In
either case, the specific nodes infected are a random sample from the
network. In contrast, a set of specific nodes may be infected by passing a
vector containing the status of each node to <code><a href="#topic+netsim">netsim</a></code>.
</p>
<p>For the initially infected nodes, this module sets the time of infection as
<code class="reqn">t_1</code>, the starting time of network simulations. For models with vital
dynamics, the infection time for those initially infected nodes is a random
draw from an exponential distribution with the rate parameter defined by the
<code>di.rate</code> argument. For models without vital dynamics, the infection
time is a random draw from a uniform distribution of integers with a minimum
of 1 and a maximum of the number of time steps in the model. In both cases,
to set the infection times to be in the past, these times are multiplied by
-1, and 2 is added to allow for possible infection times up until step 2,
when the disease simulation time loop starts.
</p>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>See Also</h3>

<p>This is an initialization module for <code><a href="#topic+netsim">netsim</a></code>.
</p>

<hr>
<h2 id='init.dcm'>Initial Conditions for Deterministic Compartmental Models</h2><span id='topic+init.dcm'></span>

<h3>Description</h3>

<p>Sets the initial conditions for deterministic compartmental
models simulated with <code>dcm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.dcm(s.num, i.num, r.num, s.num.g2, i.num.g2, r.num.g2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.dcm_+3A_s.num">s.num</code></td>
<td>
<p>Number of initial susceptible persons. For two-group models,
this is the number of initial group 1 susceptible persons.</p>
</td></tr>
<tr><td><code id="init.dcm_+3A_i.num">i.num</code></td>
<td>
<p>Number of initial infected persons. For two-group models, this
is the number of initial group 1 infected persons.</p>
</td></tr>
<tr><td><code id="init.dcm_+3A_r.num">r.num</code></td>
<td>
<p>Number of initial recovered persons. For two-group models, this
is the number of initial group 1 recovered persons. This parameter is
only used for the <code>SIR</code> model type.</p>
</td></tr>
<tr><td><code id="init.dcm_+3A_s.num.g2">s.num.g2</code></td>
<td>
<p>Number of initial susceptible persons in group 2. This
parameter is only used for two-group models.</p>
</td></tr>
<tr><td><code id="init.dcm_+3A_i.num.g2">i.num.g2</code></td>
<td>
<p>Number of initial infected persons in group 2. This parameter
is only used for two-group models.</p>
</td></tr>
<tr><td><code id="init.dcm_+3A_r.num.g2">r.num.g2</code></td>
<td>
<p>Number of initial recovered persons in group 2. This
parameter is only used for two-group <code>SIR</code> models.</p>
</td></tr>
<tr><td><code id="init.dcm_+3A_...">...</code></td>
<td>
<p>Additional initial conditions passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial conditions for a model solved with <code><a href="#topic+dcm">dcm</a></code> should be
input into the <code>init.dcm</code> function. This function handles initial
conditions for both base model types and original models. For an overview
of initial conditions for base DCM class models, consult the
<a href="http://www.epimodel.org/tut.html">Basic DCMs</a> tutorial.
</p>
<p>Original models may use the parameter names listed as arguments here, a new
set of names, or a combination of both. With new models, initial conditions
must be input in the same order that the solved derivatives from the model
are output. More details on this requirement are outlined in the
<a href="http://www.epimodel.org/tut.html">Solving New DCMs</a> tutorial.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code>init.dcm</code>.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+param.dcm">param.dcm</a></code> to specify model parameters and
<code><a href="#topic+control.dcm">control.dcm</a></code> to specify the control settings. Run the
parameterized model with <code><a href="#topic+dcm">dcm</a></code>.
</p>

<hr>
<h2 id='init.icm'>Initial Conditions for Stochastic Individual Contact Models</h2><span id='topic+init.icm'></span>

<h3>Description</h3>

<p>Sets the initial conditions for stochastic individual contact
models simulated with <code>icm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.icm(s.num, i.num, r.num, s.num.g2, i.num.g2, r.num.g2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.icm_+3A_s.num">s.num</code></td>
<td>
<p>Number of initial susceptible persons. For two-group models,
this is the number of initial group 1 susceptible persons.</p>
</td></tr>
<tr><td><code id="init.icm_+3A_i.num">i.num</code></td>
<td>
<p>Number of initial infected persons. For two-group models, this
is the number of initial group 1 infected persons.</p>
</td></tr>
<tr><td><code id="init.icm_+3A_r.num">r.num</code></td>
<td>
<p>Number of initial recovered persons. For two-group models, this
is the number of initial group 1 recovered persons. This parameter is
only used for the <code>SIR</code> model type.</p>
</td></tr>
<tr><td><code id="init.icm_+3A_s.num.g2">s.num.g2</code></td>
<td>
<p>Number of initial susceptible persons in group 2. This
parameter is only used for two-group models.</p>
</td></tr>
<tr><td><code id="init.icm_+3A_i.num.g2">i.num.g2</code></td>
<td>
<p>Number of initial infected persons in group 2. This parameter
is only used for two-group models.</p>
</td></tr>
<tr><td><code id="init.icm_+3A_r.num.g2">r.num.g2</code></td>
<td>
<p>Number of initial recovered persons in group 2. This
parameter is only used for two-group <code>SIR</code> models.</p>
</td></tr>
<tr><td><code id="init.icm_+3A_...">...</code></td>
<td>
<p>Additional initial conditions passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial conditions for a model solved with <code><a href="#topic+icm">icm</a></code> should be
input into the <code>init.icm</code> function. This function handles initial
conditions for both base models and original models using new modules. For
an overview of initial conditions for base ICM class models, consult the
<a href="http://www.epimodel.org/tut.html">Basic ICMs</a> tutorial.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code>init.icm</code>.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+param.icm">param.icm</a></code> to specify model parameters and
<code><a href="#topic+control.icm">control.icm</a></code> to specify the control settings. Run the
parameterized model with <code><a href="#topic+icm">icm</a></code>.
</p>

<hr>
<h2 id='init.net'>Initial Conditions for Stochastic Network Models</h2><span id='topic+init.net'></span>

<h3>Description</h3>

<p>Sets the initial conditions for stochastic network models
simulated with <code>netsim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.net(i.num, r.num, i.num.g2, r.num.g2, status.vector, infTime.vector, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.net_+3A_i.num">i.num</code></td>
<td>
<p>Number of initial infected persons. For two-group models, this
is the number of initial group 1 infected persons.</p>
</td></tr>
<tr><td><code id="init.net_+3A_r.num">r.num</code></td>
<td>
<p>Number of initial recovered persons. For two-group models, this
is the number of initial group 1 recovered persons. This parameter is
only used for the <code>SIR</code> model type.</p>
</td></tr>
<tr><td><code id="init.net_+3A_i.num.g2">i.num.g2</code></td>
<td>
<p>Number of initial infected persons in group 2. This parameter
is only used for two-group models.</p>
</td></tr>
<tr><td><code id="init.net_+3A_r.num.g2">r.num.g2</code></td>
<td>
<p>Number of initial recovered persons in group 2. This
parameter is only used for two-group <code>SIR</code> models.</p>
</td></tr>
<tr><td><code id="init.net_+3A_status.vector">status.vector</code></td>
<td>
<p>A vector of length equal to the size of the input
network, containing the status of each node. Setting status here
overrides any inputs passed in the <code>.num</code> arguments.</p>
</td></tr>
<tr><td><code id="init.net_+3A_inftime.vector">infTime.vector</code></td>
<td>
<p>A vector of length equal to the size of the input
network, containing the (historical) time of infection for each of
those nodes with a current status of <code>"i"</code>. Can only be used if
<code>status.vector</code> is used, and must contain <code>NA</code> values for
any nodes whose status is not <code>"i"</code>.</p>
</td></tr>
<tr><td><code id="init.net_+3A_...">...</code></td>
<td>
<p>Additional initial conditions passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial conditions for a model solved with <code><a href="#topic+netsim">netsim</a></code> should be
input into the <code>init.net</code> function. This function handles initial
conditions for both base models and new modules. For an overview of
specifying initial conditions across a variety of base network models,
consult the <a href="http://www.epimodel.org/tut.html">Basic Network Models</a>
tutorials.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code>init.net</code>.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+param.net">param.net</a></code> to specify model parameters and
<code><a href="#topic+control.net">control.net</a></code> to specify the control settings. Run the
parameterized model with <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of using status.vector and infTime.vector together
n &lt;- 100
status &lt;- sample(c("s", "i"), size = n, replace = TRUE, prob = c(0.8, 0.2))
infTime &lt;- rep(NA, n)
infTime[which(status == "i")] &lt;- -rgeom(sum(status == "i"), prob = 0.01) + 2

init.net(status.vector = status, infTime.vector = infTime)

</code></pre>

<hr>
<h2 id='InitErgmTerm.absdiffby'>Definition for absdiffby ERGM Term</h2><span id='topic+InitErgmTerm.absdiffby'></span><span id='topic+absdiffby'></span>

<h3>Description</h3>

<p>This function defines and initializes the absdiffby ERGM term
that allows for representing homophily with respect to a
non-binary attribute (e.g., age) differentially by a binary
attribute (e.g., sex).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitErgmTerm.absdiffby(nw, arglist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InitErgmTerm.absdiffby_+3A_nw">nw</code></td>
<td>
<p>An object of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="InitErgmTerm.absdiffby_+3A_arglist">arglist</code></td>
<td>
<p>A list of arguments as specified in the <code>ergm.userterms</code>
package framework.</p>
</td></tr>
<tr><td><code id="InitErgmTerm.absdiffby_+3A_...">...</code></td>
<td>
<p>Additional data passed into the function as specified in the
<code>ergm.userterms</code> package framework.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This ERGM user term was written to allow for age-based homophily in
partnership formation that is asymmetric by sex. The <code>absdiff</code> component
targets age-based homophily while the <code>by</code> component allows that to be
structured by a binary attribute such as &quot;male&quot;, in order to enforce an
offset in the average difference. This allows, for example, a average age
difference in partnerships, but with males (on average) older than females.
</p>

<hr>
<h2 id='InitErgmTerm.absdiffnodemix'>Definition for absdiffnodemix ERGM Term</h2><span id='topic+InitErgmTerm.absdiffnodemix'></span><span id='topic+absdiffnodemix'></span>

<h3>Description</h3>

<p>This function defines and initializes the absdiffnodemix ERGM
term that allows for targeting homophily based on a non-binary
attribute (e.g., age) by combinations of a binary attribute
(e.g., race).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitErgmTerm.absdiffnodemix(nw, arglist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InitErgmTerm.absdiffnodemix_+3A_nw">nw</code></td>
<td>
<p>An object of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="InitErgmTerm.absdiffnodemix_+3A_arglist">arglist</code></td>
<td>
<p>A list of arguments as specified in the <code>ergm.userterms</code>
package framework.</p>
</td></tr>
<tr><td><code id="InitErgmTerm.absdiffnodemix_+3A_...">...</code></td>
<td>
<p>Additional data passed into the function as specified in the
<code>ergm.userterms</code> package framework.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This ERGM user term was written to allow for age-based homophily in
partnership formation that is heterogeneous by race. The <code>absdiff</code>
component targets the distribution of age mixing on that continuous
variable, and the <code>nodemix</code> component differentiates this for
black-black, black-white, and white-white couples.
</p>

<hr>
<h2 id='InitErgmTerm.fuzzynodematch'>Definition for fuzzynodematch ERGM Term</h2><span id='topic+InitErgmTerm.fuzzynodematch'></span><span id='topic+fuzzynodematch'></span>

<h3>Description</h3>

<p>This function defines and initializes the fuzzynodematch ERGM
term that allows for generalized homophily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitErgmTerm.fuzzynodematch(nw, arglist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InitErgmTerm.fuzzynodematch_+3A_nw">nw</code></td>
<td>
<p>An object of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="InitErgmTerm.fuzzynodematch_+3A_arglist">arglist</code></td>
<td>
<p>A list of arguments as specified in the <code>ergm.userterms</code>
package framework.</p>
</td></tr>
<tr><td><code id="InitErgmTerm.fuzzynodematch_+3A_...">...</code></td>
<td>
<p>Additional data passed into the function as specified in the
<code>ergm.userterms</code> package framework.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This ERGM user term was written to allow for generalized homophily.The
<code>attr</code> term argument should specify a character vertex attribute
encoding the &quot;venues&quot; associated to each node.  The <code>split</code> argument
should specify a string that separates different &quot;venues&quot; in the attribute
value for each node, as handled by <code>strsplit</code> with <code>fixed = TRUE</code>.
For example, if <code>split</code> is <code>"|"</code> (the default), and the attribute
value for a given node is <code>"a12|b476"</code>, then the associated venues for
this node are <code>"a12"</code> and <code>"b476"</code>.  The empty string <code>""</code> is
interpreted as &quot;no venues&quot;.
</p>
<p>If the <code>binary</code> term argument is <code>FALSE</code> (the default), the change
statistic for an on-toggle is the number of unique venues associated to both
nodes (informally speaking, this could be described as the number of venues
on which the two nodes &quot;match&quot;); if <code>binary</code> is <code>TRUE</code>, the change
statistic for an on-toggle is <code>1</code> if any venue is associated to both
nodes, and <code>0</code> otherwise.
</p>

<hr>
<h2 id='initialize.icm'>Initialization: icm Module</h2><span id='topic+initialize.icm'></span>

<h3>Description</h3>

<p>This function initializes the main <code>icm_dat</code> class data
object, and simulates disease status and other attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize.icm(param, init, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize.icm_+3A_param">param</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+param.icm">param.icm</a></code>.</p>
</td></tr>
<tr><td><code id="initialize.icm_+3A_init">init</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+init.icm">init.icm</a></code>.</p>
</td></tr>
<tr><td><code id="initialize.icm_+3A_control">control</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+control.icm">control.icm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>

<hr>
<h2 id='initialize.net'>Initialization: netsim Module</h2><span id='topic+initialize.net'></span>

<h3>Description</h3>

<p>This function initializes the main <code>netsim_dat</code> class data
object on which data are stored, simulates the initial state of
the networks, and simulates disease status and other attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize.net(x, param, init, control, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize.net_+3A_x">x</code></td>
<td>
<p>If <code>control$start == 1</code>, either a fitted network model object
of class <code>netest</code> or a list of such objects. If
<code>control$start &gt; 1</code>, an object of class <code>netsim</code>. When
multiple networks are used, the node sets (including network size
and nodal attributes) are assumed to be the same for all networks.</p>
</td></tr>
<tr><td><code id="initialize.net_+3A_param">param</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+param.net">param.net</a></code>.</p>
</td></tr>
<tr><td><code id="initialize.net_+3A_init">init</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+init.net">init.net</a></code>.</p>
</td></tr>
<tr><td><code id="initialize.net_+3A_control">control</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+control.net">control.net</a></code>.</p>
</td></tr>
<tr><td><code id="initialize.net_+3A_s">s</code></td>
<td>
<p>Simulation number, used for restarting dependent simulations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When re-initializing a simulation, the <code>netsim</code> object passed
to <code>initialize.net</code> must contain the elements <code>param</code>,
<code>nwparam</code>, <code>epi</code>, <code>attr</code>, <code>temp</code>,
<code>coef.form</code>, and <code>num.nw</code>. If <code>tergmLite == TRUE</code> it
must also contain the elements <code>el</code> and <code>net_attr</code>. If
<code>tergmLite == FALSE</code> it must also contain the element
<code>network</code>.
</p>


<h3>Value</h3>

<p>A <code>netsim_dat</code> class main data object.
</p>

<hr>
<h2 id='is_active_posit_ids'>Are These Nodes Active (Positional IDs)</h2><span id='topic+is_active_posit_ids'></span>

<h3>Description</h3>

<p>Are These Nodes Active (Positional IDs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_active_posit_ids(dat, posit_ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_active_posit_ids_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="is_active_posit_ids_+3A_posit_ids">posit_ids</code></td>
<td>
<p>A vector of node positional identifiers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with TRUE if the node is still active and FALSE
otherwise.
</p>

<hr>
<h2 id='is_active_unique_ids'>Are These Nodes Active (Unique IDs)</h2><span id='topic+is_active_unique_ids'></span>

<h3>Description</h3>

<p>Are These Nodes Active (Unique IDs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_active_unique_ids(dat, unique_ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_active_unique_ids_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="is_active_unique_ids_+3A_unique_ids">unique_ids</code></td>
<td>
<p>A vector of node unique identifiers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with TRUE if the node is still active and FALSE
otherwise.
</p>

<hr>
<h2 id='is.transmat'>Extract Transmissions Matrix from Network Epidemic Model</h2><span id='topic+is.transmat'></span><span id='topic+transmat'></span><span id='topic+get_transmat'></span>

<h3>Description</h3>

<p>Extracts the matrix of transmission data for each transmission
event that occurred within a network epidemic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.transmat(x)

get_transmat(x, sim = 1, deduplicate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.transmat_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="is.transmat_+3A_sim">sim</code></td>
<td>
<p>Simulation number of extracted network.</p>
</td></tr>
<tr><td><code id="is.transmat_+3A_deduplicate">deduplicate</code></td>
<td>
<p>If <code>TRUE</code>, randomly select one transmission event in
the case that multiple events current per newly infected agent within
a time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following standard columns:
</p>

<ul>
<li> <p><strong>at:</strong> the time step at which the transmission occurred.
</p>
</li>
<li> <p><strong>sus:</strong> the ID number of the susceptible (newly infected) node.
</p>
</li>
<li> <p><strong>inf:</strong> the ID number of the infecting node.
</p>
</li>
<li> <p><strong>infDur:</strong> the duration of the infecting node's disease at the
time of the transmission.
</p>
</li>
<li> <p><strong>transProb:</strong> the probability of transmission per act.
</p>
</li>
<li> <p><strong>actRate:</strong> the rate of acts per unit time.
</p>
</li>
<li> <p><strong>finalProb:</strong> the final transmission probability for the
transmission event.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Simulate SI epidemic on two-group Bernoulli random graph
nw &lt;- network_initialize(n = 100)
nw &lt;- set_vertex_attribute(nw, "group", rep(1:2, each = 50))
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)
param &lt;- param.net(inf.prob = 0.3, inf.prob.g2 = 0.15)
init &lt;- init.net(i.num = 10, i.num.g2 = 10)
control &lt;- control.net(type = "SI", nsteps = 10, nsims = 3, verbose = FALSE)
mod &lt;- netsim(est, param, init, control)

## Extract the transmission matrix from simulation 2
get_transmat(mod, sim = 2)

</code></pre>

<hr>
<h2 id='make_module_list'>Populate the Module List After the Initialization Module is run</h2><span id='topic+make_module_list'></span>

<h3>Description</h3>

<p>Populate the Module List After the Initialization Module is run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_module_list(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_module_list_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='make_stats_table'>Create a Summary Table of Simulation Statistics</h2><span id='topic+make_stats_table'></span>

<h3>Description</h3>

<p>Create a Summary Table of Simulation Statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_stats_table(stats, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_stats_table_+3A_stats">stats</code></td>
<td>
<p>A list of simulated statistics matrices, of length equal to the
number of simulations performed.  Each matrix should have one row for each
simulated network if <code>dynamic == FALSE</code>, one row for each time step
if <code>dynamic == TRUE</code>, and one column for each statistic.  The columns
should be named for the statistics they correspond to, with all matrices
having the same statistics, in the same order.  Each matrix may have an
<code>attr</code>-style attribute named <code>"ess"</code> attached, giving the
effective sample sizes for the columns of the matrix; if this attribute is
<code>NULL</code>, then the effective sample sizes will be computed within the
call to <code>make_stats_table</code>.</p>
</td></tr>
<tr><td><code id="make_stats_table_+3A_targets">targets</code></td>
<td>
<p>A vector of target values for the statistics in <code>stats</code>.
May be named (in which case targets will be matched to statistics based on
column names in matrices in <code>stats</code>) or unnamed (in which case
targets will be matched to statistics based on position, and the number of
targets must equal the number of columns).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> summarizing the simulated statistics.
</p>

<hr>
<h2 id='mcat'>Write Out Test Progress to Console</h2><span id='topic+mcat'></span>

<h3>Description</h3>

<p>Writes the name of a test and <code>...</code> to console to show test
progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcat(test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcat_+3A_test">test</code></td>
<td>
<p>Character string with the name of a test.</p>
</td></tr>
</table>

<hr>
<h2 id='merge.icm'>Merge Data across Stochastic Individual Contact Model Simulations</h2><span id='topic+merge.icm'></span>

<h3>Description</h3>

<p>Merges epidemiological data from two independent simulations of
stochastic individual contact models from <code><a href="#topic+icm">icm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icm'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.icm_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+icm">icm</a></code>.</p>
</td></tr>
<tr><td><code id="merge.icm_+3A_y">y</code></td>
<td>
<p>Another <code>EpiModel</code> object of class <code><a href="#topic+icm">icm</a></code>, with the
identical model parameterization as <code>x</code>.</p>
</td></tr>
<tr><td><code id="merge.icm_+3A_...">...</code></td>
<td>
<p>Additional merge arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This merge function combines the results of two independent simulations of
<code><a href="#topic+icm">icm</a></code> class models, simulated under separate function calls. The
model parameterization between the two calls must be exactly the same, except
for the number of simulations in each call. This allows for manual
parallelization of model simulations.
</p>
<p>This merge function does not work the same as the default merge, which allows
for a combined object where the structure differs between the input elements.
Instead, the function checks that objects are identical in model
parameterization in every respect (except number of simulations) and binds
the results.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code><a href="#topic+icm">icm</a></code> containing the
data from both <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- param.icm(inf.prob = 0.2, act.rate = 0.8)
init &lt;- init.icm(s.num = 1000, i.num = 100)
control &lt;- control.icm(type = "SI", nsteps = 10,
                       nsims = 3, verbose = FALSE)
x &lt;- icm(param, init, control)

control &lt;- control.icm(type = "SI", nsteps = 10,
                       nsims = 1, verbose = FALSE)
y &lt;- icm(param, init, control)

z &lt;- merge(x, y)

# Examine separate and merged data
as.data.frame(x)
as.data.frame(y)
as.data.frame(z)

</code></pre>

<hr>
<h2 id='merge.netsim'>Merge Model Simulations across netsim Objects</h2><span id='topic+merge.netsim'></span>

<h3>Description</h3>

<p>Merges epidemiological data from two independent simulations of
stochastic network models from <code>netsim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netsim'
merge(
  x,
  y,
  keep.transmat = TRUE,
  keep.network = TRUE,
  keep.nwstats = TRUE,
  keep.other = TRUE,
  param.error = TRUE,
  keep.diss.stats = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.netsim_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="merge.netsim_+3A_y">y</code></td>
<td>
<p>Another <code>EpiModel</code> object of class <code><a href="#topic+netsim">netsim</a></code>,
with the identical model parameterization as <code>x</code>.</p>
</td></tr>
<tr><td><code id="merge.netsim_+3A_keep.transmat">keep.transmat</code></td>
<td>
<p>If <code>TRUE</code>, keep the transmission matrices from the
original <code>x</code> and <code>y</code> elements. Note: transmission matrices
only saved when (<code>save.transmat == TRUE</code>).</p>
</td></tr>
<tr><td><code id="merge.netsim_+3A_keep.network">keep.network</code></td>
<td>
<p>If <code>TRUE</code>, keep the <code>networkDynamic</code> objects
from the original <code>x</code> and <code>y</code> elements. Note: network
only saved when (<code>tergmLite == FALSE</code>).</p>
</td></tr>
<tr><td><code id="merge.netsim_+3A_keep.nwstats">keep.nwstats</code></td>
<td>
<p>If <code>TRUE</code>, keep the network statistics (as set by
the <code>nwstats.formula</code> parameter in <code>control.netsim</code>) from
the original <code>x</code> and <code>y</code> elements.</p>
</td></tr>
<tr><td><code id="merge.netsim_+3A_keep.other">keep.other</code></td>
<td>
<p>If <code>TRUE</code>, keep the other simulation elements (as set
by the <code>save.other</code> parameter in <code>control.netsim</code>) from the
original <code>x</code> and <code>y</code> elements.</p>
</td></tr>
<tr><td><code id="merge.netsim_+3A_param.error">param.error</code></td>
<td>
<p>If <code>TRUE</code>, if <code>x</code> and <code>y</code> have different
params (in <code><a href="#topic+param.net">param.net</a></code>) or controls (passed in
<code><a href="#topic+control.net">control.net</a></code>) an error will prevent the merge. Use
<code>FALSE</code> to override that check.</p>
</td></tr>
<tr><td><code id="merge.netsim_+3A_keep.diss.stats">keep.diss.stats</code></td>
<td>
<p>If <code>TRUE</code>, keep <code>diss.stats</code> from the
original <code>x</code> and <code>y</code> objects.</p>
</td></tr>
<tr><td><code id="merge.netsim_+3A_...">...</code></td>
<td>
<p>Additional merge arguments (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This merge function combines the results of two independent simulations of
<code><a href="#topic+netsim">netsim</a></code> class models, simulated under separate function calls.
The model parameterization between the two calls must be exactly the same,
except for the number of simulations in each call. This allows for manual
parallelization of model simulations.
</p>
<p>This merge function does not work the same as the default merge, which allows
for a combined object where the structure differs between the input elements.
Instead, the function checks that objects are identical in model
parameterization in every respect (except number of simulations) and binds
the results.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code><a href="#topic+netsim">netsim</a></code> containing
the data from both <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Network model
nw &lt;- network_initialize(n = 100)
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 10)
est &lt;- netest(nw, formation = ~edges, target.stats = 25,
              coef.diss = coef.diss, verbose = FALSE)

# Epidemic models
param &lt;- param.net(inf.prob = 1)
init &lt;- init.net(i.num = 1)
control &lt;- control.net(type = "SI", nsteps = 20, nsims = 2,
                       save.nwstats = TRUE,
                       nwstats.formula = ~edges + degree(0),
                       verbose = FALSE)
x &lt;- netsim(est, param, init, control)
y &lt;- netsim(est, param, init, control)

# Merging
z &lt;- merge(x, y)

# Examine separate and merged data
as.data.frame(x)
as.data.frame(y)
as.data.frame(z)

</code></pre>

<hr>
<h2 id='modules.icm'>Modules for Stochastic Individual Contact Models</h2><span id='topic+modules.icm'></span>

<h3>Description</h3>

<p>Stochastic individual contact models of infectious disease simulate epidemics
in which contacts between individuals are instantaneous events in discrete
time. They are intended to be the stochastic microsimulation analogs to
deterministic compartmental models.
</p>
<p>The <code><a href="#topic+icm">icm</a></code> function handles both the simulation tasks. Within this
function are a series of modules that initialize the simulation and then
simulate new infections, recoveries, and vital dynamics at each time step. A
module also handles the basic bookkeeping calculations for disease
prevalence.
</p>
<p>Writing original ICMs will require modifying the existing modules or
adding new modules to the workflow in <code><a href="#topic+icm">icm</a></code>. The existing modules
may be used as a template for replacement or new modules.
</p>
<p>This help page presents a brief overview of the module functions in the order
in which they are used within <code><a href="#topic+icm">icm</a></code>, in order to help guide users
in writing their own module functions. These module functions are not shown
on the help index since they are not called directly by the end-user. To
understand these functions in more detail, review the separate help pages
listed below.
</p>


<h3>Initialization Module</h3>

<p>This function sets up agent attributes, like disease status, on the network
at the starting time step of disease simulation, <code class="reqn">t_1</code>. For
multiple-simulation function calls, these are reset at the beginning of each
simulation.
</p>

<ul>
<li> <p><code><a href="#topic+initialize.icm">initialize.icm</a></code>: sets which agents are initially
infected, through the initial conditions passed in
<code><a href="#topic+init.icm">init.icm</a></code>.
</p>
</li></ul>



<h3>Disease Status Modification Modules</h3>

<p>The main disease simulation occurs at each time step given the current state
of the population at that step. Infection of agents is simulated as a
function of disease parameters and population composition. Recovery of agents
is likewise simulated with respect to infected nodes. These functions also
analyze the flows for summary measures such as disease incidence.
</p>

<ul>
<li> <p><code><a href="#topic+infection.icm">infection.icm</a></code>: randomly draws an edgelist given the
parameters, subsets the list for discordant pairs, and simulates
transmission on those discordant pairs through a series of draws from
a binomial distribution.
</p>
</li>
<li> <p><code><a href="#topic+recovery.icm">recovery.icm</a></code>: simulates recovery from infection either
to a lifelong immune state (for SIR models) or back to the susceptible
state (for SIS models), as a function of the recovery rate specified
in the <code>rec.rate</code> parameter. The recovery rate may vary for
two-group models.
</p>
</li></ul>



<h3>Demographic Modules</h3>

<p>Vital dynamics such as arrival and departure processes are simulated at each
time step to update entries into and exits from the population. These are
used in open-population ICMs.
</p>

<ul>
<li> <p><code><a href="#topic+departures.icm">departures.icm</a></code>: randomly simulates departures or exits
for agents given the departure rate specified in the disease-state and
group-specific departure parameters in <code><a href="#topic+param.icm">param.icm</a></code>. This
involves deactivating agents from the population, but their historical
data is preserved in the simulation.
</p>
</li>
<li> <p><code><a href="#topic+arrivals.icm">arrivals.icm</a></code>: randomly simulates new arrivals into the
population given the current population size and the arrival rate
parameters. This involves adding new agents into the population.
</p>
</li></ul>



<h3>Bookkeeping Module</h3>

<p>Simulations require bookkeeping at each time step to calculate the
summary epidemiological statistics used in the model output analysis.
</p>

<ul>
<li> <p><code><a href="#topic+prevalence.icm">prevalence.icm</a></code>: calculates the number in each disease
state (susceptible, infected, recovered) at each time step for those
active agents in the population.
</p>
</li></ul>


<hr>
<h2 id='modules.net'>Modules for Stochastic Network Models</h2><span id='topic+modules.net'></span>

<h3>Description</h3>

<p>Stochastic network models of infectious disease in EpiModel require
statistical modeling of networks, simulation of those networks forward
through time, and simulation of epidemic dynamics on top of those evolving
networks. The <code><a href="#topic+netsim">netsim</a></code> function handles both the network and
epidemic simulation tasks. Within this function are a series of modules that
initialize the simulation and then simulate new infections, recoveries, and
demographics on the network. Modules also handle the resimulation of the
network and some bookkeeping calculations for disease prevalence.
</p>
<p>Writing original network models that expand upon our &quot;base&quot; model set will
require modifying the existing modules or adding new modules to the workflow
in <code><a href="#topic+netsim">netsim</a></code>. The existing modules may be used as a template for
replacement or new modules.
</p>
<p>This help page provides an orientation to these module functions, in the
order in which they are used within <code><a href="#topic+netsim">netsim</a></code>, to help guide users
in writing their own functions. These module functions are not shown
on the help index since they are not called directly by the end-user. To
understand these functions in more detail, review the separate help pages
listed below.
</p>


<h3>Initialization Module</h3>

<p>This function sets up nodal attributes, like disease status, on the network
at the starting time step of disease simulation, <code class="reqn">t_1</code>. For
multiple-simulation function calls, these are reset at the beginning of each
individual simulation.
</p>

<ul>
<li> <p><code><a href="#topic+initialize.net">initialize.net</a></code>: sets up the main <code>netsim_dat</code> data
structure used in the simulation, initializes which nodes are infected
(via the initial conditions passed in <code><a href="#topic+init.net">init.net</a></code>), and
simulates a first time step of the networks given the network model
fit from <code><a href="#topic+netest">netest</a></code>.
</p>
</li></ul>



<h3>Disease Status Modification Modules</h3>

<p>The main disease simulation occurs at each time step given the current state
of the network at that step. Infection of nodes is simulated as a function of
attributes of the nodes and the edges. Recovery of nodes is likewise
simulated as a function of nodal attributes of those infected nodes. These
functions also calculate summary flow measures such as disease incidence.
</p>

<ul>
<li> <p><code><a href="#topic+infection.net">infection.net</a></code>: simulates disease transmission given an
edgelist of discordant partnerships by calculating the relevant
transmission and act rates for each edge, and then updating the nodal
attributes and summary statistics.
</p>
</li>
<li> <p><code><a href="#topic+recovery.net">recovery.net</a></code>: simulates recovery from infection either
to a lifelong immune state (for SIR models) or back to the susceptible
state (for SIS models), as a function of the recovery rate parameters
specified in <code><a href="#topic+param.net">param.net</a></code>.
</p>
</li></ul>



<h3>Demographic Modules</h3>

<p>Demographics such as arrival and departure processes are simulated at each
time step to update entries into and exits from the network. These are used
in epidemic models with network feedback, in which the network is resimulated
at each time step to account for the nodal changes affecting the edges.
</p>

<ul>
<li> <p><code><a href="#topic+departures.net">departures.net</a></code>: randomly simulates departure for nodes
given their disease status (susceptible, infected, recovered), and
their group-specific departure rates specified in
<code><a href="#topic+param.net">param.net</a></code>. Departures involve deactivating nodes.
</p>
</li>
<li> <p><code><a href="#topic+arrivals.net">arrivals.net</a></code>: randomly simulates new arrivals into the
network given the current population size and the arrival rate
specified in the <code>a.rate</code> parameters. This involves adding new
nodes into the network.
</p>
</li></ul>



<h3>Network Resimulation Module</h3>

<p>In dependent network models, the network object is resimulated at each time
step to account for changes in the size of the network (changed through
entries and exits), and the disease status of the nodes.
</p>

<ul>
<li> <p><code><a href="#topic+resim_nets">resim_nets</a></code>: resimulates the network object one time step
forward given the set of formation and dissolution coefficients
estimated in <code><a href="#topic+netest">netest</a></code>.
</p>
</li></ul>



<h3>Bookkeeping Module</h3>

<p>Network simulations require bookkeeping at each time step to calculate the
summary epidemiological statistics used in the model output analysis.
</p>

<ul>
<li> <p><code><a href="#topic+prevalence.net">prevalence.net</a></code>: calculates the number in each disease
state (susceptible, infected, recovered) at each time step for those
active nodes in the network. If the <code>epi.by</code> control is used, it
calculates these statistics by a set of specified nodal attributes.
</p>
</li>
<li> <p><code><a href="#topic+verbose.net">verbose.net</a></code>: summarizes the current state of the
simulation and prints this to the console.
</p>
</li></ul>



<h3>One- &amp; Two-Group Modules</h3>

<p>If epidemic <code>type</code> is supplied within <code><a href="#topic+control.net">control.net</a></code>,
EpiModel defaults each of the base epidemic and demographic modules described
above (arrivals.FUN, departures.FUN, infection.FUN, recovery.FUN) to the
correct .net function based on variables passed to <code><a href="#topic+param.net">param.net</a></code>
(e.g. num.g2, denoting population size of group two, would select the
two-group variants of the aforementioned modules). Two-group modules are
denoted by a .2g affix (e.g., recovery.2g.net)
</p>

<hr>
<h2 id='multilayer'>Specify Controls by Network</h2><span id='topic+multilayer'></span>

<h3>Description</h3>

<p>This utility function allows specification of certain
<code><a href="#topic+netsim">netsim</a></code> controls to vary by network.  The
<code><a href="#topic+netsim">netsim</a></code> control arguments currently supporting
<code>multilayer</code> specifications are <code>nwstats.formula</code>,
<code>set.control.ergm</code>, <code>set.control.tergm</code>, and
<code>tergmLite.track.duration</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilayer(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multilayer_+3A_...">...</code></td>
<td>
<p>control arguments to apply to each network, with the index of the
network corresponding to the index of the control argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>multilayer</code> containing the specified
control arguments
</p>

<hr>
<h2 id='mutate_epi'>Add New Epidemiology Variables</h2><span id='topic+mutate_epi'></span>

<h3>Description</h3>

<p>Inspired by <code>dplyr::mutate</code>, <code>mutate_epi</code> adds new
variables to the epidemiological and related variables within
simulated model objects of any class in <code>EpiModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_epi(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_epi_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>dcm</code>, <code>icm</code>, or
<code>netsim</code>.</p>
</td></tr>
<tr><td><code id="mutate_epi_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions (see examples below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>EpiModel</code> object of class <code>dcm</code>, <code>icm</code>,
or <code>netsim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DCM example
param &lt;- param.dcm(inf.prob = 0.2, act.rate = 0.25)
init &lt;- init.dcm(s.num = 500, i.num = 1)
control &lt;- control.dcm(type = "SI", nsteps = 500)
mod1 &lt;- dcm(param, init, control)
mod1 &lt;- mutate_epi(mod1, prev = i.num/num)
plot(mod1, y = "prev")

# Network model example
nw &lt;- network_initialize(n = 100)
nw &lt;- set_vertex_attribute(nw, "group", rep(1:2, each = 50))
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
est1 &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

param &lt;- param.net(inf.prob = 0.3, inf.prob.g2 = 0.15)
init &lt;- init.net(i.num = 1, i.num.g2 = 0)
control &lt;- control.net(type = "SI", nsteps = 10, nsims = 3,
                       verbose = FALSE)
mod1 &lt;- netsim(est1, param, init, control)
mod1

# Add the prevalences to the dataset
mod1 &lt;- mutate_epi(mod1, i.prev = i.num / num,
                         i.prev.g2 = i.num.g2 / num.g2)
plot(mod1, y = c("i.prev", "i.prev.g2"), qnts = 0.5, legend = TRUE)

# Add incidence rate per 100 person years (assume time step = 1 week)
mod1 &lt;- mutate_epi(mod1, ir100 = 5200*(si.flow + si.flow.g2) /
                                      (s.num + s.num.g2))
as.data.frame(mod1)
as.data.frame(mod1, out = "mean")

</code></pre>

<hr>
<h2 id='net-accessor'>Functions to Access and Edit the Main netsim_dat Object in Network Models</h2><span id='topic+net-accessor'></span><span id='topic+get_attr_list'></span><span id='topic+get_attr'></span><span id='topic+add_attr'></span><span id='topic+set_attr'></span><span id='topic+append_attr'></span><span id='topic+get_epi_list'></span><span id='topic+get_epi'></span><span id='topic+add_epi'></span><span id='topic+set_epi'></span><span id='topic+get_param_list'></span><span id='topic+get_param'></span><span id='topic+add_param'></span><span id='topic+set_param'></span><span id='topic+get_control_list'></span><span id='topic+get_control'></span><span id='topic+get_network_control'></span><span id='topic+add_control'></span><span id='topic+set_control'></span><span id='topic+get_init_list'></span><span id='topic+get_init'></span><span id='topic+add_init'></span><span id='topic+set_init'></span><span id='topic+append_core_attr'></span>

<h3>Description</h3>

<p>These <code>get_</code>, <code>set_</code>, <code>append_</code>, and <code>add_</code>
functions allow a safe and efficient way to retrieve and mutate
the main <code>netsim_dat</code> class object of network models
(typical variable name <code>dat</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attr_list(dat, item = NULL)

get_attr(dat, item, posit_ids = NULL, override.null.error = FALSE)

add_attr(dat, item)

set_attr(dat, item, value, posit_ids = NULL, override.length.check = FALSE)

append_attr(dat, item, value, n.new)

get_epi_list(dat, item = NULL)

get_epi(dat, item, at = NULL, override.null.error = FALSE)

add_epi(dat, item)

set_epi(dat, item, at, value)

get_param_list(dat, item = NULL)

get_param(dat, item, override.null.error = FALSE)

add_param(dat, item)

set_param(dat, item, value)

get_control_list(dat, item = NULL)

get_control(dat, item, override.null.error = FALSE)

get_network_control(dat, network, item, override.null.error = FALSE)

add_control(dat, item)

set_control(dat, item, value)

get_init_list(dat, item = NULL)

get_init(dat, item, override.null.error = FALSE)

add_init(dat, item)

set_init(dat, item, value)

append_core_attr(dat, at, n.new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net-accessor_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="net-accessor_+3A_item">item</code></td>
<td>
<p>A character vector containing the name of the element to access
(for <code>get_</code> functions), create (for <code>add_</code> functions), or
edit (for <code>set_</code> and <code>append_</code> functions). Can be of length
&gt; 1 for <code>get_*_list</code> functions.</p>
</td></tr>
<tr><td><code id="net-accessor_+3A_posit_ids">posit_ids</code></td>
<td>
<p>For <code>set_attr</code> and <code>get_attr</code>, a numeric vector of
posit_ids or a logical vector to subset the desired <code>item</code>.</p>
</td></tr>
<tr><td><code id="net-accessor_+3A_override.null.error">override.null.error</code></td>
<td>
<p>If TRUE, <code>get_</code> will return NULL if the
<code>item</code> does not exist instead of throwing an error.
(default = FALSE).</p>
</td></tr>
<tr><td><code id="net-accessor_+3A_value">value</code></td>
<td>
<p>New value to be attributed in the <code>set_</code> and <code>append_</code>
functions.</p>
</td></tr>
<tr><td><code id="net-accessor_+3A_override.length.check">override.length.check</code></td>
<td>
<p>If TRUE, <code>set_attr</code> allows the modification
of the <code>item</code> size. (default = FALSE).</p>
</td></tr>
<tr><td><code id="net-accessor_+3A_n.new">n.new</code></td>
<td>
<p>For <code>append_core_attr</code>, the number of new nodes to initiate
with core attributes; for <code>append_attr</code>, the number of new
elements to append at the end of <code>item</code>.</p>
</td></tr>
<tr><td><code id="net-accessor_+3A_at">at</code></td>
<td>
<p>For <code>get_epi</code>, the timestep at which to access the specified
<code>item</code>; for <code>set_epi</code>, the timestep at which to add the new
value for the epi output <code>item</code>; for <code>append_core_attr</code>, the
current time step.</p>
</td></tr>
<tr><td><code id="net-accessor_+3A_network">network</code></td>
<td>
<p>index of network for which to get control</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a list of vectors for <code>get_</code> functions; the main
list object for <code>set_</code>, <code>append_</code>, and <code>add_</code>
functions.
</p>


<h3>Core Attribute</h3>

<p>The <code>append_core_attr</code> function initializes the attributes necessary for
EpiModel to work (the four core attributes are: &quot;active&quot;, &quot;unique_id&quot;,
&quot;entrTime&quot;, and &quot;exitTime&quot;). These attributes are used in the initialization
phase of the simulation, to create the nodes (see
<code><a href="#topic+initialize.net">initialize.net</a></code>); and also used when adding nodes during the
simulation (see <code><a href="#topic+arrivals.net">arrivals.net</a></code>).
</p>


<h3>Mutability</h3>

<p>The <code>set_</code>, <code>append_</code>, and <code>add_</code> functions DO NOT modify the
<code>netsim_dat</code> object in place. The result must be assigned back to
<code>dat</code> in order to be registered: <code>dat &lt;- set_*(dat, item, value)</code>.
</p>


<h3><code>set_</code> and <code>append_</code> vs <code>add_</code></h3>

<p>The <code>set_</code> and <code>append_</code> functions edit a pre-existing element or
create a new one if it does not exist already by calling the <code>add_</code>
functions internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- list(
  attr = list(
    active = rbinom(100, 1, 0.9)
  ),
  epi = list(),
  param = list(),
  init = list(),
  control = list(
    nsteps = 150
  )
)
class(dat) &lt;- c("netsim_dat", class(dat))

dat &lt;- add_attr(dat, "age")
dat &lt;- set_attr(dat, "age", runif(100))
dat &lt;- set_attr(dat, "status", rbinom(100, 1, 0.9))
dat &lt;- set_attr(dat, "status", rep(1, 150), override.length.check = TRUE)
dat &lt;- append_attr(dat, "status", 1, 10)
dat &lt;- append_attr(dat, "age", NA, 10)
get_attr_list(dat)
get_attr_list(dat, c("age", "active"))
get_attr(dat, "status")
get_attr(dat, "status", c(1, 4))

dat &lt;- add_epi(dat, "i.num")
dat &lt;- set_epi(dat, "i.num", 150, 10)
dat &lt;- set_epi(dat, "s.num", 150, 90)
get_epi_list(dat)
get_epi_list(dat, c("i.num", "s.num"))
get_epi(dat, "i.num")
get_epi(dat, "i.num", c(1, 4))
get_epi(dat, "i.num", rbinom(150, 1, 0.2) == 1)

dat &lt;- add_param(dat, "x")
dat &lt;- set_param(dat, "x", 0.4)
dat &lt;- set_param(dat, "y", 0.8)
get_param_list(dat)
get_param_list(dat, c("x", "y"))
get_param(dat, "x")

dat &lt;- add_init(dat, "x")
dat &lt;- set_init(dat, "x", 0.4)
dat &lt;- set_init(dat, "y", 0.8)
get_init_list(dat)
get_init_list(dat, c("x", "y"))
get_init(dat, "x")

dat &lt;- add_control(dat, "x")
dat &lt;- set_control(dat, "x", 0.4)
dat &lt;- set_control(dat, "y", 0.8)
get_control_list(dat)
get_control_list(dat, c("x", "y"))
get_control(dat, "x")

</code></pre>

<hr>
<h2 id='netdx'>Dynamic Network Model Diagnostics</h2><span id='topic+netdx'></span>

<h3>Description</h3>

<p>Runs dynamic diagnostics on an ERGM/STERGM estimated with
<code><a href="#topic+netest">netest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netdx(
  x,
  nsims = 1,
  dynamic = TRUE,
  nsteps,
  nwstats.formula = "formation",
  set.control.ergm = control.simulate.formula(),
  set.control.tergm = control.simulate.formula.tergm(),
  sequential = TRUE,
  keep.tedgelist = FALSE,
  keep.tnetwork = FALSE,
  verbose = TRUE,
  ncores = 1,
  skip.dissolution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netdx_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>netest</code>.</p>
</td></tr>
<tr><td><code id="netdx_+3A_nsims">nsims</code></td>
<td>
<p>Number of simulations to run.</p>
</td></tr>
<tr><td><code id="netdx_+3A_dynamic">dynamic</code></td>
<td>
<p>If <code>TRUE</code>, runs dynamic diagnostics. If <code>FALSE</code> and
the <code>netest</code> object was fit with the Edges Dissolution
approximation method, simulates from the static ERGM fit.</p>
</td></tr>
<tr><td><code id="netdx_+3A_nsteps">nsteps</code></td>
<td>
<p>Number of time steps per simulation (dynamic simulations only).</p>
</td></tr>
<tr><td><code id="netdx_+3A_nwstats.formula">nwstats.formula</code></td>
<td>
<p>A right-hand sided ERGM formula with the network
statistics of interest. The default is the formation formula of the
network model contained in <code>x</code>.</p>
</td></tr>
<tr><td><code id="netdx_+3A_set.control.ergm">set.control.ergm</code></td>
<td>
<p>Control arguments passed to <code>ergm</code>'s
<code>simulate_formula.network</code> (see details).</p>
</td></tr>
<tr><td><code id="netdx_+3A_set.control.tergm">set.control.tergm</code></td>
<td>
<p>Control arguments passed to <code>tergm</code>'s
<code>simulate_formula.network</code> (see details).</p>
</td></tr>
<tr><td><code id="netdx_+3A_sequential">sequential</code></td>
<td>
<p>For static diagnostics (<code>dynamic=FALSE</code>): if
<code>FALSE</code>, each of the <code>nsims</code> simulated Markov chains begins
at the initial network; if <code>TRUE</code>, the end of one simulation is
used as the start of the next.</p>
</td></tr>
<tr><td><code id="netdx_+3A_keep.tedgelist">keep.tedgelist</code></td>
<td>
<p>If <code>TRUE</code>, keep the timed edgelist generated from
the dynamic simulations. Returned in the form of a list of matrices,
with one entry per simulation. Accessible at <code>$edgelist</code>.</p>
</td></tr>
<tr><td><code id="netdx_+3A_keep.tnetwork">keep.tnetwork</code></td>
<td>
<p>If <code>TRUE</code>, keep the full networkDynamic objects
from the dynamic simulations. Returned in the form of a list of nD
objects, with one entry per simulation. Accessible at <code>$network</code>.</p>
</td></tr>
<tr><td><code id="netdx_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print progress to the console.</p>
</td></tr>
<tr><td><code id="netdx_+3A_ncores">ncores</code></td>
<td>
<p>Number of processor cores to run multiple simulations
on, using the <code>foreach</code> and <code>doParallel</code> implementations.</p>
</td></tr>
<tr><td><code id="netdx_+3A_skip.dissolution">skip.dissolution</code></td>
<td>
<p>If <code>TRUE</code>, skip over the calculations of
duration and dissolution stats in <code>netdx</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>netdx</code> function handles dynamic network diagnostics for network
models fit with the <code><a href="#topic+netest">netest</a></code> function. Given the fitted model,
<code>netdx</code> simulates a specified number of dynamic networks for a specified
number of time steps per simulation. The network statistics in
<code>nwstats.formula</code> are saved for each time step. Summary statistics for
the formation model terms, as well as dissolution model and relational
duration statistics, are then calculated and can be accessed when printing or
plotting the <code>netdx</code> object.  See <code><a href="#topic+print.netdx">print.netdx</a></code> and
<code><a href="#topic+plot.netdx">plot.netdx</a></code> for details on printing and plotting.
</p>


<h3>Value</h3>

<p>A list of class <code>netdx</code>.
</p>


<h3>Control Arguments</h3>

<p>Models fit with the full STERGM method in <code>netest</code> (setting the
<code>edapprox</code> argument to <code>FALSE</code>) require only a call to
<code>tergm</code>'s <code>simulate_formula.network</code>. Control parameters for those
simulations may be set using <code>set.control.tergm</code> in <code>netdx</code>.
The parameters should be input through the <code>control.simulate.formula.tergm</code>
function, with the available parameters listed in the
<code><a href="tergm.html#topic+control.simulate.formula.tergm">control.simulate.formula.tergm</a></code> help page in the <code>tergm</code>
package.
</p>
<p>Models fit with the ERGM method with the edges dissolution approximation
(setting <code>edapprox</code> to <code>TRUE</code>) require a call first to
<code>ergm</code>'s <code>simulate_formula.network</code> for simulating an initial
network, and second to <code>tergm</code>'s <code>simulate_formula.network</code> for
simulating that static network forward through time. Control parameters may
be set for both processes in <code>netdx</code>. For the first, the parameters
should be input through the <code>control.simulate.formula()</code> function, with
the available parameters listed in the
<code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code> help
page in the <code>ergm</code> package. For the second, parameters should be input
through the <code>control.simulate.formula.tergm()</code> function, with the
available parameters listed in the <code><a href="tergm.html#topic+control.simulate.formula.tergm">control.simulate.formula.tergm</a></code>
help page in the <code>tergm</code> package. An example is shown below.
</p>


<h3>See Also</h3>

<p>Plot these model diagnostics with <code><a href="#topic+plot.netdx">plot.netdx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Network initialization and model parameterization
nw &lt;- network_initialize(n = 100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~ offset(edges), duration = 25)

# Estimate the model
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Static diagnostics on the ERGM fit
dx1 &lt;- netdx(est,
  nsims = 1e4, dynamic = FALSE,
  nwstats.formula = ~ edges + meandeg + concurrent
)
dx1
plot(dx1, method = "b", stats = c("edges", "concurrent"))

# Dynamic diagnostics on the STERGM approximation
dx2 &lt;- netdx(est,
  nsims = 5, nsteps = 500,
  nwstats.formula = ~ edges + meandeg + concurrent,
  set.control.ergm = control.simulate.formula(MCMC.burnin = 1e6)
)
dx2
plot(dx2, stats = c("edges", "meandeg"), plots.joined = FALSE)
plot(dx2, type = "duration")
plot(dx2, type = "dissolution", qnts.col = "orange2")
plot(dx2, type = "dissolution", method = "b", col = "bisque")

# Dynamic diagnostics on a more complex model
nw &lt;- network_initialize(n = 1000)
nw &lt;- set_vertex_attribute(nw, "neighborhood", rep(1:10, 100))
formation &lt;- ~edges + nodematch("neighborhood", diff = TRUE)
target.stats &lt;- c(800, 45, 81, 24, 16, 32, 19, 42, 21, 24, 31)
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges) +
                    offset(nodematch("neighborhood", diff = TRUE)),
                    duration = c(52, 58, 61, 55, 81, 62, 52, 64, 52, 68, 58))
est2 &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)
dx3 &lt;- netdx(est2, nsims = 5, nsteps = 100)
print(dx3)
plot(dx3)
plot(dx3, type = "duration", plots.joined = TRUE, qnts = 0.2, legend = TRUE)
plot(dx3, type = "dissolution", mean.smooth = FALSE, mean.col = "red")

## End(Not run)

</code></pre>

<hr>
<h2 id='netest'>Dynamic Network Model Estimation</h2><span id='topic+netest'></span>

<h3>Description</h3>

<p>Estimates statistical network models using the exponential
random graph modeling (ERGM) framework with extensions for
dynamic/temporal models (STERGM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netest(
  nw,
  formation,
  target.stats,
  coef.diss,
  constraints,
  coef.form = NULL,
  edapprox = TRUE,
  set.control.ergm = control.ergm(),
  set.control.tergm = control.tergm(),
  set.control.ergm.ego = control.ergm.ego(),
  verbose = FALSE,
  nested.edapprox = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netest_+3A_nw">nw</code></td>
<td>
<p>An object of class <code>network</code> or <code>egor</code>, with the latter
indicating an <code>ergm.ego</code> fit.</p>
</td></tr>
<tr><td><code id="netest_+3A_formation">formation</code></td>
<td>
<p>Right-hand sided STERGM formation formula in the form
<code>~edges + ...</code>, where <code>...</code> are additional network
statistics.</p>
</td></tr>
<tr><td><code id="netest_+3A_target.stats">target.stats</code></td>
<td>
<p>Vector of target statistics for the formation model, with
one number for each network statistic in the model.  Ignored if
fitting via <code>ergm.ego</code>.</p>
</td></tr>
<tr><td><code id="netest_+3A_coef.diss">coef.diss</code></td>
<td>
<p>An object of class <code>disscoef</code> output from the
<code><a href="#topic+dissolution_coefs">dissolution_coefs</a></code> function.</p>
</td></tr>
<tr><td><code id="netest_+3A_constraints">constraints</code></td>
<td>
<p>Right-hand sided formula specifying constraints for the
modeled network, in the form <code>~...</code>, where <code>...</code> are
constraint terms. By default, no constraints are set.</p>
</td></tr>
<tr><td><code id="netest_+3A_coef.form">coef.form</code></td>
<td>
<p>Vector of coefficients for the offset terms in the formation
formula.</p>
</td></tr>
<tr><td><code id="netest_+3A_edapprox">edapprox</code></td>
<td>
<p>If <code>TRUE</code>, use the indirect edges dissolution
approximation  method for the dynamic model fit, otherwise use the
more time-intensive full STERGM estimation (see details).  For
<code>nw</code> of class <code>egor</code>, only <code>edapprox = TRUE</code> is
supported.</p>
</td></tr>
<tr><td><code id="netest_+3A_set.control.ergm">set.control.ergm</code></td>
<td>
<p>Control arguments passed to <code>ergm</code> (see
details).</p>
</td></tr>
<tr><td><code id="netest_+3A_set.control.tergm">set.control.tergm</code></td>
<td>
<p>Control arguments passed to <code>tergm</code>
(see details).</p>
</td></tr>
<tr><td><code id="netest_+3A_set.control.ergm.ego">set.control.ergm.ego</code></td>
<td>
<p>Control arguments passed to <code>ergm.ego</code> (see
details).</p>
</td></tr>
<tr><td><code id="netest_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print model fitting progress to console.</p>
</td></tr>
<tr><td><code id="netest_+3A_nested.edapprox">nested.edapprox</code></td>
<td>
<p>Logical. If <code>edapprox = TRUE</code> the dissolution
model is an initial segment of the formation model (see details).</p>
</td></tr>
<tr><td><code id="netest_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>netest</code> is a wrapper function for the <code>ergm</code>, <code>ergm.ego</code>,
and <code>tergm</code> functions that estimate static and dynamic network models.
Network model estimation is the first step in simulating a stochastic
network epidemic model in <code>EpiModel</code>. The output from <code>netest</code> is
a necessary input for running the epidemic simulations in
<code><a href="#topic+netsim">netsim</a></code>. With a fitted network model, one should always first
proceed to model diagnostics, available through the <code><a href="#topic+netdx">netdx</a></code>
function, to check model fit. A detailed description of fitting these
models, along with examples, may be found in the
<a href="http://www.epimodel.org/tut.html">Basic Network Models</a> tutorials.
</p>


<h3>Value</h3>

<p>A fitted network model object of class <code>netest</code>.
</p>


<h3>Edges Dissolution Approximation</h3>

<p>The edges dissolution approximation method is described in Carnegie et al.
This approximation requires that the dissolution coefficients are known, that
the formation model is being fit to cross-sectional data conditional on those
dissolution coefficients, and that the terms in the dissolution model are a
subset of those in the formation model. Under certain additional conditions,
the formation coefficients of a STERGM model are approximately equal to the
coefficients of that same model fit to the observed cross-sectional data as
an ERGM, minus the corresponding coefficients in the dissolution model. The
approximation thus estimates this ERGM (which is typically much faster than
estimating a STERGM) and subtracts the dissolution coefficients.
</p>
<p>The conditions under which this approximation best hold are when there are
few relational changes from one time step to another; i.e. when either
average relational durations are long, or density is low, or both.
Conveniently, these are the same conditions under which STERGM estimation is
slowest. Note that the same approximation is also used to obtain starting
values for the STERGM estimate when the latter is being conducted. The
estimation does not allow for calculation of standard errors, p-values, or
likelihood for the formation model; thus, this approach is of most use when
the main goal of estimation is to drive dynamic network simulations rather
than to conduct inference on the formation model. The user is strongly
encouraged to examine the behavior of the resulting simulations to confirm
that the approximation is adequate for their purposes. For an example, see
the vignette for the package <code>tergm</code>.
</p>
<p>It has recently been found that subtracting a modified version of the
dissolution coefficients from the formation coefficients provides a more
principled approximation, and this is now the form of the approximation
applied by <code>netest</code>. The modified values subtracted from the formation
coefficients are equivalent to the (crude) dissolution coefficients with
their target durations increased by 1. The <code>nested.edapprox</code> argument
toggles whether to implement this modified version by appending the
dissolution terms to the formation model and appending the relevant values to
the vector of formation model coefficients (value = <code>FALSE</code>), whereas
the standard version subtracts the relevant values from the initial formation
model coefficients (value = <code>TRUE</code>).
</p>


<h3>Control Arguments</h3>

<p>The <code>ergm</code>, <code>ergm.ego</code>, and <code>tergm</code> functions allow control
settings for the model fitting process. When fitting a STERGM directly (setting
<code>edapprox</code> to <code>FALSE</code>), control parameters may be passed to the
<code>tergm</code> function with the <code>set.control.tergm</code> argument in
<code>netest</code>. The controls should be input through the
<code>control.tergm()</code> function, with the available parameters listed in the
<code><a href="tergm.html#topic+control.tergm">control.tergm</a></code> help page in the <code>tergm</code> package.
</p>
<p>When fitting a STERGM indirectly (setting <code>edapprox</code> to <code>TRUE</code>),
control settings may be passed to the <code>ergm</code> function using
<code>set.control.ergm</code>, or to the <code>ergm.ego</code> function using
<code>set.control.ergm.ego</code>.  The controls should be input through the
<code>control.ergm()</code> and <code>control.ergm.ego()</code> functions, respectively,
with the available parameters listed in the
<code><a href="ergm.html#topic+control.ergm">control.ergm</a></code> help page in the <code>ergm</code>
package and the <code><a href="ergm.ego.html#topic+control.ergm.ego">control.ergm.ego</a></code>
help page in the <code>ergm.ego</code> package. An example is below.
</p>


<h3>References</h3>

<p>Krivitsky PN, Handcock MS. &quot;A separable model for dynamic networks.&quot; JRSS(B).
2014; 76.1:29-46.
</p>
<p>Carnegie NB, Krivitsky PN, Hunter DR, Goodreau SM. An approximation method
for improving dynamic network model fitting. Journal of Computational and
Graphical Statistics. 2014; 24(2): 502-519.
</p>
<p>Jenness SM, Goodreau SM and Morris M. EpiModel: An R Package for Mathematical
Modeling of Infectious Disease over Networks. Journal of Statistical
Software. 2018; 84(8): 1-47.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+netdx">netdx</a></code> to diagnose the fitted network model, and
<code><a href="#topic+netsim">netsim</a></code> to simulate epidemic spread over a simulated
dynamic network consistent with the model fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initialize a network of 100 nodes
nw &lt;- network_initialize(n = 100)

# Set formation formula
formation &lt;- ~edges + concurrent

# Set target statistics for formation
target.stats &lt;- c(50, 25)

# Obtain the offset coefficients
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 10)

# Estimate the STERGM using the edges dissolution approximation
est &lt;- netest(nw, formation, target.stats, coef.diss,
              set.control.ergm = control.ergm(MCMC.burnin = 1e5,
                                              MCMC.interval = 1000))
est

# To estimate the STERGM directly, use edapprox = FALSE
# est2 &lt;- netest(nw, formation, target.stats, coef.diss, edapprox = FALSE)

</code></pre>

<hr>
<h2 id='netsim'>Stochastic Network Models</h2><span id='topic+netsim'></span>

<h3>Description</h3>

<p>Simulates stochastic network epidemic models for infectious
disease.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netsim(x, param, init, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netsim_+3A_x">x</code></td>
<td>
<p>If <code>control$start == 1</code>, either a fitted network model object
of class <code>netest</code> or a list of such objects. If
<code>control$start &gt; 1</code>, an object of class <code>netsim</code>. When
multiple networks are used, the node sets (including network size
and nodal attributes) are assumed to be the same for all networks.</p>
</td></tr>
<tr><td><code id="netsim_+3A_param">param</code></td>
<td>
<p>Model parameters, as an object of class <code>param.net</code>.</p>
</td></tr>
<tr><td><code id="netsim_+3A_init">init</code></td>
<td>
<p>Initial conditions, as an object of class <code>init.net</code>.</p>
</td></tr>
<tr><td><code id="netsim_+3A_control">control</code></td>
<td>
<p>Control settings, as an object of class
<code>control.net</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stochastic network models explicitly represent phenomena within and across
edges (pairs of nodes that remain connected) over time. This enables edges to
have duration, allowing for repeated transmission-related acts within the
same dyad, specification of edge formation and dissolution rates, control
over the temporal sequencing of multiple edges, and specification of
network-level features. A detailed description of these models, along with
examples, is found in the <a href="http://www.epimodel.org/tut.html">Basic
Network Models</a> tutorials.
</p>
<p>The <code>netsim</code> function performs modeling of both the base model types
and original models. Base model types include one-group and two-group models
with disease types for Susceptible-Infected (SI),
Susceptible-Infected-Recovered (SIR), and
Susceptible-Infected-Susceptible (SIS).
</p>
<p>Original models may be parameterized by writing new process modules that
either take the place of existing modules (for example, disease recovery), or
supplement the set of existing processes with a new one contained in a new
module. This functionality is documented in the
<a href="http://www.epimodel.org/tut.html">Extension Network Models</a> tutorials.
The list of modules within <code>netsim</code> available for modification is listed
in <code><a href="#topic+modules.net">modules.net</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code>netsim</code> with the following elements:
</p>

<ul>
<li> <p><strong>param:</strong> the epidemic parameters passed into the model through
<code>param</code>, with additional parameters added as necessary.
</p>
</li>
<li> <p><strong>control:</strong> the control settings passed into the model through
<code>control</code>, with additional controls added as necessary.
</p>
</li>
<li> <p><strong>epi:</strong> a list of data frames, one for each epidemiological
output from the model. Outputs for base models always include the
size of each compartment, as well as flows in, out of, and between
compartments.
</p>
</li>
<li> <p><strong>stats:</strong> a list containing two sublists, <code>nwstats</code> for any
network statistics saved in the simulation, and <code>transmat</code> for
the transmission matrix saved in the simulation. See
<code><a href="#topic+control.net">control.net</a></code> and the
<a href="http://www.epimodel.org/tut.html">tutorials</a> for further
details.
</p>
</li>
<li> <p><strong>network:</strong> a list of lists of <code>networkDynamic</code> or
<code>networkLite</code> objects, with one list of objects for each model
simulation.
</p>
</li></ul>

<p>If <code>control$raw.output == TRUE</code>: A list of the raw (pre-processed)
<code>netsim_dat</code> objects, for use in simulation continuation.
</p>


<h3>References</h3>

<p>Jenness SM, Goodreau SM and Morris M. EpiModel: An R Package for Mathematical
Modeling of Infectious Disease over Networks. Journal of Statistical
Software. 2018; 84(8): 1-47.
</p>


<h3>See Also</h3>

<p>Extract the model results with <code><a href="#topic+as.data.frame.netsim">as.data.frame.netsim</a></code>.
Summarize the time-specific model results with
<code><a href="#topic+summary.netsim">summary.netsim</a></code>. Plot the model results with
<code><a href="#topic+plot.netsim">plot.netsim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1: SI Model without Network Feedback
# Network model estimation
nw &lt;- network_initialize(n = 100)
nw &lt;- set_vertex_attribute(nw, "group", rep(1:2, each = 50))
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
est1 &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Epidemic model
param &lt;- param.net(inf.prob = 0.3, inf.prob.g2 = 0.15)
init &lt;- init.net(i.num = 10, i.num.g2 = 10)
control &lt;- control.net(type = "SI", nsteps = 100, nsims = 5, verbose.int = 0)
mod1 &lt;- netsim(est1, param, init, control)

# Print, plot, and summarize the results
mod1
plot(mod1)
summary(mod1, at = 50)

## Example 2: SIR Model with Network Feedback
# Recalculate dissolution coefficient with departure rate
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20,
                               d.rate = 0.0021)

# Reestimate the model with new coefficient
est2 &lt;- netest(nw, formation, target.stats, coef.diss)

# Reset parameters to include demographic rates
param &lt;- param.net(inf.prob = 0.3, inf.prob.g2 = 0.15,
                   rec.rate = 0.02, rec.rate.g2 = 0.02,
                   a.rate = 0.002, a.rate.g2 = NA,
                   ds.rate = 0.001, ds.rate.g2 = 0.001,
                   di.rate = 0.001, di.rate.g2 = 0.001,
                   dr.rate = 0.001, dr.rate.g2 = 0.001)
init &lt;- init.net(i.num = 10, i.num.g2 = 10,
                 r.num = 0, r.num.g2 = 0)
control &lt;- control.net(type = "SIR", nsteps = 100, nsims = 5,
                       resimulate.network = TRUE, tergmLite = TRUE)

# Simulate the model with new network fit
mod2 &lt;- netsim(est2, param, init, control)

# Print, plot, and summarize the results
mod2
plot(mod2)
summary(mod2, at = 40)

## End(Not run)

</code></pre>

<hr>
<h2 id='netsim_cond_msg'>Message to Find in Which Module a <code>condition</code> Occurred</h2><span id='topic+netsim_cond_msg'></span>

<h3>Description</h3>

<p>This function returns a formatted string describing when, where,
and why an error, message, or warning occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netsim_cond_msg(cond, module, at, msg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netsim_cond_msg_+3A_cond">cond</code></td>
<td>
<p>The type of <code>condition</code> handled (message, warning, error).</p>
</td></tr>
<tr><td><code id="netsim_cond_msg_+3A_module">module</code></td>
<td>
<p>The name of the module where the <code>condition</code> occurred.</p>
</td></tr>
<tr><td><code id="netsim_cond_msg_+3A_at">at</code></td>
<td>
<p>The time step the <code>condition</code> occurred.</p>
</td></tr>
<tr><td><code id="netsim_cond_msg_+3A_msg">msg</code></td>
<td>
<p>The <code>condition</code>'s message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string describing where and when the <code>condition</code>
occurred as well as the <code>condition</code>'s message.
</p>

<hr>
<h2 id='netsim_error_logger'>Handle the Logging of Traceback and Dumping of Frames on Error</h2><span id='topic+netsim_error_logger'></span>

<h3>Description</h3>

<p>If <code>control$.traceback.on.error == TRUE</code>, this function prints the traceback
of the current simulation to STDIN. This is useful when <code>ncores &gt; 1</code> or in
HPC settings.
If <code>control$.dump.frames.on.error == TRUE</code>, this function saves a debugging
dump for &quot;postmortem debugging&quot;. The dumps are named
&quot;dump_%Y%m%d_%H%M%S_s.rda&quot; and stored at the root of the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netsim_error_logger(dat, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netsim_error_logger_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="netsim_error_logger_+3A_s">s</code></td>
<td>
<p>The number of the simulation that failed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, after logging and dumping frames, the function gives the
control back to the general error handler
</p>

<hr>
<h2 id='network_initialize'>Initialize Network Object</h2><span id='topic+network_initialize'></span>

<h3>Description</h3>

<p>Initialize an undirected network object for use in EpiModel
workflows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_initialize(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_initialize_+3A_n">n</code></td>
<td>
<p>Network size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in <code>EpiModel</code> workflows to initialize an empty
network object.  The network attributes <code>directed</code>, <code>bipartite</code>,
<code>hyper</code>, <code>loops</code>, and <code>multiple</code> are set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>network</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- network_initialize(100)
nw

</code></pre>

<hr>
<h2 id='nwupdate.net'>Dynamic Network Updates</h2><span id='topic+nwupdate.net'></span>

<h3>Description</h3>

<p>This function handles all calls to the network object contained
on the main <code>netsim_dat</code> object handled in <code>netsim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nwupdate.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nwupdate.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="nwupdate.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='padded_vector'>Grow a Vector to a Given Size, Padding it With Empty Elements</h2><span id='topic+padded_vector'></span>

<h3>Description</h3>

<p>Grow a vector to a given size, padding it with  <code>NULL</code> if <code>orig</code> is a <code>list</code>
and with <code>NA</code> otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padded_vector(orig, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padded_vector_+3A_orig">orig</code></td>
<td>
<p>A vector to grow.</p>
</td></tr>
<tr><td><code id="padded_vector_+3A_size">size</code></td>
<td>
<p>The final size of the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>size</code> padded with <code>NULL</code>s or <code>NA</code>s at the end.
</p>

<hr>
<h2 id='param_random'>Create a Value Sampler for Random Parameters</h2><span id='topic+param_random'></span>

<h3>Description</h3>

<p>This function returns a 0 argument function that can be used as
a generator function in the <code>random.params</code> argument of the
<code><a href="#topic+param.net">param.net</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_random(values, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_random_+3A_values">values</code></td>
<td>
<p>A vector of values to sample from.</p>
</td></tr>
<tr><td><code id="param_random_+3A_prob">prob</code></td>
<td>
<p>A vector of weights to use during sampling. If <code>NULL</code>,
all values have the same probability of being picked
(default = <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 0 argument generator function to sample one of the values from the
<code>values</code> vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param.net">param.net</a></code> and <code><a href="#topic+generate_random_params">generate_random_params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define function with equal sampling probability
a &lt;- param_random(1:5)
a()

# Define function with unequal sampling probability
b &lt;- param_random(1:5, prob = c(0.1, 0.1, 0.1, 0.1, 0.6))
b()

</code></pre>

<hr>
<h2 id='param.dcm'>Epidemic Parameters for Deterministic Compartmental Models</h2><span id='topic+param.dcm'></span>

<h3>Description</h3>

<p>Sets the epidemic parameters for deterministic compartmental
models simulated with <code>dcm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.dcm(
  inf.prob,
  inter.eff,
  inter.start,
  act.rate,
  rec.rate,
  a.rate,
  ds.rate,
  di.rate,
  dr.rate,
  inf.prob.g2,
  act.rate.g2,
  rec.rate.g2,
  a.rate.g2,
  ds.rate.g2,
  di.rate.g2,
  dr.rate.g2,
  balance,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.dcm_+3A_inf.prob">inf.prob</code></td>
<td>
<p>Probability of infection per transmissible act between
a susceptible and an infected person. In two-group models, this is the
probability of infection for the group 1 members.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_inter.eff">inter.eff</code></td>
<td>
<p>Efficacy of an intervention which affects the per-act
probability of infection. Efficacy is defined as 1 - the relative
hazard of infection given exposure to the intervention, compared to no
exposure.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_inter.start">inter.start</code></td>
<td>
<p>Time step at which the intervention starts, between 1 and
the number of time steps specified in the model. This will default to
1 if <code>inter.eff</code> is defined but this parameter is not.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_act.rate">act.rate</code></td>
<td>
<p>Average number of transmissible acts per person per unit
time. For two-group models, this is the number of acts per group 1
person per unit time; a balance between the acts in groups 1 and 2 is
necessary, and set using the <code>balance</code> parameter (see details).</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_rec.rate">rec.rate</code></td>
<td>
<p>Average rate of recovery with immunity (in <code>SIR</code> models)
or re-susceptibility (in <code>SIS</code> models). The recovery rate is the
reciprocal of the disease duration. For two-group models, this is the
recovery rate for group 1 persons only. This parameter is only used
for <code>SIR</code> and <code>SIS</code> models.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_a.rate">a.rate</code></td>
<td>
<p>Arrival or entry rate. For one-group models, the arrival rate
is the rate of new arrivals per person per unit time. For two-group
models, the arrival rate is parameterized as a rate per group 1
person per unit time, with the <code>a.rate.g2</code> rate set as described
below.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_ds.rate">ds.rate</code></td>
<td>
<p>Departure or exit rate for susceptible persons. For two-group
models, it is the rate for the group 1 susceptible persons only.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_di.rate">di.rate</code></td>
<td>
<p>Departure or exit rate for infected persons. For two-group
models, it is the rate for the group 1 infected persons only.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_dr.rate">dr.rate</code></td>
<td>
<p>Departure or exit rate for recovered persons. For two-group
models, it is the rate for the group 1 recovered persons only. This
parameter is only used for <code>SIR</code> models.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_inf.prob.g2">inf.prob.g2</code></td>
<td>
<p>Probability of infection per transmissible act
between a susceptible group 2 person and an infected group 1 person.
It is the probability of infection to group 2 members.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_act.rate.g2">act.rate.g2</code></td>
<td>
<p>Average number of transmissible acts per group 2 person
per unit time; a balance between the acts in groups 1 and 2 is
necessary, and set using the <code>balance</code> parameter (see details).</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_rec.rate.g2">rec.rate.g2</code></td>
<td>
<p>Average rate of recovery with immunity (in <code>SIR</code>
models) or re-susceptibility (in <code>SIS</code> models) for group 2
persons. This parameter is only used for two-group <code>SIR</code> and
<code>SIS</code> models.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_a.rate.g2">a.rate.g2</code></td>
<td>
<p>Arrival or entry rate for group 2. This may either be
specified numerically as the rate of new arrivals per group 2 persons
per unit time, or as <code>NA</code> in which case the group 1 rate,
<code>a.rate</code>, governs the group 2 rate. The latter is used when,
for example, the first group is conceptualized as female, and the
female population size determines the arrival rate. Such arrivals are
evenly allocated between the two groups.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_ds.rate.g2">ds.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 susceptible persons.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_di.rate.g2">di.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 infected persons.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_dr.rate.g2">dr.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 recovered persons. This
parameter is only used for <code>SIR</code> model types.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_balance">balance</code></td>
<td>
<p>For two-group models, balance the <code>act.rate</code> to the rate
set for group 1 (with <code>balance="g1"</code>) or group 2 (with
<code>balance="g2"</code>). See details.</p>
</td></tr>
<tr><td><code id="param.dcm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>param.dcm</code> sets the epidemic parameters for deterministic compartmental
models solved with the <code><a href="#topic+dcm">dcm</a></code> function. The models may use the
base types, for which these parameters are used, or original model
specifications for which these parameters may be used (but not necessarily).
A detailed description of DCM parameterization for base models is found
in the <a href="http://www.epimodel.org/tut.html">Basic DCMs</a> tutorial.
</p>
<p>For base models, the model specification will be selected as a function
of the model parameters entered here and the control settings in
<code><a href="#topic+control.dcm">control.dcm</a></code>. One-group and two-group models are available,
where the former assumes a homogeneous mixing in the population and the
latter assumes some form of heterogeneous mixing between two distinct
partitions in the population (e.g., men and women). Specifying any group two
parameters (those with a <code>.g2</code>) implies the simulation of a two-group
model. All the parameters for a desired model type must be specified, even if
they are zero.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code>param.dcm</code>.
</p>


<h3>Act Balancing</h3>

<p>In two-group models, a balance between the number of acts for group 1 members
and those for group 2 members must be maintained. With purely heterogeneous
mixing, the product of one group size and act rate must equal the product of
the other group size and act rate: <code class="reqn">N_1 \alpha_1 = N_2 \alpha_2</code>, where
<code class="reqn">N_i</code> is the group size and <code class="reqn">\alpha_i</code> the group-specific act rate
at time <code class="reqn">t</code>. The <code>balance</code> parameter here specifies which group's
act rate should control the others with respect to balancing. See the
<a href="http://www.epimodel.org/tut.html">Basic DCMs</a> tutorial for further
details.
</p>


<h3>Sensitivity Analyses</h3>

<p><code>dcm</code> has been designed to easily run DCM sensitivity analyses, where a
series of models varying one or more of the model parameters is run. This is
possible by setting any parameter as a vector of length greater than one. See
the <a href="http://www.epimodel.org/tut.html">Basic DCMs</a> tutorial.
</p>


<h3>New Model Types</h3>

<p>To build original model specifications outside of the base models, start
by consulting the <a href="http://www.epimodel.org/tut.html">New DCMs with
EpiModel</a> tutorial. Briefly, an original model may use either the existing
model parameters named here, an original set of parameters, or a combination
of both. The <code>...</code> argument allows the user to pass an arbitrary set of
new model parameters into <code>param.dcm</code>. Whereas there are strict checks
for base models that the model parameters are valid, parameter validity is
the user's responsibility with these original models.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+init.dcm">init.dcm</a></code> to specify the initial conditions and
<code><a href="#topic+control.dcm">control.dcm</a></code> to specify the control settings. Run the
parameterized model with <code><a href="#topic+dcm">dcm</a></code>.
</p>

<hr>
<h2 id='param.icm'>Epidemic Parameters for Stochastic Individual Contact Models</h2><span id='topic+param.icm'></span>

<h3>Description</h3>

<p>Sets the epidemic parameters for stochastic individual contact
models simulated with <code>icm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.icm(
  inf.prob,
  inter.eff,
  inter.start,
  act.rate,
  rec.rate,
  a.rate,
  ds.rate,
  di.rate,
  dr.rate,
  inf.prob.g2,
  act.rate.g2,
  rec.rate.g2,
  a.rate.g2,
  ds.rate.g2,
  di.rate.g2,
  dr.rate.g2,
  balance,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.icm_+3A_inf.prob">inf.prob</code></td>
<td>
<p>Probability of infection per transmissible act between
a susceptible and an infected person. In two-group models, this is the
probability of infection for the group 1 members.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_inter.eff">inter.eff</code></td>
<td>
<p>Efficacy of an intervention which affects the per-act
probability of infection. Efficacy is defined as 1 - the relative
hazard of infection given exposure to the intervention, compared to no
exposure.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_inter.start">inter.start</code></td>
<td>
<p>Time step at which the intervention starts, between 1 and
the number of time steps specified in the model. This will default to
1 if <code>inter.eff</code> is defined but this parameter is not.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_act.rate">act.rate</code></td>
<td>
<p>Average number of transmissible acts per person per unit
time. For two-group models, this is the number of acts per group 1
person per unit time; a balance between the acts in groups 1 and 2 is
necessary, and set using the <code>balance</code> parameter (see details).</p>
</td></tr>
<tr><td><code id="param.icm_+3A_rec.rate">rec.rate</code></td>
<td>
<p>Average rate of recovery with immunity (in <code>SIR</code> models)
or re-susceptibility (in <code>SIS</code> models). The recovery rate is the
reciprocal of the disease duration. For two-group models, this is the
recovery rate for group 1 persons only. This parameter is only used
for <code>SIR</code> and <code>SIS</code> models.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_a.rate">a.rate</code></td>
<td>
<p>Arrival or entry rate. For one-group models, the arrival rate
is the rate of new arrivals per person per unit time. For two-group
models, the arrival rate is parameterized as a rate per group 1
person per unit time, with the <code>a.rate.g2</code> rate set as described
below.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_ds.rate">ds.rate</code></td>
<td>
<p>Departure or exit rate for susceptible persons. For two-group
models, it is the rate for the group 1 susceptible persons only.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_di.rate">di.rate</code></td>
<td>
<p>Departure or exit rate for infected persons. For two-group
models, it is the rate for the group 1 infected persons only.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_dr.rate">dr.rate</code></td>
<td>
<p>Departure or exit rate for recovered persons. For two-group
models, it is the rate for the group 1 recovered persons only. This
parameter is only used for <code>SIR</code> models.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_inf.prob.g2">inf.prob.g2</code></td>
<td>
<p>Probability of infection per transmissible act
between a susceptible group 2 person and an infected group 1 person.
It is the probability of infection to group 2 members.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_act.rate.g2">act.rate.g2</code></td>
<td>
<p>Average number of transmissible acts per group 2 person
per unit time; a balance between the acts in groups 1 and 2 is
necessary, and set using the <code>balance</code> parameter (see details).</p>
</td></tr>
<tr><td><code id="param.icm_+3A_rec.rate.g2">rec.rate.g2</code></td>
<td>
<p>Average rate of recovery with immunity (in <code>SIR</code>
models) or re-susceptibility (in <code>SIS</code> models) for group 2
persons. This parameter is only used for two-group <code>SIR</code> and
<code>SIS</code> models.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_a.rate.g2">a.rate.g2</code></td>
<td>
<p>Arrival or entry rate for group 2. This may either be
specified numerically as the rate of new arrivals per group 2 persons
per unit time, or as <code>NA</code> in which case the group 1 rate,
<code>a.rate</code>, governs the group 2 rate. The latter is used when,
for example, the first group is conceptualized as female, and the
female population size determines the arrival rate. Such arrivals are
evenly allocated between the two groups.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_ds.rate.g2">ds.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 susceptible persons.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_di.rate.g2">di.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 infected persons.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_dr.rate.g2">dr.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 recovered persons. This
parameter is only used for <code>SIR</code> model types.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_balance">balance</code></td>
<td>
<p>For two-group models, balance the <code>act.rate</code> to the rate
set for group 1 (with <code>balance="g1"</code>) or group 2 (with
<code>balance="g2"</code>). See details.</p>
</td></tr>
<tr><td><code id="param.icm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>param.icm</code> sets the epidemic parameters for the stochastic individual
contact models simulated with the <code><a href="#topic+icm">icm</a></code> function. Models
may use the base types, for which these parameters are used, or new process
modules which may use these parameters (but not necessarily). A detailed
description of ICM parameterization for base models is found in the
<a href="http://www.epimodel.org/tut.html">Basic ICMs</a> tutorial.
</p>
<p>For base models, the model specification will be chosen as a result of
the model parameters entered here and the control settings in
<code><a href="#topic+control.icm">control.icm</a></code>. One-group and two-group models are available,
where the former assumes a homogeneous mixing in the population and the
latter assumes some form of heterogeneous mixing between two distinct
partitions in the population (e.g., men and women). Specifying any group two
parameters (those with a <code>.g2</code>) implies the simulation of a two-group
model. All the parameters for a desired model type must be specified, even if
they are zero.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code>param.icm</code>.
</p>


<h3>Act Balancing</h3>

<p>In two-group models, a balance between the number of acts for group 1 members
and those for group 2 members must be maintained. With purely heterogeneous
mixing, the product of one group size and act rate must equal the product of
the other group size and act rate: <code class="reqn">N_1 \alpha_1 = N_2 \alpha_2</code>, where
<code class="reqn">N_i</code> is the group size and <code class="reqn">\alpha_i</code> the group-specific act rate
at time <code class="reqn">t</code>. The <code>balance</code> parameter here specifies which group's
act rate should control the others with respect to balancing. See the
<a href="http://www.epimodel.org/tut.html">Basic ICMs</a> tutorial.
</p>


<h3>New Modules</h3>

<p>To build original models outside of the base models, new process modules
may be constructed to replace the existing modules or to supplement the
existing set. These are passed into the control settings in
<code><a href="#topic+control.icm">control.icm</a></code>. New modules may use either the existing model
parameters named here, an original set of parameters, or a combination of
both. The <code>...</code> allows the user to pass an arbitrary set of original
model parameters into <code>param.icm</code>. Whereas there are strict checks with
default modules for parameter validity, these checks are the user's
responsibility with new modules.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+init.icm">init.icm</a></code> to specify the initial conditions and
<code><a href="#topic+control.icm">control.icm</a></code> to specify the control settings. Run the
parameterized model with <code><a href="#topic+icm">icm</a></code>.
</p>

<hr>
<h2 id='param.net'>Epidemic Parameters for Stochastic Network Models</h2><span id='topic+param.net'></span>

<h3>Description</h3>

<p>Sets the epidemic parameters for stochastic network models
simulated with <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.net(
  inf.prob,
  inter.eff,
  inter.start,
  act.rate,
  rec.rate,
  a.rate,
  ds.rate,
  di.rate,
  dr.rate,
  inf.prob.g2,
  rec.rate.g2,
  a.rate.g2,
  ds.rate.g2,
  di.rate.g2,
  dr.rate.g2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.net_+3A_inf.prob">inf.prob</code></td>
<td>
<p>Probability of infection per transmissible act between
a susceptible and an infected person. In two-group models, this is the
probability of infection to the group 1 nodes. This may also be a
vector of probabilities, with each element corresponding to the
probability in that time step of infection (see Time-Varying
Parameters below).</p>
</td></tr>
<tr><td><code id="param.net_+3A_inter.eff">inter.eff</code></td>
<td>
<p>Efficacy of an intervention which affects the per-act
probability of infection. Efficacy is defined as 1 - the relative
hazard of infection given exposure to the intervention, compared to no
exposure.</p>
</td></tr>
<tr><td><code id="param.net_+3A_inter.start">inter.start</code></td>
<td>
<p>Time step at which the intervention starts, between 1 and
the number of time steps specified in the model. This will default to
1 if <code>inter.eff</code> is defined but this parameter is not.</p>
</td></tr>
<tr><td><code id="param.net_+3A_act.rate">act.rate</code></td>
<td>
<p>Average number of transmissible acts <em>per partnership</em>
per unit time (see <code>act.rate</code> Parameter below). This may also be
a vector of rates, with each element corresponding to the rate in
that time step of infection (see Time-Varying Parameters below).</p>
</td></tr>
<tr><td><code id="param.net_+3A_rec.rate">rec.rate</code></td>
<td>
<p>Average rate of recovery with immunity (in <code>SIR</code> models)
or re-susceptibility (in <code>SIS</code> models). The recovery rate is the
reciprocal of the disease duration. For two-group models, this is the
recovery rate for group 1 persons only. This parameter is only used
for <code>SIR</code> and <code>SIS</code> models. This may also be a vector
of rates, with each element corresponding to the rate in that time
step of infection (see Time-Varying Parameters below).</p>
</td></tr>
<tr><td><code id="param.net_+3A_a.rate">a.rate</code></td>
<td>
<p>Arrival or entry rate. For one-group models, the arrival rate
is the rate of new arrivals per person per unit time. For two-group
models, the arrival rate is parameterized as a rate per group 1
person per unit time, with the <code>a.rate.g2</code> rate set as described
below.</p>
</td></tr>
<tr><td><code id="param.net_+3A_ds.rate">ds.rate</code></td>
<td>
<p>Departure or exit rate for susceptible persons. For two-group
models, it is the rate for group 1 susceptible persons only.</p>
</td></tr>
<tr><td><code id="param.net_+3A_di.rate">di.rate</code></td>
<td>
<p>Departure or exit rate for infected persons. For two-group
models, it is the rate for group 1 infected persons only.</p>
</td></tr>
<tr><td><code id="param.net_+3A_dr.rate">dr.rate</code></td>
<td>
<p>Departure or exit rate for recovered persons. For two-group
models, it is the rate for group 1 recovered persons only. This
parameter is only used for <code>SIR</code> models.</p>
</td></tr>
<tr><td><code id="param.net_+3A_inf.prob.g2">inf.prob.g2</code></td>
<td>
<p>Probability of transmission given a transmissible act
between a susceptible group 2 person and an infected group 1 person.
It is the probability of transmission to group 2 members.</p>
</td></tr>
<tr><td><code id="param.net_+3A_rec.rate.g2">rec.rate.g2</code></td>
<td>
<p>Average rate of recovery with immunity (in <code>SIR</code>
models) or re-susceptibility (in <code>SIS</code> models) for group 2
persons. This parameter is only used for two-group <code>SIR</code> and
<code>SIS</code> models.</p>
</td></tr>
<tr><td><code id="param.net_+3A_a.rate.g2">a.rate.g2</code></td>
<td>
<p>Arrival or entry rate for group 2. This may either be
specified numerically as the rate of new arrivals per group 2 person
per unit time, or as <code>NA</code>, in which case the group 1 rate,
<code>a.rate</code>, governs the group 2 rate. The latter is used when, for
example, the first group is conceptualized as female, and the female
population size determines the arrival rate. Such arrivals are evenly
allocated between the two groups.</p>
</td></tr>
<tr><td><code id="param.net_+3A_ds.rate.g2">ds.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 susceptible persons.</p>
</td></tr>
<tr><td><code id="param.net_+3A_di.rate.g2">di.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 infected persons.</p>
</td></tr>
<tr><td><code id="param.net_+3A_dr.rate.g2">dr.rate.g2</code></td>
<td>
<p>Departure or exit rate for group 2 recovered persons. This
parameter is only used for <code>SIR</code> model types.</p>
</td></tr>
<tr><td><code id="param.net_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>param.net</code> sets the epidemic parameters for the stochastic network
models simulated with the <code><a href="#topic+netsim">netsim</a></code> function. Models
may use the base types, for which these parameters are used, or new process
modules which may use these parameters (but not necessarily). A detailed
description of network model parameterization for base models is found in
the <a href="http://www.epimodel.org/tut.html">Basic Network Models</a> tutorial.
</p>
<p>For base models, the model specification will be chosen as a result of
the model parameters entered here and the control settings in
<code><a href="#topic+control.net">control.net</a></code>. One-group and two-group models are available,
where the latter assumes a heterogeneous mixing between two distinct
partitions in the population (e.g., men and women). Specifying any two-group
parameters (those with a <code>.g2</code>) implies the simulation of a two-group
model. All the parameters for a desired model type must be specified, even if
they are zero.
</p>


<h3>Value</h3>

<p>An <code>EpiModel</code> object of class <code>param.net</code>.
</p>


<h3>The <code>act.rate</code> Parameter</h3>

<p>A key difference between these network models and DCM/ICM classes is the
treatment of transmission events. With DCM and ICM, contacts or partnerships
are mathematically instantaneous events: they have no duration in time, and
thus no changes may occur within them over time. In contrast, network models
allow for partnership durations defined by the dynamic network model,
summarized in the model dissolution coefficients calculated in
<code><a href="#topic+dissolution_coefs">dissolution_coefs</a></code>. Therefore, the <code>act.rate</code> parameter has
a different interpretation here, where it is the number of transmissible acts
<em>per partnership</em> per unit time.
</p>


<h3>Time-Varying Parameters</h3>

<p>The <code>inf.prob</code>, <code>act.rate</code>, <code>rec.rate</code> arguments (and their
<code>.g2</code> companions) may be specified as time-varying parameters by passing
in a vector of probabilities or rates, respectively. The value in each
position on the vector then corresponds to the probability or rate at that
discrete time step for the infected partner. For example, an <code>inf.prob</code>
of <code>c(0.5, 0.5, 0.1)</code> would simulate a 0.5 transmission probability for
the first two time steps of a person's infection, followed by a 0.1 for the
third time step. If the infected person has not recovered or exited the
population by the fourth time step, the third element in the vector will
carry forward until one of those events occurs or the simulation ends. For
further examples, see the <a href="https://statnet.org/nme/">NME Course
Tutorials</a>.
</p>


<h3>Random Parameters</h3>

<p>In addition to deterministic parameters in either fixed or time-varying
varieties above, one may also include a generator for random parameters.
These might include a vector of potential parameter values or a statistical
distribution definition; in either case, one draw from the generator would
be completed per individual simulation. This is possible by passing a list
named <code>random.params</code> into <code>param.net</code>, with each element of
<code>random.params</code> a named generator function. See the help page and
examples in <code><a href="#topic+generate_random_params">generate_random_params</a></code>. A simple factory function
for sampling is provided with <code><a href="#topic+param_random">param_random</a></code> but any function
will do.
</p>


<h3>Using a Parameter data.frame</h3>

<p>It is possible to set input parameters using a specifically formatted
<code>data.frame</code> object. The first 3 columns of this <code>data.frame</code> must
be:
</p>

<ul>
<li> <p><code>param</code>: The name of the parameter. If this is a non-scalar
parameter (a vector of length &gt; 1), end the parameter name with the
position on the vector (e.g., <code>"p_1"</code>, <code>"p_2"</code>, ...).
</p>
</li>
<li> <p><code>value</code>: the value for the parameter (or the value of the
parameter in the Nth position if non-scalar).
</p>
</li>
<li> <p><code>type</code>: a character string containing either <code>"numeric"</code>,
<code>"logical"</code>, or <code>"character"</code> to define the parameter object
class.
</p>
</li></ul>

<p>In addition to these 3 columns, the <code>data.frame</code> can contain any number
of other columns, such as <code>details</code> or <code>source</code> columns to document
parameter meta-data. However, these extra columns will not be used by
EpiModel.
</p>
<p>This data.frame is then passed in to <code>param.net</code> under a
<code>data.frame.parameters</code> argument. Further details and examples are
provided in the &quot;Working with Model Parameters in EpiModel&quot; vignette.
</p>


<h3>Parameters with New Modules</h3>

<p>To build original models outside of the base models, new process modules
may be constructed to replace the existing modules or to supplement the
existing set. These are passed into the control settings in
<code><a href="#topic+control.net">control.net</a></code>. New modules may use either the existing model
parameters named here, an original set of parameters, or a combination of
both. The <code>...</code> allows the user to pass an arbitrary set of original
model parameters into <code>param.net</code>. Whereas there are strict checks with
default modules for parameter validity, this becomes a user
responsibility when using new modules.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+init.net">init.net</a></code> to specify the initial conditions and
<code><a href="#topic+control.net">control.net</a></code> to specify the control settings. Run the
parameterized model with <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example SIR model parameterization with fixed and random parameters
# Network model estimation
nw &lt;- network_initialize(n = 100)
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Random epidemic parameter list (here act.rate values are sampled uniformly
# with helper function param_random, and inf.prob follows a general Beta
# distribution with the parameters shown below)
my_randoms &lt;- list(
  act.rate = param_random(1:3),
  inf.prob = function() rbeta(1, 1, 2)
)

# Parameters, initial conditions, and control settings
param &lt;- param.net(rec.rate = 0.02, random.params = my_randoms)

# Printing parameters shows both fixed and and random parameter functions
param

# Set initial conditions and controls
init &lt;- init.net(i.num = 10, r.num = 0)
control &lt;- control.net(type = "SIR", nsteps = 10, nsims = 3, verbose = FALSE)

# Simulate the model
sim &lt;- netsim(est, param, init, control)

# Printing the sim object shows the randomly drawn values for each simulation
sim

# Parameter sets can be extracted with:
get_param_set(sim)

</code></pre>

<hr>
<h2 id='param.net_from_table'>Parameters List for Stochastic Network Models from a Formatted
Data Frame</h2><span id='topic+param.net_from_table'></span>

<h3>Description</h3>

<p>Sets the epidemic parameters for stochastic network models with
<code><a href="#topic+netsim">netsim</a></code> using a specially formatted data frame of
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.net_from_table(long.param.df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.net_from_table_+3A_long.param.df">long.param.df</code></td>
<td>
<p>A <code>data.frame</code> of parameters. See details for the
expected format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to set input parameters using a specifically formatted
<code>data.frame</code> object. The first 3 columns of this <code>data.frame</code> must
be:
</p>

<ul>
<li> <p><code>param</code>: The name of the parameter. If this is a non-scalar
parameter (a vector of length &gt; 1), end the parameter name with the
position on the vector (e.g., <code>"p_1"</code>, <code>"p_2"</code>, ...).
</p>
</li>
<li> <p><code>value</code>: the value for the parameter (or the value of the
parameter in the Nth position if non-scalar).
</p>
</li>
<li> <p><code>type</code>: a character string containing either <code>"numeric"</code>,
<code>"logical"</code>, or <code>"character"</code> to define the parameter object
class.
</p>
</li></ul>

<p>In addition to these 3 columns, the <code>data.frame</code> can contain any number
of other columns, such as <code>details</code> or <code>source</code> columns to document
parameter meta-data. However, these extra columns will not be used by
EpiModel.
</p>


<h3>Value</h3>

<p>A list object of class <code>param.net</code>, which can be passed to
<code><a href="#topic+netsim">netsim</a></code>.
</p>

<hr>
<h2 id='plot.dcm'>Plot Data from a Deterministic Compartmental Epidemic Model</h2><span id='topic+plot.dcm'></span>

<h3>Description</h3>

<p>Plots epidemiological data from a deterministic compartment
epidemic model solved with <code><a href="#topic+dcm">dcm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcm'
plot(
  x,
  y,
  popfrac = FALSE,
  run,
  col,
  lwd,
  lty,
  alpha = 0.9,
  legend,
  leg.name,
  leg.cex = 0.8,
  axs = "r",
  grid = FALSE,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dcm_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>dcm</code>.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_y">y</code></td>
<td>
<p>Output compartments or flows from <code>dcm</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_popfrac">popfrac</code></td>
<td>
<p>If <code>TRUE</code>, plot prevalence of values rather than numbers
(see details).</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_run">run</code></td>
<td>
<p>Run number to plot, for models with multiple runs
(default is run 1).</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_col">col</code></td>
<td>
<p>Color for lines, either specified as a single color in a standard
R color format, or alternatively as a color palette from
<code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code> (see details).</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_lwd">lwd</code></td>
<td>
<p>Line width for output lines.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_lty">lty</code></td>
<td>
<p>Line type for output lines.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_alpha">alpha</code></td>
<td>
<p>Transparency level for lines, where 0 = transparent and
1 = opaque (see <code>adjustcolor</code> function).</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_legend">legend</code></td>
<td>
<p>Type of legend to plot. Values are <code>"n"</code> for no legend,
<code>"full"</code> for full legend, and <code>"lim"</code> for limited legend
(see details).</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_leg.name">leg.name</code></td>
<td>
<p>Character string to use for legend, with the default
determined automatically based on the <code>y</code> input.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_leg.cex">leg.cex</code></td>
<td>
<p>Legend scale size.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_axs">axs</code></td>
<td>
<p>Plot axis type (see <code><a href="graphics.html#topic+par">par</a></code> for details), with default
of &quot;r&quot;.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, a grid is added to the background of plot
(see <code><a href="graphics.html#topic+grid">grid</a></code> for details), with default of nx by ny.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, new plot window is not called and lines are added
to existing plot window.</p>
</td></tr>
<tr><td><code id="plot.dcm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to main plot window (see
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots epidemiological outcomes from a deterministic
compartmental model solved with <code><a href="#topic+dcm">dcm</a></code>. Depending on the number of
model runs (sensitivity analyses) and number of groups, the default plot is
the fractional proportion of each compartment in the model over time. The
specific compartments or flows to plot may be set using the <code>y</code>
parameter, and in multiple run models the specific run may also be specified.
</p>


<h3>The <code>popfrac</code> Argument</h3>

<p>Compartment prevalence is the size of a compartment over some denominator.
To plot the raw numbers from any compartment, use <code>popfrac=FALSE</code>; this
is the default. The <code>popfrac</code> parameter calculates
and plots the denominators of all specified compartments using these rules:
</p>

<ol>
<li><p> for one-group models, the prevalence of any compartment is the compartment
size divided by the total population size; 2) for two-group models, the
prevalence of any compartment is the compartment size divided by the group
size.
</p>
</li></ol>



<h3>Color Palettes</h3>

<p>Since <code><a href="#topic+dcm">dcm</a></code> supports multiple run sensitivity models, plotting
the results of such models uses a complex color scheme for distinguishing
runs. This is accomplished using the <code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code> color
palettes, which include a range of linked colors using named palettes. For
<code>plot.dcm</code>, one may either specify a brewer color palette listed in
<code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>, or, alternatively, a vector of standard R
colors (named, hexidecimal, or positive integers; see <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>).
</p>


<h3>Plot Legends</h3>

<p>There are three automatic legend types available, and the legend is
added by default for plots. To turn off the legend, use <code>legend="n"</code>. To
plot a legend with values for every line in a sensitivity analysis, use
<code>legend="full"</code>. With models with many runs, this may be visually
overwhelming. In those cases, use <code>legend="lim"</code> to plot a legend
limited to the highest and lowest values of the varying parameter in the
model. In cases where the default legend names are not helpful, one may
override those names with the <code>leg.name</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcm">dcm</a></code>, <code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Deterministic SIR model with varying act rate
param &lt;- param.dcm(inf.prob = 0.2, act.rate = 1:10,
                   rec.rate = 1/3, a.rate = 0.011, ds.rate = 0.01,
                   di.rate = 0.03, dr.rate = 0.01)
init &lt;- init.dcm(s.num = 1000, i.num = 1, r.num = 0)
control &lt;- control.dcm(type = "SIR", nsteps = 100, dt = 0.25)
mod &lt;- dcm(param, init, control)

# Plot disease prevalence by default
plot(mod)

# Plot prevalence of susceptibles
plot(mod, y = "s.num", popfrac = TRUE, col = "Greys")

# Plot number of susceptibles
plot(mod, y = "s.num", popfrac = FALSE, col = "Greys", grid = TRUE)

# Plot multiple runs of multiple compartments together
plot(mod, y = c("s.num", "i.num"),
     run = 5, xlim = c(0, 50), grid = TRUE)
plot(mod, y = c("s.num", "i.num"),
     run = 10, lty = 2, legend = "n", add = TRUE)

</code></pre>

<hr>
<h2 id='plot.icm'>Plot Data from a Stochastic Individual Contact Epidemic Model</h2><span id='topic+plot.icm'></span>

<h3>Description</h3>

<p>Plots epidemiological data from a stochastic individual contact
model simulated with <code><a href="#topic+icm">icm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icm'
plot(
  x,
  y,
  popfrac = FALSE,
  sim.lines = FALSE,
  sims,
  sim.col,
  sim.lwd,
  sim.alpha,
  mean.line = TRUE,
  mean.smooth = TRUE,
  mean.col,
  mean.lwd = 2,
  mean.lty = 1,
  qnts = 0.5,
  qnts.col,
  qnts.alpha,
  qnts.smooth = TRUE,
  legend,
  leg.cex = 0.8,
  axs = "r",
  grid = FALSE,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.icm_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> model object of class <code>icm</code>.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_y">y</code></td>
<td>
<p>Output compartments or flows from <code>icm</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_popfrac">popfrac</code></td>
<td>
<p>If <code>TRUE</code>, plot prevalence of values rather than numbers
(see details).</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_sim.lines">sim.lines</code></td>
<td>
<p>If <code>TRUE</code>, plot individual simulation lines. Default is
to plot lines for one-group models but not for two-group models.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_sims">sims</code></td>
<td>
<p>A vector of simulation numbers to plot.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_sim.col">sim.col</code></td>
<td>
<p>Vector of any standard R color format for simulation lines.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_sim.lwd">sim.lwd</code></td>
<td>
<p>Line width for simulation lines.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_sim.alpha">sim.alpha</code></td>
<td>
<p>Transparency level for simulation lines, where
0 = transparent and 1 = opaque (see <code>adjustcolor</code> function).</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_mean.line">mean.line</code></td>
<td>
<p>If <code>TRUE</code>, plot mean of simulations across time.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_mean.smooth">mean.smooth</code></td>
<td>
<p>If <code>TRUE</code>, use a loess smoother on the mean line.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_mean.col">mean.col</code></td>
<td>
<p>Vector of any standard R color format for mean lines.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_mean.lwd">mean.lwd</code></td>
<td>
<p>Line width for mean lines.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_mean.lty">mean.lty</code></td>
<td>
<p>Line type for mean lines.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_qnts">qnts</code></td>
<td>
<p>If numeric, plot polygon of simulation quantiles based on the
range implied by the argument (see details). If <code>FALSE</code>, suppress
polygon from plot.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_qnts.col">qnts.col</code></td>
<td>
<p>Vector of any standard R color format for polygons.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_qnts.alpha">qnts.alpha</code></td>
<td>
<p>Transparency level for quantile polygons, where 0 =
transparent and 1 = opaque (see <code>adjustcolor</code> function).</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_qnts.smooth">qnts.smooth</code></td>
<td>
<p>If <code>TRUE</code>, use a loess smoother on quantile polygons.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_legend">legend</code></td>
<td>
<p>If <code>TRUE</code>, plot default legend.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_leg.cex">leg.cex</code></td>
<td>
<p>Legend scale size.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_axs">axs</code></td>
<td>
<p>Plot axis type (see <code><a href="graphics.html#topic+par">par</a></code> for details), with default
of <code>"r"</code>.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, a grid is added to the background of plot
(see <code><a href="graphics.html#topic+grid">grid</a></code> for details), with default of nx by ny.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, new plot window is not called and lines are added
to existing plot window.</p>
</td></tr>
<tr><td><code id="plot.icm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plotting function will extract the epidemiological output from a model
object of class <code>icm</code> and plot the time series data of disease
prevalence and other results. The summary statistics that the function
calculates and plots are individual simulation lines, means of the individual
simulation lines, and quantiles of those individual simulation lines. The
mean line, toggled on with <code>mean.line=TRUE</code>, is calculated as the row
mean across simulations at each time step.
</p>
<p>Compartment prevalences are the size of a compartment over some denominator.
To plot the raw numbers from any compartment, use <code>popfrac=FALSE</code>; this
is the default for any plots of flows. The <code>popfrac</code> parameter
calculates and plots the denominators of all specified compartments using
these rules: 1) for one-group models, the prevalence of any compartment is
the compartment size divided by the total population size; 2) for two-group
models, the prevalence of any compartment is the compartment size divided by
the group population size. For any prevalences that are not automatically
calculated, the <code><a href="#topic+mutate_epi">mutate_epi</a></code> function may be used to add new
variables to the <code>icm</code> object to plot or analyze.
</p>
<p>The quantiles show the range of outcome values within a certain specified
quantile range. By default, the interquartile range is shown: that is the
middle 50\
middle 95\
where they are plotted by default, specify <code>qnts=FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icm">icm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Plotting multiple compartment values from SIR model
param &lt;- param.icm(inf.prob = 0.5, act.rate = 0.5, rec.rate = 0.02)
init &lt;- init.icm(s.num = 500, i.num = 1, r.num = 0)
control &lt;- control.icm(type = "SIR", nsteps = 100,
                       nsims = 3, verbose = FALSE)
mod &lt;- icm(param, init, control)
plot(mod, grid = TRUE)

## Example 2: Plot only infected with specific output from SI model
param &lt;- param.icm(inf.prob = 0.25, act.rate = 0.25)
init &lt;- init.icm(s.num = 500, i.num = 10)
control &lt;- control.icm(type = "SI", nsteps = 100,
                       nsims = 3, verbose = FALSE)
mod2 &lt;- icm(param, init, control)

# Plot prevalence
plot(mod2, y = "i.num", mean.line = FALSE, sim.lines = TRUE)

# Plot incidence
par(mfrow = c(1, 2))
plot(mod2, y = "si.flow", mean.smooth = TRUE, grid = TRUE)
plot(mod2, y = "si.flow", qnts.smooth = FALSE, qnts = 1)

</code></pre>

<hr>
<h2 id='plot.netdx'>Plot Dynamic Network Model Diagnostics</h2><span id='topic+plot.netdx'></span>

<h3>Description</h3>

<p>Plots dynamic network model diagnostics calculated in
<code><a href="#topic+netdx">netdx</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netdx'
plot(
  x,
  type = "formation",
  method = "l",
  sims,
  stats,
  duration.imputed = TRUE,
  sim.lines = FALSE,
  sim.col,
  sim.lwd,
  mean.line = TRUE,
  mean.smooth = TRUE,
  mean.col,
  mean.lwd = 2,
  mean.lty = 1,
  qnts = 0.5,
  qnts.col,
  qnts.alpha = 0.5,
  qnts.smooth = TRUE,
  targ.line = TRUE,
  targ.col,
  targ.lwd = 2,
  targ.lty = 2,
  plots.joined,
  legend,
  grid = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.netdx_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>netdx</code>.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_type">type</code></td>
<td>
<p>Plot type, with options of <code>"formation"</code> for network
model formation statistics, <code>"duration"</code> for dissolution model
statistics for average edge duration, or <code>"dissolution"</code> for
dissolution model statistics for proportion of ties dissolved per time
step.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_method">method</code></td>
<td>
<p>Plot method, with options of <code>"l"</code> for line plots and
<code>"b"</code> for box plots.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_sims">sims</code></td>
<td>
<p>A vector of simulation numbers to plot.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_stats">stats</code></td>
<td>
<p>Statistics to plot. For <code>type = "formation"</code>, <code>stats</code>
are among those specified in the call to <code><a href="#topic+netdx">netdx</a></code>;
for <code>type = "duration", "dissolution"</code>, <code>stats</code> are among
those of the dissolution model (without <code>offset()</code>). The default
is to plot all statistics.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_duration.imputed">duration.imputed</code></td>
<td>
<p>If <code>type = "duration"</code>, a logical indicating
whether or not to impute starting times for relationships extant at
the start of the simulation. Defaults to <code>TRUE</code> when
<code>type = "duration"</code>.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_sim.lines">sim.lines</code></td>
<td>
<p>If <code>TRUE</code>, plot individual simulation lines. Default is
to plot lines for one-group models but not for two-group models.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_sim.col">sim.col</code></td>
<td>
<p>Vector of any standard R color format for simulation lines.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_sim.lwd">sim.lwd</code></td>
<td>
<p>Line width for simulation lines.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_mean.line">mean.line</code></td>
<td>
<p>If <code>TRUE</code>, plot mean of simulations across time.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_mean.smooth">mean.smooth</code></td>
<td>
<p>If <code>TRUE</code>, use a loess smoother on the mean line.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_mean.col">mean.col</code></td>
<td>
<p>Vector of any standard R color format for mean lines.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_mean.lwd">mean.lwd</code></td>
<td>
<p>Line width for mean lines.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_mean.lty">mean.lty</code></td>
<td>
<p>Line type for mean lines.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_qnts">qnts</code></td>
<td>
<p>If numeric, plot polygon of simulation quantiles based on the
range implied by the argument (see details). If <code>FALSE</code>, suppress
polygon from plot.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_qnts.col">qnts.col</code></td>
<td>
<p>Vector of any standard R color format for polygons.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_qnts.alpha">qnts.alpha</code></td>
<td>
<p>Transparency level for quantile polygons, where 0 =
transparent and 1 = opaque (see <code>adjustcolor</code> function).</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_qnts.smooth">qnts.smooth</code></td>
<td>
<p>If <code>TRUE</code>, use a loess smoother on quantile polygons.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_targ.line">targ.line</code></td>
<td>
<p>If <code>TRUE</code>, plot target or expected value line for
the statistic of interest.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_targ.col">targ.col</code></td>
<td>
<p>Vector of standard R colors for target statistic lines, with
default colors based on <code>RColorBrewer</code> color palettes.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_targ.lwd">targ.lwd</code></td>
<td>
<p>Line width for the line showing the target statistic values.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_targ.lty">targ.lty</code></td>
<td>
<p>Line type for the line showing the target statistic values.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_plots.joined">plots.joined</code></td>
<td>
<p>If <code>TRUE</code>, combine all statistics in one plot,
versus one plot per statistic if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_legend">legend</code></td>
<td>
<p>If <code>TRUE</code>, plot default legend.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, a grid is added to the background of plot
(see <code><a href="graphics.html#topic+grid">grid</a></code> for details), with default of nx by ny.</p>
</td></tr>
<tr><td><code id="plot.netdx_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot function for <code>netdx</code> objects will generate plots of two types
of model diagnostic statistics that run as part of the diagnostic tools
within that function. The <code>formation</code> plot shows the summary statistics
requested in <code>nwstats.formula</code>, where the default includes those
statistics in the network model formation formula specified in the original
call to <code><a href="#topic+netest">netest</a></code>.
</p>
<p>The <code>duration</code> plot shows the average age of existing edges at each time
step, up until the maximum time step requested. The age is used as an
estimator of the average duration of edges in the equilibrium state. When
<code>duration.imputed = FALSE</code>, edges that exist at the beginning of the
simulation are assumed to start with an age of 1, yielding a burn-in period
before the observed mean approaches its target.  When
<code>duration.imputed = TRUE</code>, expected ages prior to the start of the
simulation are calculated from the dissolution model, typically eliminating
the need for a burn-in period.
</p>
<p>The <code>dissolution</code> plot shows the proportion of the extant ties that are
dissolved at each time step, up until the maximum time step requested.
Typically, the proportion of ties that are dissolved is the reciprocal of the
mean relational duration. This plot thus contains similar information to that
in the duration plot, but should reach its expected value more quickly, since
it is not subject to censoring.
</p>
<p>The <code>plots.joined</code> argument will control whether the statistics
are joined in one plot or plotted separately, assuming there are multiple
statistics in the model. The default is based on the number of network
statistics requested. The layout of the separate plots within the larger plot
window is also based on the number of statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netdx">netdx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Network initialization and model parameterization
nw &lt;- network_initialize(n = 500)
nw &lt;- set_vertex_attribute(nw, "sex", rbinom(500, 1, 0.5))
formation &lt;- ~edges + nodematch("sex")
target.stats &lt;- c(500, 300)
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges) +
                  offset(nodematch("sex")), duration = c(50, 40))

# Estimate the model
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Static diagnostics
dx1 &lt;- netdx(est, nsims = 1e4, dynamic = FALSE,
             nwstats.formula = ~edges + meandeg + concurrent +
                                nodefactor("sex", levels = NULL) +
                                nodematch("sex"))
dx1

# Plot diagnostics
plot(dx1)
plot(dx1, stats = c("edges", "concurrent"), mean.col = "black",
     sim.lines = TRUE, plots.joined = FALSE)
plot(dx1, stats = "edges", method = "b",
     col = "seagreen3", grid = TRUE)

# Dynamic diagnostics
dx2 &lt;- netdx(est, nsims = 10, nsteps = 500,
             nwstats.formula = ~edges + meandeg + concurrent +
                                nodefactor("sex", levels = NULL) +
                                nodematch("sex"))
dx2

# Formation statistics plots, joined and separate
plot(dx2, grid = TRUE)
plot(dx2, type = "formation", plots.joined = TRUE)
plot(dx2, type = "formation", sims = 1, plots.joined = TRUE,
     qnts = FALSE, sim.lines = TRUE, mean.line = FALSE)
plot(dx2, type = "formation", plots.joined = FALSE,
     stats = c("edges", "concurrent"), grid = TRUE)

plot(dx2, method = "b", col = "bisque", grid = TRUE)
plot(dx2, method = "b", stats = "meandeg", col = "dodgerblue")

# Duration statistics plot
par(mfrow = c(1, 2))
# With duration imputed
plot(dx2, type = "duration", sim.line = TRUE, sim.lwd = 0.3,
     targ.lty = 1, targ.lwd = 0.5)
# Without duration imputed
plot(dx2, type = "duration", sim.line = TRUE, sim.lwd = 0.3,
     targ.lty = 1, targ.lwd = 0.5, duration.imputed = FALSE)

# Dissolution statistics plot
plot(dx2, type = "dissolution", qnts = 0.25, grid = TRUE)
plot(dx2, type = "dissolution", method = "b", col = "pink1")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.netsim'>Plot Data from a Stochastic Network Epidemic Model</h2><span id='topic+plot.netsim'></span>

<h3>Description</h3>

<p>Plots epidemiological and network data from a stochastic network
model simulated with <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netsim'
plot(
  x,
  type = "epi",
  y,
  popfrac = FALSE,
  sim.lines = FALSE,
  sims,
  sim.col,
  sim.lwd,
  sim.alpha,
  mean.line = TRUE,
  mean.smooth = TRUE,
  mean.col,
  mean.lwd = 2,
  mean.lty = 1,
  qnts = 0.5,
  qnts.col,
  qnts.alpha = 0.5,
  qnts.smooth = TRUE,
  legend,
  leg.cex = 0.8,
  axs = "r",
  grid = FALSE,
  add = FALSE,
  network = 1,
  at = 1,
  col.status = FALSE,
  shp.g2 = NULL,
  vertex.cex,
  stats,
  targ.line = TRUE,
  targ.col,
  targ.lwd = 2,
  targ.lty = 2,
  plots.joined,
  duration.imputed = TRUE,
  method = "l",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.netsim_+3A_x">x</code></td>
<td>
<p>An <code>EpiModel</code> model object of class <code>netsim</code>.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_type">type</code></td>
<td>
<p>Type of plot: <code>"epi"</code> for epidemic model results,
<code>"network"</code> for a static network plot (<code>plot.network</code>),
or <code>"formation"</code>, <code>"duration"</code>, or <code>"dissolution"</code> for
network formation, duration, or dissolution statistics.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_y">y</code></td>
<td>
<p>Output compartments or flows from <code>netsim</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_popfrac">popfrac</code></td>
<td>
<p>If <code>TRUE</code>, plot prevalence of values rather than numbers
(see details).</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_sim.lines">sim.lines</code></td>
<td>
<p>If <code>TRUE</code>, plot individual simulation lines. Default is
to plot lines for one-group models but not for two-group models.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_sims">sims</code></td>
<td>
<p>If <code>type="epi"</code> or <code>"formation"</code>, a vector of
simulation numbers to plot. If <code>type="network"</code>, a single
simulation number for which to plot the network, or else <code>"min"</code>
to plot the simulation number with the lowest disease prevalence,
<code>"max"</code> for the simulation with the highest disease prevalence,
or <code>"mean"</code> for the simulation with the prevalence closest to the
mean across simulations at the specified time step.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_sim.col">sim.col</code></td>
<td>
<p>Vector of any standard R color format for simulation lines.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_sim.lwd">sim.lwd</code></td>
<td>
<p>Line width for simulation lines.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_sim.alpha">sim.alpha</code></td>
<td>
<p>Transparency level for simulation lines, where
0 = transparent and 1 = opaque (see <code>adjustcolor</code> function).</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_mean.line">mean.line</code></td>
<td>
<p>If <code>TRUE</code>, plot mean of simulations across time.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_mean.smooth">mean.smooth</code></td>
<td>
<p>If <code>TRUE</code>, use a loess smoother on the mean line.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_mean.col">mean.col</code></td>
<td>
<p>Vector of any standard R color format for mean lines.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_mean.lwd">mean.lwd</code></td>
<td>
<p>Line width for mean lines.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_mean.lty">mean.lty</code></td>
<td>
<p>Line type for mean lines.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_qnts">qnts</code></td>
<td>
<p>If numeric, plot polygon of simulation quantiles based on the
range implied by the argument (see details). If <code>FALSE</code>, suppress
polygon from plot.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_qnts.col">qnts.col</code></td>
<td>
<p>Vector of any standard R color format for polygons.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_qnts.alpha">qnts.alpha</code></td>
<td>
<p>Transparency level for quantile polygons, where 0 =
transparent and 1 = opaque (see <code>adjustcolor</code> function).</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_qnts.smooth">qnts.smooth</code></td>
<td>
<p>If <code>TRUE</code>, use a loess smoother on quantile polygons.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_legend">legend</code></td>
<td>
<p>If <code>TRUE</code>, plot default legend.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_leg.cex">leg.cex</code></td>
<td>
<p>Legend scale size.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_axs">axs</code></td>
<td>
<p>Plot axis type (see <code><a href="graphics.html#topic+par">par</a></code> for details), with default
of <code>"r"</code>.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, a grid is added to the background of plot
(see <code><a href="graphics.html#topic+grid">grid</a></code> for details), with default of nx by ny.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, new plot window is not called and lines are added
to existing plot window.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_network">network</code></td>
<td>
<p>Network number, for simulations with multiple networks
representing the population.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_at">at</code></td>
<td>
<p>If <code>type = "network"</code>, time step for network graph.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_col.status">col.status</code></td>
<td>
<p>If <code>TRUE</code> and <code>type="network"</code>, automatic disease
status colors (blue = susceptible, red = infected, green = recovered).</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_shp.g2">shp.g2</code></td>
<td>
<p>If <code>type = "network"</code> and <code>x</code> is for a two-group model,
shapes for the Group 2 vertices, with acceptable inputs of &quot;triangle&quot;
and &quot;square&quot;. Group 1 vertices will remain circles.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_vertex.cex">vertex.cex</code></td>
<td>
<p>Relative size of plotted vertices if <code>type="network"</code>,
with implicit default of 1.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_stats">stats</code></td>
<td>
<p>If <code>type="formation","duration","dissolution"</code>, statistics
to plot. For <code>type = "formation"</code>, <code>stats</code> are among those
specified in <code>nwstats.formula</code> of <code><a href="#topic+control.net">control.net</a></code>; for
<code>type = "duration", "dissolution"</code>, <code>stats</code> are among those
of the dissolution model (without <code>offset()</code>). The default is
to plot all statistics.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_targ.line">targ.line</code></td>
<td>
<p>If <code>TRUE</code>, plot target or expected value line for
the statistic of interest.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_targ.col">targ.col</code></td>
<td>
<p>Vector of standard R colors for target statistic lines, with
default colors based on <code>RColorBrewer</code> color palettes.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_targ.lwd">targ.lwd</code></td>
<td>
<p>Line width for the line showing the target statistic values.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_targ.lty">targ.lty</code></td>
<td>
<p>Line type for the line showing the target statistic values.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_plots.joined">plots.joined</code></td>
<td>
<p>If <code>TRUE</code> and
<code>type="formation","duration","dissolution"</code>, combine all
statistics in one plot, versus one plot per statistic if
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_duration.imputed">duration.imputed</code></td>
<td>
<p>If <code>type = "duration"</code>, a logical indicating
whether or not to impute starting times for relationships extant at
the start of the simulation. Defaults to <code>TRUE</code> when
<code>type = "duration"</code>.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_method">method</code></td>
<td>
<p>Plot method for <code>type="formation", "duration", "dissolution"</code>,
with options of <code>"l"</code> for line plots and <code>"b"</code> for box plots.</p>
</td></tr>
<tr><td><code id="plot.netsim_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot function can produce three types of plots with a stochastic network
model simulated through <code><a href="#topic+netsim">netsim</a></code>:
</p>

<ol>
<li> <p><strong><code>type="epi"</code></strong>: epidemic model results (e.g., disease
prevalence and incidence) may be plotted.
</p>
</li>
<li> <p><strong><code>type="network"</code></strong>: a static network plot will be
generated. A static network plot of a dynamic network is a
cross-sectional extraction of that dynamic network at a specific
time point. This plotting function wraps the
<code><a href="network.html#topic+plot.network">plot.network</a></code> function in the <code>network</code> package.
Consult the help page for <code>plot.network</code> for all of the plotting
parameters. In addition, four plotting parameters specific to
<code>netsim</code> plots are available: <code>sim</code>, <code>at</code>,
<code>col.status</code>, and <code>shp.g2</code>.
</p>
</li>
<li> <p><strong><code>type="formation"</code></strong>: summary network statistics related
to the network model formation are plotted. These plots are similar
to the formation plots for <code>netdx</code> objects. When running a
<code>netsim</code> simulation, one must specify there that
<code>save.nwstats=TRUE</code>; the plot here will then show the network
statistics requested explicitly in <code>nwstats.formula</code>, or will use
the formation formula set in <code>netest</code> otherwise.
</p>
</li>
<li> <p><strong><code>type="duration","dissolution"</code></strong>: as in
<code><a href="#topic+plot.netdx">plot.netdx</a></code>; supported in <code>plot.netsim</code> only when
the dissolution model is <code>~offset(edges)</code>, <code>tergmLite</code> is
<code>FALSE</code>, and <code>save.network</code> is <code>TRUE</code>.
</p>
</li></ol>

<p>When <code>type="epi"</code>, this plotting function will extract the
epidemiological output from a model object of class <code>netsim</code> and plot
the time series data of disease prevalence and other results. The summary
statistics that the function calculates and plots are individual simulation
lines, means of the individual simulation lines, and quantiles of those
individual simulation lines. The mean line, toggled on with
<code>mean.line=TRUE</code>, is calculated as the row mean across simulations at
each time step.
</p>
<p>Compartment prevalences are the size of a compartment over some denominator.
To plot the raw numbers from any compartment, use <code>popfrac=FALSE</code>; this
is the default for any plots of flows. The <code>popfrac</code> parameter
calculates and plots the denominators of all specified compartments using
these rules: 1) for one-group models, the prevalence of any compartment is
the compartment size divided by the total population size; 2) for two-group
models, the prevalence of any compartment is the compartment size divided by
the group population size. For any prevalences that are not automatically
calculated, the <code><a href="#topic+mutate_epi">mutate_epi</a></code> function may be used to add new
variables to the <code>netsim</code> object to plot or analyze.
</p>
<p>The quantiles show the range of outcome values within a certain specified
quantile range. By default, the interquartile range is shown: that is the
middle 50\
middle 95\
where they are plotted by default, specify <code>qnts=FALSE</code>.
</p>
<p>When <code>type="network"</code>, this function will plot cross sections of the
simulated networks at specified time steps. Because it is only possible to
plot one time step from one simulation at a time, it is necessary to enter
these in the <code>at</code> and <code>sims</code> parameters. To aid in visualizing
representative and extreme simulations at specific time steps, the
<code>sims</code> parameter may be set to <code>"mean"</code> to plot the simulation in
which the disease prevalence is closest to the average across all
simulations, <code>"min"</code> to plot the simulation in which the prevalence is
lowest, and <code>"max"</code> to plot the simulation in which the prevalence is
highest.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+plot.network">plot.network</a></code>, <code><a href="#topic+mutate_epi">mutate_epi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SI Model without Network Feedback
# Initialize network and set network model parameters
nw &lt;- network_initialize(n = 100)
nw &lt;- set_vertex_attribute(nw, "group", rep(1:2, each = 50))
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)

# Estimate the network model
est &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Simulate the epidemic model
param &lt;- param.net(inf.prob = 0.3, inf.prob.g2 = 0.15)
init &lt;- init.net(i.num = 10, i.num.g2 = 10)
control &lt;- control.net(type = "SI", nsteps = 20, nsims = 3,
                       verbose = FALSE, save.nwstats = TRUE,
                       nwstats.formula = ~edges + meandeg + concurrent)
mod &lt;- netsim(est, param, init, control)

# Plot epidemic trajectory
plot(mod)
plot(mod, type = "epi", grid = TRUE)
plot(mod, type = "epi", popfrac = TRUE)
plot(mod, type = "epi", y = "si.flow", qnts = 1, ylim = c(0, 4))

# Plot static networks
par(mar = c(0, 0, 0, 0))
plot(mod, type = "network", vertex.cex = 1.5)

# Automatic coloring of infected nodes as red
par(mfrow = c(1, 2), mar = c(0, 0, 2, 0))
plot(mod, type = "network", main = "Min Prev | Time 50",
     col.status = TRUE, at = 20, sims = "min", vertex.cex = 1.25)
plot(mod, type = "network", main = "Max Prev | Time 50",
     col.status = TRUE, at = 20, sims = "max", vertex.cex = 1.25)

# Automatic shape by group number (circle = group 1)
par(mar = c(0, 0, 0, 0))
plot(mod, type = "network", at = 20, col.status = TRUE,
     shp.g2 = "square")
plot(mod, type = "network", at = 20, col.status = TRUE,
     shp.g2 = "triangle", vertex.cex = 2)

# Plot formation statistics
par(mfrow = c(1,1), mar = c(3,3,1,1), mgp = c(2,1,0))
plot(mod, type = "formation", grid = TRUE)
plot(mod, type = "formation", plots.joined = FALSE)
plot(mod, type = "formation", sims = 2:3)
plot(mod, type = "formation", plots.joined = FALSE,
     stats = c("edges", "concurrent"))
plot(mod, type = "formation", stats = "meandeg",
     mean.lwd = 1, qnts.col = "seagreen", mean.col = "black")

</code></pre>

<hr>
<h2 id='plot.transmat'>Plot transmat Infection Tree in Three Styles</h2><span id='topic+plot.transmat'></span>

<h3>Description</h3>

<p>Plots the transmission matrix tree from from <code>get_transmat</code>
in one of three styles: a phylogram, a directed network, or
a transmission timeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transmat'
plot(x, style = c("phylo", "network", "transmissionTimeline"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.transmat_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+transmat">transmat</a></code> object to be plotted.</p>
</td></tr>
<tr><td><code id="plot.transmat_+3A_style">style</code></td>
<td>
<p>Character name of plot style. One of <code>"phylo"</code>,
<code>"network"</code>, or <code>"transmissionTimeline"</code>.</p>
</td></tr>
<tr><td><code id="plot.transmat_+3A_...">...</code></td>
<td>
<p>Additional plot arguments to be passed to lower-level plot
functions (<code>plot.network</code>, <code>plot.phylo</code>, or
<code>transmissionTimeline</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>phylo</code> plot requires the <code>ape</code> package. The
<code>transmissionTimeline</code> plot requires that the <code>ndtv</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+plot.network">plot.network</a></code>, <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>,
<code><a href="ndtv.html#topic+transmissionTimeline">transmissionTimeline</a></code>.
</p>

<hr>
<h2 id='prevalence.icm'>Get Epidemic Output from icm Model</h2><span id='topic+prevalence.icm'></span>

<h3>Description</h3>

<p>This function provides all active model state sizes from
the network at the specified time step, output to a list of
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevalence.icm(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prevalence.icm_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="prevalence.icm_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>

<hr>
<h2 id='prevalence.icm.bip'>Get Epidemic Output from icm Model</h2><span id='topic+prevalence.icm.bip'></span>

<h3>Description</h3>

<p>This function provides all active model state sizes from
the network at the specified time step, output to a list of
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevalence.icm.bip(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prevalence.icm.bip_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="prevalence.icm.bip_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>

<hr>
<h2 id='prevalence.net'>Get Epidemic Output from netsim Model</h2><span id='topic+prevalence.net'></span>

<h3>Description</h3>

<p>Provides all active model state sizes from the network at the
specified time step, output to a list of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevalence.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prevalence.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="prevalence.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This network utility is used during the <code><a href="#topic+netsim">netsim</a></code> simulation
process to efficiently query the current size of each state or compartment
in the model at any given timestep. For a two-group network, the current
state size for each group and overall is provided.
</p>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='print_nwstats_table'>Print Helper For Network Stats Tables</h2><span id='topic+print_nwstats_table'></span>

<h3>Description</h3>

<p>Print Helper For Network Stats Tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_nwstats_table(nwtable, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_nwstats_table_+3A_nwtable">nwtable</code></td>
<td>
<p>A formation or dissolution statistics <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="print_nwstats_table_+3A_digits">digits</code></td>
<td>
<p>Argument to be passed to <code>round</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.netdx'>Utility Function for Printing netdx Object</h2><span id='topic+print.netdx'></span>

<h3>Description</h3>

<p>Prints basic information and statistics from a <code>netdx</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netdx'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netdx_+3A_x">x</code></td>
<td>
<p>an object of class <code>netdx</code></p>
</td></tr>
<tr><td><code id="print.netdx_+3A_digits">digits</code></td>
<td>
<p>number of digits to print in statistics tables</p>
</td></tr>
<tr><td><code id="print.netdx_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code>netdx</code> object, <code>print.netdx</code> prints the diagnostic method
(static/dynamic), number of simulations, and (if dynamic) the number of time
steps per simulation used in generating the <code>netdx</code> object, as well as
printing the formation statistics table and (if present) the duration and
dissolution statistics tables.  The statistics tables are interpreted as
follows.
</p>
<p>Each row has the name of a particular network statistic.  In the formation
table, these correspond to actual network statistics in the obvious way.
In the duration and dissolution tables, these correspond to dissolution
model dyad types: in a homogeneous dissolution model, all dyads are of the
<code>edges</code> type; in a heterogeneous dissolution model, a dyad with a
nonzero <code>nodematch</code> or <code>nodemix</code> change statistic in the
dissolution model has type equal to that statistic, and has type equal to
<code>edges</code> otherwise.  The statistics of interest for the duration and
dissolution tables are, respectively, the mean age of extant edges and the
edge dissolution rate, broken down by dissolution model dyad type.  (The
current convention is to treat the mean age and dissolution rate for a
particular dissolution dyad type as 0 on time steps with no edges of that
type; this behavior may be changed in the future.)
</p>
<p>The columns are named <code>Target</code>, <code>Sim Mean</code>, <code>Pct Diff</code>,
<code>Sim SE</code>, <code>Z Score</code>, <code>SD(Sim Means)</code>, and
<code>SD(Statistic)</code>.  The <code>Sim Mean</code> column refers to the mean
statistic value, across all time steps in all simulations in the dynamic
case, and across all sampled networks in all simulations in the static case.
The <code>Sim SE</code> column refers to the standard error in the mean, estimated
using <code><a href="coda.html#topic+effectiveSize">coda::effectiveSize</a></code>.  The <code>Target</code>
column indicates the target value (if present) for the statistic, and the
<code>Pct Diff</code> column gives <code>(Sim Mean - Target)/Target</code> when
<code>Target</code> is present.  The <code>Z Score</code> column gives
<code>(Sim Mean - Target)/(Sim SE)</code>.  The <code>SD(Sim Means)</code> column gives
the empirical standard deviation across simulations of the mean statistic
value within simulation, and <code>SD(Statistic)</code> gives the empirical
standard deviation of the statistic value across all the simulated data.
</p>

<hr>
<h2 id='process_out.net'>Save a List of netsim Data to Output List Format</h2><span id='topic+process_out.net'></span>

<h3>Description</h3>

<p>This function transfers the data from a list of the main
<code>netsim_dat</code> objects to the output <code>out</code> object at the
end of all simulations in <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_out.net(dat_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_out.net_+3A_dat_list">dat_list</code></td>
<td>
<p>A list of main <code>netsim_dat</code> objects in <code>netsim</code>
simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>netsim</code> with the following elements:
</p>

<ul>
<li> <p><strong>param:</strong> the epidemic parameters passed into the model through
<code>param</code>, with additional parameters added as necessary.
</p>
</li>
<li> <p><strong>control:</strong> the control settings passed into the model through
<code>control</code>, with additional controls added as necessary.
</p>
</li>
<li> <p><strong>epi:</strong> a list of data frames, one for each epidemiological
output from the model. Outputs for base models always include the
size of each compartment, as well as flows in, out of, and between
compartments.
</p>
</li>
<li> <p><strong>stats:</strong> a list containing two sublists, <code>nwstats</code> for any
network statistics saved in the simulation, and <code>transmat</code> for
the transmission matrix saved in the simulation. See
<code><a href="#topic+control.net">control.net</a></code> and the
<a href="http://www.epimodel.org/tut.html">tutorials</a> for further
details.
</p>
</li>
<li> <p><strong>network:</strong> a list of <code>networkDynamic</code> objects,
one for each model simulation.
</p>
</li></ul>


<hr>
<h2 id='record_attr_history'>Record Attribute History</h2><span id='topic+record_attr_history'></span>

<h3>Description</h3>

<p>This function records values specific to a time-step and a group of nodes.
In the records, the <code>posit_ids</code> are converted to <code>unique_ids</code> which
allows the recording of data for nodes that are no longer in the network by
the end of the run. The records are stored in <code>dat[["attr.history"]]</code>
where <code>dat</code> is the main <code>netsim_dat</code> class object, and can be
accessed from the <code>netsim</code> object with <code>get_attr_history</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record_attr_history(dat, at, attribute, posit_ids, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="record_attr_history_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="record_attr_history_+3A_at">at</code></td>
<td>
<p>The time where the recording happens.</p>
</td></tr>
<tr><td><code id="record_attr_history_+3A_attribute">attribute</code></td>
<td>
<p>The name of the value to record.</p>
</td></tr>
<tr><td><code id="record_attr_history_+3A_posit_ids">posit_ids</code></td>
<td>
<p>A numeric vector of posit_ids to which the measure applies.
(see <code>get_posit_ids</code>).</p>
</td></tr>
<tr><td><code id="record_attr_history_+3A_values">values</code></td>
<td>
<p>The values to be recorded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the &quot;Time-Varying Parameters&quot; section of the &quot;Working With Model
Parameters&quot; vignette.
</p>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This function must be used inside a custom module
dat &lt;- record_attr_history(dat, at, "attr_1", get_posit_ids(dat), 5)
some_nodes &lt;- get_posit_ids(dat)
some_nodes &lt;- some_nodes[runif(length(some_nodes)) &lt; 0.2]
dat &lt;- record_attr_history(
  dat, at,
  "attr_2",
  some_nodes,
  rnorm(length(some_nodes))
)

## End(Not run)

</code></pre>

<hr>
<h2 id='record_raw_object'>Record an Arbitrary Object During a Simulation</h2><span id='topic+record_raw_object'></span>

<h3>Description</h3>

<p>This function records any object during a simulation to allow its
inspection afterward. The records are stored in <code>dat[["raw.records"]]</code>
during the simulation, where <code>dat</code> is the main <code>netsim_dat</code> class
object, and in the <code>netsim</code> object under the <code>raw.records</code>
sublists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record_raw_object(dat, at, label, object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="record_raw_object_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="record_raw_object_+3A_at">at</code></td>
<td>
<p>The time where the recording happens.</p>
</td></tr>
<tr><td><code id="record_raw_object_+3A_label">label</code></td>
<td>
<p>The name to give to the recorded object.</p>
</td></tr>
<tr><td><code id="record_raw_object_+3A_object">object</code></td>
<td>
<p>The object to be recorded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the &quot;Time-Varying Parameters&quot; section of the &quot;Working With Model
Parameters&quot; vignette.
</p>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

dat &lt;- record_raw_object(dat, at, "a.df", data.frame(x = 2:200))
dat &lt;- record_raw_object(dat, at, "a.message", "I recorded something")


## End(Not run)

</code></pre>

<hr>
<h2 id='recovery.2g.net'>Recovery: netsim Module</h2><span id='topic+recovery.2g.net'></span>

<h3>Description</h3>

<p>This function simulates recovery from the infected state
either to a distinct recovered state (SIR model type) or back
to a susceptible state (SIS model type), for use in
<code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recovery.2g.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recovery.2g.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="recovery.2g.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='recovery.icm'>Recovery: icm Module</h2><span id='topic+recovery.icm'></span>

<h3>Description</h3>

<p>This function simulates recovery from the infected state
either to a distinct recovered state (SIR model type) or back
to a susceptible state (SIS model type), for use in
<code><a href="#topic+icm">icm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recovery.icm(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recovery.icm_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="recovery.icm_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>

<hr>
<h2 id='recovery.icm.bip'>Recovery: icm Module</h2><span id='topic+recovery.icm.bip'></span>

<h3>Description</h3>

<p>This function simulates recovery from the infected state
either to a distinct recovered state (SIR model type) or back
to a susceptible state (SIS model type), for use in
<code><a href="#topic+icm">icm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recovery.icm.bip(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recovery.icm.bip_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="recovery.icm.bip_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>icm_dat</code> class main data object.
</p>

<hr>
<h2 id='recovery.net'>Recovery: netsim Module</h2><span id='topic+recovery.net'></span>

<h3>Description</h3>

<p>This function simulates recovery from the infected state
either to a distinct recovered state (SIR model type) or back
to a susceptible state (SIS model type), for use in
<code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recovery.net(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recovery.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="recovery.net_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+control.ergm.ego'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ergm.ego</dt><dd><p><code><a href="ergm.ego.html#topic+control.ergm.ego">control.ergm.ego</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove_modules'>Remove a Set of Modules From the Module List</h2><span id='topic+remove_modules'></span>

<h3>Description</h3>

<p>Remove a Set of Modules From the Module List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_modules(dat, names.to.remove)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_modules_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="remove_modules_+3A_names.to.remove">names.to.remove</code></td>
<td>
<p>a character vector containing the name of the modules
to remove.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='resim_nets'>Resimulate Dynamic Network at Time 2+</h2><span id='topic+resim_nets'></span>

<h3>Description</h3>

<p>This function resimulates the dynamic network in stochastic
network models simulated in <code><a href="#topic+netsim">netsim</a></code> with dependence
between the epidemic and demographic processes and the network
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resim_nets(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resim_nets_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="resim_nets_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='saveout.dcm'>Save dcm Data to Output List Format</h2><span id='topic+saveout.dcm'></span>

<h3>Description</h3>

<p>This function transfers the data from the main <code>df</code>
object to the output <code>out</code> object at the end of each
run in <code><a href="#topic+dcm">dcm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveout.dcm(df, s, param, control, out = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveout.dcm_+3A_df">df</code></td>
<td>
<p>Main object in <code><a href="#topic+dcm">dcm</a></code> simulations.</p>
</td></tr>
<tr><td><code id="saveout.dcm_+3A_s">s</code></td>
<td>
<p>Current run number.</p>
</td></tr>
<tr><td><code id="saveout.dcm_+3A_param">param</code></td>
<td>
<p>Param list set in <code><a href="#topic+param.dcm">param.dcm</a></code>.</p>
</td></tr>
<tr><td><code id="saveout.dcm_+3A_control">control</code></td>
<td>
<p>Control list set in <code><a href="#topic+control.dcm">control.dcm</a></code>.</p>
</td></tr>
<tr><td><code id="saveout.dcm_+3A_out">out</code></td>
<td>
<p>Out list passed back in for updating at runs 2+.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><strong>param:</strong> the epidemic parameters passed into the model through
<code><a href="#topic+param.dcm">param.dcm</a></code>, with additional parameters added as
necessary.
</p>
</li>
<li> <p><strong>control:</strong> the control settings passed into the model through
<code><a href="#topic+control.dcm">control.dcm</a></code>, with additional controls added as
necessary.
</p>
</li>
<li> <p><strong>epi:</strong> a list of data frames, one for each epidemiological
output from the model.
</p>
</li></ul>


<hr>
<h2 id='saveout.icm'>Save icm Data to Output List Format</h2><span id='topic+saveout.icm'></span>

<h3>Description</h3>

<p>This function transfers the data from the main <code>icm_dat</code>
class data object to the output <code>out</code> object at the end of
each simulation in <code><a href="#topic+icm">icm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveout.icm(dat, s, out = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveout.icm_+3A_dat">dat</code></td>
<td>
<p>Main <code>icm_dat</code> class data object passed through <code>icm</code>
simulations.</p>
</td></tr>
<tr><td><code id="saveout.icm_+3A_s">s</code></td>
<td>
<p>Current simulation number.</p>
</td></tr>
<tr><td><code id="saveout.icm_+3A_out">out</code></td>
<td>
<p>Out list passed back in for updating at simulations 2+.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><strong>param:</strong> the epidemic parameters passed into the model through
<code><a href="#topic+param.icm">param.icm</a></code>, with additional parameters added as
necessary.
</p>
</li>
<li> <p><strong>control:</strong> the control settings passed into the model through
<code><a href="#topic+control.icm">control.icm</a></code>, with additional controls added as
necessary.
</p>
</li>
<li> <p><strong>epi:</strong> a list of data frames, one for each epidemiological
output from the model.
</p>
</li></ul>


<hr>
<h2 id='saveout.net'>Save netsim Data to Output List Format</h2><span id='topic+saveout.net'></span>

<h3>Description</h3>

<p>This function transfers the data from the main <code>netsim_dat</code>
object to the output <code>out</code> object at the end of each
simulation in <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveout.net(dat, s, out = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveout.net_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="saveout.net_+3A_s">s</code></td>
<td>
<p>Current simulation number.</p>
</td></tr>
<tr><td><code id="saveout.net_+3A_out">out</code></td>
<td>
<p>Out list passed back in for updating at simulations 2+.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><strong>param:</strong> the epidemic parameters passed into the model through
<code><a href="#topic+param.net">param.net</a></code>, with additional parameters added as
necessary.
</p>
</li>
<li> <p><strong>control:</strong> the control settings passed into the model through
<code><a href="#topic+control.net">control.net</a></code>, with additional controls added as
necessary.
</p>
</li>
<li> <p><strong>epi:</strong> a list of data frames, one for each epidemiological
output from the model.
</p>
</li>
<li> <p><strong>stats:</strong> a list containing two sublists, <code>nwstats</code> for any
network statistics saved in the simulation, and <code>transmat</code> for
the transmission matrix saved in the simulation.
</p>
</li>
<li> <p><strong>network:</strong> a list of <code>networkDynamic</code> objects,
one for each model simulation.
</p>
</li></ul>


<hr>
<h2 id='set_current_timestep'>Set the Current Timestep</h2><span id='topic+set_current_timestep'></span>

<h3>Description</h3>

<p>Changes the current timestep in the <code>netsim_dat</code> object.
Use with caution. This function exists to work around unforeseen
corner cases. In most situation, <code>increment_timestep</code> is
preferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_current_timestep(dat, timestep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_current_timestep_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="set_current_timestep_+3A_timestep">timestep</code></td>
<td>
<p>The new value for the timestep.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>Mutability</h3>

<p>This DOES NOT modify the <code>netsim_dat</code> object in place. The result must
be assigned back to <code>dat</code> in order to be registered:
<code>dat &lt;- increment_timestep(dat)</code>.
</p>

<hr>
<h2 id='set_modules'>Set the List of Modules</h2><span id='topic+set_modules'></span>

<h3>Description</h3>

<p>Set the List of Modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_modules(dat, modules)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_modules_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="set_modules_+3A_modules">modules</code></td>
<td>
<p>A named list of modules to be run by the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='set_network'>Set Network State During netsim Simulation</h2><span id='topic+set_network'></span><span id='topic+set_network.netsim_dat'></span>

<h3>Description</h3>

<p>This function updates the <code>netsim_dat</code> object given a
network representing the current state of the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_network(x, ...)

## S3 method for class 'netsim_dat'
set_network(x, network = 1L, nw, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_network_+3A_x">x</code></td>
<td>
<p>a <code>netsim_dat</code> object</p>
</td></tr>
<tr><td><code id="set_network_+3A_network">network</code></td>
<td>
<p>the index of the network to set on <code>x</code></p>
</td></tr>
<tr><td><code id="set_network_+3A_nw">nw</code></td>
<td>
<p>the value of the network to set on <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If running <code>tergmLite</code> simulation, this function updates
<code>x$el[[network]]</code> and (if <code>tergmLite.track.duration</code> is <code>TRUE</code>
for the network index <code>network</code>) the network attributes <code>"time"</code>
and <code>"lasttoggle"</code> in <code>x$net_attr[[network]]</code>. If not running
<code>tergmLite</code> simulation, this function updates the <code>networkDynamic</code>
object stored in <code>x$nw[[network]]</code>. The input <code>nw</code> should be of
class <code>networkLite</code> when running <code>tergmLite</code> simulation, and of
class <code>networkDynamic</code> when not running <code>tergmLite</code> simulation.
</p>


<h3>Value</h3>

<p>the <code>netsim_dat</code> object with the network state updated
</p>

<hr>
<h2 id='set_transmat'>Save Transmission Matrix</h2><span id='topic+set_transmat'></span>

<h3>Description</h3>

<p>This function appends the transmission matrix created during
<code>infection.net</code> and <code>infection.2g.net</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_transmat(dat, del, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_transmat_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="set_transmat_+3A_del">del</code></td>
<td>
<p>Discordant edgelist created within <code><a href="#topic+infection.net">infection.net</a></code> and
<code><a href="#topic+infection.2g.net">infection.2g.net</a></code>.</p>
</td></tr>
<tr><td><code id="set_transmat_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal function works within the parent <code><a href="#topic+infection.net">infection.net</a></code>
functions to save the transmission matrix created at time step <code>at</code> to
the main <code>netsim_dat</code> class object <code>dat</code>.
</p>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='set_vertex_attribute'>Set Vertex Attribute on Network Object</h2><span id='topic+set_vertex_attribute'></span>

<h3>Description</h3>

<p>Sets a vertex attribute on an object of class <code>network</code>.
This function simplifies the related function in the
<code>network</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_vertex_attribute(x, attrname, value, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_vertex_attribute_+3A_x">x</code></td>
<td>
<p>An object of class network.</p>
</td></tr>
<tr><td><code id="set_vertex_attribute_+3A_attrname">attrname</code></td>
<td>
<p>The name of the attribute to set.</p>
</td></tr>
<tr><td><code id="set_vertex_attribute_+3A_value">value</code></td>
<td>
<p>A vector of values of the attribute to be set.</p>
</td></tr>
<tr><td><code id="set_vertex_attribute_+3A_v">v</code></td>
<td>
<p>IDs for the vertices whose attributes are to be altered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in <code>EpiModel</code> workflows to set vertex attributes
on an initialized empty network object (see <code><a href="#topic+network_initialize">network_initialize</a></code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>network</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- network_initialize(100)
nw &lt;- set_vertex_attribute(nw, "age", runif(100, 15, 65))
nw

</code></pre>

<hr>
<h2 id='sim_nets_t1'>Initialize Networks Used in netsim</h2><span id='topic+sim_nets_t1'></span>

<h3>Description</h3>

<p>This function initializes the networks used in
<code><a href="#topic+netsim">netsim</a></code>. The initial edge set for a given network
is obtained either from simulating the cross-sectional model
(if <code>edapprox == TRUE</code>) or from the <code>newnetwork</code>
element of the <code>netest</code> object (if
<code>edapprox == FALSE</code>). Once the initial edge sets are
determined, the first time step is simulated if
<code>resimulate.network == TRUE</code>, and all time steps are
simulated if <code>resimulate.network == FALSE</code>. Initializes the
<code>sim.num(.g2)</code> epi fields used in
<code><a href="#topic+edges_correct">edges_correct</a></code> for computing edge coefficient
adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_nets_t1(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_nets_t1_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='simulate_dat'>Simulate a Network for a Specified Number of Time Steps</h2><span id='topic+simulate_dat'></span>

<h3>Description</h3>

<p>This function simulates a dynamic network over one or multiple
time steps for TERGMs or one or multiple cross-sectional network
panels for ERGMs, for use in <code><a href="#topic+netsim">netsim</a></code> modeling.
Network statistics are also extracted and saved if
<code>save.nwstats == TRUE</code> and
<code>resimulate.network == FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_dat(dat, at, network = 1L, nsteps = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_dat_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_dat_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
<tr><td><code id="simulate_dat_+3A_network">network</code></td>
<td>
<p>index of the network to simulate</p>
</td></tr>
<tr><td><code id="simulate_dat_+3A_nsteps">nsteps</code></td>
<td>
<p>number of time steps to simulate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='ssample'>Stable Sampling Function</h2><span id='topic+ssample'></span>

<h3>Description</h3>

<p>Provides a sampling function useful for dynamic simulations, in
which the length of the input vector may be multiple lengths and
the size of the sample may be 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssample(x, size, replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssample_+3A_x">x</code></td>
<td>
<p>Either a vector of one or more elements from which to choose, or a
positive integer.</p>
</td></tr>
<tr><td><code id="ssample_+3A_size">size</code></td>
<td>
<p>Non-negative integer giving the number of items to choose.</p>
</td></tr>
<tr><td><code id="ssample_+3A_replace">replace</code></td>
<td>
<p>Should sampling be with replacement?</p>
</td></tr>
<tr><td><code id="ssample_+3A_prob">prob</code></td>
<td>
<p>Vector of probability weights for obtaining the elements of the
vector being sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the sampled value(s).
</p>

<hr>
<h2 id='summary_nets'>Extract Summary Statistics of Networks Used in netsim</h2><span id='topic+summary_nets'></span>

<h3>Description</h3>

<p>This function calls <code>summary</code> on each network being
simulated in <code>netsim</code>, provided <code>save.nwstats</code> and
<code>resimulate.network</code> are both <code>TRUE</code>. It records the
statistics represented by <code>nwstats.formula</code> in
<code>dat$stats$nwstats</code>, where <code>dat</code> is the main
<code>netsim_dat</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_nets(dat, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_nets_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="summary_nets_+3A_at">at</code></td>
<td>
<p>Current time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='summary.dcm'>Summary Model Statistics</h2><span id='topic+summary.dcm'></span>

<h3>Description</h3>

<p>Extracts and prints model statistics solved with <code>dcm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcm'
summary(object, at, run = 1, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dcm_+3A_object">object</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>dcm</code>.</p>
</td></tr>
<tr><td><code id="summary.dcm_+3A_at">at</code></td>
<td>
<p>Time step for model statistics.</p>
</td></tr>
<tr><td><code id="summary.dcm_+3A_run">run</code></td>
<td>
<p>Model run number, for <code>dcm</code> class models with multiple runs
(sensitivity analyses).</p>
</td></tr>
<tr><td><code id="summary.dcm_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="summary.dcm_+3A_...">...</code></td>
<td>
<p>Additional summary function arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides summary statistics for the main epidemiological
outcomes (state and transition size and prevalence) from a <code>dcm</code> model.
Time-specific summary measures are provided, so it is necessary to input a
time of interest. For multiple-run models (sensitivity analyses), input a
model run number. See examples below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcm">dcm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Deterministic SIR model with varying act.rate
param &lt;- param.dcm(inf.prob = 0.2, act.rate = 2:4, rec.rate = 1/3,
                   a.rate = 0.011, ds.rate = 0.01,
                   di.rate = 0.03, dr.rate = 0.01)
init &lt;- init.dcm(s.num = 1000, i.num = 1, r.num = 0)
control &lt;- control.dcm(type = "SIR", nsteps = 50)
mod &lt;- dcm(param, init, control)
summary(mod, at = 25, run = 1)
summary(mod, at = 25, run = 3)
summary(mod, at = 26, run = 3)

</code></pre>

<hr>
<h2 id='summary.icm'>Summary Model Statistics</h2><span id='topic+summary.icm'></span>

<h3>Description</h3>

<p>Extracts and prints model statistics simulated with <code>icm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icm'
summary(object, at, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.icm_+3A_object">object</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>icm</code>.</p>
</td></tr>
<tr><td><code id="summary.icm_+3A_at">at</code></td>
<td>
<p>Time step for model statistics.</p>
</td></tr>
<tr><td><code id="summary.icm_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="summary.icm_+3A_...">...</code></td>
<td>
<p>Additional summary function arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides summary statistics for the main epidemiological
outcomes (state and transition size and prevalence) from an <code>icm</code> model.
Time-specific summary measures are provided, so it is necessary to input a
time of interest.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icm">icm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Stochastic ICM SI model with 3 simulations
param &lt;- param.icm(inf.prob = 0.2, act.rate = 1)
init &lt;- init.icm(s.num = 500, i.num = 1)
control &lt;- control.icm(type = "SI", nsteps = 50,
                       nsims = 5, verbose = FALSE)
mod &lt;- icm(param, init, control)
summary(mod, at = 25)
summary(mod, at = 50)

</code></pre>

<hr>
<h2 id='summary.netest'>Summary for Network Model Fit</h2><span id='topic+summary.netest'></span>

<h3>Description</h3>

<p>Prints the summary model fit statistics for an ERGM or STERGM
fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.netest_+3A_object">object</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>netest</code>.</p>
</td></tr>
<tr><td><code id="summary.netest_+3A_...">...</code></td>
<td>
<p>Additional summary function arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is simply a wrapper function for <code>summary.ergm</code>.
Additionally, if the edges dissolution approximation was used to fit the
temporal ERGM, then the dissolution coefficient information will be printed.
</p>
<p>If the <code>fit</code> object is attached to the <code>netest</code> object, then
<code>summary.netest</code> will call <code>summary</code> on <code>fit</code> using the
<code>...</code> passed to <code>summary.netest</code>.  Otherwise,
<code>summary.netest</code> will print the stored summary of the fit generated
in the original <code>netest</code> call, using the <code>...</code> passed to
<code>netest</code>.
</p>

<hr>
<h2 id='summary.netsim'>Summary Model Statistics</h2><span id='topic+summary.netsim'></span>

<h3>Description</h3>

<p>Extracts and prints model statistics simulated with
<code>netsim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netsim'
summary(object, at, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.netsim_+3A_object">object</code></td>
<td>
<p>An <code>EpiModel</code> object of class <code>netsim</code>.</p>
</td></tr>
<tr><td><code id="summary.netsim_+3A_at">at</code></td>
<td>
<p>Time step for model statistics.</p>
</td></tr>
<tr><td><code id="summary.netsim_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="summary.netsim_+3A_...">...</code></td>
<td>
<p>Additional summary function arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides summary statistics for the main epidemiological
outcomes (state and transition size and prevalence) from a <code>netsim</code>
model. Time-specific summary measures are provided, so it is necessary to
input a time of interest.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsim">netsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## SI Model without Network Feedback
# Initialize network and set network model parameters
nw &lt;- network_initialize(n = 100)
nw &lt;- set_vertex_attribute(nw, "group", rep(1:2, each = 50))
formation &lt;- ~edges
target.stats &lt;- 50
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 20)

# Estimate the ERGM models (see help for netest)
est1 &lt;- netest(nw, formation, target.stats, coef.diss, verbose = FALSE)

# Parameters, initial conditions, and controls for model
param &lt;- param.net(inf.prob = 0.3, inf.prob.g2 = 0.15)
init &lt;- init.net(i.num = 10, i.num.g2 = 10)
control &lt;- control.net(type = "SI", nsteps = 100, nsims = 5, verbose.int = 0)

# Run the model simulation
mod &lt;- netsim(est1, param, init, control)

summary(mod, at = 1)
summary(mod, at = 50)
summary(mod, at = 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='tedgelist_to_toggles'>Convert Timed Edgelist to Matrix of Toggles</h2><span id='topic+tedgelist_to_toggles'></span>

<h3>Description</h3>

<p>Convert Timed Edgelist to Matrix of Toggles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tedgelist_to_toggles(tedgelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tedgelist_to_toggles_+3A_tedgelist">tedgelist</code></td>
<td>
<p>A timed edgelist, as produced by
<code><a href="networkDynamic.html#topic+as.data.frame.networkDynamic">as.data.frame.networkDynamic</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of toggles corresponding to <code>tedgelist</code>.
</p>

<hr>
<h2 id='test_icm'>Test the Model Output from a Stochastic Individual Contact Model</h2><span id='topic+test_icm'></span>

<h3>Description</h3>

<p>Tests whether the model output from an individual contact model
is consistent with key balancing equations for compartment and
flow sizes for each simulation for each time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_icm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_icm_+3A_x">x</code></td>
<td>
<p>An object of class <code>icm</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='test_net'>Test the Model Output from a Network Model</h2><span id='topic+test_net'></span>

<h3>Description</h3>

<p>Tests whether the model output from a network model is
consistent with key balancing equations for compartment and
flow sizes for each simulation for each time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_net(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_net_+3A_x">x</code></td>
<td>
<p>An object of class <code>netsim</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='toggles_to_diss_stats'>Convert Matrix of Toggles to Dissolution and Duration Statistics</h2><span id='topic+toggles_to_diss_stats'></span>

<h3>Description</h3>

<p>Convert Matrix of Toggles to Dissolution and Duration Statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toggles_to_diss_stats(toggles, coef.diss, nsteps, nw, time.start = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toggles_to_diss_stats_+3A_toggles">toggles</code></td>
<td>
<p>A matrix of toggles, as produced by
<code><a href="#topic+tedgelist_to_toggles">tedgelist_to_toggles</a></code>.</p>
</td></tr>
<tr><td><code id="toggles_to_diss_stats_+3A_coef.diss">coef.diss</code></td>
<td>
<p>Dissolution coefficients used in the simulation.</p>
</td></tr>
<tr><td><code id="toggles_to_diss_stats_+3A_nsteps">nsteps</code></td>
<td>
<p>Number of time steps in the simulation.</p>
</td></tr>
<tr><td><code id="toggles_to_diss_stats_+3A_nw">nw</code></td>
<td>
<p>Network used in the simulation.</p>
</td></tr>
<tr><td><code id="toggles_to_diss_stats_+3A_time.start">time.start</code></td>
<td>
<p>Starting time for the simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing dissolution and duration statistics matrices
and other related information.
</p>

<hr>
<h2 id='trigger_end_horizon'>Function to Trigger the End Horizon</h2><span id='topic+trigger_end_horizon'></span>

<h3>Description</h3>

<p>Function to Trigger the End Horizon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trigger_end_horizon(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trigger_end_horizon_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function triggers the end horizon if a control <code>end.horizon</code> exists and
its <code>at</code> value is equal to the current timestep. The end horizon consists on
the removal of a set of modules from the module list.
</p>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='trim_netest'>Function to Reduce the Size of a <code>netest</code> Object</h2><span id='topic+trim_netest'></span>

<h3>Description</h3>

<p>Trims formula environments from the <code>netest</code> object.
Optionally converts the <code>newnetwork</code> element of the
<code>netest</code> object to a <code>networkLite</code> class, and removes
the <code>fit</code> element (if present) from the <code>netest</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_netest(
  object,
  as.networkLite = TRUE,
  keep.fit = FALSE,
  keep = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_netest_+3A_object">object</code></td>
<td>
<p>A <code>netest</code> class object.</p>
</td></tr>
<tr><td><code id="trim_netest_+3A_as.networklite">as.networkLite</code></td>
<td>
<p>If <code>TRUE</code>, converts <code>object$newnetwork</code>
to a <code>networkLite</code>.</p>
</td></tr>
<tr><td><code id="trim_netest_+3A_keep.fit">keep.fit</code></td>
<td>
<p>If <code>FALSE</code>, removes the <code>object$fit</code> (if present)
on the <code>netest</code> object.</p>
</td></tr>
<tr><td><code id="trim_netest_+3A_keep">keep</code></td>
<td>
<p>Character vector of object names to keep in formula environments.
By default, all objects are removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With larger, more complex network structures with epidemic models, it is
generally useful to reduce the memory footprint of the fitted TERGM model
object (estimated with <code><a href="#topic+netest">netest</a></code>). This utility function removes
all but the bare essentials needed for simulating a network model with
<code><a href="#topic+netsim">netsim</a></code>.
</p>
<p>The function always trims the environments of <code>object$constraints</code> and
<code>object$coef.diss$dissolution</code>.
</p>
<p>When both <code>edapprox = TRUE</code> and <code>nested.edapprox = TRUE</code> in the
<code>netest</code> call, also trims the environments of <code>object$formula</code>
and <code>object$formation</code>.
</p>
<p>When both <code>edapprox = TRUE</code> and <code>nested.edapprox = FALSE</code> in the
<code>netest</code> call, also trims the environments of <code>object$formula</code>,
<code>environment(object$formation)$formation</code>, and
<code>environment(object$formation)$dissolution</code>.
</p>
<p>When <code>edapprox = FALSE</code> in the <code>netest</code> call, also trims the
environments of <code>object$formation</code>,
<code>environment(object$formula)$formation</code> and
<code>environment(object$formula)$dissolution</code>.
</p>
<p>By default all objects are removed from these trimmed environments. Specific
objects may be retained by passing their names as the <code>keep</code> argument.
For the output of <code>trim_netest</code> to be usable in <code><a href="#topic+netsim">netsim</a></code>
simulation, any objects referenced in the formulas should be included in the
<code>keep</code> argument.
</p>
<p>If <code>as.networkLite = TRUE</code>, converts <code>object$newnetwork</code> to a
<code>networkLite</code> object. If <code>keep.fit = FALSE</code>, removes <code>fit</code> (if
present) from <code>object</code>.
</p>


<h3>Value</h3>

<p>A <code>netest</code> object with formula environments trimmed, optionally with the
<code>newnetwork</code> element converted to a <code>networkLite</code> and the
<code>fit</code> element removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- network_initialize(n = 100)
formation &lt;- ~edges + concurrent
target.stats &lt;- c(50, 25)
coef.diss &lt;- dissolution_coefs(dissolution = ~offset(edges), duration = 10)
est &lt;- netest(nw, formation, target.stats, coef.diss,
              set.control.ergm = control.ergm(MCMC.burnin = 1e5,
                                              MCMC.interval = 1000))
print(object.size(est), units = "KB")

est.small &lt;- trim_netest(est)
print(object.size(est.small), units = "KB")

</code></pre>

<hr>
<h2 id='truncate_sim'>Truncate Simulation Time Series</h2><span id='topic+truncate_sim'></span>

<h3>Description</h3>

<p>Left-truncates simulation epidemiological summary statistics
and network statistics at a specified time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate_sim(x, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_sim_+3A_x">x</code></td>
<td>
<p>Object of class <code>netsim</code> or <code>icm</code>.</p>
</td></tr>
<tr><td><code id="truncate_sim_+3A_at">at</code></td>
<td>
<p>Time step at which to left-truncate the time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function would be used when running a follow-up simulation from time
steps <code>b</code> to <code>c</code> after a burn-in period from time <code>a</code> to
<code>b</code>, where the final time window of interest for data analysis is
<code>b</code> to <code>c</code> only.
</p>


<h3>Value</h3>

<p>The updated object of class <code>netsim</code> or <code>icm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- param.icm(inf.prob = 0.2, act.rate = 0.25)
init &lt;- init.icm(s.num = 500, i.num = 1)
control &lt;- control.icm(type = "SI", nsteps = 200, nsims = 1)
mod1 &lt;- icm(param, init, control)
df &lt;- as.data.frame(mod1)
print(df)
plot(mod1)
mod1$control$nsteps

mod2 &lt;- truncate_sim(mod1, at = 150)
df2 &lt;- as.data.frame(mod2)
print(df2)
plot(mod2)
mod2$control$nsteps

</code></pre>

<hr>
<h2 id='unique_id-tools'>Convert Unique Identifiers to/from Positional Identifiers</h2><span id='topic+unique_id-tools'></span><span id='topic+get_unique_ids'></span><span id='topic+get_posit_ids'></span>

<h3>Description</h3>

<p>EpiModel refers to its nodes either by positional identifiers
(<code>posit_ids</code>), which describe the position of a node in the
<code>attr</code> vector, or by unique identifiers
(<code>unique_ids</code>), which allow references to nodes even after
they are deactivated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unique_ids(dat, posit_ids = NULL)

get_posit_ids(dat, unique_ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_id-tools_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="unique_id-tools_+3A_posit_ids">posit_ids</code></td>
<td>
<p>A vector of node positional identifiers (default = NULL).</p>
</td></tr>
<tr><td><code id="unique_id-tools_+3A_unique_ids">unique_ids</code></td>
<td>
<p>A vector of node unique identifiers (default = NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of unique or positional identifiers.
</p>


<h3>All elements</h3>

<p>When <code>unique_ids</code> or <code>posit_ids</code> is NULL (default)
the full list of positional IDs or unique IDs is returned.
</p>


<h3>Deactivated nodes</h3>

<p>When providing <code>unique_ids</code> of deactivated nodes to
<code>get_posit_ids</code>, <code>NA</code>s are returned instead and a warning is
produced.
</p>

<hr>
<h2 id='update_cumulative_edgelist'>Update a Cumulative Edgelist of the Specified Network</h2><span id='topic+update_cumulative_edgelist'></span>

<h3>Description</h3>

<p>Update a Cumulative Edgelist of the Specified Network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_cumulative_edgelist(dat, network, truncate = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_cumulative_edgelist_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="update_cumulative_edgelist_+3A_network">network</code></td>
<td>
<p>Numerical index of the network for which the cumulative
edgelist will be updated. (May be &gt; 1 for models with
multiple overlapping networks.)</p>
</td></tr>
<tr><td><code id="update_cumulative_edgelist_+3A_truncate">truncate</code></td>
<td>
<p>After how many time steps a partnership that is no longer
active should be removed from the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>


<h3>Truncation</h3>

<p>To avoid storing a cumulative edgelist too long, the <code>truncate</code>
parameter defines a number of steps after which an edge that is no longer
active is truncated out of the cumulative edgelist.
When <code>truncate = Inf</code>, no edges are ever removed. When
<code>truncate = 0</code>, only the active edges are kept. You may want this
behavior to keep track of the active edges' start step.
</p>

<hr>
<h2 id='update_dissolution'>Adjust Dissolution Component of Network Model Fit</h2><span id='topic+update_dissolution'></span>

<h3>Description</h3>

<p>Adjusts the dissolution component of a dynamic ERGM fit using
the <code><a href="#topic+netest">netest</a></code> function with the edges dissolution
approximation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_dissolution(old.netest, new.coef.diss, nested.edapprox = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_dissolution_+3A_old.netest">old.netest</code></td>
<td>
<p>An object of class <code>netest</code>, from the
<code><a href="#topic+netest">netest</a></code> function.</p>
</td></tr>
<tr><td><code id="update_dissolution_+3A_new.coef.diss">new.coef.diss</code></td>
<td>
<p>An object of class <code>disscoef</code>, from the
<code><a href="#topic+dissolution_coefs">dissolution_coefs</a></code> function.</p>
</td></tr>
<tr><td><code id="update_dissolution_+3A_nested.edapprox">nested.edapprox</code></td>
<td>
<p>Logical. If <code>edapprox = TRUE</code> the dissolution
model is an initial segment of the formation model (see details in
<code><a href="#topic+netest">netest</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitting an ERGM is a computationally intensive process when the model
includes dyad dependent terms. With the edges dissolution approximation
method of Carnegie et al, the coefficients for a temporal ERGM are
approximated by fitting a static ERGM and adjusting the formation
coefficients to account for edge dissolution. This function provides a very
efficient method to adjust the coefficients of that model when one wants to
use a different dissolution model; a typical use case may be to fit several
different models with different average edge durations as targets. The
example below exhibits that case.
</p>


<h3>Value</h3>

<p>An updated network model object of class <code>netest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nw &lt;- network_initialize(n = 1000)

# Two dissolutions: an average duration of 300 versus 200
diss.300 &lt;- dissolution_coefs(~offset(edges), 300, 0.001)
diss.200 &lt;- dissolution_coefs(~offset(edges), 200, 0.001)

# Fit the two reference models
est300 &lt;- netest(nw = nw,
                formation = ~edges,
                target.stats = c(500),
                coef.diss = diss.300)

est200 &lt;- netest(nw = nw,
                formation = ~edges,
                target.stats = c(500),
                coef.diss = diss.200)

# Alternatively, update the 300 model with the 200 coefficients
est200.compare &lt;- update_dissolution(est300, diss.200)

identical(est200$coef.form, est200.compare$coef.form)

## End(Not run)

</code></pre>

<hr>
<h2 id='update_list'>Update List <code>x</code> Using the Elements of List <code>new.x</code>.</h2><span id='topic+update_list'></span>

<h3>Description</h3>

<p>Update List <code>x</code> Using the Elements of List <code>new.x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_list(x, new.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_list_+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="update_list_+3A_new.x">new.x</code></td>
<td>
<p>A list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function updates list <code>x</code> by name. If <code>x</code> and <code>new.x</code>
elements are not named, the function will not work properly. If a function is
provided to replace an element that was originally not a function, this
function will be applied to the original value.
</p>


<h3>Value</h3>

<p>The full <code>x</code> list with the modifications added by <code>new.x</code>.
</p>

<hr>
<h2 id='update_params'>Update Model Parameters for Stochastic Network Models</h2><span id='topic+update_params'></span>

<h3>Description</h3>

<p>Updates epidemic model parameters originally set with
<code><a href="#topic+param.net">param.net</a></code> and adds new parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_params(param, new.param.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_params_+3A_param">param</code></td>
<td>
<p>Object of class <code>param.net</code>, output from function of same
name.</p>
</td></tr>
<tr><td><code id="update_params_+3A_new.param.list">new.param.list</code></td>
<td>
<p>Named list of new parameters to add to original
parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can update any original parameters specified with
<code><a href="#topic+param.net">param.net</a></code> and add new parameters. This function would be used
if the inputs to <code><a href="#topic+param.net">param.net</a></code> were a long list of fixed model
parameters that needed supplemental replacements or additions for particular
model runs (e.g., changing an intervention efficacy parameter but leaving all
other parameters fixed).
</p>
<p>The <code>new.param.list</code> object should be a named list object containing
named parameters matching those already in <code>x</code> (in which case those
original parameter values will be replaced) or not matching (in which case
new parameters will be added to <code>param</code>).
</p>


<h3>Value</h3>

<p>An updated list object of class <code>param.net</code>, which can be passed to the
EpiModel function <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- param.net(inf.prob = 0.5, act.rate = 2)
y &lt;- list(inf.prob = 0.75, dx.rate = 0.2)
z &lt;- update_params(x, y)
print(z)

</code></pre>

<hr>
<h2 id='update_unique_ids'>Create the Unique Identifiers for New Nodes</h2><span id='topic+update_unique_ids'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+append_core_attr">append_core_attr</a></code> and
appends new <code>unique_ids</code> to the created nodes. It also keeps track of
the already used <code>unique_ids</code> with the <code>dat[["_last_unique_id"]]</code>
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_unique_ids(dat, n.new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_unique_ids_+3A_dat">dat</code></td>
<td>
<p>Main <code>netsim_dat</code> object containing a <code>networkDynamic</code>
object and other initialization information passed from
<code><a href="#topic+netsim">netsim</a></code>.</p>
</td></tr>
<tr><td><code id="update_unique_ids_+3A_n.new">n.new</code></td>
<td>
<p>The number of new nodes to give <code>unique_ids</code> to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>netsim_dat</code> main list object.
</p>

<hr>
<h2 id='use_scenario'>Apply a scenario object to a param.net object</h2><span id='topic+use_scenario'></span>

<h3>Description</h3>

<p>Apply a scenario object to a param.net object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_scenario(param, scenario)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_scenario_+3A_param">param</code></td>
<td>
<p>Object of class <code>param.net</code>, output from function of same
name.</p>
</td></tr>
<tr><td><code id="use_scenario_+3A_scenario">scenario</code></td>
<td>
<p>a scenario object usually created from a <code>data.frame</code> of
scenarios using the <code>create_scenario_list</code> function. See the vignette
&quot;network-model-scenarios&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated list object of class <code>param.net</code>, which can be passed to the
EpiModel function <code><a href="#topic+netsim">netsim</a></code>.
</p>


<h3>scenario</h3>

<p>A scenario is a list containing an &quot;id&quot; field, the name of the scenario and
a &quot;.param.updater.list&quot; containing a list of updaters that modifies the
parameters of the model at given time steps. If a scenario contains a
parameter not defined in the <code>param</code> object, an error will be produced.
See the vignette &quot;model-parameters&quot; for the technical detail of their
implementation.
</p>

<hr>
<h2 id='verbose.dcm'>Progress Print Module for Deterministic Compartmental Models</h2><span id='topic+verbose.dcm'></span>

<h3>Description</h3>

<p>This function prints progress from deterministic compartmental
models simulated with <code><a href="#topic+dcm">dcm</a></code> to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbose.dcm(x, type, s = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbose.dcm_+3A_x">x</code></td>
<td>
<p>If the <code>type</code> is &quot;startup&quot;, then an object of class
<code>control.dcm</code>, otherwise the main <code>df</code> object in <code>dcm</code>
runs.</p>
</td></tr>
<tr><td><code id="verbose.dcm_+3A_type">type</code></td>
<td>
<p>Progress type, either of &quot;startup&quot; for starting messages before
all runs, or &quot;progress&quot; for time step specific messages.</p>
</td></tr>
<tr><td><code id="verbose.dcm_+3A_s">s</code></td>
<td>
<p>Current run number, if type is &quot;progress&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='verbose.icm'>Progress Print Module for Stochastic Individual Contact Models</h2><span id='topic+verbose.icm'></span>

<h3>Description</h3>

<p>This function prints progress from stochastic individual contact
models simulated with <code><a href="#topic+icm">icm</a></code> to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbose.icm(x, type, s = 1, at = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbose.icm_+3A_x">x</code></td>
<td>
<p>If the <code>type</code> is &quot;startup&quot;, then an object of class
<code>control.icm</code>; otherwise, an object of class <code>icm_dat</code>, the
main data object in <code>icm</code> simulations.</p>
</td></tr>
<tr><td><code id="verbose.icm_+3A_type">type</code></td>
<td>
<p>Progress type, either of &quot;startup&quot; for starting messages before
all simulations, or &quot;progress&quot; for time step specific messages.</p>
</td></tr>
<tr><td><code id="verbose.icm_+3A_s">s</code></td>
<td>
<p>Current simulation number, if type is &quot;progress&quot;.</p>
</td></tr>
<tr><td><code id="verbose.icm_+3A_at">at</code></td>
<td>
<p>Current time step, if type is &quot;progress&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='verbose.net'>Progress Print Module for Stochastic Network Models</h2><span id='topic+verbose.net'></span>

<h3>Description</h3>

<p>This function prints progress from stochastic network models
simulated with <code><a href="#topic+netsim">netsim</a></code> to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbose.net(x, type, s = 1, at = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbose.net_+3A_x">x</code></td>
<td>
<p>If the <code>type</code> is &quot;startup&quot;, then an object of class
<code>control.net</code>; otherwise, an object of class <code>netsim_dat</code>,
the main data object in <code><a href="#topic+netsim">netsim</a></code> simulations.</p>
</td></tr>
<tr><td><code id="verbose.net_+3A_type">type</code></td>
<td>
<p>Progress type, either of &quot;startup&quot; for starting messages before
all simulations, or &quot;progress&quot; for time step specific messages.</p>
</td></tr>
<tr><td><code id="verbose.net_+3A_s">s</code></td>
<td>
<p>Current simulation number, if type is &quot;progress&quot;.</p>
</td></tr>
<tr><td><code id="verbose.net_+3A_at">at</code></td>
<td>
<p>Current time step, if type is &quot;progress&quot;.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
