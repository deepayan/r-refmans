<!DOCTYPE html><html lang="en"><head><title>Help for package splithalfr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splithalfr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#splithalfr'><p>splithalfr: Split-Half Reliabilities</p></a></li>
<li><a href='#angoff_feldt'><p>Calculate Angoff-Feldt coefficient</p></a></li>
<li><a href='#apply_split_indexes_to_strata'><p>Split each element of a list of strata based on a list of indexes</p></a></li>
<li><a href='#apply_split_indexes_to_stratum'><p>Split a stratum based on a list of indexes</p></a></li>
<li><a href='#assmd'><p>Calculate Absolute Strictly Standardized Mean Difference (ASSMD)</p></a></li>
<li><a href='#by_split'><p>Calculate split scores per participant</p></a></li>
<li><a href='#check_strata'><p>Check whether two strata have the same structure</p></a></li>
<li><a href='#ds_aat'><p>Example Approach Avoidance Task (AAT) Measurement Data in JASMIN2 Format</p></a></li>
<li><a href='#ds_gng'><p>Example Go/No Go data</p></a></li>
<li><a href='#ds_iat'><p>Example Implicit Association Task (IAT) Data in JASMIN2 Format</p></a></li>
<li><a href='#ds_rapi'><p>Example 23-item Rutgers Alcohol Problem Inventory (RAPI) data</p></a></li>
<li><a href='#ds_sst'><p>Example Stop Signal Task data</p></a></li>
<li><a href='#ds_vpt'><p>Example Visual Probe Task (VPT) Measurement Data in JASMIN1 Format</p></a></li>
<li><a href='#flanagan_rulon'><p>Calculate Flanagon-Rulon coefficient</p></a></li>
<li><a href='#get_split_indexes_from_strata'><p>Generate indexes for splitting strata</p></a></li>
<li><a href='#get_split_indexes_from_stratum'><p>Generate indexes that can be used to split a stratum into two parts</p></a></li>
<li><a href='#sdregi'><p>SD ratio of equalities or greater inequalities</p></a></li>
<li><a href='#short_icc'><p>Calculate Intraclass Correlation Coefficient (ICC)</p></a></li>
<li><a href='#spearman_brown'><p>Calculate Spearman-brown coefficient</p></a></li>
<li><a href='#split_ci'><p>Calculate nonparametric bias-corrected and accelerated bootstrap confidence</p>
intervals for coefficients averaged across split replications</a></li>
<li><a href='#split_coefs'><p>Calculate a bivariate coefficient for each split-half replication</p></a></li>
<li><a href='#split_df'><p>Split a data frame into two parts</p></a></li>
<li><a href='#split_strata'><p>Split each stratum into two parts</p></a></li>
<li><a href='#split_stratum'><p>Split a stratum into two parts</p></a></li>
<li><a href='#stratify'><p>Stratify a data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Estimate Split-Half Reliabilities</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Pronk [aut, cre]</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates split-half reliabilities for scoring algorithms of cognitive tasks and questionnaires. The 'splithalfr' supports researcher-provided scoring algorithms, with six vignettes illustrating how on included datasets. The package provides four splitting methods (first-second, odd-even, permutated, Monte Carlo), the option to stratify splits by task design, a number of reliability coefficients, and the option to sub-sample data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.20), rmarkdown (&ge; 1.10), testthat (&ge; 2.1.0),
MASS (&ge; 7.3.51)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.7), tibble (&ge; 2.1.1), psych (&ge; 1.8.12),
bcaboot (&ge; 0.2.1), rlang (&ge; 0.4.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tpronk/splithalfr">https://github.com/tpronk/splithalfr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tpronk/splithalfr/issues">https://github.com/tpronk/splithalfr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-14 14:17:40 UTC; Thomas</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Pronk &lt;pronkthomas@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-14 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='splithalfr'>splithalfr: Split-Half Reliabilities</h2><span id='topic+splithalfr'></span><span id='topic+splithalfr-package'></span>

<h3>Description</h3>

<p>Estimates split-half reliabilities for scoring algorithms of cognitive tasks and questionnaires.
</p>


<h3>Getting started</h3>

<p>We've got six short vignettes to help you get started. You can open a vignette bij running the corresponding code snippets (<code>vignette(...)</code>) in the R console.
</p>

<ul>
<li> <p><code>vignette("rapi_sum")</code> Sum-score for data of the 23-item version of the Rutgers Alcohol Problem Index (<a href="https://doi.org/10.15288/jsa.1989.50.30">doi:10.15288/jsa.1989.50.30</a>White &amp; Labouvie, 1989)
</p>
</li>
<li> <p><code>vignette("vpt_diff_of_means")</code> Difference of mean RTs for correct responses, after removing RTs below 200 ms and above 520 ms, on Visual Probe Task data (Mogg &amp; Bradley, 1999 &lt;<a href="https://doi.org/10.1080/026999399379050">doi:10.1080/026999399379050</a>&gt;)
</p>
</li>
<li> <p><code>vignette("aat_double_diff_of_medians")</code> Double difference of medians for correct responses on Approach Avoidance Task data (Heuer, Rinck, &amp; Becker, 2007 &lt;<a href="https://doi.org/10.1016/j.brat.2007.08.010">doi:10.1016/j.brat.2007.08.010</a>&gt;)
</p>
</li>
<li> <p><code>vignette("iat_dscore_ri")</code> Improved d-score algorithm for data of an Implicit Association Task that requires a correct response in order to continue to the next trial (<a href="https://pubmed.ncbi.nlm.nih.gov/12916565/">Greenwald, Nosek, &amp; Banaji, 2003</a>)
</p>
</li>
<li> <p><code>vignette("sst_ssrti")</code> Stop-Signal Reaction Time integration method for data of a Stop Signal Task (<a href="http://www.psy.vanderbilt.edu/faculty/logan/Logan(1981).pdf">Logan, 1981</a>)
</p>
</li>
<li> <p><code>vignette("gng_dprime")</code> D-prime for data of a Go/No Go task (Miller, 1996 &lt;<a href="https://doi.org/10.3758/BF03205476">doi:10.3758/BF03205476</a>&gt;)
</p>
</li></ul>



<h3>Splitting methods</h3>

<p>The splithalfr supports a variety of methods for splitting your data. We review and assess each  method in the compendium paper (Pronk et al., 2021 &lt;<a href="https://doi.org/10.3758/s13423-021-01948-3">doi:10.3758/s13423-021-01948-3</a>&gt;). This vignette illustrates how to apply each splitting method via the splithalfr: <code>vignette("splitting_methods")</code>
</p>

<ul>
<li><p> first-second and odd-even (Green et al., 2016 &lt;<a href="https://doi.org/10.3758/s13423-015-0968-3">doi:10.3758/s13423-015-0968-3</a>&gt;; Webb, Shavelson, &amp; Haertel, 1996 &lt;<a href="https://doi.org/10.1016/S0169-7161%2806%2926004-8">doi:10.1016/S0169-7161(06)26004-8</a>&gt;; Williams &amp; Kaufmann, 2012 &lt;<a href="https://doi.org/10.1016/j.jesp.2012.03.001">doi:10.1016/j.jesp.2012.03.001</a>&gt;)
</p>
</li>
<li><p> stratified (Green et al., 2016 &lt;<a href="https://doi.org/10.3758/s13423-015-0968-3">doi:10.3758/s13423-015-0968-3</a>&gt;)
</p>
</li>
<li><p> permutated/bootstrapped/random sample of split halves (Kopp, Lange, &amp; Steinke, 2021 &lt;<a href="https://doi.org/10.1177/1073191119866257">doi:10.1177/1073191119866257</a>&gt;, Parsons, Kruijt, &amp; Fox, 2019 &lt;<a href="https://doi.org/10.1177/2515245919879695">doi:10.1177/2515245919879695</a>&gt;; Williams &amp; Kaufmann, 2012 &lt;<a href="https://doi.org/10.1016/j.jesp.2012.03.001">doi:10.1016/j.jesp.2012.03.001</a>&gt;)
</p>
</li>
<li><p> Monte Carlo (Williams &amp; Kaufmann, 2012 &lt;<a href="https://doi.org/10.1016/j.jesp.2012.03.001">doi:10.1016/j.jesp.2012.03.001</a>&gt;)
</p>
</li></ul>



<h3>Validation of split-half estimations</h3>

<p>Part of the splithalfr algorithm has been validated via a set of simulations that are not included in this package.
The R script for these simulations can be found <a href="https://github.com/tpronk/splithalfr_simulation">here</a>.
</p>


<h3>Related packages</h3>

<p>These R packages offer bootstrapped split-half reliabilities for specific scoring algorithms and are available via CRAN at 
the time of this writing: 
<a href="https://cran.r-project.org/package=multicon">multicon</a>, 
<a href="https://cran.r-project.org/package=psych">psych</a>, and
<a href="https://cran.r-project.org/package=splithalf">splithalf</a>.
</p>


<h3>Acknowledgments</h3>

<p>I would like to thank 
Craig Hedge,
Eva Schmitz,
Fadie Hanna,
<a href="https://scholar.google.com/citations?user=ugPnkjEAAAAJ&amp;hl=en">Helle Larsen</a>,
Marilisa Boffo, and
Marjolein Zee
for making datasets available for inclusion in the splithalfr.
Additionally, I would like to thank 
Craig Hedge and 
<a href="https://www.swinburne.edu.au/research/our-research/access-our-research/find-a-researcher-or-supervisor/researcher-profile/?id=bwilliams">Benedict Williams</a>
for sharing R-scripts with scoring algorithms that were adapted for splithalfr vignettes. 
Finally, I would like to thank Mae Nuijs and Sera-Maren Wiechert for spotting bugs in earlier versions of this package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Pronk <a href="mailto:pronkthomas@gmail.com">pronkthomas@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tpronk/splithalfr">https://github.com/tpronk/splithalfr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tpronk/splithalfr/issues">https://github.com/tpronk/splithalfr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='angoff_feldt'>Calculate Angoff-Feldt coefficient</h2><span id='topic+angoff_feldt'></span>

<h3>Description</h3>

<p>Angoff-Feldt reliability coefficient.
Formula obtained from Warrens (2015) &lt;<a href="https://doi.org/10.1007/s11634-015-0198-6">doi:10.1007/s11634-015-0198-6</a>&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angoff_feldt(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angoff_feldt_+3A_x">x</code></td>
<td>
<p>(vector) a numeric vector</p>
</td></tr>
<tr><td><code id="angoff_feldt_+3A_y">y</code></td>
<td>
<p>(vector) a numeric vector with compatible dimensions to x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) Angoff-Feldt cefficient
</p>


<h3>See Also</h3>

<p>Other splithalfr coefficients: 
<code><a href="#topic+assmd">assmd</a>()</code>,
<code><a href="#topic+flanagan_rulon">flanagan_rulon</a>()</code>,
<code><a href="#topic+sdregi">sdregi</a>()</code>,
<code><a href="#topic+short_icc">short_icc</a>()</code>,
<code><a href="#topic+spearman_brown">spearman_brown</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two variables with different means, variances and a correlation of about 0.5
library(MASS)
vars = mvrnorm(30, mu = c(0, 2), Sigma = matrix(c(5, 2, 2, 3), ncol = 2), empirical = TRUE)
# Calculate coefficient
angoff_feldt(vars[,1], vars[,2])
</code></pre>

<hr>
<h2 id='apply_split_indexes_to_strata'>Split each element of a list of strata based on a list of indexes</h2><span id='topic+apply_split_indexes_to_strata'></span>

<h3>Description</h3>

<p>Splits each element of <code>strata</code> into two parts based on a list of
indexes. For more information about splitting options, and an extensive list
of examples, see <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_split_indexes_to_strata(strata, indexes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_split_indexes_to_strata_+3A_strata">strata</code></td>
<td>
<p>(list) list of strata to split</p>
</td></tr>
<tr><td><code id="apply_split_indexes_to_strata_+3A_indexes">indexes</code></td>
<td>
<p>(list) list of indexes, which can be generated via
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) A list with two elements, containing the first and second
split of <code>strata</code>.
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_stratum">apply_split_indexes_to_stratum</a>()</code>,
<code><a href="#topic+check_strata">check_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a>()</code>,
<code><a href="#topic+split_df">split_df</a>()</code>,
<code><a href="#topic+split_strata">split_strata</a>()</code>,
<code><a href="#topic+split_stratum">split_stratum</a>()</code>,
<code><a href="#topic+stratify">stratify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stratify a data frame, then split it odd-even
ds &lt;- data.frame(condition = rep(c("a", "b"), each = 4), score = 1 : 8)
strata &lt;- stratify(ds, ds$condition)
split_indexes &lt;- get_split_indexes_from_strata(strata, method = "odd_even")
apply_split_indexes_to_strata(strata, split_indexes)
</code></pre>

<hr>
<h2 id='apply_split_indexes_to_stratum'>Split a stratum based on a list of indexes</h2><span id='topic+apply_split_indexes_to_stratum'></span>

<h3>Description</h3>

<p>Splits <code>stratum</code> into two parts based on a list of indexes.  For more information
about splitting options, and an extensive list of examples, see
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_split_indexes_to_stratum(stratum, indexes_1, indexes_2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_split_indexes_to_stratum_+3A_stratum">stratum</code></td>
<td>
<p>(data frame, tibble, list, or vector) stratum to split</p>
</td></tr>
<tr><td><code id="apply_split_indexes_to_stratum_+3A_indexes_1">indexes_1</code></td>
<td>
<p>(vector) indexes for first split, which can be generated via <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code></p>
</td></tr>
<tr><td><code id="apply_split_indexes_to_stratum_+3A_indexes_2">indexes_2</code></td>
<td>
<p>(vector) indexes for second split, which can be generated via <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) List with two elements that contain stratum split in two parts.
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_strata">apply_split_indexes_to_strata</a>()</code>,
<code><a href="#topic+check_strata">check_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a>()</code>,
<code><a href="#topic+split_df">split_df</a>()</code>,
<code><a href="#topic+split_strata">split_strata</a>()</code>,
<code><a href="#topic+split_stratum">split_stratum</a>()</code>,
<code><a href="#topic+stratify">stratify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Random split-half. One of the splits gets 4 elements and the other 5
stratum =  letters[1:9]
indexes = get_split_indexes_from_stratum(stratum)
apply_split_indexes_to_stratum(stratum, indexes[[1]], indexes[[2]])
</code></pre>

<hr>
<h2 id='assmd'>Calculate Absolute Strictly Standardized Mean Difference (ASSMD)</h2><span id='topic+assmd'></span>

<h3>Description</h3>

<p>Returns the absolute difference of the mean of <code>x</code> and <code>y</code> 
divided by their shared standard deviation. Since the resulting difference 
is absolute, the larger of the two means is always used as minuend and the
smallest as subtrahend. Based on 
Zhang (2012) &lt;<a href="https://doi.org/10.1016/j.ygeno.2006.12.014">doi:10.1016/j.ygeno.2006.12.014</a>&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assmd(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assmd_+3A_x">x</code></td>
<td>
<p>(vector) a numeric vector</p>
</td></tr>
<tr><td><code id="assmd_+3A_y">y</code></td>
<td>
<p>(vector) a numeric vector with compatible dimensions to x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) Absolute SSMD
</p>


<h3>See Also</h3>

<p>Other splithalfr coefficients: 
<code><a href="#topic+angoff_feldt">angoff_feldt</a>()</code>,
<code><a href="#topic+flanagan_rulon">flanagan_rulon</a>()</code>,
<code><a href="#topic+sdregi">sdregi</a>()</code>,
<code><a href="#topic+short_icc">short_icc</a>()</code>,
<code><a href="#topic+spearman_brown">spearman_brown</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two variables with different means, variances and a correlation of about 0.5
library(MASS)
vars = mvrnorm(30, mu = c(0, 2), Sigma = matrix(c(5, 2, 2, 3), ncol = 2), empirical = TRUE)
# Calculate Absolute SSMD
assmd(vars[,1], vars[,2])
</code></pre>

<hr>
<h2 id='by_split'>Calculate split scores per participant</h2><span id='topic+by_split'></span>

<h3>Description</h3>

<p>Calculates split scores, by applying <code>fn_score</code> to subsets of
<code>data</code> as specified via <code>participants</code>. It provides a range of
additional arguments for different splitting methods and to support parallel
processing. To learn more about writing scoring algorithms for use with the
<code><a href="#topic+splithalfr">splithalfr</a></code>, see the included vignettes. <code><a href="#topic+by_split">by_split</a></code>
is modeled after the <code><a href="base.html#topic+by">by</a></code> function, accepting similar values for
the first three arguments (<code>data</code>, <code>INDICES</code>, <code>FUN</code>). For more
information about different metods for splitting data, see
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>. For more information about 
stratification, see <code><a href="#topic+split_df">split_df</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_split(
  data,
  participants,
  fn_score,
  stratification = NULL,
  replications = 1,
  method = c("random", "odd_even", "first_second"),
  replace = FALSE,
  split_p = 0.5,
  subsample_p = 1,
  subsample_n = NULL,
  careful = TRUE,
  match_participants = FALSE,
  ncores = detectCores(),
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by_split_+3A_data">data</code></td>
<td>
<p>(data frame) data frame containing data to score. Data should be
in long format, with one row per combination of participant and trial or
item.</p>
</td></tr>
<tr><td><code id="by_split_+3A_participants">participants</code></td>
<td>
<p>(vector) Vector that identifies participants in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="by_split_+3A_fn_score">fn_score</code></td>
<td>
<p>(function) receives full or split sets, should return a
single number.</p>
</td></tr>
<tr><td><code id="by_split_+3A_stratification">stratification</code></td>
<td>
<p>(vector). Vector that identifies which subsets of
<code>data</code> should be split separately (denoted as strata in splitting
functions) in order to ensure they are evenly distributed between parts.
By default, the dataset of a participant formes a single stratum.</p>
</td></tr>
<tr><td><code id="by_split_+3A_replications">replications</code></td>
<td>
<p>(numeric) Number of replications that split scores are
calculated.</p>
</td></tr>
<tr><td><code id="by_split_+3A_method">method</code></td>
<td>
<p>(character) Splitting method. Note that <code>first_second</code> and
<code>odd_even</code> splitting method will only deliver a valid split with
default settings for other arguments (<code>split_p = 0.5, replace = FALSE,
subsample_p = 1</code>)</p>
</td></tr>
<tr><td><code id="by_split_+3A_replace">replace</code></td>
<td>
<p>(logical) If TRUE, stratum is sampled with replacement.</p>
</td></tr>
<tr><td><code id="by_split_+3A_split_p">split_p</code></td>
<td>
<p>(numeric) Desired length of both parts, expressed as a
proportion of the length of the data per participant. If <code>split_p</code>
is larger than 1 and <code>careful</code> is FALSE, then parts are automatically
sampled with replacement</p>
</td></tr>
<tr><td><code id="by_split_+3A_subsample_p">subsample_p</code></td>
<td>
<p>(numeric) Subsample a proportion of <code>stratum</code> before
splitting.</p>
</td></tr>
<tr><td><code id="by_split_+3A_subsample_n">subsample_n</code></td>
<td>
<p>(numeric) Subsample a number of participants before
splitting.</p>
</td></tr>
<tr><td><code id="by_split_+3A_careful">careful</code></td>
<td>
<p>(boolean) If TRUE, stop with an error when called with
arguments that may yield unexpected splits</p>
</td></tr>
<tr><td><code id="by_split_+3A_match_participants">match_participants</code></td>
<td>
<p>(logical) Default FALSE. If FALSE, the split-halves
are newly randomized for each iteration and participant. If TRUE, the
split-halves are newly randomized for each replication, but within a
replication the same randomization is applied across participants. If the
order of rows of datasets per participant denotes similar observations
(such as items in a questionnaire), <code>match_participants</code> can be set to
TRUE to ensure that per iteration, the same items are assigned to each part
of the split-halves across participants. If <code>method</code> is &quot;odd_even&quot; or
&quot;first_second&quot;, splits are based on row number, so
<code>match_participants</code> generally has little effects. If TRUE, each 
stratum
should have the same number of rows, as checked via 
<code><a href="#topic+check_strata">check_strata</a></code>.</p>
</td></tr>
<tr><td><code id="by_split_+3A_ncores">ncores</code></td>
<td>
<p>(integer). By default, all available CPU cores are used. If 1,
split replications are executed serially (via <code><a href="base.html#topic+lapply">lapply</a></code>). If
greater than 1, split replications are executed in parallel, via (via
<code><a href="parallel.html#topic+parLapply">parLapply</a></code>).</p>
</td></tr>
<tr><td><code id="by_split_+3A_seed">seed</code></td>
<td>
<p>(integer). When split replications are exectured in parallel,
<code>seed</code> can be used to specificy a random seet to generate random seeds
from for each worker via <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
<tr><td><code id="by_split_+3A_verbose">verbose</code></td>
<td>
<p>(logical) If TRUE, reports progress. Note that progress across
split replications is not displayed when these are executed in parallel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(data frame) Returns a data frame with a column for
<code>participant</code>, a column <code>replication</code> that counts split
replications, and <code>score_1</code> and <code>score_2</code> for the score
calculated of each part via <code>fn_score</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># N.B. This example uses R script from the vignette: "rapi_sum"
data("ds_rapi", package = "splithalfr")
# Convert to long format
ds_long &lt;- reshape(
  ds_rapi,
  varying = paste("V", 1 : 23, sep = ""),
  v.names = "answer",
  direction = "long",
  idvar = "twnr",
  timevar = "item"
)
# Function for RAPI sum score
rapi_fn_score &lt;- function (data) {
  return (sum(data$answer))
}
# Calculate scores on full data
by(
  ds_long,
  ds_long$twnr,
  rapi_fn_score
)
# Permutation split, one iteration, items matched across participants
split_scores &lt;- by_split(
  ds_long,
  ds_long$twnr,
  rapi_fn_score,
  ncores = 1,
  match_participants = TRUE
)
# Mean flanagan-rulon coefficient across splits
fr &lt;- mean(split_coefs(split_scores, flanagan_rulon))
</code></pre>

<hr>
<h2 id='check_strata'>Check whether two strata have the same structure</h2><span id='topic+check_strata'></span>

<h3>Description</h3>

<p>Checks <code>strata</code> against <code>strata_left</code>. Each element of
<code>strata_left</code> should also be present in <code>strata</code>, be of a similar
type (data frame/tibble or list/vector), and be of similar size
(<code><a href="base.html#topic+nrow">nrow</a></code> for data frames/tibbles or <code><a href="base.html#topic+length">length</a></code> for
lists/vectors). Stops with an arror if any checks fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_strata(strata_left, strata_right)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_strata_+3A_strata_left">strata_left</code></td>
<td>
<p>(list) strata to check against</p>
</td></tr>
<tr><td><code id="check_strata_+3A_strata_right">strata_right</code></td>
<td>
<p>(list) strata to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_strata">apply_split_indexes_to_strata</a>()</code>,
<code><a href="#topic+apply_split_indexes_to_stratum">apply_split_indexes_to_stratum</a>()</code>,
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a>()</code>,
<code><a href="#topic+split_df">split_df</a>()</code>,
<code><a href="#topic+split_strata">split_strata</a>()</code>,
<code><a href="#topic+split_stratum">split_stratum</a>()</code>,
<code><a href="#topic+stratify">stratify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_strata(list(1 : 4), list(1 : 4))
</code></pre>

<hr>
<h2 id='ds_aat'>Example Approach Avoidance Task (AAT) Measurement Data in JASMIN2 Format</h2><span id='topic+ds_aat'></span>

<h3>Description</h3>

<p>The JASMIN1 AAT was an irrelevant feature task, in which participants were instructed to
approach/avoid left/right rotated stimuli. This particular AAT was administered (and described in detail) in 
<a href="https://doi.org/10.1111/add.14071">doi:10.1111/add.14071</a>Boffo et al., 2018. Participants were presented stimuli from a &quot;test&quot;
category, which were gambling-related pictures, and from a &quot;control&quot; category, which were pictures unrelated
to gambling. It registered approach responses by participants pressing (and holding) the arrow down key,
while avoid responses were given via the arrow up key. Upon a response, the stimulus zoomed in or
out, until it disappeared from the screen. The first response to a stimulus was logged. 
The dataset contains one row per trial.
This dataset was graciously provided by Eva Schmitz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds_aat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 6528 rows and 12 columns.
</p>


<h3>Details</h3>

<p>Overview of columns:
</p>

<ul>
<li><p> UserID. Identifies participants
</p>
</li>
<li><p> approach_tilt. If &quot;left&quot;, participants were instructed to approach left rotated stimuli. If &quot;right&quot;, participants were instructed to approach right rotated stimuli.
</p>
</li>
<li><p> block_type. Type of block: &quot;practice&quot; for practice trials with neutral stimuli, &quot;assess&quot; for assessment trials with salient stimuli
</p>
</li>
<li><p> block. Counts blocks, starting at zero
</p>
</li>
<li><p> trial. Counts trials in blocks, starting at zero
</p>
</li>
<li><p> appr. If &quot;yes&quot;, this trial was an approach trial. If &quot;no&quot;, this trial was an avoid trial.
</p>
</li>
<li><p> tilt. Whether the stimulus was rotated to the &quot;left&quot; or to the &quot;right&quot;
</p>
</li>
<li><p> cat. Stimulus category: &quot;practice&quot;, &quot;test&quot;, or &quot;control&quot;
</p>
</li>
<li><p> stim. Stimulus ID
</p>
</li>
<li><p> response. Response; 1 = correct, 2 = incorrect, 3 = timeout (no response in 4000 ms), 4 = invalid key
</p>
</li>
<li><p> rt. Response time in milliseconds
</p>
</li>
<li><p> sust. Was approach or avoid response sustained until the stimulus was completely zoomed in or out?
</p>
</li></ul>


<hr>
<h2 id='ds_gng'>Example Go/No Go data</h2><span id='topic+ds_gng'></span>

<h3>Description</h3>

<p>The Go/No Go is a task in which participants respond to one set of stimuli, but withhold a response
to another set of stimuli. This particular dataset is from the first session of a study that is 
described in detail in <a href="https://doi.org/10.1016/j.tate.2019.102887">doi:10.1016/j.tate.2019.102887</a>Hedge, Powell, and Sumner (2018). 
It was graciously provided by Craig Hedge and can
be obtained from <a href="https://osf.io/cwzds">https://osf.io/cwzds</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds_gng
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 28200 rows and 7 columns.
</p>


<h3>Details</h3>

<p>Overview of columns:
</p>

<ul>
<li><p> block. Block number
</p>
</li>
<li><p> trial. Trial number
</p>
</li>
<li><p> stim. Stimuli set used in that block
</p>
</li>
<li><p> condition. 0 = go, 2 = no go
</p>
</li>
<li><p> response. Correct (1) or incorrect (0)
</p>
</li>
<li><p> rt. Reaction time (seconds)
</p>
</li>
<li><p> participant. Participant ID
</p>
</li></ul>


<hr>
<h2 id='ds_iat'>Example Implicit Association Task (IAT) Data in JASMIN2 Format</h2><span id='topic+ds_iat'></span>

<h3>Description</h3>

<p>The JASMIN2 IAT closely followed the original IAT procedure
(<a href="https://pubmed.ncbi.nlm.nih.gov/9654756/">Greenwald, McGhee, &amp; Schwartz, 1998</a>),
except that target and attribute trials did not alternate.  Upon a correct response, the next trial started.
Upon an incorrect response, the current trial was repeated. The response to each trial was logged.
This particular dataset is from a Ethnicity-Valence IAT, which was administered (and described in detail) in 
<a href="https://doi.org/10.1016/j.tate.2019.102887">doi:10.1016/j.tate.2019.102887</a>Abacioglu and colleagues (2019). 
This dataset was graciously provided by Fadie Hanna and Marjolein Zee.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds_iat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 9696 rows and 11 columns.
</p>


<h3>Details</h3>

<p>Overview of columns:
</p>

<ul>
<li><p> participation_id Identifies participants
</p>
</li>
<li><p> t1_left. If TRUE, the first combination block had target 1 on the left (and target 2 on the right)
</p>
</li>
<li><p> a1_left. If TRUE, the first combination block had attribute 1 on the left (and attribute 2 on the right)
</p>
</li>
<li><p> block_type. Type of block
</p>
</li>
<li><p> block. Counts blocks, starting at zero
</p>
</li>
<li><p> trial. Counts trials in blocks, starting at zero
</p>
</li>
<li><p> attempt. Counts attempts (responses) in trials, starting at zero
</p>
</li>
<li><p> cat. Category that stimulus belonged to
</p>
</li>
<li><p> stim. Stimulus
</p>
</li>
<li><p> response. Response; 1 = correct, 2 = incorrect, 3 = timeout (no response in 4000 ms), 4 = invalid key
</p>
</li>
<li><p> rt. Response time in milliseconds. Note that some response times may exceed the timeout window due to clock errors on the computer that the IAT was administered
</p>
</li></ul>

<p>The variable block_type can have these values:
</p>

<ul>
<li><p> tar_discr: target discrimination
</p>
</li>
<li><p> att_discr: attribute discrimination
</p>
</li>
<li><p> tar1att1_1: target 1 with attitude 1, practice block
</p>
</li>
<li><p> tar1att1_2: target 1 with attitude 1, test block
</p>
</li>
<li><p> tar_rev: reverse target discrimination
</p>
</li>
<li><p> tar1att2_1: target 1 with attitude 2, practice block
</p>
</li>
<li><p> tar1att2_2: target 1 with attitude 2, test block
</p>
</li></ul>


<hr>
<h2 id='ds_rapi'>Example 23-item Rutgers Alcohol Problem Inventory (RAPI) data</h2><span id='topic+ds_rapi'></span>

<h3>Description</h3>

<p>The RAPI is a questionnaire which asks how often a participant experienced each of 23 alcohol-related
problems within the last year (<a href="https://doi.org/10.15288/jsa.1989.50.30">doi:10.15288/jsa.1989.50.30</a>White &amp; Labouvie, 1989).
The dataset contains one row per participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds_rapi
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 426 rows and 24 columns.
</p>


<h3>Details</h3>

<p>The dataset contains the following columns:
</p>

<ul>
<li><p> twnr. Identifies participants
</p>
</li>
<li><p> V1 to V23. Answers on each of the 23 RAPI items
</p>
</li></ul>

<p>Each item is answered on a four-point scale with the following answer options:
</p>

<ul>
<li><p> 0 = None
</p>
</li>
<li><p> 1 = 1-2 times
</p>
</li>
<li><p> 2 = 3-5
</p>
</li>
<li><p> 3 = More than 5 times
</p>
</li></ul>


<hr>
<h2 id='ds_sst'>Example Stop Signal Task data</h2><span id='topic+ds_sst'></span>

<h3>Description</h3>

<p>The Stop Signal Task is a task in which participants responded whether a stimulus was a square or a circle.
On 25
This particular dataset is from the first session of a study that is 
described in detail in <a href="https://doi.org/10.1016/j.tate.2019.102887">doi:10.1016/j.tate.2019.102887</a>Hedge, Powell, and Sumner (2018). 
It was graciously provided by Craig Hedge and can
be obtained from <a href="https://osf.io/cwzds">https://osf.io/cwzds</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds_sst
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 27000 rows and 7 columns.
</p>


<h3>Details</h3>

<p>Overview of columns:
</p>

<ul>
<li><p> block. Block number
</p>
</li>
<li><p> trial. Trial number
</p>
</li>
<li><p> ssd. Stop signal delay
</p>
</li>
<li><p> condition. 0 = go, 1 = stop
</p>
</li>
<li><p> response. Correct (1) or incorrect (0)
</p>
</li>
<li><p> rt. Reaction time (milliseconds)
</p>
</li>
<li><p> participant. Participant ID
</p>
</li></ul>


<hr>
<h2 id='ds_vpt'>Example Visual Probe Task (VPT) Measurement Data in JASMIN1 Format</h2><span id='topic+ds_vpt'></span>

<h3>Description</h3>

<p>The JASMIN1 VPT distinguished between &quot;test&quot; stimuli, which are in some way assumed to be salient to the participant
and &quot;control&quot; stimuli, which are not. Test and control stimuli were presented in pairs, with
one left and one right, followed by a probe that was an arrow pointing up or down. Participants needed
to indicate whether the arrow pointed up or down. Upon a correct response the next trial started and
upon an incorrect response the current trial was repeated. Only the first response to a new trial was logged.
This particular VPT was part of the pre-measurement
of a cognitive bias modification study. The &quot;test&quot; stimuli were alcoholic beverages and the &quot;control&quot; stimuli
were non-alcoholic beverages, selected from the Amsterdam Beverage Picture Set
<a href="https://doi.org/10.1111/acer.12853">doi:10.1111/acer.12853</a>(Pronk, Deursen, Beraha, Larsen, &amp; Wiers, 2015).
The dataset contains one row per trial.
This dataset was graciously provided by Marilisa Boffo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds_vpt
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 19520 rows and 12 columns.
</p>


<h3>Details</h3>

<p>Overview of columns:
</p>

<ul>
<li><p> UserID. Identifies participants
</p>
</li>
<li><p> patt. Probe-at-test. If &quot;yes&quot;, the probe was positioned at the test stimulus. If &quot;no&quot;, the probe was positioned at the control stimulus.
</p>
</li>
<li><p> phor. Probe horizontal position. Values: &quot;left&quot; or &quot;right&quot;
</p>
</li>
<li><p> thor. Test horizontal position. Values: &quot;left&quot; or &quot;right&quot;
</p>
</li>
<li><p> keep. If &quot;yes&quot; the probe was superimposed on the stimuli. If &quot;no&quot; the probe replaced the stimuli.
</p>
</li>
<li><p> pdir. Probe direction. Values: &quot;up&quot; or &quot;down&quot;
</p>
</li>
<li><p> stim. Stimulus
</p>
</li>
<li><p> response. Response; 1 = correct, 2 = incorrect, 3 and NA = timeout (no response in 5000 ms), 4 = invalid key
</p>
</li>
<li><p> rt. Response time in milliseconds
</p>
</li>
<li><p> block. Counts blocks, starting at zero
</p>
</li>
<li><p> trial. Counts trials in blocks, starting at zero
</p>
</li>
<li><p> block_type. Type of block: &quot;assess&quot; for assessment trials with salient stimuli
</p>
</li></ul>


<hr>
<h2 id='flanagan_rulon'>Calculate Flanagon-Rulon coefficient</h2><span id='topic+flanagan_rulon'></span>

<h3>Description</h3>

<p>Flanagon-Rulon reliability coefficient. Formula obtained from
Warrens (2015) &lt;<a href="https://doi.org/10.1007/s11634-015-0198-6">doi:10.1007/s11634-015-0198-6</a>&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flanagan_rulon(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flanagan_rulon_+3A_x">x</code></td>
<td>
<p>(vector) a numeric vector</p>
</td></tr>
<tr><td><code id="flanagan_rulon_+3A_y">y</code></td>
<td>
<p>(vector) a numeric vector with compatible dimensions to x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) Flanagon-Rulon coefficient
</p>


<h3>See Also</h3>

<p>Other splithalfr coefficients: 
<code><a href="#topic+angoff_feldt">angoff_feldt</a>()</code>,
<code><a href="#topic+assmd">assmd</a>()</code>,
<code><a href="#topic+sdregi">sdregi</a>()</code>,
<code><a href="#topic+short_icc">short_icc</a>()</code>,
<code><a href="#topic+spearman_brown">spearman_brown</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two variables with different means, variances and a correlation of about 0.5
library(MASS)
vars = mvrnorm(30, mu = c(0, 2), Sigma = matrix(c(5, 2, 2, 3), ncol = 2), empirical = TRUE)
# Calculate coefficient
flanagan_rulon(vars[,1], vars[,2])
</code></pre>

<hr>
<h2 id='get_split_indexes_from_strata'>Generate indexes for splitting strata</h2><span id='topic+get_split_indexes_from_strata'></span>

<h3>Description</h3>

<p>Generates indexes for splitting each element of <code>strata</code> into two parts.
For more information about splitting options, and an extensive list of
examples, see <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_split_indexes_from_strata(strata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_split_indexes_from_strata_+3A_strata">strata</code></td>
<td>
<p>(list) Strata to split</p>
</td></tr>
<tr><td><code id="get_split_indexes_from_strata_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>
</p>

<dl>
<dt><code>method</code></dt><dd><p>(character) Splitting method. Note that <code>first_second</code> and
<code>odd_even</code> splitting method will only deliver a valid split with
default settings for other arguments (<code>subsample_p = 1, split_p = 1,
replace = TRUE</code>)</p>
</dd>
<dt><code>replace</code></dt><dd><p>(logical) If FALSE, splits are constructed by sampling from
stratum without replacement. If TRUE, stratum is sampled with replacement.</p>
</dd>
<dt><code>split_p</code></dt><dd><p>(numeric) Desired joint size of both parts, expressed as a
proportion of the size of the subsampled <code>stratum</code>. If <code>split_p</code>
is larger than 1, and <code>careful</code> is FALSE, then parts are automatically
sampled with replacement</p>
</dd>
<dt><code>subsample_p</code></dt><dd><p>(numeric) Subsample a proportion of <code>stratum</code> to be
used in the split.</p>
</dd>
<dt><code>careful</code></dt><dd><p>(boolean) If TRUE, stop with an error when called with
arguments that may yield unexpected splits</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) A list with two elements, containing the first and second part
of <code>strata</code>.
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_strata">apply_split_indexes_to_strata</a>()</code>,
<code><a href="#topic+apply_split_indexes_to_stratum">apply_split_indexes_to_stratum</a>()</code>,
<code><a href="#topic+check_strata">check_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a>()</code>,
<code><a href="#topic+split_df">split_df</a>()</code>,
<code><a href="#topic+split_strata">split_strata</a>()</code>,
<code><a href="#topic+split_stratum">split_stratum</a>()</code>,
<code><a href="#topic+stratify">stratify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stratify a data frame, then split it odd-even
ds &lt;- data.frame(condition = rep(c("a", "b"), each = 4), score = 1 : 8)
strata &lt;- stratify(ds, ds$condition)
split_indexes &lt;- get_split_indexes_from_strata(strata, method = "odd_even")
apply_split_indexes_to_strata(strata, split_indexes)
</code></pre>

<hr>
<h2 id='get_split_indexes_from_stratum'>Generate indexes that can be used to split a stratum into two parts</h2><span id='topic+get_split_indexes_from_stratum'></span>

<h3>Description</h3>

<p><code>get_split_indexes_from_stratum</code> returns a list with indexes for
splitting its <code>stratum</code> argument in two parts. The splits differ at most
by one in size. With default arguments, a random split-half is returned,
which samples elements for each part from <code>stratum</code> without replacement.
Via additional arguments to <code>get_split_indexes_from_stratum</code> a range of
other splitting methods can be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_split_indexes_from_stratum(
  stratum,
  method = c("random", "odd_even", "first_second"),
  replace = FALSE,
  split_p = 0.5,
  subsample_p = 1,
  careful = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_split_indexes_from_stratum_+3A_stratum">stratum</code></td>
<td>
<p>(data frame, tibble, list, or vector) Object to split;
dataframes and tibbles are counted and split by row. All other data types
are counted and split by element</p>
</td></tr>
<tr><td><code id="get_split_indexes_from_stratum_+3A_method">method</code></td>
<td>
<p>(character) Splitting method. Note that <code>first_second</code> and
<code>odd_even</code> splitting method will only deliver a valid split with
default settings for other arguments (<code>subsample_p = 1, split_p = 1,
replace = TRUE</code>)</p>
</td></tr>
<tr><td><code id="get_split_indexes_from_stratum_+3A_replace">replace</code></td>
<td>
<p>(logical) If FALSE, splits are constructed by sampling from
stratum without replacement. If TRUE, stratum is sampled with replacement.</p>
</td></tr>
<tr><td><code id="get_split_indexes_from_stratum_+3A_split_p">split_p</code></td>
<td>
<p>(numeric) Desired joint size of both parts, expressed as a
proportion of the size of the subsampled <code>stratum</code>. If <code>split_p</code>
is larger than 1, and <code>careful</code> is FALSE, then parts are automatically
sampled with replacement</p>
</td></tr>
<tr><td><code id="get_split_indexes_from_stratum_+3A_subsample_p">subsample_p</code></td>
<td>
<p>(numeric) Subsample a proportion of <code>stratum</code> to be
used in the split.</p>
</td></tr>
<tr><td><code id="get_split_indexes_from_stratum_+3A_careful">careful</code></td>
<td>
<p>(boolean) If TRUE, stop with an error when called with
arguments that may yield unexpected splits</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following rounding rules apply to subsample size and split size:
</p>
 <ul>
<li><p> If the size of the subsample, calculated as
<code>subsample_p</code> times size of <code>stratum</code>, is a fraction, then
subsample size is rounded up. </p>
</li>
<li><p> If the joint size of the two parts,
calculated as 2 * <code>split_p</code> times size of the subsampled <code>stratum</code>,
is a fraction, the part size is rounded up. </p>
</li>
<li><p> If the joint size of the
two parts is odd and <code>replace</code> is FALSE, then one of the parts randomly
gets one more element than the other part. </p>
</li>
<li><p> If the joint size of the two
parts is odd and <code>replace</code> is TRUE, part size is rounded up to the next
whole number, so each of the splits has the same size. </p>
</li></ul>



<h3>Value</h3>

<p>(list) List with two elements that contain indexes that can be used
to split the stratum in two parts two splits of stratum.
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_strata">apply_split_indexes_to_strata</a>()</code>,
<code><a href="#topic+apply_split_indexes_to_stratum">apply_split_indexes_to_stratum</a>()</code>,
<code><a href="#topic+check_strata">check_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a>()</code>,
<code><a href="#topic+split_df">split_df</a>()</code>,
<code><a href="#topic+split_strata">split_strata</a>()</code>,
<code><a href="#topic+split_stratum">split_stratum</a>()</code>,
<code><a href="#topic+stratify">stratify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split-half. One of the splits gets 4 elements and the other 5
stratum = letters[1:9]
indexes = get_split_indexes_from_stratum(stratum)
apply_split_indexes_to_stratum(stratum, indexes[[1]], indexes[[2]])
</code></pre>

<hr>
<h2 id='sdregi'>SD ratio of equalities or greater inequalities</h2><span id='topic+sdregi'></span>

<h3>Description</h3>

<p>Returns the ratio of the SDs of <code>x</code> and <code>y</code>, using the largest
SD of the two as denominator. Hence, the result is always 1 (ratio of
equalities) or greater than 1 (ratio of greater inequalities).
If x or y have less than two elements, NA is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdregi(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdregi_+3A_x">x</code></td>
<td>
<p>(vector) a numeric vector</p>
</td></tr>
<tr><td><code id="sdregi_+3A_y">y</code></td>
<td>
<p>(vector) a numeric vector with compatible dimensions to x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) SD ratio
</p>


<h3>See Also</h3>

<p>Other splithalfr coefficients: 
<code><a href="#topic+angoff_feldt">angoff_feldt</a>()</code>,
<code><a href="#topic+assmd">assmd</a>()</code>,
<code><a href="#topic+flanagan_rulon">flanagan_rulon</a>()</code>,
<code><a href="#topic+short_icc">short_icc</a>()</code>,
<code><a href="#topic+spearman_brown">spearman_brown</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two variables with different means, variances and a correlation of about 0.5
library(MASS)
vars = mvrnorm(30, mu = c(0, 2), Sigma = matrix(c(5, 2, 2, 3), ncol = 2), empirical = TRUE)
# Calculate SD ratio of left and right variables
sdregi(vars[,1], vars[,2])
# Calculate SD ratio of right and left variables; should give same result
sdregi(vars[,1], vars[,2])
</code></pre>

<hr>
<h2 id='short_icc'>Calculate Intraclass Correlation Coefficient (ICC)</h2><span id='topic+short_icc'></span>

<h3>Description</h3>

<p>Wrapper for ICCs calculated via <code><a href="psych.html#topic+ICC">ICC</a></code>. If x or y have 
less than two elements, NA is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>short_icc(
  x,
  y,
  type = c("ICC1", "ICC2", "ICC3", "ICC1k", "ICC2k", "ICC3k"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="short_icc_+3A_x">x</code></td>
<td>
<p>(vector) a numeric vector</p>
</td></tr>
<tr><td><code id="short_icc_+3A_y">y</code></td>
<td>
<p>(vector) a numeric vector with compatible dimensions to x</p>
</td></tr>
<tr><td><code id="short_icc_+3A_type">type</code></td>
<td>
<p>(character) type of ICC to calculate, see <code><a href="psych.html#topic+ICC">ICC</a></code></p>
</td></tr>
<tr><td><code id="short_icc_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="psych.html#topic+ICC">ICC</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) Value of ICC coefficient
</p>


<h3>See Also</h3>

<p>Other splithalfr coefficients: 
<code><a href="#topic+angoff_feldt">angoff_feldt</a>()</code>,
<code><a href="#topic+assmd">assmd</a>()</code>,
<code><a href="#topic+flanagan_rulon">flanagan_rulon</a>()</code>,
<code><a href="#topic+sdregi">sdregi</a>()</code>,
<code><a href="#topic+spearman_brown">spearman_brown</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two variables with different means, variances and a correlation of about 0.5
library(MASS)
vars = mvrnorm(30, mu = c(0, 2), Sigma = matrix(c(5, 2, 2, 3), ncol = 2), empirical = TRUE)
# Calculate ICC1
short_icc(vars[,1], vars[,2], type = "ICC1", lmer = FALSE)
</code></pre>

<hr>
<h2 id='spearman_brown'>Calculate Spearman-brown coefficient</h2><span id='topic+spearman_brown'></span>

<h3>Description</h3>

<p>Spearman-Brown reliability coefficient for doubling test length. Formula
obtained from Warrens (2015) &lt;<a href="https://doi.org/10.1007/s11634-015-0198-6">doi:10.1007/s11634-015-0198-6</a>&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spearman_brown(x, y, fn_cor = cor, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spearman_brown_+3A_x">x</code></td>
<td>
<p>(vector) a numeric vector</p>
</td></tr>
<tr><td><code id="spearman_brown_+3A_y">y</code></td>
<td>
<p>(vector) a numeric vector with compatible dimensions to x</p>
</td></tr>
<tr><td><code id="spearman_brown_+3A_fn_cor">fn_cor</code></td>
<td>
<p>(function) a function returning a correlation coefficient</p>
</td></tr>
<tr><td><code id="spearman_brown_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>fn_cor</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) Spearman-Brown coefficient
</p>


<h3>See Also</h3>

<p>Other splithalfr coefficients: 
<code><a href="#topic+angoff_feldt">angoff_feldt</a>()</code>,
<code><a href="#topic+assmd">assmd</a>()</code>,
<code><a href="#topic+flanagan_rulon">flanagan_rulon</a>()</code>,
<code><a href="#topic+sdregi">sdregi</a>()</code>,
<code><a href="#topic+short_icc">short_icc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two variables with different means, variances and a correlation of about 0.5
library(MASS)
vars = mvrnorm(30, mu = c(0, 2), Sigma = matrix(c(5, 2, 2, 3), ncol = 2), empirical = TRUE)
# Calculate coefficient based on Pearson correlation
spearman_brown(vars[,1], vars[,2])
# Calculate coefficient based on ICC, two-way, random effects, absolute agreement, single rater
spearman_brown(vars[,1], vars[,2], short_icc, type = "ICC1", lmer = FALSE)
</code></pre>

<hr>
<h2 id='split_ci'>Calculate nonparametric bias-corrected and accelerated bootstrap confidence
intervals for coefficients averaged across split replications</h2><span id='topic+split_ci'></span>

<h3>Description</h3>

<p>Calculates nonparametric bias-corrected and accelerated bootstrap confidence intervals
via <code><a href="bcaboot.html#topic+bcajack">bcajack</a></code>. Coefficients are <code>ds</code> should be a data frame as returned by
<code><a href="#topic+by_split">by_split</a></code>: Each unique value of the column <code>participant</code> is considered a independent
sample of the target population. For each unique value of the column <code>split</code> in
<code>ds</code>, it selects the corresponding rows in <code>ds</code>, and passes the
values in the columns <code>score_1</code> and <code>score_2</code> as the first and
second argument to <code>fn_coef</code>. Any row in <code>ds</code> for which
<code>score_1</code> or <code>score_2</code> is NA is pairwise removed before passing the
data to <code>fn_coef</code>. Any coefficient that is NA is removed before passing
the data to to <code>fn_summary</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_ci(
  ds,
  fn_coef,
  fn_average = function(values) {
     mean(values, na.rm = TRUE)
 },
  replications = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_ci_+3A_ds">ds</code></td>
<td>
<p>(data frame) a data frame with columns <code>split</code>,
<code>score_1</code>, and <code>score_2</code></p>
</td></tr>
<tr><td><code id="split_ci_+3A_fn_coef">fn_coef</code></td>
<td>
<p>(function) a function that calculates a bivariate coefficient.</p>
</td></tr>
<tr><td><code id="split_ci_+3A_fn_average">fn_average</code></td>
<td>
<p>(function) a function that calculates an average across coefficients</p>
</td></tr>
<tr><td><code id="split_ci_+3A_replications">replications</code></td>
<td>
<p>(integer) number of bootstrap replications</p>
</td></tr>
<tr><td><code id="split_ci_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="bcaboot.html#topic+bcajack">bcajack</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For averaging internal consistency coefficients, see Feldt and Charter (2006). For more 
information about bias-corrected and accelerated bootstrap confidence intervals, see
Efron (1987).
</p>


<h3>Value</h3>

<p>Confidence interval
</p>


<h3>References</h3>

<p>Efron, B. (1987). Better bootstrap confidence intervals. <em>Journal of the
American statistical Association</em>, 82(397), 171-185.
<a href="https://doi.org/10.1080/01621459.1987.10478410">doi:10.1080/01621459.1987.10478410</a>
</p>
<p>Feldt, L. S., &amp; Charter, R. A. (2006). Averaging internal consistency
reliability coefficients. <em>Educational and Psychological Measurement</em>,
66(2), 215-227.
<a href="https://doi.org/10.1177/0013164404273947">doi:10.1177/0013164404273947</a>
</p>


<h3>See Also</h3>

<p>Other split aggregation functions: 
<code><a href="#topic+split_coefs">split_coefs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate five splits with scores that are correlated 0.00, 0.25, 0.5, 0.75, and 1.00
library(MASS)
ds_splits = data.frame(V1 = numeric(), V2 = numeric(), split = numeric())
for (r in 0:4) {
  vars = mvrnorm(10, mu = c(0, 0), Sigma = matrix(c(10, 3, 3, 2), ncol = 2), empirical = FALSE)
  ds_splits = rbind(ds_splits, cbind(vars, r, 1 : 10))
}
names(ds_splits) = c("score_1", "score_2", "replication", "participant")
# Calculate confidence interval
split_ci(ds_splits, cor)
</code></pre>

<hr>
<h2 id='split_coefs'>Calculate a bivariate coefficient for each split-half replication</h2><span id='topic+split_coefs'></span>

<h3>Description</h3>

<p>Calculates a bivariate coefficient across participants for each split-half
replication and returns their values calculated across
replications. <code>ds</code> should be a data frame as returned by
<code><a href="#topic+by_split">by_split</a></code>: For each unique value of the column <code>split</code> in
<code>ds</code>, it selects the corresponding rows in <code>ds</code>, and passes the
values in the columns <code>score_1</code> and <code>score_2</code> as the first and
second argument to <code>fn_coef</code>. Any row in <code>ds</code> for which
<code>score_1</code> or <code>score_2</code> is NA is pairwise removed before passing the
data to <code>fn_coef</code>. For averaging internal consistency coefficients,
see Feldt and Charter (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_coefs(ds, fn_coef, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_coefs_+3A_ds">ds</code></td>
<td>
<p>(data frame) a data frame with columns <code>split</code>, <code>score_1</code>,
and <code>score_2</code></p>
</td></tr>
<tr><td><code id="split_coefs_+3A_fn_coef">fn_coef</code></td>
<td>
<p>(function) a function that calculates a bivariate coefficient.</p>
</td></tr>
<tr><td><code id="split_coefs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn_coef</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients per split calculated via <code>fn_coef</code>.
</p>


<h3>References</h3>

<p>Feldt, L. S., &amp; Charter, R. A. (2006). Averaging internal consistency
reliability coefficients. <em>Educational and Psychological Measurement</em>,
66(2), 215-227. <a href="https://doi.org/10.1177/0013164404273947">doi:10.1177/0013164404273947</a>
</p>


<h3>See Also</h3>

<p>Other split aggregation functions: 
<code><a href="#topic+split_ci">split_ci</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate five splits with scores that are correlated 0.00, 0.25, 0.5, 0.75, and 1.00
library(MASS)
ds_splits = data.frame(score_1 = numeric(), score_2 = numeric(), replication = numeric())
for (r in 0:4) {
  vars = mvrnorm(10, mu = c(0, 0), Sigma = matrix(c(10, 3, 3, 2), ncol = 2), empirical = FALSE)
  ds_splits = rbind(ds_splits, cbind(vars, r))
}
names(ds_splits) = c("score_1", "score_2", "replication")
# Pearson correlations
split_coefs(ds_splits, cor)
# Spearman-brown corrected Pearson correlations
split_coefs(ds_splits, spearman_brown)
# Flanagan-Rulon coefficient
split_coefs(ds_splits, flanagan_rulon)
# Angoff-Feldt coefficient
split_coefs(ds_splits, angoff_feldt)
# Spearman-Brown corrected ICCs
split_coefs(
  ds_splits,
  spearman_brown,
  short_icc,
  type = "ICC1",
  lmer = FALSE
)
</code></pre>

<hr>
<h2 id='split_df'>Split a data frame into two parts</h2><span id='topic+split_df'></span>

<h3>Description</h3>

<p>Splits <code>data</code>, Applies a stratified split to a data frame and returns
each part. For more information about splitting options, and an extensive
list of examples, see <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_df(data, stratification = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_df_+3A_data">data</code></td>
<td>
<p>(data frame) Data to split, in long format, with one row per
observation.</p>
</td></tr>
<tr><td><code id="split_df_+3A_stratification">stratification</code></td>
<td>
<p>(vector). Vector that identifies which subsets of
<code>data</code> should be split separately (denoted as strata in splitting
functions) in order to ensure they are evenly distributed between parts. 
If NULL, all <code>data</code> is considered a single stratum.</p>
</td></tr>
<tr><td><code id="split_df_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>
</p>

<dl>
<dt><code>method</code></dt><dd><p>(character) Splitting method. Note that <code>first_second</code> and
<code>odd_even</code> splitting method will only deliver a valid split with
default settings for other arguments (<code>subsample_p = 1, split_p = 1,
replace = TRUE</code>)</p>
</dd>
<dt><code>replace</code></dt><dd><p>(logical) If FALSE, splits are constructed by sampling from
stratum without replacement. If TRUE, stratum is sampled with replacement.</p>
</dd>
<dt><code>split_p</code></dt><dd><p>(numeric) Desired joint size of both parts, expressed as a
proportion of the size of the subsampled <code>stratum</code>. If <code>split_p</code>
is larger than 1, and <code>careful</code> is FALSE, then parts are automatically
sampled with replacement</p>
</dd>
<dt><code>subsample_p</code></dt><dd><p>(numeric) Subsample a proportion of <code>stratum</code> to be
used in the split.</p>
</dd>
<dt><code>careful</code></dt><dd><p>(boolean) If TRUE, stop with an error when called with
arguments that may yield unexpected splits</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) List with two elements that each contain one of two parts.
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_strata">apply_split_indexes_to_strata</a>()</code>,
<code><a href="#topic+apply_split_indexes_to_stratum">apply_split_indexes_to_stratum</a>()</code>,
<code><a href="#topic+check_strata">check_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a>()</code>,
<code><a href="#topic+split_strata">split_strata</a>()</code>,
<code><a href="#topic+split_stratum">split_stratum</a>()</code>,
<code><a href="#topic+stratify">stratify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(condition = rep(c("a", "b"), each = 4), score = 1 : 8)
split_df(ds, method = "random")
split_df(ds, method = "odd_even")
split_df(ds, method = "first_second")
split_df(ds, stratification = ds$condition, method = "random")
split_df(ds, stratification = ds$condition, method = "odd_even")
split_df(ds, stratification = ds$condition, method = "first_second")
ds &lt;- data.frame(condition = rep(c("a", "b"), 4), score = 1 : 8)
split_df(ds, method = "random")
split_df(ds, method = "odd_even")
split_df(ds, method = "first_second")
split_df(ds, stratification = ds$condition, method = "random")
split_df(ds, stratification = ds$condition, method = "odd_even")
split_df(ds, stratification = ds$condition, method = "first_second")
</code></pre>

<hr>
<h2 id='split_strata'>Split each stratum into two parts</h2><span id='topic+split_strata'></span>

<h3>Description</h3>

<p>Splits each element of <code>strata</code> into two parts. For more information
about splitting options, and an extensive list of examples, see
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_strata(strata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_strata_+3A_strata">strata</code></td>
<td>
<p>(list) list of strata to split</p>
</td></tr>
<tr><td><code id="split_strata_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>
</p>

<dl>
<dt><code>method</code></dt><dd><p>(character) Splitting method. Note that <code>first_second</code> and
<code>odd_even</code> splitting method will only deliver a valid split with
default settings for other arguments (<code>subsample_p = 1, split_p = 1,
replace = TRUE</code>)</p>
</dd>
<dt><code>replace</code></dt><dd><p>(logical) If FALSE, splits are constructed by sampling from
stratum without replacement. If TRUE, stratum is sampled with replacement.</p>
</dd>
<dt><code>split_p</code></dt><dd><p>(numeric) Desired joint size of both parts, expressed as a
proportion of the size of the subsampled <code>stratum</code>. If <code>split_p</code>
is larger than 1, and <code>careful</code> is FALSE, then parts are automatically
sampled with replacement</p>
</dd>
<dt><code>subsample_p</code></dt><dd><p>(numeric) Subsample a proportion of <code>stratum</code> to be
used in the split.</p>
</dd>
<dt><code>careful</code></dt><dd><p>(boolean) If TRUE, stop with an error when called with
arguments that may yield unexpected splits</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) A list with two elements, containing the first and second
split of <code>strata</code>.
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_strata">apply_split_indexes_to_strata</a>()</code>,
<code><a href="#topic+apply_split_indexes_to_stratum">apply_split_indexes_to_stratum</a>()</code>,
<code><a href="#topic+check_strata">check_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a>()</code>,
<code><a href="#topic+split_df">split_df</a>()</code>,
<code><a href="#topic+split_stratum">split_stratum</a>()</code>,
<code><a href="#topic+stratify">stratify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stratify a data frame, then split it odd-even
ds &lt;- data.frame(condition = rep(c("a", "b"), each = 4), score = 1 : 8)
strata &lt;- stratify(ds, ds$condition)
split_strata(strata, method = "odd_even")
</code></pre>

<hr>
<h2 id='split_stratum'>Split a stratum into two parts</h2><span id='topic+split_stratum'></span>

<h3>Description</h3>

<p>Splits <code>stratum</code> into two parts. For more information
about splitting options, and an extensive list of examples, see
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_stratum(stratum, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_stratum_+3A_stratum">stratum</code></td>
<td>
<p>(data frame, tibble, list, or vector) Stratum to split;
dataframes and tibbles are counted and split by row. All other data types
are counted and split by element</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a></code>
</p>

<dl>
<dt><code>method</code></dt><dd><p>(character) Splitting method. Note that <code>first_second</code> and
<code>odd_even</code> splitting method will only deliver a valid split with
default settings for other arguments (<code>subsample_p = 1, split_p = 1,
replace = TRUE</code>)</p>
</dd>
<dt><code>replace</code></dt><dd><p>(logical) If FALSE, splits are constructed by sampling from
stratum without replacement. If TRUE, stratum is sampled with replacement.</p>
</dd>
<dt><code>split_p</code></dt><dd><p>(numeric) Desired joint size of both parts, expressed as a
proportion of the size of the subsampled <code>stratum</code>. If <code>split_p</code>
is larger than 1, and <code>careful</code> is FALSE, then parts are automatically
sampled with replacement</p>
</dd>
<dt><code>subsample_p</code></dt><dd><p>(numeric) Subsample a proportion of <code>stratum</code> to be
used in the split.</p>
</dd>
<dt><code>careful</code></dt><dd><p>(boolean) If TRUE, stop with an error when called with
arguments that may yield unexpected splits</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) List with two elements that contain each of the two parts of
stratum split in two.
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_strata">apply_split_indexes_to_strata</a>()</code>,
<code><a href="#topic+apply_split_indexes_to_stratum">apply_split_indexes_to_stratum</a>()</code>,
<code><a href="#topic+check_strata">check_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a>()</code>,
<code><a href="#topic+split_df">split_df</a>()</code>,
<code><a href="#topic+split_strata">split_strata</a>()</code>,
<code><a href="#topic+stratify">stratify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split stratum odd-even
ds &lt;- data.frame(condition = rep(c("a", "b"), each = 4), score = 1 : 8)
split_stratum(ds, method = "odd_even")
</code></pre>

<hr>
<h2 id='stratify'>Stratify a data frame</h2><span id='topic+stratify'></span>

<h3>Description</h3>

<p>Split a dataframe into strata formed by each a unique value of <code>stratification</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratify(ds, stratification = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stratify_+3A_ds">ds</code></td>
<td>
<p>(data frame) data to split into strata</p>
</td></tr>
<tr><td><code id="stratify_+3A_stratification">stratification</code></td>
<td>
<p>(vector). Vector that identifies which subsets of
<code>data</code> should be split separately (denoted as strata in splitting
functions) in order to ensure they are evenly distributed between patrs. 
If NULL, all <code>data</code> is considered a single stratum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) List of strata
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+apply_split_indexes_to_strata">apply_split_indexes_to_strata</a>()</code>,
<code><a href="#topic+apply_split_indexes_to_stratum">apply_split_indexes_to_stratum</a>()</code>,
<code><a href="#topic+check_strata">check_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_strata">get_split_indexes_from_strata</a>()</code>,
<code><a href="#topic+get_split_indexes_from_stratum">get_split_indexes_from_stratum</a>()</code>,
<code><a href="#topic+split_df">split_df</a>()</code>,
<code><a href="#topic+split_strata">split_strata</a>()</code>,
<code><a href="#topic+split_stratum">split_stratum</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stratify a data frame, then split it odd-even
ds &lt;- data.frame(condition = rep(c("a", "b"), each = 4), score = 1 : 8)
strata &lt;- stratify(ds, ds$condition)
split_strata(strata, method = "odd_even")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
