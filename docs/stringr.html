<!DOCTYPE html><html><head><title>Help for package stringr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stringr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#case'><p>Convert string to upper case, lower case, title case, or sentence case</p></a></li>
<li><a href='#invert_match'><p>Switch location of matches to location of non-matches</p></a></li>
<li><a href='#modifiers'><p>Control matching behaviour with modifier functions</p></a></li>
<li><a href='#str_c'><p>Join multiple strings into one string</p></a></li>
<li><a href='#str_conv'><p>Specify the encoding of a string</p></a></li>
<li><a href='#str_count'><p>Count number of matches</p></a></li>
<li><a href='#str_detect'><p>Detect the presence/absence of a match</p></a></li>
<li><a href='#str_dup'><p>Duplicate a string</p></a></li>
<li><a href='#str_equal'><p>Determine if two strings are equivalent</p></a></li>
<li><a href='#str_escape'><p>Escape regular expression metacharacters</p></a></li>
<li><a href='#str_extract'><p>Extract the complete match</p></a></li>
<li><a href='#str_flatten'><p>Flatten a string</p></a></li>
<li><a href='#str_glue'><p>Interpolation with glue</p></a></li>
<li><a href='#str_interp'><p>String interpolation</p></a></li>
<li><a href='#str_length'><p>Compute the length/width</p></a></li>
<li><a href='#str_like'><p>Detect a pattern in the same way as <code>SQL</code>'s <code>LIKE</code> operator</p></a></li>
<li><a href='#str_locate'><p>Find location of match</p></a></li>
<li><a href='#str_match'><p>Extract components (capturing groups) from a match</p></a></li>
<li><a href='#str_order'><p>Order, rank, or sort a character vector</p></a></li>
<li><a href='#str_pad'><p>Pad a string to minimum width</p></a></li>
<li><a href='#str_remove'><p>Remove matched patterns</p></a></li>
<li><a href='#str_replace'><p>Replace matches with new text</p></a></li>
<li><a href='#str_replace_na'><p>Turn NA into &quot;NA&quot;</p></a></li>
<li><a href='#str_split'><p>Split up a string into pieces</p></a></li>
<li><a href='#str_starts'><p>Detect the presence/absence of a match at the start/end</p></a></li>
<li><a href='#str_sub'><p>Get and set substrings using their positions</p></a></li>
<li><a href='#str_subset'><p>Find matching elements</p></a></li>
<li><a href='#str_trim'><p>Remove whitespace</p></a></li>
<li><a href='#str_trunc'><p>Truncate a string to maximum width</p></a></li>
<li><a href='#str_unique'><p>Remove duplicated strings</p></a></li>
<li><a href='#str_view'><p>View strings and matches</p></a></li>
<li><a href='#str_which'><p>Find matching indices</p></a></li>
<li><a href='#str_wrap'><p>Wrap words into nicely formatted paragraphs</p></a></li>
<li><a href='#stringr-data'><p>Sample character vectors for practicing string manipulations</p></a></li>
<li><a href='#stringr-package'><p>stringr: Simple, Consistent Wrappers for Common String Operations</p></a></li>
<li><a href='#word'><p>Extract words from a sentence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simple, Consistent Wrappers for Common String Operations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A consistent, simple and easy to use set of wrappers around
    the fantastic 'stringi' package. All function and argument names (and
    positions) are consistent, all functions deal with "NA"'s and zero
    length vectors in the same way, and the output from one function is
    easy to feed into the input of another.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://stringr.tidyverse.org">https://stringr.tidyverse.org</a>,
<a href="https://github.com/tidyverse/stringr">https://github.com/tidyverse/stringr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/stringr/issues">https://github.com/tidyverse/stringr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, glue (&ge; 1.6.1), lifecycle (&ge; 1.0.3), magrittr, rlang
(&ge; 1.0.0), stringi (&ge; 1.5.3), vctrs (&ge; 0.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, gt, htmltools, htmlwidgets, knitr, rmarkdown,
testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-14 15:03:52 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre, cph],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='case'>Convert string to upper case, lower case, title case, or sentence case</h2><span id='topic+case'></span><span id='topic+str_to_upper'></span><span id='topic+str_to_lower'></span><span id='topic+str_to_title'></span><span id='topic+str_to_sentence'></span>

<h3>Description</h3>


<ul>
<li> <p><code>str_to_upper()</code> converts to upper case.
</p>
</li>
<li> <p><code>str_to_lower()</code> converts to lower case.
</p>
</li>
<li> <p><code>str_to_title()</code> converts to title case, where only the first letter of
each word is capitalized.
</p>
</li>
<li> <p><code>str_to_sentence()</code> convert to sentence case, where only the first letter
of sentence is capitalized.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>str_to_upper(string, locale = "en")

str_to_lower(string, locale = "en")

str_to_title(string, locale = "en")

str_to_sentence(string, locale = "en")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="case_+3A_locale">locale</code></td>
<td>
<p>Locale to use for comparisons. See
<code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> for all possible options.
Defaults to &quot;en&quot; (English) to ensure that default behaviour is
consistent across platforms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dog &lt;- "The quick brown dog"
str_to_upper(dog)
str_to_lower(dog)
str_to_title(dog)
str_to_sentence("the quick brown dog")

# Locale matters!
str_to_upper("i") # English
str_to_upper("i", "tr") # Turkish
</code></pre>

<hr>
<h2 id='invert_match'>Switch location of matches to location of non-matches</h2><span id='topic+invert_match'></span>

<h3>Description</h3>

<p>Invert a matrix of match locations to match the opposite of what was
previously matched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_match(loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_match_+3A_loc">loc</code></td>
<td>
<p>matrix of match locations, as from <code><a href="#topic+str_locate_all">str_locate_all()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric match giving locations of non-matches
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numbers &lt;- "1 and 2 and 4 and 456"
num_loc &lt;- str_locate_all(numbers, "[0-9]+")[[1]]
str_sub(numbers, num_loc[, "start"], num_loc[, "end"])

text_loc &lt;- invert_match(num_loc)
str_sub(numbers, text_loc[, "start"], text_loc[, "end"])
</code></pre>

<hr>
<h2 id='modifiers'>Control matching behaviour with modifier functions</h2><span id='topic+modifiers'></span><span id='topic+fixed'></span><span id='topic+coll'></span><span id='topic+regex'></span><span id='topic+boundary'></span>

<h3>Description</h3>

<p>Modifier functions control the meaning of the <code>pattern</code> argument to
stringr functions:
</p>

<ul>
<li> <p><code>boundary()</code>: Match boundaries between things.
</p>
</li>
<li> <p><code>coll()</code>: Compare strings using standard Unicode collation rules.
</p>
</li>
<li> <p><code>fixed()</code>: Compare literal bytes.
</p>
</li>
<li> <p><code>regex()</code> (the default): Uses ICU regular expressions.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>fixed(pattern, ignore_case = FALSE)

coll(pattern, ignore_case = FALSE, locale = "en", ...)

regex(
  pattern,
  ignore_case = FALSE,
  multiline = FALSE,
  comments = FALSE,
  dotall = FALSE,
  ...
)

boundary(
  type = c("character", "line_break", "sentence", "word"),
  skip_word_none = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modifiers_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to modify behaviour.</p>
</td></tr>
<tr><td><code id="modifiers_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Should case differences be ignored in the match?
For <code>fixed()</code>, this uses a simple algorithm which assumes a
one-to-one mapping between upper and lower case letters.</p>
</td></tr>
<tr><td><code id="modifiers_+3A_locale">locale</code></td>
<td>
<p>Locale to use for comparisons. See
<code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> for all possible options.
Defaults to &quot;en&quot; (English) to ensure that default behaviour is
consistent across platforms.</p>
</td></tr>
<tr><td><code id="modifiers_+3A_...">...</code></td>
<td>
<p>Other less frequently used arguments passed on to
<code><a href="stringi.html#topic+stri_opts_collator">stringi::stri_opts_collator()</a></code>,
<code><a href="stringi.html#topic+stri_opts_regex">stringi::stri_opts_regex()</a></code>, or
<code><a href="stringi.html#topic+stri_opts_brkiter">stringi::stri_opts_brkiter()</a></code></p>
</td></tr>
<tr><td><code id="modifiers_+3A_multiline">multiline</code></td>
<td>
<p>If <code>TRUE</code>, <code>$</code> and <code>^</code> match
the beginning and end of each line. If <code>FALSE</code>, the
default, only match the start and end of the input.</p>
</td></tr>
<tr><td><code id="modifiers_+3A_comments">comments</code></td>
<td>
<p>If <code>TRUE</code>, white space and comments beginning with
<code style="white-space: pre;">&#8288;#&#8288;</code> are ignored. Escape literal spaces with <code style="white-space: pre;">&#8288;\\ &#8288;</code>.</p>
</td></tr>
<tr><td><code id="modifiers_+3A_dotall">dotall</code></td>
<td>
<p>If <code>TRUE</code>, <code>.</code> will also match line terminators.</p>
</td></tr>
<tr><td><code id="modifiers_+3A_type">type</code></td>
<td>
<p>Boundary type to detect.
</p>

<dl>
<dt><code>character</code></dt><dd><p>Every character is a boundary.</p>
</dd>
<dt><code>line_break</code></dt><dd><p>Boundaries are places where it is acceptable to have
a line break in the current locale.</p>
</dd>
<dt><code>sentence</code></dt><dd><p>The beginnings and ends of sentences are boundaries,
using intelligent rules to avoid counting abbreviations
(<a href="https://www.unicode.org/reports/tr29/#Sentence_Boundaries">details</a>).</p>
</dd>
<dt><code>word</code></dt><dd><p>The beginnings and ends of words are boundaries.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="modifiers_+3A_skip_word_none">skip_word_none</code></td>
<td>
<p>Ignore &quot;words&quot; that don't contain any characters
or numbers - i.e. punctuation. Default <code>NA</code> will skip such &quot;words&quot;
only when splitting on <code>word</code> boundaries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stringr modifier object, i.e. a character vector with
parent S3 class <code>stringr_pattern</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern &lt;- "a.b"
strings &lt;- c("abb", "a.b")
str_detect(strings, pattern)
str_detect(strings, fixed(pattern))
str_detect(strings, coll(pattern))

# coll() is useful for locale-aware case-insensitive matching
i &lt;- c("I", "\u0130", "i")
i
str_detect(i, fixed("i", TRUE))
str_detect(i, coll("i", TRUE))
str_detect(i, coll("i", TRUE, locale = "tr"))

# Word boundaries
words &lt;- c("These are   some words.")
str_count(words, boundary("word"))
str_split(words, " ")[[1]]
str_split(words, boundary("word"))[[1]]

# Regular expression variations
str_extract_all("The Cat in the Hat", "[a-z]+")
str_extract_all("The Cat in the Hat", regex("[a-z]+", TRUE))

str_extract_all("a\nb\nc", "^.")
str_extract_all("a\nb\nc", regex("^.", multiline = TRUE))

str_extract_all("a\nb\nc", "a.")
str_extract_all("a\nb\nc", regex("a.", dotall = TRUE))
</code></pre>

<hr>
<h2 id='str_c'>Join multiple strings into one string</h2><span id='topic+str_c'></span>

<h3>Description</h3>

<p><code>str_c()</code> combines multiple character vectors into a single character
vector. It's very similar to <code><a href="base.html#topic+paste0">paste0()</a></code> but uses tidyverse recycling and
<code>NA</code> rules.
</p>
<p>One way to understand how <code>str_c()</code> works is picture a 2d matrix of strings,
where each argument forms a column. <code>sep</code> is inserted between each column,
and then each row is combined together into a single string. If <code>collapse</code>
is set, it's inserted between each row, and then the result is again
combined, this time into a single string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_c(..., sep = "", collapse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_c_+3A_...">...</code></td>
<td>
<p>One or more character vectors.
</p>
<p><code>NULL</code>s are removed; scalar inputs (vectors of length 1) are recycled to
the common length of vector inputs.
</p>
<p>Like most other R functions, missing values are &quot;infectious&quot;: whenever
a missing value is combined with another string the result will always
be missing. Use <code><a href="dplyr.html#topic+coalesce">dplyr::coalesce()</a></code> or <code><a href="#topic+str_replace_na">str_replace_na()</a></code> to convert to
the desired value.</p>
</td></tr>
<tr><td><code id="str_c_+3A_sep">sep</code></td>
<td>
<p>String to insert between input vectors.</p>
</td></tr>
<tr><td><code id="str_c_+3A_collapse">collapse</code></td>
<td>
<p>Optional string used to combine output into single
string. Generally better to use <code><a href="#topic+str_flatten">str_flatten()</a></code> if you needed this
behaviour.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>collapse = NULL</code> (the default) a character vector with
length equal to the longest input. If <code>collapse</code> is a string, a character
vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_c("Letter: ", letters)
str_c("Letter", letters, sep = ": ")
str_c(letters, " is for", "...")
str_c(letters[-26], " comes before ", letters[-1])

str_c(letters, collapse = "")
str_c(letters, collapse = ", ")

# Differences from paste() ----------------------
# Missing inputs give missing outputs
str_c(c("a", NA, "b"), "-d")
paste0(c("a", NA, "b"), "-d")
# Use str_replace_NA to display literal NAs:
str_c(str_replace_na(c("a", NA, "b")), "-d")

# Uses tidyverse recycling rules
## Not run: str_c(1:2, 1:3) # errors
paste0(1:2, 1:3)

str_c("x", character())
paste0("x", character())
</code></pre>

<hr>
<h2 id='str_conv'>Specify the encoding of a string</h2><span id='topic+str_conv'></span>

<h3>Description</h3>

<p>This is a convenient way to override the current encoding of a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_conv(string, encoding)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_conv_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_conv_+3A_encoding">encoding</code></td>
<td>
<p>Name of encoding. See <code><a href="stringi.html#topic+stri_enc_list">stringi::stri_enc_list()</a></code>
for a complete list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example from encoding?stringi::stringi
x &lt;- rawToChar(as.raw(177))
x
str_conv(x, "ISO-8859-2") # Polish "a with ogonek"
str_conv(x, "ISO-8859-1") # Plus-minus
</code></pre>

<hr>
<h2 id='str_count'>Count number of matches</h2><span id='topic+str_count'></span>

<h3>Description</h3>

<p>Counts the number of times <code>pattern</code> is found within each element
of <code>string.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_count(string, pattern = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_count_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_count_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector the same length as <code>string</code>/<code>pattern</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_count">stringi::stri_count()</a></code> which this function wraps.
</p>
<p><code><a href="#topic+str_locate">str_locate()</a></code>/<code><a href="#topic+str_locate_all">str_locate_all()</a></code> to locate position
of matches
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit &lt;- c("apple", "banana", "pear", "pineapple")
str_count(fruit, "a")
str_count(fruit, "p")
str_count(fruit, "e")
str_count(fruit, c("a", "b", "p", "p"))

str_count(c("a.", "...", ".a.a"), ".")
str_count(c("a.", "...", ".a.a"), fixed("."))
</code></pre>

<hr>
<h2 id='str_detect'>Detect the presence/absence of a match</h2><span id='topic+str_detect'></span>

<h3>Description</h3>

<p><code>str_detect()</code> returns a logical vector with <code>TRUE</code> for each element of
<code>string</code> that matches <code>pattern</code> and <code>FALSE</code> otherwise. It's equivalent to
<code>grepl(pattern, string)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_detect(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_detect_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_detect_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
<tr><td><code id="str_detect_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, inverts the resulting boolean vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same length as <code>string</code>/<code>pattern</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_detect">stringi::stri_detect()</a></code> which this function wraps,
<code><a href="#topic+str_subset">str_subset()</a></code> for a convenient wrapper around
<code>x[str_detect(x, pattern)]</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit &lt;- c("apple", "banana", "pear", "pineapple")
str_detect(fruit, "a")
str_detect(fruit, "^a")
str_detect(fruit, "a$")
str_detect(fruit, "b")
str_detect(fruit, "[aeiou]")

# Also vectorised over pattern
str_detect("aecfg", letters)

# Returns TRUE if the pattern do NOT match
str_detect(fruit, "^p", negate = TRUE)
</code></pre>

<hr>
<h2 id='str_dup'>Duplicate a string</h2><span id='topic+str_dup'></span>

<h3>Description</h3>

<p><code>str_dup()</code> duplicates the characters within a string, e.g.
<code>str_dup("xy", 3)</code> returns <code>"xyxyxy"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_dup(string, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_dup_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_dup_+3A_times">times</code></td>
<td>
<p>Number of times to duplicate each string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>/<code>times</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit &lt;- c("apple", "pear", "banana")
str_dup(fruit, 2)
str_dup(fruit, 1:3)
str_c("ba", str_dup("na", 0:5))
</code></pre>

<hr>
<h2 id='str_equal'>Determine if two strings are equivalent</h2><span id='topic+str_equal'></span>

<h3>Description</h3>

<p>This uses Unicode canonicalisation rules, and optionally ignores case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_equal(x, y, locale = "en", ignore_case = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_equal_+3A_x">x</code>, <code id="str_equal_+3A_y">y</code></td>
<td>
<p>A pair of character vectors.</p>
</td></tr>
<tr><td><code id="str_equal_+3A_locale">locale</code></td>
<td>
<p>Locale to use for comparisons. See
<code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> for all possible options.
Defaults to &quot;en&quot; (English) to ensure that default behaviour is
consistent across platforms.</p>
</td></tr>
<tr><td><code id="str_equal_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Ignore case when comparing strings?</p>
</td></tr>
<tr><td><code id="str_equal_+3A_...">...</code></td>
<td>
<p>Other options used to control collation. Passed on to
<code><a href="stringi.html#topic+stri_opts_collator">stringi::stri_opts_collator()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An logical vector the same length as <code>x</code>/<code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_compare">stringi::stri_cmp_equiv()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These two strings encode "a" with an accent in two different ways
a1 &lt;- "\u00e1"
a2 &lt;- "a\u0301"
c(a1, a2)

a1 == a2
str_equal(a1, a2)

# ohm and omega use different code points but should always be treated
# as equal
ohm &lt;- "\u2126"
omega &lt;- "\u03A9"
c(ohm, omega)

ohm == omega
str_equal(ohm, omega)
</code></pre>

<hr>
<h2 id='str_escape'>Escape regular expression metacharacters</h2><span id='topic+str_escape'></span>

<h3>Description</h3>

<p>This function escapes metacharacter, the characters that have special
meaning to the regular expression engine. In most cases you are better
off using <code><a href="#topic+fixed">fixed()</a></code> since it is faster, but <code>str_escape()</code> is useful
if you are composing user provided strings into a pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_escape(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_escape_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_detect(c("a", "."), ".")
str_detect(c("a", "."), str_escape("."))
</code></pre>

<hr>
<h2 id='str_extract'>Extract the complete match</h2><span id='topic+str_extract'></span><span id='topic+str_extract_all'></span>

<h3>Description</h3>

<p><code>str_extract()</code> extracts the first complete match from each string,
<code>str_extract_all()</code>extracts all matches from each string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_extract(string, pattern, group = NULL)

str_extract_all(string, pattern, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_extract_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_extract_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
<tr><td><code id="str_extract_+3A_group">group</code></td>
<td>
<p>If supplied, instead of returning the complete match, will
return the matched text from the specified capturing group.</p>
</td></tr>
<tr><td><code id="str_extract_+3A_simplify">simplify</code></td>
<td>
<p>A boolean.
</p>

<ul>
<li> <p><code>FALSE</code> (the default): returns a list of character vectors.
</p>
</li>
<li> <p><code>TRUE</code>: returns a character matrix.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>str_extract()</code>: an character vector the same length as <code>string</code>/<code>pattern</code>.
</p>
</li>
<li> <p><code>str_extract_all()</code>: a list of character vectors the same length as
<code>string</code>/<code>pattern</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+str_match">str_match()</a></code> to extract matched groups;
<code><a href="stringi.html#topic+stri_extract">stringi::stri_extract()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shopping_list &lt;- c("apples x4", "bag of flour", "bag of sugar", "milk x2")
str_extract(shopping_list, "\\d")
str_extract(shopping_list, "[a-z]+")
str_extract(shopping_list, "[a-z]{1,4}")
str_extract(shopping_list, "\\b[a-z]{1,4}\\b")

str_extract(shopping_list, "([a-z]+) of ([a-z]+)")
str_extract(shopping_list, "([a-z]+) of ([a-z]+)", group = 1)
str_extract(shopping_list, "([a-z]+) of ([a-z]+)", group = 2)

# Extract all matches
str_extract_all(shopping_list, "[a-z]+")
str_extract_all(shopping_list, "\\b[a-z]+\\b")
str_extract_all(shopping_list, "\\d")

# Simplify results into character matrix
str_extract_all(shopping_list, "\\b[a-z]+\\b", simplify = TRUE)
str_extract_all(shopping_list, "\\d", simplify = TRUE)

# Extract all words
str_extract_all("This is, suprisingly, a sentence.", boundary("word"))
</code></pre>

<hr>
<h2 id='str_flatten'>Flatten a string</h2><span id='topic+str_flatten'></span><span id='topic+str_flatten_comma'></span>

<h3>Description</h3>

<p><code>str_flatten()</code> reduces a character vector to a single string. This is a
summary function because regardless of the length of the input <code>x</code>, it
always returns a single string.
</p>
<p><code>str_flatten_comma()</code> is a variation designed specifically for flattening
with commas. It automatically recognises if <code>last</code> uses the Oxford comma
and handles the special case of 2 elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_flatten(string, collapse = "", last = NULL, na.rm = FALSE)

str_flatten_comma(string, last = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_flatten_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_flatten_+3A_collapse">collapse</code></td>
<td>
<p>String to insert between each piece. Defaults to <code>""</code>.</p>
</td></tr>
<tr><td><code id="str_flatten_+3A_last">last</code></td>
<td>
<p>Optional string to use in place of the final separator.</p>
</td></tr>
<tr><td><code id="str_flatten_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove missing values? If <code>FALSE</code> (the default), the result
will be <code>NA</code> if any element of <code>string</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string, i.e. a character vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_flatten(letters)
str_flatten(letters, "-")

str_flatten(letters[1:3], ", ")

# Use last to customise the last component
str_flatten(letters[1:3], ", ", " and ")

# this almost works if you want an Oxford (aka serial) comma
str_flatten(letters[1:3], ", ", ", and ")

# but it will always add a comma, even when not necessary
str_flatten(letters[1:2], ", ", ", and ")

# str_flatten_comma knows how to handle the Oxford comma
str_flatten_comma(letters[1:3], ", and ")
str_flatten_comma(letters[1:2], ", and ")
</code></pre>

<hr>
<h2 id='str_glue'>Interpolation with glue</h2><span id='topic+str_glue'></span><span id='topic+str_glue_data'></span>

<h3>Description</h3>

<p>These functions are wrappers around <code><a href="glue.html#topic+glue">glue::glue()</a></code> and <code><a href="glue.html#topic+glue">glue::glue_data()</a></code>,
which provide a powerful and elegant syntax for interpolating strings
with <code>{}</code>.
</p>
<p>These wrappers provide a small set of the full options. Use <code>glue()</code> and
<code>glue_data()</code> directly from glue for more control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_glue(..., .sep = "", .envir = parent.frame())

str_glue_data(.x, ..., .sep = "", .envir = parent.frame(), .na = "NA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_glue_+3A_...">...</code></td>
<td>
<p>[<code>expressions</code>]<br /> Unnamed arguments are taken to be expression
string(s) to format. Multiple inputs are concatenated together before formatting.
Named arguments are taken to be temporary variables available for substitution.</p>
</td></tr>
<tr><td><code id="str_glue_+3A_.sep">.sep</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;&quot;&quot;&rsquo;]<br /> Separator used to separate elements.</p>
</td></tr>
<tr><td><code id="str_glue_+3A_.envir">.envir</code></td>
<td>
<p>[<code>environment</code>: <code>parent.frame()</code>]<br /> Environment to evaluate each expression in. Expressions are
evaluated from left to right. If <code>.x</code> is an environment, the expressions are
evaluated in that environment and <code>.envir</code> is ignored. If <code>NULL</code> is passed, it is equivalent to <code><a href="base.html#topic+emptyenv">emptyenv()</a></code>.</p>
</td></tr>
<tr><td><code id="str_glue_+3A_.x">.x</code></td>
<td>
<p>[<code>listish</code>]<br /> An environment, list, or data frame used to lookup values.</p>
</td></tr>
<tr><td><code id="str_glue_+3A_.na">.na</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;NA&rsquo;]<br /> Value to replace <code>NA</code> values
with. If <code>NULL</code> missing values are propagated, that is an <code>NA</code> result will
cause <code>NA</code> output. Otherwise the value is replaced by the value of <code>.na</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with same length as the longest input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name &lt;- "Fred"
age &lt;- 50
anniversary &lt;- as.Date("1991-10-12")
str_glue(
  "My name is {name}, ",
  "my age next year is {age + 1}, ",
  "and my anniversary is {format(anniversary, '%A, %B %d, %Y')}."
)

# single braces can be inserted by doubling them
str_glue("My name is {name}, not {{name}}.")

# You can also used named arguments
str_glue(
  "My name is {name}, ",
  "and my age next year is {age + 1}.",
  name = "Joe",
  age = 40
)

# `str_glue_data()` is useful in data pipelines
mtcars %&gt;% str_glue_data("{rownames(.)} has {hp} hp")
</code></pre>

<hr>
<h2 id='str_interp'>String interpolation</h2><span id='topic+str_interp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>str_interp()</code> is superseded in favour of <code><a href="#topic+str_glue">str_glue()</a></code>.
</p>
<p>String interpolation is a useful way of specifying a character string which
depends on values in a certain environment. It allows for string creation
which is easier to read and write when compared to using e.g.
<code><a href="base.html#topic+paste">paste()</a></code> or <code><a href="base.html#topic+sprintf">sprintf()</a></code>. The (template) string can
include expression placeholders of the form <code style="white-space: pre;">&#8288;${expression}&#8288;</code> or
<code style="white-space: pre;">&#8288;$[format]{expression}&#8288;</code>, where expressions are valid R expressions that
can be evaluated in the given environment, and <code>format</code> is a format
specification valid for use with <code><a href="base.html#topic+sprintf">sprintf()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_interp(string, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_interp_+3A_string">string</code></td>
<td>
<p>A template character string. This function is not vectorised:
a character vector will be collapsed into a single string.</p>
</td></tr>
<tr><td><code id="str_interp_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate the expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interpolated character string.
</p>


<h3>Author(s)</h3>

<p>Stefan Milton Bache
</p>


<h3>See Also</h3>

<p><code><a href="#topic+str_glue">str_glue()</a></code> and <code><a href="#topic+str_glue_data">str_glue_data()</a></code> for alternative approaches to
the same problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using values from the environment, and some formats
user_name &lt;- "smbache"
amount &lt;- 6.656
account &lt;- 1337
str_interp("User ${user_name} (account $[08d]{account}) has $$[.2f]{amount}.")

# Nested brace pairs work inside expressions too, and any braces can be
# placed outside the expressions.
str_interp("Works with } nested { braces too: $[.2f]{{{2 + 2}*{amount}}}")

# Values can also come from a list
str_interp(
  "One value, ${value1}, and then another, ${value2*2}.",
  list(value1 = 10, value2 = 20)
)

# Or a data frame
str_interp(
  "Values are $[.2f]{max(Sepal.Width)} and $[.2f]{min(Sepal.Width)}.",
  iris
)

# Use a vector when the string is long:
max_char &lt;- 80
str_interp(c(
  "This particular line is so long that it is hard to write ",
  "without breaking the ${max_char}-char barrier!"
))
</code></pre>

<hr>
<h2 id='str_length'>Compute the length/width</h2><span id='topic+str_length'></span><span id='topic+str_width'></span>

<h3>Description</h3>

<p><code>str_length()</code> returns the number of codepoints in a string. These are
the individual elements (which are often, but not always letters) that
can be extracted with <code><a href="#topic+str_sub">str_sub()</a></code>.
</p>
<p><code>str_width()</code> returns how much space the string will occupy when printed
in a fixed width font (i.e. when printed in the console).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_length(string)

str_width(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_length_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same length as <code>string</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_length">stringi::stri_length()</a></code> which this function wraps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_length(letters)
str_length(NA)
str_length(factor("abc"))
str_length(c("i", "like", "programming", NA))

# Some characters, like emoji and Chinese characters (hanzi), are square
# which means they take up the width of two Latin characters
x &lt;- c("\u6c49\u5b57", "\U0001f60a")
str_view(x)
str_width(x)
str_length(x)

# There are two ways of representing a u with an umlaut
u &lt;- c("\u00fc", "u\u0308")
# They have the same width
str_width(u)
# But a different length
str_length(u)
# Because the second element is made up of a u + an accent
str_sub(u, 1, 1)
</code></pre>

<hr>
<h2 id='str_like'>Detect a pattern in the same way as <code>SQL</code>'s <code>LIKE</code> operator</h2><span id='topic+str_like'></span>

<h3>Description</h3>

<p><code>str_like()</code> follows the conventions of the SQL <code>LIKE</code> operator:
</p>

<ul>
<li><p> Must match the entire string.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_&#8288;</code> matches a single character (like <code>.</code>).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;%&#8288;</code> matches any number of characters (like <code style="white-space: pre;">&#8288;.*&#8288;</code>).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;\%&#8288;</code> and <code style="white-space: pre;">&#8288;\_&#8288;</code> match literal <code style="white-space: pre;">&#8288;%&#8288;</code> and <code style="white-space: pre;">&#8288;_&#8288;</code>.
</p>
</li>
<li><p> The match is case insensitive by default.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>str_like(string, pattern, ignore_case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_like_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_like_+3A_pattern">pattern</code></td>
<td>
<p>A character vector containing a SQL &quot;like&quot; pattern.
See above for details.</p>
</td></tr>
<tr><td><code id="str_like_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Ignore case of matches? Defaults to <code>TRUE</code> to match
the SQL <code>LIKE</code> operator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same length as <code>string</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit &lt;- c("apple", "banana", "pear", "pineapple")
str_like(fruit, "app")
str_like(fruit, "app%")
str_like(fruit, "ba_ana")
str_like(fruit, "%APPLE")
</code></pre>

<hr>
<h2 id='str_locate'>Find location of match</h2><span id='topic+str_locate'></span><span id='topic+str_locate_all'></span>

<h3>Description</h3>

<p><code>str_locate()</code> returns the <code>start</code> and <code>end</code> position of the first match;
<code>str_locate_all()</code> returns the <code>start</code> and <code>end</code> position of each match.
</p>
<p>Because the <code>start</code> and <code>end</code> values are inclusive, zero-length matches
(e.g. <code>$</code>, <code>^</code>, <code style="white-space: pre;">&#8288;\\b&#8288;</code>) will have an <code>end</code> that is smaller than <code>start</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_locate(string, pattern)

str_locate_all(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_locate_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_locate_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>str_locate()</code> returns an integer matrix with two columns and
one row for each element of <code>string</code>. The first column, <code>start</code>,
gives the position at the start of the match, and the second column, <code>end</code>,
gives the position of the end.
</p>
</li>
<li> <p><code>str_locate_all()</code> returns a list of integer matrices with the same
length as <code>string</code>/<code>pattern</code>. The matrices have columns <code>start</code> and <code>end</code>
as above, and one row for each match.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+str_extract">str_extract()</a></code> for a convenient way of extracting matches,
<code><a href="stringi.html#topic+stri_locate">stringi::stri_locate()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit &lt;- c("apple", "banana", "pear", "pineapple")
str_locate(fruit, "$")
str_locate(fruit, "a")
str_locate(fruit, "e")
str_locate(fruit, c("a", "b", "p", "p"))

str_locate_all(fruit, "a")
str_locate_all(fruit, "e")
str_locate_all(fruit, c("a", "b", "p", "p"))

# Find location of every character
str_locate_all(fruit, "")
</code></pre>

<hr>
<h2 id='str_match'>Extract components (capturing groups) from a match</h2><span id='topic+str_match'></span><span id='topic+str_match_all'></span>

<h3>Description</h3>

<p>Extract any number of matches defined by unnamed, <code>(pattern)</code>, and
named, <code style="white-space: pre;">&#8288;(?&lt;name&gt;pattern)&#8288;</code> capture groups.
</p>
<p>Use a non-capturing group, <code style="white-space: pre;">&#8288;(?:pattern)&#8288;</code>, if you need to override default
operate precedence but don't want to capture the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_match(string, pattern)

str_match_all(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_match_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_match_+3A_pattern">pattern</code></td>
<td>
<p>Unlike other stringr functions, <code>str_match()</code> only supports
regular expressions, as described <code>vignette("regular-expressions")</code>.
The pattern should contain at least one capturing group.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>str_match()</code>: a character matrix with the same number of rows as the
length of <code>string</code>/<code>pattern</code>. The first column is the complete match,
followed by one column for each capture group. The columns will be named
if you used &quot;named captured groups&quot;, i.e. <code style="white-space: pre;">&#8288;(?&lt;name&gt;pattern')&#8288;</code>.
</p>
</li>
<li> <p><code>str_match_all()</code>: a list of the same length as <code>string</code>/<code>pattern</code>
containing character matrices. Each matrix has columns as descrbed above
and one row for each match.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+str_extract">str_extract()</a></code> to extract the complete match,
<code><a href="stringi.html#topic+stri_match">stringi::stri_match()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c(" 219 733 8965", "329-293-8753 ", "banana", "595 794 7569",
  "387 287 6718", "apple", "233.398.9187  ", "482 952 3315",
  "239 923 8115 and 842 566 4692", "Work: 579-499-7527", "$1000",
  "Home: 543.355.3679")
phone &lt;- "([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"

str_extract(strings, phone)
str_match(strings, phone)

# Extract/match all
str_extract_all(strings, phone)
str_match_all(strings, phone)

# You can also name the groups to make further manipulation easier
phone &lt;- "(?&lt;area&gt;[2-9][0-9]{2})[- .](?&lt;phone&gt;[0-9]{3}[- .][0-9]{4})"
str_match(strings, phone)

x &lt;- c("&lt;a&gt; &lt;b&gt;", "&lt;a&gt; &lt;&gt;", "&lt;a&gt;", "", NA)
str_match(x, "&lt;(.*?)&gt; &lt;(.*?)&gt;")
str_match_all(x, "&lt;(.*?)&gt;")

str_extract(x, "&lt;.*?&gt;")
str_extract_all(x, "&lt;.*?&gt;")
</code></pre>

<hr>
<h2 id='str_order'>Order, rank, or sort a character vector</h2><span id='topic+str_order'></span><span id='topic+str_rank'></span><span id='topic+str_sort'></span>

<h3>Description</h3>


<ul>
<li> <p><code>str_sort()</code> returns the sorted vector.
</p>
</li>
<li> <p><code>str_order()</code> returns an integer vector that returns the desired
order when used for subsetting, i.e. <code>x[str_order(x)]</code> is the same
as <code>str_sort()</code>
</p>
</li>
<li> <p><code>str_rank()</code> returns the ranks of the values, i.e.
<code>arrange(df, str_rank(x))</code> is the same as <code>str_sort(df$x)</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>str_order(
  x,
  decreasing = FALSE,
  na_last = TRUE,
  locale = "en",
  numeric = FALSE,
  ...
)

str_rank(x, locale = "en", numeric = FALSE, ...)

str_sort(
  x,
  decreasing = FALSE,
  na_last = TRUE,
  locale = "en",
  numeric = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_order_+3A_x">x</code></td>
<td>
<p>A character vector to sort.</p>
</td></tr>
<tr><td><code id="str_order_+3A_decreasing">decreasing</code></td>
<td>
<p>A boolean. If <code>FALSE</code>, the default, sorts from
lowest to highest; if <code>TRUE</code> sorts from highest to lowest.</p>
</td></tr>
<tr><td><code id="str_order_+3A_na_last">na_last</code></td>
<td>
<p>Where should <code>NA</code> go? <code>TRUE</code> at the end,
<code>FALSE</code> at the beginning, <code>NA</code> dropped.</p>
</td></tr>
<tr><td><code id="str_order_+3A_locale">locale</code></td>
<td>
<p>Locale to use for comparisons. See
<code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> for all possible options.
Defaults to &quot;en&quot; (English) to ensure that default behaviour is
consistent across platforms.</p>
</td></tr>
<tr><td><code id="str_order_+3A_numeric">numeric</code></td>
<td>
<p>If <code>TRUE</code>, will sort digits numerically, instead
of as strings.</p>
</td></tr>
<tr><td><code id="str_order_+3A_...">...</code></td>
<td>
<p>Other options used to control collation. Passed on to
<code><a href="stringi.html#topic+stri_opts_collator">stringi::stri_opts_collator()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_order">stringi::stri_order()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("apple", "car", "happy", "char")
str_sort(x)

str_order(x)
x[str_order(x)]

str_rank(x)

# In Czech, ch is a digraph that sorts after h
str_sort(x, locale = "cs")

# Use numeric = TRUE to sort numbers in strings
x &lt;- c("100a10", "100a5", "2b", "2a")
str_sort(x)
str_sort(x, numeric = TRUE)
</code></pre>

<hr>
<h2 id='str_pad'>Pad a string to minimum width</h2><span id='topic+str_pad'></span>

<h3>Description</h3>

<p>Pad a string to a fixed width, so that
<code>str_length(str_pad(x, n))</code> is always greater than or equal to <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_pad(
  string,
  width,
  side = c("left", "right", "both"),
  pad = " ",
  use_width = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_pad_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_pad_+3A_width">width</code></td>
<td>
<p>Minimum width of padded strings.</p>
</td></tr>
<tr><td><code id="str_pad_+3A_side">side</code></td>
<td>
<p>Side on which padding character is added (left, right or both).</p>
</td></tr>
<tr><td><code id="str_pad_+3A_pad">pad</code></td>
<td>
<p>Single padding character (default is a space).</p>
</td></tr>
<tr><td><code id="str_pad_+3A_use_width">use_width</code></td>
<td>
<p>If <code>FALSE</code>, use the length of the string instead of the
width; see <code><a href="#topic+str_width">str_width()</a></code>/<code><a href="#topic+str_length">str_length()</a></code> for the difference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>stringr</code>/<code>width</code>/<code>pad</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+str_trim">str_trim()</a></code> to remove whitespace;
<code><a href="#topic+str_trunc">str_trunc()</a></code> to decrease the maximum width of a string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rbind(
  str_pad("hadley", 30, "left"),
  str_pad("hadley", 30, "right"),
  str_pad("hadley", 30, "both")
)

# All arguments are vectorised except side
str_pad(c("a", "abc", "abcdef"), 10)
str_pad("a", c(5, 10, 20))
str_pad("a", 10, pad = c("-", "_", " "))

# Longer strings are returned unchanged
str_pad("hadley", 3)
</code></pre>

<hr>
<h2 id='str_remove'>Remove matched patterns</h2><span id='topic+str_remove'></span><span id='topic+str_remove_all'></span>

<h3>Description</h3>

<p>Remove matches, i.e. replace them with <code>""</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_remove(string, pattern)

str_remove_all(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_remove_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_remove_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>/<code>pattern</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+str_replace">str_replace()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruits &lt;- c("one apple", "two pears", "three bananas")
str_remove(fruits, "[aeiou]")
str_remove_all(fruits, "[aeiou]")
</code></pre>

<hr>
<h2 id='str_replace'>Replace matches with new text</h2><span id='topic+str_replace'></span><span id='topic+str_replace_all'></span>

<h3>Description</h3>

<p><code>str_replace()</code> replaces the first match; <code>str_replace_all()</code> replaces
all matches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_replace(string, pattern, replacement)

str_replace_all(string, pattern, replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_replace_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_replace_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described
in <a href="stringi.html#topic+about_search_regex">stringi::about_search_regex</a>. Control options with
<code><a href="#topic+regex">regex()</a></code>.
</p>
<p>For <code>str_replace_all()</code> this can also be a named vector
(<code>c(pattern1 = replacement1)</code>), in order to perform multiple replacements
in each element of <code>string</code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.</p>
</td></tr>
<tr><td><code id="str_replace_+3A_replacement">replacement</code></td>
<td>
<p>The replacement value, usually a single string,
but it can be the a vector the same length as <code>string</code> or <code>pattern</code>.
References of the form <code style="white-space: pre;">&#8288;\1&#8288;</code>, <code style="white-space: pre;">&#8288;\2&#8288;</code>, etc will be replaced with
the contents of the respective matched group (created by <code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>Alternatively, supply a function, which will be called once for each
match (from right to left) and its return value will be used to replace
the match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as
<code>string</code>/<code>pattern</code>/<code>replacement</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+str_replace_na">str_replace_na()</a></code> to turn missing values into &quot;NA&quot;;
<code><a href="stringi.html#topic+stri_replace">stri_replace()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruits &lt;- c("one apple", "two pears", "three bananas")
str_replace(fruits, "[aeiou]", "-")
str_replace_all(fruits, "[aeiou]", "-")
str_replace_all(fruits, "[aeiou]", toupper)
str_replace_all(fruits, "b", NA_character_)

str_replace(fruits, "([aeiou])", "")
str_replace(fruits, "([aeiou])", "\\1\\1")

# Note that str_replace() is vectorised along text, pattern, and replacement
str_replace(fruits, "[aeiou]", c("1", "2", "3"))
str_replace(fruits, c("a", "e", "i"), "-")

# If you want to apply multiple patterns and replacements to the same
# string, pass a named vector to pattern.
fruits %&gt;%
  str_c(collapse = "---") %&gt;%
  str_replace_all(c("one" = "1", "two" = "2", "three" = "3"))

# Use a function for more sophisticated replacement. This example
# replaces colour names with their hex values.
colours &lt;- str_c("\\b", colors(), "\\b", collapse="|")
col2hex &lt;- function(col) {
  rgb &lt;- col2rgb(col)
  rgb(rgb["red", ], rgb["green", ], rgb["blue", ], max = 255)
}

x &lt;- c(
  "Roses are red, violets are blue",
  "My favourite colour is green"
)
str_replace_all(x, colours, col2hex)
</code></pre>

<hr>
<h2 id='str_replace_na'>Turn NA into &quot;NA&quot;</h2><span id='topic+str_replace_na'></span>

<h3>Description</h3>

<p>Turn NA into &quot;NA&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_replace_na(string, replacement = "NA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_replace_na_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_replace_na_+3A_replacement">replacement</code></td>
<td>
<p>A single string.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>str_replace_na(c(NA, "abc", "def"))
</code></pre>

<hr>
<h2 id='str_split'>Split up a string into pieces</h2><span id='topic+str_split'></span><span id='topic+str_split_1'></span><span id='topic+str_split_fixed'></span><span id='topic+str_split_i'></span>

<h3>Description</h3>

<p>This family of functions provides various ways of splitting a string up
into pieces. These two functions return a character vector:
</p>

<ul>
<li> <p><code>str_split_1()</code> takes a single string and splits it into pieces,
returning a single character vector.
</p>
</li>
<li> <p><code>str_split_i()</code> splits each string in a character vector into pieces and
extracts the <code>i</code>th value, returning a character vector.
</p>
</li></ul>

<p>These two functions return a more complex object:
</p>

<ul>
<li> <p><code>str_split()</code> splits each string in a character vector into a varying
number of pieces, returning a list of character vectors.
</p>
</li>
<li> <p><code>str_split_fixed()</code> splits each string in a character vector into a
fixed number of pieces, returning a character matrix.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>str_split(string, pattern, n = Inf, simplify = FALSE)

str_split_1(string, pattern)

str_split_fixed(string, pattern, n)

str_split_i(string, pattern, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_split_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_split_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
<tr><td><code id="str_split_+3A_n">n</code></td>
<td>
<p>Maximum number of pieces to return. Default (Inf) uses all
possible split positions.
</p>
<p>For <code>str_split()</code>, this determines the maximum length of each element
of the output. For <code>str_split_fixed()</code>, this determines the number of
columns in the output; if an input is too short, the result will be padded
with <code>""</code>.</p>
</td></tr>
<tr><td><code id="str_split_+3A_simplify">simplify</code></td>
<td>
<p>A boolean.
</p>

<ul>
<li> <p><code>FALSE</code> (the default): returns a list of character vectors.
</p>
</li>
<li> <p><code>TRUE</code>: returns a character matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="str_split_+3A_i">i</code></td>
<td>
<p>Element to return. Use a negative value to count from the
right hand side.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>str_split_1()</code>: a character vector.
</p>
</li>
<li> <p><code>str_split()</code>: a list the same length as <code>string</code>/<code>pattern</code> containing
character vectors.
</p>
</li>
<li> <p><code>str_split_fixed()</code>: a character matrix with <code>n</code> columns and the same
number of rows as the length of <code>string</code>/<code>pattern</code>.
</p>
</li>
<li> <p><code>str_split_i()</code>: a character vector the same length as <code>string</code>/<code>pattern</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_split">stri_split()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruits &lt;- c(
  "apples and oranges and pears and bananas",
  "pineapples and mangos and guavas"
)

str_split(fruits, " and ")
str_split(fruits, " and ", simplify = TRUE)

# If you want to split a single string, use `str_split_1`
str_split_1(fruits[[1]], " and ")

# Specify n to restrict the number of possible matches
str_split(fruits, " and ", n = 3)
str_split(fruits, " and ", n = 2)
# If n greater than number of pieces, no padding occurs
str_split(fruits, " and ", n = 5)

# Use fixed to return a character matrix
str_split_fixed(fruits, " and ", 3)
str_split_fixed(fruits, " and ", 4)

# str_split_i extracts only a single piece from a string
str_split_i(fruits, " and ", 1)
str_split_i(fruits, " and ", 4)
# use a negative number to select from the end
str_split_i(fruits, " and ", -1)
</code></pre>

<hr>
<h2 id='str_starts'>Detect the presence/absence of a match at the start/end</h2><span id='topic+str_starts'></span><span id='topic+str_ends'></span>

<h3>Description</h3>

<p><code>str_starts()</code> and <code>str_ends()</code> are special cases of <code><a href="#topic+str_detect">str_detect()</a></code> that
only match at the beginning or end of a string, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_starts(string, pattern, negate = FALSE)

str_ends(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_starts_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_starts_+3A_pattern">pattern</code></td>
<td>
<p>Pattern with which the string starts or ends.
</p>
<p>The default interpretation is a regular expression, as described in
<a href="stringi.html#topic+about_search_regex">stringi::about_search_regex</a>. Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>. This
is fast, but approximate. Generally, for matching human text, you'll want
<code><a href="#topic+coll">coll()</a></code> which respects character matching rules for the specified locale.</p>
</td></tr>
<tr><td><code id="str_starts_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, inverts the resulting boolean vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit &lt;- c("apple", "banana", "pear", "pineapple")
str_starts(fruit, "p")
str_starts(fruit, "p", negate = TRUE)
str_ends(fruit, "e")
str_ends(fruit, "e", negate = TRUE)
</code></pre>

<hr>
<h2 id='str_sub'>Get and set substrings using their positions</h2><span id='topic+str_sub'></span><span id='topic+str_sub+3C-'></span><span id='topic+str_sub_all'></span>

<h3>Description</h3>

<p><code>str_sub()</code> extracts or replaces the elements at a single position in each
string. <code>str_sub_all()</code> allows you to extract strings at multiple elements
in every string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_sub(string, start = 1L, end = -1L)

str_sub(string, start = 1L, end = -1L, omit_na = FALSE) &lt;- value

str_sub_all(string, start = 1L, end = -1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_sub_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_sub_+3A_start">start</code>, <code id="str_sub_+3A_end">end</code></td>
<td>
<p>A pair of integer vectors defining the range of characters
to extract (inclusive).
</p>
<p>Alternatively, instead of a pair of vectors, you can pass a matrix to
<code>start</code>. The matrix should have two columns, either labelled <code>start</code>
and <code>end</code>, or <code>start</code> and <code>length</code>.</p>
</td></tr>
<tr><td><code id="str_sub_+3A_omit_na">omit_na</code></td>
<td>
<p>Single logical value. If <code>TRUE</code>, missing values in any of the
arguments provided will result in an unchanged input.</p>
</td></tr>
<tr><td><code id="str_sub_+3A_value">value</code></td>
<td>
<p>replacement string</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>str_sub()</code>: A character vector the same length as <code>string</code>/<code>start</code>/<code>end</code>.
</p>
</li>
<li> <p><code>str_sub_all()</code>: A list the same length as <code>string</code>. Each element is
a character vector the same length as <code>start</code>/<code>end</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>The underlying implementation in <code><a href="stringi.html#topic+stri_sub">stringi::stri_sub()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hw &lt;- "Hadley Wickham"

str_sub(hw, 1, 6)
str_sub(hw, end = 6)
str_sub(hw, 8, 14)
str_sub(hw, 8)

# Negative indices index from end of string
str_sub(hw, -1)
str_sub(hw, -7)
str_sub(hw, end = -7)

# str_sub() is vectorised by both string and position
str_sub(hw, c(1, 8), c(6, 14))

# if you want to extract multiple positions from multiple strings,
# use str_sub_all()
x &lt;- c("abcde", "ghifgh")
str_sub(x, c(1, 2), c(2, 4))
str_sub_all(x, start = c(1, 2), end = c(2, 4))

# Alternatively, you can pass in a two column matrix, as in the
# output from str_locate_all
pos &lt;- str_locate_all(hw, "[aeio]")[[1]]
pos
str_sub(hw, pos)

# You can also use `str_sub()` to modify strings:
x &lt;- "BBCDEF"
str_sub(x, 1, 1) &lt;- "A"; x
str_sub(x, -1, -1) &lt;- "K"; x
str_sub(x, -2, -2) &lt;- "GHIJ"; x
str_sub(x, 2, -2) &lt;- ""; x
</code></pre>

<hr>
<h2 id='str_subset'>Find matching elements</h2><span id='topic+str_subset'></span>

<h3>Description</h3>

<p><code>str_subset()</code> returns all elements of <code>string</code> where there's at least
one match to <code>pattern</code>. It's a wrapper around <code>x[str_detect(x, pattern)]</code>,
and is equivalent to <code>grep(pattern, x, value = TRUE)</code>.
</p>
<p>Use <code><a href="#topic+str_extract">str_extract()</a></code> to find the location of the match <em>within</em> each string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_subset(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_subset_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_subset_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
<tr><td><code id="str_subset_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, inverts the resulting boolean vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, usually smaller than <code>string</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep()</a></code> with argument <code>value = TRUE</code>,
<code><a href="stringi.html#topic+stri_subset">stringi::stri_subset()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit &lt;- c("apple", "banana", "pear", "pineapple")
str_subset(fruit, "a")

str_subset(fruit, "^a")
str_subset(fruit, "a$")
str_subset(fruit, "b")
str_subset(fruit, "[aeiou]")

# Elements that don't match
str_subset(fruit, "^p", negate = TRUE)

# Missings never match
str_subset(c("a", NA, "b"), ".")
</code></pre>

<hr>
<h2 id='str_trim'>Remove whitespace</h2><span id='topic+str_trim'></span><span id='topic+str_squish'></span>

<h3>Description</h3>

<p><code>str_trim()</code> removes whitespace from start and end of string; <code>str_squish()</code>
removes whitespace at the start and end, and replaces all internal whitespace
with a single space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_trim(string, side = c("both", "left", "right"))

str_squish(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_trim_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_trim_+3A_side">side</code></td>
<td>
<p>Side on which to remove whitespace: &quot;left&quot;, &quot;right&quot;, or
&quot;both&quot;, the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+str_pad">str_pad()</a></code> to add whitespace
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_trim("  String with trailing and leading white space\t")
str_trim("\n\nString with trailing and leading white space\n\n")

str_squish("  String with trailing,  middle, and leading white space\t")
str_squish("\n\nString with excess,  trailing and leading white   space\n\n")
</code></pre>

<hr>
<h2 id='str_trunc'>Truncate a string to maximum width</h2><span id='topic+str_trunc'></span>

<h3>Description</h3>

<p>Truncate a string to a fixed of characters, so that
<code>str_length(str_trunc(x, n))</code> is always less than or equal to <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_trunc(string, width, side = c("right", "left", "center"), ellipsis = "...")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_trunc_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_trunc_+3A_width">width</code></td>
<td>
<p>Maximum width of string.</p>
</td></tr>
<tr><td><code id="str_trunc_+3A_side">side</code>, <code id="str_trunc_+3A_ellipsis">ellipsis</code></td>
<td>
<p>Location and content of ellipsis that indicates
content has been removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+str_pad">str_pad()</a></code> to increase the minimum width of a string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "This string is moderately long"
rbind(
  str_trunc(x, 20, "right"),
  str_trunc(x, 20, "left"),
  str_trunc(x, 20, "center")
)
</code></pre>

<hr>
<h2 id='str_unique'>Remove duplicated strings</h2><span id='topic+str_unique'></span>

<h3>Description</h3>

<p><code>str_unique()</code> removes duplicated values, with optional control over
how duplication is measured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_unique(string, locale = "en", ignore_case = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_unique_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_unique_+3A_locale">locale</code></td>
<td>
<p>Locale to use for comparisons. See
<code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> for all possible options.
Defaults to &quot;en&quot; (English) to ensure that default behaviour is
consistent across platforms.</p>
</td></tr>
<tr><td><code id="str_unique_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Ignore case when comparing strings?</p>
</td></tr>
<tr><td><code id="str_unique_+3A_...">...</code></td>
<td>
<p>Other options used to control collation. Passed on to
<code><a href="stringi.html#topic+stri_opts_collator">stringi::stri_opts_collator()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, usually shorter than <code>string</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique()</a></code>, <code><a href="stringi.html#topic+stri_unique">stringi::stri_unique()</a></code> which this function wraps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_unique(c("a", "b", "c", "b", "a"))

str_unique(c("a", "b", "c", "B", "A"))
str_unique(c("a", "b", "c", "B", "A"), ignore_case = TRUE)

# Use ... to pass additional arguments to stri_unique()
str_unique(c("motley", "mtley", "pinguino", "pingino"))
str_unique(c("motley", "mtley", "pinguino", "pingino"), strength = 1)
</code></pre>

<hr>
<h2 id='str_view'>View strings and matches</h2><span id='topic+str_view'></span><span id='topic+str_view_all'></span>

<h3>Description</h3>

<p><code>str_view()</code> is used to print the underlying representation of a string and
to see how a <code>pattern</code> matches.
</p>
<p>Matches are surrounded by <code style="white-space: pre;">&#8288;&lt;&gt;&#8288;</code> and unusual whitespace (i.e. all whitespace
apart from <code>" "</code> and <code>"\n"</code>) are surrounded by <code>{}</code> and escaped. Where
possible, matches and unusual whitespace are coloured blue and <code>NA</code>s red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_view(
  string,
  pattern = NULL,
  match = TRUE,
  html = FALSE,
  use_escapes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_view_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_view_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
<tr><td><code id="str_view_+3A_match">match</code></td>
<td>
<p>If <code>pattern</code> is supplied, which elements should be shown?
</p>

<ul>
<li> <p><code>TRUE</code>, the default, shows only elements that match the pattern.
</p>
</li>
<li> <p><code>NA</code> shows all elements.
</p>
</li>
<li> <p><code>FALSE</code> shows only elements that don't match the pattern.
</p>
</li></ul>

<p>If <code>pattern</code> is not supplied, all elements are always shown.</p>
</td></tr>
<tr><td><code id="str_view_+3A_html">html</code></td>
<td>
<p>Use HTML output? If <code>TRUE</code> will create an HTML widget; if <code>FALSE</code>
will style using ANSI escapes.</p>
</td></tr>
<tr><td><code id="str_view_+3A_use_escapes">use_escapes</code></td>
<td>
<p>If <code>TRUE</code>, all non-ASCII characters will be rendered
with unicode escapes. This is useful to see exactly what underlying
values are stored in the string.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Show special characters
str_view(c("\"\\", "\\\\\\", "fgh", NA, "NA"))

# A non-breaking space looks like a regular space:
nbsp &lt;- "Hi\u00A0you"
nbsp
# But it doesn't behave like one:
str_detect(nbsp, " ")
# So str_view() brings it to your attention with a blue background
str_view(nbsp)

# You can also use escapes to see all non-ASCII characters
str_view(nbsp, use_escapes = TRUE)

# Supply a pattern to see where it matches
str_view(c("abc", "def", "fghi"), "[aeiou]")
str_view(c("abc", "def", "fghi"), "^")
str_view(c("abc", "def", "fghi"), "..")

# By default, only matching strings will be shown
str_view(c("abc", "def", "fghi"), "e")
# but you can show all:
str_view(c("abc", "def", "fghi"), "e", match = NA)
# or just those that don't match:
str_view(c("abc", "def", "fghi"), "e", match = FALSE)
</code></pre>

<hr>
<h2 id='str_which'>Find matching indices</h2><span id='topic+str_which'></span>

<h3>Description</h3>

<p><code>str_which()</code> returns the indices of <code>string</code> where there's at least
one match to <code>pattern</code>. It's a wrapper around
<code>which(str_detect(x, pattern))</code>, and is equivalent to <code>grep(pattern, x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_which(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_which_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_which_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
<tr><td><code id="str_which_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, inverts the resulting boolean vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector, usually smaller than <code>string</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit &lt;- c("apple", "banana", "pear", "pineapple")
str_which(fruit, "a")

# Elements that don't match
str_which(fruit, "^p", negate = TRUE)

# Missings never match
str_which(c("a", NA, "b"), ".")
</code></pre>

<hr>
<h2 id='str_wrap'>Wrap words into nicely formatted paragraphs</h2><span id='topic+str_wrap'></span>

<h3>Description</h3>

<p>Wrap words into paragraphs, minimizing the &quot;raggedness&quot; of the lines
(i.e. the variation in length line) using the Knuth-Plass algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_wrap(string, width = 80, indent = 0, exdent = 0, whitespace_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_wrap_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_wrap_+3A_width">width</code></td>
<td>
<p>Positive integer giving target line width (in number of
characters). A width less than or equal to 1 will put each word on its
own line.</p>
</td></tr>
<tr><td><code id="str_wrap_+3A_indent">indent</code>, <code id="str_wrap_+3A_exdent">exdent</code></td>
<td>
<p>A non-negative integer giving the indent for the
first line (<code>indent</code>) and all subsequent lines (<code>exdent</code>).</p>
</td></tr>
<tr><td><code id="str_wrap_+3A_whitespace_only">whitespace_only</code></td>
<td>
<p>A boolean.
</p>

<ul>
<li><p> If <code>TRUE</code> (the default) wrapping will only occur at whitespace.
</p>
</li>
<li><p> If <code>FALSE</code>, can break on any non-word character (e.g. <code>/</code>, <code>-</code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_wrap">stringi::stri_wrap()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>thanks_path &lt;- file.path(R.home("doc"), "THANKS")
thanks &lt;- str_c(readLines(thanks_path), collapse = "\n")
thanks &lt;- word(thanks, 1, 3, fixed("\n\n"))
cat(str_wrap(thanks), "\n")
cat(str_wrap(thanks, width = 40), "\n")
cat(str_wrap(thanks, width = 60, indent = 2), "\n")
cat(str_wrap(thanks, width = 60, exdent = 2), "\n")
cat(str_wrap(thanks, width = 0, exdent = 2), "\n")
</code></pre>

<hr>
<h2 id='stringr-data'>Sample character vectors for practicing string manipulations</h2><span id='topic+stringr-data'></span><span id='topic+sentences'></span><span id='topic+fruit'></span><span id='topic+words'></span>

<h3>Description</h3>

<p><code>fruit</code> and <code>words</code> come from the <code>rcorpora</code> package
written by Gabor Csardi; the data was collected by Darius Kazemi
and made available at <a href="https://github.com/dariusk/corpora">https://github.com/dariusk/corpora</a>.
<code>sentences</code> is a collection of &quot;Harvard sentences&quot; used for
standardised testing of voice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sentences

fruit

words
</code></pre>


<h3>Format</h3>

<p>Character vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>length(sentences)
sentences[1:5]

length(fruit)
fruit[1:5]

length(words)
words[1:5]
</code></pre>

<hr>
<h2 id='stringr-package'>stringr: Simple, Consistent Wrappers for Common String Operations</h2><span id='topic+stringr'></span><span id='topic+stringr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A consistent, simple and easy to use set of wrappers around the fantastic 'stringi' package. All function and argument names (and positions) are consistent, all functions deal with &quot;NA&quot;'s and zero length vectors in the same way, and the output from one function is easy to feed into the input of another.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://stringr.tidyverse.org">https://stringr.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/stringr">https://github.com/tidyverse/stringr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/stringr/issues">https://github.com/tidyverse/stringr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='word'>Extract words from a sentence</h2><span id='topic+word'></span>

<h3>Description</h3>

<p>Extract words from a sentence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>word(string, start = 1L, end = start, sep = fixed(" "))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="word_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="word_+3A_start">start</code>, <code id="word_+3A_end">end</code></td>
<td>
<p>Pair of integer vectors giving range of words (inclusive)
to extract. If negative, counts backwards from the last word.
</p>
<p>The default value select the first word.</p>
</td></tr>
<tr><td><code id="word_+3A_sep">sep</code></td>
<td>
<p>Separator between words. Defaults to single space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the same length as <code>string</code>/<code>start</code>/<code>end</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sentences &lt;- c("Jane saw a cat", "Jane sat down")
word(sentences, 1)
word(sentences, 2)
word(sentences, -1)
word(sentences, 2, -1)

# Also vectorised over start and end
word(sentences[1], 1:3, -1)
word(sentences[1], 1, 1:4)

# Can define words by other separators
str &lt;- 'abc.def..123.4568.999'
word(str, 1, sep = fixed('..'))
word(str, 2, sep = fixed('..'))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
