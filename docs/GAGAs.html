<!DOCTYPE html><html lang="en-US"><head><title>Help for package GAGAs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GAGAs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cal.acc'><p>Calculate ACC for classification, the inputs must be characters</p></a></li>
<li><a href='#cal.cindex'><p>compute C index for a Cox model</p></a></li>
<li><a href='#cal.F1Score'><p>Calculate F1 score for classification, the inputs must be characters, and each of these elements must be either 'FALSE' or 'TRUE'.</p></a></li>
<li><a href='#cal.w.acc'><p>Calculate the weighted ACC of the classification, the inputs must be characters</p></a></li>
<li><a href='#cox_GAGA'><p>Fit a Cox model via the GAGA algorithm.</p></a></li>
<li><a href='#cpp_COX_gaga'><p>Fit a Cox model via the GAGA algorithm using cpp.</p></a></li>
<li><a href='#cpp_logistic_gaga'><p>Fit a logistic model via the Global Adaptive Generative Adjustment algorithm using cpp</p></a></li>
<li><a href='#cpp_multinomial_gaga'><p>Fit a multinomial model via the GAGA algorithm using cpp</p></a></li>
<li><a href='#cpp_poisson_gaga'><p>Fit a poisson model via the GAGA algorithm using cpp</p></a></li>
<li><a href='#GAGAs'><p>GAGAs: A package for fiting a GLM with GAGA algorithm</p></a></li>
<li><a href='#LM_GAGA'><p>Fit a linear model via the GAGA algorithm</p></a></li>
<li><a href='#logistic_GAGA'><p>Fit a logistic model via the Global Adaptive Generative Adjustment algorithm</p></a></li>
<li><a href='#multinomial_GAGA'><p>Fit a multinomial model via the GAGA algorithm</p></a></li>
<li><a href='#poisson_GAGA'><p>Fit a Poisson model via the GAGA algorithm</p></a></li>
<li><a href='#predict_cox_GAGA'><p>Get predictions from a GAGA cox model fit object</p></a></li>
<li><a href='#predict_LM_GAGA'><p>Get predictions from a GAGA linear model fit object</p></a></li>
<li><a href='#predict_logistic_GAGA'><p>Get predictions from a GAGA logistic model fit object</p></a></li>
<li><a href='#predict_multinomial_GAGA'><p>Get predictions from a GAGA multinomial model fit object</p></a></li>
<li><a href='#predict_poisson_GAGA'><p>Get predictions from a GAGA poisson model fit object</p></a></li>
<li><a href='#predict.GAGA'><p>Get predictions from a GAGA fit object</p></a></li>
<li><a href='#rcpp_lm_gaga'><p>Fit a linear model via the GAGA algorithm using cpp.</p></a></li>
<li><a href='#summary.GAGA'><p>Print a summary of GAGA object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Global Adaptive Generative Adjustment Algorithm for Generalized
Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits linear regression, logistic and multinomial regression models, Poisson regression, Cox model via Global Adaptive Generative Adjustment Algorithm.  
 For more detailed information, see Bin Wang, Xiaofei Wang and Jianhua Guo (2022) &lt;<a href="https://doi.org/10.48550/arXiv.1911.00658">doi:10.48550/arXiv.1911.00658</a>&gt;. 
 This paper provides the theoretical properties of Gaga linear model when the load matrix is orthogonal. 
 Further study is going on for the nonorthogonal cases and generalized linear models. 
 These works are in part supported by the National Natural Foundation of China (No.12171076). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/1911.00658">https://arxiv.org/abs/1911.00658</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), survival, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bin Wang &lt;eatingbeen@hotmail.com&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 06:45:10 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Bin Wang [aut, cre],
  Xiaofei Wang [ctb],
  Jianhua Guo [ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 07:02:53 UTC</td>
</tr>
</table>
<hr>
<h2 id='cal.acc'>Calculate ACC for classification, the inputs must be characters</h2><span id='topic+cal.acc'></span>

<h3>Description</h3>

<p>Calculate ACC for classification, the inputs must be characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.acc(predictions, truelabels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal.acc_+3A_predictions">predictions</code></td>
<td>
<p>predictions</p>
</td></tr>
<tr><td><code id="cal.acc_+3A_truelabels">truelabels</code></td>
<td>
<p>true labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ACC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2022)
p_size = 30
sample_size=300
R1 = 3
R2 = 2
ratio = 0.5 #The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y=X%*%beta_true + rnorm(sample_size,mean=0,sd=2)
# Estimation
fit = GAGAs(X,y,alpha = 3,family="gaussian")
Eb = fit$beta
#Create testing data
X_t = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y_t=X_t%*%beta_true + rnorm(sample_size,mean=0,sd=2)
#Prediction
Ey = predict.GAGA(fit,newx=X_t)

cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n perr:", norm(Ey-y_t,type="2")/sqrt(sample_size))
</code></pre>

<hr>
<h2 id='cal.cindex'>compute C index for a Cox model</h2><span id='topic+cal.cindex'></span>

<h3>Description</h3>

<p>Computes Harrel's C index for predictions from a <code>"cox"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.cindex(pred, y, weights = rep(1, nrow(y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal.cindex_+3A_pred">pred</code></td>
<td>
<p>Predictions from a <code>"cox"</code> object</p>
</td></tr>
<tr><td><code id="cal.cindex_+3A_y">y</code></td>
<td>
<p>a survival response object - a matrix with two columns &quot;time&quot; and
&quot;status&quot;; see documentation for &quot;glmnet&quot; or see documentation for &quot;GAGA&quot;</p>
</td></tr>
<tr><td><code id="cal.cindex_+3A_weights">weights</code></td>
<td>
<p>optional observation weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the concordance index, taking into account censoring.
This file fully references the Cindex.R file in glmnet package.
</p>


<h3>Value</h3>

<p>Harrel's C index
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie  &lt;hastie@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Harrel Jr, F. E. and Lee, K. L. and Mark, D. B. (1996)
<em>Tutorial in biostatistics: multivariable prognostic models: issues in
developing models, evaluating assumptions and adequacy, and measuring and
reducing error</em>, Statistics in Medicine, 15, pages 361&ndash;387.
</p>


<h3>See Also</h3>

<p><code>cv.glmnet</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(10101)
N = 1000
p = 30
nzc = p/3
x = matrix(rnorm(N * p), N, p)
beta = rnorm(nzc)
fx = x[, seq(nzc)] %*% beta/3
hx = exp(fx)
ty = rexp(N, hx)
tcens = rbinom(n = N, prob = 0.3, size = 1)  # censoring indicator
y = cbind(time = ty, status = 1 - tcens)  # y=Surv(ty,1-tcens) with library(survival)
fit = GAGAs(x, y, family = "cox")
pred = predict(fit, newx = x)
cat("\n Cindex:", cal.cindex(pred, y))


</code></pre>

<hr>
<h2 id='cal.F1Score'>Calculate F1 score for classification, the inputs must be characters, and each of these elements must be either 'FALSE' or 'TRUE'.</h2><span id='topic+cal.F1Score'></span>

<h3>Description</h3>

<p>Calculate F1 score for classification, the inputs must be characters, and each of these elements must be either 'FALSE' or 'TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.F1Score(predictions, truelabels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal.F1Score_+3A_predictions">predictions</code></td>
<td>
<p>predictions</p>
</td></tr>
<tr><td><code id="cal.F1Score_+3A_truelabels">truelabels</code></td>
<td>
<p>true labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>F1 score
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2022)
p_size = 30
sample_size=300
R1 = 3
R2 = 2
ratio = 0.5 #The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y=X%*%beta_true + rnorm(sample_size,mean=0,sd=2)
# Estimation
fit = GAGAs(X,y,alpha = 3,family="gaussian")
Eb = fit$beta
cat("\n F1 score:", cal.F1Score(as.character(Eb!=0),as.character(beta_true!=0)))
</code></pre>

<hr>
<h2 id='cal.w.acc'>Calculate the weighted ACC of the classification, the inputs must be characters</h2><span id='topic+cal.w.acc'></span>

<h3>Description</h3>

<p>Calculate the weighted ACC of the classification, the inputs must be characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.w.acc(predictions, truelabels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal.w.acc_+3A_predictions">predictions</code></td>
<td>
<p>predictions</p>
</td></tr>
<tr><td><code id="cal.w.acc_+3A_truelabels">truelabels</code></td>
<td>
<p>true labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>weighted ACC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2022)
p_size = 30
sample_size=300
R1 = 3
R2 = 2
ratio = 0.5 #The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y=X%*%beta_true + rnorm(sample_size,mean=0,sd=2)
# Estimation
fit = GAGAs(X,y,alpha = 3,family="gaussian")
Eb = fit$beta
#Create testing data
X_t = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y_t=X_t%*%beta_true + rnorm(sample_size,mean=0,sd=2)
#Prediction
Ey = predict.GAGA(fit,newx=X_t)

cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n perr:", norm(Ey-y_t,type="2")/sqrt(sample_size))
</code></pre>

<hr>
<h2 id='cox_GAGA'>Fit a Cox model via the GAGA algorithm.</h2><span id='topic+cox_GAGA'></span>

<h3>Description</h3>

<p>Fit a Cox model via the Global Adaptive Generative Adjustment algorithm.
Part of this function refers to the coxphfit function in MATLAB 2016b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox_GAGA(
  X,
  t,
  alpha = 2,
  itrNum = 20,
  thresh = 0.001,
  flag = TRUE,
  lamda_0 = 0.5,
  fdiag = TRUE,
  subItrNum = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cox_GAGA_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="cox_GAGA_+3A_t">t</code></td>
<td>
<p>A n*2 matrix, one column should be named &quot;time&quot;, indicating the survival time;
the other column must be named &quot;status&quot;, and consists of 0 and 1, 0 indicates that the row of data is censored, 1 is opposite.</p>
</td></tr>
<tr><td><code id="cox_GAGA_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 2 or 3.</p>
</td></tr>
<tr><td><code id="cox_GAGA_+3A_itrnum">itrNum</code></td>
<td>
<p>Maximum number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="cox_GAGA_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="cox_GAGA_+3A_flag">flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cox_GAGA_+3A_lamda_0">lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="cox_GAGA_+3A_fdiag">fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="cox_GAGA_+3A_subitrnum">subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2022)
p_size = 50
sample_size = 500
test_size = 1000
R1 = 3
R2 = 1
ratio = 0.5 #The ratio of zeroes in coefficients
censoringRate = 0.25 #Proportion of censoring data in observation data
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,-R2,R2)
beta_true[ind] = 0
# Generate training samples
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
z = X%*%beta_true
u = runif(sample_size,0,1)
t = ((-log(1-u)/(3*exp(z)))*100)^(0.1)
cs = rep(0,sample_size)
csNum = round(censoringRate*sample_size)
ind = sample(1:sample_size,csNum)
cs[ind] = 1
t[ind] = runif(csNum,0,0.8)*t[ind]
y = cbind(t,1 - cs)
colnames(y) = c("time", "status")
#Estimation
fit = GAGAs(X,y,alpha=2,family="cox")
Eb = fit$beta

#Generate testing samples
X_t = R1*matrix(rnorm(test_size * p_size), ncol = p_size)
z = X_t%*%beta_true
u = runif(test_size,0,1)
t = ((-log(1-u)/(3*exp(z)))*100)^(0.1)
cs = rep(0,test_size)
csNum = round(censoringRate*test_size)
ind = sample(1:test_size,csNum)
cs[ind] = 1
t[ind] = runif(csNum,0,0.8)*t[ind]
y_t = cbind(t,1 - cs)
colnames(y_t) = c("time", "status")
#Prediction
pred = predict(fit,newx=X_t)

cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n Cindex:", cal.cindex(pred,y_t))
</code></pre>

<hr>
<h2 id='cpp_COX_gaga'>Fit a Cox model via the GAGA algorithm using cpp.</h2><span id='topic+cpp_COX_gaga'></span>

<h3>Description</h3>

<p>Fit a Cox model via the Global Adaptive Generative Adjustment algorithm.
Part of this function refers to the coxphfit function in MATLAB 2016b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_COX_gaga(
  X,
  y,
  cens,
  alpha = 2,
  itrNum = 50L,
  thresh = 0.001,
  flag = TRUE,
  lamda_0 = 0.5,
  fdiag = TRUE,
  subItrNum = 20L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp_COX_gaga_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_y">y</code></td>
<td>
<p>A n*1 matrix, indicating the survival time;</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_cens">cens</code></td>
<td>
<p>A n*1 matrix, consists of 0 and 1, 1 indicates that the row of data is censored, 0 is opposite.</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 2 or 3.</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_itrnum">itrNum</code></td>
<td>
<p>Maximum number of iteration steps. In general, 20 steps are enough.</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_flag">flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_lamda_0">lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_fdiag">fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="cpp_COX_gaga_+3A_subitrnum">subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient vector
</p>

<hr>
<h2 id='cpp_logistic_gaga'>Fit a logistic model via the Global Adaptive Generative Adjustment algorithm using cpp</h2><span id='topic+cpp_logistic_gaga'></span>

<h3>Description</h3>

<p>Fit a logistic model via the Global Adaptive Generative Adjustment algorithm using cpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_logistic_gaga(
  X,
  y,
  s_alpha,
  s_itrNum,
  s_thresh,
  s_flag,
  s_lamda_0,
  s_fdiag,
  s_subItrNum
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp_logistic_gaga_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="cpp_logistic_gaga_+3A_y">y</code></td>
<td>
<p>should be either a factor with two levels.</p>
</td></tr>
<tr><td><code id="cpp_logistic_gaga_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 1 or 2.
When the collinearity of the load matrix is serious, the hyperparameters can be selected larger, such as 5.</p>
</td></tr>
<tr><td><code id="cpp_logistic_gaga_+3A_s_itrnum">s_itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="cpp_logistic_gaga_+3A_s_thresh">s_thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="cpp_logistic_gaga_+3A_s_flag">s_flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cpp_logistic_gaga_+3A_s_lamda_0">s_lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="cpp_logistic_gaga_+3A_s_fdiag">s_fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="cpp_logistic_gaga_+3A_s_subitrnum">s_subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient vector.
</p>

<hr>
<h2 id='cpp_multinomial_gaga'>Fit a multinomial model via the GAGA algorithm using cpp</h2><span id='topic+cpp_multinomial_gaga'></span>

<h3>Description</h3>

<p>Fit a multinomial model the Global Adaptive Generative Adjustment algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_multinomial_gaga(
  X,
  y,
  s_alpha,
  s_itrNum,
  s_thresh,
  s_flag,
  s_lamda_0,
  s_fdiag,
  s_subItrNum
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp_multinomial_gaga_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="cpp_multinomial_gaga_+3A_y">y</code></td>
<td>
<p>a One-hot response matrix or a <code>nc&gt;=2</code> level factor</p>
</td></tr>
<tr><td><code id="cpp_multinomial_gaga_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 1 or 2.
When the collinearity of the load matrix is serious, the hyperparameters can be selected larger, such as 5.</p>
</td></tr>
<tr><td><code id="cpp_multinomial_gaga_+3A_s_itrnum">s_itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="cpp_multinomial_gaga_+3A_s_thresh">s_thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="cpp_multinomial_gaga_+3A_s_flag">s_flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cpp_multinomial_gaga_+3A_s_lamda_0">s_lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="cpp_multinomial_gaga_+3A_s_fdiag">s_fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="cpp_multinomial_gaga_+3A_s_subitrnum">s_subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient matrix with K-1 columns, where K is the class number.
For k=1,..,K-1, the probability
</p>
<p style="text-align: center;"><code class="reqn">Pr(G=k|x)=exp(x^T beta_k) /(1+sum_{k=1}^{K-1}exp(x^T beta_k))</code>
</p>
<p>.
For k=K, the probability </p>
<p style="text-align: center;"><code class="reqn">Pr(G=K|x)=1/(1+sum_{k=1}^{K-1}exp(x^T beta_k))</code>
</p>
<p>.
</p>

<hr>
<h2 id='cpp_poisson_gaga'>Fit a poisson model via the GAGA algorithm using cpp</h2><span id='topic+cpp_poisson_gaga'></span>

<h3>Description</h3>

<p>Fit a poisson model the Global Adaptive Generative Adjustment algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_poisson_gaga(
  X,
  y,
  s_alpha,
  s_itrNum,
  s_thresh,
  s_flag,
  s_lamda_0,
  s_fdiag,
  s_subItrNum
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp_poisson_gaga_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.
In order to run the program stably, it is recommended that the value of X should not be too large. It is recommended to
preprocess all the items in X except the intercept item by means of preprocessing, so that the mean value of each column
is 0 and the standard deviation is <code>1/ colnum(X)</code>.</p>
</td></tr>
<tr><td><code id="cpp_poisson_gaga_+3A_y">y</code></td>
<td>
<p>Non-negative count response vector.</p>
</td></tr>
<tr><td><code id="cpp_poisson_gaga_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 1 or 2.
When the collinearity of the load matrix is serious, the hyperparameters can be selected larger, such as 5.</p>
</td></tr>
<tr><td><code id="cpp_poisson_gaga_+3A_s_itrnum">s_itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="cpp_poisson_gaga_+3A_s_thresh">s_thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="cpp_poisson_gaga_+3A_s_flag">s_flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cpp_poisson_gaga_+3A_s_lamda_0">s_lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="cpp_poisson_gaga_+3A_s_fdiag">s_fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="cpp_poisson_gaga_+3A_s_subitrnum">s_subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient vector.
</p>

<hr>
<h2 id='GAGAs'>GAGAs: A package for fiting a GLM with GAGA algorithm</h2><span id='topic+GAGAs'></span>

<h3>Description</h3>

<p>Fits linear, logistic and multinomial, poisson, and Cox regression models via Global Adaptive Generative Adjustment algorithm.
</p>
<p>Fits linear, logistic and multinomial, poisson, and Cox regression models via the Global Adaptive Generative Adjustment algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAGAs(
  X,
  y,
  family = c("gaussian", "binomial", "poisson", "multinomial", "cox"),
  alpha = 2,
  itrNum = 100,
  thresh = 0.001,
  QR_flag = FALSE,
  flag = TRUE,
  lamda_0 = 0.001,
  fdiag = TRUE,
  frp = TRUE,
  subItrNum = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GAGAs_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_y">y</code></td>
<td>
<p>Response variable. Quantitative for <code>family="gaussian"</code>, or
<code>family="poisson"</code> (non-negative counts). For <code>family="binomial"</code> should be either a factor with two levels.
For <code>family="multinomial"</code> should be a one-hot matrix or a <code>nc&gt;=2</code> level factor.
For <code>family="cox"</code> should be an n*2 matrix, one column should be named &quot;time&quot;, indicating the survival time;
the other column must be named &quot;status&quot;, and consists of 0 and 1, 0 indicates that the row of data is censored, 1 is opposite.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_family">family</code></td>
<td>
<p>Either a character string representing one of the built-in families,
<code>"gaussian"</code>, <code>"binomial"</code>, <code>"poisson"</code>, <code>"multinomial"</code> or <code>"cox"</code>.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter. In general, alpha can be set to 1, 2 or 3.
for <code>family="gaussian"</code> and <code>family="cox"</code>, the suggested value for alpha is 2 or 3.
for <code>family="binomial"</code>, <code>family="poisson"</code> and <code>family="multinomial"</code>, the suggested value for alpha is 1 or 2.
but when the collinearity of the load matrix is serious, the hyperparameters can be selected larger, such as 5.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_itrnum">itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_qr_flag">QR_flag</code></td>
<td>
<p>It identifies whether to use QR decomposition to speed up the algorithm.
Currently only valid for linear models.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_flag">flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_lamda_0">lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_fdiag">fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_frp">frp</code></td>
<td>
<p>Identifies if a method is preprocessed to reduce the number of parameters</p>
</td></tr>
<tr><td><code id="GAGAs_+3A_subitrnum">subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Regression coefficients
</p>


<h3>Mypackage functions</h3>

<p>GAGAs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
set.seed(2022)
p_size = 30
sample_size=300
R1 = 3
R2 = 2
ratio = 0.5 #The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y=X%*%beta_true + rnorm(sample_size,mean=0,sd=2)
# Estimation
fit = GAGAs(X,y,alpha = 3,family="gaussian")
Eb = fit$beta
#Create testing data
X_t = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y_t=X_t%*%beta_true + rnorm(sample_size,mean=0,sd=2)
#Prediction
Ey = predict.GAGA(fit,newx=X_t)

cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n perr:", norm(Ey-y_t,type="2")/sqrt(sample_size))

# binomial
set.seed(2022)
cat("\n")
cat("Test binomial GAGA\n")
p_size = 30
sample_size=600
test_size=1000
R1 = 1
R2 = 3
ratio = 0.5 #The ratio of zeroes in coefficients
#Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,R2*0.2,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
X[1:sample_size,1]=1
t = 1/(1+exp(-X%*%beta_true))
tmp = runif(sample_size,0,1)
y = rep(0,sample_size)
y[t&gt;tmp] = 1
fit = GAGAs(X,y,family = "binomial", alpha = 1)
Eb = fit$beta
#Generate test samples
X_t = R1*matrix(rnorm(test_size * p_size), ncol = p_size)
X_t[1:test_size,1]=1
t = 1/(1+exp(-X_t%*%beta_true))
tmp = runif(test_size,0,1)
y_t = rep(0,test_size)
y_t[t&gt;tmp] = 1
#Prediction
Ey = predict(fit,newx = X_t)
cat("\n--------------------")
cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n pacc:", cal.w.acc(as.character(Ey),as.character(y_t)))
cat("\n")
# multinomial
set.seed(2022)
cat("\n")
cat("Test multinomial GAGA\n")
p_size = 20
C = 3
classnames = c("C1","C2","C3","C4")
sample_size = 500
test_size = 1000
ratio = 0.5 #The ratio of zeroes in coefficients
Num = 10 # Total number of experiments
R1 = 1
R2 = 5
#Set the true coefficients
beta_true = matrix(rep(0,p_size*C),c(p_size,C))
zeroNum = round(ratio*p_size)
for(jj in 1:C){
  ind = sample(1:p_size,zeroNum)
  tmp = runif(p_size,0,R2)
  tmp[ind] = 0
  beta_true[,jj] = tmp
}
#Generate training samples
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
X[1:sample_size,1]=1
z = X%*%beta_true
t = exp(z)/(1+rowSums(exp(z)))
t = cbind(t,1-rowSums(t))
tt = t(apply(t,1,cumsum))
tt = cbind(rep(0,sample_size),tt)
# y = matrix(rep(0,sample_size*(C+1)),c(sample_size,C+1))
y = rep(0,sample_size)
for(jj in 1:sample_size){
  tmp = runif(1,0,1)
  for(kk in 1:(C+1)){
    if((tmp&gt;tt[jj,kk])&amp;&amp;(tmp&lt;=tt[jj,kk+1])){
      # y[jj,kk] = 1
      y[jj] = kk
      break
    }
  }
}
y = classnames[y]
fit = GAGAs(X, y,alpha=1,family = "multinomial")
Eb = fit$beta
#Prediction
#Generate test samples
X_t = R1*matrix(rnorm(test_size * p_size), ncol = p_size)
X_t[1:test_size,1]=1
z = X_t%*%beta_true
t = exp(z)/(1+rowSums(exp(z)))
t = cbind(t,1-rowSums(t))
tt = t(apply(t,1,cumsum))
tt = cbind(rep(0,test_size),tt)
y_t = rep(0,test_size)
for(jj in 1:test_size){
  tmp = runif(1,0,1)
  for(kk in 1:(C+1)){
    if((tmp&gt;tt[jj,kk])&amp;&amp;(tmp&lt;=tt[jj,kk+1])){
      y_t[jj] = kk
      break
    }
  }
}
y_t = classnames[y_t]
Ey = predict(fit,newx = X_t)
cat("\n--------------------")
cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n pacc:", cal.w.acc(as.character(Ey),as.character(y_t)))
cat("\n")

# Poisson
set.seed(2022)
p_size = 30
sample_size=300
R1 = 1/sqrt(p_size)
R2 = 5
ratio = 0.5 #The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
X[1:sample_size,1]=1
y = rpois(sample_size,lambda = as.vector(exp(X%*%beta_true)))
y = as.vector(y)
# Estimate
fit = GAGAs(X,y,alpha = 2,family="poisson")
Eb = fit$beta
cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))

# cox
p_size = 50
sample_size = 500
test_size = 1000
R1 = 3
R2 = 1
ratio = 0.5 #The ratio of zeroes in coefficients
censoringRate = 0.25 #Proportion of censoring data in observation data
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,-R2,R2)
beta_true[ind] = 0
# Generate training samples
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
z = X%*%beta_true
u = runif(sample_size,0,1)
t = ((-log(1-u)/(3*exp(z)))*100)^(0.1)
cs = rep(0,sample_size)
csNum = round(censoringRate*sample_size)
ind = sample(1:sample_size,csNum)
cs[ind] = 1
t[ind] = runif(csNum,0,0.8)*t[ind]
y = cbind(t,1 - cs)
colnames(y) = c("time", "status")
#Estimation
fit = GAGAs(X,y,alpha=2,family="cox")
Eb = fit$beta

#Generate testing samples
X_t = R1*matrix(rnorm(test_size * p_size), ncol = p_size)
z = X_t%*%beta_true
u = runif(test_size,0,1)
t = ((-log(1-u)/(3*exp(z)))*100)^(0.1)
cs = rep(0,test_size)
csNum = round(censoringRate*test_size)
ind = sample(1:test_size,csNum)
cs[ind] = 1
t[ind] = runif(csNum,0,0.8)*t[ind]
y_t = cbind(t,1 - cs)
colnames(y_t) = c("time", "status")
#Prediction
pred = predict(fit,newx=X_t)

cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n Cindex:", cal.cindex(pred,y_t))
</code></pre>

<hr>
<h2 id='LM_GAGA'>Fit a linear model via the GAGA algorithm</h2><span id='topic+LM_GAGA'></span>

<h3>Description</h3>

<p>Fit a linear model with a Gaussian noise via the Global Adaptive Generative Adjustment algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LM_GAGA(
  X,
  y,
  alpha = 3,
  itrNum = 50,
  thresh = 0.001,
  QR_flag = FALSE,
  flag = TRUE,
  lamda_0 = 0.001,
  fix_sigma = FALSE,
  sigm2_0 = 1,
  fdiag = TRUE,
  frp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LM_GAGA_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_y">y</code></td>
<td>
<p>Quantitative response vector.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 2 or 3.
When the collinearity of the load matrix is serious, the hyperparameters can be selected larger, such as 5.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_itrnum">itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_qr_flag">QR_flag</code></td>
<td>
<p>It identifies whether to use QR decomposition to speed up the algorithm.
Currently only valid for linear models.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_flag">flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_lamda_0">lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_fix_sigma">fix_sigma</code></td>
<td>
<p>It identifies whether to update the variance estimate of the Gaussian noise or not.
<code>fix_sigma=TRUE</code> uses the initial variance as the variance estimate in each loop.
<code>fix_sigma=FALSE</code> updates the variance estimate in each loop.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_sigm2_0">sigm2_0</code></td>
<td>
<p>The initial variance of the Gaussian noise.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_fdiag">fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="LM_GAGA_+3A_frp">frp</code></td>
<td>
<p>Identifies whether pre-processing is performed by the OMP method to reduce the number of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
set.seed(2022)
p_size = 30
sample_size=300
R1 = 3
R2 = 2
ratio = 0.5 # The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y=X%*%beta_true + rnorm(sample_size,mean=0,sd=2)
# Estimation
fit = GAGAs(X,y,alpha = 3,family="gaussian")
Eb = fit$beta
#Create testing data
X_t = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y_t=X_t%*%beta_true + rnorm(sample_size,mean=0,sd=2)
#Prediction
Ey = predict.GAGA(fit,newx=X_t)

cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n perr:", norm(Ey-y_t,type="2")/sqrt(sample_size))
</code></pre>

<hr>
<h2 id='logistic_GAGA'>Fit a logistic model via the Global Adaptive Generative Adjustment algorithm</h2><span id='topic+logistic_GAGA'></span>

<h3>Description</h3>

<p>Fit a logistic model via the Global Adaptive Generative Adjustment algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic_GAGA(
  X,
  y,
  alpha = 1,
  itrNum = 30,
  thresh = 0.001,
  flag = TRUE,
  lamda_0 = 0.001,
  fdiag = TRUE,
  subItrNum = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logistic_GAGA_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="logistic_GAGA_+3A_y">y</code></td>
<td>
<p>should be either a factor with two levels.</p>
</td></tr>
<tr><td><code id="logistic_GAGA_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 1 or 2.
When the collinearity of the load matrix is serious, the hyperparameters can be selected larger, such as 5.</p>
</td></tr>
<tr><td><code id="logistic_GAGA_+3A_itrnum">itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="logistic_GAGA_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="logistic_GAGA_+3A_flag">flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="logistic_GAGA_+3A_lamda_0">lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="logistic_GAGA_+3A_fdiag">fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="logistic_GAGA_+3A_subitrnum">subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># binomial
set.seed(2022)
cat("\n")
cat("Test binomial GAGA\n")
p_size = 30
sample_size=600
test_size=1000
R1 = 1
R2 = 3
ratio = 0.5 #The ratio of zeroes in coefficients
#Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,R2*0.2,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
X[1:sample_size,1]=1
t = 1/(1+exp(-X%*%beta_true))
tmp = runif(sample_size,0,1)
y = rep(0,sample_size)
y[t&gt;tmp] = 1
fit = GAGAs(X,y,family = "binomial", alpha = 1)
Eb = fit$beta
#Generate test samples
X_t = R1*matrix(rnorm(test_size * p_size), ncol = p_size)
X_t[1:test_size,1]=1
t = 1/(1+exp(-X_t%*%beta_true))
tmp = runif(test_size,0,1)
y_t = rep(0,test_size)
y_t[t&gt;tmp] = 1
#Prediction
Ey = predict(fit,newx = X_t)
cat("\n--------------------")
cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n pacc:", cal.w.acc(as.character(Ey),as.character(y_t)))
cat("\n")
</code></pre>

<hr>
<h2 id='multinomial_GAGA'>Fit a multinomial model via the GAGA algorithm</h2><span id='topic+multinomial_GAGA'></span>

<h3>Description</h3>

<p>Fit a multinomial model the Global Adaptive Generative Adjustment algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinomial_GAGA(
  X,
  y,
  alpha = 1,
  itrNum = 50,
  thresh = 0.001,
  flag = TRUE,
  lamda_0 = 0.001,
  fdiag = TRUE,
  subItrNum = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multinomial_GAGA_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="multinomial_GAGA_+3A_y">y</code></td>
<td>
<p>a One-hot response matrix or a <code>nc&gt;=2</code> level factor</p>
</td></tr>
<tr><td><code id="multinomial_GAGA_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 1 or 2.
When the collinearity of the load matrix is serious, the hyperparameters can be selected larger, such as 5.</p>
</td></tr>
<tr><td><code id="multinomial_GAGA_+3A_itrnum">itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="multinomial_GAGA_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="multinomial_GAGA_+3A_flag">flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="multinomial_GAGA_+3A_lamda_0">lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="multinomial_GAGA_+3A_fdiag">fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="multinomial_GAGA_+3A_subitrnum">subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient matrix with K-1 columns, where K is the class number.
For k=1,..,K-1, the probability
</p>
<p style="text-align: center;"><code class="reqn">Pr(G=k|x)=exp(x^T beta_k) /(1+sum_{k=1}^{K-1}exp(x^T beta_k))</code>
</p>
<p>.
For k=K, the probability </p>
<p style="text-align: center;"><code class="reqn">Pr(G=K|x)=1/(1+sum_{k=1}^{K-1}exp(x^T beta_k))</code>
</p>
<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># multinomial
set.seed(2022)
cat("\n")
cat("Test multinomial GAGA\n")
p_size = 20
C = 3
classnames = c("C1","C2","C3","C4")
sample_size = 500
test_size = 1000
ratio = 0.5 #The ratio of zeroes in coefficients
Num = 10 # Total number of experiments
R1 = 1
R2 = 5
#Set the true coefficients
beta_true = matrix(rep(0,p_size*C),c(p_size,C))
zeroNum = round(ratio*p_size)
for(jj in 1:C){
  ind = sample(1:p_size,zeroNum)
  tmp = runif(p_size,0,R2)
  tmp[ind] = 0
  beta_true[,jj] = tmp
}
#Generate training samples
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
X[1:sample_size,1]=1
z = X%*%beta_true
t = exp(z)/(1+rowSums(exp(z)))
t = cbind(t,1-rowSums(t))
tt = t(apply(t,1,cumsum))
tt = cbind(rep(0,sample_size),tt)
# y = matrix(rep(0,sample_size*(C+1)),c(sample_size,C+1))
y = rep(0,sample_size)
for(jj in 1:sample_size){
  tmp = runif(1,0,1)
  for(kk in 1:(C+1)){
    if((tmp&gt;tt[jj,kk])&amp;&amp;(tmp&lt;=tt[jj,kk+1])){
      # y[jj,kk] = 1
      y[jj] = kk
      break
    }
  }
}
y = classnames[y]
fit = GAGAs(X, y,alpha=1,family = "multinomial")
Eb = fit$beta
#Prediction
#Generate test samples
X_t = R1*matrix(rnorm(test_size * p_size), ncol = p_size)
X_t[1:test_size,1]=1
z = X_t%*%beta_true
t = exp(z)/(1+rowSums(exp(z)))
t = cbind(t,1-rowSums(t))
tt = t(apply(t,1,cumsum))
tt = cbind(rep(0,test_size),tt)
y_t = rep(0,test_size)
for(jj in 1:test_size){
  tmp = runif(1,0,1)
  for(kk in 1:(C+1)){
    if((tmp&gt;tt[jj,kk])&amp;&amp;(tmp&lt;=tt[jj,kk+1])){
      y_t[jj] = kk
      break
    }
  }
}
y_t = classnames[y_t]
Ey = predict(fit,newx = X_t)
cat("\n--------------------")
cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n pacc:", cal.w.acc(as.character(Ey),as.character(y_t)))
cat("\n")
</code></pre>

<hr>
<h2 id='poisson_GAGA'>Fit a Poisson model via the GAGA algorithm</h2><span id='topic+poisson_GAGA'></span>

<h3>Description</h3>

<p>Fit a Poisson model the Global Adaptive Generative Adjustment algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson_GAGA(
  X,
  y,
  alpha = 1,
  itrNum = 30,
  thresh = 0.001,
  flag = TRUE,
  lamda_0 = 0.5,
  fdiag = TRUE,
  subItrNum = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poisson_GAGA_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.
In order to run the program stably, it is recommended that the value of X should not be too large. It is recommended to
preprocess all the items in X except the intercept item by means of preprocessing, so that the mean value of each column
is 0 and the standard deviation is <code>1/ colnum(X)</code>.</p>
</td></tr>
<tr><td><code id="poisson_GAGA_+3A_y">y</code></td>
<td>
<p>Non-negative count response vector.</p>
</td></tr>
<tr><td><code id="poisson_GAGA_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 1 or 2.
When the collinearity of the load matrix is serious, the hyperparameters can be selected larger, such as 5.</p>
</td></tr>
<tr><td><code id="poisson_GAGA_+3A_itrnum">itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.
If the condition number of <code>X</code> is large, it is recommended to greatly increase the
number of iteration steps.</p>
</td></tr>
<tr><td><code id="poisson_GAGA_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="poisson_GAGA_+3A_flag">flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="poisson_GAGA_+3A_lamda_0">lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.
The running result of the algorithm is not sensitive to this value.</p>
</td></tr>
<tr><td><code id="poisson_GAGA_+3A_fdiag">fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="poisson_GAGA_+3A_subitrnum">subItrNum</code></td>
<td>
<p>Maximum number of steps for subprocess iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Poisson
set.seed(2022)
p_size = 30
sample_size=300
R1 = 1/sqrt(p_size)
R2 = 5
ratio = 0.5 #The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
X[1:sample_size,1]=1
y = rpois(sample_size,lambda = as.vector(exp(X%*%beta_true)))
y = as.vector(y)
# Estimate
fit = GAGAs(X,y,alpha = 2,family="poisson")
Eb = fit$beta
cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))


</code></pre>

<hr>
<h2 id='predict_cox_GAGA'>Get predictions from a GAGA cox model fit object</h2><span id='topic+predict_cox_GAGA'></span>

<h3>Description</h3>

<p>Get predictions from a GAGA cox model fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_cox_GAGA(fit, newx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_cox_GAGA_+3A_fit">fit</code></td>
<td>
<p>Fitted &quot;GAGA&quot; object.</p>
</td></tr>
<tr><td><code id="predict_cox_GAGA_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made. Must be a
matrix.  If the intercept term needs to be considered in the estimation process, then
the first column of <code>X</code> must be all 1s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictions
</p>

<hr>
<h2 id='predict_LM_GAGA'>Get predictions from a GAGA linear model fit object</h2><span id='topic+predict_LM_GAGA'></span>

<h3>Description</h3>

<p>Get predictions from a GAGA linear model fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_LM_GAGA(fit, newx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_LM_GAGA_+3A_fit">fit</code></td>
<td>
<p>Fitted &quot;GAGA&quot; object.</p>
</td></tr>
<tr><td><code id="predict_LM_GAGA_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made. Must be a
matrix.  If the intercept term needs to be considered in the estimation process, then
the first column of <code>X</code> must be all 1s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictions
</p>

<hr>
<h2 id='predict_logistic_GAGA'>Get predictions from a GAGA logistic model fit object</h2><span id='topic+predict_logistic_GAGA'></span>

<h3>Description</h3>

<p>Get predictions from a GAGA logistic model fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_logistic_GAGA(fit, newx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_logistic_GAGA_+3A_fit">fit</code></td>
<td>
<p>Fitted &quot;GAGA&quot; object.</p>
</td></tr>
<tr><td><code id="predict_logistic_GAGA_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made. Must be a
matrix.  If the intercept term needs to be considered in the estimation process, then
the first column of <code>X</code> must be all 1s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictions
</p>

<hr>
<h2 id='predict_multinomial_GAGA'>Get predictions from a GAGA multinomial model fit object</h2><span id='topic+predict_multinomial_GAGA'></span>

<h3>Description</h3>

<p>Get predictions from a GAGA multinomial model fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_multinomial_GAGA(fit, newx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_multinomial_GAGA_+3A_fit">fit</code></td>
<td>
<p>Fitted &quot;GAGA&quot; object.</p>
</td></tr>
<tr><td><code id="predict_multinomial_GAGA_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made. Must be a
matrix.  If the intercept term needs to be considered in the estimation process, then
the first column of <code>X</code> must be all 1s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictions
</p>

<hr>
<h2 id='predict_poisson_GAGA'>Get predictions from a GAGA poisson model fit object</h2><span id='topic+predict_poisson_GAGA'></span>

<h3>Description</h3>

<p>Get predictions from a GAGA poisson model fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_poisson_GAGA(fit, newx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_poisson_GAGA_+3A_fit">fit</code></td>
<td>
<p>Fitted &quot;GAGA&quot; object.</p>
</td></tr>
<tr><td><code id="predict_poisson_GAGA_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made. Must be a
matrix.  If the intercept term needs to be considered in the estimation process, then
the first column of <code>X</code> must be all 1s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictions
</p>

<hr>
<h2 id='predict.GAGA'>Get predictions from a GAGA fit object</h2><span id='topic+predict.GAGA'></span>

<h3>Description</h3>

<p>Gives fitted values from a fitted GAGA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GAGA'
predict(object, newx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.GAGA_+3A_object">object</code></td>
<td>
<p>Fitted &quot;GAGA&quot; object.</p>
</td></tr>
<tr><td><code id="predict.GAGA_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made. Must be a
matrix.  If the intercept term needs to be considered in the estimation process, then
the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="predict.GAGA_+3A_...">...</code></td>
<td>
<p>some other params</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2022)
p_size = 30
sample_size=300
R1 = 3
R2 = 2
ratio = 0.5 #The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y=X%*%beta_true + rnorm(sample_size,mean=0,sd=2)
# Estimation
fit = GAGAs(X,y,alpha = 3,family="gaussian")
Eb = fit$beta
#Create testing data
X_t = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y_t=X_t%*%beta_true + rnorm(sample_size,mean=0,sd=2)
#Prediction
Ey = predict.GAGA(fit,newx=X_t)

cat("\n err:", norm(Eb-beta_true,type="2")/norm(beta_true,type="2"))
cat("\n acc:", cal.w.acc(as.character(Eb!=0),as.character(beta_true!=0)))
cat("\n perr:", norm(Ey-y_t,type="2")/sqrt(sample_size))

</code></pre>

<hr>
<h2 id='rcpp_lm_gaga'>Fit a linear model via the GAGA algorithm using cpp.</h2><span id='topic+rcpp_lm_gaga'></span>

<h3>Description</h3>

<p>Fit a linear model via the GAGA algorithm using cpp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_lm_gaga(
  X,
  y,
  s_alpha,
  s_itrNum,
  s_thresh,
  s_QR_flag,
  s_flag,
  s_lamda_0,
  s_fix_sigma,
  s_sigm2_0,
  s_fdiag,
  s_frp
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcpp_lm_gaga_+3A_x">X</code></td>
<td>
<p>Input matrix, of dimension nobs*nvars; each row is an observation.
If the intercept term needs to be considered in the estimation process, then the first column of <code>X</code> must be all 1s.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_y">y</code></td>
<td>
<p>Quantitative response N*1 matrix.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Hyperparameter. The suggested value for alpha is 2 or 3.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_itrnum">s_itrNum</code></td>
<td>
<p>The number of iteration steps. In general, 20 steps are enough.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_thresh">s_thresh</code></td>
<td>
<p>Convergence threshold for beta Change, if <code>max(abs(beta-beta_old))&lt;threshold</code>, return.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_qr_flag">s_QR_flag</code></td>
<td>
<p>It identifies whether to use QR decomposition to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_flag">s_flag</code></td>
<td>
<p>It identifies whether to make model selection. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_lamda_0">s_lamda_0</code></td>
<td>
<p>The initial value of the regularization parameter for ridge regression.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_fix_sigma">s_fix_sigma</code></td>
<td>
<p>It identifies whether to update the variance estimate of the Gaussian noise or not.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_sigm2_0">s_sigm2_0</code></td>
<td>
<p>The initial variance of the Gaussian noise.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_fdiag">s_fdiag</code></td>
<td>
<p>It identifies whether to use diag Approximation to speed up the algorithm.</p>
</td></tr>
<tr><td><code id="rcpp_lm_gaga_+3A_s_frp">s_frp</code></td>
<td>
<p>Pre-processing by OMP method to reduce the number of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient vector
</p>

<hr>
<h2 id='summary.GAGA'>Print a summary of GAGA object</h2><span id='topic+summary.GAGA'></span>

<h3>Description</h3>

<p>Print a summary of GAGA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GAGA'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.GAGA_+3A_object">object</code></td>
<td>
<p>Fitted &quot;GAGA&quot; object.</p>
</td></tr>
<tr><td><code id="summary.GAGA_+3A_...">...</code></td>
<td>
<p>some other params</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2022)
p_size = 30
sample_size=300
R1 = 3
R2 = 2
ratio = 0.5 #The ratio of zeroes in coefficients
# Set the true coefficients
zeroNum = round(ratio*p_size)
ind = sample(1:p_size,zeroNum)
beta_true = runif(p_size,0,R2)
beta_true[ind] = 0
X = R1*matrix(rnorm(sample_size * p_size), ncol = p_size)
y=X%*%beta_true + rnorm(sample_size,mean=0,sd=2)
# Estimation
fit = GAGAs(X,y,alpha = 3,family="gaussian")
summary(fit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
