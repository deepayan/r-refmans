<!DOCTYPE html><html lang="en"><head><title>Help for package grapherator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grapherator}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grapherator-package'><p>grapherator: A modular multi-step graph generator</p></a></li>
<li><a href='#addEdges'><p>Add edges to graph.</p></a></li>
<li><a href='#addEdgesToPlot'><p>Highlight edges in graph.</p></a></li>
<li><a href='#addNodes'><p>Add nodes to graph.</p></a></li>
<li><a href='#addWeights'><p>Add weights to graph.</p></a></li>
<li><a href='#addWeightsConcave'><p>@title Weight generators.</p></a></li>
<li><a href='#as.character.grapherator'><p>Graph string representation.</p></a></li>
<li><a href='#edgeGenerators'><p>Edge generators.</p></a></li>
<li><a href='#getter'><p>Getter functions.</p></a></li>
<li><a href='#graph'><p>Generate a bare graph.</p></a></li>
<li><a href='#grapherator'><p>Graph object.</p></a></li>
<li><a href='#nodeGenerators'><p>Node generators.</p></a></li>
<li><a href='#plot.grapherator'><p>Visualize graph.</p></a></li>
<li><a href='#writeGP'><p>Export/import graph.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Modular Multi-Step Graph Generator</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of functions for step-wise generation of (weighted) graphs. Aimed for research in the field of single- and multi-objective combinatorial optimization. Graphs are generated adding nodes, edges and weights. Each step may be repeated multiple times with different predefined and custom generators resulting in high flexibility regarding the graph topology and structure of edge weights.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-12-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakob Bossek &lt;j.bossek@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jakobbossek/grapherator">https://github.com/jakobbossek/grapherator</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jakobbossek/grapherator/issues">https://github.com/jakobbossek/grapherator/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>BBmisc (&ge; 1.6), checkmate (&ge; 1.1), reshape2 (&ge; 1.4.1),
vegan, ggplot2 (&ge; 1.0.0), lhs, deldir, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.9.1), knitr, rmarkdown, gridExtra, magrittr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-12-20 16:53:57 UTC; jboss</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakob Bossek [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-12-21 13:19:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='grapherator-package'>grapherator: A modular multi-step graph generator</h2><span id='topic+grapherator-package'></span>

<h3>Description</h3>

<p>Due to lack of real world graphs, e.g., the optimization community often
relies on artificial graphs to benchmark algorithms. The <span class="pkg">grapherator</span>
package implements a multi-step approach for the generation of weighted graphs.
A set of predefined node, edge and weight generators allows for fast and convenient
graph generation. Furthermore, the modular structure of the package enables
writing user-defined generators and use them within the framework in a
plug-and-play style.
</p>


<h3>Generation philosophy</h3>

<p>The graph generation follows a three step procedure. A bare graph (see <code><a href="#topic+graph">graph</a></code>), i.e., an empty graph object, the following three
serves as a staring point for several iterations of the following steps. Note that
once edges have been added, no furhter nodes may be added. Likewise, after weights
have been attached to edges, no further edges may be added.
1) Node generation via <code><a href="#topic+addNodes">addNodes</a></code>: nodes are generated by placing node
coordinates in the two-dimensional Euclidean plane using different node generators.
2) Edge generation via <code><a href="#topic+addEdges">addEdges</a></code>: links between nodes are established
via one or multiple edge generators.
3) Weight generation via <code><a href="#topic+addWeights">addWeights</a></code>: One or more weights are attached
to each edge by different weight generators.
</p>

<hr>
<h2 id='addEdges'>Add edges to graph.</h2><span id='topic+addEdges'></span>

<h3>Description</h3>

<p>This method allows to add edges to a <code>grapherator</code> graph.
The method can be applied multiple times with different parameterizations. E.g.,
add edges in clusters first and add edges between clusters in a second step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEdges(graph, generator, type = "all", k = NULL, cluster.ids = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addEdges_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="addEdges_+3A_generator">generator</code></td>
<td>
<p>[<code>function(graph, ...)</code>]<br />
Method applied to <code>graph</code> in order to determine which edges to add.</p>
</td></tr>
<tr><td><code id="addEdges_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Value &ldquo;all&rdquo; applies <code>generator</code> to all nodes. Value &ldquo;intracluster&rdquo;
instead applies the method for each cluster seperately. Value &ldquo;intercluster&rdquo;
selects each <code>k</code> nodes from each cluster and applies <code>generator</code> to the union.
Lastly, value &ldquo;intercenter&rdquo; selects the cluster centers exclusively.
Default is &ldquo;all&rdquo;.</p>
</td></tr>
<tr><td><code id="addEdges_+3A_k">k</code></td>
<td>
<p>[<code>integer</code> | <code>NULL</code>]<br />
Integer vector specifying the number of nodes selected randomly from each cluster
to be selected for edge construction. May be a scalar value or a vector of length
<code>graph$n.clusters</code>. NAs are allowed and indicate clusters to be ignored.</p>
</td></tr>
<tr><td><code id="addEdges_+3A_cluster.ids">cluster.ids</code></td>
<td>
<p>[<code>integer</code> | <code>NULL</code>]<br />
Ignored unless <code>type</code> is not set to &ldquo;intracluster&rdquo;.
Integer vector of cluster IDs. If <code>NULL</code> the <code>generator</code> is applied
within each cluster.</p>
</td></tr>
<tr><td><code id="addEdges_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed down to edge generator <code>generator</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+grapherator">grapherator</a></code>] Graph.
</p>


<h3>References</h3>

<p>Erdos, P., and A. Renyi. 1959. &quot;On random graphs, I.&quot; Publicationes Mathematicae
(Debrecen) 6: 290-97.
</p>
<p>Waxman, B. M. 1988. &quot;Routing of Multipoint Connections.&quot;&quot; IEEE Journal on Selected
Areas in Communications 6 (9): 1617-22. doi:10.1109/49.12889.
</p>
<p>Knowles, J. D., and D. W. Corne. 2001. &quot;Benchmark Problem Generators and Results
for the Multiobjective Degree-Constrained Minimum Spanning Tree Problem.&quot;
In Proceedings of the 3rd Annual Conference on Genetic and Evolutionary
Computation, 424-31. GECCO'01. San Francisco, CA, USA: Morgan Kaufmann Publishers Inc.
</p>


<h3>See Also</h3>

<p>Other graph generators: <code><a href="#topic+addNodes">addNodes</a></code>,
<code><a href="#topic+addWeights">addWeights</a></code>, <code><a href="#topic+graph">graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = graph(0, 1000)
g = addNodes(g, n = 5, generator = addNodesLHS)
g = addNodes(g, n = c(3, 10, 20, 10, 40), by.centers = TRUE, generator = addNodesUniform,
  lower = c(0, 0), upper = c(30, 30))
# user different edge generators for clusters
g = addEdges(g, generator = addEdgesDelauney, type = "intracluster", cluster.ids = 1:3)
g = addEdges(g, generator = addEdgesSpanningTree, type = "intracluster", cluster.ids = 4:5)
# link cluster centers
g = addEdges(g, generator = addEdgesSpanningTree, runs = 2, type = "intercenter")
# additional random links between each 2 nodes from each cluster
g = addEdges(g, generator = addEdgesGilbert, p = 0.4, type = "intercluster", k = 2)
</code></pre>

<hr>
<h2 id='addEdgesToPlot'>Highlight edges in graph.</h2><span id='topic+addEdgesToPlot'></span>

<h3>Description</h3>

<p>Highlights edges in coordinate plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEdgesToPlot(x, g, edge.list, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addEdgesToPlot_+3A_x">x</code></td>
<td>
<p>[<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>]<br />
Coordinate plot generated via <code><a href="#topic+plot.grapherator">plot.grapherator</a></code>.</p>
</td></tr>
<tr><td><code id="addEdgesToPlot_+3A_g">g</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="addEdgesToPlot_+3A_edge.list">edge.list</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of edges (each column is one edge).</p>
</td></tr>
<tr><td><code id="addEdgesToPlot_+3A_...">...</code></td>
<td>
<p>[any]<br />
Arguments passed down to <code><a href="ggplot2.html#topic+geom_segment">geom_segment</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>] Modified <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g = graph(0, 100)
g = addNodes(g, n = 10, generator = addNodesUniform)
g = addEdges(g, generator = addEdgesComplete)
pl = plot(g)$pl.coords
el = matrix(c(1, 2, 1, 3, 4, 5, 3, 4), nrow = 2L)
pl = addEdgesToPlot(pl, g, el)
print(pl)

## End(Not run)
</code></pre>

<hr>
<h2 id='addNodes'>Add nodes to graph.</h2><span id='topic+addNodes'></span>

<h3>Description</h3>

<p>Places node coordinates in the two-dimensional Euclidean plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNodes(graph, n, generator, coordinates = NULL, by.centers = FALSE,
  skip.centers = integer(0L), par.fun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addNodes_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="addNodes_+3A_n">n</code></td>
<td>
<p>[<code>integer</code>]<br />
Number of nodes to place. If <code>by.centers</code> is <code>FALSE</code> a single
integer value is expected. Otherwise, a vector <code class="reqn">v</code> may be passed. In this case
<code class="reqn">v[i]</code> coordinates are generated for each cluster. However, if a single value is
passed and <code>by.center == TRUE</code>, each cluster is assigned the same number of
nodes.</p>
</td></tr>
<tr><td><code id="addNodes_+3A_generator">generator</code></td>
<td>
<p>[<code>function(graph, ...)</code>]<br />
Function used to generate nodes. The functions needs to expect the number
of points to generate as the first argument <code>n</code>. Additional control argument are
possible.</p>
</td></tr>
<tr><td><code id="addNodes_+3A_coordinates">coordinates</code></td>
<td>
<p>[<code>matrix(n, 2)</code>]<br />
Matrix of coordinates (each row is one node/point).
Default is <code>NULL</code>. If this is set, setting of <code>generator</code>, <code>by.centers</code>,
and <code>par.fun</code> are ignored. This parameter is handy, if one wants to add
coordinates by hand.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="addNodes_+3A_by.centers">by.centers</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should coordinates be placed for each cluster center seperately? This enables
generation of clustered graphs.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="addNodes_+3A_skip.centers">skip.centers</code></td>
<td>
<p>[<code>integer</code>]<br />
Optional IDs of cluster centers not to consider in clustered node generation, i.e.,
if <code>by.centers = TRUE</code>.
Default is not to skip any cluster.</p>
</td></tr>
<tr><td><code id="addNodes_+3A_par.fun">par.fun</code></td>
<td>
<p>[<code>function(cc) | NULL</code>]<br />
Optional function which is applied to each cluster center before the generation
of coordinates in case <code>by.centers</code> is <code>TRUE</code>. This enables to specifically
determine additional parameters for the <code>generator</code> for each cluster.</p>
</td></tr>
<tr><td><code id="addNodes_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed down to <code>generator</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+grapherator">grapherator</a></code>] Graph.
</p>


<h3>See Also</h3>

<p>Other graph generators: <code><a href="#topic+addEdges">addEdges</a></code>,
<code><a href="#topic+addWeights">addWeights</a></code>, <code><a href="#topic+graph">graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Clustered graph
g = graph(0, 1000)
g = addNodes(g, n = 5, generator = addNodesLHS)
g = addNodes(g, n = c(3, 10, 20, 10, 40), by.centers = TRUE, generator = addNodesUniform,
 lower = c(0, 0), upper = c(30, 30))
## Not run: 
plot(g, show.edges = FALSE)$pl.coords

## End(Not run)

# Mixed graph
g = graph(0, 100)
g = addNodes(g, n = 100, generator = addNodesLHS)
g = addNodes(g, n = 100, generator = addNodesGrid)

## Not run: 
plot(g, show.edges = FALSE)$pl.coords

## End(Not run)
</code></pre>

<hr>
<h2 id='addWeights'>Add weights to graph.</h2><span id='topic+addWeights'></span>

<h3>Description</h3>

<p><code>addWeights</code> allows to add edge weights to a graph. This is
the last step of the graph generation process. Note that adding edges is not
possible once <code>addWeights</code> was called once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addWeights(graph, generator = NULL, weights = NULL, symmetric = TRUE,
  to.int = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addWeights_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="addWeights_+3A_generator">generator</code></td>
<td>
<p>[<code>function(graph, ...)</code>]<br />
Function used to generate weights. The functions needs to expect the graph
as the first argument <code>graph</code>. Additional control argument are
possible.</p>
</td></tr>
<tr><td><code id="addWeights_+3A_weights">weights</code></td>
<td>
<p>[<code>matrix</code>]<br />
Square matrix of weights.
If some weights are already assigned, pay attention to the correct dimensions.
If this is passed all other arguments are ignored.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="addWeights_+3A_symmetric">symmetric</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the weights be symmetric, i.e., <code class="reqn">w(i, j) = w(j, i)</code> for each pair <code class="reqn">i, j</code> of nodes?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="addWeights_+3A_to.int">to.int</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should weights be rounded to integer?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="addWeights_+3A_...">...</code></td>
<td>
<p>[any]<br />
Additional arguments passed down to <code>generator</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+grapherator">grapherator</a></code>] Graph.
</p>


<h3>See Also</h3>

<p>Other graph generators: <code><a href="#topic+addEdges">addEdges</a></code>,
<code><a href="#topic+addNodes">addNodes</a></code>, <code><a href="#topic+graph">graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first we define a simple graph
g = graph(0, 100)
g = addNodes(g, n = 5, generator = addNodesLHS)
g = addNodes(g, n = c(3, 10, 20, 10, 40), by.centers = TRUE, generator = addNodesUniform,
  lower = c(0, 0), upper = c(15, 15))
g = addEdges(g, generator = addEdgesDelauney)

# first graph contains two integer random weights per edge
g1 = addWeights(g, generator = addWeightsRandom, method = runif, min = 10, max = 20, to.int = TRUE)
g1 = addWeights(g, generator = addWeightsRandom, method = runif, min = 10, max = 30, to.int = TRUE)
## Not run: 
plot(g1)$pl.weights

## End(Not run)

# next one contains correlated weights. The first weight corresponds to the
# Euclidean distance of the points, the second is generated in a way, that
# a given correlation rho is achieved.
g2 = addWeights(g, generator = addWeightsCorrelated, rho = -0.7)
## Not run: 
plot(g2)$pl.weights

## End(Not run)

# Last example contains two weights per edge: the first one is the Manhattan
# block distance between the nodes in the plane. The second one is the Euclidean
# distance plus a normally distributed jitter. Here we write a custom weight
# generator which returns two weight matrizes.
myWeightGenerator = function(graph, ...) {
  n = getNumberOfNodes(graph)
  adj.mat = getAdjacencyMatrix(graph)
  coords = getNodeCoordinates(graph)

  man.dist = as.matrix(dist(coords), method = "manhattan")
  euc.dist = as.matrix(dist(coords)) + abs(rnorm(n * n, ...))

  # keep in mind non-existent edges
  euc.dist[!adj.mat] = man.dist[!adj.mat] = Inf

  # return the necessary format
  return(list(weights = list(man.dist, euc.dist), generator = "MyWG"))
}

g3 = addWeights(g, generator = myWeightGenerator, mean = 30, sd = 5)
## Not run: 
plot(g3)$pl.weights

## End(Not run)
</code></pre>

<hr>
<h2 id='addWeightsConcave'>@title Weight generators.</h2><span id='topic+addWeightsConcave'></span><span id='topic+addWeightsCorrelated'></span><span id='topic+addWeightsDistance'></span><span id='topic+addWeightsRandom'></span>

<h3>Description</h3>

<p>Function for adding weight(s) to edges. The following functions
are implemented and may be passed as argument <code>generator</code> to <code><a href="#topic+addWeights">addWeights</a></code>:
</p>

<dl>
<dt><code>addWeightsRandom</code></dt><dd><p>Add purely random weights. Calls the passed <code>method</code>, e.g., <code>method = runif</code> to generate weights.</p>
</dd>
<dt><code>addWeightsDistance</code></dt><dd><p>Weights correspond to a distance metric based on the node coordinates
in the Euclidean plane. Internally function <code><a href="stats.html#topic+dist">dist</a></code> is called.</p>
</dd>
<dt><code>addWeightsCorrelated</code></dt><dd><p>This method generates two weight matrices with correlated weights. The
correlation may be adjusted by the <code>rho</code> argument. Here, the first weight of an
edge is the Euclidean distance between the nodes in the plane and the second one
is generated in a way, that the correlation is close to <code>rho</code>.</p>
</dd>
<dt><code>addWeightsCocave</code></dt><dd><p>This method is interesting for generating bi-objective graphs to
benchmark algorithms for the multi-criteria spanning tree problem. Graphs generated this way expose
a concave Pareto-front.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>addWeightsConcave(graph, xhi = 10, nu = 20, M = 100, ...)

addWeightsCorrelated(graph, rho, ...)

addWeightsDistance(graph, method, ...)

addWeightsRandom(graph, method, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addWeightsConcave_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="addWeightsConcave_+3A_xhi">xhi</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Positive integer for <code>addWeightsConcave</code>.
Default is 10.</p>
</td></tr>
<tr><td><code id="addWeightsConcave_+3A_nu">nu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Positive integer for <code>addWeightsConcave</code>.
Default is 20.</p>
</td></tr>
<tr><td><code id="addWeightsConcave_+3A_m">M</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximum weight for weights generated via <code>addWeightsConcave</code>.
Note that <code>M</code> minus <code>xhi</code> needs to be much bigger than <code>nu</code>.
Default is 100.</p>
</td></tr>
<tr><td><code id="addWeightsConcave_+3A_...">...</code></td>
<td>
<p>[any]
Further arguments. Not used at the moment.
This may be useful for user-written weight generators.</p>
</td></tr>
<tr><td><code id="addWeightsConcave_+3A_rho">rho</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Desired correlation, i.e., value between -1 and 1, of edge weights for
<code>addWeightsCorrelated</code>.</p>
</td></tr>
<tr><td><code id="addWeightsConcave_+3A_method">method</code></td>
<td>
<p>[<code>character(1)</code> | <code>function(n, ...)</code>]<br />
String representing the distance measure to use for <code>addWeightsDistance</code>
(see <code>method</code> argument of <code><a href="stats.html#topic+dist">dist</a></code>) or <code>function(n, ...)</code>
used to generate random weights in case of <code>addWeightsRandom</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] A list with components
</p>

<dl>
<dt>weights [<code>list</code>]</dt><dd><p>List of weight matrices. Even in the case of one weight matrix
it is wrapped in a list of length one.</p>
</dd>
<dt>generator [<code>character(1)</code>]</dt><dd><p>String description of the generator used.</p>
</dd>
</dl>



<h3>Note</h3>

<p>These functions are not meant to be called directly. Instead, they need
to be assigned to the <code>generator</code> argument of <code><a href="#topic+addWeights">addWeights</a></code>.
</p>

<hr>
<h2 id='as.character.grapherator'>Graph string representation.</h2><span id='topic+as.character.grapherator'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+grapherator">grapherator</a></code> object the function returns
a string representation. Basically this is a concatenation of meta data, node,
edge and weight generator types of the following format:
N&lt;n.nodes&gt;-E&lt;n.edges&gt;-C&lt;n.clusters&gt;-W&lt;n.weights&gt;&mdash;&lt;node-types&gt;&mdash;&lt;edge-types&gt;&mdash;&lt;weight-types&gt;
where n.x is the number of x of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grapherator'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.grapherator_+3A_x">x</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="as.character.grapherator_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character(1)</code>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = graph(lower = c(0, 0), upper = c(100, 100))
g = addNodes(g, n = 3, generator = addNodesUniform)
g = addNodes(g, n = 14, by.centers = TRUE, generator = addNodesUniform,
  lower = c(0, 0), upper = c(10, 10))
g = addEdges(g, generator = addEdgesWaxman, alpha = 0.2,
  beta = 0.2, type = "intracluster")
g = addEdges(g, generator = addEdgesDelauney, type = "intercenter")
g = addWeights(g, generator = addWeightsCorrelated, rho = -0.9)
g = addWeights(g, generator = addWeightsDistance, method = "euclidean")
as.character(g)
</code></pre>

<hr>
<h2 id='edgeGenerators'>Edge generators.</h2><span id='topic+edgeGenerators'></span><span id='topic+addEdgesComplete'></span><span id='topic+addEdgesGrid'></span><span id='topic+addEdgesOnion'></span><span id='topic+addEdgesDelauney'></span><span id='topic+addEdgesWaxman'></span><span id='topic+addEdgesGilbert'></span><span id='topic+addEdgesErdosRenyi'></span><span id='topic+addEdgesSpanningTree'></span>

<h3>Description</h3>

<p>Function to add edges into a graph. The following methods
are implemented so far:
</p>

<dl>
<dt><code>addEdgesComplete</code></dt><dd><p>Generates a simple complete graph. I.e., an edge
exists between each two nodes. However, no self-loops or multi-edges are included.</p>
</dd>
<dt><code>addEdgesGrid</code></dt><dd><p>Only usefull if nodes are generated via <code><a href="#topic+addNodesGrid">addNodesGrid</a></code>.
This method generates a Manhattan-like street network.</p>
</dd>
<dt><code>addEdgesOnion</code></dt><dd><p>This method determines the nodes on the convex hull
of the node cloud in the euclidean plane and adds edges between neighbour nodes.
Ignoring all nodes on the hull, this process is repeated iteratively resulting in an
onion like peeling topololgy. Note that the graph is not connected! In order to
ensure connectivity, another edge generator must be applied in addition, e.g.,
<code>addEdgesSpanningTree</code>.</p>
</dd>
<dt><code>addEdgesDelauney</code></dt><dd><p>Edges are determined by means of a Delauney triangulation
of the node coordinates in the Euclidean plane.</p>
</dd>
<dt><code>addEdgesWaxman</code></dt><dd><p>Edges are generated using the Waxman-model, i.e., the
probability <code class="reqn">p_{ij}</code> for the edge <code class="reqn">(i, j)</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = \alpha e^{-\beta d_{ij}}</code>
</p>
<p>,
where <code class="reqn">\alpha, \beta \geq 0</code> are control parameters and <code class="reqn">d_{ij}</code> is the
Euclidean distance of the nodes <code class="reqn">i</code> and <code class="reqn">j</code>.</p>
</dd>
<dt><code>addEdgesSpanningTree</code></dt><dd><p>A minimum spanning tree is computed based on
a complete random weight matrix. All edges of the spanning tree are added. If <code>runs</code>
is greater 1, the process is repeated for <code>runs</code>. However, already added edges are
ignored in subsequent runs.
This method is particularly useful to assist probablistic methods, e.g., Waxman model,
in order to generate connected graphs.</p>
</dd>
<dt><code>addEdgesGilbert</code></dt><dd><p>Use Gilbert-model to generate edges. I.e., each edge is
added with probability <code class="reqn">p \in [0, 1]</code>.</p>
</dd>
<dt><code>addEdgesErdosRenyi</code></dt><dd><p>In total <code class="reqn">m \leq n(n-1)/2</code> edges are added at random.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>addEdgesComplete(graph, ...)

addEdgesGrid(graph, ...)

addEdgesOnion(graph, ...)

addEdgesDelauney(graph, ...)

addEdgesWaxman(graph, alpha = 0.5, beta = 0.5, ...)

addEdgesGilbert(graph, p, ...)

addEdgesErdosRenyi(graph, m, ...)

addEdgesSpanningTree(graph, runs = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edgeGenerators_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="edgeGenerators_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used at the moment.</p>
</td></tr>
<tr><td><code id="edgeGenerators_+3A_alpha">alpha</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Positive number indicating the average degree of nodes in the Waxman model.
Default is 0.5.</p>
</td></tr>
<tr><td><code id="edgeGenerators_+3A_beta">beta</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Positive number indicating the scale between short and long edges in the Waxman model.
Default is 0.5.</p>
</td></tr>
<tr><td><code id="edgeGenerators_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability for each edge <code class="reqn">(v_i, v_j), i, j = 1, \ldots, n</code> to be added
for Gilbert graphs.</p>
</td></tr>
<tr><td><code id="edgeGenerators_+3A_m">m</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of edges to sample for Erdos-Renyi graphs.
Must be at most <code class="reqn">n(n-1)/2</code> where <code class="reqn">n</code> is the number of nodes of <code>graph</code>.</p>
</td></tr>
<tr><td><code id="edgeGenerators_+3A_runs">runs</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of runs to perform by <code><a href="#topic+addEdgesSpanningTree">addEdgesSpanningTree</a></code>.
Default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently all edge generators create symmetric edges only.
</p>


<h3>Value</h3>

<p>[<code>list</code>] List with components:
</p>

<dl>
<dt>adj.mat <code>matrix</code></dt><dd><p>Adjacency matrix.</p>
</dd>
<dt>generator [<code>character(1)</code>]</dt><dd><p>String description of the generator used.</p>
</dd>
</dl>



<h3>Note</h3>

<p>These functions are not meant to be called directly. Instead, they need
to be assigned to the <code>generator</code> argument of <code><a href="#topic+addEdges">addEdges</a></code>.
</p>

<hr>
<h2 id='getter'>Getter functions.</h2><span id='topic+getter'></span><span id='topic+getNumberOfNodes'></span><span id='topic+getNumberOfEdges'></span><span id='topic+getNumberOfClusters'></span><span id='topic+getNumberOfWeights'></span><span id='topic+getNodeCoordinates'></span><span id='topic+getWeightMatrix'></span><span id='topic+getAdjacencyMatrix'></span><span id='topic+getNodeDegrees'></span>

<h3>Description</h3>

<p>Functions to extract meta information of <code>grapherator</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfNodes(graph)

getNumberOfEdges(graph)

getNumberOfClusters(graph)

getNumberOfWeights(graph)

getNodeCoordinates(graph, cluster.centers = FALSE)

getWeightMatrix(graph, objective)

getAdjacencyMatrix(graph)

getNodeDegrees(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getter_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="getter_+3A_cluster.centers">cluster.centers</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Return coordinates of cluster centers only?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getter_+3A_objective">objective</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of weight matrix to return.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>g = graph(0, 100)
g = addNodes(g, n = 25, generator = addNodesGrid)
g = addEdges(g, generator = addEdgesGrid)
g = addWeights(g, generator = addWeightsRandom, method = runif, min = 5, max = 100, to.int = TRUE)
g = addWeights(g, generator = addWeightsDistance, method = "euclidean")

getNumberOfNodes(g)
getNumberOfEdges(g)
getNumberOfClusters(g)
getNumberOfWeights(g)
getNodeCoordinates(g)
getWeightMatrix(g, 2)
getAdjacencyMatrix(g)
getNodeDegrees(g)
</code></pre>

<hr>
<h2 id='graph'>Generate a bare graph.</h2><span id='topic+graph'></span>

<h3>Description</h3>

<p>This function generates a bare graph object of type <code><a href="#topic+grapherator">grapherator</a></code>.
The generated object does not contain nodes, edges or edge weights. It serves as a starting
point for a three step approach of grapherator graph construction:
1) Add nodes respectively coordinates via <code><a href="#topic+addNodes">addNodes</a></code>, 2) add edges
via <code><a href="#topic+addEdges">addEdges</a></code> and finally 3) add edge weights with the function
<code><a href="#topic+addWeights">addWeights</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph(lower, upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_+3A_lower">lower</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Lower bounds for node coordinates in the Euclidean plane.</p>
</td></tr>
<tr><td><code id="graph_+3A_upper">upper</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Upper bounds for node coordinates in the Euclidean plane.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+grapherator">grapherator</a></code>] Graph.
</p>


<h3>See Also</h3>

<p>Other graph generators: <code><a href="#topic+addEdges">addEdges</a></code>,
<code><a href="#topic+addNodes">addNodes</a></code>, <code><a href="#topic+addWeights">addWeights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># complete graph with one U(10, 20) sampled weight per edge
g = graph(0, 10)
g = addNodes(g, n = 10, generator = addNodesUniform)
g = addEdges(g, generator = addEdgesComplete)
g = addWeights(g, generator = addWeightsRandom, method = runif, min = 10, max = 20)
## Not run: 
do.call(gridExtra::grid.arrange, plot(g, show.edges = FALSE))

## End(Not run)

# we extend the graph by adding another weight which is based
# on the Euclidean distance between the node coordinates
g = addWeights(g, generator = addWeightsDistance, method = "euclidean")
## Not run: 
do.call(gridExtra::grid.arrange, plot(g, show.edges = FALSE))

## End(Not run)

# next we generate a graph with each two weights per edge which resembles
# a street network. The edge weights have a positive correlation.
g = graph(0, 100)
g = addNodes(g, n = 5, generator = addNodesLHS)
g = addNodes(g, n = c(10, 10, 15, 20, 50), by.centers = TRUE,
  generator = addNodesUniform, lower = c(0, 0), upper = c(10, 10))
g = addEdges(g, generator = addEdgesDelauney, type = "intracluster")
g = addEdges(g, generator = addEdgesDelauney, type = "intercluster", k = 4L)
g = addWeights(g, generator = addWeightsCorrelated, rho = 0.6)
## Not run: 
print(g)
do.call(gridExtra::grid.arrange, plot(g, show.edges = FALSE))

## End(Not run)
</code></pre>

<hr>
<h2 id='grapherator'>Graph object.</h2><span id='topic+grapherator'></span>

<h3>Description</h3>

<p>S3 object describing a graph with the following fields:
</p>

<dl>
<dt>lower [<code>numeric(2)</code>]</dt><dd><p>Lower bounds for node coordinates in the Euclidean plane.</p>
</dd>
<dt>upper [<code>numeric(2)</code>]</dt><dd><p>Upper bounds for node coordinates in the Euclidean plane.</p>
</dd>
<dt>n.clusters [<code>integer(1)</code>]</dt><dd><p>Number of clusters.</p>
</dd>
<dt>n.nodes [<code>integer(1)</code>]</dt><dd><p>Number of nodes.</p>
</dd>
<dt>n.edges [<code>integer(1)</code>]</dt><dd><p>Number of edges.</p>
</dd>
<dt>n.weights [<code>integer(1)</code>]</dt><dd><p>Number of weights associated with each edge.</p>
</dd>
<dt>node.types [<code>character</code>]</dt><dd><p>Character vector describing the node generators used to create nodes.</p>
</dd>
<dt>edge.types [<code>character</code>]</dt><dd><p>Character vector describing the node generators used to create edges.</p>
</dd>
<dt>weight.types [<code>character</code>]</dt><dd><p>Character vector describing the node generators used to create weights.</p>
</dd>
<dt>weights [<code>list</code> of <code>matrix</code>]</dt><dd><p>List of weight/distance/cost matrizes.</p>
</dd>
<dt>degree [<code>integer</code>]</dt><dd><p>Integer vector of node degrees.</p>
</dd>
<dt>membership [<code>integer</code> | <code>NULL</code>]</dt><dd><p>Integer vector which stores the cluster membership of each node. Not <code>NULL</code> only if graph is clustered.</p>
</dd>
<dt>coordinates [<code>matrix(n.nodes, 2)</code>]</dt><dd><p>Matrix of node coordinates. Each row contains the node coordinates of one node.</p>
</dd>
</dl>


<hr>
<h2 id='nodeGenerators'>Node generators.</h2><span id='topic+nodeGenerators'></span><span id='topic+addNodesLHS'></span><span id='topic+addNodesUniform'></span><span id='topic+addNodesTriangular'></span><span id='topic+addNodesGrid'></span><span id='topic+addNodesNormal'></span>

<h3>Description</h3>

<p>Functions for the placement of nodes / node coordinates in the
Euclidean plane. Function <code>addNodesLHS</code> generates a space-filling
Latin-Hypercube-Sample (LHS), function <code>addNodesUniform</code> samples points from a
bivariate uniform distribution, <code>addNodesGrid</code> generates a regular
grid/lattice of points, <code>addNodesTriangular</code> generates a regular triangular
grid/lattice and <code>addNodesNormal</code> generates nodes on basis of a normal
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNodesLHS(n, lower = 0, upper = 1, method = NULL)

addNodesUniform(n, lower, upper)

addNodesTriangular(n, lower, upper)

addNodesGrid(n, lower, upper)

addNodesNormal(n, lower, upper, x.mean, x.sd, y.mean, y.sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodeGenerators_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of nodes to generate.</p>
</td></tr>
<tr><td><code id="nodeGenerators_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric(2)</code>]<br />
Minimal values for the first and second node coordinates respectively.
Default is 0 for both dimensions.</p>
</td></tr>
<tr><td><code id="nodeGenerators_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric(2)</code>]<br />
Maximal values for the first and second node coordinates respectively.
Default is 1 for both dimensions.</p>
</td></tr>
<tr><td><code id="nodeGenerators_+3A_method">method</code></td>
<td>
<p>[<code>function</code>]<br />
Function from package <span class="pkg">lhs</span>.
Default is <code><a href="lhs.html#topic+maximinLHS">maximinLHS</a></code>.
Only relevant for <code><a href="#topic+addNodesLHS">addNodesLHS</a></code>.</p>
</td></tr>
<tr><td><code id="nodeGenerators_+3A_x.mean">x.mean</code></td>
<td>
<p>[<code>numeric</code>]<br />
Mean value of normal distribution for x-value generation.
Only relevant for <code><a href="#topic+addNodesNormal">addNodesNormal</a></code>.</p>
</td></tr>
<tr><td><code id="nodeGenerators_+3A_x.sd">x.sd</code></td>
<td>
<p>[<code>numeric</code>]<br />
Standard deviation of normal distribution for x-value generation.
Only relevant for <code><a href="#topic+addNodesNormal">addNodesNormal</a></code>.</p>
</td></tr>
<tr><td><code id="nodeGenerators_+3A_y.mean">y.mean</code></td>
<td>
<p>[<code>numeric</code>]<br />
Mean value of normal distribution for y-value generation.
Only relevant for <code><a href="#topic+addNodesNormal">addNodesNormal</a></code>.</p>
</td></tr>
<tr><td><code id="nodeGenerators_+3A_y.sd">y.sd</code></td>
<td>
<p>[<code>numeric</code>]<br />
Standard deviation of normal distribution for y-value generation.
Only relevant for <code><a href="#topic+addNodesNormal">addNodesNormal</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List with components:
</p>

<dl>
<dt>coords [<code>matrix(n, 2)</code>]</dt><dd><p>Matrix of node coordinates.</p>
</dd>
<dt>generator [<code>character(1)</code>]</dt><dd><p>String description of the generator used.</p>
</dd>
</dl>



<h3>Note</h3>

<p>These functions are not meant to be called directly. Instead, they need
to be assigned to the <code>generator</code> argument of <code><a href="#topic+addNodes">addNodes</a></code>.
</p>

<hr>
<h2 id='plot.grapherator'>Visualize graph.</h2><span id='topic+plot.grapherator'></span>

<h3>Description</h3>

<p><code>plot.grapherator</code> generates a scatterplot of the nodes in the
Euclidean plane. Additionally, the edge weights are visualized. In case of one
weight per edge either a histogram or an empirical distribution function is drawn.
For graphs with two weights per edge a scatterplot is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grapherator'
plot(x, y = NULL, show.cluster.centers = TRUE,
  highlight.clusters = FALSE, show.edges = TRUE,
  weight.plot.type = "histogram", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.grapherator_+3A_x">x</code></td>
<td>
<p>[<code>grapherator</code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="plot.grapherator_+3A_y">y</code></td>
<td>
<p>Not used at the moment.</p>
</td></tr>
<tr><td><code id="plot.grapherator_+3A_show.cluster.centers">show.cluster.centers</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Display cluster centers?
Default is <code>TRUE</code>. This option is ignored silently if the instance is not clustered.</p>
</td></tr>
<tr><td><code id="plot.grapherator_+3A_highlight.clusters">highlight.clusters</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Shall nodes be coloured by cluster membership?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.grapherator_+3A_show.edges">show.edges</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Display edges? Keep in mind, that the number of edges is <code class="reqn">O(n^2)</code>
where <code class="reqn">n</code> is the number of nodes.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.grapherator_+3A_weight.plot.type">weight.plot.type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Type of visualization which should be used for weights in case <code>x</code> has only
as single weight attached to each edge. Either &ldquo;histogram&rdquo; or &ldquo;ecdf&rdquo;
(empirical distribution function) are possible choices.
Default is <code>histogram</code>.</p>
</td></tr>
<tr><td><code id="plot.grapherator_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] A list of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> objects with components
<code>pl.weights</code> (scatterplot of edge weights) and eventually <code>pl.coords</code> (scatterplot of
nodes). The latter is <code>NULL</code>, if <code>graph</code> has no associated coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = graph(0, 100)
g = addNodes(g, n = 25, generator = addNodesGrid)
g = addEdges(g, generator = addEdgesDelauney)
g = addWeights(g, generator = addWeightsDistance, method = "manhattan")
## Not run: 
pls = plot(g, weight.plot.type = "ecdf")

## End(Not run)

g = addWeights(g, generator = addWeightsRandom,
  method = rpois, lambda = 0.1)
## Not run: 
pls = plot(g, show.edges = FALSE)

## End(Not run)

g = graph(0, 100)
g = addNodes(g, n = 25, generator = addNodesGrid)
g = addNodes(g, n = 9, by.centers = TRUE, generator = addNodesGrid,
  lower = c(0, 0), upper = c(7, 7))
g = addEdges(g, generator = addEdgesDelauney)
g = addWeights(g, generator = addWeightsCorrelated, rho = -0.8)
## Not run: 
do.call(gridExtra::grid.arrange, plot(g, show.edges = FALSE))
do.call(gridExtra::grid.arrange, plot(g, show.edges = TRUE,
  show.cluster.centers = FALSE))

## End(Not run)
</code></pre>

<hr>
<h2 id='writeGP'>Export/import graph.</h2><span id='topic+writeGP'></span><span id='topic+readGP'></span>

<h3>Description</h3>

<p>Given a <code>grapherator</code> graph function <code><a href="#topic+writeGP">writeGP</a></code>
saves the graph to a file. Function <code><a href="#topic+readGP">readGP</a></code> imports a graph
given a filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeGP(graph, file)

readGP(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeGP_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="writeGP_+3A_file">file</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path to file where the graph shall be stored (for <code><a href="#topic+writeGP">writeGP</a></code>)
or which contains the graph to be imported (for <code>link{readGP}</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instances are stored in a format similar to the one used
by Cardoso et al. in their MOST project. Note that all values in each line are separated by comma.
First line contains four integer values: number of nodes n, number of edges m,
number of clusters cl and number of weights p per edge.
The second line contains the weight types.
The third line contains the node types.
The next n lines contain the node coordinates.
In case of a clustered instance the next line contains the node to cluster
membership mapping.
The last m lines contain the following information each:
i,j,w1(i,j),...,wp(i,j)
I.e., each two node numbers i and j followed by the p weights of the edge
(i, j).
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+writeGP">writeGP</a></code> silently returns the passed filename
<code>file</code> whereas <code><a href="#topic+writeGP">writeGP</a></code> returns a <code>grapherator</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = graph(0, 100)
g = addNodes(g, n = 25, generator = addNodesGrid)
g = addEdges(g, generator = addEdgesGrid)
g = addWeights(g, generator = addWeightsRandom, method = runif, min = 5, max = 100, to.int = TRUE)
g = addWeights(g, generator = addWeightsRandom, method = runif, min = 10, max = 100, to.int = TRUE)
## Not run: 
filename = tempfile()
writeGP(g, file = filename)
g2 = readGP(file = filename)
unlink(filename)
do.call(gridExtra::grid.arrange, c(plot(g), plot(g2), list(nrow = 2)))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
