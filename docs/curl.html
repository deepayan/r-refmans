<!DOCTYPE html><html><head><title>Help for package curl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {curl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#curl'><p>Curl connection interface</p></a></li>
<li><a href='#curl_download'><p>Download file to disk</p></a></li>
<li><a href='#curl_echo'><p>Echo Service</p></a></li>
<li><a href='#curl_escape'><p>URL encoding</p></a></li>
<li><a href='#curl_fetch_memory'><p>Fetch the contents of a URL</p></a></li>
<li><a href='#curl_options'><p>List curl version and options.</p></a></li>
<li><a href='#curl_upload'><p>Upload a File</p></a></li>
<li><a href='#file_writer'><p>Lazy File Writer</p></a></li>
<li><a href='#handle'><p>Create and configure a curl handle</p></a></li>
<li><a href='#handle_cookies'><p>Extract cookies from a handle</p></a></li>
<li><a href='#ie_proxy'><p>Internet Explorer proxy settings</p></a></li>
<li><a href='#multi'><p>Async Concurrent Requests</p></a></li>
<li><a href='#multi_download'><p>Advanced download interface</p></a></li>
<li><a href='#multipart'><p>POST files or data</p></a></li>
<li><a href='#nslookup'><p>Lookup a hostname</p></a></li>
<li><a href='#parse_date'><p>Parse date/time</p></a></li>
<li><a href='#parse_headers'><p>Parse response headers</p></a></li>
<li><a href='#send_mail'><p>Send email</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Modern and Flexible Web Client for R</td>
</tr>
<tr>
<td>Version:</td>
<td>5.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The curl() and curl_download() functions provide highly
    configurable drop-in replacements for base url() and download.file() with
    better performance, support for encryption (https, ftps), gzip compression,
    authentication, and other 'libcurl' goodies. The core of the package implements a
    framework for performing fully customized requests where data can be processed
    either in memory, on disk, or streaming via the callback or connection
    interfaces. Some knowledge of 'libcurl' is recommended; for a more-user-friendly
    web client see the 'httr' package which builds on this package with http
    specific tools and logic.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libcurl: libcurl-devel (rpm) or
libcurl4-openssl-dev (deb).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jeroen.r-universe.dev/curl">https://jeroen.r-universe.dev/curl</a> <a href="https://curl.se/libcurl/">https://curl.se/libcurl/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jeroen/curl/issues">https://github.com/jeroen/curl/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, testthat (&ge; 1.0.0), knitr, jsonlite, later,
rmarkdown, magrittr, httpuv (&ge; 1.4.4), webutils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 23:07:08 UTC; jeroen</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Hadley Wickham [ctb],
  RStudio [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeroen Ooms &lt;jeroen@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 07:30:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:13:55 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='curl'>Curl connection interface</h2><span id='topic+curl'></span>

<h3>Description</h3>

<p>Drop-in replacement for base <code><a href="base.html#topic+url">url</a></code> that supports https, ftps,
gzip, deflate, etc. Default behavior is identical to <code><a href="base.html#topic+url">url</a></code>, but
request can be fully configured by passing a custom <code><a href="curl.html#topic+handle">handle</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl(url = "https://hb.cran.dev/get", open = "", handle = new_handle())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_+3A_url">url</code></td>
<td>
<p>character string. See examples.</p>
</td></tr>
<tr><td><code id="curl_+3A_open">open</code></td>
<td>
<p>character string. How to open the connection if it should be opened
initially. Currently only &quot;r&quot; and &quot;rb&quot; are supported.</p>
</td></tr>
<tr><td><code id="curl_+3A_handle">handle</code></td>
<td>
<p>a curl handle object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of version 2.3 curl connections support <code>open(con, blocking = FALSE)</code>.
In this case <code>readBin</code> and <code>readLines</code> will return immediately with data
that is available without waiting. For such non-blocking connections the caller
needs to call <code><a href="base.html#topic+isIncomplete">isIncomplete</a></code> to check if the download has completed
yet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- curl("https://hb.cran.dev/get")
readLines(con)

# Auto-opened connections can be recycled
open(con, "rb")
bin &lt;- readBin(con, raw(), 999)
close(con)
rawToChar(bin)

# HTTP error
curl("https://hb.cran.dev/status/418", "r")

# Follow redirects
readLines(curl("https://hb.cran.dev/redirect/3"))

# Error after redirect
curl("https://hb.cran.dev/redirect-to?url=https://hb.cran.dev/status/418", "r")

# Auto decompress Accept-Encoding: gzip / deflate (rfc2616 #14.3)
readLines(curl("https://hb.cran.dev/gzip"))
readLines(curl("https://hb.cran.dev/deflate"))

# Binary support
buf &lt;- readBin(curl("https://hb.cran.dev/bytes/98765", "rb"), raw(), 1e5)
length(buf)

# Read file from disk
test &lt;- paste0("file://", system.file("DESCRIPTION"))
readLines(curl(test))

# Other protocols
read.csv(curl("ftp://cran.r-project.org/pub/R/CRAN_mirrors.csv"))
readLines(curl("ftps://test.rebex.net:990/readme.txt"))
readLines(curl("gopher://quux.org/1"))

# Streaming data
con &lt;- curl("http://jeroen.github.io/data/diamonds.json", "r")
while(length(x &lt;- readLines(con, n = 5))){
  print(x)
}

# Stream large dataset over https with gzip
library(jsonlite)
con &lt;- gzcon(curl("https://jeroen.github.io/data/nycflights13.json.gz"))
nycflights &lt;- stream_in(con)

## End(Not run)

</code></pre>

<hr>
<h2 id='curl_download'>Download file to disk</h2><span id='topic+curl_download'></span>

<h3>Description</h3>

<p>Libcurl implementation of <code>C_download</code> (the &quot;internal&quot; download method)
with added support for https, ftps, gzip, etc. Default behavior is identical
to <code><a href="utils.html#topic+download.file">download.file</a></code>, but request can be fully configured by passing
a custom <code><a href="curl.html#topic+handle">handle</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_download(url, destfile, quiet = TRUE, mode = "wb", handle = new_handle())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_download_+3A_url">url</code></td>
<td>
<p>A character string naming the URL of a resource to be downloaded.</p>
</td></tr>
<tr><td><code id="curl_download_+3A_destfile">destfile</code></td>
<td>
<p>A character string with the name where the downloaded file
is saved. Tilde-expansion is performed.</p>
</td></tr>
<tr><td><code id="curl_download_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, suppress status messages (if any), and the
progress bar.</p>
</td></tr>
<tr><td><code id="curl_download_+3A_mode">mode</code></td>
<td>
<p>A character string specifying the mode with which to write the file.
Useful values are <code>"w"</code>, <code>"wb"</code> (binary), <code>"a"</code> (append)
and <code>"ab"</code>.</p>
</td></tr>
<tr><td><code id="curl_download_+3A_handle">handle</code></td>
<td>
<p>a curl handle object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main difference between <code>curl_download</code> and <code>curl_fetch_disk</code>
is that <code>curl_download</code> checks the http status code before starting the
download, and raises an error when status is non-successful. The behavior of
<code>curl_fetch_disk</code> on the other hand is to proceed as normal and write
the error page to disk in case of a non success response.
</p>
<p>For a more advanced download interface which supports concurrent requests and
resuming large files, have a look at the <a href="curl.html#topic+multi_download">multi_download</a> function.
</p>


<h3>Value</h3>

<p>Path of downloaded file (invisibly).
</p>


<h3>See Also</h3>

<p>Advanced download interface: <a href="curl.html#topic+multi_download">multi_download</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Download large file
## Not run: 
url &lt;- "http://www2.census.gov/acs2011_5yr/pums/csv_pus.zip"
tmp &lt;- tempfile()
curl_download(url, tmp)

## End(Not run)
</code></pre>

<hr>
<h2 id='curl_echo'>Echo Service</h2><span id='topic+curl_echo'></span><span id='topic+find_port'></span>

<h3>Description</h3>

<p>This function is only for testing purposes. It starts a local httpuv server to
echo the request body and content type in the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_echo(handle, port = find_port(), progress = interactive(), file = NULL)

find_port(range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_echo_+3A_handle">handle</code></td>
<td>
<p>a curl handle object</p>
</td></tr>
<tr><td><code id="curl_echo_+3A_port">port</code></td>
<td>
<p>the port number on which to run httpuv server</p>
</td></tr>
<tr><td><code id="curl_echo_+3A_progress">progress</code></td>
<td>
<p>show progress meter during http transfer</p>
</td></tr>
<tr><td><code id="curl_echo_+3A_file">file</code></td>
<td>
<p>path or connection to write body. Default returns body as raw vector.</p>
</td></tr>
<tr><td><code id="curl_echo_+3A_range">range</code></td>
<td>
<p>optional integer vector of ports to consider</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('httpuv')){
h &lt;- new_handle(url = 'https://hb.cran.dev/post')
handle_setform(h, foo = "blabla", bar = charToRaw("test"),
  myfile = form_file(system.file("DESCRIPTION"), "text/description"))

# Echo the POST request data
formdata &lt;- curl_echo(h)

# Show the multipart body
cat(rawToChar(formdata$body))

# Parse multipart
webutils::parse_http(formdata$body, formdata$content_type)
}
</code></pre>

<hr>
<h2 id='curl_escape'>URL encoding</h2><span id='topic+curl_escape'></span><span id='topic+curl_unescape'></span>

<h3>Description</h3>

<p>Escape all special characters (i.e. everything except for a-z, A-Z, 0-9, '-',
'.', '_' or '~') for use in URLs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_escape(url)

curl_unescape(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_escape_+3A_url">url</code></td>
<td>
<p>A character vector (typically containing urls or parameters) to be
encoded/decoded</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Escape strings
out &lt;- curl_escape("foo = bar + 5")
curl_unescape(out)

# All non-ascii characters are encoded
mu &lt;- "\u00b5"
curl_escape(mu)
curl_unescape(curl_escape(mu))
</code></pre>

<hr>
<h2 id='curl_fetch_memory'>Fetch the contents of a URL</h2><span id='topic+curl_fetch_memory'></span><span id='topic+curl_fetch_disk'></span><span id='topic+curl_fetch_stream'></span><span id='topic+curl_fetch_multi'></span><span id='topic+curl_fetch_echo'></span>

<h3>Description</h3>

<p>Low-level bindings to write data from a URL into memory, disk or a callback
function. These are mainly intended for <code>httr</code>, most users will be better
off using the <code><a href="curl.html#topic+curl">curl</a></code> or <code><a href="curl.html#topic+curl_download">curl_download</a></code> function, or the
http specific wrappers in the <code>httr</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_fetch_memory(url, handle = new_handle())

curl_fetch_disk(url, path, handle = new_handle())

curl_fetch_stream(url, fun, handle = new_handle())

curl_fetch_multi(
  url,
  done = NULL,
  fail = NULL,
  pool = NULL,
  data = NULL,
  handle = new_handle()
)

curl_fetch_echo(url, handle = new_handle())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_fetch_memory_+3A_url">url</code></td>
<td>
<p>A character string naming the URL of a resource to be downloaded.</p>
</td></tr>
<tr><td><code id="curl_fetch_memory_+3A_handle">handle</code></td>
<td>
<p>a curl handle object</p>
</td></tr>
<tr><td><code id="curl_fetch_memory_+3A_path">path</code></td>
<td>
<p>Path to save results</p>
</td></tr>
<tr><td><code id="curl_fetch_memory_+3A_fun">fun</code></td>
<td>
<p>Callback function. Should have one argument, which will be
a raw vector.</p>
</td></tr>
<tr><td><code id="curl_fetch_memory_+3A_done">done</code></td>
<td>
<p>callback function for completed request. Single argument with
response data in same structure as <a href="curl.html#topic+curl_fetch_memory">curl_fetch_memory</a>.</p>
</td></tr>
<tr><td><code id="curl_fetch_memory_+3A_fail">fail</code></td>
<td>
<p>callback function called on failed request. Argument contains
error message.</p>
</td></tr>
<tr><td><code id="curl_fetch_memory_+3A_pool">pool</code></td>
<td>
<p>a multi handle created by <a href="curl.html#topic+new_pool">new_pool</a>. Default uses a global pool.</p>
</td></tr>
<tr><td><code id="curl_fetch_memory_+3A_data">data</code></td>
<td>
<p>(advanced) callback function, file path, or connection object for writing
incoming data. This callback should only be used for <em>streaming</em> applications,
where small pieces of incoming data get written before the request has completed. The
signature for the callback function is <code>write(data, final = FALSE)</code>. If set
to <code>NULL</code> the entire response gets buffered internally and returned by in
the <code>done</code> callback (which is usually what you want).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The curl_fetch functions automatically raise an error upon protocol problems
(network, disk, ssl) but do not implement application logic. For example for
you need to check the status code of http requests yourself in the response,
and deal with it accordingly.
</p>
<p>Both <code>curl_fetch_memory</code> and <code>curl_fetch_disk</code> have a blocking and
non-blocking C implementation. The latter is slightly slower but allows for
interrupting the download prematurely (using e.g. CTRL+C or ESC). Interrupting
is enabled when R runs in interactive mode or when
<code>getOption("curl_interrupt") == TRUE</code>.
</p>
<p>The <code>curl_fetch_multi</code> function is the asynchronous equivalent of
<code>curl_fetch_memory</code>. It wraps <code>multi_add</code> to schedule requests which
are executed concurrently when calling <code>multi_run</code>. For each successful
request the <code>done</code> callback is triggered with response data. For failed
requests (when <code>curl_fetch_memory</code> would raise an error), the <code>fail</code>
function is triggered with the error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load in memory
res &lt;- curl_fetch_memory("https://hb.cran.dev/cookies/set?foo=123&amp;bar=ftw")
res$content

# Save to disk
res &lt;- curl_fetch_disk("https://hb.cran.dev/stream/10", tempfile())
res$content
readLines(res$content)

# Stream with callback
drip_url &lt;- "https://hb.cran.dev/drip?duration=3&amp;numbytes=15&amp;code=200"
res &lt;- curl_fetch_stream(drip_url, function(x){
  cat(rawToChar(x))
})

# Async API
data &lt;- list()
success &lt;- function(res){
  cat("Request done! Status:", res$status, "\n")
  data &lt;&lt;- c(data, list(res))
}
failure &lt;- function(msg){
  cat("Oh noes! Request failed!", msg, "\n")
}
curl_fetch_multi("https://hb.cran.dev/get", success, failure)
curl_fetch_multi("https://hb.cran.dev/status/418", success, failure)
curl_fetch_multi("https://urldoesnotexist.xyz", success, failure)
multi_run()
str(data)

</code></pre>

<hr>
<h2 id='curl_options'>List curl version and options.</h2><span id='topic+curl_options'></span><span id='topic+curl_symbols'></span><span id='topic+curl_version'></span>

<h3>Description</h3>

<p><code>curl_version()</code> shows the versions of libcurl, libssl and zlib and
supported protocols. <code>curl_options()</code> lists all options available in
the current version of libcurl.  The dataset <code>curl_symbols</code> lists all
symbols (including options) provides more information about the symbols,
including when support was added/removed from libcurl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_options(filter = "")

curl_symbols(filter = "")

curl_version()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_options_+3A_filter">filter</code></td>
<td>
<p>string: only return options with string in name</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Available options
curl_options()

# List proxy options
curl_options("proxy")

# Symbol table
curl_symbols("proxy")
# Curl/ssl version info
curl_version()
</code></pre>

<hr>
<h2 id='curl_upload'>Upload a File</h2><span id='topic+curl_upload'></span>

<h3>Description</h3>

<p>Upload a file to an <code>http://</code>, <code>ftp://</code>, or <code>sftp://</code> (ssh)
server. Uploading to HTTP means performing an <code>HTTP PUT</code> on that URL.
Be aware that sftp is only available for libcurl clients built with libssh2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_upload(file, url, verbose = TRUE, reuse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_upload_+3A_file">file</code></td>
<td>
<p>connection object or path to an existing file on disk</p>
</td></tr>
<tr><td><code id="curl_upload_+3A_url">url</code></td>
<td>
<p>where to upload, should start with e.g. <code>ftp://</code></p>
</td></tr>
<tr><td><code id="curl_upload_+3A_verbose">verbose</code></td>
<td>
<p>emit some progress output</p>
</td></tr>
<tr><td><code id="curl_upload_+3A_reuse">reuse</code></td>
<td>
<p>try to keep alive and recycle connections when possible</p>
</td></tr>
<tr><td><code id="curl_upload_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="curl.html#topic+handle_setopt">handle_setopt</a></code>, for
example a <code>username</code> and <code>password</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # Upload package to winbuilder:
curl_upload('mypkg_1.3.tar.gz', 'ftp://win-builder.r-project.org/R-devel/')

## End(Not run)
</code></pre>

<hr>
<h2 id='file_writer'>Lazy File Writer</h2><span id='topic+file_writer'></span>

<h3>Description</h3>

<p>Generates a closure that writes binary (raw) data to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_writer(path, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_writer_+3A_path">path</code></td>
<td>
<p>file name or path on disk</p>
</td></tr>
<tr><td><code id="file_writer_+3A_append">append</code></td>
<td>
<p>open file in append mode</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The writer function automatically opens the file on the first write and closes when
it goes out of scope, or explicitly by setting <code>close = TRUE</code>. This can be used
for the <code>data</code> callback in <code>multi_add()</code> or <code>curl_fetch_multi()</code> such
that we only keep open file handles for active downloads. This prevents running out
of file descriptors when performing thousands of concurrent requests.
</p>


<h3>Value</h3>

<p>Function with signature <code>writer(data = raw(), close = FALSE)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Doesn't open yet
tmp &lt;- tempfile()
writer &lt;- file_writer(tmp)

# Now it opens
writer(charToRaw("Hello!\n"))
writer(charToRaw("How are you?\n"))

# Close it!
writer(charToRaw("All done!\n"), close = TRUE)

# Check it worked
readLines(tmp)
</code></pre>

<hr>
<h2 id='handle'>Create and configure a curl handle</h2><span id='topic+handle'></span><span id='topic+new_handle'></span><span id='topic+handle_setopt'></span><span id='topic+handle_setheaders'></span><span id='topic+handle_getheaders'></span><span id='topic+handle_getcustom'></span><span id='topic+handle_setform'></span><span id='topic+handle_reset'></span><span id='topic+handle_data'></span>

<h3>Description</h3>

<p>Handles are the work horses of libcurl. A handle is used to configure a
request with custom options, headers and payload. Once the handle has been
set up, it can be passed to any of the download functions such as <code><a href="curl.html#topic+curl">curl</a></code>
,<code><a href="curl.html#topic+curl_download">curl_download</a></code> or <code><a href="curl.html#topic+curl_fetch_memory">curl_fetch_memory</a></code>. The handle will maintain
state in between requests, including keep-alive connections, cookies and
settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_handle(...)

handle_setopt(handle, ..., .list = list())

handle_setheaders(handle, ..., .list = list())

handle_getheaders(handle)

handle_getcustom(handle)

handle_setform(handle, ..., .list = list())

handle_reset(handle)

handle_data(handle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_+3A_...">...</code></td>
<td>
<p>named options / headers to be set in the handle.
To send a file, see <code><a href="curl.html#topic+form_file">form_file</a></code>. To list all allowed options,
see <code><a href="curl.html#topic+curl_options">curl_options</a></code></p>
</td></tr>
<tr><td><code id="handle_+3A_handle">handle</code></td>
<td>
<p>Handle to modify</p>
</td></tr>
<tr><td><code id="handle_+3A_.list">.list</code></td>
<td>
<p>A named list of options. This is useful if you've created
a list of options elsewhere, avoiding the use of <code>do.call()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>new_handle()</code> to create a new clean curl handle that can be
configured with custom options and headers. Note that <code>handle_setopt</code>
appends or overrides options in the handle, whereas <code>handle_setheaders</code>
replaces the entire set of headers with the new ones. The <code>handle_reset</code>
function resets only options/headers/forms in the handle. It does not affect
active connections, cookies or response data from previous requests. The safest
way to perform multiple independent requests is by using a separate handle for
each request. There is very little performance overhead in creating handles.
</p>


<h3>Value</h3>

<p>A handle object (external pointer to the underlying curl handle).
All functions modify the handle in place but also return the handle
so you can create a pipeline of operations.
</p>


<h3>See Also</h3>

<p>Other handles: 
<code><a href="curl.html#topic+handle_cookies">handle_cookies</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- new_handle()
handle_setopt(h, customrequest = "PUT")
handle_setform(h, a = "1", b = "2")
r &lt;- curl_fetch_memory("https://hb.cran.dev/put", h)
cat(rawToChar(r$content))

# Or use the list form
h &lt;- new_handle()
handle_setopt(h, .list = list(customrequest = "PUT"))
handle_setform(h, .list = list(a = "1", b = "2"))
r &lt;- curl_fetch_memory("https://hb.cran.dev/put", h)
cat(rawToChar(r$content))
</code></pre>

<hr>
<h2 id='handle_cookies'>Extract cookies from a handle</h2><span id='topic+handle_cookies'></span>

<h3>Description</h3>

<p>The <code>handle_cookies</code> function returns a data frame with 7 columns as specified in the
<a href="http://www.cookiecentral.com/faq/#3.5">netscape cookie file format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_cookies(handle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_cookies_+3A_handle">handle</code></td>
<td>
<p>a curl handle object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other handles: 
<code><a href="curl.html#topic+handle">handle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- new_handle()
handle_cookies(h)

# Server sets cookies
req &lt;- curl_fetch_memory("https://hb.cran.dev/cookies/set?foo=123&amp;bar=ftw", handle = h)
handle_cookies(h)

# Server deletes cookies
req &lt;- curl_fetch_memory("https://hb.cran.dev/cookies/delete?foo", handle = h)
handle_cookies(h)

# Cookies will survive a reset!
handle_reset(h)
handle_cookies(h)
</code></pre>

<hr>
<h2 id='ie_proxy'>Internet Explorer proxy settings</h2><span id='topic+ie_proxy'></span><span id='topic+ie_proxy_info'></span><span id='topic+ie_get_proxy_for_url'></span>

<h3>Description</h3>

<p>Lookup and mimic the system proxy settings on Windows as set by Internet
Explorer. This can be used to configure curl to use the same proxy server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ie_proxy_info()

ie_get_proxy_for_url(target_url = "http://www.google.com")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ie_proxy_+3A_target_url">target_url</code></td>
<td>
<p>url with host for which to lookup the proxy server</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="curl.html#topic+ie_proxy_info">ie_proxy_info</a> function looks up your current proxy settings as configured
in IE under &quot;Internet Options&quot; under &quot;LAN Settings&quot;. The <a href="curl.html#topic+ie_get_proxy_for_url">ie_get_proxy_for_url</a>
determines if and which proxy should be used to connect to a particular
URL. If your settings have an &quot;automatic configuration script&quot; this
involves downloading and executing a PAC file, which can take a while.
</p>

<hr>
<h2 id='multi'>Async Concurrent Requests</h2><span id='topic+multi'></span><span id='topic+multi_add'></span><span id='topic+multi_run'></span><span id='topic+multi_set'></span><span id='topic+multi_list'></span><span id='topic+multi_cancel'></span><span id='topic+new_pool'></span><span id='topic+multi_fdset'></span>

<h3>Description</h3>

<p>AJAX style concurrent requests, possibly using HTTP/2 multiplexing.
Results are only available via callback functions. Advanced use only!
For downloading many files in parallel use <a href="curl.html#topic+multi_download">multi_download</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_add(handle, done = NULL, fail = NULL, data = NULL, pool = NULL)

multi_run(timeout = Inf, poll = FALSE, pool = NULL)

multi_set(total_con = 50, host_con = 6, multiplex = TRUE, pool = NULL)

multi_list(pool = NULL)

multi_cancel(handle)

new_pool(total_con = 100, host_con = 6, multiplex = TRUE)

multi_fdset(pool = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_+3A_handle">handle</code></td>
<td>
<p>a curl <a href="curl.html#topic+handle">handle</a> with preconfigured <code>url</code> option.</p>
</td></tr>
<tr><td><code id="multi_+3A_done">done</code></td>
<td>
<p>callback function for completed request. Single argument with
response data in same structure as <a href="curl.html#topic+curl_fetch_memory">curl_fetch_memory</a>.</p>
</td></tr>
<tr><td><code id="multi_+3A_fail">fail</code></td>
<td>
<p>callback function called on failed request. Argument contains
error message.</p>
</td></tr>
<tr><td><code id="multi_+3A_data">data</code></td>
<td>
<p>(advanced) callback function, file path, or connection object for writing
incoming data. This callback should only be used for <em>streaming</em> applications,
where small pieces of incoming data get written before the request has completed. The
signature for the callback function is <code>write(data, final = FALSE)</code>. If set
to <code>NULL</code> the entire response gets buffered internally and returned by in
the <code>done</code> callback (which is usually what you want).</p>
</td></tr>
<tr><td><code id="multi_+3A_pool">pool</code></td>
<td>
<p>a multi handle created by <a href="curl.html#topic+new_pool">new_pool</a>. Default uses a global pool.</p>
</td></tr>
<tr><td><code id="multi_+3A_timeout">timeout</code></td>
<td>
<p>max time in seconds to wait for results. Use <code>0</code> to poll for results without
waiting at all.</p>
</td></tr>
<tr><td><code id="multi_+3A_poll">poll</code></td>
<td>
<p>If <code>TRUE</code> then return immediately after any of the requests has completed.
May also be an integer in which case it returns after n requests have completed.</p>
</td></tr>
<tr><td><code id="multi_+3A_total_con">total_con</code></td>
<td>
<p>max total concurrent connections.</p>
</td></tr>
<tr><td><code id="multi_+3A_host_con">host_con</code></td>
<td>
<p>max concurrent connections per host.</p>
</td></tr>
<tr><td><code id="multi_+3A_multiplex">multiplex</code></td>
<td>
<p>enable HTTP/2 multiplexing if supported by host and client.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requests are created in the usual way using a curl <a href="curl.html#topic+handle">handle</a> and added
to the scheduler with <a href="curl.html#topic+multi_add">multi_add</a>. This function returns immediately
and does not perform the request yet. The user needs to call <a href="curl.html#topic+multi_run">multi_run</a>
which performs all scheduled requests concurrently. It returns when all
requests have completed, or case of a <code>timeout</code> or <code>SIGINT</code> (e.g.
if the user presses <code>ESC</code> or <code>CTRL+C</code> in the console). In case of
the latter, simply call <a href="curl.html#topic+multi_run">multi_run</a> again to resume pending requests.
</p>
<p>When the request succeeded, the <code>done</code> callback gets triggered with
the response data. The structure if this data is identical to <a href="curl.html#topic+curl_fetch_memory">curl_fetch_memory</a>.
When the request fails, the <code>fail</code> callback is triggered with an error
message. Note that failure here means something went wrong in performing the
request such as a connection failure, it does not check the http status code.
Just like <a href="curl.html#topic+curl_fetch_memory">curl_fetch_memory</a>, the user has to implement application logic.
</p>
<p>Raising an error within a callback function stops execution of that function
but does not affect other requests.
</p>
<p>A single handle cannot be used for multiple simultaneous requests. However
it is possible to add new requests to a pool while it is running, so you
can re-use a handle within the callback of a request from that same handle.
It is up to the user to make sure the same handle is not used in concurrent
requests.
</p>
<p>The <a href="curl.html#topic+multi_cancel">multi_cancel</a> function can be used to cancel a pending request.
It has no effect if the request was already completed or canceled.
</p>
<p>The <a href="curl.html#topic+multi_fdset">multi_fdset</a> function returns the file descriptors curl is
polling currently, and also a timeout parameter, the number of
milliseconds an application should wait (at most) before proceeding. It
is equivalent to the <code>curl_multi_fdset</code> and
<code>curl_multi_timeout</code> calls. It is handy for applications that is
expecting input (or writing output) through both curl, and other file
descriptors.
</p>


<h3>See Also</h3>

<p>Advanced download interface: <a href="curl.html#topic+multi_download">multi_download</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- list()
success &lt;- function(x){
  results &lt;&lt;- append(results, list(x))
}
failure &lt;- function(str){
  cat(paste("Failed request:", str), file = stderr())
}
# This handle will take longest (3sec)
h1 &lt;- new_handle(url = "https://hb.cran.dev/delay/3")
multi_add(h1, done = success, fail = failure)

# This handle writes data to a file
con &lt;- file("output.txt")
h2 &lt;- new_handle(url = "https://hb.cran.dev/post", postfields = "bla bla")
multi_add(h2, done = success, fail = failure, data = con)

# This handle raises an error
h3 &lt;- new_handle(url = "https://urldoesnotexist.xyz")
multi_add(h3, done = success, fail = failure)

# Actually perform the requests
multi_run(timeout = 2)
multi_run()

# Check the file
readLines("output.txt")
unlink("output.txt")
</code></pre>

<hr>
<h2 id='multi_download'>Advanced download interface</h2><span id='topic+multi_download'></span>

<h3>Description</h3>

<p>Download multiple files concurrently, with support for resuming large files.
This function is based on <code><a href="curl.html#topic+multi_run">multi_run()</a></code> and hence does not error in case any
of the individual requests fail; you should inspect the return value to find
out which of the downloads were completed successfully.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_download(
  urls,
  destfiles = NULL,
  resume = FALSE,
  progress = TRUE,
  timeout = Inf,
  multiplex = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_download_+3A_urls">urls</code></td>
<td>
<p>vector with files to download</p>
</td></tr>
<tr><td><code id="multi_download_+3A_destfiles">destfiles</code></td>
<td>
<p>vector (of equal length as <code>urls</code>) with paths of output files,
or <code>NULL</code> to use <a href="base.html#topic+basename">basename</a> of urls.</p>
</td></tr>
<tr><td><code id="multi_download_+3A_resume">resume</code></td>
<td>
<p>if the file already exists, resume the download. Note that this may
change server responses, see details.</p>
</td></tr>
<tr><td><code id="multi_download_+3A_progress">progress</code></td>
<td>
<p>print download progress information</p>
</td></tr>
<tr><td><code id="multi_download_+3A_timeout">timeout</code></td>
<td>
<p>in seconds, passed to <a href="curl.html#topic+multi_run">multi_run</a></p>
</td></tr>
<tr><td><code id="multi_download_+3A_multiplex">multiplex</code></td>
<td>
<p>passed to <a href="curl.html#topic+new_pool">new_pool</a></p>
</td></tr>
<tr><td><code id="multi_download_+3A_...">...</code></td>
<td>
<p>extra handle options passed to each request <a href="curl.html#topic+new_handle">new_handle</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Upon completion of all requests, this function returns a data frame with results.
The <code>success</code> column indicates if a request was successfully completed (regardless
of the HTTP status code). If it failed, e.g. due to a networking issue, the error
message is in the <code>error</code> column. A <code>success</code> value <code>NA</code> indicates that the request
was still in progress when the function was interrupted or reached the elapsed
<code>timeout</code> and perhaps the download can be resumed if the server supports it.
</p>
<p>It is also important to inspect the <code>status_code</code> column to see if any of the
requests were successful but had a non-success HTTP code, and hence the downloaded
file probably contains an error page instead of the requested content.
</p>
<p>Note that when you set <code>resume = TRUE</code> you should expect HTTP-206 or HTTP-416
responses. The latter could indicate that the file was already complete, hence
there was no content left to resume from the server. If you try to resume a file
download but the server does not support this, success if <code>FALSE</code> and the file
will not be touched. In fact, if we request to a download to be resumed and the
server responds <code style="white-space: pre;">&#8288;HTTP 200&#8288;</code> instead of <code style="white-space: pre;">&#8288;HTTP 206&#8288;</code>, libcurl will error and not
download anything, because this probably means the server did not respect our
range request and is sending us the full file.
</p>


<h4>About HTTP/2</h4>

<p>Availability of HTTP/2 can increase the performance when making many parallel
requests to a server, because HTTP/2 can multiplex many requests over a single
TCP connection. Support for HTTP/2 depends on the version of <code>libcurl</code> that
your system has, and the TLS back-end that is in use, check <a href="curl.html#topic+curl_version">curl_version</a>.
For clients or servers without HTTP/2, curl makes at most 6 connections per
host over which it distributes the queued downloads.
</p>
<p>On Windows and MacOS you can switch the active TLS backend by setting an
environment variable <a href="https://curl.se/libcurl/c/libcurl-env.html"><code>CURL_SSL_BACKEND</code></a>
in your <code style="white-space: pre;">&#8288;~/.Renviron&#8288;</code> file. On Windows you can switch between <code>SecureChannel</code>
(default) and <code>OpenSSL</code> where only the latter supports HTTP/2. On MacOS you
can use either <code>SecureTransport</code> or <code>LibreSSL</code>, the default varies by MacOS
version.
</p>



<h3>Value</h3>

<p>The function returns a data frame with one row for each downloaded file and
the following columns:
</p>

<ul>
<li> <p><code>success</code> if the HTTP request was successfully performed, regardless of the
response status code. This is <code>FALSE</code> in case of a network error, or in case
you tried to resume from a server that did not support this. A value of <code>NA</code>
means the download was interrupted while in progress.
</p>
</li>
<li> <p><code>status_code</code> the HTTP status code from the request. A successful download is
usually <code>200</code> for full requests or <code>206</code> for resumed requests. Anything else
could indicate that the downloaded file contains an error page instead of the
requested content.
</p>
</li>
<li> <p><code>resumefrom</code> the file size before the request, in case a download was resumed.
</p>
</li>
<li> <p><code>url</code> final url (after redirects) of the request.
</p>
</li>
<li> <p><code>destfile</code> downloaded file on disk.
</p>
</li>
<li> <p><code>error</code> if <code>success == FALSE</code> this column contains an error message.
</p>
</li>
<li> <p><code>type</code> the <code>Content-Type</code> response header value.
</p>
</li>
<li> <p><code>modified</code> the <code>Last-Modified</code> response header value.
</p>
</li>
<li> <p><code>time</code> total elapsed download time for this file in seconds.
</p>
</li>
<li> <p><code>headers</code> vector with http response headers for the request.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example: some large files
urls &lt;- sprintf(
  "https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2021-%02d.parquet", 1:12)
res &lt;- multi_download(urls, resume = TRUE) # You can interrupt (ESC) and resume

# Example: revdep checker
# Download all reverse dependencies for the 'curl' package from CRAN:
pkg &lt;- 'curl'
mirror &lt;- 'https://cloud.r-project.org'
db &lt;- available.packages(repos = mirror)
packages &lt;- c(pkg, tools::package_dependencies(pkg, db = db, reverse = TRUE)[[pkg]])
versions &lt;- db[packages,'Version']
urls &lt;- sprintf("%s/src/contrib/%s_%s.tar.gz", mirror, packages,  versions)
res &lt;- multi_download(urls)
all.equal(unname(tools::md5sum(res$destfile)), unname(db[packages, 'MD5sum']))
# And then you could use e.g.: tools:::check_packages_in_dir()

# Example: URL checker
pkg_url_checker &lt;- function(dir){
  db &lt;- tools:::url_db_from_package_sources(dir)
  res &lt;- multi_download(db$URL, rep('/dev/null', nrow(db)), nobody=TRUE)
  db$OK &lt;- res$status_code == 200
  db
}

# Use a local package source directory
pkg_url_checker(".")


## End(Not run)
</code></pre>

<hr>
<h2 id='multipart'>POST files or data</h2><span id='topic+multipart'></span><span id='topic+form_file'></span><span id='topic+form_data'></span>

<h3>Description</h3>

<p>Build multipart form data elements. The <code>form_file</code> function uploads a
file. The <code>form_data</code> function allows for posting a string or raw vector
with a custom content-type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_file(path, type = NULL, name = NULL)

form_data(value, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multipart_+3A_path">path</code></td>
<td>
<p>a string with a path to an existing file on disk</p>
</td></tr>
<tr><td><code id="multipart_+3A_type">type</code></td>
<td>
<p>MIME content-type of the file.</p>
</td></tr>
<tr><td><code id="multipart_+3A_name">name</code></td>
<td>
<p>a string with the file name to use for the upload</p>
</td></tr>
<tr><td><code id="multipart_+3A_value">value</code></td>
<td>
<p>a character or raw vector to post</p>
</td></tr>
</table>

<hr>
<h2 id='nslookup'>Lookup a hostname</h2><span id='topic+nslookup'></span><span id='topic+has_internet'></span>

<h3>Description</h3>

<p>The <code>nslookup</code> function is similar to <code>nsl</code> but works on all platforms
and can resolve ipv6 addresses if supported by the OS. Default behavior raises an
error if lookup fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nslookup(host, ipv4_only = FALSE, multiple = FALSE, error = TRUE)

has_internet()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nslookup_+3A_host">host</code></td>
<td>
<p>a string with a hostname</p>
</td></tr>
<tr><td><code id="nslookup_+3A_ipv4_only">ipv4_only</code></td>
<td>
<p>always return ipv4 address. Set to <code>FALSE</code> to allow for ipv6 as well.</p>
</td></tr>
<tr><td><code id="nslookup_+3A_multiple">multiple</code></td>
<td>
<p>returns multiple ip addresses if possible</p>
</td></tr>
<tr><td><code id="nslookup_+3A_error">error</code></td>
<td>
<p>raise an error for failed DNS lookup. Otherwise returns <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>has_internet</code> function tests for internet connectivity by performing a
dns lookup. If a proxy server is detected, it will also check for connectivity by
connecting via the proxy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Should always work if we are online
nslookup("www.r-project.org")

# If your OS supports IPv6
nslookup("ipv6.test-ipv6.com", ipv4_only = FALSE, error = FALSE)
</code></pre>

<hr>
<h2 id='parse_date'>Parse date/time</h2><span id='topic+parse_date'></span>

<h3>Description</h3>

<p>Can be used to parse dates appearing in http response headers such
as <code>Expires</code> or <code>Last-Modified</code>. Automatically recognizes
most common formats. If the format is known, <code><a href="base.html#topic+strptime">strptime</a></code>
might be easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_date(datestring)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_date_+3A_datestring">datestring</code></td>
<td>
<p>a string consisting of a timestamp</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Parse dates in many formats
parse_date("Sunday, 06-Nov-94 08:49:37 GMT")
parse_date("06 Nov 1994 08:49:37")
parse_date("20040911 +0200")
</code></pre>

<hr>
<h2 id='parse_headers'>Parse response headers</h2><span id='topic+parse_headers'></span><span id='topic+parse_headers_list'></span>

<h3>Description</h3>

<p>Parse response header data as returned by curl_fetch, either as a set of strings
or into a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_headers(txt, multiple = FALSE)

parse_headers_list(txt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_headers_+3A_txt">txt</code></td>
<td>
<p>raw or character vector with the header data</p>
</td></tr>
<tr><td><code id="parse_headers_+3A_multiple">multiple</code></td>
<td>
<p>parse multiple sets of headers separated by a blank line. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parse_headers_list function parses the headers into a normalized (lowercase
field names, trimmed whitespace) named list.
</p>
<p>If a request has followed redirects, the data can contain multiple sets of headers.
When multiple = TRUE, the function returns a list with the response headers
for each request. By default it only returns the headers of the final request.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- curl_fetch_memory("https://hb.cran.dev/redirect/3")
parse_headers(req$headers)
parse_headers(req$headers, multiple = TRUE)

# Parse into named list
parse_headers_list(req$headers)
</code></pre>

<hr>
<h2 id='send_mail'>Send email</h2><span id='topic+send_mail'></span>

<h3>Description</h3>

<p>Use the curl SMTP client to send an email. The <code>message</code> argument must be
properly formatted <a href="https://www.rfc-editor.org/rfc/rfc2822">RFC2822</a> email message with From/To/Subject headers and CRLF
line breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send_mail(
  mail_from,
  mail_rcpt,
  message,
  smtp_server = "smtp://localhost",
  use_ssl = c("try", "no", "force"),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send_mail_+3A_mail_from">mail_from</code></td>
<td>
<p>email address of the sender.</p>
</td></tr>
<tr><td><code id="send_mail_+3A_mail_rcpt">mail_rcpt</code></td>
<td>
<p>one or more recipient email addresses. Do not include names,
these go into the <code>message</code> headers.</p>
</td></tr>
<tr><td><code id="send_mail_+3A_message">message</code></td>
<td>
<p>either a string or connection with (properly formatted) email
message, including sender/recipient/subject headers. See example.</p>
</td></tr>
<tr><td><code id="send_mail_+3A_smtp_server">smtp_server</code></td>
<td>
<p>hostname or address of the SMTP server, or, an
<code>smtp://</code> or <code>smtps://</code> URL. See &quot;Specifying the server, port,
and protocol&quot; below.</p>
</td></tr>
<tr><td><code id="send_mail_+3A_use_ssl">use_ssl</code></td>
<td>
<p>Request to upgrade the connection to SSL using the STARTTLS command,
see <a href="https://curl.se/libcurl/c/CURLOPT_USE_SSL.html">CURLOPT_USE_SSL</a>
for details. Default will try to SSL, proceed as normal otherwise.</p>
</td></tr>
<tr><td><code id="send_mail_+3A_verbose">verbose</code></td>
<td>
<p>print output</p>
</td></tr>
<tr><td><code id="send_mail_+3A_...">...</code></td>
<td>
<p>other options passed to <code><a href="curl.html#topic+handle_setopt">handle_setopt</a></code>. In most cases
you will need to set a <code>username</code> and <code>password</code> to authenticate
with the SMTP server.</p>
</td></tr>
</table>


<h3>Specifying the server, port, and protocol</h3>

<p>The <code>smtp_server</code> argument takes a hostname, or an SMTP URL:
</p>

<ul>
<li> <p><code>mail.example.com</code> - hostname only
</p>
</li>
<li> <p><code>mail.example.com:587</code> - hostname and port
</p>
</li>
<li> <p><code>smtp://mail.example.com</code> - protocol and hostname
</p>
</li>
<li> <p><code>smtp://mail.example.com:587</code> - full SMTP URL
</p>
</li>
<li> <p><code>smtps://mail.example.com:465</code> - full SMTPS URL
</p>
</li></ul>

<p>By default, the port will be 25, unless <code>smtps://</code> is specified&ndash;then
the default will be 465 instead.
</p>


<h3>Encrypting connections via SMTPS or STARTTLS</h3>

<p>There are two different ways in which SMTP can be encrypted: SMTPS servers
run on a port which only accepts encrypted connections, similar to HTTPS.
Alternatively, a regular insecure smtp connection can be &quot;upgraded&quot; to a
secure TLS connection using the STARTTLS command. It is important to know
which method your server expects.
</p>
<p>If your smtp server listens on port 465, then use a  <code>smtps://hostname:465</code>
URL. The SMTPS protocol <em>guarantees</em> that TLS will be used to protect
all communications from the start.
</p>
<p>If your email server listens on port 25 or 587, use an <code>smtp://</code> URL in
combination with the  <code>use_ssl</code> parameter to control if the connection
should be upgraded with STARTTLS. The default value <code>"try"</code> will
<em>opportunistically</em> try to upgrade to a secure connection if the server
supports it, and proceed as normal otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # Set sender and recipients (email addresses only)
recipients &lt;- readline("Enter your email address to receive test: ")
sender &lt;- 'test@noreply.com'

# Full email message in RFC2822 format
message &lt;- 'From: "R (curl package)" &lt;test@noreply.com&gt;
To: "Roger Recipient" &lt;roger@noreply.com&gt;
Subject: Hello R user!

Dear R user,

I am sending this email using curl.'

# Send the email
send_mail(sender, recipients, message, smtp_server = 'smtps://smtp.gmail.com',
  username = 'curlpackage', password  = 'qyyjddvphjsrbnlm')
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
