<!DOCTYPE html><html><head><title>Help for package slp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {slp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.dpss'><p>Compute Discrete Prolate Spheroidal Sequences</p></a></li>
<li><a href='#basis'><p>slp: Pre-computed basis sets</p></a></li>
<li><a href='#checkSaved'><p>Determine if combination of N, W and K is available on disk, or must be computed</p></a></li>
<li><a href='#Predict.matrix.slp.smooth'><p>Create model matrix for prediction, for model using slp smoother</p></a></li>
<li><a href='#slp-package'>
<p>slp: Discrete Prolate Spheroidal (Slepian) Sequence Regression Smoothers</p></a></li>
<li><a href='#slp.gam'><p>Generate a Basis Matrix for Discrete Prolate Spheroidal (Slepian) Sequences</p></a></li>
<li><a href='#slp.mgcv'><p>Generate a Basis Matrix for Discrete Prolate Spheroidal (Slepian) Sequences</p></a></li>
<li><a href='#slpSavedObjects'><p>slp: Listing of available pre-computed basis sets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-5</td>
</tr>
<tr>
<td>Author:</td>
<td>Wesley Burr, with contributions from Karim Rahim</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file COPYRIGHTS</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wesley Burr &lt;wesley.burr@gmail.com&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Discrete Prolate Spheroidal (Slepian) Sequence Regression
Smoothers</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface for creation of 'slp' class smoother objects for 
             use in Generalized Additive Models (as implemented by packages 
             'gam' and 'mgcv'). </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv (&ge; 1.7.18)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gam (&ge; 1.09)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-08-28 15:03:05 UTC; wburr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-08-28 18:54:58</td>
</tr>
</table>
<hr>
<h2 id='.dpss'>Compute Discrete Prolate Spheroidal Sequences</h2><span id='topic+.dpss'></span><span id='topic+dpss'></span>

<h3>Description</h3>

<p>Compute Discrete Prolate Spheroidal (Slepian) Sequences for use as
time-based smoother. This approach uses the tridiagonal method and exploits
symmetry. Note the odd order tapers are normalized so that the slope at the
centre is positive, in accordance with Slepian (1978) and Thomson (1982). This
differs from Percival and Walden (1993). This code follows Chapter
8.3 of Percival and Walden (1993) using LAPACK function calls,  Anderson (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.dpss(n,k,nw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".dpss_+3A_n">n</code></td>
<td>
<p>A positive integer, typically the length of the time series-regression data set.</p>
</td></tr>
<tr><td><code id=".dpss_+3A_k">k</code></td>
<td>
<p>A positive integer, the number of basis vectors for the smoother, often 2*nw - 2. </p>
</td></tr>
<tr><td><code id=".dpss_+3A_nw">nw</code></td>
<td>
<p>A positive double-precision number, the time-bandwidth parameter. The frequency domain
analogue of the maximum period of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>v</code></td>
<td>
<p>A 'n' by 'k' matrix of basis vectors of class 'dpss'. Each column is the appropriate
Slepian sequence of order 'k-1'.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Anderson, E. (1999).
<em>LAPACK Users' guide (Vol. 9).</em>
SIAM.
</p>
<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications.</em>
Cambridge University Press.
</p>
<p>Slepian, D. (1978)
Prolate spheroidal wave functions, Fourier analysis, and
uncertainty. V&ndash;The discrete case. <em>Bell System Technical Journal</em>
Volume <b>57</b>, pp. 1371&ndash;1430
</p>
<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>
Volume <b>70</b>, number 9, pp. 1055&ndash;1096.
</p>

<hr>
<h2 id='basis'>slp: Pre-computed basis sets</h2><span id='topic+basis'></span>

<h3>Description</h3>

<p>Shared name for a number of pre-computed basis sets included with the 
<code>slp</code> package. For large <code>N</code>, significant speed-ups can be 
obtained by pre-computing the basis set and simply loading it from disk. 
</p>


<h3>Format</h3>

<p>Each file named <code>basis_N_XXX_W_X_K_XX.RData</code>,
with the <code>X</code> entries integers indicating the <code>N</code>, <code>W</code> (in
<code>df/</code>year) and <code>K</code> parameters, can be loaded via <code>data(...)</code>
as a <code>basis</code> object in the environment of your choice.
</p>
<p>Currently, these pre-computed bases are used as speed-up aids within 
<code>{slp(...)}</code> and <code>{s(..., bs='slp', ...)}</code>.
A full list of available bases can be obtained by examining
<code>slpSavedObjects</code>, an additional <code>data(...)</code> object included
with the package. 
</p>

<hr>
<h2 id='checkSaved'>Determine if combination of N, W and K is available on disk, or must be computed</h2><span id='topic+checkSaved'></span>

<h3>Description</h3>

<p>Given values for <code>N</code>, <code>W</code> and <code>K</code>, determine if the combination is 
available on disk as a <code>data()</code> load. If so, significant time savings can be
obtained, especially for large <code>N</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSaved(N, W, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSaved_+3A_n">N</code></td>
<td>
<p>the length of the time index array, in units of <code>deltat</code>.</p>
</td></tr>
<tr><td><code id="checkSaved_+3A_w">W</code></td>
<td>
<p>the time bandwidth, <b>in units of</b> <code>df/</code>year. This is <b>not</b>
the same units as a <code>slp(...)</code> call, and <code>W</code> should be an integer, 
e.g., 6 <code>df/</code>year.</p>
</td></tr>
<tr><td><code id="checkSaved_+3A_k">K</code></td>
<td>
<p>the number of basis vectors requested. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does a lookup against <code>data(slpSavedObjects)</code> to determine whether the
combination of <code>N</code>, <code>W</code> and <code>K</code> is saved on disk as part of the
package, and can be loaded. It is possible to create your own basis objects for
particular choices of <code>N</code>, <code>W</code> and <code>K</code> and save them as part 
of the library directory, updating <code>slpSavedObjects</code> as you do so. 
</p>


<h3>Value</h3>

<p>Logical (<code>TRUE</code> or <code>FALSE</code>), indicating availability or lack thereof. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Examples using pkg:gam
    library("slp")
    checkSaved(N = 730, W = 6, K = 24)
    checkSaved(N = 365, W = 6, K = 13)
</code></pre>

<hr>
<h2 id='Predict.matrix.slp.smooth'>Create model matrix for prediction, for model using slp smoother</h2><span id='topic+Predict.matrix.slp.smooth'></span><span id='topic+slp.smooth'></span>

<h3>Description</h3>

<p>Re-generate the basis matrix for a particular <code>N, W</code> Slepian sequence
family member, with the additional property that the smoother captures/passes constants
without distortion. Simply re-arranges <code>object</code>. Not intended to be used
directly by user. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slp.smooth'
Predict.matrix(object,data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Predict.matrix.slp.smooth_+3A_object">object</code></td>
<td>
<p>a smooth specification object, usually generated by a model term <code>s(..., bs = 'slp', ..., xt = list(...))</code>,
and for this type, <b>requiring</b> an additional <code>xt = list()</code> object containing parameters.
For examples, see below. </p>
</td></tr>
<tr><td><code id="Predict.matrix.slp.smooth_+3A_data">data</code></td>
<td>
<p>a list containing just the data required by this term, with names corresponding to
<code>object[['term']]</code>. Typically just a single time index array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Presumably because most basis sets are larger in size than their computational
burden, <code>mgcv</code> passes objects around without including the actual basis
vectors. For example, if using basis <code>cr</code>, the parameters are included in
<code>object</code>, and then the bases re-computed as needed.
</p>
<p>As the <code>slp</code> basis is significantly more computational in nature, the
basis vectors are saved as part of the object. While <code>mgcv</code> deletes
the main set of time-aligned vectors, this routine restores such vectors
so that <code>predict</code> and <code>plot</code> work correctly. 
</p>


<h3>Value</h3>

<p>A corrected (re-assembled) version of <code>object</code>, which contains the 
<code>X</code> basis vectors in a format that can be used by <code>predict</code> or
<code>plot</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>,
<code><a href="mgcv.html#topic+Predict.matrix">Predict.matrix</a></code>
</p>

<hr>
<h2 id='slp-package'>
slp: Discrete Prolate Spheroidal (Slepian) Sequence Regression Smoothers 
</h2><span id='topic+slp-package'></span><span id='topic+slp.package'></span><span id='topic+Slepians'></span>

<h3>Description</h3>

<p>Interface for creation of 'slp' class smoother objects for use in 
Generalized Additive Models as implemented by packages gam and mgcv.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> slp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-08-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wesley Burr, with contributions from Karim Rahim
</p>
<p>Maintainer: Wesley Burr &lt;wesley.burr@gmail.com&gt;
</p>


<h3>References</h3>

<p>Thomson, D.J. (1982) Spectrum estimation and harmonic analysis. 
<em>Proceedings of the IEEE</em> Volume <b>70</b>, number 9, pp. 1055&ndash;1096.
</p>
<p>Thomson, D.J. (2001) Inverse Constrained Projection Filters. 
<em>Proc. SPIE 4478</em>, Wavelets: Applications in Signal and Image Processing IX, 172 
(December 5, 2001); doi:10.1117/12.449708
</p>
<p>Hastie, T. J. (1991)
<em>Generalized additive models.</em>
Chapter 7 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth \&amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990)
<em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood 
and marginal likelihood estimation of semiparametric generalized linear 
models. Journal of the Royal Statistical Society (B) 73(1):3-36
</p>
<p>Wood, S.N. (2004) Stable and efficient multiple smoothing parameter estimation for
generalized additive models. J. Amer. Statist. Ass. 99:673-686. 
</p>
<p>Wood, S.N. (2006) <em>Generalized Additive Models: an introduction with R</em>,
CRC
</p>

<hr>
<h2 id='slp.gam'>Generate a Basis Matrix for Discrete Prolate Spheroidal (Slepian) Sequences</h2><span id='topic+slp.gam'></span><span id='topic+slp'></span>

<h3>Description</h3>

<p>Generate the basis matrix for a particular <code>N, W</code> Slepian sequence
family member, with the additional property that the smoother passes constants
without distortion. Can be quite slow execution due to the latter property.
</p>
<p>Based on <code><a href="splines.html#topic+ns">ns</a></code> for implementation with <code><a href="gam.html#topic+gam">gam</a></code>.
</p>
<p>Parallel implementation for <code>mgcv</code> included in package as
<code><a href="#topic+slp.mgcv">slp.mgcv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slp(x, W = NA, K = NA, deltat = 1, naive = FALSE, intercept = FALSE, 
    customSVD = TRUE, forceC = FALSE, returnS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slp.gam_+3A_x">x</code></td>
<td>
<p>the predictor variable.  Missing values are allowed. Assumed to be contiguous;
if not, then converted to a contiguous series to determine appropriate <code>N</code>,
<code>K</code> and <code>W</code>, then the basis vectors are back-converted at the termination
of the routine. Should be in units of <code>deltat</code>. </p>
</td></tr>
<tr><td><code id="slp.gam_+3A_w">W</code></td>
<td>
<p>the time bandwidth. Computed as the frequency domain analogue of the maximum period of
interest for a time series-regression problem using &ldquo;smooth functions of time&rdquo;. For example,
a period choice of 2 months converts to 60 days and <code>W = 1/60</code> cycles per day. Alternatively,
if the interest is in a period of <code>7</code> cycles per year, then <code>W = 7 / 365.2425 = 0.0192</code>
cycles per day.</p>
</td></tr>
<tr><td><code id="slp.gam_+3A_k">K</code></td>
<td>
<p>the number of basis vectors requested. If not provided, then <code>W</code> must be, and
<code>K</code> is set to approximately <code>floor(2 * N * W - 1)</code>. This parameter is approximately equivalent
to <code>df</code> for <code><a href="splines.html#topic+ns">ns</a></code> with fixed dimension. Note: if you specify <code>K</code> higher
than <code>2 * N * W + 1</code> performance will suffer significantly. The actual number of basis vectors
returned is <code>K-1</code> for the case of <code>intercept = FALSE</code>, and <code>K</code> for <code>intercept = TRUE</code>.</p>
</td></tr>
<tr><td><code id="slp.gam_+3A_deltat">deltat</code></td>
<td>
<p>the time step for the input <code>x</code>. Restricted to <code>1</code> and <code>6</code> days
for ease of logic checking, as these are the most traditional choices. Assumes that 
<code>W</code>  is in the same units, and has no real impact beyond this, so it is trivial to 
make <code>deltat</code> symbolically equal an arbitrary choice and convert <code>W</code> to match.</p>
</td></tr>
<tr><td><code id="slp.gam_+3A_naive">naive</code></td>
<td>
<p>a flag for returning the naive (default) Slepian basis vectors <code>v</code> (<code>TRUE</code>) rather than
the mean-passing SLP2 or SLP3 variants (<code>FALSE</code>). </p>
</td></tr>
<tr><td><code id="slp.gam_+3A_intercept">intercept</code></td>
<td>
<p>a flag for choosing between a SLP2 or SLP3 basis. Type-2 bases capture (absorb) 
means of target series, while Type-3 bases ignore (pass) means. </p>
</td></tr>
<tr><td><code id="slp.gam_+3A_customsvd">customSVD</code></td>
<td>
<p>a flag for using the built-in <code><a href="base.html#topic+svd">svd</a></code> (case <code>FALSE</code>) or a 
modified version of <code>DGESDD</code> LAPACK 3.5.0. The modified version provides significant
speed improvements as it skips a number of unnecessary steps for the particular edge
case needed by <code>slp</code>.</p>
</td></tr>
<tr><td><code id="slp.gam_+3A_forcec">forceC</code></td>
<td>
<p>a flag for forced computation of the basis vectors. Several combinations of commonly
used <code>N, W, K</code> parameters have been pre-computed and included with the package. If this 
parameter is set to <code>TRUE</code>, the routine will compute the basis vectors regardless of whether
they are available in pre-computed form. See <code><a href="#topic+checkSaved">checkSaved</a>{checkSaved}</code> for further details. </p>
</td></tr>
<tr><td><code id="slp.gam_+3A_returns">returnS</code></td>
<td>
<p>a flag for returning the projection matrix <code>S</code> rather than the basis vectors that form the same.
Intended to be used outside of model-fitting environments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slp</code> is based around the routine <code>.dpss</code>, which generates a family of Discrete
Prolate Spheroidal (Slepian) Sequences. These vectors are orthonormal, have alternating
even/odd parity, and form the optimally concentrated basis set for the subspace of 
<code>R^N</code> corresponding to the bandwidth <code>W</code>. Full details are given
in Slepian (1978).  These basis functions have natural boundary conditions, and lack any form of 
knot structure. This version is returned for <code>naive = TRUE</code>.
</p>
<p>The <code>dpss</code> basis vectors can be adapted to provide the additional
useful property of capturing or passing constants perfectly. That is, the smoother matrix
<code>S</code> formed from the returned rectangular matrix will either reproduce constants
at near round-off precision, i.e., <code>S %*% rep(1, N) = rep(1, N)</code>, 
for <code>naive = FALSE</code> with <code>intercept = TRUE</code>, or will pass constants, 
i.e., <code>S %*% rep(1, N) = rep(0, N)</code>, for <code>naive = FALSE</code> with <code>intercept = FALSE</code>. 
</p>
<p>The primary use is in modeling formula to directly specify a Slepian time-based smoothing
term in a model: see the examples.
</p>
<p>For large <code>N</code> this routine can be <b>very</b> slow. If you are computing models with
large <code>N</code>, we highly recommend pre-computing the basis object, then using it
in your models without recomputation. The third example below demonstrates this approach.
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>length(x) * K</code> or <code>length(x) * (K-1)</code> where 
either <code>K</code> was supplied, or <code>W</code> was supplied and <code>K</code> converted. Note that the
basis vectors are computed on a contiguous grid based on <code>x</code>, and then
back-converted to the time structure of <code>x</code>.
</p>
<p>Attributes are returned that correspond to the arguments to <code>ns</code>,
and explicitly give <code>K</code>, <code>W</code>, etc.
</p>


<h3>References</h3>

<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>.
Volume <b>70</b>, number 9, pp. 1055-1096.
</p>
<p>Slepian, David (1978)
Prolate Spheroidal Wave Functions, Fourier Analysis, and Uncertainty V: the Discrete Case.
<em>Bell System Technical Journal</em>. Volume <b>57</b>, pp. 1371-1429.
</p>


<h3>See Also</h3>

<p><code><a href="splines.html#topic+ns">ns</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Examples using pkg:gam
    library("gam")
    library("slp")
    N &lt;- 730
    W &lt;- 14 / N
    K &lt;- 28         # will actually use 27 df when intercept = FALSE
    x &lt;- rnorm(n = N, sd = 1)
    y &lt;- x + rnorm(n = N, sd = 2) + 5.0
    t &lt;- seq(1, N)    

    # note: all three examples share identical results

    # example with in-call computation, using K (df)
    fit1 &lt;- gam(y ~ x + slp(t, K = K, forceC = TRUE), family = gaussian) 

    # example with in-call computation, using W
    fit2 &lt;- gam(y ~ x + slp(t, W = W, forceC = TRUE), family = gaussian)

    # example with out-of-call computation, using K
    timeBasis &lt;- slp(t, K = K, forceC = TRUE)
    fit3 &lt;- gam(y ~ x + timeBasis, family = gaussian)

    # the same computations can be done using pre-computed basis vectors
    # for significant speed-ups, especially for large N - see `checkSaved'
    # for more details
    fit4 &lt;- gam(y ~ x + slp(t, W = W, forceC = FALSE))
</code></pre>

<hr>
<h2 id='slp.mgcv'>Generate a Basis Matrix for Discrete Prolate Spheroidal (Slepian) Sequences</h2><span id='topic+slp.mgcv'></span><span id='topic+smooth.construct.slp.smooth.spec'></span><span id='topic+slp.smooth.spec'></span>

<h3>Description</h3>

<p>Generate the basis matrix for a particular <code>N, W</code> Slepian sequence
family member, with the additional property that the smoother captures/passes constants
without distortion. Can be quite slow in execution due to the latter property.
</p>
<p>Based on <code><a href="mgcv.html#topic+smooth.construct.cr.smooth.spec">smooth.construct.cr.smooth.spec</a></code> for implementation 
with <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slp.smooth.spec'
smooth.construct(object,data,knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slp.mgcv_+3A_object">object</code></td>
<td>
<p>a smooth specification object, usually generated by a model term <code>s(..., bs = 'slp', ..., xt = list(...))</code>,
and for this type, <b>requiring</b> an additional <code>xt = list()</code> object containing parameters.
For examples, see below. </p>
</td></tr>
<tr><td><code id="slp.mgcv_+3A_data">data</code></td>
<td>
<p>a list containing just the data required by this term, with names corresponding to
<code>object[['term']]</code>. Typically just a single time index array.</p>
</td></tr>
<tr><td><code id="slp.mgcv_+3A_knots">knots</code></td>
<td>
<p>a list containing any knots supplied for basis setup &ndash; should be <code>NULL</code>, as
slp basis objects are not generated from knots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slp</code> is based on <code><a href="#topic+.dpss">.dpss</a></code>, which generates a family of Discrete
Prolate Spheroidal (Slepian) Sequences. These vectors are orthonormal, have alternating
even/odd parity, and form the optimally concentrated basis set for the subspace of 
<code>R^N</code> corresponding to the bandwidth <code>W</code>. Full details are given
in Slepian (1978).  These basis functions have natural boundary conditions, and lack any form of 
knot structure. This version is returned for <code>naive = TRUE</code>.
</p>
<p>The <code>dpss</code> basis vectors can be adapted to provide the additional
useful property of capturing or passing constants perfectly. That is, the smoother matrix
<code>S</code> formed from the returned rectangular matrix will either reproduce constants
at near round-off precision, i.e., <code>S %*% rep(1, N) = rep(1, N)</code>, 
for <code>naive = FALSE</code> with <code>intercept = TRUE</code>, or will pass constants, 
i.e., <code>S %*% rep(1, N) = rep(0, N)</code>, for <code>naive = FALSE</code> with <code>intercept = FALSE</code>. 
</p>
<p>The primary use is in modeling formula to directly specify a Slepian time-based smoothing
term in a model: see the examples.
</p>
<p>For large <code>N</code> this routine can be <b>very</b> slow. If you are computing models with
large <code>N</code>, we highly recommend pre-computing the basis object, then using it
in your models without recomputation. The third example below demonstrates this approach.
</p>


<h3>Value</h3>

<p>An object of class <code>slp.smooth</code>. In addition to the usual elements of a smooth
class (see <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>), this object will
contain:
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>a constraint matrix which restricts <code>mgcv</code> from modifying the (already) 
orthogonal and mean-passing/capturing basis vectors. </p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the user-specified number of basis vectors, or the computed <code>K</code> from
user-supplied <code>W</code>.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>the user-specified bandwidth <code>W</code>, or the computed <code>W</code> from
user-supplied <code>K</code>.</p>
</td></tr>
<tr><td><code>fullBasis</code></td>
<td>
<p>the full-span computed, normalized basis set, before contiguity is
taken into account. Used by <code><a href="mgcv.html#topic+Predict.matrix">predict</a></code> 
when given an object of type <code>slp.smooth</code>. </p>
</td></tr>
<tr><td><code>contiguous</code></td>
<td>
<p>a logical variable declaring whether or not the input time array
was considered to be contiguous by the basis computation procedure.</p>
</td></tr>
<tr><td><code>wx</code></td>
<td>
<p>the &ldquo;corrected&rdquo; input time array; if <code>contiguous == FALSE</code> then 
this will be the same as <code>data[object[['term']]]</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with 
R. Chapman and Hall/CRC Press.
</p>
<p>Hastie T.J. &amp; Tibshirani, R.J. (1990) Generalized Additive Models.
Chapman and Hall.
</p>
<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>.
Volume <b>70</b>, number 9, pp. 1055-1096.
</p>
<p>Slepian, David (1978)
Prolate Spheroidal Wave Functions, Fourier Analysis, and Uncertainty V: the Discrete Case.
<em>Bell System Technical Journal</em>. Volume <b>57</b>, pp. 1371-1429.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Examples using pkg:mgcv
    library("mgcv")
    library("slp")

    N &lt;- 730
    W &lt;- 8 / N
    K &lt;- 16         # will actually use 15 df as intercept = FALSE
    x &lt;- rnorm(n = N, sd = 1)
    y &lt;- x + rnorm(n = N, sd = 2) + 5.0
    t &lt;- seq(1, N)    

    # note: all three examples share identical results

    # example with in-call computation, using K (df)
    fit1 &lt;- gam(y ~ x + s(t, bs = 'slp', xt = list(K = K)), family = gaussian) 

    # example with in-call computation, using W
    fit2 &lt;- gam(y ~ x + s(t, bs = 'slp', xt = list(W = W)), family = gaussian)

</code></pre>

<hr>
<h2 id='slpSavedObjects'>slp: Listing of available pre-computed basis sets</h2><span id='topic+slpSavedObjects'></span><span id='topic+slpSavedObject'></span>

<h3>Description</h3>

<p>List of pre-computed basis sets included with the <code>slp</code> package.
For large <code>N</code>, significant speed-ups can be obtained by pre-computing
the basis set and simply loading it from disk. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slpSavedObjects</code></pre>


<h3>Format</h3>

<p>A list containing the <code>N</code>, <code>W</code> (in <code>df/</code>year) and 
<code>K</code> of the pre-computed basis sets. Each combination is included as a
<code>data(...)</code> loadable <code>.RData</code> file.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
