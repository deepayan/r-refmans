<!DOCTYPE html><html><head><title>Help for package conformalbayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {conformalbayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conformalbayes-package'><p>conformalbayes: Jackknife(+) Predictive Intervals for Bayesian Models</p></a></li>
<li><a href='#loo_conformal'><p>Enable leave-one-out conformal predictive intervals for a fit model</p></a></li>
<li><a href='#predictive_interval.conformal'><p>Jackknife(+) predictive intervals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Jackknife(+) Predictive Intervals for Bayesian Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to construct finite-sample calibrated predictive 
    intervals for Bayesian models, following the approach in Barber et al. 
    (2021) &lt;<a href="https://doi.org/10.1214%2F20-AOS1965">doi:10.1214/20-AOS1965</a>&gt;. These intervals are calculated efficiently
    using importance sampling for the leave-one-out residuals. By default,
    the intervals will also reflect the relative uncertainty in the Bayesian 
    model, using the locally-weighted conformal methods of Lei et al. (2018)
    &lt;<a href="https://doi.org/10.1080%2F01621459.2017.1307116">doi:10.1080/01621459.2017.1307116</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, rstantools, loo, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rstanarm, brms, testthat (&ge; 3.0.0), ggplot2, knitr,
rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CoryMcCartan/conformalbayes">https://github.com/CoryMcCartan/conformalbayes</a>,
<a href="https://corymccartan.com/conformalbayes/">https://corymccartan.com/conformalbayes/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CoryMcCartan/conformalbayes/issues">https://github.com/CoryMcCartan/conformalbayes/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-12 07:55:01 UTC; cmccartan</td>
</tr>
<tr>
<td>Author:</td>
<td>Cory McCartan <a href="https://orcid.org/0000-0002-6251-669X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cory McCartan &lt;cmccartan@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-12 08:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='conformalbayes-package'>conformalbayes: Jackknife(+) Predictive Intervals for Bayesian Models</h2><span id='topic+conformalbayes'></span><span id='topic+conformalbayes-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides functions to construct finite-sample calibrated predictive intervals for Bayesian models, following the approach in Barber et al. (2021) <a href="https://doi.org/10.1214/20-AOS1965">doi:10.1214/20-AOS1965</a>. These intervals are calculated efficiently using importance sampling for the leave-one-out residuals. By default, the intervals will also reflect the relative uncertainty in the Bayesian model, using the locally-weighted conformal methods of Lei et al. (2018) <a href="https://doi.org/10.1080/01621459.2017.1307116">doi:10.1080/01621459.2017.1307116</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Cory McCartan <a href="mailto:cmccartan@g.harvard.edu">cmccartan@g.harvard.edu</a> (<a href="https://orcid.org/0000-0002-6251-669X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/CoryMcCartan/conformalbayes">https://github.com/CoryMcCartan/conformalbayes</a>
</p>
</li>
<li> <p><a href="https://corymccartan.com/conformalbayes/">https://corymccartan.com/conformalbayes/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/CoryMcCartan/conformalbayes/issues">https://github.com/CoryMcCartan/conformalbayes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='loo_conformal'>Enable leave-one-out conformal predictive intervals for a fit model</h2><span id='topic+loo_conformal'></span><span id='topic+loo_conformal.default'></span><span id='topic+loo_conformal.stanreg'></span><span id='topic+loo_conformal.brmsfit'></span>

<h3>Description</h3>

<p>Prepares for jackknife(+) conformal prediction by performing Pareto-smoothed
importance sampling to yield leave-one-out residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo_conformal(fit, ...)

## Default S3 method:
loo_conformal(fit, truth, chain = NULL, est_fun = c("mean", "median"), ...)

## S3 method for class 'stanreg'
loo_conformal(fit, est_fun = c("mean", "median"), ...)

## S3 method for class 'brmsfit'
loo_conformal(fit, est_fun = c("mean", "median"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_conformal_+3A_fit">fit</code></td>
<td>
<p>Model fit; an object with <code>posterior_predict()</code> and <code>log_lik()</code>
methods. Can also be an <code>array</code> of posterior predictions.</p>
</td></tr>
<tr><td><code id="loo_conformal_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="loo_conformal_+3A_truth">truth</code></td>
<td>
<p>True values to predict. Not required for <code>rstanarm</code> or <code>brms</code>
models.</p>
</td></tr>
<tr><td><code id="loo_conformal_+3A_chain">chain</code></td>
<td>
<p>An integer vector identifying the chain numbers for the
posterior draws. Should be provided if multiple chains are used.</p>
</td></tr>
<tr><td><code id="loo_conformal_+3A_est_fun">est_fun</code></td>
<td>
<p>Whether to use the posterior <code>mean</code> (the default) or <code>median</code>
as a point estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>fit</code> object with an additional class <code>conformal</code>.
Calling <code>predictive_interval()</code> on this new object will yield conformal
intervals.
</p>


<h3>References</h3>

<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., &amp; Gabry, J. (2015).
Pareto smoothed importance sampling. <a href="https://arxiv.org/abs/1507.02646">arXiv preprint arXiv:1507.02646</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("rstanarm", quietly=TRUE)) suppressWarnings({
    library(rstanarm)
    # fit a simple linear regression
    m = stan_glm(mpg ~ disp + cyl, data=mtcars,
        chains=1, iter=1000,
        control=list(adapt_delta=0.999), refresh=0)

    loo_conformal(m)
})

</code></pre>

<hr>
<h2 id='predictive_interval.conformal'>Jackknife(+) predictive intervals</h2><span id='topic+predictive_interval.conformal'></span>

<h3>Description</h3>

<p>Construct finite-sample calibrated predictive intervals for Bayesian models,
following the approach in Barber et al. (2021). By default, the intervals will also reflect the
relative uncertainty in the Bayesian model, using the locally-weighted
conformal methods of Lei et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conformal'
predictive_interval(object, probs = 0.9, plus = NULL, local = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_interval.conformal_+3A_object">object</code></td>
<td>
<p>A fitted model which has been passed through <code><a href="#topic+loo_conformal">loo_conformal()</a></code></p>
</td></tr>
<tr><td><code id="predictive_interval.conformal_+3A_probs">probs</code></td>
<td>
<p>The coverage probabilities to calculate intervals for.
Empirically, the coverage rate of the constructed intervals will generally
match these probabilities, but the theoretical guarantee for a probability
of <code class="reqn">1-\alpha</code> is only for coverage of at least <code class="reqn">1-2\alpha</code>, and
only if <code>plus=TRUE</code> (below).</p>
</td></tr>
<tr><td><code id="predictive_interval.conformal_+3A_plus">plus</code></td>
<td>
<p>If <code>TRUE</code>, construct jackknife+ intervals, which have a
theoretical guarantee. These require higher computational costs, which
scale with both the number of training and prediction points. Defaults to
<code>TRUE</code> when both of these numbers are less than 500.</p>
</td></tr>
<tr><td><code id="predictive_interval.conformal_+3A_local">local</code></td>
<td>
<p>If <code>TRUE</code> (the default), perform locally-weighted conformal
inference. This will inflate the width of the predictive intervals by a
constant amount across all predictions, preserving the relative amount of
uncertainty captured by the model. If <code>FALSE</code>, all predictive intervals
will have (nearly) the same width.</p>
</td></tr>
<tr><td><code id="predictive_interval.conformal_+3A_...">...</code></td>
<td>
<p>Further arguments to the <code>posterior_predict()</code> method for <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the number of rows matching the number of predictions.
Columns will be labeled with a percentile corresponding to <code>probs</code>; e.g. if
<code>probs=0.9</code> the columns will be <code style="white-space: pre;">&#8288;5%&#8288;</code> and <code style="white-space: pre;">&#8288;95%&#8288;</code>.
</p>


<h3>References</h3>

<p>Barber, R. F., Candes, E. J., Ramdas, A., &amp; Tibshirani, R. J. (2021).
Predictive inference with the jackknife+. <em>The Annals of Statistics, 49</em>(1),
486-507.
</p>
<p>Lei, J., G’Sell, M., Rinaldo, A., Tibshirani, R. J., &amp; Wasserman, L. (2018).
Distribution-free predictive inference for regression. <em>Journal of the
American Statistical Association, 113</em>(523), 1094-1111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("rstanarm", quietly=TRUE)) suppressWarnings({
    library(rstanarm)
    # fit a simple linear regression
    m = stan_glm(mpg ~ disp + cyl, data=mtcars,
        chains=1, iter=1000,
        control=list(adapt_delta=0.999), refresh=0)

    m = loo_conformal(m)
    # make predictive intervals
    predictive_interval(m)
})

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
