<!DOCTYPE html><html lang="en"><head><title>Help for package qslice</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qslice}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auc'><p>Area Under the Curve (histogram)</p></a></li>
<li><a href='#imh_pseudo'><p>Independence Metropolis-Hastings</p></a></li>
<li><a href='#lapprox'><p>Pseudo-target from Laplace Approximation</p></a></li>
<li><a href='#pseudo_condseq'><p>Sequence of conditional pseudo-targets from a realization</p></a></li>
<li><a href='#pseudo_condseq_XfromU'><p>Inverse transform from sequence of conditional pseudo-targets</p></a></li>
<li><a href='#pseudo_list'><p>Specify a pseudo-target within a given class</p></a></li>
<li><a href='#pseudo_opt'><p>Optimal pseudo-target for a given target</p></a></li>
<li><a href='#slice_elliptical'><p>Univariate Elliptical Slice Sampler</p></a></li>
<li><a href='#slice_elliptical_mv'><p>Multivariate Elliptical Slice Sampler</p></a></li>
<li><a href='#slice_genelliptical'><p>Generalized Elliptical Slice Sampler (univariate)</p></a></li>
<li><a href='#slice_genelliptical_mv'><p>Generalized Elliptical Slice Sampler (Multivariate)</p></a></li>
<li><a href='#slice_hyperrect'><p>Multivariate Slice Sampler with Shrinking Hyperrectangle</p></a></li>
<li><a href='#slice_latent'><p>Latent Slice Sampler</p></a></li>
<li><a href='#slice_quantile'><p>Quantile Slice Sampler</p></a></li>
<li><a href='#slice_quantile_mv'><p>Multivariate Quantile Slice Sampler</p></a></li>
<li><a href='#slice_quantile_mv_seq'><p>Multivariate Quantile Slice Sampler from a sequence of conditional pseudo-targets</p></a></li>
<li><a href='#slice_stepping_out'><p>Slice sampler using the Stepping Out and Shrinkage Procedures</p></a></li>
<li><a href='#utility_pseudo'><p>Utility for a given target and pseudo-target</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Implementations of Various Slice Samplers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of the quantile slice sampler of Heiner et al. (2024+, in preparation) as well as other popular slice samplers are provided. 
    Helper functions for specifying pseudo-target distributions are included, both for diagnostics and for tuning the quantile slice sampler. 
    Other implemented methods include the generalized elliptical slice sampler of Nishihara et al. (2014)&lt;https://jmlr.org/papers/v15/nishihara14a.html},
    latent slice sampler of Li and Walker (2023)&lt;<a href="https://doi.org/10.1016%2Fj.csda.2022.107652">doi:10.1016/j.csda.2022.107652</a>&gt;, and stepping-out slice sampler of Neal (2003)&lt;<a href="https://doi.org/10.1214%2Faos%2F1056562461">doi:10.1214/aos/1056562461</a>&gt;,
    and independence Metropolis-Hastings sampler.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-29 22:50:32 UTC; dahl</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Heiner <a href="https://orcid.org/0000-0002-7944-5517"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  David B. Dahl <a href="https://orcid.org/0000-0002-8173-1547"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sam Johnson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David B. Dahl &lt;dahl@stat.byu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-30 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auc'>Area Under the Curve (histogram)</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>Calculate the histogram approximation to the area under the curve after restricting
the curve to fit within the unit square. Specifically, the highest histogram bar reaches 1 and
the support is the unit interval. See Heiner et al. (2024+).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(u = NULL, x = NULL, y = NULL, nbins = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auc_+3A_u">u</code></td>
<td>
<p>Numeric vector of samples supported on unit interval with which to
create a histogram (use <code>u = NULL</code> if <code>x</code> and <code>y</code> are supplied).</p>
</td></tr>
<tr><td><code id="auc_+3A_x">x</code></td>
<td>
<p>Numeric vector of histogram locations. (Not used if <code>u</code> is supplied).</p>
</td></tr>
<tr><td><code id="auc_+3A_y">y</code></td>
<td>
<p>Numeric vector of histogram heights OR function evaluating the curve
for a given value of <code>u</code> supported on (0,1). (Not used if <code>u</code> is supplied).</p>
</td></tr>
<tr><td><code id="auc_+3A_nbins">nbins</code></td>
<td>
<p>Number of histogram bins to use (defaults to 30).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepts either samples <code>u</code> or a function <code>y</code> representing a (possibly
unnormalized) probability density supported on the unit interval.
</p>


<h3>Value</h3>

<p>The (approximate) area under the curve as a numeric value of length one.
</p>


<h3>References</h3>

<p>Heiner, M. J., Johnson, S. B., Christensen, J. R., and Dahl, D. B. (2024+), &quot;Quantile Slice Sampling,&quot; <em>arXiv preprint arXiv:###</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u_samples &lt;- rbeta(10e3, 2, 2)
auc(u = u_samples)
auc(u = u_samples, nbins = 50)
auc(y = function(x) {dbeta(x, 2, 2)}, nbins = 30)
auc(y = function(x) {dbeta(x, 2, 2)}, nbins = 300)
xx &lt;- seq(0.001, 0.999, length = 1000)
auc(x = xx, y = function(x) {dbeta(x, 2, 2)})
auc(x = xx, y = dbeta(xx, 2, 2))
</code></pre>

<hr>
<h2 id='imh_pseudo'>Independence Metropolis-Hastings</h2><span id='topic+imh_pseudo'></span>

<h3>Description</h3>

<p>Independence Metropolis-Hastings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imh_pseudo(x, log_target, pseudo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imh_pseudo_+3A_x">x</code></td>
<td>
<p>The current state (scalar or numeric vector).</p>
</td></tr>
<tr><td><code id="imh_pseudo_+3A_log_target">log_target</code></td>
<td>
<p>A function taking a scalar or numeric vector that evaluates the log-target
density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="imh_pseudo_+3A_pseudo">pseudo</code></td>
<td>
<p>List specifying the pseudo-target (proposal distribution). If the list length is
equal to the number of dimensions in <code>x</code>, each element is itself a list that specifies
the pseudo-target for the corresponding dimension with functions <code>ld</code>
that evaluates the log density for that dimension,
and <code>q</code> that evaluates the quantile (inverse-CDF) function for that dimension.
If the dimension of <code>x</code> is one, then supply only the inner list
specifying the single pseudo-target.
</p>
<p>If <code>x</code> is a vector but a single pseudo-target is supplied, the list must
contain a log-density function <code>ld</code> that accepts a vector, and a <code>r</code>
function that takes no arguments and generates a single multivariate draw from the
proposal distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the new state, <code>x</code>, and whether the proposed value was accepted, logical <code>accpt</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x[1], 3, 4, log = TRUE) + dbeta(x[2], 5, 3, log = TRUE)
n_iter &lt;- 100 # set to 1e3 for more complete illustration
draws &lt;- matrix(0.2, nrow = n_iter, ncol = 2)
nAccpt &lt;- 0L
pseudo &lt;- list( list(ld = function(x) dbeta(x, 2, 2, log = TRUE),
                     q = function(u) qbeta(u, 2, 2)),
                list(ld = function(x) dbeta(x, 2, 2, log = TRUE),
                     q = function(u) qbeta(u, 2, 2))
)
for (i in seq.int(2, n_iter)) {
 out &lt;- imh_pseudo(draws[i - 1, ], log_target = lf, pseudo = pseudo)
 draws[i,] &lt;- out$x
 nAccpt &lt;- nAccpt + out$accpt
 cat(i, '\r')
}
nAccpt / (nrow(draws) - 1)
plot(draws[,1], draws[,2], xlim = c(0, 1))
hist(draws[,1], freq = FALSE); curve(dbeta(x, 3, 4), col = "blue", add = TRUE)
hist(draws[,2], freq = FALSE); curve(dbeta(x, 5, 3), col = "blue", add = TRUE)
</code></pre>

<hr>
<h2 id='lapprox'>Pseudo-target from Laplace Approximation</h2><span id='topic+lapprox'></span>

<h3>Description</h3>

<p>Find the location and scale for an approximating pseudo-target via Laplace
approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapprox(
  log_target,
  init,
  family = "t",
  params = NULL,
  sc_adj = 1,
  lb = -Inf,
  ub = Inf,
  maxit = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lapprox_+3A_log_target">log_target</code></td>
<td>
<p>Univariate function evaluating the unnormalized log density to approximate.</p>
</td></tr>
<tr><td><code id="lapprox_+3A_init">init</code></td>
<td>
<p>Numeric scalar for an initial value (used in optimization).</p>
</td></tr>
<tr><td><code id="lapprox_+3A_family">family</code></td>
<td>
<p>String specifying the family of distributions for the pseudo-target.
Can be any of the families accepted by <a href="#topic+pseudo_list">pseudo_list</a>.</p>
</td></tr>
<tr><td><code id="lapprox_+3A_params">params</code></td>
<td>
<p>List specifying the parameters for the pseudo-target to be used.
The location and scale parameters will be replaced with the Laplace approximation and
others (e.g., degrees of freedom) will be retained.</p>
</td></tr>
<tr><td><code id="lapprox_+3A_sc_adj">sc_adj</code></td>
<td>
<p>Positive numeric scalar; manual multiplicative adjustment to the
scale of the output pseudo-target.</p>
</td></tr>
<tr><td><code id="lapprox_+3A_lb">lb</code></td>
<td>
<p>Numeric scalar giving the value of left truncation of the resulting pseudo-target.
Defaults to <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="lapprox_+3A_ub">ub</code></td>
<td>
<p>Numeric scalar giving the value of right truncation of the resulting pseudo-target.
Defaults to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="lapprox_+3A_maxit">maxit</code></td>
<td>
<p>See <a href="stats.html#topic+optim">optim</a>.</p>
</td></tr>
<tr><td><code id="lapprox_+3A_...">...</code></td>
<td>
<p>See <a href="stats.html#topic+optim">optim</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same outputs as <a href="#topic+pseudo_list">pseudo_list</a>; also includes
<code>opt</code>, which gives output of <a href="stats.html#topic+optim">optim</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pseu &lt;- lapprox(function(x) dnorm(x, log = TRUE),
  family = "t",
  params = list(loc = NA, sc = NA, degf = 5.0),
  init = 0.5, lb = -1.0)
curve(dnorm(x)/(1- pnorm(-1)), from = -1, to = 6, col = "blue")
xx &lt;- seq(-1, 6, length = 500)
lines(xx, sapply(xx, FUN = pseu$d))
</code></pre>

<hr>
<h2 id='pseudo_condseq'>Sequence of conditional pseudo-targets from a realization</h2><span id='topic+pseudo_condseq'></span>

<h3>Description</h3>

<p>Given a realization of a random vector, generate a the corresponding
sequence of conditional pseudo-target inverse CDFs (Heiner et al., 2024+).
The pseudo-target is specified as
a sequence of growing conditional distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_condseq(x, pseudo_init, loc_fn, sc_fn, lb, ub)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudo_condseq_+3A_x">x</code></td>
<td>
<p>A numeric vector of values between 0 and 1.</p>
</td></tr>
<tr><td><code id="pseudo_condseq_+3A_pseudo_init">pseudo_init</code></td>
<td>
<p>A list output from <a href="#topic+pseudo_list">pseudo_list</a> describing the
marginal pseudo-target for <code>x[1]</code>. All subsequent pseudo-targets will
resemble <code>pseudo_init</code> with exception of different location and scale parameters.</p>
</td></tr>
<tr><td><code id="pseudo_condseq_+3A_loc_fn">loc_fn</code></td>
<td>
<p>A function that specifies the location of a conditional
pseudo-target given the elements in <code>x</code> that precede it.</p>
</td></tr>
<tr><td><code id="pseudo_condseq_+3A_sc_fn">sc_fn</code></td>
<td>
<p>A function that specifies the scale of a conditional
pseudo-target given the elements in <code>x</code> that precede it</p>
</td></tr>
<tr><td><code id="pseudo_condseq_+3A_lb">lb</code></td>
<td>
<p>A numeric vector (same length as <code>x</code>) specifying the lower
bound of support for each conditional pseudo-target.</p>
</td></tr>
<tr><td><code id="pseudo_condseq_+3A_ub">ub</code></td>
<td>
<p>A numeric vector (same length as <code>x</code>) specifying the upper
bound of support for each conditional pseudo-target.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation for <a href="#topic+slice_quantile_mv_seq">slice_quantile_mv_seq</a> for examples.
</p>


<h3>Value</h3>

<p>A list containing a sequence of pseudo-targets, each from <a href="#topic+pseudo_list">pseudo_list</a>.
</p>


<h3>References</h3>

<p>Heiner, M. J., Johnson, S. B., Christensen, J. R., and Dahl, D. B. (2024+), &quot;Quantile Slice Sampling,&quot; <em>arXiv preprint arXiv:###</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Funnel distribution from Neal (2003).
K &lt;- 10
n_iter &lt;- 50 # MCMC iterations; set to 10e3 for more complete illustration
n &lt;- 100 # number of iid samples from the target; set to 10e3 for more complete illustration
Y &lt;- matrix(NA, nrow = n, ncol = K) # iid samples from the target
Y[,1] &lt;- rnorm(n, 0.0, 3.0)
for (i in 1:n) {
  Y[i, 2:K] &lt;- rnorm(K-1, 0.0, exp(0.5*Y[i,1]))
}
ltarget &lt;- function(x) {
dnorm(x[1], 0.0, 3.0, log = TRUE) +
  sum(dnorm(x[2:K], 0.0, exp(0.5*x[1]), log = TRUE))
}
pseudo_control &lt;- list(
  loc_fn = function(x) {
    0.0
  },
  sc_fn = function(x) {
    if (is.null(x)) {
      out &lt;- 3.0
    } else {
      out &lt;- exp(0.5*x[1])
    }
    out
  },
  pseudo_init = pseudo_list(family = "t",
                            params = list(loc = 0.0, sc = 3.0, degf = 20),
                            lb = -Inf, ub = Inf),
  lb = rep(-Inf, K),
  ub = rep(Inf, K)
)
x0 &lt;- runif(K)
draws &lt;- matrix(rep(x0, n_iter + 1), nrow = n_iter + 1, byrow = TRUE)
draws_u &lt;- matrix(rep(x0, n_iter), nrow = n_iter, byrow = TRUE)
n_eval &lt;- 0
for (i in 2:(n_iter + 1)) {
  tmp &lt;- slice_quantile_mv_seq(draws[i-1,],
                                log_target = ltarget,
                                pseudo_control = pseudo_control)
  draws[i,] &lt;- tmp$x
  draws_u[i-1,] &lt;- tmp$u
  n_eval &lt;- n_eval + tmp$nEvaluations
}
# (es &lt;- coda::effectiveSize(coda::as.mcmc(draws)))
# mean(es)
n_eval / n_iter
sapply(1:K, function (k) auc(u = draws_u[,k]))
hist(draws_u[,1])
plot(draws[,1], draws[,2])
points(Y[,1], Y[,2], col = "blue", cex = 0.5)
</code></pre>

<hr>
<h2 id='pseudo_condseq_XfromU'>Inverse transform from sequence of conditional pseudo-targets</h2><span id='topic+pseudo_condseq_XfromU'></span>

<h3>Description</h3>

<p>Given a vector of from a unit hypercube, map to the original (back-transformed)
vector using a sequence of conditional pseudo-target inverse CDFs.
The pseudo-target is specified as
a sequence of growing conditional distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_condseq_XfromU(u, pseudo_init, loc_fn, sc_fn, lb, ub)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudo_condseq_XfromU_+3A_u">u</code></td>
<td>
<p>A numeric vector of values between 0 and 1.</p>
</td></tr>
<tr><td><code id="pseudo_condseq_XfromU_+3A_pseudo_init">pseudo_init</code></td>
<td>
<p>A list output from <a href="#topic+pseudo_list">pseudo_list</a> describing the
marginal pseudo-target for <code>x[1]</code>.</p>
</td></tr>
<tr><td><code id="pseudo_condseq_XfromU_+3A_loc_fn">loc_fn</code></td>
<td>
<p>A function that specifies the location of a conditional
pseudo-target given the elements in <code>x</code> that precede it.</p>
</td></tr>
<tr><td><code id="pseudo_condseq_XfromU_+3A_sc_fn">sc_fn</code></td>
<td>
<p>A function that specifies the scale of a conditional
pseudo-target given the elements in <code>x</code> that precede it</p>
</td></tr>
<tr><td><code id="pseudo_condseq_XfromU_+3A_lb">lb</code></td>
<td>
<p>A numeric vector (same length as <code>x</code>) specifying the lower
bound of support for each conditional pseudo-target.</p>
</td></tr>
<tr><td><code id="pseudo_condseq_XfromU_+3A_ub">ub</code></td>
<td>
<p>A numeric vector (same length as <code>x</code>) specifying the upper
bound of support for each conditional pseudo-target.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation for <a href="#topic+slice_quantile_mv_seq">slice_quantile_mv_seq</a> for examples.
</p>


<h3>Value</h3>

<p>A list containing <code>x</code> obtained from the sequence of inverse
CDFs, and <code>pseudo_seq</code>, a list of the corresponding sequential
pseudo-targets output from <a href="#topic+pseudo_list">pseudo_list</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Funnel distribution from Neal (2003).
K &lt;- 10
n_iter &lt;- 50 # MCMC iterations; set to 10e3 for more complete illustration
n &lt;- 100 # number of iid samples from the target; set to 10e3 for more complete illustration
Y &lt;- matrix(NA, nrow = n, ncol = K) # iid samples from the target
Y[,1] &lt;- rnorm(n, 0.0, 3.0)
for (i in 1:n) {
  Y[i, 2:K] &lt;- rnorm(K-1, 0.0, exp(0.5*Y[i,1]))
}
ltarget &lt;- function(x) {
dnorm(x[1], 0.0, 3.0, log = TRUE) +
  sum(dnorm(x[2:K], 0.0, exp(0.5*x[1]), log = TRUE))
}
pseudo_control &lt;- list(
  loc_fn = function(x) {
    0.0
  },
  sc_fn = function(x) {
    if (is.null(x)) {
      out &lt;- 3.0
    } else {
      out &lt;- exp(0.5*x[1])
    }
    out
  },
  pseudo_init = pseudo_list(family = "t",
                            params = list(loc = 0.0, sc = 3.0, degf = 20),
                            lb = -Inf, ub = Inf),
  lb = rep(-Inf, K),
  ub = rep(Inf, K)
)
x0 &lt;- runif(K)
draws &lt;- matrix(rep(x0, n_iter + 1), nrow = n_iter + 1, byrow = TRUE)
draws_u &lt;- matrix(rep(x0, n_iter), nrow = n_iter, byrow = TRUE)
n_eval &lt;- 0
for (i in 2:(n_iter + 1)) {
  tmp &lt;- slice_quantile_mv_seq(draws[i-1,],
                                log_target = ltarget,
                                pseudo_control = pseudo_control)
  draws[i,] &lt;- tmp$x
  draws_u[i-1,] &lt;- tmp$u
  n_eval &lt;- n_eval + tmp$nEvaluations
}
# (es &lt;- coda::effectiveSize(coda::as.mcmc(draws)))
# mean(es)
n_eval / n_iter
sapply(1:K, function (k) auc(u = draws_u[,k]))
hist(draws_u[,1])
plot(draws[,1], draws[,2])
points(Y[,1], Y[,2], col = "blue", cex = 0.5)
</code></pre>

<hr>
<h2 id='pseudo_list'>Specify a pseudo-target within a given class</h2><span id='topic+pseudo_list'></span>

<h3>Description</h3>

<p>Create a list of functions to evaluate a pseudo-target in a given class
with supplied parameters (usually location and scale). The distribution is optionally
truncated to specified bounds (and renormalized). See Heiner et al. (2024+).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_list(family, params, lb = -Inf, ub = Inf, log_p = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudo_list_+3A_family">family</code></td>
<td>
<p>String identifying the distribution family. One of <code>t</code>, <code>cauchy</code>,
<code>normal</code>, <code>logistic</code>, and <code>beta</code>.</p>
</td></tr>
<tr><td><code id="pseudo_list_+3A_params">params</code></td>
<td>
<p>Named list identifying parameters, which vary by distribution family.
</p>
<p><code>t</code>: location <code>loc</code>, scale <code>sc</code>, and degrees of freedom <code>degf</code>
</p>
<p><code>cauchy</code>: location <code>loc</code> and scale <code>sc</code>
</p>
<p><code>norm</code>: location <code>loc</code> and scale <code>sc</code>
</p>
<p><code>logistic</code>: location <code>loc</code> and scale <code>sc</code>
</p>
<p><code>beta</code>: scale <code>scale1</code> and scale <code>scale2</code></p>
</td></tr>
<tr><td><code id="pseudo_list_+3A_lb">lb</code></td>
<td>
<p>Numeric scalar giving the value of left truncation. Defaults to <code>-Inf</code>. Not operative in family <code>beta</code>.</p>
</td></tr>
<tr><td><code id="pseudo_list_+3A_ub">ub</code></td>
<td>
<p>Numeric scalar giving the value of right truncation. Defaults to <code>Inf</code>. Not operative in family <code>beta</code>.</p>
</td></tr>
<tr><td><code id="pseudo_list_+3A_log_p">log_p</code></td>
<td>
<p>(Not implemented) Logical: evaluate distribution and quantile functions using the log probability.</p>
</td></tr>
<tr><td><code id="pseudo_list_+3A_name">name</code></td>
<td>
<p>String appending optional message to the textual name of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supported classes of pseudo-targets include: <code>t</code>, <code>cauchy</code>,
<code>normal</code>, <code>logistic</code>, and <code>beta</code>.
</p>


<h3>Value</h3>

<p>A list with named components:
</p>
<p><code>d</code>: function to evaluate the density
</p>
<p><code>ld</code>: function to evaluate the log density
</p>
<p><code>q</code>: function to evaluate the quantile function
</p>
<p><code>p</code>: function to evaluate the distribution function
</p>
<p><code>txt</code>: text description of the distribution
</p>
<p><code>params</code>: repeats the <code>params</code> argument
</p>
<p><code>lb</code>: lower boundary of support
</p>
<p><code>ub</code>: upper boundary of support
</p>


<h3>References</h3>

<p>Heiner, M. J., Johnson, S. B., Christensen, J. R., and Dahl, D. B. (2024+), &quot;Quantile Slice Sampling,&quot; <em>arXiv preprint arXiv:###</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pseu &lt;- pseudo_list(family = "t", params = list(loc = 0.0, sc = 1.0, degf = 5),
                    lb = 0.0, ub = Inf) # half t
str(pseu)
pseu$d(1.5)
pseu$ld(1.5)
pseu$p(1.5)
pseu$q(0.8060963)
pseu &lt;- pseudo_list(family = "cauchy", params = list(loc = 0.0, sc = 1.0),
                    lb = 0.0, ub = Inf) # half Cauchy
str(pseu)
pseu$d(1.5)
pseu$ld(1.5)
pseu$p(1.5)
pseu$q(0.6256659)
pseu &lt;- pseudo_list(family = "normal", params = list(loc = 0.0, sc = 1.0),
                    lb = 0.0, ub = Inf) # half normal
str(pseu)
pseu$d(1.5)
pseu$ld(1.5)
pseu$p(1.5)
pseu$q(0.8663856)
pseu &lt;- pseudo_list(family = "logistic", params = list(loc = 0.0, sc = 1.0),
                    lb = 0.0, ub = Inf) # half logistic
str(pseu)
pseu$d(1.5)
pseu$ld(1.5)
pseu$p(1.5)
pseu$q(0.635149)
pseu &lt;- pseudo_list(family = "beta", params = list(shape1 = 2.0, shape2 = 1.0))
str(pseu)
pseu$d(0.5)
pseu$ld(0.5)
pseu$p(0.5)
pseu$q(0.25)
</code></pre>

<hr>
<h2 id='pseudo_opt'>Optimal pseudo-target for a given target</h2><span id='topic+pseudo_opt'></span>

<h3>Description</h3>

<p>Find an optimal pseudo-target in a specified family to approximate
the given (unnormalized) target (Heiner et al., 2024+). Optimize over the selected utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_opt(
  log_target = NULL,
  samples = NULL,
  type = "samples",
  family = "t",
  degf = c(1, 5, 20),
  lb = -Inf,
  ub = Inf,
  utility_type = "AUC",
  nbins = 100,
  tol_opt = 1e-06,
  tol_int = 0.001,
  plot = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudo_opt_+3A_log_target">log_target</code></td>
<td>
<p>Function to evaluate the log density of the unnormalized target.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_samples">samples</code></td>
<td>
<p>Optional numeric vector providing samples from the target distribution
(for use as alternative to <code>log_target</code>).</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_type">type</code></td>
<td>
<p>String specifying the input type. One of &quot;function&quot;, &quot;samples&quot;, or &quot;grid&quot;.
Default is to use &quot;samples&quot;.
</p>
<p>Use of &quot;function&quot; requires specification of <code>log_target</code>.
</p>
<p>Use of &quot;samples&quot; requires specification of <code>samples</code>.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_family">family</code></td>
<td>
<p>String specifying the family of distributions for the pseudo-target.
Can be any of the families accepted by <a href="#topic+pseudo_list">pseudo_list</a>.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_degf">degf</code></td>
<td>
<p>Numeric vector of degrees of freedom values to try (only if <code>family = "t"</code>.
Defaults to <code>c(1, 5, 20)</code>.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_lb">lb</code></td>
<td>
<p>Numeric scalar giving the value of left truncation. Defaults to <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_ub">ub</code></td>
<td>
<p>Numeric scalar giving the value of right truncation. Defaults to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_utility_type">utility_type</code></td>
<td>
<p>String identifying utility type, either AUC (default) or MSW.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_nbins">nbins</code></td>
<td>
<p>Positive integer specifying the number of histogram bins if using &quot;samples&quot; or &quot;grid&quot;.
Defaults to 100.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_tol_opt">tol_opt</code></td>
<td>
<p>Positive numeric scalar that passes to <code>reltol</code> in the call
to <a href="stats.html#topic+optim">optim</a>. Defaults to <code>1.0e-6</code>.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_tol_int">tol_int</code></td>
<td>
<p>Positive numeric scalar that passes to <code>abs.tol</code> in the call to <a href="stats.html#topic+integrate">integrate</a>.
Defaults to <code>1.0e-3</code>.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_plot">plot</code></td>
<td>
<p>Logical for whether to generate two plots:
</p>

<ol>
<li><p> direct comparison of the target and pseudo-target densities, and
</p>
</li>
<li><p> transformed target density.
</p>
</li></ol>

<p>Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pseudo_opt_+3A_verbose">verbose</code></td>
<td>
<p>Logical for whether to print intermediate steps of optimization.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optionally supply samples from the target distribution.
</p>


<h3>Value</h3>

<p>A list with named components:
</p>
<p><code>pseudo</code>: a list with functions corresponding to the selected pseudo-target;
output of <a href="#topic+pseudo_list">pseudo_list</a>.
</p>
<p><code>utility</code>: value of the utility function using the selected pseudo-target;
output of <a href="#topic+utility_pseudo">utility_pseudo</a>.
</p>
<p><code>utility_type</code>: repeats the input specifying the utility type.
</p>
<p><code>opt</code>: output of <a href="stats.html#topic+optim">optim</a>.
</p>
<p>Other outputs repeating inputs.
</p>


<h3>References</h3>

<p>Heiner, M. J., Johnson, S. B., Christensen, J. R., and Dahl, D. B. (2024+), &quot;Quantile Slice Sampling,&quot; <em>arXiv preprint arXiv:###</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(pseu &lt;- pseudo_opt(samples = rnorm(1e3), type = "samples",
               family = "t", utility_type = "AUC",
               nbins = 10, plot = TRUE,
               verbose = FALSE))
oldpar &lt;- par(mfrow = c(1,2))
(pseu &lt;- pseudo_opt(log_target = function(x) dnorm(x, log = TRUE),
                type = "function",
                family = "logistic", utility_type = "AUC",
                nbins = 100, plot = TRUE,
                verbose = FALSE))
(pseu &lt;- pseudo_opt(log_target = function(x) dbeta(x, 4, 2, log = TRUE),
                lb = 0, ub = 1,
                type = "function",
                family = "cauchy", utility_type = "AUC",
                nbins = 30, plot = TRUE,
                verbose = FALSE))
par(oldpar)

</code></pre>

<hr>
<h2 id='slice_elliptical'>Univariate Elliptical Slice Sampler</h2><span id='topic+slice_elliptical'></span>

<h3>Description</h3>

<p>Algorithm 1 of Nishihara et al. (2014) of the
elliptical slice sampler of Murray et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_elliptical(x, log_target, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_elliptical_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric scalar).</p>
</td></tr>
<tr><td><code id="slice_elliptical_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric scalar that evaluates the
(potentially unnormalized) log-target density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_elliptical_+3A_mu">mu</code></td>
<td>
<p>A numeric scalar with the mean of the supporting normal distribution.</p>
</td></tr>
<tr><td><code id="slice_elliptical_+3A_sigma">sigma</code></td>
<td>
<p>A numeric scalar with the standard deviation of the supporting normal distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<p><code>x</code> is the new state.
</p>
<p><code>nEvaluations</code> is the number of evaluations of the target function used to obtain the new
state.
</p>


<h3>References</h3>

<p>Murray, I., Adams, R., and MacKay, D., (2010), &quot;Elliptical Slice Sampling,&quot; in <em>Proceedings of the Thirteenth International Conference on Artificial Intelligence and Statistics</em>, JMLR Workshop and Conference Proceedings. <a href="https://proceedings.mlr.press/v9/murray10a">https://proceedings.mlr.press/v9/murray10a</a>
</p>
<p>Nishihara, R., Murray, I., and Adams, R. P. (2014), &quot;Parallel MCMC with Generalized Elliptical Slice Sampling,&quot; <em>Journal of Machine Learning Research</em>, 15, 2087-2112. <a href="https://jmlr.org/papers/v15/nishihara14a.html">https://jmlr.org/papers/v15/nishihara14a.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x, 3, 4, log = TRUE)
draws &lt;- numeric(10) # set to numeric(1e3) for more complete illustration
nEvaluations &lt;- 0L
for (i in seq.int(2, length(draws))) {
  out &lt;- slice_elliptical(draws[i - 1], log_target = lf, mu = 0.5, sigma = 1)
  draws[i] &lt;- out$x
  nEvaluations &lt;- nEvaluations + out$nEvaluations
}
nEvaluations / (length(draws) - 1)
plot(density(draws), xlim = c(0, 1))
curve(exp(lf(x)), 0, 1, col = "blue", add = TRUE)

</code></pre>

<hr>
<h2 id='slice_elliptical_mv'>Multivariate Elliptical Slice Sampler</h2><span id='topic+slice_elliptical_mv'></span>

<h3>Description</h3>

<p>Algorithm 1 of Nishihara et al. (2014) of the
elliptical slice sampler of Murray et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_elliptical_mv(x, log_target, mu, Sig, is_chol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_elliptical_mv_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric scalar).</p>
</td></tr>
<tr><td><code id="slice_elliptical_mv_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric scalar that evaluates the
(potentially unnormalized) log-target density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_elliptical_mv_+3A_mu">mu</code></td>
<td>
<p>Numeric vector with the mean of the supporting normal distribution.</p>
</td></tr>
<tr><td><code id="slice_elliptical_mv_+3A_sig">Sig</code></td>
<td>
<p>Positive definite covariance matrix. Alternatively, a
lower-triangular matrix with the Cholesky factor of the covariance matrix
(for faster computation).</p>
</td></tr>
<tr><td><code id="slice_elliptical_mv_+3A_is_chol">is_chol</code></td>
<td>
<p>Logical, is the supplied <code>Sig</code> in Cholesky (lower triangular) format? Default is false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<p><code>x</code> is the new state.
</p>
<p><code>nEvaluations</code> is the number of evaluations of the target function used to obtain the new
state.
</p>


<h3>References</h3>

<p>Murray, I., Adams, R., and MacKay, D., (2010), &quot;Elliptical Slice Sampling,&quot; in <em>Proceedings of the Thirteenth International Conference on Artificial Intelligence and Statistics</em>, JMLR Workshop and Conference Proceedings. <a href="https://proceedings.mlr.press/v9/murray10a">https://proceedings.mlr.press/v9/murray10a</a>
</p>
<p>Nishihara, R., Murray, I., and Adams, R. P. (2014), &quot;Parallel MCMC with Generalized Elliptical Slice Sampling,&quot; <em>Journal of Machine Learning Research</em>, 15, 2087-2112. <a href="https://jmlr.org/papers/v15/nishihara14a.html">https://jmlr.org/papers/v15/nishihara14a.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x[1], 3, 4, log = TRUE) + dbeta(x[2], 5, 3, log = TRUE)
n_iter &lt;- 10 # set to 1e3 for more complete illustration
draws &lt;- matrix(0.3, nrow = n_iter, ncol = 2)
nEvaluations &lt;- 0L
for (i in seq.int(2, n_iter)) {
  out &lt;- slice_elliptical_mv(draws[i - 1,], log_target = lf,
              mu = c(0.5, 0.5), Sig = matrix(c(0.5, 0.25, 0.25, 0.5), nrow = 2))
  draws[i,] &lt;- out$x
  nEvaluations &lt;- nEvaluations + out$nEvaluations
}
nEvaluations / (n_iter - 1)
plot(draws[,1], draws[,2], xlim = c(0, 1))
hist(draws[,1], freq = FALSE); curve(dbeta(x, 3, 4), col = "blue", add = TRUE)
hist(draws[,2], freq = FALSE); curve(dbeta(x, 5, 3), col = "blue", add = TRUE)

</code></pre>

<hr>
<h2 id='slice_genelliptical'>Generalized Elliptical Slice Sampler (univariate)</h2><span id='topic+slice_genelliptical'></span>

<h3>Description</h3>

<p>Single update using the generalized elliptical slice sampler of Nishihara et al. (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_genelliptical(x, log_target, mu, sigma, df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_genelliptical_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric scalar).</p>
</td></tr>
<tr><td><code id="slice_genelliptical_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric scalar that evaluates the
(potentially unnormalized) log-target density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_genelliptical_+3A_mu">mu</code></td>
<td>
<p>A numeric scalar with the mean of the supporting normal distribution.</p>
</td></tr>
<tr><td><code id="slice_genelliptical_+3A_sigma">sigma</code></td>
<td>
<p>A numeric scalar with the standard deviation of the supporting normal distribution.</p>
</td></tr>
<tr><td><code id="slice_genelliptical_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of Student t pseudo-target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains two elements:
</p>
<p><code>x</code> is the new state.
</p>
<p><code>nEvaluations</code> is the number of evaluations of the target function used to obtain the new
state.
</p>


<h3>References</h3>

<p>Nishihara, R., Murray, I., and Adams, R. P. (2014), &quot;Parallel MCMC with Generalized Elliptical Slice Sampling,&quot; <em>Journal of Machine Learning Research</em>, 15, 2087-2112. <a href="https://jmlr.org/papers/v15/nishihara14a.html">https://jmlr.org/papers/v15/nishihara14a.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x, 3, 4, log = TRUE)
draws &lt;- numeric(10) # set to numeric(1e3) for more complete illustration
nEvaluations &lt;- 0L
for (i in seq.int(2, length(draws))) {
  out &lt;- slice_genelliptical(draws[i - 1], log_target = lf,
                                      mu = 0.5, sigma = 1, df = 5)
  draws[i] &lt;- out$x
  nEvaluations &lt;- nEvaluations + out$nEvaluations
}
nEvaluations / (length(draws) - 1)
plot(density(draws), xlim = c(0, 1))
curve(exp(lf(x)), 0, 1, col = "blue", add = TRUE)

</code></pre>

<hr>
<h2 id='slice_genelliptical_mv'>Generalized Elliptical Slice Sampler (Multivariate)</h2><span id='topic+slice_genelliptical_mv'></span>

<h3>Description</h3>

<p>Generalized Elliptical Slice Sampler, Algorithm 2 of Nishihara et al. (2014)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_genelliptical_mv(x, log_target, mu, Sig, df, is_chol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_genelliptical_mv_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric scalar).</p>
</td></tr>
<tr><td><code id="slice_genelliptical_mv_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric scalar that evaluates the
(potentially unnormalized) log-target density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_genelliptical_mv_+3A_mu">mu</code></td>
<td>
<p>Numeric vector with the mean of the supporting normal distribution.</p>
</td></tr>
<tr><td><code id="slice_genelliptical_mv_+3A_sig">Sig</code></td>
<td>
<p>Positive definite covariance matrix. Alternatively, a
lower-triangular matrix with the Cholesky factor of the covariance matrix
(for faster computation).</p>
</td></tr>
<tr><td><code id="slice_genelliptical_mv_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of Student t pseudo-target.</p>
</td></tr>
<tr><td><code id="slice_genelliptical_mv_+3A_is_chol">is_chol</code></td>
<td>
<p>Logical, is the supplied <code>Sig</code> in Cholesky (lower triangular) format? Default is false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains two elements: <code>x</code> is the new state and <code>nEvaluations</code>
is the number of evaluations of the target function used to obtain the new
state.
</p>


<h3>References</h3>

<p>Nishihara, R., Murray, I., and Adams, R. P. (2014), &quot;Parallel MCMC with Generalized Elliptical Slice Sampling,&quot; <em>Journal of Machine Learning Research</em>, 15, 2087-2112. <a href="https://jmlr.org/papers/v15/nishihara14a.html">https://jmlr.org/papers/v15/nishihara14a.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x[1], 3, 4, log = TRUE) + dbeta(x[2], 5, 3, log = TRUE)
n_iter &lt;- 10 # set to 1e4 for more complete illustration
draws &lt;- matrix(0.3, nrow = n_iter, ncol = 2)
nEvaluations &lt;- 0L
for (i in seq.int(2, n_iter)) {
  out &lt;- slice_genelliptical_mv(draws[i - 1,], log_target = lf,
              mu = c(0.5, 0.5), Sig = matrix(c(0.5, 0.25, 0.25, 0.5), nrow = 2),
              df = 5)
  draws[i,] &lt;- out$x
  nEvaluations &lt;- nEvaluations + out$nEvaluations
}
nEvaluations / (n_iter - 1)
plot(draws[,1], draws[,2], xlim = c(0, 1))
hist(draws[,1], freq = FALSE); curve(dbeta(x, 3, 4), col = "blue", add = TRUE)
hist(draws[,2], freq = FALSE); curve(dbeta(x, 5, 3), col = "blue", add = TRUE)

</code></pre>

<hr>
<h2 id='slice_hyperrect'>Multivariate Slice Sampler with Shrinking Hyperrectangle</h2><span id='topic+slice_hyperrect'></span>

<h3>Description</h3>

<p>Multivariate slice sampler
in Algorithm 8 of Neal (2003) using the &quot;shrinkage&quot; procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_hyperrect(x, log_target, w = NULL, L = NULL, R = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_hyperrect_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric vector).</p>
</td></tr>
<tr><td><code id="slice_hyperrect_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric vector that evaluates the log-target
density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_hyperrect_+3A_w">w</code></td>
<td>
<p>A numeric vector tuning the algorithm which gives the typical slice
width in each dimension. This is a main tuning parameter of the algorithm.
If <code>NULL</code>, the sampler begins shrinking from the supplied boundaries (should,
correspond with the support).</p>
</td></tr>
<tr><td><code id="slice_hyperrect_+3A_l">L</code></td>
<td>
<p>Numeric vector giving the lower boundary of support in each dimension.</p>
</td></tr>
<tr><td><code id="slice_hyperrect_+3A_r">R</code></td>
<td>
<p>Numeric vector giving the upper boundary of support in each dimension.
Will be used if <code>w</code> is null. If all of <code>L</code>, <code>R</code>, and <code>w</code>
are null, then the boundaries default to those of the unit hypercube.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains two elements: &quot;x&quot; is the new state and &quot;nEvaluations&quot;
is the number of evaluations of the target function used to obtain the new
state.
</p>


<h3>References</h3>

<p>Neal, R. M. (2003), &quot;Slice sampling,&quot; <em>The Annals of Statistics</em>, 31, 705-767. <a href="https://doi.org/10.1214/aos/1056562461">doi:10.1214/aos/1056562461</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x[1], 3, 4, log = TRUE) + dbeta(x[2], 5, 3, log = TRUE)
n_iter &lt;- 10 # set to 1e4 for more complete illustration
draws &lt;- matrix(0.2, nrow = n_iter, ncol = 2)
nEvaluations &lt;- 0L
for (i in seq.int(2, n_iter)) {
 out &lt;- slice_hyperrect(draws[i - 1, ], log_target = lf, w = c(0.5, 0.5))
 draws[i,] &lt;- out$x
 nEvaluations &lt;- nEvaluations + out$nEvaluations
 cat(i, '\r')
}
nEvaluations / (nrow(draws) - 1)
plot(draws[,1], draws[,2], xlim = c(0, 1))
hist(draws[,1], freq = FALSE); curve(dbeta(x, 3, 4), col = "blue", add = TRUE)
hist(draws[,2], freq = FALSE); curve(dbeta(x, 5, 3), col = "blue", add = TRUE)

</code></pre>

<hr>
<h2 id='slice_latent'>Latent Slice Sampler</h2><span id='topic+slice_latent'></span>

<h3>Description</h3>

<p>Single update using the latent slice sampler of Li and Walker (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_latent(x, s, log_target, rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_latent_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric scalar).</p>
</td></tr>
<tr><td><code id="slice_latent_+3A_s">s</code></td>
<td>
<p>A random variable that determines the length of the initial shrinking interval.</p>
</td></tr>
<tr><td><code id="slice_latent_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric scalar that evaluates the
(potentially unnormalized) log-target density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_latent_+3A_rate">rate</code></td>
<td>
<p>The rate parameter for the distribution of <code>s</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three elements:
</p>
<p><code>x</code> is the new state of the target variable.
</p>
<p><code>s</code> is the new state of the latent scale variable.
</p>
<p><code>nEvaluations</code> is the number of evaluations of the
target function used to obtain the new state.
</p>


<h3>References</h3>

<p>Li, Y. and Walker, S. G. (2023), &quot;A latent slice sampling algorithm,&quot; <em>Computational Statistics and Data Analysis</em>, 179, 107652. <a href="https://doi.org/10.1016/j.csda.2022.107652">doi:10.1016/j.csda.2022.107652</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x, 3, 4, log = TRUE)
draws &lt;- numeric(10) # set to numeric(1e3) for more complete illustration
nEvaluations &lt;- 0L
s &lt;- 0.5
for (i in seq.int(2, length(draws))) {
  out &lt;- slice_latent(draws[i - 1], s, log_target = lf, rate = 0.3)
  draws[i] &lt;- out$x
  s &lt;- out$s
  nEvaluations &lt;- nEvaluations + out$nEvaluations
}
nEvaluations / (length(draws) - 1)
plot(density(draws), xlim = c(0, 1))
curve(exp(lf(x)), 0, 1, col = "blue", add = TRUE)

</code></pre>

<hr>
<h2 id='slice_quantile'>Quantile Slice Sampler</h2><span id='topic+slice_quantile'></span>

<h3>Description</h3>

<p>Single update using a quantile slice sampler of Heiner et al. (2024+).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_quantile(x, log_target, pseudo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_quantile_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric scalar).</p>
</td></tr>
<tr><td><code id="slice_quantile_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric scalar that evaluates the
(potentially unnormalized) log-target density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_quantile_+3A_pseudo">pseudo</code></td>
<td>
<p>List containing two functions specifying the pseudo-target distribution:
</p>
<p><code>ld</code> evaluates the log density for a scalar input, and
</p>
<p><code>q</code> evaluates the quantile (inverse-CDF) function for an input in (0,1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three elements:
</p>
<p><code>x</code> is the new state.
</p>
<p><code>u</code> is the value of the CDF of the psuedo-target associated with the
returned value (also referred to as psi).
</p>
<p><code>nEvaluations</code> is the number of evaluations of the
target function used to obtain the new state.
</p>


<h3>References</h3>

<p>Heiner, M. J., Johnson, S. B., Christensen, J. R., and Dahl, D. B. (2024+), &quot;Quantile Slice Sampling,&quot; <em>arXiv preprint arXiv:###</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x, 3, 4, log = TRUE)
pseu &lt;- list(ld = function(x) dbeta(x, shape1 = 1, shape2 = 1, log = TRUE),
             q = function(u) qbeta(u, shape1 = 1, shape2 = 1))
draws &lt;- numeric(10) # set to numeric(1e3) for more complete illustration
nEvaluations &lt;- 0L
for (i in seq.int(2, length(draws))) {
  out &lt;- slice_quantile(draws[i - 1], log_target = lf, pseudo = pseu)
  draws[i] &lt;- out$x
  nEvaluations &lt;- nEvaluations + out$nEvaluations
}
nEvaluations / (length(draws) - 1)
plot(density(draws), xlim = c(0, 1))
curve(exp(lf(x)), 0, 1, col = "blue", add = TRUE)

</code></pre>

<hr>
<h2 id='slice_quantile_mv'>Multivariate Quantile Slice Sampler</h2><span id='topic+slice_quantile_mv'></span>

<h3>Description</h3>

<p>Quantile slice sampler for a random vector (Heiner et al., 2024+). The pseudo-target is specified
through independent univariate distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_quantile_mv(x, log_target, pseudo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_quantile_mv_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric vector).</p>
</td></tr>
<tr><td><code id="slice_quantile_mv_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric vector that evaluates the log-target
density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_quantile_mv_+3A_pseudo">pseudo</code></td>
<td>
<p>List of length equal to the number of dimensions in <code>x</code>. Each element is itself a list that specifies
the pseudo-target for the corresponding dimension with functions <code>ld</code> that evaluates the log density,
<code>p</code> that evaluates the CDF, and <code>q</code> that evaluates the quantile (inverse-CDF) function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three elements: &quot;x&quot; is the new state, &quot;u&quot; is the
value of the CDF of the psuedo-target associated with the returned value,
inverse CDF method, and &quot;nEvaluations is the number of evaluations of the
target function used to obtain the new state.
</p>


<h3>References</h3>

<p>Heiner, M. J., Johnson, S. B., Christensen, J. R., and Dahl, D. B. (2024+), &quot;Quantile Slice Sampling,&quot; <em>arXiv preprint arXiv:###</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x[1], 3, 4, log = TRUE) + dbeta(x[2], 5, 3, log = TRUE)
ps_shsc &lt;- list(c(2, 2), c(2, 1))
ps &lt;- list(
  list(ld = function(x) dbeta(x, ps_shsc[[1]][1], ps_shsc[[1]][2], log = TRUE),
       p = function(x) pbeta(x, ps_shsc[[1]][1], ps_shsc[[1]][2]),
       q = function(x) qbeta(x, ps_shsc[[1]][1], ps_shsc[[1]][2]) ),
  list(ld = function(x) dbeta(x, ps_shsc[[2]][1], ps_shsc[[2]][2], log = TRUE),
       p = function(x) pbeta(x, ps_shsc[[2]][1], ps_shsc[[2]][2]),
       q = function(x) qbeta(x, ps_shsc[[2]][1], ps_shsc[[2]][2]) )
  )
n_iter &lt;- 10 # set to 1e4 for more complete illustration
draws &lt;- matrix(0.2, nrow = n_iter, ncol = 2)
draws_u &lt;- draws
draws_u[1,] &lt;- sapply(1:length(ps), function(k) ps[[k]]$p(draws[1,k]))
nEvaluations &lt;- 0L
for (i in seq.int(2, n_iter)) {
  out &lt;- slice_quantile_mv(draws[i - 1, ], log_target = lf, pseudo = ps)
  draws[i,] &lt;- out$x
  draws_u[i,] &lt;- out$u
  nEvaluations &lt;- nEvaluations + out$nEvaluations
  cat(i, '\r')
}
nEvaluations / (nrow(draws) - 1)
plot(draws[,1], draws[,2], xlim = c(0, 1))
hist(draws[,1], freq = FALSE); curve(dbeta(x, 3, 4), col = "blue", add = TRUE)
hist(draws[,2], freq = FALSE); curve(dbeta(x, 5, 3), col = "blue", add = TRUE)
plot(draws_u[,1], draws_u[,2], xlim = c(0, 1))
hist(draws_u[,1], freq = FALSE)
hist(draws_u[,2], freq = FALSE)
auc(u = draws_u[,1])
auc(u = draws_u[,2])
</code></pre>

<hr>
<h2 id='slice_quantile_mv_seq'>Multivariate Quantile Slice Sampler from a sequence of conditional pseudo-targets</h2><span id='topic+slice_quantile_mv_seq'></span>

<h3>Description</h3>

<p>Quantile slice sampler for a random vector (Heiner et al., 2024+). The pseudo-target is specified as
a sequence of growing conditional distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_quantile_mv_seq(x, log_target, pseudo_control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_quantile_mv_seq_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric vector).</p>
</td></tr>
<tr><td><code id="slice_quantile_mv_seq_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric vector that evaluates the log-target
density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_quantile_mv_seq_+3A_pseudo_control">pseudo_control</code></td>
<td>
<p>A list with
</p>
<p><code>pseudo_init</code>, a list output from
<a href="#topic+pseudo_list">pseudo_list</a> describing the marginal pseudo-target for <code>x[1]</code>.
Attributes of <code>pseudo_init</code> will be used in subsequent pseudo-targets,
except for location and scale parameters.
</p>
<p><code>loc_fn</code>, a function that specifies the location of a conditional
pseudo-target given the elements in <code>x</code> that precede it.
</p>
<p><code>sc_fn</code>, a function that specifies the scale of a conditional
pseudo-target given the elements in <code>x</code> that precede it.
</p>
<p><code>lb</code>, a numeric vector (same length as <code>x</code>) specifying the lower
bound of support for each conditional pseudo-target.
</p>
<p><code>ub</code>, a numeric vector (same length as <code>x</code>) specifying the upper
bound of support for each conditional pseudo-target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three elements: &quot;x&quot; is the new state, &quot;u&quot; is a vector
of values of the sequence of conditional CDFs of the psuedo-targets associated
with the returned value, and &quot;nEvaluations is the number of evaluations of the
target function used to obtain the new state.
</p>


<h3>References</h3>

<p>Heiner, M. J., Johnson, S. B., Christensen, J. R., and Dahl, D. B. (2024+), &quot;Quantile Slice Sampling,&quot; <em>arXiv preprint arXiv:###</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Funnel distribution from Neal (2003).
K &lt;- 10
n_iter &lt;- 50 # MCMC iterations; set to 10e3 for more complete illustration
n &lt;- 100 # number of iid samples from the target; set to 10e3 for more complete illustration
Y &lt;- matrix(NA, nrow = n, ncol = K) # iid samples from the target
Y[,1] &lt;- rnorm(n, 0.0, 3.0)
for (i in 1:n) {
  Y[i, 2:K] &lt;- rnorm(K-1, 0.0, exp(0.5*Y[i,1]))
}
ltarget &lt;- function(x) {
dnorm(x[1], 0.0, 3.0, log = TRUE) +
  sum(dnorm(x[2:K], 0.0, exp(0.5*x[1]), log = TRUE))
}
pseudo_control &lt;- list(
  loc_fn = function(x) {
    0.0
  },
  sc_fn = function(x) {
    if (is.null(x)) {
      out &lt;- 3.0
    } else {
      out &lt;- exp(0.5*x[1])
    }
    out
  },
  pseudo_init = pseudo_list(family = "t",
                            params = list(loc = 0.0, sc = 3.0, degf = 20),
                            lb = -Inf, ub = Inf),
  lb = rep(-Inf, K),
  ub = rep(Inf, K)
)
x0 &lt;- runif(K)
draws &lt;- matrix(rep(x0, n_iter + 1), nrow = n_iter + 1, byrow = TRUE)
draws_u &lt;- matrix(rep(x0, n_iter), nrow = n_iter, byrow = TRUE)
n_eval &lt;- 0
for (i in 2:(n_iter + 1)) {
  tmp &lt;- slice_quantile_mv_seq(draws[i-1,],
                                log_target = ltarget,
                                pseudo_control = pseudo_control)
  draws[i,] &lt;- tmp$x
  draws_u[i-1,] &lt;- tmp$u
  n_eval &lt;- n_eval + tmp$nEvaluations
}
# (es &lt;- coda::effectiveSize(coda::as.mcmc(draws)))
# mean(es)
n_eval / n_iter
sapply(1:K, function (k) auc(u = draws_u[,k]))
hist(draws_u[,1])
plot(draws[,1], draws[,2])
points(Y[,1], Y[,2], col = "blue", cex = 0.5)
</code></pre>

<hr>
<h2 id='slice_stepping_out'>Slice sampler using the Stepping Out and Shrinkage Procedures</h2><span id='topic+slice_stepping_out'></span>

<h3>Description</h3>

<p>Single update for the univariate slice sampler of Neal (2003) using the
&quot;stepping out&quot; procedure, followed by the &quot;shrinkage&quot; procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_stepping_out(x, log_target, w, max = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_stepping_out_+3A_x">x</code></td>
<td>
<p>The current state (as a numeric scalar).</p>
</td></tr>
<tr><td><code id="slice_stepping_out_+3A_log_target">log_target</code></td>
<td>
<p>A function taking numeric scalar that evaluates the
(potentially unnormalized) log-target density, returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="slice_stepping_out_+3A_w">w</code></td>
<td>
<p>A numeric scalar tuning the algorithm which gives the typical slice
width. This is a main tuning parameter of the algorithm.</p>
</td></tr>
<tr><td><code id="slice_stepping_out_+3A_max">max</code></td>
<td>
<p>The maximum number of times to step out. Setting <code>max</code> to
zero avoids some evaluations of <code>log_target</code>, but may lead to relatively
high autocorrelation if <code>w</code> is too small.  If <code>w</code> is too small,
setting <code>max</code> to a large value (even <code>Inf</code>) should lead to low
autocorrelation at the cost of more evaluations for <code>log_target</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<p><code>x</code> is the new state.
</p>
<p><code>nEvaluations</code> is the number of evaluations of the target function used to obtain the new
state.
</p>


<h3>References</h3>

<p>Neal, R. M. (2003), &quot;Slice sampling,&quot; <em>The Annals of Statistics</em>, 31, 705-767. <a href="https://doi.org/10.1214/aos/1056562461">doi:10.1214/aos/1056562461</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- function(x) dbeta(x, 3, 4, log = TRUE)
draws &lt;- numeric(10) + 0.5 # set to numeric(1e3) for more complete illustration
nEvaluations &lt;- 0L
for (i in seq.int(2, length(draws))) {
  out &lt;- slice_stepping_out(draws[i - 1], log_target = lf, w = 0.7, max = Inf)
  draws[i] &lt;- out$x
  nEvaluations &lt;- nEvaluations + out$nEvaluations
}
nEvaluations / (length(draws) - 1)
plot(density(draws), xlim = c(0, 1))
curve(exp(lf(x)), 0, 1, col = "blue", add = TRUE)

</code></pre>

<hr>
<h2 id='utility_pseudo'>Utility for a given target and pseudo-target</h2><span id='topic+utility_pseudo'></span>

<h3>Description</h3>

<p>Takes a pseudo-target and target (or samples from the target) and
evaluates the utility function for the transformed target, which can be one of
Area Under the Curve (AUC) and Mean Slice Width (MSW). See Heiner et al. (2024+).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility_pseudo(
  pseudo,
  log_target = NULL,
  samples = NULL,
  type = "samples",
  x = NULL,
  nbins = 30,
  plot = TRUE,
  utility_type = "AUC",
  tol_int = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utility_pseudo_+3A_pseudo">pseudo</code></td>
<td>
<p>List containing the following functions with scalar input:
</p>
<p><code>ld</code>: function to evaluate the log density
</p>
<p><code>q</code>: function to evaluate the quantile function
</p>
<p><code>p</code>: function to evaluate the distribution function</p>
</td></tr>
<tr><td><code id="utility_pseudo_+3A_log_target">log_target</code></td>
<td>
<p>Function to evaluate the log density of the unnormalized target.</p>
</td></tr>
<tr><td><code id="utility_pseudo_+3A_samples">samples</code></td>
<td>
<p>Numeric vector of samples from the target distribution.</p>
</td></tr>
<tr><td><code id="utility_pseudo_+3A_type">type</code></td>
<td>
<p>String specifying the input type. One of &quot;function&quot;, &quot;samples&quot;, or &quot;grid&quot;.
Default is to use &quot;samples&quot;.
</p>
<p>Use of &quot;function&quot; requires specification of <code>log_target</code>.
</p>
<p>Use of &quot;samples&quot; requires specification of <code>samples</code>.
</p>
<p>Use of &quot;grid&quot; requires specification of <code>x</code>.</p>
</td></tr>
<tr><td><code id="utility_pseudo_+3A_x">x</code></td>
<td>
<p>Numeric vector specifying grid (on (0,1)) over which to evaluate
the transformed target. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="utility_pseudo_+3A_nbins">nbins</code></td>
<td>
<p>Number of histogram bins to use (defaults to 30). Must match the length
of <code>x</code> if <code>x</code> is supplied.</p>
</td></tr>
<tr><td><code id="utility_pseudo_+3A_plot">plot</code></td>
<td>
<p>Logical for whether to generate two plots:
</p>

<ol>
<li><p> direct comparison of the target and pseudo-target densities, and
</p>
</li>
<li><p> transformed target density.
</p>
</li></ol>

<p>Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utility_pseudo_+3A_utility_type">utility_type</code></td>
<td>
<p>String identifying utility type, either AUC (default) or MSW.</p>
</td></tr>
<tr><td><code id="utility_pseudo_+3A_tol_int">tol_int</code></td>
<td>
<p>Positive numeric scalar that passes to <code>abs.tol</code> in the call to <a href="stats.html#topic+integrate">integrate</a>.
Defaults to <code>1.0e-3</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optionally plot the target and pseudo-target densities as well as the
transformed tartet.
</p>


<h3>Value</h3>

<p>Scalar value of the utility function evaluation.
</p>


<h3>References</h3>

<p>Heiner, M. J., Johnson, S. B., Christensen, J. R., and Dahl, D. B. (2024+), &quot;Quantile Slice Sampling,&quot; <em>arXiv preprint arXiv:###</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pseu &lt;- pseudo_list(family = "logistic", params = list(loc = 0.0, sc = 0.66))
ltarg &lt;- list(ld = function(x) dnorm(x, log = TRUE))
oldpar &lt;- par(mfrow = c(1,2))
utility_pseudo(pseudo = pseu, log_target = ltarg$ld, type = "function",
               nbins = 100, utility_type = "MSW")
samp &lt;- rnorm(10e3)
utility_pseudo(pseudo = pseu, samples = samp, type = "samples", utility_type = "AUC")
utility_pseudo(pseudo = pseu, samples = samp, type = "samples", utility_type = "MSW")
par(oldpar)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
