<!DOCTYPE html><html><head><title>Help for package multimark</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multimark}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bobcat'><p>Bobcat data</p></a></li>
<li><a href='#bobcatSCR'><p>Bobcat spatial capture-recapture data</p></a></li>
<li><a href='#getdensityClosedSCR'><p>Calculate population density estimates</p></a></li>
<li><a href='#getprobsCJS'><p>Calculate posterior capture and survival probabilities</p></a></li>
<li><a href='#getprobsClosed'><p>Calculate posterior capture and recapture probabilities</p></a></li>
<li><a href='#getprobsClosedSCR'><p>Calculate posterior capture and recapture probabilities</p></a></li>
<li><a href='#markCJS'><p>Fit open population survival models for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type</p></a></li>
<li><a href='#markClosed'><p>Fit closed population abundance models for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type</p></a></li>
<li><a href='#markClosedSCR'><p>Fit spatial population abundance models for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type</p></a></li>
<li><a href='#multimarkCJS'><p>Fit open population survival models for capture-mark-recapture data consisting of multiple non-invasive marks</p></a></li>
<li><a href='#multimarkClosed'><p>Fit closed population abundance models for capture-mark-recapture data consisting of multiple non-invasive marks</p></a></li>
<li><a href='#multimarkClosedSCR'><p>Fit spatially-explicit population abundance models for capture-mark-recapture data consisting of multiple non-invasive marks</p></a></li>
<li><a href='#multimarkSCRsetup-class'><p>Class <code>"multimarkSCRsetup"</code></p></a></li>
<li><a href='#multimarksetup-class'><p>Class <code>"multimarksetup"</code></p></a></li>
<li><a href='#multimodelCJS'><p>Multimodel inference for 'multimark' open population survival models</p></a></li>
<li><a href='#multimodelClosed'><p>Multimodel inference for 'multimark' closed population abundance models</p></a></li>
<li><a href='#multimodelClosedSCR'><p>Multimodel inference for 'multimark' spatial population abundance models</p></a></li>
<li><a href='#plotSpatialData'><p>Plot spatial capture-mark-recapture data</p></a></li>
<li><a href='#processdata'><p>Generate model inputs for fitting 'multimark' models</p></a></li>
<li><a href='#processdataSCR'><p>Generate model inputs for fitting spatial 'multimark' models</p></a></li>
<li><a href='#simdataCJS'><p>Simulate open population capture-mark-recapture data arising from multiple non-invasive marks</p></a></li>
<li><a href='#simdataClosed'><p>Simulate closed population capture-mark-recapture data arising from multiple non-invasive marks</p></a></li>
<li><a href='#simdataClosedSCR'><p>Simulate spatially-explicit capture-mark-recapture data from a (demographically) closed population with multiple non-invasive marks</p></a></li>
<li><a href='#tiger'><p>Tiger data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Capture-Mark-Recapture Analysis using Multiple Non-Invasive
Marks</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-09</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, Matrix, coda, statmod, RMark, Brobdingnag, mvtnorm,
graphics, methods, stats, utils, prodlim, sp, raster</td>
</tr>
<tr>
<td>Description:</td>
<td>Traditional and spatial capture-mark-recapture analysis with
    multiple non-invasive marks. The models implemented in 'multimark' combine
    encounter history data arising from two different non-invasive "marks",
    such as images of left-sided and right-sided pelage patterns of bilaterally
    asymmetrical species, to estimate abundance and related demographic
    parameters while accounting for imperfect detection. Bayesian models are
    specified using simple formulae and fitted using Markov chain Monte Carlo.
    Addressing deficiencies in currently available software, 'multimark' also
    provides a user-friendly interface for performing Bayesian multimodel
    inference using non-spatial or spatial capture-recapture data consisting of a single
    conventional mark or multiple non-invasive marks. See McClintock (2015) &lt;<a href="https://doi.org/10.1002%2Fece3.1676">doi:10.1002/ece3.1676</a>&gt; and Maronde et al. (2020) &lt;<a href="https://doi.org/10.1002%2Fece3.6990">doi:10.1002/ece3.6990</a>&gt;.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-09 19:08:12 UTC; brettmcclintock</td>
</tr>
<tr>
<td>Author:</td>
<td>Brett T. McClintock [aut, cre],
  Acho Arnold [ctb, cph] (C original matrix library,
    https://github.com/najela/matrix.h),
  Barry Brown [ctb] (Fortran original ranlib library),
  James Lovato [ctb] (Fortran original ranlib library),
  John Burkardt [ctb] (C original ranlib library,
    http://people.sc.fsu.edu/~jburkardt/c_src/ranlib),
  Cleve Moler [ctb] (C original linpack library,
    http://www.kkant.net/geist/ranlib/),
  Arjun Gopalaswamy [ctb] (modified snippets of R package SPACECAP code)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brett T. McClintock &lt;brett.mcclintock@noaa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-10 11:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bobcat'>Bobcat data</h2><span id='topic+bobcat'></span>

<h3>Description</h3>

<p>Example bobcat data for <code>multimark</code> package.
</p>


<h3>Format</h3>

<p>The data are summarized in a 46x8 matrix containing observed encounter histories for 46 bobcats across 8 sampling occasions. Bobcats are bilaterially asymmetrical, and sampling was conducted using camera stations consisting of a single camera. 
</p>
<p>Because the left-side cannot be reconciled with the right-side, the two types of &ldquo;marks&rdquo; in this case are the pelage patterns on the left- and right-side of each individual. Encounter type 0 corresponds to non-detection, encounter type 1 corresponds to left-sided detection, encounter type 2 corresponds to right-sided detection. 
</p>
<p>Both-sided encounters were never observed in this dataset, hence the most appropriate <code>multimark</code> data type is <code>data.type="never".</code>
</p>


<h3>Source</h3>

<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkClosed">multimarkClosed</a></code>, <code><a href="#topic+processdata">processdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bobcat)
</code></pre>

<hr>
<h2 id='bobcatSCR'>Bobcat spatial capture-recapture data</h2><span id='topic+bobcatSCR'></span>

<h3>Description</h3>

<p>Example spatial bobcat data for <code>multimark</code> package.
</p>


<h3>Format</h3>

<p>These spatial capture-recapture data with multiple mark types are summarized in a list of length 3 containing the following objects:
</p>
<p><code>Enc.Mat</code> is a 42 x (noccas*ntraps) matrix containing observed encounter histories for 42 bobcats across <code>noccas=187</code> sampling occasions and <code>ntraps=30</code> traps. The first 187 columns correspond to trap 1, the second 187 columns corresopond to trap 2, etc.
</p>
<p><code>trapCoords</code> is a matrix of dimension <code>ntraps</code> x (2 + <code>noccas</code>) indicating the Cartesian coordinates and operating occasions for the traps, where rows correspond to trap, the first column the x-coordinate, and the second column the y-coordinate. The last <code>noccas</code> columns indicate whether or not the trap was operating on each of the occasions, where &lsquo;1&rsquo; indciates the trap was operating and &lsquo;0&rsquo; indicates the trap was not operating.
</p>
<p><code>studyArea</code> is a 3-column matrix containing the coordinates for the centroids of the contiguous grid of 1023 cells that define the study area and available habitat. Each row corresponds to a grid cell. The first 2 columns indicate the Cartesian x- and y-coordinate for the centroid of each grid cell, and the third column indicates whether the cell is available habitat (=1) or not (=0). The grid cells are 0.65x0.65km resolution. 
</p>
<p>Bobcats are bilaterially asymmetrical, and sampling was conducted using camera stations consisting of a single camera. Because the left-side cannot be reconciled with the right-side, the two types of &ldquo;marks&rdquo; in this case are the pelage patterns on the left- and right-side of each individual. Encounter type 0 corresponds to non-detection, encounter type 1 corresponds to left-sided detection, encounter type 2 corresponds to right-sided detection. 
</p>
<p>Both-sided encounters were never observed in this dataset, hence the most appropriate <code>multimark</code> data type is <code>data.type="never".</code>
</p>
<p>The first 15 rows of <code>bobcatSCR$Enc.Mat</code> correspond to individuals for which both the left and right sides were known because they were physically captured for telemetry deployments prior to sampling surveys. The encounter histories for these 15 individuals are therefore known with certainty and should be specified as such using the <code>known</code> argument in <code><a href="#topic+processdataSCR">processdataSCR</a></code> and/or <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code> (see example below).
</p>
<p>These data were obtained from the R package <code>SPIM</code> (Augustine et al. 2017) and modified by projecting onto a regular rectangular grid consisting of square grid cells (as is required by the spatial capture-recapture models in <code>multimark</code>).
</p>


<h3>Details</h3>

<p>We thank B. Augustine and co-authors for making these data publicly available in the <code>SPIM</code> package (Augustine et al. 2017).
</p>


<h3>Source</h3>

<p>Augustine, B., Royle, J.A., Kelly, M., Satter, C., Alonso, R., Boydston, E. and Crooks, K. 2017. Spatial capture-recapture with partial identity: an application to camera traps. bioRxiv doi: https://doi.org/10.1101/056804
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code>, <code><a href="#topic+processdataSCR">processdataSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bobcatSCR)
#plot the traps and available habitat within the study area
plotSpatialData(trapCoords=bobcatSCR$trapCoords,studyArea=bobcatSCR$studyArea)

# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

# Fit spatial model to tiger data
Enc.Mat &lt;- bobcatSCR$Enc.Mat
trapCoords &lt;- bobcatSCR$trapCoords
studyArea &lt;- bobcatSCR$studyArea

# specify known encounter histories
known &lt;- c(rep(1,15),rep(0,nrow(Enc.Mat)-15))

# specify prior bounds for sigma2_scr
sig_bounds &lt;- c(0.1,max(diff(range(studyArea[,"x"])),diff(range(studyArea[,"y"]))))

mmsSCR &lt;- processdataSCR(Enc.Mat,trapCoords,studyArea,known=known)
bobcatSCR.dot.type &lt;- multimarkClosedSCR(mms=mmsSCR,iter=200,adapt=100,burnin=100,
                                         sigma_bounds=sig_bounds)
summary(bobcatSCR.dot.type$mcmc)
</code></pre>

<hr>
<h2 id='getdensityClosedSCR'>Calculate population density estimates</h2><span id='topic+getdensityClosedSCR'></span>

<h3>Description</h3>

<p>This function calculates posterior population density estimates from <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code> output as D = N/A, where D is density, N is abundance, and A is the area of available habitat within the study area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getdensityClosedSCR(out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getdensityClosedSCR_+3A_out">out</code></td>
<td>
<p>List of output returned by <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> containing the following:
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>Posterior samples for density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Run behavior model for simulated data with constant detection probability (i.e., mod.p=~c)
sim.data&lt;-simdataClosedSCR()
Enc.Mat&lt;-sim.data$Enc.Mat
trapCoords&lt;-sim.data$spatialInputs$trapCoords
studyArea&lt;-sim.data$spatialInputs$studyArea
example.dot &lt;- multimarkClosedSCR(Enc.Mat,trapCoords,studyArea,mod.p=~1)
  
#Calculate capture and recapture probabilities
D &lt;- getdensityClosedSCR(example.dot)
summary(D)

</code></pre>

<hr>
<h2 id='getprobsCJS'>Calculate posterior capture and survival probabilities</h2><span id='topic+getprobsCJS'></span>

<h3>Description</h3>

<p>This function calculates posterior capture (<code class="reqn">p</code>) and survival (<code class="reqn">\phi</code>) probabilities for each sampling occasion from <code><a href="#topic+multimarkCJS">multimarkCJS</a></code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getprobsCJS(out, link = "probit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getprobsCJS_+3A_out">out</code></td>
<td>
<p>List of output returned by <code><a href="#topic+multimarkCJS">multimarkCJS</a></code></p>
</td></tr>
<tr><td><code id="getprobsCJS_+3A_link">link</code></td>
<td>
<p>Link function for <code class="reqn">p</code> and <code class="reqn">\phi</code>. Must be &quot;<code>probit</code>&quot; or &quot;<code>logit</code>&quot;. Note that <code><a href="#topic+multimarkCJS">multimarkCJS</a></code> is currently implemented for the probit link only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> containing the following:
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>Posterior samples for capture probability (<code class="reqn">p[c,t]</code>) for each release cohort (<code class="reqn">c=1,\ldots,T-1</code>) and sampling occasion (<code class="reqn">t=2,\ldots,T</code>).</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>Posterior samples for survival probability (<code class="reqn">\phi[c,k]</code>) for each release cohort (<code class="reqn">c=1,\ldots,T-1</code>) and interval (<code class="reqn">k=1,\ldots,T-1</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkCJS">multimarkCJS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Simulate open population data with temporal variation in survival
noccas &lt;- 5
data &lt;- simdataCJS(noccas=noccas, phibeta=rnorm(noccas-1,1.6,0.1))
 
#Fit open population model with temporal variation in survival
sim.time &lt;- multimarkCJS(data$Enc.Mat,mod.phi=~time)
    
#Calculate capture and survival probabilities for each cohort and time
pphi &lt;- getprobsCJS(sim.time)
summary(pphi)

</code></pre>

<hr>
<h2 id='getprobsClosed'>Calculate posterior capture and recapture probabilities</h2><span id='topic+getprobsClosed'></span>

<h3>Description</h3>

<p>This function calculates posterior capture (<code class="reqn">p</code>) and recapture (<code class="reqn">c</code>) probabilities for each sampling occasion from <code><a href="#topic+multimarkClosed">multimarkClosed</a></code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getprobsClosed(out, link = "logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getprobsClosed_+3A_out">out</code></td>
<td>
<p>List of output returned by <code><a href="#topic+multimarkClosed">multimarkClosed</a></code>.</p>
</td></tr>
<tr><td><code id="getprobsClosed_+3A_link">link</code></td>
<td>
<p>Link function for detection probability. Must be &quot;<code>logit</code>&quot; or &quot;<code>probit</code>&quot;. Note that <code><a href="#topic+multimarkClosed">multimarkClosed</a></code> is currently implemented for the logit link only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> containing the following:
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>Posterior samples for capture probability (<code class="reqn">p</code>) for each sampling occasion.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Posterior samples for recapture probability (<code class="reqn">c</code>) for each sampling occasion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkClosed">multimarkClosed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Run behavior model for bobcat data with constant detection probability (i.e., mod.p=~c)
bobcat.c &lt;- multimarkClosed(bobcat,mod.p=~c)
  
#Calculate capture and recapture probabilities
pc &lt;- getprobsClosed(bobcat.c)
summary(pc)

</code></pre>

<hr>
<h2 id='getprobsClosedSCR'>Calculate posterior capture and recapture probabilities</h2><span id='topic+getprobsClosedSCR'></span>

<h3>Description</h3>

<p>This function calculates posterior spatial capture (<code class="reqn">p</code>) and recapture (<code class="reqn">c</code>) probabilities (at zero distance from an activity center) for each sampling occasion from <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getprobsClosedSCR(out, link = "cloglog")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getprobsClosedSCR_+3A_out">out</code></td>
<td>
<p>List of output returned by <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code>.</p>
</td></tr>
<tr><td><code id="getprobsClosedSCR_+3A_link">link</code></td>
<td>
<p>Link function for detection probability. Must be &quot;<code>cloglog</code>&quot;. Note that <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code> is currently implemented for the cloglog link only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> containing the following:
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>Posterior samples for capture probability (<code class="reqn">p</code>) for each sampling occasion (first index) and trap (second index).</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Posterior samples for recapture probability (<code class="reqn">c</code>) for each sampling occasion (first index) and trap (second index).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Run behavior model for simulated data with constant detection probability (i.e., mod.p=~c)
sim.data&lt;-simdataClosedSCR()
Enc.Mat&lt;-sim.data$Enc.Mat
trapCoords&lt;-sim.data$spatialInputs$trapCoords
studyArea&lt;-sim.data$spatialInputs$studyArea
example.c &lt;- multimarkClosedSCR(Enc.Mat,trapCoords,studyArea,mod.p=~c,
                                iter=1000,adapt=500,burnin=500)
  
#Calculate capture and recapture probabilities
pc &lt;- getprobsClosedSCR(example.c)
summary(pc)

</code></pre>

<hr>
<h2 id='markCJS'>Fit open population survival models for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type</h2><span id='topic+markCJS'></span>

<h3>Description</h3>

<p>This function fits Cormack-Jolly-Seber (CJS) open population models for survival probability (<code class="reqn">\phi</code>) and capture probability (<code class="reqn">p</code>) for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type. Using Bayesian analysis methods, Markov chain Monte Carlo (MCMC) is used to draw samples from the joint posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markCJS(
  Enc.Mat,
  covs = data.frame(),
  mod.p = ~1,
  mod.phi = ~1,
  parms = c("pbeta", "phibeta"),
  nchains = 1,
  iter = 12000,
  adapt = 1000,
  bin = 50,
  thin = 1,
  burnin = 2000,
  taccept = 0.44,
  tuneadjust = 0.95,
  proppbeta = 0.1,
  propzp = 1,
  propsigmap = 1,
  propphibeta = 0.1,
  propzphi = 1,
  propsigmaphi = 1,
  pbeta0 = 0,
  pSigma0 = 1,
  phibeta0 = 0,
  phiSigma0 = 1,
  l0p = 1,
  d0p = 0.01,
  l0phi = 1,
  d0phi = 0.01,
  initial.values = NULL,
  link = "probit",
  printlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markCJS_+3A_enc.mat">Enc.Mat</code></td>
<td>
<p>A matrix of observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions. With a single mark type, encounter histories consist of only non-detections (0) and type 1 encounters (1).</p>
</td></tr>
<tr><td><code id="markCJS_+3A_covs">covs</code></td>
<td>
<p>A data frame of temporal covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of sampling occasions. Covariate names cannot be &quot;time&quot;, &quot;age&quot;, or &quot;h&quot;; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_mod.p">mod.p</code></td>
<td>
<p>Model formula for detection probability (<code class="reqn">p</code>). For example, <code>mod.p=~1</code> specifies no effects (i.e., intercept only), <code>mod.p~time</code> specifies temporal effects, <code>mod.p~age</code> specifies age effects, <code>mod.p~h</code> specifies individual heterogeneity, and <code>mod.p~time+age</code> specifies additive temporal and age effects.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_mod.phi">mod.phi</code></td>
<td>
<p>Model formula for survival probability (<code class="reqn">\phi</code>). For example, <code>mod.phi=~1</code> specifies no effects (i.e., intercept only), <code>mod.phi~time</code> specifies temporal effects, <code>mod.phi~age</code> specifies age effects, <code>mod.phi~h</code> specifies individual heterogeneity, and <code>mod.phi~time+age</code> specifies additive temporal and age effects.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_parms">parms</code></td>
<td>
<p>A character vector giving the names of the parameters and latent variables to monitor. Possible parameters are probit-scale detection probability parameters (&quot;<code>pbeta</code>&quot; for <code class="reqn">p</code> and &quot;<code>phibeta</code>&quot; for <code class="reqn">\phi</code>), probit-scale individual heterogeneity variance terms (&quot;<code>sigma2_zp</code>&quot; for <code class="reqn">p</code> and &quot;<code>sigma2_zphi</code>&quot; for <code class="reqn">\phi</code>), and probit-scale individual effects (&quot;<code>zp</code>&quot; and &quot;<code>zphi</code>&quot;). Latent variable indicators for whether each individual was alive (1) or dead (0) during each sampling occasion (&quot;<code>q</code>&quot;) and the log likelihood (&quot;<code>loglike</code>&quot;) may also be monitored. Setting <code>parms="all"</code> monitors all possible parameters and latent variables.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_nchains">nchains</code></td>
<td>
<p>The number of parallel MCMC chains for the model.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_iter">iter</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_adapt">adapt</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_bin">bin</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= burnin &lt; iter</code>).</p>
</td></tr>
<tr><td><code id="markCJS_+3A_taccept">taccept</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_tuneadjust">tuneadjust</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_proppbeta">proppbeta</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_propzp">propzp</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_propsigmap">propsigmap</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_propphibeta">propphibeta</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_propzphi">propzphi</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_propsigmaphi">propsigmaphi</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_pbeta0">pbeta0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of pbeta ~ multivariateNormal(pbeta0, pSigma0) prior. If <code>pbeta0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>pbeta0 = 0</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_psigma0">pSigma0</code></td>
<td>
<p>Scaler or k x k matrix specifying covariance matrix of pbeta ~ multivariateNormal(pbeta0, pSigma0) prior. If <code>pSigma0</code> is a scaler, then this value is used for all pSigma0[j,j] for j = 1, ..., k (with pSigma[j,l] = 0 for all <code class="reqn">j \ne l</code>). Default is <code>pSigma0 = 1</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_phibeta0">phibeta0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of phibeta ~ multivariateNormal(phibeta0, phiSigma0) prior. If <code>phibeta0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>phibeta0 = 0</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_phisigma0">phiSigma0</code></td>
<td>
<p>Scaler or k x k matrix specifying covariance matrix of phibeta ~ multivariateNormal(phibeta0, phiSigma0) prior. If <code>phiSigma0</code> is a scaler, then this value is used for all phiSigma0[j,j] for j = 1, ..., k (with phiSigma[j,l] = 0 for all <code class="reqn">j \ne l</code>). Default is <code>phiSigma0 = 1</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_l0p">l0p</code></td>
<td>
<p>Specifies &quot;shape&quot; parameter for [sigma2_zp] ~ invGamma(l0p,d0p) prior. Default is <code>l0p = 1</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_d0p">d0p</code></td>
<td>
<p>Specifies &quot;scale&quot; parameter for [sigma2_zp] ~ invGamma(l0p,d0p) prior. Default is <code>d0p = 0.01</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_l0phi">l0phi</code></td>
<td>
<p>Specifies &quot;shape&quot; parameter for [sigma2_zphi] ~ invGamma(l0phi,d0phi) prior. Default is <code>l0phi = 1</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_d0phi">d0phi</code></td>
<td>
<p>Specifies &quot;scale&quot; parameter for [sigma2_zphi] ~ invGamma(l0phi,d0phi) prior. Default is <code>d0phi = 0.01</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_initial.values">initial.values</code></td>
<td>
<p>OOptional list of <code>nchain</code> list(s) specifying initial values for &quot;<code>pbeta</code>&quot;, &quot;<code>phibeta</code>&quot;, &quot;<code>sigma2_zp</code>&quot;, &quot;<code>sigma2_zphi</code>&quot;, &quot;<code>zp</code>&quot;, &quot;<code>zphi</code>&quot;, and &quot;<code>q</code>&quot;. Default is <code>initial.values = NULL</code>, which causes initial values to be generated automatically.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_link">link</code></td>
<td>
<p>Link function for survival and capture probabilities. Only probit link is currently implemented.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
<tr><td><code id="markCJS_+3A_...">...</code></td>
<td>
<p>Additional &quot;<code>parameters</code>&quot; arguments for specifying <code>mod.p</code> and <code>mod.phi</code>. See <code>RMark::<a href="RMark.html#topic+make.design.data">make.design.data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first time <code>markCJS</code> (or <code><a href="#topic+markClosed">markClosed</a></code>) is called, it will likely produce a firewall warning alerting users that R has requested the ability to accept incoming network connections. Incoming network connections are required to use parallel processing as implemented in <code>multimarkCJS</code>. Note that setting <code>parms="all"</code> is required for any <code>markCJS</code> model output to be used in <code><a href="#topic+multimodelCJS">multimodelCJS</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.</p>
</td></tr>
<tr><td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (as specified by <code>mod.p</code> above).</p>
</td></tr>
<tr><td><code>mod.phi</code></td>
<td>
<p>Model formula for survival probability (as specified by <code>mod.phi</code> above).</p>
</td></tr>
<tr><td><code>mod.delta</code></td>
<td>
<p>Formula always <code>NULL</code>; only for internal use in <code><a href="#topic+multimodelCJS">multimodelCJS</a></code>.</p>
</td></tr>
<tr><td><code>DM</code></td>
<td>
<p>A list of design matrices for detection and survival probability respectively generated by <code>mod.p</code> and <code>mod.phi</code>, where DM$p is the design matrix for capture probability (<code class="reqn">p</code>) and DM$phi is the design matrix for survival probability (<code class="reqn">\phi</code>).</p>
</td></tr>
<tr><td><code>initial.values</code></td>
<td>
<p>A list containing the parameter and latent variable values at iteration <code>iter</code> for each chain. Values are provided for &quot;<code>pbeta</code>&quot;, &quot;<code>phibeta</code>&quot;, &quot;<code>sigma2_zp</code>&quot;, &quot;<code>sigma2_zphi</code>&quot;, &quot;<code>zp</code>&quot;, &quot;<code>zphi</code>&quot;, and &quot;<code>q</code>&quot;.</p>
</td></tr>
<tr><td><code>mms</code></td>
<td>
<p>An object of class <code>multimarksetup</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processdata">processdata</a></code>, <code><a href="#topic+multimodelCJS">multimodelCJS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# These examples are excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Simulate open population data using defaults
data &lt;- simdataCJS(delta_1=1,delta_2=0)$Enc.Mat

#Fit default open population model
sim.dot &lt;- markCJS(data)

#Posterior summary for monitored parameters
summary(sim.dot$mcmc)
plot(sim.dot$mcmc)

#Fit ``age'' model with 2 age classes (e.g., juvenile and adult) for survival
#using 'parameters' and 'right' arguments from RMark::make.design.data
sim.age &lt;- markCJS(data,mod.phi=~age,
           parameters=list(Phi=list(age.bins=c(0,1,4))),right=FALSE)
summary(getprobsCJS(sim.age))

</code></pre>

<hr>
<h2 id='markClosed'>Fit closed population abundance models for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type</h2><span id='topic+markClosed'></span>

<h3>Description</h3>

<p>This function fits closed population abundance models for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type using Bayesian analysis methods. Markov chain Monte Carlo (MCMC) is used to draw samples from the joint posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markClosed(
  Enc.Mat,
  covs = data.frame(),
  mod.p = ~1,
  parms = c("pbeta", "N"),
  nchains = 1,
  iter = 12000,
  adapt = 1000,
  bin = 50,
  thin = 1,
  burnin = 2000,
  taccept = 0.44,
  tuneadjust = 0.95,
  proppbeta = 0.1,
  propzp = 1,
  propsigmap = 1,
  npoints = 500,
  a = 25,
  mu0 = 0,
  sigma2_mu0 = 1.75,
  initial.values = NULL,
  printlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markClosed_+3A_enc.mat">Enc.Mat</code></td>
<td>
<p>A matrix of observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions. With a single mark type, encounter histories consist of only non-detections (0) and type 1 encounters (1).</p>
</td></tr>
<tr><td><code id="markClosed_+3A_covs">covs</code></td>
<td>
<p>A data frame of temporal covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of sampling occasions. Covariate names cannot be &quot;time&quot;, &quot;age&quot;, or &quot;h&quot;; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_mod.p">mod.p</code></td>
<td>
<p>Model formula for detection probability. For example, <code>mod.p=~1</code> specifies no effects (i.e., intercept only), <code>mod.p~time</code> specifies temporal effects, <code>mod.p~c</code> specifies behavioral reponse (i.e., trap &quot;happy&quot; or &quot;shy&quot;), <code>mod.p~h</code> specifies individual heterogeneity, and <code>mod.p~time+c</code> specifies additive temporal and behavioral effects.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_parms">parms</code></td>
<td>
<p>A character vector giving the names of the parameters and latent variables to monitor. Possible parameters are logit-scale detection probability parameters (&quot;<code>pbeta</code>&quot;), population abundance (&quot;<code>N</code>&quot;), logit-scale individual heterogeneity variance term (&quot;<code>sigma2_zp</code>&quot;), and logit-scale individual effects (&quot;<code>zp</code>&quot;). The log posterior density (&quot;<code>logPosterior</code>&quot;) may also be monitored. Setting <code>parms="all"</code> monitors all possible parameters and latent variables.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_nchains">nchains</code></td>
<td>
<p>The number of parallel MCMC chains for the model.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_iter">iter</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_adapt">adapt</code></td>
<td>
<p>The number of iterations for proposal distribution adaptation. If <code>adapt = 0</code> then no adaptation occurs.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_bin">bin</code></td>
<td>
<p>Bin length for calculating acceptance rates during adaptive phase (<code>0 &lt; bin &lt;= iter</code>).</p>
</td></tr>
<tr><td><code id="markClosed_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= burnin &lt; iter</code>).</p>
</td></tr>
<tr><td><code id="markClosed_+3A_taccept">taccept</code></td>
<td>
<p>Target acceptance rate during adaptive phase (<code>0 &lt; taccept &lt;= 1</code>). Acceptance rate is monitored every <code>bin</code> iterations. Default is <code>taccept = 0.44</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_tuneadjust">tuneadjust</code></td>
<td>
<p>Adjustment term during adaptive phase (<code>0 &lt; tuneadjust &lt;= 1</code>). If acceptance rate is less than <code>taccept</code>, then proposal term (<code>proppbeta</code>, <code>propzp</code>, or <code>propsigmap</code>) is multiplied by <code>tuneadjust</code>. If acceptance rate is greater than or equal to <code>taccept</code>, then proposal term is divided by <code>tuneadjust</code>. Default is <code>tuneadjust = 0.95</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_proppbeta">proppbeta</code></td>
<td>
<p>Scaler or vector (of length k) specifying the initial standard deviation of the Normal(pbeta[j], proppbeta[j]) proposal distribution. If <code>proppbeta</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>proppbeta = 0.1</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_propzp">propzp</code></td>
<td>
<p>Scaler or vector (of length M) specifying the initial standard deviation of the Normal(zp[i], propzp[i]) proposal distribution. If <code>propzp</code> is a scaler, then this value is used for all i = 1, ..., M individuals. Default is <code>propzp = 1</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_propsigmap">propsigmap</code></td>
<td>
<p>Scaler specifying the initial Gamma(shape = 1/<code>propsigmap</code>, scale = sigma_zp * <code>propsigmap</code>) proposal distribution for sigma_zp = sqrt(sigma2_zp). Default is <code>propsigmap=1</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_npoints">npoints</code></td>
<td>
<p>Number of Gauss-Hermite quadrature points to use for numerical integration. Accuracy increases with number of points, but so does computation time.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_a">a</code></td>
<td>
<p>Scale parameter for [sigma_z] ~ half-Cauchy(a) prior for the individual hetegeneity term sigma_zp = sqrt(sigma2_zp). Default is &ldquo;uninformative&rdquo; <code>a = 25</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_mu0">mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>mu0 = 0</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_sigma2_mu0">sigma2_mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying variance of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>sigma2_mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>sigma2_mu0 = 1.75</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_initial.values">initial.values</code></td>
<td>
<p>Optional list of <code>nchain</code> list(s) specifying initial values for &quot;<code>pbeta</code>&quot;, &quot;<code>zp</code>&quot;, &quot;<code>sigma2_zp</code>&quot;, and &quot;<code>N</code>&quot;. Default is <code>initial.values = NULL</code>, which causes initial values to be generated automatically.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
<tr><td><code id="markClosed_+3A_...">...</code></td>
<td>
<p>Additional &quot;<code>parameters</code>&quot; arguments for specifying <code>mod.p</code>. See <code><a href="RMark.html#topic+make.design.data">make.design.data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first time <code>markClosed</code> (or <code><a href="#topic+markCJS">markCJS</a></code>) is called, it will likely produce a firewall warning alerting users that R has requested the ability to accept incoming network connections. Incoming network connections are required to use parallel processing as implemented in <code>markClosed</code>. Note that setting <code>parms="all"</code> is required for any <code>markClosed</code> model output to be used in <code><a href="#topic+multimodelClosed">multimodelClosed</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.</p>
</td></tr>
<tr><td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (as specified by <code>mod.p</code> above).</p>
</td></tr>
<tr><td><code>mod.delta</code></td>
<td>
<p>Formula always <code>NULL</code>; only for internal use in <code><a href="#topic+multimodelClosed">multimodelClosed</a></code>.</p>
</td></tr>
<tr><td><code>DM</code></td>
<td>
<p>A list of design matrices for detection probability generated for model <code>mod.p</code>, where DM$p is the design matrix for initial capture probability (p) and DM$c is the design matrix for recapture probability (c).</p>
</td></tr>
<tr><td><code>initial.values</code></td>
<td>
<p>A list containing the parameter and latent variable values at iteration <code>iter</code> for each chain. Values are provided for &quot;<code>pbeta</code>&quot;, &quot;<code>zp</code>&quot;, &quot;<code>sigma2_zp</code>&quot;, and &quot;<code>N</code>&quot;.</p>
</td></tr>
<tr><td><code>mms</code></td>
<td>
<p>An object of class <code>multimarksetup</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimodelClosed">multimodelClosed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Run single chain using the default model for simulated ``traditional'' data
data&lt;-simdataClosed(delta_1=1,delta_2=0)$Enc.Mat
sim.dot&lt;-markClosed(data)

#Posterior summary for monitored parameters
summary(sim.dot$mcmc)
plot(sim.dot$mcmc)

</code></pre>

<hr>
<h2 id='markClosedSCR'>Fit spatial population abundance models for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type</h2><span id='topic+markClosedSCR'></span>

<h3>Description</h3>

<p>This function fits spatial population abundance models for &ldquo;traditional&rdquo; capture-mark-recapture data consisting of a single mark type using Bayesian analysis methods. Markov chain Monte Carlo (MCMC) is used to draw samples from the joint posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markClosedSCR(
  Enc.Mat,
  trapCoords,
  studyArea = NULL,
  buffer = NULL,
  ncells = 1024,
  covs = data.frame(),
  mod.p = ~1,
  detection = "half-normal",
  parms = c("pbeta", "N"),
  nchains = 1,
  iter = 12000,
  adapt = 1000,
  bin = 50,
  thin = 1,
  burnin = 2000,
  taccept = 0.44,
  tuneadjust = 0.95,
  proppbeta = 0.1,
  propsigma = 1,
  propcenter = NULL,
  sigma_bounds = NULL,
  mu0 = 0,
  sigma2_mu0 = 1.75,
  initial.values = NULL,
  scalemax = 10,
  printlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markClosedSCR_+3A_enc.mat">Enc.Mat</code></td>
<td>
<p>A matrix containing the observed encounter histories with rows corresponding to individuals and (<code>ntraps</code>*<code>noccas</code>) columns corresponding to traps and sampling occasions.  The first <code>noccas</code> columns correspond to trap 1, the second <code>noccas</code> columns corresopond to trap 2, etc.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_trapcoords">trapCoords</code></td>
<td>
<p>A matrix of dimension <code>ntraps</code> x (2 + <code>noccas</code>) indicating the Cartesian coordinates and operating occasions for the traps, where rows correspond to trap, the first column the x-coordinate (&ldquo;x&rdquo;), and the second column the y-coordinate (&ldquo;y&rdquo;). The last <code>noccas</code> columns indicate whether or not the trap was operating on each of the occasions, where &lsquo;1&rsquo; indciates the trap was operating and &lsquo;0&rsquo; indicates the trap was not operating. Ignored unless <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_studyarea">studyArea</code></td>
<td>
<p>is a 3-column matrix containing the coordinates for the centroids a contiguous grid of cells that define the study area and available habitat. Each row corresponds to a grid cell. The first 2 columns (&ldquo;x&rdquo; and &ldquo;y&rdquo;) indicate the Cartesian x- and y-coordinate for the centroid of each grid cell, and the third column (&ldquo;avail&rdquo;) indicates whether the cell is available habitat (=1) or not (=0). All cells must have the same resolution. If <code>studyArea=NULL</code> (the default) and  <code>mms=NULL</code>, then a square study area grid composed of <code>ncells</code> cells of available habitat is drawn around the bounding box of <code>trapCoords</code> based on <code>buffer</code>. Ignored unless <code>mms=NULL</code>.
Note that rows should be ordered by raster cell order (raster cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom).</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_buffer">buffer</code></td>
<td>
<p>A scaler in same units as <code>trapCoords</code> indicating the buffer around the bounding box of <code>trapCoords</code> for defining the study area when <code>studyArea=NULL</code>.  Ignored unless <code>studyArea=NULL</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_ncells">ncells</code></td>
<td>
<p>The number of grid cells in the study area when <code>studyArea=NULL</code>. The square root of <code>ncells</code> must be a whole number. Default is <code>ncells=1024</code>. Ignored unless <code>studyArea=NULL</code> and <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_covs">covs</code></td>
<td>
<p>A data frame of time- and/or trap-dependent covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of traps times the number of sampling occasions (<code>ntraps*noccas</code>), where the first <code>noccas</code> rows correspond to trap 1, the <code>noccas</code> rows correspond to trap 2, etc. Covariate names cannot be &quot;time&quot;, &quot;age&quot;, or &quot;h&quot;; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_mod.p">mod.p</code></td>
<td>
<p>Model formula for detection probability. For example, <code>mod.p=~1</code> specifies no effects (i.e., intercept only), <code>mod.p~time</code> specifies temporal effects, <code>mod.p~c</code> specifies behavioral reponse (i.e., trap &quot;happy&quot; or &quot;shy&quot;), <code>mod.p~trap</code> specifies trap effects, and <code>mod.p~time+c</code> specifies additive temporal and behavioral effects.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_detection">detection</code></td>
<td>
<p>Model for detection probability as a function of distance from activity centers . Must be &quot;<code>half-normal</code>&quot; (of the form <code class="reqn">\exp{(-d^2 / (2*\sigma^2))}</code>, where <code class="reqn">d</code> is distance) or &quot;<code>exponential</code>&quot; (of the form <code class="reqn">\exp{(-d / \lambda)}</code>).</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_parms">parms</code></td>
<td>
<p>A character vector giving the names of the parameters and latent variables to monitor. Possible parameters are cloglog-scale detection probability parameters (&quot;<code>pbeta</code>&quot;), population abundance (&quot;<code>N</code>&quot;), and cloglog-scale distance term for the detection function (&quot;<code>sigma2_scr</code>&quot; when <code>detection=``half-normal''</code> or &quot;<code>lambda</code>&quot; when <code>detection=``exponential''</code>). Individual activity centers (&quot;<code>centers</code>&quot;) and the log posterior density (&quot;<code>logPosterior</code>&quot;) may also be monitored. Setting <code>parms="all"</code> monitors all possible parameters and latent variables.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_nchains">nchains</code></td>
<td>
<p>The number of parallel MCMC chains for the model.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_iter">iter</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_adapt">adapt</code></td>
<td>
<p>The number of iterations for proposal distribution adaptation. If <code>adapt = 0</code> then no adaptation occurs.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_bin">bin</code></td>
<td>
<p>Bin length for calculating acceptance rates during adaptive phase (<code>0 &lt; bin &lt;= iter</code>).</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= burnin &lt; iter</code>).</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_taccept">taccept</code></td>
<td>
<p>Target acceptance rate during adaptive phase (<code>0 &lt; taccept &lt;= 1</code>). Acceptance rate is monitored every <code>bin</code> iterations. Default is <code>taccept = 0.44</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_tuneadjust">tuneadjust</code></td>
<td>
<p>Adjustment term during adaptive phase (<code>0 &lt; tuneadjust &lt;= 1</code>). If acceptance rate is less than <code>taccept</code>, then proposal term (<code>proppbeta</code> or <code>propsigma</code>) is multiplied by <code>tuneadjust</code>. If acceptance rate is greater than or equal to <code>taccept</code>, then proposal term is divided by <code>tuneadjust</code>. Default is <code>tuneadjust = 0.95</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_proppbeta">proppbeta</code></td>
<td>
<p>Scaler or vector (of length k) specifying the initial standard deviation of the Normal(pbeta[j], proppbeta[j]) proposal distribution. If <code>proppbeta</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>proppbeta = 0.1</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_propsigma">propsigma</code></td>
<td>
<p>Scaler specifying the initial Gamma(shape = 1/<code>propsigma</code>, scale = sigma_scr * <code>propsigma</code>) proposal distribution for sigma_scr = sqrt(sigma2_scr). Default is <code>propsigma=1</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_propcenter">propcenter</code></td>
<td>
<p>Scaler specifying the neighborhood distance when proposing updates to activity centers. When <code>propcenter=NULL</code> (the default), then propcenter = a*10, where a is the cell size for the study area grid, and each cell has (at most) approximately 300 neighbors.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_sigma_bounds">sigma_bounds</code></td>
<td>
<p>Positive vector of length 2 for the lower and upper bounds for the [sigma_scr] ~ Uniform(sigma_bounds[1], sigma_bounds[2]) (or [sqrt(lambda)] when <code>detection=``exponential''</code>) prior for the detection function term sigma_scr = sqrt(sigma2_scr) (or sqrt(lambda)). When <code>sigma_bounds = NULL</code> (the default), then <code>sigma_bounds = c(1.e-6,max(diff(range(studyArea[,"x"])),diff(range(studyArea[,"y"]))))</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_mu0">mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>mu0 = 0</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_sigma2_mu0">sigma2_mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying variance of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>sigma2_mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>sigma2_mu0 = 1.75</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_initial.values">initial.values</code></td>
<td>
<p>Optional list of <code>nchain</code> list(s) specifying initial values for &quot;<code>pbeta</code>&quot;, &quot;<code>N</code>&quot;, &quot;<code>sigma2_scr</code>&quot;, and &quot;<code>centers</code>&quot;. Default is <code>initial.values = NULL</code>, which causes initial values to be generated automatically.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_scalemax">scalemax</code></td>
<td>
<p>Upper bound for internal re-scaling of grid cell centroid coordinates. Default is <code>scalemax=10</code>, which re-scales the centroids to be between 0 and 10.  Re-scaling is done internally to avoid numerical overflows during model fitting.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
<tr><td><code id="markClosedSCR_+3A_...">...</code></td>
<td>
<p>Additional &quot;<code>parameters</code>&quot; arguments for specifying <code>mod.p</code>. See <code><a href="RMark.html#topic+make.design.data">make.design.data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first time <code>markClosedSCR</code> is called, it will likely produce a firewall warning alerting users that R has requested the ability to accept incoming network connections. Incoming network connections are required to use parallel processing as implemented in <code>markClosed</code>. Note that setting <code>parms="all"</code> is required for any <code>markClosed</code> model output to be used in <code><a href="#topic+multimodelClosed">multimodelClosed</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.</p>
</td></tr>
<tr><td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (as specified by <code>mod.p</code> above).</p>
</td></tr>
<tr><td><code>mod.delta</code></td>
<td>
<p>Formula always <code>NULL</code>; only for internal use in <code><a href="#topic+multimodelClosedSCR">multimodelClosedSCR</a></code>.</p>
</td></tr>
<tr><td><code>mod.det</code></td>
<td>
<p>Model formula for detection function (as specified by <code>detection</code> above).</p>
</td></tr>
<tr><td><code>DM</code></td>
<td>
<p>A list of design matrices for detection probability generated for model <code>mod.p</code>, where DM$p is the design matrix for initial capture probability (p) and DM$c is the design matrix for recapture probability (c).</p>
</td></tr>
<tr><td><code>initial.values</code></td>
<td>
<p>A list containing the parameter and latent variable values at iteration <code>iter</code> for each chain. Values are provided for &quot;<code>pbeta</code>&quot;, &quot;<code>N</code>&quot;, &quot;<code>sigma2_scr</code>&quot;, and &quot;<code>centers</code>&quot;.</p>
</td></tr>
<tr><td><code>mms</code></td>
<td>
<p>An object of class <code>multimarkSCRsetup</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Gopalaswamy, A.M., Royle, J.A., Hines, J.E., Singh, P., Jathanna, D., Kumar, N. and Karanth, K.U. 2012. Program SPACECAP: software for estimating animal density using spatially explicit capture-recapture models. <em>Methods in Ecology and Evolution</em> 3:1067-1072.
</p>
<p>King, R., McClintock, B. T., Kidney, D., and Borchers, D. L. 2016. Capture-recapture abundance estimation using a semi-complete data likelihood approach. <em>The Annals of Applied Statistics</em> 10: 264-285 
</p>
<p>Royle, J.A., Karanth, K.U., Gopalaswamy, A.M. and Kumar, N.S. 2009. Bayesian inference in camera trapping studies for a class of spatial capture-recapture models.  <em>Ecology</em> 90: 3233-3244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimodelClosedSCR">multimodelClosedSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Run single chain using the default model for ``traditional'' tiger data of Royle et al (2009)
Enc.Mat&lt;-tiger$Enc.Mat
trapCoords&lt;-tiger$trapCoords
studyArea&lt;-tiger$studyArea
tiger.dot&lt;-markClosedSCR(Enc.Mat,trapCoords,studyArea,iter=100,adapt=50,burnin=50)

#Posterior summary for monitored parameters
summary(tiger.dot$mcmc)
plot(tiger.dot$mcmc)

</code></pre>

<hr>
<h2 id='multimarkCJS'>Fit open population survival models for capture-mark-recapture data consisting of multiple non-invasive marks</h2><span id='topic+multimarkCJS'></span>

<h3>Description</h3>

<p>This function fits Cormack-Jolly-Seber (CJS) open population models for survival probability (<code class="reqn">\phi</code>) and capture probability (<code class="reqn">p</code>) from capture-mark-recapture data consisting of multiple non-invasive marks. Using Bayesian analysis methods, Markov chain Monte Carlo (MCMC) is used to draw samples from the joint posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimarkCJS(
  Enc.Mat,
  data.type = "never",
  covs = data.frame(),
  mms = NULL,
  mod.p = ~1,
  mod.phi = ~1,
  mod.delta = ~type,
  parms = c("pbeta", "phibeta", "delta"),
  nchains = 1,
  iter = 12000,
  adapt = 1000,
  bin = 50,
  thin = 1,
  burnin = 2000,
  taccept = 0.44,
  tuneadjust = 0.95,
  proppbeta = 0.1,
  propzp = 1,
  propsigmap = 1,
  propphibeta = 0.1,
  propzphi = 1,
  propsigmaphi = 1,
  maxnumbasis = 1,
  pbeta0 = 0,
  pSigma0 = 1,
  phibeta0 = 0,
  phiSigma0 = 1,
  l0p = 1,
  d0p = 0.01,
  l0phi = 1,
  d0phi = 0.01,
  a0delta = 1,
  a0alpha = 1,
  b0alpha = 1,
  a0psi = 1,
  b0psi = 1,
  initial.values = NULL,
  known = integer(),
  link = "probit",
  printlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimarkCJS_+3A_enc.mat">Enc.Mat</code></td>
<td>
<p>A matrix of observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions (ignored unless <code>mms=NULL</code>).</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_data.type">data.type</code></td>
<td>
<p>Specifies the encounter history data type. All data types include non-detections (type 0 encounter), type 1 encounter (e.g., left-side), and type 2 encounters (e.g., right-side). When both type 1 and type 2 encounters occur for the same individual within a sampling occasion, these can either be &quot;non-simultaneous&quot; (type 3 encounter) or &quot;simultaneous&quot; (type 4 encounter). Three data types are currently permitted:
</p>
<p><code>data.type="never"</code> indicates both type 1 and type 2 encounters are never observed for the same individual within a sampling occasion, and observed encounter histories therefore include only type 1 or type 2 encounters (e.g., only left- and right-sided photographs were collected). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), and type 2 encounters (2). See <code><a href="#topic+bobcat">bobcat</a></code>. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 3 encounters (3).
</p>
<p><code>data.type="sometimes"</code> indicates both type 1 and type 2 encounters are sometimes observed (e.g., both-sided photographs are sometimes obtained, but not necessarily for all individuals). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). Type 3 encounters can only be observed when an individual has at least one type 4 encounter. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). 
</p>
<p><code>data.type="always"</code> indicates both type 1 and type 2 encounters are always observed, but some encounter histories may still include only type 1 or type 2 encounters. Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4). Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4).</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_covs">covs</code></td>
<td>
<p>A data frame of temporal covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of sampling occasions. Covariate names cannot be &quot;time&quot;, &quot;age&quot;, or &quot;h&quot;; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_mms">mms</code></td>
<td>
<p>An optional object of class <code>multimarksetup-class</code>; if <code>NULL</code> it is created. See <code><a href="#topic+processdata">processdata</a></code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_mod.p">mod.p</code></td>
<td>
<p>Model formula for detection probability (<code class="reqn">p</code>). For example, <code>mod.p=~1</code> specifies no effects (i.e., intercept only), <code>mod.p~time</code> specifies temporal effects, <code>mod.p~age</code> specifies age effects, <code>mod.p~h</code> specifies individual heterogeneity, and <code>mod.p~time+age</code> specifies additive temporal and age effects.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_mod.phi">mod.phi</code></td>
<td>
<p>Model formula for survival probability (<code class="reqn">\phi</code>). For example, <code>mod.phi=~1</code> specifies no effects (i.e., intercept only), <code>mod.phi~time</code> specifies temporal effects, <code>mod.phi~age</code> specifies age effects, <code>mod.phi~h</code> specifies individual heterogeneity, and <code>mod.phi~time+age</code> specifies additive temporal and age effects.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_mod.delta">mod.delta</code></td>
<td>
<p>Model formula for conditional probabilities of type 1 (delta_1) and type 2 (delta_2) encounters, given detection. Currently only <code>mod.delta=~1</code> (i.e., <code class="reqn">\delta_1 = \delta_2</code>) and <code>mod.delta=~type</code> (i.e., <code class="reqn">\delta_1 \ne \delta_2</code>) are implemented.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_parms">parms</code></td>
<td>
<p>A character vector giving the names of the parameters and latent variables to monitor. Possible parameters are probit-scale detection probability parameters (&quot;<code>pbeta</code>&quot; for <code class="reqn">p</code> and &quot;<code>phibeta</code>&quot; for <code class="reqn">\phi</code>), conditional probability of type 1 or type 2 encounter, given detection (&quot;<code>delta</code>)&quot;, probability of simultaneous type 1 and type 2 detection, given both types encountered (&quot;<code>alpha</code>&quot;), probit-scale individual heterogeneity variance terms (&quot;<code>sigma2_zp</code>&quot; for <code class="reqn">p</code> and &quot;<code>sigma2_zphi</code>&quot; for <code class="reqn">\phi</code>), probit-scale individual effects (&quot;<code>zp</code>&quot; and &quot;<code>zphi</code>&quot;), and the probability that a randomly selected individual from the <code>M = nrow(Enc.Mat)</code> observed individuals belongs to the <code class="reqn">n</code> unique individuals encountered at least once (&quot;<code>psi</code>&quot;). Individual encounter history indices (&quot;<code>H</code>&quot;), latent variable indicators for whether each individual was alive (1) or dead (0) during each sampling occasion (&quot;<code>q</code>&quot;), and the log likelihood (&quot;<code>loglike</code>&quot;) may also be monitored. Setting <code>parms="all"</code> monitors all possible parameters and latent variables.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_nchains">nchains</code></td>
<td>
<p>The number of parallel MCMC chains for the model.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_iter">iter</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_adapt">adapt</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_bin">bin</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= burnin &lt; iter</code>).</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_taccept">taccept</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_tuneadjust">tuneadjust</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_proppbeta">proppbeta</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_propzp">propzp</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_propsigmap">propsigmap</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_propphibeta">propphibeta</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_propzphi">propzphi</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_propsigmaphi">propsigmaphi</code></td>
<td>
<p>Ignored; no adaptive phase is needed for &quot;probit&quot; link.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_maxnumbasis">maxnumbasis</code></td>
<td>
<p>Maximum number of basis vectors to use when proposing latent history frequency updates. Default is <code>maxnumbasis = 1</code>, but higher values can potentially improve mixing.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_pbeta0">pbeta0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of pbeta ~ multivariateNormal(pbeta0, pSigma0) prior. If <code>pbeta0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>pbeta0 = 0</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_psigma0">pSigma0</code></td>
<td>
<p>Scaler or k x k matrix specifying covariance matrix of pbeta ~ multivariateNormal(pbeta0, pSigma0) prior. If <code>pSigma0</code> is a scaler, then this value is used for all pSigma0[j,j] for j = 1, ..., k (with pSigma[j,l] = 0 for all <code class="reqn">j \ne l</code>). Default is <code>pSigma0 = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_phibeta0">phibeta0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of phibeta ~ multivariateNormal(phibeta0, phiSigma0) prior. If <code>phibeta0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>phibeta0 = 0</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_phisigma0">phiSigma0</code></td>
<td>
<p>Scaler or k x k matrix specifying covariance matrix of phibeta ~ multivariateNormal(phibeta0, phiSigma0) prior. If <code>phiSigma0</code> is a scaler, then this value is used for all phiSigma0[j,j] for j = 1, ..., k (with phiSigma[j,l] = 0 for all <code class="reqn">j \ne l</code>). Default is <code>phiSigma0 = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_l0p">l0p</code></td>
<td>
<p>Specifies &quot;shape&quot; parameter for [sigma2_zp] ~ invGamma(l0p,d0p) prior. Default is <code>l0p = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_d0p">d0p</code></td>
<td>
<p>Specifies &quot;scale&quot; parameter for [sigma2_zp] ~ invGamma(l0p,d0p) prior. Default is <code>d0p = 0.01</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_l0phi">l0phi</code></td>
<td>
<p>Specifies &quot;shape&quot; parameter for [sigma2_zphi] ~ invGamma(l0phi,d0phi) prior. Default is <code>l0phi = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_d0phi">d0phi</code></td>
<td>
<p>Specifies &quot;scale&quot; parameter for [sigma2_zphi] ~ invGamma(l0phi,d0phi) prior. Default is <code>d0phi = 0.01</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_a0delta">a0delta</code></td>
<td>
<p>Scaler or vector (of length d) specifying the prior for the conditional (on detection) probability of type 1 (delta_1), type 2 (delta_2), and both type 1 and type 2 encounters (1-delta_1-delta_2). If <code>a0delta</code> is a scaler, then this value is used for all a0delta[j] for j = 1, ..., d. For <code>mod.delta=~type</code>, d=3 with [delta_1, delta_2, 1-delta_1-delta_2] ~ Dirichlet(a0delta) prior. For <code>mod.delta=~1</code>, d=2 with [tau] ~ Beta(a0delta[1],a0delta[2]) prior, where (delta_1,delta_2,1-delta_1-delta_2) = (tau/2,tau/2,1-tau). See McClintock et al. (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_a0alpha">a0alpha</code></td>
<td>
<p>Specifies &quot;shape1&quot; parameter for [alpha] ~ Beta(a0alpha, b0alpha) prior. Only applicable when <code>data.type = "sometimes"</code>. Default is <code>a0alpha = 1</code>. Note that when <code>a0alpha = 1</code> and <code>b0alpha = 1</code>, then [alpha] ~ Unif(0,1).</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_b0alpha">b0alpha</code></td>
<td>
<p>Specifies &quot;shape2&quot; parameter for [alpha] ~ Beta(a0alpha, b0alpha) prior. Only applicable when <code>data.type = "sometimes"</code>. Default is <code>b0alpha = 1</code>. Note that when <code>a0alpha = 1</code> and <code>b0alpha = 1</code>, then [alpha] ~ Unif(0,1).</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_a0psi">a0psi</code></td>
<td>
<p>Specifies &quot;shape1&quot; parameter for [psi] ~ Beta(a0psi,b0psi) prior. Default is <code>a0psi = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_b0psi">b0psi</code></td>
<td>
<p>Specifies &quot;shape2&quot; parameter for [psi] ~ Beta(a0psi,b0psi) prior. Default is <code>b0psi = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_initial.values">initial.values</code></td>
<td>
<p>Optional list of <code>nchain</code> list(s) specifying initial values for parameters and latent variables. Default is <code>initial.values = NULL</code>, which causes initial values to be generated automatically. In addition to the parameters (&quot;<code>pbeta</code>&quot;, &quot;<code>phibeta</code>&quot;, &quot;<code>delta_1</code>&quot;, &quot;<code>delta_2</code>&quot;, &quot;<code>alpha</code>&quot;, &quot;<code>sigma2_zp</code>&quot;, &quot;<code>sigma2_zphi</code>&quot;, &quot;<code>zp</code>&quot;, &quot;<code>zphi</code>&quot;, and &quot;<code>psi</code>&quot;), initial values can be specified for the initial latent history frequencies (&quot;<code>x</code>&quot;), initial individual encounter history indices (&quot;<code>H</code>&quot;), and initial latent variable indicators for whether each individual was alive (1) or dead (0) during each sampling occasion (&quot;<code>q</code>&quot;).</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_known">known</code></td>
<td>
<p>Optional integer vector indicating whether the encounter history of an individual is known with certainty (i.e., the observed encounter history is the true encounter history). Encounter histories with at least one type 4 encounter are automatically assumed to be known, and <code>known</code> does not need to be specified unless there exist encounter histories that do not contain a type 4 encounter that happen to be known with certainty (e.g., from independent telemetry studies). If specified, <code>known = c(v_1,v_2,...,v_M)</code> must be a vector of length <code>M = nrow(Enc.Mat)</code> where <code>v_i = 1</code> if the encounter history for individual <code>i</code> is known (<code>v_i = 0</code> otherwise). Note that known all-zero encounter histories (e.g., &lsquo;000&rsquo;) are ignored.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_link">link</code></td>
<td>
<p>Link function for survival and capture probabilities. Only probit link is currently implemented.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
<tr><td><code id="multimarkCJS_+3A_...">...</code></td>
<td>
<p>Additional &quot;<code>parameters</code>&quot; arguments for specifying <code>mod.p</code> and <code>mod.phi</code>. See <code>RMark::<a href="RMark.html#topic+make.design.data">make.design.data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first time <code>multimarkCJS</code> (or <code><a href="#topic+multimarkClosed">multimarkClosed</a></code>) is called, it will likely produce a firewall warning alerting users that R has requested the ability to accept incoming network connections. Incoming network connections are required to use parallel processing as implemented in <code>multimarkCJS</code>. Note that setting <code>parms="all"</code> is required for any <code>multimarkCJS</code> model output to be used in <code><a href="#topic+multimodelCJS">multimodelCJS</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.</p>
</td></tr>
<tr><td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (as specified by <code>mod.p</code> above).</p>
</td></tr>
<tr><td><code>mod.phi</code></td>
<td>
<p>Model formula for survival probability (as specified by <code>mod.phi</code> above).</p>
</td></tr>
<tr><td><code>mod.delta</code></td>
<td>
<p>Formula always <code>NULL</code>; only for internal use in <code><a href="#topic+multimodelCJS">multimodelCJS</a></code>.</p>
</td></tr>
<tr><td><code>DM</code></td>
<td>
<p>A list of design matrices for detection and survival probability respectively generated by <code>mod.p</code> and <code>mod.phi</code>, where DM$p is the design matrix for capture probability (<code class="reqn">p</code>) and DM$phi is the design matrix for survival probability (<code class="reqn">\phi</code>).</p>
</td></tr>
<tr><td><code>initial.values</code></td>
<td>
<p>A list containing the parameter and latent variable values at iteration <code>iter</code> for each chain. Values are provided for &quot;<code>pbeta</code>&quot;, &quot;<code>phibeta</code>&quot;, &quot;<code>delta_1</code>&quot;, &quot;<code>delta_2</code>&quot;, &quot;<code>alpha</code>&quot;, &quot;<code>sigma2_zp</code>&quot; &quot;<code>sigma2_zphi</code>&quot;, &quot;<code>zp</code>&quot;, &quot;<code>zphi</code>&quot;, &quot;<code>psi</code>&quot;, &quot;<code>x</code>&quot;, &quot;<code>H</code>&quot;, and &quot;<code>q</code>&quot;.</p>
</td></tr>
<tr><td><code>mms</code></td>
<td>
<p>An object of class <code>multimarksetup</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Bonner, S. J., and Holmberg J. 2013. Mark-recapture with multiple, non-invasive marks. <em>Biometrics</em> 69: 766-775.
</p>
<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>
<p>McClintock, B. T., Bailey, L. L., Dreher, B. P., and Link, W. A. 2014. Probit models for capture-recapture data subject to imperfect detection, individual heterogeneity and misidentification. <em>The Annals of Applied Statistics</em> 8: 2461-2484.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processdata">processdata</a></code>, <code><a href="#topic+multimodelCJS">multimodelCJS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Simulate open population data using defaults
data &lt;- simdataCJS()

#Fit default open population model
sim.dot &lt;- multimarkCJS(data$Enc.Mat)

#Posterior summary for monitored parameters
summary(sim.dot$mcmc)
plot(sim.dot$mcmc)

#' #Fit ``age'' model with 2 age classes (e.g., juvenile and adult) for survival
#using 'parameters' and 'right' arguments from RMark::make.design.data
sim.age &lt;- multimarkCJS(data$Enc.Mat,mod.phi=~age,
           parameters=list(Phi=list(age.bins=c(0,1,4))),right=FALSE)
summary(getprobsCJS(sim.age))

</code></pre>

<hr>
<h2 id='multimarkClosed'>Fit closed population abundance models for capture-mark-recapture data consisting of multiple non-invasive marks</h2><span id='topic+multimarkClosed'></span>

<h3>Description</h3>

<p>This function fits closed population abundance models for capture-mark-recapture data consisting of multiple non-invasive marks using Bayesian analysis methods. Markov chain Monte Carlo (MCMC) is used to draw samples from the joint posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimarkClosed(
  Enc.Mat,
  data.type = "never",
  covs = data.frame(),
  mms = NULL,
  mod.p = ~1,
  mod.delta = ~type,
  parms = c("pbeta", "delta", "N"),
  nchains = 1,
  iter = 12000,
  adapt = 1000,
  bin = 50,
  thin = 1,
  burnin = 2000,
  taccept = 0.44,
  tuneadjust = 0.95,
  proppbeta = 0.1,
  propzp = 1,
  propsigmap = 1,
  npoints = 500,
  maxnumbasis = 1,
  a0delta = 1,
  a0alpha = 1,
  b0alpha = 1,
  a = 25,
  mu0 = 0,
  sigma2_mu0 = 1.75,
  a0psi = 1,
  b0psi = 1,
  initial.values = NULL,
  known = integer(),
  printlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimarkClosed_+3A_enc.mat">Enc.Mat</code></td>
<td>
<p>A matrix of observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions (ignored unless <code>mms=NULL</code>).</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_data.type">data.type</code></td>
<td>
<p>Specifies the encounter history data type. All data types include non-detections (type 0 encounter), type 1 encounter (e.g., left-side), and type 2 encounters (e.g., right-side). When both type 1 and type 2 encounters occur for the same individual within a sampling occasion, these can either be &quot;non-simultaneous&quot; (type 3 encounter) or &quot;simultaneous&quot; (type 4 encounter). Three data types are currently permitted:
</p>
<p><code>data.type="never"</code> indicates both type 1 and type 2 encounters are never observed for the same individual within a sampling occasion, and observed encounter histories therefore include only type 1 or type 2 encounters (e.g., only left- and right-sided photographs were collected). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), and type 2 encounters (2). See <code><a href="#topic+bobcat">bobcat</a></code>. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 3 encounters (3).
</p>
<p><code>data.type="sometimes"</code> indicates both type 1 and type 2 encounters are sometimes observed (e.g., both-sided photographs are sometimes obtained, but not necessarily for all individuals). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). Type 3 encounters can only be observed when an individual has at least one type 4 encounter. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). 
</p>
<p><code>data.type="always"</code> indicates both type 1 and type 2 encounters are always observed, but some encounter histories may still include only type 1 or type 2 encounters. Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4). Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4).</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_covs">covs</code></td>
<td>
<p>A data frame of temporal covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of sampling occasions. Covariate names cannot be &quot;time&quot;, &quot;c&quot;, or &quot;h&quot;; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_mms">mms</code></td>
<td>
<p>An optional object of class <code>multimarksetup-class</code>; if <code>NULL</code> it is created. See <code><a href="#topic+processdata">processdata</a></code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_mod.p">mod.p</code></td>
<td>
<p>Model formula for detection probability. For example, <code>mod.p=~1</code> specifies no effects (i.e., intercept only), <code>mod.p~time</code> specifies temporal effects, <code>mod.p~c</code> specifies behavioral reponse (i.e., trap &quot;happy&quot; or &quot;shy&quot;), <code>mod.p~h</code> specifies individual heterogeneity, and <code>mod.p~time+c</code> specifies additive temporal and behavioral effects.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_mod.delta">mod.delta</code></td>
<td>
<p>Model formula for conditional probabilities of type 1 (delta_1) and type 2 (delta_2) encounters, given detection. Currently only <code>mod.delta=~1</code> (i.e., <code class="reqn">\delta_1 = \delta_2</code>) and <code>mod.delta=~type</code> (i.e., <code class="reqn">\delta_1 \ne \delta_2</code>) are implemented.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_parms">parms</code></td>
<td>
<p>A character vector giving the names of the parameters and latent variables to monitor. Possible parameters are logit-scale detection probability parameters (&quot;<code>pbeta</code>&quot;), population abundance (&quot;<code>N</code>&quot;), conditional probability of type 1 or type 2 encounter, given detection (&quot;<code>delta</code>)&quot;, probability of simultaneous type 1 and type 2 detection, given both types encountered (&quot;<code>alpha</code>&quot;), logit-scale individual heterogeneity variance term (&quot;<code>sigma2_zp</code>&quot;), logit-scale individual effects (&quot;<code>zp</code>&quot;), and the probability that a randomly selected individual from the <code>M = nrow(Enc.Mat)</code> observed individuals belongs to the <code class="reqn">n</code> unique individuals encountered at least once (&quot;<code>psi</code>&quot;). Individual encounter history indices (&quot;<code>H</code>&quot;) and the log posterior density (&quot;<code>logPosterior</code>&quot;) may also be monitored. Setting <code>parms="all"</code> monitors all possible parameters and latent variables.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_nchains">nchains</code></td>
<td>
<p>The number of parallel MCMC chains for the model.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_iter">iter</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_adapt">adapt</code></td>
<td>
<p>The number of iterations for proposal distribution adaptation. If <code>adapt = 0</code> then no adaptation occurs.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_bin">bin</code></td>
<td>
<p>Bin length for calculating acceptance rates during adaptive phase (<code>0 &lt; bin &lt;= iter</code>).</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= burnin &lt; iter</code>).</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_taccept">taccept</code></td>
<td>
<p>Target acceptance rate during adaptive phase (<code>0 &lt; taccept &lt;= 1</code>). Acceptance rate is monitored every <code>bin</code> iterations. Default is <code>taccept = 0.44</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_tuneadjust">tuneadjust</code></td>
<td>
<p>Adjustment term during adaptive phase (<code>0 &lt; tuneadjust &lt;= 1</code>). If acceptance rate is less than <code>taccept</code>, then proposal term (<code>proppbeta</code>, <code>propzp</code>, or <code>propsigmap</code>) is multiplied by <code>tuneadjust</code>. If acceptance rate is greater than or equal to <code>taccept</code>, then proposal term is divided by <code>tuneadjust</code>. Default is <code>tuneadjust = 0.95</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_proppbeta">proppbeta</code></td>
<td>
<p>Scaler or vector (of length k) specifying the initial standard deviation of the Normal(pbeta[j], proppbeta[j]) proposal distribution. If <code>proppbeta</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>proppbeta = 0.1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_propzp">propzp</code></td>
<td>
<p>Scaler or vector (of length M) specifying the initial standard deviation of the Normal(zp[i], propzp[i]) proposal distribution. If <code>propzp</code> is a scaler, then this value is used for all i = 1, ..., M individuals. Default is <code>propzp = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_propsigmap">propsigmap</code></td>
<td>
<p>Scaler specifying the initial Gamma(shape = 1/<code>propsigmap</code>, scale = sigma_zp * <code>propsigmap</code>) proposal distribution for sigma_zp = sqrt(sigma2_zp). Default is <code>propsigmap=1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_npoints">npoints</code></td>
<td>
<p>Number of Gauss-Hermite quadrature points to use for numerical integration. Accuracy increases with number of points, but so does computation time.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_maxnumbasis">maxnumbasis</code></td>
<td>
<p>Maximum number of basis vectors to use when proposing latent history frequency updates. Default is <code>maxnumbasis = 1</code>, but higher values can potentially improve mixing.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_a0delta">a0delta</code></td>
<td>
<p>Scaler or vector (of length d) specifying the prior for the conditional (on detection) probability of type 1 (delta_1), type 2 (delta_2), and both type 1 and type 2 encounters (1-delta_1-delta_2). If <code>a0delta</code> is a scaler, then this value is used for all a0delta[j] for j = 1, ..., d. For <code>mod.delta=~type</code>, d=3 with [delta_1, delta_2, 1-delta_1-delta_2] ~ Dirichlet(a0delta) prior. For <code>mod.delta=~1</code>, d=2 with [tau] ~ Beta(a0delta[1],a0delta[2]) prior, where (delta_1,delta_2,1-delta_1-delta_2) = (tau/2,tau/2,1-tau). See McClintock et al. (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_a0alpha">a0alpha</code></td>
<td>
<p>Specifies &quot;shape1&quot; parameter for [alpha] ~ Beta(a0alpha, b0alpha) prior. Only applicable when <code>data.type = "sometimes"</code>. Default is <code>a0alpha = 1</code>. Note that when <code>a0alpha = 1</code> and <code>b0alpha = 1</code>, then [alpha] ~ Unif(0,1).</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_b0alpha">b0alpha</code></td>
<td>
<p>Specifies &quot;shape2&quot; parameter for [alpha] ~ Beta(a0alpha, b0alpha) prior. Only applicable when <code>data.type = "sometimes"</code>. Default is <code>b0alpha = 1</code>. Note that when <code>a0alpha = 1</code> and <code>b0alpha = 1</code>, then [alpha] ~ Unif(0,1).</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_a">a</code></td>
<td>
<p>Scale parameter for [sigma_z] ~ half-Cauchy(a) prior for the individual hetegeneity term sigma_zp = sqrt(sigma2_zp). Default is &ldquo;uninformative&rdquo; <code>a = 25</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_mu0">mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>mu0 = 0</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_sigma2_mu0">sigma2_mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying variance of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>sigma2_mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>sigma2_mu0 = 1.75</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_a0psi">a0psi</code></td>
<td>
<p>Specifies &quot;shape1&quot; parameter for [psi] ~ Beta(a0psi,b0psi) prior. Default is <code>a0psi = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_b0psi">b0psi</code></td>
<td>
<p>Specifies &quot;shape2&quot; parameter for [psi] ~ Beta(a0psi,b0psi) prior. Default is <code>b0psi = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_initial.values">initial.values</code></td>
<td>
<p>Optional list of <code>nchain</code> list(s) specifying initial values for parameters and latent variables. Default is <code>initial.values = NULL</code>, which causes initial values to be generated automatically. In addition to the parameters (&quot;<code>pbeta</code>&quot;, &quot;<code>N</code>&quot;, &quot;<code>delta_1</code>&quot;, &quot;<code>delta_2</code>&quot;, &quot;<code>alpha</code>&quot;, &quot;<code>sigma2_zp</code>&quot;, &quot;<code>zp</code>&quot;, and &quot;<code>psi</code>&quot;), initial values can be specified for the initial latent history frequencies (&quot;<code>x</code>&quot;) and initial individual encounter history indices (&quot;<code>H</code>&quot;).</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_known">known</code></td>
<td>
<p>Optional integer vector indicating whether the encounter history of an individual is known with certainty (i.e., the observed encounter history is the true encounter history). Encounter histories with at least one type 4 encounter are automatically assumed to be known, and <code>known</code> does not need to be specified unless there exist encounter histories that do not contain a type 4 encounter that happen to be known with certainty (e.g., from independent telemetry studies). If specified, <code>known = c(v_1,v_2,...,v_M)</code> must be a vector of length <code>M = nrow(Enc.Mat)</code> where <code>v_i = 1</code> if the encounter history for individual <code>i</code> is known (<code>v_i = 0</code> otherwise). Note that known all-zero encounter histories (e.g., &lsquo;000&rsquo;) are ignored.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosed_+3A_...">...</code></td>
<td>
<p>Additional &quot;<code>parameters</code>&quot; arguments for specifying <code>mod.p</code>. See <code><a href="RMark.html#topic+make.design.data">make.design.data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first time <code>multimarkClosed</code> (or <code><a href="#topic+multimarkCJS">multimarkCJS</a></code>) is called, it will likely produce a firewall warning alerting users that R has requested the ability to accept incoming network connections. Incoming network connections are required to use parallel processing as implemented in <code>multimarkClosed</code>. Note that setting <code>parms="all"</code> is required for any <code>multimarkClosed</code> model output to be used in <code><a href="#topic+multimodelClosed">multimodelClosed</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.</p>
</td></tr>
<tr><td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (as specified by <code>mod.p</code> above).</p>
</td></tr>
<tr><td><code>mod.delta</code></td>
<td>
<p>Model formula for conditional probability of type 1 or type 2 encounter, given detection (as specified by <code>mod.delta</code> above).</p>
</td></tr>
<tr><td><code>DM</code></td>
<td>
<p>A list of design matrices for detection probability generated for model <code>mod.p</code>, where DM$p is the design matrix for initial capture probability (p) and DM$c is the design matrix for recapture probability (c).</p>
</td></tr>
<tr><td><code>initial.values</code></td>
<td>
<p>A list containing the parameter and latent variable values at iteration <code>iter</code> for each chain. Values are provided for &quot;<code>pbeta</code>&quot;, &quot;<code>N</code>&quot;, &quot;<code>delta_1</code>&quot;, &quot;<code>delta_2</code>&quot;, &quot;<code>alpha</code>&quot;, &quot;<code>sigma2_zp</code>&quot;, &quot;<code>zp</code>&quot;, &quot;<code>psi</code>&quot;, &quot;<code>x</code>&quot;, and &quot;<code>H</code>&quot;.</p>
</td></tr>
<tr><td><code>mms</code></td>
<td>
<p>An object of class <code>multimarksetup</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Bonner, S. J., and Holmberg J. 2013. Mark-recapture with multiple, non-invasive marks. <em>Biometrics</em> 69: 766-775.
</p>
<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>
<p>McClintock, B. T., Bailey, L. L., Dreher, B. P., and Link, W. A. 2014. Probit models for capture-recapture data subject to imperfect detection, individual heterogeneity and misidentification. <em>The Annals of Applied Statistics</em> 8: 2461-2484.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bobcat">bobcat</a></code>, <code><a href="#topic+processdata">processdata</a></code>, <code><a href="#topic+multimodelClosed">multimodelClosed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Run single chain using the default model for bobcat data
bobcat.dot&lt;-multimarkClosed(bobcat)

#Posterior summary for monitored parameters
summary(bobcat.dot$mcmc)
plot(bobcat.dot$mcmc)

</code></pre>

<hr>
<h2 id='multimarkClosedSCR'>Fit spatially-explicit population abundance models for capture-mark-recapture data consisting of multiple non-invasive marks</h2><span id='topic+multimarkClosedSCR'></span>

<h3>Description</h3>

<p>This function fits spatially-explicit population abundance models for capture-mark-recapture data consisting of multiple non-invasive marks using Bayesian analysis methods. Markov chain Monte Carlo (MCMC) is used to draw samples from the joint posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimarkClosedSCR(
  Enc.Mat,
  trapCoords,
  studyArea = NULL,
  buffer = NULL,
  ncells = 1024,
  data.type = "never",
  covs = data.frame(),
  mms = NULL,
  mod.p = ~1,
  mod.delta = ~type,
  detection = "half-normal",
  parms = c("pbeta", "delta", "N"),
  nchains = 1,
  iter = 12000,
  adapt = 1000,
  bin = 50,
  thin = 1,
  burnin = 2000,
  taccept = 0.44,
  tuneadjust = 0.95,
  proppbeta = 0.1,
  propsigma = 1,
  propcenter = NULL,
  maxnumbasis = 1,
  a0delta = 1,
  a0alpha = 1,
  b0alpha = 1,
  sigma_bounds = NULL,
  mu0 = 0,
  sigma2_mu0 = 1.75,
  a0psi = 1,
  b0psi = 1,
  initial.values = NULL,
  known = integer(),
  scalemax = 10,
  printlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimarkClosedSCR_+3A_enc.mat">Enc.Mat</code></td>
<td>
<p>A matrix containing the observed encounter histories with rows corresponding to individuals and (<code>ntraps</code>*<code>noccas</code>) columns corresponding to traps and sampling occasions.  The first <code>noccas</code> columns correspond to trap 1, the second <code>noccas</code> columns corresopond to trap 2, etc. Ignored unless <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_trapcoords">trapCoords</code></td>
<td>
<p>A matrix of dimension <code>ntraps</code> x (2 + <code>noccas</code>) indicating the Cartesian coordinates and operating occasions for the traps, where rows correspond to trap, the first column the x-coordinate (&ldquo;x&rdquo;), and the second column the y-coordinate (&ldquo;y&rdquo;). The last <code>noccas</code> columns indicate whether or not the trap was operating on each of the occasions, where &lsquo;1&rsquo; indciates the trap was operating and &lsquo;0&rsquo; indicates the trap was not operating. Ignored unless <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_studyarea">studyArea</code></td>
<td>
<p>is a 3-column matrix containing the coordinates for the centroids of a contiguous grid of cells that define the study area and available habitat. Each row corresponds to a grid cell. The first 2 columns (&ldquo;x&rdquo; and &ldquo;y&rdquo;) indicate the Cartesian x- and y-coordinate for the centroid of each grid cell, and the third column (&ldquo;avail&rdquo;) indicates whether the cell is available habitat (=1) or not (=0). All cells must be square and have the same resolution. If <code>studyArea=NULL</code> (the default) and  <code>mms=NULL</code>, then a square study area grid composed of <code>ncells</code> cells of available habitat is drawn around the bounding box of <code>trapCoords</code> based on <code>buffer</code>. Ignored unless <code>mms=NULL</code>.
Note that rows should be ordered in raster cell order (raster cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom).</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_buffer">buffer</code></td>
<td>
<p>A scaler in same units as <code>trapCoords</code> indicating the buffer around the bounding box of <code>trapCoords</code> for defining the study area when <code>studyArea=NULL</code>.  Ignored unless <code>studyArea=NULL</code> and <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_ncells">ncells</code></td>
<td>
<p>The number of grid cells in the study area when <code>studyArea=NULL</code>. The square root of <code>ncells</code> must be a whole number. Default is <code>ncells=1024</code>. Ignored unless <code>studyArea=NULL</code> and <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_data.type">data.type</code></td>
<td>
<p>Specifies the encounter history data type. All data types include non-detections (type 0 encounter), type 1 encounter (e.g., left-side), and type 2 encounters (e.g., right-side). When both type 1 and type 2 encounters occur for the same individual within a sampling occasion, these can either be &quot;non-simultaneous&quot; (type 3 encounter) or &quot;simultaneous&quot; (type 4 encounter). Three data types are currently permitted:
</p>
<p><code>data.type="never"</code> indicates both type 1 and type 2 encounters are never observed for the same individual within a sampling occasion, and observed encounter histories therefore include only type 1 or type 2 encounters (e.g., only left- and right-sided photographs were collected). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), and type 2 encounters (2). See <code><a href="#topic+bobcat">bobcat</a></code>. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 3 encounters (3).
</p>
<p><code>data.type="sometimes"</code> indicates both type 1 and type 2 encounters are sometimes observed (e.g., both-sided photographs are sometimes obtained, but not necessarily for all individuals). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). Type 3 encounters can only be observed when an individual has at least one type 4 encounter. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). 
</p>
<p><code>data.type="always"</code> indicates both type 1 and type 2 encounters are always observed, but some encounter histories may still include only type 1 or type 2 encounters. Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4). Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4).</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_covs">covs</code></td>
<td>
<p>A data frame of time- and/or trap-dependent covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of traps times the number of sampling occasions (<code>ntraps*noccas</code>), where the first <code>noccas</code> rows correspond to trap 1, the second <code>noccas</code> rows correspond to trap 2, etc. Covariate names cannot be &quot;time&quot;, &quot;age&quot;, or &quot;h&quot;; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_mms">mms</code></td>
<td>
<p>An optional object of class <code>multimarkSCRsetup-class</code>; if <code>NULL</code> it is created. See <code><a href="#topic+processdataSCR">processdataSCR</a></code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_mod.p">mod.p</code></td>
<td>
<p>Model formula for detection probability as a function of distance from activity centers. For example, <code>mod.p=~1</code> specifies no effects (i.e., intercept only) other than distance, <code>mod.p~time</code> specifies temporal effects, <code>mod.p~c</code> specifies behavioral reponse (i.e., trap &quot;happy&quot; or &quot;shy&quot;), <code>mod.p~trap</code> specifies trap effects, and <code>mod.p~time+c</code> specifies additive temporal and behavioral effects.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_mod.delta">mod.delta</code></td>
<td>
<p>Model formula for conditional probabilities of type 1 (delta_1) and type 2 (delta_2) encounters, given detection. Currently only <code>mod.delta=~1</code> (i.e., <code class="reqn">\delta_1 = \delta_2</code>) and <code>mod.delta=~type</code> (i.e., <code class="reqn">\delta_1 \ne \delta_2</code>) are implemented.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_detection">detection</code></td>
<td>
<p>Model for detection probability as a function of distance from activity centers . Must be &quot;<code>half-normal</code>&quot; (of the form <code class="reqn">\exp{(-d^2 / (2*\sigma^2))}</code>, where <code class="reqn">d</code> is distance) or &quot;<code>exponential</code>&quot; (of the form <code class="reqn">\exp{(-d / \lambda)}</code>).</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_parms">parms</code></td>
<td>
<p>A character vector giving the names of the parameters and latent variables to monitor. Possible parameters are cloglog-scale detection probability parameters (&quot;<code>pbeta</code>&quot;), population abundance (&quot;<code>N</code>&quot;), conditional probability of type 1 or type 2 encounter, given detection (&quot;<code>delta</code>)&quot;, probability of simultaneous type 1 and type 2 detection, given both types encountered (&quot;<code>alpha</code>&quot;), cloglog-scale distance term for the detection function (&quot;<code>sigma2_scr</code>&quot; when <code>detection=``half-normal''</code> or &quot;<code>lambda</code>&quot; when <code>detection=``exponential''</code>), and the probability that a randomly selected individual from the <code>M = nrow(Enc.Mat)</code> observed individuals belongs to the <code class="reqn">n</code> unique individuals encountered at least once (&quot;<code>psi</code>&quot;). Individual activity centers (&quot;<code>centers</code>&quot;), encounter history indices (&quot;<code>H</code>&quot;), and the log posterior density (&quot;<code>logPosterior</code>&quot;) may also be monitored. Setting <code>parms="all"</code> monitors all possible parameters and latent variables.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_nchains">nchains</code></td>
<td>
<p>The number of parallel MCMC chains for the model.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_iter">iter</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_adapt">adapt</code></td>
<td>
<p>The number of iterations for proposal distribution adaptation. If <code>adapt = 0</code> then no adaptation occurs.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_bin">bin</code></td>
<td>
<p>Bin length for calculating acceptance rates during adaptive phase (<code>0 &lt; bin &lt;= iter</code>).</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= burnin &lt; iter</code>).</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_taccept">taccept</code></td>
<td>
<p>Target acceptance rate during adaptive phase (<code>0 &lt; taccept &lt;= 1</code>). Acceptance rate is monitored every <code>bin</code> iterations. Default is <code>taccept = 0.44</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_tuneadjust">tuneadjust</code></td>
<td>
<p>Adjustment term during adaptive phase (<code>0 &lt; tuneadjust &lt;= 1</code>). If acceptance rate is less than <code>taccept</code>, then proposal term (<code>proppbeta</code> or <code>propsigma</code>) is multiplied by <code>tuneadjust</code>. If acceptance rate is greater than or equal to <code>taccept</code>, then proposal term is divided by <code>tuneadjust</code>. Default is <code>tuneadjust = 0.95</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_proppbeta">proppbeta</code></td>
<td>
<p>Scaler or vector (of length k) specifying the initial standard deviation of the Normal(pbeta[j], proppbeta[j]) proposal distribution. If <code>proppbeta</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>proppbeta = 0.1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_propsigma">propsigma</code></td>
<td>
<p>Scaler specifying the initial Gamma(shape = 1/<code>propsigma</code>, scale = sigma_scr * <code>propsigma</code>) proposal distribution for sigma_scr = sqrt(sigma2_scr) (or sqrt(lambda) = lambda if <code>detection=``exponential''</code>). Default is <code>propsigma=1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_propcenter">propcenter</code></td>
<td>
<p>Scaler specifying the neighborhood distance when proposing updates to activity centers. When <code>propcenter=NULL</code> (the default), then propcenter = a*10, where a is the cell size for the study area grid, and each cell has (at most) approximately 300 neighbors.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_maxnumbasis">maxnumbasis</code></td>
<td>
<p>Maximum number of basis vectors to use when proposing latent history frequency updates. Default is <code>maxnumbasis = 1</code>, but higher values can potentially improve mixing.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_a0delta">a0delta</code></td>
<td>
<p>Scaler or vector (of length d) specifying the prior for the conditional (on detection) probability of type 1 (delta_1), type 2 (delta_2), and both type 1 and type 2 encounters (1-delta_1-delta_2). If <code>a0delta</code> is a scaler, then this value is used for all a0delta[j] for j = 1, ..., d. For <code>mod.delta=~type</code>, d=3 with [delta_1, delta_2, 1-delta_1-delta_2] ~ Dirichlet(a0delta) prior. For <code>mod.delta=~1</code>, d=2 with [tau] ~ Beta(a0delta[1],a0delta[2]) prior, where (delta_1,delta_2,1-delta_1-delta_2) = (tau/2,tau/2,1-tau). See McClintock et al. (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_a0alpha">a0alpha</code></td>
<td>
<p>Specifies &quot;shape1&quot; parameter for [alpha] ~ Beta(a0alpha, b0alpha) prior. Only applicable when <code>data.type = "sometimes"</code>. Default is <code>a0alpha = 1</code>. Note that when <code>a0alpha = 1</code> and <code>b0alpha = 1</code>, then [alpha] ~ Unif(0,1).</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_b0alpha">b0alpha</code></td>
<td>
<p>Specifies &quot;shape2&quot; parameter for [alpha] ~ Beta(a0alpha, b0alpha) prior. Only applicable when <code>data.type = "sometimes"</code>. Default is <code>b0alpha = 1</code>. Note that when <code>a0alpha = 1</code> and <code>b0alpha = 1</code>, then [alpha] ~ Unif(0,1).</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_sigma_bounds">sigma_bounds</code></td>
<td>
<p>Positive vector of length 2 for the lower and upper bounds for the [sigma_scr] ~ Uniform(sigma_bounds[1], sigma_bounds[2]) (or [sqrt(lambda)] when <code>detection=``exponential''</code>) prior for the detection function term sigma_scr = sqrt(sigma2_scr) (or sqrt(lambda)). When <code>sigma_bounds = NULL</code> (the default), then <code>sigma_bounds = c(1.e-6,max(diff(range(studyArea[,"x"])),diff(range(studyArea[,"y"]))))</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_mu0">mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>mu0 = 0</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_sigma2_mu0">sigma2_mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying variance of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>sigma2_mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>sigma2_mu0 = 1.75</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_a0psi">a0psi</code></td>
<td>
<p>Specifies &quot;shape1&quot; parameter for [psi] ~ Beta(a0psi,b0psi) prior. Default is <code>a0psi = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_b0psi">b0psi</code></td>
<td>
<p>Specifies &quot;shape2&quot; parameter for [psi] ~ Beta(a0psi,b0psi) prior. Default is <code>b0psi = 1</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_initial.values">initial.values</code></td>
<td>
<p>Optional list of <code>nchain</code> list(s) specifying initial values for parameters and latent variables. Default is <code>initial.values = NULL</code>, which causes initial values to be generated automatically. In addition to the parameters (&quot;<code>pbeta</code>&quot;, &quot;<code>N</code>&quot;, &quot;<code>delta_1</code>&quot;, &quot;<code>delta_2</code>&quot;, &quot;<code>alpha</code>&quot;, &quot;<code>sigma2_scr</code>&quot;, &quot;<code>centers</code>&quot;, and &quot;<code>psi</code>&quot;), initial values can be specified for the initial latent history frequencies (&quot;<code>x</code>&quot;) and initial individual encounter history indices (&quot;<code>H</code>&quot;).</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_known">known</code></td>
<td>
<p>Optional integer vector indicating whether the encounter history of an individual is known with certainty (i.e., the observed encounter history is the true encounter history). Encounter histories with at least one type 4 encounter are automatically assumed to be known, and <code>known</code> does not need to be specified unless there exist encounter histories that do not contain a type 4 encounter that happen to be known with certainty (e.g., from independent telemetry studies). If specified, <code>known = c(v_1,v_2,...,v_M)</code> must be a vector of length <code>M = nrow(Enc.Mat)</code> where <code>v_i = 1</code> if the encounter history for individual <code>i</code> is known (<code>v_i = 0</code> otherwise). Note that known all-zero encounter histories (e.g., &lsquo;000&rsquo;) are ignored.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_scalemax">scalemax</code></td>
<td>
<p>Upper bound for internal re-scaling of grid cell centroid coordinates. Default is <code>scalemax=10</code>, which re-scales the centroids to be between 0 and 10.  Re-scaling is done internally to avoid numerical overflows during model fitting. Ignored unless <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
<tr><td><code id="multimarkClosedSCR_+3A_...">...</code></td>
<td>
<p>Additional &quot;<code>parameters</code>&quot; arguments for specifying <code>mod.p</code>. See <code><a href="RMark.html#topic+make.design.data">make.design.data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first time <code>multimarkSCRClosed</code> is called, it will likely produce a firewall warning alerting users that R has requested the ability to accept incoming network connections. Incoming network connections are required to use parallel processing as implemented in <code>multimarkClosed</code>. Note that setting <code>parms="all"</code> is required for any <code>multimarkClosed</code> model output to be used in <code><a href="#topic+multimodelClosed">multimodelClosed</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.</p>
</td></tr>
<tr><td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (as specified by <code>mod.p</code> above).</p>
</td></tr>
<tr><td><code>mod.delta</code></td>
<td>
<p>Model formula for conditional probability of type 1 or type 2 encounter, given detection (as specified by <code>mod.delta</code> above).</p>
</td></tr>
<tr><td><code>mod.det</code></td>
<td>
<p>Model formula for detection function (as specified by <code>detection</code> above).</p>
</td></tr>
<tr><td><code>DM</code></td>
<td>
<p>A list of design matrices for detection probability generated for model <code>mod.p</code>, where DM$p is the design matrix for initial capture probability (p) and DM$c is the design matrix for recapture probability (c).</p>
</td></tr>
<tr><td><code>initial.values</code></td>
<td>
<p>A list containing the parameter and latent variable values at iteration <code>iter</code> for each chain. Values are provided for &quot;<code>pbeta</code>&quot;, &quot;<code>N</code>&quot;, &quot;<code>delta_1</code>&quot;, &quot;<code>delta_2</code>&quot;, &quot;<code>alpha</code>&quot;, &quot;<code>sigma2_scr</code>&quot;, &quot;<code>centers</code>&quot;, &quot;<code>psi</code>&quot;, &quot;<code>x</code>&quot;, and &quot;<code>H</code>&quot;.</p>
</td></tr>
<tr><td><code>mms</code></td>
<td>
<p>An object of class <code>multimarkSCRsetup</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Bonner, S. J., and Holmberg J. 2013. Mark-recapture with multiple, non-invasive marks. <em>Biometrics</em> 69: 766-775.
</p>
<p>Gopalaswamy, A.M., Royle, J.A., Hines, J.E., Singh, P., Jathanna, D., Kumar, N. and Karanth, K.U. 2012. Program SPACECAP: software for estimating animal density using spatially explicit capture-recapture models. <em>Methods in Ecology and Evolution</em> 3:1067-1072.
</p>
<p>King, R., McClintock, B. T., Kidney, D., and Borchers, D. L. 2016. Capture-recapture abundance estimation using a semi-complete data likelihood approach. <em>The Annals of Applied Statistics</em> 10: 264-285 
</p>
<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>
<p>McClintock, B. T., Bailey, L. L., Dreher, B. P., and Link, W. A. 2014. Probit models for capture-recapture data subject to imperfect detection, individual heterogeneity and misidentification. <em>The Annals of Applied Statistics</em> 8: 2461-2484.
</p>
<p>Royle, J.A., Karanth, K.U., Gopalaswamy, A.M. and Kumar, N.S. 2009. Bayesian inference in camera trapping studies for a class of spatial capture-recapture models.  <em>Ecology</em> 90: 3233-3244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processdataSCR">processdataSCR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Generate object of class "multimarkSCRsetup" from simulated data
sim.data&lt;-simdataClosedSCR()
Enc.Mat &lt;- sim.data$Enc.Mat
trapCoords &lt;- sim.data$spatialInputs$trapCoords
studyArea &lt;- sim.data$spatialInputs$studyArea

#Run single chain using the default model for simulated data
example.dot&lt;-multimarkClosedSCR(Enc.Mat,trapCoords,studyArea)

#Posterior summary for monitored parameters
summary(example.dot$mcmc)
plot(example.dot$mcmc)

</code></pre>

<hr>
<h2 id='multimarkSCRsetup-class'>Class <code>"multimarkSCRsetup"</code></h2><span id='topic+multimarkSCRsetup-class'></span>

<h3>Description</h3>

<p>A class of spatial 'mulitmark' model inputs
</p>


<h3>Slots</h3>


<dl>
<dt><code>Enc.Mat</code></dt><dd><p>Object of class <code>"matrix"</code>. The observed encounter histories (with rows corresponding to individuals and columns corresponding to sampling occasions).</p>
</dd>
<dt><code>data.type</code></dt><dd><p>Object of class <code>"character"</code>. The encounter history data type (&quot;never&quot;, &quot;sometimes&quot;, or &quot;always&quot;).</p>
</dd>
<dt><code>vAll.hists</code></dt><dd><p>Object of class <code>"integer"</code>. An ordered vector containing all possible encounter histories in sequence.</p>
</dd>
<dt><code>Aprime</code></dt><dd><p>Object of class <code>"sparseMatrix"</code>. Transpose of the A matrix mapping latent encounter histories to observed histories.</p>
</dd>
<dt><code>indBasis</code></dt><dd><p>Object of class <code>"numeric"</code>.An ordered vector of the indices of the three encounter histories updated by each basis vector.</p>
</dd>
<dt><code>ncolbasis</code></dt><dd><p>Object of class <code>"integer"</code>. The number of needed basis vectors.</p>
</dd>
<dt><code>knownx</code></dt><dd><p>Object of class <code>"integer"</code>. Frequencies of known encounter histories.</p>
</dd>
<dt><code>C</code></dt><dd><p>Object of class <code>"integer"</code>. Sampling occasion of first capture for each encounter history.</p>
</dd>
<dt><code>L</code></dt><dd><p>Object of class <code>"integer"</code>. Sampling occasion of last capture for each encounter history.</p>
</dd>
<dt><code>naivex</code></dt><dd><p>Object of class <code>"integer"</code>. &ldquo;Naive&rdquo; latent history frequencies assuming a one-to-one mapping with <code>Enc.Mat</code>.</p>
</dd>
<dt><code>covs</code></dt><dd><p>Object of class <code>"data.frame"</code>. Temporal covariates for detection probability (the number of rows in the data frame must equal the number of sampling occasions).</p>
</dd>
<dt><code>spatialInputs</code></dt><dd><p>Object of class <code>"list"</code>. List is of length 4 containing <code>trapCoords</code> and <code>studyArea</code> after re-scaling coordinates based on <code>maxscale</code>, as well as the original (not re-scaled) grid cell resolution (<code>origCellRes</code>) and re-scaling range (<code>Srange</code>).</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>processdata(Enc.Mat, ...)</code> or <code>new("multimarkSCRsetup", ...)</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;multimarkSCRsetup&quot;.
</p>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processdataSCR">processdataSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("multimarkSCRsetup")
</code></pre>

<hr>
<h2 id='multimarksetup-class'>Class <code>"multimarksetup"</code></h2><span id='topic+multimarksetup-class'></span>

<h3>Description</h3>

<p>A class of 'mulitmark' model inputs
</p>


<h3>Slots</h3>


<dl>
<dt><code>Enc.Mat</code></dt><dd><p>Object of class <code>"matrix"</code>. The observed encounter histories (with rows corresponding to individuals and columns corresponding to sampling occasions).</p>
</dd>
<dt><code>data.type</code></dt><dd><p>Object of class <code>"character"</code>. The encounter history data type (&quot;never&quot;, &quot;sometimes&quot;, or &quot;always&quot;).</p>
</dd>
<dt><code>vAll.hists</code></dt><dd><p>Object of class <code>"integer"</code>. An ordered vector containing all possible encounter histories in sequence.</p>
</dd>
<dt><code>Aprime</code></dt><dd><p>Object of class <code>"sparseMatrix"</code>. Transpose of the A matrix mapping latent encounter histories to observed histories.</p>
</dd>
<dt><code>indBasis</code></dt><dd><p>Object of class <code>"numeric"</code>.An ordered vector of the indices of the three encounter histories updated by each basis vector.</p>
</dd>
<dt><code>ncolbasis</code></dt><dd><p>Object of class <code>"integer"</code>. The number of needed basis vectors.</p>
</dd>
<dt><code>knownx</code></dt><dd><p>Object of class <code>"integer"</code>. Frequencies of known encounter histories.</p>
</dd>
<dt><code>C</code></dt><dd><p>Object of class <code>"integer"</code>. Sampling occasion of first capture for each encounter history.</p>
</dd>
<dt><code>L</code></dt><dd><p>Object of class <code>"integer"</code>. Sampling occasion of last capture for each encounter history.</p>
</dd>
<dt><code>naivex</code></dt><dd><p>Object of class <code>"integer"</code>. &ldquo;Naive&rdquo; latent history frequencies assuming a one-to-one mapping with <code>Enc.Mat</code>.</p>
</dd>
<dt><code>covs</code></dt><dd><p>Object of class <code>"data.frame"</code>. Temporal covariates for detection probability (the number of rows in the data frame must equal the number of sampling occasions).</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>processdata(Enc.Mat, ...)</code> or <code>new("multimarksetup", ...)</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;multimarksetup&quot;.
</p>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processdata">processdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("multimarksetup")
</code></pre>

<hr>
<h2 id='multimodelCJS'>Multimodel inference for 'multimark' open population survival models</h2><span id='topic+multimodelCJS'></span>

<h3>Description</h3>

<p>This function performs Bayesian multimodel inference for a set of 'multimark' open population survival (i.e., Cormack-Jolly-Seber) models using the reversible jump Markov chain Monte Carlo (RJMCMC) algorithm proposed by Barker &amp; Link (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimodelCJS(
  modlist,
  modprior = rep(1/length(modlist), length(modlist)),
  monparms = "phi",
  miter = NULL,
  mburnin = 0,
  mthin = 1,
  M1 = NULL,
  pbetapropsd = 1,
  zppropsd = NULL,
  phibetapropsd = 1,
  zphipropsd = NULL,
  sigppropshape = 1,
  sigppropscale = 0.01,
  sigphipropshape = 1,
  sigphipropscale = 0.01,
  printlog = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimodelCJS_+3A_modlist">modlist</code></td>
<td>
<p>A list of individual model output lists returned by <code><a href="#topic+multimarkCJS">multimarkCJS</a></code>. The models must have the same number of chains and MCMC iterations.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_modprior">modprior</code></td>
<td>
<p>Vector of length <code>length(modlist)</code> containing prior model probabilities. Default is <code>modprior = rep(1/length(modlist), length(modlist))</code>.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_monparms">monparms</code></td>
<td>
<p>Parameters to monitor. Only parameters common to all models can be monitored (e.g., &quot;<code>pbeta[(Intercept)]</code>&quot;, &quot;<code>phibeta[(Intercept)]</code>&quot;, &quot;<code>psi</code>&quot;), but derived survival (&quot;<code>phi</code>&quot;) and capture (&quot;<code>p</code>&quot;) probabilities can also be monitored. Default is <code>monparms = "phi"</code>.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_miter">miter</code></td>
<td>
<p>The number of RJMCMC iterations per chain. If <code>NULL</code>, then the number of MCMC iterations for each individual model chain is used.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_mburnin">mburnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= mburnin &lt; miter</code>).</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_mthin">mthin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_m1">M1</code></td>
<td>
<p>Integer vector indicating the initial model for each chain, where <code>M1_j=i</code> initializes the RJMCMC algorithm for chain j in the model corresponding to <code>modlist[[i]]</code> for i=1,...,  <code>length(modlist)</code>. If <code>NULL</code>, the algorithm for all chains is initialized in the most general model. Default is <code>M1=NULL</code>.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_pbetapropsd">pbetapropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, pbetapropsd) proposal distribution for &quot;<code>pbeta</code>&quot;  parameters. Default is <code>pbetapropsd=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_zppropsd">zppropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, zppropsd) proposal distribution for &quot;<code>zp</code>&quot;  parameters. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. If <code>NULL</code>, zppropsd = sqrt(sigma2_zp) is used. Default is <code>zppropsd=NULL</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_phibetapropsd">phibetapropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, phibetapropsd) proposal distribution for &quot;<code>phibeta</code>&quot;  parameters. Default is <code>phibetapropsd=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_zphipropsd">zphipropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, zphipropsd) proposal distribution for &quot;<code>zphi</code>&quot;  parameters. Only applies if at least one (but not all) model(s) include individual hetergeneity in survival probability. If <code>NULL</code>, zphipropsd = sqrt(sigma2_zphi) is used. Default is <code>zphipropsd=NULL</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_sigppropshape">sigppropshape</code></td>
<td>
<p>Scaler specifying the shape parameter of the invGamma(shape = sigppropshape, scale = sigppropscale) proposal distribution for &quot;<code>sigma2_zp</code>&quot;. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. Default is <code>sigppropshape=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_sigppropscale">sigppropscale</code></td>
<td>
<p>Scaler specifying the scale parameter of the invGamma(shape = sigppropshape, scale = sigppropscale) proposal distribution for &quot;<code>sigma2_zp</code>&quot;. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. Default is <code>sigppropscale=0.01</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_sigphipropshape">sigphipropshape</code></td>
<td>
<p>Scaler specifying the shape parameter of the invGamma(shape = sigphipropshape, scale = sigphipropscale) proposal distribution for &quot;<code>sigma2_zphi</code>&quot;. Only applies if at least one (but not all) model(s) include individual hetergeneity in survival probability. Default is <code>sigphipropshape=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_sigphipropscale">sigphipropscale</code></td>
<td>
<p>Scaler specifying the scale parameter of the invGamma(shape = sigphipropshape, scale = sigphipropscale) proposal distribution for &quot;<code>sigma_zphi</code>&quot;. Only applies if at least one (but not all) model(s) include individual hetergeneity in survival probability. Default is <code>sigphipropscale=0.01</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelCJS_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that setting <code>parms="all"</code> is required when fitting individual <code><a href="#topic+multimarkCJS">multimarkCJS</a></code> models to be included in <code>modlist</code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>rjmcmc</code></td>
<td>
<p>Reversible jump Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>. Includes RJMCMC output for monitored parameters and the current model at each iteration (&quot;<code>M</code>&quot;).</p>
</td></tr>
<tr><td><code>pos.prob</code></td>
<td>
<p>A list of calculated posterior model probabilities for each chain, including the overall posterior model probabilities across all chains.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Barker, R. J. and Link. W. A. 2013. Bayesian multimodel inference by RJMCMC: a Gibbs sampling approach. The American Statistician 67: 150-156.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkCJS">multimarkCJS</a></code>, <code><a href="#topic+processdata">processdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Generate object of class "multimarksetup" from simulated data
data_type = "always"
noccas &lt;- 5
phibetaTime &lt;- seq(2,0,length=noccas-1) # declining trend in survival
data &lt;- simdataCJS(noccas=5,phibeta=phibetaTime,data.type=data_type)
setup &lt;- processdata(data$Enc.Mat,data.type=data_type)

#Run single chain using the default model. Note parms="all".
sim.pdot.phidot &lt;- multimarkCJS(mms=setup,parms="all",iter=1000,adapt=500,burnin=500)

#Run single chain with temporal trend for phi. Note parms="all".
sim.pdot.phiTime &lt;- multimarkCJS(mms=setup,mod.phi=~Time,parms="all",iter=1000,adapt=500,burnin=500)

#Perform RJMCMC using defaults
modlist &lt;- list(mod1=sim.pdot.phidot,mod2=sim.pdot.phiTime)
sim.M &lt;- multimodelCJS(modlist=modlist)

#Posterior model probabilities
sim.M$pos.prob

#multimodel posterior summary for survival (display first cohort only)
summary(sim.M$rjmcmc[,paste0("phi[1,",1:(noccas-1),"]")])

</code></pre>

<hr>
<h2 id='multimodelClosed'>Multimodel inference for 'multimark' closed population abundance models</h2><span id='topic+multimodelClosed'></span>

<h3>Description</h3>

<p>This function performs Bayesian multimodel inference for a set of 'multimark' closed population abundance models using the reversible jump Markov chain Monte Carlo (RJMCMC) algorithm proposed by Barker &amp; Link (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimodelClosed(
  modlist,
  modprior = rep(1/length(modlist), length(modlist)),
  monparms = "N",
  miter = NULL,
  mburnin = 0,
  mthin = 1,
  M1 = NULL,
  pbetapropsd = 1,
  zppropsd = NULL,
  sigppropshape = 6,
  sigppropscale = 4,
  printlog = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimodelClosed_+3A_modlist">modlist</code></td>
<td>
<p>A list of individual model output lists returned by <code><a href="#topic+multimarkClosed">multimarkClosed</a></code> or <code><a href="#topic+markClosed">markClosed</a></code>. The models must have the same number of chains and MCMC iterations.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_modprior">modprior</code></td>
<td>
<p>Vector of length <code>length(modlist)</code> containing prior model probabilities. Default is <code>modprior = rep(1/length(modlist), length(modlist))</code>.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_monparms">monparms</code></td>
<td>
<p>Parameters to monitor. Only parameters common to all models can be monitored (e.g., &quot;<code>pbeta[(Intercept)]</code>&quot;, &quot;<code>N</code>&quot;), but derived capture (&quot;<code>p</code>&quot;) and recapture (&quot;<code>c</code>&quot;) probabilities can also be monitored. Default is <code>monparms = "N"</code>.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_miter">miter</code></td>
<td>
<p>The number of RJMCMC iterations per chain. If <code>NULL</code>, then the number of MCMC iterations for each individual model chain is used.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_mburnin">mburnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= mburnin &lt; miter</code>).</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_mthin">mthin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_m1">M1</code></td>
<td>
<p>Integer vector indicating the initial model for each chain, where <code>M1_j=i</code> initializes the RJMCMC algorithm for chain j in the model corresponding to <code>modlist[[i]]</code> for i=1,...,  <code>length(modlist)</code>. If <code>NULL</code>, the algorithm for all chains is initialized in the most general model. Default is <code>M1=NULL</code>.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_pbetapropsd">pbetapropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, pbetapropsd) proposal distribution for &quot;<code>pbeta</code>&quot;  parameters. Default is <code>pbetapropsd=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_zppropsd">zppropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, zppropsd) proposal distribution for &quot;<code>zp</code>&quot;  parameters. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. If <code>NULL</code>, zppropsd = sqrt(sigma2_zp) is used. Default is <code>zppropsd=NULL</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_sigppropshape">sigppropshape</code></td>
<td>
<p>Scaler specifying the shape parameter of the invGamma(shape = sigppropshape, scale = sigppropscale) proposal distribution for <code>sigma_zp</code>. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. Default is <code>sigppropshape=6</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_sigppropscale">sigppropscale</code></td>
<td>
<p>Scaler specifying the scale parameter of the invGamma(shape = sigppropshape, scale = sigppropscale) proposal distribution for <code>sigma_zp</code>. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. Default is <code>sigppropscale=4</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelClosed_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that setting <code>parms="all"</code> is required when fitting individual <code><a href="#topic+multimarkClosed">multimarkClosed</a></code> or <code><a href="#topic+markClosed">markClosed</a></code> models to be included in <code>modlist</code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>rjmcmc</code></td>
<td>
<p>Reversible jump Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>. Includes RJMCMC output for monitored parameters and the current model at each iteration (&quot;<code>M</code>&quot;).</p>
</td></tr>
<tr><td><code>pos.prob</code></td>
<td>
<p>A list of calculated posterior model probabilities for each chain, including the overall posterior model probabilities across all chains.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Barker, R. J. and Link. W. A. 2013. Bayesian multimodel inference by RJMCMC: a Gibbs sampling approach. The American Statistician 67: 150-156.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkClosed">multimarkClosed</a></code>, <code><a href="#topic+markClosed">markClosed</a></code>, <code><a href="#topic+processdata">processdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Generate object of class "multimarksetup"
setup &lt;- processdata(bobcat)
 
#Run single chain using the default model for bobcat data. Note parms="all".
bobcat.dot &lt;- multimarkClosed(mms=setup,parms="all",iter=1000,adapt=500,burnin=500)

#Run single chain for bobcat data with time effects. Note parms="all".
bobcat.time &lt;- multimarkClosed(mms=setup,mod.p=~time,parms="all",iter=1000,adapt=500,burnin=500)

#Perform RJMCMC using defaults
modlist &lt;- list(mod1=bobcat.dot,mod2=bobcat.time)
bobcat.M &lt;- multimodelClosed(modlist=modlist,monparms=c("N","p"))

#Posterior model probabilities
bobcat.M$pos.prob
 
#multimodel posterior summary for abundance
summary(bobcat.M$rjmcmc[,"N"])

</code></pre>

<hr>
<h2 id='multimodelClosedSCR'>Multimodel inference for 'multimark' spatial population abundance models</h2><span id='topic+multimodelClosedSCR'></span>

<h3>Description</h3>

<p>This function performs Bayesian multimodel inference for a set of 'multimark' spatial population abundance models using the reversible jump Markov chain Monte Carlo (RJMCMC) algorithm proposed by Barker &amp; Link (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimodelClosedSCR(
  modlist,
  modprior = rep(1/length(modlist), length(modlist)),
  monparms = "N",
  miter = NULL,
  mburnin = 0,
  mthin = 1,
  M1 = NULL,
  pbetapropsd = 1,
  sigpropmean = 0.8,
  sigpropsd = 0.4,
  printlog = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimodelClosedSCR_+3A_modlist">modlist</code></td>
<td>
<p>A list of individual model output lists returned by <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code> or <code><a href="#topic+markClosedSCR">markClosedSCR</a></code>. The models must have the same number of chains and MCMC iterations.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_modprior">modprior</code></td>
<td>
<p>Vector of length <code>length(modlist)</code> containing prior model probabilities. Default is <code>modprior = rep(1/length(modlist), length(modlist))</code>.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_monparms">monparms</code></td>
<td>
<p>Parameters to monitor. Only parameters common to all models can be monitored (e.g., &quot;<code>pbeta[(Intercept)]</code>&quot;, &quot;<code>N</code>&quot;, &quot;<code>sigma2_scr</code>&quot;), but derived density (&quot;<code>D</code>&quot;) as well as capture (&quot;<code>p</code>&quot;) and recapture (&quot;<code>c</code>&quot;) probabilities (at distance zero from activity centers) can also be monitored. Default is <code>monparms = "N"</code>.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_miter">miter</code></td>
<td>
<p>The number of RJMCMC iterations per chain. If <code>NULL</code>, then the number of MCMC iterations for each individual model chain is used.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_mburnin">mburnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= mburnin &lt; miter</code>).</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_mthin">mthin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_m1">M1</code></td>
<td>
<p>Integer vector indicating the initial model for each chain, where <code>M1_j=i</code> initializes the RJMCMC algorithm for chain j in the model corresponding to <code>modlist[[i]]</code> for i=1,...,  <code>length(modlist)</code>. If <code>NULL</code>, the algorithm for all chains is initialized in the most general model. Default is <code>M1=NULL</code>.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_pbetapropsd">pbetapropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, pbetapropsd) proposal distribution for &quot;<code>pbeta</code>&quot;  parameters. Default is <code>pbetapropsd=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_sigpropmean">sigpropmean</code></td>
<td>
<p>Scaler specifying the mean of the inverse Gamma proposal distribution for <code>sigma2_scr</code> (or <code>lambda</code> if <code>detection=``exponential''</code>). Only applies if models do not have the same detection function (i.e., &ldquo;half-normal&rdquo; or &ldquo;exponential&rdquo;). Default is <code>sigpropmean=0.8</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_sigpropsd">sigpropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the inverse Gamma proposal distribution for <code>sigma2_scr</code> (or <code>lambda</code> if <code>detection=``exponential''</code>). Only applies if models do not have the same detection function (i.e., &ldquo;half-normal&rdquo; or &ldquo;exponential&rdquo;). Default is <code>sigpropsd=0.4</code>. See Barker &amp; Link (2013) for more details.</p>
</td></tr>
<tr><td><code id="multimodelClosedSCR_+3A_printlog">printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for &quot;Unix-like&quot; machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that setting <code>parms="all"</code> is required when fitting individual <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code> or <code><a href="#topic+markClosedSCR">markClosedSCR</a></code> models to be included in <code>modlist</code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>rjmcmc</code></td>
<td>
<p>Reversible jump Markov chain Monte Carlo object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>. Includes RJMCMC output for monitored parameters and the current model at each iteration (&quot;<code>M</code>&quot;).</p>
</td></tr>
<tr><td><code>pos.prob</code></td>
<td>
<p>A list of calculated posterior model probabilities for each chain, including the overall posterior model probabilities across all chains.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Barker, R. J. and Link. W. A. 2013. Bayesian multimodel inference by RJMCMC: a Gibbs sampling approach. The American Statistician 67: 150-156.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code>, <code><a href="#topic+processdataSCR">processdataSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Generate object of class "multimarkSCRsetup"
sim.data&lt;-simdataClosedSCR()
Enc.Mat&lt;-sim.data$Enc.Mat
trapCoords&lt;-sim.data$spatialInputs$trapCoords
studyArea&lt;-sim.data$spatialInputs$studyArea
setup&lt;-processdataSCR(Enc.Mat,trapCoords,studyArea)
 
#Run single chain using the default model for simulated data. Note parms="all".
example.dot &lt;- multimarkClosedSCR(mms=setup,parms="all",iter=1000,adapt=500,burnin=500)

#Run single chain for simulated data with behavior effects. Note parms="all".
example.c &lt;- multimarkClosedSCR(mms=setup,mod.p=~c,parms="all",iter=1000,adapt=500,burnin=500)

#Perform RJMCMC using defaults
modlist &lt;- list(mod1=example.dot,mod2=example.c)
example.M &lt;- multimodelClosedSCR(modlist=modlist,monparms=c("N","D","sigma2_scr"))

#Posterior model probabilities
example.M$pos.prob
 
#multimodel posterior summary for abundance and density
summary(example.M$rjmcmc[,c("N","D")])

</code></pre>

<hr>
<h2 id='plotSpatialData'>Plot spatial capture-mark-recapture data</h2><span id='topic+plotSpatialData'></span>

<h3>Description</h3>

<p>This function plots the study area grid, available habitat, and trap coordinates for spatial capture-recapture studies.  Activity centers and capture locations can also be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatialData(
  mms = NULL,
  trapCoords,
  studyArea,
  centers = NULL,
  trapLines = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSpatialData_+3A_mms">mms</code></td>
<td>
<p>An optional object of class <code>multimarkSCRsetup-class</code> from which the (re-scaled) study area and trap coordinates are plotted.</p>
</td></tr>
<tr><td><code id="plotSpatialData_+3A_trapcoords">trapCoords</code></td>
<td>
<p>A matrix of dimension <code>ntraps</code> x (2 + <code>noccas</code>) indicating the Cartesian coordinates and operating occasions for the traps, where rows correspond to trap, the first column the x-coordinate, and the second column the y-coordinate. The last <code>noccas</code> columns indicate whether or not the trap was operating on each of the occasions, where &lsquo;1&rsquo; indciates the trap was operating and &lsquo;0&rsquo; indicates the trap was not operating. Ignored unless <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="plotSpatialData_+3A_studyarea">studyArea</code></td>
<td>
<p>A 3-column matrix defining the study area and available habitat. Each row corresponds to a grid cell. The first 2 columns indicate the Cartesian x- and y-coordinate for the centroid of each grid cell, and the third column indicates whether the cell is available habitat (=1) or not (=0). All cells must have the same resolution. Ignored unless <code>mms=NULL</code>.
Note that rows should be ordered in raster cell order (raster cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom).</p>
</td></tr>
<tr><td><code id="plotSpatialData_+3A_centers">centers</code></td>
<td>
<p>An optional vector indicating the grid cell (i.e., the row of <code>studyArea</code>) that contains the true (latent) activity centers for each individual. If <code>mms</code> is provided, then <code>centers</code> must be of length <code>nrow(Enc.Mat)</code> (i.e., a center must be provided for each observed individual).</p>
</td></tr>
<tr><td><code id="plotSpatialData_+3A_traplines">trapLines</code></td>
<td>
<p>Logical indicating whether to draw lines from activity centers to respective traps at which each individual was captured. Default is <code>trapLines=FALSE</code>. Ignored when <code>mms=NULL</code> or <code>centers=NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Plot the tiger example data
plotSpatialData(trapCoords=tiger$trapCoords,studyArea=tiger$studyArea)

</code></pre>

<hr>
<h2 id='processdata'>Generate model inputs for fitting 'multimark' models</h2><span id='topic+processdata'></span>

<h3>Description</h3>

<p>This function generates an object of class <code>multimarksetup</code> that is required to fit &lsquo;multimark&rsquo; models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processdata(
  Enc.Mat,
  data.type = "never",
  covs = data.frame(),
  known = integer()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processdata_+3A_enc.mat">Enc.Mat</code></td>
<td>
<p>A matrix of observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions (ignored unless <code>mms=NULL</code>).</p>
</td></tr>
<tr><td><code id="processdata_+3A_data.type">data.type</code></td>
<td>
<p>Specifies the encounter history data type. All data types include non-detections (type 0 encounter), type 1 encounter (e.g., left-side), and type 2 encounters (e.g., right-side). When both type 1 and type 2 encounters occur for the same individual within a sampling occasion, these can either be &quot;non-simultaneous&quot; (type 3 encounter) or &quot;simultaneous&quot; (type 4 encounter). Three data types are currently permitted:
</p>
<p><code>data.type="never"</code> indicates both type 1 and type 2 encounters are never observed for the same individual within a sampling occasion, and observed encounter histories therefore include only type 1 or type 2 encounters (e.g., only left- and right-sided photographs were collected). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), and type 2 encounters (2). See <code><a href="#topic+bobcat">bobcat</a></code>. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 3 encounters (3).
</p>
<p><code>data.type="sometimes"</code> indicates both type 1 and type 2 encounters are sometimes observed (e.g., both-sided photographs are sometimes obtained, but not necessarily for all individuals). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). Type 3 encounters can only be observed when an individual has at least one type 4 encounter. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). 
</p>
<p><code>data.type="always"</code> indicates both type 1 and type 2 encounters are always observed, but some encounter histories may still include only type 1 or type 2 encounters. Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4). Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4).</p>
</td></tr>
<tr><td><code id="processdata_+3A_covs">covs</code></td>
<td>
<p>A data frame of temporal covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of sampling occasions. Covariate names cannot be &quot;time&quot;, &quot;age&quot;, or &quot;h&quot;; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td></tr>
<tr><td><code id="processdata_+3A_known">known</code></td>
<td>
<p>Optional integer vector indicating whether the encounter history of an individual is known with certainty (i.e., the observed encounter history is the true encounter history). Encounter histories with at least one type 4 encounter are automatically assumed to be known, and <code>known</code> does not need to be specified unless there exist encounter histories that do not contain a type 4 encounter that happen to be known with certainty (e.g., from independent telemetry studies). If specified, <code>known = c(v_1,v_2,...,v_M)</code> must be a vector of length <code>M = nrow(Enc.Mat)</code> where <code>v_i = 1</code> if the encounter history for individual <code>i</code> is known (<code>v_i = 0</code> otherwise). Note that known all-zero encounter histories (e.g., &lsquo;000&rsquo;) are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>multimarksetup</code>.
</p>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Bonner, S. J., and Holmberg J. 2013. Mark-recapture with multiple, non-invasive marks. <em>Biometrics</em> 69: 766-775.
</p>
<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarksetup-class">multimarksetup-class</a></code>, <code><a href="#topic+multimarkClosed">multimarkClosed</a></code>, <code><a href="#topic+bobcat">bobcat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Generate object of class "multimarksetup"
setup &lt;- processdata(bobcat)

#Run single chain using the default model for bobcat data
bobcat.dot&lt;-multimarkClosed(mms=setup)

#Run single chain for bobcat data with temporal effects (i.e., mod.p=~time)
bobcat.time &lt;- multimarkClosed(mms=setup,mod.p=~time)

</code></pre>

<hr>
<h2 id='processdataSCR'>Generate model inputs for fitting spatial 'multimark' models</h2><span id='topic+processdataSCR'></span>

<h3>Description</h3>

<p>This function generates an object of class <code>multimarkSCRsetup</code> that is required to fit spatial &lsquo;multimark&rsquo; models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processdataSCR(
  Enc.Mat,
  trapCoords,
  studyArea = NULL,
  buffer = NULL,
  ncells = NULL,
  data.type = "never",
  covs = data.frame(),
  known = integer(),
  scalemax = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processdataSCR_+3A_enc.mat">Enc.Mat</code></td>
<td>
<p>A matrix containing the observed encounter histories with rows corresponding to individuals and (<code>ntraps</code>*<code>noccas</code>) columns corresponding to traps and sampling occasions.  The first <code>noccas</code> columns correspond to trap 1, the second <code>noccas</code> columns corresopond to trap 2, etc. Ignored unless <code>mms=NULL</code>.</p>
</td></tr>
<tr><td><code id="processdataSCR_+3A_trapcoords">trapCoords</code></td>
<td>
<p>A matrix of dimension <code>ntraps</code> x (2 + <code>noccas</code>) indicating the Cartesian coordinates and operating occasions for the traps, where rows correspond to trap, the first column the x-coordinate, and the second column the y-coordinate. The last <code>noccas</code> columns indicate whether or not the trap was operating on each of the occasions, where &lsquo;1&rsquo; indciates the trap was operating and &lsquo;0&rsquo; indicates the trap was not operating.</p>
</td></tr>
<tr><td><code id="processdataSCR_+3A_studyarea">studyArea</code></td>
<td>
<p>is a 3-column matrix containing the coordinates for the centroids of a contiguous grid of cells that define the study area and available habitat. Each row corresponds to a grid cell. The first 2 columns indicate the Cartesian x- and y-coordinate for the centroid of each grid cell, and the third column indicates whether the cell is available habitat (=1) or not (=0). All cells must be square and have the same resolution. If <code>studyArea=NULL</code> (the default), then a square study area grid composed of <code>ncells</code> cells of available habitat is drawn around the bounding box of <code>trapCoords</code> based on <code>buffer</code>.
Note that rows should be ordered in raster cell order (raster cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom).</p>
</td></tr>
<tr><td><code id="processdataSCR_+3A_buffer">buffer</code></td>
<td>
<p>A scaler in same units as <code>trapCoords</code> indicating the buffer around the bounding box of <code>trapCoords</code> for defining the study area when <code>studyArea=NULL</code>.  Ignored unless <code>studyArea=NULL</code>.</p>
</td></tr>
<tr><td><code id="processdataSCR_+3A_ncells">ncells</code></td>
<td>
<p>The number of grid cells in the study area when <code>studyArea=NULL</code>. The square root of <code>ncells</code> must be a whole number. Default is <code>ncells=1024</code>. Ignored unless <code>studyArea=NULL</code>.</p>
</td></tr>
<tr><td><code id="processdataSCR_+3A_data.type">data.type</code></td>
<td>
<p>Specifies the encounter history data type. All data types include non-detections (type 0 encounter), type 1 encounter (e.g., left-side), and type 2 encounters (e.g., right-side). When both type 1 and type 2 encounters occur for the same individual within a sampling occasion, these can either be &quot;non-simultaneous&quot; (type 3 encounter) or &quot;simultaneous&quot; (type 4 encounter). Three data types are currently permitted:
</p>
<p><code>data.type="never"</code> indicates both type 1 and type 2 encounters are never observed for the same individual within a sampling occasion, and observed encounter histories therefore include only type 1 or type 2 encounters (e.g., only left- and right-sided photographs were collected). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), and type 2 encounters (2). See <code><a href="#topic+bobcat">bobcat</a></code>. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 3 encounters (3).
</p>
<p><code>data.type="sometimes"</code> indicates both type 1 and type 2 encounters are sometimes observed (e.g., both-sided photographs are sometimes obtained, but not necessarily for all individuals). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). Type 3 encounters can only be observed when an individual has at least one type 4 encounter. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). 
</p>
<p><code>data.type="always"</code> indicates both type 1 and type 2 encounters are always observed, but some encounter histories may still include only type 1 or type 2 encounters. Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4). Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4).</p>
</td></tr>
<tr><td><code id="processdataSCR_+3A_covs">covs</code></td>
<td>
<p>A data frame of time- and/or trap-dependent covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of traps times the number of sampling occasions (<code>ntraps*noccas</code>), where the first <code>noccas</code> rows correspond to trap 1, the second <code>noccas</code> rows correspond to trap 2, etc. Covariate names cannot be &quot;time&quot;, &quot;age&quot;, or &quot;h&quot;; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td></tr>
<tr><td><code id="processdataSCR_+3A_known">known</code></td>
<td>
<p>Optional integer vector indicating whether the encounter history of an individual is known with certainty (i.e., the observed encounter history is the true encounter history). Encounter histories with at least one type 4 encounter are automatically assumed to be known, and <code>known</code> does not need to be specified unless there exist encounter histories that do not contain a type 4 encounter that happen to be known with certainty (e.g., from independent telemetry studies). If specified, <code>known = c(v_1,v_2,...,v_M)</code> must be a vector of length <code>M = nrow(Enc.Mat)</code> where <code>v_i = 1</code> if the encounter history for individual <code>i</code> is known (<code>v_i = 0</code> otherwise). Note that known all-zero encounter histories (e.g., &lsquo;000&rsquo;) are ignored.</p>
</td></tr>
<tr><td><code id="processdataSCR_+3A_scalemax">scalemax</code></td>
<td>
<p>Upper bound for internal re-scaling of grid cell centroid coordinates. Default is <code>scalemax=10</code>, which re-scales the centroids to be between 0 and 10.  Re-scaling is done internally to avoid numerical overflows during model fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>multimarkSCRsetup</code>.
</p>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Bonner, S. J., and Holmberg J. 2013. Mark-recapture with multiple, non-invasive marks. <em>Biometrics</em> 69: 766-775.
</p>
<p>Gopalaswamy, A.M., Royle, J.A., Hines, J.E., Singh, P., Jathanna, D., Kumar, N. and Karanth, K.U. 2012. Program SPACECAP: software for estimating animal density using spatially explicit capture-recapture models. <em>Methods in Ecology and Evolution</em> 3:1067-1072.
</p>
<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>
<p>Royle, J.A., Karanth, K.U., Gopalaswamy, A.M. and Kumar, N.S. 2009. Bayesian inference in camera trapping studies for a class of spatial capture-recapture models.  <em>Ecology</em> 90: 3233-3244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multimarkSCRsetup-class">multimarkSCRsetup-class</a></code>, <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Generate object of class "multimarksetup" from simulated data
sim.data&lt;-simdataClosedSCR()
Enc.Mat &lt;- sim.data$Enc.Mat
trapCoords &lt;- sim.data$spatialInputs$trapCoords
studyArea &lt;- sim.data$spatialInputs$studyArea
setup &lt;- processdataSCR(Enc.Mat,trapCoords,studyArea)

#Run single chain using the default model for simulated data
example.dot&lt;-multimarkClosedSCR(mms=setup)

</code></pre>

<hr>
<h2 id='simdataCJS'>Simulate open population capture-mark-recapture data arising from multiple non-invasive marks</h2><span id='topic+simdataCJS'></span>

<h3>Description</h3>

<p>This function generates encounter histories from simulated open population capture-mark-recapture data consisting of multiple non-invasive marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdataCJS(
  N = 100,
  noccas = 5,
  pbeta = -0.25,
  sigma2_zp = 0,
  phibeta = 1.6,
  sigma2_zphi = 0,
  delta_1 = 0.4,
  delta_2 = 0.4,
  alpha = 0.5,
  data.type = "never",
  link = "probit"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simdataCJS_+3A_n">N</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_noccas">noccas</code></td>
<td>
<p>Number of sampling occasions. <code>floor(N/noccas)</code> individuals are first encountered on each occasion.</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_pbeta">pbeta</code></td>
<td>
<p>Logit- or probit-scale intercept term(s) for capture probability (p). Must be a scaler or vector of length <code>noccas</code>.</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_sigma2_zp">sigma2_zp</code></td>
<td>
<p>Logit- or probit-scale individual heterogeneity variance term for capture probability (p).</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_phibeta">phibeta</code></td>
<td>
<p>Logit- or probit-scale intercept term(s) for survival probability (<code class="reqn">\phi</code>). Must be a scaler or vector of length <code>noccas</code>.</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_sigma2_zphi">sigma2_zphi</code></td>
<td>
<p>Logit- or probit-scale individual heterogeneity variance term for survival probability (<code class="reqn">\phi</code>).</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_delta_1">delta_1</code></td>
<td>
<p>Conditional probability of type 1 encounter, given detection.</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_delta_2">delta_2</code></td>
<td>
<p>Conditional probability of type 2 encounter, given detection.</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_alpha">alpha</code></td>
<td>
<p>Conditional probability of simultaneous type 1 and type 2 detection, given both types encountered. Only applies when <code>data.type="sometimes"</code>.</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_data.type">data.type</code></td>
<td>
<p>Specifies the encounter history data type. All data types include non-detections (type 0 encounter), type 1 encounter (e.g., left-side), and type 2 encounters (e.g., right-side). When both type 1 and type 2 encounters occur for the same individual within a sampling occasion, these can either be &quot;non-simultaneous&quot; (type 3 encounter) or &quot;simultaneous&quot; (type 4 encounter). Three data types are currently permitted:
</p>
<p><code>data.type="never"</code> indicates both type 1 and type 2 encounters are never observed for the same individual within a sampling occasion, and observed encounter histories therefore include only type 1 or type 2 encounters (e.g., only left- and right-sided photographs were collected). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), and type 2 encounters (2). See <code><a href="#topic+bobcat">bobcat</a></code>. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 3 encounters (3).
</p>
<p><code>data.type="sometimes"</code> indicates both type 1 and type 2 encounters are sometimes observed (e.g., both-sided photographs are sometimes obtained, but not necessarily for all individuals). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). Type 3 encounters can only be observed when an individual has at least one type 4 encounter. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). 
</p>
<p><code>data.type="always"</code> indicates both type 1 and type 2 encounters are always observed, but some encounter histories may still include only type 1 or type 2 encounters. Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4). Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4).</p>
</td></tr>
<tr><td><code id="simdataCJS_+3A_link">link</code></td>
<td>
<p>Link function for detection probability. Must be &quot;<code>logit</code>&quot; or &quot;<code>probit</code>&quot;. Note that <code><a href="#topic+multimarkCJS">multimarkCJS</a></code> is currently implemented for the probit link only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>Enc.Mat</code></td>
<td>
<p>A matrix containing the observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions.</p>
</td></tr>
<tr><td><code>trueEnc.Mat</code></td>
<td>
<p>A matrix containing the true (latent) encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Bonner, S. J., and Holmberg J. 2013. Mark-recapture with multiple, non-invasive marks. <em>Biometrics</em> 69: 766-775.
</p>
<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processdata">processdata</a></code>, <code><a href="#topic+multimarkCJS">multimarkCJS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate data for data.type="sometimes" using defaults
data&lt;-simdataCJS(data.type="sometimes")

</code></pre>

<hr>
<h2 id='simdataClosed'>Simulate closed population capture-mark-recapture data arising from multiple non-invasive marks</h2><span id='topic+simdataClosed'></span>

<h3>Description</h3>

<p>This function generates encounter histories from simulated closed population capture-mark-recapture data consisting of multiple non-invasive marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdataClosed(
  N = 100,
  noccas = 5,
  pbeta = -0.4,
  tau = 0,
  sigma2_zp = 0,
  delta_1 = 0.4,
  delta_2 = 0.4,
  alpha = 0.5,
  data.type = "never",
  link = "logit"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simdataClosed_+3A_n">N</code></td>
<td>
<p>True population size or abundance.</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_noccas">noccas</code></td>
<td>
<p>The number of sampling occasions.</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_pbeta">pbeta</code></td>
<td>
<p>Logit- or probit-scale intercept term(s) for capture probability (p). Must be a scaler or vector of length <code>noccas</code>.</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_tau">tau</code></td>
<td>
<p>Additive logit- or probit-scale behavioral effect term for recapture probability (c).</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_sigma2_zp">sigma2_zp</code></td>
<td>
<p>Logit- or probit-scale individual heterogeneity variance term.</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_delta_1">delta_1</code></td>
<td>
<p>Conditional probability of type 1 encounter, given detection.</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_delta_2">delta_2</code></td>
<td>
<p>Conditional probability of type 2 encounter, given detection.</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_alpha">alpha</code></td>
<td>
<p>Conditional probability of simultaneous type 1 and type 2 detection, given both types encountered. Only applies when <code>data.type="sometimes"</code>.</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_data.type">data.type</code></td>
<td>
<p>Specifies the encounter history data type. All data types include non-detections (type 0 encounter), type 1 encounter (e.g., left-side), and type 2 encounters (e.g., right-side). When both type 1 and type 2 encounters occur for the same individual within a sampling occasion, these can either be &quot;non-simultaneous&quot; (type 3 encounter) or &quot;simultaneous&quot; (type 4 encounter). Three data types are currently permitted:
</p>
<p><code>data.type="never"</code> indicates both type 1 and type 2 encounters are never observed for the same individual within a sampling occasion, and observed encounter histories therefore include only type 1 or type 2 encounters (e.g., only left- and right-sided photographs were collected). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), and type 2 encounters (2). See <code><a href="#topic+bobcat">bobcat</a></code>. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 3 encounters (3).
</p>
<p><code>data.type="sometimes"</code> indicates both type 1 and type 2 encounters are sometimes observed (e.g., both-sided photographs are sometimes obtained, but not necessarily for all individuals). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). Type 3 encounters can only be observed when an individual has at least one type 4 encounter. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). 
</p>
<p><code>data.type="always"</code> indicates both type 1 and type 2 encounters are always observed, but some encounter histories may still include only type 1 or type 2 encounters. Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4). Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4).</p>
</td></tr>
<tr><td><code id="simdataClosed_+3A_link">link</code></td>
<td>
<p>Link function for detection probability. Must be &quot;<code>logit</code>&quot; or &quot;<code>probit</code>&quot;. Note that <code><a href="#topic+multimarkClosed">multimarkClosed</a></code> is currently implemented for the logit link only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>Enc.Mat</code></td>
<td>
<p>A matrix containing the observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions.</p>
</td></tr>
<tr><td><code>trueEnc.Mat</code></td>
<td>
<p>A matrix containing the true (latent) encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Bonner, S. J., and Holmberg J. 2013. Mark-recapture with multiple, non-invasive marks. <em>Biometrics</em> 69: 766-775.
</p>
<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processdata">processdata</a></code>, <code><a href="#topic+multimarkClosed">multimarkClosed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate data for data.type="sometimes" using defaults
data&lt;-simdataClosed(data.type="sometimes")

</code></pre>

<hr>
<h2 id='simdataClosedSCR'>Simulate spatially-explicit capture-mark-recapture data from a (demographically) closed population with multiple non-invasive marks</h2><span id='topic+simdataClosedSCR'></span>

<h3>Description</h3>

<p>This function generates encounter histories from spatially-explicit capture-mark-recapture data consisting of multiple non-invasive marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdataClosedSCR(
  N = 30,
  ntraps = 9,
  noccas = 5,
  pbeta = 0.25,
  tau = 0,
  sigma2_scr = 0.75,
  lambda = 0.75,
  delta_1 = 0.4,
  delta_2 = 0.4,
  alpha = 0.5,
  data.type = "never",
  detection = "half-normal",
  spatialInputs = NULL,
  buffer = 3 * sqrt(sigma2_scr),
  ncells = 1024,
  scalemax = 10,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simdataClosedSCR_+3A_n">N</code></td>
<td>
<p>True population size or abundance.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_ntraps">ntraps</code></td>
<td>
<p>The number of traps. If <code>trapCoords=NULL</code>, the square root of <code>ntraps</code> must be a whole number in order to create a regular grid of trap coordinates on a square.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_noccas">noccas</code></td>
<td>
<p>Scaler indicating the number of sampling occasions per trap.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_pbeta">pbeta</code></td>
<td>
<p>Complementary loglog-scale intercept term for detection probability (p). Must be a scaler or vector of length <code>noccas</code>.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_tau">tau</code></td>
<td>
<p>Additive complementary loglog-scale behavioral effect term for recapture probability (c).</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_sigma2_scr">sigma2_scr</code></td>
<td>
<p>Complementary loglog-scale term for effect of distance in the &ldquo;half-normal&rdquo; detection function. Ignored unless <code>detection=``half-normal''</code>.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_lambda">lambda</code></td>
<td>
<p>Complementary loglog-scale term for effect of distance in the &ldquo;exponential&rdquo; detection function. Ignored unless <code>detection=``exponential''</code>.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_delta_1">delta_1</code></td>
<td>
<p>Conditional probability of type 1 encounter, given detection.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_delta_2">delta_2</code></td>
<td>
<p>Conditional probability of type 2 encounter, given detection.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_alpha">alpha</code></td>
<td>
<p>Conditional probability of simultaneous type 1 and type 2 detection, given both types encountered. Only applies when <code>data.type="sometimes"</code>.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_data.type">data.type</code></td>
<td>
<p>Specifies the encounter history data type. All data types include non-detections (type 0 encounter), type 1 encounter (e.g., left-side), and type 2 encounters (e.g., right-side). When both type 1 and type 2 encounters occur for the same individual within a sampling occasion, these can either be &quot;non-simultaneous&quot; (type 3 encounter) or &quot;simultaneous&quot; (type 4 encounter). Three data types are currently permitted:
</p>
<p><code>data.type="never"</code> indicates both type 1 and type 2 encounters are never observed for the same individual within a sampling occasion, and observed encounter histories therefore include only type 1 or type 2 encounters (e.g., only left- and right-sided photographs were collected). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), and type 2 encounters (2). See <code><a href="#topic+bobcat">bobcat</a></code>. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 3 encounters (3).
</p>
<p><code>data.type="sometimes"</code> indicates both type 1 and type 2 encounters are sometimes observed (e.g., both-sided photographs are sometimes obtained, but not necessarily for all individuals). Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). Type 3 encounters can only be observed when an individual has at least one type 4 encounter. Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), type 3 encounters (3), and type 4 encounters (4). 
</p>
<p><code>data.type="always"</code> indicates both type 1 and type 2 encounters are always observed, but some encounter histories may still include only type 1 or type 2 encounters. Observed encounter histories can consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4). Latent encounter histories consist of non-detections (0), type 1 encounters (1), type 2 encounters (2), and type 4 encounters (4).</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_detection">detection</code></td>
<td>
<p>Model for detection probability as a function of distance from activity centers. Must be &quot;<code>half-normal</code>&quot; (of the form <code class="reqn">\exp{(-d^2 / (2*\sigma^2))}</code>, where <code class="reqn">d</code> is distance) or &quot;<code>exponential</code>&quot; (of the form <code class="reqn">\exp{(-d / \lambda)}</code>).</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_spatialinputs">spatialInputs</code></td>
<td>
<p>A list of length 3 composed of objects named <code>trapCoords</code>, <code>studyArea</code>, and <code>centers</code>:
</p>
<p><code>trapCoords</code> is a matrix of dimension <code>ntraps</code> x (2 + <code>noccas</code>) indicating the Cartesian coordinates and operating occasions for the traps, where rows correspond to trap, the first column the x-coordinate (&ldquo;x&rdquo;), and the second column the y-coordinate (&ldquo;y&rdquo;). The last <code>noccas</code> columns indicate whether or not the trap was operating on each of the occasions, where &lsquo;1&rsquo; indciates the trap was operating and &lsquo;0&rsquo; indicates the trap was not operating.  
</p>
<p><code>studyArea</code> is a 3-column matrix defining the study area and available habitat. Each row corresponds to a grid cell. The first 2 columns (&ldquo;x&rdquo; and &ldquo;y&rdquo;) indicate the Cartesian x- and y-coordinate for the centroid of each grid cell, and the third column (&ldquo;avail&rdquo;) indicates whether the cell is available habitat (=1) or not (=0). All grid cells must have the same resolution. Note that rows should be ordered in raster cell order (raster cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom).
</p>
<p><code>centers</code> is a <code>N</code>-vector indicating the grid cell (i.e., the row of <code>studyArea</code>) that contains the true (latent) activity centers for each individual in the population. 
</p>
<p>If <code>spatialInputs=NULL</code> (the default), then all traps are assumed to be operating on all occasions, the study area is assumed to be composed of <code>ncells</code> grid cells, grid cells within <code>buffer</code> of the trap array are assumed to be available habitat, and the activity centers are randomly assigned to grid cells of available habitat.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_buffer">buffer</code></td>
<td>
<p>A scaler indicating the buffer around the bounding box of <code>trapCoords</code> for defining the study area and available habitat when <code>spatialInputs=NULL</code>.  Default is <code>buffer=3*sqrt(sigma2_scr)</code>. Ignored unless <code>spatialInputs=NULL</code>.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_ncells">ncells</code></td>
<td>
<p>The number of grid cells in the study area when <code>studyArea=NULL</code>. The square root of <code>ncells</code> must be a whole number. Default is <code>ncells=1024</code>. Ignored unless <code>spatialInputs=NULL</code>.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_scalemax">scalemax</code></td>
<td>
<p>Upper bound for grid cell centroid x- and y-coordinates. Default is <code>scalemax=10</code>, which scales the x- and y-coordinates to be between 0 and 10.  Ignored unless <code>spatialInputs=NULL</code>.</p>
</td></tr>
<tr><td><code id="simdataClosedSCR_+3A_plot">plot</code></td>
<td>
<p>Logical indicating whether to plot the simulated trap coordinates, study area, and activity centers using <code><a href="#topic+plotSpatialData">plotSpatialData</a></code>.  Default is <code>plot=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please be very careful when specifying your own <code>spatialInputs</code>; <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code> and <code><a href="#topic+markClosedSCR">markClosedSCR</a></code> do little to verify that these make sense during model fitting.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>Enc.Mat</code></td>
<td>
<p>Matrix containing the observed encounter histories with rows corresponding to individuals and (<code>ntraps</code>*<code>noccas</code>) columns corresponding to traps and sampling occasions.  The first <code>noccas</code> columns correspond to trap 1, the second <code>noccas</code> columns corresopond to trap 2, etc.</p>
</td></tr>
<tr><td><code>trueEnc.Mat</code></td>
<td>
<p>Matrix containing the true (latent) encounter histories with rows corresponding to individuals and (<code>ntraps</code>*<code>noccas</code>) columns corresponding to traps and sampling occasions.  The first <code>noccas</code> columns correspond to trap 1, the second <code>noccas</code> columns corresopond to trap 2, etc.</p>
</td></tr>
<tr><td><code>spatialInputs</code></td>
<td>
<p>List of length 2 with objects named <code>trapCoords</code> and <code>studyArea</code>:
</p>
<p><code>trapCoords</code> is a matrix of dimension <code>ntraps</code> x (2 + <code>noccas</code>) indicating the Cartesian coordinates and operating occasions for the traps, where rows correspond to trap, the first column the x-coordinate, and the second column the y-coordinate. The last <code>noccas</code> columns indicate whether or not the trap was operating on each of the occasions, where &lsquo;1&rsquo; indciates the trap was operating and &lsquo;0&rsquo; indicates the trap was not operating.
</p>
<p><code>studyArea</code> is a 3-column matrix containing the coordinates for the centroids a contiguous grid of cells that define the study area and available habitat. Each row corresponds to a grid cell. The first 2 columns indicate the Cartesian x- and y-coordinate for the centroid of each grid cell, and the third column indicates whether the cell is available habitat (=1) or not (=0). All cells must have the same resolution.</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p><code>N</code>-vector indicating the grid cell (i.e., the row of <code>spatialInputs$studyArea</code>) that contains the true (latent) activity centers for each individual in the population.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Bonner, S. J., and Holmberg J. 2013. Mark-recapture with multiple, non-invasive marks. <em>Biometrics</em> 69: 766-775.
</p>
<p>McClintock, B. T., Conn, P. B., Alonso, R. S., and Crooks, K. R. 2013. Integrated modeling of bilateral photo-identification data in mark-recapture analyses. <em>Ecology</em> 94: 1464-1471.
</p>
<p>Royle, J.A., Karanth, K.U., Gopalaswamy, A.M. and Kumar, N.S. 2009. Bayesian inference in camera trapping studies for a class of spatial capture-recapture models.  <em>Ecology</em> 90: 3233-3244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processdataSCR">processdataSCR</a></code>, <code><a href="#topic+multimarkClosedSCR">multimarkClosedSCR</a></code>, <code><a href="#topic+markClosedSCR">markClosedSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate data for data.type="sometimes" using defaults
data&lt;-simdataClosedSCR(data.type="sometimes")

</code></pre>

<hr>
<h2 id='tiger'>Tiger data</h2><span id='topic+tiger'></span>

<h3>Description</h3>

<p>Example tiger data for <code>multimark</code> package.
</p>


<h3>Format</h3>

<p>These spatial capture-recapture data with a single mark type are summarized in a list of length 3 containing the following objects:
</p>
<p><code>Enc.Mat</code> is a 44 x (noccas*ntraps) matrix containing observed encounter histories for 44 tigers across <code>noccas=48</code> sampling occasions and <code>ntraps=120</code> traps.
</p>
<p><code>trapCoords</code> is a matrix of dimension <code>ntraps</code> x (2 + <code>noccas</code>) indicating the Cartesian coordinates and operating occasions for the traps, where rows correspond to trap, the first column the x-coordinate, and the second column the y-coordinate. The last <code>noccas</code> columns indicate whether or not the trap was operating on each of the occasions, where &lsquo;1&rsquo; indciates the trap was operating and &lsquo;0&rsquo; indicates the trap was not operating.
</p>
<p><code>studyArea</code> is a 3-column matrix containing the coordinates for the centroids of the contiguous grid of cells that define the study area and available habitat. Each row corresponds to a grid cell. The first 2 columns indicate the Cartesian x- and y-coordinate for the centroid of each grid cell, and the third column indicates whether the cell is available habitat (=1) or not (=0). The grid cells are 0.336 km^2 resolution. 
</p>
<p>These data were obtained from the R package <code>SPACECAP</code> and modified by projecting onto a regular rectangular grid consisting of square grid cells (as is required by the spatial capture-recapture models in <code>multimark</code>).
</p>


<h3>Details</h3>

<p>We thank Ullas Karanth, Wildlife Conservation Society, for providing the tiger data for use as an example with this package.
</p>


<h3>Source</h3>

<p>Gopalaswamy, A.M., Royle, J.A., Hines, J.E., Singh, P., Jathanna, D., Kumar, N. and Karanth, K.U. 2012. Program SPACECAP: software for estimating animal density using spatially explicit capture-recapture models. <em>Methods in Ecology and Evolution</em> 3:1067-1072.
</p>
<p>Royle, J.A., Karanth, K.U., Gopalaswamy, A.M. and Kumar, N.S. 2009. Bayesian inference in camera trapping studies for a class of spatial capture-recapture models.  <em>Ecology</em> 90: 3233-3244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markClosedSCR">markClosedSCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tiger)
#plot the traps and available habitat within the study area
plotSpatialData(trapCoords=tiger$trapCoords,studyArea=tiger$studyArea)

# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

# Fit spatial model to tiger data
Enc.Mat&lt;-tiger$Enc.Mat
trapCoords&lt;-tiger$trapCoords
studyArea&lt;-tiger$studyArea
tiger.dot&lt;-markClosedSCR(Enc.Mat,trapCoords,studyArea,iter=100,adapt=50,burnin=50)
summary(tiger.dot$mcmc)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
