<!DOCTYPE html><html lang="en"><head><title>Help for package dcsvm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dcsvm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dcsvm-package'><p>Density-Convoluted Support Vector Machines</p></a></li>
<li><a href='#coef.cv.dcsvm'><p>Compute Coefficients from a &quot;cv.dcsvm&quot; Object</p></a></li>
<li><a href='#coef.dcsvm'><p>Compute Coefficients for Sparse Density-Convoluted SVM</p></a></li>
<li><a href='#colon'><p>Simplified Gene Expression Data from Alon et al. (1999)</p></a></li>
<li><a href='#cv.dcsvm'><p>Cross-Validation for Sparse Density-Convoluted SVM</p></a></li>
<li><a href='#dcsvm'><p>Density-Convoluted Support Vector Machine</p></a></li>
<li><a href='#dcsvm-internal'><p>Internal DCSVM Functions</p></a></li>
<li><a href='#plot.cv.dcsvm'><p>Plot the Cross-Validation Curve of Sparse Density-Convoluted SVM</p></a></li>
<li><a href='#plot.dcsvm'><p>Plot Coefficients for Sparse Density-Convoluted SVM</p></a></li>
<li><a href='#predict.cv.dcsvm'><p>Make Predictions from a &quot;cv.dcsvm&quot; Object</p></a></li>
<li><a href='#predict.dcsvm'><p>Make Predictions for Sparse Density-Convoluted SVM</p></a></li>
<li><a href='#print.dcsvm'><p>Print a DCSVM Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Density Convoluted Support Vector Machines</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an efficient algorithm for solving sparse-penalized support vector machines with kernel density convolution. This package is designed for high-dimensional classification tasks, supporting lasso (L1) and elastic-net penalties for sparse feature selection and providing options for tuning kernel bandwidth and penalty weights. The 'dcsvm' is applicable to fields such as bioinformatics, image analysis, and text classification, where high-dimensional data commonly arise. Learn more about the methodology and algorithm at Wang, Zhou, Gu, and Zou (2023) &lt;<a href="https://doi.org/10.1109%2FTIT.2022.3222767">doi:10.1109/TIT.2022.3222767</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, methods, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 00:31:20 UTC; boxiang</td>
</tr>
<tr>
<td>Author:</td>
<td>Boxiang Wang [aut, cre],
  Le Zhou [aut],
  Yuwen Gu [aut],
  Hui Zou [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Boxiang Wang &lt;boxiang-wang@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-10 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dcsvm-package'>Density-Convoluted Support Vector Machines</h2><span id='topic+dcsvm-package'></span>

<h3>Description</h3>

<p>This package provides tools to perform density-convoluted support vector machine (DCSVM) modeling for high-dimensional data classification.
</p>


<h3>Details</h3>

<p>This package implements the density-convoluted SVM for high-dimensional classification.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dcsvm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2025-01-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package <code>dcsvm</code> contains five main functions:<br />
</p>

<ul>
<li> <p><code>dcsvm</code>
</p>
</li>
<li> <p><code>cv.dcsvm</code>
</p>
</li>
<li> <p><code>coef.dcsvm</code>
</p>
</li>
<li> <p><code>plot.dcsvm</code>
</p>
</li>
<li> <p><code>plot.cv.dcsvm</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Boxiang Wang, Le Zhou, Yuwen Gu, and Hui Zou<br /> Maintainer:
Boxiang Wang &lt;boxiang-wang@uiowa.edu&gt;
</p>


<h3>References</h3>

<p>Wang, B., Zhou, L., Gu, Y., and Zou, H. (2023)
<em>Density-Convoluted Support Vector Machines for High-Dimensional Classification, IEEE Transactions on Information Theory, Vol. 69(4), 2523-2536</em>,
</p>

<hr>
<h2 id='coef.cv.dcsvm'>Compute Coefficients from a &quot;cv.dcsvm&quot; Object</h2><span id='topic+coef.cv.dcsvm'></span>

<h3>Description</h3>

<p>Computes the coefficients at specified <code>lambda</code> values for a <code>cv.dcsvm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.dcsvm'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.dcsvm_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code> object, obtained by conducting cross-validation on the sparse density-convoluted SVM model.</p>
</td></tr>
<tr><td><code id="coef.cv.dcsvm_+3A_s">s</code></td>
<td>
<p>Value(s) of the L1 tuning parameter <code>lambda</code> for computing coefficients. Default is <code>"lambda.1se"</code>, the largest <code>lambda</code> value achieving a cross-validation error within one standard error of the minimum. Alternatively, <code>"lambda.min"</code> corresponds to the <code>lambda</code> incurring the least cross-validation error. <code>s</code> can also be numeric, specifying the value(s) to use.</p>
</td></tr>
<tr><td><code id="coef.cv.dcsvm_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code><a href="#topic+dcsvm">dcsvm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute Coefficients from a &quot;cv.dcsvm&quot; Object
</p>
<p>Computes coefficients at chosen values of <code>lambda</code> from the <code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code> object.
</p>
<p>This function computes the coefficients for <code>lambda</code> values suggested by cross-validation.
</p>


<h3>Value</h3>

<p>The returned object depends on the choice of <code>s</code> and any additional arguments passed to the <code><a href="#topic+dcsvm">dcsvm</a></code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code> and <code><a href="#topic+predict.cv.dcsvm">predict.cv.dcsvm</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon)
colon$x &lt;- colon$x[ ,1:100] # Use only the first 100 columns for this example
set.seed(1)
cv &lt;- cv.dcsvm(colon$x, colon$y, lam2=1, nfolds=5)
c1 &lt;- coef(cv, s="lambda.1se")

</code></pre>

<hr>
<h2 id='coef.dcsvm'>Compute Coefficients for Sparse Density-Convoluted SVM</h2><span id='topic+coef.dcsvm'></span>

<h3>Description</h3>

<p>Computes the coefficients or indices of nonzero coefficients at specified <code>lambda</code> values from a fitted <code>dcsvm</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcsvm'
coef(object, s = NULL, type = c("coefficients", "nonzero"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.dcsvm_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+dcsvm">dcsvm</a></code> object.</p>
</td></tr>
<tr><td><code id="coef.dcsvm_+3A_s">s</code></td>
<td>
<p>Value(s) of the L1 tuning parameter <code>lambda</code> for computing coefficients. Default is the entire <code>lambda</code> sequence obtained by <code><a href="#topic+dcsvm">dcsvm</a></code>.</p>
</td></tr>
<tr><td><code id="coef.dcsvm_+3A_type">type</code></td>
<td>
<p><code>"coefficients"</code> or <code>"nonzero"</code>? <code>"coefficients"</code> computes the coefficients at given values for <code>s</code>; <code>"nonzero"</code> returns a list of the indices of the nonzero coefficients for each value of <code>s</code>. Default is <code>"coefficients"</code>.</p>
</td></tr>
<tr><td><code id="coef.dcsvm_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>predict</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute Coefficients for Sparse Density-Convoluted SVM
</p>
<p>Computes the coefficients or returns the indices of nonzero coefficients at chosen values of <code>lambda</code> from a fitted <code><a href="#topic+dcsvm">dcsvm</a></code> object.
</p>
<p><code>s</code> is the vector of <code>lambda</code> values at which predictions are requested. If <code>s</code> is not in the lambda sequence used for fitting the model, the <code>coef</code> function uses linear interpolation. The new values are interpolated using a fraction of coefficients from both left and right <code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>Either the coefficients at the requested values of <code>lambda</code>, or a list of the indices of the nonzero coefficients for each <code>lambda</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.dcsvm">predict.dcsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon)
fit &lt;- dcsvm(colon$x, colon$y, lam2=1)
c1 &lt;- coef(fit, type="coefficients", s=c(0.1, 0.005))
c2 &lt;- coef(fit, type="nonzero")

</code></pre>

<hr>
<h2 id='colon'>Simplified Gene Expression Data from Alon et al. (1999)</h2><span id='topic+colon'></span>

<h3>Description</h3>

<p>This dataset contains 62 colon tissue samples with 2000 gene expression levels. Among these samples, 40 are tumor tissues (coded as 1) and 22 are normal tissues (coded as -1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colon)
</code></pre>


<h3>Details</h3>

<p>Simplified Gene Expression Data from Alon et al. (1999)
</p>
<p>Gene expression data (2000 genes for 62 samples) from a DNA microarray experiment of colon tissue samples (Alon et al., 1999).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>A matrix of 62 rows and 2000 columns representing the gene expression levels of 62 colon tissue samples. Each row corresponds to a sample, and each column corresponds to a gene.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A numeric vector of length 62 representing the tissue type (1 for tumor; -1 for normal).</p>
</td></tr>
</table>


<h3>Source</h3>

<p>The data were introduced in Alon et al. (1999).
</p>


<h3>References</h3>

<p>Alon, U., Barkai, N., Notterman, D.A., Gish, K., Ybarra, S., Mack, D., and Levine, A.J. (1999). 
&ldquo;Broad patterns of gene expression revealed by clustering analysis of tumor and normal colon tissues probed by oligonucleotide arrays,&rdquo;
<em>Proceedings of the National Academy of Sciences</em>, <b>96</b>(12), 6745&ndash;6750.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the dcsvm library
library(dcsvm)

# Load the dataset
data(colon)

# Check the dimensions of the data
dim(colon$x)

# Count the number of samples in each class
sum(colon$y == -1)
sum(colon$y == 1)

</code></pre>

<hr>
<h2 id='cv.dcsvm'>Cross-Validation for Sparse Density-Convoluted SVM</h2><span id='topic+cv.dcsvm'></span>

<h3>Description</h3>

<p>Performs cross-validation for the sparse density-convoluted SVM to estimate the optimal tuning parameter <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.dcsvm(x, y, lambda = NULL, hval = 1, 
  pred.loss = c("misclass", "loss"), nfolds = 5, foldid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.dcsvm_+3A_x">x</code></td>
<td>
<p>A matrix of predictors, i.e., the <code>x</code> matrix used in <code><a href="#topic+dcsvm">dcsvm</a></code>.</p>
</td></tr>
<tr><td><code id="cv.dcsvm_+3A_y">y</code></td>
<td>
<p>A vector of binary class labels, i.e., the <code>y</code> used in <code><a href="#topic+dcsvm">dcsvm</a></code>.</p>
</td></tr>
<tr><td><code id="cv.dcsvm_+3A_lambda">lambda</code></td>
<td>
<p>Default is <code>NULL</code>, and the sequence generated by <code><a href="#topic+dcsvm">dcsvm</a></code> is used. User can also provide a new <code>lambda</code> sequence for cross-validation.</p>
</td></tr>
<tr><td><code id="cv.dcsvm_+3A_hval">hval</code></td>
<td>
<p>The bandwidth parameter for kernel smoothing. Default is 1.</p>
</td></tr>
<tr><td><code id="cv.dcsvm_+3A_pred.loss">pred.loss</code></td>
<td>
<p><code>"misclass"</code> for classification error, <code>"loss"</code> for the density-convoluted SVM loss.</p>
</td></tr>
<tr><td><code id="cv.dcsvm_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of folds. Default is 5. The allowable range is from 3 to the sample size. Larger <code>nfolds</code> increases computational time.</p>
</td></tr>
<tr><td><code id="cv.dcsvm_+3A_foldid">foldid</code></td>
<td>
<p>An optional vector with values between 1 and <code>nfold</code>, representing the fold indices for each observation. If supplied, <code>nfolds</code> can be missing.</p>
</td></tr>
<tr><td><code id="cv.dcsvm_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code><a href="#topic+dcsvm">dcsvm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cross-Validation for Sparse Density-Convoluted SVM
</p>
<p>Conducts a k-fold cross-validation for <code><a href="#topic+dcsvm">dcsvm</a></code> and returns the suggested values of the L1 parameter <code>lambda</code>.
</p>
<p>This function runs <code><a href="#topic+dcsvm">dcsvm</a></code> on the sparse density-convoluted SVM by excluding each fold in turn, then computes the mean cross-validation error and standard deviation. It is adapted from the <code>cv</code> functions in the <code>gcdnet</code> and <code>glmnet</code> packages.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code> object is returned, which includes the cross-validation fit:
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>The <code>lambda</code> sequence used in <code><a href="#topic+dcsvm">dcsvm</a></code>.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>A vector of length <code>length(lambda)</code> for the mean cross-validated error.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>A vector of length <code>length(lambda)</code> for estimates of standard error of <code>cvm</code>.</p>
</td></tr>
<tr><td><code>cvupper</code></td>
<td>
<p>The upper curve: <code>cvm + cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlower</code></td>
<td>
<p>The lower curve: <code>cvm - cvsd</code>.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>Number of non-zero coefficients at each <code>lambda</code>.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>&quot;Mis-classification error&quot;, for plotting purposes.</p>
</td></tr>
<tr><td><code>dcsvm.fit</code></td>
<td>
<p>A fitted <code><a href="#topic+dcsvm">dcsvm</a></code> object using the full data.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The <code>lambda</code> incurring the minimum cross-validation error <code>cvm</code>.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error is within one standard error of the minimum.</p>
</td></tr>
<tr><td><code>cv.min</code></td>
<td>
<p>The minimum cross-validation error.</p>
</td></tr>
<tr><td><code>cv.1se</code></td>
<td>
<p>The cross-validation error associated with <code>lambda.1se</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dcsvm">dcsvm</a></code>, <code><a href="#topic+plot.cv.dcsvm">plot.cv.dcsvm</a></code>, <code><a href="#topic+predict.cv.dcsvm">predict.cv.dcsvm</a></code>, and <code><a href="#topic+coef.cv.dcsvm">coef.cv.dcsvm</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon)
colon$x &lt;- colon$x[ ,1:100] # Use only the first 100 columns for this example
n &lt;- nrow(colon$x)
set.seed(1)
id &lt;- sample(n, trunc(n / 3))
cvfit &lt;- cv.dcsvm(colon$x[-id, ], colon$y[-id], lam2=1, nfolds=5)
plot(cvfit)
predict(cvfit, newx=colon$x[id, ], s="lambda.min")

</code></pre>

<hr>
<h2 id='dcsvm'>Density-Convoluted Support Vector Machine</h2><span id='topic+dcsvm'></span>

<h3>Description</h3>

<p>Fits the density-convoluted support vector machine (DCSVM) through kernel density convolutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcsvm(
  x,
  y,
  nlambda = 100,
  lambda.factor = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  lam2 = 0,
  kern = c("gaussian", "uniform", "epanechnikov"),
  hval = 1,
  pf = rep(1, nvars),
  pf2 = rep(1, nvars),
  exclude,
  dfmax = nvars + 1,
  pmax = min(dfmax * 1.2, nvars),
  standardize = TRUE,
  eps = 1e-08,
  maxit = 1e+06,
  istrong = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dcsvm_+3A_x">x</code></td>
<td>
<p>A numeric matrix with <code class="reqn">N</code> rows and <code class="reqn">p</code> columns representing predictors. Each row corresponds to an observation, and each column corresponds to a variable.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_y">y</code></td>
<td>
<p>A numeric vector of length <code class="reqn">N</code> representing binary responses. Elements must be either -1 or 1.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_nlambda">nlambda</code></td>
<td>
<p>Number of <code>lambda</code> values in the sequence. Default is 100.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>Ratio of the smallest to the largest <code>lambda</code> in the sequence: <code>lambda.factor</code> = <code>min(lambda)</code> / <code>max(lambda)</code>. The default value is 0.0001 if <code class="reqn">N &gt;= p</code> or 0.01 if <code class="reqn">N &lt; p</code>. Takes no effect if a <code>lambda</code> sequence is specified.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_lambda">lambda</code></td>
<td>
<p>An optional user-specified sequence of <code>lambda</code> values. If <code>lambda = NULL</code> (default), the sequence is computed based on <code>nlambda</code> and <code>lambda.factor</code>. The program automatically sorts user-defined <code>lambda</code> sequences in decreasing order.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_lam2">lam2</code></td>
<td>
<p>Users may tune <code class="reqn">\lambda_2</code>, which controls the L2 regularization strength. Default is 0 (lasso).</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_kern">kern</code></td>
<td>
<p>Type of kernel method for smoothing. Options are <code>"gaussian"</code>, <code>"uniform"</code>, and <code>"epanechnikov"</code>. Default is <code>"epanechnikov"</code>.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_hval">hval</code></td>
<td>
<p>The bandwidth parameter for kernel smoothing. Default is 1.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_pf">pf</code></td>
<td>
<p>A numeric vector of length <code class="reqn">p</code> representing the L1 penalty weights for each coefficient. A common choice is <code class="reqn">(\beta + 1/n)^{-1}</code>, where <code class="reqn">n</code> is the sample size and <code class="reqn">\beta</code> is obtained from L1 DCSVM or enet DCSVM. Default is 1 for all predictors.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_pf2">pf2</code></td>
<td>
<p>A numeric vector of length <code class="reqn">p</code> representing the L2 penalty weights for each coefficient. A value of 0 indicates no L2 shrinkage. Default is 1 for all predictors.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_exclude">exclude</code></td>
<td>
<p>Indices of predictors to exclude from the model. Equivalent to assigning an infinite penalty factor. Default is none.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_dfmax">dfmax</code></td>
<td>
<p>Maximum number of nonzero coefficients allowed in the model. Default is <code class="reqn">p + 1</code>. Useful for large <code class="reqn">p</code> when a partial path is acceptable.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_pmax">pmax</code></td>
<td>
<p>Maximum number of variables allowed to ever be nonzero during the computation. Default is <code>min(dfmax * 1.2, p)</code>.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_standardize">standardize</code></td>
<td>
<p>Logical indicating whether predictors should be standardized to unit variance. Default is <code>TRUE</code>. Note that predictors are always centered.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold. The algorithm stops when <code class="reqn">4\max_j(\beta_j^{new} - \beta_j^{old})^2</code> is less than <code>eps</code>. Default is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations allowed. Default is <code>1e6</code>. Consider increasing <code>maxit</code> if the algorithm does not converge.</p>
</td></tr>
<tr><td><code id="dcsvm_+3A_istrong">istrong</code></td>
<td>
<p>Logical indicating whether to use the strong rule for faster computation. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dcsvm</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>b0</code></td>
<td>
<p>Intercept values for each <code>lambda</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Sparse matrix of coefficients for each <code>lambda</code>. Use <code>as.matrix()</code> to convert.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Number of nonzero coefficients for each <code>lambda</code>.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Dimensions of the coefficient matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Sequence of <code>lambda</code> values used.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>Total number of iterations across all <code>lambda</code> values.</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>Warnings and errors. 0 if no errors.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>print.dcsvm</code>, <code>predict.dcsvm</code>, <code>coef.dcsvm</code>, <code>plot.dcsvm</code>, and <code>cv.dcsvm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data
data(colon)
# Fit the elastic-net penalized DCSVM with lambda2 to be 1
fit &lt;- dcsvm(colon$x, colon$y, lam2 = 1)
print(fit)
# Coefficients at some lambda value
c1 &lt;- coef(fit, s = 0.005)
# Make predictions
predict(fit, newx = colon$x[1:10, ], s = c(0.01, 0.005))

</code></pre>

<hr>
<h2 id='dcsvm-internal'>Internal DCSVM Functions</h2><span id='topic+dcsvm-internal'></span><span id='topic+cv.gaussian'></span><span id='topic+cv.uniform'></span><span id='topic+cv.epanechnikov'></span><span id='topic+cvcompute'></span><span id='topic+dcsvm.gauss'></span><span id='topic+dcsvm.unif'></span><span id='topic+dcsvm.epane'></span><span id='topic+err'></span><span id='topic+error.bars'></span><span id='topic+getmin'></span><span id='topic+getoutput'></span><span id='topic+lambda.interp'></span><span id='topic+lamfix'></span><span id='topic+loss.epanechnikov'></span><span id='topic+loss.gaussian'></span><span id='topic+loss.uniform'></span><span id='topic+nonzero'></span><span id='topic+zeromat'></span>

<h3>Description</h3>

<p>These internal functions are not intended for direct use by users. 
For example, <code>err</code> obtains error messages from Fortran code, 
<code>error.bars</code> helps to plot cross-validation error curves, 
and <code>getmin</code> identifies the best <code>lambda</code> through cross-validation.
Other functions assist with kernel loss computations, coefficient management, and interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.gaussian(outlist, lambda, x, y, foldid, pred.loss, hval)
cv.uniform(outlist, lambda, x, y, foldid, pred.loss, hval)
cv.epanechnikov(outlist, lambda, x, y, foldid, pred.loss, hval)
cvcompute(mat, foldid, nlams)
dcsvm.gauss(x, y, alpha, lam2, hval, nlam, flmin, ulam, isd, eps, dfmax, pmax, jd, 
  pfncol, pf, pf2, maxit, istrong, nobs, nvars, vnames)
dcsvm.unif(x, y, alpha, lam2, hval, nlam, flmin, ulam, isd, eps, dfmax, pmax, jd, 
  pfncol, pf, pf2, maxit, istrong, nobs, nvars, vnames)
dcsvm.epane(x, y, alpha, lam2, hval, nlam, flmin, ulam, isd, eps, dfmax, pmax, jd, 
  pfncol, pf, pf2, maxit, istrong, nobs, nvars, vnames)
err(n, maxit, pmax)
error.bars(x, upper, lower, width = 0.02, ...)
getmin(lambda, cvm, cvsd)
getoutput(fit, maxit, pmax, nvars, vnames)
lambda.interp(lambda, s)
lamfix(lam)
loss.epanechnikov(u, hval)
loss.gaussian(u, hval)
loss.uniform(u, hval)
nonzero(beta, bystep = FALSE)
zeromat(nvars, nalam, vnames, stepnames)
</code></pre>


<h3>Details</h3>

<p>Internal DCSVM Functions
</p>
<p>Internal helper functions for the DCSVM package.
</p>
<p>Most of these functions are adapted or directly copied from the <code>gcdnet</code> and <code>glmnet</code> packages.
</p>

<hr>
<h2 id='plot.cv.dcsvm'>Plot the Cross-Validation Curve of Sparse Density-Convoluted SVM</h2><span id='topic+plot.cv.dcsvm'></span>

<h3>Description</h3>

<p>Depicts the cross-validation curves for the sparse density-convoluted SVM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.dcsvm'
plot(x, sign.lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cv.dcsvm_+3A_x">x</code></td>
<td>
<p>A fitted <code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.cv.dcsvm_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>Specifies whether to plot against <code>log(lambda)</code> (default) or its negative if <code>sign.lambda = -1</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.dcsvm_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the Cross-Validation Curve of Sparse Density-Convoluted SVM
</p>
<p>Plots the cross-validation curve against a function of <code>lambda</code> values, including upper and lower standard deviation curves.
</p>
<p>This function visualizes the cross-validation curves for a <code>cv.dcsvm</code> object, which plots the relationship between <code>lambda</code> values and cross-validation error.
</p>


<h3>Value</h3>

<p>No return value, only called for plots.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon)
colon$x &lt;- colon$x[ ,1:100] # Use only the first 100 columns for this example
set.seed(1)
cv &lt;- cv.dcsvm(colon$x, colon$y, lam2=1, nfolds=5)
plot(cv)

</code></pre>

<hr>
<h2 id='plot.dcsvm'>Plot Coefficients for Sparse Density-Convoluted SVM</h2><span id='topic+plot.dcsvm'></span>

<h3>Description</h3>

<p>Plots the solution paths as a coefficient profile plot for a fitted <code>dcsvm</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcsvm'
plot(x, xvar = c("norm", "lambda"), color = FALSE, label = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dcsvm_+3A_x">x</code></td>
<td>
<p>A fitted <code><a href="#topic+dcsvm">dcsvm</a></code> model.</p>
</td></tr>
<tr><td><code id="plot.dcsvm_+3A_xvar">xvar</code></td>
<td>
<p>Specifies the X-axis. If <code>xvar == "norm"</code>, plots against the L1-norm of the coefficients; if <code>xvar == "lambda"</code>, plots against the log-lambda sequence.</p>
</td></tr>
<tr><td><code id="plot.dcsvm_+3A_color">color</code></td>
<td>
<p>If <code>TRUE</code>, plots the curves with rainbow colors; otherwise, with gray colors (default).</p>
</td></tr>
<tr><td><code id="plot.dcsvm_+3A_label">label</code></td>
<td>
<p>If <code>TRUE</code>, labels the curves with variable sequence numbers. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.dcsvm_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot Coefficients for Sparse Density-Convoluted SVM
</p>
<p>Plots the solution paths for a fitted <code><a href="#topic+dcsvm">dcsvm</a></code> object.
</p>
<p>This function generates a coefficient profile plot showing the solution paths of the sparse density-convoluted SVM.
</p>


<h3>Value</h3>

<p>No return value, only called for plots.
</p>


<h3>See Also</h3>

<p><code>print.dcsvm</code>, <code>predict.dcsvm</code>, <code>coef.dcsvm</code>, <code>plot.dcsvm</code>, and <code>cv.dcsvm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon)
fit &lt;- dcsvm(colon$x, colon$y)
oldpar &lt;- par(mfrow = c(1,3)) #changes par() and stores original par()
# Plots against the L1-norm of the coefficients
plot(fit)
# Plots against the log-lambda sequence
plot(fit, xvar="lambda", label=TRUE)
# Plots with colors
plot(fit, color=TRUE)
# Reset to user's option
par(oldpar)

</code></pre>

<hr>
<h2 id='predict.cv.dcsvm'>Make Predictions from a &quot;cv.dcsvm&quot; Object</h2><span id='topic+predict.cv.dcsvm'></span>

<h3>Description</h3>

<p>Predicts class labels for new data based on the cross-validated <code>lambda</code> values from a <code>cv.dcsvm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.dcsvm'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.dcsvm_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.cv.dcsvm_+3A_newx">newx</code></td>
<td>
<p>A matrix of new values for <code>x</code> at which predictions are to be made. Must be a matrix. See documentation for <code>predict.dcsvm</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.dcsvm_+3A_s">s</code></td>
<td>
<p>Value(s) of the L1 tuning parameter <code>lambda</code> for making predictions. Default is <code>s = "lambda.1se"</code> saved in the <code>cv.dcsvm</code> object. An alternative choice is <code>s = "lambda.min"</code>. <code>s</code> can also be numeric, representing the specific value(s) to use.</p>
</td></tr>
<tr><td><code id="predict.cv.dcsvm_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>predict</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Make Predictions from a &quot;cv.dcsvm&quot; Object
</p>
<p>This function predicts the class labels of new observations using the sparse density-convoluted SVM at the <code>lambda</code> values suggested by <code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code>.
</p>
<p>This function uses the cross-validation results to make predictions. It is adapted from the <code>predict.cv</code> function in the <code>glmnet</code> and <code>gcdnet</code> packages.
</p>


<h3>Value</h3>

<p>Predicted class labels or fitted values, depending on the choice of <code>s</code> and any arguments passed to the <code><a href="#topic+dcsvm">dcsvm</a></code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.dcsvm">cv.dcsvm</a></code>, and <code><a href="#topic+coef.cv.dcsvm">coef.cv.dcsvm</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon)
colon$x &lt;- colon$x[ , 1:100] # Use only the first 100 columns for this example
set.seed(1)
cv &lt;- cv.dcsvm(colon$x, colon$y, lam2=1, nfolds=5)
predict(cv$dcsvm.fit, newx=colon$x[2:5, ], 
  s=cv$lambda.1se, type="class")

</code></pre>

<hr>
<h2 id='predict.dcsvm'>Make Predictions for Sparse Density-Convoluted SVM</h2><span id='topic+predict.dcsvm'></span>

<h3>Description</h3>

<p>Predicts binary class labels or fitted values for a <code>dcsvm</code> model using new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcsvm'
predict(object, newx, s = NULL, type = c("class", "link"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.dcsvm_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+dcsvm">dcsvm</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.dcsvm_+3A_newx">newx</code></td>
<td>
<p>A matrix of new values for <code>x</code> at which predictions are to be made. Note that <code>newx</code> must be a matrix; vectors or other formats are not accepted.</p>
</td></tr>
<tr><td><code id="predict.dcsvm_+3A_s">s</code></td>
<td>
<p>Value(s) of the L1 tuning parameter <code>lambda</code> for computing coefficients. Default is the entire <code>lambda</code> sequence obtained by <code><a href="#topic+dcsvm">dcsvm</a></code>.</p>
</td></tr>
<tr><td><code id="predict.dcsvm_+3A_type">type</code></td>
<td>
<p><code>"class"</code> or <code>"link"</code>? <code>"class"</code> produces the predicted binary class labels, while <code>"link"</code> returns the fitted values. Default is <code>"class"</code>.</p>
</td></tr>
<tr><td><code id="predict.dcsvm_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>predict</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Make Predictions for Sparse Density-Convoluted SVM
</p>
<p>This function predicts the binary class labels or the fitted values of a <code><a href="#topic+dcsvm">dcsvm</a></code> object.
</p>
<p><code>s</code> represents the new <code>lambda</code> values for making predictions. If <code>s</code> is not part of the original <code>lambda</code> sequence generated by <code><a href="#topic+dcsvm">dcsvm</a></code>, <code>predict.dcsvm</code> uses linear interpolation to compute predictions by combining adjacent <code>lambda</code> values in the original sequence. This functionality is adapted from the <code>predict</code> methods in the <code>glmnet</code> and <code>gcdnet</code> packages.
</p>


<h3>Value</h3>

<p>Returns either the predicted class labels or the fitted values, depending on the choice of <code>type</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.dcsvm">coef.dcsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon)
fit &lt;- dcsvm(colon$x, colon$y, lam2=1)
print(predict(fit, type="class", newx=colon$x[2:5, ]))

</code></pre>

<hr>
<h2 id='print.dcsvm'>Print a DCSVM Object</h2><span id='topic+print.dcsvm'></span>

<h3>Description</h3>

<p>Prints a summary of the <code>dcsvm</code> object, showing the solution paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcsvm'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.dcsvm_+3A_x">x</code></td>
<td>
<p>A fitted <code><a href="#topic+dcsvm">dcsvm</a></code> object.</p>
</td></tr>
<tr><td><code id="print.dcsvm_+3A_digits">digits</code></td>
<td>
<p>Specifies the significant digits to use in the output. Default is <code>max(3, getOption("digits") - 3)</code>.</p>
</td></tr>
<tr><td><code id="print.dcsvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print a DCSVM Object
</p>
<p>Print a summary of the <code><a href="#topic+dcsvm">dcsvm</a></code> solution paths.
</p>
<p>This function prints a two-column matrix with columns <code>Df</code> and <code>Lambda</code>. The <code>Df</code> column shows the number of nonzero coefficients, and the <code>Lambda</code> column displays the corresponding <code>lambda</code> value. It is adapted from the <code>print</code> function in the <code>gcdnet</code> and <code>glmnet</code> packages.
</p>


<h3>Value</h3>

<p>A two-column matrix with one column showing the number of nonzero coefficients and the other column showing the <code>lambda</code> values.
</p>


<h3>See Also</h3>

<p><code>print.dcsvm</code>, <code>predict.dcsvm</code>, <code>coef.dcsvm</code>, <code>plot.dcsvm</code>, and <code>cv.dcsvm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon)
fit &lt;- dcsvm(colon$x, colon$y)
print(fit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
