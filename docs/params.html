<!DOCTYPE html><html><head><title>Help for package params</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {params}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_args'><p>Assert none of the arguments of a function are null.</p></a></li>
<li><a href='#fix_column_names'><p>fix_column_names</p></a></li>
<li><a href='#fix_names'><p>fix_names</p></a></li>
<li><a href='#kable'><p>Create tables in LaTeX, HTML, Markdown and reStructuredText</p></a></li>
<li><a href='#load_opts'><p>Setting/loading and extracting various options into the environment</p></a></li>
<li><a href='#opts'><p>default opts</p></a></li>
<li><a href='#parse_opts'><p>Parse options to expand <code>{{variable}}</code> into their respective values</p></a></li>
<li><a href='#read_sheet'><p>Read/Write sheets (automatically detect the file type and work accordingly)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simplify Parameters</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface to simplify organizing parameters used in a package,
    using external configuration files. This attempts to provide a cleaner
    alternative to options().</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), whisker</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, RcppTOML, glue, readr (&ge; 1.4.0), purrr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>openxlsx, testthat, knitr, utf8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sahilseth/params">https://github.com/sahilseth/params</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sahilseth/params/issues">https://github.com/sahilseth/params/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-01 19:24:54 UTC; sahilseth</td>
</tr>
<tr>
<td>Author:</td>
<td>Sahil Seth [aut, cre],
  Yihui Xie [ctb] (kable from knitr R/table.R)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sahil Seth &lt;me@sahilseth.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-01 20:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_args'>Assert none of the arguments of a function are null.</h2><span id='topic+check_args'></span>

<h3>Description</h3>

<p>Checks all the arguments in the parent function and makes sure that none of them
are NULL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_args(ignore, select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_args_+3A_ignore">ignore</code></td>
<td>
<p>optionally ignore a few variables for checking [character vector].</p>
</td></tr>
<tr><td><code id="check_args_+3A_select">select</code></td>
<td>
<p>optionally only check a few variables of the function [character vector].</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
myfunc &lt;- function(verbose = get_opts("verbose"), b = get_opts("b")){
  check_args()
}

set_opts(verbose = 1)
## this will throw an error, suggesting b is not defined properly
try(myfunc())


</code></pre>

<hr>
<h2 id='fix_column_names'>fix_column_names</h2><span id='topic+fix_column_names'></span>

<h3>Description</h3>

<p>removes special chars from names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_column_names(x, char = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_column_names_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="fix_column_names_+3A_char">char</code></td>
<td>
<p>replace special characters with this symbol</p>
</td></tr>
</table>

<hr>
<h2 id='fix_names'>fix_names</h2><span id='topic+fix_names'></span>

<h3>Description</h3>

<p>Replace special characters in column names of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_names(x, char = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_names_+3A_x">x</code></td>
<td>
<p>a vector of column names</p>
</td></tr>
<tr><td><code id="fix_names_+3A_char">char</code></td>
<td>
<p>substitute special char with this.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>make.names
</p>

<hr>
<h2 id='kable'>Create tables in LaTeX, HTML, Markdown and reStructuredText</h2><span id='topic+kable'></span>

<h3>Description</h3>

<p>This is a very simple table generator. It is simple by design. It is not
intended to replace any other R packages for making tables.
This is a trimmed down version of the original kable function in knitr package.
Please refer to knitr's <a href="knitr.html#topic+kable">kable</a> function for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kable(
  x,
  format,
  digits = getOption("digits"),
  row.names = NA,
  col.names = colnames(x),
  align,
  caption = NULL,
  escape = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kable_+3A_x">x</code></td>
<td>
<p>an R object (typically a matrix or data frame)</p>
</td></tr>
<tr><td><code id="kable_+3A_format">format</code></td>
<td>
<p>a character string; possible values are <code>latex</code>,
<code>html</code>, <code>markdown</code>, <code>pandoc</code>, and <code>rst</code>; this will be
automatically determined if the function is called within <span class="pkg">knitr</span>; it
can also be set in the global option <code>knitr.table.format</code></p>
</td></tr>
<tr><td><code id="kable_+3A_digits">digits</code></td>
<td>
<p>the maximum number of digits for numeric columns (passed to
<code>round()</code>); it can also be a vector of length <code>ncol(x)</code> to set
the number of digits for individual columns</p>
</td></tr>
<tr><td><code id="kable_+3A_row.names">row.names</code></td>
<td>
<p>a logical value indicating whether to include row names; by
default, row names are included if <code>rownames(x)</code> is neither
<code>NULL</code> nor identical to <code>1:nrow(x)</code></p>
</td></tr>
<tr><td><code id="kable_+3A_col.names">col.names</code></td>
<td>
<p>a character vector of column names to be used in the table</p>
</td></tr>
<tr><td><code id="kable_+3A_align">align</code></td>
<td>
<p>the alignment of columns: a character vector consisting of
<code>'l'</code> (left), <code>'c'</code> (center) and/or <code>'r'</code> (right); by
default, numeric columns are right-aligned, and other columns are
left-aligned; if <code>align = NULL</code>, the default alignment is used</p>
</td></tr>
<tr><td><code id="kable_+3A_caption">caption</code></td>
<td>
<p>the table caption</p>
</td></tr>
<tr><td><code id="kable_+3A_escape">escape</code></td>
<td>
<p>escape special characters when producing HTML or LaTeX tables</p>
</td></tr>
<tr><td><code id="kable_+3A_...">...</code></td>
<td>
<p>other arguments (see examples)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yihui Xie <a href="http://yihui.org">http://yihui.org</a>
</p>

<hr>
<h2 id='load_opts'>Setting/loading and extracting various options into the environment</h2><span id='topic+load_opts'></span><span id='topic+load_toml'></span><span id='topic+params'></span><span id='topic+new_opts'></span><span id='topic+get_opts'></span><span id='topic+set_opts'></span><span id='topic+print.opts'></span>

<h3>Description</h3>


<ul>
<li><p> set_opts(): set options into a custom envir
</p>
</li>
<li><p> get_opts(): extract options
</p>
</li>
<li><p> load_opts(): Read a tab delimited file using <a href="#topic+read_sheet">read_sheet</a> or toml file and load them as options using <a href="#topic+set_opts">set_opts</a>
</p>
</li>
<li><p> new_opts(): create a options manager to be included in a pacakge
</p>
</li>
<li><p> print.opts(): print pkg options as a pretty table
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>load_opts(x, check = TRUE, envir = opts, verbose = TRUE, .parse = TRUE, ...)

load_toml(toml, .remove_period = T, envir = envir, verbose = T)

new_opts(envir = new.env())

get_opts(x, envir = opts, .use.names = FALSE)

set_opts(..., .dots, .parse = TRUE, envir = opts)

## S3 method for class 'opts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_opts_+3A_x">x</code></td>
<td>

<ul>
<li><p> get_opts: a character vector of names of options to extract.
</p>
</li>
<li><p> load_opts: path to a configuration file
</p>
</li></ul>
</td></tr>
<tr><td><code id="load_opts_+3A_check">check</code></td>
<td>
<p>load_opts(): in case of a configuration file, whether to check if files defined in parameters exists. [TRUE]</p>
</td></tr>
<tr><td><code id="load_opts_+3A_envir">envir</code></td>
<td>
<p>environ used to store objects. Default is a environ object called opts [params:::opts]</p>
</td></tr>
<tr><td><code id="load_opts_+3A_verbose">verbose</code></td>
<td>
<p>load_opts(): Logical variable indicate level of verboseness [TRUE]</p>
</td></tr>
<tr><td><code id="load_opts_+3A_.parse">.parse</code></td>
<td>
<p>set_opts(), load_opts(): logical, whether to auto-complete <code>{{myvar}}</code> using previously defined options. [TRUE]</p>
</td></tr>
<tr><td><code id="load_opts_+3A_...">...</code></td>
<td>
<p>set_opts(): a named set of variable/value pairs separated by comma</p>
</td></tr>
<tr><td><code id="load_opts_+3A_toml">toml</code></td>
<td>
<p>load_toml(): instead of a tsv, use toml to load options</p>
</td></tr>
<tr><td><code id="load_opts_+3A_.remove_period">.remove_period</code></td>
<td>
<p>load_opts(): remove \. period from option names (and replace with _)</p>
</td></tr>
<tr><td><code id="load_opts_+3A_.use.names">.use.names</code></td>
<td>
<p>get_opts(): The resulting vector should be have names (esp. if length(x) is 1). If length(x)&gt;1, this returns a list.</p>
</td></tr>
<tr><td><code id="load_opts_+3A_.dots">.dots</code></td>
<td>
<p>set_opts(): A named list, as a alternative to ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Integrating <a href="#topic+params">params</a> in a package:</strong>
</p>
<p><em>create a options manager</em>:
</p>
<p><code>
opts_mypkg = new_opts()
</code>
</p>
<p>The object <code>opts_mypkg</code> is a list of a few functions, which set, fetch and load
options (using a isolated environment). Here are a few examples:
</p>
<p><em>Set some options</em>:
</p>
<p><code>opts_mypkg$set(version = '0.1', name = 'mypkg')</code>
</p>
<p><em>Fetch ALL options</em>:
</p>
<p><code>opts_mypkg$get()</code>
OR
<code>opts_mypkg$get("version")</code> to fetch a specific option.
</p>
<p><strong>Loading configuration files</strong>:
</p>
<p><code>load_opts()</code> OR <code>opts_pkg$load()</code>:
</p>
<p>There are cases when options and params are actually paths to scripts or other apps or folders etc.
In such cases it might be useful to quickly check if these paths exists on the system.
As such, <a href="#topic+load_opts">load_opts</a>() automatically checks params ending with <code>path|dir|exe</code> (if check=TRUE).
</p>
<p>For example, values for variables like <code>mypath</code>, <code>my_path</code>, <code>tool_exe</code>, etc would be check if they exists
and a warning would be shown if they don't exist.
</p>
<p>Below is a list example options, retrieved via
</p>
<p><code>get_opts()</code>:
</p>
<pre>
|name          |value            |
|default_regex |(.*)             |
|my_conf_path  |~/flowr/conf     |
|my_dir        |path/to/a/folder |
|my_path       |~/flowr          |
|my_tool_exe   |/usr/bin/ls      |
</pre>


<h3>See Also</h3>

<p><a href="#topic+read_sheet">read_sheet</a>
</p>
<p><a href="#topic+read_sheet">read_sheet</a>
</p>
<p><a href="#topic+read_sheet">read_sheet</a> <a href="#topic+load_opts">load_opts</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set options
opts = set_opts(flow_run_path = "~/mypath")
#OR
opts = set_opts(.dots = list(flow_run_path = "~/mypath"))

## printing options, this is internally called by get_opts()
print(opts)

## Fetch options
get_opts()
get_opts("flow_run_path")

## Load options from a file
fl = system.file("conf/params.conf", package = "params")
load_opts(fl)


## Create a options manager:
opts_mypkg = new_opts()
## this provides three functions
opts_mypkg$set(version = '0.1', name = 'mypkg')
opts_mypkg$load(fl)
opts_mypkg$get()

## Additionally, one has the options of using braces ({{}})
## do define nested options:

set_opts(first = "John", last = "Doe", full = "{{first}} {{last}}")

</code></pre>

<hr>
<h2 id='opts'>default opts</h2><span id='topic+opts'></span>

<h3>Description</h3>

<p>default opts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 6.
</p>

<hr>
<h2 id='parse_opts'>Parse options to expand <code>{{variable}}</code> into their respective values</h2><span id='topic+parse_opts'></span>

<h3>Description</h3>

<p>This function is internally called by <a href="#topic+set_opts">set_opts</a> and <a href="#topic+load_opts">load_opts</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_opts(lst, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_opts_+3A_lst">lst</code></td>
<td>
<p>a list of configuration options to parse</p>
</td></tr>
<tr><td><code id="parse_opts_+3A_envir">envir</code></td>
<td>
<p>environ used to store objects. Default is a environ object called opts [params:::opts]</p>
</td></tr>
</table>

<hr>
<h2 id='read_sheet'>Read/Write sheets (automatically detect the file type and work accordingly)</h2><span id='topic+read_sheet'></span><span id='topic+write_sheet'></span>

<h3>Description</h3>

<p>Read/Write sheets (automatically detect the file type and work accordingly)
</p>
<p>write_sheet requires version 0.3.1.
</p>

<ul>
<li> <p><strong>tsv, txt, conf, def</strong>: assumed to be tab-delimited
</p>
</li>
<li> <p><strong>csv</strong>: assumed to be comma delimited
</p>
</li>
<li> <p><strong>xlsx</strong>: microsoft excel, uses openxlsx to read the sheet.
Also, it removes extra columns which often creep into excel files.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>read_sheet(
  x,
  id_column,
  start_row = 1,
  sheet = 1,
  ext,
  header = TRUE,
  verbose = FALSE,
  ...
)

write_sheet(x, file, ext, type = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_sheet_+3A_x">x</code></td>
<td>
<p>read: path to a file, to be read. write: a data.frame</p>
</td></tr>
<tr><td><code id="read_sheet_+3A_id_column">id_column</code></td>
<td>
<p>all rows which have this column as blank are skipped. See details.</p>
</td></tr>
<tr><td><code id="read_sheet_+3A_start_row">start_row</code></td>
<td>
<p>supplied to read.xlsx</p>
</td></tr>
<tr><td><code id="read_sheet_+3A_sheet">sheet</code></td>
<td>
<p>supplied to read.xlsx, index or name of the sheet to be read from excel file. See <a href="openxlsx.html#topic+read.xlsx">read.xlsx</a></p>
</td></tr>
<tr><td><code id="read_sheet_+3A_ext">ext</code></td>
<td>
<p>determined using file extension. Specifying will override</p>
</td></tr>
<tr><td><code id="read_sheet_+3A_header">header</code></td>
<td>
<p>first line is header? See <a href="utils.html#topic+read.table">read.table</a></p>
</td></tr>
<tr><td><code id="read_sheet_+3A_verbose">verbose</code></td>
<td>
<p>verbosity level.</p>
</td></tr>
<tr><td><code id="read_sheet_+3A_...">...</code></td>
<td>
<p>passed onto read.xlsx of openxlsx, read.table or read.csv2 depending on the file type.</p>
</td></tr>
<tr><td><code id="read_sheet_+3A_file">file</code></td>
<td>
<p>write: output file name.</p>
</td></tr>
<tr><td><code id="read_sheet_+3A_type">type</code></td>
<td>
<p>in case of writing an xlsx file, should the data.frame to written as excel 'table'. ['table']</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note: for excel sheets</strong>:
</p>

<ul>
<li><p> If <code>id_column</code> is missing, default if first column
</p>
</li>
<li><p> If <code>sheet</code> is missing, it automatically reads the first sheet
</p>
</li></ul>

<p><strong>Some important default values for tsv and csv files</strong>:
</p>
<p><code>stringsAsFactors = FALSE,comment.char = '#', strip.white=TRUE, blank.lines.skip=TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## read a excel sheet
sheet = read_sheet(system.file("extdata/example.xlsx", package = "params"))

## read a comma separated sheet
csv = read_sheet(system.file("extdata/example.csv", package = "params"))

## read a tab separate sheet
tsv = read_sheet(system.file("extdata/example.tsv", package = "params"))


# write sheets -------

## Not run: 
# throws a R CMD check note - don't run
## write a comma separated sheet
write_sheet(sheet, "example.csv")

## write a tab separated sheet
write_sheet(sheet, "example.tsv")

## write an excel separated sheet
write_sheet(sheet, "example.xlsx")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
