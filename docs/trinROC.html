<!DOCTYPE html><html><head><title>Help for package trinROC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {trinROC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot.test'><p>Bootstrap test for three-class ROC data</p></a></li>
<li><a href='#boxcoxROC'><p>Box-Cox transformation on three-class ROC data</p></a></li>
<li><a href='#cancer'><p>Synthetic data set to investigate three-class ROC data.</p></a></li>
<li><a href='#emp.vus'><p>Empirical VUS calculation</p></a></li>
<li><a href='#findmu'><p>Determine equidistant means of trinormal ROC data simulation</p></a></li>
<li><a href='#krebs'><p>Synthetic small data set to investigate three-class ROC data.</p></a></li>
<li><a href='#roc.eda'><p>Exploratory data analysis for a three-class ROC marker</p></a></li>
<li><a href='#roc3.test'><p>Statistical test function for computing multiple tests on three-class ROC data</p></a></li>
<li><a href='#rocsurf.emp'><p>Empirical ROC surface plot</p></a></li>
<li><a href='#rocsurf.trin'><p>Trinormal ROC surface plot</p></a></li>
<li><a href='#trinROC-package'><p>trinROC: Statistical Tests for Assessing Trinormal ROC Data</p></a></li>
<li><a href='#trinROC.test'><p>Trinormal based ROC test</p></a></li>
<li><a href='#trinVUS.test'><p>Trinormal VUS test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Tests for Assessing Trinormal ROC Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Several statistical test functions as well as a function for exploratory data analysis to investigate classifiers allocating individuals to one of three disjoint and ordered classes. In a single classifier assessment the discriminatory power is compared to classification by chance. In a comparison of two classifiers the null hypothesis corresponds to equal discriminatory power of the two classifiers.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, rgl, gridExtra</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, MASS, reshape</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://math.uzh.ch/pages/trinROC/">https://math.uzh.ch/pages/trinROC/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://git.math.uzh.ch/reinhard.furrer/trinROC/-/issues">https://git.math.uzh.ch/reinhard.furrer/trinROC/-/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-27 16:55:12 UTC; furrer</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel Noll [aut],
  Reinhard Furrer [aut],
  Benjamin Reiser [ctb],
  Christos T. Nakas [ctb],
  Annina Cincera [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Annina Cincera &lt;annina.cincera@math.uzh.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-27 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='boot.test'>Bootstrap test for three-class ROC data</h2><span id='topic+boot.test'></span>

<h3>Description</h3>

<p>A statistical test function to assess three-class ROC data. It can be used
for assessment of a single classifier or comparison of two independent /
correlated classifiers, using the Bootstrap test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.test(
  x1,
  y1,
  z1,
  x2 = 0,
  y2 = 0,
  z2 = 0,
  dat = NULL,
  paired = FALSE,
  n.boot = 1000,
  conf.level = 0.95,
  alternative = c("two.sided", "less", "greater")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.test_+3A_x1">x1</code>, <code id="boot.test_+3A_y1">y1</code>, <code id="boot.test_+3A_z1">z1</code></td>
<td>
<p>Non-empty numeric vectors of data from the healthy,
intermediate and diseased class from Classifier 1.</p>
</td></tr>
<tr><td><code id="boot.test_+3A_x2">x2</code>, <code id="boot.test_+3A_y2">y2</code>, <code id="boot.test_+3A_z2">z2</code></td>
<td>
<p>Numeric vectors of data from the healthy, intermediate and
diseased class from Classifier 2, only needed in a comparison of two
classifiers.</p>
</td></tr>
<tr><td><code id="boot.test_+3A_dat">dat</code></td>
<td>
<p>A data frame of the following structure: The first column
represents a factor with three levels, containing the true class membership
of each measurement. The levels are ordered according to the convention of
higher values for more severe disease status. The second column contains
all measurements obtained from Classifier 1 (in the case of single marker
assessment). In the case of comparison of two markers, column three
contains the measurementss from the Classifier.</p>
</td></tr>
<tr><td><code id="boot.test_+3A_paired">paired</code></td>
<td>
<p>A logical indicating whether data arose from a paired setting.
If <code>TRUE</code>, each class must have equal sample size for both
classifiers.</p>
</td></tr>
<tr><td><code id="boot.test_+3A_n.boot">n.boot</code></td>
<td>
<p>An integer incicating the number of bootstrap replicates
sampled to obtain the variance of the VUS. Default is 1000.</p>
</td></tr>
<tr><td><code id="boot.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval. A numeric value between (0,1)
yielding the significance level <code class="reqn">\alpha=1-\code{conf.level}</code>.</p>
</td></tr>
<tr><td><code id="boot.test_+3A_alternative">alternative</code></td>
<td>
<p>character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>. You can specify
just the initial letter. For two sided test, notice <code class="reqn">H0: Z = (VUS_1-VUS_2) /
(Var(VUS_1)+Var(VUS_2)-2Cov(VUS_1,VUS_2))^{0.5}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the reference standard, the Bootstrap test assesses the
discriminatory power of classifiers by comparing the volumes under the ROC
surfaces (VUS). It distinguishes between single classifier assessment,
where a classifier is compared to the chance plane with VUS=1/6, and
comparison between two classifiers. The latter case tests the equality
between VUS_1 and VUS_2. The data can arise in a unpaired or paired
setting. If <code>paired</code> is <code>TRUE</code>, a correlation is introduced which
has to be taken into account. Therefore the sets of the two classifiers
have to have classwise equal size. The data can be input as the data
frame <code>dat</code> or as single vectors <code>x1, y1, z1, ...</code>. The
implemented methods to evaluate the <code>VUS</code> and <code>var(VUS),
  cov(vus.1,vus.2)</code> are based on the empirical model assumptions and
resampling techniques. This means, there are no underlying distributions
assumed in any of the classes.
</p>


<h3>Value</h3>

<p>A list of class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Z-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>a data frame containing the
estimated parameters from Classifier 1 and Classifier 2 (if specified).</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>a character expressing the null hypothesis.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of extended
Metz&ndash;Kronman test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr>
<tr><td><code>Summary</code></td>
<td>
<p>A data frame representing the number of NA's as well as the
means and the standard deviations per class.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>The covariance matrix of the VUS.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nakas, C. T. and C. T. Yiannoutsos (2004). Ordered multiple-class
ROC analysis with continuous measurements. <em>Statistics in
Medicine</em>, <b>23</b>(22), 3437–3449.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trinROC.test">trinROC.test</a></code>, <code><a href="#topic+trinVUS.test">trinVUS.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer)
data(krebs)

# investigate a single marker:
boot.test(dat = krebs[,c(1,2)], n.boot=500)

# result is equal to:
x1 &lt;- with(krebs, krebs[trueClass=="healthy", 2])
y1 &lt;- with(krebs, krebs[trueClass=="intermediate", 2])
z1 &lt;- with(krebs, krebs[trueClass=="diseased", 2])
boot.test(x1, y1, z1, n.boot=500) 

# comparison of marker 2 and 6:
boot.test(dat = krebs[,c(1,2,5)], paired = TRUE) 

# result is equal to:
x2 &lt;- with(krebs, krebs[trueClass=="healthy", 5])
y2 &lt;- with(krebs, krebs[trueClass=="intermediate", 5])
z2 &lt;- with(krebs, krebs[trueClass=="diseased", 5])
boot.test(x1, y1, z1, x2, y2, z2, paired = TRUE) 
</code></pre>

<hr>
<h2 id='boxcoxROC'>Box-Cox transformation on three-class ROC data</h2><span id='topic+boxcoxROC'></span>

<h3>Description</h3>

<p>A transformation function for three-class ROC data in order to obtain normally
distributed classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcoxROC(
  x,
  y,
  z,
  lambda = seq(-2, 2, 0.05),
  lambda2 = NULL,
  eps = 0.02,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcoxROC_+3A_x">x</code>, <code id="boxcoxROC_+3A_y">y</code>, <code id="boxcoxROC_+3A_z">z</code></td>
<td>
<p>vectors containing the data of the three classes &quot;healthy&quot;,
&quot;intermediate&quot; and &quot;diseased&quot; to be transformed. In two-class ROC analysis only.</p>
</td></tr>
<tr><td><code id="boxcoxROC_+3A_lambda">lambda</code></td>
<td>
<p>vector of possible lambdas the log-likelihood function is evaluated.</p>
</td></tr>
<tr><td><code id="boxcoxROC_+3A_lambda2">lambda2</code></td>
<td>
<p>numeric shifting parameter. For the implemented Box-Cox
transformation positive measurements in <code>x, y, z</code> are required.
<code>lambda2</code> is used to shift these measurements.</p>
</td></tr>
<tr><td><code id="boxcoxROC_+3A_eps">eps</code></td>
<td>
<p>numeric; indicating the bandwith around zero, where <code>lambda</code>
is treated to be zero and the data is log-transformed.</p>
</td></tr>
<tr><td><code id="boxcoxROC_+3A_verbose">verbose</code></td>
<td>
<p>logical; indicating whether output should be displayed (default) or
not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Box-Cox transformation computing
</p>
<p style="text-align: center;"><code class="reqn">X^{(\lambda)} = \left\{ \begin{array}{ll} (X^\lambda -1)/\lambda, 	&amp;
\mbox{if } \; \lambda \neq 0,\\ \log(X),	&amp; \mbox{else } \; \lambda = 0,
\end{array} \right.</code>
</p>

<p>with optimal <code class="reqn">\lambda</code> estimated from the likelihood kernel function,
as formally described in the supplementary
material in Bantis et al. (2017). If the data include any nonpositive
observations, a shifting parameter <code>lambda2</code> can be included in the
transformation given by:
</p>
<p style="text-align: center;"><code class="reqn">X^{(\lambda)} = \left\{ \begin{array}{ll} ((X+\lambda_2)^\lambda -1)/\lambda, &amp;	\mbox{if }
\, \lambda \neq 0,\\ \log(X+\lambda_2),	&amp; \mbox{else } \; \lambda = 0. \end{array}
\right.\\
</code>
</p>



<h3>Value</h3>

<p>A list with  components:
</p>
<table>
<tr><td><code>xbc</code>, <code>ybc</code>, <code>zbc</code></td>
<td>
<p>The transformed vectors.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>estimated optimal parameter.</p>
</td></tr>
<tr><td><code>shapiro.p.value</code></td>
<td>
<p>p-values obtained from <code>shapiro.test()</code> of
the original and transformed data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bantis LE, Nakas CT, Reiser B, Myall D and Dalrymple-Alford JC
(2015) Construction of joint confidence regions for the optimal true class
fractions of receiver operating characteristic (roc) surfaces and
manifolds. <em>Statistical Methods in Medical Research</em> <b>26</b>(3): 1429–1442.
</p>
<p>Box, G. E. P. and Cox, D. R.  (1964). An analysis of
transformations (with discussion). <em>Journal of the Royal Statistical Society,
Series B</em>, <b>26</b>, 211–252.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code> and <code><a href="MASS.html#topic+boxcox">boxcox</a></code> from the package <code>MASS</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer)
x1 &lt;- with(cancer, cancer[trueClass=="healthy", 9])
y1 &lt;- with(cancer, cancer[trueClass=="intermediate", 9])
z1 &lt;- with(cancer, cancer[trueClass=="diseased", 9])

boxcoxROC(x1, y1, z1)
</code></pre>

<hr>
<h2 id='cancer'>Synthetic data set to investigate three-class ROC data.</h2><span id='topic+cancer'></span>

<h3>Description</h3>

<p>A dataset containing randomly generated measurements from three diagnostic classes as they may
arise in a cancer investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cancer
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 10 variables (9 classifiers):
</p>

<dl>
<dt>trueClass</dt><dd><p>A factor, indicating the class membership of the
individuals.</p>
</dd>
<dt>Class1, Class2, Class3, Class4, Class5, Class6, Class7,  Class8, Class9</dt><dd><p>Measurements of a specific classifier obtained from the patients that underwent the
clinical study.</p>
</dd>
</dl>


<hr>
<h2 id='emp.vus'>Empirical VUS calculation</h2><span id='topic+emp.vus'></span>

<h3>Description</h3>

<p>This function computes the empirical Volume Under the Surface (VUS)
of three-class ROC data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp.vus(x, y, z, dat = NULL, old.version = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp.vus_+3A_x">x</code>, <code id="emp.vus_+3A_y">y</code>, <code id="emp.vus_+3A_z">z</code></td>
<td>
<p>Numeric vectors contaning the measurements from the healthy,
intermediate and diseased class.</p>
</td></tr>
<tr><td><code id="emp.vus_+3A_dat">dat</code></td>
<td>
<p>A data frame of the following structure: The first column
represents a factor with three levels, containing the true class membership
of each measurement. The levels are ordered according to the convention of
higher values for more severe disease status. The second column contains
all measurements obtained from Classifier.</p>
</td></tr>
<tr><td><code id="emp.vus_+3A_old.version">old.version</code></td>
<td>
<p>A logical to switch computation method to the old version,
which is up to 50% faster in computation (at N=50).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the empirical VUS of three-class ROC data
using the <code>expand.grid</code> function. It has been shown to be faster than
computation using the <code>merge</code> function (<code>VUS.merge()</code>) or direct
geometrical imlementation. The measurements can be input as seperate vectors
<code>x, y, z</code> or as a data frame <code>dat</code>.
</p>


<h3>Value</h3>

<p>It returns the numeric <code>VUS</code> of the data.
</p>


<h3>References</h3>

<p>Scurfield, B. K. (1996). Multiple-event forced-choice tasks in
the theory of signal detectability. <em>Journal of Mathematical
Psychology</em> <b>40.3</b>, 253–269.
</p>
<p>Nakas CT and Yiannoutsos CT (2004) Ordered multiple-class roc
analysis with continuous measurements. <em>Statistics in Medicine</em> <b>23</b>(22):
3437–3449.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(krebs)
x1 &lt;- with(krebs, cancer[trueClass=="healthy", 4])
y1 &lt;- with(krebs, cancer[trueClass=="intermediate", 4])
z1 &lt;- with(krebs, cancer[trueClass=="diseased", 4])

emp.vus(x1, y1, z1)
# Alternatively:
emp.vus(dat = krebs[,c(1,4)])
</code></pre>

<hr>
<h2 id='findmu'>Determine equidistant means of trinormal ROC data simulation</h2><span id='topic+findmu'></span>

<h3>Description</h3>

<p>A function that computes the equidistant means <code>muy</code> and <code>muz</code> for
a specific <code>mux</code>. The VUS as well as the set of standard errors are
given as arguments to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findmu(mux = 0, sdx = 1, sdy = 1, sdz = 1, VUS = 1/6, step = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findmu_+3A_mux">mux</code></td>
<td>
<p>The numeric mean of the healthy class. Default is zero.</p>
</td></tr>
<tr><td><code id="findmu_+3A_sdx">sdx</code>, <code id="findmu_+3A_sdy">sdy</code>, <code id="findmu_+3A_sdz">sdz</code></td>
<td>
<p>The numeric standard errors of the healthy, intermediate
and diseased class, for which the according means have to be determined
given a specifiv VUS.</p>
</td></tr>
<tr><td><code id="findmu_+3A_vus">VUS</code></td>
<td>
<p>The Volume Under the Surface. A numeric value between 1/6 and 1. Default
is 1/6.</p>
</td></tr>
<tr><td><code id="findmu_+3A_step">step</code></td>
<td>
<p>A numeric indicating the step size each iteration takes in order to
find the closest set of means. Default set to 0.001.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Defaults are: VUS = 1/6, standard errors for all three classes equal
1. The searching algorithm is stepwise increasing the differences
<code>muy-mux</code> and <code>muz-mux</code> according to the variable <code>step</code>.
The algorithm stops when the computed VUS exceeds the preferred VUS. The
according parameters <code>mux, muy, muz</code> are returned with the computed
VUS.
</p>
<p>Remark: The bigger <code>VUS</code> and the smaller <code>step</code> is chosen, the
longer the computation lasts.
</p>


<h3>Value</h3>

<p>A data frame with the following components:
</p>
<table>
<tr><td><code>mux</code></td>
<td>
<p>The initial mean of the healthy class</p>
</td></tr>
<tr><td><code>muy</code></td>
<td>
<p>The mean of the intermediate class computed for the specified <code>VUS</code>.</p>
</td></tr>
<tr><td><code>muz</code></td>
<td>
<p>The mean of the diseased class computed for the specified <code>VUS</code>.</p>
</td></tr>
<tr><td><code>VUS</code></td>
<td>
<p>The VUS computed for <code>mux</code>, <code>muy</code> and <code>muz</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># find equidistant means with mux=2.7 and VUS = 0.45:
findmu(mux = 2.7, VUS = 0.45)
# specify standard errors:
findmu(mux = 2.7, sdx = 1.1, sdy = 1.3, sdz = 1.5, VUS = 0.45)
</code></pre>

<hr>
<h2 id='krebs'>Synthetic small data set to investigate three-class ROC data.</h2><span id='topic+krebs'></span>

<h3>Description</h3>

<p>A dataset containing randomly generated measurements from three diagnostic classes as they may
arise in a cancer investigation. For illustration, this dataset has been
chosen to be smaller than the data set <code><a href="#topic+cancer">cancer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krebs
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 5 variables (4 classifiers):
</p>

<dl>
<dt>trueClass</dt><dd><p>A factor, indicating the class membership of the
individuals.</p>
</dd>
<dt>Fac1, Fac2, Fac3, Fac4</dt><dd><p>Measurements obtained from the patients that underwent the
clinical study.</p>
</dd></dl>


<hr>
<h2 id='roc.eda'>Exploratory data analysis for a three-class ROC marker</h2><span id='topic+roc.eda'></span>

<h3>Description</h3>

<p>A function that investigates data that arose from a single marker and
containes the reference standard of the three classes &quot;healthy&quot;,
&quot;intermediate&quot; and &quot;diseased&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc.eda(
  x,
  y,
  z,
  dat = NULL,
  type = c("empirical", "trinormal"),
  plotVUS = FALSE,
  saveVUS = FALSE,
  sep.dens = FALSE,
  scatter = FALSE,
  conf.level = 0.95,
  n.boot = 1000,
  verbose = TRUE,
  alternative = c("two.sided", "less", "greater")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.eda_+3A_x">x</code>, <code id="roc.eda_+3A_y">y</code>, <code id="roc.eda_+3A_z">z</code></td>
<td>
<p>numeric vectors contaning the measurements from the healthy,
intermediate and diseased class.</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_dat">dat</code></td>
<td>
<p>a data frame of the following structure: The first column
represents a factor with three levels, containing the true class membership
of each measurement. The levels are ordered according to the convention of
higher values for more severe disease status.</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_type">type</code></td>
<td>
<p>a character, specifying if the <code>empirical</code> VUS and tests or
the <code>trinormal</code> VUS and tests are computed.</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_plotvus">plotVUS</code></td>
<td>
<p>a logical whether to evaluate and plot the VUS (default is
<code>FALSE</code>). Note: To save a png <code>plotVUS</code> needs to be <code>TRUE</code> too.</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_savevus">saveVUS</code></td>
<td>
<p>a logical whether to save a PNG of the VUS in your current
working directory (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_sep.dens">sep.dens</code></td>
<td>
<p>a logical indicating if the densitie plots should be plotted
on separate x-axes (<code>TRUE</code>) or on a common axe (<code>FALSE</code>, is
default).</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_scatter">scatter</code></td>
<td>
<p>a logical indicating if the measurements per class plot should
be plotted as a boxplot (default) or as a scatterplot (<code>scatter =
TRUE</code>).</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_conf.level">conf.level</code></td>
<td>
<p>A numeric value between 0 and 1 yielding the significance
level <code class="reqn">\alpha=1-\code{conf.level}</code>.</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_n.boot">n.boot</code></td>
<td>
<p>an integer incicating the number of bootstrap replicates sampled
to obtain the variance of the VUS. Default is 1000.</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_verbose">verbose</code></td>
<td>
<p>a logical, indicating whether output should be displayed or
not. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="roc.eda_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the preliminary assessment of a classifier, exporatory
data analysis  (EDA) on the markers is necessary. This function assesses
measurements from a single marker and computes the VUS, statistical tests
and returns a summary table as well as some plots of the data.
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The value of the test(s).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value for the test(s).</p>
</td></tr>
<tr><td><code>VUS</code></td>
<td>
<p>the VUS computed with the specific method defined in
<code>type</code>.</p>
</td></tr>
<tr><td><code>dat.summary</code></td>
<td>
<p>A data frame displaying size, mean and standard deviation
of the three classes.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>The alternative hypothesis.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character containing the the method used for the exploratory
data analysis.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character containing the name of the data.</p>
</td></tr>
<tr><td><code>xVUS</code>, <code>yVUS</code>, <code>zVUS</code></td>
<td>
<p>(if <code>plotVUS = TRUE</code>) numeric vectors and
matrices computed by <code>rocsurf.emp</code> or <code>rocsurf.trin</code>, used for
displaying the surface with package <code>rgl</code>.</p>
</td></tr>
<tr><td><code>histROC</code></td>
<td>
<p>a <code>ggplot2</code> object, displaying the historgrams and
densities of the three classes.</p>
</td></tr>
<tr><td><code>meas.overview</code></td>
<td>
<p>A ggplot2 object, displaying the boxplots (if
<code>scatter = FALSE</code>) or scatter plots of the three classes (if
<code>scatter = TRUE</code>).</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If <code>type = "empirical"</code>, computation may take a while, as <code>roc.eda</code> calls
the function <code>boot.test()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trinROC.test">trinROC.test</a></code>, <code><a href="#topic+trinVUS.test">trinVUS.test</a></code> for trinormal
data investigation, <code><a href="#topic+boot.test">boot.test</a></code> for empirical data analysis.
<code><a href="#topic+rocsurf.emp">rocsurf.emp</a></code>, <code><a href="#topic+rocsurf.trin">rocsurf.trin</a></code> for the surface plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(krebs)

# empirical EDA:
roc.eda(dat = krebs[,c(1,5)], type = "e", plotVUS = FALSE)

# equal data input via:
x &lt;- with(krebs, krebs[trueClass=="healthy", 5])
y &lt;- with(krebs, krebs[trueClass=="intermediate", 5])
z &lt;- with(krebs, krebs[trueClass=="diseased", 5])
roc.eda(x, y, z, type = "e", sep.dens = TRUE)

data(cancer)
# trinormal EDA:
roc.eda(dat = cancer[,c(1,10)], type = "trin", plotVUS = FALSE)
# trinormal EDA with different plots:
roc.eda(dat = cancer[,c(1,5)], type = "t", sep.dens = TRUE, scatter = TRUE)
</code></pre>

<hr>
<h2 id='roc3.test'>Statistical test function for computing multiple tests on three-class ROC data</h2><span id='topic+roc3.test'></span>

<h3>Description</h3>

<p>A statistical test function that assesses three-class ROC data with the
trinormal based ROC test, the trinormal VUS test and the Bootstrap test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc3.test(
  dat,
  type = c("ROC", "VUS", "Bootstrap"),
  paired = FALSE,
  conf.level = 0.95,
  n.boot = 1000,
  p.adjust = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc3.test_+3A_dat">dat</code></td>
<td>
<p>A data frame of the following structure: The first column
represents a factor with three levels, containing the true class membership
of each measurement. The levels are ordered according to the convention of
higher values for more severe disease status.</p>
</td></tr>
<tr><td><code id="roc3.test_+3A_type">type</code></td>
<td>
<p>A character, specifying which tests are applied to <code>dat</code>.
<code>"ROC"</code> implies the trinormal based ROC test, <code>"VUS"</code> the trinormal
VUS test and <code>"Bootstrap"</code> the Bootstrap test.</p>
</td></tr>
<tr><td><code id="roc3.test_+3A_paired">paired</code></td>
<td>
<p>A logical indicating whether data arose from a paired setting.
If data is paired, each class must have equal sample size for both classifiers.</p>
</td></tr>
<tr><td><code id="roc3.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval. A numeric value between (0,1)
yielding the significance level <code class="reqn">\alpha=1-\code{conf.level}</code>.</p>
</td></tr>
<tr><td><code id="roc3.test_+3A_n.boot">n.boot</code></td>
<td>
<p>An integer incicating the number of Bootstrap replicates sampled
to obtain the variance of the VUS. Default is 1000.</p>
</td></tr>
<tr><td><code id="roc3.test_+3A_p.adjust">p.adjust</code></td>
<td>
<p>A logical, indicating whether a FDR adjustment
should be applied to the p-values. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the preliminary assessment of a classifier, different
statistical tests have been proposed in the literature. This function can
be used for either comparison of single classifiers to a null hypothesis of
being not better than a random allocation function or comparison of two
classifiers under the null hypothesis of having equal discriminatory power.
Depending on the specification of the user, (s)he can apply the trinormal
based ROC test (LINK), the test developed by Xiong et. al. or the Bootstrap
test or any combination of these tests. More information of the specific
tests can be obtained by calling <code>?functionname</code>. If more than two
markers are present, a pairwise comparison between each marker is realized.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>Overview</code></td>
<td>
<p>a data frame with number of columns according to number of
markers. Rows contain the following information about the makers:
</p>

<ol>
<li><p> Index according to smallest VUS
</p>
</li>
<li><p> VUS
</p>
</li>
<li><p> P-values of statistical test specified by <code>type</code>
</p>
</li>
<li><p> Number of NA's
</p>
</li></ol>
</td></tr>
<tr><td><code>O.orig</code></td>
<td>
<p>the unsorted <code>Overview.</code></p>
</td></tr>
<tr><td><code>P.values</code></td>
<td>
<p>a list, containing the upper triangular matrices of the optionally adjusted
p-values of the statistical tests chosen by <code>type</code>.</p>
</td></tr>
<tr><td><code>Test.Values</code></td>
<td>
<p>a list, containing the upper triangular matrices of the
test values of the statistical tests chosen by <code>type</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>type = "Bootstrap"</code>, the Bootstrap test is evaluated. This
may take some time, especially with sample sizes &gt; 100.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(krebs)
roc3.test(krebs, type = c("ROC", "VUS"), paired = TRUE)[c("Overview","P.values")]
</code></pre>

<hr>
<h2 id='rocsurf.emp'>Empirical ROC surface plot</h2><span id='topic+rocsurf.emp'></span>

<h3>Description</h3>

<p>Function for computation of the empirical ROC surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rocsurf.emp(x, y, z, plot = TRUE, saveVUS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rocsurf.emp_+3A_x">x</code>, <code id="rocsurf.emp_+3A_y">y</code>, <code id="rocsurf.emp_+3A_z">z</code></td>
<td>
<p>Vectors containing the data of the three classes &quot;healthy&quot;,
&quot;intermediate&quot; and &quot;diseased&quot;.</p>
</td></tr>
<tr><td><code id="rocsurf.emp_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (default), the VUS is plotted using <code>surface3d</code> from the package <code>rgl</code>.</p>
</td></tr>
<tr><td><code id="rocsurf.emp_+3A_savevus">saveVUS</code></td>
<td>
<p>A logical whether to save a PNG of the VUS in your current
working directory (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes three-class ROC data and computes the three
dimentional surface using the R-package <code>rgl</code>. The ROC surface is
defined as
</p>
<p style="text-align: center;"><code class="reqn">z = ROCs(t_-,t_+) = F_0(c_+) - F_0(c_-)=F_0(G_+^{-1}(t_+) )
 -F_0(F_-^{-1}(t_-) ),</code>
</p>

<p>where <code class="reqn">c_-, c_+</code> are the two cut-off points and <code class="reqn">F_-, F_0, F_+</code> the
cdf of the three classes with <code class="reqn">G = 1-F</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>t1</code>, <code>t2</code>, <code>zVUS</code></td>
<td>
<p>The matice containing the surface values.</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code>, <code>z</code></td>
<td>
<p>The original data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+surface3d">surface3d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer)
x1 &lt;- with(cancer, cancer[trueClass=="healthy", 9])
y1 &lt;- with(cancer, cancer[trueClass=="intermediate", 9])
z1 &lt;- with(cancer, cancer[trueClass=="diseased", 9])

rocsurf.emp(x1, y1, z1)
</code></pre>

<hr>
<h2 id='rocsurf.trin'>Trinormal ROC surface plot</h2><span id='topic+rocsurf.trin'></span>

<h3>Description</h3>

<p>Function for computation of the trinormal ROC surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rocsurf.trin(x, y, z, p = 300, plot = TRUE, saveVUS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rocsurf.trin_+3A_x">x</code>, <code id="rocsurf.trin_+3A_y">y</code>, <code id="rocsurf.trin_+3A_z">z</code></td>
<td>
<p>Vectors containing the data of the three classes &quot;healthy&quot;,
&quot;intermediate&quot; and &quot;diseased&quot;.</p>
</td></tr>
<tr><td><code id="rocsurf.trin_+3A_p">p</code></td>
<td>
<p>An integer for the precision of the surface. <code>p</code> gives the
number of gridpoints per axis.</p>
</td></tr>
<tr><td><code id="rocsurf.trin_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (default), the VUS is plotted using <code>surface3d</code> from the package <code>rgl</code>.</p>
</td></tr>
<tr><td><code id="rocsurf.trin_+3A_savevus">saveVUS</code></td>
<td>
<p>A logical whether to save a PNG of the VUS in your current
working directory (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes three-class ROC data and computes the three
dimentional surface using the R-package <code>rgl</code>. The ROC surface is
defined as
</p>
<p style="text-align: center;"><code class="reqn">z = ROCs(t_-,t_+) = F_0(c_+) - F_0(c_-)=F_0(G_+^{-1}(t_+) )
 -F_0(F_-^{-1}(t_-) ),</code>
</p>

<p>where <code class="reqn">c_-, c_+</code> are the two cut-off points and <code class="reqn">F_-, F_0, F_+</code> the
cdf of the three classes with <code class="reqn">G = 1-F</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>The vectors <code class="reqn">t_-=F_-^{(c_-)}</code> and <code class="reqn">t_+=F_+^{(c_+)}</code></p>
</td></tr>
<tr><td><code>zVUS</code></td>
<td>
<p>The matix containing the surface values.</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code>, <code>z</code></td>
<td>
<p>The original data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Xiong, C., G. Van Belle, et al. (2006). Measuring and estimating
diagnostic accuracy when there are three ordinal diagnostic groups.
<em>Statistics in Medicine</em> 25(7), 1251–1273.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer)
x1 &lt;- with(cancer, cancer[trueClass=="healthy", 8])
y1 &lt;- with(cancer, cancer[trueClass=="intermediate", 8])
z1 &lt;- with(cancer, cancer[trueClass=="diseased", 8])

rocsurf.trin(x1, y1, z1)
</code></pre>

<hr>
<h2 id='trinROC-package'>trinROC: Statistical Tests for Assessing Trinormal ROC Data</h2><span id='topic+trinROC'></span><span id='topic+trinROC-package'></span>

<h3>Description</h3>

<p>Several statistical test functions as well as a function for exploratory data analysis to investigate classifiers allocating individuals to one of three disjoint and ordered classes. In a single classifier assessment the discriminatory power is compared to classification by chance. In a comparison of two classifiers the null hypothesis corresponds to equal discriminatory power of the two classifiers.
</p>


<h3>Details</h3>

<p>See <code>vignette("Overview", package = "trinROC")</code> for an overview of the package.
Further, <code>sd()</code>, <code>var()</code> and <code>cov()</code> are chosen with <code>options(trinROC.MLE = TRUE)</code> according to the maximum likelihood estimates (<code>default</code>). Change to sample
estimates by setting <code>options(trinROC.MLE = FALSE)</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Annina Cincera <a href="mailto:annina.cincera@math.uzh.ch">annina.cincera@math.uzh.ch</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Samuel Noll <a href="mailto:uncle.sam@gmx.net">uncle.sam@gmx.net</a>
</p>
</li>
<li><p> Reinhard Furrer <a href="mailto:reinhard.furrer@math.uzh.ch">reinhard.furrer@math.uzh.ch</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Benjamin Reiser [contributor]
</p>
</li>
<li><p> Christos T. Nakas <a href="mailto:cnakas@uth.gr">cnakas@uth.gr</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Noll, S., Furrer, R., Reiser, B. and Nakas, C. T. (2019).
Inference in ROC surface analysis via a trinormal model-based testing approach.
<em>Stat</em>, <b>8</b>(1), e249.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://math.uzh.ch/pages/trinROC/">https://math.uzh.ch/pages/trinROC/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://git.math.uzh.ch/reinhard.furrer/trinROC/-/issues">https://git.math.uzh.ch/reinhard.furrer/trinROC/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='trinROC.test'>Trinormal based ROC test</h2><span id='topic+trinROC.test'></span>

<h3>Description</h3>

<p>A statistical test function to assess three-class ROC data. It is possible to
investigate a single classifier or make a comparison of two independent /
correlated classifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trinROC.test(
  x1,
  y1,
  z1,
  x2 = 0,
  y2 = 0,
  z2 = 0,
  dat = NULL,
  paired = FALSE,
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trinROC.test_+3A_x1">x1</code>, <code id="trinROC.test_+3A_y1">y1</code>, <code id="trinROC.test_+3A_z1">z1</code></td>
<td>
<p>(non-empty) numeric vectors of data from the healthy,
intermediate and diseased class from Classifier 1.</p>
</td></tr>
<tr><td><code id="trinROC.test_+3A_x2">x2</code>, <code id="trinROC.test_+3A_y2">y2</code>, <code id="trinROC.test_+3A_z2">z2</code></td>
<td>
<p>numeric vectors of data from the healthy, intermediate and
diseased class from Classifier 2.</p>
</td></tr>
<tr><td><code id="trinROC.test_+3A_dat">dat</code></td>
<td>
<p>a data frame of the following structure: The first column
represents a factor with three levels, containing the true class membership
of each measurement. The levels are ordered according to the convention of
higher values for more severe disease status. The second column contains
all measurements obtained from Classifier 1 (in the case of single marker
assessment). In the case of comparison of two markers, column three
contains the measurementss from the Classifier.</p>
</td></tr>
<tr><td><code id="trinROC.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether data arose from a paired setting.
If <code>TRUE</code>, each class must have equal sample size for both
classifiers.</p>
</td></tr>
<tr><td><code id="trinROC.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval. A numeric value between (0,1)
yielding the significance level <code class="reqn">\alpha=1-</code><code>conf.level</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trinormal ROC model is a parametric model in three-class ROC
analysis. It is based on normality in each of the trhee classes D_-
(healthy), D_0 (intermediate) and D_+ (diseased) with denoted distributions
<code class="reqn">N(\mu_-,\sigma_-^2)</code>, <code class="reqn">N(\mu_0,\sigma_0^2)</code> and
<code class="reqn">N(\mu_+,\sigma_+^2)</code>. A classifier of a trinormal ROC model classifies
individuals into one of the three ordered classes based on two cut-off points
<code class="reqn">c_- &lt; c_+</code>. We define <code class="reqn">t_-=F_-(c_-)</code> and <code class="reqn">t_+
=1-F_+(c_+)=G_+(c_+)</code>. Now, the ROC surface can be written as
</p>
<p style="text-align: center;"><code class="reqn">ROCs(t_-,t_+) = \Phi \left(\frac{\Phi^{-1} (1-t_+) +d}{c} \right) -
\Phi \left(\frac{\Phi^{-1} (t_-)+b}{a} \right)</code>
</p>

<p>whith parameters a, b, c and c given by <code class="reqn">a =
\frac{\hat{\sigma}_0}{\hat{\sigma}_-}, b = \frac{ \hat{\mu}_- -
\hat{\mu}_0}{\hat{\sigma}_-}, c = \frac{\hat{\sigma}_0}{\hat{\sigma}_+}, d =
\frac{ \hat{\mu}_+ - \hat{\mu}_0}{\hat{\sigma}_+} </code>. It is a surface in the
unit cube that plots the probability of a measurement to get assigned to the
intermediate class as the two thresholds <code class="reqn">c_-,c_+</code> are varying.
</p>
<p>Based on the reference standard, the trinormal based ROC test can be used
to assess the discriminatory power of such classifiers. It distinguishes
between single classifier assessment, where a classifier is compared to some
hypothetical distributions in the classes, and comparison between two
classifiers. The latter case tests for equality between the parameters a, b,
c and d of the ROC curves. The data can arise in a unpaired or paired
setting. If <code>paired</code> is <code>TRUE</code>, a correlation is introduced which
has to be taken into account. Therefore the sets of the two classifiers have
to have classwise equal size. The data can be input as the data frame
<code>dat</code> or as single vectors <code>x1, y1, z1, ...</code>.
</p>
<p>As the Chi-squared test is by definition a one-sided test, the variable
<code>alternative</code> cannot be specified in this test. For this 'goodness of
fit' test, we assume the parameters <code class="reqn">a_1, \dots , d_1</code> and <code class="reqn">a_2, \dots , d_2</code> to have a
pairwise equivalent normal distribution (in large sample sets).
</p>


<h3>Value</h3>

<p>A list of class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the chi-squared statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the chi-squared statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>a data frame containing the estimated VUS and parameters
a, b, c and d from Classifier 1 and Classifier 2 (if specified).</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>a character expressing the null hypothesis.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what
type of trinormal based ROC test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr>
<tr><td><code>CovMat</code></td>
<td>
<p>the covariance matrix of the chi-squared statistic.</p>
</td></tr>
<tr><td><code>Summary</code></td>
<td>
<p>a data frame representing the number of NA's as well as
the means and the standard deviations per class.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Noll, S., Furrer, R., Reiser, B. and Nakas, C. T. (2019).
Inference in ROC surface analysis via a trinormal model-based testing approach.
<em>Stat</em>, <b>8</b>(1), e249.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trinVUS.test">trinVUS.test</a></code>, <code><a href="#topic+boot.test">boot.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer)
data(krebs)

# investigate a single marker:
trinROC.test(dat = cancer[,c(1,3)])
trinROC.test(dat = krebs[,c(1,5)])

# result is equal to:
x1 &lt;- with(cancer, cancer[trueClass=="healthy", 3])
y1 &lt;- with(cancer, cancer[trueClass=="intermediate", 3])
z1 &lt;- with(cancer, cancer[trueClass=="diseased", 3])
trinROC.test(x1, y1, z1)

# comparison of marker 2 and 6:
trinROC.test(dat = cancer[,c(1,3,5)], paired = TRUE)
trinROC.test(dat = cancer[,c(1,3,5)], paired = FALSE)

# result is equal to:
x2 &lt;- with(cancer, cancer[trueClass=="healthy", 5])
y2 &lt;- with(cancer, cancer[trueClass=="intermediate", 5])
z2 &lt;- with(cancer, cancer[trueClass=="diseased", 5])
trinROC.test(x1, y1, z1, x2, y2, z2, paired = TRUE)
</code></pre>

<hr>
<h2 id='trinVUS.test'>Trinormal VUS test</h2><span id='topic+trinVUS.test'></span>

<h3>Description</h3>

<p>A statistical test function to assess three-class ROC data. It can be used
for assessment of a single classifier or comparison of two independent /
correlated classifiers, using the statistical test developed by Xiong et al.
(2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trinVUS.test(
  x1,
  y1,
  z1,
  x2 = 0,
  y2 = 0,
  z2 = 0,
  dat = NULL,
  paired = FALSE,
  conf.level = 0.95,
  alternative = c("two.sided", "less", "greater")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trinVUS.test_+3A_x1">x1</code>, <code id="trinVUS.test_+3A_y1">y1</code>, <code id="trinVUS.test_+3A_z1">z1</code></td>
<td>
<p>non-empty numeric vectors of data from the healthy,
intermediate and diseased class from Classifier 1.</p>
</td></tr>
<tr><td><code id="trinVUS.test_+3A_x2">x2</code>, <code id="trinVUS.test_+3A_y2">y2</code>, <code id="trinVUS.test_+3A_z2">z2</code></td>
<td>
<p>numeric vectors of data from the healthy, intermediate and
diseased class from Classifier 2, only needed in a comparison of two
classifiers.</p>
</td></tr>
<tr><td><code id="trinVUS.test_+3A_dat">dat</code></td>
<td>
<p>a data frame of the following structure: The first column
represents a factor with three levels, containing the true class membership
of each measurement. The levels are ordered according to the convention of
higher values for more severe disease status. The second column contains
all measurements obtained from Classifier 1 (in the case of single marker
assessment). In the case of comparison of two markers, column three
contains the measurementss from the Classifier.</p>
</td></tr>
<tr><td><code id="trinVUS.test_+3A_paired">paired</code></td>
<td>
<p>logical; indicating whether data arose from a paired setting.
If <code>TRUE</code>, each class must have equal sample size for both
classifiers.</p>
</td></tr>
<tr><td><code id="trinVUS.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval. A numeric value between (0,1)
yielding the significance level <code class="reqn">\alpha=1-\code{conf.level}</code>.</p>
</td></tr>
<tr><td><code id="trinVUS.test_+3A_alternative">alternative</code></td>
<td>
<p>character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>. You can specify
just the initial letter. For two sided test, notice <code class="reqn">H0: Z = (VUS_1-VUS_2) /
(Var(VUS_1)+Var(VUS_2)-2Cov(VUS_1,VUS_2))^{0.5}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the reference standard, this trinormal VUS test assesses the
discriminatory power of classifiers by comparing the volumes under the ROC
surfaces (VUS). It distinguishes between single classifier assessment,
where a classifier is compared to the chance plane with VUS=1/6, and
comparison between two classifiers. The latter case tests the equality
between VUS_1 and VUS_2. The data can arise in a unpaired or paired
setting. If <code>paired</code> is <code>TRUE</code>, a correlation is introduced which
has to be taken into account. Therefore the sets of the two classifiers
have to have classwise equal size. The data can be input as the data
frame <code>dat</code> or as single vectors <code>x1, y1, z1, ...</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Z-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>a data frame containing the
estimated VUS from Classifier 1 and Classifier 2 (if specified).</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>a character expressing the null hypothesis.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative  hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of trinormal VUS test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr> <tr><td><code>Summary</code></td>
<td>
<p>a data frame representing the
number of NA's as well as the means and the standard deviations per class.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>the covariance matrix of the VUS.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Xiong, C., Van Belle, G.  Miller J. P., Morris, J. C. (2006). Measuring and estimating
diagnostic accuracy when there are three ordinal diagnostic groups.
<em>Statistics in Medicine</em>, <b>25</b>(7), 1251–1273.
</p>
<p>Xiong, C., van Belle, G.,  Miller, J. P.,  Yan, Y.,  Gao, F., Yu, K., and Morris, J. C. (2007). A parametric comparison
of diagnostic accuracy with three ordinal diagnostic groups.
<em>Biometrical Journal</em>, <b>49</b>(5), 682–693. doi: <a href="https://doi.org/10.1002/bimj.200610359">10.1002/bimj.200610359</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trinROC.test">trinROC.test</a></code>, <code><a href="#topic+boot.test">boot.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer)
data(krebs)

# investigate a single marker:
trinVUS.test(dat = cancer[,c(1,3)])
trinVUS.test(dat = krebs[,c(1,5)])

# result is equal to:
x1 &lt;- with(cancer, cancer[trueClass=="healthy", 3])
y1 &lt;- with(cancer, cancer[trueClass=="intermediate", 3])
z1 &lt;- with(cancer, cancer[trueClass=="diseased", 3])
trinVUS.test(x1, y1, z1)

# comparison of marker 2 and 6:
trinVUS.test(dat = cancer[,c(1,3,5)], paired = TRUE)
trinVUS.test(dat = cancer[,c(1,3,5)], paired = FALSE)

# result is equal to:
x2 &lt;- with(cancer, cancer[trueClass=="healthy", 5])
y2 &lt;- with(cancer, cancer[trueClass=="intermediate", 5])
z2 &lt;- with(cancer, cancer[trueClass=="diseased", 5])
trinVUS.test(x1, y1, z1, x2, y2, z2, paired = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
