<!DOCTYPE html><html><head><title>Help for package rbmn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rbmn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rbmn-package'>
<p>Linear Gaussian Bayesian network manipulations</p></a></li>
<li><a href='#adja2arcs'>
<p>Arc matrix from an adjacency matrix</p></a></li>
<li><a href='#adja2crossed'>
<p>creates a crossed-adjacency matrix from two ones</p></a></li>
<li><a href='#adja2nbn'>
<p>standardized /nbn/ from an adjacency matrix</p></a></li>
<li><a href='#adja4nbn'>
<p>adjacency matrix of a /nbn/</p></a></li>
<li><a href='#adja4three'>
<p>Adjacency matrices of DAGs having three nodes</p></a></li>
<li><a href='#arc7nb4nbn'>
<p>returns the number(s) of arcs of a /nbn/</p></a></li>
<li><a href='#arcs4nbn1nbn'>
<p>returns the list of 'parallel' arcs of a crossed-nbn</p></a></li>
<li><a href='#bn2nbn'>
<p>transforms a /bn/ of /bnlearn/ package to a /nbn/</p></a></li>
<li><a href='#bnfit2nbn'>
<p>transforms a /bn.fit/ of /bnlearn/ package to a /nbn/</p></a></li>
<li><a href='#body+20composition'><p>Body Composition Variables and Covariables</p></a></li>
<li><a href='#chain2correlation'>
<p>computes the correlation matrix of a chain</p></a></li>
<li><a href='#chain2gema'>
<p>transforms a /chain/ to a /gema/</p></a></li>
<li><a href='#chain2mn'>
<p>computes the distribution of a chain</p></a></li>
<li><a href='#chain2nbn'>
<p>transforms a /chain/ to a /nbn/</p></a></li>
<li><a href='#chain2pre'>
<p>computes the precision of a chain</p></a></li>
<li><a href='#chain4chain'>
<p>extracts a chain from a chain</p></a></li>
<li><a href='#check8chain'>
<p>checks a /chain/ object</p></a></li>
<li><a href='#check8gema'>
<p>checks a /gema/ object</p></a></li>
<li><a href='#check8nbn'>
<p>checks a /nbn/ object</p></a></li>
<li><a href='#condi4joint'>
<p>computes some conditional distribution of a multinormal vector</p></a></li>
<li><a href='#cor4var'>
<p>returns the correlation matrix from the variance</p></a></li>
<li><a href='#crossed4nbn1nbn'>
<p>creates a crossed-nbn from two /nbn/s</p></a></li>
<li><a href='#dev4mn'>
<p>Computes the deviance for a sample of multinormal vector</p></a></li>
<li><a href='#diff8nbn'>
<p>returns a score of the difference between two /nbn/s</p></a></li>
<li><a href='#estimate8constrainednbn'>
<p>estimates the parameters of a nbn with equality constraints</p></a></li>
<li><a href='#estimate8nbn'>
<p>estimating the /nbn/ parameters</p></a></li>
<li><a href='#gema2mn'>
<p>computes a /mn/ from a /gema/</p></a></li>
<li><a href='#gema2nbn'>
<p>computes a /nbn/ from a /gema/</p></a></li>
<li><a href='#generate8chain'>
<p>generation of a /chain/ /nbn/</p></a></li>
<li><a href='#generate8nbn'>
<p>returns a randomly built /nbn/ object.</p></a></li>
<li><a href='#inout4chain'>
<p>reduces a chain to its inputs and outputs</p></a></li>
<li><a href='#is8nbn8chain'>
<p>Checks if a given /nbn/ is a /chain/</p></a></li>
<li><a href='#marginal4chain'>
<p>returns marginal expectations and standard deviations of a chain</p></a></li>
<li><a href='#mn2gema'>
<p>computes a /gema/ from a /mn/</p></a></li>
<li><a href='#mn4joint1condi'>
<p>computes a joint distribution from a marginal and a conditional one</p>
for multinormal distributions</a></li>
<li><a href='#nb8bn'>
<p>number of Bayesian networks</p></a></li>
<li><a href='#nbn2bnfit'>
<p>transforms a /nbn/ to a /bn.fit/ of /bnlearn/ package</p></a></li>
<li><a href='#nbn2chain'>
<p>transforms a /nbn/ into a /chain/</p></a></li>
<li><a href='#nbn2gema'>
<p>computes a /gema/ from a /nbn/</p></a></li>
<li><a href='#nbn2mn'>
<p>computes the joint distribution of a /nbn/</p></a></li>
<li><a href='#nbn2nbn'>
<p>computes the /nbn/ changing its topological order</p></a></li>
<li><a href='#nbn2rr'>
<p>computes standard matrices from a /nbn/</p></a></li>
<li><a href='#nbn4nbn'>
<p>From a /nbn/ computes the associated nbn1</p></a></li>
<li><a href='#nbn4rmatrix'>
<p>a /nbn/ from a regression matrix</p></a></li>
<li><a href='#normalize8nbn'>
<p>normalizes a /nbn/</p></a></li>
<li><a href='#order4chain'>
<p>returns a topological order of a /chain/ or checks a proposed order.</p></a></li>
<li><a href='#order4gema'>
<p>topological order of a /gema/</p></a></li>
<li><a href='#order4nbn'>
<p>topological order of a /nbn/</p></a></li>
<li><a href='#print8chain'>
<p>prints a /chain/ object</p></a></li>
<li><a href='#print8gema'>
<p>standard print function for a /gema/ object.</p></a></li>
<li><a href='#print8mn'>
<p>standard print function for a /mn/ object.</p></a></li>
<li><a href='#print8nbn'>
<p>print function for a /nbn/ object.</p></a></li>
<li><a href='#provided+20objects'><p>Some examplifying structures</p></a></li>
<li><a href='#reverse8chain'>
<p>reverses the nodes of a chain</p></a></li>
<li><a href='#rm8nd4adja'>
<p>removes somes nodes from an adjacency matrix</p></a></li>
<li><a href='#rm8nd4nbn'>
<p>removes some nodes from a /nbn/</p></a></li>
<li><a href='#rmatrix4nbn'>
<p>regression matrix of a /nbn/</p></a></li>
<li><a href='#simulate8gema'>
<p>simulates from a /gema/ object</p></a></li>
<li><a href='#simulate8gmn'>
<p>simulates a multinormal vector with varying expectation</p></a></li>
<li><a href='#simulate8mn'>
<p>simulates a multinormal vector</p></a></li>
<li><a href='#simulate8nbn'>
<p>simulates from a /nbn/ object</p></a></li>
<li><a href='#state4chain'>
<p>returns the states of each node of a chain</p></a></li>
<li><a href='#string7dag4nbn'>
<p>provides so-called string model of a /nbn/</p></a></li>
<li><a href='#var2pre'>
<p>returns the precision matrix from the variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-28</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Handling Linear Gaussian Bayesian Networks</td>
</tr>
<tr>
<td>Author:</td>
<td>Jean-Baptiste Denis [aut, cre], Marco Scutari [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Scutari &lt;scutari@bnlearn.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Creation, manipulation, simulation of linear Gaussian Bayesian
             networks from text files and more...</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bnlearn, igraph</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-30 08:24:49 UTC; fizban</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-30 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rbmn-package'>
Linear Gaussian Bayesian network manipulations
</h2><span id='topic+rbmn-package'></span><span id='topic+rbmn'></span>

<h3>Description</h3>

<p>General functions to generate, transform, display general and
particular linear Gaussian Bayesian networks [/nbn/] are provided.<br />
Specific /nbn/ are chain and crossed /nbn/s. Focus is given in getting
joint and conditional probability distributions of the set of
nodes.<br />
<em>rbmn</em> stands for <em>R'eseau Bay'esien MultiNormal</em>.
</p>


<h3>Details</h3>

<p>Some basic concepts:
</p>

<ul>
<li> <p><em>chain /nbn/s</em> are /nbn/s where all nodes are connected with two
other nodes, except the two ending nodes of the chain having only one
connection. (This is not the usual terminology in graphical models
but I didn't find a more appropriate word: suggestions are welcome.)
</p>
</li>
<li> <p><em>crossed /nbn/s</em> are /nbn/s having the node set defined as a
Cartesian product of two series of items, and a DAG based on this
structure. See the <code>crossed4nbn1nbn</code> function and/or Tian (2014) for
details.
</p>
</li>
<li><p> An <em>adjacency matrix</em> is a matrix equivalent to the DAG
associated to a /nbn/. Its rows as well as its columns are associated
to the set of nodes. The <code>(i,j)</code> cell is one when there is an arc going
from node <code>i</code> to <code>j</code> and zero otherwise.
</p>
</li></ul>

<p>Three equivalent ways can be used to represent the joint probability
distribution of a set of nodes respectively associated to the
structures /mn/, /nbn/ and /gema/:
</p>

<ul>
<li><p> /mn/ (for multivariate normal) is just the list of the
expectation (<code>$mu</code>) and the variance matrix (<code>$gamma</code>).
</p>
</li>
<li><p> /nbn/ (for normal Bayesian network) is a simple list, a
component a node described with a list. The names are node names and
each list associated to a node provides the conditional expectation
and variance, the parent (if any) and the associated regression
coefficients.
</p>
</li>
<li><p> /gema/ (for generating matrices) is a list of a vector
(<code>mu</code>) and a matrix (<code>li</code>) such that the vector of the
nodes can be defined by <code>X = mu + li%*%E</code> where <code>E</code> is a
normal random vector with expectation zero and variance matrix
unity.
</p>
</li>
<li><p>  It is planned to add a fourth one under the name of /gbn/.
</p>
</li></ul>

<p>To relieve the memory effort, most names of the functions have been
given a two (or more) components structure separated with a
figure. This idea will be explained and exploited in a package to come
named <span class="pkg">documair</span>. The approximate meaning of the figures are:
</p>

<ul>
<li><p> 0 (similar to 'o') <code>rbmn0chain.01</code> to indicate an object
example provided by <span class="pkg">rbmn</span>.
</p>
</li>
<li><p> 1 (similar to an ~ and) ??? to link different objects or
actions <code>train1car</code> for train and car.
</p>
</li>
<li><p> 2 (as usual but only one-to-one) <code>nbn2gema</code> means
\&quot;transforming a /nbn/ into a /gema/ objects\&quot;.
</p>
</li>
<li><p> 3 (remind the 'belong to' sign) <code>form3repeat</code> could be
interpreted as &quot;repeat action from the series of 'form' functions&quot;.
</p>
</li>
<li><p> 4 (associated to 'from') <code>adja4nbn</code> means &quot;get the adjacency
matrix from a /nbn/ object&quot;.
</p>
</li>
<li><p> 7 (upper bar of '7' similar to the hyphen) <code>arc7nb4nbn</code>
means &quot;get the arc-numbers from a /nbn/&quot;.
</p>
</li>
<li><p> 8 (similar to 'a') <code>generate8nbn</code> or <code>print8nbn</code>
for \&quot;generating or printing a /nbn/ object\&quot;.
</p>
</li></ul>

<p>A number of ancillary functions have not been exported to give a better
access to the main function of /rbmn/. Nevertheless they are available
in the <code>../rbmn/R/</code> directory, and with all their comments
(equivalent to <code>Rd</code> files into <code>../rbmn/inst/original/</code>
directory). Some of them are visible when defining the default
arguments of some functions.
</p>


<h3>Projected evolution of /mn/</h3>


<ul>
<li><p> Generalize the /mn/ object with a regression part like
the output of function <code>condi4joint</code> when argument
<code>pour</code> is not of length zero and argument <code>x2</code> is not
null. With such a structure, every node of a /nbn/ could be
described with a /mn/ comprising a unique variable... Also the two
arguments of function <code>mn4joint1condi</code> would be just two /mn/
objects... This is also the generalized /mn/ proposed in function
<code>simulate8gmn</code> under the argument of <code>loi</code>... Of course
almost all functions dealing with /nbn/ objects will be to rewrite!
</p>
</li>
<li><p> Introduce a new object <code>gbn</code> for Gaussian Bayesian
network similar to the list provided by function <code>nbn2rr</code>.
</p>
</li></ul>



<h3>TO DO list</h3>


<ul>
<li><p> Systemize the existence of <code>check8object</code> functions
</p>
</li>
<li><p> Introduce their systematic use conditionned with a
<code>rbmn0check</code> variable.
</p>
</li>
<li><p> Follow the main checking of every functions
</p>
</li>
<li><p> Give (and use) class attributes to the main objects.
</p>
</li>
<li><p> Introduce the main objects in this short presentation.
</p>
</li>
<li><p> Make a true small example in this short presentation.
</p>
</li>
<li><p> Make the function <code>nbn4string7dag</code>.
</p>
</li>
<li><p> Add the computation made with /bnlearn/ in the example of
<code>estimate8nbn</code>.
</p>
</li>
<li><p> Check the topological order within <code>nbn2nbn</code> depending on
<code>rbmn0check</code> value.
</p>
</li>
<li><p> Make a super transformation function from an object associated
to a Bayesian network to any other type, including itself.
</p>
</li>
<li><p> Correct the <code>ord</code> option in <code>order4chain</code>.
</p>
</li>
<li><p> Check the topological order in <code>rm8nd4adja</code>.
</p>
</li>
<li><p> Think about removing all <code>rmatrix</code> transformations to the
benefit of the to-come <code>gbn</code> object.
</p>
</li>
<li><p> Introduce a check of non-negativity of <code>ma</code> into
<code>cor4var</code>.
</p>
</li>
<li><p> Add examples to all functions without any.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Original author: Jean-Baptiste Denis<br />
Maintainer: Marco Scutari
</p>


<h3>References</h3>

<p>Scutari M (2010). &quot;Learning Bayesian Networks with the bnlearn R Package&quot;.
Journal of Statistical Software, <strong>35</strong>(3), 1-22.
</p>
<p>Tian S, Scutari M &amp; Denis J-B (2014). &quot;Predicting with Crossed Linear Gaussian
Bayesian Networks&quot;. Journal de la Societe Francaise de Statistique,
<strong>155</strong>(3), 1-21.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rbmn)

## getting the data set
data(boco)
print(head(boco));

</code></pre>

<hr>
<h2 id='adja2arcs'>
Arc matrix from an adjacency matrix
</h2><span id='topic+adja2arcs'></span>

<h3>Description</h3>

<p>returns the arc matrix from an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adja2arcs(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adja2arcs_+3A_adj">adj</code></td>
<td>
<p> The adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with two columns (&quot;from&quot;,&quot;to&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> adja2arcs(rbmn0adja.02)
</code></pre>

<hr>
<h2 id='adja2crossed'>
creates a crossed-adjacency matrix from two ones
</h2><span id='topic+adja2crossed'></span>

<h3>Description</h3>

<p>Like crossed4nbn1nbn but at the level of adjacency matrices. Must be
much efficient when regression coefficients are not needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adja2crossed(adj1, adj2, nona=as.vector(outer(dimnames(adj1)[[1]],
	  dimnames(adj2)[[1]], paste, sep="_")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adja2crossed_+3A_adj1">adj1</code></td>
<td>
<p> The first adjacency matrix.</p>
</td></tr>
<tr><td><code id="adja2crossed_+3A_adj2">adj2</code></td>
<td>
<p> The second adjacency matrix.</p>
</td></tr>
<tr><td><code id="adja2crossed_+3A_nona">nona</code></td>
<td>
<p> The node names to give to the crossed /nbn/, the nodes
of the <code>nbn1</code> varying first.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just two Kronecker products of matrices.
</p>


<h3>Value</h3>

<p>The resulting crossed adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print(adja2crossed(rbmn0adja.01, rbmn0adja.01));
</code></pre>

<hr>
<h2 id='adja2nbn'>
standardized /nbn/ from an adjacency matrix
</h2><span id='topic+adja2nbn'></span>

<h3>Description</h3>

<p>returns a <code>nbn</code> object with O/1 regression coefficients having
<code>adja</code> as adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adja2nbn(adja)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adja2nbn_+3A_adja">adja</code></td>
<td>
<p> The initial adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding standardized <code>nbn</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8nbn(adja2nbn(adja4nbn(rbmn0nbn.03)));
</code></pre>

<hr>
<h2 id='adja4nbn'>
adjacency matrix of a /nbn/
</h2><span id='topic+adja4nbn'></span>

<h3>Description</h3>

<p>returns a dimnamed matrix indicating with 1 an arc from row to column
nodes (0 everywhere else); i.e. the adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adja4nbn(nbn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adja4nbn_+3A_nbn">nbn</code></td>
<td>
<p> The initial <code>nbn</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dimnamed matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'> adja4nbn(rbmn0nbn.04);
</code></pre>

<hr>
<h2 id='adja4three'>
Adjacency matrices of DAGs having three nodes
</h2><span id='topic+adja4three'></span>

<h3>Description</h3>

<p>Returns the list of the 25 adjacency matrices associated to DAGs
comprising three nodes. The first character of the name components
gives the number of arcs in the DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adja4three(nona=LETTERS[1:3])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adja4three_+3A_nona">nona</code></td>
<td>
<p> The three node names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Poor filling...
</p>


<h3>Value</h3>

<p>a named list having 25 components, each being a 3x3 matrix.
</p>

<hr>
<h2 id='arc7nb4nbn'>
returns the number(s) of arcs of a /nbn/
</h2><span id='topic+arc7nb4nbn'></span>

<h3>Description</h3>

<p>returns the arc numbers of the node of /nbn/ object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arc7nb4nbn(nbn, each=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arc7nb4nbn_+3A_nbn">nbn</code></td>
<td>
<p> The <code>nbn</code> object to consider.</p>
</td></tr>
<tr><td><code id="arc7nb4nbn_+3A_each">each</code></td>
<td>
<p> When <code>TRUE</code>, returns a named vector of the number
of parents of each node. If not the total number of arcs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parents associated with a zero regression coefficient are not
excluded in the counting.
</p>


<h3>Value</h3>

<p>Either a number or a named vector of numbers (names being the node
names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> arc7nb4nbn(rbmn0nbn.05);
</code></pre>

<hr>
<h2 id='arcs4nbn1nbn'>
returns the list of 'parallel' arcs of a crossed-nbn
</h2><span id='topic+arcs4nbn1nbn'></span>

<h3>Description</h3>

<p>Returns a list of matrices with two columns (as needed by
<code>estimate8constrainednbn</code>) indicating corresponding arcs for
each arcs/nodes of <code>nbn1</code> (or <code>nbn2</code>) of the crossed /nbn/
obtained when crossing /nbn1/ and /nbn2/ with node names given by
<code>nona</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcs4nbn1nbn(nbn1, nbn2, type="a1", nona=as.vector(outer(names(nbn1),
	  names(nbn2), paste, sep="_")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcs4nbn1nbn_+3A_nbn1">nbn1</code></td>
<td>
<p> The first generating /nbn/.</p>
</td></tr>
<tr><td><code id="arcs4nbn1nbn_+3A_nbn2">nbn2</code></td>
<td>
<p> The second generating /nbn/.</p>
</td></tr>
<tr><td><code id="arcs4nbn1nbn_+3A_type">type</code></td>
<td>
<p> Must be <code>"a1"</code> to indicate that the parallelism
must be done for each arc of <code>nbn1</code>. <code>"a2"</code> for each arc of
<code>nbn2</code>. Or <code>"n1"</code> for each node of <code>nbn1</code>. Or
<code>"n2"</code> for each node of <code>nbn2</code>. </p>
</td></tr>
<tr><td><code id="arcs4nbn1nbn_+3A_nona">nona</code></td>
<td>
<p> The node names to give to the crossed /nbn/, the nodes
of the <code>nbn1</code> varying first.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting named (after node names) list of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print(arcs4nbn1nbn(rbmn0nbn.01, rbmn0nbn.04));
</code></pre>

<hr>
<h2 id='bn2nbn'>
transforms a /bn/ of /bnlearn/ package to a /nbn/
</h2><span id='topic+bn2nbn'></span>

<h3>Description</h3>

<p>returns a <code>nbn</code> object from a DAG (<code>bn</code> object) of
/bnlearn/ package. O and 1 coefficients are introduced...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bn2nbn(bn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bn2nbn_+3A_bn">bn</code></td>
<td>
<p> The object to be transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list following the <code>nbn</code> specification
</p>

<hr>
<h2 id='bnfit2nbn'>
transforms a /bn.fit/ of /bnlearn/ package to a /nbn/
</h2><span id='topic+bnfit2nbn'></span>

<h3>Description</h3>

<p>returns a <code>nbn</code> object from a Gaussian <code>bn.fit</code> object of
/bnlearn/ package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bnfit2nbn(bn.fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bnfit2nbn_+3A_bn.fit">bn.fit</code></td>
<td>
<p> The object to be transformed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>bn.fit</code> is not pertinent, a fatal error is issued.
</p>


<h3>Value</h3>

<p>A list following the <code>nbn</code> specification
</p>

<hr>
<h2 id='body+20composition'>Body Composition Variables and Covariables </h2><span id='topic+boco'></span>

<h3>Description</h3>

<p>Real-world data set extracted from the Nhanes data base comprising
nine variables describing the body composition and five easy
measurable covariables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(boco)
</code></pre>


<h3>Format</h3>

<p>The <code>boco</code> data set stored in variable <code>boco</code>
comprises 100 individuals with the following variables:
</p>

<ul>
<li> <p><code>A</code> the age in years
</p>
</li>
<li> <p><code>H</code> the height in cm
</p>
</li>
<li> <p><code>W</code> the weight in kg
</p>
</li>
<li> <p><code>C</code> the waist circumference in cm
</p>
</li>
<li> <p><code>TF</code> the trunk fat in kg
</p>
</li>
<li> <p><code>LF</code> the leg fat in kg
</p>
</li>
<li> <p><code>AF</code> the arm fat in kg
</p>
</li>
<li> <p><code>TL</code> the trunk lean in kg
</p>
</li>
<li> <p><code>LL</code> the leg lean in kg
</p>
</li>
<li> <p><code>AL</code> the arm lean in kg
</p>
</li>
<li> <p><code>TB</code> the trunk bone in kg
</p>
</li>
<li> <p><code>LB</code> the leg bone in kg
</p>
</li>
<li> <p><code>AB</code> the arm bone in kg
</p>
</li></ul>



<h3>Source</h3>

<p>Centers for Disease Control and Prevention. The 1999-2004 dual energy
X-ray absorptiometry (DXA) multiple imputation data files and
technical documentation.<br /> Available from:
http://www.cdc.gov/nchs/about/major/nhanes/dxx/dxa.html (accessed on
13_07_03).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load the data and build the correct network from the model string.
data(boco);
print(head(boco));
boco7dag &lt;- "[H][W|H][TF|W;H]";
# to be finished
</code></pre>

<hr>
<h2 id='chain2correlation'>
computes the correlation matrix of a chain
</h2><span id='topic+chain2correlation'></span>

<h3>Description</h3>

<p>returns the correlation matrix of a /chain/ object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain2correlation(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain2correlation_+3A_chain">chain</code></td>
<td>
<p> The chain object to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The correlation matrix. It is not sorted to respect a topological
order contrary to <code>chain2mn</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> chain2correlation(rbmn0chain.03);
</code></pre>

<hr>
<h2 id='chain2gema'>
transforms a /chain/ to a /gema/
</h2><span id='topic+chain2gema'></span>

<h3>Description</h3>

<p>From a <code>chain</code> object returns the <code>gema</code> using a direct
formulae.<br /> Much precised than to use the /nbn/ way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain2gema(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain2gema_+3A_chain">chain</code></td>
<td>
<p> the <code>chain</code> object to be transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding <code>gema</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> identical(chain2gema(rbmn0chain.02)$mu, rbmn0gema.02$mu);
 print(chain2gema(rbmn0chain.02)$li-rbmn0gema.02$li);
</code></pre>

<hr>
<h2 id='chain2mn'>
computes the distribution of a chain
</h2><span id='topic+chain2mn'></span>

<h3>Description</h3>

<p>returns the /mn/ object associated to a /chain/ object. Much better
to use this function that the general function <code>nbn2mn</code> since
exact formulae are applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain2mn(chain, order=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain2mn_+3A_chain">chain</code></td>
<td>
<p> The chain object to consider.</p>
</td></tr>
<tr><td><code id="chain2mn_+3A_order">order</code></td>
<td>
<p> Must a topological order be imposed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting /mn/ object. Following the convention of <code>mn</code>
objects, a topological order is given to it. This is necessary to
retrieve the associate /nbn/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8mn(chain2mn(rbmn0chain.01));
</code></pre>

<hr>
<h2 id='chain2nbn'>
transforms a /chain/ to a /nbn/
</h2><span id='topic+chain2nbn'></span>

<h3>Description</h3>

<p>From a <code>chain</code> object returns the <code>nbn</code> translation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain2nbn(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain2nbn_+3A_chain">chain</code></td>
<td>
<p> the <code>chain</code> object to be transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding <code>nbn</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8nbn(chain2nbn(rbmn0chain.02), ordering=names(rbmn0nbn.02));
</code></pre>

<hr>
<h2 id='chain2pre'>
computes the precision of a chain
</h2><span id='topic+chain2pre'></span>

<h3>Description</h3>

<p>returns the precision matrix of a chain, that is the inverse of its
variance (correlation) matrix. Much better to use this function that
<code>solve(chain2mn(chain)$gamma)</code> since exact formulae are applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain2pre(chain, corre=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain2pre_+3A_chain">chain</code></td>
<td>
<p> The chain object to consider.</p>
</td></tr>
<tr><td><code id="chain2pre_+3A_corre">corre</code></td>
<td>
<p>To get the inverse of the correlation matrix instead
of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dimnamed matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'> chain2pre(rbmn0chain.02);
</code></pre>

<hr>
<h2 id='chain4chain'>
extracts a chain from a chain
</h2><span id='topic+chain4chain'></span>

<h3>Description</h3>

<p>returns the chain obtained from <code>chain</code> retaining only nodes
indicated by <code>nodes</code> and conditioned with nodes indicated in
<code>condi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain4chain(chain, nodes, condi=numeric(0), value=rep(0, length(condi)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain4chain_+3A_chain">chain</code></td>
<td>
<p> The chain object to consider.</p>
</td></tr>
<tr><td><code id="chain4chain_+3A_nodes">nodes</code></td>
<td>
 <p><code>numeric</code> (or <code>character</code>) vector giving the
numbers (or names) of the nodes to be retained in the extracted
chain.</p>
</td></tr>
<tr><td><code id="chain4chain_+3A_condi">condi</code></td>
<td>
 <p><code>numeric</code> (or <code>character</code>) vector giving the
numbers (or names) of the conditioning nodes for the extracted
chain.</p>
</td></tr>
<tr><td><code id="chain4chain_+3A_value">value</code></td>
<td>
<p> Numerical values associated to <code>condi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Integration is done for nodes not belonging to the extracted chain
nor being in the conditioning subset. Then the distribution of the
retained nodes is left identical to this in the initial chain.
</p>


<h3>Value</h3>

<p>The resulting chain
</p>


<h3>Examples</h3>

<pre><code class='language-R'> chain4chain(rbmn0chain.02, c("a", "d"), c("b"), 12);
</code></pre>

<hr>
<h2 id='check8chain'>
checks a /chain/ object
</h2><span id='topic+check8chain'></span>

<h3>Description</h3>

<p>checks the consistency of <code>chain</code> as a /chain/ object issues a
fatal error with some clues if inconsistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check8chain(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check8chain_+3A_chain">chain</code></td>
<td>
<p> The <code>chain</code> object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looking a the code of this function provides a way to know which are
the requirements of a /chain/ object.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or a <code>character</code> containing some clue about the
discovered inconsistency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> check8chain(rbmn0chain.01);
 res &lt;- check8chain(rbmn0adja.01);
 if (is.na(as.logical(res))) { print(res);}
</code></pre>

<hr>
<h2 id='check8gema'>
checks a /gema/ object
</h2><span id='topic+check8gema'></span>

<h3>Description</h3>

<p>checks the consistency of <code>gema</code> as a /gema/ object issues a
fatal error with some clues if inconsistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check8gema(gema)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check8gema_+3A_gema">gema</code></td>
<td>
<p> The <code>gema</code> object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looking a the code of this function provides a way to know which are
the requirements of a /chain/ object.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or a <code>character</code> containing some clue about the
discovered inconsistency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> check8gema(rbmn0gema.01);
 res &lt;- check8gema(rbmn0adja.01);
 if (is.na(as.logical(res))) { print(res);}
</code></pre>

<hr>
<h2 id='check8nbn'>
checks a /nbn/ object
</h2><span id='topic+check8nbn'></span>

<h3>Description</h3>

<p>checks the consistency of <code>nbn</code> as a /nbn/ object issues a fatal
error with some clues if inconsistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check8nbn(nbn, sto = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check8nbn_+3A_nbn">nbn</code></td>
<td>
<p> The <code>nbn</code> object to check.</p>
</td></tr>
<tr><td><code id="check8nbn_+3A_sto">sto</code></td>
<td>
<p> If 'TRUE', the possible error is displayed and the process is
stopped. If 'FALSE', the possible error is returned as a character. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looking a the code of this function provides a way to know which are
the requirements of a /chain/ object.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or a <code>character</code> containing some clue about the
discovered inconsistency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> check8nbn(rbmn0nbn.01);
 res &lt;- check8nbn(rbmn0adja.01);
 if (is.na(as.logical(res))) { print(res);}
</code></pre>

<hr>
<h2 id='condi4joint'>
computes some conditional distribution of a multinormal vector
</h2><span id='topic+condi4joint'></span>

<h3>Description</h3>

<p>returns the expectation and variance of a sub-vector conditionned
with another (non overlapping) sub-vector from an initial random
vector described by <code>mn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condi4joint(mn, par, pour, x2=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condi4joint_+3A_mn">mn</code></td>
<td>
<p> list defining the distribution of the initial vector with
<code>$mu</code>, its expectation, and <code>$gamma</code>, its variance matrix.</p>
</td></tr>
<tr><td><code id="condi4joint_+3A_par">par</code></td>
<td>
<p> names (or indices) of the sub-vector to give the
distribution.</p>
</td></tr>
<tr><td><code id="condi4joint_+3A_pour">pour</code></td>
<td>
<p> names (or indices) of the conditionning sub-vector (can
be <code>NULL</code> when for non conditionning.</p>
</td></tr>
<tr><td><code id="condi4joint_+3A_x2">x2</code></td>
<td>
<p>values to consider for the conditioning sub-vector. When
<code>NULL</code> the general form is supplied, not a /mn/ object. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>when no names are given to <code>mn$mu</code>, <code>par</code> and <code>pour</code>
are supposed containing indices and default sequential names are
provided.
</p>


<h3>Value</h3>

<p>A list:<br /> when <code>x2</code> provides the values taken by the
conditioning part, it is a /mn/ object with its two components:
<code>$mu</code> for the expectation vector and <code>$gamma</code> for the
variance matrix.<br /> when <code>x2</code> is <code>NULL</code> the list has got
three components: <code>$mu</code> for the fixed part of the expectation
vector, <code>$b</code> for the regression coefficients to be associated to
the non precised <code>x2</code> values, varying part of the expectation
and <code>$gamma</code> for the variance matrix.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8mn(condi4joint(rbmn0mn.04, c("1.1", "2.2", "1.2", "2.1"), NULL));
 print8mn(condi4joint(rbmn0mn.04, c("1.1", "2.2", "1.2", "2.1"), "C", 0));
 print(condi4joint(rbmn0mn.04, c("1.1", "2.2", "1.2", "2.1"), "C", NULL));
</code></pre>

<hr>
<h2 id='cor4var'>
returns the correlation matrix from the variance
</h2><span id='topic+cor4var'></span>

<h3>Description</h3>

<p>returns the correlation matrix from the variance preserving possible
variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor4var(ma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor4var_+3A_ma">ma</code></td>
<td>
<p> The variance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero variances are detected and accepted (all associated correlation
coefficients are forced to be zero.<code class="reqn">&gt;&gt;</code>
</p>


<h3>Value</h3>

<p>The correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'> cor4var(rbmn0mn.04$gamma);
</code></pre>

<hr>
<h2 id='crossed4nbn1nbn'>
creates a crossed-nbn from two /nbn/s
</h2><span id='topic+crossed4nbn1nbn'></span>

<h3>Description</h3>

<p>A crossed /nbn/ is a /nbn/ obtained when replacing each node of the
first /nbn/ by the second /nbn/ and vice-versa.<br /> Let <code>nn1/nn2</code>
and <code>na1/na2</code> be the node and arc numbers of the two
<code>nbn</code>s, the node number of the crossed <code>nbn</code> is
<code>nn1*nn2</code> and its arc number is <code>nn1*na2+nn2*na1</code>.<br /> The
regression coefficients attributed to the crossed <code>nbn</code> are the
products of the weights (<code>we1/we2</code>) and the regression
coefficients of the initial <code>nbn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossed4nbn1nbn(nbn1, nbn2, we1=rep(1, length(nbn1)), we2=rep(1, length(nbn2)),
	  nona=as.vector(outer(names(nbn1), names(nbn2), paste,
	  sep="_")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossed4nbn1nbn_+3A_nbn1">nbn1</code></td>
<td>
<p> The first generating /nbn/.</p>
</td></tr>
<tr><td><code id="crossed4nbn1nbn_+3A_nbn2">nbn2</code></td>
<td>
<p> The second generating /nbn/.</p>
</td></tr>
<tr><td><code id="crossed4nbn1nbn_+3A_we1">we1</code></td>
<td>
<p> The weight to apply to the nodes of the first generating
/nbn/.</p>
</td></tr>
<tr><td><code id="crossed4nbn1nbn_+3A_we2">we2</code></td>
<td>
<p> The weight to apply to the nodes of the second generating
/nbn/.</p>
</td></tr>
<tr><td><code id="crossed4nbn1nbn_+3A_nona">nona</code></td>
<td>
<p> The node names to give to the crossed /nbn/, the nodes
of the <code>nbn1</code> varying first.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mu</code> coefficient is the sum of the two corresponding
<code>mu</code>s of the generating <code>nbn</code>.<br /> The <code>sigma</code>
coefficient is the product of the two corresponding <code>sigma</code>s of
the generating <code>nbn</code>.<br /> The regression coefficient are directed
inherited from the <code>nbn</code> which is duplicated with this arc.
</p>


<h3>Value</h3>

<p>The resulting crossed <code>nbn</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8nbn(crossed4nbn1nbn(rbmn0nbn.01, rbmn0nbn.04));
</code></pre>

<hr>
<h2 id='dev4mn'>
Computes the deviance for a sample of multinormal vector
</h2><span id='topic+dev4mn'></span>

<h3>Description</h3>

<p>From the <code>n</code> observed values of a vector of size <code>p</code> (Y),
their expectations (EY) and the variance matrix (VY) supposed
identical for all vectors, returns the deviance, i.e.
<code>-2*log(p(Y))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dev4mn(Y, EY, VY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dev4mn_+3A_y">Y</code></td>
<td>
<p>Matrix <code>nxp</code> of the <code>n</code> observed values of length
<code>p</code>.</p>
</td></tr>
<tr><td><code id="dev4mn_+3A_ey">EY</code></td>
<td>
<p>Expectation of <code>Y</code> (matrix <code>nxp</code> or vector
<code>p</code>).</p>
</td></tr>
<tr><td><code id="dev4mn_+3A_vy">VY</code></td>
<td>
<p>Matrix of the variance of each row of <code>Y</code> (matrix
<code>pxp</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>EY</code> is a vector with length <code>ncol(Y)</code> this supposes
that all observations have the same expectation.
</p>


<h3>Value</h3>

<p>A scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dev4mn(matrix(runif(3), 1), t(rbmn0mn.01$mu), rbmn0mn.01$gamma);
</code></pre>

<hr>
<h2 id='diff8nbn'>
returns a score of the difference between two /nbn/s
</h2><span id='topic+diff8nbn'></span>

<h3>Description</h3>

<p>Returns a positive scalar value measuring, in some way, the
difference existing within two /nbn/s sharing the same structure.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff8nbn(nbn1, nbn2, type=1, scalar=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff8nbn_+3A_nbn1">nbn1</code></td>
<td>
<p>First <code>nbn</code> object.</p>
</td></tr>
<tr><td><code id="diff8nbn_+3A_nbn2">nbn2</code></td>
<td>
<p>Second <code>nbn</code> object.</p>
</td></tr>
<tr><td><code id="diff8nbn_+3A_type">type</code></td>
<td>
<p>When 1, the score includes the difference between the
sigmas. When -1, sigmas are not taken into account.</p>
</td></tr>
<tr><td><code id="diff8nbn_+3A_scalar">scalar</code></td>
<td>
<p>When <code>TRUE</code> the squared norm is returned, if not
the vector of difference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type==1</code> it is the canonical euclidian difference between
all parameters, including the <code>sigma</code>. The score to use to
measure the differences between two successive estimations is not
well established (see the code).
</p>


<h3>Value</h3>

<p>Either a scalar or a named vector (according to <code>scalar</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> diff8nbn(rbmn0nbn.01, rbmn0nbn.01);
 diff8nbn(rbmn0nbn.01, rbmn0nbn.01, scalar=FALSE);
</code></pre>

<hr>
<h2 id='estimate8constrainednbn'>
estimates the parameters of a nbn with equality constraints
</h2><span id='topic+estimate8constrainednbn'></span>

<h3>Description</h3>

<p>Estimations of the parameters of a /nbn/ is done when there are some
equality constraints onto the regression coefficients.<br /> Constant
terms (<code>mu</code>) and conditional standard deviations (<code>sigma</code>)
are supposed independent (that is not constrained with
equalities).<br /> Equality constraints are given by <code>sarc</code>, a list
of matrices with two columns, indicating each the series of arcs
having the same regression coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate8constrainednbn(nbn, sarc, data, imp=0, nite=10, eps=10^-5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate8constrainednbn_+3A_nbn">nbn</code></td>
<td>
<p><code>nbn</code> object.</p>
</td></tr>
<tr><td><code id="estimate8constrainednbn_+3A_sarc">sarc</code></td>
<td>
<p>List of Matrices with two columns indicating the tails
(1rst column) and the heads (2d column) of the arcs having a common
parameter. It is checked that these arcs are indeed included in
<code>nbn</code>. Nodes must be indicated by their names (not their
number).</p>
</td></tr>
<tr><td><code id="estimate8constrainednbn_+3A_data">data</code></td>
<td>
<p>Data frame to be used for the estimation. It must
comprise all necessary nodes (not only those involved in <code>sarc</code>
but also the remaining parents of <code>sarc[,2]</code>. Usually, all used
variables are centred but this is not required.</p>
</td></tr>
<tr><td><code id="estimate8constrainednbn_+3A_imp">imp</code></td>
<td>
<p>When <code>0</code> nothing displayed. When <code>1</code> the number
of iterations is displayed. When <code>2</code> the successive values of
the criterion are also displayed. </p>
</td></tr>
<tr><td><code id="estimate8constrainednbn_+3A_nite">nite</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="estimate8constrainednbn_+3A_eps">eps</code></td>
<td>
<p>relative difference in successive scores needed to stop
the iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not linked regression coefficients doesn't require to be included in
<code>sarc</code>, the function do it by itself.<br /> The score to use to
measure the differences between two successive estimations is not
well established (see the code).
</p>


<h3>Value</h3>

<p>The resulting /nbn/ object with the estimated parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(boco);
 print8nbn(rbmn0nbn.05);
 print8nbn(estimate8nbn(rbmn0nbn.05, boco));
 print8nbn(estimate8constrainednbn(rbmn0nbn.05, rbmn0crarc.05, boco));
</code></pre>

<hr>
<h2 id='estimate8nbn'>
estimating the /nbn/ parameters
</h2><span id='topic+estimate8nbn'></span>

<h3>Description</h3>

<p>From a /nbn/ to describe the DAG, and a data.frame containing the
necessary observations, returns the /nbn/ with all its parameters
newly estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate8nbn(nbn, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate8nbn_+3A_nbn">nbn</code></td>
<td>
<p> The initial /nbn/.</p>
</td></tr>
<tr><td><code id="estimate8nbn_+3A_data">data</code></td>
<td>
<p>The data frame comprising all /nbn/ nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No constraints are put on the parameters.
</p>


<h3>Value</h3>

<p>The resulting /nbn/ with the estimated parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(boco);
 print8nbn(rbmn0nbn.05);
 print8nbn(estimate8nbn(rbmn0nbn.05, boco));
</code></pre>

<hr>
<h2 id='gema2mn'>
computes a /mn/ from a /gema/
</h2><span id='topic+gema2mn'></span>

<h3>Description</h3>

<p>from a /gema/ object defining a normal Bayesian network, computes the
expectation and variance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gema2mn(gema)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gema2mn_+3A_gema">gema</code></td>
<td>
<p>Initial <code>gema</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following components: <code>mu</code> and <code>gamma</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8mn(gema2mn(rbmn0gema.04));
</code></pre>

<hr>
<h2 id='gema2nbn'>
computes a /nbn/ from a /gema/
</h2><span id='topic+gema2nbn'></span>

<h3>Description</h3>

<p>from a /gema/ object defining a normal Bayesian network, computes
more standard /nbn/ where each node is defined from its parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gema2nbn(gema)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gema2nbn_+3A_gema">gema</code></td>
<td>
<p>Initial <code>gema</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>using general formulae rather a sequential algorithm as done in the
original <code>gema2nbn</code> implementation.
</p>


<h3>Value</h3>

<p>the corresponding /nbn/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8nbn(gema2nbn(rbmn0gema.02));
</code></pre>

<hr>
<h2 id='generate8chain'>
generation of a /chain/ /nbn/
</h2><span id='topic+generate8chain'></span>

<h3>Description</h3>

<p>[randomly] generates a /chain/ /nbn/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate8chain(rnn=c(3, 7), proo=0.5, rcor=c(-1, 1), rmu=c(0, 0), rsig=c(0, 1),
	  nona=r.form3names(max(rnn)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate8chain_+3A_rnn">rnn</code></td>
<td>
<p>Range of the number of nodes.</p>
</td></tr>
<tr><td><code id="generate8chain_+3A_proo">proo</code></td>
<td>
<p>Probabilit[y<code class="reqn">|</code>ies] that the successive and
acceptable nodes be colliders. Can be a vector.</p>
</td></tr>
<tr><td><code id="generate8chain_+3A_rcor">rcor</code></td>
<td>
<p>Range of the correlations between neighbour nodes.</p>
</td></tr>
<tr><td><code id="generate8chain_+3A_rmu">rmu</code></td>
<td>
<p>Range of the expectations.</p>
</td></tr>
<tr><td><code id="generate8chain_+3A_rsig">rsig</code></td>
<td>
<p>Range of the standard deviations.</p>
</td></tr>
<tr><td><code id="generate8chain_+3A_nona">nona</code></td>
<td>
<p>Proposed names for the maximum number of nodes, only the
necessary first ones will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proposed ranges can be a unique value, implying no randomness in the
value.<br /> Roots are placed according to <code>proo</code> probabilities,
then collider are placed in between with uniform probability on the
possibles nodes.
</p>


<h3>Value</h3>

<p>A /chain/ coding list is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(1234);
 print8chain(generate8chain());
 print8chain(generate8chain());
 print8chain(generate8chain(rnn=10, rcor=0.5));
 print8chain(generate8chain(rnn=10, rcor=0.5));
</code></pre>

<hr>
<h2 id='generate8nbn'>
returns a randomly built /nbn/ object.
</h2><span id='topic+generate8nbn'></span>

<h3>Description</h3>

<p>To obtain systematic results, you have to call <code>set.seed</code> before
hands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate8nbn(rnn=c(3, 7), ppar=0.5, rreg=c(-1, 1), rmu=c(0, 0), rsig=c(0, 1),
	  nona=r.form3names(max(rnn)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate8nbn_+3A_rnn">rnn</code></td>
<td>
<p>Range of the number of nodes.</p>
</td></tr>
<tr><td><code id="generate8nbn_+3A_ppar">ppar</code></td>
<td>
<p>Probabilities (not a range) of the parent occurrence for
each ancestor of every node. Can be a vector, cycled as necessary.</p>
</td></tr>
<tr><td><code id="generate8nbn_+3A_rreg">rreg</code></td>
<td>
<p>Range of regression coefficients.</p>
</td></tr>
<tr><td><code id="generate8nbn_+3A_rmu">rmu</code></td>
<td>
<p>Range of the conditional expectations.</p>
</td></tr>
<tr><td><code id="generate8nbn_+3A_rsig">rsig</code></td>
<td>
<p>Range of the conditional standard deviations.</p>
</td></tr>
<tr><td><code id="generate8nbn_+3A_nona">nona</code></td>
<td>
<p>Proposed names for the maximum number of nodes, only the
necessary first ones will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Node numbers are uniformly drawn. Parent numbers are independently
drawn from all ancestors with the probability associated to the
considered node. Regression coefficient are uniformly drawn.
Conditional expectations and standard deviations are uniformly
drawn.<br /> All range arguments can be given one value instead of two,
to precise the unique value to use.
</p>


<h3>Value</h3>

<p>a /nbn/ object, with nodes in topological order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(1234)
 print8nbn(generate8nbn());
 print8nbn(generate8nbn());
</code></pre>

<hr>
<h2 id='inout4chain'>
reduces a chain to its inputs and outputs
</h2><span id='topic+inout4chain'></span>

<h3>Description</h3>

<p>From a <code>chain</code> returns the reduced <code>chain</code> comprising only
inputs (that is root nodes) and outputs (that is colliders and ends
which are not roots)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inout4chain(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inout4chain_+3A_chain">chain</code></td>
<td>
<p> The chain object to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting chain
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8chain(inout4chain(rbmn0chain.02));
</code></pre>

<hr>
<h2 id='is8nbn8chain'>
Checks if a given /nbn/ is a /chain/
</h2><span id='topic+is8nbn8chain'></span>

<h3>Description</h3>

<p>returns <code>TRUE</code> [the order] or <code>FALSE</code> [NULL] according that
<code>nbn</code> is a chain of not [according to <code>order</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is8nbn8chain(nbn, order=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is8nbn8chain_+3A_nbn">nbn</code></td>
<td>
<p> The nbn object to consider.</p>
</td></tr>
<tr><td><code id="is8nbn8chain_+3A_order">order</code></td>
<td>
<p> When <code>FALSE</code> the answer to the question is
returned with <code>TRUE</code> or <code>FALSE</code>.<br /> When <code>TRUE</code> the
chain order of the nodes is returned if it is a /chain/ else
<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical(1)</code> when <code>order</code> si <code>TRUE</code> if not the
resulting chain order versus NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is8nbn8chain(rbmn0nbn.01);
is8nbn8chain(rbmn0nbn.04);
</code></pre>

<hr>
<h2 id='marginal4chain'>
returns marginal expectations and standard deviations of a chain
</h2><span id='topic+marginal4chain'></span>

<h3>Description</h3>

<p>From a <code>chain</code> object returns a list with two components:
<code>$mu</code> and <code>$sigma</code> vectors of marginal expectations and
standard deviations.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal4chain(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal4chain_+3A_chain">chain</code></td>
<td>
<p> the <code>chain</code> object to be considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the two components <code>$mu</code> and <code>$sigma</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> marginal4chain(rbmn0chain.02);
</code></pre>

<hr>
<h2 id='mn2gema'>
computes a /gema/ from a /mn/
</h2><span id='topic+mn2gema'></span>

<h3>Description</h3>

<p>proposes generating matrices of a Bayesian network from a /mn/ object
defining a multinormal distribution by expectation and variance,
under the assumption that the nodes are in topological order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mn2gema(mn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mn2gema_+3A_mn">mn</code></td>
<td>
<p>Initial <code>mn</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the /gema/ components <code>$mu</code> and <code>$li</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8gema(mn2gema(rbmn0mn.04));
</code></pre>

<hr>
<h2 id='mn4joint1condi'>
computes a joint distribution from a marginal and a conditional one
for multinormal distributions
</h2><span id='topic+mn4joint1condi'></span>

<h3>Description</h3>

<p>returns the expectation and variance of the multinormal normal
distribution defined through a marginal subcomponent and a
conditional distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mn4joint1condi(lmar, lcon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mn4joint1condi_+3A_lmar">lmar</code></td>
<td>
<p> list defining the distribution of the marginal part with
elements <code>mu</code>, its expectation, and <code>gamma</code>, its variance
matrix (in fact a /mn/ object).</p>
</td></tr>
<tr><td><code id="mn4joint1condi_+3A_lcon">lcon</code></td>
<td>
<p> list defining the distribution of the conditional part
(see the <em>Details</em> section).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional distribution is defined with a list with elements
<code>a</code> for the constant part of the expectation; <code>b</code> for the
regression coefficient part of the expectation; and <code>S</code> for the
residual variance matrix.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>The expectation vector.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>The joint variance matrix.</p>
</td></tr>
</table>
<p>that is a /mn/ object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> lcon &lt;- list(a=c(D=2, E=4),
 b=matrix(1:6, 2, dimnames=list(LETTERS[4:5],
 LETTERS[1:3])),
 S=matrix(c(1, 1, 1, 2), 2));

 print8mn(mn4joint1condi(rbmn0mn.01, lcon));
</code></pre>

<hr>
<h2 id='nb8bn'>
number of Bayesian networks
</h2><span id='topic+nb8bn'></span>

<h3>Description</h3>

<p>returns the number of different Bayesian networks having <code>n</code>
labelled or not nodes. Non labelled nodes means that nodes are
exchangeable: <code>A -&gt; B</code> is identical to <code>A &lt;- B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb8bn(n, label=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb8bn_+3A_n">n</code></td>
<td>
<p> number of nodes. Must be less or equal to 18.</p>
</td></tr>
<tr><td><code id="nb8bn_+3A_label">label</code></td>
<td>
<p>Indicates if the nodes must be considered as labelled or
not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When not labelled nodes, the results were proposed by Sloane in 'the
on line encyclopedy of integer sequences' (http://oeis.org/A003087).
For labelled nodes, just the application of the recursive formula of
Robinson.
</p>


<h3>Value</h3>

<p>Number of Bayesian networks
</p>


<h3>Examples</h3>

<pre><code class='language-R'> nb8bn(5)
 nb8bn(5, TRUE);
</code></pre>

<hr>
<h2 id='nbn2bnfit'>
transforms a /nbn/ to a /bn.fit/ of /bnlearn/ package
</h2><span id='topic+nbn2bnfit'></span>

<h3>Description</h3>

<p>returns a <code>bn.fit</code> object from a Gaussian <code>nbn</code> object of
/rbmn/ package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbn2bnfit(nbn, onlydag=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbn2bnfit_+3A_nbn">nbn</code></td>
<td>
<p> The object to be transformed.</p>
</td></tr>
<tr><td><code id="nbn2bnfit_+3A_onlydag">onlydag</code></td>
<td>
<p> Indicates if only the DAG must be computed. In that
case a /bn/ object of /bnlearn/</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting <code>bn.fit</code> (or <code>bn</code>) object.
</p>

<hr>
<h2 id='nbn2chain'>
transforms a /nbn/ into a /chain/
</h2><span id='topic+nbn2chain'></span>

<h3>Description</h3>

<p>returns the chain obtained from <code>nbn</code> which is supposed to a
chain. If it is not a chain, an error is issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbn2chain(nbn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbn2chain_+3A_nbn">nbn</code></td>
<td>
<p> The /nbn/ object to consider.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is advised to use <code>is8nbn8chain</code> before calling this
function.
</p>


<h3>Value</h3>

<p>The resulting chain
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8chain(nbn2chain(rbmn0nbn.02));
</code></pre>

<hr>
<h2 id='nbn2gema'>
computes a /gema/ from a /nbn/
</h2><span id='topic+nbn2gema'></span>

<h3>Description</h3>

<p>from a /nbn/ object defining a normal Bayesian network, computes the
vector <code>mu</code> and the matrix <code>li</code> such that if the vector
<code>E</code> is a vector of i.i.d. centred and standardized normal, then
<code>mu + li 
*
 E</code> has the same distribution as the input /nbn/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbn2gema(nbn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbn2gema_+3A_nbn">nbn</code></td>
<td>
<p><code>nbn</code> object for which the generating matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the two following components: <code>mu</code> and <code>li</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> identical(nbn2gema(rbmn0nbn.02), rbmn0gema.02);
</code></pre>

<hr>
<h2 id='nbn2mn'>
computes the joint distribution of a /nbn/
</h2><span id='topic+nbn2mn'></span>

<h3>Description</h3>

<p>Computes the joint distribution of a /nbn/ with three possible
algorithms according to <code>algo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbn2mn(nbn, algo=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbn2mn_+3A_nbn">nbn</code></td>
<td>
<p>The <code>nbn</code> object to be converted.</p>
</td></tr>
<tr><td><code id="nbn2mn_+3A_algo">algo</code></td>
<td>
<p>either <code>1</code>: transforming the <code>nbn</code> into a
<code>gema</code> first before getting the <code>mn</code> form; or <code>2</code>: one
variable after another is added to the joint distribution following a
topological order; or <code>3</code>: variances are computed through the
differents paths o</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be explained if it works
</p>


<h3>Value</h3>

<p>the resulting /mn/ object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8mn(nbn2mn(rbmn0nbn.05));
</code></pre>

<hr>
<h2 id='nbn2nbn'>
computes the /nbn/ changing its topological order
</h2><span id='topic+nbn2nbn'></span>

<h3>Description</h3>

<p>returns the proposed /nbn/ with a new topological order without
modifying the joint distribution of all variables.<br /> This allows to
directly find regression formulae within the Gaussian Bayesian
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbn2nbn(nbn, norder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbn2nbn_+3A_nbn">nbn</code></td>
<td>
<p> The /nbn/ to transform.</p>
</td></tr>
<tr><td><code id="nbn2nbn_+3A_norder">norder</code></td>
<td>
<p> The topological order to follow. It can be indicated
by names or numbers. When not all nodes are included, the resulting
/nbn/ is restricted to these nodes after marginalization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BE aware that for the moment, no check is made about the topological
order and if it is not, the result is FALSE!
</p>


<h3>Value</h3>

<p>The resulting /nbn/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8mn(nbn2mn(rbmn0nbn.01, algo=1));
 print8mn(nbn2mn(rbmn0nbn.01, algo=2));
 print8mn(nbn2mn(rbmn0nbn.01, algo=3));
 print8mn(nbn2mn(nbn2nbn(rbmn0nbn.02, c(1, 2, 4, 5, 3))));
 print8mn(nbn2mn(nbn2nbn(rbmn0nbn.02, c(4, 1, 2, 3, 5))));
</code></pre>

<hr>
<h2 id='nbn2rr'>
computes standard matrices from a /nbn/
</h2><span id='topic+nbn2rr'></span>

<h3>Description</h3>

<p>from a /nbn/ object defining a normal Bayesian network, returns a
list comprising (i) <code>mm</code> the vector of the mean of the different
nodes when the parents are nought, (ii) <code>ss</code> the vector of the
conditional standard deviations and (iii) <code>rr</code> the matrix of the
regression coefficients of the direct parents (<code>rr[i,j]</code>
contains the regression coefficient of the node <code>j</code> for its
parents <code>i</code> or zero when <code>i</code> is not a parent of <code>j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbn2rr(nbn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbn2rr_+3A_nbn">nbn</code></td>
<td>
<p><code>nbn</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting list with the three components: <code>mm</code>, <code>ss</code>
and <code>rr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> nbn2rr(rbmn0nbn.01);
</code></pre>

<hr>
<h2 id='nbn4nbn'>
From a /nbn/ computes the associated nbn1
</h2><span id='topic+nbn4nbn'></span>

<h3>Description</h3>

<p>returns a /nbn/ object with the same structure as <code>nbn</code> but all
<code>$mu</code> are put to zero, all <code>$sigma</code> to one as well as
<code>$regcof</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbn4nbn(nbn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbn4nbn_+3A_nbn">nbn</code></td>
<td>
<p> The <code>nbn</code> object to transform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These coefficient values allows the easy study of the /nbn/
structure.
</p>


<h3>Value</h3>

<p>The resulting <code>nbn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8nbn(nbn4nbn(rbmn0nbn.04));
</code></pre>

<hr>
<h2 id='nbn4rmatrix'>
a /nbn/ from a regression matrix
</h2><span id='topic+nbn4rmatrix'></span>

<h3>Description</h3>

<p>reverse of <code>rmatrix4nbn</code> but the standard deviations must be
included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbn4rmatrix(rmatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbn4rmatrix_+3A_rmatrix">rmatrix</code></td>
<td>
<p> The regression coefficient matrix with the standard
deviations in the diagonal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mu</code>s are put to nought
</p>


<h3>Value</h3>

<p>A /nbn/ object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8nbn(nbn4rmatrix(rmatrix4nbn(rbmn0nbn.02)));
</code></pre>

<hr>
<h2 id='normalize8nbn'>
normalizes a /nbn/
</h2><span id='topic+normalize8nbn'></span>

<h3>Description</h3>

<p>returns a <code>nbn</code> with a given expectation and variance through an
transformation leaving the correlation unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize8nbn(nbn, mu=0, sigma=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize8nbn_+3A_nbn">nbn</code></td>
<td>
<p> The <code>nbn</code> object to transform.</p>
</td></tr>
<tr><td><code id="normalize8nbn_+3A_mu">mu</code></td>
<td>
<p> Imposed expectations. When <code>NULL</code> nothing is changed.
When of length one, this value is given to all the node expectations.
If not the complete vector of expect</p>
</td></tr>
<tr><td><code id="normalize8nbn_+3A_sigma">sigma</code></td>
<td>
<p> The same as <code>mu</code> but for the standard deviations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed <code>nbn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8nbn(normalize8nbn(rbmn0nbn.01));
</code></pre>

<hr>
<h2 id='order4chain'>
returns a topological order of a /chain/ or checks a proposed order.
</h2><span id='topic+order4chain'></span>

<h3>Description</h3>

<p>From a <code>chain</code> object returns one of the possible topological
orders, through a permutation when <code>is.null(ord)</code>. If not
<code>ord</code> must be a proposed order to be checked given as a
permutation if <code>is.numeric(ord)</code> or a vector of ordered names if
<code>is.character(ord)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order4chain(chain, ord=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order4chain_+3A_chain">chain</code></td>
<td>
<p> the <code>chain</code> object to be considered.</p>
</td></tr>
<tr><td><code id="order4chain_+3A_ord">ord</code></td>
<td>
<p> Indicates what must be done. <code>NULL</code> to get a
topological order associated to the chain otherwise a permutation to
be checked as one of the possible topological orders of the chain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the moment the <code>ord</code> option is bad and an error message is
returned when used.
</p>


<h3>Value</h3>

<p>a permutation vector of the nodes of the /nbn/ or a named character
with the nodes not having their parents before them; when it is of
length zero this means that the check was successful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> order4chain(rbmn0chain.02);
 order4chain(rbmn0chain.02, order4chain(rbmn0chain.02));
</code></pre>

<hr>
<h2 id='order4gema'>
topological order of a /gema/
</h2><span id='topic+order4gema'></span>

<h3>Description</h3>

<p>returns one of the orders of the nodes such as the parents of any
node are less ranked than it when <code>is.null(ord)</code>. If not check
that the proposed order is either a right permutation
(<code>is.numeric(ord)</code>) or a vector of node names providing a
topological order (<code>is.character(ord)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order4gema(gema, ord=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order4gema_+3A_gema">gema</code></td>
<td>
<p><code>gema</code> object for which the order must be computed.</p>
</td></tr>
<tr><td><code id="order4gema_+3A_ord">ord</code></td>
<td>
<p><code>NULL</code> or an order to test as a permutation or a
vector of names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>!is.null(ord)</code> the order must be an order, if not an error
is issued.
</p>


<h3>Value</h3>

<p>a permutation vector of the nodes of the /gema/ or a named list with
the nodes not having their parents before them. That is a topological
order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> names(rbmn0gema.04$mu)[order4gema(rbmn0gema.04)];
</code></pre>

<hr>
<h2 id='order4nbn'>
topological order of a /nbn/
</h2><span id='topic+order4nbn'></span>

<h3>Description</h3>

<p>returns one of the orders of the nodes such as the parents of any
node are less ranked than it when <code>is.null(ord)</code>. If not check
that the proposed order is either a right permutation
(<code>is.numeric(ord)</code>) or a vector of node names providing a
topological order (<code>is.character(ord)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order4nbn(nbn, ord=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order4nbn_+3A_nbn">nbn</code></td>
<td>
<p><code>nbn</code> object for which the order must be computed.</p>
</td></tr>
<tr><td><code id="order4nbn_+3A_ord">ord</code></td>
<td>
<p><code>NULL</code> or an order to test as a permutation or a
vector of names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>!is.null(ord)</code> the order must be an order, if not an error
is issued.
</p>


<h3>Value</h3>

<p>a permutation vector of the nodes of the /nbn/ or a named list with
the nodes not having their parents before them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> names(rbmn0nbn.04)[order4nbn(rbmn0nbn.04)];
</code></pre>

<hr>
<h2 id='print8chain'>
prints a /chain/ object
</h2><span id='topic+print8chain'></span>

<h3>Description</h3>

<p>prints a /chain/ object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print8chain(chain, digits=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print8chain_+3A_chain">chain</code></td>
<td>
<p> The <code>chain</code> object to print.</p>
</td></tr>
<tr><td><code id="print8chain_+3A_digits">digits</code></td>
<td>
<p> when not null, the number of digits for rounding the
numerical values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>nbn2chain</code> code for some details about the definition of a
/chain/.
</p>


<h3>Value</h3>

<p>nothing but something is printed
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8chain(rbmn0chain.01);
 print8chain(rbmn0chain.02);
 print8chain(rbmn0chain.03);
</code></pre>

<hr>
<h2 id='print8gema'>
standard print function for a /gema/ object.
</h2><span id='topic+print8gema'></span>

<h3>Description</h3>

<p>prints a /gema/ object completely or a part of it according to
<code>what</code> specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print8gema(gema, what="ml", ordering=NULL, digits=3, printed=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print8gema_+3A_gema">gema</code></td>
<td>
<p><code>gema</code> object to be printed.</p>
</td></tr>
<tr><td><code id="print8gema_+3A_what">what</code></td>
<td>
<p>a <code>character(1)</code>; when comprising &quot;m&quot; the
expectations are printed, &quot;l&quot; the linear combinations are printed.</p>
</td></tr>
<tr><td><code id="print8gema_+3A_ordering">ordering</code></td>
<td>
<p> Nodes are given following the indices of &quot;ordering&quot;
if <code>numeric</code> or the names if it is <code>character</code>. <code>NULL</code>
means the identity permutation. Repetitions or missing nodes are
accepted.</p>
</td></tr>
<tr><td><code id="print8gema_+3A_digits">digits</code></td>
<td>
<p> when not null, the number of digits for rounding.</p>
</td></tr>
<tr><td><code id="print8gema_+3A_printed">printed</code></td>
<td>
 <p><code>TRUE</code> to issue a printing, if not the prepared
matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>gema</code> is printed or a matrix having <code>nn x ?</code> is
returned binding which elements are precised in the argument
<code>what</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8gema(rbmn0gema.01);
 print8gema(rbmn0gema.02, "m");
 print8gema(rbmn0gema.03, "l", digit=1);
 print8gema(rbmn0gema.04, printed=FALSE);
</code></pre>

<hr>
<h2 id='print8mn'>
standard print function for a /mn/ object.
</h2><span id='topic+print8mn'></span>

<h3>Description</h3>

<p>prints a /mn/ object completely or a part of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print8mn(mn, what="msC", ordering=NULL, digits=3, printed=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print8mn_+3A_mn">mn</code></td>
<td>
<p><code>mn</code> object to be printed.</p>
</td></tr>
<tr><td><code id="print8mn_+3A_what">what</code></td>
<td>
<p>a <code>character(1)</code>; when comprising &quot;m&quot; the
expectations are printed, &quot;s&quot; the standard deviations are printed,
&quot;C&quot; the correlation matrix is printed, &quot;S&quot; the variance matrix is
printed, &quot;P&quot; the precision matrix is printed, &quot;p&quot; the normalized
precision matrix is printed.</p>
</td></tr>
<tr><td><code id="print8mn_+3A_ordering">ordering</code></td>
<td>
<p> Nodes are given following the indices of &quot;ordering&quot;
if <code>numeric</code> or the names if it is <code>character</code>. <code>NULL</code>
means the identity permutation. Repetitions or missing nodes are
accepted.</p>
</td></tr>
<tr><td><code id="print8mn_+3A_digits">digits</code></td>
<td>
<p> when not null, the number of digits for rounding the
parameter values.</p>
</td></tr>
<tr><td><code id="print8mn_+3A_printed">printed</code></td>
<td>
 <p><code>TRUE</code> to issue a printing, if not the prepared
matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>mn</code> is printed or a matrix having <code>nn x ?</code> is returned
binding which elements precised in the argument <code>what</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8mn(rbmn0mn.01);
</code></pre>

<hr>
<h2 id='print8nbn'>
print function for a /nbn/ object.
</h2><span id='topic+print8nbn'></span>

<h3>Description</h3>

<p>prints a /nbn/ object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print8nbn(nbn, what="pr", digits=3, ordering=NULL, chk=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print8nbn_+3A_nbn">nbn</code></td>
<td>
<p><code>nbn</code> object to be printed.</p>
</td></tr>
<tr><td><code id="print8nbn_+3A_what">what</code></td>
<td>
<p>a <code>character(1)</code>; when comprising &quot;p&quot; the name of
each node with its parents are given, when comprising &quot;r&quot; the formula regression
of each node is given with the node, when comprising &quot;m&quot; the model is given.</p>
</td></tr>
<tr><td><code id="print8nbn_+3A_digits">digits</code></td>
<td>
<p> when not null, the number of digits for rounding.</p>
</td></tr>
<tr><td><code id="print8nbn_+3A_ordering">ordering</code></td>
<td>
<p> Nodes are given following the indices of &quot;ordering&quot;
if <code>numeric</code> or the names if it is <code>character</code>. <code>NULL</code>
means the identity permutation. Repetitions or missing nodes are
accepted.</p>
</td></tr>
<tr><td><code id="print8nbn_+3A_chk">chk</code></td>
<td>
<p>Check of the consistency of 'nbn' be performed before printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing but but <code>nbn</code> is printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8nbn(rbmn0nbn.01);
 print8nbn(rbmn0nbn.03, "pm", order=1:2)
</code></pre>

<hr>
<h2 id='provided+20objects'>Some examplifying structures</h2><span id='topic+provided+20objects'></span><span id='topic+rbmn0chain.01'></span><span id='topic+rbmn0chain.02'></span><span id='topic+rbmn0chain.03'></span><span id='topic+rbmn0nbn.01'></span><span id='topic+rbmn0nbn.02'></span><span id='topic+rbmn0nbn.03'></span><span id='topic+rbmn0nbn.04'></span><span id='topic+rbmn0nbn.05'></span><span id='topic+rbmn0adja.01'></span><span id='topic+rbmn0adja.02'></span><span id='topic+rbmn0adja.03'></span><span id='topic+rbmn0adja.04'></span><span id='topic+rbmn0adja.05'></span><span id='topic+rbmn0mn.01'></span><span id='topic+rbmn0mn.02'></span><span id='topic+rbmn0mn.03'></span><span id='topic+rbmn0mn.04'></span><span id='topic+rbmn0mn.05'></span><span id='topic+rbmn0gema.01'></span><span id='topic+rbmn0gema.02'></span><span id='topic+rbmn0gema.03'></span><span id='topic+rbmn0gema.04'></span><span id='topic+rbmn0gema.05'></span><span id='topic+rbmn0crarc.05'></span>

<h3>Description</h3>

<p>Small examples of adjacency matrices, /nbn/, /chain/, /gema/ and /mn/ objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>       rbmn0chain.01
       rbmn0chain.02
       rbmn0chain.03
       rbmn0nbn.01
       rbmn0nbn.02
       rbmn0nbn.03
       rbmn0nbn.04
       rbmn0adja.01
       rbmn0adja.02
       rbmn0adja.03
       rbmn0adja.04
       rbmn0mn.01
       rbmn0mn.02
       rbmn0mn.03
       rbmn0mn.04
       rbmn0gema.01
       rbmn0gema.02
       rbmn0gema.03
       rbmn0gema.04
</code></pre>


<h3>Details</h3>


<ul>
<li> <p><code>rbmn0chain.#</code> objects are chain /nbn/ objects
</p>
</li>
<li> <p><code>rbmn0nbn.#</code> objects are general /nbn/ objects
</p>
</li>
<li> <p><code>rbmn0adja.#</code> objects are adjacency matrices
</p>
</li>
<li> <p><code>rbmn0mn.#</code> objects are /mn/ distributions
</p>
</li>
<li> <p><code>rbmn0gema.#</code> objects are /gema/ generating matrices
</p>
</li></ul>

<p>Every last numbers (#) refer to the same Gaussian Bayesian networks.
</p>


<h3>Author(s)</h3>

<p> Jean-Baptiste Denis </p>

<hr>
<h2 id='reverse8chain'>
reverses the nodes of a chain
</h2><span id='topic+reverse8chain'></span>

<h3>Description</h3>

<p>returns the chain obtained after reversing its node order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse8chain(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse8chain_+3A_chain">chain</code></td>
<td>
<p> The chain object to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting chain
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print8chain(rbmn0chain.02);
 print8chain(reverse8chain(rbmn0chain.02));
</code></pre>

<hr>
<h2 id='rm8nd4adja'>
removes somes nodes from an adjacency matrix
</h2><span id='topic+rm8nd4adja'></span>

<h3>Description</h3>

<p>Eliminates from the adjacency matrix (<code>adja</code>)all <code>nodes</code>
not breaking the existing links.<br /> Important: the node order in
<code>adja</code> must be topological.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm8nd4adja(adja, nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm8nd4adja_+3A_adja">adja</code></td>
<td>
<p>The relation matrix to be consider (same format as those
provided by the function <code>adja4nbn</code>. Must be in topological
order, roots first.</p>
</td></tr>
<tr><td><code id="rm8nd4adja_+3A_nodes">nodes</code></td>
<td>
<p>Numeric or character vector providing the node numbers
to use for the generation of the subset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a node is removed, all its parents become parent of its
children.
</p>


<h3>Value</h3>

<p>The reduced adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> rm8nd4adja(rbmn0adja.04, "1.1");
</code></pre>

<hr>
<h2 id='rm8nd4nbn'>
removes some nodes from a /nbn/
</h2><span id='topic+rm8nd4nbn'></span>

<h3>Description</h3>

<p>returns a /nbn/ object deduced from an original /nbn/ by integrating
on a given subset of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm8nd4nbn(nbn, nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm8nd4nbn_+3A_nbn">nbn</code></td>
<td>
<p> The <code>nbn</code> object to reduce.</p>
</td></tr>
<tr><td><code id="rm8nd4nbn_+3A_nodes">nodes</code></td>
<td>
<p><code>character</code> or <code>numeric</code> vector giving the
subset of nodes to remove.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation is made through the associated joint distributions
for the probabilities and with the help of the function
<code>rm8nd4adja</code> for the relationships.
</p>


<h3>Value</h3>

<p>The resulting <code>nbn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> rm8nd4nbn(rbmn0nbn.04, "1.1"); 
</code></pre>

<hr>
<h2 id='rmatrix4nbn'>
regression matrix of a /nbn/
</h2><span id='topic+rmatrix4nbn'></span>

<h3>Description</h3>

<p>returns a dimnamed matrix indicating with <code>rho</code> an arc from row
to column nodes (0 everywhere else) where <code>rho</code> is the
regression coefficient. Also conditional standard deviations can be
introduced as diagonal elements but <code>mu</code> coefficient are lost...
It is advisable to normalize the /nbn/ first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrix4nbn(nbn, stdev=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrix4nbn_+3A_nbn">nbn</code></td>
<td>
<p> The initial <code>nbn</code> object.</p>
</td></tr>
<tr><td><code id="rmatrix4nbn_+3A_stdev">stdev</code></td>
<td>
<p>Indicates if the standard deviations must placed in the
diagonal positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dimnamed matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'> rmatrix4nbn(rbmn0nbn.02);
 (rmatrix4nbn(rbmn0nbn.02, FALSE)&gt;0)*1;
</code></pre>

<hr>
<h2 id='simulate8gema'>
simulates from a /gema/ object
</h2><span id='topic+simulate8gema'></span>

<h3>Description</h3>

<p>returns a matrix of simulated values with the variable in columns and
the simulations in rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate8gema(gema, nbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate8gema_+3A_gema">gema</code></td>
<td>
<p> The <code>gema</code> object.</p>
</td></tr>
<tr><td><code id="simulate8gema_+3A_nbs">nbs</code></td>
<td>
<p> number of simulations to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just the application of the standard formula to a white noise.
Variables names are taken from those of <code>gema$mu</code>, when these
does not exist, standard ones are provided.
</p>


<h3>Value</h3>

<p>A matrix of size : <code>nbs x length(gema$mu)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> simulate8gema(rbmn0gema.01, 10);
</code></pre>

<hr>
<h2 id='simulate8gmn'>
simulates a multinormal vector with varying expectation
</h2><span id='topic+simulate8gmn'></span>

<h3>Description</h3>

<p>returns a matrix of simulated values with the variable in columns and
the simulations in rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate8gmn(loi, cova, nbs, tol=1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate8gmn_+3A_loi">loi</code></td>
<td>
<p> list defining the distribution of the initial vector with
<code>$mu</code>, its expectation, <code>$gamma</code>, its variance matrix and
<code>$rho</code> a matrix of regression coefficients for the covariables
modifying the expectation.</p>
</td></tr>
<tr><td><code id="simulate8gmn_+3A_cova">cova</code></td>
<td>
<p> Values to give to the covariables. Must be a matrix with
<code>nbs</code> rows and <code>ncol(loi$rho)</code> columns or a vector with
<code>ncol(loi$rho)</code> values to be used for all simulations (i.e to
replace a matrix with identical rows..</p>
</td></tr>
<tr><td><code id="simulate8gmn_+3A_nbs">nbs</code></td>
<td>
<p> number of simulations to return.</p>
</td></tr>
<tr><td><code id="simulate8gmn_+3A_tol">tol</code></td>
<td>
<p> tolerance value to be transmitted to <code>mvrnorm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just a call to the function <code>simulate8mn</code>, adding the terms to
the expectation due to the regression...
</p>


<h3>Value</h3>

<p>A matrix of size : <code>nbs x length(loi$mu)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> loi &lt;- list(mu=c(D=2, E=4), 
 rho=matrix(1:6, 2, dimnames=list(LETTERS[4:5], 
 LETTERS[1:3])), 
 gamma=matrix(c(1, 1, 1, 2), 2));
 cova &lt;- matrix(runif(36), 12, dimnames=list(NULL, LETTERS[1:3]));
 print(simulate8gmn(loi, cova, 12));
</code></pre>

<hr>
<h2 id='simulate8mn'>
simulates a multinormal vector
</h2><span id='topic+simulate8mn'></span>

<h3>Description</h3>

<p>returns a matrix of simulated values with the variable in columns and
the simulations in rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate8mn(mn, nbs, tol=1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate8mn_+3A_mn">mn</code></td>
<td>
<p> list defining the distribution of the initial vector with
<code>$mu</code>, its expectation, and <code>$gamma</code>, its variance matrix.</p>
</td></tr>
<tr><td><code id="simulate8mn_+3A_nbs">nbs</code></td>
<td>
<p> number of simulations to return.</p>
</td></tr>
<tr><td><code id="simulate8mn_+3A_tol">tol</code></td>
<td>
<p> tolerance value to be transmitted to <code>mvrnorm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just a call to the basic function <code>mvrnorm</code>. Names of the
variables are taken from those of <code>mn$mu</code>, when these does not
exist, standard ones are provided.
</p>


<h3>Value</h3>

<p>A matrix/data frame of size : <code>nbs x length(mn$mu)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print(simulate8mn(rbmn0mn.01, 12));
</code></pre>

<hr>
<h2 id='simulate8nbn'>
simulates from a /nbn/ object
</h2><span id='topic+simulate8nbn'></span>

<h3>Description</h3>

<p>returns a matrix of simulated values with the variable in columns and
the simulations in rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate8nbn(nbn, nbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate8nbn_+3A_nbn">nbn</code></td>
<td>
<p> The <code>nbn</code> object.</p>
</td></tr>
<tr><td><code id="simulate8nbn_+3A_nbs">nbs</code></td>
<td>
<p> number of simulations to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just the sequential simulations of the nodes
</p>


<h3>Value</h3>

<p>A matrix of size : <code>nbs x length(nbn)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> simulate8nbn(rbmn0nbn.01, 10);
</code></pre>

<hr>
<h2 id='state4chain'>
returns the states of each node of a chain
</h2><span id='topic+state4chain'></span>

<h3>Description</h3>

<p>From a <code>chain</code> object returns a named character precising the
role of each node: &quot;r&quot; for root, &quot;c&quot; for collider, &quot;t&quot; for
transmitter and &quot;l&quot; for leaf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state4chain(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state4chain_+3A_chain">chain</code></td>
<td>
<p> the <code>chain</code> object to be considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character of the states named with node names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> state4chain(rbmn0chain.01);
 state4chain(rbmn0chain.03);
</code></pre>

<hr>
<h2 id='string7dag4nbn'>
provides so-called string model of a /nbn/
</h2><span id='topic+string7dag4nbn'></span>

<h3>Description</h3>

<p>returns a <code>character(1)</code> describing the dag of the nbn under the
string form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string7dag4nbn(nbn, sep=";")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string7dag4nbn_+3A_nbn">nbn</code></td>
<td>
<p> The nbn.</p>
</td></tr>
<tr><td><code id="string7dag4nbn_+3A_sep">sep</code></td>
<td>
<p>Separation sign between parents after the conditioning
sign (<code>|</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character(1)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> string7dag4nbn(rbmn0nbn.01);
 string7dag4nbn(rbmn0nbn.04, sep=", ");
</code></pre>

<hr>
<h2 id='var2pre'>
returns the precision matrix from the variance
</h2><span id='topic+var2pre'></span>

<h3>Description</h3>

<p>returns the precision matrix from the variance preserving possible
variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var2pre(ma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var2pre_+3A_ma">ma</code></td>
<td>
<p> The variance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non full rank matrices are accepted, a generalized inverse is
returned and a warning is issued.
</p>


<h3>Value</h3>

<p>The precision matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'> var2pre(rbmn0mn.04$gamma);
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
