<!DOCTYPE html><html><head><title>Help for package sim2Dpredictr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sim2Dpredictr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beta_builder'><p>Create a Parameter Vector from Lattice Locations</p></a></li>
<li><a href='#chol_s2Dp'><p>Build and Take the Cholesky Decomposition of a Covariance Matrix</p></a></li>
<li><a href='#classify_multiclass'><p>Classify subjects based on predicted probabilities for each class</p></a></li>
<li><a href='#corr_fun'><p>Specify the Correlation Function between Two Locations</p></a></li>
<li><a href='#correlation_builder'><p>Build a Correlation Matrix for 2D Spatial Data</p></a></li>
<li><a href='#generate_grid'><p>Convert a 2D Space to Grid Coordinates</p></a></li>
<li><a href='#generate_multinom_probs'><p>Generate Probabilities for Multinomial Draws</p></a></li>
<li><a href='#inf_2D_image'><p>Display Inference Results for 2D Predictors</p></a></li>
<li><a href='#make_rejection'><p>Determine rejections</p></a></li>
<li><a href='#neighbors_by_dist'><p>Determine and store neighbors by Euclidean Distance Constraints</p></a></li>
<li><a href='#precision_builder'><p>Construct a Precision Matrix</p></a></li>
<li><a href='#proximity_builder'><p>Generate a Proximity Matrix</p></a></li>
<li><a href='#sample_FP_Power'><p>Obtain Sample False Positive Rates and Power</p></a></li>
<li><a href='#sim_MVN_X'><p>Simulate Spatially Correlated MVN Data</p></a></li>
<li><a href='#sim_Y_Binary_X'><p>Simulate Scalar Outcomes from Simulated Spatially Dependent Binary Predictors</p></a></li>
<li><a href='#sim_Y_MVN_X'><p>Simulate Scalar Outcomes from Simulated Spatially Correlated Predictors</p></a></li>
<li><a href='#sim2D_binarymap'><p>Generate a Binary Map via the Boolean Method</p></a></li>
<li><a href='#sim2D_RandSet_HPPP'><p>Generate a Random Set Using a Poisson Process and Random Radii About Events</p></a></li>
<li><a href='#within_area'><p>Determine Whether Lattice Points are Within or Without a Random Set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulate Outcomes Using Spatially Dependent Design Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for simulating spatially dependent predictors (continuous or binary),
    which are used to generate scalar outcomes in a (generalized) linear model framework. Continuous
    predictors are generated using traditional multivariate normal distributions or Gauss Markov random
    fields with several correlation function approaches (e.g., see Rue (2001) &lt;<a href="https://doi.org/10.1111%2F1467-9868.00288">doi:10.1111/1467-9868.00288</a>&gt;
    and Furrer and Sain (2010) &lt;<a href="https://doi.org/10.18637%2Fjss.v036.i10">doi:10.18637/jss.v036.i10</a>&gt;), while binary predictors are generated using
    a Boolean model (see Cressie and Wikle (2011, ISBN: 978-0-471-69274-4)). Parameter vectors 
	exhibiting spatial clustering can also be easily specified by the user.  </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Rdpack, spam (&ge; 2.2-0), tibble, dplyr, matrixcalc</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, V8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmleach-bst/sim2Dpredictr">https://github.com/jmleach-bst/sim2Dpredictr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmleach-bst/sim2Dpredictr">https://github.com/jmleach-bst/sim2Dpredictr</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-03 12:36:37 UTC; cotto</td>
</tr>
<tr>
<td>Author:</td>
<td>Justin Leach [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Justin Leach &lt;jleach@uab.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-03 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='beta_builder'>Create a Parameter Vector from Lattice Locations</h2><span id='topic+beta_builder'></span>

<h3>Description</h3>

<p>Specify the locations in the lattice/image that have non-zero parameters
as well as the values for those parameters, and the function creates
the parameter vector that matches the correct locations in the design 
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_builder(
  row.index,
  col.index,
  im.res,
  B0 = 0,
  B.values,
  index.type = "manual",
  decay.fn = "gaussian",
  phi = 0.5,
  max.d = Inf,
  h,
  w,
  bayesian = FALSE,
  bayesian.dist = NULL,
  bayesian.scale = NULL,
  output.indices = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_builder_+3A_row.index">row.index</code>, <code id="beta_builder_+3A_col.index">col.index</code></td>
<td>
<p>Vectors of row/columns indices for non-zero 
parameters.
If <code>index.type = "manual"</code>, each vector should contain specific
coordinates.
If <code>index.type = "rectangle"</code>, each vector should specify rectangle 
length; e.g. row.index = 1:3 means the rectangle's 'length' is from rows
1 to 3.
If <code>index.type = "ellipse"</code>, the arguments should be scalar values
specifying the row/column coordinates for the center of the ellipse.
If <code>index.type = "decay"</code>, the arguments should specify the row/column coordinates,
respectively, of the peak parameter value.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_im.res">im.res</code></td>
<td>
<p>A vector specifying the dimension/resolution of the image. 
The first entry is the number of 'rows' in the lattice/image, and the
second entry is the number of 'columns' in the lattice/image.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_b0">B0</code></td>
<td>
<p>is the &quot;true&quot; intercept value; default is 0.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_b.values">B.values</code></td>
<td>
<p>is a vector &quot;true&quot; parameter values for non-zero parameters.
The order of assignment is by row. If B.values argument is a single value,
then all non-zero parameters are assigned to that value, unless 
<code>decay.fn</code> has been specified, in which case <code>B.values</code> is the 
&quot;peak&quot;, and non-zero parameters decay smoothly by distance.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_index.type">index.type</code></td>
<td>
<p>is one of index.type = c(&quot;manual&quot;, &quot;rectangle&quot;, &quot;ellipse&quot;, &quot;decay&quot;)
</p>

<ul>
<li> <p><code>index.type = "manual"</code> uses row.index and col.index 
arguments to specify manually selected non-zero locations. This 
setting is good for irregular shaped regions.
</p>
</li>
<li> <p><code>index.type = "rectangle"</code> uses row.index and col.index 
arguments to specify a rectangular region of non-zero parameters.
</p>
</li>
<li> <p><code>index.type = "ellipse"</code> uses <code>w</code> and <code>h</code> 
arguments to specify elliptical region of non-zero parameters.
</p>
</li>
<li> <p><code>index.type = "decay"</code> allows the user to specify a peak
location with <code>row.index</code> and <code>col.index</code>, as with 
<code>index.type = "ellipse"</code>. However, the non-zero parameter values
decay as a function of distance from the peak.
</p>
</li></ul>
</td></tr>
<tr><td><code id="beta_builder_+3A_decay.fn">decay.fn</code></td>
<td>
<p>An argument to specify the decay function of non-zero 
parameters decay from the peak when <code>index.type = "decay"</code>. Options 
are &quot;exponential&quot; or &quot;gaussian&quot;. The rate of decay is given by 
<code class="reqn">B.values * exp(-phi * d)</code> and <code class="reqn">B.values * exp(-phi * d ^ 2)</code> for
&quot;exponential&quot; and &quot;gaussian&quot;, respectively. The default is 
<code>decay.fn = "gaussian"</code>. Note that <code class="reqn">d</code> is the Euclidean distance
between the peak and a specified location, while <code class="reqn">phi</code> is the rate of 
decay and is set by the user with <code>phi</code>.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_phi">phi</code></td>
<td>
<p>A scalar value greater than 0 that determines the decay rate of
non-zero parameters when <code>index.type = "decay"</code>. The default is 
<code>phi = 0.5</code>.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_max.d">max.d</code></td>
<td>
<p>When <code>index.type = "decay"</code>, <code>max.d</code> determines the
maximum Euclidean distance from the peak that is allowed to be non-zero; 
parameters for locations further than <code>max.d</code> from the peak are set 
to zero. If this argument is not set by the user then all parameter values 
are determined by the decay function.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_w">w</code>, <code id="beta_builder_+3A_h">h</code></td>
<td>
<p>If index.type = &quot;ellipse&quot; then the width and height of the 
ellipse, respectively.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_bayesian">bayesian</code></td>
<td>
<p>If <code>TRUE</code>, then parameters are drawn from distributions
based on initial
<code>B.values</code> vector. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_bayesian.dist">bayesian.dist</code></td>
<td>
<p>When <code>bayesian = TRUE</code>, specifies the distribution
of the parameters. Options are <code>"gaussian"</code> and <code>uniform</code>.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_bayesian.scale">bayesian.scale</code></td>
<td>
<p>A list. When <code>bayesian = TRUE</code> and 
<code>bayesian.dist = "gaussian"</code>, specifies the sd for the distributions 
of parameters. When <code>bayesian = TRUE</code> and 
<code>bayesian.dist = "uniform"</code>, specifies the width for the uniform 
distributions for the parameters. The first entry should be one of 
<code>"unique", "binary"</code>. If  <code>"unique"</code>, then the second entry in 
the list should be a vector with length equal to <code>B.values + 1</code> with 
unique values for the sd's/widths, including B0. B0 can be set to a constant
value by setting the first position of <code>bayesian.scale[[2]]</code> to 0. 
If <code>"binary"</code>, then the second entry in the list should be a 3-element
vector whose first entry is the sd/width of B0, second entry the sd/width 
of &quot;non-zero&quot; or &quot;important&quot; parameters, and the third entry is the 
sd/width of the &quot;zero&quot; or  &quot;irrelevant&quot;  parameters.</p>
</td></tr>
<tr><td><code id="beta_builder_+3A_output.indices">output.indices</code></td>
<td>
<p>If <code>output.indices = TRUE</code>, then the first 
element of the returned list contains the indices for the non-zero parameter
locations (Default). If <code>output.indices = FALSE</code>, then only the 
parameter vector is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-element list containing (1) indices for the locations of &quot;true&quot;
non-zero parameters, and (2) a parameter vector.
</p>


<h3>Note</h3>

<p>The order of the parameters is by row. That is, if the lattice/image
is 4x4, then parameters 1-4 make up the first row, 5-8 then second, and so
forth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example
Bex1 &lt;- beta_builder(row.index = c(5, 5, 6, 6),
                    col.index = c(5, 6, 5, 6),
                    im.res = c(10, 10),
                    B0 = 0, B.values = rep(1, 4))

## True non-zero parameters are locations 45, 46, 55, 56 in B
## i.e. locations (5, 5), (5, 6), (6, 5), (6, 6)

## Suppose that we index rows by i = 1, ... , I
##                       cols by j = 1, ... , J

## The index for a parameter is given by  J * (i - 1) + j
## In this example, I = 10, J = 10; Thus:

## (5, 5) -&gt; 10 * (5 - 1) + 5 = 45
## (5, 6) -&gt; 10 * (5 - 1) + 6 = 46
## (6, 5) -&gt; 10 * (6 - 1) + 5 = 55
## (6, 6) -&gt; 10 * (6 - 1) + 6 = 45
Bex1
## length 101 (includes B0 w/ 100 variable parameter values)
length(Bex1$B)

## example: index.type = "rectangle"
Bex2 &lt;- beta_builder(row.index = 12:15, col.index = 6:19,
                    im.res = c(20, 20), B0 = 16,
                    B.values = 1:(length(12:15) * length(6:19)),
                    index.type = "rectangle")

Bex2
matrix(Bex2$B[-1], nrow = 20, byrow = TRUE)

## example: index.type = "ellipse"
Bex3 &lt;- beta_builder(row.index = 4, col.index = 5,
                    im.res = c(10, 10),
                    B0 = 16, B.values = 3,
                    index.type = "ellipse",
                    h = 5, w = 4)
Bex3
matrix(Bex3$B[-1], nrow = 10, byrow = TRUE)

## decaying parameter values
Bex4 &lt;- beta_builder(row.index = 10, col.index = 20,
                     im.res = c(30, 30), B0 = 0, B.values = 10,
                     index.type = "decay", max.d = 7,
                     output.indices = FALSE)
inf_2D_image(B = Bex4, im.res = c(30, 30), binarize.B = FALSE)

Bex5 &lt;- beta_builder(row.index = 4, col.index = 5,
                     im.res = c(10, 10),
                     B0 = 16, B.values = 5,
                     index.type = "ellipse",
                     h = 5, w = 4,
                     bayesian = TRUE,
                     bayesian.dist = "gaussian",
                     bayesian.scale = list("binary", c(0, 1, 0.25)))

inf_2D_image(B = Bex5$B, im.res = c(10, 10), binarize.B = FALSE)

</code></pre>

<hr>
<h2 id='chol_s2Dp'>Build and Take the Cholesky Decomposition of a Covariance Matrix</h2><span id='topic+chol_s2Dp'></span>

<h3>Description</h3>

<p>The function first builds a correlation matrix with correlation.builder, 
converts that matrix to a covariance matrix if necessary, and then takes 
the Cholesky decomposition of the matrix using either base R or the R 
package <code>spam</code>. Note that <code>spam</code> is particularly effective when
the matrix is sparse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol_s2Dp(
  matrix.type = "cov",
  im.res,
  use.spam = FALSE,
  corr.structure = "ar1",
  rho = NULL,
  phi = NULL,
  tau = 1,
  alpha = 0.75,
  corr.min = NULL,
  neighborhood = "none",
  w = NULL,
  h = NULL,
  r = NULL,
  print.R = FALSE,
  print.S = FALSE,
  print.Q = FALSE,
  sigma = 1,
  triangle = "upper",
  print.all = FALSE,
  round.d = FALSE,
  return.cov = TRUE,
  return.prec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol_s2Dp_+3A_matrix.type">matrix.type</code></td>
<td>
<p>Determines whether to build a covariance matrix, 
<code>"cov"</code>, or a precision matrix, <code>"prec"</code>. See 
<code><a href="#topic+correlation_builder">correlation_builder</a>{sim2Dpredictr}</code> and
<code><a href="#topic+precision_builder">precision_builder</a>{sim2Dpredictr}</code> for more details.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_im.res">im.res</code></td>
<td>
<p>A vector defining the dimension of spatial data. The first 
entry is the number of rows and the second  entry is the number of columns.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_use.spam">use.spam</code></td>
<td>
<p>If <code>use.spam = TRUE</code> then use tools from the R package
<code>spam</code>; otherwise, base R functions are employed. For large dimension
MVN with sparse correlation structure, <code>spam</code> is recommended; 
otherwise, base R may be faster. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_corr.structure">corr.structure</code></td>
<td>
<p>One of <code>"ar1"</code>, <code>exponential</code>, 
<code>gaussian</code>, or <code>"CS"</code>. Correlations between locations i and j 
are <code>rho</code><code class="reqn">^{d}</code> for <code>corr.structure = "ar1"</code>, 
<code class="reqn">exp(-phi * d)</code> for <code>corr.structure = "exponential"</code>,
<code class="reqn">exp(-phi * d ^ 2)</code> for <code>corr.structure = "gaussian"</code>, and 
<code>rho</code> when <code>corr.structure = "CS"</code>. Note that <code>d</code> is the
Euclidean distance between locations i and j.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_rho">rho</code></td>
<td>
<p>This is the maximum possible correlation between locations i 
and j. For all i,j <code>rho</code> MUST be between -1 and 1.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_phi">phi</code></td>
<td>
<p>A scalar value greater than 0 that determines the decay rate of
correlation. This argument is only utilized when <code>corr.structure 
%in% c("exponential", "gaussian")</code>.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_tau">tau</code></td>
<td>
<p>A vector containing precision parameters. If of length 1, then 
all precisions are assumed equal. Otherwise the length of <code>tau</code> should 
equal the number of variables.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_alpha">alpha</code></td>
<td>
<p>A scalar value between 0 and 1 that defines the strength of 
correlations. Note that when <code>alpha = 0</code> the data are independent and
when <code>alpha = 1</code>, the joint distribution is the improper Intrinsic 
Autoregression (IAR), which cannot be used to generate data. Note also that
while <code>alpha</code> does control dependence it is not interpretable as a 
correlation.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_corr.min">corr.min</code></td>
<td>
<p>Scalar value to specify the minimum non-zero correlation. 
Any correlations below <code>corr.min</code> are set to 0. Especially for high 
image resolution using this option can result in a sparser covariance 
matrix, which may significantly speed up draws when using <code>spam</code>. 
This option is preferred to using <code>neighborhood</code> and associated 
arguments when the primary concern is to avoid very small correlations 
and improve computation efficiency. Default is <code>NULL</code>, which places
no restrictions on the correlations.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Defines the neighborhood within which marginal 
correlations are non-zero. The default is <code>"none"</code>, which allows 
marginal correlations to extend indefinitely. <code>neighborhood = "round"</code>
defines a circular neighborhood about locations and 
<code>neighborhood = "rectangle"</code> defines a rectangular neighborhood about
locations. Note that this argument differs from that in 
<code><a href="#topic+precision_builder">precision_builder</a></code>, in which <code>neighborhood</code> defines conditional non-zero
correlations.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_w">w</code>, <code id="chol_s2Dp_+3A_h">h</code></td>
<td>
<p>If <code>neighborhood = "rectangle"</code> then w and h are the number
of locations to the left/right and above/below a location i that define 
its neighborhood. Any locations outside this neighborhood have have zero 
correlation with location i.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_r">r</code></td>
<td>
<p>If <code>neighborhood = "round"</code>, then if locations i,j are 
separated by distance <code class="reqn">d \ge r</code>, the correlation between them is zero.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_print.r">print.R</code>, <code id="chol_s2Dp_+3A_print.s">print.S</code>, <code id="chol_s2Dp_+3A_print.q">print.Q</code></td>
<td>
<p>Logical. When <code>TRUE</code>, then print the 
correlation, covariance, or precision matrix before taking the Cholesky 
decomposition. If <code>sigma</code> = 1, then S = R.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_sigma">sigma</code></td>
<td>
<p>Specify the desired standard deviations; the default is 1, in
which case the Cholesky decomposition is of a correlation matrix. If 
<code>sigma</code> != 1, then the Cholesky decomposition is of a covariance 
Matrix.
</p>

<ul>
<li><p> If sigma is a vector then length(sigma) must be equal to the
total number of locations, i.e. <code class="reqn">(n.row * n.col) by (n.row * n.col)</code>.
</p>
</li>
<li><p> sigma can take any scalar value when specifying common standard
deviation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_triangle">triangle</code></td>
<td>
<p>Determine whether to output an upper 
(<code>triangle = "upper"</code>) or lower (<code>triangle = "lower"</code>) triangular
matrix.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_print.all">print.all</code></td>
<td>
<p>If <code>print.all = TRUE</code>, then prints each correlation 
and allows you to check whether the correlations are as you intended. This
option is NOT recommended for large point lattices/images.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_round.d">round.d</code></td>
<td>
<p>If <code>round.d = TRUE</code>, then d is rounded to the nearest 
whole number.</p>
</td></tr>
<tr><td><code id="chol_s2Dp_+3A_return.cov">return.cov</code>, <code id="chol_s2Dp_+3A_return.prec">return.prec</code></td>
<td>
<p>Logical. When <code>TRUE</code>, also return the 
covariance or precision matrix, respectively. This is recommended when 
using <code>spam</code> to generate draws from the MVN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of dimension (n.row x n.col) x (n.row x n.col). If either 
<code>return.cov</code> or <code>return.prec</code> is <code>TRUE</code>, then returns a 
list where the first element is the covariance or precision matrix, and the
second element is the Cholesky factor.
</p>


<h3>References</h3>

<p>Banerjee S, Carlin BP, Gelfand AE (2015).
<em>Hierarchical Modeling and Analysis for Spatial Data</em>, Second edition.
Chapman &amp; Hall/CRC, Boca Raton, Florida.
</p>
<p>Ripley BD (1987).
<em>Stochastic Simulation</em>.
John Wiley &amp; Sons.
<a href="https://doi.org/10.1002/9780470316726">doi:10.1002/9780470316726</a>.
</p>
<p>Rue H (2001).
&ldquo;Fast Sampling of Gaussian Markov Random Fields.&rdquo;
<em>Journal of the Royal Statistical Society B</em>, <b>63</b>, 325-338.
<a href="https://doi.org/10.1111/1467-9868.00288">doi:10.1111/1467-9868.00288</a>.
</p>
<p>Furrer R, Sain SR (2010).
&ldquo;spam: A Sparse Matrix R Package with Emphasis on MCMC Methods for Gaussian Markov Random Fields.&rdquo;
<em>Journal of Statistical Software</em>, <b>36</b>(10), 1-25.
<a href="https://www.jstatsoft.org/v36/i10/">https://www.jstatsoft.org/v36/i10/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use R package spam for Cholesky decomposition
R_spam &lt;- chol_s2Dp(im.res = c(3, 3), matrix.type = "prec",
                    use.spam = TRUE, neighborhood = "ar1",
                    triangle = "upper")

## Use base R for Cholesky decomposition
R_base &lt;- chol_s2Dp(corr.structure = "ar1", 
                    im.res = c(3, 3), rho = 0.15,
                    neighborhood = "round", 
                    r = 3, use.spam = FALSE)

## Specify standard deviations instead of default of sigma = 1.
R_sd &lt;- chol_s2Dp(corr.structure = "ar1",
                  im.res = c(3, 3), rho = 0.15,
                  neighborhood = "round", r = 3, 
                  sigma = runif(9, 1.1, 4))
## Not run: 
## Print options ON
R_pr_on &lt;- chol_s2Dp(corr.structure = "ar1", 
                     im.res = c(3, 3), rho = 0.15,
                     sigma = 1:9, neighborhood = "round", 
                     r = 3, print.R = TRUE, print.S = TRUE)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='classify_multiclass'>Classify subjects based on predicted probabilities for each class</h2><span id='topic+classify_multiclass'></span>

<h3>Description</h3>

<p>Classify subjects based on predicted probabilities for each class. The 
predicted probabilities can be input by the user or calculated within 
function using parameter estimates and design matrix for a multinomial
regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_multiclass(
  predicted.probs = NULL,
  category.names,
  keep.probs = TRUE,
  B = NULL,
  X = NULL,
  X.incl.X0 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_multiclass_+3A_predicted.probs">predicted.probs</code></td>
<td>
<p>A matrix where the number of rows is equal to the 
number of subjects and the number of columns equals the number of 
categories. <code>predicted.probs[i, j]</code> contains the probability that
subject <code>i</code> belongs to category <code>j</code>.</p>
</td></tr>
<tr><td><code id="classify_multiclass_+3A_category.names">category.names</code></td>
<td>
<p>A vector containing the names of each category. The 
order of names should match the order of columns in <code>predicted.probs</code>;
correspondingly, the length of the vector should equal the number of columns
in <code>predicted.probs</code>.</p>
</td></tr>
<tr><td><code id="classify_multiclass_+3A_keep.probs">keep.probs</code></td>
<td>
<p>Logical. When <code>TRUE</code>, the output is data frame 
consisting of the information in <code>predicted.probs</code> with an additional
column <code>predicted.class</code> that contains the predicted class for each
subject. When <code>FALSE</code>, a vector of the predicted classes is returned.</p>
</td></tr>
<tr><td><code id="classify_multiclass_+3A_b">B</code></td>
<td>
<p>A list, each element of which contains a parameter vector. The 
list should have length <code>V - 1</code>, i.e., should contain parameter values
associated with all categories except the reference category, following 
Agresti (2007). Alternatively, <code>B</code> may be a list of length <code>V</code> 
if one desires to specify parameters for every category, i.e., the
over-parameterized model used in Friedman (2010).</p>
</td></tr>
<tr><td><code id="classify_multiclass_+3A_x">X</code></td>
<td>
<p>A matrix, each row of which contains subject covariate/predictor 
values.</p>
</td></tr>
<tr><td><code id="classify_multiclass_+3A_x.incl.x0">X.incl.X0</code></td>
<td>
<p>Logical. When <code>TRUE</code>, <code>X</code> should contain column
of 1's for the intercept. Otherwise, a column of 1's is generated 
internally. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classification for each subject is determined based on the category
with highest predicted probability.
</p>


<h3>Value</h3>

<p>Depending on the option selected for <code>keep.probs</code>, returns a 
data frame or vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## number of categories
vt &lt;- 3

## covariate values
xt &lt;- matrix(rnorm(10 * 2), ncol = 2, nrow = 10)

## list of parameter vectors (over-parameterized model)
bu &lt;- list(b1 = c(0, 0.25, 0.25),
           b2 = c(0, -0.25, -0.25),
           b3 = c(0, 0.25, -0.25))

## subject specific probabilities for each category 
## (over-parameterized model)
prp &lt;- generate_multinom_probs(V = vt, X = xt, B = bu)

classify_multiclass(predicted.probs = prp, 
                    category.names = c("A", "B", "C"))

## generate predicted probabilities within function
classify_multiclass(predicted.probs = NULL, 
                    category.names = c("A", "B", "C"),
                    X = xt, B = bu)
                    
</code></pre>

<hr>
<h2 id='corr_fun'>Specify the Correlation Function between Two Locations</h2><span id='topic+corr_fun'></span>

<h3>Description</h3>

<p>This is primarily for use within correlation builder, and may be 
altered/expanded to handle more complicated correlation functions
if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_fun(
  corr.structure,
  im.res,
  corr.min = NULL,
  rho = NULL,
  phi = NULL,
  neighborhood = "none",
  round.d = FALSE,
  w = NULL,
  h = NULL,
  r = NULL,
  i,
  j,
  k,
  v
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_fun_+3A_corr.structure">corr.structure</code></td>
<td>
<p>One of <code>"ar1"</code>, <code>"exponential"</code>, 
<code>"gaussian"</code>, or <code>"CS"</code>. Correlations between locations i 
and j are <code>rho</code><code class="reqn">^{d}</code> for <code>corr.structure = "ar1"</code>, 
<code class="reqn">exp(-phi * d)</code> for <code>corr.structure = "exponential"</code>,
<code class="reqn">exp(-phi * d ^ 2)</code> for <code>corr.structure = "gaussian"</code>, and 
<code>rho</code> when <code>corr.structure = "CS"</code>. Note that <code>d</code> is the
Euclidean distance between locations i and j.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_im.res">im.res</code></td>
<td>
<p>A vector defining the dimension of spatial data. The first
entry is the number of rows and the second  entry is the number of columns.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_corr.min">corr.min</code></td>
<td>
<p>Scalar value to specify the minimum non-zero correlation. 
Any correlations below <code>corr.min</code> are set to 0. Especially for high 
image resolution using this option can result in a sparser covariance 
matrix, which may significantly speed up draws when using <code>spam</code>.
This option is preferred to using <code>neighborhood</code> and associated 
arguments when the primary concern is to avoid very small correlations 
and improve computation efficiency. Default is <code>NULL</code>, which places
no restrictions on the correlations.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_rho">rho</code></td>
<td>
<p>This is the maximum possible correlation between locations i and
j. For all i,j <code>rho</code> MUST be between -1 and 1.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_phi">phi</code></td>
<td>
<p>A scalar value greater than 0 that determines the decay of 
correlation. This argument is only utilized when <code>corr.structure 
%in% c("exponential", "gaussian")</code>.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Defines the neighborhood within which marginal 
correlations are non-zero. The default is <code>"none"</code>, which allows 
marginal correlations to extend indefinitely. <code>neighborhood = "round"</code>
defines a circular neighborhood about locations and 
<code>neighborhood = "rectangle"</code> defines a rectangular neighborhood about
locations.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_round.d">round.d</code></td>
<td>
<p>If <code>round.d = TRUE</code>, then d is rounded to the nearest
whole number.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_w">w</code>, <code id="corr_fun_+3A_h">h</code></td>
<td>
<p>If <code>neighborhood = "rectangle"</code> then w and h are the number
of locations to the left/right and above/below a location i that define its
neighborhood. Any locations outside this neighborhood have have zero 
correlation with location i.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_r">r</code></td>
<td>
<p>If <code>neighborhood = "round"</code>, then if locations i,j are 
separated by distance <code class="reqn">d \ge r</code>, the correlation between them is zero.</p>
</td></tr>
<tr><td><code id="corr_fun_+3A_i">i</code>, <code id="corr_fun_+3A_j">j</code>, <code id="corr_fun_+3A_k">k</code>, <code id="corr_fun_+3A_v">v</code></td>
<td>
<p>These are the coordinates for the two locations. Location 
1 has coordinates (i, j) and location 2 has coordinates (k, v).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single element vector containing the correlation between spatial 
locations with indices (i, j) and (k, v).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples
corr_fun(corr.structure = "ar1", im.res = c(3, 3), rho = 0.5,
         neighborhood = "round", r = 6, i = 1, j = 2, k = 2, v = 3)

corr_fun(corr.structure = "ar1", im.res = c(3, 3), rho = 0.5,
         neighborhood = "rectangle", w = 1, h = 1, 
         i = 1, j = 2, k = 2, v = 3)

</code></pre>

<hr>
<h2 id='correlation_builder'>Build a Correlation Matrix for 2D Spatial Data</h2><span id='topic+correlation_builder'></span>

<h3>Description</h3>

<p>This function &quot;builds&quot; a correlation matrix based on user specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_builder(
  corr.structure = "ar1",
  im.res,
  corr.min = NULL,
  neighborhood = "none",
  rho = NULL,
  phi = NULL,
  w = NULL,
  h = NULL,
  r = NULL,
  print.all = FALSE,
  round.d = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation_builder_+3A_corr.structure">corr.structure</code></td>
<td>
<p>One of <code>"ar1"</code>, <code>exponential</code>, 
<code>gaussian</code>, or <code>"CS"</code>. Correlations between locations i and j 
are <code>rho</code><code class="reqn">^{d}</code> for <code>corr.structure = "ar1"</code>, 
<code class="reqn">exp(-phi * d)</code> for <code>corr.structure = "exponential"</code>,
<code class="reqn">exp(-phi * d ^ 2)</code> for <code>corr.structure = "gaussian"</code>, and 
<code>rho</code> when <code>corr.structure = "CS"</code>. Note that <code>d</code> is the
Euclidean distance between locations i and j.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_im.res">im.res</code></td>
<td>
<p>A vector defining the dimension of spatial data. The first 
entry is the number of rows and the second  entry is the number of columns.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_corr.min">corr.min</code></td>
<td>
<p>Scalar value to specify the minimum non-zero correlation. 
Any correlations below <code>corr.min</code> are set to 0. Especially for high 
image resolution using this option can result in a sparser covariance 
matrix, which may significantly speed up draws when using <code>spam</code>. 
This option is preferred to using <code>neighborhood</code> and associated 
arguments when the primary concern is to avoid very small correlations 
and improve computation efficiency. Default is <code>NULL</code>, which places
no restrictions on the correlations.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Defines the neighborhood within which marginal 
correlations are non-zero. The default is <code>"none"</code>, which allows 
marginal correlations to extend indefinitely. <code>neighborhood = "round"</code>
defines a circular neighborhood about locations and 
<code>neighborhood = "rectangle"</code> defines a rectangular neighborhood about
locations. Note that this argument differs from that in 
<code><a href="#topic+precision_builder">precision_builder</a></code>, in which <code>neighborhood</code> defines conditional non-zero
correlations.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_rho">rho</code></td>
<td>
<p>This is the maximum possible correlation between locations i 
and j. For all i,j <code>rho</code> MUST be between -1 and 1.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_phi">phi</code></td>
<td>
<p>A scalar value greater than 0 that determines the decay rate of
correlation. This argument is only utilized when <code>corr.structure 
%in% c("exponential", "gaussian")</code>.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_w">w</code>, <code id="correlation_builder_+3A_h">h</code></td>
<td>
<p>If <code>neighborhood = "rectangle"</code> then w and h are the number
of locations to the left/right and above/below a location i that define 
its neighborhood. Any locations outside this neighborhood have have zero 
correlation with location i.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_r">r</code></td>
<td>
<p>If <code>neighborhood = "round"</code>, then if locations i,j are 
separated by distance <code class="reqn">d \ge r</code>, the correlation between them is zero.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_print.all">print.all</code></td>
<td>
<p>If <code>print.all = TRUE</code>, then prints each correlation 
and allows you to check whether the correlations are as you intended. This
option is NOT recommended for large point lattices/images.</p>
</td></tr>
<tr><td><code id="correlation_builder_+3A_round.d">round.d</code></td>
<td>
<p>If <code>round.d = TRUE</code>, then d is rounded to the nearest 
whole number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code class="reqn">(nr*nc) by (nr*nc)</code> correlation matrix.
</p>


<h3>Note</h3>

<p>Caution is recommended when using <code>corr.min</code> or 
<code>neighborhood</code> to set many correlations to 0, as not all 
specifications will result in a positive definite matrix. In particular, 
sharp drop-offs tend to result in non-positive definite matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples
correlation_builder(corr.structure = "ar1", im.res = c(3, 3), rho = 0.5,
                    neighborhood = "round", r = 6, print.all = TRUE)

correlation_builder(corr.structure = "exponential", im.res = c(3, 3), 
                    phi = 0.5,
                    neighborhood = "round", r = 3, print.all = TRUE)

correlation_builder(corr.structure = "CS", im.res = c(3, 3),
                    rho = 0.5, print.all = TRUE)

## no "true" zeros, but gets close
c.nr &lt;- correlation_builder(corr.structure = "ar1", neighborhood = "none",
                    corr.min = NULL, im.res = c(15, 15), rho = 0.5)
length(c.nr[c.nr &gt; 0])
min(c.nr)

## set corr.min gives many zero entries; sparser structure
c.r &lt;- correlation_builder(corr.structure = "ar1", neighborhood = "none",
                    corr.min = 0.01, im.res = c(15, 15), rho = 0.5)
## raw number &gt; 0
length(c.r[c.r &gt; 0])
## proportion &gt; 0
length(c.r[c.r &gt; 0]) / length(c.nr)
</code></pre>

<hr>
<h2 id='generate_grid'>Convert a 2D Space to Grid Coordinates</h2><span id='topic+generate_grid'></span>

<h3>Description</h3>

<p>Input the limits of a 2D space and the desired image resolution, then
the function outputs the appropriate grid/lattice coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_grid(im.res, xlim = c(0, 1), ylim = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_grid_+3A_im.res">im.res</code></td>
<td>
<p>A vector specifying the dimension/resolution of the image. The 
first entry is the number of 'rows' in the lattice/image, and the second 
entry is the number of columns' in the lattice/image.</p>
</td></tr>
<tr><td><code id="generate_grid_+3A_xlim">xlim</code>, <code id="generate_grid_+3A_ylim">ylim</code></td>
<td>
<p>These are the 2D image limits. Defaults for both are 
<code>c(0, 1)</code>. It is not recommended to alter these arguments unless 
changing the limits has a specific practical utility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame whose first column is x-coordinates and whose second 
column is y-coordinates.
</p>

<hr>
<h2 id='generate_multinom_probs'>Generate Probabilities for Multinomial Draws</h2><span id='topic+generate_multinom_probs'></span>

<h3>Description</h3>

<p>Obtain probabilities for each category of a multinomial distribution
based on covariate and parameter values based on the logit models
for the multinomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_multinom_probs(V = NULL, B = NULL, X = NULL, X.incl.X0 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_multinom_probs_+3A_v">V</code></td>
<td>
<p>A numeric value stating the number of categories desired.</p>
</td></tr>
<tr><td><code id="generate_multinom_probs_+3A_b">B</code></td>
<td>
<p>A list, each element of which contains a parameter vector. The 
list should have length <code>V - 1</code>, i.e., should contain parameter values
associated with all categories except the reference category, following 
Agresti (2007). Alternatively, <code>B</code> may be a list of length <code>V</code> 
if one desires to specify parameters for every category, i.e., the
over-parameterized model used in Friedman (2010).</p>
</td></tr>
<tr><td><code id="generate_multinom_probs_+3A_x">X</code></td>
<td>
<p>A matrix, each row of which contains subject covariate/predictor 
values.</p>
</td></tr>
<tr><td><code id="generate_multinom_probs_+3A_x.incl.x0">X.incl.X0</code></td>
<td>
<p>Logical. When <code>TRUE</code>, <code>X</code> should contain column
of 1's for the intercept. Otherwise, a column of 1's is generated 
internally. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing subject-specific probabilities for each 
category of the multinomial distribution. The number of rows equals 
<code>nrow(X)</code> and the number of columns equals <code>V</code>.
</p>


<h3>References</h3>

<p>Agresti A (2007).
<em>An Introduction to Categorical Analysis</em>, 2nd edition.
John Wiley &amp; Sons, Hoboken, New Jersey.
</p>
<p>Friedman J, Hastie T, Tibshirani R (2010).
&ldquo;Regularization paths for generalized linear models via coordinate descent.&rdquo;
<em>Journal of Statistical Software</em>, <b>33</b>, 1-22.
<a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## number of categories
vt &lt;- 3

## covariate values
xt &lt;- matrix(rnorm(10 * 2), ncol = 2, nrow = 10)

## list of parameter vectors
bt &lt;- list(b1 = c(1, 0.25, -0.25),
           b2 = c(-0.5, 0.15, 0.15))
           
## list of parameter vectors (over-parameterized model)
bu &lt;- list(b1 = c(1, 0.25, -0.25),
           b2 = c(-0.5, 0.15, 0.15),
           b3 = c(-1, 0.1, -0.20))

## subject specific probabilities for each category
generate_multinom_probs(V = vt, X = xt, B = bt)

## subject specific probabilities for each category 
## (over-parameterized model)
generate_multinom_probs(V = vt, X = xt, B = bu)

</code></pre>

<hr>
<h2 id='inf_2D_image'>Display Inference Results for 2D Predictors</h2><span id='topic+inf_2D_image'></span>

<h3>Description</h3>

<p>Provide graphics for spatial extent of predictor parameters, rejections
and/or the truth/falsity of the rejections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inf_2D_image(
  rejections = NULL,
  B = NULL,
  im.res,
  test.statistic = NULL,
  reject.threshold = NULL,
  binarize.B = TRUE,
  grid.color = "grey",
  n.colors = length(unique(B)),
  B.incl.B0 = TRUE,
  plot.title = TRUE,
  manual.title = NULL,
  title.size = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inf_2D_image_+3A_rejections">rejections</code></td>
<td>
<p>A binary vector; <code>rejection[i] = 1</code> means the null
hypothesis is rejected for parameter <code>B[i]</code>, whereas 
<code>rejection[i] = 0</code> means that the null hypothesis was not rejected
for parameter <code>B[i]</code>.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_b">B</code></td>
<td>
<p>A vector of &quot;true&quot; parameter values. For inference purposes, this
can be a vector of actual parameter values, or a binary vector indicating
non-zero status.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_im.res">im.res</code></td>
<td>
<p>A vector defining the dimension of spatial data. The first
entry is the number of rows and the second  entry is the number of columns.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_test.statistic">test.statistic</code></td>
<td>
<p>A vector of test statistics; e.g., t-statistics or
p-values that are used to determine whether or not to reject the null
hypothesis.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_reject.threshold">reject.threshold</code></td>
<td>
<p>A list whose first element is the rejection 
criteria, e.g., the minimum t-statistic or maximum p-value for which to
reject the null hypothesis. The second element is one of 
<code>c("greater", "less", "2-tailed")</code>, which tell the function to reject
when the values in <code>test.statistic</code> are greater than or less than the
threshold, the test is a 2-tailed, respectively. In the latter case the 
function internally calculates the upper or lower threshold needed for the
2-tailed test.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_binarize.b">binarize.B</code></td>
<td>
<p>Either <code>TRUE</code> (default) or <code>FALSE</code>. When
<code>binarize.B = TRUE</code> the parameter vector is converted to a binary 
vector where 1 indicates non-zero parameter and 0 indicates zero-valued 
parameter.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_grid.color">grid.color</code></td>
<td>
<p>Specify the color for the grid lines.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_n.colors">n.colors</code></td>
<td>
<p>Determines the number of colors in the printed image. 
Default is <code>length(unique(B))</code>, but it is recommended to use trial 
and error to determine the ideal setting for specific situations.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_b.incl.b0">B.incl.B0</code></td>
<td>
<p>If <code>B.incl.B0 = TRUE</code> then the first entry should be
the intercept, B0. <code>B.incl.B0 = FALSE</code> indicates that the first entry
of B is not an intercept.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_plot.title">plot.title</code></td>
<td>
<p>When <code>plot.title = TRUE</code> a title accompanies the 
output graph, and <code>plot.title = FALSE</code> suppresses the title.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_manual.title">manual.title</code></td>
<td>
<p>When <code>plot.title = TRUE</code>, use <code>manual.title</code>
to specify a title manually.</p>
</td></tr>
<tr><td><code id="inf_2D_image_+3A_title.size">title.size</code></td>
<td>
<p>Specifies the size of the title text. This is based on 
<code>cex.main</code> within the <code>image()</code> function. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image depicting the spatial extent of some image characteristic.
</p>


<h3>Note</h3>

<p>If both <code>rejections</code> and <code>B</code> are specified then the 
function provides an image with separate color each for:
</p>

<ul>
<li><p> No rejection and <code>B[i] = 0</code> (i.e. True Negative).
</p>
</li>
<li><p> No rejection and <code>B[i] != 0</code> (i.e. False Negative).
</p>
</li>
<li><p> Rejection and <code>B[i] = 0</code> (i.e. False Positive).
</p>
</li>
<li><p> Rejection and <code>B[i] != 0</code> (i.e. True Positive).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## parameter vector
Bex &lt;- beta_builder(row.index = c(rep(5, 3), rep(6, 3), rep(7, 3)),
                    col.index = rep(c(5, 6, 7), 3),
                    im.res = c(10, 10), index.type = "manual",
                    B0 = 0, B.values = 1:9,
                    output.indices = FALSE)

## co-opt beta builder to get rejections
rejex &lt;- beta_builder(row.index = c(rep(4, 3), rep(5, 3), rep(6, 3)),
                      col.index = rep(c(4, 5, 6), 3),
                      im.res = c(10, 10), index.type = "manual",
                      B0 = 0, B.values = rep(1, 9),
                      output.indices = FALSE)[-1]

rejex.sm2 &lt;- beta_builder(row.index = 5:6, col.index = 5:6,
                          im.res = c(10, 10),
                          B0 = 0, B.values = 1,
                          output.indices = FALSE)[-1]

## just B
inf_2D_image(B = Bex, im.res = c(10, 10))
## just rejections
inf_2D_image(rejections = rejex, im.res = c(10, 10))

## both B and rejections
inf_2D_image(rejections = rejex, B = Bex, im.res = c(10, 10))
inf_2D_image(rejections = rejex.sm2, B = Bex, im.res = c(10, 10))

## larger dimension example
Bex2 &lt;- beta_builder(row.index = 5:15, col.index = 16:20,
                     im.res = c(50, 50), B0 = 0,
                     B.values = 1:(length(5:15) * length(16:20)),
                     index.type = "rectangle",
                     output.indices = FALSE)
rejex2 &lt;- beta_builder(row.index = 13:21, col.index = 30:41,
                       im.res = c(50, 50), B0 = 0,
                       B.values = rep(1, (length(13:21) * length(30:41))),
                       index.type = "rectangle",
                       output.indices = FALSE)[-1]
rejex3 &lt;- beta_builder(row.index = 5:20, col.index = 16:30,
                       im.res = c(50, 50), B0 = 0,
                       B.values = rep(1, (length(5:20) * length(16:30))),
                       index.type = "rectangle",
                       output.indices = FALSE)[-1]
rejex4 &lt;- beta_builder(row.index = 5:10, col.index = 16:17,
                       im.res = c(50, 50), B0 = 0,
                       B.values = rep(1, (length(5:10) * length(16:17))),
                       index.type = "rectangle",
                       output.indices = FALSE)[-1]
## images
inf_2D_image(B = Bex2, im.res = c(50, 50))
inf_2D_image(B = Bex2, im.res = c(50, 50), binarize.B = FALSE)
inf_2D_image(rejections = rejex2, im.res = c(50, 50))

## No TP
inf_2D_image(rejections = rejex2, B = Bex2, im.res = c(50, 50))
## ALL TP
inf_2D_image(rejections = Bex2[-1], B = Bex2, im.res = c(50, 50))
## No FN
inf_2D_image(rejections = rejex3, B = Bex2, im.res = c(50, 50))
## No FP, but FN
inf_2D_image(rejections = rejex4, im.res = c(50, 50))
inf_2D_image(B = Bex2, im.res = c(50, 50))
inf_2D_image(rejections = rejex4, B = Bex2, im.res = c(50, 50))
</code></pre>

<hr>
<h2 id='make_rejection'>Determine rejections</h2><span id='topic+make_rejection'></span>

<h3>Description</h3>

<p>Determine rejections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_rejection(B, reject.threshold, test.statistic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_rejection_+3A_b">B</code></td>
<td>
<p>A vector of &quot;true&quot; parameter values. For inference purposes, this
can be a vector of actual parameter values, or a binary vector indicating
non-zero status.</p>
</td></tr>
<tr><td><code id="make_rejection_+3A_reject.threshold">reject.threshold</code></td>
<td>
<p>A list whose first element is the rejection 
criteria, e.g., the minimum t-statistic or maximum p-value for which to
reject the null hypothesis. The second element is one of 
<code>c("greater", "less", "2-tailed")</code>, which tell the function to reject
when the values in <code>test.statistic</code> are greater than or less than the
threshold, the test is a 2-tailed, respectively. In the latter case the 
function internally calculates the upper or lower threshold needed for the
2-tailed test.</p>
</td></tr>
<tr><td><code id="make_rejection_+3A_test.statistic">test.statistic</code></td>
<td>
<p>A vector of test statistics; e.g., t-statistics or
p-values that are used to determine whether or not to reject the null
hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of hypothesis testing rejection indicators, where 1 
indicates a rejection and 0 otherwise.
</p>

<hr>
<h2 id='neighbors_by_dist'>Determine and store neighbors by Euclidean Distance Constraints</h2><span id='topic+neighbors_by_dist'></span>

<h3>Description</h3>

<p>Determine and store neighbors by Euclidean Distance Constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbors_by_dist(x, y, coords, im.res, r, print.ring = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbors_by_dist_+3A_x">x</code>, <code id="neighbors_by_dist_+3A_y">y</code></td>
<td>
<p>are the row and column coordinates, respectively.</p>
</td></tr>
<tr><td><code id="neighbors_by_dist_+3A_coords">coords</code></td>
<td>
<p>A dataframe containing indices and coordinates for the image.</p>
</td></tr>
<tr><td><code id="neighbors_by_dist_+3A_im.res">im.res</code></td>
<td>
<p>A vector containing the number of rows and columns, 
respectively.</p>
</td></tr>
<tr><td><code id="neighbors_by_dist_+3A_r">r</code></td>
<td>
<p>A scalar value determining the radius within which other locations
are neighbors to the current location (x, y).</p>
</td></tr>
<tr><td><code id="neighbors_by_dist_+3A_print.ring">print.ring</code></td>
<td>
<p>When <code>print.ring = TRUE</code>, each iteration is shown,
with corresponding information regarding the number of neighbors present
in each ring. This argument primarily exists to allow the user to test
whether the neighborhood structure specified is as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble whose first column contains x indices, second column 
contains y indices, and third column denotes the current ring about a 
location.
</p>


<h3>Note</h3>

<p>This function avoids testing all points for being with a certain 
distance in order to determine neighbor status of a given point by 
progressively widening a box around the point. Each iteration widens the
box by an extra ring, and we only test points in the new ring. If at the 
end of testing a ring there are no new neighbors then we stop expanding the
box and return the neighbors' coordinates. For computational efficiency, 
this function assumes that all arguments except the current point's 
coordinates have been specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Necessary pre-specified arguments required for the function to work.

## image resoluation + number of spatial predictors
im.res &lt;- c(5, 5)
J &lt;- prod(im.res)

## create predictor indices w/ coordinates
row.id &lt;-rep(1, im.res[2])
for (i in 2:im.res[1]) {
 row.id &lt;- c(row.id, rep(i, im.res[2]))
}
coords &lt;- data.frame(index = 1:J,
                     row.id = row.id,
                     col.id = rep(c(1:im.res[2]), im.res[1]) )

neighbors_by_dist(x = 2, y = 2, im.res = im.res, coords = coords, r = 2)

</code></pre>

<hr>
<h2 id='precision_builder'>Construct a Precision Matrix</h2><span id='topic+precision_builder'></span>

<h3>Description</h3>

<p>This function constructs the precision matrix for a Conditional 
Autoregression (CAR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision_builder(
  im.res,
  tau = 1,
  alpha = 0.75,
  neighborhood = "ar1",
  weight = "binary",
  phi = 1,
  r = NULL,
  w = NULL,
  h = NULL,
  digits.Q = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision_builder_+3A_im.res">im.res</code></td>
<td>
<p>A vector defining the dimension of spatial data. The first 
entry is the number of rows and the second  entry is the number of columns.</p>
</td></tr>
<tr><td><code id="precision_builder_+3A_tau">tau</code></td>
<td>
<p>A vector containing precision parameters. If of length 1, then 
all precisions are assumed equal. Otherwise the length of <code>tau</code> should 
equal the number of variables.</p>
</td></tr>
<tr><td><code id="precision_builder_+3A_alpha">alpha</code></td>
<td>
<p>A scalar value between 0 and 1 that defines the strength of 
correlations. Note that when <code>alpha = 0</code> the data are independent and
when <code>alpha = 1</code>, the joint distribution is the improper Intrinsic 
Autoregression (IAR), which cannot be used to generate data. Note also that
while <code>alpha</code> does control dependence it is not interpretable as a 
correlation.</p>
</td></tr>
<tr><td><code id="precision_builder_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Defines the neighborhood within which conditional 
correlations are non-zero. This differs from use in 
<code><a href="#topic+correlation_builder">correlation_builder</a></code>, where the neighborhood
defines non-zero marginal correlations. The default is <code>"ar1"</code>, which
creates a neighborhood where the spatial locations directly above, below,
left, and right of a location are included in the neighborhood. More 
complicated neighborhoods can be specified by <code>neighborhood = "round"</code>,
which defines a circular neighborhood about each location, and 
<code>neighborhood = "rectangle"</code>, which defines a rectangular neighborhood
about each location.</p>
</td></tr>
<tr><td><code id="precision_builder_+3A_weight">weight</code></td>
<td>
<p>Determines how weights are assigned. <code>"distance"</code> 
assigns weights as the inverse of Euclidean distance times a constant, 
<code>phi</code>. <code>"binary"</code> assigns weights to 1 for neighbors and 0 
otherwise.</p>
</td></tr>
<tr><td><code id="precision_builder_+3A_phi">phi</code></td>
<td>
<p>When <code>weight = "distance"</code> a constant by which to multiply 
the inverse of Euclidean distance. Defaults to 1, and must exceed 0.</p>
</td></tr>
<tr><td><code id="precision_builder_+3A_r">r</code></td>
<td>
<p>If <code>neighborhood = "round"</code>, then locations i,j are 
separated by distance <code class="reqn">d \ge r</code> are conditionally independent.</p>
</td></tr>
<tr><td><code id="precision_builder_+3A_w">w</code>, <code id="precision_builder_+3A_h">h</code></td>
<td>
<p>If <code>neighborhood = "rectangle"</code> then <code>w</code> and <code>h</code>
are the number of locations to the left/right and above/below a location 
i that define its neighborhood. Any locations outside this neighborhood are
conditionally independent of the specified location.</p>
</td></tr>
<tr><td><code id="precision_builder_+3A_digits.q">digits.Q</code></td>
<td>
<p>Determines the number of digits to round entries in the 
precision matrix. Default is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This formulation of the CAR model is based on a formulation found 
in (Banerjee et al. 2015) where the joint distribution 
of the of the conditionally specified random variables are assumed to be
<code class="reqn">N(0, [diag(tau^2)(D - alpha W)] ^ {-1})</code> and all neighbors are 
weighted 1. When weights other than 1 are desired, the joint distribution
is <code class="reqn">N(0, [diag(tau^2) D (I - alpha D^{-1}W)] ^ {-1})</code>, e.g. as in
(Jin et al. 2005).
</p>


<h3>Value</h3>

<p>A (precision) matrix.
</p>


<h3>References</h3>

<p>Banerjee S, Carlin BP, Gelfand AE (2015).
<em>Hierarchical Modeling and Analysis for Spatial Data</em>, Second edition.
Chapman &amp; Hall/CRC, Boca Raton, Florida.
</p>
<p>Jin X, Carlin BP, Banerjee S (2005).
&ldquo;Generalized Hierarchical Multivariate CAR Models for Areal Data.&rdquo;
<em>Biometrics</em>, <b>61</b>(4), 950-961.
<a href="https://doi.org/10.1111/j.1541-0420.2005.00359.x">doi:10.1111/j.1541-0420.2005.00359.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
precision_builder(im.res = c(3, 3), tau = 1, alpha = 0.75,
                  neighborhood = "ar1")

## binary weights
precision_builder(im.res = c(3, 3), tau = 1, alpha = 0.75,
                  neighborhood = "round", r = 3)

## weights based on distance
precision_builder(im.res = c(3, 3), tau = 1, alpha = 0.75,
                  weight = "distance", phi = 1,
                  neighborhood = "round", r = 3)

precision_builder(im.res = c(3, 3), tau = 1, alpha = 0.75,
                  neighborhood = "rectangle", w = 2, h = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='proximity_builder'>Generate a Proximity Matrix</h2><span id='topic+proximity_builder'></span>

<h3>Description</h3>

<p>Generates a proximity matrix where non-zero entries are the weights 
associated with neighbors, and zero entries are not neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximity_builder(
  im.res,
  neighborhood = "ar1",
  type = c("sparse", "full"),
  weight = "binary",
  phi = 1,
  r = NULL,
  h = NULL,
  w = NULL,
  include.coords = FALSE,
  print.im = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proximity_builder_+3A_im.res">im.res</code></td>
<td>
<p>A vector defining the dimension of spatial data. The first 
entry is the number of rows and the second  entry is the number of columns.</p>
</td></tr>
<tr><td><code id="proximity_builder_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Determines how to assign neighbor status to locations;
i.e. 1 for neighbors, 0 otherwise. <code>type = "round"</code> assigns neighbor 
status to locations within radius <code>r</code>. <code>type = "ar1"</code> assigns
1 to locations directly above or beside. <code>type = "rectangle"</code> assigns 
neighbor status to locations within <code>w</code> units to the left or right 
and  <code>h</code> units up or down.</p>
</td></tr>
<tr><td><code id="proximity_builder_+3A_type">type</code></td>
<td>
<p>Specifies either sparse (<code>type = "sparse"</code>) or full 
(<code>type = "full"</code>) proximity matrix.</p>
</td></tr>
<tr><td><code id="proximity_builder_+3A_weight">weight</code></td>
<td>
<p>Determines how weights are assigned. <code>"distance"</code> 
assigns weights as the inverse of Euclidean distance times a constant, 
<code>phi</code>. <code>"binary"</code> assigns weights to 1 for neighbors and 0 
otherwise.</p>
</td></tr>
<tr><td><code id="proximity_builder_+3A_phi">phi</code></td>
<td>
<p>When <code>weight = "distance"</code> a constant by which
to multiply the inverse of Euclidean distance. Defaults to 1.</p>
</td></tr>
<tr><td><code id="proximity_builder_+3A_r">r</code>, <code id="proximity_builder_+3A_h">h</code>, <code id="proximity_builder_+3A_w">w</code></td>
<td>
<p>When <code>neighborhood = "round"</code>, <code>r</code> specifies the 
radius within which other locations are neighbors. When 
<code>neighborhood = "rectangle"</code>, <code>w</code> and <code>h</code> specify the number
of units to the left/right and above/below the location are to be counted 
as neighbors.</p>
</td></tr>
<tr><td><code id="proximity_builder_+3A_include.coords">include.coords</code></td>
<td>
<p>If <code>type = "sparse"</code> and 
<code>include.coords = TRUE</code>, then the coordinates of neighbors are
returned along with their indices.</p>
</td></tr>
<tr><td><code id="proximity_builder_+3A_print.im">print.im</code></td>
<td>
<p>Allows user to print the 2D &quot;image&quot; matrix with index 
labels to visually verify that the proximity matrix is as expected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (proximity) matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## adjacency matrix with sparse structure (i.e., 2 columns) 
## and ar1 neighborhood
sp.ar1 &lt;- proximity_builder(im.res = c(3, 3),
                            weight = "binary",
                            neighborhood = "ar1",
                            type = "sparse")
## adjacency matrix with full structure 
## (i.e., prod(im.dim) rows &amp; columns) and ar1 neighborhood
full.ar1 &lt;- proximity_builder(im.res = c(3, 3),
                              weight = "binary",
                              neighborhood = "ar1",
                              type = "full")

## proximity matrix weighted by distance (sparse)
sp.rnd &lt;- proximity_builder(im.res = c(3, 3),
                            weight = "distance",
                            neighborhood = "round", r = 2,
                            type = "sparse",
                            include.coords = TRUE)

## proximity matrix weighted by distance (full)
full.rnd &lt;- proximity_builder(im.res = c(3, 3),
                              weight = "distance",
                              neighborhood = "round", r = 2,
                              type = "full")

## End(Not run)
</code></pre>

<hr>
<h2 id='sample_FP_Power'>Obtain Sample False Positive Rates and Power</h2><span id='topic+sample_FP_Power'></span>

<h3>Description</h3>

<p>This function calculates sample FDR, FWER, and Power for large numbers of
predictors, given a vector of &quot;true&quot; parameter values and a vector of 
associated rejections. In the case that more than 1 predictor has a &quot;true&quot;
non-zero parameter, then Power is defined as the proportion/percentage of
those &quot;true&quot; parameters identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_FP_Power(
  rejections = NULL,
  FP = NULL,
  TP = NULL,
  test.statistic = NULL,
  reject.threshold = NULL,
  B = NULL,
  B.incl.B0 = TRUE,
  full.summary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_FP_Power_+3A_rejections">rejections</code></td>
<td>
<p>A binary vector; <code>rejection[i] = 1</code> means the null
hypothesis is rejected for parameter <code>B[i]</code>, whereas 
<code>rejection[i] = 0</code> means that the null hypothesis was not rejected
for parameter <code>B[i]</code>.</p>
</td></tr>
<tr><td><code id="sample_FP_Power_+3A_fp">FP</code>, <code id="sample_FP_Power_+3A_tp">TP</code></td>
<td>
<p>Binary vectors of false positive and true positive indicators,
respectively. <code>FP[i] = 1</code> means the null hypothesis was incorrectly 
rejected, and <code>TP[i] = 1</code> means the null hypothesis was correctly 
rejected. If either argument is <code>NULL</code>, then these vectors are 
computed; this is the default setting.</p>
</td></tr>
<tr><td><code id="sample_FP_Power_+3A_test.statistic">test.statistic</code></td>
<td>
<p>A vector of test statistics; e.g., t-statistics or
p-values that are used to determine whether or not to reject the null
hypothesis.</p>
</td></tr>
<tr><td><code id="sample_FP_Power_+3A_reject.threshold">reject.threshold</code></td>
<td>
<p>A list whose first element is the rejection 
criteria, e.g., the minimum t-statistic or maximum p-value for which to
reject the null hypothesis. The second element is one of 
<code>c("greater", "less", "2-tailed")</code>, which tell the function to reject
when the values in <code>test.statistic</code> are greater than or less than the
threshold, the test is a 2-tailed, respectively. In the latter case the 
function internally calculates the upper or lower threshold needed for the
2-tailed test.</p>
</td></tr>
<tr><td><code id="sample_FP_Power_+3A_b">B</code></td>
<td>
<p>A vector of &quot;true&quot; parameter values. For inference purposes, this
can be a vector of actual parameter values, or a binary vector indicating
non-zero status.</p>
</td></tr>
<tr><td><code id="sample_FP_Power_+3A_b.incl.b0">B.incl.B0</code></td>
<td>
<p>If <code>B.incl.B0 = TRUE</code> then the first entry should be
the intercept, B0. <code>B.incl.B0 = FALSE</code> indicates that the first entry
of B is not an intercept.</p>
</td></tr>
<tr><td><code id="sample_FP_Power_+3A_full.summary">full.summary</code></td>
<td>
<p>If <code>full.summary = TRUE</code> then the total numbers of
rejections, false positives, true positives, and non-zero parameters are
output along with FDR, FWER, and Power; otherwise, only FDR, FWER, and 
Power are output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns for sample FDR, FWER, and Power.
</p>


<h3>Note</h3>

<p>The default operating approach is that the null hypothesis is 
<code>B[i] = 0</code> for each parameter. If other hypotheses are being tested 
then <code>B</code> should be converted to a binary vector indicating whether 
the null hypothesis <em>should</em> have been rejected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example 1

## rejection vector
rej.ex &lt;- c(0, 1, 1, 0, 0, 1, 0)
## false positive vector
fp.ex  &lt;- c(0, 0, 1, 0, 0, 0, 0)
## true positive vector
tp.ex  &lt;- c(0, 1, 0, 0, 0, 1, 0)
## parameter vector
par.ex &lt;- c(0, 4, 0, 0, 3, 9, 0)

sample_FP_Power(rej.ex, fp.ex, tp.ex, par.ex, B.incl.B0 = FALSE)

## Function can calculate TP and FP vectors
sample_FP_Power(rejections = rej.ex, 
                FP = NULL, TP = NULL, 
                B = par.ex, B.incl.B0 = FALSE)

## example 2: sum(FP, TP) must equal sum(rejections) or
## function stops execution

rej.ex2 &lt;- c(0, 1, 0, 0, 0, 1, 0)
fp.ex2  &lt;- c(0, 0, 1, 0, 0, 0, 0)
tp.ex2  &lt;- c(0, 1, 0, 0, 0, 1, 0)
par.ex2 &lt;- c(0, 4, 0, 0, 3, 9, 0)

## Not run: sample_FP_Power(rej.ex2, 
                         fp.ex2, tp.ex2, par.ex2, 
                         B.incl.B0 = FALSE)
## End(Not run)

## example 3: calculate rejections from vector of test statistics
zstat &lt;- c(-0.5, 1.98, 2.01, 1.45, -1.99)
# 2-tailed
sample_FP_Power(test.statistic = zstat,
                reject.threshold = list(1.96, "2-tailed"),
                B = c(0, 0, 4, 1, -2), B.incl.B0 = FALSE)
# 1-tailed (upper)
sample_FP_Power(test.statistic = zstat,
                reject.threshold = list(1.96, "greater"),
                B = c(0, 0, 4, 1, -2), B.incl.B0 = FALSE)
## p-value
sample_FP_Power(test.statistic = c(0.44, 0.04, 0.01, 0.06, 0.02 ),
                reject.threshold = list(0.05, "less"),
                B = c(0, 0, 4, 1, -2), B.incl.B0 = FALSE)
</code></pre>

<hr>
<h2 id='sim_MVN_X'>Simulate Spatially Correlated MVN Data</h2><span id='topic+sim_MVN_X'></span>

<h3>Description</h3>

<p>Takes N draws from a Multivariate Normal (MVN) distribution using either
base R or the R package <code>spam</code>. This function requires the Cholesky
decomposition of the desired covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_MVN_X(
  N,
  mu = 0,
  L = NULL,
  R = NULL,
  S = NULL,
  Q = NULL,
  use.spam = FALSE,
  use.MASS = FALSE,
  X.categorical = FALSE,
  X.num.categories = 2,
  X.category.type = "percentile",
  X.percentiles = NULL,
  X.manual.thresh = NULL,
  X.cat.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_MVN_X_+3A_n">N</code></td>
<td>
<p>The number of draws to take from MVN; i.e., the number of subjects.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_mu">mu</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li><p> A single scalar value for common mean.
</p>
</li>
<li><p> A vector of length <code>nrow(R)</code> (equivalently <code>nrow(R)</code>)
containing means for the MVN.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_l">L</code>, <code id="sim_MVN_X_+3A_r">R</code></td>
<td>
<p><code>L</code> and <code>R</code> are lower and upper triangular matrices, 
respectively, and are the Cholesky factor(s) of the desired covariance 
matrix for the MVN. Obtain <code>L</code> or <code>R</code> via <code>chol_s2Dp()</code> 
with settings <code>triangle = "lower"</code> or <code>triangle = "upper"</code>, 
respectively. Specify either <code>L</code> or <code>R</code>, but NOT both.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_s">S</code>, <code id="sim_MVN_X_+3A_q">Q</code></td>
<td>
<p>A covariance or precision matrix respectively. These are for 
use with <code>spam</code>, and can be extracted from output of 
<code><a href="#topic+chol_s2Dp">chol_s2Dp</a></code> after choosing 
<code>return.cov = TRUE</code> or <code>return.prec = TRUE</code>, respectively.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_use.spam">use.spam</code></td>
<td>
<p>Logical. If <code>use.spam = TRUE</code> then use tools from the
R package <code>spam</code>; otherwise, base R functions are employed. For large
dimension MVN with sparse correlation structure, <code>spam</code> is 
recommended; otherwise, base R may be faster. Defaults to <code>FALSE</code>.
Requires either the covariance matrix <code>S</code> or precision matrix, 
<code>Q</code>, that corresponds to the Cholesky factor.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_use.mass">use.MASS</code></td>
<td>
<p>Logical. When <code>TRUE</code> draws X from MVN using 
<code>mvrnorm</code> from <code>MASS</code>. Note that this requires specification of
the covariance matrix, <code>S</code>. Specifying the precision matrix instead 
may slow down the process for large dimensions. Recommended to use 
<code>spam</code> to generate draws when specifying a precision matrix, <code>Q</code>.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_x.categorical">X.categorical</code></td>
<td>
<p>Default is <code>X.categorical = FALSE</code>. If
<code>X.categorical = TRUE</code> then thresholds are applied to categorize
each predictor/image value.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_x.num.categories">X.num.categories</code></td>
<td>
<p>A scalar value denoting the number of categories
in which to divide the data.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_x.category.type">X.category.type</code></td>
<td>
<p>Tells R how to categorize the data. Options are
<code>X.category.type = c("percentile", "manual")</code>.
If <code>X.category.type = "percentile"</code> then the data are divided into
percentiles based on <code>X.num.categories</code>; e.g. if 
<code>X.num.categories = 4</code> then the values are divided into quartiles, 
and values in Q1 equal 0, between Q1 and Q2 equal 1, between Q2 and Q3 
equal 2, and greater than Q3 equal 3. 
If <code>X.category.type = "manual"</code> then specify the cutoff points with
<code>X.manual.thresh</code>.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_x.percentiles">X.percentiles</code></td>
<td>
<p>A vector of percentiles to be used in thresholding 
when <code>X.categorical = TRUE</code> and <code>X.category.type = "percentile"</code>.
The length of this vector should equal the number of categories minus one,
and all values should be between zero and one.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_x.manual.thresh">X.manual.thresh</code></td>
<td>
<p>A vector containing the thresholds for categorizing
the values; e.g. if <code>X.num.categories = 4</code> and 
<code>X.manual.thresh = c(-3, 1, 17)</code>, then values less than -3 are set to
0, equal or greater than -3 and less than 1 are set to 1, equal or greater
than 1 but less than 17 are set to 2, and equal or greater than 17 are set
to 3. Note that <code>length(X.manual.thresh)</code> must always equal 
<code>X.num.categories - 1</code>.</p>
</td></tr>
<tr><td><code id="sim_MVN_X_+3A_x.cat.names">X.cat.names</code></td>
<td>
<p>A vector of category names. If <code>X.cat.names = NULL</code>
then the initial integers assigned are left as the values; the names in
<code>X.cat.names</code> are assigned in ascending order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of dimension <code>N</code> x <code>(nrow(L))</code> (or equivalently
<code>N</code> x <code>(nrow(R))</code>) where each row is draw from MVN, and each 
column represents a different &quot;variable&quot;; e.g. location in an image.
</p>


<h3>Note</h3>

<p>This function requires the Cholesky decomposition of the desired 
covariance matrix for the MVN; this allows for using this function in 
simulating multiple datasets of <code>N</code> MVN draws while only taking the
Cholesky decomposition of the covariance matrix once.
</p>


<h3>References</h3>

<p>Furrer R, Sain SR (2010).
&ldquo;spam: A Sparse Matrix R Package with Emphasis on MCMC Methods for Gaussian Markov Random Fields.&rdquo;
<em>Journal of Statistical Software</em>, <b>36</b>(10), 1-25.
<a href="https://www.jstatsoft.org/v36/i10/">https://www.jstatsoft.org/v36/i10/</a>.
</p>
<p>Ripley BD (1987).
<em>Stochastic Simulation</em>.
John Wiley &amp; Sons.
<a href="https://doi.org/10.1002/9780470316726">doi:10.1002/9780470316726</a>.
</p>
<p>Rue H (2001).
&ldquo;Fast Sampling of Gaussian Markov Random Fields.&rdquo;
<em>Journal of the Royal Statistical Society B</em>, <b>63</b>, 325-338.
<a href="https://doi.org/10.1111/1467-9868.00288">doi:10.1111/1467-9868.00288</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## verify MVN with base R
set.seed(732)
Lex &lt;- chol_s2Dp(corr.structure = "ar1",
                 im.res = c(3, 3), 
                 rho = 0.25,
                 sigma = 1, 
                 use.spam = FALSE, 
                 corr.min = 0.02,
                 triangle = "lower", 
                 return.cov = TRUE)
XbR = sim_MVN_X(N = 1000, mu = 0, L = Lex$L)

apply(XbR, 2, mean)
cov(XbR)
Lex$S

## verify MVN with \code{spam}
set.seed(472)
Rex &lt;- chol_s2Dp(im.res = c(3, 3), matrix.type = "prec",
                use.spam = TRUE, neighborhood = "ar1",
                triangle = "upper", return.prec = TRUE)

Xspam = sim_MVN_X(N = 1000, mu = 0, R = Rex$R, Q = Rex$Q)

apply(Xspam, 2, mean)
solve(cov(Xspam))
as.matrix(Rex$Q)

## Categories
set.seed(832)
Xtest &lt;- sim_MVN_X(N = 30, mu = 0, L = Lex$L,
                   X.categorical = TRUE,
                   X.num.categories = 3,
                   X.category.type = "percentile",
                   X.cat.names = c("A", "B", "C"))
Xtest

</code></pre>

<hr>
<h2 id='sim_Y_Binary_X'>Simulate Scalar Outcomes from Simulated Spatially Dependent Binary Predictors</h2><span id='topic+sim_Y_Binary_X'></span>

<h3>Description</h3>

<p>N spatially dependent binary design vectors are simulated using 
<code>sim2D_binarymap</code>. These design vectors are used to then simulate
scalar outcomes that have one of Gaussian, Binomial, or Poisson 
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_Y_Binary_X(
  N,
  B,
  rand.err = 1,
  dist,
  incl.subjectID = TRUE,
  binomial.method = "traditional",
  count.method = "traditional",
  Y.thresh = NULL,
  print.out = FALSE,
  xlim = c(0, 1),
  ylim = c(0, 1),
  im.res,
  radius.bounds = c(0.02, 0.1),
  lambda = 50,
  random.lambda = FALSE,
  lambda.sd = 10,
  lambda.bound = NULL,
  prior = "gamma",
  sub.area = FALSE,
  min.sa = c(0.1, 0.1),
  max.sa = c(0.3, 0.3),
  radius.bounds.min.sa = c(0.02, 0.05),
  radius.bounds.max.sa = c(0.08, 0.15),
  print.subj.sa = FALSE,
  print.lambda = FALSE,
  print.iter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_Y_Binary_X_+3A_n">N</code></td>
<td>
<p>A scalar value determining the number of images to create.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_b">B</code></td>
<td>
<p>A vector parameter values; i.e. &quot;betas&quot;. Note that 
<code>length(B)</code> must equal <code>p + 1 = n.row * n.col + 1</code>; e.g. for
normal outcomes <code class="reqn">Y = XB + e</code> with <code>Y</code> a scalar outcome and 
<code>e</code> the random error.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_rand.err">rand.err</code></td>
<td>
<p>A scalar for the random error variance when 
<code>dist = "gaussian"</code>.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_dist">dist</code></td>
<td>
<p>The distribution of the scalar outcome.
</p>

<ul>
<li> <p><code>dist = "gaussian"</code> has <code class="reqn">Y = XB + e</code>, where
<code class="reqn">e ~ N(0, rand.err)</code>.
</p>
</li>
<li> <p><code>dist = "binomial"</code> is drawn from eqnBin(XB, XB(1-XB))
using <code>rbinom()</code> when <code>binary.method = "Traditional"</code>. If
<code>binary.method = "Gaussian"</code>, then simulation is based on a
cutoff using <code>binary.cutoff</code>.
</p>
</li>
<li> <p><code>dist = "poisson"</code> is drawn from <code class="reqn">Poisson(XB)</code> using
<code>rpois()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_incl.subjectid">incl.subjectID</code></td>
<td>
<p>When <code>incl.subjectID = TRUE</code> a column of subject
indices is generated.
<code>Y.thresh = NULL</code> (default). If <code>binomial.method = "gaussian manual"</code>,
then <code>Y.thresh</code> should be any scalar real number; values equal or 
above this cutoff are assigned 1 and values below are assigned 0.
If <code>binomial.method = "gaussian percentile"</code>, then values equal or 
above this percentile are assigned 1, and other wise 0; in this case values
should be between 0 and 1. For example, if <code>Y.thresh = 0.9</code>, then the
cutoff is the 90th percentile.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_binomial.method">binomial.method</code></td>
<td>
<p>One of <code>c("traditional", "gaussian manual",
"gaussian percentile")</code>. Only specified when <code>dist = "binomial"</code>, 
and determines whether draws are directly taken from a binomial 
distribution or if draws are taken from a Multivariate Normal 
Distribution (in the manner of <code>dist = "gaussian"</code>) and thresholds 
imposed to binarize the outcomes. <code>binomial.method = "gaussian manual"</code>
allows the user to specify specific values for categorizing outcomes. 
<code>binomial.method = "gaussian percentile"</code> allows the user to specify
percentiles for binarizing the data. Both approaches use <code>Y.thresh</code> 
to specify the cutoff value(s). If <code>binomial.method = "gaussian percentile"</code>
and <code>Y.thresh = NULL</code> then the median is used as the threshold. If
<code>binomial.method = "gaussian manual"</code> and <code>Y.thresh = NULL</code>, then
0 is used as the threshold. Default is <code>binomial.method = "traditional"</code>.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_count.method">count.method</code></td>
<td>
<p>One of <code>c("traditional", "rounding")</code>. When 
<code>count.method = "traditional"</code>, the outcomes are drawn sequentially 
using <code>rpois()</code>. When <code>count.method = "traditional"</code>, the
outcomes are drawn from an MVN, then values less than or equal to 0 are 
set to 0, and all other values are rounded to the nearest whole number.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_y.thresh">Y.thresh</code></td>
<td>
<p>When <code>binomial.method = "traditional"</code></p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_print.out">print.out</code></td>
<td>
<p>If <code>print.out = TRUE</code> then print the following for
each subject, indexed y: </p>

<ul>
<li> <p><code>X[y] %*% B</code>
</p>
</li>
<li> <p><code>p[y]</code>, <code>lambda[y]</code> for Binomial, Poisson, respectively.
</p>
</li></ul>

<p>This is useful to see the effect of image parameter selection and beta
parameter selection on distributional parameters for the outcome of 
interest.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_xlim">xlim</code>, <code id="sim_Y_Binary_X_+3A_ylim">ylim</code></td>
<td>
<p>These are the 2D image limits. Defaults for both are 
<code>c(0, 1)</code>. It is not recommended to alter these arguments unless 
changing the limits has a specific practical utility.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_im.res">im.res</code></td>
<td>
<p>A vector specifying the dimension/resolution of the image. 
The first entry is the number of 'rows' in the lattice/image, and the 
second entry is the number of columns' in the lattice/image.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_radius.bounds">radius.bounds</code></td>
<td>
<p>A 2-element vector whose first and second entries 
determine the minimum and maximum radius sizes, respectively; these will 
be the bounds of the uniform distribution used to draw the radii. If 
<code>sub.area = TRUE</code>, then use <code>radius.bounds.min.sa</code> and 
<code>radius.bounds.max.sa</code>.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_lambda">lambda</code></td>
<td>
<p>A scalar value specifying the mean/intensity value of the 
Poisson process. If <code>random.lambda = FALSE</code> then this is the parameter
used to generate the binary image for each subject. If 
<code>random.lambda = TRUE</code>, then this is the mean parameter in the
distribution used to draw subject-specific lambda.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_random.lambda">random.lambda</code></td>
<td>
<p><code>random.lambda = TRUE</code> allows the lambda 
(mean/intensity) parameter in the Poisson process to vary randomly by 
subject.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_lambda.sd">lambda.sd</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and 
specifies the standard deviation in the distribution used to draw 
subject-specific lambda.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_lambda.bound">lambda.bound</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and 
allows the user to specify a lower and upper bound for the subject-specific
lambda; if the randomly selected value is outside of this range, then 
another draw is taken. This continues until a value is selected within the
specified bounds. If no bounds are desired then specify 
<code>lambda.bound = NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_prior">prior</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and specifies
the distribution from which to draw the subject-specific lambda.
Options are <code>c("gaussian", "gamma")</code>.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_sub.area">sub.area</code></td>
<td>
<p>When <code>sub.area = TRUE</code>, a random sub-section of the 
image is chosen, within which the Poisson process is used to generate the
binary image.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_min.sa">min.sa</code>, <code id="sim_Y_Binary_X_+3A_max.sa">max.sa</code></td>
<td>
<p>Only utilized when <code>sub.area = TRUE</code>, and
determines the width and height of the  minimum and maximum sub-areas; 
e.g., if <code>min.sa = c(0.1, 0.1)</code>, then the smallest possible random 
sub-area is a 0.1 x 0.1 square.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_radius.bounds.min.sa">radius.bounds.min.sa</code>, <code id="sim_Y_Binary_X_+3A_radius.bounds.max.sa">radius.bounds.max.sa</code></td>
<td>
<p>Only utilized when 
<code>sub.area = TRUE</code>, and specifies <code>radius.bounds</code> for the minimum
and maximum sub-areas, respectively. This information is used to adaptively
alter the bounds in between the minimum and maximum sub-areas.</p>
</td></tr>
<tr><td><code id="sim_Y_Binary_X_+3A_print.subj.sa">print.subj.sa</code>, <code id="sim_Y_Binary_X_+3A_print.lambda">print.lambda</code>, <code id="sim_Y_Binary_X_+3A_print.iter">print.iter</code></td>
<td>
<p>These arguments are either
<code>TRUE</code> or <code>FALSE</code>, and define print options for checking that the
function is working as the user intends. <code>print.subj.sa = TRUE</code> prints
the x-and y-limits for each subject's sub-area. <code>print.lambda = TRUE</code> 
prints each subject's mean and realized events; the means will be the same
unless <code>random.lambda = TRUE</code>, but the number of realized events will
always vary. <code>print.iter = TRUE</code> is only used when 
<code>random.lambda = TRUE</code> and <code>is.null(lambda.bound) = FALSE</code>, and
shows iterations for re-drawing when the randomly selected intensity is 
outside the specified bounds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where each row consists of a single subject's data.
Col 1 is the outcome, Y, and each successive column contains the subject
predictor values.
</p>


<h3>Note</h3>

<p>Careful parameter selection, i.e. <code>B</code>, is necessary to ensure 
that simulated outcomes are reasonable; in particular, counts arising from
the Poisson distribution can be unnaturally large.
</p>


<h3>References</h3>

<p>Cressie N, Wikle CK (2011).
<em>Statistics for Spatio-Temporal Data</em>,  Wiley Series in Probability and Statistics.
John Wiley &amp; Sons, Hoboken, NJ.
</p>
<p>Ripley BD (1987).
<em>Stochastic Simulation</em>.
John Wiley &amp; Sons.
<a href="https://doi.org/10.1002/9780470316726">doi:10.1002/9780470316726</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Define non-zero beta values
Bex &lt;- beta_builder(row.index = c(3, 3, 4), 
                    col.index = c(3, 4, 3),
                    im.res = c(5, 5),
                    B0 = 0, B.values = rep(1/3, 3),
                    output.indices = FALSE)
## Simulate Datasets
## parameter values
Nex = 10
set.seed(28743)

Gauss.ex &lt;- sim_Y_Binary_X(N = Nex, 
                           B = Bex,
                           dist = "gaussian", 
                           im.res = c(5, 5))
hist(Gauss.ex$Y)

## direct draws from binomial
Bin.ex &lt;- sim_Y_Binary_X(N = Nex, 
                         B = Bex, 
                         im.res = c(5, 5),
                         dist = "binomial", 
                         print.out = TRUE)
table(Bin.ex$Y)
</code></pre>

<hr>
<h2 id='sim_Y_MVN_X'>Simulate Scalar Outcomes from Simulated Spatially Correlated Predictors</h2><span id='topic+sim_Y_MVN_X'></span>

<h3>Description</h3>

<p>N spatially correlated design vectors are simulated from an MVN. These
design vectors are used to then simulate scalar outcomes that have
one of Gaussian, Binomial, Multinomial or Poisson distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_Y_MVN_X(
  N,
  B,
  L = NULL,
  R = NULL,
  S = NULL,
  Q = NULL,
  use.spam = TRUE,
  mu = 0,
  rand.err = 1,
  dist = "gaussian",
  V = NULL,
  incl.subjectID = TRUE,
  threshold.method = "none",
  Y.thresh = NULL,
  X.categorical = FALSE,
  X.num.categories = 2,
  X.category.type = "percentile",
  X.manual.thresh = NULL,
  X.cat.names = NULL,
  print.out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_Y_MVN_X_+3A_n">N</code></td>
<td>
<p>The number of draws to take from MVN; i.e., the number of subjects.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_b">B</code></td>
<td>
<p>A vector parameter values; i.e. &quot;betas&quot;. Note that 
<code>length(B)</code> must equal <code>p + 1 = n.row * n.col + 1</code>; e.g. for 
normal outcomes <code class="reqn">Y = XB + e</code> with <code>Y</code> a scalar outcome and 
<code>e</code> the random error. Note that when <code>dist = "multinomial"</code> then
<code>B</code> should be a list with length equal to <code>V - 1</code>, i.e., should
contain parameter values associated with all categories except the 
reference category. Alternatively, when <code>dist = "multinomial"</code>  
<code>B</code> may be a list of length <code>V</code> if one desires to specify 
parameters for every category, i.e., the over-parameterized model used in 
Friedman (2010).</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_l">L</code>, <code id="sim_Y_MVN_X_+3A_r">R</code></td>
<td>
<p><code>L</code> and <code>R</code> are lower and upper triangular matrices, 
respectively, and are the Cholesky factor(s) of the desired covariance 
matrix for the MVN. Obtain <code>L</code> or <code>R</code> via <code>chol_s2Dp()</code> 
with settings <code>triangle = "lower"</code> or <code>triangle = "upper"</code>, 
respectively. Specify either <code>L</code> or <code>R</code>, but NOT both.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_s">S</code>, <code id="sim_Y_MVN_X_+3A_q">Q</code></td>
<td>
<p>A covariance or precision matrix respectively. These are for 
use with <code>spam</code>, and can be extracted from output of 
<code><a href="#topic+chol_s2Dp">chol_s2Dp</a></code> after choosing 
<code>return.cov = TRUE</code> or <code>return.prec = TRUE</code>, respectively.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_use.spam">use.spam</code></td>
<td>
<p>Logical. If <code>use.spam = TRUE</code> then use tools from the
R package <code>spam</code>; otherwise, base R functions are employed. For large
dimension MVN with sparse correlation structure, <code>spam</code> is 
recommended; otherwise, base R may be faster. Defaults to <code>FALSE</code>.
Requires either the covariance matrix <code>S</code> or precision matrix, 
<code>Q</code>, that corresponds to the Cholesky factor.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_mu">mu</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li><p> A single scalar value for common mean.
</p>
</li>
<li><p> A vector of length <code>nrow(R)</code> (equivalently <code>nrow(R)</code>)
containing means for the MVN.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_rand.err">rand.err</code></td>
<td>
<p>A vector for the random error standard deviation when 
<code>dist = "gaussian"</code>, or thresholding is used to obtain non-Normal 
draws. Must have length 1 or length N.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_dist">dist</code></td>
<td>
<p>The distribution of the scalar outcome.
</p>

<ul>
<li> <p><code>dist = "gaussian"</code> has <code class="reqn">Y = XB + e</code>, where
<code class="reqn">e ~ N(0, rand.err)</code>.
</p>
</li>
<li> <p><code>dist = "binomial"</code>: Y is drawn from a binomial distribution
with probability of &quot;success&quot; equal to <code class="reqn">1 / (1 + 1 / exp(XB))</code> 
using <code>rbinom()</code> when <code>binary.method = "traditional"</code>. If 
<code>binary.method = "gaussian"</code>, then simulation  is based on a 
cutoff using <code>binary.cutoff</code>.
</p>
</li>
<li> <p><code>dist = "multinomial"</code>: Y is drawn from <code>sample()</code> 
using probabilities generated based on Chapter 6.1.3 of Agresti (2007)
when <code>length(B) = V - 1</code> or Friedman (2010) when the 
<code>length(B) = V</code>. Threshold-based approaches are not currently 
supported.
</p>
</li>
<li> <p><code>dist = "poisson"</code>: Y is drawn from <code class="reqn">Poisson(exp(XB))</code>
using <code>rpois()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_v">V</code></td>
<td>
<p>A numeric value stating the number of categories desired when 
<code>dist = "multinomial"</code>.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_incl.subjectid">incl.subjectID</code></td>
<td>
<p>When <code>incl.subjectID = TRUE</code> a column of subject
indices is generated.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_threshold.method">threshold.method</code></td>
<td>
<p>One of <code>"none", "manual", "percentile", "round"</code>.
When <code>"none"</code> draws from Binomial or Poisson distributions are taken 
subject-wise using base <code>R</code> functions. For the remaining options, 
draws are first taken from a Normal distribution and then thresholded. 
<code>"manual"</code> uses <code>Y.thresh</code> to manually select a cutoff, 
<code>"percentile"</code> uses <code>Y.thresh</code> to select percentiles used to 
bin outcomes, and <code>"round"</code> sets values equal or less than 0 to 0, 
and rounds all positive values to the nearest whole number.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_y.thresh">Y.thresh</code></td>
<td>
<p>A manual value used to threshold when 
<code>threshold.method = "manual"</code>; values equal or greater than the cutoff
are assigned 1 and all others 0. When <code>threshold.method = "percentile"</code>,
a percentile to use to bin outcomes.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_x.categorical">X.categorical</code></td>
<td>
<p>Default is <code>X.categorical = FALSE</code>. If
<code>X.categorical = TRUE</code> then thresholds are applied to categorize
each predictor/image value.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_x.num.categories">X.num.categories</code></td>
<td>
<p>A scalar value denoting the number of categories
in which to divide the data.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_x.category.type">X.category.type</code></td>
<td>
<p>Tells R how to categorize the data. Options are
<code>X.category.type = c("percentile", "manual")</code>.
If <code>X.category.type = "percentile"</code> then the data are divided into
percentiles based on <code>X.num.categories</code>; e.g. if 
<code>X.num.categories = 4</code> then the values are divided into quartiles, 
and values in Q1 equal 0, between Q1 and Q2 equal 1, between Q2 and Q3 
equal 2, and greater than Q3 equal 3. 
If <code>X.category.type = "manual"</code> then specify the cutoff points with
<code>X.manual.thresh</code>.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_x.manual.thresh">X.manual.thresh</code></td>
<td>
<p>A vector containing the thresholds for categorizing
the values; e.g. if <code>X.num.categories = 4</code> and 
<code>X.manual.thresh = c(-3, 1, 17)</code>, then values less than -3 are set to
0, equal or greater than -3 and less than 1 are set to 1, equal or greater
than 1 but less than 17 are set to 2, and equal or greater than 17 are set
to 3. Note that <code>length(X.manual.thresh)</code> must always equal 
<code>X.num.categories - 1</code>.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_x.cat.names">X.cat.names</code></td>
<td>
<p>A vector of category names. If <code>X.cat.names = NULL</code>
then the initial integers assigned are left as the values; the names in
<code>X.cat.names</code> are assigned in ascending order.</p>
</td></tr>
<tr><td><code id="sim_Y_MVN_X_+3A_print.out">print.out</code></td>
<td>
<p>If <code>print.out = TRUE</code> then print the following for
each subject, indexed y: </p>

<ul>
<li> <p><code>X[y] %*% B</code>
</p>
</li>
<li> <p><code>p[y]</code>, <code>lambda[y]</code> for Binomial, Poisson, respectively.
</p>
</li></ul>

<p>This is useful to see the effect of image parameter selection and beta
parameter selection on distributional parameters for the outcome of 
interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where each row consists of a single subject's data.
Col 1 is the outcome, Y, and each successive column contains the subject
predictor values.
</p>


<h3>Note</h3>

<p>Careful parameter selection, i.e. <code>B</code>, is necessary to ensure 
that simulated outcomes are reasonable; in particular, counts arising from
the Poisson distribution can be unnaturally large.
</p>


<h3>References</h3>

<p>Furrer R, Sain SR (2010).
&ldquo;spam: A Sparse Matrix R Package with Emphasis on MCMC Methods for Gaussian Markov Random Fields.&rdquo;
<em>Journal of Statistical Software</em>, <b>36</b>(10), 1-25.
<a href="https://www.jstatsoft.org/v36/i10/">https://www.jstatsoft.org/v36/i10/</a>.
</p>
<p>Ripley BD (1987).
<em>Stochastic Simulation</em>.
John Wiley &amp; Sons.
<a href="https://doi.org/10.1002/9780470316726">doi:10.1002/9780470316726</a>.
</p>
<p>Rue H (2001).
&ldquo;Fast Sampling of Gaussian Markov Random Fields.&rdquo;
<em>Journal of the Royal Statistical Society B</em>, <b>63</b>, 325-338.
<a href="https://doi.org/10.1111/1467-9868.00288">doi:10.1111/1467-9868.00288</a>.
</p>
<p>Agresti A (2007).
<em>An Introduction to Categorical Analysis</em>, 2nd edition.
John Wiley &amp; Sons, Hoboken, New Jersey.
</p>
<p>Friedman J, Hastie T, Tibshirani R (2010).
&ldquo;Regularization paths for generalized linear models via coordinate descent.&rdquo;
<em>Journal of Statistical Software</em>, <b>33</b>, 1-22.
<a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate precision matrix and take Cholesky decomposition
Rpre &lt;- chol_s2Dp(im.res = c(3, 3), matrix.type = "prec",
                  use.spam = TRUE, neighborhood = "ar1",
                  triangle = "upper", return.prec = TRUE)
## Generate correlation matrix &amp; take Cholesky decomposition
Rcov &lt;- chol_s2Dp(corr.structure = "ar1", im.res = c(3, 3), 
                  rho = 0.5,
                  triangle = "upper",
                  use.spam = FALSE, neighborhood = "none")

## Define non-zero beta values
Bex &lt;- beta_builder(row.index = c(2, 3), 
                    col.index = c(3, 3),
                    im.res = c(3, 3),
                    B0 = 0, B.values = rep(1, 2),
                    output.indices = FALSE)
## Simulate Datasets
## parameter values
Nex = 100
set.seed(28743)

## with precision matrix
Gauss.exp &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                         R = Rpre$R, Q = Rpre$Q,
                         dist = "gaussian")
hist(Gauss.exp$Y)

## with covariance matrix
Gauss.exc &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                         R = Rcov$R, S = Rcov$S,
                         dist = "gaussian")
hist(Gauss.exc$Y)

## direct draws from binomial
Bin.ex &lt;- sim_Y_MVN_X(N = Nex, B = Bex, R = Rcov$R, S = Rcov$S,
                      dist = "binomial", print.out = TRUE)
table(Bin.ex$Y)

## manual cutoff
Bin.ex2 &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                       R = Rcov$R, S = Rcov$S,
                       dist = "binomial",
                       threshold.method = "manual",
                       Y.thresh = 1.25)
table(Bin.ex2$Y)

## percentile cutoff
Bin.ex3 &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                       R = Rcov$R, S = Rcov$S,
                       dist = "binomial",
                       threshold.method = "percentile",
                       Y.thresh = 0.75)
table(Bin.ex3$Y)

## Poisson Example - note the large counts
Pois.ex &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                       R = Rcov$R, S = Rcov$S,
                       dist = "poisson", print.out = TRUE)
mean(Pois.ex$Y)
quantile(Pois.ex$Y, 
         probs = c(0, 0.1, 0.25, 0.45, 0.5,
                   0.75, 0.9, 0.95, 0.99, 1))
hist(Pois.ex$Y)
</code></pre>

<hr>
<h2 id='sim2D_binarymap'>Generate a Binary Map via the Boolean Method</h2><span id='topic+sim2D_binarymap'></span>

<h3>Description</h3>

<p>Use a Homogenous Poisson Process to generate random &quot;events&quot;, a uniform 
distribution to generate circles of random radii about the events, and take
the union to obtain a random set. This is mapped onto a lattice to obtain 
a binary map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim2D_binarymap(
  N,
  xlim = c(0, 1),
  ylim = c(0, 1),
  im.res,
  radius.bounds = c(0.02, 0.1),
  lambda = 50,
  random.lambda = FALSE,
  lambda.sd = 10,
  lambda.bound = NULL,
  prior = "gamma",
  sub.area = FALSE,
  min.sa = c(0.1, 0.1),
  max.sa = c(0.3, 0.3),
  radius.bounds.min.sa = c(0.02, 0.05),
  radius.bounds.max.sa = c(0.08, 0.15),
  print.subj.sa = FALSE,
  print.lambda = FALSE,
  print.iter = FALSE,
  store.type = "list",
  output.randset = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim2D_binarymap_+3A_n">N</code></td>
<td>
<p>A scalar value determining the number of images to create.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_xlim">xlim</code>, <code id="sim2D_binarymap_+3A_ylim">ylim</code></td>
<td>
<p>These are the 2D image limits. Defaults for both are 
<code>c(0, 1)</code>. It is not recommended to alter these arguments unless 
changing the limits has a specific practical utility.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_im.res">im.res</code></td>
<td>
<p>A vector specifying the dimension/resolution of the image. 
The first entry is the number of 'rows' in the lattice/image, and the 
second entry is the number of columns' in the lattice/image.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_radius.bounds">radius.bounds</code></td>
<td>
<p>A 2-element vector whose first and second entries 
determine the minimum and maximum radius sizes, respectively; these will 
be the bounds of the uniform distribution used to draw the radii. If 
<code>sub.area = TRUE</code>, then use <code>radius.bounds.min.sa</code> and 
<code>radius.bounds.max.sa</code>.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_lambda">lambda</code></td>
<td>
<p>A scalar value specifying the mean/intensity value of the 
Poisson process. If <code>random.lambda = FALSE</code> then this is the parameter
used to generate the binary image for each subject. If 
<code>random.lambda = TRUE</code>, then this is the mean parameter in the
distribution used to draw subject-specific lambda.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_random.lambda">random.lambda</code></td>
<td>
<p><code>random.lambda = TRUE</code> allows the lambda 
(mean/intensity) parameter in the Poisson process to vary randomly by 
subject.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_lambda.sd">lambda.sd</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and 
specifies the standard deviation in the distribution used to draw 
subject-specific lambda.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_lambda.bound">lambda.bound</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and 
allows the user to specify a lower and upper bound for the subject-specific
lambda; if the randomly selected value is outside of this range, then 
another draw is taken. This continues until a value is selected within the
specified bounds. If no bounds are desired then specify 
<code>lambda.bound = NULL</code>.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_prior">prior</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and specifies
the distribution from which to draw the subject-specific lambda.
Options are <code>c("gaussian", "gamma")</code>.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_sub.area">sub.area</code></td>
<td>
<p>When <code>sub.area = TRUE</code>, a random sub-section of the 
image is chosen, within which the Poisson process is used to generate the
binary image.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_min.sa">min.sa</code>, <code id="sim2D_binarymap_+3A_max.sa">max.sa</code></td>
<td>
<p>Only utilized when <code>sub.area = TRUE</code>, and
determines the width and height of the  minimum and maximum sub-areas; 
e.g., if <code>min.sa = c(0.1, 0.1)</code>, then the smallest possible random 
sub-area is a 0.1 x 0.1 square.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_radius.bounds.min.sa">radius.bounds.min.sa</code>, <code id="sim2D_binarymap_+3A_radius.bounds.max.sa">radius.bounds.max.sa</code></td>
<td>
<p>Only utilized when 
<code>sub.area = TRUE</code>, and specifies <code>radius.bounds</code> for the minimum
and maximum sub-areas, respectively. This information is used to adaptively
alter the bounds in between the minimum and maximum sub-areas.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_print.subj.sa">print.subj.sa</code>, <code id="sim2D_binarymap_+3A_print.lambda">print.lambda</code>, <code id="sim2D_binarymap_+3A_print.iter">print.iter</code></td>
<td>
<p>These arguments are either
<code>TRUE</code> or <code>FALSE</code>, and define print options for checking that the
function is working as the user intends. <code>print.subj.sa = TRUE</code> prints
the x-and y-limits for each subject's sub-area. <code>print.lambda = TRUE</code> 
prints each subject's mean and realized events; the means will be the same
unless <code>random.lambda = TRUE</code>, but the number of realized events will
always vary. <code>print.iter = TRUE</code> is only used when 
<code>random.lambda = TRUE</code> and <code>is.null(lambda.bound) = FALSE</code>, and
shows iterations for re-drawing when the randomly selected intensity is 
outside the specified bounds.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_store.type">store.type</code></td>
<td>
<p>One of <code>c("list", "matrix", "all")</code>. When 
<code>store.type = "list"</code>, the output is a list where each element is a 
matrix defining a subject image. If <code>store.type = "matrix"</code>, then the
images are vectorized by row and each row of the output matrix contains an 
image vector for a single subject.</p>
</td></tr>
<tr><td><code id="sim2D_binarymap_+3A_output.randset">output.randset</code></td>
<td>
<p>Logical. When <code>TRUE</code>, stores the data frame of 
original draws from the HPPP and and random radii from 
<code>sim2D_RandSet_HPPP()</code>. This data frame is stored in the first element
of the output list named <code>randset</code>. The second element of the output 
list is a  list/matrix of the final subject images depending on 
<code>store.type</code> and named <code>images</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list; each element is a matrix of zeroes and ones.
</p>


<h3>References</h3>

<p>Cressie N, Wikle CK (2011).
<em>Statistics for Spatio-Temporal Data</em>,  Wiley Series in Probability and Statistics.
John Wiley &amp; Sons, Hoboken, NJ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin_ims &lt;- sim2D_binarymap(N = 5, im.res = c(10, 10), store.type = "list",
                           lambda = 50, sub.area = TRUE,
                           min.sa = c(0.10, 0.10), max.sa = c(0.5, 0.5),
                           radius.bounds.min.sa = c(0.015, 0.04),
                           radius.bounds.max.sa = c(0.041, 0.06))

rotate = function(x){
  t(apply(x, 2, rev))
}

for (i in 1:length(bin_ims)) {
  image(rotate(bin_ims[[i]]),
        col = c("white", "darkgreen"),
        axes = FALSE)
  box()
  grid(nx = 10, ny = 10, col = "black",
       lty = 1)
}
</code></pre>

<hr>
<h2 id='sim2D_RandSet_HPPP'>Generate a Random Set Using a Poisson Process and Random Radii About Events</h2><span id='topic+sim2D_RandSet_HPPP'></span>

<h3>Description</h3>

<p>A random set is generated by using a Poisson process in 2D space to choose
'event' locations, about which a circle of random radius is 'drawn'. The 
union of the circles defines ultimately defines the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim2D_RandSet_HPPP(
  N,
  xlim = c(0, 1),
  ylim = c(0, 1),
  radius.bounds = c(0.02, 0.1),
  lambda = 50,
  lambda.sd = 10,
  lambda.bound = NULL,
  prior = "gamma",
  random.lambda = FALSE,
  sub.area = FALSE,
  min.sa = c(0.1, 0.1),
  max.sa = c(0.3, 0.3),
  radius.bounds.min.sa = c(0.02, 0.05),
  radius.bounds.max.sa = c(0.08, 0.15),
  print.subj.sa = FALSE,
  print.lambda = FALSE,
  print.iter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_n">N</code></td>
<td>
<p>A scalar value determining the number of images to create.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_xlim">xlim</code>, <code id="sim2D_RandSet_HPPP_+3A_ylim">ylim</code></td>
<td>
<p>These are the 2D image limits. Defaults for both are 
<code>c(0, 1)</code>. It is not recommended to alter these arguments unless 
changing the limits has a specific practical utility.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_radius.bounds">radius.bounds</code></td>
<td>
<p>A 2-element vector whose first and second entries 
determine the minimum and maximum radius sizes, respectively; these will 
be the bounds of the uniform distribution used to draw the radii. If 
<code>sub.area = TRUE</code>, then use <code>radius.bounds.min.sa</code> and 
<code>radius.bounds.max.sa</code>.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_lambda">lambda</code></td>
<td>
<p>A scalar value specifying the mean/intensity value of the 
Poisson process. If <code>random.lambda = FALSE</code> then this is the parameter
used to generate the binary image for each subject. If 
<code>random.lambda = TRUE</code>, then this is the mean parameter in the
distribution used to draw subject-specific lambda.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_lambda.sd">lambda.sd</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and 
specifies the standard deviation in the distribution used to draw 
subject-specific lambda.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_lambda.bound">lambda.bound</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and 
allows the user to specify a lower and upper bound for the subject-specific
lambda; if the randomly selected value is outside of this range, then 
another draw is taken. This continues until a value is selected within the
specified bounds. If no bounds are desired then specify 
<code>lambda.bound = NULL</code>.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_prior">prior</code></td>
<td>
<p>Only utilized when <code>random.lambda = TRUE</code>, and specifies
the distribution from which to draw the subject-specific lambda.
Options are <code>c("gaussian", "gamma")</code>.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_random.lambda">random.lambda</code></td>
<td>
<p><code>random.lambda = TRUE</code> allows the lambda 
(mean/intensity) parameter in the Poisson process to vary randomly by 
subject.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_sub.area">sub.area</code></td>
<td>
<p>When <code>sub.area = TRUE</code>, a random sub-section of the 
image is chosen, within which the Poisson process is used to generate the
binary image.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_min.sa">min.sa</code>, <code id="sim2D_RandSet_HPPP_+3A_max.sa">max.sa</code></td>
<td>
<p>Only utilized when <code>sub.area = TRUE</code>, and
determines the width and height of the  minimum and maximum sub-areas; 
e.g., if <code>min.sa = c(0.1, 0.1)</code>, then the smallest possible random 
sub-area is a 0.1 x 0.1 square.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_radius.bounds.min.sa">radius.bounds.min.sa</code>, <code id="sim2D_RandSet_HPPP_+3A_radius.bounds.max.sa">radius.bounds.max.sa</code></td>
<td>
<p>Only utilized when 
<code>sub.area = TRUE</code>, and specifies <code>radius.bounds</code> for the minimum
and maximum sub-areas, respectively. This information is used to adaptively
alter the bounds in between the minimum and maximum sub-areas.</p>
</td></tr>
<tr><td><code id="sim2D_RandSet_HPPP_+3A_print.subj.sa">print.subj.sa</code>, <code id="sim2D_RandSet_HPPP_+3A_print.lambda">print.lambda</code>, <code id="sim2D_RandSet_HPPP_+3A_print.iter">print.iter</code></td>
<td>
<p>These arguments are either
<code>TRUE</code> or <code>FALSE</code>, and define print options for checking that the
function is working as the user intends. <code>print.subj.sa = TRUE</code> prints
the x-and y-limits for each subject's sub-area. <code>print.lambda = TRUE</code> 
prints each subject's mean and realized events; the means will be the same
unless <code>random.lambda = TRUE</code>, but the number of realized events will
always vary. <code>print.iter = TRUE</code> is only used when 
<code>random.lambda = TRUE</code> and <code>is.null(lambda.bound) = FALSE</code>, and
shows iterations for re-drawing when the randomly selected intensity is 
outside the specified bounds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns for subject ID, x-coordinates, 
y-coordinates, and associated radii.
</p>


<h3>References</h3>

<p>Cressie N, Wikle CK (2011).
<em>Statistics for Spatio-Temporal Data</em>,  Wiley Series in Probability and Statistics.
John Wiley &amp; Sons, Hoboken, NJ.
</p>

<hr>
<h2 id='within_area'>Determine Whether Lattice Points are Within or Without a Random Set</h2><span id='topic+within_area'></span>

<h3>Description</h3>

<p>Determine whether locations in the image/lattice (from <code>generate.grid</code>)
are within or without the union of a random set generated by 
<code>sim2D_HPPP_coords()</code>. If the Euclidean distance between a lattice 
location and any 'event' is less than the radius about the 'event', then 
the location is said to be within the random set. Otherwise, it is without
the random set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>within_area(grid.centers, radii, event.xcoord, event.ycoord)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="within_area_+3A_grid.centers">grid.centers</code></td>
<td>
<p>Output from <code>generate.grid()</code> that specifies the 
coordinates of the lattice locations in native space.</p>
</td></tr>
<tr><td><code id="within_area_+3A_radii">radii</code></td>
<td>
<p>A vector of radii values.</p>
</td></tr>
<tr><td><code id="within_area_+3A_event.xcoord">event.xcoord</code>, <code id="within_area_+3A_event.ycoord">event.ycoord</code></td>
<td>
<p>Paired vectors specifying the x- and 
y- coordinates, respectively, of each 'event' from the Poisson process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with lattice x- and y- coordinates, and a binary vector
where 1 indicates the location is within the random set, and 0 indicates 
the location is without the random set.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
