<!DOCTYPE html><html><head><title>Help for package mergingTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mergingTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#code2hem'><p>Code to HEM name</p></a></li>
<li><a href='#correlation_matrix'><p>Compute correlation matrix</p></a></li>
<li><a href='#data_hrm_raw_vignette'><p>Data generated for HRM merging</p></a></li>
<li><a href='#data_much_raw_vignette'><p>Data generated for MUCH merging</p></a></li>
<li><a href='#generate_mvg_params'><p>Generate multivariate Gaussian distribution parameters</p></a></li>
<li><a href='#get_independent_matrix'><p>Generate independent HEMs</p></a></li>
<li><a href='#HRM_merge'><p>HRM merge</p></a></li>
<li><a href='#MUCH_merge'><p>MUCH Merge</p></a></li>
<li><a href='#process_raw_experiments'><p>Process raw experimental data</p></a></li>
<li><a href='#simulate_and_merge'><p>Simulate the MVG and merge the HEMs</p></a></li>
<li><a href='#T2080_code2name'><p>T2080 HEM codes to HEM names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools to Merge Hardware Event Monitors (HEMs) Coming from
Separate Subexperiments into One Single Dataframe</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of two tools to merge Hardware Event Monitors (HEMs) from different subexperiments. Hardware Reading and Merging (HRM), which uses order statistics to merge; and MUlti-Correlation HEM (MUCH) which merges using a multivariate normal distribution. The reference paper for HRM is: S. Vilardell, I. Serra, R. Santalla, E. Mezzetti, J. Abella and F. J. Cazorla, "HRM: Merging Hardware Event Monitors for Improved Timing Analysis of Complex MPSoCs," in IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 39, no. 11, pp. 3662-3673, Nov. 2020, &lt;<a href="https://doi.org/10.1109%2FTCAD.2020.3013051">doi:10.1109/TCAD.2020.3013051</a>&gt;. For MUCH: S. Vilardell, I. Serra, E. Mezzetti, J. Abella, and F. J. Cazorla. 2021. "MUCH: exploiting pairwise hardware event monitor correlations for improved timing analysis of complex MPSoCs". In Proceedings of the 36th Annual ACM Symposium on Applied Computing (SAC '21). Association for Computing Machinery. &lt;<a href="https://doi.org/10.1145%2F3412841.3441931">doi:10.1145/3412841.3441931</a>&gt;. This work has been supported by the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No. 772773).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, purrr, tidyr, stringr, rlang, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DT, knitr, rmarkdown, devtools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-13 09:59:59 UTC; Sergi Vilardell</td>
</tr>
<tr>
<td>Author:</td>
<td>Sergi Vilardell [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sergi Vilardell &lt;sergi.vilardell@bsc.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-13 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='code2hem'>Code to HEM name</h2><span id='topic+code2hem'></span>

<h3>Description</h3>

<p><code>code2hem</code> returns the name of the HEM corresponding to the code of the T2080 manual.
When gathering experimental data the captured HEMs will be coded with a number.
This functions transforms the number into the reference name in the T2080 manual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code2hem(cod = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code2hem_+3A_cod">cod</code></td>
<td>
<p>HEM code on the T2080 manual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the name of the HEM that corresponds to the input code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- 1
hem &lt;- code2hem(code)
hem

</code></pre>

<hr>
<h2 id='correlation_matrix'>Compute correlation matrix</h2><span id='topic+correlation_matrix'></span>

<h3>Description</h3>

<p>Compute correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_matrix(splitted_data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation_matrix_+3A_splitted_data">splitted_data</code></td>
<td>
<p>Sample data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a merged dataframe as stated in the description
</p>


<h3>References</h3>

<p>S. Vilardell, I. Serra, R. Santalla, E. Mezzetti, J. Abella and F. J. Cazorla, &quot;HRM: Merging Hardware Event Monitors for Improved Timing Analysis of Complex MPSoCs,&quot; in IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 39, no. 11, pp. 3662-3673, Nov. 2020, &lt;doi:10.1109/TCAD.2020.3013051&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_pmcs &lt;- 6
data_much &lt;- mergingTools::process_raw_experiments(data = data_much_raw_vignette,
                                                   n_pmcs = n_pmcs)
cor_matrix &lt;- mergingTools::correlation_matrix(splitted_data = data_much)
</code></pre>

<hr>
<h2 id='data_hrm_raw_vignette'>Data generated for HRM merging</h2><span id='topic+data_hrm_raw_vignette'></span>

<h3>Description</h3>

<p>Data from a hardware platform experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_hrm_raw_vignette
</code></pre>


<h3>Format</h3>

<p>An object of class dataframe
</p>

<hr>
<h2 id='data_much_raw_vignette'>Data generated for MUCH merging</h2><span id='topic+data_much_raw_vignette'></span>

<h3>Description</h3>

<p>Data from a hardware platform experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_much_raw_vignette
</code></pre>


<h3>Format</h3>

<p>An object of class dataframe
</p>

<hr>
<h2 id='generate_mvg_params'>Generate multivariate Gaussian distribution parameters</h2><span id='topic+generate_mvg_params'></span>

<h3>Description</h3>

<p><code>generate_mvg_params</code> takes as input the experimental data along its correlation matrix to estimate the Sigma matrix and the vector of means to compute the multivariate Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_mvg_params(splitted_data = NULL, cor_matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_mvg_params_+3A_splitted_data">splitted_data</code></td>
<td>
<p>Splitted experimental data.</p>
</td></tr>
<tr><td><code id="generate_mvg_params_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>Correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the parameters of the multivariate Gaussian distributions as well as a list of concatenated HEM readings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_pmcs &lt;- 6
data_much &lt;- mergingTools::process_raw_experiments(data = data_much_raw_vignette,
                                                   n_pmcs = n_pmcs)
cor_matrix &lt;- mergingTools::correlation_matrix(splitted_data = data_much)
dep_lvl &lt;- 0.85
# Remove the HEMs which are linearly dependant on other HEMs
cor_matrix_independent &lt;- mergingTools::get_independent_matrix(cor_matrix = cor_matrix,
                                                               dep_lvl = dep_lvl)
mvg_params &lt;- mergingTools::generate_mvg_params(splitted_data = data_much,
                                                cor_matrix = cor_matrix_independent)
</code></pre>

<hr>
<h2 id='get_independent_matrix'>Generate independent HEMs</h2><span id='topic+get_independent_matrix'></span>

<h3>Description</h3>

<p>There may be some HEMs which are linear dependent on another HEM.
This produces conflicts when generating the multivariate Gaussian distribution as the Sigma matrix will not be invertible, causing an error.
To avoid this, <code>get_independent_matrix</code> tells the user which HEMs are independent so they can choose which HEMs to use.
To do so the user must input the maximum correlation between HEMs by <code>dep_lvl</code>.
If <code>dep_lvl</code> is too high (&gt;0.95) the user may leave very dependent HEMs and thus the Sigma matrix will not be invertible.
We advise the user to lower the <code>dep_lvl</code> until the Sigma matrix is invertible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_independent_matrix(cor_matrix = NULL, dep_lvl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_independent_matrix_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>Correlation matrix</p>
</td></tr>
<tr><td><code id="get_independent_matrix_+3A_dep_lvl">dep_lvl</code></td>
<td>
<p>Dependency level allowed. A number between 0 and 1 indicating the maximum correlation allowed between HEMs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of independent HEMs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_pmcs &lt;- 6
data_much &lt;- mergingTools::process_raw_experiments(data = data_much_raw_vignette,
                                                  n_pmcs = n_pmcs)
cor_matrix &lt;- mergingTools::correlation_matrix(splitted_data = data_much)
dep_lvl &lt;- 0.85
# Remove the HEMs which are linearly dependant on other HEMs
cor_matrix_independent &lt;- mergingTools::get_independent_matrix(cor_matrix = cor_matrix,
                                                               dep_lvl = dep_lvl)
</code></pre>

<hr>
<h2 id='HRM_merge'>HRM merge</h2><span id='topic+HRM_merge'></span>

<h3>Description</h3>

<p><code>HRM_merge</code> merges HEMs coming from separate subexperiments into one single dataset. A Subexperiment is a measurement of a group of HEMs the size of the allowed PMCs by the machine. For HRM there is a designated anchor HEM that will be included on each subexperiment.
For more details check the reference paper below.
The input data must be in a specific format:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>1</strong>  </td><td style="text-align: left;"> <strong>2</strong>  </td><td style="text-align: left;"> <strong>3</strong>  </td><td style="text-align: left;">  <strong>1</strong> </td><td style="text-align: left;">  <strong>4</strong> </td><td style="text-align: left;">  <strong>5</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
30 </td><td style="text-align: left;"> 15 </td><td style="text-align: left;"> 20 </td><td style="text-align: left;"> 40 </td><td style="text-align: left;"> 10 </td><td style="text-align: left;"> 12</td>
</tr>
<tr>
 <td style="text-align: left;">
35 </td><td style="text-align: left;"> 16 </td><td style="text-align: left;"> 25 </td><td style="text-align: left;"> 25 </td><td style="text-align: left;"> 13 </td><td style="text-align: left;"> 15</td>
</tr>
<tr>
 <td style="text-align: left;">
32 </td><td style="text-align: left;"> 14 </td><td style="text-align: left;"> 30 </td><td style="text-align: left;"> 21 </td><td style="text-align: left;"> 11 </td><td style="text-align: left;"> 17</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where the numbers on top are the codes for the HEMs on the T2080. In this case we have two subexperiments: subexp1 = (<strong>1</strong>, <strong>2</strong>, <strong>3</strong>), subexp2 = (<strong>1</strong>, <strong>4</strong>, <strong>5</strong>);
and H1 is the anchor HEM that should be included in each subexperiment. The data will be processed into:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>H1</strong>  </td><td style="text-align: left;"> <strong>H2</strong>  </td><td style="text-align: left;"> <strong>H3</strong>  </td><td style="text-align: left;">  <strong>H1</strong> </td><td style="text-align: left;">  <strong>H4</strong> </td><td style="text-align: left;">  <strong>H5</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
30 </td><td style="text-align: left;"> 15 </td><td style="text-align: left;"> 20 </td><td style="text-align: left;"> 40 </td><td style="text-align: left;"> 10 </td><td style="text-align: left;"> 12</td>
</tr>
<tr>
 <td style="text-align: left;">
35 </td><td style="text-align: left;"> 16 </td><td style="text-align: left;"> 25 </td><td style="text-align: left;"> 25 </td><td style="text-align: left;"> 13 </td><td style="text-align: left;"> 15</td>
</tr>
<tr>
 <td style="text-align: left;">
32 </td><td style="text-align: left;"> 14 </td><td style="text-align: left;"> 30 </td><td style="text-align: left;"> 21 </td><td style="text-align: left;"> 11 </td><td style="text-align: left;"> 17</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The processing transforms the code of the HEMs to the reference name on the T2080 manual.
<code>merge_hems</code> sorts each subexperiment by the anchor HEM, and the substitutes the anchor HEM by its quantiles. If one inputs the example dataset, <code>merge_hems</code> will return:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>H1</strong> </td><td style="text-align: left;"> <strong>H2</strong> </td><td style="text-align: left;"> <strong>H3</strong> </td><td style="text-align: left;"> <strong>H4</strong> </td><td style="text-align: left;"> <strong>H5</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
21 </td><td style="text-align: left;"> 15 </td><td style="text-align: left;"> 20 </td><td style="text-align: left;"> 11 </td><td style="text-align: left;"> 17</td>
</tr>
<tr>
 <td style="text-align: left;">
31 </td><td style="text-align: left;"> 14 </td><td style="text-align: left;"> 30 </td><td style="text-align: left;"> 13 </td><td style="text-align: left;"> 15</td>
</tr>
<tr>
 <td style="text-align: left;">
40 </td><td style="text-align: left;"> 16 </td><td style="text-align: left;"> 25 </td><td style="text-align: left;"> 10 </td><td style="text-align: left;"> 12</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>HRM_merge(data = NULL, anchor_hem = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HRM_merge_+3A_data">data</code></td>
<td>
<p>Sample data.</p>
</td></tr>
<tr><td><code id="HRM_merge_+3A_anchor_hem">anchor_hem</code></td>
<td>
<p>Reference HEM for merging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a merged dataframe as stated in the description
</p>


<h3>References</h3>

<p>S. Vilardell, I. Serra, R. Santalla, E. Mezzetti, J. Abella and F. J. Cazorla, &quot;HRM: Merging Hardware Event Monitors for Improved Timing Analysis of Complex MPSoCs,&quot; in IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 39, no. 11, pp. 3662-3673, Nov. 2020, &lt;doi:10.1109/TCAD.2020.3013051&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mergingTools)
n_pmcs &lt;- 6
data_hrm &lt;- mergingTools::process_raw_experiments(data = data_hrm_raw_vignette, n_pmcs = n_pmcs)
merged_data &lt;- mergingTools::HRM_merge(data = data_hrm, anchor_hem = "PROCESSOR_CYCLES")
</code></pre>

<hr>
<h2 id='MUCH_merge'>MUCH Merge</h2><span id='topic+MUCH_merge'></span>

<h3>Description</h3>

<p><code>MUCH_merge</code> merges HEMs coming from separate subexperiments into one single dataset.
A Subexperiment is a measurement of a group of HEMs the size of the allowed PMCs by the machine.
For MUCH you need to measure each HEM against the rest of them. For instance, let's say that one has 2 PMCs and 3 HEMs to measure.
The input data coming from the experiments should look like this:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>1</strong>  </td><td style="text-align: left;"> <strong>2</strong>  </td><td style="text-align: left;"> <strong>1</strong>  </td><td style="text-align: left;">  <strong>3</strong> </td><td style="text-align: left;">  <strong>2</strong> </td><td style="text-align: left;">  <strong>3</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
30 </td><td style="text-align: left;"> 15 </td><td style="text-align: left;"> 20 </td><td style="text-align: left;"> 54 </td><td style="text-align: left;"> 15 </td><td style="text-align: left;"> 24 </td>
</tr>
<tr>
 <td style="text-align: left;">
35 </td><td style="text-align: left;"> 16 </td><td style="text-align: left;"> 25 </td><td style="text-align: left;"> 32 </td><td style="text-align: left;"> 10 </td><td style="text-align: left;"> 29 </td>
</tr>
<tr>
 <td style="text-align: left;">
32 </td><td style="text-align: left;"> 14 </td><td style="text-align: left;"> 30 </td><td style="text-align: left;"> 45 </td><td style="text-align: left;"> 9  </td><td style="text-align: left;"> 32 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where the numbers on top are the codes for the HEMs on the T2080. In this case we have three subexperiments:
subexp1 = (<strong>1</strong>, <strong>2</strong>), subexp2 = (<strong>1</strong>, <strong>3</strong>, <strong>6</strong>), subexp3 = (<strong>2</strong>, <strong>3</strong>);
The data will be processed into:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>H1</strong>  </td><td style="text-align: left;"> <strong>H2</strong>  </td><td style="text-align: left;"> <strong>H1</strong>  </td><td style="text-align: left;">  <strong>H3</strong> </td><td style="text-align: left;">  <strong>H2</strong> </td><td style="text-align: left;">  <strong>H3</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
30 </td><td style="text-align: left;"> 15 </td><td style="text-align: left;"> 20 </td><td style="text-align: left;"> 54 </td><td style="text-align: left;"> 15 </td><td style="text-align: left;"> 24</td>
</tr>
<tr>
 <td style="text-align: left;">
35 </td><td style="text-align: left;"> 16 </td><td style="text-align: left;"> 25 </td><td style="text-align: left;"> 32 </td><td style="text-align: left;"> 10 </td><td style="text-align: left;"> 29</td>
</tr>
<tr>
 <td style="text-align: left;">
32 </td><td style="text-align: left;"> 14 </td><td style="text-align: left;"> 30 </td><td style="text-align: left;"> 45 </td><td style="text-align: left;"> 9  </td><td style="text-align: left;"> 32</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The processing transforms the code of the HEMs to the reference name on the T2080 manual.
Now with this data, <code>MUCH_merge</code> computes the correlation matrix of all HEMs and with it it constructs a multivariate Gaussian distribution (MVG).
Then <code>MUCH_merge</code> uses the order statistics of the MVG to arrange the experimental data.
Therefore the final input will look like this:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>H1</strong>  </td><td style="text-align: left;"> <strong>H2</strong>  </td><td style="text-align: left;"> <strong>H3</strong>  </td>
</tr>
<tr>
 <td style="text-align: left;">
30 </td><td style="text-align: left;"> 15 </td><td style="text-align: left;"> 45 </td>
</tr>
<tr>
 <td style="text-align: left;">
35 </td><td style="text-align: left;"> 16 </td><td style="text-align: left;"> 54 </td>
</tr>
<tr>
 <td style="text-align: left;">
32 </td><td style="text-align: left;"> 14 </td><td style="text-align: left;"> 32 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>MUCH_merge(splitted_data = NULL, n_runs = NULL, n_sims = NULL, dep_lvl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MUCH_merge_+3A_splitted_data">splitted_data</code></td>
<td>
<p>Sample data as list of dataframes.</p>
</td></tr>
<tr><td><code id="MUCH_merge_+3A_n_runs">n_runs</code></td>
<td>
<p>Number of rows for the output merged data</p>
</td></tr>
<tr><td><code id="MUCH_merge_+3A_n_sims">n_sims</code></td>
<td>
<p>Number of simulations for the multivariate Gaussian distribution to find the optimal merge</p>
</td></tr>
<tr><td><code id="MUCH_merge_+3A_dep_lvl">dep_lvl</code></td>
<td>
<p>Dependency level allowed. A number between 0 and 1 indicating the maximum correlation allowed between HEMs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Take into consideration that the input data has readings on the same HEM for multiple subexperiments.
Therefore one must select the number of runs <code>n_runs</code> that they want the final output to have.
</p>


<h3>Value</h3>

<p>Returns a merged dataframe as stated in the description
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_pmcs &lt;- 6
data_much &lt;- mergingTools::process_raw_experiments(data = data_much_raw_vignette,
                                                   n_pmcs = n_pmcs)
merged_data &lt;- mergingTools::MUCH_merge(splitted_data = data_much,
                                        n_runs = 1000,
                                        n_sims = 10,
                                        dep_lvl = 0.85)
</code></pre>

<hr>
<h2 id='process_raw_experiments'>Process raw experimental data</h2><span id='topic+process_raw_experiments'></span>

<h3>Description</h3>

<p><code>process_raw_experiments</code> splits the data into separate dataframes.
The number of different dataframes is the number of subexperiments and the number of variables on each one is the number of PMCs.
The validation data is on the form of several subexperiments that don't need to be merged together.
The intent of the data is to provide information on how each HEM behaves when put against another HEM.
The validation data them is a collection of subexperiments where each HEM is put against each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_raw_experiments(data = NULL, n_pmcs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_raw_experiments_+3A_data">data</code></td>
<td>
<p>Validation data.</p>
</td></tr>
<tr><td><code id="process_raw_experiments_+3A_n_pmcs">n_pmcs</code></td>
<td>
<p>Number of PMCS used on the experiment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of dataframes as stated in the description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_pmcs &lt;- 6
data_much &lt;- mergingTools::process_raw_experiments(data = data_much_raw_vignette,
                                                   n_pmcs = n_pmcs)
</code></pre>

<hr>
<h2 id='simulate_and_merge'>Simulate the MVG and merge the HEMs</h2><span id='topic+simulate_and_merge'></span>

<h3>Description</h3>

<p><code>simulate_and_merge</code> takes as input the parameters of the multivariate Gaussian distribution and simulates multiple samples.
The number of samples is determined by <code>n_sims</code>.
On each simulation, each HEM of the experimental data is sorted from lowest to highest independently.
Then, the simulated MGD is used as the model to arrange the experimental data.
For instance, if on the MGD the 10th highest value of HEM 1 is paired with the 2nd highest and the 4th highest values of HEMs 2 and 3 respectively,
Then, we modify the experimental data to copy this arrangement.
After merging and arranging, the 10th highest value of HEM 1 on the experimental data will be paired with the 2nd highest and the 4th highest values of HEMs 2 and 3 respectively.
The algorithm does multiple simulations of the MGD and keeps the sample that gives the lowest error on the correlation matrix when the data is merged w.r.t. the correlation matrix of the experimental data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_and_merge(
  mvg_params = NULL,
  n_runs = NULL,
  n_sims = NULL,
  cor_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_and_merge_+3A_mvg_params">mvg_params</code></td>
<td>
<p>parameters from the multivariate Gaussian distribution</p>
</td></tr>
<tr><td><code id="simulate_and_merge_+3A_n_runs">n_runs</code></td>
<td>
<p>Number of rows for the output merged data</p>
</td></tr>
<tr><td><code id="simulate_and_merge_+3A_n_sims">n_sims</code></td>
<td>
<p>Number of simulations for the multivariate Gaussian distribution to find the optimal merge</p>
</td></tr>
<tr><td><code id="simulate_and_merge_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>Correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a merged dataframe as stated in the description
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_pmcs &lt;- 6
data_much &lt;- mergingTools::process_raw_experiments(data = data_much_raw_vignette,
                                                   n_pmcs = n_pmcs)
cor_matrix &lt;- mergingTools::correlation_matrix(splitted_data = data_much)
dep_lvl &lt;- 0.85
# Remove the HEMs which are linearly dependant on other HEMs
cor_matrix_independent &lt;- mergingTools::get_independent_matrix(cor_matrix = cor_matrix,
                                                               dep_lvl = dep_lvl)
mvg_params &lt;- mergingTools::generate_mvg_params(splitted_data = data_much,
                                                cor_matrix = cor_matrix_independent)
n_sims &lt;- 10
n_runs &lt;- 1000
merged_data &lt;- mergingTools::simulate_and_merge(mvg_params = mvg_params,
                                                n_runs = n_runs,
                                                n_sims = n_sims,
                                                cor_matrix = cor_matrix_independent)
</code></pre>

<hr>
<h2 id='T2080_code2name'>T2080 HEM codes to HEM names</h2><span id='topic+T2080_code2name'></span>

<h3>Description</h3>

<p>Dataset used to transform the codes from the T2080 manual into readable HEM names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T2080_code2name
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 262 rows and 2 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(T2080_code2name)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
