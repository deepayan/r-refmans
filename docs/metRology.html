<!DOCTYPE html><html><head><title>Help for package metRology</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metRology}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='# bootMSD '><p> Parametric bootstrap for median scaled difference</p></a></li>
<li><a href='# bootMSD-class '><p> Object returned by <code>bootMSD</code> and associated methods.</p></a></li>
<li><a href='# cplot '><p> Consistency plot for Key Comparisons</p></a></li>
<li><a href='# kplot '><p> Dot-and-bar plot for Key Comparisons</p></a></li>
<li><a href='# msd '><p> Median scaled difference</p></a></li>
<li><a href='# MSD-class '><p> Methods for the object returned by <code>msd</code>.</p></a></li>
<li><a href='# pmsd '><p> Median scaled difference probabilities and quantiles</p></a></li>
<li><a href='#.pmsd.xnorm'>
<p>Internal functions for package RKC.</p></a></li>
<li><a href='#algA'>
<p>Robust estimation of location and scale using Algorithm A</p></a></li>
<li><a href='#algS'>
<p>&lsquo;Algorithm S&rsquo; - robust estimate of pooled standard deviation</p></a></li>
<li><a href='#apricot'>
<p>Collaborative study results for fibre content in an apricot test material</p></a></li>
<li><a href='#barplot.mandel.kh'>
<p>Barplot of Mandel's h or k statistics</p></a></li>
<li><a href='#bkp'>
<p>Draw block plots from block plot objects</p></a></li>
<li><a href='#blockplot'>
<p>Generate a &ldquo;block plot&rdquo; - a histogram variant identifiying individual data points.</p></a></li>
<li><a href='#boxplot.mandel.kh'>
<p>Box plot of Mandel's h or k statistics</p></a></li>
<li><a href='#buildCor'>
<p>Functions to build correlation and covariance matrices.</p></a></li>
<li><a href='#chromium'>
<p>Chromium data for two different materials included in an interlaboratory study</p></a></li>
<li><a href='#contribs'>
<p>Extract contributions from an 'uncert' object.</p></a></li>
<li><a href='#cov.dellipse'>
<p>Constructs a covariance and location object for use in plotting data ellipses.</p></a></li>
<li><a href='#data.ellipse'>
<p>Construct data ellipses suitable for use with Youden plots.</p></a></li>
<li><a href='#derSimonian-Laird'>
<p>derSimonian-Laird estimator</p></a></li>
<li><a href='#drop1.uncert'>
<p>Single variable deletions from the uncertainty budget.</p></a></li>
<li><a href='#duewer.plot'>
<p>Duewer concordance/apparent precision plot</p></a></li>
<li><a href='#Extract.ilab'>
<p>The 'ilab' class.</p></a></li>
<li><a href='#gplot'>
<p>Grouped plots of type &quot;h&quot;</p></a></li>
<li><a href='#GUM'>
<p>Propagation of Measurement Uncertainty for Typical Metrology Applications</p>
Using the Methods Outlined in the GUM</a></li>
<li><a href='#GUM.H.1'>
<p>Example H.1 from the <em>Guide to the Expression of Uncertainty in Measurement</em></p></a></li>
<li><a href='#GUM.validate'>
<p>Monte Carlo Check on the Statistical Performance of GUM Uncertainty Intervals</p>
Using Attained Coverage Probability</a></li>
<li><a href='#ilab-class'>
<p>The 'ilab' class.</p></a></li>
<li><a href='#LCS'><p>LCS: Largest consistent subset</p></a></li>
<li><a href='#loc.est-class'><p>The location estimate class</p></a></li>
<li><a href='#M-estimators'>
<p>M- and MM-estimators for location.</p></a></li>
<li><a href='#Mandel-h'>
<p>Mandel's h statistic.</p>
</p></a></li>
<li><a href='#Mandel-k'>
<p>Mandel's k statistic.</p></a></li>
<li><a href='#Mandel-Paule'><p>Mandel-Paule calculation</p></a></li>
<li><a href='#mandel.h'>
<p>Calculate Mandel's h statistics for replicate observations</p></a></li>
<li><a href='#mandel.k'>
<p>Calculate Mandel's k statistics for replicate observations</p></a></li>
<li><a href='#mandel.kh'>
<p>Calculate Mandel's h and k statistics for replicate observations</p></a></li>
<li><a href='#methods.ilab'>
<p>Methods for the 'ilab' class.</p></a></li>
<li><a href='#metRology_pkg-internal'><p>Internal metRology objects</p></a></li>
<li><a href='#metRology-package'>
<p>Support for Metrological Applications</p></a></li>
<li><a href='#mle.1wre'>
<p>Vangel-Rukhin Maximum Likelihood Estimate</p></a></li>
<li><a href='#Pb'>
<p>Lead in wine</p></a></li>
<li><a href='#plot.d.ellipse'>
<p>Plot data ellipses</p></a></li>
<li><a href='#plot.mandel.kh'>
<p>Classical plots of Mandel's statistics.</p></a></li>
<li><a href='#plot.uncert'>
<p>Plot method for 'uncert' objects</p></a></li>
<li><a href='#plot.uncertMC'>
<p>Plot method for 'uncertMC' objects</p></a></li>
<li><a href='#potassium'>
<p>Potassium data for two different materials included in an interlaboratory study</p></a></li>
<li><a href='#rbind.ilab'>
<p>Combine 'ilab' objects</p></a></li>
<li><a href='#REML location estimate'>
<p>Restricted maximum likelihood estimate of location</p></a></li>
<li><a href='#RMstudy'>
<p>Collaborative study results for metals in a reference material certification study</p></a></li>
<li><a href='#Scaled t distribution'>
<p>Scaled and shifted t distribution.</p></a></li>
<li><a href='#Triangular'>
<p>The triangular distribution.</p></a></li>
<li><a href='#uncert'>
<p>Uncertainty estimation functions</p></a></li>
<li><a href='#uncert-class'>
<p>The 'uncert' class</p></a></li>
<li><a href='#uncertMC'>
<p>Monte Carlo evaluation of measurement uncertainty.</p></a></li>
<li><a href='#uncertMC-class'>
<p>The 'uncertMC' class</p></a></li>
<li><a href='#update.uncert'>
<p>Update and recalculate an uncertainty estimate</p></a></li>
<li><a href='#vr.mle'>
<p>Vangel-Rukhin Maximum Likelihood Estimate</p></a></li>
<li><a href='#welch.satterthwaite'>
<p>Welch-Satterthwaite effective degrees of freedom</p></a></li>
<li><a href='#xs.plot'>
<p>Mean/Standard deviation plot with confidence region.</p></a></li>
<li><a href='#youden.plot'>
<p>Youden plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9-28-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-09-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Support for Metrological Applications</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen L R Ellison &lt;s.ellison@lgc.co.uk&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen L R Ellison &lt;s.ellison@lgcgroup.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), base, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, MASS, numDeriv, robustbase</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides classes and calculation and plotting functions 
 for metrology applications, including measurement uncertainty estimation
 and inter-laboratory metrology comparison studies. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/metrology/">https://r-forge.r-project.org/projects/metrology/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>metrology</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>128</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2018-09-04 21:35:58</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-09-10 08:30:03 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-09-04 21:50:17 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='+20bootMSD+20'> Parametric bootstrap for median scaled difference </h2><span id='topic+bootMSD'></span><span id='topic+bootMSD.MSD'></span><span id='topic+bootMSD.default'></span>

<h3>Description</h3>

<p>Generates a parametric bootstrap for the median of scaled differences 
from each point in a data set to all other points..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>        bootMSD(x, ...)

        ## Default S3 method:
bootMSD(x, s = mad, B = 3000, probs = c(0.95, 0.99), 
                method = c("rnorm", "lhs"), keep = FALSE, labels = names(x), ...)

        ## S3 method for class 'MSD'
bootMSD(x, B = 3000, probs = c(0.95, 0.99), 
                method = c("rnorm", "lhs"), keep = FALSE, labels = names(x), ...)
	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20bootMSD+2B20_+3A_x">x</code></td>
<td>

<p>An R object. For the default method, a vector of observations. For the <code>MSD</code>
method, an object of class <code>"MSD"</code>. For <code>print</code>, <code>summary</code> and <code>plot</code>
methods, an object of class <code>"bootMSD"</code>. 
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD+2B20_+3A_s">s</code></td>
<td>
<p>Either a function returning an estimate of scale for <code>x</code> or a vector of 
length <code>length(x)</code> of standard errors or standard uncertainties in 
<code>x</code>.</p>
</td></tr>
<tr><td><code id="+2B20bootMSD+2B20_+3A_b">B</code></td>
<td>

<p>Scalar number of bootstrap replicates.
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD+2B20_+3A_probs">probs</code></td>
<td>

<p>Vector of probabilities at which to calculate upper quantiles. Passed to
<code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD+2B20_+3A_method">method</code></td>
<td>

<p>Character value describing the simulation method. 
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD+2B20_+3A_keep">keep</code></td>
<td>

<p>If <code>keep == TRUE</code> the individual bootstrap replicates are retained.
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD+2B20_+3A_labels">labels</code></td>
<td>

<p>Character vector of labels for individual values.
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD+2B20_+3A_...">...</code></td>
<td>
<p>Parameters passed to other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bootMSD</code> calculates a parametric bootstrap simulation (or Monte carlo simulation)
of the results of <code><a href="#topic+msd">msd</a></code> applied to data. This allows individual case-specific 
quantiles and <em>p</em>-values to be estimated that allow for different standard errors 
(or standard uncertainties) <code>s</code>. 
</p>
<p>The sampling method is currently either sampling from <code>rnorm</code> or by latin hypercube sampling
using <code>lhs</code>.
</p>
<p>Individual upper quantiles for probabilities <code>probs</code> and <em>p</em>-values are estimated 
directly from the bootstrap replicates. Quantiles use <code><a href="stats.html#topic+quantile">quantile</a></code>. <em>p</em>-values 
are estimated from the proportion of replicates that exceed the observed MSD calculated by 
<code><a href="#topic+msd">msd</a></code>. Note that the <code>print</code> method for the <code>summary</code> object does 
not report zero proportions as identically zero. 	
</p>


<h3>Value</h3>

<p>An object of class &quot;bootMSD&quot;, consisting of a vector of length <code>length(x)</code> of median 
scaled absolute deviations for each observation, with attributes:
</p>

<ul>
<li><p>msdvector of raw calculated MSD values calculated by <code><a href="#topic+msd">msd</a></code>
</p>
</li>
<li><p>labelscharacter vector of labels, by default taken from <code>x</code>
</p>
</li>
<li><p>probsvextor of probabilities supplied and used for quantiles
</p>
</li>
<li><p>critical.valuesmatrix of quantiles. Each row corresponds to a probability 
in <code>probs</code> and each column to an individual data point.
</p>
</li>
<li><p>pvals<em>p</em>-values estimated as the observed proportion of
simulated values exceeding the MSD value calculated by <code>msd</code>.
</p>
</li>
<li><p>BNumber of bootstrap replicates used.
</p>
</li>
<li><p>methodThe sampling method used by the parametric bootstrap.
</p>
</li>
<li><p>tIf <code>keep == TRUE</code>, the individual bootstrap replicates 
generated by <code>bootMSD</code>. Set to <code>NA</code> if <code>keep == FALSE</code>.
</p>
</li></ul>

<p>Summary, print and plot methods are provided for the class; see <code><a href="#topic+bootMSD-class">bootMSD-class</a></code>. 
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msd">msd</a></code>, <code><a href="#topic+bootMSD-class">bootMSD-class</a></code>, <code><a href="#topic+print.bootMSD">print.bootMSD</a></code>, 
<code><a href="#topic+plot.bootMSD">plot.bootMSD</a></code>, <code><a href="#topic+summary.bootMSD">summary.bootMSD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Pb)
  ## Not run: 
  #Default method:
  set.seed(1023)
  boot.Pb.default &lt;- bootMSD(Pb$value, Pb$u)  # Uses individual standard uncertainties
  summary(boot.Pb.default)
  
  
  #Method for MSD object:
  msd.Pb&lt;-msd(Pb$value, Pb$u)  # Uses individual standard uncertainties
  boot.Pb &lt;- bootMSD(msd.Pb, B=5000)
  	#Increased replication compared to default
  summary(boot.Pb)
  
  # NOTE: The default summary gives individual observation p-values. 
  # To correct for multiple comparisons, apply 
  # a suitable p-value adjustment:
  summary(boot.Pb, p.adjust="holm")

  
## End(Not run)


</code></pre>

<hr>
<h2 id='+20bootMSD-class+20'> Object returned by <code>bootMSD</code> and associated methods.</h2><span id='topic+bootMSD-class'></span><span id='topic+print.bootMSD'></span><span id='topic+summary.bootMSD'></span><span id='topic+print.summary.bootMSD'></span><span id='topic+barplot.bootMSD'></span><span id='topic+plot.bootMSD'></span>

<h3>Description</h3>

<p>The object class returned by <code><a href="#topic+bootMSD">bootMSD</a></code> and associated
<code>print</code>, <code>summary</code>, and plotting classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>       ## S3 method for class 'bootMSD'
print(x, ...)

       ## S3 method for class 'bootMSD'
plot(x, ...)

       ## S3 method for class 'bootMSD'
barplot(height, ylab="MSD", names.arg=height$labels, 
	crit.vals=TRUE, lty.crit=c(2,1), col.crit=2, lwd.crit=c(1,2), ... )

       ## S3 method for class 'bootMSD'
summary(object, p.adjust="none", ...) 

       ## S3 method for class 'summary.bootMSD'
print(x, digits=3, ..., 
		signif.stars = getOption("show.signif.stars"), 
		signif.legend=signif.stars) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_x">x</code></td>
<td>

<p>An R object. For <code>print.bootMSD</code> and <code>plot.bootMSD</code>, an object 
of class <code>"bootMSD"</code>. For <code>print.summary.bootMSD</code>, an object 
of class <code>"summary.bootMSD"</code>.
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_height">height</code></td>
<td>

<p>An object of class <code>"bootMSD"</code>. 
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_object">object</code></td>
<td>

<p>An object of class <code>"MSD"</code>. 
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_p.adjust">p.adjust</code></td>
<td>

<p>Multiple correction method for calculated <em>p</em>-values, passed to
<code><a href="stats.html#topic+p.adjust">p.adjust</a></code>. 
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_ylab">ylab</code></td>
<td>

<p>Label for vertical axis, passed to <code>barplot</code>
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_names.arg">names.arg</code></td>
<td>

<p>Labels for individual bars in bar plot, passed to <code>barplot</code>. If <code>names(height)</code> 
is <code>NULL</code>, bars are numbered. 
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_crit.vals">crit.vals</code></td>
<td>

<p>If <code>TRUE</code>, individual critical values based on observation-specific 
bootstrap quantiles are added to the plot. These are taken from <code>critical.values</code>
in the supplied <code>bootMSD</code> object.
</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_lty.crit">lty.crit</code>, <code id="+2B20bootMSD-class+2B20_+3A_col.crit">col.crit</code>, <code id="+2B20bootMSD-class+2B20_+3A_lwd.crit">lwd.crit</code></td>
<td>

<p>Vectors of line style parameters for plotted critical values, passed to 
<code><a href="graphics.html#topic+segments">segments</a></code>. Recycled to the length of <code>critical.values</code>
in the supplied <code>bootMSD</code> object.</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_digits">digits</code></td>
<td>
<p>integer; passed to <code>print</code>. The minimum number of
significant digits to be printed in values. Change to <code>NULL</code> for default.</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical; if <code>TRUE</code>, P-values are additionally encoded
visually as &lsquo;significance stars&rsquo; in order to help scanning of
long coefficient tables.  Defaults to the <code>show.signif.stars</code> 
slot of <code>options</code>.</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_signif.legend">signif.legend</code></td>
<td>
<p>logical; if <code>TRUE</code>, a legend for the &lsquo;significance
stars&rsquo; is printed provided <code>signif.stars == TRUE</code>.</p>
</td></tr>
<tr><td><code id="+2B20bootMSD-class+2B20_+3A_...">...</code></td>
<td>
<p>Parameters passed to other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>plot</code> method is an alias for the <code>barplot</code> method. 
For the plot methods, quantiles for each point are taken directly from the quantiles 
calulated by <code><a href="#topic+bootMSD">bootMSD</a></code> and retained in the returned object. 
</p>
<p>For the <code>summary</code> method, <em>p</em>-values are initially calculated as the observed 
proportion of simulated values exceeding the MSD value calculated by <code>msd</code>. The
summary method additionally returns <em>p</em>-values  after adjustment
for multiple comparisons using the adjustment method specified. 
</p>
<p>The <code>print</code> method for the <code>summary.bootMSD</code> object prints the summary as a data 
frame adjusted with columns for the calculated MSD values, data-specific upper quantiles 
(one column for each probability supplied to <code>bootMSD</code> and the <em>p</em>-values 
after adjustment for multiple comparisons based on the proportion of simulated values 
exceeding the observed MSD. Where that proportion is zero, the summary replaces the 
raw zero proportion with <code>1/B</code>, corrects that proportion using the requested 
adjustment method, andreports the <em>p</em>-value as less than (&quot;&lt;&quot;) the resulting 
adjusted value. 
</p>


<h3>Value</h3>

<p>The <code>print</code> method returns the object, invisibly.
</p>
<p>The <code>plot</code> and <code>barplot</code> methods return the values at the midpoint of each bar.
</p>
<p>The <code>summary</code> method returns an object of class <code>"summary.bootMSD"</code> which 
is a list with members:
</p>

<ul>
<li><p>msdCalculated MSD values from <code>msd</code>
</p>
</li>
<li><p>labelscharacter vector of labels for individual data points
</p>
</li>
<li><p>probsProbabilities used for quantiles
</p>
</li>
<li><p>critical.valuesmatrix of quantiles. Each row corresponds to a probability 
in <code>probs</code> and each column to an individual data point.
</p>
</li>
<li><p>pvals<em>p</em>-values estimated as the observed proportion of
simulated values exceeding the MSD value calculated by <code>msd</code>.
</p>
</li>
<li><p>p.adjustCharacter value containing the name of the p-value adjustment method used.
</p>
</li>
<li><p>p.adj <em>p</em>-values adjusted using the given <em>p</em>-value adjustment method 
specified by <code>p.adjust</code>.
</p>
</li>
<li><p>BNumber of bootstrap replicates used.
</p>
</li>
<li><p>methodThe sampling method used by the parametric bootstrap.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msd">msd</a></code>, <code><a href="#topic+qmsd">qmsd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  data(Pb)
  msd.Pb&lt;-msd(Pb$value, Pb$u)  # Uses individual standard uncertainties

  set.seed(1023)
  boot.Pb &lt;- bootMSD(msd.Pb)
  summary(boot.Pb)

  # The default summary gives individual observation p-values. To 
  # avoid over-interpretation for the study as a whole, 
  # apply a sensible p-value adjustment:
  summary(boot.Pb, p.adjust="holm")

  plot(boot.Pb, crit=TRUE)

  
## End(Not run)
</code></pre>

<hr>
<h2 id='+20cplot+20'> Consistency plot for Key Comparisons </h2><span id='topic+cplot'></span>

<h3>Description</h3>

<p>Produces a consistency plot for typical metrology comparison data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cplot(x,u,labels=names(x), p.adjust.method="holm", ordered=TRUE,
        breaks=c(0,0.001,0.01, 0.05, 0.1,1), 
        col=terrain.colors(length(breaks)-1), log.p=FALSE,
        main=paste("Consistency map -", deparse(substitute(x))), 
        subtitle=NULL, key=FALSE, 
        key.width=2.54, key.height=0.6,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20cplot+2B20_+3A_x">x</code></td>
<td>
<p>Vector of reported values</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_u">u</code></td>
<td>
<p>Vector of length <code>length(x)</code> of standard uncertainties</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_labels">labels</code></td>
<td>
<p>Vector of of length <code>length(x)</code> labels for x-axis marks.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>p-value adjustment method; passed to <code>p.adjust</code>.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_ordered">ordered</code></td>
<td>
<p>If <code>TRUE</code> (the default) observations are arranged in ascending order of <code>x</code>.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_breaks">breaks</code></td>
<td>
<p>Vector of breaks; passed to <code>image</code>.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_col">col</code></td>
<td>
<p>Vector of colours of length <code>length(breaks)-1</code>. Passed to <code>image</code>.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_log.p">log.p</code></td>
<td>
<p>If <code>TRUE</code>, the plot shows <code>-log_10(p)</code>.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_main">main</code>, <code id="+2B20cplot+2B20_+3A_subtitle">subtitle</code></td>
<td>
<p>Main and subtitle for plot.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_key">key</code></td>
<td>
<p>If <code>TRUE</code> a key is added to the plot.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_key.width">key.width</code>, <code id="+2B20cplot+2B20_+3A_key.height">key.height</code></td>
<td>
<p>Width and height of key, if plotted. See details for specification.</p>
</td></tr>
<tr><td><code id="+2B20cplot+2B20_+3A_...">...</code></td>
<td>
<p>Graphical parameters passed to <code>image</code>. If present, <code>cex.axis</code> is passed 
to <code>axis</code> for main figure axes only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the (square, symmetric matrix of) optionally adjusted p-values for a 
two-tailed z-test of <code>|x[i]-x[j]|/sqrt(u[i]^2+u[j]^2)</code> against zero
and plots the p-values as an image.
</p>
<p><code>p.adjust</code> is called prior to plotting to correct for multiple comparisons. 
To suppress adjustment, set <code>p.adjust.method="none"</code>. 
</p>
<p>key.height is a fraction of the figure region height. key.width is the width 
of the key area in cm, unless under 1, in which case it is interpreted as a 
fraction of the plot region width.
</p>
<p>If <code>log.p</code> is <code>TRUE</code> and <code>subtitle</code> <code>NULL</code>, 
a subtitle indicating the use of log.p is added to the plot, 
</p>


<h3>Value</h3>

<p>Invisibly returns a matrix of pairwise test p-values or, if <code>log.p==TRUE</code>,
matrix of <code>-log_10(p)</code>.	
</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+p.adjust">p.adjust</a></code>, <code><a href="graphics.html#topic+image">image</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Pb)
  cplot(Pb$value, Pb$u, key=TRUE)

</code></pre>

<hr>
<h2 id='+20kplot+20'> Dot-and-bar plot for Key Comparisons </h2><span id='topic+kplot'></span><span id='topic+kplot.default'></span><span id='topic+kplot.ilab'></span><span id='topic+kpoints'></span>

<h3>Description</h3>

<p>Produces a dot plot of typical metrology comparison data (value/uncertainty) with 
error bars, assigned value and uncertainty and optional percentage deviation axis or 
marginal density
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kplot(x, ...)

## Default S3 method:
kplot(x,U=NULL, labels=names(x),  assigned=NULL, U.assigned=NULL, 
	U.lo=U, U.hi=U, k=2, strata=NULL,
	do.percent=!is.null(assigned) &amp;&amp; !do.pdf, 
	ordered=TRUE, order.strata=levels(strata),
	xlim=c(0.5, length(x)+0.5), ylim,
	main=NULL, xlab=NULL, ylab=NULL,
	axis.main=2, axis.pct=4, at=1:length(x), at.main=NULL,
	cex.axis=0.8, las=2, las.pct=1, ylab.line=2.5, 
	ylab.line.pct=2.1, ci.width=0.03, col.ci=par("fg"), 
	lty.ci=par("lty"), lwd.ci=par("lwd"), pch=21, 
	col=par("fg"), bg="white", add.outliers=FALSE, 
	outlier.offset=0.2, mar=NULL, box=TRUE,
	do.pdf=FALSE, do.individual.pdf=do.pdf, 
	col.pdf=par("fg"), lwd.pdf=1, lty.pdf=1,
	do.total.pdf=TRUE, col.total.pdf=col.pdf[1], 
	lwd.total.pdf=2, lty.total.pdf=1, n.pdf=200, 
	pdf.layout=c(4,1), pdf.scale=0.7, pdf.offset=0.05, 
	xlim.pdf, pdf.axis=FALSE, las.pdf=0, 
	mgp.pdf=c(3,0.5,0), ...)
	
## S3 method for class 'ilab'
kplot(x, ...)

kpoints(x,U=NULL, labels=names(x), U.lo=U, U.hi=U, k=2, 
	strata=NULL, ordered=TRUE, order.strata=levels(strata),
	at=1:length(x), ci.width=0.03, col.ci=par("fg"), 
	lty.ci=par("lty"), lwd.ci=par("lwd"), pch=21, 
	col=par("fg"), bg="white", add.outliers=FALSE, 
	outlier.offset=0.2, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20kplot+2B20_+3A_x">x</code></td>
<td>
<p>an R object. For the default method, a vector of reported values. For the 
ilab method, an object of class &lsquo;ilab&rsquo;</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_u">U</code></td>
<td>
<p>Vector of length <code>length(x)</code> of expanded uncertainties</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_labels">labels</code></td>
<td>
<p>Vector of of length <code>length(x)</code> labels for x-axis marks. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_assigned">assigned</code></td>
<td>
<p>Assigned value for the comparison. Plotted as a horizontal line on the plot.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_u.assigned">U.assigned</code></td>
<td>
<p>Expanded uncertainty for the assigned value</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_u.lo">U.lo</code>, <code id="+2B20kplot+2B20_+3A_u.hi">U.hi</code></td>
<td>
<p>Vectors of of length <code>length(x)</code> of lower and upper 
limits for the uncertainty intervals around the reported 
values, to allow asymmetric intervals. Both default to U. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_k">k</code></td>
<td>
<p>Coverage factor originally used in calculating U. Required only if 
<code>do.pdf=TRUE</code>, as k is used to calculate standard uncertainties 
from U. k can be a scalar (recycled to length  <code>length(x)</code> 
if necessary) or a vector of length of length <code>length(x)</code>. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_strata">strata</code></td>
<td>
<p>A Factor identifying subsets of the data. Currently not implemented.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_do.percent">do.percent</code></td>
<td>
<p>Logical indicating whether percentage deviation should be 
plotted as a secondary axis. Defaults to <code>TRUE</code> if an assigned 
value is provided and <code>FALSE</code> if there is no assigned value 
or if a marginal density is  required via <code>do.pdf=TRUE</code>.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_ordered">ordered</code></td>
<td>
<p>If <code>TRUE</code>, values are plotted in ascending order.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_order.strata">order.strata</code></td>
<td>
<p>Character vector showing the order of plotting for strata. 
Currently not implemented.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_xlim">xlim</code>, <code id="+2B20kplot+2B20_+3A_ylim">ylim</code></td>
<td>
<p>Plot limits as in <code>plot.default</code>.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_main">main</code>, <code id="+2B20kplot+2B20_+3A_xlab">xlab</code>, <code id="+2B20kplot+2B20_+3A_ylab">ylab</code></td>
<td>
<p>Titles; see <code>?title</code> for details.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_axis.main">axis.main</code>, <code id="+2B20kplot+2B20_+3A_axis.pct">axis.pct</code></td>
<td>
<p>Integers specifying on which side of the plot the relevant axis is to
be drawn, passed to <code>axis</code> as <code>side</code>. The axis is placed as for follows: 
1=below, 2=left, 3=above and 4=right. The main axis (<code>axis.main</code>) is provided 
in the same units as <code>x</code>; the percentage axis (<code>axis.pct</code>) shows 
corresponding percentage deviation.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_at">at</code></td>
<td>
<p>Vector of x-axis locations for the data points, x-axis tick marks and labels. 
Defaults to <code>1:length(x)</code>. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_at.main">at.main</code></td>
<td>
<p>The points at which tick-marks are to be drawn on the main (y) axis. 
Passed to <code>axis</code> via <code>at</code>. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation
relative to the current setting of 'cex'. Passed to <code>axis</code>.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_las">las</code>, <code id="+2B20kplot+2B20_+3A_las.pct">las.pct</code></td>
<td>
<p>Integers defining x- and y axis and percentage axis label
orientation; see <code>par(las)</code>.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_ylab.line">ylab.line</code>, <code id="+2B20kplot+2B20_+3A_ylab.line.pct">ylab.line.pct</code></td>
<td>
<p>Margin lines for main and percentage axis titles. 
Passed to <code>axis</code>.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_ci.width">ci.width</code></td>
<td>
<p>Width of error bar terminators, passed to <code>arrows</code>.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_col.ci">col.ci</code>, <code id="+2B20kplot+2B20_+3A_lty.ci">lty.ci</code>, <code id="+2B20kplot+2B20_+3A_lwd.ci">lwd.ci</code></td>
<td>
<p>Graphical parameters for the error bars; passed 
to <code>arrows</code>. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_pch">pch</code>, <code id="+2B20kplot+2B20_+3A_col">col</code>, <code id="+2B20kplot+2B20_+3A_bg">bg</code></td>
<td>
<p>Graphical parameters for data points, passed to <code>points</code>. 
<code>bg</code> specifies the fill colour for <code>pch</code> from 21 to 25. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_add.outliers">add.outliers</code></td>
<td>
<p>If <code>TRUE</code>, points outside <code>ylim</code> are indicated as 
an arrow indicating the direction in which the omitted points lie, with 
a text label showing the reported value.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_outlier.offset">outlier.offset</code></td>
<td>
<p>X-offset (in x-axis units) specifying lateral location of outlier 
tet labels relative to x-axis location of the outlier indicator.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_mar">mar</code></td>
<td>
<p>Plot margins as in <code>par(mar)</code>. The default varies depending on 
<code>do.pct</code> and <code>do.pdf</code>.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_box">box</code></td>
<td>
<p>If <code>TRUE</code>, a box is drawn round the plot region.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_do.pdf">do.pdf</code></td>
<td>
<p>If <code>TRUE</code>, a marginal density and/or individual densities for the 
individual reported values are plotted based on the reported 
values <code>x</code> and standard uncertainties calculated as <code>U/k</code>.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_do.individual.pdf">do.individual.pdf</code></td>
<td>
<p>Logical controlling whether the individual densities 
are plotted as well as/instead of the combined density.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_col.pdf">col.pdf</code>, <code id="+2B20kplot+2B20_+3A_lwd.pdf">lwd.pdf</code>, <code id="+2B20kplot+2B20_+3A_lty.pdf">lty.pdf</code></td>
<td>
<p>Graphical parameters controlling the appearance of 
the marginal density plot(s). Vectors are permitted, allowing different 
styles for each individual pdf.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_do.total.pdf">do.total.pdf</code></td>
<td>
<p>Logical controlling whether the sum of individual densities 
is plotted.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_col.total.pdf">col.total.pdf</code>, <code id="+2B20kplot+2B20_+3A_lwd.total.pdf">lwd.total.pdf</code>, <code id="+2B20kplot+2B20_+3A_lty.total.pdf">lty.total.pdf</code></td>
<td>
<p>Graphical parameters controlling the 
appearance of the marginal density plot for the combined density. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_n.pdf">n.pdf</code></td>
<td>
<p>Number of points used to construct the marginal density.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_pdf.layout">pdf.layout</code></td>
<td>
<p>Vector of length 2 specifying the relative sizes of the main plot and 
marginal density plot. See <code>?layout</code> for details.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_pdf.scale">pdf.scale</code>, <code id="+2B20kplot+2B20_+3A_pdf.offset">pdf.offset</code></td>
<td>
<p>Offset and scaling factor used to control the location 
and height of the marginal density plot(s). </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_xlim.pdf">xlim.pdf</code></td>
<td>
<p>Controls the x-axis (i.e. the horizontal axis) for the marginal density 
plotting area. </p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_pdf.axis">pdf.axis</code></td>
<td>
<p>If <code>TRUE</code> and no other axis has been plotted to the right of the main plot, 
an axis is plotted with the marginal density.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_las.pdf">las.pdf</code>, <code id="+2B20kplot+2B20_+3A_mgp.pdf">mgp.pdf</code></td>
<td>
<p>Axis control parameters passed to <code>axis</code> to plot the axis for the 
marginal density.</p>
</td></tr>
<tr><td><code id="+2B20kplot+2B20_+3A_...">...</code></td>
<td>
<p>Parameters passed to other functions; currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>do.pdf=TRUE</code> a marginal density plot is added. This plot is constructed 
from a set of (currently) normal densities centred at <code>x</code> with standard 
deviation <code>U/k</code>.
</p>
<p>If a marginal density is plotted, <code>par("layout")</code> is changed to 
<code>pdf.layout</code>; otherwise, <code>par("layout")</code> is set to <code>matrix(1)</code>. 
Both override any previously set layout. <code>par("layout")</code> is preserved on exit.
</p>
<p>The &lsquo;ilab&rsquo; method passes all parameters in &lsquo;...&rsquo; to the default method
with default values for <code>x</code>, upper and lower bounds <code>U.lo</code> and <code>U.hi</code>, 
labels and title taken from the <code>ilab</code> object.
</p>
<p><code>kpoints</code> is a convenience function for adding points with confidence 
intervals to an existing plot. <code>kpoints</code> is not a generic function  
and requires a vector <code>x</code>. Note that <code>kpoints</code> does not check for 
the presence of a marginal density plot.
</p>


<h3>Value</h3>

<p>Invisibly returns a list with components:
</p>
<table>
<tr><td><code>order</code></td>
<td>
<p>The order for plotting the original data, as returned by <code>order</code>. </p>
</td></tr>
<tr><td><code>at</code></td>
<td>
<p> x-axis locations used, in plotting order. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+arrows">arrows</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Pb)
  kplot(Pb$value, Pb$U, assigned=2.99, U.assigned=0.06)
  kplot(Pb$value, Pb$U, assigned=2.99, U.assigned=0.06, do.pdf=TRUE)
	
  #Use of return value for annotation
  kp&lt;-kplot(Pb$value, Pb$U, assigned=2.99, U.assigned=0.06)
  text(kp$at, Pb$value-Pb$U, Pb$lab, srt=90, pos=4, cex=0.7)

</code></pre>

<hr>
<h2 id='+20msd+20'> Median scaled difference </h2><span id='topic+msd'></span>

<h3>Description</h3>

<p>Generates median of scaled differences from each point in a data set to all other points..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>        msd(x, s=mad , ...)
	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20msd+2B20_+3A_x">x</code></td>
<td>
<p>Vector of observations</p>
</td></tr>
<tr><td><code id="+2B20msd+2B20_+3A_s">s</code></td>
<td>
<p>Either a function returning an estimate of scale for <code>x</code> or a vector of 
length <code>length(x)</code> of standard errors or standard uncertainties in <code>x</code>.</p>
</td></tr>
<tr><td><code id="+2B20msd+2B20_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code>s</code> if <code>s</code> is a function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each observation <code>x[i]</code>, <code>msd</code> calculates the median of <code>|x[i]-x[j]|/sqrt(s[i]^2+s[j]^2), j!=i</code>,
that is, the median of differences divided by the estimated uncertainties of the distance.
</p>
<p>If <code>s</code> is a function, it is applied to <code>x</code> and replicated to length <code>length(x)</code>; if 
a scalar, it is replicated to length <code>length(x)</code>. 
</p>
<p>The median scaled difference is a measure of how &lsquo;far&rsquo; an individual observation is from 
the majority of the other values in the data set. As a rule of thumb, values above
2 are indicative of a suspect <code>(x[i], s[i])</code> data pair; that is, a value <code>x[i]</code> that 
is remote from a large fraction of the remaining data given its associated standard 
error or standard uncertainty <code>s[i]</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;MSD&quot;, consisting of a vector of length <code>length(x)</code> of median 
scaled absolute deviations for each observation, with attributes:
</p>
<table>
<tr><td><code>names</code></td>
<td>
<p>character vector of names, taken from <code>x</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>values supplied as <code>x</code></p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>values supplied as <code>s</code></p>
</td></tr>
</table>
<p>Print and plotting methods are currently provided for the <code>"MSD"</code> class; 
see <code><a href="#topic+MSD-class">MSD-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmsd">pmsd</a></code>, <code><a href="#topic+qmsd">qmsd</a></code>, <code><a href="#topic+MSD-class">MSD-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Pb)
  msd(Pb$value)  # Uses mad(Pb$value) as scale estimate
  msd(Pb$value, Pb$u)  # Scales differences using standard uncertainties

</code></pre>

<hr>
<h2 id='+20MSD-class+20'> Methods for the object returned by <code>msd</code>.</h2><span id='topic+MSD-class'></span><span id='topic+print.MSD'></span><span id='topic+plot.MSD'></span><span id='topic+barplot.MSD'></span>

<h3>Description</h3>

<p>Print and plotting methods for the <code>MSD</code> object class returned by <code><a href="#topic+msd">msd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>       ## S3 method for class 'MSD'
print(x, ...)

       ## S3 method for class 'MSD'
plot(x, type="h", ylab="MSD", ...)

       ## S3 method for class 'MSD'
barplot(height, ylab="MSD", names.arg=names(height), 
	crit.vals=TRUE, lty.crit=c(2,1), col.crit=2, lwd.crit=c(1,2), 
	probs=c(0.95, 0.99), n=length(height), ... )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20MSD-class+2B20_+3A_x">x</code>, <code id="+2B20MSD-class+2B20_+3A_height">height</code></td>
<td>

<p>Object of class <code>"MSD"</code>. 
</p>
</td></tr>
<tr><td><code id="+2B20MSD-class+2B20_+3A_type">type</code></td>
<td>

<p>The plot type. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>. 
</p>
</td></tr>
<tr><td><code id="+2B20MSD-class+2B20_+3A_ylab">ylab</code></td>
<td>

<p>Label for vertical axis, passed to <code>barplot</code>
</p>
</td></tr>
<tr><td><code id="+2B20MSD-class+2B20_+3A_names.arg">names.arg</code></td>
<td>

<p>Labels for individual bars in bar plot, passed to <code>barplot</code>. If <code>names(height)</code> 
is <code>NULL</code>, bars are numbered. 
</p>
</td></tr>
<tr><td><code id="+2B20MSD-class+2B20_+3A_crit.vals">crit.vals</code></td>
<td>

<p>If <code>TRUE</code>, horizontal lines at critical values are added to the plot. 
These are calculated by <code>link{qmsd}</code> based on supplied values of 
<code>probs</code>, <code>n</code> and <code>multiple</code>. 
</p>
</td></tr>
<tr><td><code id="+2B20MSD-class+2B20_+3A_lty.crit">lty.crit</code>, <code id="+2B20MSD-class+2B20_+3A_col.crit">col.crit</code>, <code id="+2B20MSD-class+2B20_+3A_lwd.crit">lwd.crit</code></td>
<td>

<p>Vectors of line style parameters for plotted critical values, passed to 
<code><a href="graphics.html#topic+segments">segments</a></code>. Recycled to the length of <code>critical.values</code>
in the supplied <code>bootMSD</code> object.</p>
</td></tr>
<tr><td><code id="+2B20MSD-class+2B20_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities at which critical values are drawn.</p>
</td></tr>
<tr><td><code id="+2B20MSD-class+2B20_+3A_n">n</code></td>
<td>
<p>integer number of observations for critical value calculation; passed to 
<code><a href="#topic+qmsd">qmsd</a></code>.</p>
</td></tr>
<tr><td><code id="+2B20MSD-class+2B20_+3A_...">...</code></td>
<td>
<p>Parameters passed to other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+msd">msd</a></code> for the object description.
</p>
<p>For the barplot method, critical values are &lsquo;single-observation&rsquo; quantiles. 
For use as an outlier test, use probabilities adjusted for multiple comparison;
for example, for the barplot method, consider raising the default <code>probs</code> 
to the power <code class="reqn">1/n</code>.
</p>


<h3>Value</h3>

<p>The <code>print</code> method returns the object, invisibly.
</p>
<p>The <code>plot</code> method returns NULL, invisibly.
</p>
<p>The <code>barplot</code> methods return the values at the midpoint of each bar.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msd">msd</a></code>, <code><a href="#topic+qmsd">qmsd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Pb)
  msd.Pb&lt;-msd(Pb$value, Pb$u)  # Uses individual standard uncertainties
  names(msd.Pb) &lt;- as.character(Pb$lab)
  
  plot(msd.Pb)

  barplot(msd.Pb)

</code></pre>

<hr>
<h2 id='+20pmsd+20'> Median scaled difference probabilities and quantiles </h2><span id='topic+pmsd'></span><span id='topic+qmsd'></span><span id='topic+dmsd'></span>

<h3>Description</h3>

<p>Cumulative lower tail probability and quantile for median of scaled differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	dmsd(q, n, method=c('fast', 'exact', 'even', 'asymp'), max.odd=199)
	
	pmsd(q, n, lower.tail = TRUE, 
		method=c('fast', 'exact', 'even', 'asymp'), max.odd=199)
	           
	qmsd(p, n, lower.tail = TRUE, 
		method=c('fast', 'exact', 'even', 'asymp'), max.odd=199)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20pmsd+2B20_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="+2B20pmsd+2B20_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="+2B20pmsd+2B20_+3A_n">n</code></td>
<td>
<p>Number of observations from which msd was calculated. Unused (and can be missing)
for <code>method="asymp"</code></p>
</td></tr>
<tr><td><code id="+2B20pmsd+2B20_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (the default), probabilities are P[X &lt;= x];
otherwise, P[X &gt; x]. </p>
</td></tr>
<tr><td><code id="+2B20pmsd+2B20_+3A_method">method</code></td>
<td>
<p>Calculation method. See details.</p>
</td></tr>
<tr><td><code id="+2B20pmsd+2B20_+3A_max.odd">max.odd</code></td>
<td>
<p>Highest odd <code>n</code> for which exact values are calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pmsd</code>, <code>dmsd</code> and <code>qmsd</code> return probabilities, densities and quantiles, respectively, 
for the median scaled difference applied to a single observation in a standard normal
distribution, where otehr values are also IID normal.
</p>
<p><code>n</code> is the number of observations in the data set of interest and <em>not</em> the degrees of 
freedom or number of differences (msd for a value x[i] in a set of <code>n</code> observations 
involves <code>n-1</code> scaled differences).
</p>
<p><code>n</code>, <code>p</code> and <code>q</code> are recycled to the length of the longest, as necessary.
</p>
<p><code>method</code> determines the method of calculation. 
For <code>method="fast"</code>, probabilities are calculated using monotonic spline 
interpolation on precalculated probabilities. <code>qmsd</code> with <code>method="fast"</code> is obtained 
by root-finding on the corresponding spline function using <code>uniroot</code>, and densities are 
estimated from the first derivative of the interpolating spline. This provides fast 
calculation, and values for most practical probabilities are within 10^-6 of exact calculations. 
For high probabilites and for low quantiles (below 0.48) at high <code>n</code>, fast quantile accuracy 
is poorer due to the very low function gradients in this regions, but is still guaranteed 
monotonic with <code>p</code>.
</p>
<p>For <code>method="exact"</code>, probabilities and densities are calculated using quadrature 
integration for an order statistic. For odd <code>n</code>, this requires a double integral. Values for 
odd <code>n</code> accordingly take about an order of magnitude longer to obtain than for even <code>n</code>. 
This can be slow (seconds for a vector of several hundred values of <code>q</code> on an Intel x86
machine running at 1-2GHz). <code>qmsd</code> with <code>method="exact"</code> is obtained by root-finding from 
<code>pmsd(..., method="excat")</code> using <code>uniroot</code>, and is over an order of magnitude slower than 
<code>pmsd</code> pmsd. 
</p>
<p>For <code>method="exact"</code>, asymptotic (large <code class="reqn">n</code>) probabilities, densities and quantiles are 
returned. <code>n</code> is unused and can be missing. 
</p>
<p>For <code>method="exact"</code>, odd <code>n</code> above <code>max.odd</code> are replaced with the next lower 
even value.  This  provides a fair approximation for <code>n</code> above 30 (though the fast method is better)
and a good approximation above the default of 199. Values of <code>max.odd</code> above 199 are not recommended 
as integration can become unstable at high odd <code>n</code>; a warning is issued if <code>max.odd &gt; 199</code>. 
</p>
<p>For <code>method="even"</code>, an exact calculation is performed with any odd <code>n</code> replaced with the 
next lower even value. This is equivalent to setting <code>method="exact"</code> and <code>max.odd=0</code>. 
This is provided for interest only; the <code>method="fast"</code> method provides a substantially better 
approximation for odd <code>n</code> than <code>method="even"</code> and is faster.
</p>
<p>Note that these functions are appropriate for the distribution of single values. If 
seeking an outlier test in a data set of size <code class="reqn">N</code>, either adjust <code>p</code> for <code class="reqn">N</code> 
comparisons before applying <code>qmsd</code> to find a critical value, or adjust the returned 
<em>p</em>-values using, for example, Holm adjustment.
</p>


<h3>Value</h3>

<p>A vector of length <code>length(p)</code> or <code>length(q)</code> (or, if longer, <code>length(n)</code>) of 
cumulative probabilities, densities or quantiles respectively.
</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+msd">msd</a></code> for calculation of MSD values, and <code><a href="#topic+bootMSD">bootMSD</a></code> for 
a parametric bootstrap (MCS) method of obtaining <em>p</em>-values and quantiles
for the more general non-IID case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Pb)
  msd(Pb$value)          # Uses mad(Pb$value) as scale estimate
  msd(Pb$value, Pb$u)    # Scales differences using standard uncertainties

</code></pre>

<hr>
<h2 id='.pmsd.xnorm'>
Internal functions for package RKC.
</h2><span id='topic+.pmsd.xnorm'></span>

<h3>Description</h3>

<p>The following functions are used internally by pmsd and qmsd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pmsd.xnorm(q, x, n, sd = 1, scale = FALSE, method="exact")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pmsd.xnorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id=".pmsd.xnorm_+3A_x">x</code></td>
<td>
<p>scalar value</p>
</td></tr>
<tr><td><code id=".pmsd.xnorm_+3A_n">n</code></td>
<td>
<p>number of observations in data set to which msd is applied</p>
</td></tr>
<tr><td><code id=".pmsd.xnorm_+3A_sd">sd</code></td>
<td>
<p>Standard deviation, used to scale q.</p>
</td></tr>
<tr><td><code id=".pmsd.xnorm_+3A_scale">scale</code></td>
<td>
<p>If scale is <code>TRUE</code>, <code>sd</code> is divided by <code>sqrt(2)</code>.</p>
</td></tr>
<tr><td><code id=".pmsd.xnorm_+3A_method">method</code></td>
<td>
<p>Controls method of calculation; see <code><a href="#topic+pmsd">pmsd</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides the distribution function for msd given a value x, using the cumulative 
probability for an order statistics givn in Mood, Graybill and Boes (1974) pp252ff.  
<code>pmsd</code> integrates (using <code>integrate</code>) over x to obtain the distribution 
function for msd for random x.</p>


<h3>Value</h3>

<p>A vector of probabilities</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a></p>


<h3>References</h3>

<p>Mood, Graybill and Boes (1974) pp252ff
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmsd">pmsd</a></code>, <code><a href="#topic+msd">msd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(q, x, n, sd=1, scale=FALSE) {

if(scale) sd &lt;- sd/sqrt(2)

pxnorm&lt;-function(q,x,sd=1) ifelse(q&gt;0, pnorm(x+q, 0, sd)-pnorm(x-q, 0, sd), 0) 

Fy&lt;-rep(0, length(q))

n.med&lt;-floor(n/2) #exact for odd samples, low for even
#Note that for n values there are n-1 differences,
#so an even-n case is an odd-median case
ph&lt;-pxnorm(q,x,sd)

for(j in n.med:(n-1)) Fy &lt;- Fy + choose(n-1,j) * (ph^j) * (1-ph)^(n-j-1)

return(Fy)

  }
</code></pre>

<hr>
<h2 id='algA'>
Robust estimation of location and scale using Algorithm A
</h2><span id='topic+algA'></span>

<h3>Description</h3>

<p>Algorithm A is an implementation of Huber's location and scale estimate
with iterated scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	algA(x, k = 1.5, na.rm = FALSE, tol = .Machine$double.eps^0.25,
		maxiter = 25, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algA_+3A_x">x</code></td>
<td>
<p>numeric vector or array of values.
</p>
</td></tr>
<tr><td><code id="algA_+3A_k">k</code></td>
<td>
<p>Tuning factor; Winsorisation occurs ar k standard deviations.
</p>
</td></tr>
<tr><td><code id="algA_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values should be
removed before the computation proceeds.
</p>
</td></tr>
<tr><td><code id="algA_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance Iteration continues until the relative 
change in estimated sd drops below <code>tol</code>.
</p>
</td></tr>
<tr><td><code id="algA_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations permitted.
</p>
</td></tr>
<tr><td><code id="algA_+3A_verbose">verbose</code></td>
<td>
<p>Controls information displayed during iteration; see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm A is the robust estimate of location described in ISO 5725-5:1998. 
It proceeds by winsorisation and re-estimation of scale and location.
</p>
<p>The argument <code>k</code> controls the point at which values are Winsorised 
and hence controls the efficiency. At <code>k=1.5</code>, the value chosen by 
ISO 5725, the estimator has asymptotic efficiency at the Normal of 0.964. 
With iterated estimate of scale and <code>k=1.5</code>, the estimator has a 
breakdown point of about 30
</p>
<p>The convergence criterion for Algorithm A is not specified in ISO 5725-5:1998.
The criterion chosen here is reasonably stringent but the results will differ 
from those obtained using other choices. Use <code>verbose=2</code> to check the 
effect of different tolerance or maximum iteration count.
</p>
<p>If <code>verbose</code> is non-zero, the current iteration number
and estimate are printed; if <code>verbose&gt;1</code>, the current set
of truncated values <code class="reqn">w</code> is also printed.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mu</code></td>
<td>
<p>Robust estimate of location</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Robust estimate of scale</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Algorithm A uses the corrected median absolute deviation as the initial
estimate of scale; an error is returned if the resulting scale estimate is 
zero, which can occur with over 50% of the data set equal. <code>huberM</code> in 
the robustbase package uses an alternative scale estimate in these 
circumstances.
</p>


<h3>Note</h3>

<p>Algorithm A is identical to Huber's estimate with variable scale. 
The implementation here differs from <code>hubers</code> from MASS in:
</p>

<ul>
<li><p> hubers allows prior specification of fixed scale (which 
provides higher breakdown if chosen properly) or location
</p>
</li>
<li><p> the option of verbose output in <code>algA</code>, 
</p>
</li>
<li><p> a maximum iteration option in <code>algA</code>  
</p>
</li>
<li><p> the convergence criterion; hubers converges on changes in <code>mu</code>, 
whilst this implementation of Algorithm A converges on changes in <code>s</code>. 
</p>
</li>
<li><p> Internally, Algorithm A multiplies by a correction factor for
standard deviation whilst <code>hubers</code> divides by a correction factor
applied to the variance; the actual correction to <code>s</code> is identical.
</p>
</li></ul>

<p>The principal reasons for providing an implementation in the metRology 
package are i) to ensure a close implementation of the cited Standard irrespective
of other package developments (though the MASS implementation has proved very stable)
and ii) to make the implementation easy to recognise for users of the ISO standard.
</p>


<h3>Author(s)</h3>

<p>S L R Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>ISO 5725-5:1998 Accuracy (trueness and precision) of measurement methods and 
results - Part 5: Alternative methods for the determination of the precision 
of a standard measurement method
</p>
<p>Maronna R A, Martin R D, Yohai V J (2006) Robust statistics - theory and methods.
Jhn Wiley and Sons, West Sussex, England.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+algS">algS</a></code>, <code><a href="MASS.html#topic+hubers">hubers</a></code>, <code><a href="robustbase.html#topic+huberM">huberM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Creosote example from ISO 5725-5:1998
#Means for each group are:
cm &lt;-c(24.140, 20.155, 19.500, 20.300, 20.705, 17.570, 20.100, 20.940, 21.185)

algA(cm, verbose=TRUE)
	#Iteration 4 corresponds very closely to the ISO 5725 answer
	
</code></pre>

<hr>
<h2 id='algS'>
&lsquo;Algorithm S&rsquo; - robust estimate of pooled standard deviation
</h2><span id='topic+algS'></span>

<h3>Description</h3>

<p>&lsquo;Algorithm S&rsquo; calculates a robust estimate of pooled standard deviation 
from a set of standard deviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	algS(s, degfree, na.rm = FALSE, prob.eta = 0.9, 
		is.range = FALSE, tol = .Machine$double.eps^0.25, 
		maxiter = 25, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algS_+3A_s">s</code></td>
<td>
<p> A vector of standard deviations or, if <code>is.range</code> is <code>TRUE</code>,
ranges.
</p>
</td></tr>
<tr><td><code id="algS_+3A_degfree">degfree</code></td>
<td>
<p>Scalar number of degrees of freedom associated with all 
values in <code>s</code>. If a vector is supplied,  <code>median(degfree)</code> will be used.
</p>
</td></tr>
<tr><td><code id="algS_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether 'NA' values should be
stripped before the computation proceeds.
</p>
</td></tr>
<tr><td><code id="algS_+3A_prob.eta">prob.eta</code></td>
<td>
<p>prob.eta is set to specify the lower tail area of the chi-squared 
distribution used as a cut-off.
</p>
</td></tr>
<tr><td><code id="algS_+3A_is.range">is.range</code></td>
<td>
<p>if is.range is TRUE, s is interpreted as a vector of positive differences of 
duplcate observations and degfree is set to 1
</p>
</td></tr>
<tr><td><code id="algS_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance Iteration continues until the relative 
change in estimated pooled sd drops below <code>tol</code>.
</p>
</td></tr>
<tr><td><code id="algS_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations permitted.
</p>
</td></tr>
<tr><td><code id="algS_+3A_verbose">verbose</code></td>
<td>
<p>Controls information displayed during iteration; see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm S is suggested by ISO 5725-5:1998 as a robust estimator of 
pooled standard deviation <code class="reqn">s_{pool}</code> from standard deviations of 
groups of size <code class="reqn">\nu+1</code>. 
</p>
<p>The algorithm calculates a &lsquo;limit factor&rsquo;, <code class="reqn">\eta</code>, set to 
<code>qchisq(prob.eta, degfree)</code>. Following an initial estimate of 
<code class="reqn">s_{pool}</code> as <code>median(s)</code>, the standard deviations <code class="reqn">s_i</code>
are replaced with <code class="reqn">w_i=min(\eta*s_{pool}, s_i)</code> 
and an updated value for <code class="reqn">s_{pool}</code> calculated as
</p>
<p style="text-align: center;"><code class="reqn">\xi*\sqrt{\frac{\sum_{i=1}^{p} (w_i)^2}{p}}</code>
</p>

<p>where <code class="reqn">p</code> is the number of standard deviations and <code class="reqn">\xi</code> is calculated as
</p>
<p style="text-align: center;"><code class="reqn">\xi=\frac{1}{\sqrt{\chi_{p-1}^{2}\left(\nu\eta^{2}+\left(1-p_{\eta}\right)\eta^{2}\right)}}</code>
</p>

<p>If the <code class="reqn">s_i</code> are ranges of two values, ISO 5725 recommends 
carrying out the above iteration on the ranges and then dividing by 
<code class="reqn">\sqrt{\nu+1}</code>; in the implementation here, this
is done prior to returning the estimate.
</p>
<p>If <code>verbose</code> is non-zero, the current iteration number
and estimate are printed; if <code>verbose&gt;1</code>, the current set
of truncated values <code class="reqn">w</code> is also printed.
</p>


<h3>Value</h3>

<p>A scalar estimate of poooled standard deviation.
</p>


<h3>Author(s)</h3>

<p>S L R Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>ISO 5725-5:1998 Accuracy (trueness and precision) of measurement methods and 
results - Part 5: Alternative methods for the determination of the precision 
of a standard measurement method
</p>


<h3>See Also</h3>

<p><code><a href="#topic+algA">algA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example from ISO 5725-5:1998 (cell ranges for percent creosote)

cdiff &lt;- c(0.28, 0.49, 0.40, 0.00, 0.35, 1.98, 0.80, 0.32, 0.95)

algS(cdiff, is.range=TRUE)
	

#Compare with the sd of the two values (based on the range)
c.sd &lt;- cdiff/sqrt(2)
algS(c.sd, degfree=1, verbose=TRUE)


</code></pre>

<hr>
<h2 id='apricot'>
Collaborative study results for fibre content in an apricot test material
</h2><span id='topic+apricot'></span>

<h3>Description</h3>

<p>A data frame containing reported duplicate results for dietary fibre from 
a collaborative study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(apricot)
</code></pre>


<h3>Format</h3>

<p>A data frame containing duplicate results from 9 laboratories:
</p>

<dl>
<dt>lab</dt><dd><p>Factor giving abbreviated laboratory identifier</p>
</dd>
<dt>fibre</dt><dd><p>The reported fibre content.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Replicate results appear on separate rows.
</p>


<h3>Source</h3>

<p>B. W. Li, M. S. Cardozo (1994) Determination of total dietary fibre in foods 
and products with little or no starch, non-enzymatic gravimetric method: 
collaborative study.  
<em>J. AOAC Int.</em> <b>77</b>, 687-689, 1994
</p>


<h3>References</h3>

<p>A. L. Ruhkin, C. J. Biggerstaff and M. G. Vangel (2000) Restricted maximum likelihood
estimation of a common mean and the Mandel-Paule algorithm. 
<em>J. Stat. Planning an Inferences</em>
<b>83</b>, 319-330, 2008
</p>
<p>B. W. Li, M. S. Cardozo (1994) Determination of total dietary fibre in foods 
and products with little or no starch, non-enzymatic gravimetric method: 
collaborative study.  
<em>J. AOAC Int.</em> <b>77</b>, 687-689, 1994
</p>

<hr>
<h2 id='barplot.mandel.kh'>
Barplot of Mandel's h or k statistics
</h2><span id='topic+barplot.mandel.kh'></span>

<h3>Description</h3>

<p><code>barplot.mandel.kh</code> produces a bar plot of Mandel's statistics, suitably
grouped and with appropriate indicator lines for unusual values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'mandel.kh'
barplot(height, probs = c(0.95, 0.99), main,
		xlab = attr(height, "grouped.by"), 
		ylab = attr(height, "mandel.type"), separators = TRUE, 
		zero.line = TRUE, ylim, p.adjust = "none", 
		frame.plot = TRUE, ..., 
		col.ind = 1, lty.ind = c(2, 1), lwd.ind = 1, 
		col.sep = "lightgrey", lwd.sep = 1, lty.sep = 1, 
		lwd.zero = 1, col.zero = 1, lty.zero = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplot.mandel.kh_+3A_height">height</code></td>
<td>
<p>An object of class <code>'mandel.kh'</code> (the name is for consistency 
with <code>barplot</code>).
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_probs">probs</code></td>
<td>

<p>Indicator lines are drawn for these probabilities. Note that
<code>probs</code> is interpreted as specifying two-tailed probabilities
for Mandel's h and one-sided (upper tail) probabilities for
Mandel's k.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_main">main</code></td>
<td>

<p>a main title for the plot. If missing, the default is
<code> paste(deparse(substitute(x)), " - Mandel's", 
                     attr(x, "mandel.type"), 
                     if(attr(x, "mandel.method") == "robust") "(Robust variant)")</code>
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_xlab">xlab</code></td>
<td>

<p>a label for the x axis; defaults to the <code>grouped.by</code> attribute for
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_ylab">ylab</code></td>
<td>

<p>a label for the x axis; defaults to the <code>mandel.type</code> attribute for
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_separators">separators</code></td>
<td>

<p>Logical; if <code>TRUE</code>, separator lines are drawn between groups of values.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_zero.line">zero.line</code></td>
<td>

<p>logical; if <code>TRUE</code> a horizontal line is drawn at zero.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_ylim">ylim</code></td>
<td>

<p>the y limits of the plot. For Mandel's k, the default lower limit is zero.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_p.adjust">p.adjust</code></td>
<td>

<p>Correction method for probabilities. If not <code>"none"</code>, passed to <code>p.adjust</code>
prior to calculating indicator lines. Usually, indicator lines are drawn without 
correction (that is, with <code>p.adjust="none"</code>); specifying a p-value correction 
effectively turns the Mandel's 	statistics into single outlier tests.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_frame.plot">frame.plot</code></td>
<td>

<p>Logical; If <code>TRUE</code> a box is drawn around the plot.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_...">...</code></td>
<td>

<p>Other (usually graphical) parameters passed to <code>barplot</code>. Note that some 
parameters appear after ... to prevent spurious argument matching inside
<code>barplot.default</code>.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_col.ind">col.ind</code>, <code id="barplot.mandel.kh_+3A_lty.ind">lty.ind</code>, <code id="barplot.mandel.kh_+3A_lwd.ind">lwd.ind</code></td>
<td>

<p>Graphical parameters used for the indicator lines, recyckled to <code>length(probs)</code>. 
For <code>attr(x, "mandel.type")=="h"</code> the graphical parameters are applied to negative
as well as positive indicator lines, applied outwards from zero.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_col.sep">col.sep</code>, <code id="barplot.mandel.kh_+3A_lwd.sep">lwd.sep</code>, <code id="barplot.mandel.kh_+3A_lty.sep">lty.sep</code></td>
<td>

<p>Graphical parameters used for the separator lines.
</p>
</td></tr>
<tr><td><code id="barplot.mandel.kh_+3A_lwd.zero">lwd.zero</code>, <code id="barplot.mandel.kh_+3A_col.zero">col.zero</code>, <code id="barplot.mandel.kh_+3A_lty.zero">lty.zero</code></td>
<td>

<p>Graphical parameters used for the zero line.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mandel's statistics are traditionally plotted for inter-laboratory study data, 
grouped by laboratory, to give a rapid graphical view of laboratory bias and 
relative precision. This plot produces a grouped, side-by-side bar plot.
</p>
<p>For classical Mandel statistics, indicator lines are drawn based on <code>qmandelh</code>
or  <code>qmandelk</code> as appropriate. For robust variants, indicator lines use
<code>qnorm</code> for the <code class="reqn">h</code> statistic and <code>qf(probs, n, Inf)</code> for 
the <code class="reqn">k</code> statistic. Note that this corresponds to taking the robust estimates of 
location and scale as true values, so will be somewhat anticonservative.
</p>


<h3>Value</h3>

<p>barplot.mandel.kh returns a numeric vector of mid-points of the groups 
along the x-axis.
</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Accuracy (trueness and precision) of measurement methods and results &ndash; Part 2: 
Basic method for the determination of repeatability and reproducibility of a 
standard measurement method. ISO, Geneva (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mandel.h">mandel.h</a></code>, <code><a href="#topic+mandel.k">mandel.k</a></code>, <code><a href="#topic+mandel.kh">mandel.kh</a></code>,
<code><a href="#topic+pmandelh">pmandelh</a></code>, <code><a href="#topic+pmandelk">pmandelk</a></code>  for probabilities, quantiles etc.
</p>
<p>See <code><a href="#topic+plot.mandel.kh">plot.mandel.kh</a></code> for the 'classic' Mandel plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(RMstudy)

   h &lt;- with(RMstudy, mandel.h(RMstudy[2:9], g=Lab))
   barplot(h, las=2) # Lab 4 shows consistent low bias; 
                  # Lab 23 several extreme values.

   #Use colours to identify particular measurands:
   barplot(h, las=2, col=1:8)
   legend("bottomleft", legend=names(h), fill=1:8, cex=0.7, bg="white")
   
   #Example of Mandel's k:
   k &lt;- with(RMstudy, mandel.k(RMstudy[2:9], g=Lab))
   barplot(k, las=2) # Lab 8 looks unusually variable; 
                  # Lab 14 unusually precise
</code></pre>

<hr>
<h2 id='bkp'>
Draw block plots from block plot objects
</h2><span id='topic+bkp'></span>

<h3>Description</h3>

<p><code>bkp</code> draws block plots based on block plot objects generated by <code>blockplot</code> and its methods. 
It is normally called from within <code>blockplot</code> but can be invoked directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	bkp(x, labels = x$labels, xlim = NULL, ylim = NULL, 
            main = NULL, xlab = NULL, ylab = "Frequency", 
            square = FALSE, add = FALSE, offset = 0, 
            grp.spacing = 2, grp.at = NA, 
            fill = NA, border = NULL, density = NULL, angle = 45, 
            lty = 1, lwd = 2, label.col = 1, cex = NA, adj = c(0.5, 0.4), 
            uline = 2, uline.lwd = lwd, uline.lty = 1, 
            uline.col = if (!is.null(border)) border else par("fg"), 
            grp.labs = FALSE, grp.pos = 1, glab.control = list(), 
            axes = c(TRUE, FALSE), asp = NA, frame.plot = any(axes), 
            drop.unused = TRUE, unused.label="[Missing]", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkp_+3A_x">x</code></td>
<td>
<p> An R object. For the default method, a vector of values for which the blockplot is desired. 
For the formula method, a valid formula, such as <code>y ~ grp</code> (see Details).
</p>
</td></tr>
<tr><td><code id="bkp_+3A_labels">labels</code></td>
<td>
<p>Labels for data points, passed to <code>text</code>; in principle of any type acceptable to <code>text</code>. 
Labels are placed inside boxes so should be short for readability.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_xlim">xlim</code></td>
<td>
<p> Limits <code>(x1, x2)</code> for the horizontal (<code class="reqn">x</code>) range of the plot. The default is the range of <code>breaks</code>, after computation if necessary.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_ylim">ylim</code></td>
<td>
<p> limits for the vertical range of the plot. Will be overridden if <code>square=TRUE</code> (see below).
</p>
</td></tr>
<tr><td><code id="bkp_+3A_main">main</code></td>
<td>
<p>Main title for the plot, passed to <code><a href="graphics.html#topic+plot">plot</a></code>.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_xlab">xlab</code>, <code id="bkp_+3A_ylab">ylab</code></td>
<td>
<p> x- and y-axis labels for the plot. As usual, either can be expressions (see <code><a href="grDevices.html#topic+plotmath">plotmath</a></code>).
</p>
</td></tr>
<tr><td><code id="bkp_+3A_square">square</code></td>
<td>
<p> Logical: If <code>square=TRUE</code>, the aspect ratio is set (via <code>asp</code>) to make the individual 
blocks appear square when rendered. Note that this generally overrides <code>ylim</code>. 
</p>
</td></tr>
<tr><td><code id="bkp_+3A_add">add</code></td>
<td>
<p> Logical: If <code>TRUE</code>, the plot will be added to an existing plot.  
</p>
</td></tr>
<tr><td><code id="bkp_+3A_offset">offset</code></td>
<td>
<p>Numeric scalar value. Vertical offset for the plot, in units of block height.  
<code>offset</code> is added to the vertical position of the boxplot and any subplots. <code>offset</code> can be 
considered as a number of vertical block heights to raise (or lower, if negative) the plot. 
This, with <code>add</code>, is useful for adding further groups manually to an existing plot. 
</p>
</td></tr>
<tr><td><code id="bkp_+3A_grp.spacing">grp.spacing</code></td>
<td>
<p>Numeric scalar, giving the minimum vertical spacing (in units of block height) between subplots when 
there is more than one group.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_grp.at">grp.at</code></td>
<td>
<p>Optional vector specifying explicit vertical locations for subplot 
baselines (including the first group). The default (<code>grp.at=NA</code>) is 
to use <code>grp.spacing</code>. If specified, <code>grp.at</code> overrides <code>grp.spacing</code>. 
</p>
</td></tr>
<tr><td><code id="bkp_+3A_fill">fill</code></td>
<td>
<p>Fill colour for the rectangles (&ldquo;blocks&rdquo;) making up the plot. 
Recycled to length <code>length(x)</code>. Passed to <code><a href="graphics.html#topic+rect">rect</a></code>.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_border">border</code></td>
<td>
<p>Border colour for the rectangles (&ldquo;blocks&rdquo;) making up the plot. 
Recycled to length <code>length(x)</code>. Passed to <code><a href="graphics.html#topic+rect">rect</a></code>.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_density">density</code></td>
<td>
<p>Shading line density for (&ldquo;blocks&rdquo;) making up the plot. Recycled 
to length <code>length(x)</code>. Passed to <code><a href="graphics.html#topic+rect">rect</a></code>.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_angle">angle</code></td>
<td>
<p>Shading line angle for (&ldquo;blocks&rdquo;) making up the plot. Recycled 
to length <code>length(x)</code>. Passed to <code><a href="graphics.html#topic+rect">rect</a></code>.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_lty">lty</code></td>
<td>
<p>Border line type for (&ldquo;blocks&rdquo;) making up the plot. Recycled 
to length <code>length(x)</code>. Passed to <code><a href="graphics.html#topic+rect">rect</a></code>.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_lwd">lwd</code></td>
<td>
<p>Border line width for (&ldquo;blocks&rdquo;) making up the plot. Recycled 
to length <code>length(x)</code>. Passed to <code><a href="graphics.html#topic+rect">rect</a></code>.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_label.col">label.col</code></td>
<td>
<p>Colour used for text labels in each (&ldquo;block&rdquo;) making up the plot. 
Recycled to length <code>length(x)</code>. Passed to <code><a href="graphics.html#topic+text">text</a></code>.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_cex">cex</code></td>
<td>
<p>Size of text labels in each (&ldquo;block&rdquo;) making up the plot. 
Recycled to length <code>length(x)</code> and passed to <code><a href="graphics.html#topic+text">text</a></code>. The 
default is to fit text inside each block automatically.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_adj">adj</code></td>
<td>
<p>Vector of two values giving text location adjustment for all block labels.
Passed to <code><a href="graphics.html#topic+text">text</a></code>
</p>
</td></tr>
<tr><td><code id="bkp_+3A_uline">uline</code></td>
<td>
<p>Specification for the distance by which the baseline for each subplot 
extends beyond the data range for the group. See &lsquo;Graphical elements&rsquo; 
for details. The default is two units either side. 
</p>
</td></tr>
<tr><td><code id="bkp_+3A_uline.lwd">uline.lwd</code></td>
<td>
<p>Scalar: Line width for the subplot baseline(s). 
</p>
</td></tr>
<tr><td><code id="bkp_+3A_uline.lty">uline.lty</code></td>
<td>
<p>Scalar: Line type for the subplot baseline(s). 
</p>
</td></tr>
<tr><td><code id="bkp_+3A_uline.col">uline.col</code></td>
<td>
<p>Scalar: Line colour for the subplot baseline(s). 
</p>
</td></tr>
<tr><td><code id="bkp_+3A_grp.labs">grp.labs</code></td>
<td>
<p> Logical, determining whether group labels are plotted, or 
a vector of labels. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_grp.pos">grp.pos</code></td>
<td>
<p>Specification for the position of group labels. Follows <code>pos</code> in 
<code><a href="graphics.html#topic+text">text</a></code>. See &lsquo;Details&rsquo;.  
</p>
</td></tr>
<tr><td><code id="bkp_+3A_glab.control">glab.control</code></td>
<td>
<p>List of arguments to be passed to <code><a href="graphics.html#topic+text">text</a></code> 
when drawing group labels.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_axes">axes</code></td>
<td>
<p>Logical, indicating whether axes are drawn. Can be a vector 
of two logicals, specifying horizontal and vertical axes 
respectively. See &lsquo;Graphical elements&rsquo; for details.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio, passed to <code><a href="graphics.html#topic+plot">plot</a></code>
</p>
</td></tr>
<tr><td><code id="bkp_+3A_frame.plot">frame.plot</code></td>
<td>
<p>Logical, controlling whether a frame (box) is drawn round the plot.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_drop.unused">drop.unused</code></td>
<td>
<p>Logical specification for the treatment of empty groups. If <code>TRUE</code>,
groups (identified by levels in <code>x$groups</code>) that contain no non-missing
values will be omitted from the plot. If <code>FALSE</code>, a space is created
for the missing subplot but no subplot is generated. If <code>grp.labels</code>
requires group labelling, the group label is drawn in the space with 
<code>unused.label</code> appended.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_unused.label">unused.label</code></td>
<td>
<p>Character string appended to missing group labels.
</p>
</td></tr>
<tr><td><code id="bkp_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="graphics.html#topic+plot">plot</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bkp</code> provides considerable control of graphical elements. The main 
elements, and the arguments controlling their location and appearance, are:
</p>

<dl>
<dt>General appearance</dt><dd><p>A block plot of a single group of data has the general 
appearance of a histogram. However, instead of vertical bars (of possibly 
variable width) indicating the number of data points within the bin interval,
each bin is a stack of rectangles, each corresponding to a single data point
and with an optional label identifying the datum.
</p>
<p>Block plots of this kind are useful for data sets of modest size; typically 10-100
per group, as individual labels quickly become hard to identify in larger data sets.
</p>
<p>By default, <code>blockplot</code> produces one such plot for a set of data. If 
a series of such plots is needed, this can be accommodated either by using
<code>blockplot</code> with <code>add=TRUE</code> to build up a plot manually, setting
<code>xlim</code>, <code>ylim</code> and <code>breaks</code> to accommodate all the required 
groups. Alternatively, a grouping factor can be provided (via argument 
<code>groups</code>) which will produce a series of subplots, laid out automatically.
The use of <code>groups</code> and the corresponding layout options are detailed below
(see &ldquo;Groups&rdquo;).
</p>
<p>The vertical position of a single block plot within the figure 
can be set using <code>offset</code>, which sets the baseline height, 
in units of block height, from the figure origin. This is useful for 
separating several groups that are added manually; just set <code>offset</code>
appropriately for each separate plot. Note that setting <code>offset</code>
has no effect on the automatic <code>ylim</code> setting, which means that 
<code>ylim</code> must be set manually to accommodate the vertical offset.
</p>
</dd>
<dt>Blocks</dt><dd><p>Each individual rectangle (&ldquo;block&rdquo; in the plot corresponds to
a single data point. In this implementation, blocks appear in rank order
from left to right <em>and</em> from bottom to top; that is, data are placed in 
vertical bins as in a normal histogram but, in addition, the vertical ordering of 
blocks corresponds to the data order within each bin, with blocks at the 
bottom corresponding to lower values.  
</p>
<p>Blocks are always 1 unit high, so the total vertical height of each bin corresponds
directly to frequency (not density) in a histogram. The block width is the interval 
between <code>breaks</code>, which must be equispaced.
</p>
<p>By default, the apparent aspect ratio for blocks depends primarily on 
<code>xlim</code> and <code>ylim</code> and the height and width of the plotting device. 
However, setting <code>square=TRUE</code> will cause the plot aspect ration (<code>asp</code>)
to be set such that the bocks appear square in the current plot window.
</p>
<p>Fill colour, border colour and style, fill effects and text colour of individual 
blocks can all be controlled using <code>fill</code>, <code>border</code>, 
<code>density</code>, <code>angle</code>, <code>lty</code>, <code>lwd</code> and <code>label.col</code>, 
as the relevant arguments can be vectors of length <code>length(x)</code>. This 
allows conditional formatting, for example to identify
a particular data point or some secondary grouping variable.
</p>
</dd>
<dt>Subplot baseline</dt><dd><p>The baseline for each subplot is controlled by <code>uline</code>,
as follows:
</p>

<dl>
<dt><code>TRUE</code>:</dt><dd><p> The line extends the full width of the plot;</p>
</dd>
<dt><code>FALSE</code>:</dt><dd><p> No baseline is drawn;</p>
</dd>
<dt>numeric:</dt><dd><p> If numeric (as for the default), <code>uline</code> specifies 
the distance that the baseline extends beyond each end of the data, 
in units of block width. <code>uline</code> can be length 2 numeric vector,
which specifies the baseline extension on the left and right sides 
respectively.</p>
</dd>
</dl>

<p>Colour, line type, and line width for the subplot baseline(s) can be controlled
with <code>uline.col</code>, <code>uline.lty</code>, and <code>uline.lwd</code> respectively. 
</p>
</dd>
<dt>Axes</dt><dd><p> Axes can be controlled with the <code>axes</code> argument, which 
controls whether or not axes are drawn. If a vector of two logical 
values (as for the default), <code>axes</code> specifies drawing for horizontal 
and vertical axes respectively.
</p>
<p>The horizontal axis is normally continuous for the plot. If a 
vertical (frequency) axis is requested (either by <code>axes=TRUE</code> or,
for example, by <code>axes=c(TRUE, TRUE)</code>, a vertical axis is drawn
for each subplot, starting at zero at the baseline and terminating 
at the highest vertical value in the subplot. Vertical axes, 
restarting at 0 at the next subplot baseline, are drawn if 
there is more than one group.
</p>
</dd>
<dt>Groups</dt><dd><p><code>blockplot</code> provides a simple grouping mechanism to display
separate subplots for different groups of data on the same figure. The 
default method provides for a grouping variable specified via <code>groups</code>.
The formula method provides a somewhat more flexible interface, allowing 
specification of more than one grouping variable. Like <code><a href="graphics.html#topic+boxplot">boxplot</a></code>,
if there is more than one goruping variable in the formula, subplots are drawn 
for each (non-empty) level of the interaction term. 
</p>
<p>Subplots for different groups are arranged vertically. Vertical position can be
specified explicitly via <code>grp.at</code> or, more simply, by setting 
<code>grp.spacing</code>. The latter sets <code>grp.at</code> to equal vertical
spacing such that the smallest vertical gap is <code>grp.spacing</code>.
Both <code>grp.at</code> and <code>grp.spacing</code> are in units of block height;
that is, <code>grpspacing=2</code> (the default) means that the smallest vertical 
gap is equivalent to two blocks. 
</p>
</dd>
<dt>Group labels</dt><dd><p>Labels can be added to each subplot. These are controlled by <code>grp.labs</code> ..
<code>grp.labs</code> provides the specification for group labels, and can be a single logical or 
a vector of labels. Effects of <code>grp.labs</code> are as follows:
</p>

<ul>
<li><p><code>FALSE</code> (The default): No group labels are drawn. 
</p>
</li>
<li><p><code>TRUE</code> Labels are taken as <code>levels(groups)</code>, 
and set to <code>"1"</code> if there is only one group.
</p>
</li>
<li><p>Vector If a character vector (or expression) is provided, 
these are used as labels for the groups plotted. 
</p>
<p>WARNING: If missing values in <code>x</code> cause group levels to be 
dropped, those groups will not be plotted. <code>grp.labs</code> must
have the same length as the number of groups plotted. An error
is generated if the length of <code>labels</code> differs from the number
of groups actually plotted.
</p>
</li></ul>

<p><code>grp.pos</code> specifies the general positioning of group labels 
relative to each subplot. <code>grp.pos</code> follows <code>pos</code> in <code><a href="graphics.html#topic+text">text</a></code>:
Values of <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code>, respectively 
indicate positions below, to the left of, above and to the right of the plot.
</p>
<p>The detailed positioning of group labels is automatic; the four positions 
specified by <code>grp.pos</code> correspond approximately to the midpoints of the 
corresponding edge of each plot, where the &lsquo;edges&rsquo; are the baseline, 
leftmost block, topmost block and rightmost block. Labels are placed a short 
distance outward from these edges. Labels are justified according to position;
<code>grp.pos</code> is re-used as the default <code>pos</code> argument to <code><a href="graphics.html#topic+text">text</a></code>.
</p>
<p>Further control of group label position is available via <code>grp.control</code>, 
which is a list (empty by default) of arguments passed to <code><a href="graphics.html#topic+text">text</a></code>.
Ths can include arguments such as <code>pos</code> and <code>adj</code>, as well as 
appearance elements such as <code>col</code>, <code>cex</code> etc.
</p>
</dd>
</dl>
   


<h3>Value</h3>

<p><code>bxp</code> returns the original object <code>x</code> with additional elements:
</p>
<table>
<tr><td><code>grp.at</code></td>
<td>
<p>The vertical coordinated for the subplot baselines.
</p>
</td></tr>
<tr><td><code>blockwidth</code></td>
<td>
<p>The width of the blocks in the plot.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stephen L R Ellison <a href="mailto:s.ellison@lgcgroup.com">s.ellison@lgcgroup.com</a>.
</p>


<h3>References</h3>

<p>ISO 5725-2:1994 <em>Accuracy (trueness and precision) of measurement methods 
and results &ndash; Part 2: Basic method for the determination of repeatability 
and reproducibility of a standard measurement method.</em> ISO, Geneva, 1994.
</p>


<h3>See Also</h3>

<p>For constructing breaks and grouping:
<code><a href="#topic+blockplot">blockplot</a></code> 
</p>
<p>For graphical elements:
<code><a href="graphics.html#topic+text">text</a></code>, <code><a href="graphics.html#topic+rect">rect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#A simple blockplot
set.seed(55)
x&lt;-rnorm(48, 15)
b &lt;- blockplot(x)

#Aspect ratio control for square blocks
bkp(b, square=TRUE)

# Specifying groups 
grp &lt;- gl(3, 16)
bg &lt;- blockplot(x~grp)

# Add vertical axes ( axes=TRUE asks for horizontal and vertical axes)
bkp(bg, axes=TRUE ) 

#Axes both left and right
par(mar=c(5,4,4,4)+0.1)
bkp(bg, axes=c(TRUE, TRUE, FALSE, TRUE) ) 
		#Note that axes[3] is FALSE to suppress top axis
		
# Vectorised colour specification
bkp(bg, square=TRUE, fill=ifelse(1:48 %in% c(15, 23, 24), "gold", "white") )

# Group labelling
bkp(bg, square=TRUE, grp.labs=paste("Level", 1:3), grp.pos=2)

</code></pre>

<hr>
<h2 id='blockplot'>
Generate a &ldquo;block plot&rdquo; - a histogram variant identifiying individual data points.
</h2><span id='topic+blockplot.default'></span><span id='topic+blockplot.formula'></span><span id='topic+blockplot'></span><span id='topic+bplot'></span><span id='topic+nclass.23'></span>

<h3>Description</h3>

<p>A &ldquo;block plot&rdquo; is a histogram variant identifiying individual data points. Histogram bars are replaced 
by a stack of rectangles (&ldquo;blocks&rdquo;, each of which is labelled. <code>blockplot</code> provides for grouped 
data, which generates vertically separated subplots for each group. Fills and label colours can be specified 
for each data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	blockplot(x, ...)

	bplot(x, ...)

	## Default S3 method:
blockplot(x, breaks = "23", labels = paste(1:length(x)), groups = NA, 
		xlim = NULL, ylim = NULL, 
		main = NULL, xlab = NULL, ylab = "Frequency", grp.labs = FALSE, 
		include.lowest = TRUE, right = TRUE, nclass = NULL, 
		plot = TRUE,  add=FALSE, ...)

	
	## S3 method for class 'formula'
blockplot(x, data = NULL, ..., subset, main = NULL, xlab = NULL)
	
	
	nclass.23(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockplot_+3A_x">x</code></td>
<td>
<p> An R object. For the default method, a vector of values for which the blockplot is desired. 
For the formula method, a valid formula, such as <code>y ~ grp</code> (see Details).
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_data">data</code></td>
<td>
<p> For the formula method, a data frame or list from which the variables in <code>formula</code>
should be taken.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_subset">subset</code></td>
<td>
<p> For the formula method, an optional vector specifying a subset of observations to be
used for plotting.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_breaks">breaks</code></td>
<td>
<p> Either a specification for choosing breakpoints for &ldquo;binning&rdquo; 
the data, or a vector giving the breakpoints themselves. The 
specification can be a single number, a function, or a character 
string identifying a function. See &lsquo;Details&rsquo; for detailed 
specification. 
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_labels">labels</code></td>
<td>
<p>Labels for data points, passed to <code>text</code>; in principle of any type acceptable to <code>text</code>. 
Labels are placed inside boxes so should be short for readability.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_groups">groups</code></td>
<td>
<p>An optional grouping variable, coerced to factor. If present, one subplot is produced for each non-empty group.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_xlim">xlim</code></td>
<td>
<p> Limits <code>(x1, x2)</code> for the horizontal (<code class="reqn">x</code>) range of the plot. The default is the range of <code>breaks</code>, after computation if necessary.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_ylim">ylim</code></td>
<td>
<p> limits for the vertical range of the plot. Will be overridden if <code>square=TRUE</code> (see below).
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_main">main</code></td>
<td>
<p>Main title for the plot, passed to <code><a href="graphics.html#topic+plot">plot</a></code>.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_xlab">xlab</code>, <code id="blockplot_+3A_ylab">ylab</code></td>
<td>
<p> x- and y-axis labels for the plot. As usual, either can be expressions (see <code><a href="grDevices.html#topic+plotmath">plotmath</a></code>).
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_grp.labs">grp.labs</code></td>
<td>
<p> Logical, determining whether group labels are plotted, or 
a vector of labels. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_include.lowest">include.lowest</code></td>
<td>
<p> Logical, indicating whether a value equal to the lowest 
(or highest, for <code>right = FALSE</code>) <code>breaks</code> value should be included 
in a given bin. Passed to <code><a href="base.html#topic+cut">cut</a></code>.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_right">right</code></td>
<td>
<p>Logical, indicating whether the bin intervals should be closed on the right (and open 
on the left) or vice versa. Passed to <code><a href="base.html#topic+cut">cut</a></code>.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_nclass">nclass</code></td>
<td>
<p>Suggested number of classes for <code>breaks</code>; equivalent to a single 
numerical value for <code>breaks</code>. 
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, no plot is produced. The return value is returned invisibly.
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, the plot is added to an existing figure. 
</p>
</td></tr>
<tr><td><code id="blockplot_+3A_...">...</code></td>
<td>
<p>Further parameters passed to other functions, in particular, <code><a href="#topic+bkp">bkp</a></code>, 
which creates the plot, and <code><a href="graphics.html#topic+plot">plot</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>blockplot</code> produces a block plot - a histogram variant identifying individual
data points. Histogram bars are replaced by a stack of rectangles (&ldquo;blocks&rdquo;, 
each of which can be (and by default, is) labelled.
</p>
<p><code>bplot</code> is an alias for <code>blockplot</code>.
</p>
<p>For the formula method, <code>x</code> is a formula, such as <code>y ~ grp</code>, in which <code>y</code> is a numeric vector
of data values to be split into groups according to the grouping variable <code>grp</code> (usually a factor). 
More than one grouping variable can be specified, in which case subplots are produced for each level
of the interaction between grouping factors.
</p>
<p>The specification for breakpoints, <code>breaks</code>, is modelled closely on that for 
<code><a href="graphics.html#topic+hist">hist</a></code>. <code>breaks</code> can be one of:
</p>

<ul>
<li><p> a vector giving the (equally spaced) breakpoints between bins;
</p>
</li>
<li><p> a function to compute the vector of breakpoints;
</p>
</li>
<li><p> a single number giving the suggested number of bins for the
blockplot;
</p>
</li>
<li><p> a character string naming an algorithm to compute the
number of cells. Values of <code>"23"</code> (the default),
<code>"Sturges"</code>, <code>"Scott"</code>, <code>"FD"</code> and 
<code>"Freedman-Diaconis"</code> are currently 
supported; see below for their effect
</p>
</li>
<li><p> a function to compute the number of bins.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only, as the breakpoints 
will be set to &ldquo;pretty&rdquo; values. 
</p>
<p>The different character string specifications correspond to &ldquo;nclass&rdquo; 
functions, including those used by <code><a href="graphics.html#topic+hist">hist</a></code>; see <code><a href="grDevices.html#topic+nclass.FD">nclass.FD</a></code> 
for details of those. In addition, the default <code>"23"</code> corresponds to the 
function <code>nclass.23</code>. This is just a wrapper for the one-line expression
</p>
<p><code>ceiling(length(x)^(2/3))</code>,
</p>
<p>which appears to provide good results for block plots.
</p>
<p>Considerable control of graphical elements is provided by the plotting function 
<code><a href="#topic+bkp">bkp</a></code>, which is called by <code>blockplot</code>. In particular, arguments 
passed through <code>...</code> to <code><a href="#topic+bkp">bkp</a></code> can control:
</p>

<ul>
<li><p> The general shape of the plot, including the asbect ratio of the &ldquo;blocks&rdquo;;
</p>
</li>
<li><p> whether a plot should be added to an existing figure (<code>add</code>)
</p>
</li>
<li><p> the fill colour and shading, the border width, type and colour, and the font size 
and colour of individual blocks;
</p>
</li>
<li><p> the vertical location of the plot in the figure region <code>offset</code>;
</p>
</li>
<li><p> the vertical spacing between multiple plots on the same figure when a grouping 
variable is provided (<code>grp.spacing</code> and <code>grp.at</code>;
</p>
</li>
<li><p> the presence, location and appearance of labels for individual subplots;
</p>
</li>
<li><p> whether axes are plotted on any of the four sides of the plot;
</p>
</li>
<li><p> the appearance or omission of empty groups.
</p>
</li></ul>

<p>See <code><a href="#topic+bkp">bkp</a></code> for further details.  
</p>


<h3>Value</h3>

<p>Blockplot currently returns an object of class <code>blockplot</code>, which is a list with elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The original data</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>If there is more than one group, a factor of groups for each data point,
with additional attribute <code>"gname"</code> containing a default name for the grouping 
variable(s). <code>groups</code> is set to <code>NA</code> if there is only one group.</p>
</td></tr>
<tr><td><code>x.left</code></td>
<td>
<p>Vector of x-coordinates for the left side of each block</p>
</td></tr>
<tr><td><code>x.height</code></td>
<td>
<p>Vector of y-coordinates for each box, relative to the group baseline</p>
</td></tr>
<tr><td><code>x.mid</code></td>
<td>
<p>Vector of x-coordinates for the middle of each block (the text location)</p>
</td></tr>
<tr><td><code>x.mid</code></td>
<td>
<p>Vector of x-coordinates for the middle of each block (the text location)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The name &ldquo;block plot&rdquo; may not be in general use, but the package author 
has been unable to identify either an alternative designation or an original source
for this type of plot. An example - apparently hand drawn - was given in ISO 5725-2:1994 (referenced above).
</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgcgroup.com">s.ellison@lgcgroup.com</a>
</p>


<h3>References</h3>

<p>ISO 5725-2:1994 <em>Accuracy (trueness and precision) of measurement methods 
and results &ndash; Part 2: Basic method for the determination of repeatability 
and reproducibility of a standard measurement method.</em> ISO, Geneva, 1994.
</p>


<h3>See Also</h3>

<p>For plotting and control of plot appearance:
<code>link{bkp}</code> 
</p>
<p>For graphical elements:
<code><a href="graphics.html#topic+text">text</a></code>, <code><a href="graphics.html#topic+rect">rect</a></code>
</p>
<p>For specification of <code>breaks</code>:
<code>link{nclass.Sturges}</code>, <code>link{nclass.Scott}</code>, <code>link{nclass.FD}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#A simple blockplot
set.seed(55)
x&lt;-rnorm(48, 15)
blockplot(x)

#Aspect ratio control for square blocks
blockplot(x, square=TRUE)

# Specifying groups 
grp &lt;- gl(3, 16)
blockplot(x, groups=grp)

#Formula interface
blockplot(x~grp)

#Vectorised colour specification
blockplot(x~grp, square=TRUE, fill=ifelse(1:48 %in% c(15, 23, 24), "gold", "white") )

#Group labelling
blockplot(x~grp, square=TRUE, grp.labs=paste("Level", 1:3), grp.pos=2)

#A missing group
xm &lt;- x
xm[ grp == "2" ] &lt;- NA
blockplot(xm~grp, square=TRUE, grp.labs=paste("Level", 1:3), grp.pos=2)

blockplot(xm~grp, square=TRUE, grp.labs=paste("Level", 1:3), grp.pos=2, drop.unused=FALSE)

</code></pre>

<hr>
<h2 id='boxplot.mandel.kh'>
Box plot of Mandel's h or k statistics
</h2><span id='topic+boxplot.mandel.kh'></span>

<h3>Description</h3>

<p>Produces a box plot of Mandel's statistics, with optional outlier labels
and indicator lines for unusual values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'mandel.kh'
boxplot(x, probs=c(0.95, 0.99), main,  
		xlab=attr(x, "grouped.by"), ylab=attr(x, "mandel.type"),
		separators=FALSE, zero.line=TRUE, ylim,  p.adjust="none", 
		frame.plot = TRUE, horizontal=FALSE, at,
		... , 
		col.ind=1, lty.ind=c(2,1), lwd.ind=1, 
		col.sep="lightgrey", lwd.sep=1, lty.sep=1,
		lwd.zero=1, col.zero=1, lty.zero=1,
		outlier.labels=row.names(x), cex.lab=0.7, col.lab=1, 
		adj=NULL, pos=NULL, srt=0 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.mandel.kh_+3A_x">x</code></td>
<td>
<p>An object of class <code>"mandel.kh"</code>
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_probs">probs</code></td>
<td>

<p>Indicator lines are drawn for these probabilities. Note that
<code>probs</code> is interpreted as specifying two-tailed probabilities
for Mandel's h and one-sided (upper tail) probabilities for
Mandel's k.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_main">main</code></td>
<td>

<p>a main title for the plot. If missing, the default is
<code> paste(deparse(substitute(x)), " - Mandel's", 
                     attr(x, "mandel.type"), 
                     if(attr(x, "mandel.method") == "robust") "(Robust variant)")</code>
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_xlab">xlab</code></td>
<td>

<p>a label for the x axis; defaults to the <code>grouped.by</code> attribute for
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_ylab">ylab</code></td>
<td>

<p>a label for the x axis; defaults to the <code>mandel.type</code> attribute for
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_separators">separators</code></td>
<td>

<p>Logical; if <code>TRUE</code>, separator lines are drawn between groups of values.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_zero.line">zero.line</code></td>
<td>

<p>logical; if <code>TRUE</code> a horizontal line is drawn at zero.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_ylim">ylim</code></td>
<td>

<p>the y limits of the plot. For Mandel's k, the default lower limit for y is zero.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_p.adjust">p.adjust</code></td>
<td>

<p>Correction method for probabilities. If not <code>"none"</code>, passed to <code>p.adjust</code>
prior to calculating indicator lines. Usually, indicator lines are drawn without 
correction (that is, with <code>p.adjust="none"</code>); specifying a p-value correction 
effectively turns the Mandel's 	statistics into single outlier tests.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_frame.plot">frame.plot</code></td>
<td>

<p>Logical; If <code>TRUE</code> a box is drawn around the plot.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_horizontal">horizontal</code></td>
<td>

<p>if <code>TRUE</code> boxes are plotted horizontally and separators, indicators etc
adjusted accordingly.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_at">at</code></td>
<td>

<p>numeric vector giving the locations where the boxplots should
be drawn; defaults to <code>1:n</code> where <code>n</code> is the number of boxes.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_...">...</code></td>
<td>

<p>Other (usually graphical) parameters passed to <code>barplot</code>. Note that some 
parameters appear after ... to prevent spurious argument matching inside
<code>barplot.default</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_col.ind">col.ind</code>, <code id="boxplot.mandel.kh_+3A_lty.ind">lty.ind</code>, <code id="boxplot.mandel.kh_+3A_lwd.ind">lwd.ind</code></td>
<td>

<p>Graphical parameters used for the indicator lines, recyckled to <code>length(probs)</code>. 
For <code>attr(x, "mandel.type")=="h"</code> the graphical parameters are applied to negative
as well as positive indicator lines, applied outwards from zero.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_col.sep">col.sep</code>, <code id="boxplot.mandel.kh_+3A_lwd.sep">lwd.sep</code>, <code id="boxplot.mandel.kh_+3A_lty.sep">lty.sep</code></td>
<td>

<p>Graphical parameters used for the separator lines.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_lwd.zero">lwd.zero</code>, <code id="boxplot.mandel.kh_+3A_col.zero">col.zero</code>, <code id="boxplot.mandel.kh_+3A_lty.zero">lty.zero</code></td>
<td>

<p>Graphical parameters used for the zero line.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_outlier.labels">outlier.labels</code></td>
<td>

<p>Either a logical indicating whether outliers should be labelled or a character vector
of length nrow(x) giving labels. Defaults to row.names(x). 
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_cex.lab">cex.lab</code>, <code id="boxplot.mandel.kh_+3A_col.lab">col.lab</code></td>
<td>

<p>Character size and colour for outlier labels, passed to <code>text</code> as 
<code>col</code> and <code>cex</code> respectively.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_adj">adj</code>, <code id="boxplot.mandel.kh_+3A_pos">pos</code></td>
<td>

<p>Position of outlier labels relative to outliers; passed to <code>text</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.mandel.kh_+3A_srt">srt</code></td>
<td>

<p>Label rotation, in degrees, for outlier labels; passed to <code>text</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot produces a box plot (using <code>boxplot.default</code>) of the variables in an object of 
class <code>"mandel.kh"</code>. 
</p>
<p>If labels are specified for outliers (the default), outliers are first located based on the 
locations given by boxplot.default. WARNING: ties may be mislabelled, as the label 
allocated will be the _first_ point at that location.  
</p>
<p>Indicator lines are, if requested, drawn as for <code><a href="#topic+plot.mandel.kh">plot.mandel.kh</a></code>.
</p>
<p>Vertical separators are drawn at midpoints of <code>at</code>. If 
</p>


<h3>Value</h3>

<p><code>boxplot.mandel.kh</code> returns the box plot statistics returned by 
<code>boxplot</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code> for box plot arguments, and <code><a href="graphics.html#topic+text">text</a></code> for outlier label
location, colour and rotation.
<code><a href="#topic+mandel.h">mandel.h</a></code>, <code><a href="#topic+mandel.k">mandel.k</a></code>, <code><a href="#topic+mandel.kh">mandel.kh</a></code>,
<code><a href="#topic+pmandelh">pmandelh</a></code>, <code><a href="#topic+pmandelk">pmandelk</a></code>  for probabilities, quantiles etc.
</p>
<p>See <code><a href="#topic+plot.mandel.kh">plot.mandel.kh</a></code> for the 'classic' Mandel plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(RMstudy)

   h &lt;- with(RMstudy, mandel.h(RMstudy[2:9], g=Lab))
   boxplot(h, las=2) 
   	#Recall that for normally distributed data mandel's h should 
   	#have the same dispersion (and IQR) for all groups. But outliers adversely 
   	#affect the estimate of dispersion, so the interquartile ranges differ.
   	#The same effect also accounts for the many boxplot outliers visible
   	#inside the classical Mandel indicator lines; the indicators also 
   	#assume normality.
   	
   #with separators:
   boxplot(h, las=2, separators=TRUE)
   
   #With different labels and label colours:
   boxplot(h, las=2, outlier.labels=paste(1:nrow(h)), col.lab=1:5) 
   
   #... and a horizontal variant (note use of pos to change label positions)
   par(omd=c(0.1,1,0,1))		#to make room for axis labels
   boxplot(h, las=1, separators=TRUE, horizontal=TRUE, pos=1)

</code></pre>

<hr>
<h2 id='buildCor'>
Functions to build correlation and covariance matrices.
</h2><span id='topic+buildCor'></span><span id='topic+buildCov'></span><span id='topic+updateCor'></span><span id='topic+updateCov'></span>

<h3>Description</h3>

<p>Functions to build and update correlation and covariance matrices using a compact
specification of off-diagonal terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildCor(n, cors)

updateCor(cor, cors, cor.names)

buildCov(s, covs, vars = s^2, cors, cov.names)

updateCov(cov, covs, cors, cov.names)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildCor_+3A_n">n</code></td>
<td>
<p>scalar: number of rows/colums required in correlation matrix. 
</p>
</td></tr>
<tr><td><code id="buildCor_+3A_cors">cors</code>, <code id="buildCor_+3A_covs">covs</code></td>
<td>
<p>3-column matrix or data frame specification of individual 
correlation or covariance terms. Can also be a vector of length 3. See Details.</p>
</td></tr>
<tr><td><code id="buildCor_+3A_s">s</code>, <code id="buildCor_+3A_vars">vars</code></td>
<td>
<p>vector of standard deviations or variances respectively. One of 
<code>s</code> or <code>vars</code> must be present.</p>
</td></tr>
<tr><td><code id="buildCor_+3A_cor.names">cor.names</code>, <code id="buildCor_+3A_cov.names">cov.names</code></td>
<td>
<p>vectors of names for the rows and columns of the returned 
matrix. <code>cov.names</code> defaults to <code>names(s)</code> if <code>s</code> is named.</p>
</td></tr>
<tr><td><code id="buildCor_+3A_cor">cor</code>, <code id="buildCor_+3A_cov">cov</code></td>
<td>
<p>correlation or covariance matrix requiring amendment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>buildCor</code>, the size of the returned correlation matrix is set using <code>n</code>; 
an <code>n</code> by <code>n</code> correlation matrix is returned. For <code>buildCov</code> the size is 
set to <code>length(s)</code> by <code>length(s)</code>.
</p>
<p>Each row of <code>cors</code> specifies a correlation term <code class="reqn">r_{ij}</code> in the form
<code class="reqn">(i, j, r_{ij})</code>. That is, the first two columns give the row 
and column in the desired correlation matrix, and the third gives the relevant 
correlation coefficient. On constructing or updating the correlation matrix, 
<code class="reqn">r_{ij}</code> is set equal to <code class="reqn">r_{ji}</code>, so it is only necessary 
to specify one of <code class="reqn">r_{ij}</code> or <code class="reqn">r_{ji}</code>.
</p>
<p><code>covs</code> specifies covariance terms in the same way except that the third column of 
<code>covs</code> must be a covariance.
</p>
<p>If either <code>cors</code>  or <code>covs</code> is a vector of length 3, it is coerced 
to a matrix of three columns. 
</p>
<p>If <code>cor.names</code> or <code>cov.names</code> are present, the matrix returned has 
dimnames set to the names supplied.
</p>
<p>All four functions test for positive definite return values and generate a 
warning if not positive definite.
</p>


<h3>Value</h3>

<p>A square symmetric correlation or covariance matrix.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None.
</p>


<h3>See Also</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    #Duplicate correlation for example for uncert()
    buildCor(4, cors=c(3, 4, 0.5))
               
    
    #Multiple correlations
    r&lt;-buildCor(3, cors=rbind( c(1,2,0.5), c(2,3,0.25) ) )
    r
    
    updateCor(r, cors=c(1,3,0.13)) #perhaps more realistic
    
    buildCov(1:3, cors=rbind( c(1,2,0.5), c(2,3,0.25),c(1,3,0.13) ) )
    
</code></pre>

<hr>
<h2 id='chromium'>
Chromium data for two different materials included in an interlaboratory study
</h2><span id='topic+chromium'></span>

<h3>Description</h3>

<p>Chromium data for two different materials included in an interlaboratory study 
intended to provide data for certification of a reference material.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("chromium")</code></pre>


<h3>Format</h3>

<p>A data frame with 28 observations on the following 2 variables.
</p>

<dl>
<dt><code>QC</code></dt><dd><p>Chromium concentrations (ug/kg) reported on a 
material used as a quality control material</p>
</dd>
<dt><code>RM</code></dt><dd><p>Chromium concentrations (ug/kg) reported on a 
candidate reference material material used as a quality control material</p>
</dd>
</dl>



<h3>Details</h3>

<p>Chromium data for two different materials included in an interlaboratory study 
intended to provide data for certification of a crab tissue reference material. 
The study included a previously certified reference material (near end of stock) to 
serve as a quality control (QC) check. Laboratories were asked to report five replicate 
measurements on the candidate reference material and three for the QC material. Each 
row in the data set corresponds to the mean of replicate results reported by each laboratory. 
</p>
<p>Inspection of the data suggests that one laboratory interchanged or mislabelled 
the test materials; this is hard to see in univariate plots but relatively easy 
to see in a Youden plot (a type of pairwise scatter plot - see <code><a href="#topic+youden.plot">youden.plot</a></code>).
</p>


<h3>Source</h3>

<p>Private communication - Pending publication
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromium)
yplot(chromium)
</code></pre>

<hr>
<h2 id='contribs'>
Extract contributions from an 'uncert' object.
</h2><span id='topic+contribs'></span>

<h3>Description</h3>

<p>Extracts the individual nonzero contributions 
to the combined uncertainty in an 'uncert' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contribs(object, scope, as.sd = FALSE, keep.sign = TRUE, 
	simplify = TRUE, expand.dot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contribs_+3A_object">object</code></td>
<td>

<p>An object of class <code>uncert</code> returned by <code><a href="#topic+uncert">uncert</a></code> or  <code><a href="#topic+uncertMC">uncertMC</a></code></p>
</td></tr>
<tr><td><code id="contribs_+3A_scope">scope</code></td>
<td>

<p>An expression, one-sided formula or character vector describing the particular variables
for which contributions are desired. If missing, contributions for all variables
are returned.
</p>
</td></tr>
<tr><td><code id="contribs_+3A_as.sd">as.sd</code></td>
<td>
<p> logical; controls whether values are returned in the form of 
standard uncertainties or variance contributions. See Details.
</p>
</td></tr>
<tr><td><code id="contribs_+3A_keep.sign">keep.sign</code></td>
<td>
<p>logical; controls whether the sign of the cobntributions is appended to
the return value when <code>as.sd=TRUE</code>. See Details.
</p>
</td></tr>
<tr><td><code id="contribs_+3A_simplify">simplify</code></td>
<td>
<p> logical. If <code>simplify=FALSE</code> the contribution matrix itself 
is returned. If <code>simplify=TRUE</code>, only the requested (by <code>scope</code>) 
nonzero elements of the contribution matrix are returned, as a vector.  
See Details for the treatment of off-diagonal terms
</p>
</td></tr>
<tr><td><code id="contribs_+3A_expand.dot">expand.dot</code></td>
<td>
<p>logical; if <code>TRUE</code>, &lsquo;.&rsquo; in a formula <code>scope</code> is
expanded to all contributions including pairwise contributions. If <code>FALSE</code>,
the dot operator implies only the single-variable terms. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>contribs</code> calculates the contribution matrix <code class="reqn">C</code> where 
<code class="reqn">C_{i,j}=(c_iu_i)(c_ju_j)r_{i,j}</code>. 
In general, these values are possibly negative (co)variance contributions 
to the variance (squared standard uncertainty) in <code class="reqn">y</code>. In GUM notation 
(&lsquo;the GUM&rsquo; is JCGM 100 (2008) - see references), the diagonal elements of 
<code>C</code> are squared standard uncertainties in <code class="reqn">y</code>. The form of the 
return value depends on <code>simplify</code>, <code>as.sd</code> and <code>keep.sign</code>.
</p>
<p>If <code>as.sd</code> is <code>FALSE</code> (the default), contributions <code class="reqn">C_{ij}</code>
are returned unchanged. For the diagonal elements of <code class="reqn">C</code> (contributions for 
individual individual terms), this form corresponds to squared standard uncertainties 
<code class="reqn">u_i^2(y)</code> in GUM notation. 
</p>
<p>If <code>as.sd=TRUE</code>, the magnitude of the value returned is <code class="reqn">\sqrt{|C_{ij}|}</code>.
For the diagonal elements of <code class="reqn">C</code> this corresponds to standard uncertainties 
<code class="reqn">u[i]{y}</code> in GUM notation.
</p>
<p>If <code>as.sd=TRUE</code>, <code>keep.sign</code> controls whether the values are signed or 
returned as absolute values. If <code>keep.sign=TRUE</code>, the value returned is 
<code class="reqn">sign(C_{ij}\sqrt{|C_{ij}|}{sign(C[i,j]sqrt( abs(C[i,j] ) )}</code>. If false, 
the absolute value is returned. Note that the sign is returned solely to indicate 
the direction of the original contribution. <code>keep.sign</code> has no effect if 
<code>as.sd=FALSE</code>.
</p>
<p>If <code>simplify=FALSE</code> (the default), the requested elements of the contribution matrix 
<code class="reqn">C</code> are returned as a matrix. If <code>simplify=FALSE</code>, the return value is a vector 
containing only those terms with nonzero values in the associated correlation matrix. 
The threshold for deciding a correlation is nonzero is that its magnitude is greater
than <code>2*.Machine$double.eps</code>.
</p>
<p>Off-diagonal terms for the same pair of variables are summed, that is, for 
the pair <code class="reqn">(C_{ij}, C_{ji}), j \neq i</code>
the (single) value returned is <code class="reqn">C_{i,j}+C_{j,i}=2C_{i,j}</code>. 
</p>
<p>The contributions returned can be limited to a chosen subset using <code>scope</code>; 
only the terms involving variables included in <code>scope</code> are returned. 
<code>scope</code> can be an expression, formula or character vector of variable names. 
If an expression or formula, only those contributions involving variables in 
the expression or formula are returned. 
</p>
<p>Any variable names in <code>scope</code> which are not present in 
<code>row.names(object$budget)</code> are silently ignored except for 
the formula specification which will return an error.
</p>
<p>If <code>simplify=FALSE</code>, the matrix returned always contains all contributions 
involving individual variables in <code>scope</code>. If <code>simplify=TRUE</code>, however, specifying
<code>scope</code> as a formula provides additional control over the returned contributions: 
</p>
<p>If a formula, <code>scope</code> accepts the usual model formula operators &lsquo;.&rsquo;, &lsquo;+&rsquo;, &lsquo;-&rsquo;,
&lsquo;*&rsquo; and &lsquo;^&rsquo;, but the interpretation is not quite identical to <code>lm</code>.
</p>
<p>First, if present, &lsquo;.&rsquo; is taken by default as &lsquo;all contributions&rsquo;, implying 
all single terms and all pairwise terms (like &lsquo;<code>.^2</code>)&rsquo; in other formula specifications). 
This can be disabled by specifying <code>expand.dot=FALSE</code>.
</p>
<p>The negation operator &lsquo;-&rsquo; removes terms, but removing a single variable also removes any 
associated covariance contributions. For example, <code>scope=~.-A</code> is expanded to all single 
and pairwise contributions to the uncertanty budget that do not involve <code>A</code>.
</p>
<p>Interaction-like terms of the form <code>A:B</code> are interpreted as indicating the <em>total</em> 
off-diagonal contribution, that is, <code>A:B</code> is equivalent to <code>B:A</code> and the associated 
value returned is based on <code class="reqn">C_{i,j}+C_{j,i}</code>. 
</p>
<p>Cross-terms like <code>~A*B</code> are supported and expand, as usual, to <code>~A+B+A:B</code>. 
</p>
<p>Unlike the two other scope specifications, single terms in the formula do <em>not</em>
automatically imply off-diagonal terms; <code>A+B</code> will not return the off-diagonal contribution for 
<code>A</code> and <code>B</code>. Use <code>A*B</code> or <code>(A+B)^2</code> etc. to get off-diagonal contributions.  
Cross-terms of order above two are ignored so <code>A*B*C</code> safely returns only the set of 
individual and pairwise terms, but it is perhaps more precise to use <code>(A+B+C)^2</code>.
</p>
<p><code>I()</code> and other operators or functions are not supported.
</p>


<h3>Value</h3>

<p>A named vector or matrix of contributions. Names for off-diagonal contributions 
in the vector format are constructed from the names of the two contributing variables.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>JCGM 100 (2008) <em>Evaluation of measurement data - Guide to the expression
of uncertainty in measurement</em>. <a href="http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf">http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf</a>. 
(JCGM 100:2008 is a public domain copy of ISO/IEC <em>Guide to the expression
of uncertainty in measurement</em> (1995) ). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncert-class">uncert-class</a></code>,  <code><a href="#topic+uncert">uncert</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example with negative correlation
  x &lt;- list(a=1, b=3, c=2, d=11)
  u &lt;- lapply(x, function(x) x/10)
  u.cor&lt;-diag(1,4)
  u.cor[3,4]&lt;-u.cor[4,3]&lt;- -0.5
  u.form.c&lt;-uncert(~a+b*2+c*3+d/2, x, u, method="NUM", cor=u.cor)

  contribs(u.form.c, simplify=FALSE)
  contribs(u.form.c)
  contribs(u.form.c, as.sd=TRUE)
  contribs(u.form.c, as.sd=TRUE, keep.sign=FALSE)

  contribs(u.form.c, scope=c("a", "c", "d") )

  #Effects of formula specification for scope:
  contribs(u.form.c, ~.)           #All contributions
  contribs(u.form.c, ~(a+b+c+d)^2) #same as ~.
  contribs(u.form.c, ~a+b+c+d )    #single-variable contributions only
  contribs(u.form.c, ~., expand.dot=FALSE )    # as ~a+b+c+d
  contribs(u.form.c, ~.-d)         #Drops d and c:d
  contribs(u.form.c, ~.-c:d)
  contribs(u.form.c, ~c+d)
  contribs(u.form.c, ~c*d)

</code></pre>

<hr>
<h2 id='cov.dellipse'>
Constructs a covariance and location object for use in plotting data ellipses. 
</h2><span id='topic+cov.dellipse'></span>

<h3>Description</h3>

<p>Constructs a covariance matrix and associated location using a variety 
of (possibly robust) estimators. The returned object is suitable for use 
by <code><a href="#topic+plot.d.ellipse">plot.d.ellipse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.dellipse(x, y = NULL, cov.method = c("spearman", "kendall", "pearson", 
                           "MCD", "OGK", "GK", "gk", "rgk", "mcd", "mve"), 
                           scalefn = NULL, locfn = NULL, cov.control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.dellipse_+3A_x">x</code></td>
<td>

<p>An R <code>numeric</code> object. Can be a vector (in which case <code>y</code> must be specified 
and of the same length) or a two-column numeric matrix.
</p>
</td></tr>
<tr><td><code id="cov.dellipse_+3A_y">y</code></td>
<td>

<p>A numeric vector of the same length as <code>x</code>. It is an error to provide <code>y</code> 
in addition to a two-column matrix for <code>x</code>.
</p>
</td></tr>
<tr><td><code id="cov.dellipse_+3A_cov.method">cov.method</code></td>
<td>

<p>A character value specifying the covariance method used.
</p>
</td></tr>
<tr><td><code id="cov.dellipse_+3A_scalefn">scalefn</code></td>
<td>

<p>A function that computes univariate scale and (optionally) location estimates from a 
numeric vector. 
If provided, <code>scalefn()</code> should return a single numeric value containing a scale 
(standard deviation) estimate. For many covariance methods this can be a simple
scale estimator. For cov.method &quot;GK&quot;, scalefn must accept 
an additional argument <code>mu.too</code>. When mu.too is true, <code>scalefn()</code> should 
return a numeric vector of length 2 containing location and scale estimates. See 
<code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code>, <code><a href="robustbase.html#topic+s_Qn">s_Qn</a></code>,<code><a href="robustbase.html#topic+s_mad">s_mad</a></code>, or <code><a href="robustbase.html#topic+s_IQR">s_IQR</a></code> 
for examples to be used as <code>scalefn</code> argument.
</p>
</td></tr>
<tr><td><code id="cov.dellipse_+3A_locfn">locfn</code></td>
<td>

<p>A function that computes univariate location estimates from a numeric vector. 
If used, <code>locfn()</code> should return a single numeric value containing a location 
(mean) estimate. 
</p>
</td></tr>
<tr><td><code id="cov.dellipse_+3A_cov.control">cov.control</code></td>
<td>

<p>A named list of arguments passed to the covariance calculation used. Note that this can 
override <code>scalefn</code> and <code>locfn</code>; see below for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cov.dellipse</code> is a wrapper for a range of covariance estimation methods found in 
various packages. Its operation and defaults depend on the particular covariance 
estimator specified by <code>cov.method</code>.  Details for each are as follows.
</p>

<dl>
<dt><code>spearman</code>, <code>kendall</code></dt><dd><p>By default, the median and mad are used as location and scale respectively, 
and the covariance is calculated from the product of scale estimates and the 
Spearman rank correlation or Kendall's tau respectively. 
If either <code>scalefn</code> or <code>locfn</code>is supplied, <code>scalefn</code> is used for scale estimation and 
<code>locfn</code> for location. For both <code>spearman</code> and <code>kendall</code>, <code>scalefn</code> is 
only used as a scale estimator and need not take a <code>mu.too</code> argument.</p>
</dd>
<dt><code>pearson</code></dt><dd><p>By default, the mean and sd are used as location and scale respectively, 
and the covariance is calculated from the product of scale estimates and the 
Pearson correlation. 
If either <code>scalefn</code> or <code>locfn</code>is supplied, <code>scalefn</code> is used for scale 
estimation and <code>locfn</code> for location, making it possible (if not very sensible) to 
use a combination of robust scale or location functions with the Pearson correlation coefficient.
For this case,  <code>scalefn</code> is only used as a scale estimator and need 
not take a <code>mu.too</code> argument.</p>
</dd>
<dt><code>MCD</code>, <code>mcd</code></dt><dd><p>Both compute the Minimum Covariance Determinant (MCD) estimator, a robust multivariate 
location and scale estimate with a high breakdown point, via the 'Fast MCD' or 'Deterministic MCD' 
(&quot;DetMcd&quot;) algorithm. <code>"MCD"</code> uses the implementation <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> in the robustbase package; 
<code>"mcd"</code> uses <code><a href="MASS.html#topic+cov.mcd">cov.mcd</a></code> in the MASS package.
Neither require or use <code>scalefn</code> or <code>locfn</code>. 
Note that these MCD implementations differ appreciably for small samples (at least to n=60). <code>MCD</code> 
includes consistency and finite sample correction whereas <code>mcd</code> apparently does not apply a finite 
sample correction. As a result, the <code>mcd</code> scales can be considerably smaller for modest 
data set sizes.</p>
</dd>
<dt><code>OGK</code></dt><dd><p>Computes the orthogonalized pairwise covariance matrix estimate described by Maronna and Zamar (2002),
as implemented by the <code><a href="robustbase.html#topic+covOGK">covOGK</a></code> in the robustbase package. 
By default, scale and location use <code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code> from robustbase. Alternatives 
can be specified either by providing <strong>both</strong> <code>scalefn</code> and <code>locfn</code> or by including
an argument <code>sigmamu</code> in <code>cov.control</code>, which is passed to <code>covOGK</code>. See 
<code><a href="robustbase.html#topic+covOGK">covOGK</a></code> for a description of <code>sigmamu</code>.
If <code>sigmamu</code> is not present in <code>cov.control</code> and both <code>scalefn</code> and <code>locfn</code> 
are provided, scale and location are constructed from <code>scalefn</code> and <code>locfn</code>. If only one
of these is provided, a warning is issued and <code>]{scaleTau2}</code> is used.
</p>
</dd>
<dt><code>GK</code></dt><dd><p>Computes a simple pairwise covariance estimate suggested by Gnanadesikan and Kettenring (1972),
as implemented by the <code><a href="robustbase.html#topic+covGK">covGK</a></code> in the robustbase package. 
By default, scale and location use <code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code> from robustbase. Alternatives 
can be specified either by providing <code>scalefn</code> and <code>locfn</code> or by including
an argument <code>scalefn</code> in <code>cov.control</code>, which is passed to <code>covGK</code>. See 
<code><a href="robustbase.html#topic+covGK">covGK</a></code> for a description of <code>scalefn</code>.
If <code>scalefn</code> is not present in <code>cov.control</code>, scale and location are constructed from <code>scalefn</code> 
and <code>locfn</code>. If <code>locfn</code> is omitted, <code>scalefn</code> is used if it takes an argument <code>mu.too</code> 
and the median is used otherwise.</p>
</dd> 
<dt><code>gk</code></dt><dd><p>As <code>GK</code>, except that the variables are scaled to unit (robust) sd (using <code>scalefn</code>) before 
calculating the covariance (which is then rescaled). This can prevent large scale differences from 
masking outliers in a variable with small scale.</p>
</dd> 
<dt><code>rgk</code></dt><dd><p>Implements  Gnanadesikan and Kettenring's second covariance estimate 
based on scaled variables <code class="reqn">(Z_1, Z_2)</code> and a robust correlation <code class="reqn">\rho^*</code>
calculated as 
</p>
<p style="text-align: center;"><code class="reqn">\rho^*=(\hat{\sigma}_{+}^{*2} - \hat{\sigma}_{-}^{*2})/(\hat{\sigma}_{+}^{*2} - \hat{\sigma}_{-}^{*2})</code>
</p>

<p>where <code class="reqn">\hat{\sigma}_{+}^{*2}</code> and <code class="reqn">\hat{\sigma}_{-}^{*2}</code> are robust variances of 
<code class="reqn">(Z_1+Z_2)</code> and <code class="reqn">(Z_1-Z_2)</code> respectively, calculated using <code>scalefn</code>. 
The advantage over <code>"gk"</code> and <code>"GK"</code> is that the correlation
coefficient is guaranteed to be in <code class="reqn">[-1,1]</code>, making for a positive definite covariance matrix. Scaling also
helps prevent large scale differences from masking outliers in a variable with small scale.</p>
</dd> 
<dt><code>mve</code></dt><dd><p>Uses uses <code><a href="MASS.html#topic+cov.mve">cov.mve</a></code> in the MASS package, which is based on the location and covariance matrix for 
a minimum volume ellipsoid. The method neither requires nor uses <code>scalefn</code> or <code>locfn</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>cov.dellipse</code>, which is a list with (at least) components
</p>
	
<dl>
<dt>method</dt><dd><p>Character string describing method; identical to <code>cov.method</code></p>
</dd>
<dt>cov</dt><dd><p>2x2 covariance matrix</p>
</dd>
<dt>cor</dt><dd><p>2x2 correlation matrix</p>
</dd>
<dt>center</dt><dd><p>vector (length 2) specifying centre of ellipse</p>
</dd>
<dt>scale</dt><dd><p>vector, length 2, specifying scale estimates for each variable</p>
</dd>
<dt>n.obs</dt><dd><p>number of points (rows) used in the covariance estimate</p>
</dd>
</dl>

<p>This list is intended to be consistent with that returned by <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>.
</p>


<h3>Author(s)</h3>

<p>Stephen L R Ellison
</p>


<h3>References</h3>

<p>Maronna, R.A. and Zamar, R.H. (2002) Robust estimates of location and dispersion of 
high-dimensional datasets; Technometrics <b>44(4)</b>, 307-317.
</p>
<p>Gnanadesikan, R. and John R. Kettenring (1972) Robust estimates, residuals, 
and outlier detection with multiresponse data. Biometrics <b>28</b>, 81-124
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+cov.rob">cov.rob</a></code> in MASS, <code><a href="robustbase.html#topic+covMcd">covMcd</a></code>, <code><a href="robustbase.html#topic+covOGK">covOGK</a></code> and 
<code><a href="robustbase.html#topic+covGK">covGK</a></code> in robustbase.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potassium)
cov.dellipse(potassium) #Defaults to Spearman rank correlation

#With different method
cov.dellipse(potassium, cov.method="OGK") 

#Same as above but specifying control parameters
library(robustbase) #For scaleTau2
cov.dellipse(potassium, cov.method="OGK", cov.control=list(sigmamu=scaleTau2)) 
	
#With individually specified (mad) scale
cov.dellipse(potassium, cov.method="GK", scalefn=mad) 
	#Defaults to median for location because mad()
	#does not accept a mu.too argument

cov.dellipse(potassium, cov.method="GK", scalefn=scaleTau2) 
	#Defaults to specified scalefn for location because scaleTau2 
	#accepts mu.too=TRUE

</code></pre>

<hr>
<h2 id='data.ellipse'>
Construct data ellipses suitable for use with Youden plots.
</h2><span id='topic+data.ellipse'></span><span id='topic+summary.d.ellipse'></span><span id='topic+d.ellipse'></span><span id='topic+print.d.ellipse'></span>

<h3>Description</h3>

<p>Constructs and optionally plots a set of probability ellipses for a bivariate 
normal distribution with defined centre and covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data.ellipse(cov, probs = 0.95, plot = TRUE, npoints = 100, ...)

	## S3 method for class 'd.ellipse'
summary(object, ...)

	## S3 method for class 'd.ellipse'
print(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.ellipse_+3A_cov">cov</code></td>
<td>

<p>Covariance and location object of class <code>cov.dellipse</code> as returned by <code>cov.dellipse()</code>
</p>
</td></tr>
<tr><td><code id="data.ellipse_+3A_probs">probs</code></td>
<td>

<p>A vector of probabilities at which ellipses will be constructed.
</p>
</td></tr>
<tr><td><code id="data.ellipse_+3A_plot">plot</code></td>
<td>

<p>Logical specifying whether the ellipses constructed will additionally be plotted. 
If <code>TRUE</code>, the result is plotted using <code>plot.d.ellipse()</code>
</p>
</td></tr>
<tr><td><code id="data.ellipse_+3A_npoints">npoints</code></td>
<td>

<p>Integer number of points for each quadrant of the ellipses returned.
</p>
</td></tr>
<tr><td><code id="data.ellipse_+3A_object">object</code></td>
<td>

<p>Object of class <code>d.ellipse</code> (for summary method).
</p>
</td></tr>
<tr><td><code id="data.ellipse_+3A_x">x</code></td>
<td>

<p>Object of class <code>d.ellipse</code> (for print method.
</p>
</td></tr>
<tr><td><code id="data.ellipse_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods, particularly <code>plot.d.ellipse</code> and, for <code>print</code>,
<code>format</code> and <code>print.default</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data.ellipse</code> constructs and returns one set of x, y coordinates for each value of 
<code>probs</code>, in a form that can be passed directly to <code>polygon</code>.
</p>
<p>Ellipses are constructed from the upper <code>probs</code> quantile of the F distribution using
</p>
<p><code>T = sqrt( 2 * (n - 1) * qf(probs, 2, n - 1)/(n - 2))</code>
</p>
<p>where <code>n</code> is the number of pairs used in forming the covariance matrix.
If the number of points is missing or NA, <code>Inf</code> is substituted.
</p>
<p>Summary and print methods are provided. The summary method returns a list with the 
same names as class <code>d.ellipse</code>, each containing a default summary of the respective 
member of the <code>d.ellipse</code> object. The print method returns its argument invisibly.
</p>


<h3>Value</h3>

<p>An object of class <code>d.ellipse</code>, consisting of:
</p>
<table>
<tr><td><code>ellipses</code></td>
<td>
<p>A named list of ellipsoids named for each probability in <code>probs</code>. 
Each is a <code class="reqn">4*npoints\times 2</code> matrix suitable for passing direct to 
<code>polygon</code>.</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>Numeric vector of probabilities as supplied by <code>probs</code></p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>Covariance object of class  <code>cov.dellipse</code> as provided in <code>cov</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>S L R Ellison
</p>


<h3>References</h3>

<p>ISO 13528:2005 Statistical methods for use in proficiency testing by 
interlaboratory comparisons. (2005) International organization for 
Standardizaton, Geneva
</p>
<p>Jackson, J. E. (1956) <em>Quality control methods for two related variables</em>.
Industrial Quality Control, Vol. 7, pp. 2-6 
</p>
<p>Jackson, J. E. (1959) <em>Control Methods for Several Related Variables</em>.
Technometrics, Vol. 1, pp. 359-377
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.dellipse">cov.dellipse</a></code>, <code><a href="#topic+plot.d.ellipse">plot.d.ellipse</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromium)
cov.Cr &lt;- cov.dellipse(chromium)
dellipse.Cr &lt;- data.ellipse(cov.Cr, plot=FALSE)
summary(dellipse.Cr)
</code></pre>

<hr>
<h2 id='derSimonian-Laird'>
derSimonian-Laird estimator
</h2><span id='topic+dsl'></span><span id='topic+dsl.default'></span>

<h3>Description</h3>

<p>Calculates derSimonian-Laird estimate of location, with standard error, assuming 
a random-effects model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	dsl(x, ..., na.rm = FALSE)

	## Default S3 method:
dsl(x, s, n = NULL, groups = NULL, ..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derSimonian-Laird_+3A_x">x</code></td>
<td>
<p>numeric vector of mean values for groups, or (if <code>groups</code> 
is given) of individual observations</p>
</td></tr>
<tr><td><code id="derSimonian-Laird_+3A_s">s</code></td>
<td>
<p>numeric vector of length <code>length(x)</code> of standard deviations or 
standard uncertainties associated with the values <code>x</code>.
</p>
</td></tr>
<tr><td><code id="derSimonian-Laird_+3A_n">n</code></td>
<td>
<p>integer giving the number of observations in each group. May be a vector 
of length <code>length(x)</code>. If <code>n</code> is <code>NULL</code>, <code>s</code> is interpreted as 
a vector of standard uncertainties or standard errors. <code>n</code> is recycled 
to <code>length(x)</code>
</p>
</td></tr>
<tr><td><code id="derSimonian-Laird_+3A_groups">groups</code></td>
<td>
<p>factor, or vetor which can be coerced to factor, of groups. If 
present, <code>x</code> is interpreted as a vector of individual observations 
and <code>s</code> and <code>n</code> ignored, if present, with a warning. 
</p>
</td></tr>
<tr><td><code id="derSimonian-Laird_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if <code>TRUE</code>,  <code>NA</code> values are removed 
before processing.
</p>
</td></tr>
<tr><td><code id="derSimonian-Laird_+3A_...">...</code></td>
<td>
<p>Further parameters passed to other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dsl</code> implements the derSimonian-Laird random-effects estimate of location,
using the implementation described by Jackson (2010).
</p>
<p>The estimator assumes a model of the form
</p>
<p style="text-align: center;"><code class="reqn">x_i=\mu+b_i+e_i</code>
</p>

<p>in which <code class="reqn">b_i</code> is drawn from <code class="reqn">N(0, \tau^2)</code> and
<code class="reqn">e_i</code> is drawn from <code class="reqn">N(0, \sigma_i^2)</code>.
</p>
<p>The estimator forms a direct calculation of <code class="reqn">\tau</code>, and uses this to 
form revised estimates of standard error <code class="reqn">\sqrt{s_i^2+\tau^2}</code> 
in <code>x</code>, calculates weights as the inverse of these and in turn calculates a 
weighted mean, allowing for any calculated excess variance <code class="reqn">\tau^2</code>.
</p>
<p>This implementation permits input in the form of:
</p>

<ul>
<li><p> means <code>x</code> and standard errors <code>s</code>, in which case neither <code>n</code> nor 
<code>groups</code> are supplied;
</p>
</li>
<li><p> means <code>x</code>, standard deviations <code>s</code> and group size(s) <code>n</code>, 
standard errors then being calculated as <code>s/sqrt(n)</code>
</p>
</li>
<li><p> individual observations <code>x</code> with a groupinf factor <code>groups</code>, in 
which case standard errors are calculated from the groups using <code>tapply</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A loc.est object; see loc.est for details. In the returned object, individual
values <code>xi</code> are always input means (calculated from groups and <code>n</code> as 
necessary); <code>method.details</code> is returned as a list containing:
</p>

<dl>
<dt>mu</dt><dd><p>The estimated location.
</p>
</dd>
<dt>s</dt><dd><p>The standard error in the location.
</p>
</dd>
<dt>tau</dt><dd><p>The excess variance (as a standard deviation).
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>S L R Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Jackson et al. (2010) J Stat Plan Inf 140, 961-970 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loc.est-class">loc.est-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #PCB measurements in a sediment from Key Comparison CCQM-K25
  #s are reported standard uncertainties
  pcb105 &lt;- data.frame(x=c(10.21, 10.9, 10.94, 10.58, 10.81, 9.62, 10.8),
               s=c(0.381, 0.250, 0.130, 0.410, 0.445, 0.196, 0.093))
               		
  with( pcb105, dsl(x, s) )

</code></pre>

<hr>
<h2 id='drop1.uncert'>
Single variable deletions from the uncertainty budget.
</h2><span id='topic+drop1.uncert'></span><span id='topic+drop1.uncertMC'></span><span id='topic+print.drop1.uncert'></span><span id='topic+plot.drop1.uncert'></span>

<h3>Description</h3>

<p><code>drop1</code> calculates revised combined uncertainty for single variable deletions from 
an object of class 'uncert'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uncert'
drop1(object, scope, simplify = TRUE, 
	which=c("% Change", "var", "u", "var.change", "u.change"), ...)

## S3 method for class 'uncertMC'
drop1(object, scope, simplify = TRUE, 
	which=c("% Change", "var", "u", "var.change", "u.change"), ...)

#Print and plot methods 
## S3 method for class 'drop1.uncert'
print(x, ..., digits=2)

## S3 method for class 'drop1.uncert'
plot(x, ..., 
	which=c("% Change", "var", "u", "var.change", "u.change"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop1.uncert_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;uncert&rsquo; or &lsquo;uncertMC&rsquo;.</p>
</td></tr>
<tr><td><code id="drop1.uncert_+3A_scope">scope</code></td>
<td>
<p>character vector, expression or formula containing the list of 
variables to be dropped. If missing, all variables in object$budget are taken
as scope.</p>
</td></tr>
<tr><td><code id="drop1.uncert_+3A_simplify">simplify</code></td>
<td>
<p>logical. If <code>simplify=TRUE</code>, the return value is simplified to 
a named vector. If <code>FALSE</code>, all forms available (see <code>which</code>) are 
returned in a data frame.</p>
</td></tr>
<tr><td><code id="drop1.uncert_+3A_which">which</code></td>
<td>
<p> logical; controls the form of information returned when <code>simplify=TRUE</code>. 
Possible values are:
</p>

<dl>
<dt><code>"var"</code></dt><dd><p>The modified values of <code class="reqn">u(y)^2</code>.</p>
</dd>
<dt><code>"u"</code></dt><dd><p>The modified values of <code class="reqn">u(y)</code>.</p>
</dd>
<dt><code>"var.change"</code></dt><dd><p>The signed changes in <code class="reqn">u(y)^2</code>.</p>
</dd>
<dt><code>"u.change"</code></dt><dd><p>The signed changes in <code class="reqn">u(y)</code>.</p>
</dd>
<dt><code>"% Change"</code></dt><dd><p>The percentage change in <code class="reqn">u(y)</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="drop1.uncert_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;drop1.uncert&rsquo; returned by <code>drop1.uncert</code>.
</p>
</td></tr>
<tr><td><code id="drop1.uncert_+3A_...">...</code></td>
<td>
<p>Further objects passed to other functions.
</p>
</td></tr>
<tr><td><code id="drop1.uncert_+3A_digits">digits</code></td>
<td>
<p>number of digits used to format the output. See the <code>digits</code> argument
of <code><a href="base.html#topic+format">format</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By analogy with <code>drop1</code>, <code>drop1.uncert</code> perfoms single variable deletions from 
the uncertainty budget in <code>object</code>, calculates the resulting uncertainty and returns the 
results in the form requested by <code>simplify</code> and <code>which</code>.
</p>
<p>&lsquo;Single variable deletion&rsquo; of a variable <code class="reqn">x_i</code> is equivalent to setting the uncertainty 
<code class="reqn">u(x_i)</code> to zero. Note that this also sets covariance terms involving <code class="reqn">x_i</code> 
to zero. <code>drop1.uncert</code> does not support the deletion of single <em>terms</em> such as <code class="reqn">cov(i, j)</code>.
</p>
<p>In the case of &lsquo;uncertMC&rsquo; objects, <code>drop1</code> currently requires <code>object$MC$x</code> to be 
present (i.e. <code>uncertMC</code> called with <code>keep.x=TRUE</code>). The <code>uncertMC</code> 
method does not support correlation.
</p>
<p>For <code>which="var.change"</code>, <code>which="u.change"</code> and <code>which="% Change"</code> the 
change on dropping a variable is negative if the uncertainty reduces on removing the variable.
</p>
<p>The print method simply prints the output with a header formed from the <code>expr</code> attribute 
and with '%' appended to the &quot;% Change&quot; column.
</p>
<p>The plot method produces a barplot of the chosen data column.  A plot for each value in <code>which</code>
is produced. Arguments in &lsquo;...&rsquo; are passed to barplot. If not already present in &lsquo;...&rsquo; 
a default main title and ylab are used. The <code>expr</code> attribute is shown as marginal text if not NA.
</p>


<h3>Value</h3>

<p>If <code>simplify=FALSE</code>, an object of class &lsquo;drop1.uncert&rsquo;, consisting of a 
data frame with row names corresponding to <code>row.names(object$budget)</code>, columns 
corresponding to all possible values of <code>which</code> in the order <code>"var", "u", "var.change",
"u.change", "% Change"</code>, and an attribute <code>expr</code> containing a copy of the <code>expr</code> 
value of the 'uncert' object to which <code>drop1.uncert</code> is applied.
</p>
<p>If <code>simplify=TRUE</code>, the column of the above data frame corresponding to <code>which</code>
is returned as a vector with names <code>row.names(object$budget)</code>.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison, <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncert">uncert</a></code>,  <code><a href="#topic+uncert-class">uncert-class</a></code>,  <code><a href="base.html#topic+format">format</a></code> for <code>digits</code>, 
<code><a href="graphics.html#topic+barplot">barplot</a></code> for available plot parameters. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  

  #Continuing the example from plot.uncert:
  require(graphics)
  
  d1&lt;-drop1(u.form.c, simplify=FALSE)
  d1
  
  plot(d1)
  
  drop1(u.form.c)         #% change only
  
  

</code></pre>

<hr>
<h2 id='duewer.plot'>
Duewer concordance/apparent precision plot 
</h2><span id='topic+duewer.plot'></span><span id='topic+duewer.plot.default'></span><span id='topic+dplot'></span>

<h3>Description</h3>

<p>Produces a Duewer concordance/apparent precision plot, showing relative precision or
uncertainty plotted against (relative) deviation from assigned value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
dplot(x, ...)

duewer.plot(x, ...)

## Default S3 method:
duewer.plot(x,s,mu=median(x),sigma=mad(x), s0=median(s), labels=NA,
             radius=1:3, units=c("z","x"), 
             main, xlab, ylab, xlim, ylim,  
             at.xax=NULL, at.yax=NULL, aspect, 
             col.contours="lightgrey", lty.contours=par("lty"), lwd.contours=par("lwd"),
             label.contours=T, format.clab="p=%4.3f",
             cex=par("cex"), cex.label=0.7, pos=3, adj=NULL, 
             pos.clab="bottomright", col.clab=col.contours,
             cex.axis=par("cex.axis"), pch=par("pch"), las=par("las"), 
             col=par("col"), bg=par("bg"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duewer.plot_+3A_x">x</code></td>
<td>
<p>Numeric vector of values to be plotted.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_s">s</code></td>
<td>
<p>Numeric vector of standard deviations, standard errors or uncertainties
of length <code>length(x)</code> associated with x.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_mu">mu</code></td>
<td>
<p>A single location against which to compare x.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_sigma">sigma</code></td>
<td>
<p>A measure of dispersion against which deviations x-mu can be compared.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_s0">s0</code></td>
<td>
<p>A typical, expected or reference value for the standard uncertainties s
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_labels">labels</code></td>
<td>
<p>An optional vector of point labels of length <code>length(x)</code>. 
<code>labels</code> are coerced to character on use, so may be character, factor etc..
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_radius">radius</code></td>
<td>
<p>A vector of radii for reference lines in the classic Duewer plot.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_units">units</code></td>
<td>
<p>Controls scaling of the plot. If set to <code>"z"</code>, a classic Duewer plot 
of <code>s/s0</code> vs. <code>(x-mu)/sigma</code> is produced. If <code>units=="x"</code>, the plot is 
drawn without scaling by <code>sigma</code> or <code>s0</code>.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_main">main</code></td>
<td>
<p>Main title for the plot, passed to <code>title()</code>.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_xlab">xlab</code>, <code id="duewer.plot_+3A_ylab">ylab</code></td>
<td>
<p>x- and y-axis labels, passed to <code>title()</code>.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_xlim">xlim</code>, <code id="duewer.plot_+3A_ylim">ylim</code></td>
<td>
<p>x- and y-limits for the plot. 
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_at.xax">at.xax</code>, <code id="duewer.plot_+3A_at.yax">at.yax</code></td>
<td>
<p>Locations for x- and yaxis tick marks, passed to <code>axis()</code>
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_aspect">aspect</code></td>
<td>
<p>The aspect ratio for the plot, passed to <code>plot.window</code>. This defaults to 1.0 for
<code>basis=="radius"</code>, giving semicircular countours, and NA otherwise.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_col.contours">col.contours</code>, <code id="duewer.plot_+3A_lty.contours">lty.contours</code>, <code id="duewer.plot_+3A_lwd.contours">lwd.contours</code></td>
<td>
<p>Colour, line type and line width for contour lines.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_label.contours">label.contours</code></td>
<td>
<p>Logical, controlling whether countour lines are labelled with approximate probabilities.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_format.clab">format.clab</code></td>
<td>
<p>format string for contour labels; passed to <code>sprintf</code>.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_cex">cex</code></td>
<td>
<p>Expansion factor for plotted symbols.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_cex.label">cex.label</code></td>
<td>
<p>Expansion factor for point labels.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_pos">pos</code>, <code id="duewer.plot_+3A_adj">adj</code></td>
<td>
<p>Specifies position/adjustment of point labels. Passed to <code>text</code>.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_pos.clab">pos.clab</code></td>
<td>
<p>Specification for location of contour labels. Options are '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;',
'&quot;bottomright&quot;', '&quot;bottom&quot;', '&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;'. A vector can be provided
to give multiple labels. Contour labels for <code>basis="prob"</code> are placed approximately 
at the location indicated and adjusted outward appropriately. For basis=&quot;radius&quot;, 
&quot;bottomright&quot; and &quot;bottomleft&quot; are as for &quot;right&quot; and &quot;left&quot; but just below the x-axis,
and &quot;bottom&quot; is replaced with c(&quot;bottomright&quot;, &quot;bottomleft&quot;).
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_col.clab">col.clab</code></td>
<td>
<p>Colour for contour labels.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Expansion factor for axis labels.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_las">las</code></td>
<td>
<p>Axis label orientation, passed to <code>axis</code>.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_pch">pch</code>, <code id="duewer.plot_+3A_col">col</code>, <code id="duewer.plot_+3A_bg">bg</code></td>
<td>
<p>Graphical parameters passed to <code>points</code>.
</p>
</td></tr>
<tr><td><code id="duewer.plot_+3A_...">...</code></td>
<td>
<p>Other parameters passed to plotting functions. Currently unused.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Duewer plot is a plot of dispersion against location. Classically, this has been applied to
multiple observations from laboratories. Locations <code>x</code> are mean results of the form 
<code>(x-mu)/s</code> and and dispersions <code>s</code> are the associated sd. The principle has also 
been applied to multiple results for different measurands per laboratory, by calculating 
z-scores for all observations relative to the assigned value and dispersion for each measurand
and then plotting mean and sd of the scores. More recently the plot has been used to summarise
reported values and (usually) standard uncertainties in metrology comparisons to allow
quick assessment of anomalies within data sets.
</p>
<p>The traditional plot includes visual guides in the form of semicircular 
contours at multiples of (x-mu)/sigma for the x-axis and s/s0 for the y-axis, 
s0 being a median or other estimate of the typical standard deviation. 
</p>
<p>Contours are, by default, labelled with probabilities corresponding to quantiles
of the normal distribution.
</p>
<p><code>dplot</code> is an alias for <code>duewer.plot</code>.
</p>


<h3>Value</h3>

<p>This function is called for its side effect, which is the production of a plot.
</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Duewer, D, Probably in Anal. Chem. in about 1990

</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+axis">axis</a></code> for axis control, <code><a href="graphics.html#topic+points">points</a></code>,  <code><a href="graphics.html#topic+text">text</a></code> for 
plotting parameters; <code><a href="base.html#topic+sprintf">sprintf</a></code> for contour label format. 
</p>
<p><code><a href="#topic+xs.plot">xs.plot</a></code> for a plot of location and scale data with probabilistic
confidence regions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	require(metRology)
	data(Pb)
	Pb
	
	duewer.plot(Pb$value, Pb$u)

	duewer.plot(Pb$value, Pb$u, basis="prob", df=5)

	#Illustrate contour labelling
	duewer.plot(Pb$value, Pb$u, pos.clab="bottom")
</code></pre>

<hr>
<h2 id='Extract.ilab'>
The 'ilab' class. 
</h2><span id='topic+Extract.ilab'></span><span id='topic+subset.ilab'></span><span id='topic++5B.ilab'></span>

<h3>Description</h3>

<p>Functions for manipulating interlaboratory study objects objects of class &lsquo;ilab&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ilab'
subset(x, subset, drop=FALSE, ...)

## S3 method for class 'ilab'
x[i, j]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.ilab_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;ilab&rsquo;</p>
</td></tr>
<tr><td><code id="Extract.ilab_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or rows to keep:
missing values are taken as false.</p>
</td></tr>
<tr><td><code id="Extract.ilab_+3A_drop">drop</code></td>
<td>
<p> passed on to '[' indexing operator.</p>
</td></tr>
<tr><td><code id="Extract.ilab_+3A_...">...</code></td>
<td>
<p>Parameters passed to other functions</p>
</td></tr>
<tr><td><code id="Extract.ilab_+3A_i">i</code>, <code id="Extract.ilab_+3A_j">j</code></td>
<td>
<p>elements to extract. May be numeric or logical vectors.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the subset method, <code>subset</code> is an expression evaluated in the frame
of <code>ilab$data</code> and in the parent environment if objects are not found in 
<code>ilab$data</code>. Note that since <code>ilab$distrib</code> and <code>ilab$distrib.pars</code> are
not in <code>ilab$data</code>, any operation on these must be specified in full.
</p>
<p>The indexing method <code>'['</code> operates on both rows and columns of the object. However,
only the <code>$data</code> element can be addressed with the <code>j</code>; the <code>distrib</code> and 
<code>distrib.pars</code> elements are unaffected by <code>j</code> and will always be included 
in the returned object.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;ilab&rsquo; with fewer rows and (if <code>j</code> is present) 
fewer columns. 
</p>


<h3>Warning</h3>

<p>Removing the standard columns from &lsquo;ilab&rsquo; objects using <code>'['</code> may have unforeseen 
consequences for other functions; only the print method is likely to operate successfully. 
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, yet.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ilab-class">ilab-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pb)
il.pb&lt;-construct.ilab(org=Pb$lab, x=Pb$value, measurand="Pb", item="none", 
                u=Pb$u, k=Pb$k, U=Pb$U, title=c("CCQM K30", "Lead in wine"), method=Pb$method)

subset(il.pb, u &lt; 0.03)

il.pb[1:6,]

</code></pre>

<hr>
<h2 id='gplot'>
Grouped plots of type &quot;h&quot;
</h2><span id='topic+gplot'></span>

<h3>Description</h3>

<p>gplot is primarily used by plot.mandel.kh to produce the underlying grouped data plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	gplot(x, main = NULL, xlab = NULL, ylab = deparse(substitute(x)), 
		ylim = NULL, las = 1, axes = TRUE, cex.axis = 1, 
		frame.plot = axes, lwd = 1, lty = 1, col = par("col"), 
		separators = TRUE, col.sep = "lightgrey", lwd.sep = 1, 
		lty.sep = 1, zero.line = TRUE, 
		lwd.zero = 1, col.zero = 1, lty.zero = 1, 
		spacing=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gplot_+3A_x">x</code></td>
<td>

<p>A matrix or data frame to be plotted.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_main">main</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="gplot_+3A_xlab">xlab</code>, <code id="gplot_+3A_ylab">ylab</code></td>
<td>
<p>Labels for x and y axes.</p>
</td></tr>
<tr><td><code id="gplot_+3A_ylim">ylim</code></td>
<td>
<p>	the y limits of the plot. 
</p>
</td></tr>
<tr><td><code id="gplot_+3A_las">las</code></td>
<td>

<p>the style of the axis labels; see <code>par</code> for details.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_axes">axes</code></td>
<td>

<p>a logical value indicating whether axes should be drawn
on the plot.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_cex.axis">cex.axis</code></td>
<td>

<p>The magnification to be used for axis annotation
relative to the current setting of 'cex'.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_frame.plot">frame.plot</code></td>
<td>

<p>Logical; If <code>TRUE</code> a box is drawn around the plot.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_lwd">lwd</code>, <code id="gplot_+3A_lty">lty</code>, <code id="gplot_+3A_col">col</code></td>
<td>

<p>Graphical parameters used for the plotted vertical lines corresponding 
to each value in x.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_separators">separators</code></td>
<td>

<p>Logical; if <code>TRUE</code>, separator lines are drawn between groups of values.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_col.sep">col.sep</code>, <code id="gplot_+3A_lwd.sep">lwd.sep</code>, <code id="gplot_+3A_lty.sep">lty.sep</code></td>
<td>

<p>Graphical parameters used for the separator lines.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_zero.line">zero.line</code></td>
<td>

<p>logical; if <code>TRUE</code> a horizontal line is drawn at zero.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_lwd.zero">lwd.zero</code>, <code id="gplot_+3A_col.zero">col.zero</code>, <code id="gplot_+3A_lty.zero">lty.zero</code></td>
<td>

<p>Graphical parameters used for the zero line.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_...">...</code></td>
<td>

<p>Other graphical parameters passed to <code>plot</code>.
</p>
</td></tr>
<tr><td><code id="gplot_+3A_spacing">spacing</code></td>
<td>

<p>Spacing for data within each group, as a fraction of inter-group spacing. 
Defaults to 0.3 or less.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gplot</code> produces a plot of type=&quot;h&quot;, with values in x grouped by row and with 
optional vertical separators between groups. The plotting order (left to right) is 
in order of <code>stack(as.data.frame(t(x)))</code>; each group corresoponds to a row in x.
</p>
<p>Because <code>gplot</code> is primarily a supporting function for <code>plot.mandel.kh</code>,
it assumes a suitable object will be provided and does minimal checking
to ensure an appropriate object class. Error messages may not be 
very informative.
</p>


<h3>Value</h3>

<p>A numeric vector of mid-points of the groups along the x-axis.
</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Accuracy (trueness and precision) of measurement methods and results &ndash; Part 2: 
Basic method for the determination of repeatability and reproducibility of a 
standard measurement method. ISO, Geneva (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mandel.kh">plot.mandel.kh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(RMstudy)
   h &lt;- with(RMstudy, mandel.h(RMstudy[2:9], g=Lab))
   gplot(h, las=2) 
   	#Note the absence of indicator lines, title etc. 
   	#compared to plot(h)
</code></pre>

<hr>
<h2 id='GUM'>
Propagation of Measurement Uncertainty for Typical Metrology Applications 
Using the Methods Outlined in the GUM
</h2><span id='topic+GUM'></span>

<h3>Description</h3>

<p>A function for propagation of measurement uncertainty for typical metrology 
applications using the methods from the Joint Committee on Guides in Metrology (JCGM)
<em>Guide to the Expression of Uncertainty in Measurement (GUM)</em>. This approach 
approximates the uncertainty of a function of random variables that define a 
measurement result by computing the uncertainty of the first-order Taylor series for
the measurement function. This function also serves as the primary computational tool
underlying the GUM uncertainty templates found in the metRology for Microsoft Excel user interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GUM(var.name, x.i, u.i, nu.i, measurement.fnc, correlation = diag(length(var.name)),
shared.u.i = var.name, cl = 0.95, cov.factor = "Student's t", sig.digits.U = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GUM_+3A_var.name">var.name</code></td>
<td>
<p>Character vector of input variable names.</p>
</td></tr>
<tr><td><code id="GUM_+3A_x.i">x.i</code></td>
<td>
<p>Vector of input variable values.</p>
</td></tr>
<tr><td><code id="GUM_+3A_u.i">u.i</code></td>
<td>
<p>Vector of standard uncertainties (i.e. standard errors) for each input variable value.</p>
</td></tr>
<tr><td><code id="GUM_+3A_nu.i">nu.i</code></td>
<td>
<p>Degrees of freedom associated with each standard uncertainty.</p>
</td></tr>
<tr><td><code id="GUM_+3A_measurement.fnc">measurement.fnc</code></td>
<td>
<p>Character string specifying the functional relationship between
input variables that defines the output measurement result.</p>
</td></tr>
<tr><td><code id="GUM_+3A_correlation">correlation</code></td>
<td>
<p>Matrix giving the correlation between the different input variable values. 
Default is to assume no correlation between input variable values.</p>
</td></tr>
<tr><td><code id="GUM_+3A_shared.u.i">shared.u.i</code></td>
<td>
<p>Character vector giving the relative relationship between the standard uncertainties
for each variable value. Groups of variables based on a common shared standard uncertainty
will all share the same variable name. The default is to assume all standard uncertainties
are assessed independently, resulting a value of shared.u.i that is identical to var.name.</p>
</td></tr>
<tr><td><code id="GUM_+3A_cl">cl</code></td>
<td>
<p>Nominal confidence level to be used to compute the expanded uncertainty of the output measurement result.
Default value is 0.95.</p>
</td></tr>
<tr><td><code id="GUM_+3A_cov.factor">cov.factor</code></td>
<td>
<p>Type of coverage factor to be used. The default is to use the value from the Student's t 
distribution with confidence level specified above and nu.eff effective degrees of freedom.</p>
</td></tr>
<tr><td><code id="GUM_+3A_sig.digits.u">sig.digits.U</code></td>
<td>
<p>Number of significant digits to be reported in the expanded uncertainty of 
the measurement result. The measurement result will be rounded to the same
number of decimal places.</p>
</td></tr>
<tr><td><code id="GUM_+3A_...">...</code></td>
<td>
<p> Arguments passed to other functions. Currently unimplemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever possible, sensitivity coefficients are obtained analytically using the gradient attribute of the 
<code><a href="stats.html#topic+deriv">deriv</a></code> function. In situations where some part of the measurement function is not found in
derivative table, sensitivity coefficients are obtained by numeric partial differentiation using the
<code><a href="numDeriv.html#topic+grad">grad</a></code> function from the package numDeriv.
</p>


<h3>Value</h3>

<p>A list containing the 9 components:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>Value of the measurement result obtained by evaluating the measurement function at the input variable values.</p>
</td></tr>
<tr><td><code>uc</code></td>
<td>
<p>The combined standard uncertainty of the measurement result, y.</p>
</td></tr>
<tr><td><code>nu.eff</code></td>
<td>
<p>The effective degrees of freedom associated with uc, computed using the Welch-Satterthwaite formula.</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>The nominal confidence level used to obtain the coverage factor, k.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The coverage factor used to control the confidence level associated with the expanded uncertainty of the
measurement result.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>The expanded uncertainty of the measurement result, computed as U=k*uc.</p>
</td></tr>
<tr><td><code>contributions</code></td>
<td>
<p>Relative variance contributed to the standard uncertainty (uc) of the measurement result
from each input variable.</p>
</td></tr>
<tr><td><code>sensitivities</code></td>
<td>
<p>Sensitivity coefficient associated with each input variable.</p>
</td></tr>
<tr><td><code>msgs</code></td>
<td>
<p>Error and warning messages that point out potential problems with the inputs to the <code>GUM</code> function
or with the interpretation of the function's output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hung-kung Liu <a href="mailto:hung-kung.liu@nist.gov">hung-kung.liu@nist.gov</a> and Will Guthrie <a href="mailto:will.guthrie@nist.gov">will.guthrie@nist.gov</a>
</p>


<h3>References</h3>

<p>Joint Committee on Guides in Metrology (JCGM), <em>Evaluation of Measurement Data Guide to the Expression of
Uncertainty in Measurement</em>, http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf, 2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GUM.validate">GUM.validate</a></code> a function to assess the statistical performance of GUM uncertainty intervals
for the application of interest in terms of average attained coverage probability.
<code><a href="#topic+uncert">uncert</a></code> for a family of functions focused on the study and comparison of different approaches
and numerical options in uncertainty analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a simple uncertainty analysis for the product of two quantities
GUM(c("x1","x2"),c(2.3,1.1),c(0.030,0.015),c(5,9999),"x1*x2")

## example of the difference in the measurements of two standards, each 
## with a standard uncertainty based on a common value drawn from a control chart
## representative of the measurement process made using a check standard that 
## is comparable to the two individual standards under study
GUM(c("s1","s2"),c(45.3,46.0),c(0.26,0.26),c(134,134),"s1-s2",shared.u.i=c("s1","s1"))

## compare with results for equivalent, alternative specification of shared.u.i
GUM(c("s1","s2"),c(45.3,46.0),c(0.26,0.26),c(134,134),"s1-s2",shared.u.i=c("s2","s2"))
</code></pre>

<hr>
<h2 id='GUM.H.1'>
Example H.1 from the <em>Guide to the Expression of Uncertainty in Measurement</em>
</h2><span id='topic+GUM.H.1'></span>

<h3>Description</h3>

<p>Calibration of an end gauge for length measurement. Notation is based on the presentation in chapter 3 of 
<em>Data Modeling for Metrology and Testing in Measurement Science</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GUM.H.1
data(GUM.H.1)
</code></pre>


<h3>Format</h3>

<p>A list containing 10 components that give the uncertainty budget, measurement function, and other quantities
needed to carry out an uncertainty analysis using the methods from the Guide to the Expression of Uncertainty
in Measurement:
</p>

<dl>
<dt>var.name</dt><dd><p>Character vector giving the name of each input variable included in the analysis.</p>
</dd>
<dt>unit</dt><dd><p>Expression giving the units of each input variable</p>
</dd>
<dt>x.i</dt><dd><p>Vector giving the reported value for each input variable.</p>
</dd>
<dt>u.i</dt><dd><p>Vector giving the standard uncertainty associated with each reported value.</p>
</dd>
<dt>nu.i</dt><dd><p>Vector giving the degrees of freedom associated with each standard uncertainty.</p>
</dd>
<dt>type</dt><dd><p>Character vector indicating the method of evaluation (Type A or Type B) for each standard uncertainty.</p>
</dd>
<dt>distribution</dt><dd><p>Character vector listing the probability distribution assumed to describe each variable value.</p>
</dd>
<dt>measurement.fnc</dt><dd><p>Character string giving the measurement function for the output variable.</p>
</dd>
<dt>correlation</dt><dd><p>Matrix giving the correlations between input variable values.</p>
</dd>
<dt>shared.u.i</dt><dd><p>Character vector describing which standard uncertainties, if any, are based on a common 
underlying standard uncertainty. A vector that is the same as var.name indicates that all standard
uncertainties are based on independent assessments of standard uncertainty. A vector with fewer names
than in var.names indicates that one or more variables are derived from a common uncertainty assessment.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Details can be found in the GUM and in Data Modeling for Metrology and Testing in Measurement Science.
</p>


<h3>Source</h3>

<p>Joint Committee on Guides in Metrology (JCGM), <em>Evaluation of Measurement Data Guide to the Expression of
Uncertainty in Measurement</em>, http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf, 2008.
</p>


<h3>References</h3>

<p>Guthrie, W.F. et. al., &quot;Three Statistical Paradigms for Assessment and Interpretation of Measurement Uncertainty&quot; in
<em>Data Modeling for Metrology and Testing in Measurement Science</em>, F. Pavese and A.B. Forbes, eds., Birkhauser,
Boston, 2009.
</p>

<hr>
<h2 id='GUM.validate'>
Monte Carlo Check on the Statistical Performance of GUM Uncertainty Intervals 
Using Attained Coverage Probability
</h2><span id='topic+GUM.validate'></span>

<h3>Description</h3>

<p>A function for assessing the statistical performance of measurement uncertainty intervals for 
particular metrology applications computed using the methods from the Joint Committee on 
Guides in Metrology (JCGM) <em>Guide to the Expression of Uncertainty in Measurement (GUM)</em>. 
The validation is carried out using the input values as true values in a simulation that 
directly checks the attained coverage probability of the uncertainty
intervals produced using the <code><a href="#topic+GUM">GUM</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GUM.validate(var.name, x.i, u.i, nu.i, type, distribution, measurement.fnc, 
             correlation = diag(length(var.name)), shared.u.i = var.name, cl = 0.95, 
             cov.factor = "Student's t", sig.digits.U = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GUM.validate_+3A_var.name">var.name</code></td>
<td>
<p>Character vector of input variable names.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_x.i">x.i</code></td>
<td>
<p>Vector of input variable values.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_u.i">u.i</code></td>
<td>
<p>Vector of standard uncertainties (i.e. standard errors) for each input variable value.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_nu.i">nu.i</code></td>
<td>
<p>Degrees of freedom associated with each standard uncertainty.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_type">type</code></td>
<td>
<p>Character vector of values &quot;A&quot; and &quot;B&quot; indicating the methods used to evaluate the standard
uncertainty of each input value. Standard uncertainties evaluated using statistical methods
are denoted Type A in the GUM, while standard uncertainties evaluated using other means are
denoted Type B.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_distribution">distribution</code></td>
<td>
<p>Character vector of probability distributions associated with the potential values
taken on by each input variable. The current possible choices are &quot;Normal&quot; (i.e. Gaussian),
&quot;Triangular&quot;, or &quot;Rectangular&quot; (i.e. Uniform).</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_measurement.fnc">measurement.fnc</code></td>
<td>
<p>Character string specifying the functional relationship between
input variables that defines the output measurement result.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_correlation">correlation</code></td>
<td>
<p>Matrix giving the correlation between the different input variable values. 
Default is to assume no correlation between input variable values.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_shared.u.i">shared.u.i</code></td>
<td>
<p>Character vector giving the relative relationship between the standard uncertainties
for each variable value. Groups of variables based on a common shared standard uncertainty
share will all share the same variable name. The default is to assume all standard uncertainties
are assessed independently, resulting a value of shared.u.i that is identical to var.name.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_cl">cl</code></td>
<td>
<p>Nominal confidence level to be used to compute the expanded uncertainty of the output measurement result.
Default value is 0.95.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_cov.factor">cov.factor</code></td>
<td>
<p>Type of coverage factor to be used. The default is to use the value from the Student's t 
distribution with confidence level specified above and nu.eff effective degrees of freedom.</p>
</td></tr>
<tr><td><code id="GUM.validate_+3A_sig.digits.u">sig.digits.U</code></td>
<td>
<p>Number of significant digits to be reported in the expanded uncertainty of the measurement result.
The measurement result will be rounded to the same number of decimal places.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently 1000 simulated sets of uncertainty data are used for the computation of the attained confidence level.
</p>


<h3>Value</h3>

<p>A Monte Carlo assessment of the attained coverage of expanded uncertainty intervals like those produced 
using the <code><a href="#topic+GUM">GUM</a></code> function for the application of interest.
</p>


<h3>Author(s)</h3>

<p>Hung-kung Liu <a href="mailto:hung-kung.liu@nist.gov">hung-kung.liu@nist.gov</a> and Will Guthrie <a href="mailto:will.guthrie@nist.gov">will.guthrie@nist.gov</a>
</p>


<h3>References</h3>

<p>Joint Committee on Guides in Metrology (JCGM), <em>Evaluation of Measurement Data Guide to the Expression of
Uncertainty in Measurement</em>, http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf, 2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GUM">GUM</a></code> a function to compute GUM uncertainty intervals for general metrological applications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a simple uncertainty analysis for the product of two quantities
GUM.validate(c("x1","x2"), c(2.3,1.1), c(0.030,0.015), c(5,9999),
               c("A","B"),c("Normal","Rectangular"),"x1*x2")
</code></pre>

<hr>
<h2 id='ilab-class'>
The 'ilab' class. 
</h2><span id='topic+ilab-class'></span><span id='topic+construct.ilab'></span>

<h3>Description</h3>

<p>The &lsquo;ilab&rsquo; class and its constructor function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.ilab(org, item, measurand, x, u, df, k, U, U.lower, U.upper,
           distrib=NULL, distrib.pars=NULL, study=NA, title=NA, p=0.95, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ilab-class_+3A_org">org</code></td>
<td>
<p>Character vector or factor of organisation names.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_item">item</code></td>
<td>
<p>vector or factor of identifiers for test items. Coerced to factor on storage.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_measurand">measurand</code></td>
<td>
<p>vector or factor identifying the measurand(s) involved in the study.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_x">x</code></td>
<td>
<p>numeric vector of reported values.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_u">u</code></td>
<td>
<p>numeric vector of reported standard uncertainties or standard errors associated with x.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_df">df</code></td>
<td>
<p>optional numeric vector of degrees of freedom associated with each reported uncertainty.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_k">k</code></td>
<td>
<p>numeric vector of coverage factors. The coverage factor is the factor multiplying u to obtain U.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_u">U</code></td>
<td>
<p>numeric or character vector of expanded uncertainties or confidence interval half-widths. 
Coerced to numeric but may include a character representation of interval limits; see Details.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_u.lower">U.lower</code>, <code id="ilab-class_+3A_u.upper">U.upper</code></td>
<td>
<p>numeric vectors of lower and upper limits for the confidence 
interval around x, allowing asymmetric intervals. Defaults to U or to the limits 
specified by U. See Details.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_distrib">distrib</code></td>
<td>
<p>A character vector of length <code>length(x)</code> or a named list 
of names of distribution functions associated with <code>u</code>. If a character vector, 
<code>distrib</code> is recycled to length <code>length(x)</code>.
</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_distrib.pars">distrib.pars</code></td>
<td>
<p>A named list of lists of parameters describing the distributions 
associated with <code>u</code> to be passed to the relevant distribution function.
If <code>distrib</code> is present but <code>distrib.pars</code> is not, an attempt is made 
to set defaults based on other parameters; see Details.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_study">study</code></td>
<td>
<p>A character value or vector or a factor identifying different studies 
or study populations within the data set. Typically used, for example, for identifying 
participants in global and regional components of a combined study. Recycled to length
<code>length(x)</code> if necessary.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_title">title</code></td>
<td>
<p>An optional title for the study. May be a character vector, 
in which case each element is displayed on a separate line when printed.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_p">p</code></td>
<td>
<p>Confidence level assumed to apply to <code>k</code>. Used only to set a default value 
for <code>df</code> when <code>distrib</code> indicates a t-distribution and <code>df</code> is 
unspecified.</p>
</td></tr>
<tr><td><code id="ilab-class_+3A_...">...</code></td>
<td>
<p>Other <em>named</em> factors or character vectors used to group observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>U</code> is a character vector, it may contain character representations of range.
Two forms are permitted:
</p>

<dl>
<dt>&quot;a-b&quot;</dt><dd><p>Interpreted as limits of a range from <code>a</code> to <code>b</code>. <code>U.lower</code>
and <code>U.upper</code> are calculated from these limits and <code>x</code></p>
</dd>
<dt>&quot;+a[/]-b&quot; (or &quot;-a[/]+b&quot;)</dt><dd><p><code>U.upper</code> is set to <code>a</code> in <code>"+a"</code>, 
and <code>U.lower</code> is set to <code>b</code> in <code>"-b"</code>.</p>
</dd>
</dl>

<p>If <code>distrib.pars</code> is missing, an attempt is made to deduce appropriate 
distribution parameters from <code>x</code>, <code>u</code>, <code>df</code> and <code>distrib</code>. 
In doing so, the following assumptions and values apply for the respective distributions:
</p>

<dl>
<dt>norm</dt><dd><p><code>mean=x$name, sd=u$name</code>.</p>
</dd>
<dt>unif</dt><dd><p><code>min=x-sqrt(3)*u, max=x+sqrt(3)*u</code>.</p>
</dd>
<dt>tri</dt><dd><p><code>min=x-sqrt(6)*u, max=x+sqrt(6)*u, mode=x</code>.</p>
</dd>
<dt>t, t.scaled</dt><dd><p><code>df=df, mean=x, sd=u</code>.</p>
</dd>
</dl>

<p>In addition, if <code>distrib</code> contains <code>"t"</code> or <code>"t.scaled"</code>, and
<code>df</code> is <code>NA</code>, the corresponding degrees of freedom are chosen based on 
<code>k</code> and <code>p</code>.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;ilab&rsquo; consisting of:
</p>
<table>
<tr><td><code>title</code></td>
<td>
<p>A character value or vector describing the study</p>
</td></tr>
<tr><td><code>subset</code></td>
<td>
<p>A character string describing any subset operation used to form the object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A data frame with columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    org	</td><td style="text-align: left;">	Factor of organisations submitting results in the study  </td>
</tr>
<tr>
 <td style="text-align: left;">
    item	</td><td style="text-align: left;">	Factor of test item identifiers.   </td>
</tr>
<tr>
 <td style="text-align: left;">
    measurand	</td><td style="text-align: left;">	Factor of measurands determined for each item  </td>
</tr>
<tr>
 <td style="text-align: left;">
    x	</td><td style="text-align: left;">	numeric vector of reported values.  </td>
</tr>
<tr>
 <td style="text-align: left;">
    u	</td><td style="text-align: left;">	numeric vector of reported standard uncertainties or standard 
    		errors associated with x.  </td>
</tr>
<tr>
 <td style="text-align: left;">
    df	</td><td style="text-align: left;">	numeric vector of degrees of freedom associated with each reported
    		uncertainty. Set to <code>NA</code> if not provided.  </td>
</tr>
<tr>
 <td style="text-align: left;">
    k	</td><td style="text-align: left;">	numeric vector of coverage factors. The coverage factor is the 
    		factor multiplying u to obtain U.  </td>
</tr>
<tr>
 <td style="text-align: left;">
    U	</td><td style="text-align: left;">	numeric or character vector of expanded uncertainties or confidence 
    		interval half-widths. <code>U</code> is coerced to numeric but may include
    		a character representation of interval limits; see Details.  </td>
</tr>
<tr>
 <td style="text-align: left;">
    U.lower, U.upper	</td><td style="text-align: left;">	numeric vectors of lower and upper limits for the confidence 
      interval around x.  </td>
</tr>
<tr>
 <td style="text-align: left;">
    study	</td><td style="text-align: left;">	Identifier for study groups (see Arguments above).  </td>
</tr>
<tr>
 <td style="text-align: left;">
    ...	</td><td style="text-align: left;">	Other grouping factors (supplied in &lsquo;...&rsquo; in <code>construct.ilab</code>)
	which can be used for sub-categorisation.  </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>


















</td></tr>
<tr><td><code>distrib</code></td>
<td>
<p>An unnamed list of distribution names.</p>
</td></tr>
<tr><td><code>distrib.pars</code></td>
<td>
<p>An unnamed list of lists of parameters describing the distributions 
associated with <code>u</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, yet.</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ilab">print.ilab</a></code>,  <code><a href="#topic+subset.ilab">subset.ilab</a></code>,  <code><a href="#topic+plot.ilab">plot.ilab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pb)
construct.ilab(org=Pb$lab, x=Pb$value, measurand="Pb", item="none", 
                u=Pb$u, k=Pb$k, U=Pb$U, title=c("CCQM K30", "Lead in wine"), 
                method=Pb$method)

#Illustrate default for U and automatic distrib.pars
construct.ilab(org=Pb$lab, x=Pb$value, measurand="Pb", item="none", 
                u=Pb$u, k=Pb$k, distrib="norm")

construct.ilab(org=Pb$lab, x=Pb$value, measurand="Pb", item="none", 
                u=Pb$u, k=Pb$k, distrib="t.scaled")

</code></pre>

<hr>
<h2 id='LCS'>LCS: Largest consistent subset</h2><span id='topic+LCS'></span>

<h3>Description</h3>

<p>Calculates a 'largest consistent subset' given values and associated uncertainty information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCS(x, u, p = 0.05, method = "enum", simplify = FALSE, 
	verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LCS_+3A_x">x</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="LCS_+3A_u">u</code></td>
<td>
<p>Vector of standard errors or standard uncertainties associated with <code>x</code>.</p>
</td></tr>
<tr><td><code id="LCS_+3A_p">p</code></td>
<td>
<p>Significance level at which consistency is tested.</p>
</td></tr>
<tr><td><code id="LCS_+3A_method">method</code></td>
<td>
<p>Subset identification method. Currently only 'enum' is supported.</p>
</td></tr>
<tr><td><code id="LCS_+3A_simplify">simplify</code></td>
<td>
<p>If <code>simplify</code> is <code>TRUE</code>, only the lowest-uncertainty 
subset is returned even if several are of the same size.</p>
</td></tr>
<tr><td><code id="LCS_+3A_verbose">verbose</code></td>
<td>
<p>Logical: Controls the level of reporting during the search.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>LCS</code> obtains the largest subset(s) of <code>x</code> which pass a chi-squared 
test for consistency, taking the uncertainties <code>u</code> into account. 
</p>
<p><code>method</code> controls the search method used. Method &quot;enum&quot; uses complete enumeration 
of all subsets of size <code>n</code>, starting at <code>n==length(x)</code> and decreasing <code>n</code> 
until at least one consistent subset is found. No other method is currently supported; if 
a different method is specified, LCS provides a warning and continues with &quot;enum&quot;.
</p>
<p>There may be more than on consistent subset of size n. If so, LCS returns all such 
subsets unless <code>simplify</code> is <code>TRUE</code>, in which case LCS prints a short warning 
and returns the subset with smallest estimated uncertainty as estimated for the Graybill-Deal
weighted mean assuming large degrees of freedom in <code>u</code>. 
</p>
<p><code>verbose</code> controls the level of reporting. If <code>TRUE</code>, LCS prints the progress of 
the search.
</p>
<p>The general idea of a Largest Consistent Subset as implemented here was suggested by Cox (2006),
though at least one other related method has been suggested by Heydorn (2006). It has,
however, been criticised as an estimator (Toman and Possolo (2009)) ; see Warning below.
</p>


<h3>Value</h3>

<p>If there is only one subset of maximum size, or if <code>simplify=TRUE</code>, a vector of indices 
for <code>x</code> representing the largest consistent subset.
</p>
<p>If there is more than one subset of maximum size and <code>simplify=FALSE</code>, a matrix of indices 
in which the rows contain the indices of each subset.
</p>


<h3>Warning </h3>

<p>LCS methods are essentially equivalent to unsupervised outlier rejection. In general,
this results in a possibly extreme low estimated variance for an arbitrarily small subset 
(in the limit of gross inconsistency, LCS will return subsets of size 1). The estimated uncertainty 
calculated for the Graybill-Deal weighted mean of the subset(s) does not generally take 
account of the subset selection process or the dispersion of the complete data set, so 
is <em>not</em> an estimate of sampling variance. 
</p>
<p>LCS is therefore not recommended for consensus value estimation. It is however, quite 
useful for identifying value/uncertainty outliers.
</p>


<h3>Author(s)</h3>

<p>S. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Cox, M. G. (2007) The evaluation of key comparison data: determining the 
largest consistent subset. Metrologia <b>44</b>, 187-200 (2007) 
</p>
<p>Heydorn, K. (2006) The determination of an accepted reference value from 
proficiency data with stated uncertainties. Accred Qual Assur <b>10</b>, 479-484 (2006)
</p>
<p>Toman, B. and Possolo, A. (2009) Laboratory effects models for interlaboratory
comparisons. Accred. Qual. Assur. <b>14</b>, 553-563 (2009)
</p>


<h3>See Also</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pb)
with(Pb, LCS(value, U/k))

</code></pre>

<hr>
<h2 id='loc.est-class'>The location estimate class</h2><span id='topic+loc.est-class'></span><span id='topic+print.loc.est'></span>

<h3>Description</h3>

<p>The location estimate class contains output from a variety of estimators used in 
the metRology package.
</p>
<p>A print method is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loc.est'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loc.est-class_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;loc.est&rsquo;</p>
</td></tr>
<tr><td><code id="loc.est-class_+3A_...">...</code></td>
<td>
<p>Parameters passed to other functions. Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class &lsquo;loc.est&rsquo; is a list containing 
</p>

<dl>
<dt>x</dt><dd><p>Scalar estimate of location</p>
</dd>
<dt>u</dt><dd><p>Standard uncertainty (usually equivalent to standard error) of the location estimate.</p>
</dd>
<dt>df</dt><dd><p>Degrees of freedom associated with the location estimate (may be NA)</p>
</dd>
<dt>xi</dt><dd><p>Numeric vector of individual values contributing to the estimate</p>
</dd>
<dt>ui</dt><dd><p>Numeric vector of uncertainties initially associated with <code>xi</code>.</p>
</dd>
<dt>dfi</dt><dd><p>Numeric vector of degrees of freedom associated with <code>ui</code>.</p>
</dd>
<dt>u.eff</dt><dd><p>Numeric vector of &lsquo;effective uncertainties&rsquo; in <code>xi</code> after 
any additional terms or adjustments are added (see below).</p>
</dd>
<dt>w</dt><dd><p>Numeric vector of weights associated with <code>xi</code> (see below).</p>
</dd>
<dt>method</dt><dd><p>Character string describing the method used to obtain the estimate.</p>
</dd>
<dt>method.details</dt><dd><p>An optional list of additional details provided by the particular method used.</p>
</dd>
</dl>

<p>The &lsquo;effective uncertainties&rsquo; <code>u.eff</code> arise from some estimation methods (for example, 
Mandel-Paule). These typically involve either the estimation of an additional variance term, 
a scale adjustment to the output value uncertainty or (for example in the case of the 
arithmetic mean) replacement of the initial individual uncertainties with some single 
estimate based on the dispersion of values. These adjustments are usually equivalent to 
replacing the estimator used with a weighted mean using weights <code class="reqn">1/u_{eff}^2</code>. 
</p>
<p>The weight vector <code>w</code> is <em>not</em> equivalent to  <code class="reqn">1/u_{eff}^2</code>. Rather, it 
gives the ratio of prior weights <code class="reqn">1/u_{eff}^2</code> to posterior weights, which combine 
prior weights with some additional weighting. Posterior weights arise in particular when using 
robust estimators, and are generally 1 otherwise. The returned location estimate in such cases
can be calculated as <code>sum(w*x/(u^2))/sum(w/(u^2)))</code>. 



</p>
<p><code>method.details</code> is an optional list that may contain anything from a short 
summary of a scale factor or additional variance to a complete object (e.g. an rlm 
object) returned by the function used to calculate the estimate.
</p>


<h3>Value</h3>

<p>The print method is called for its side effect; no value is returned.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, yet
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpaule">mpaule</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Cd heat of vapourisation example (see ?mpaule)
x2&lt;-c(27.044, 26.022, 26.340, 26.787, 26.796)
v&lt;-c(3, 76, 464, 3, 14)*1e-3
mp&lt;-mpaule(x2, sqrt(v))

print(mp)

</code></pre>

<hr>
<h2 id='M-estimators'>
M- and MM-estimators for location.
</h2><span id='topic+M-estimators'></span><span id='topic+huber.estimate'></span><span id='topic+huber.estimate.default'></span><span id='topic+MM.estimate'></span><span id='topic+MM.estimate.default'></span>

<h3>Description</h3>

<p>Functions for calculating M- and MM-estimators for location given values 
and associated standard errors or standard uncertainties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MM.estimate(x, ...)

## Default S3 method:
MM.estimate(x, u, c = 4.685, ...)

huber.estimate(x, ...)

## Default S3 method:
huber.estimate(x, u, k= 1.345, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M-estimators_+3A_x">x</code></td>
<td>
<p>numeric vector of mean values for groups</p>
</td></tr>
<tr><td><code id="M-estimators_+3A_u">u</code></td>
<td>
<p>numeric vector of standard deviations or standard uncertainties associated with the values <code>x</code></p>
</td></tr>
<tr><td><code id="M-estimators_+3A_c">c</code>, <code id="M-estimators_+3A_k">k</code></td>
<td>
<p>Tuning parameters passed to other functions (see <code>rlm</code>)</p>
</td></tr>
<tr><td><code id="M-estimators_+3A_...">...</code></td>
<td>
<p>Parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are wrappers for robust estimation using <code>rlm</code>. All simply 
call <code>rlm</code> with the formula <code>x~1</code> and weights <code>1/u^2</code>. 
</p>


<h3>Value</h3>

<p>An object of class &lsquo;loc.est&rsquo;.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, yet.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+rlm">rlm</a></code>, <code><a href="#topic+loc.est-class">loc.est-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Cd heat of vapourisation example 
## from Paule, R. C.  and Mandel, J. (1982) - see ?mpaule
x2&lt;-c(27.044, 26.022, 26.340, 26.787, 26.796)
v&lt;-c(3, 76, 464, 3, 14)*1e-3

MM.estimate(x2, sqrt(v))

huber.estimate(x2, sqrt(v))
</code></pre>

<hr>
<h2 id='Mandel-h'>
Mandel's h statistic.
</h2><span id='topic+dmandelh'></span><span id='topic+pmandelh'></span><span id='topic+qmandelh'></span><span id='topic+rmandelh'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for Mandel's h statistic, a measure of relative
deviation from a common mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmandelh(x, g, log = FALSE)
pmandelh(q, g, lower.tail = TRUE, log.p = FALSE)
qmandelh(p, g, lower.tail = TRUE, log.p = FALSE)
rmandelh(B, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mandel-h_+3A_x">x</code>, <code id="Mandel-h_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_g">g</code></td>
<td>
<p>number of means for which h is calculated.</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_b">B</code></td>
<td>
<p> Number of observations. If 'length(B) &gt; 1', the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x];
otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_log">log</code>, <code id="Mandel-h_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mandel's h is calculated for a particular mean value <code>y[i]</code> in a set of 
mean values <code>y</code> as 
<code>h[i] = ( y[i] - mean(y) )/sd(y) )</code>
</p>
<p>The density, probabilities and quantiles can be derived from the beta distribution:
(1+h*sqrt(g)/(g-1))/2 is distributed as Beta((g-2)/2, (g-2)/2).  
</p>


<h3>Value</h3>

<p>dmandelh returns the density at <code>x</code>, pmandelh the cumulative probability,  
qmandelh the quantiles for probability <code>p</code> and rmandelh returns <code>B</code> 
random values drawn from the distribution. 
</p>
<p>Vector values of x, p, q and g are permitted, in which case the functions return vectors.
</p>


<h3>Warning </h3>

<p>Note that <code>rmandelh</code> uses <code>B</code> and not <code>n</code> (as do most R random 
number functions) for number of random draws; this is for compatibility with 
the relevant functions for Mandel's k, for which <code>n</code> is conventionally
used for the number of replicates per group. Be careful when using named parameters!
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison, <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmandelk">pmandelk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#Generate the 95% and 99% quantiles for comparison with tables in 
	#ISO 5725:1996 Part 2:
	n &lt;- 3:30
	round(qmandelh(0.975, n), 2) #95% 2-tailed

	round(qmandelh(0.995, n), 2) #99% 2-tailed
	
</code></pre>

<hr>
<h2 id='Mandel-k'>
Mandel's k statistic.
</h2><span id='topic+dmandelk'></span><span id='topic+pmandelk'></span><span id='topic+qmandelk'></span><span id='topic+rmandelk'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for Mandel's k statistic, a measure of relative 
precision compared to a common variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmandelk(x, g, n, log = FALSE)
pmandelk(q, g, n, lower.tail = TRUE, log.p = FALSE)
qmandelk(p, g, n, lower.tail = TRUE, log.p = FALSE)
rmandelk(B, g, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mandel-k_+3A_x">x</code>, <code id="Mandel-k_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_g">g</code></td>
<td>
<p>number of groups for which k is calculated.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_n">n</code></td>
<td>
<p>number of observations in each group of data for which k is calculated.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_b">B</code></td>
<td>
<p> Number of observations. If 'length(B) &gt; 1', the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x];
otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_log">log</code>, <code id="Mandel-k_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mandel's k for one of a set of <code class="reqn">g</code> standard deviations <code class="reqn">s</code> is calculated as
</p>
<p style="text-align: center;"><code class="reqn">k=\frac{s_{ij}^2}{\sum_{i=1}^p{s_{ij}^2/p}}</code>
</p>

<p>Since the numerator is chi-squared(n-1), or Gamma((n-1)/2, 2),  and the denominator 
can be written as the sum of the same quantity and a pooled variance with distribution
Gamma((g-1)*(n-1)/2, 2), k is distributed as Beta((n-1)/2, (g-1)(n-1)/2).
Quantiles, probabilities, density and random numbers can therefore be generated
from the Beta distribution. For example, qmandelk is calculated as 
<code>sqrt( g * qbeta( (n-1)/2, (g-1)*(n-1)/2))</code>.
</p>


<h3>Value</h3>

<p>dmandelh returns the density at <code>x</code>, pmandelh the cumulative probability,  
qmandelh the quantiles for probability <code>p</code> and rmandelh returns <code>B</code> 
random values drawn from the distribution. 
</p>
<p>Vector values of x, p, q and g are permitted, in which case the functions return vectors.
</p>


<h3>Warning </h3>

<p>Note that <code>rmandelk</code> uses <code>B</code> and not <code>n</code> (as do most R random 
number functions) for number of random draws; this is because <code>n</code> is conventionally
used for the number of replicates per group. Be careful when using named parameters!
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison, <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmandelh">pmandelh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#Generate the 95% and 99% quantiles for comparison with tables in 
	#ISO 5725:1996 Part 2:
	
	round(qmandelk(0.95, g=3:30, n=3), 2) #95% upper tail

	round(qmandelk(0.99, g=3:30, n=3), 2) #99% upper tail
	
</code></pre>

<hr>
<h2 id='Mandel-Paule'>Mandel-Paule calculation</h2><span id='topic+mpaule'></span><span id='topic+mpaule.default'></span><span id='topic+mandel.paule'></span>

<h3>Description</h3>

<p>Calculate a weighted mean, between-group standard deviation and standard error on the
weighted mean using the Mandel-Paule algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
mpaule(x, ..., tol=.Machine$double.eps^0.25, maxiter=25) 

## Default S3 method:
mpaule(x, u=NULL, n=NULL, groups=NULL, 
                   tol=.Machine$double.eps^0.25, maxiter=25, ...)

mandel.paule(x, ..., tol=.Machine$double.eps^0.25, maxiter=25) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mandel-Paule_+3A_x">x</code></td>
<td>
<p>numeric vector of mean values for groups, or (if <code>groups</code> 
is given) of individual observations</p>
</td></tr>
<tr><td><code id="Mandel-Paule_+3A_u">u</code></td>
<td>
<p>numeric vector of standard deviations or standard uncertainties 
associated with the values <code>x</code></p>
</td></tr>
<tr><td><code id="Mandel-Paule_+3A_n">n</code></td>
<td>
<p>integer vector of numbers in each group. If <code>NULL</code>, <code>u</code> are interpreted as 
standard uncertainties or standard errors. <code>n</code> is recycled to <code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="Mandel-Paule_+3A_groups">groups</code></td>
<td>
<p>factor, or vetor which can be coerced to factor, of groups. If present, <code>x</code> is 
interpreted as a vector of individual observations and <code>u</code> and <code>n</code> ignored.</p>
</td></tr>
<tr><td><code id="Mandel-Paule_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
<tr><td><code id="Mandel-Paule_+3A_tol">tol</code></td>
<td>
<p>numeric tolerance; iteration stops when the variance step size drops below <code>tol*var(x)</code></p>
</td></tr>
<tr><td><code id="Mandel-Paule_+3A_maxiter">maxiter</code></td>
<td>
<p>numeric maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Mandel-Paule algorithm finds the between-method variance by iteratively solving the
equation relating the weighted mean to the weighting factor applied. The weighting factor is
the inverse of the sum of the standard error in <code>x</code> and the between-group variance.
</p>
<p>If the iterative procedure produces a negative estimate for the between-group variance,
the between-group variance is set to zero.
</p>
<p>For the default method, if <code>u</code> is present and <code>n=NULL</code>, <code>u</code> is interpreted as 
a vector of standard uncertainties or standard errors. If <code>n</code> is not <code>NULL</code>, <code>u</code> 
is interpreted as a vector of standard deviations and standard errors are calculated as 
<code>u/sqrt(n)</code>.
If <code>groups</code> is not <code>NULL</code>, <code>x</code> is interpreted as a vector of individual 
observations grouped by <code>groups</code>, and the algorithm is applied to the corresponding 
group means and standard errors. 
</p>
<p>If <code>maxiter</code> is set less than 1, no iterations are performed and the consensus mean 
is returned as <code>NA</code>.
</p>
<p><code>mandel.paule</code> is an alias for <code>mpaule</code> retained for backward compatibility.
</p>


<h3>Value</h3>

<p>A loc.est object; see loc.est for details. In the returned object, <code>df</code> is
set to <code class="reqn">n-1</code> where <code class="reqn">n</code> is the number of non-<code>NA</code> observations or
group means as appropriate, and <code>method.details</code> is returned as :
</p>
<table>
<tr><td><code>var.between</code></td>
<td>
<p>the estimated between-group variance)</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations taken</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p><code>converged</code> indicates the convergence status. <code>0L</code> indicates
failure to converge (<code>maxiter</code> reached before step size drops below tolerance); 
<code>1L</code> indicates normal convergence; <code>2L</code> indicates that the final step size resulted 
in a negative between-group variance, at which point the variance and step size are set to 0.0</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>S. Cowen <a href="mailto:simon.cowen@lgc.co.uk">simon.cowen@lgc.co.uk</a> with amendments by S. L. R. Ellison.
</p>


<h3>References</h3>

<p>Paule, R. C.  and Mandel, J. (1982), J Res Nat Bur Stand, <b>87</b>, (5) 377-385 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the second example in the paper cited above
x &lt;- c(201.533, 216.55)
s &lt;- c(0.154, 0.25)
n &lt;- c(6, 2)

mpaule(x, s/sqrt(n))

## Cd heat of vapourisation example from the paper cited above
x2&lt;-c(27.044, 26.022, 26.340, 26.787, 26.796)
v&lt;-c(3, 76, 464, 3, 14)*1e-3
mpaule(x2, sqrt(v))

</code></pre>

<hr>
<h2 id='mandel.h'>
Calculate Mandel's h statistics for replicate observations
</h2><span id='topic+mandel.h'></span><span id='topic+mandel.h.default'></span><span id='topic+mandel.h.data.frame'></span><span id='topic+mandel.h.matrix'></span><span id='topic+mandel.h.array'></span><span id='topic+mandel.h.ilab'></span>

<h3>Description</h3>

<p><code>mandel.h</code> calculates Mandel's h statistics for replicate observations. 
Mandel's h is an indication of relative deviation from the mean value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	mandel.h(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			method=c("classical", "robust"), n = NA, ...)

	## Default S3 method:
mandel.h(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			method=c("classical", "robust"), n = NA, ...)

	## S3 method for class 'ilab'
mandel.h(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			method=c("classical", "robust"), n = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mandel.h_+3A_x">x</code></td>
<td>
<p>An R object (see Details below), which contains replicate observations or, 
if <code>g</code> is absent, means or standard deviations.</p>
</td></tr>
<tr><td><code id="mandel.h_+3A_g">g</code></td>
<td>
<p>A primary grouping factor, usually corresponding to Laboratory in an
inter-laboratory study. If not present, <code>x</code> is taken as 
a set of means or standard deviations (depending on whether 
<code>type</code> is <code>"h"</code> or <code>"k"</code>.</p>
</td></tr>
<tr><td><code id="mandel.h_+3A_m">m</code></td>
<td>
<p>A secondary grouping factor, usually corresponding to test item 
or measured quantity. <code>m</code> is ignored if <code>x</code> has
more than one column.</p>
</td></tr>
<tr><td><code id="mandel.h_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether 'NA' values should be
stripped before the computation proceeds. Passed to functions 
such as <code>mean</code> and <code>sd</code>.</p>
</td></tr>
<tr><td><code id="mandel.h_+3A_rowname">rowname</code></td>
<td>
<p>A single character label for the primary grouping factor 
(e.g. &quot;Lab&quot;, &quot;Organisation&quot;).</p>
</td></tr>
<tr><td><code id="mandel.h_+3A_method">method</code></td>
<td>
<p>Character scalar giving the calculation method. <code>"classical"</code> gives the
traditional calculation; <code>"robust"</code> gives a robust variant (see Details).</p>
</td></tr>
<tr><td><code id="mandel.h_+3A_n">n</code></td>
<td>
<p>scalar number of observations per group. Required only if <code>x</code> consists of 
calculated standard deviations.</p>
</td></tr>
<tr><td><code id="mandel.h_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>hubers</code> when <code>method="robust"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mandel.h</code> is a convenience wrapper for mandel.kh(..., type=&quot;h&quot;). It is generic, 
with methods for numeric vectors, arrays, data frames, matrices and objects of class 
<code>'ilab'</code>. All parameters are passed to <code>mandel.kh</code>.
</p>
<p>Mandel's h is an indicators of relative deviation for grouped 
sets of observations. Given a set of observations <code class="reqn">x_{ijl}</code> where <code class="reqn">i, j, l</code>
denotes observation <code class="reqn">l</code>, <code class="reqn">l=1, 2, ... n</code> for measurand or test item <code class="reqn">j</code> and group
(usually laboratory) <code class="reqn">i</code>, <code class="reqn">i=1, 2, ... p</code>, Mandel's <code class="reqn">h</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">h=\frac{\bar{x_{ij}}-\bar{x_j}}{s_j}</code>
</p>

<p>where
<code class="reqn"> s_j=\sqrt{\sum_{i=1}^p{\frac{(\bar{x_{ij}}-\bar{x_j})}{p-1}}}</code>
</p>
<p>If <code>x</code> is a vector, one-dimensional array or single-column matrix, values are aggregated 
by <code>g</code> and, if present, by <code>m</code>. If <code>x</code> is a data frame or matrix, each column 
is aggregated by <code>g</code> and <code>m</code> silently ignored if present. In all cases, if <code>g</code>
is <code>NULL</code> or missing, each row (or value, if a vector) in <code>x</code> 
is taken as a pre-calculated mean (for Mandel's <code class="reqn">h</code>) or standard deviation (for Mandel's <code class="reqn">k</code>).
</p>
<p>If <code>x</code> is an object of class <code>'ilab'</code>, <code>g</code> defaults to <code>'$org'</code> and 
<code>m</code> to <code>$measurand</code>. 
</p>
<p>The returned object includes a label (<code>'grouped.by'</code>) for the primary grouping factor. 
For the <code>'ilab'</code> method, this is <code>"Organisation"</code>. For other methods, If <code>rowname</code> is 
non-null, <code>rowname</code> is used. If <code>rowname</code> is NULL, the default is <code>deparse(substitute(g))</code>;
if <code>g</code> is also NULL or missing, &quot;Row&quot; is used.
</p>
<p>If <code>method="robust"</code>, Mandel's <code class="reqn">h</code> is replaced by a robust z score calculated by 
replacing <code class="reqn">\bar{x_j}</code> and <code class="reqn">s_j</code> with the robust estimates of location and scale 
obtained using Huber's estimate with tuning constant <code>k</code> set to 1.5 (unless otherwise 
specified in <code>...</code>). 
</p>


<h3>Value</h3>

<p>mandel.h returns an object of class <code>"mandel.kh"</code>, which is  a data frame consisting
of the required Mandel's statistics and in which each row corresponds to a level of <code>g</code>
and each column to a level of <code>m</code> or (if <code>x</code> was a matrix or data frame) to the 
corresponding column in <code>x</code>. In addition to the class, the object has attributes:
</p>

<dl>
<dt>'mandel.type'</dt><dd><p><code>"h"</code> or <code>"k"</code></p>
</dd>
<dt>'grouped.by'</dt><dd><p>Character scalar giving the label used for the grouping 
factor <code>g</code>; see Details above for the defaults.</p>
</dd>
<dt>'n'</dt><dd><p>Number of observations per group (<code>n</code> if specified</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Accuracy (trueness and precision) of measurement methods and results &ndash; Part 2: 
Basic method for the determination of repeatability and reproducibility of a 
standard measurement method. ISO, Geneva (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mandel.k">mandel.k</a></code>, <code><a href="#topic+mandel.kh">mandel.kh</a></code>;  
<code><a href="#topic+pmandelh">pmandelh</a></code>, <code><a href="#topic+pmandelk">pmandelk</a></code>  for probabilities, quantiles etc.;
<code><a href="#topic+plot.mandel.kh">plot.mandel.kh</a></code>, <code><a href="#topic+barplot.mandel.kh">barplot.mandel.kh</a></code> for plotting methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(RMstudy)

	#Data frame examples: note no secondary grouping factor
	h &lt;- with(RMstudy, mandel.h(RMstudy[2:9], g=Lab))
	plot(h, las=2)

	#Vector variant
	RMstk &lt;- stack(RMstudy[,2:9])
	names(RMstk) &lt;- c("x", "meas")
		#names replace 'values' and 'ind'
	RMstk$Lab &lt;- rep(RMstudy$Lab, 8)
	h2 &lt;- with(RMstk, mandel.h(x, g=Lab, m=meas, rowname="Laboratory"))
		#Note use of rowname to override g
	plot(h2, las=2)
	
	#ilab method
	RM.ilab &lt;- with(RMstk, construct.ilab(org=Lab, x=x, measurand=meas, 
		item=factor(rep("CRM", nrow(RMstk))) ) )

	plot(mandel.h(RM.ilab))
	
	#Robust variant
	hrob &lt;- with(RMstudy, mandel.kh(RMstudy[2:9], g=Lab, type="h", method="robust"))
	plot(hrob, las=2)
	
</code></pre>

<hr>
<h2 id='mandel.k'>
Calculate Mandel's k statistics for replicate observations
</h2><span id='topic+mandel.k'></span><span id='topic+mandel.k.default'></span><span id='topic+mandel.k.data.frame'></span><span id='topic+mandel.k.matrix'></span><span id='topic+mandel.k.array'></span><span id='topic+mandel.k.ilab'></span>

<h3>Description</h3>

<p><code>mandel.k</code> calculates Mandel's k statistics for replicate observations. 
Mandel's k an indicator of precision compared to the pooled standard deviation across
all groups.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	mandel.k(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			method=c("classical", "robust"), n = NA, ...)

	## Default S3 method:
mandel.k(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			method=c("classical", "robust"), n = NA, ...)

	## S3 method for class 'ilab'
mandel.k(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			method=c("classical", "robust"), n = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mandel.k_+3A_x">x</code></td>
<td>
<p>An R object (see Details below), which contains replicate observations or, 
if <code>g</code> is absent, means or standard deviations.</p>
</td></tr>
<tr><td><code id="mandel.k_+3A_g">g</code></td>
<td>
<p>A primary grouping factor, usually corresponding to Laboratory in an
inter-laboratory study. If not present, <code>x</code> is taken as 
a set of means or standard deviations (depending on whether 
<code>type</code> is <code>"h"</code> or <code>"k"</code>.</p>
</td></tr>
<tr><td><code id="mandel.k_+3A_m">m</code></td>
<td>
<p>A secondary grouping factor, usually corresponding to test item 
or measured quantity. <code>m</code> is ignored if <code>x</code> has
more than one column.</p>
</td></tr>
<tr><td><code id="mandel.k_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether 'NA' values should be
stripped before the computation proceeds. Passed to functions 
such as <code>mean</code> and <code>sd</code>.</p>
</td></tr>
<tr><td><code id="mandel.k_+3A_rowname">rowname</code></td>
<td>
<p>A single character label for the primary grouping factor 
(e.g. &quot;Lab&quot;, &quot;Organisation&quot;).</p>
</td></tr>
<tr><td><code id="mandel.k_+3A_method">method</code></td>
<td>
<p>Character scalar giving the calculation method. <code>"classical"</code> gives the
traditional calculation; <code>"robust"</code> gives a robust variant (see Details).</p>
</td></tr>
<tr><td><code id="mandel.k_+3A_n">n</code></td>
<td>
<p>scalar number of observations per group. Required only if <code>x</code> consists of 
calculated standard deviations.</p>
</td></tr>
<tr><td><code id="mandel.k_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other methods. Currently not 
implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mandel.k</code> is a convenience wrapper for mandel.kh(..., type=&quot;k&quot;). It is generic, 
with methods for numeric vectors, arrays, data frames, matrices and objects of 
class <code>'ilab'</code>. All parameters are passed to <code>mandel.kh</code>.
</p>
<p>Mandel's <code class="reqn">k</code> is an indicator of relative dispersion for grouped 
sets of observations. Given a set of observations <code class="reqn">x_{ijl}</code> where <code class="reqn">i, j, l</code>
denotes observation <code class="reqn">l</code>, <code class="reqn">l=1, 2, ... n</code> for measurand or test item <code class="reqn">j</code> and group
(usually laboratory) <code class="reqn">i</code>, <code class="reqn">i=1, 2, ... p</code>, Mandel's <code class="reqn">k</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">k=\sqrt{\frac{s_{ij}^2}{\sum_{i=1}^p{s_{ij}^2/p}}}</code>
</p>

<p>where <code class="reqn">s_{ij}</code> is the standard deviation of values <code class="reqn">x_{ijk}</code> over <code class="reqn">k=1, 2, ..., n</code>. 
</p>
<p>If <code>x</code> is a vector, one-dimensional array or single-column matrix, values are aggregated 
by <code>g</code> and, if present, by <code>m</code>. If <code>x</code> is a data frame or matrix, each column 
is aggregated by <code>g</code> and <code>m</code> silently ignored if present. In all cases, if <code>g</code>
is <code>NULL</code> or missing, each row (or value, if a vector) in <code>x</code> 
is taken as a pre-calculated mean (for Mandel's h) or standard deviation (for Mandel's k).
</p>
<p>If <code>x</code> is an object of class <code>'ilab'</code>, <code>g</code> defaults to <code>'$org'</code> and 
<code>m</code> to <code>$measurand</code>. 
</p>
<p>The returned object includes a label (<code>'grouped.by'</code>) for the primary grouping factor. 
For the <code>'ilab'</code> method, this is &quot;Organisation&quot;. For other methods, If <code>rowname</code> is 
non-null, <code>rowname</code> is used. If <code>rowname</code> is NULL, the default is <code>deparse(substitute(g))</code>;
if <code>g</code> is also NULL or missing, &quot;Row&quot; is used.
</p>
<p>If <code>method="robust"</code>, Mandel's <code class="reqn">k</code> is calculated by replacing the classical pooled standard 
deviation with the robust pooled standard deviation calculated by algorithm S (see <code><a href="#topic+algS">algS</a></code>). 
</p>


<h3>Value</h3>

<p>mandel.k returns an object of class <code>"mandel.kh"</code>, which is  a data frame consisting
of the required Mandel's statistics and in which each row corresponds to a level of <code>g</code>
and each column to a level of <code>m</code> or (if <code>x</code> was a matrix or data frame) to the 
corresponding column in <code>x</code>. In addition to the class, the object has attributes:
</p>

<dl>
<dt>'mandel.type'</dt><dd><p><code>"h"</code> or <code>"k"</code></p>
</dd>
<dt>'grouped.by'</dt><dd><p>Character scalar giving the label used for the grouping 
factor <code>g</code>; see Details above for the defaults.</p>
</dd>
<dt>'n'</dt><dd><p>Number of observations per group (<code>n</code> if specified</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Accuracy (trueness and precision) of measurement methods and results &ndash; Part 2: 
Basic method for the determination of repeatability and reproducibility of a 
standard measurement method. ISO, Geneva (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mandel.h">mandel.h</a></code>, <code><a href="#topic+mandel.kh">mandel.kh</a></code>;  
<code><a href="#topic+pmandelh">pmandelh</a></code>, <code><a href="#topic+pmandelk">pmandelk</a></code>  for probabilities, quantiles etc.;
<code><a href="#topic+plot.mandel.kh">plot.mandel.kh</a></code>, <code><a href="#topic+barplot.mandel.kh">barplot.mandel.kh</a></code> for plotting methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(RMstudy)

	#Data frame examples: note no secondary grouping factor
	h &lt;- with(RMstudy, mandel.k(RMstudy[2:9], g=Lab))
	plot(h, las=2)

	#Vector variant
	RMstk &lt;- stack(RMstudy[,2:9])
	names(RMstk) &lt;- c("x", "meas")
		#names replace 'values' and 'ind'
	RMstk$Lab &lt;- rep(RMstudy$Lab, 8)
	h2 &lt;- with(RMstk, mandel.k(x, g=Lab, m=meas, rowname="Laboratory"))
		#Note use of rowname to override g
	plot(h2, las=2)
	
	#ilab method
	RM.ilab &lt;- with(RMstk, construct.ilab(org=Lab, x=x, measurand=meas, 
		item=factor(rep("CRM", nrow(RMstk))) ) )

	plot(mandel.k(RM.ilab))
	
	#Robust variant
	krob &lt;- with(RMstudy, mandel.kh(RMstudy[2:9], g=Lab, type="k", method="robust"))
	plot(krob, las=2)
</code></pre>

<hr>
<h2 id='mandel.kh'>
Calculate Mandel's h and k statistics for replicate observations
</h2><span id='topic+mandel.kh'></span><span id='topic+mandel.kh.default'></span><span id='topic+mandel.kh.data.frame'></span><span id='topic+mandel.kh.matrix'></span><span id='topic+mandel.kh.array'></span><span id='topic+mandel.kh.ilab'></span>

<h3>Description</h3>

<p><code>mandel.kh</code> calculates Mandel's h and k statistics for replicate observations. 
These are traditionally used to provide a rapid graphical summary of results 
from an inter-laboratory exercise in which each organisation provides replicate
observations of one or more measurands on one or more test items.
Mandel's h is an indication of relative deviation from the mean value; Mandel's
k is an indicator of precision compared to the pooled standard deviation across
all groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	mandel.kh(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			type = c("h", "k"), method=c("classical", "robust"), n = NA, ...)

	## Default S3 method:
mandel.kh(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			type = c("h", "k"), method=c("classical", "robust"), n = NA, ...)

	## S3 method for class 'data.frame'
mandel.kh(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			type = c("h", "k"), method=c("classical", "robust"), n = NA, ...)

	## S3 method for class 'matrix'
mandel.kh(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			type = c("h", "k"), method=c("classical", "robust"), n = NA, ...)

	## S3 method for class 'array'
mandel.kh(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			type = c("h", "k"), method=c("classical", "robust"), n = NA, ...)

	## S3 method for class 'ilab'
mandel.kh(x, g = NULL, m = NULL, na.rm = T, rowname = NULL, 
			type = c("h", "k"), method=c("classical", "robust"), n = NA, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mandel.kh_+3A_x">x</code></td>
<td>
<p>An R object (see Details below), which contains replicate observations or, 
if <code>g</code> is absent, means or standard deviations.</p>
</td></tr>
<tr><td><code id="mandel.kh_+3A_g">g</code></td>
<td>
<p>A primary grouping factor, usually corresponding to Laboratory in an
inter-laboratory study. If not present, <code>x</code> is taken as 
a set of means or standard deviations (depending on whether 
<code>type</code> is <code>"h"</code> or <code>"k"</code>.</p>
</td></tr>
<tr><td><code id="mandel.kh_+3A_m">m</code></td>
<td>
<p>A secondary grouping factor, usually corresponding to test item 
or measured quantity. <code>m</code> is ignored if <code>x</code> has
more than one column.</p>
</td></tr>
<tr><td><code id="mandel.kh_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether 'NA' values should be
stripped before the computation proceeds. Passed to functions 
such as <code>mean</code> and <code>sd</code>.</p>
</td></tr>
<tr><td><code id="mandel.kh_+3A_rowname">rowname</code></td>
<td>
<p>A single character label for the primary grouping factor 
(e.g. &quot;Lab&quot;, &quot;Organisation&quot;).</p>
</td></tr>
<tr><td><code id="mandel.kh_+3A_type">type</code></td>
<td>
<p>Character denoting the statistic to be calculated; may be &quot;h&quot; or &quot;k&quot;.</p>
</td></tr>
<tr><td><code id="mandel.kh_+3A_method">method</code></td>
<td>
<p>Character scalar giving the calculation method. <code>"classical"</code> gives the
traditional calculation; <code>"robust"</code> gives a robust variant (see Details).</p>
</td></tr>
<tr><td><code id="mandel.kh_+3A_n">n</code></td>
<td>
<p>scalar number of observations per group. Required only if <code>x</code> consists of 
calculated standard deviations.</p>
</td></tr>
<tr><td><code id="mandel.kh_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>hubers</code> when <code>method="robust"</code> 
and <code>type="h"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mandel.kh</code> can be called directly, but is usually intended to be called via 
convenience functions <code>mandel.h</code> or <code>mandel.k</code>.
</p>
<p><code>mandel.kh</code> is a generic, with methods for numeric vectors, arrays, data 
frames, matrices and objects of class <code>'ilab'</code>.
</p>
<p>Mandel's statistics are simple indicators of relative deviation or precision for grouped 
sets of observations. Given a set of observations <code class="reqn">x_{ijl}</code> where <code class="reqn">i, j, l</code>
denotes observation <code class="reqn">l</code>, <code class="reqn">l=1, 2, ... n</code> for measurand or test item <code class="reqn">j</code> and group
(usually laboratory) <code class="reqn">i</code>, <code class="reqn">i=1, 2, ... p</code>, Mandel's <code class="reqn">h</code> and <code class="reqn">k</code> are given by:
</p>
<p style="text-align: center;"><code class="reqn">h=\frac{\bar{x_{ij}}-\bar{x_j}}{s_j}</code>
</p>

<p>where
<code class="reqn"> s_j=\sqrt{\sum_{i=1}^p{\frac{(\bar{x_{ij}}-\bar{x_j})}{p-1}}}</code>
</p>
<p>and
</p>
<p style="text-align: center;"><code class="reqn">k=\sqrt{\frac{s_{ij}^2}{\sum_{i=1}^p{s_{ij}^2/p}}}</code>
</p>

<p>where <code class="reqn">s_{ij}</code> is the standard deviation of values <code class="reqn">x_{ijk}</code> over <code class="reqn">k=1, 2, ..., n</code>. 
</p>
<p>If <code>x</code> is a vector, one-dimensional array or single-column matrix, values are aggregated 
by <code>g</code> and, if present, by <code>m</code>. If <code>x</code> is a data frame or matrix, each column 
is aggregated by <code>g</code> and <code>m</code> silently ignored if present. In all cases, if <code>g</code>
is <code>NULL</code> or missing, each row (or value, if a vector) in <code>x</code> 
is taken as a pre-calculated mean (for Mandel's <code class="reqn">h</code>) or standard deviation (for Mandel's <code class="reqn">k</code>).
</p>
<p>If <code>x</code> is an object of class <code>'ilab'</code>, <code>g</code> defaults to <code>'$org'</code> and 
<code>m</code> to <code>$measurand</code>. 
</p>
<p>The returned object includes a label (<code>'grouped.by'</code>) for the primary grouping factor. 
For the <code>'ilab'</code> method, this is &quot;Organisation&quot;. For other methods, If <code>rowname</code> is 
non-null, <code>rowname</code> is used. If <code>rowname</code> is NULL, the default is <code>deparse(substitute(g))</code>;
if <code>g</code> is also NULL or missing, &quot;Row&quot; is used.
</p>
<p>If <code>method="robust"</code>, Mandel's <code class="reqn">h</code> is replaced by a robust z score calculated by replacing <code class="reqn">\bar{x_j}</code> 
and <code class="reqn">s_j</code> with the robust estimates of location and scale obtained using Huber's estimate with tuning constant 
<code>k</code> set to 1.5 (or as included in <code>...</code>), and Mandel's <code class="reqn">k</code> is calculated by replacing the 
classical pooled standard deviation in the denominator with the robust pooled standard deviation 
calculated by algorithm S (see <code><a href="#topic+algS">algS</a></code>). 
</p>


<h3>Value</h3>

<p>mandel.kh returns an object of class <code>"mandel.kh"</code>, which is  a data frame consisting
of the required Mandel's statistics and in which each row corresponds to a level of <code>g</code>
and each column to a level of <code>m</code> or (if <code>x</code> was a matrix or data frame) to the 
corresponding column in <code>x</code>. In addition to the class, the object has attributes:
</p>

<dl>
<dt>'mandel.type'</dt><dd><p><code>"h"</code> or <code>"k"</code></p>
</dd>
<dt>'grouped.by'</dt><dd><p>Character scalar giving the label used for the grouping 
factor <code>g</code>; see Details above for the defaults.</p>
</dd>
<dt>'n'</dt><dd><p>Number of observations per group (<code>n</code> if specified</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Accuracy (trueness and precision) of measurement methods and results &ndash; Part 2: 
Basic method for the determination of repeatability and reproducibility of a 
standard measurement method. ISO, Geneva (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mandel.h">mandel.h</a></code>, <code><a href="#topic+mandel.k">mandel.k</a></code>  for convenience functions;
<code><a href="#topic+pmandelh">pmandelh</a></code>, <code><a href="#topic+pmandelk">pmandelk</a></code>  for probabilities, quantiles etc.;
<code><a href="#topic+plot.mandel.kh">plot.mandel.kh</a></code>, <code><a href="#topic+barplot.mandel.kh">barplot.mandel.kh</a></code> for plotting methods.
<code><a href="#topic+algS">algS</a></code> and <code><a href="MASS.html#topic+hubers">hubers</a></code> for robust estimates used when <code>method="robust"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(RMstudy)

	#Data frame examples: note no secondary grouping factor
	h &lt;- with(RMstudy, mandel.kh(RMstudy[2:9], g=Lab, type="h"))
	plot(h, las=2)

	k &lt;- with(RMstudy, mandel.kh(RMstudy[2:9], g=Lab, type="k"))
	plot(k, las=2)

	#Vector variant
	RMstk &lt;- stack(RMstudy[,2:9])
	names(RMstk) &lt;- c("x", "meas")
		#names replace 'values' and 'ind'
	RMstk$Lab &lt;- rep(RMstudy$Lab, 8)
	h2 &lt;- with(RMstk, mandel.kh(x, g=Lab, m=meas, rowname="Laboratory"))
		#Note use of rowname to override g
	plot(h2, las=2)
	
	#ilab method
	RM.ilab &lt;- with(RMstk, construct.ilab(org=Lab, x=x, measurand=meas, 
		item=factor(rep("CRM", nrow(RMstk))) ) )

	plot(mandel.kh(RM.ilab, type="h"))
	
	#Robust variants
	hrob &lt;- with(RMstudy, mandel.kh(RMstudy[2:9], g=Lab, type="h", method="robust"))
	plot(hrob, las=2)
	
	krob &lt;- with(RMstudy, mandel.kh(RMstudy[2:9], g=Lab, type="k", method="robust"))
	plot(krob, las=2)
</code></pre>

<hr>
<h2 id='methods.ilab'>
Methods for the 'ilab' class. 
</h2><span id='topic+methods.ilab'></span><span id='topic+print.ilab'></span><span id='topic+plot.ilab'></span>

<h3>Description</h3>

<p>Functions for printing and plotting interlaboratory study objects objects of class &lsquo;ilab&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ilab'
print(x, ..., digits = NULL, right = FALSE)

## S3 method for class 'ilab'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.ilab_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;ilab&rsquo;</p>
</td></tr>
<tr><td><code id="methods.ilab_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display in budget and (if present) distribution parameter lists.
Passed to <code>format</code> for distribution parameter list and to <code>print.data.frame</code> 
for output.</p>
</td></tr>
<tr><td><code id="methods.ilab_+3A_right">right</code></td>
<td>
<p>If TRUE, strings in uncertainty budget are right-justified. 
This differs from the default in <code>print.data.frame</code>.</p>
</td></tr>
<tr><td><code id="methods.ilab_+3A_...">...</code></td>
<td>
<p>Parameters passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method uses <code>print.data.frame</code> to display the data after formatting the 
<code>distrib</code> and <code>distrib.pars</code> elements. 
</p>
<p>The plot method passes the object to <code>kplot</code>.
</p>


<h3>Value</h3>

<p>The print and plot methods are called for their side effects.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, yet.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ilab-class">ilab-class</a></code>, <code><a href="#topic+subset.ilab">subset.ilab</a></code> <code><a href="#topic+kplot">kplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pb)
il.pb&lt;-construct.ilab(org=Pb$lab, x=Pb$value, measurand="Pb", item="none", 
                u=Pb$u, k=Pb$k, U=Pb$U, title=c("CCQM K30", "Lead in wine"), method=Pb$method)

print(il.pb)

plot(il.pb)

</code></pre>

<hr>
<h2 id='metRology_pkg-internal'>Internal metRology objects</h2><span id='topic+.to.wide'></span>

<h3>Description</h3>

<p>Internal metRology package objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='metRology-package'>
Support for Metrological Applications
</h2><span id='topic+metRology-package'></span><span id='topic+metRology'></span>

<h3>Description</h3>

<p>Provides classes and calculation and plotting functions 
for metrology applications, including measurement uncertainty estimation
and inter-laboratory metrology comparison studies. 
</p>


<h3>Details</h3>

<p>The metRology package includes functions for:
</p>
 
<ul>
<li><p> Plotting for Key Comparisons (dot-and-bar, consistency)
</p>
</li>
<li><p> Uncertainty evaluation using algebraic or numeric differentiation, with support for correlation
</p>
</li>
<li><p> Monte Carlo evaluation of uncertainty (including correlation for normally distributed variables)
</p>
</li>
<li><p> Classes and functions for location estimates for metrology comparisons
</p>
</li>
<li><p> Mandel's h and k statistics and plots for interlaboratory studies
</p>
</li>
<li><p> Support functions for an excel interface
</p>
</li></ul>
 
<p>Changes in version 0.9-28-1 from version 0.9-28-0 include: 
</p>
	
<ul>
<li><p> Fixed <code>blockplot</code> x-axis label, which was incorrect.
</p>
</li></ul>

<p>Changes in version 0.9-28-0 from version 0.9-27-2 include: 
</p>
	
<ul>
<li><p> A new plot, <code>blockplot</code>, added. A &ldquo;block plot&rdquo; is a histogram variant identifiying 
individual data points, which appear as &ldquo;blocks&rdquo; in the plot. <code>blockplot</code> provides for grouped 
data, which generates vertically separated subplots for each group. Fills and label colours can be specified 
for each data point.
</p>
</li></ul>

<p>Changes in version 0.9-27-2 from version 0.9-26-2 include: 
</p>
	
<ul>
<li> <p><code>pmsd</code> and related functions will now use fast interpolation by default, and
provide exact values for both odd- and even-<code class="reqn">n</code> data sets up to <code class="reqn">n=199</code>. 
</p>
</li>
<li> <p><code>gplot</code> (called by <code>plot.mandel.kh</code>) now has a <code>spacing</code> parameter
which allows finer control of vertical line spacing. 
</p>
</li></ul>

<p>Changes in version 0.9-26-2 from version 0.9-26-1 include: 
</p>

<ul>
<li><p> Fix to a bug in <code><a href="#topic+reml.loc">reml.loc</a></code> which failed to report the standard uncertainty <code>u</code> 
correctly. 
</p>
</li>
<li> <p><code>cplot</code> now respects <code>cex.axis</code> as a plot parameter. 
</p>
</li></ul>

<p>Changes in version 0.9-26-1 from version 0.9-26-0 include: 
</p>

<ul>
<li><p> Added plot and barplot methods for MSD class. 
</p>
</li>
<li><p> Minor correction to code in <code>msd</code> to prevent over-replication
of estimated <code>s</code> when <code>s</code> is a function and returns a vector.
</p>
</li></ul>

<p>Changes in version 0.9-26 from version 0.9-25 include: 
</p>

<ul>
<li> <p><code><a href="#topic+msd">msd</a></code> now returns an object of class <code>"MSD"</code> which
includes the original data as attributes to permit subsequent bootstrapping.
</p>
</li>
<li><p> A new function, <code><a href="#topic+bootMSD">bootMSD</a></code> that performs parametric
bootstrapping for <code>MSD</code> objects to obtain critical values 
and <em>p</em>-values for the general case where standard uncertainties/standard 
errors differ appreciably.
</p>
</li></ul>

<p>Improvements in version 0.9-25 from version 0.9-23 include: 
</p>

<ul>
<li> <p><code><a href="#topic+plot.d.ellipse">plot.d.ellipse</a></code> now takes default <code>xlab</code> and <code>ylab</code> from 
dimnames in the supplied <code>cov.dellipse</code>.
</p>
</li></ul>

<p>Improvements in version 0.9-23 from version 0.9-22 include: 
</p>

<ul>
<li><p> A wholly new Youden plot (see <code><a href="#topic+yplot">yplot</a></code>), with many options for confidence ellipses
</p>
</li>
<li><p> A REML location estimate, <code><a href="#topic+reml.loc">reml.loc</a></code>, in addition to <code><a href="#topic+vr.mle">vr.mle</a></code>;
<code>reml.loc</code> can use means and standard uncertainties/standard errors instead of raw data 
and when doing so does not require degrees of freedom. 
</p>
</li>
<li><p> Incremental improvements in handling for the median scaled difference measure of anomalies.
<code><a href="#topic+msd">msd</a></code> is faster and less memory-intensive, and <code><a href="#topic+pmsd">pmsd</a></code> now uses a 
beta formulation to extend to very high <code>n</code> (at least 1e6 - if you feel <em>very</em> 
patient).
</p>
</li>
<li><p> Support for <code>log</code> and <code>log.p</code> in <code><a href="#topic+dt.scaled">dt.scaled</a></code>.
</p>
</li></ul>

<p>Corrections and bugfixes include: 
</p>

<ul>
<li><p> amends <code><a href="#topic+plot.drop1.uncert">plot.drop1.uncert</a></code> to give a plot for each measure of change specified in <code>which</code>
</p>
</li>
<li><p> corrects a grep warning appearing in <code>drop1.uncert</code>;
</p>
</li>
<li><p> corrects an unnecessary 'missing <code>u</code>' error message in version 0.9-22's <code>uncert()</code> 
when <code>cov</code> was specified and <code>u</code> was not.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Stephen L R Ellison &lt;s.ellison@lgc.co.uk&gt;.
</p>
<p>Maintainer: Stephen L R Ellison &lt;s.ellison@lgcgroup.com&gt;
</p>

<hr>
<h2 id='mle.1wre'>
Vangel-Rukhin Maximum Likelihood Estimate
</h2><span id='topic+mle.1wre'></span>

<h3>Description</h3>

<p>Calculate a weighted mean, between-group standard deviation and
standard error on the weighted mean using the Maximum likelihood 
algorithm of Vangel-Rukhin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.1wre(x, s2, n, init.mu = mean(x), init.sigma2 = var(x), labels = c(1:length(x)), 
         max.iter = 200, tol = .Machine$double.eps^0.5, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle.1wre_+3A_x">x</code></td>
<td>

<p>numeric vector of the sample mean values of each group
</p>
</td></tr>
<tr><td><code id="mle.1wre_+3A_s2">s2</code></td>
<td>

<p>numeric vector of the sample variances of each group
</p>
</td></tr>
<tr><td><code id="mle.1wre_+3A_n">n</code></td>
<td>

<p>integer vector of sample size of each group
</p>
</td></tr>
<tr><td><code id="mle.1wre_+3A_init.mu">init.mu</code></td>
<td>

<p>numeric initial value for the mean
</p>
</td></tr>
<tr><td><code id="mle.1wre_+3A_init.sigma2">init.sigma2</code></td>
<td>

<p>numeric initial value for the between-group component of variance
</p>
</td></tr>
<tr><td><code id="mle.1wre_+3A_labels">labels</code></td>
<td>

<p>vector of group names. Coerced to character on use.
</p>
</td></tr>
<tr><td><code id="mle.1wre_+3A_max.iter">max.iter</code></td>
<td>

<p>numeric maximum number of iterations
</p>
</td></tr>
<tr><td><code id="mle.1wre_+3A_tol">tol</code></td>
<td>

<p>numeric tolerance; iteration stops when the relative step size drops 
below 'tol'
</p>
</td></tr>
<tr><td><code id="mle.1wre_+3A_trace">trace</code></td>
<td>

<p>when TRUE shows the sequence of intermediate results
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Vangel-Rukhin MLE algorithm finds the between-method variance by
iteratively solving the equation relating the weighted mean to the
weighting factor applied. The weighting factor is the inverse of
the sum of the standard error in 'x' and the between-method
variance, scaled by the between-method variance.
</p>
<p>For the default method, 's2'  is interpreted as a vector of
sample variances. 'x' is interpreted as a vector of sample means
and the algorithm is applied to the corresponding group means,
variances, and sample sizes.
</p>
<p>The Vangel-Rukhin MLE algorithm shows an improvement in the number
of iterations required to converge over the classical MLE based on
the Score equations.
</p>
<p>The function mle.1wre implements the MLE for the one way random effects 
based on the Fisher scoring equations and is provided for comparison 
purpose only.
</p>


<h3>Value</h3>

<p><code>mle.1wre</code> returns an object of class &quot;summary.mle.1wre&quot; which contains
the following fields:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>the estimated mean
</p>
</td></tr>
<tr><td><code>var.mu</code></td>
<td>
<p>the variance associated with the estimated mean
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>the estimated between variance component
</p>
</td></tr>
<tr><td><code>llh</code></td>
<td>
<p>the log likelihood of the estimates
</p>
</td></tr>
<tr><td><code>tot.iter</code></td>
<td>
<p>the total number of iterations ran
</p>
</td></tr>
<tr><td><code>cur.rel.abs.error</code></td>
<td>
<p>the current relative absolute error reached
</p>
</td></tr>
<tr><td><code>sigmai2</code></td>
<td>
<p>a vector with the estimates of the within variance components
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>H. Gasca-Aragon
</p>


<h3>References</h3>

<p>Vangel, M. G. and Rukhin, A. L. (1999), Biometrics, Vol 55, No. 1 pp 129-136
</p>
<p>Searle, S. R., Cassella, G., and McCulloch, C. E. (1992). Variance Components. New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vr.mle">vr.mle</a></code>, <code><a href="#topic+loc.est-class">loc.est-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     ##===================================================================
     ## the dietary fiber in apples example in the Vangel and Rukhin paper
     ##===================================================================

     m1 &lt;- c(12.46, 13.035, 12.44, 12.87, 13.42, 12.08, 13.18, 14.335, 12.23)
     s1 &lt;- c(0.028, 0.233, 0.325, 0.071, 0.339, 0.325, 0.099, 0.064, 0.212)
     n1 &lt;- c(2, 2, 2, 2, 2, 2, 2, 2, 2)

     mle.1wre(m1, s1^2, n1, tol=1e-6)


     # output:
     # 12.90585
     # 0.2234490
     # 0.4262122
     # 12.46790 13.34380
     # 6
 
</code></pre>

<hr>
<h2 id='Pb'>
Lead in wine
</h2><span id='topic+Pb'></span>

<h3>Description</h3>

<p>A data frame containing reported results for lead (in mg/kg) from 
CCQM Key Comparison CCQM-K30.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Pb
</code></pre>


<h3>Format</h3>

<p>A data frame containing 11 reported results with uncertainty data:
</p>

<dl>
<dt>lab</dt><dd><p>Factor giving abbreviated laboratory identifier</p>
</dd>
<dt>value</dt><dd><p>The reported value for lead (mg/kg)</p>
</dd>
<dt>u</dt><dd><p>Standard uncertainty (mg/kg). The values in <code>Pb</code> were calculated from 
the reported expanded uncertainty <code>U</code> and coverage factor <code>k</code> using <code>u=U/k</code>. </p>
</dd>
<dt>k</dt><dd><p>Coverage factor. Conventionally, the coverage factor is set to a suitable  
quantile of Student's t based on the Welch-Satterthwaite effective degrees of freedom 
or simply set to 2 for approximately 95% confidence. In this data set, labs all quoted 
<code>k</code> for approximately 95% confidence. </p>
</dd>
<dt>U</dt><dd><p>Expanded uncertainty as reported by labs.</p>
</dd>
<dt>method</dt><dd><p>Factor indicating general measurement methodology:
</p>

<dl>
<dt>IDMS</dt><dd><p>Isotope dilution mass spectrometry</p>
</dd>
<dt>ICP</dt><dd><p>Inductively coupled plasma spectrometry</p>
</dd>
<dt>GFAAS</dt><dd><p>Graphite furnace atomic absorbtion spectrometry</p>
</dd>
</dl>

</dd>
<dt>include</dt><dd><p>logical; Whether the reported result was included in the calculation 
of the Key Comparison Reference Value for the study. </p>
</dd>
</dl>



<h3>Details</h3>

<p>The study involved circulation of a homogeneous set of samples of wine for analysis for lead (Pb) content
by a number of National Measurement Institutes. 
</p>
<p>The Key Comparison Reference Value, or assigned value for the lead content, was
set at 2.99 mg/kg with expanded uncertainty 0.06 mg/kg.
</p>


<h3>Source</h3>

<p>Hearn, R., Santamaria-Fernandez, R. and Sargent, M. (2008) 
Final report on key comparison CCQM-K30: Determination of lead in wine.
<em>Metrologia</em>
<b>45</b>, 08001, 2008
</p>


<h3>References</h3>

<p>See source.
</p>

<hr>
<h2 id='plot.d.ellipse'>
Plot data ellipses
</h2><span id='topic+plot.d.ellipse'></span>

<h3>Description</h3>

<p>Plots a number of data ellipses specified by </p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'd.ellipse'
plot(x, col.ellipse = 1, lty.ellipse = 1, lwd.ellipse = 1, 
		fill = NA, density = NULL, angle = 45, add = FALSE, npoints = 100, 
		xlim = NA, ylim = NA, 
		prinax = FALSE, col.prinax = 1, lty.prinax = 1, lwd.prinax = 1, 
		xlab=NULL, ylab=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.d.ellipse_+3A_x">x</code></td>
<td>

<p>An object of class <code>d.ellipse</code>
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_col.ellipse">col.ellipse</code>, <code id="plot.d.ellipse_+3A_lty.ellipse">lty.ellipse</code>, <code id="plot.d.ellipse_+3A_lwd.ellipse">lwd.ellipse</code></td>
<td>

<p>Colour, line type and line width for the ellipse(s). Can be vectors, allowing different
colour, line type etc. Recycled as necessary to length <code>length(x)</code>. 
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_fill">fill</code>, <code id="plot.d.ellipse_+3A_density">density</code>, <code id="plot.d.ellipse_+3A_angle">angle</code></td>
<td>

<p>Fill colour, line density and line angle for each ellipse in <code>x</code>. See  <code><a href="graphics.html#topic+polygon">polygon</a></code> for details. 
Can be vectors. Recycled as necessary to length <code>length(x)</code>. 
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_add">add</code></td>
<td>

<p>If <code>TRUE</code>, ellipses are added to an existing plot. If <code>FALSE</code> a new plot is created. 
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_npoints">npoints</code></td>
<td>

<p>Controls the number of points used to form each ellipse. See  <code><a href="#topic+data.ellipse">data.ellipse</a></code> for details.
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_xlim">xlim</code>, <code id="plot.d.ellipse_+3A_ylim">ylim</code></td>
<td>

<p>Plot limits. Ignored if <code>add == FALSE</code>
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_prinax">prinax</code></td>
<td>

<p>If <code>TRUE</code> (the default), the principal axes are drawn on the plot. 
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_col.prinax">col.prinax</code>, <code id="plot.d.ellipse_+3A_lty.prinax">lty.prinax</code>, <code id="plot.d.ellipse_+3A_lwd.prinax">lwd.prinax</code></td>
<td>

<p>Colour, line type and line width for principal axes. 
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_xlab">xlab</code>, <code id="plot.d.ellipse_+3A_ylab">ylab</code></td>
<td>

<p>Axis labels passed to <code>plot</code> if <code>add == FALSE</code>. Defaults to dimension names
in <code>x</code> or, if those are <code>NULL</code>, to &quot;X&quot; and &quot;Y&quot;.
</p>
</td></tr>
<tr><td><code id="plot.d.ellipse_+3A_...">...</code></td>
<td>

<p>Additional arguments, passed to <code>plot</code> if <code>add == TRUE</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A series of ellipses specified in <code>x</code> is plotted. 
The function is primarily used for adding ellipses to a Youden plot.
</p>


<h3>Value</h3>

<p>The function is called for its side effect, which is the drawing of ellipses.
</p>


<h3>Author(s)</h3>

<p>S L R Ellison
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.ellipse">data.ellipse</a></code>, <code><a href="#topic+youden.plot">youden.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chromium)
cov.Cr &lt;- cov.dellipse(chromium)
dellipse.Cr &lt;- data.ellipse(cov.Cr, plot=FALSE)
plot(dellipse.Cr)

</code></pre>

<hr>
<h2 id='plot.mandel.kh'>
Classical plots of Mandel's statistics.
</h2><span id='topic+plot.mandel.kh'></span>

<h3>Description</h3>

<p><code>plot.mandel.kh</code> produces classic plots of Mandel's statistics, suitably
grouped and with appropriate indicator lines for unusual values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'mandel.kh'
plot(x, probs = c(0.95, 0.99), main, xlab = attr(x, "grouped.by"), 
		ylab = attr(x, "mandel.type"), ylim = NULL, las = 1, 
		axes = TRUE, cex.axis = 1, frame.plot = axes, 
		lwd = 1, lty = 1, col = par("col"), 
		col.ind = 1, lty.ind = c(2, 1), lwd.ind = 1, 
		separators = TRUE, col.sep = "lightgrey", lwd.sep = 1, lty.sep = 1, 
		zero.line = TRUE, lwd.zero = 1, col.zero = 1, lty.zero = 1, 
		p.adjust = "none", ...)
		

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mandel.kh_+3A_x">x</code></td>
<td>
<p>An object of class <code>'mandel.kh'</code>
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_probs">probs</code></td>
<td>

<p>Indicator lines are drawn for these probabilities. Note that
<code>probs</code> is interpreted as specifying two-tailed probabilities
for Mandel's h and one-sided (upper tail) probabilities for
Mandel's k.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_main">main</code></td>
<td>

<p>a main title for the plot. If missing, the default is
<code> paste(deparse(substitute(x)), " - Mandel's", 
                     attr(x, "mandel.type"), 
                     if(attr(x, "mandel.method") == "robust") "(Robust variant)")</code>
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_xlab">xlab</code></td>
<td>

<p>a label for the x axis; defaults to the <code>grouped.by</code> attribute for
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_ylab">ylab</code></td>
<td>

<p>a label for the x axis; defaults to the <code>mandel.type</code> attribute for
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_ylim">ylim</code></td>
<td>

<p>the y limits of the plot. For Mandel's k, the default lower limit is zero.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_las">las</code></td>
<td>

<p>the style of the axis labels; see <code>par</code> for details.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_axes">axes</code></td>
<td>

<p>a logical value indicating whether axes should be drawn
on the plot.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_cex.axis">cex.axis</code></td>
<td>

<p>The magnification to be used for axis annotation
relative to the current setting of 'cex'.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_frame.plot">frame.plot</code></td>
<td>

<p>Logical; If <code>TRUE</code> a box is drawn around the plot.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_lwd">lwd</code>, <code id="plot.mandel.kh_+3A_lty">lty</code>, <code id="plot.mandel.kh_+3A_col">col</code></td>
<td>

<p>Graphical parameters used for the plotted vertical lines corresponding 
to each value of Mandel's statistics (the plot is of type &quot;h&quot;). All are
recycled across the prinmary grouping factor, allowing different measurands/test 
items to be identified more clearly.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_col.ind">col.ind</code>, <code id="plot.mandel.kh_+3A_lty.ind">lty.ind</code>, <code id="plot.mandel.kh_+3A_lwd.ind">lwd.ind</code></td>
<td>

<p>Graphical parameters used for the indicator lines, recyckled to <code>length(probs)</code>. 
For <code>attr(x, "mandel.type")=="h"</code> the graphical parameters are applied to negative
as well as positive indicator lines, applied outwards from zero.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_separators">separators</code></td>
<td>

<p>Logical; if <code>TRUE</code>, separator lines are drawn between groups of values.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_col.sep">col.sep</code>, <code id="plot.mandel.kh_+3A_lwd.sep">lwd.sep</code>, <code id="plot.mandel.kh_+3A_lty.sep">lty.sep</code></td>
<td>

<p>Graphical parameters used for the separator lines.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_zero.line">zero.line</code></td>
<td>

<p>logical; if <code>TRUE</code> a horizontal line is drawn at zero.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_lwd.zero">lwd.zero</code>, <code id="plot.mandel.kh_+3A_col.zero">col.zero</code>, <code id="plot.mandel.kh_+3A_lty.zero">lty.zero</code></td>
<td>

<p>Graphical parameters used for the zero line.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_p.adjust">p.adjust</code></td>
<td>

<p>Correction method for probabilities. If not <code>"none"</code>, passed to <code>p.adjust</code>
prior to calculating indicator lines. Usually, indicator lines are drawn without 
correction (that is, with <code>p.adjust="none"</code>); specifying a p-value correction 
effectively turns the Mandel's 	statistics into single outlier tests.
</p>
</td></tr>
<tr><td><code id="plot.mandel.kh_+3A_...">...</code></td>
<td>

<p>Other (usually graphical) parameters passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mandel's statistics are traditionally plotted for inter-laboratory study data, 
grouped by laboratory, to give a rapid graphical view of laboratory bias and 
relative precision. The traditional plot is a plot of type <code>"h"</code>, that is, 
simple vertical lines from the x-axis.
</p>
<p>For classical Mandel statistics, indicator lines are drawn based on <code>qmandelh</code>
or  <code>qmandelk</code> as appropriate. For robust variants, indicator lines use
<code>qnorm</code> for the <code class="reqn">h</code> statistic and <code>qf(probs, n, Inf)</code> for 
the <code class="reqn">k</code> statistic. Note that this corresponds to taking the robust estimates of 
location and scale as true values, so will be somewhat anticonservative.
</p>
<p><code>plot.mandel.kh</code> uses <code>gplot</code> for the main plot.
</p>


<h3>Value</h3>

<p>plot.mandel.kh returns a numeric vector of mid-points of the groups along the x-axis.
</p>


<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>Accuracy (trueness and precision) of measurement methods and results &ndash; Part 2: 
Basic method for the determination of repeatability and reproducibility of a 
standard measurement method. ISO, Geneva (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mandel.h">mandel.h</a></code>, <code><a href="#topic+mandel.k">mandel.k</a></code>, <code><a href="#topic+mandel.kh">mandel.kh</a></code>,
<code><a href="#topic+pmandelh">pmandelh</a></code>, <code><a href="#topic+pmandelk">pmandelk</a></code>  for probabilities, quantiles etc.
</p>
<p>See <code><a href="#topic+barplot.mandel.kh">barplot.mandel.kh</a></code> for an alternative plotting method.
<code><a href="#topic+gplot">gplot</a></code> for the underlying plotting function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   data(RMstudy)

   h &lt;- with(RMstudy, mandel.h(RMstudy[2:9], g=Lab))
   plot(h, las=2) # Lab 4 shows consistent low bias; 
                  # Lab 23 several extreme values.

   #Use colours to identify particular measurands:
   plot(h, las=2, col=1:8)
   legend("bottomleft", legend=names(h), col=1:8, lty=1, cex=0.7, bg="white")
   
   #Example of Mandel's k:
   k &lt;- with(RMstudy, mandel.k(RMstudy[2:9], g=Lab))
   plot(k, las=2) # Lab 8 looks unusually variable; 
                  # Lab 14 unusually precise

</code></pre>

<hr>
<h2 id='plot.uncert'>
Plot method for 'uncert' objects
</h2><span id='topic+plot.uncert'></span>

<h3>Description</h3>

<p>Plots for uncertainty budgets produced by <code>uncert</code> calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uncert'
plot(x, which = c(1,2,4,5), main = paste(deparse(substitute(x))), 
    ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), 
    caption = list("Variance and covariance contributions", 
    expression(sqrt(group("|", "Variance and covariance contributions", "|"))), 
    expression("Contribution " * u[i](y) == c[i] * u[i]), 
    "Combined contribution", "Correlation (x,y)", 
    "Covariances (x,y)"), cex.caption = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.uncert_+3A_x">x</code></td>
<td>
<p>An object of class <code>uncert</code> produced by a call to <code>uncert()</code>.
</p>
</td></tr>
<tr><td><code id="plot.uncert_+3A_which">which</code></td>
<td>
<p>Integer in 1:6; the particular variant(s) of plot required. A 
vector is permitted, in which case plots are produced in ascending order.
</p>
</td></tr>
<tr><td><code id="plot.uncert_+3A_main">main</code></td>
<td>
<p>Main title for the plot
</p>
</td></tr>
<tr><td><code id="plot.uncert_+3A_ask">ask</code></td>
<td>
<p>logical; if 'TRUE', the user is _ask_ed before each plot, see 'par(&quot;ask=&quot;)'</p>
</td></tr>
<tr><td><code id="plot.uncert_+3A_caption">caption</code></td>
<td>
<p>A list of captions for <em>all</em> the different plots. 
</p>
</td></tr>
<tr><td><code id="plot.uncert_+3A_cex.caption">cex.caption</code></td>
<td>
<p>Text size for captions. Note that if the number of figures per 
page is over 2, captions are further scaled by 0.8 
</p>
</td></tr>
<tr><td><code id="plot.uncert_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code>plot()</code> (mostly barplot).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For uncert objects created with methods other than MC, the plot types are:
</p>

<dl>
<dt><code>which=1</code></dt><dd><p>A barplot of all non-zero contributions to the combined 
uncertainty. These are derived from the covariance matrix and the coefficients <code class="reqn">c_i</code>. 
For terms on the diagonal of the covariance matrix, these are <code class="reqn">(c_i*u_i)^2</code>; for 
off-diagonal terms (the correlation terms), <code class="reqn">2*(c_i*u_i)*(c_j*u_j)*r_ij</code>. 
The threshold for deciding an off-diagonal term is nonzero is that its magnitude 
is greater than <code>2*.Machine$double.eps</code>. Note that off-diagonal contributions
may be negative.</p>
</dd>
<dt><code>which=2</code></dt><dd><p>As for <code>which=1</code> except that the square root of the 
absolute value is plotted. For the 'diagonal' terms, these are just eqnu_i(y) 
in the nomenclature used by the GUM.</p>
</dd>
<dt><code>which=3</code></dt><dd><p>A barplot of <code class="reqn">u_i(y)^2</code>, without the correlation terms.</p>
</dd>
<dt><code>which=4</code></dt><dd><p>A barplot of the sum of all (co)variance contributions 
associated with each <code class="reqn">x_i</code>, that is, 
</p>
<p style="text-align: center;"><code class="reqn">contrib(i)=(c_{i}u_{i})^2+\sum\nolimits _{j\neq{}i} 2(c_{i}u_{i})(c_{j}u_{j})r_{i,j}</code>
</p>
<p>. 
</p>
</dd>
<dt><code>which=5</code></dt><dd><p>A barplot of the theoretical correlations 
<code class="reqn">cov(x_i,y)/u(x_i)u_y</code>. 
</p>
</dd>
<dt><code>which=6</code></dt><dd><p>A barplot of the theoretical covariances <code class="reqn">cov(x_i,y)</code>. 
</p>
</dd>
</dl>

<p>Values of <code>which</code> outside this range are silently ignored.
</p>
<p>For the X-Y correlation and covariance plots, the covariances are calculated from the 
covariance matrix <code class="reqn">V</code> (supplied to <code>uncert()</code> as <code>cov</code> 
or calculated as <code>outer(u,u,"*")*cor</code>) and sensitivity coefficients <code class="reqn">c_i</code> 
as <code class="reqn">cov(x_i,y) = \sum\nolimits _{j} V_{j,i}c_j </code>. 
In fact the calculation used is simpler: <code>cov.xy &lt;- V %*% ci</code>. The correlations 
are calculated in turn from these using <code class="reqn">cov(x_i,y)/u(x_i)u_y</code>.
</p>
<p>Perhaps the most informative plots are for <code>which=1</code>, <code>which=2</code>,
<code>which=4</code> and <code>which=5</code>. The first of these includes all nonzero signed contributions, 
making the negative contributions visible; the second (<code>which=2</code>) makes direct
comparison of magnitudes easier. The combined contribution plot is the effect on
the total variance of removing all terms associated with a particular variable; it
shows how much <code class="reqn">u_y^2</code> would <em>reduce</em> if the uncertainty for <code class="reqn">x_i</code> were 
reduced to zero. Note that in some cases with negative correlation the combined uncertainty can <em>increase</em>,
on dropping a variable, shown by a negative reduction in the plot. (<code>which=5</code>) is among the most 
direct indications of the relative importance of individual parameters.
</p>
<p>Objects created with the MC method are passed to <code><a href="#topic+plot.uncertMC">plot.uncertMC</a></code>.
</p>


<h3>Value</h3>

<p>Invisibly returns the default return value for the last plot produced.</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison, <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncert">uncert</a></code>, <code><a href="graphics.html#topic+barplot">barplot</a></code>, <code><a href="#topic+plot.uncertMC">plot.uncertMC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #An example with negative correlation
  x &lt;- list(a=1, b=3, c=2, d=11)
  u &lt;- lapply(x, function(x) x/10)
  u.cor&lt;-diag(1,4)
  u.cor[3,4]&lt;-u.cor[4,3]&lt;- -0.5
  u.form.c&lt;-uncert(~a+b*2+c*3+d/2, x, u, method="NUM", cor=u.cor)
  
  par(mfrow=c(3,2))
  plot(u.form.c, which=1:6, las=1, horiz=TRUE)  #Note use of barplot parameters

</code></pre>

<hr>
<h2 id='plot.uncertMC'>
Plot method for 'uncertMC' objects
</h2><span id='topic+plot.uncertMC'></span>

<h3>Description</h3>

<p>Plots for uncertainty evaluations produced by <code>uncertMC</code> or calls 
to <code>uncert</code> with <code>method=MC</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uncertMC'
plot(x, which = 1:2, 
    main=paste("Monte Carlo evaluation -",deparse(substitute(x))), 
    ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), 
    caption = list("Histogram", "Q-Q plot", "Density", 
    "Correlation x-y", "Covariance x-y"), 
    xlab = paste(deparse(substitute(x)), "$y", sep = ""), 
    ..., cex.caption = 1, cex.main = 1.25, lwd.y = 2, col.y = 2, lty.y,
    col.qqline = NULL, lty.qqline = NULL, lwd.qqline = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.uncertMC_+3A_x">x</code></td>
<td>
<p>An object of class <code>uncertMC</code> produced by <code>uncertMC()</code> or  
<code>uncert()</code> with <code>method="MC"</code>.
</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_which">which</code></td>
<td>
<p>Integer in 1:5; the particular variant(s) of plot required. 
A vector is permitted, in which case plots are produced in ascending order 
of <code>which</code>.</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_main">main</code></td>
<td>
<p>Main title for the plot</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_ask">ask</code></td>
<td>
<p>logical; if 'TRUE', the user is _ask_ed before each plot, see 'par(&quot;ask=&quot;)'</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_caption">caption</code></td>
<td>
<p>A list of captions for <em>all</em> the different plots. 
</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, currently passed only to the histogram plot.</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions. See details
for which parameters are passed.</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_cex.caption">cex.caption</code></td>
<td>
<p>Expansion factor for individual plot captions; as <code>cex</code> in <code>par</code>.</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_cex.main">cex.main</code></td>
<td>
<p>Expansion factor for main title; as <code>cex.main</code> in <code>par</code>.
</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_lwd.y">lwd.y</code>, <code id="plot.uncertMC_+3A_col.y">col.y</code>, <code id="plot.uncertMC_+3A_lty.y">lty.y</code></td>
<td>
<p>Line width and colour for the location line in the histogram
and density plots. Setting lwd.y=0 suppresses the location line.</p>
</td></tr>
<tr><td><code id="plot.uncertMC_+3A_col.qqline">col.qqline</code>, <code id="plot.uncertMC_+3A_lty.qqline">lty.qqline</code>, <code id="plot.uncertMC_+3A_lwd.qqline">lwd.qqline</code></td>
<td>
<p>Graphical parameters for the Q-Q line in the 
Q-Q plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For uncert objects created with methods other than MC, the plot types are:
</p>

<dl>
<dt><code>which=1</code></dt><dd><p>A histogram of the MC replicates in <code>x$MC$y</code>, 
with optional line for <code>x$MC$y</code>. The histogram is produced using
<code>hist.default</code></p>
</dd>
<dt><code>which=2</code></dt><dd><p>A Q-Q plot of the MC replicates in <code>x$MC$y</code>, 
with Q-Q line. The plot uses <code>qqnorm.default</code>. If <code>datax</code> is not
present (in sQuote...), it is set to <code>TRUE</code>.</p>
</dd>
<dt><code>which=3</code></dt><dd><p>A density plot of the MC replicates in <code>x$MC$y</code>.
The plot calls <code>density.default</code> to calculate the density and 
<code>plot.density</code> to produce the plot.</p>
</dd>
<dt><code>which=4</code></dt><dd><p>A bar plot of eqncor(x_i,y) if <code>x$y</code>
is present. Any correlation method supported by <code>stats::cor</code> may 
be included in &lsquo;...&rsquo; (e.g as <code>method="pearson"</code>.</p>
</dd>
<dt><code>which=5</code></dt><dd><p>A bar plot of eqncov(x_i,y) if <code>x$y</code>
is present. Any correlation method supported by <code>stats::cov</code> may 
be included in &lsquo;...&rsquo; (e.g as <code>method="pearson"</code>.</p>
</dd>
</dl>

<p>Values outside 1:5 are silently ignored.
</p>
<p>Parameters in &lsquo;...&rsquo; are passed to the various plot methods or calculations called. 
Only those parameters relevant to a given plot are passed to each calculation or
plotting function, so &lsquo;...&rsquo; can include any parameter accepted by any of the 
functions called.
</p>
<p>For the x-y correlation and x-y covariance plot, values in <code>x$cor.xy</code> are 
used if available. If not, <code>stats::cor</code> or <code>stats::cov</code> is called on values 
in <code>x$MC$y</code> and <code>x$MC$x</code> if the latter is available 
(i.e. <code>uncertMC</code> was called with <code>keep.x=TRUE</code>). If neither 
<code>x$cor.xy</code> nor <code>x$MC$x</code> is present, or if <code>method</code> is 
unknown, the plot is skipped with a warning.
</p>


<h3>Value</h3>

<p><code>plot.uncertMC</code> invisibly returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison, <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncertMC-class">uncertMC-class</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>, 
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>, <code><a href="stats.html#topic+qqline">qqline</a></code>, 
<code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+plot.density">plot.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  expr &lt;- expression(a/(b-c))
  x &lt;- list(a=1, b=3, c=2)
  u &lt;- lapply(x, function(x) x/20)
  set.seed(403)
  u.invexpr&lt;-uncertMC(expr, x, u, distrib=rep("norm", 3), B=999, keep.x=TRUE )
  par(mfrow=c(2,2))
  plot(u.invexpr, which=1:4, pch=20, method="k") 
                                # method="k" gives Kendall correlation 
</code></pre>

<hr>
<h2 id='potassium'>
Potassium data for two different materials included in an interlaboratory study
</h2><span id='topic+potassium'></span>

<h3>Description</h3>

<p>Potassium data for two different materials included in an interlaboratory study 
intended to provide data for certification of a reference material.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("potassium")</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 2 variables.
</p>

<dl>
<dt><code>QC</code></dt><dd><p>Potassium concentrations (mg/kg) reported on a 
material used as a quality control material</p>
</dd>
<dt><code>RM</code></dt><dd><p>Potassium concentrations (mg/kg) reported on a 
candidate reference material material used as a quality control material</p>
</dd>
</dl>



<h3>Details</h3>

<p>Potassium data for two different materials included in an interlaboratory study 
intended to provide data for certification of a crab tissue reference material. 
The study included a previously certified reference material (near end of stock) to 
serve as a quality control (QC) check. Laboratories were asked to report five replicate 
measurements on the candidate reference material and three for the QC material. Each 
row in the data set corresponds to the mean of replicate results reported by each laboratory. 
</p>
<p>Inspection of the data suggests that one laboratory interchanged or mislabelled 
the test materials. The anomalous results appear as an outlier for both QC and RM, as well as
being visible as an off-diagonal outlier in a Youden plot - see <code><a href="#topic+youden.plot">youden.plot</a></code>).
</p>


<h3>Source</h3>

<p>Private communication - Pending publication
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potassium)
yplot(potassium)
</code></pre>

<hr>
<h2 id='rbind.ilab'>
Combine 'ilab' objects
</h2><span id='topic+rbind'></span><span id='topic+cbind'></span><span id='topic+rbind.default'></span><span id='topic+cbind.default'></span><span id='topic+rbind.ilab'></span><span id='topic+cbind.ilab'></span><span id='topic+c.ilab'></span>

<h3>Description</h3>

<p>Functions to combine ilab objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind(..., deparse.level = 1)
## Default S3 method:
rbind(..., deparse.level = 1)
## S3 method for class 'ilab'
rbind(..., deparse.level = 1)

## S3 method for class 'ilab'
c(..., recursive=FALSE)

cbind(..., deparse.level = 1)
## Default S3 method:
cbind(..., deparse.level = 1)
## S3 method for class 'ilab'
cbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.ilab_+3A_...">...</code></td>
<td>
<p>For <code>rbind</code> and <code>c</code>, objects of class &lsquo;ilab&rsquo;
to be combined. For <code>cbind</code>, one 'ilab' object and vectors, scalars 
or data frames to be appended to the 'ilab' object's $data element. See Details.
</p>
</td></tr>
<tr><td><code id="rbind.ilab_+3A_deparse.level">deparse.level</code></td>
<td>
<p>integer controlling the construction of labels. Passed 
to <code><a href="base.html#topic+cbind">rbind.data.frame</a></code> or <code>base::cbind</code>.
</p>
</td></tr>
<tr><td><code id="rbind.ilab_+3A_recursive">recursive</code></td>
<td>
<p>logical, controlling recursion in lists. Included solely for 
consistency with <code>base::c</code>; no effect in <code>c.ilab</code>. 
</p>
</td></tr>
<tr><td><code id="rbind.ilab_+3A_ilab">ilab</code></td>
<td>
<p>object of class &lsquo;ilab&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic and default cbind and rbind functions defined by metRology use the first 
object in <code>'...'</code> to decide which method to apply. This differs from the behaviour 
of these functions in the base package, which dispatch based on inspection of 
all objects in <code>'...'</code> (see <code><a href="base.html#topic+cbind">rbind</a></code> in the base package for details). 
Control is, however, passed to the base package functions if an ilab object is not first 
in the list.
</p>
<p>The <code>rbind</code> method for class 'ilab' combines objects by applying
<code>rbind</code> to the <code>$data</code> elements in turn and then concatenating the 
<code>$distrib</code> and <code>$distrib.pars</code> elements using the default <code>c</code> 
method. 
</p>
<p>Combination of the <code>$data</code> elements follows the rules of <code>rbind.data.frame</code>; 
in particular, names must match, but need not be in the same order and the return value 
column classes will be coerced to match the first if necessary. 
</p>
<p><code>c.ilab</code> simply passes the objects to <code>rbind.ilab</code>, using the default value 
for <code>deparse.level</code>. <code>recursive</code> is ignored. An error is returned if any 
objects in <code>'...'</code> are not of class &lsquo;ilab&rsquo;.
</p>
<p>The <code>cbind</code> method for &lsquo;ilab&rsquo; objects combines objects of class &lsquo;ilab&rsquo; 
with atomic objects or data frames by applying <code>base::cbind</code> to <code>$data</code> in the 
(single) supplied ilab object and the items listed in <code>'...'</code>. <code>base::cbind</code> 
will extend scalars, vectors or columns in data frames to length <code>nrow(ilab$data)</code> if
their length is an integer fraction of <code>nrow(ilab$data)</code>. Unlike <code>base::cbind</code>, 
<code>cbind.ilab</code> does not permit vectors or data frames longer than <code>nrow(ilab$data)</code>
and will return an error in such cases. cbind.ilab will also return an error if any objects in 
<code>'...'</code> are not one of atomic, data frame or class &lsquo;ilab&rsquo;, if more than one 
&lsquo;ilab&rsquo; object is supplied or if none are. 
</p>


<h3>Value</h3>

<p>An object of class &lsquo;ilab&rsquo;. The title for the returned object is the title for 
the first ilab object in the list.
</p>
<p>For the <code>cbind</code> method, the returned object will have additional columns in the 
<code>$data</code> element, and the title will be unchanged.
</p>


<h3>Warning</h3>

<p>Because of the unusual method dispatch behaviour of <code>base::cbind</code> and 
<code>base::rbind</code>, which use the data frame method if <em>any</em> objects in
<code>'...'</code> are data frames, metRology masks the base package functions 
in order to guarantee correct dispatch when data frames are included in <code>'...'</code>. 
No adverse effects are currently known, but please report any to the package maintainer.
Calling <code>base::cbind</code> directly will provide a work-around if necessary.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, yet.</p>


<h3>See Also</h3>

<p>base package functions <code><a href="base.html#topic+cbind">cbind</a></code>, <code><a href="base.html#topic+c">c</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pb)
il1&lt;-construct.ilab(org=Pb$lab, x=Pb$value, measurand="Pb", item="none", 
                u=Pb$u, k=Pb$k, U=Pb$U, title=c("CCQM K30", "Lead in wine"),
                method=Pb$method)

rbind(il1, il1)

</code></pre>

<hr>
<h2 id='REML+20location+20estimate'>
Restricted maximum likelihood estimate of location
</h2><span id='topic+reml.loc'></span><span id='topic+reml.loc.default'></span>

<h3>Description</h3>

<p>Calculates REML estimate of location, with standard error, assuming 
a random-effects model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	reml.loc(x, ..., na.rm = FALSE)

	## Default S3 method:
reml.loc(x, s, n = NULL, groups = NULL, na.rm = FALSE,
	          tol=.Machine$double.eps^0.5, REML=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="REML+2B20location+2B20estimate_+3A_x">x</code></td>
<td>
<p>numeric vector of mean values for groups, or (if <code>groups</code> 
is given) of individual observations</p>
</td></tr>
<tr><td><code id="REML+2B20location+2B20estimate_+3A_s">s</code></td>
<td>
<p>numeric vector of length <code>length(x)</code> of standard deviations or 
standard uncertainties associated with the values <code>x</code>.
</p>
</td></tr>
<tr><td><code id="REML+2B20location+2B20estimate_+3A_n">n</code></td>
<td>
<p>integer giving the number of observations in each group. May be a vector 
of length <code>length(x)</code>. If <code>n</code> is <code>NULL</code>, <code>s</code> is interpreted as 
a vector of standard uncertainties or standard errors. <code>n</code> is recycled 
to <code>length(x)</code>
</p>
</td></tr>
<tr><td><code id="REML+2B20location+2B20estimate_+3A_groups">groups</code></td>
<td>
<p>factor, or vetor which can be coerced to factor, of groups. If 
present, <code>x</code> is interpreted as a vector of individual observations 
and <code>s</code> and <code>n</code> ignored, if present, with a warning. 
</p>
</td></tr>
<tr><td><code id="REML+2B20location+2B20estimate_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if <code>TRUE</code>,  <code>NA</code> values are removed 
before processing.
</p>
</td></tr>
<tr><td><code id="REML+2B20location+2B20estimate_+3A_tol">tol</code></td>
<td>
<p>numeric tolerance for convergence, used by <code>optimize()</code>.
</p>
</td></tr>
<tr><td><code id="REML+2B20location+2B20estimate_+3A_reml">REML</code></td>
<td>
<p>logical: if <code>TRUE</code> (the default),  the function optimises the REML 
criterion (see Details). If FALSE, the maximum likelihood criterion is used.
</p>
</td></tr>
<tr><td><code id="REML+2B20location+2B20estimate_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code>optimize()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reml.loc</code> finds an excess variance <code class="reqn">\tau^2</code> and location <code class="reqn">\mu</code> that maximise the 
restricted maximum likelihood criterion.
</p>
<p>The estimator assumes a model of the form
</p>
<p style="text-align: center;"><code class="reqn">x_i=\mu+b_i+e_i</code>
</p>

<p>in which <code class="reqn">b_i</code> is drawn from <code class="reqn">N(0, \tau^2)</code> and
<code class="reqn">e_i</code> is drawn from <code class="reqn">N(0, \sigma_i^2)</code>.
</p>
<p>By default the function maximises the data-dependent part of the negative log restricted likelihood:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2}  \left( \sum_{i=1}^{k}\frac{(x_i-mu)^2}{u_i^2}  + \sum_{i=1}^{k}log(u_i^2) + 
			 log\left(\sum_{i=1}^{k}(1/u_i^2)\right) \right)</code>
</p>

<p>where <code class="reqn">u_i=s_i^2 + \tau^2</code> and <code class="reqn">k</code> is the number of mean values.
If <code>REML=FALSE</code>, the final term is omitted to give the maximum likelihood criterion.
</p>
<p>This implementation permits input in the form of:
</p>

<ul>
<li><p> means <code>x</code> and standard errors <code>s</code>, in which case neither <code>n</code> nor 
<code>groups</code> are supplied;
</p>
</li>
<li><p> means <code>x</code>, standard deviations <code>s</code> and group size(s) <code>n</code>, 
standard errors then being calculated as <code>s/sqrt(n)</code>
</p>
</li>
<li><p> individual observations <code>x</code> with a groupinf factor <code>groups</code>, in 
which case standard errors are calculated from the groups using <code>tapply</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A loc.est object; see loc.est for details. In the returned object, individual
values <code>xi</code> are always input means (calculated from groups and <code>n</code> as 
necessary); <code>method.details</code> is returned as a list containing:
</p>

<dl>
<dt>mu</dt><dd><p>The estimated location.
</p>
</dd>
<dt>s</dt><dd><p>The standard error in the location.
</p>
</dd>
<dt>tau</dt><dd><p>The excess variance (as a standard deviation).
</p>
</dd>
<dt>REML</dt><dd><p>Logical, giving the value of REML used.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>S L R Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, but see documentation for the metafor package for a more general implementation of REML.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loc.est-class">loc.est-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #PCB measurements in a sediment from Key Comparison CCQM-K25
  #s are reported standard uncertainties
  pcb105 &lt;- data.frame(x=c(10.21, 10.9, 10.94, 10.58, 10.81, 9.62, 10.8),
               s=c(0.381, 0.250, 0.130, 0.410, 0.445, 0.196, 0.093))
               		
  with( pcb105, reml.loc(x, s) )

</code></pre>

<hr>
<h2 id='RMstudy'>
Collaborative study results for metals in a reference material certification study
</h2><span id='topic+RMstudy'></span>

<h3>Description</h3>

<p>A data frame containing reported replicate results, in mg/L, for elements reported 
in an inter-laboratory certification study for a candiate drinking reference material.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(RMstudy)
</code></pre>


<h3>Format</h3>

<p>A data frame with 145 observations on the following 9 variables.
</p>

<dl>
<dt><code>Lab</code></dt><dd><p>a factor with levels <code>Lab1</code> - <code>Lab29</code></p>
</dd>
<dt><code>Arsenic</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Cadmium</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Chromium</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Copper</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Lead</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Manganese</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Nickel</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Zinc</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data set includes results for eight of a total of 23 elements studied in an 
inter-laboratory study of a candidate reference material.  All observations are 
reported in ug/l. 
Laboratories were asked to report 5 replicate observations for each element. Replicate 
observations appear on separate rows. Most but not all laboratories reported five 
replicates, and some laboratories reported no results for some elements. The eight
elements included in the data set are those for which no more than three laboratories
failed to report any results. Missing observations are coded <code>NA</code>.
</p>
<p>Laboratories were coded anonymously in order of receipt of results.
</p>


<h3>Source</h3>

<p>LGC limited, Teddington, UK (Private communication).
</p>

<hr>
<h2 id='Scaled+20t+20distribution'>
Scaled and shifted t distribution.
</h2><span id='topic+dt.scaled'></span><span id='topic+pt.scaled'></span><span id='topic+qt.scaled'></span><span id='topic+rt.scaled'></span>

<h3>Description</h3>

<p>Student's t distribution for 'df' degrees of freedom, shifted by 'mean' and
scaled by 'sd'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.scaled(x, df, mean = 0, sd = 1, ncp, log = FALSE)
pt.scaled(q, df, mean = 0, sd = 1, ncp, lower.tail = TRUE, log.p = FALSE)
qt.scaled(p, df, mean = 0, sd = 1, ncp, lower.tail = TRUE, log.p = FALSE)
rt.scaled(n, df, mean = 0, sd = 1, ncp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_x">x</code>, <code id="Scaled+2B20t+2B20distribution_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_df">df</code></td>
<td>
<p>degrees of freedom (&gt; 0, maybe non-integer).  <code>df = Inf</code> is
allowed.</p>
</td></tr>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_mean">mean</code></td>
<td>
<p>mean value for the shifted, scaled distribution.</p>
</td></tr>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_sd">sd</code></td>
<td>
<p>Scale factor for the shifted, scaled distribution.</p>
</td></tr>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter delta; currently except for <code>rt()</code>,
only for <code>abs(ncp) &lt;= 37.62</code>. If omitted, use the central t
distribution.</p>
</td></tr>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x]; otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="Scaled+2B20t+2B20distribution_+3A_log">log</code>, <code id="Scaled+2B20t+2B20distribution_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are wrappers for the corresponding t distribution functions in package <code>stats</code>. 
</p>
<p>The scaled, shifted t distribution has mean <code>mean</code> and variance <code>sd^2 * df/(df-2)</code>
</p>
<p>The scaled, shifted t distribution is used for Monte Carlo evaluation when a value x has 
been assigned a standard uncertainty u associated with with df degrees of freedom; 
the corresponding distribution function for that is then <code>t.scaled</code> with
<code>mean=x</code>, <code>sd=u</code> and <code>df=df</code>.
</p>


<h3>Value</h3>

<p><code>dt.scaled</code> gives the density, <code>pt.scaled</code> gives the distribution function, 
<code>qt.scaled</code> gives the quantile function, and <code>rt.scaled</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a
warning.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	u&lt;-rt.scaled(20, df=5, mean=11, sd=0.7)
	
	qt.scaled(c(0.025,0.975), Inf, mean=10, sd=1) #10 +- 1.96*sd
	
	require(graphics)
	hist(rt.scaled(10000, df=4, mean=11, sd=0.7), breaks=50, probability=TRUE)
	x&lt;-seq(0,25, 0.05)
	lines(x,dnorm(x,mean=11, sd=0.7), col=2)

</code></pre>

<hr>
<h2 id='Triangular'>
The triangular distribution.
</h2><span id='topic+dtri'></span><span id='topic+ptri'></span><span id='topic+qtri'></span><span id='topic+rtri'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the triangular distribution with range 'min' to 'max' 
and mode equal to 'mode'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtri(x, min=-sqrt(6), max=sqrt(6), mode = (min + max)/2, 
		log = FALSE)
		
ptri(q, min=-sqrt(6), max=sqrt(6), mode = (min + max)/2, 
		lower.tail = TRUE, log.p = FALSE)
		
qtri(p, min=-sqrt(6), max=sqrt(6), mode = (min + max)/2, 
		lower.tail = TRUE, log.p = FALSE)
		
rtri(n, min=-sqrt(6), max=sqrt(6), mode = (min + max)/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Triangular_+3A_x">x</code>, <code id="Triangular_+3A_q">q</code></td>
<td>
<p> Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_p">p</code></td>
<td>
<p> Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_n">n</code></td>
<td>
<p> Number of observations. If 'length(n) &gt; 1', the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_min">min</code></td>
<td>
<p>Vector of lower limits of distribution.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_max">max</code></td>
<td>
<p>Vector of upper limits of distribution.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_mode">mode</code></td>
<td>
<p>Vector of modes</p>
</td></tr>
<tr><td><code id="Triangular_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x]; otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="Triangular_+3A_log">log</code>, <code id="Triangular_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The triangular distribution has density 
</p>
<p style="text-align: center;"><code class="reqn">f(x)=2*(x-min) / ((max-min)*(mode-min))  (min &lt; x &lt;= mode)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(x)=2*(max-x) / ((max-min)*(max-mode))  (mode &lt; x &lt; max)</code>
</p>

<p>and 0 elsewhere.
</p>
<p>The mean is
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{3}(min + mode + max)</code>
</p>

<p>and the variance is
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{18}(min^2 + mode^2 + max^2 - min*mode - min*max - mode*max)</code>
</p>

<p>The default values of <code>min</code>, <code>max</code> and <code>mode</code> give a distribution with 
mean 0 and unit variance.
</p>
<p>If <code>min&gt;max</code>, <code>min</code> amd <code>max</code> will be silently interchanged. If 
mode is not within <code>[min, max]</code>, the functions return <code>NA</code>, with a warning.
</p>
<p><code>rtri</code> calls <code>runif(n, 0, 1)</code> to generate probabilities which are passed to 
<code>qtri</code>. 
</p>


<h3>Value</h3>

<p>A vector of densities, probabilities, quantiles or random deviates. 
<code>dtri</code> gives the density, <code>ptri</code> gives the distribution function, 
<code>qtri</code> gives the quantile function, and <code>rtri</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+runif">runif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     require(graphics)
     x&lt;-seq(-3,3,0.02)

     par(mfrow=c(2,1))
     plot(x, dtri(x), type="l", main="Density")
     plot(x, ptri(x), type="l", main="p(X&lt;x)")

     u &lt;- rtri(5000)

     var(rtri(10000,-1,1))  # ~ = 1/6 = 0.167

</code></pre>

<hr>
<h2 id='uncert'>
Uncertainty estimation functions
</h2><span id='topic+uncert'></span><span id='topic+uncert.default'></span><span id='topic+uncert.expression'></span><span id='topic+uncert.function'></span><span id='topic+uncert.formula'></span>

<h3>Description</h3>

<p>Functions for estimating measurement uncertainty from standard uncertainties
and either sensitivity coefficients or (for some methods) expressions or functions. 
Correlation is supported via either a correlation or covariance matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   uncert(obj, ...)

   ## Default S3 method:
uncert(obj, c, method = c("GUM", "MC"), cor, 
            cov, distrib=NULL, distrib.pars=NULL, B=200, x=NULL, keep.x = TRUE, 
            u=obj, ...)

   ## S3 method for class 'expression'
uncert(obj, x, u, method=c("GUM", "NUM", "kragten", "k2", "MC"), 
            cor, cov, distrib=NULL, distrib.pars=NULL, 
            B=200, delta=0.01, keep.x = TRUE, ...) 

   ## S3 method for class 'function'
uncert(obj, x, u, method=c("NUM", "kragten", "k2", "MC"), 
            cor, cov, distrib=NULL, distrib.pars=NULL, 
            B=200, delta=0.01, keep.x = TRUE, ...)

   ## S3 method for class 'formula'
uncert(obj, x, u, method=c("GUM", "NUM", "kragten", "k2", "MC"), 
            cor, cov, distrib=NULL, distrib.pars=NULL, 
            B=200, delta=0.01, keep.x = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncert_+3A_obj">obj</code></td>
<td>
<p>An R object used for method dispatch; see below. Methods currently exist for 
numeric vector, expression, function, or formula</p>
</td></tr>
<tr><td><code id="uncert_+3A_u">u</code></td>
<td>
<p>For the default method, a numeric vector of standard uncertainties. For 
the formula or expression methods, a named list of standard uncertainties.Note that 
for the default method, <code>u</code> is set to the value of <code>obj</code>, allowing 
specification of either as the <em>first</em> argument</p>
</td></tr>
<tr><td><code id="uncert_+3A_c">c</code></td>
<td>
<p>A numeric vector of senstivity coefficients.</p>
</td></tr>
<tr><td><code id="uncert_+3A_x">x</code></td>
<td>
<p>For the expression or formula methods, an R object which can be used 
as an environment by <code>eval</code>.  For the function method, a list of 
parameters supplied to FUN via <code>do.call</code>.</p>
</td></tr>
<tr><td><code id="uncert_+3A_method">method</code></td>
<td>
<p>Method of uncertainty evaluation. The current list of methods is:
</p>

<dl>
<dt>GUM</dt><dd><p>First-order error propagation (the &ldquo;law of propagation of uncertainty&rdquo;) 
as implemented by the GUM.</p>
</dd>
<dt>NUM</dt><dd><p>Numerical differentiation using a simple small step size.</p>
</dd>
<dt>kragten</dt><dd><p>Numerical estimation of uncertainty following Kragten (Kragten (1994).</p>
</dd>
<dt>k2</dt><dd><p>A symmetric modification of Kragten's approach described by Ellison (Ellison (2005)).</p>
</dd>
<dt>MC</dt><dd><p>Monte Carlo simulation.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="uncert_+3A_cor">cor</code>, <code id="uncert_+3A_cov">cov</code></td>
<td>
<p>A (square, symmetric) correlation or covariance matrix, respectively.
If neither is specified, <code>cor</code> is set to the identity matrix.</p>
</td></tr>
<tr><td><code id="uncert_+3A_distrib">distrib</code></td>
<td>
<p>For <code>method="MC"</code>, a character vector of length 
<code>length(x)</code> or a named list of names of distribution functions associated 
with <code>u</code>. See Details for defaults. The list format may include 
user-specified functions. Silently ignored for other methods.</p>
</td></tr>
<tr><td><code id="uncert_+3A_distrib.pars">distrib.pars</code></td>
<td>
<p>For <code>method="MC"</code>, a list of 
lists of parameters describing the distributions associated with <code>u</code>
to be passed to the relevant distribution function. If <code>distrib</code> is present
but <code>distrib.pars</code> is not, neither are included in the return value
unless <code>method="MC"</code>. See Details for defaults when <code>method="MC"</code>.
Silently ignored for other methods.</p>
</td></tr>
<tr><td><code id="uncert_+3A_b">B</code></td>
<td>
<p>Number of Monte Carlo replicates.</p>
</td></tr>
<tr><td><code id="uncert_+3A_delta">delta</code></td>
<td>
<p>Step size for numerical differentiation.</p>
</td></tr>
<tr><td><code id="uncert_+3A_keep.x">keep.x</code></td>
<td>
<p>For <code>method="MC"</code>, if <code>keepx=TRUE</code>, the simulated replicates of 
<code>x</code> are included in the return object.</p>
</td></tr>
<tr><td><code id="uncert_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to a function (for the function method)
or used in an expression (for expression or formula method).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default &ldquo;GUM&rdquo; method applies first-order error propagation principles to estimate 
a combined standard uncertainty from a set of sensitivity coefficients and <em>either</em> a 
set of standard uncertainties and a correlation matrix (which defaults to an identity matrix) 
<em>or</em> a covariance matrix. Both options use the same calculation, which is simply 
<code> (t(c) %*% cov) %*% c </code>; standard uncertainties are  first combined with 
the correlation matrix provided to form the covariance matrix. Since the correlation 
matrix defaults to the identity matrix, the default is combination without 
correlation.
</p>
<p>The default method takes <code>obj</code> as a vector of uncertainty contributions unless <code>u</code> 
is specified, in which case <code>u</code> is used. It is not necessary to specify both. 
The expression method requires <code>obj</code> to be a differentiable R expression which can 
be evaluated in the environment <code>x</code> to provide a numeric value.
For the function method, <code>obj</code> must be an R function which takes parameters from x and 
returns a numeric value.
For the formula method, <code>obj</code> must be a formula with no left-hand side (e.g. <code>~a*x+b*x^2</code>) 
which can be evaluated in the environment <code>x</code> to provide a numeric value.
</p>
<p>The formula and expression methods first calculate derivatives for the expression or formula, 
evaluate them using the supplied values of <code>x</code> and then pass the resulting sensitivity 
coefficients, with supplied <code>u</code>, <code>cor</code> or <code>cov</code> to uncert.default.
</p>
<p>The derivatives for the &ldquo;GUM&rdquo; method (formula and expression methods only) are algorithmic 
derivatives (that is, algebraic or analytical derivatives) obtained using <code>deriv</code> 
applied to <code>expr</code> and <code>formula</code>.  
</p>
<p>Numerical derivatives are computed in different ways depending on the method specified: 
</p>
<p>- For <code>method="NUM"</code>, the derivatives are calculated as 
<code class="reqn">(f(x+delta*u)-f(x-delta*u))/(2*delta*u)</code>.
</p>
<p>- For <code>method="kragten"</code>, derivatives are calculated as 
<code class="reqn">(f(x+u*sign(delta))-f(x))/u</code>.
</p>
<p>- For <code>method="k2"</code>, derivatives are calculated as 
<code class="reqn">(f(x+u)-f(x-u))/(2*u)</code>.
</p>
<p><code>"NUM"</code> is likely to give a close approximation to analytical differentiation provided that 
<code>delta</code> is appreciably less than 1 but not so small as to give step sizes near machine 
precision. <code>"k2"</code> is equivalent to <code>"NUM"</code> with <code>delta=1.0</code>. Both will give zero coefficients
at stationary points (e.g minima), leading to under-estimation of uncertainty if 
the curvature is large. <code>"kragten"</code> uses a <em>deliberately</em> one-sided (and large) step to 
avoid this problem; as a result, <code>"kragten"</code> is a poorer (sometimes much poorer) estimate of
the analytical differential but likely a better approximation to the truth.
</p>
<p>Since these methods rely on <code>u</code>, if <code>u</code> is unspecified and <code>cov</code> is 
provided, <code>u</code> is extracted from <code>cov</code> (using <code>sqrt(diag(cov))</code>). It is
assumed that the row and column order in <code>cov</code> is identical to the order of named 
parameters in <code>x</code>.
</p>
<p>Derivatives (and uncertainty contributions) are computed for all parameters in 
<code>x</code>. Additional parameters used in <code>FUN</code>, <code>expr</code> or <code>formula</code>
may be included in <code>...</code>; these will be treated as constants in the 
uncertainty calculation. 
</p>
<p>If <code>distrib</code> is missing, or if it is a list with some members missing, the distribution 
is assumed Normal and <code>distrib$name</code> is set to <code>"norm"</code>. Similarly, if <code>distrib.pars</code>
or a member of it is missing, the default parameters for <code>x$name</code> are 
<code>list(mean=x$name, sd=u$name)</code>. If the list is not named, <code>names(x)</code> are used 
(so the list must be in order of <code>names(x)</code>).
</p>
<p>If <code>method="MC"</code>, <code>uncert</code> calls <code>uncertMC</code>. Distributions and 
distribution parameters are required and B must be present and &gt;1. See <code><a href="#topic+uncertMC">uncertMC</a></code>
for details of distribution specification. 
</p>
<p>For other evaluation methods, the distributions are silently ignored.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;uncert&rsquo; or, for <code>method="MC"</code> of class &lsquo;uncertMC&rsquo;. 
See <code><a href="#topic+uncert-class">uncert-class</a></code> and <code><a href="#topic+uncertMC-class">uncertMC-class</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>JCGM 100 (2008) <em>Evaluation of measurement data - Guide to the expression
of uncertainty in measurement</em>. <a href="http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf">http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf</a>. 
(JCGM 100:2008 is a public domain copy of ISO/IEC <em>Guide to the expression
of uncertainty in measurement</em> (1995) ). 
</p>
<p>Kragten, J. (1994) Calculating standard deviations and confidence intervals with 
a universally applicable spreadsheet technique, Analyst, <b>119</b>, 2161-2166.
</p>
<p>Ellison, S. L. R. (2005) Including correlation effects in an improved spreadsheet 
calculation of combined standard uncertainties, Accred. Qual. Assur. <b>10</b>, 338-343.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncert-class">uncert-class</a></code>,  <code><a href="stats.html#topic+deriv">deriv</a></code>
</p>
<p>For <code>method="MC"</code> see <code><a href="#topic+uncertMC">uncertMC</a></code> and <code><a href="#topic+uncertMC-class">uncertMC-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  expr &lt;- expression(a+b*2+c*3+d/2)
  x &lt;- list(a=1, b=3, c=2, d=11)
  u &lt;- lapply(x, function(x) x/10)
  u.expr&lt;-uncert(expr, x, u, method="NUM")
  u.expr

  #Compare with default:
  uncert(u=c(0.1, 0.3, 0.2, 1.1), c=c(1.0, 2.0, 3.0, 0.5))
  
  #... or with function method
  f &lt;- function(a,b,c,d) a+b*2+c*3+d/2
  u.fun&lt;-uncert(f, x, u, method="NUM")
  u.fun

  #.. or with the formula method
  u.form&lt;-uncert(~a+b*2+c*3+d/2, x, u, method="NUM")
  u.form
  
  #An example with correlation
  u.cor&lt;-diag(1,4)
  u.cor[3,4]&lt;-u.cor[4,3]&lt;-0.5
  u.formc&lt;-uncert(~a+b*2+c*3+d/2, x, u, method="NUM", cor=u.cor)
  u.formc
  
  #A Monte Carlo example
  #See uncertMC for a less linear example
  u.formc.MC&lt;-uncert(~a+b*2+c*3+d/2, x, u, method="MC", cor=u.cor, B=200)
  u.formc.MC
</code></pre>

<hr>
<h2 id='uncert-class'>
The 'uncert' class
</h2><span id='topic+print.uncert'></span><span id='topic+summary.uncert'></span><span id='topic+uncert-class'></span>

<h3>Description</h3>

<p>Object returned by <code>uncert</code> calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'uncert'
print(x, digits=NULL, right=FALSE, ..., simplify=TRUE)

   ## S3 method for class 'uncert'
summary(object, ..., simplify=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncert-class_+3A_x">x</code>, <code id="uncert-class_+3A_object">object</code></td>
<td>
<p>An object of class uncert</p>
</td></tr>
<tr><td><code id="uncert-class_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display in budget and (if present) distribution parameter lists.
Passed to <code>format</code> for distribution parameter list and to <code>print.data.frame</code> 
for output.</p>
</td></tr>
<tr><td><code id="uncert-class_+3A_right">right</code></td>
<td>
<p>If TRUE, strings in uncertainty budget are right-justified. 
This differs from the default in <code>print.data.frame</code>.</p>
</td></tr>
<tr><td><code id="uncert-class_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>print.data.frame</code></p>
</td></tr>
<tr><td><code id="uncert-class_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, only the call, evaluation method, budget, value <code>y</code> 
and combined uncertainty (u.y) are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.uncert</code> simply calls <code>print.uncert</code>.
</p>
<p>An object of class &quot;uncert&quot; contains:
</p>

<dl>
<dt>call</dt><dd><p>The matched call</p>
</dd>
<dt>y</dt><dd><p>The calculated value (for function, expression or formula methods) or NA</p>
</dd>
<dt>u.y</dt><dd><p>The combined standard uncertainty</p>
</dd>
<dt>method</dt><dd><p>The uncertainty evaluation method used.</p>
</dd>
<dt>budget</dt><dd><p>A data frame consisting of:
</p>

<dl>
<dt>x</dt><dd><p><code>x</code> (if supplied; otherwise a vector of NA's).</p>
</dd>
<dt>u</dt><dd><p>The standard uncertainties in input quantities (originally provided as <code>u</code>)</p>
</dd>
<dt>df</dt><dd><p>The degrees of freedom asscociated with <code>u</code></p>
</dd>
<dt>c</dt><dd><p>Sensitivity coefficients either provided as <code>c</code> or (for the formula, function 
and expression methods) as calculated.</p>
</dd>
<dt>u.c</dt><dd><p>The product of <code>u</code> and <code>c</code>. These are the contributions to the 
combined uncertainty for uncorrelated quantities.</p>
</dd>
</dl>

</dd>
<dt>additional</dt><dd><p>Any relevant parameters other than those in $budget$x (typically addditional 
constants passed to function or expression methods)</p>
</dd>
<dt>distrib</dt><dd><p>If available, a named list of the distributions associated with <code>u</code>. 
The list contains either root nams of distribution functions (e.g <code>"norm"</code> or
function definitions.</p>
</dd>
<dt>distrib.pars</dt><dd><p>If available, a list of lists of parameters describing the 
distributions associated with <code>u</code>.</p>
</dd>
<dt>cov</dt><dd><p>The covariance matrix used</p>
</dd>
<dt>cor</dt><dd><p>The correlation matrix used</p>
</dd>
<dt>cov.xy</dt><dd><p>A data frame of covariances between x and y. Row names correspond
to the correlation method used. For all uncertainty evaluation methods but MC,
the only correlation calculation is &quot;theoretical&quot;; for MC row names include
all methods supported by stats::cor at the time the object was created.</p>
</dd>
<dt>cor.xy</dt><dd><p>A data frame of correlations between x and y, of the same form as <code>cov.xy</code></p>
</dd>
<dt>deriv</dt><dd><p>For the formula and expression methods, the result of a call to <code>deriv</code>; 
an expression which evaluates to the value with attributes corresponding to the derivatives 
(that is, an expression which can be evaluated to give the value and sensitivity coefficients)</p>
</dd>
</dl>
     


<h3>Value</h3>

<p><code>print</code> and <code>summary</code> methods invisibly return the original object.
</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p>The print method provides a formatted printout of the object. By default,
<code>simplify=TRUE</code>; this displays a shortened listing. Columns in <code>$budget</code> are 
suppressed if all NA (typically df when not specified).</p>
</dd>
<dt>summary</dt><dd><p>summary is currently an alias for the print method.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncert">uncert</a></code>, especially for calculation methods; 
<code><a href="#topic+plot.uncert">plot.uncert</a></code>, <code><a href="#topic+uncertMC-class">uncertMC-class</a></code>,
<code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>, <code><a href="base.html#topic+format">format</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  expr &lt;- expression(a+b*2+c*3+d/2)
  x &lt;- list(a=1, b=3, c=2, d=11)
  u &lt;- lapply(x, function(x) x/10)
  u.expr&lt;-uncert(expr, x, u, method="NUM")
  print(u.expr)

</code></pre>

<hr>
<h2 id='uncertMC'>
Monte Carlo evaluation of measurement uncertainty.
</h2><span id='topic+uncertMC'></span>

<h3>Description</h3>

<p><code>uncertMC</code> estimates measurement uncertainty from a function,
expression or formula by Monte Carlo simulation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncertMC(expr, x, u, method = "MC", df, cor, cov, distrib, distrib.pars, 
   B = 200, keep.x = TRUE, vectorized=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncertMC_+3A_expr">expr</code></td>
<td>
<p>An expression, function, or formula with no left-hand side (e.g. 
<code>~a*x+b*x^2</code>) which can be evaluated in the environment <code>x</code> to
provide a numeric value.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_x">x</code></td>
<td>
<p>A named list or vector of parameters supplied to <code>expr</code>.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_u">u</code></td>
<td>
<p>A named list or named vector of length <code>length(x)</code> of standard uncertainties.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_method">method</code></td>
<td>
<p>Method of uncertainty evaluation. The only method currently supported
by <code>uncertMC</code> is <code>"MC"</code>. If any other method is specified, control is 
passed to <code>uncert</code>.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_df">df</code></td>
<td>
<p>A named list or named vector of degrees of freedom. <code>df</code> can be
a partial named list if not all distributions (see below) use degrees of 
freedom.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_cor">cor</code>, <code id="uncertMC_+3A_cov">cov</code></td>
<td>
<p>Optional (square, symmetric) correlation or covariance matrices, respectively.
If neither is specified, <code>uncertMC</code> assumes independent variables.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_distrib">distrib</code></td>
<td>
<p>A character vector of length <code>length(x)</code> or a named list 
of names of distribution functions associated with <code>u</code>. See Details
for defaults. 
</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_distrib.pars">distrib.pars</code></td>
<td>
<p>A named list of lists of parameters describing the distributions 
associated with <code>u</code> to be passed to the relevant distribution function.
If <code>distrib</code> is present but <code>distrib.pars</code> is not, an attempt is made 
to set defaults based on other parameters; see Details.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_b">B</code></td>
<td>
<p>Number of Monte Carlo replicates.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_keep.x">keep.x</code></td>
<td>
<p>If <code>TRUE</code>, the simulated replicates of <code>x</code> are included in 
the return object.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_vectorized">vectorized</code></td>
<td>
<p>If <code>TRUE</code>, <code>expr</code> is assumed to take vector arguments. If <code>FALSE</code>, 
<code>expr</code> is treated as if it takes scalar arguments. See Details for the difference.</p>
</td></tr>
<tr><td><code id="uncertMC_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to a function (for the function method)
or used in an expression (for expression or formula method).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although most likely to be called by <code>uncert</code>, <code>uncertMC</code> may be called directly.
</p>
<p>If any of <code>x</code>, <code>u</code>, <code>df</code>, <code>distrib</code> or <code>distrib.pars</code> are not lists,
they are coerced to lists. If <code>x</code> is not named, arbitrary names of the form 'Xn' 
are applied. If <code>u</code>, <code>df</code>, <code>distrib</code> or <code>distrib.pars</code> do not have
names, the names will be set to <code>names(x)</code> if they are of length exactly 
<code>length(x)</code>; if not, an error is returned.
</p>
<p>For Monte Carlo evaluation, distributions and distribution parameters are needed but 
defaults are used if some or all are absent. If <code>distrib</code> is missing, or 
if it is a list with some members missing, the distribution is assumed Normal
and any missing member of <code>distrib</code> is set to &quot;norm&quot;. 
</p>
<p>Distributions are usually identified by the root of the distribution function name; for example 
to specify the Normal, <code>distrib$name="norm"</code>. At present, only the random value 
generator (e.g. <code>rnorm</code>) is used. Names of user-specified distributions functions can also be 
used, provided they have a random value generator named <code>r&lt;dist&gt;</code> where <code>&lt;dist&gt;</code>
is the abbreviated distribution. Parameters are passed to distribution functions using 
<code>do.call</code>, so the function must accept the parameters supplied in <code>distrib.pars</code>.


</p>
<p>If <code>distrib.pars</code> or members of it are missing, an attempt is made to deduce 
appropriate distribution parameters from <code>x</code>, <code>u</code>, <code>df</code> and <code>distrib</code>. 
In doing so, the following assumptions and values apply for the respective distributions:
</p>

<dl>
<dt>norm</dt><dd><p><code>mean=x$name, sd=u$name</code>.</p>
</dd>
<dt>unif</dt><dd><p><code>min=x-sqrt(3)*u, max=x+sqrt(3)*u</code>.</p>
</dd>
<dt>tri</dt><dd><p><code>min=x-sqrt(6)*u, max=x+sqrt(6)*u, mode=x</code>.</p>
</dd>
<dt>t, t.scaled</dt><dd><p><code>df=df, mean=x, sd=u</code>.</p>
</dd>
</dl>

<p>If either <code>cor</code> or <code>cov</code> are present, a test is made to see if off-diagonal
elements are significant. If not, <code>uncertMC</code> treats the values as independent.
The test simply checks whether the sum of off-diagonal elements of <code>cor</code> (calculated 
from <code>cov</code> if <code>cov</code> is present) is bigger than 
<code>.Machine.double.eps*nrow^2</code>.
</p>
<p>Correlation is supported as long as all correlated variables are normally distributed.
If correlation is present, <code>uncertMC</code> follows a two-stage simulation procedure. 
First, variables showing correlation are identified. Following a check that 
their associated <code>distrib</code> values are all <code>"norm"</code>, <code>mvrnorm</code> from 
the MASS library is called to generate the simulated <code>x</code> values for those variables.
Second, any remaining (i.e. independent) variables are simulated from their respective 
<code>distrib</code> and <code>distrib.pars</code>. 
</p>
<p>Vectorisation makes a difference to execution speed. If <code>vectorize=TRUE</code>, MC evaluation 
uses <code>eval</code> using the simulated data as the evaluation environment; if not, <code>apply</code>
is used row-wise on the simulated input matrix. This makes an appreciable difference to 
execution speed (typically <code>eval</code> is faster by a factor of 5 or more) so the default 
assumes vectorised expressions. However, not all functions and expressions take vector arguments, 
especially user functions involving complicated arithmetic or numerical solutions. Use <code>vectorize=FALSE</code>
for functions or expressions that do not take vector arguments. 
Note: One common symptom of an expression that does not take vector arguments is
an R warning indicating that only the first element (typically of a parameter in <code>x</code>) is used. 
uncertMC may also return NA for <code>u</code> on attempting to take the sd of a single simulated point.
</p>


<h3>Value</h3>

<p>An object of class <code>uncertMC</code>. See <code><a href="#topic+uncertMC-class">uncertMC-class</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>JCGM 100 (2008) <em>Evaluation of measurement data - Guide to the expression
of uncertainty in measurement</em>. <a href="http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf">http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf</a>. 
(JCGM 100:2008 is a public domain copy of ISO/IEC <em>Guide to the expression
of uncertainty in measurement</em> (1995) ). 
</p>
<p>Kragten, J. (1994) Calculating standard deviations and confidence intervals with 
a universally applicable spreadsheet technique, Analyst, <b>119</b>, 2161-2166.
</p>
<p>Ellison, S. L. R. (2005) Including correlation effects in an improved spreadsheet 
calculation of combined standard uncertainties, Accred. Qual. Assur. <b>10</b>, 338-343.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncert">uncert</a></code>,  <code><a href="#topic+uncert-class">uncert-class</a></code>,   <code><a href="#topic+uncertMC-class">uncertMC-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  expr &lt;- expression(a+b*2+c*3+d/2)
  x &lt;- list(a=1, b=3, c=2, d=11)
  u &lt;- lapply(x, function(x) x/10)
  u.MC&lt;-uncertMC(expr, x, u, distrib=rep("norm", 4), method="MC")
  print(u.MC, simplify=FALSE)

  #An example with correlation
  u.cor&lt;-diag(1,4)
  u.cor[3,4]&lt;-u.cor[4,3]&lt;-0.5
  u.formc.MC&lt;-uncertMC(~a+b*2+c*3+d/2, x, u, cor=u.cor, keep.x=TRUE)
  u.formc.MC

  #A non-linear example
  expr &lt;- expression(a/(b-c))
  x &lt;- list(a=1, b=3, c=2)
  u &lt;- lapply(x, function(x) x/20)
  set.seed(403)
  u.invexpr&lt;-uncertMC(expr, x, u, distrib=rep("norm", 3), B=999, keep.x=TRUE )
  u.invexpr

  #Look at effect of vectorize
  system.time(uncertMC(expr, x, u, distrib=rep("norm", 3), B=9999, keep.x=TRUE ))
  system.time(uncertMC(expr, x, u, distrib=rep("norm", 3), B=9999, keep.x=TRUE, vectorize=FALSE))
  
</code></pre>

<hr>
<h2 id='uncertMC-class'>
The 'uncertMC' class
</h2><span id='topic+uncertMC-class'></span><span id='topic+print.uncertMC'></span><span id='topic+summary.uncertMC'></span>

<h3>Description</h3>

<p>Object returned by <code>uncertMC</code> calls and by <code>uncertainty</code> with <code>method="MC"</code>.
</p>
<p><code>summary.uncertMC</code> is currently an alias for <code>print.uncertMC</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'uncertMC'
print(x, digits=NULL, right=FALSE, 
                      ..., simplify=TRUE, minimise=FALSE)

   ## S3 method for class 'uncertMC'
summary(object, digits=NULL, right=FALSE, 
                      ..., simplify=TRUE, minimise=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncertMC-class_+3A_x">x</code>, <code id="uncertMC-class_+3A_object">object</code></td>
<td>
<p>An object of class <code>"uncertMC"</code></p>
</td></tr>
<tr><td><code id="uncertMC-class_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display in budget and (if present) distribution parameter lists.
Passed to <code>format</code> for distribution parameter list and to <code>print.data.frame</code> 
for output.</p>
</td></tr>
<tr><td><code id="uncertMC-class_+3A_right">right</code></td>
<td>
<p>If TRUE, strings in uncertainty budget are right-justified. 
This differs from the default in <code>print.data.frame</code>.</p>
</td></tr>
<tr><td><code id="uncertMC-class_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>print.data.frame</code></p>
</td></tr>
<tr><td><code id="uncertMC-class_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, only the call, evaluation method, budget, value <code>y</code> 
and combined uncertainty (u.y) are printed.</p>
</td></tr>
<tr><td><code id="uncertMC-class_+3A_minimise">minimise</code></td>
<td>
<p>If <code>TRUE</code>, the header, call, <code>expr</code> and evaluation method 
are suppressed; this is the mode used when printing an <code>uncertMC</code> object as part of an 
<code>uncert</code> object.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>An object of class &quot;uncertMC&quot; inherits from class &quot;uncert&quot;. In addition to the 
contents of the &quot;uncert&quot; object, it contains the results from the MC replication as 
a list MC. The complete description is:
</p>

<dl>
<dt>call</dt><dd><p>The matched call</p>
</dd>
<dt>expr</dt><dd><p>The expression, formula or function supplied to <code>uncertMC</code>.</p>
</dd>
<dt>method</dt><dd><p>The uncertainty evaluation method used (always 'MC').</p>
</dd>
<dt>B</dt><dd><p>The number of Monte Carlo replicates used.</p>
</dd>
<dt>budget</dt><dd><p>A data frame consisting of:
</p>

<dl>
<dt>x</dt><dd><p>The starting values <code>x</code>.</p>
</dd>
<dt>u</dt><dd><p>The standard uncertainties in input quantities (originally provided as <code>u</code>)</p>
</dd>
<dt>df</dt><dd><p>The degrees of freedom asscociated with <code>u</code></p>
</dd>
<dt>c</dt><dd><p>Sensitivity coefficients estimated from the MC output (see <code><a href="#topic+uncertMC">uncertMC</a></code> 
for how this is done).</p>
</dd>
</dl>

</dd>
<dt>distrib</dt><dd><p>If available, a named list of the distributions associated with <code>u</code>. 
The list contains either root nams of distribution functions (e.g <code>"norm"</code> or
function definitions.</p>
</dd>
<dt>distrib.pars</dt><dd><p>If available, a list of lists of parameters describing the 
distributions associated with <code>u</code>.</p>
</dd>
<dt>additional</dt><dd><p>If supplied, any relevant parameters other than those in <code>$budget$x</code> 
(typically addditional constants passed to function or expression methods)</p>
</dd>
<dt>cov</dt><dd><p>The covariance matrix used</p>
</dd>
<dt>cor</dt><dd><p>The correlation matrix used</p>
</dd>
<dt>cov.xy</dt><dd><p>A data frame of covariances between x and y. The Row names correspond
to the correlation method used. For <code>uncertMC</code> objects only
<code>"pearson"</code> is currently supported (because <code>"kendall"</code> and <code>"spearman"</code>
take a very long time to compute)</p>
</dd>
<dt>cor.xy</dt><dd><p>A data frame of correlations between x and y, of the same form as <code>cov.xy</code></p>
</dd>
<dt>MC</dt><dd>
<p>A list containing:
</p>

<dl>
<dt>seed</dt><dd><p>The value of <code>.Random.seed</code> when <code>uncertMC</code> was called.</p>
</dd>
<dt>y</dt><dd><p>The <code>B</code> Monte Carlo replicates of the standard uncertainty 
calculated as <code>sd(y)</code>.</p>
</dd>
<dt>x.mc</dt><dd><p>If <code>uncertMC</code> is called with <code>keep.x=TRUE</code>, a data frame 
whose columns are the Monte Carlo replicates of the variables in <code>x</code>.</p>
</dd>
</dl>

</dd>
</dl>
     


<h3>Value</h3>

<p><code>print</code> and <code>summary</code> methods invisibly return the original object.
</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p>The print method provides a formatted printout of the object. By default,
<code>simplify=TRUE</code>; this displays a shortened listing. Columns in <code>$data</code> are 
suppressed if all NA.</p>
</dd>
<dt>summary</dt><dd><p>summary is currently an alias for the print method.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncert">uncert</a></code>, <code><a href="#topic+uncertMC">uncertMC</a></code>, <code><a href="#topic+uncert-class">uncert-class</a></code>, 
<code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>, <code><a href="base.html#topic+format">format</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  set.seed(13*17)
  expr &lt;- expression(a+b*2+c*3+d/2)
  x &lt;- list(a=1, b=3, c=2, d=11)
  u &lt;- lapply(x, function(x) x/10)
  u.expr&lt;-uncertMC(expr, x, u, distrib=rep("norm", 4), method="MC")
  print(u.expr)

</code></pre>

<hr>
<h2 id='update.uncert'>
Update and recalculate an uncertainty estimate
</h2><span id='topic+update.uncert'></span>

<h3>Description</h3>

<p>&lsquo;update&rsquo; allows modification of components of &lsquo;uncert&rsquo; or &lsquo;uncertMC&rsquo; objects, 
including the uncertainty estimation method used, and will recalculate the estimate and return a new
&lsquo;uncert&rsquo; or &lsquo;uncertMC&rsquo; object.  Individual elements of most components can be amended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uncert'
update(object, expr = NULL, method = NULL, x = NULL, u = NULL, c=NULL, 
		df = NULL, cov = NULL, cor = NULL, distrib = NULL, 
		distrib.pars = NULL, delta = NULL, B = NULL, keep.x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.uncert_+3A_object">object</code></td>
<td>

<p>An object of class &lsquo;uncert&rsquo;</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_expr">expr</code></td>
<td>
<p>An expression, formula or function.</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_method">method</code></td>
<td>

<p>Uncertainty evaluation method. May be any of the methods listed for <code><a href="#topic+uncert">uncert</a></code>. 
</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_x">x</code>, <code id="update.uncert_+3A_u">u</code>, <code id="update.uncert_+3A_df">df</code></td>
<td>
<p>Named list, vector or array of values to update elements of 
object <code>uncert</code>. See Details for options.
</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_c">c</code></td>
<td>
<p>Update to <code>uncert$budget$c</code> No effect except for updates using <code>uncert.default</code>.
</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_cov">cov</code>, <code id="update.uncert_+3A_cor">cor</code></td>
<td>
<p>A covariance or correlation matrix. Only one of <code>u</code> and <code>cov</code> 
should be specified; if both are specified, <code>cov</code> will take precedence and a warning will be issued.</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_distrib">distrib</code></td>
<td>
<p>Named list or character vector of updated distribution names.</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_distrib.pars">distrib.pars</code></td>
<td>
<p>Named list of updates for distribution names and parameters.</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_delta">delta</code></td>
<td>
<p>Scalar value updating <code>delta</code> for numeric evaluation methods.</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_b">B</code></td>
<td>
<p>Updated number of Monte Carlo iterations for &lsquo;uncertMC&rsquo; objects or specification of
<code>B</code> when updating &lsquo;uncertMC&rsquo; objects using <code>method="MC"</code>.
</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_keep.x">keep.x</code></td>
<td>
<p>Update to <code>keep.x</code> passed to <code>uncertMC</code> for Monte Carlo updates.</p>
</td></tr>
<tr><td><code id="update.uncert_+3A_...">...</code></td>
<td>
<p>Other values passed to <code>uncert</code> or <code>uncertMC</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Update will use the values provided to update the object given, call the original function 
with the revised parameters and return the result as an object of class &lsquo;uncert&rsquo; 
or &lsquo;uncert&rsquo; depending on the uncertainty evaluation method used. 
</p>
<p>Note that updating with a different value of <code>method</code> may result in an object of 
different class. Updating an &lsquo;uncertMC&rsquo; object with a method other than <code>"MC"</code> 
will return an object of class &lsquo;uncert&rsquo;; similarly, updating an &lsquo;uncert&rsquo; object 
using <code>method="MC"</code> will return an object of class &lsquo;uncertMC&rsquo;.
</p>
<p>Updates to vector or list elements of <code>uncert</code> such as <code>x</code>, <code>u</code>, <code>df</code> 
etc. can be specified as named lists, named vectors or arrays, with names corresponding to 
names of the input quantities in the uncertainty budget (that is, the names may correspond
to one or more of <code>row.names(uncert$budget)</code>). If names are present, only the 
corresponding individual members are updated.
If names are not present, the complete vector or list in <code>uncert</code> is replaced, and names added.
</p>
<p>Matrix elements <code>cor</code> and <code>cov</code> must be specified completely; see
<code><a href="#topic+buildCor">buildCor</a></code>, <code><a href="#topic+updateCor">updateCor</a></code> and associated functions for
covariance matrices for compact update methods.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;uncert&rsquo; or, for <code>method="MC"</code> of class &lsquo;uncertMC&rsquo;. 
See <code><a href="#topic+uncert-class">uncert-class</a></code> and <code><a href="#topic+uncertMC-class">uncertMC-class</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, yet.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncert-class">uncert-class</a></code>,  <code><a href="#topic+uncert-class">uncert-class</a></code>, <code><a href="#topic+uncertMC">uncertMC</a></code>, <code><a href="#topic+uncertMC-class">uncertMC-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #From uncert:
  expr &lt;- expression(a+b*2+c*3+d/2)
  x &lt;- list(a=1, b=3, c=2, d=11)
  u &lt;- lapply(x, function(x) x/10)
  u.expr&lt;-uncert(expr, x, u, method="NUM")
  u.expr

  update(u.expr, u=list(a=0.3))
  
  update(u.expr, method="MC")
  
</code></pre>

<hr>
<h2 id='vr.mle'>
Vangel-Rukhin Maximum Likelihood Estimate
</h2><span id='topic+vr.mle'></span><span id='topic+print.summary.vr.mle'></span>

<h3>Description</h3>

<p>Calculate a weighted mean, between-group standard deviation and
standard error on the weighted mean using the Maximum likelihood 
algorithm of Vangel-Rukhin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vr.mle(x, s2, n, init.mu = mean(x), init.sigma2 = var(x), labels = c(1:length(x)), 
       max.iter = 1000, tol = .Machine$double.eps^0.5, trace = FALSE)

## S3 method for class 'summary.vr.mle'
print(x, ..., digits=3) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vr.mle_+3A_x">x</code></td>
<td>

<p>numeric vector of the sample mean values of each group
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_s2">s2</code></td>
<td>

<p>numeric vector of the sample variances of each group
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_n">n</code></td>
<td>

<p>integer vector of sample size of each group
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_init.mu">init.mu</code></td>
<td>

<p>numeric initial value for the mean
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_init.sigma2">init.sigma2</code></td>
<td>

<p>numeric initial value for the between-group component of variance
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_labels">labels</code></td>
<td>

<p>vector of group names. Coerced to character on use.
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_max.iter">max.iter</code></td>
<td>

<p>numeric maximum number of iterations
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_tol">tol</code></td>
<td>

<p>numeric tolerance; iteration stops when the relative step size drops 
below 'tol'
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_trace">trace</code></td>
<td>

<p>when TRUE shows the sequence of intermediate results
</p>
</td></tr>
<tr><td><code id="vr.mle_+3A_...">...</code>, <code id="vr.mle_+3A_digits">digits</code></td>
<td>

<p>Passed to <code>format</code> to control printed output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Vangel-Rukhin MLE algorithm finds the between-method variance by
iteratively solving the equation relating the weighted mean to the
weighting factor applied. The weighting factor is the inverse of
the sum of the standard error in 'x' and the between-method
variance, scaled by the between-method variance.
</p>
<p>For the default method, 's2'  is interpreted as a vector of
sample variances. 'x' is interpreted as a vector of sample means
and the algorithm is applied to the corresponding group means,
variances, and sample sizes.
</p>
<p>The Vangel-Rukhin MLE algorithm shows an improvement in the number
of iterations required to converge over the classical MLE based on
the Score equations.
</p>
<p>The function mle.1wre implements the MLE for the one way random effects 
based on the Fisher scoring equations and is provided for comparison 
purpose only.
</p>


<h3>Value</h3>

<p><code>vr.mle</code> returns an object of class &quot;summary.vr.mle&quot; which contains
the following fields: 
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>the estimated mean
</p>
</td></tr>
<tr><td><code>var.mu</code></td>
<td>
<p>the variance associated with the estimated mean
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>the estimated between variance component
</p>
</td></tr>
<tr><td><code>llh</code></td>
<td>
<p>the log likelihood of the estimates
</p>
</td></tr>
<tr><td><code>tot.iter</code></td>
<td>
<p>the total number of iterations ran
</p>
</td></tr>
<tr><td><code>cur.rel.abs.error</code></td>
<td>
<p>the current relative absolute error reached
</p>
</td></tr>
<tr><td><code>gammai</code></td>
<td>
<p>a vector with the estimates of the weights
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>TRUE is convergence criteria was met, FALSE otherwise
</p>
</td></tr>
<tr><td><code>reduced.model</code></td>
<td>
<p>TRUE implies that a reduced model, with no
between-group effect, is suggested, based on <code>sigma2==0</code>;
FALSE indicates <code>sigma2 &gt; 0</code>. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>H. Gasca-Aragon
</p>


<h3>References</h3>

<p>Vangel, M. G. and Rukhin, A. L. (1999), Biometrics, Vol 55, No. 1 pp 129-136
</p>
<p>Searle, S. R., Cassella, G., and McCulloch, C. E. (1992). Variance Components. New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle.1wre">mle.1wre</a></code>, , <code><a href="#topic+loc.est-class">loc.est-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     ##===================================================================
     ## the dietary fiber in apples example in the Vangel and Rukhin paper
     ##===================================================================

     m1 &lt;- c(12.46, 13.035, 12.44, 12.87, 13.42, 12.08, 13.18, 14.335, 12.23)
     s1 &lt;- c(0.028, 0.233, 0.325, 0.071, 0.339, 0.325, 0.099, 0.064, 0.212)
     n1 &lt;- c(2, 2, 2, 2, 2, 2, 2, 2, 2)

     res&lt;- vr.mle(m1, s1^2, n1, tol=1e-6)

     res$mu
     sqrt(res$var.mu)
     res$sigma2
     res$mu+c(-1,1)*qnorm(0.975)*sqrt(res$var.mu)
     res$tot.iter
     res$converged
     res$reduced.model

     # output
     # 12.90585
     # 0.2234490
     # 0.4262122
     # 12.46790 13.34380
     # 6
     # converged = TRUE
     # reduced.model = FALSE
 
</code></pre>

<hr>
<h2 id='welch.satterthwaite'>
Welch-Satterthwaite effective degrees of freedom</h2><span id='topic+w.s'></span><span id='topic+welch.satterthwaite'></span>

<h3>Description</h3>

<p>Provides the Welch-Satterthwaite effective degrees of freedom given standard 
uncertainties and associated degrees of freedom.
</p>
<p>w.s is an alias for welch.satterthwaite. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w.s(ui, df, ci = rep(1, length(ui)), uc=sqrt(sum((ci*ui)^2)))

welch.satterthwaite(ui, df, ci = rep(1, length(ui)), 
                       uc=sqrt(sum((ci*ui)^2)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="welch.satterthwaite_+3A_ui">ui</code></td>
<td>
<p>Standard uncertainties</p>
</td></tr>
<tr><td><code id="welch.satterthwaite_+3A_df">df</code></td>
<td>
<p>Degrees of freedom</p>
</td></tr>
<tr><td><code id="welch.satterthwaite_+3A_ci">ci</code></td>
<td>
<p>Sensitivity coefficients <code class="reqn">dy/dx_i</code></p>
</td></tr>
<tr><td><code id="welch.satterthwaite_+3A_uc">uc</code></td>
<td>
<p>Combined standard uncertainty</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the Welch-Satterthwaite equation as provided in the ISO Guide to the expression of
uncertainty in measurement (1995) (See JCGM 100:2008). This assumes that <code>uc</code> is the 
uncertainty in a measurement result <code class="reqn">y</code>, where <code class="reqn">y=f(x_1, x_2, \dots)</code>, <code>ci</code> are 
the partial derivatives <code class="reqn">\partial y/\partial x_i</code> and <code>ui</code> is the standard uncertainty associated with <code>xi</code>.
</p>
<p>The implementation assumes that the combined uncertainty <code>uc</code> is equal to
<code>sqrt(sum((ci*ui)^2)</code>. An independent estimate of <code>uc</code> can be provided.
</p>
<p>The <code>ci</code> are 'sensitivity coefficients'; the default is 1, so that the <code>ui</code>
can be given either as standard uncertainties in the values of influence quantities <code class="reqn">x_i</code>, 
together with the associated <code>ci</code>, or as contributions <code>ci*ui</code> to the uncertainty in <code class="reqn">y</code>.
</p>
<p>Correlation is not supported, because the Welch-Satterthwaite equation is only valid 
for independent variances.
</p>


<h3>Value</h3>

<p>The calculated effective degrees of freedom associated with <code>uc</code>.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>JCGM 100 (2008) <em>Evaluation of measurement data - Guide to the expression
of uncertainty in measurement</em>. <a href="http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf">http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf</a>. 
(JCGM 100:2008 is a public domain copy of ISO/IEC <em>Guide to the expression
of uncertainty in measurement</em> (1995) ). 
</p>
<p>Satterthwaite, F. E. (1946), An Approximate Distribution of Estimates of Variance Components., 
Biometrics Bulletin <b>2</b>, 110-114, doi:10.2307/3002019 
</p>
<p>Welch, B. L. (1947), The generalization of &quot;Student's&quot; problem when several different 
population variances are involved., Biometrika <b>34</b> 28-35
</p>


<h3>See Also</h3>

<p>None, yet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- c(0.1, 0.3, 0.2, 1.1)
ci &lt;- c(1.0, 2.0, 3.0, 0.5)
degfree &lt;- c(Inf,6,8,3)

w.s(ui=u,df=degfree, ci=ci)

</code></pre>

<hr>
<h2 id='xs.plot'>
Mean/Standard deviation plot with confidence region. 
</h2><span id='topic+xs.plot'></span><span id='topic+xs.plot.default'></span><span id='topic+XSplot'></span>

<h3>Description</h3>

<p>Produces a plot of standard deviations versus means with a confidence region
based on either robust or classical estimates of location and scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
xs.plot(x, ...)

## Default S3 method:
xs.plot(x,g,s, degfree, labels.arg=NA, mu, sigma, 
        probs=c(0.5, 0.95, 0.99), basis=c("robust","classical"), 
        method=c("chisq","density"), main=paste("X-S plot -", basis, "basis"), 
        xlab=deparse(substitute(x)), ylab, 
        contours=TRUE, col.contours="lightgrey", lty.contours=par("lty"), 
        lwd.contours=par("lwd"),
        label.contours=contours, format.clab="p=%3.2f",
        pos.clab="bottomright", col.clab=col.contours, cex.clab=0.7,
        cex.label=0.7, pos=3, adj=NULL, 
        pch=par("pch"), col=par("col"), bg=par("bg"), cex=par("cex"), 
        add=FALSE, ...)

XSplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xs.plot_+3A_x">x</code></td>
<td>
<p>Numeric vector of values to be plotted.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_g">g</code></td>
<td>
<p>grouping factor of length <code>length(x)</code>.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_s">s</code></td>
<td>
<p>numeric vector of standard deviations of length <code>length(x)</code>
associated with x.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_degfree">degfree</code></td>
<td>
<p>A single value for degrees of freedom associated with <em>all</em> 
the standard deviations <code>s</code>. Ignored if <code>s</code> is not supplied.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_labels.arg">labels.arg</code></td>
<td>
<p>An optional vector of point labels, 
coerced to character on use.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_mu">mu</code></td>
<td>
<p>A single location used to centre the confidence region. The default is 
specified by <code>"basis"</code>; see Details.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_sigma">sigma</code></td>
<td>
<p>A measure of dispersion against which deviations x-mu can be compared.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities for confidence region contours. 
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_basis">basis</code></td>
<td>
<p>Controls the nature of the location and scale estimators used to 
produce the confidence contours drawn on the plot. See Details for 
specification.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_method">method</code></td>
<td>
<p>The method used to calculate the confidence region. See Details.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_main">main</code></td>
<td>
<p>Main title for the plot.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_xlab">xlab</code>, <code id="xs.plot_+3A_ylab">ylab</code></td>
<td>
<p>x- and y-axis labels, 
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_contours">contours</code></td>
<td>
<p>logical, specifying whether confidence contours should be drawn. 
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_col.contours">col.contours</code>, <code id="xs.plot_+3A_lty.contours">lty.contours</code>, <code id="xs.plot_+3A_lwd.contours">lwd.contours</code></td>
<td>
<p>Colour, line type and line width 
for contour lines.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_label.contours">label.contours</code></td>
<td>
<p>Logical, controlling whether contour lines are 
labelled with approximate probabilities.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_format.clab">format.clab</code></td>
<td>
<p>Format string for contour labels, passed to <code>sprintf</code>.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_pos.clab">pos.clab</code></td>
<td>
<p>Specification for location of contour labels.  A vector can be 
provided to give multiple labels. See Details for further description.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_col.clab">col.clab</code>, <code id="xs.plot_+3A_cex.clab">cex.clab</code></td>
<td>
<p>Colour and expansion for contour labels.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_pch">pch</code>, <code id="xs.plot_+3A_col">col</code>, <code id="xs.plot_+3A_bg">bg</code>, <code id="xs.plot_+3A_cex">cex</code></td>
<td>
<p>Graphical parameters passed to <code>points</code>.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_cex.label">cex.label</code></td>
<td>
<p>Expansion factor for point labels, passed to <code>text</code>.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_pos">pos</code>, <code id="xs.plot_+3A_adj">adj</code></td>
<td>
<p>Specifies position/adjustment of point labels. Passed to <code>text</code>; 
see <code>text</code> for details.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_add">add</code></td>
<td>
<p>If TRUE the plot region is not cleared before plotting; points and contours 
are added to the present plot. Use <code>pch=NA</code> to suppress symbols if only added 
contours are required.
</p>
</td></tr>
<tr><td><code id="xs.plot_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot of standard deviations against locations is produced, together 
with optional confidence region(s) calculated (by default) by a 
method suggested in ISO 13528:2005.
</p>
<p>If <code>s</code> is supplied, <code>x</code> is taken as a vector of locations and 
<code>s</code> a vector of standard deviations. <code>degfree</code> must be supplied
in this case.
</p>
<p>If <code>g</code> is supplied and <code>s</code> is not, the locations and standard deviations
used are the means and standard deviations for each group. <code>degfree</code> is calculated 
from the median group size. Groups should, of course, be of the same size for accurate 
inference; however, using the median group size allows for some groups with missing values. 
</p>
<p>If <code>s</code> and <code>g</code> are both supplied, <code>g</code> is ignored with a warning
</p>
<p>If requested by <code>contours=TRUE</code>, confidence regions are drawn for each value
of <code>probs</code>. Contour location and shape are controlled by <code>basis</code>
which specifies the location and scale estimators used, and <code>method</code>, which 
specifies the method of calculation for the contours. Two methods are supported; 
one using the chi-squared distribution (<code>method="chisq"</code>) and one based on 
equal density countours (<code>method="density"</code>). The default, and the method 
recommended by the cited Standard, is <code>method="chisq"</code> and <code>basis="robust"</code>.
</p>
<p>Both calculations for confidence regions require estimation of a location <code class="reqn">\hat{\mu}</code> 
and an estimate <code class="reqn">\hat{\sigma}</code> of the pooled within-group standard deviation or pooled 
estimate from <code>s</code>. If <code>basis="robust"</code>, <code class="reqn">\hat{\mu}</code> and <code class="reqn">\hat{\sigma}</code>
are calculated using <code>algA</code> and <code>algS</code> respectively. If <code>basis="classical"</code>, 
<code class="reqn">\hat{\mu}</code> and <code class="reqn">\hat{\sigma}</code> are the mean of the group means and the classical pooled 
standard deviation respectively. If <code>mu</code> or <code>sigma</code> are given, these are used
in place of the calculated  <code class="reqn">\hat{\mu}</code> and <code class="reqn">\hat{\sigma}</code> respectively.
</p>
<p>If <code>method="chisq"</code>, contours for probability <code class="reqn">p</code> are calculated as 
</p>
<p style="text-align: center;"><code class="reqn">s=\hat{\sigma}\exp\left ( \pm\frac{1}{\sqrt{2(n-1)}}\sqrt{\chi_{2,p}^2-n \left ( \frac{x-\hat{\mu}}{\hat{\sigma}}\right ) ^2}\right )</code>
</p>

<p>for <code class="reqn">x</code> from 
<code class="reqn"> \hat{\mu}-\hat{\sigma}\sqrt{\frac{\chi_{2,p}^2}{n}}</code> to 
<code class="reqn">\hat{\mu}+\hat{\sigma}\sqrt{\frac{\chi_{2,p}^2}{n}}</code>.  
</p>
<p>If <code>method="density"</code>, contours for probability <code class="reqn">p</code> are calculated using 
Helmert's distribution to provide constant likelihood contours round the chosen mean 
and standard deviation. In the present implementation, these are found using
<code>uniroot</code> to find the mean corresponding to the required density at
given standard deviations. The density chosen is <code class="reqn">d_{max}(1-p)</code> where <code class="reqn">p</code> is
the probability and <code class="reqn">d_{max}</code> the maximum density for Helmert's 
distribution for the requisite nunber of degrees of freedom. (See Kruskal 
(1946) for a description of Helmert's distribution and, for example, 
Pawitan (2001) for the rationale behind the choice of density
contour level.) This seems to give reasonably good results for <code class="reqn">n \ge 3 </code>
but is anticonservative (particularly to high <code class="reqn">s</code>) for <code class="reqn">n = 2 </code>. 
</p>
<p>Contours are by default labelled. Label locations can be specified using <code>pos.clab</code>. 
Options are code&quot;top&quot;, code&quot;topright&quot;, code&quot;right&quot;, code&quot;bottomright&quot;, 
code&quot;bottom&quot;, code&quot;bottomleft&quot;, code&quot;left&quot; and code&quot;topleft&quot;. A vector can be 
specified to give labels at more than one such location. 
Contour labels are usually placed approximately at the location(s) indicated and adjusted outward 
appropriately. For the special case of <code>method="density"</code> and  <code>degfree=1</code> (or where group 
sizes <code class="reqn">n=1</code>), for which the region is a maximu width at s=0, 
<code>"bottomright"</code> and <code>"bottomleft"</code> place labels immediately below the countour boundary 
at <code class="reqn">s=0</code> and, if specified, <code>"bottom"</code> is replaced with <code>c("bottomright", "bottomleft")</code>.
</p>
<p><code>XSplot</code> is an alias for <code>xs.plot</code>.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt>x, y</dt><dd><p>respectively, the plotted locations and standard deviations. 
(the names allow a simple call to <code>plot()</code>) 
</p>
</dd>
<dt>mu</dt><dd><p> The location and pooled SD estimates <code class="reqn">\hat{\mu}</code> and 
<code class="reqn">\hat{\sigma}</code> used to construct the confidence ellipsoids. 
</p>
</dd>
<dt>clist</dt><dd><p> A list of sets of coordinates for each confidence region. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>S Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>ISO 13528:2005, Statistical methods for use in proficiency testing by interlaboratory
comparisons, International Organization for Standardization, Geneva (2005)
</p>
<p>Y Pawitan, (2001) In all likelihood: Statistical Modelling and Inference Using 
Likelihood,Clarendon Press, Oxford, pp258-9
</p>
<p>W Kruskal, American Mathematical Monthly 53, 435-438, (1946)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+algA">algA</a></code>, <code><a href="#topic+algS">algS</a></code>
</p>
<p><code><a href="graphics.html#topic+axis">axis</a></code> for axis control; <code><a href="graphics.html#topic+points">points</a></code>,  <code><a href="graphics.html#topic+text">text</a></code> for 
plotting parameters; <code><a href="base.html#topic+sprintf">sprintf</a></code> for contour label formatting.
</p>
<p><code><a href="#topic+duewer.plot">duewer.plot</a></code> for an alternative plot for locations and associated 
standard errors or standard uncertainties; 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	require(metRology)
	set.seed(1017)
	x &lt;- rnorm(80)
	g &lt;- gl(20,4)
	
	xs.plot(x,g)

	#Identical plot with precalculated s:
	X &lt;- tapply(x,g,mean)
	S &lt;- tapply(x,g,sd)
	xs.plot(X, s=S, degfree=3)

	#Specify different location and within-group SD estimates:
	xs.plot(X, s=S, degfree=3, mu=median(X), sigma=median(S))
	
	#Illustrate multiple contour labelling, point labels and further embellishment
	rv &lt;- xs.plot(x,g, pos.clab=c("bottomleft", "bottomright"), labels=TRUE)
	abline(v=rv$mu, h=rv$s, col=2)
	
	
</code></pre>

<hr>
<h2 id='youden.plot'>
Youden plots
</h2><span id='topic+youden.plot'></span><span id='topic+youden.plot.default'></span><span id='topic+yplot'></span>

<h3>Description</h3>

<p>A Youden plot is a bivariate scatter plot, named for its use by W. M Youden in 
interlaboratory studies. This implementation includes data ellipses based on Pearson, 
Spearman, Kendall or several robust covariance measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>youden.plot(x, ...)

yplot(x, ...)

## Default S3 method:
youden.plot(x, y = NULL, type = c("points", "labels", "both", "outliers"), 
	labels, probs = c(0.95, 0.99), x0, y0,  pch = par("pch"), cex = par("cex"), 
	col = par("col"), bg = par("bg"), main, xlab, ylab,  
	xlim = c("data", "ellipse", "all"), ylim = c("data", "ellipse", "all"), 
	col.axes = 2, lwd.axes = 1, lty.axes = 1, cex.lab = 0.7, pos = 3, 
	out.method = c("F", "chisq", "n"), n.out, p.out = 0.99, 
	add = FALSE,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="youden.plot_+3A_x">x</code></td>
<td>

<p>An R <code>numeric</code> object. Can be a vector (in which case <code>y</code> must be specified 
and of the same length) or a two-column numeric matrix.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_y">y</code></td>
<td>

<p>A numeric vector of the same length as <code>x</code>. It is an error to provide <code>y</code> 
in addition to a two-column matrix for <code>x</code>.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_type">type</code></td>
<td>

<p>The type of plot produced. See Details.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_labels">labels</code></td>
<td>

<p>Character vector of text labels for data points. Defaults to <code>row.names(x)</code> if
<code>x</code> is a matrix or data frame with row names, <code>names(x)</code> if <code>x</code> is a 
named vector, and to <code>1:length(x)</code> or <code>1:nrow(x)</code> 
as appropriate if <code>x</code> does not have names.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_probs">probs</code></td>
<td>

<p>Numeric vector of probabilities for data ellipses.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_x0">x0</code>, <code id="youden.plot_+3A_y0">y0</code></td>
<td>

<p>If specified, data ellipses will be centred on <code>(x0, y0)</code> instead of using the 
location calculated from the data.  
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_pch">pch</code>, <code id="youden.plot_+3A_cex">cex</code>, <code id="youden.plot_+3A_col">col</code>, <code id="youden.plot_+3A_bg">bg</code></td>
<td>

<p>passed to <code>points</code>; see <code><a href="graphics.html#topic+points">points</a></code> for details.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_main">main</code>, <code id="youden.plot_+3A_xlab">xlab</code>, <code id="youden.plot_+3A_ylab">ylab</code></td>
<td>

<p>Plot titles. If missing, titles are based on the names of the objects plotted. 
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_xlim">xlim</code>, <code id="youden.plot_+3A_ylim">ylim</code></td>
<td>

<p>Specifications for horizintal and vertical plot limits. Each can be either a length 2 
numeric vector (as usual) or a character value matching one of <code>"data"</code>, 
<code>"ellipse"</code> or <code>"all"</code>. If <code>"data"</code>, the relevant limits are set to 
include the range of the data. If <code>"ellipse"</code>, the relevant limits are set to 
include the whole of the outermost ellipse. If <code>"all"</code>, limits are set to include 
both the data and the outermost ellipse.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_col.axes">col.axes</code>, <code id="youden.plot_+3A_lwd.axes">lwd.axes</code>, <code id="youden.plot_+3A_lty.axes">lty.axes</code></td>
<td>

<p>Colour, line width and line type for vertical and horizontal location markers
drawn through the ellipse centre.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_cex.lab">cex.lab</code></td>
<td>

<p>Size for data point labels; see <code><a href="graphics.html#topic+text">text</a></code> for details.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_pos">pos</code></td>
<td>

<p>a position specifier for data point labels; see <code><a href="graphics.html#topic+text">text</a></code> for details.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_out.method">out.method</code></td>
<td>

<p>Character specifying outlier marking. See Details.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_n.out">n.out</code></td>
<td>

<p>Number of outliers marked if <code>out.method=="n"</code>.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_p.out">p.out</code></td>
<td>

<p>Confidence level at which points are marked as outliers if <code>out.method</code> is
one of <code>"F"</code> or <code>"chisq"</code>.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_add">add</code></td>
<td>

<p>If <code>TRUE</code>, ellipses and points are added to an existing plot.
</p>
</td></tr>
<tr><td><code id="youden.plot_+3A_...">...</code></td>
<td>
<p> Named arguments passed to other functions. In particular:
</p>

<ul>
<li><p>Arguments <code>cov.method</code>, <code>cov.control</code>, <code>scalefn</code>, and <code>locfn</code> 
will be passed to <code>cov.dellipse</code> to control the (optionally robust) 
location, scale and covariance estimates used for the ellipses. 
</p>
</li>
<li><p>Arguments <code>sub</code>, <code>ann</code>, <code>axes</code>, <code>frame.plot</code>, and <code>asp</code> 
are passed to <code>plot</code> to add a sub-title, control axes and annotation and, 
importantly, control the plot aspect ratio.
</p>
</li>
<li><p>Arguments <code>col.ellipse</code>, <code>lty.ellipse</code>, <code>lwd.ellipse</code>, <code>fill</code>, 
<code>density</code>, <code>angle</code>, <code>npoints</code>, <code>prinax</code>, <code>col.prinax</code>, 
<code>lty.prinax</code>, and <code>lwd.prinax</code> are passed to <code><a href="#topic+plot.d.ellipse">plot.d.ellipse</a></code>
to control the appearance of ellipses and ellipse principal axes.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p><code>type</code> controls the type of plot produced. Allowed types and their effect are:
</p>

<dl>
<dt><code>points</code></dt><dd><p>Points only are drawn.</p>
</dd>
<dt><code>labels</code></dt><dd><p>Point labels only are drawn</p>
</dd>
<dt><code>both</code></dt><dd><p>Points are drawn with labels</p>
</dd>
<dt><code>outliers</code></dt><dd><p>Points are drawn and outlying points are labelled (see below)</p>
</dd>
</dl>

<p>Ellipses are constructed based on a location and covariance matrix constructed from the data 
by the method specified by <code>cov.method</code>. <code>probs</code> specifies the approximate coverage.
See <code><a href="#topic+data.ellipse">data.ellipse</a></code> for details of covariance methods and ellipse specification.
</p>
<p>The outlier identification method, if any, is specified by <code>out.method</code> and controlled by 
one of <code>n.out</code> or <code>p.out</code>. If <code>out.method</code> is <code>"F"</code> or <code>"chisq"</code>, 
points with Mahalanobis distance greater than an upper critical value with probability <code>p.out</code> 
are considered to be outliers. The critical values used are
</p>

<dl>
<dt><code>"F"</code></dt><dd><p>Mahalanobis distance greater than 
<code> 2 * (n-1) * qf(p.out, 2, n-1) / (n-2)</code></p>
</dd>
<dt><code>"chisq"</code></dt><dd><p>Mahalanobis distance greater than <code>qchisq(p.out, 2)</code></p>
</dd>
</dl>
<p>which( md &gt; 2 * (n-1) * qf(p.out, 2, n-1) / (n-2) ) #F dist

The Mahalanobis distance is calculated based on the covariance matrix used to consstruct plot ellipses.
</p>
<p>If <code>out.method</code> is <code>"n"</code>, the outermost <code>n.out</code> points (judged by Mahalanobis distance)
are marked as outliers. Specifying <code>out.method="n"</code> and <code>n.out=0</code> suppresses outlier 
identification.
If outliers are marked, a list of marked outliers is included in the returned list 
(see Value, below).
</p>
<p><code>yplot</code> is an alias for <code>youden.plot</code>
</p>


<h3>Value</h3>

<p>Invisibly returns the plotted data ellipses as an object of class <code><a href="#topic+d.ellipse">d.ellipse</a></code>. 
</p>


<h3>Author(s)</h3>

<p>S L R Ellison (s.ellison@lgcgroup.com)
</p>


<h3>References</h3>

<p>Youden, W.J. and Steiner, E.H.  (1975) <em>Statistical Manual of the AOAC</em>. AOAC 
International, Washington, US. ISBN 0-935584-15-3
</p>
<p>ISO 13528:2005, Statistical methods for use in proficiency testing by interlaboratory
comparisons, International Organization for Standardization, Geneva (2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+d.ellipse">d.ellipse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromium)
data(potassium)

( yy &lt;- youden.plot(chromium, main="Chromium") )

#With outlier ID (F based)
youden.plot(chromium, main="Chromium", xlim='a', ylim='a', type='o', p.out=0.95)
	#Note use of xlim="a" etc. to ensure both ellipses and data are included.
	
#Top 5 most distant outliers (5 is also the default)
youden.plot(chromium, main="Chromium", xlim='a', ylim='a', type='o', out.method="n", n.out=5)

#With ellipse principal axes
#(useful to specify asp=1 or the axes will not always appear orthogonal)
youden.plot(chromium, main="Chromium", 
	xlim='a', ylim='a', type='o', p.out=0.99, prinax=TRUE, lty.prinax=2, asp=1.0)

youden.plot(potassium, main="Potassium")

#A different pairs plot ...
panel.youden &lt;- function(x, y, ...) youden.plot(x, y, add=TRUE, type="o", cex=1, pos=1, p.out=0.95)
pairs(chromium, upper.panel=panel.youden)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
