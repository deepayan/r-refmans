<!DOCTYPE html><html><head><title>Help for package tessellation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tessellation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cellVertices'><p>Vertices of a bounded cell</p></a></li>
<li><a href='#cellVolume'><p>Volume of a bounded Voronoï cell</p></a></li>
<li><a href='#centricCuboctahedron'><p>Centric cuboctahedron</p></a></li>
<li><a href='#delaunay'><p>Delaunay triangulation</p></a></li>
<li><a href='#Edge2'><p>R6 class representing an edge in dimension 2.</p></a></li>
<li><a href='#Edge3'><p>R6 class representing an edge in dimension 3.</p></a></li>
<li><a href='#getDelaunaySimplices'><p>Delaunay simplices</p></a></li>
<li><a href='#IEdge2'><p>R6 class representing a semi-infinite edge in dimension 2</p></a></li>
<li><a href='#IEdge3'><p>R6 class representing a semi-infinite edge in dimension 3</p></a></li>
<li><a href='#isBoundedCell'><p>Is this cell bounded?</p></a></li>
<li><a href='#plotBoundedCell2D'><p>Plot a bounded Voronoï 2D cell</p></a></li>
<li><a href='#plotBoundedCell3D'><p>Plot a bounded Voronoï 3D cell</p></a></li>
<li><a href='#plotDelaunay2D'><p>Plot 2D Delaunay tessellation</p></a></li>
<li><a href='#plotDelaunay3D'><p>Plot 3D Delaunay tessellation</p></a></li>
<li><a href='#plotVoronoiDiagram'><p>Plot Voronoï diagram</p></a></li>
<li><a href='#surface'><p>Tessellation surface</p></a></li>
<li><a href='#teapot'><p>Utah teapot</p></a></li>
<li><a href='#tessellation-imports'><p>Objects imported from other packages</p></a></li>
<li><a href='#volume'><p>Tessellation volume</p></a></li>
<li><a href='#voronoi'><p>Voronoï tessellation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Delaunay and Voronoï Tessellations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Laurent &lt;laurent_step@outlook.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Delaunay and Voronoï tessellations, with emphasis on the
    two-dimensional and the three-dimensional cases (the package provides
    functions to plot the tessellations for these cases). Delaunay
    tessellations are computed in C with the help of the 'Qhull' library
    <a href="http://www.qhull.org/">http://www.qhull.org/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stla/tessellation">https://github.com/stla/tessellation</a>,
<a href="https://stla.github.io/tessellation/">https://stla.github.io/tessellation/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stla/tessellation/issues">https://github.com/stla/tessellation/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>colorsGen, cxhull, english, graphics, hash, Polychrome, R6,
rgl, Rvcg, scales, sets, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, paletteer, rmarkdown, uniformly, viridisLite</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 12:13:58 UTC; SDL96354</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Laurent [aut, cre],
  C. B. Barber [cph] (author of the Qhull library),
  The Geometry Center [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 15:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cellVertices'>Vertices of a bounded cell</h2><span id='topic+cellVertices'></span>

<h3>Description</h3>

<p>Get all vertices of a bounded cell, without duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellVertices(cell, check.bounded = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellVertices_+3A_cell">cell</code></td>
<td>
<p>a bounded Voronoï cell</p>
</td></tr>
<tr><td><code id="cellVertices_+3A_check.bounded">check.bounded</code></td>
<td>
<p>Boolean, whether to check that the cell is bounded;
set to <code>FALSE</code> for a small speed gain if you know that the cell is
bounded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, each row represents a vertex.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
d &lt;- delaunay(centricCuboctahedron())
v &lt;- voronoi(d)
cell13 &lt;- v[[13]]
isBoundedCell(cell13) # TRUE
library(rgl)
open3d(windowRect = c(50, 50, 562, 562))
invisible(lapply(cell13[["cell"]], function(edge){
  edge$plot(edgeAsTube = TRUE, tubeRadius = 0.025, tubeColor = "yellow")
}))
cellvertices &lt;- cellVertices(cell13)
spheres3d(cellvertices, radius = 0.1, color = "green")
</code></pre>

<hr>
<h2 id='cellVolume'>Volume of a bounded Voronoï cell</h2><span id='topic+cellVolume'></span>

<h3>Description</h3>

<p>For a bounded 2D Voronoï cell, returns the area of the cell,
and for a bounded 3D Voronoï cell, returns the volume of the cell and
its surface area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellVolume(cell)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellVolume_+3A_cell">cell</code></td>
<td>
<p>a bounded 2D or 3D Voronoï cell</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, the area/volume of the cell, and in the 3D case, the
surface area of the cell is attached to this number as an attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
d &lt;- delaunay(centricCuboctahedron())
v &lt;- voronoi(d)
cell13 &lt;- v[[13]]
isBoundedCell(cell13) # TRUE
cellVolume(cell13)
</code></pre>

<hr>
<h2 id='centricCuboctahedron'>Centric cuboctahedron</h2><span id='topic+centricCuboctahedron'></span>

<h3>Description</h3>

<p>A cuboctahedron (12 vertices), with a point added at its center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centricCuboctahedron()
</code></pre>


<h3>Value</h3>

<p>A numeric matrix with 13 rows and 3 columns.
</p>

<hr>
<h2 id='delaunay'>Delaunay triangulation</h2><span id='topic+delaunay'></span>

<h3>Description</h3>

<p>Delaunay triangulation (or tessellation) of a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delaunay(
  points,
  atinfinity = FALSE,
  degenerate = FALSE,
  exteriorEdges = FALSE,
  elevation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delaunay_+3A_points">points</code></td>
<td>
<p>the points given as a matrix, one point per row</p>
</td></tr>
<tr><td><code id="delaunay_+3A_atinfinity">atinfinity</code></td>
<td>
<p>Boolean, whether to include a point at infinity;
ignored if <code>elevation=TRUE</code></p>
</td></tr>
<tr><td><code id="delaunay_+3A_degenerate">degenerate</code></td>
<td>
<p>Boolean, whether to include degenerate tiles;
ignored if <code>elevation=TRUE</code></p>
</td></tr>
<tr><td><code id="delaunay_+3A_exterioredges">exteriorEdges</code></td>
<td>
<p>Boolean, for dimension 3 only, whether to return
the exterior edges (see below)</p>
</td></tr>
<tr><td><code id="delaunay_+3A_elevation">elevation</code></td>
<td>
<p>Boolean, only for three-dimensional points; if <code>TRUE</code>,
the function performs an elevated Delaunay triangulation (also called 2.5D
Delaunay triangulation), using the third coordinate of a point as its
elevation; see the example</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the function performs an elevated Delaunay tessellation, then
the returned value is a list with four fields: <code>mesh</code>, <code>edges</code>,
<code>volume</code>, and <code>surface</code>. The <code>mesh</code> field is an object of
class <code>mesh3d</code>, ready for plotting with the <strong>rgl</strong> package. The
<code>edges</code> field is an integer matrix which provides the indices of the
vertices of the edges, and an indicator of whether an edge is a border
edge; this matrix is obtained with <code><a href="Rvcg.html#topic+vcgGetEdge">vcgGetEdge</a></code>.
The <code>volume</code> field provides the sum of the
volumes under the Delaunay triangles, that is to say the total volume
under the triangulated surface. Finally, the <code>surface</code> field provides
the sum of the areas of the Delaunay triangles, thus this is an approximate
value of the area of the surface that is triangulated.
The elevated Delaunay tessellation is built with the help of the
<strong>interp</strong> package.
</p>
<p>Otherwise, the function returns the Delaunay tessellation with many details,
in a list. This list contains five fields:
</p>

<dl>
<dt><em>vertices</em></dt><dd><p>the vertices (or sites) of the tessellation; these
are the points passed to the function</p>
</dd>
<dt><em>tiles</em></dt><dd><p>the tiles of the tessellation (triangles in dimension
2, tetrahedra in dimension 3)</p>
</dd>
<dt><em>tilefacets</em></dt><dd><p>the facets of the tiles of the tessellation</p>
</dd>
<dt><em>mesh</em></dt><dd><p>a 'rgl' mesh (<code><a href="rgl.html#topic+mesh3d">mesh3d</a></code> object)</p>
</dd>
<dt><em>edges</em></dt><dd><p>a two-columns integer matrix representing the edges,
each row represents an edge; the two integers of a row are the indices of
the two points which form the edge.</p>
</dd>
</dl>

<p>In dimension 3, the list contains an additional field <em>exteriorEdges</em>
if you set <code>exteriorEdges = TRUE</code>. This is the list of the exterior
edges, represented as <code><a href="#topic+Edge3">Edge3</a></code> objects. This field is involved
in the function <code><a href="#topic+plotDelaunay3D">plotDelaunay3D</a></code>.
</p>
<p>The <strong>vertices</strong> field is a list with the following fields:
</p>

<dl>
<dt><em>id</em></dt><dd><p>the id of the vertex; this is nothing but the index of
the corresponding point passed to the function</p>
</dd>
<dt><em>neighvertices</em></dt><dd><p>the ids of the vertices of the tessellation
connected to this vertex by an edge</p>
</dd>
<dt><em>neightilefacets</em></dt><dd><p>the ids of the tile facets this vertex
belongs to</p>
</dd>
<dt><em>neightiles</em></dt><dd><p>the ids of the tiles this vertex belongs to</p>
</dd>
</dl>

<p>The <strong>tiles</strong> field is a list with the following fields:
</p>

<dl>
<dt><em>id</em></dt><dd><p>the id of the tile</p>
</dd>
<dt><em>simplex</em></dt><dd><p>a list describing the simplex (that is, the tile);
this list contains four fields: <em>vertices</em>, a
<code><a href="hash.html#topic+hash">hash</a></code> giving the simplex vertices and their id,
<em>circumcenter</em>, the circumcenter of the simplex, <em>circumradius</em>,
the circumradius of the simplex, and <em>volume</em>, the volume of the
simplex</p>
</dd>
<dt><em>facets</em></dt><dd><p>the ids of the facets of this tile</p>
</dd>
<dt><em>neighbors</em></dt><dd><p>the ids of the tiles adjacent to this tile</p>
</dd>
<dt><em>family</em></dt><dd><p>two tiles have the same family if they share the
same circumcenter; in this case the family is an integer, and the family is
<code>NA</code> for tiles which do not share their circumcenter with any other
tile</p>
</dd>
<dt><em>orientation</em></dt><dd><p><code>1</code> or <code>-1</code>, an indicator of the
orientation of the tile</p>
</dd>
</dl>

<p>The <strong>tilefacets</strong> field is a list with the following fields:
</p>

<dl>
<dt><em>id</em></dt><dd><p>the id of this tile facet</p>
</dd>
<dt><em>subsimplex</em></dt><dd><p>a list describing the subsimplex (that is, the
tile facet); this list is similar to the <em>simplex</em> list of
<strong>tiles</strong></p>
</dd>
<dt><em>facetOf</em></dt><dd><p>one or two ids, the id(s) of the tile this facet
belongs to</p>
</dd>
<dt><em>normal</em></dt><dd><p>a vector, the normal of the tile facet</p>
</dd>
<dt><em>offset</em></dt><dd><p>a number, the offset of the tile facet</p>
</dd>
</dl>



<h3>Note</h3>

<p>The package provides the functions <code><a href="#topic+plotDelaunay2D">plotDelaunay2D</a></code> to
plot a 2D Delaunay tessellation and <code><a href="#topic+plotDelaunay3D">plotDelaunay3D</a></code> to
plot a 3D Delaunay tessellation. But there is no function to plot an
elevated Delaunay tessellation; the examples show how to plot such a
Delaunay tessellation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDelaunaySimplices">getDelaunaySimplices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
points &lt;- rbind(
 c(0.5,0.5,0.5),
 c(0,0,0),
 c(0,0,1),
 c(0,1,0),
 c(0,1,1),
 c(1,0,0),
 c(1,0,1),
 c(1,1,0),
 c(1,1,1)
)
del &lt;- delaunay(points)
del$vertices[[1]]
del$tiles[[1]]
del$tilefacets[[1]]

# an elevated Delaunay tessellation ####
f &lt;- function(x, y){
  dnorm(x) * dnorm(y)
}
x &lt;- y &lt;- seq(-5, 5, length.out = 50)
grd &lt;- expand.grid(x = x, y = y) # grid on the xy-plane
points &lt;- as.matrix(transform( # data (x_i, y_i, z_i)
  grd, z = f(x, y)
))
del &lt;- delaunay(points, elevation = TRUE)
del[["volume"]] # close to 1, as expected
# plotting
library(rgl)
mesh &lt;- del[["mesh"]]
open3d(windowRect = c(100, 100, 612, 356), zoom = 0.6)
aspect3d(1, 1, 20)
shade3d(mesh, color = "limegreen", polygon_offset = 1)
wire3d(mesh)

# another elevated Delaunay triangulation, to check the correctness
#   of the calculated surface and the calculated volume ####
library(Rvcg)
library(rgl)
cap &lt;- vcgSphericalCap(angleRad = pi/2, subdivision = 3)
open3d(windowRect = c(100, 100, 612, 356), zoom = 0.6)
shade3d(cap, color = "lawngreen", polygon_offset = 1)
wire3d(cap)
# exact value of the surface of the spherical cap:
R &lt;- 1
h &lt;- R * (1 - sin(pi/2/2))
2 * pi * R * h
# our approximation:
points &lt;- t(cap$vb[-4, ]) # the points on the spherical cap
del &lt;- delaunay(points, elevation = TRUE)
del[["surface"]]
# try to increase `subdivision` in `vcgSphericalCap` to get a
#   better approximation of the true value
# note that 'Rvcg' returns the same result as ours:
vcgArea(cap)
# let's check the volume as well:
pi * h^2 * (R - h/3) # true value
del[["volume"]]
# there's a warning with 'Rvcg':
tryCatch(vcgVolume(cap), warning = function(w) message(w))
suppressWarnings({vcgVolume(cap)})
</code></pre>

<hr>
<h2 id='Edge2'>R6 class representing an edge in dimension 2.</h2><span id='topic+Edge2'></span>

<h3>Description</h3>

<p>An edge is given by two vertices in the 2D space,
named <code>A</code> and <code>B</code>. This is for example an edge of a Voronoï cell
of a 2D Delaunay tessellation.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>A</code></dt><dd><p>get or set the vertex <code>A</code></p>
</dd>
<dt><code>B</code></dt><dd><p>get or set the vertex <code>B</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Edge2-new"><code>Edge2$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge2-print"><code>Edge2$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge2-plot"><code>Edge2$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge2-stack"><code>Edge2$stack()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge2-clone"><code>Edge2$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Edge2-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Edge2</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge2$new(A, B)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>A</code></dt><dd><p>the vertex <code>A</code></p>
</dd>
<dt><code>B</code></dt><dd><p>the vertex <code>B</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Edge2</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>edge &lt;- Edge2$new(c(1, 1), c(2, 3))
edge
edge$A
edge$A &lt;- c(1, 0)
edge
</pre>
</div>


<hr>
<a id="method-Edge2-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an <code>Edge2</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge2$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Edge2$new(c(2, 0), c(3, -1))
</pre>
</div>


<hr>
<a id="method-Edge2-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot an <code>Edge2</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge2$plot(color = "black", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color</code></dt><dd><p>the color of the edge</p>
</dd>
<dt><code>...</code></dt><dd><p>graphical parameters such as <code>lty</code> or <code>lwd</code></p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>library(tessellation)
centricSquare &lt;- rbind(
  c(-1, 1), c(1, 1), c(1, -1), c(-1, -1), c(0, 0)
)
d &lt;- delaunay(centricSquare)
v &lt;- voronoi(d)
cell5 &lt;- v[[5]] # the cell of the point (0, 0), at the center
isBoundedCell(cell5) # TRUE
plot(centricSquare, type = "n")
invisible(lapply(cell5[["cell"]], function(edge) edge$plot()))
</pre>
</div>


<hr>
<a id="method-Edge2-stack"></a>



<h4>Method <code>stack()</code></h4>

<p>Stack the two vertices of the edge (this is for internal
purpose).
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge2$stack()</pre></div>


<hr>
<a id="method-Edge2-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge2$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Edge2$new`
## ------------------------------------------------

edge &lt;- Edge2$new(c(1, 1), c(2, 3))
edge
edge$A
edge$A &lt;- c(1, 0)
edge

## ------------------------------------------------
## Method `Edge2$print`
## ------------------------------------------------

Edge2$new(c(2, 0), c(3, -1))

## ------------------------------------------------
## Method `Edge2$plot`
## ------------------------------------------------

library(tessellation)
centricSquare &lt;- rbind(
  c(-1, 1), c(1, 1), c(1, -1), c(-1, -1), c(0, 0)
)
d &lt;- delaunay(centricSquare)
v &lt;- voronoi(d)
cell5 &lt;- v[[5]] # the cell of the point (0, 0), at the center
isBoundedCell(cell5) # TRUE
plot(centricSquare, type = "n")
invisible(lapply(cell5[["cell"]], function(edge) edge$plot()))
</code></pre>

<hr>
<h2 id='Edge3'>R6 class representing an edge in dimension 3.</h2><span id='topic+Edge3'></span>

<h3>Description</h3>

<p>An edge is given by two vertices in the 3D space,
named <code>A</code> and <code>B</code>. This is for example an edge of a Voronoï cell
of a 3D Delaunay tessellation.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>A</code></dt><dd><p>get or set the vertex <code>A</code></p>
</dd>
<dt><code>B</code></dt><dd><p>get or set the vertex <code>B</code></p>
</dd>
<dt><code>idA</code></dt><dd><p>get or set the id of vertex <code>A</code></p>
</dd>
<dt><code>idB</code></dt><dd><p>get or set the id of vertex <code>B</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Edge3-new"><code>Edge3$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge3-print"><code>Edge3$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge3-plot"><code>Edge3$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge3-stack"><code>Edge3$stack()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge3-clone"><code>Edge3$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Edge3-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Edge3</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge3$new(A, B, idA, idB)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>A</code></dt><dd><p>the vertex <code>A</code></p>
</dd>
<dt><code>B</code></dt><dd><p>the vertex <code>B</code></p>
</dd>
<dt><code>idA</code></dt><dd><p>the id of vertex <code>A</code>, an integer; can be missing</p>
</dd>
<dt><code>idB</code></dt><dd><p>the id of vertex <code>B</code>, an integer; can be missing</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Edge3</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>edge &lt;- Edge3$new(c(1, 1, 1), c(1, 2, 3))
edge
edge$A
edge$A &lt;- c(1, 0, 0)
edge
</pre>
</div>


<hr>
<a id="method-Edge3-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an <code>Edge3</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge3$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Edge3$new(c(2, 0, 0), c(3, -1, 4))
</pre>
</div>


<hr>
<a id="method-Edge3-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot an <code>Edge3</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge3$plot(edgeAsTube = FALSE, tubeRadius, tubeColor)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>edgeAsTube</code></dt><dd><p>Boolean, whether to plot the edge as a tube</p>
</dd>
<dt><code>tubeRadius</code></dt><dd><p>the radius of the tube</p>
</dd>
<dt><code>tubeColor</code></dt><dd><p>the color of the tube</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>library(tessellation)
d &lt;- delaunay(centricCuboctahedron())
v &lt;- voronoi(d)
cell13 &lt;- v[[13]] # the point (0, 0, 0), at the center
isBoundedCell(cell13) # TRUE
library(rgl)
open3d(windowRect = c(50, 50, 562, 562))
invisible(lapply(cell13[["cell"]], function(edge) edge$plot()))
</pre>
</div>


<hr>
<a id="method-Edge3-stack"></a>



<h4>Method <code>stack()</code></h4>

<p>Stack the two vertices of the edge (this is for internal
purpose).
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge3$stack()</pre></div>


<hr>
<a id="method-Edge3-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge3$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Edge3$new`
## ------------------------------------------------

edge &lt;- Edge3$new(c(1, 1, 1), c(1, 2, 3))
edge
edge$A
edge$A &lt;- c(1, 0, 0)
edge

## ------------------------------------------------
## Method `Edge3$print`
## ------------------------------------------------

Edge3$new(c(2, 0, 0), c(3, -1, 4))

## ------------------------------------------------
## Method `Edge3$plot`
## ------------------------------------------------

library(tessellation)
d &lt;- delaunay(centricCuboctahedron())
v &lt;- voronoi(d)
cell13 &lt;- v[[13]] # the point (0, 0, 0), at the center
isBoundedCell(cell13) # TRUE
library(rgl)
open3d(windowRect = c(50, 50, 562, 562))
invisible(lapply(cell13[["cell"]], function(edge) edge$plot()))
</code></pre>

<hr>
<h2 id='getDelaunaySimplices'>Delaunay simplices</h2><span id='topic+getDelaunaySimplices'></span><span id='topic+getDelaunaySimplicies'></span>

<h3>Description</h3>

<p>Get Delaunay simplices (tiles).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDelaunaySimplices(tessellation, hashes = FALSE)

getDelaunaySimplicies(tessellation, hashes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDelaunaySimplices_+3A_tessellation">tessellation</code></td>
<td>
<p>the output of <code><a href="#topic+delaunay">delaunay</a></code></p>
</td></tr>
<tr><td><code id="getDelaunaySimplices_+3A_hashes">hashes</code></td>
<td>
<p>Boolean, whether to return the simplices as hash maps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of simplices of the Delaunay tessellation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
pts &lt;- rbind(
  c(-5, -5,  16),
  c(-5,  8,   3),
  c(4,  -1,   3),
  c(4,  -5,   7),
  c(4,  -1, -10),
  c(4,  -5, -10),
  c(-5,  8, -10),
  c(-5, -5, -10)
)
tess &lt;- delaunay(pts)
getDelaunaySimplices(tess)
</code></pre>

<hr>
<h2 id='IEdge2'>R6 class representing a semi-infinite edge in dimension 2</h2><span id='topic+IEdge2'></span>

<h3>Description</h3>

<p>A semi-infinite edge is given by a vertex, its origin,
and a vector, its direction. Voronoï diagrams possibly have such edges.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>O</code></dt><dd><p>get or set the vertex <code>O</code></p>
</dd>
<dt><code>direction</code></dt><dd><p>get or set the vector <code>direction</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IEdge2-new"><code>IEdge2$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IEdge2-print"><code>IEdge2$print()</code></a>
</p>
</li>
<li> <p><a href="#method-IEdge2-clone"><code>IEdge2$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IEdge2-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>IEdge2</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IEdge2$new(O, direction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>O</code></dt><dd><p>the vertex <code>O</code> (origin)</p>
</dd>
<dt><code>direction</code></dt><dd><p>the vector <code>direction</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>IEdge2</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>iedge &lt;- IEdge2$new(c(1, 1), c(2, 3))
iedge
iedge$O
iedge$O &lt;- c(1, 0)
iedge
</pre>
</div>


<hr>
<a id="method-IEdge2-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an <code>IEdge2</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IEdge2$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>IEdge2$new(c(2, 0), c(3, -1))
</pre>
</div>


<hr>
<a id="method-IEdge2-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IEdge2$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `IEdge2$new`
## ------------------------------------------------

iedge &lt;- IEdge2$new(c(1, 1), c(2, 3))
iedge
iedge$O
iedge$O &lt;- c(1, 0)
iedge

## ------------------------------------------------
## Method `IEdge2$print`
## ------------------------------------------------

IEdge2$new(c(2, 0), c(3, -1))
</code></pre>

<hr>
<h2 id='IEdge3'>R6 class representing a semi-infinite edge in dimension 3</h2><span id='topic+IEdge3'></span>

<h3>Description</h3>

<p>A semi-infinite edge is given by a vertex, its origin,
and a vector, its direction. Voronoï diagrams possibly have such edges.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>O</code></dt><dd><p>get or set the vertex <code>O</code></p>
</dd>
<dt><code>direction</code></dt><dd><p>get or set the vector <code>direction</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IEdge3-new"><code>IEdge3$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IEdge3-print"><code>IEdge3$print()</code></a>
</p>
</li>
<li> <p><a href="#method-IEdge3-clone"><code>IEdge3$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IEdge3-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>IEdge3</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IEdge3$new(O, direction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>O</code></dt><dd><p>the vertex <code>O</code> (origin)</p>
</dd>
<dt><code>direction</code></dt><dd><p>the vector <code>direction</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>IEdge3</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>iedge &lt;- IEdge3$new(c(1, 1, 1), c(1, 2, 3))
iedge
iedge$O
iedge$O &lt;- c(1, 0, 0)
iedge
</pre>
</div>


<hr>
<a id="method-IEdge3-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an <code>IEdge3</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IEdge3$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>IEdge3$new(c(2, 0, 0), c(3, -1, 4))
</pre>
</div>


<hr>
<a id="method-IEdge3-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IEdge3$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `IEdge3$new`
## ------------------------------------------------

iedge &lt;- IEdge3$new(c(1, 1, 1), c(1, 2, 3))
iedge
iedge$O
iedge$O &lt;- c(1, 0, 0)
iedge

## ------------------------------------------------
## Method `IEdge3$print`
## ------------------------------------------------

IEdge3$new(c(2, 0, 0), c(3, -1, 4))
</code></pre>

<hr>
<h2 id='isBoundedCell'>Is this cell bounded?</h2><span id='topic+isBoundedCell'></span>

<h3>Description</h3>

<p>Check whether a Voronoï cell is bounded, i.e. contains only
finite edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isBoundedCell(cell)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isBoundedCell_+3A_cell">cell</code></td>
<td>
<p>a Voronoï cell</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value, whether the cell is bounded.
</p>

<hr>
<h2 id='plotBoundedCell2D'>Plot a bounded Voronoï 2D cell</h2><span id='topic+plotBoundedCell2D'></span>

<h3>Description</h3>

<p>Plot a bounded Voronoï 2D cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBoundedCell2D(
  cell,
  border = "black",
  color = NA,
  check.bounded = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBoundedCell2D_+3A_cell">cell</code></td>
<td>
<p>a bounded Voronoï 2D cell</p>
</td></tr>
<tr><td><code id="plotBoundedCell2D_+3A_border">border</code></td>
<td>
<p>color of the borders of the cell; <code>NA</code> for no color</p>
</td></tr>
<tr><td><code id="plotBoundedCell2D_+3A_color">color</code></td>
<td>
<p>color of the cell; <code>NA</code> for no color</p>
</td></tr>
<tr><td><code id="plotBoundedCell2D_+3A_check.bounded">check.bounded</code></td>
<td>
<p>Boolean, whether to check that the cell is bounded;
set to <code>FALSE</code> for a small speed gain if you know that the cell is
bounded</p>
</td></tr>
<tr><td><code id="plotBoundedCell2D_+3A_...">...</code></td>
<td>
<p>graphical parameters for the borders</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value, this function just plots the cell (more precisely, it adds
the plot of the cell to the current plot).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
centricSquare &lt;- rbind(
  c(-1, 1), c(1, 1), c(1, -1), c(-1, -1), c(0, 0)
)
d &lt;- delaunay(centricSquare)
v &lt;- voronoi(d)
cell5 &lt;- v[[5]]
isBoundedCell(cell5) # TRUE
plot(centricSquare, type = "n", asp = 1, xlab = "x", ylab = "y")
plotBoundedCell2D(cell5, color = "pink")
</code></pre>

<hr>
<h2 id='plotBoundedCell3D'>Plot a bounded Voronoï 3D cell</h2><span id='topic+plotBoundedCell3D'></span>

<h3>Description</h3>

<p>Plot a bounded Voronoï 3D cell with <strong>rgl</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBoundedCell3D(
  cell,
  edgesAsTubes = FALSE,
  tubeRadius,
  tubeColor,
  facetsColor = NA,
  alpha = 1,
  check.bounded = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBoundedCell3D_+3A_cell">cell</code></td>
<td>
<p>a bounded Voronoï 3D cell</p>
</td></tr>
<tr><td><code id="plotBoundedCell3D_+3A_edgesastubes">edgesAsTubes</code></td>
<td>
<p>Boolean, whether to plot edges as tubes or as lines</p>
</td></tr>
<tr><td><code id="plotBoundedCell3D_+3A_tuberadius">tubeRadius</code></td>
<td>
<p>radius of the tubes if <code>edgesAsTubes = TRUE</code></p>
</td></tr>
<tr><td><code id="plotBoundedCell3D_+3A_tubecolor">tubeColor</code></td>
<td>
<p>color of the tubes if <code>edgesAsTubes = TRUE</code></p>
</td></tr>
<tr><td><code id="plotBoundedCell3D_+3A_facetscolor">facetsColor</code></td>
<td>
<p>color of the facets; <code>NA</code> for no color</p>
</td></tr>
<tr><td><code id="plotBoundedCell3D_+3A_alpha">alpha</code></td>
<td>
<p>opacity of the facets, a number between 0 and 1</p>
</td></tr>
<tr><td><code id="plotBoundedCell3D_+3A_check.bounded">check.bounded</code></td>
<td>
<p>Boolean, whether to check that the cell is bounded;
set to <code>FALSE</code> for a small speed gain if you know that the cell is
bounded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value, this function just plots the cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
d &lt;- delaunay(centricCuboctahedron())
v &lt;- voronoi(d)
cell13 &lt;- v[[13]]
isBoundedCell(cell13) # TRUE
library(rgl)
open3d(windowRect = c(50, 50, 562, 562))
plotBoundedCell3D(
  cell13, edgesAsTubes = TRUE, tubeRadius = 0.03, tubeColor = "yellow",
  facetsColor = "navy", alpha = 0.7
)
</code></pre>

<hr>
<h2 id='plotDelaunay2D'>Plot 2D Delaunay tessellation</h2><span id='topic+plotDelaunay2D'></span>

<h3>Description</h3>

<p>Plot a 2D Delaunay tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDelaunay2D(
  tessellation,
  border = "black",
  color = "distinct",
  distinctArgs = list(seedcolors = c("#ff0000", "#00ff00", "#0000ff")),
  randomArgs = list(hue = "random", luminosity = "bright"),
  lty = par("lty"),
  lwd = par("lwd"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDelaunay2D_+3A_tessellation">tessellation</code></td>
<td>
<p>the output of <code><a href="#topic+delaunay">delaunay</a></code></p>
</td></tr>
<tr><td><code id="plotDelaunay2D_+3A_border">border</code></td>
<td>
<p>the color of the borders of the triangles; <code>NULL</code> for
no borders</p>
</td></tr>
<tr><td><code id="plotDelaunay2D_+3A_color">color</code></td>
<td>
<p>controls the filling colors of the triangles, either
<code>FALSE</code> for no color, <code>"random"</code> to use
<code><a href="colorsGen.html#topic+randomColor">randomColor</a></code>, or <code>"distinct"</code> to use
<code><a href="Polychrome.html#topic+createPalette">createPalette</a></code></p>
</td></tr>
<tr><td><code id="plotDelaunay2D_+3A_distinctargs">distinctArgs</code></td>
<td>
<p>if <code>color = "distinct"</code>, a list of arguments
passed to <code><a href="Polychrome.html#topic+createPalette">createPalette</a></code></p>
</td></tr>
<tr><td><code id="plotDelaunay2D_+3A_randomargs">randomArgs</code></td>
<td>
<p>if <code>color = "random"</code>, a list of arguments passed
to <code><a href="colorsGen.html#topic+randomColor">randomColor</a></code></p>
</td></tr>
<tr><td><code id="plotDelaunay2D_+3A_lty">lty</code>, <code id="plotDelaunay2D_+3A_lwd">lwd</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
<tr><td><code id="plotDelaunay2D_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value, just renders a 2D plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># random points in a square
set.seed(314)
library(tessellation)
library(uniformly)
square &lt;- rbind(
  c(-1, 1), c(1, 1), c(1, -1), c(-1, -1)
)
ptsin &lt;- runif_in_cube(10L, d = 2L)
pts &lt;- rbind(square, ptsin)
d &lt;- delaunay(pts)
opar &lt;- par(mar = c(0, 0, 0, 0))
plotDelaunay2D(
  d, xlab = NA, ylab = NA, asp = 1, color = "random",
  randomArgs = list(hue = "random", luminosity = "dark")
)
par(opar)
</code></pre>

<hr>
<h2 id='plotDelaunay3D'>Plot 3D Delaunay tessellation</h2><span id='topic+plotDelaunay3D'></span>

<h3>Description</h3>

<p>Plot a 3D Delaunay tessellation with <strong>rgl</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDelaunay3D(
  tessellation,
  color = "distinct",
  distinctArgs = list(seedcolors = c("#ff0000", "#00ff00", "#0000ff")),
  randomArgs = list(hue = "random", luminosity = "bright"),
  alpha = 0.3,
  exteriorEdgesAsTubes = FALSE,
  tubeRadius,
  tubeColor
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDelaunay3D_+3A_tessellation">tessellation</code></td>
<td>
<p>the output of <code><a href="#topic+delaunay">delaunay</a></code></p>
</td></tr>
<tr><td><code id="plotDelaunay3D_+3A_color">color</code></td>
<td>
<p>controls the filling colors of the tetrahedra, either
<code>FALSE</code> for no color, <code>"random"</code> to use
<code><a href="colorsGen.html#topic+randomColor">randomColor</a></code>, or <code>"distinct"</code> to use
<code><a href="Polychrome.html#topic+createPalette">createPalette</a></code></p>
</td></tr>
<tr><td><code id="plotDelaunay3D_+3A_distinctargs">distinctArgs</code></td>
<td>
<p>if <code>color = "distinct"</code>, a list of arguments
passed to <code><a href="Polychrome.html#topic+createPalette">createPalette</a></code></p>
</td></tr>
<tr><td><code id="plotDelaunay3D_+3A_randomargs">randomArgs</code></td>
<td>
<p>if <code>color = "random"</code>, a list of arguments passed
to <code><a href="colorsGen.html#topic+randomColor">randomColor</a></code></p>
</td></tr>
<tr><td><code id="plotDelaunay3D_+3A_alpha">alpha</code></td>
<td>
<p>opacity, number between 0 and 1</p>
</td></tr>
<tr><td><code id="plotDelaunay3D_+3A_exterioredgesastubes">exteriorEdgesAsTubes</code></td>
<td>
<p>Boolean, whether to plot the exterior edges
as tubes; in order to use this feature, you need to set
<code>exteriorEdges = TRUE</code> in the <code><a href="#topic+delaunay">delaunay</a></code> function</p>
</td></tr>
<tr><td><code id="plotDelaunay3D_+3A_tuberadius">tubeRadius</code></td>
<td>
<p>if <code>exteriorEdgesAsTubes = TRUE</code>, the radius of
the tubes</p>
</td></tr>
<tr><td><code id="plotDelaunay3D_+3A_tubecolor">tubeColor</code></td>
<td>
<p>if <code>exteriorEdgesAsTubes = TRUE</code>, the color of
the tubes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value, just renders a 3D plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
pts &lt;- rbind(
  c(-5, -5,  16),
  c(-5,  8,   3),
  c(4,  -1,   3),
  c(4,  -5,   7),
  c(4,  -1, -10),
  c(4,  -5, -10),
  c(-5,  8, -10),
  c(-5, -5, -10)
)
tess &lt;- delaunay(pts)
library(rgl)
open3d(windowRect = c(50, 50, 562, 562))
plotDelaunay3D(tess, color = "random")
open3d(windowRect = c(50, 50, 562, 562))
plotDelaunay3D(
  tess, exteriorEdgesAsTubes = TRUE, tubeRadius = 0.3, tubeColor = "yellow"
)
</code></pre>

<hr>
<h2 id='plotVoronoiDiagram'>Plot Voronoï diagram</h2><span id='topic+plotVoronoiDiagram'></span>

<h3>Description</h3>

<p>Plot all the bounded cells of a 2D or 3D Voronoï tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVoronoiDiagram(
  v,
  colors = "random",
  distinctArgs = list(seedcolors = c("#ff0000", "#00ff00", "#0000ff")),
  randomArgs = list(hue = "random", luminosity = "bright"),
  alpha = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVoronoiDiagram_+3A_v">v</code></td>
<td>
<p>an output of <code><a href="#topic+voronoi">voronoi</a></code></p>
</td></tr>
<tr><td><code id="plotVoronoiDiagram_+3A_colors">colors</code></td>
<td>
<p>this can be <code>"random"</code> to use random colors for the cells
with <code><a href="colorsGen.html#topic+randomColor">randomColor</a></code>, <code>"distinct"</code> to use
distinct colors with the help of
<code><a href="Polychrome.html#topic+createPalette">createPalette</a></code>, or this can be <code>NA</code>
for no colors, or a vector of colors; the length of this vector
of colors must match the number of bounded cells, which is displayed when
you run the <code><a href="#topic+voronoi">voronoi</a></code> function and that you can also get by
typing <code>attr(v, "nbounded")</code></p>
</td></tr>
<tr><td><code id="plotVoronoiDiagram_+3A_distinctargs">distinctArgs</code></td>
<td>
<p>if <code>colors = "distinct"</code>, a list of arguments
passed to <code><a href="Polychrome.html#topic+createPalette">createPalette</a></code></p>
</td></tr>
<tr><td><code id="plotVoronoiDiagram_+3A_randomargs">randomArgs</code></td>
<td>
<p>if <code>colors = "random"</code>, a list of arguments passed
to <code><a href="colorsGen.html#topic+randomColor">randomColor</a></code></p>
</td></tr>
<tr><td><code id="plotVoronoiDiagram_+3A_alpha">alpha</code></td>
<td>
<p>opacity, a number between 0 and 1
(used when <code>colors</code> is not <code>NA</code>)</p>
</td></tr>
<tr><td><code id="plotVoronoiDiagram_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+plotBoundedCell2D">plotBoundedCell2D</a></code> or
<code><a href="#topic+plotBoundedCell3D">plotBoundedCell3D</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returned value.
</p>


<h3>Note</h3>

<p>Sometimes, it is necessary to set the option <code>degenerate=TRUE</code>
in the <code><a href="#topic+delaunay">delaunay</a></code> function in order to get a correct
Voronoï diagram with the <code>plotVoronoiDiagram</code> function (I don't know
why).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
# 2D example: Fermat spiral
theta &lt;- seq(0, 100, length.out = 300L)
x &lt;- sqrt(theta) * cos(theta)
y &lt;- sqrt(theta) * sin(theta)
pts &lt;- cbind(x,y)
opar &lt;- par(mar = c(0, 0, 0, 0), bg = "black")
# Here is a Fermat spiral:
plot(pts, asp = 1, xlab = NA, ylab = NA, axes = FALSE, pch = 19, col = "white")
# And here is its Voronoï diagram:
plot(NULL, asp = 1, xlim = c(-15, 15), ylim = c(-15, 15),
     xlab = NA, ylab = NA, axes = FALSE)
del &lt;- delaunay(pts)
v &lt;- voronoi(del)
length(Filter(isBoundedCell, v)) # 281 bounded cells
plotVoronoiDiagram(v, colors = viridisLite::turbo(281L))
par(opar)

# 3D example: tetrahedron surrounded by three circles
tetrahedron &lt;-
  rbind(
    c(2*sqrt(2)/3, 0, -1/3),
    c(-sqrt(2)/3, sqrt(2/3), -1/3),
    c(-sqrt(2)/3, -sqrt(2/3), -1/3),
    c(0, 0, 1)
  )
angles &lt;- seq(0, 2*pi, length.out = 91)[-1]
R &lt;- 2.5
circle1 &lt;- t(vapply(angles, function(a) R*c(cos(a), sin(a), 0), numeric(3L)))
circle2 &lt;- t(vapply(angles, function(a) R*c(cos(a), 0, sin(a)), numeric(3L)))
circle3 &lt;- t(vapply(angles, function(a) R*c(0, cos(a), sin(a)), numeric(3L)))
circles &lt;- rbind(circle1, circle2, circle3)
pts &lt;- rbind(tetrahedron, circles)
d &lt;- delaunay(pts, degenerate = TRUE)
v &lt;- voronoi(d)
library(rgl)
open3d(windowRect = c(50, 50, 562, 562))
material3d(lwd = 2)
plotVoronoiDiagram(v)
</code></pre>

<hr>
<h2 id='surface'>Tessellation surface</h2><span id='topic+surface'></span>

<h3>Description</h3>

<p>Exterior surface of the Delaunay tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface(tessellation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface_+3A_tessellation">tessellation</code></td>
<td>
<p>output of <code><a href="#topic+delaunay">delaunay</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, the exterior surface of the Delaunay tessellation
(perimeter in 2D).
</p>


<h3>Note</h3>

<p>It is not guaranteed that this function provides the correct result
for all cases. The exterior surface of the Delaunay tessellation is the
exterior surface of the convex hull of the sites (the points), and you can
get it with the <strong>cxhull</strong> package (by summing the volumes of the
facets). Moreover, I encountered some cases for which I got a correct
result only with the option <code>degenerate=TRUE</code> in the
<code>delaunay</code> function. I will probably remove this function in the
next version.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+volume">volume</a></code>
</p>

<hr>
<h2 id='teapot'>Utah teapot</h2><span id='topic+teapot'></span>

<h3>Description</h3>

<p>Vertices of the Utah teapot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teapot()
</code></pre>


<h3>Value</h3>

<p>A matrix with 1976 rows and 3 columns.
</p>

<hr>
<h2 id='tessellation-imports'>Objects imported from other packages</h2><span id='topic+tessellation-imports'></span><span id='topic+values'></span><span id='topic+keys'></span>

<h3>Description</h3>

<p>These objects are imported from other packages.
Follow the links to their documentation:
<code><a href="hash.html#topic+values">values</a></code>,
<code><a href="hash.html#topic+keys">keys</a></code>.
</p>

<hr>
<h2 id='volume'>Tessellation volume</h2><span id='topic+volume'></span>

<h3>Description</h3>

<p>The volume of the Delaunay tessellation, that is, the volume of
the convex hull of the sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volume(tessellation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volume_+3A_tessellation">tessellation</code></td>
<td>
<p>output of <code><a href="#topic+delaunay">delaunay</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, the volume of the Delaunay tessellation (area in 2D).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surface">surface</a></code>
</p>

<hr>
<h2 id='voronoi'>Voronoï tessellation</h2><span id='topic+voronoi'></span>

<h3>Description</h3>

<p>Voronoï tessellation from Delaunay tessellation; this is a list
of pairs made of a site (a vertex) and a list of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi(tessellation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi_+3A_tessellation">tessellation</code></td>
<td>
<p>output of <code><a href="#topic+delaunay">delaunay</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of pairs representing the Voronoï tessellation. Each
<code><a href="sets.html#topic+pair">pair</a></code> is named: the first component is called
<code>"site"</code>, and the second component is called <code>"cell"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isBoundedCell">isBoundedCell</a></code>, <code><a href="#topic+cellVertices">cellVertices</a></code>,
<code><a href="#topic+plotBoundedCell2D">plotBoundedCell2D</a></code>, <code><a href="#topic+plotBoundedCell3D">plotBoundedCell3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tessellation)
d &lt;- delaunay(centricCuboctahedron())
v &lt;- voronoi(d)
# the Voronoï diagram has 13 cells (one for each site):
length(v)
# there is only one bounded cell:
length(Filter(isBoundedCell, v)) # or attr(v, "nbounded")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
