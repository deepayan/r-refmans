<!DOCTYPE html><html><head><title>Help for package haarfisz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {haarfisz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#haarfisz-package'><p>A Haar-Fisz Algorithm for Poisson Intensity Estimation.</p></a></li>
<li><a href='#denoise.poisson'><p>denoise.poisson</p></a></li>
<li><a href='#hf.bt'><p>hf.bt</p></a></li>
<li><a href='#hf.cv'><p>hf.cv</p></a></li>
<li><a href='#hf.tiu'><p>hf.tiu</p></a></li>
<li><a href='#hf.u'><p>hf.u</p></a></li>
<li><a href='#hft'><p>hft</p></a></li>
<li><a href='#hft.inv'><p>hft.inv</p></a></li>
<li><a href='#shift.sequence'><p>shift.sequence</p></a></li>
<li><a href='#xquake'><p>xquake</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Software to Perform Haar Fisz Transforms</td>
</tr>
<tr>
<td>Version:</td>
<td>4.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-01</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), wavethresh</td>
</tr>
<tr>
<td>Description:</td>
<td>A Haar-Fisz algorithm for Poisson intensity estimation.
	Will denoise Poisson distributed sequences where
        underlying intensity is not constant. Uses the multiscale
        variance-stabilization method called the Haar-Fisz transform.
        Contains functions to carry out the forward and inverse
        Haar-Fisz transform and denoising on near-Gaussian sequences.
        Can also carry out cycle-spinning.
	Main reference: Fryzlewicz, P. and Nason, G.P. (2004)
	"A Haar-Fisz algorithm for Poisson intensity estimation."
        Journal of Computational and Graphical Statistics,
        13, 621-638. &lt;<a href="https://doi.org/10.1198%2F106186004X2697">doi:10.1198/106186004X2697</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-01 10:02:02 UTC; guynason</td>
</tr>
<tr>
<td>Author:</td>
<td>Piotr Fryzlewicz [aut],
  Guy Nason [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guy Nason &lt;g.nason@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-01 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='haarfisz-package'>A Haar-Fisz Algorithm for Poisson Intensity Estimation.
</h2><span id='topic+haarfisz-package'></span><span id='topic+haarfisz'></span>

<h3>Description</h3>

<p>Package to denoise Poisson distributed sequence where
underlying intensity is not constant. Uses the multiscale
variance-stabilization method called the Haar-Fisz transform.
Contains functions to carry out the foward and inverse
Haar-Fisz transform and denoising on near-Gaussian sequences.
Can also carry out cycle-spinning.
</p>


<h3>Details</h3>

<p>Package to denoise Poisson distributed sequence where
underlying intensity is not constant. Uses the multiscale
variance-stabilization method called the Haar-Fisz transform.
Contains functions to carry out the foward and inverse
Haar-Fisz transform and denoising on near-Gaussian sequences.
Can also carry out cycle-spinning.
See main routine <code><a href="#topic+denoise.poisson">denoise.poisson</a></code>
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz&gt;
</p>


<h3>References</h3>

<p>Fryzlewicz, P. (2003) Wavelet Techniques for Time Series and Poisson
Data. <em>PhD Thesis</em>, University of Bristol, Bristol, UK
<a href="https://www.ma.imperial.ac.uk/~gnason/Research/MAPZFthesis.ps.gz">https://www.ma.imperial.ac.uk/~gnason/Research/MAPZFthesis.ps.gz</a>
</p>
<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a> 
</p>
<p>Nason, G.P. (2008) <em>Wavelet Methods in Statistics with R.</em>
Springer: New York (Section 6.4)
<a href="https://doi.org/10.1007/978-0-387-75961-6">doi:10.1007/978-0-387-75961-6</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise.poisson">denoise.poisson</a></code>, <code><a href="#topic+hft">hft</a></code>, <code><a href="#topic+hft.inv">hft.inv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#
# Main Poisson denoising function is denoise.poisson
#
# Forward Haar-Fisz transform is hft
#
# Inverse Haar-Fisz transform is hft.inv
</code></pre>

<hr>
<h2 id='denoise.poisson'>denoise.poisson</h2><span id='topic+denoise.poisson'></span>

<h3>Description</h3>

<p>Main routine of the package. Estimates the deterministic discretised intensity of a one-dimensional Poisson process using the Haar-Fisz transformation and partial cycle spinning. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoise.poisson(y, meth.1 = hf.bt, cs.1 = 50, meth.2 = hf.cv, cs.2 = 50, hybrid = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoise.poisson_+3A_y">y</code></td>
<td>
<p>The vector of Poisson counts, its length must be a power of 2.</p>
</td></tr>
<tr><td><code id="denoise.poisson_+3A_meth.1">meth.1</code></td>
<td>
<p>Unquoted name of an S-Plus routine for denoising Gaussian contaminated vectors. Must take and return a vector of length <code class="reqn">2^J</code> where J is an integer. The following routines supplied in this package can be used here: <code><a href="#topic+hf.u">hf.u</a></code>, <code><a href="#topic+hf.cv">hf.cv</a></code>, <code><a href="#topic+hf.bt">hf.bt</a></code>, <code><a href="#topic+hf.tiu">hf.tiu</a></code>. The user can define and plug in his or her own routines here. </p>
</td></tr>
<tr><td><code id="denoise.poisson_+3A_cs.1">cs.1</code></td>
<td>
<p>The number of cycle spins to be performed with <code>meth.1</code>. Must be between 1 and N-1, where N is the length of <code>y</code>.</p>
</td></tr> 
<tr><td><code id="denoise.poisson_+3A_meth.2">meth.2</code></td>
<td>
<p>Of the same type as <code>meth.1</code>.</p>
</td></tr>
<tr><td><code id="denoise.poisson_+3A_cs.2">cs.2</code></td>
<td>
<p>The number of cycle spins to be performed with <code>meth.2</code>.</p>
</td></tr>
<tr><td><code id="denoise.poisson_+3A_hybrid">hybrid</code></td>
<td>
<p>If set to TRUE, then the estimates are computed using both <code>meth.1</code> with <code>cs.1</code> cycle spins, and <code>meth.2</code> with <code>cs.2</code> cycle spins, and the final estimate is taken to be the average of these two. If set to <code>FALSE</code>, only <code>meth.1</code> with <code>cs.1</code> cycle spins is used to compute the final estimate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given input sequence, basic operation of the code
performs a cyclic shift on
the data. Then applies the Haar-Fisz transform, then one 
of the denoising methods (specified by <code>meth.1</code>),
then the inverse Haar-Fisz transform and then a shift back.
This is repeated for <code>cs.1</code> cyclic shifts and the results of
all shifts returned.
</p>


<h3>Value</h3>

<p>Returns vector of the same length as the input <code>y</code> but is the
denoised estimate.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hft">hft</a></code>, <code><a href="#topic+hft.inv">hft.inv</a></code>,
<code><a href="#topic+hf.u">hf.u</a></code>, <code><a href="#topic+hf.cv">hf.cv</a></code>, <code><a href="#topic+hf.bt">hf.bt</a></code>, <code><a href="#topic+hf.tiu">hf.tiu</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Apply denoise.poisson to xquake data
#
data(xquake)
xquake.denoised &lt;- denoise.poisson(xquake)
#
# Now plot the original data and it's denoised version in red
#
plot(xquake, type="l")
lines(xquake.denoised, col=2)
</code></pre>

<hr>
<h2 id='hf.bt'>hf.bt</h2><span id='topic+hf.bt'></span>

<h3>Description</h3>

<p>Denoises a Gaussian contaminated vector using a version of the wavelet-based &ldquo;greedy tree&quot; algorithm by Baraniuk, see references. 
Note: this function does not actually do any Haar-Fisz transform, it is
a homogeneous variance Gaussian denoising function, which is used by
the <span class="pkg">haarfisz</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hf.bt(x, filter.number = 1, family = "DaubExPhase", min.level = 3, noise.level = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hf.bt_+3A_x">x</code></td>
<td>
<p>The noisy vector, its length must be a power of 2.</p>
</td></tr>
<tr><td><code id="hf.bt_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the analysing wavelet. Can be set to 1, 2, ..., 10 for <code>family == "DaubExPhase"</code>, or to 4, 5, ..., 10 for <code>family == "DaubLeAsymm"</code>.</p>
</td></tr>
<tr><td><code id="hf.bt_+3A_family">family</code></td>
<td>
<p>The family of wavelet bases from which the wavelet <code>filter.number</code> is chosen. Can be set to &quot;DaubExPhase&quot; or &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="hf.bt_+3A_min.level">min.level</code></td>
<td>
<p>The minimum level thresholded.</p>
</td></tr>
<tr><td><code id="hf.bt_+3A_noise.level">noise.level</code></td>
<td>
<p>Standard deviation of the noise, can be set to a positive number or NULL; in the latter case it will be estimated using MAD.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Denoised version of <code>x</code>.</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>Baraniuk, R. G. (1999) Optimal tree approximation with wavelets.
Pages 206-214 of Unser, M.A., Aldroubi, A. and Laine, A.F. (eds),
<em>Wavelet Applications in Signal and Image Processing VII</em>,
Proceedings of SPIE <b>3813</b>. SPIE.
<a href="https://doi.org/10.1117/12.366780">doi:10.1117/12.366780</a>
</p>
<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate simple sinusoidal test signal
#
test.sig &lt;- sin(seq(from=0, to=6*pi, length=128))
#
# Invent simulated noisy signal
#
test.dat &lt;- test.sig + rnorm(128, sd=0.2)
#
# Denoise using hf.bt
#
test.est &lt;- hf.bt(test.dat)
#
# Now plot the results: the truth, the noisy signal, the estimate
#
ts.plot(test.dat)
lines(test.est, col=2)
lines(test.sig, col=3, lty=2)
</code></pre>

<hr>
<h2 id='hf.cv'>hf.cv</h2><span id='topic+hf.cv'></span>

<h3>Description</h3>

<p>Denoises a Gaussian contaminated vector using wavelet thresholding with a threshold chosen by &ldquo;leave-half-out&quot; cross-validation. 
Note: this function does not actually do any Haar-Fisz transform, it is
a homogeneous variance Gaussian denoising function, which is used by
the <span class="pkg">haarfisz</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hf.cv(x, filter.number = 1, family = "DaubExPhase", min.level = 3, type = "hard") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hf.cv_+3A_x">x</code></td>
<td>
<p>The noisy vector, its length must be a power of 2.</p>
</td></tr>
<tr><td><code id="hf.cv_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the analysing wavelet. Can be set to 1, 2, ..., 10 for <code>family == "DaubExPhase"</code>, or to 4, 5, ..., 10 for <code>family == "DaubLeAsymm"</code>.</p>
</td></tr>
<tr><td><code id="hf.cv_+3A_family">family</code></td>
<td>
<p>The family of wavelet bases from which the wavelet <code>filter.number</code> is chosen. Can be set to &quot;DaubExPhase&quot; or &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="hf.cv_+3A_min.level">min.level</code></td>
<td>
<p>The minimum level thresholded.</p>
</td></tr>
<tr><td><code id="hf.cv_+3A_type">type</code></td>
<td>
<p>Type of thresholding, can be set to &quot;hard&quot; or &quot;soft&quot;.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Uses <code><a href="wavethresh.html#topic+threshold">threshold</a></code>,
<code><a href="wavethresh.html#topic+wd">wd</a></code> and
<code><a href="wavethresh.html#topic+AvBasis">AvBasis</a></code></p>


<h3>Value</h3>

<p>Denoised version of <code>x</code> 
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a>
</p>


<h3>See Also</h3>

<p><code><a href="wavethresh.html#topic+threshold">threshold</a></code>,
<code><a href="wavethresh.html#topic+wd">wd</a></code>,
<code><a href="wavethresh.html#topic+AvBasis">AvBasis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate simple sinusoidal test signal
#
test.sig &lt;- sin(seq(from=0, to=6*pi, length=128))
#
# Invent simulated noisy signal
#
test.dat &lt;- test.sig + rnorm(128, sd=0.2)
#
# Denoise using hf.bt
#
test.est &lt;- hf.cv(test.dat)
#
# Now plot the results: the truth, the noisy signal, the estimate
#
ts.plot(test.dat)
lines(test.est, col=2)
lines(test.sig, col=3, lty=2)
</code></pre>

<hr>
<h2 id='hf.tiu'>hf.tiu</h2><span id='topic+hf.tiu'></span>

<h3>Description</h3>

<p>Denoises a Gaussian contaminated vector using translation-invariant hard wavelet thresholding with the universal threshold. 
Note: this function does not actually do any Haar-Fisz transform, it is
a homogeneous variance Gaussian denoising function, which is used by
the <span class="pkg">haarfisz</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hf.tiu(x, filter.number = 1, family = "DaubExPhase", min.level = 3, noise.level = 1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hf.tiu_+3A_x">x</code></td>
<td>
<p>The noisy vector, its length must be a power of 2.</p>
</td></tr>
<tr><td><code id="hf.tiu_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the analysing wavelet. Can be set to 1, 2, ..., 10 for <code>family == "DaubExPhase"</code>, or to 4, 5, ..., 10 for <code>family == "DaubLeAsymm"</code>.</p>
</td></tr>
<tr><td><code id="hf.tiu_+3A_family">family</code></td>
<td>
<p>The family of wavelet bases from which the wavelet <code>filter.number</code> is chosen. Can be set to &quot;DaubExPhase&quot; or &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="hf.tiu_+3A_min.level">min.level</code></td>
<td>
<p>The minimum level thresholded.</p>
</td></tr>
<tr><td><code id="hf.tiu_+3A_noise.level">noise.level</code></td>
<td>
<p>Standard deviation of the noise, can be set to a positive number or to an estimate (a function of x).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="wavethresh.html#topic+threshold">threshold</a></code>,
<code><a href="wavethresh.html#topic+wd">wd</a></code> and
<code><a href="wavethresh.html#topic+AvBasis">AvBasis</a></code></p>


<h3>Value</h3>

<p>Denoised version of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a>
</p>


<h3>See Also</h3>

<p><code><a href="wavethresh.html#topic+threshold">threshold</a></code>,
<code><a href="wavethresh.html#topic+wd">wd</a></code>,
<code><a href="wavethresh.html#topic+AvBasis">AvBasis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate simple sinusoidal test signal
#
test.sig &lt;- sin(seq(from=0, to=6*pi, length=128))
#
# Invent simulated noisy signal
#
test.dat &lt;- test.sig + rnorm(128, sd=0.2)
#
# Denoise using hf.bt
#
test.est &lt;- hf.tiu(test.dat)
#
# Now plot the results: the truth, the noisy signal, the estimate
#
ts.plot(test.dat)
lines(test.est, col=2)
lines(test.sig, col=3, lty=2)
</code></pre>

<hr>
<h2 id='hf.u'>hf.u</h2><span id='topic+hf.u'></span>

<h3>Description</h3>

<p>Denoises a Gaussian contaminated vector using wavelet thresholding with the universal threshold. 
Note: this function does not actually do any Haar-Fisz transform, it is
a homogeneous variance Gaussian denoising function, which is used by
the <span class="pkg">haarfisz</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hf.u(x, filter.number = 10, family = "DaubLeAsymm", min.level = 3, type = "hard")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hf.u_+3A_x">x</code></td>
<td>
<p>The noisy vector, its length must be a power of 2.</p>
</td></tr>
<tr><td><code id="hf.u_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number of the analysing wavelet. Can be set to 1, 2, ..., 10 for <code>family == "DaubExPhase"</code>, or to 4, 5, ..., 10 for <code>family == "DaubLeAsymm"</code>.</p>
</td></tr>
<tr><td><code id="hf.u_+3A_family">family</code></td>
<td>
<p>The family of wavelet bases from which the wavelet <code>filter.number</code> is chosen. Can be set to &quot;DaubExPhase&quot; or &quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="hf.u_+3A_min.level">min.level</code></td>
<td>
<p>The minimum level thresholded.</p>
</td></tr>
<tr><td><code id="hf.u_+3A_type">type</code></td>
<td>
<p>Type of thresholding, can be set to hard or soft</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="wavethresh.html#topic+threshold">threshold</a></code>,
<code><a href="wavethresh.html#topic+wd">wd</a></code> and
<code><a href="wavethresh.html#topic+AvBasis">AvBasis</a></code></p>


<h3>Value</h3>

<p>Denoised version of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a>
</p>


<h3>See Also</h3>

<p><code><a href="wavethresh.html#topic+threshold">threshold</a></code>,
<code><a href="wavethresh.html#topic+wd">wd</a></code>,
<code><a href="wavethresh.html#topic+AvBasis">AvBasis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate simple sinusoidal test signal
#
test.sig &lt;- sin(seq(from=0, to=6*pi, length=128))
#
# Invent simulated noisy signal
#
test.dat &lt;- test.sig + rnorm(128, sd=0.2)
#
# Denoise using hf.bt
#
test.est &lt;- hf.u(test.dat)
#
# Now plot the results: the truth, the noisy signal, the estimate
#
ts.plot(test.dat)
lines(test.est, col=2)
lines(test.sig, col=3, lty=2)
</code></pre>

<hr>
<h2 id='hft'>hft</h2><span id='topic+hft'></span>

<h3>Description</h3>

<p>Performs the (forward) Haar-Fisz transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hft(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hft_+3A_data">data</code></td>
<td>
<p>A vector of Poisson counts, its length must be a power of 2</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The Haar-Fisz for Poisson works, roughly speaking, by taking
the Haar wavelet transform of <code>data</code>. Then dividing the
mother wavelet coefficients by the respective father coefficients,
and replacing the results of the divisions back into the same
coefficient locations, and then carrying out an inverse
Haar wavelet transform. This produces a nearer-Gaussian variance
stabilized version of the original (or a version of the underlying
intensity which is close to an 'intensity PLUS homogeneous
Gaussian noise' signal, which is easier to denoise using &lsquo;standard&rsquo;
methods.
</p>
<p>The inverse transform is <code><a href="#topic+hft.inv">hft.inv</a></code></p>


<h3>Value</h3>

<p>The Haar-Fisz transform of <code>data</code>, which will be the same
length as <code>data</code>. 
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise.poisson">denoise.poisson</a></code>,
<code><a href="#topic+hft.inv">hft.inv</a></code>,
<code><a href="#topic+hf.bt">hf.bt</a></code>,
<code><a href="#topic+hf.cv">hf.cv</a></code>,
<code><a href="#topic+hf.u">hf.u</a></code>,
<code><a href="#topic+hf.tiu">hf.tiu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate Poisson data, half with one intensity, and half with a larger one
#
v &lt;- c( rpois(64, lambda=1), rpois(64, lambda=10))
#
# Plot it to note that the variation is bigger in the second half
# (and the mean, but this is not important for this bit)
#
ts.plot(v)
#
# Now do the Haar-Fisz transform
#
vhft &lt;- hft(v)
#
# Now plot this, and see that the variance of the second bit is now comparable
# to the first
#
ts.plot(vhft)
</code></pre>

<hr>
<h2 id='hft.inv'>hft.inv</h2><span id='topic+hft.inv'></span>

<h3>Description</h3>

<p>Performs the inverse Haar-Fisz transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hft.inv(data) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hft.inv_+3A_data">data</code></td>
<td>
<p>Vector of length <code class="reqn">2^J</code> where J is an integer</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The inverse Haar-Fisz transform of <code>data</code>
(vector of the same length as <code>data</code>).  </p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise.poisson">denoise.poisson</a></code>, <code><a href="#topic+hft">hft</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make up test set (mimics sequence with half low intensity, followed by
#  half high intensity)
#
test.set &lt;-  c(8,5,6,3, 30,40,20,35)
#
# Do forward HFT
#
test.hft &lt;- hft(test.set)
test.hft
# [1] 16.38621 15.20951 15.65216 14.23795 21.20421 22.89452 19.27753 22.13791
#
# Do inverse HFT
#
test.back &lt;- hft.inv(test.hft)
test.back
# [1]  8  5  6  3 30 40 20 35
#
# Same as original
#
</code></pre>

<hr>
<h2 id='shift.sequence'>shift.sequence</h2><span id='topic+shift.sequence'></span>

<h3>Description</h3>

<p>One of my functions to resolve issues for a similar function that seems to have been forgotten in haarfisz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.sequence(v, places, dir="right")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.sequence_+3A_v">v</code></td>
<td>
<p>Vector to shift</p>
</td></tr>
<tr><td><code id="shift.sequence_+3A_places">places</code></td>
<td>
<p>The number of places to shift</p>
</td></tr>
<tr><td><code id="shift.sequence_+3A_dir">dir</code></td>
<td>
<p>Whether the shift should be right or left</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a sequence input and shifts it to the left or right by the specified number of places. This is a circular shift. For example, when shifting
to the right, any numbers that drop off are appended circularly to the front,
etc.
</p>


<h3>Value</h3>

<p>a shifted output sequence.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>Fryzlewicz, P. and Nason, G.P. (2004) A Haar-Fisz algorithm for Poisson
intensity estimation.
<em>Journal of Computational and Graphical Statistics</em>,
<b>13</b>, 621-638. <a href="https://doi.org/10.1198/106186004X2697">doi:10.1198/106186004X2697</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Shift 1:10 one place to the right
#
shift.sequence(1:10,1, dir="right")
#  [1] 10  1  2  3  4  5  6  7  8  9

#
# Shift 1:10 twos place to the right
#
shift.sequence(1:10,2, dir="right")
#  [1]  9 10  1  2  3  4  5  6  7  8

#
# Shift 1:10 one place to the left
#
shift.sequence(1:10,1, dir="left")
# [1]  2  3  4  5  6  7  8  9 10  1
</code></pre>

<hr>
<h2 id='xquake'>xquake</h2><span id='topic+xquake'></span>

<h3>Description</h3>

<p>Time series of the number of earthquakes of magnitude &gt;= 3.0 which occurred in Northern California in 1024 weeks, the last week being 29/11 &ndash; 05/12/2000. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(xquake)</code></pre>


<h3>Source</h3>

<p>The series was composed using the data obtained from the Northern California Earthquake Data Center. 
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
