<!DOCTYPE html><html><head><title>Help for package habtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {habtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#cell_count_1d'><p>Count filled cells in 1D</p></a></li>
<li><a href='#cell_count_2d'><p>Count filled cells in 2D</p></a></li>
<li><a href='#cell_count_3d'><p>Count filled cells 3D</p></a></li>
<li><a href='#centroid'><p>Calculate the centroid of 3D points</p></a></li>
<li><a href='#circularity'><p>Calculate circularity of a 2D shape</p></a></li>
<li><a href='#convexity'><p>Calculate convexity of a 3D mesh</p></a></li>
<li><a href='#csf'><p>Calculate mechanical shape factor</p></a></li>
<li><a href='#dem_crop'><p>Crop DEM around points</p></a></li>
<li><a href='#dem_sample'><p>Sample a random DEM with specified size from a larger DEM</p></a></li>
<li><a href='#dem_split'><p>Split DEM into smaller tiles</p></a></li>
<li><a href='#dem_to_points'><p>Transform DEM to 3D pointcloud of raster corners</p></a></li>
<li><a href='#detect_drop'><p>Detect a sudden drop, edge, or overhang in a DEM</p></a></li>
<li><a href='#extent'><p>Calculate extent of a 3D object</p></a></li>
<li><a href='#fd'><p>Calculate fractal dimension</p></a></li>
<li><a href='#fd_area'><p>Calculate fractal dimension using the surface area method</p></a></li>
<li><a href='#fd_boxes'><p>Calculate fractal dimension using the box counting method</p></a></li>
<li><a href='#fd_cubes'><p>Calculate fractal dimension using the cube counting method</p></a></li>
<li><a href='#fd_diagnose'><p>Diagnose fractal dimension</p></a></li>
<li><a href='#fd_hvar'><p>Calculate fractal Dimension using the height variation method</p></a></li>
<li><a href='#fd_sd'><p>Calculate fractal Dimension using the standard deviation method</p></a></li>
<li><a href='#horseshoe'><p>Horseshoe reef</p></a></li>
<li><a href='#hr'><p>Calculate height range</p></a></li>
<li><a href='#hvar'><p>Calculate height variation in cells at different scales</p></a></li>
<li><a href='#mcap'><p>Montipora capitata</p></a></li>
<li><a href='#mcap2'><p>Montipora capitata 2</p></a></li>
<li><a href='#mesh_to_2d'><p>Transform 3D mesh into 2D outline</p></a></li>
<li><a href='#mesh_to_dem'><p>Transform 3D mesh to DEM</p></a></li>
<li><a href='#mesh_to_points'><p>Transform mesh to 3D point cloud</p></a></li>
<li><a href='#mid_find'><p>Find midpoint of a DEM</p></a></li>
<li><a href='#packing'><p>Calculate packing of 3D object</p></a></li>
<li><a href='#perimeter'><p>Calculate perimeter of a 2D shape</p></a></li>
<li><a href='#planar'><p>Calculates planar area of a mesh</p></a></li>
<li><a href='#rdh'><p>Calculate rugosity, fractal dimension, and height for a DEM</p></a></li>
<li><a href='#rdh_theory'><p>Calculate metric based on geometric plane equation</p></a></li>
<li><a href='#rg'><p>Calculate rugosity</p></a></li>
<li><a href='#sa_triangle'><p>Calculate surface area of triangle</p></a></li>
<li><a href='#scale_area'><p>Re-scale mesh based on a fixed area</p></a></li>
<li><a href='#scale_volume'><p>Re-scale mesh based on a fixed volume of 1</p></a></li>
<li><a href='#set_origin'><p>Set the origin of a mesh</p></a></li>
<li><a href='#sim_circle'><p>Simulate a circle</p></a></li>
<li><a href='#sim_dem'><p>Simulates a fractal DEM</p></a></li>
<li><a href='#sma'><p>Calculate second moment of area</p></a></li>
<li><a href='#smv'><p>Calculate second moment of volume</p></a></li>
<li><a href='#sphericity'><p>Calculate sphericity of a 3D object</p></a></li>
<li><a href='#surface_area'><p>Calculate surface area</p></a></li>
<li><a href='#svol_triangle'><p>Calculate signed volume of triangle</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools and Metrics for 3D Surfaces and Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>
    A collection of functions for sampling and simulating 3D surfaces and objects 
    and estimating metrics like rugosity, fractal dimension, convexity, sphericity, circularity, 
    second moments of area and volume, and more.   </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jmadinlab.github.io/habtools/">https://jmadinlab.github.io/habtools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmadinlab/habtools/issues">https://github.com/jmadinlab/habtools/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>raster (&ge; 3.5), terra, methods, Rvcg, sp, geometry,
concaveman, magrittr, purrr, dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, rgl, parallel, ggplot2, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-01 00:40:18 UTC; nina</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Madin <a href="https://orcid.org/0000-0002-5005-6227"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nina Schiettekatte
    <a href="https://orcid.org/0000-0002-1925-3484"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nina Schiettekatte &lt;nina.schiettekatte@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-01 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='cell_count_1d'>Count filled cells in 1D</h2><span id='topic+cell_count_1d'></span>

<h3>Description</h3>

<p>A helper function for segment, box and cube counting fractal methods.
The function divide the array into <code>n</code> pieces and counts how many are
occupied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_count_1d(pts, xmin, xmax, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_count_1d_+3A_pts">pts</code></td>
<td>
<p>Data frame with x coordinates</p>
</td></tr>
<tr><td><code id="cell_count_1d_+3A_xmin">xmin</code></td>
<td>
<p>Minimum x-value</p>
</td></tr>
<tr><td><code id="cell_count_1d_+3A_xmax">xmax</code></td>
<td>
<p>Maximum x-value</p>
</td></tr>
<tr><td><code id="cell_count_1d_+3A_n">n</code></td>
<td>
<p>Multiplier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of filled cells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts &lt;- data.frame(x = rnorm(200, 0, 5))
cell_count_1d(pts, xmin = min(pts$x), xmax = max(pts$x), n = 5)


</code></pre>

<hr>
<h2 id='cell_count_2d'>Count filled cells in 2D</h2><span id='topic+cell_count_2d'></span>

<h3>Description</h3>

<p>A helper function for segment, box and cube counting fractal methods.
The function divide the array into <code>n</code> pieces and counts how many are
occupied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_count_2d(pts, xmin, xmax, ymin, ymax, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_count_2d_+3A_pts">pts</code></td>
<td>
<p>Data frame with x and y coordinates</p>
</td></tr>
<tr><td><code id="cell_count_2d_+3A_xmin">xmin</code></td>
<td>
<p>Minimum x-value</p>
</td></tr>
<tr><td><code id="cell_count_2d_+3A_xmax">xmax</code></td>
<td>
<p>Maximum x-value</p>
</td></tr>
<tr><td><code id="cell_count_2d_+3A_ymin">ymin</code></td>
<td>
<p>Minimum y-value</p>
</td></tr>
<tr><td><code id="cell_count_2d_+3A_ymax">ymax</code></td>
<td>
<p>Maximum y-value</p>
</td></tr>
<tr><td><code id="cell_count_2d_+3A_n">n</code></td>
<td>
<p>Multiplier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of filled cells
</p>

<hr>
<h2 id='cell_count_3d'>Count filled cells 3D</h2><span id='topic+cell_count_3d'></span>

<h3>Description</h3>

<p>A helper function for segment, box and cube counting fractal methods.
The function divide the array into <code>n</code> pieces and counts how many are
occupied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_count_3d(pts, xmin, xmax, ymin, ymax, zmin, zmax, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_count_3d_+3A_pts">pts</code></td>
<td>
<p>Data frame with x, y, and z coordinates</p>
</td></tr>
<tr><td><code id="cell_count_3d_+3A_xmin">xmin</code></td>
<td>
<p>Minimum x-value</p>
</td></tr>
<tr><td><code id="cell_count_3d_+3A_xmax">xmax</code></td>
<td>
<p>Maximum x-value</p>
</td></tr>
<tr><td><code id="cell_count_3d_+3A_ymin">ymin</code></td>
<td>
<p>Minimum y-value</p>
</td></tr>
<tr><td><code id="cell_count_3d_+3A_ymax">ymax</code></td>
<td>
<p>Maximum y-value</p>
</td></tr>
<tr><td><code id="cell_count_3d_+3A_zmin">zmin</code></td>
<td>
<p>Minimum z-value</p>
</td></tr>
<tr><td><code id="cell_count_3d_+3A_zmax">zmax</code></td>
<td>
<p>Maximum z-value</p>
</td></tr>
<tr><td><code id="cell_count_3d_+3A_n">n</code></td>
<td>
<p>Multiplier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of filled cells
</p>

<hr>
<h2 id='centroid'>Calculate the centroid of 3D points</h2><span id='topic+centroid'></span>

<h3>Description</h3>

<p>Calculates the centroid for a given set of XYZ coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_+3A_data">data</code></td>
<td>
<p>A data frame with x, y, and z coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coordinates of the centroid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mesh_to_points(mcap)
centroid(data)
</code></pre>

<hr>
<h2 id='circularity'>Calculate circularity of a 2D shape</h2><span id='topic+circularity'></span>

<h3>Description</h3>

<p>The perimeter of the 2D shape is divided by the perimeter of a circle with
the same area as the shape. The more irregular the shape is, the closer the
output value is to zero. The closer the shape is to a circle, the closer
the output value is to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circularity(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circularity_+3A_data">data</code></td>
<td>
<p>A data frame with the first two columns x and y coordinates, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value between 0 (infinitely irregular) and 1 (a perfect circle).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sphericity">sphericity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcap_2d &lt;- mesh_to_2d(mcap)
plot(mcap_2d, asp=1)
circularity(mcap_2d)

circ &lt;- sim_circle() # simulate xy coordinates for a circle
plot(circ, asp=1)
circularity(circ)

</code></pre>

<hr>
<h2 id='convexity'>Calculate convexity of a 3D mesh</h2><span id='topic+convexity'></span>

<h3>Description</h3>

<p>The ratio of the volume of the object and the volume of the convex
hull around the object. Objects with fewer concavities will be closer to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convexity(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convexity_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.
#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The convexity value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convexity(mcap)
</code></pre>

<hr>
<h2 id='csf'>Calculate mechanical shape factor</h2><span id='topic+csf'></span>

<h3>Description</h3>

<p>Calculates mechanical vulnerability of rigid, cantilever-type
structural elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csf(mesh, z_min, res, keep_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csf_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
<tr><td><code id="csf_+3A_z_min">z_min</code></td>
<td>
<p>The z plane about which csf should be calculated. Defaults to min(z).</p>
</td></tr>
<tr><td><code id="csf_+3A_res">res</code></td>
<td>
<p>The resolution to be used for the calculation. Defaults to the resolution of the mesh.</p>
</td></tr>
<tr><td><code id="csf_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical. Return list with supplemental info? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the mechanical vulnerability of a
structural element, like a hard coral colony, to fluid flow. While
developed for corals, and originally called the Colony Shape Factor
(CSF), the function is applicable to any attached, rigid cantilever
type structure. CSF is dimensionless and can be used to compare the
vulnerability among structures. Mechanistically, if the CSF of a
structure becomes greater than the dislodgement mechanical threshold,
breakage occurs. This threshold is a function of material tensile
strength and inversely related to fluid velocity and density
(Madin &amp; Connolly 2006).
</p>


<h3>Value</h3>

<p>A value for csf or if keep_data = TRUE, a list containing the
colony shape factor (csf), the parallel to flow (dy) and perpendicular
(dx) diameters of the cantilever base, and the bending moment (mom).
</p>


<h3>Note</h3>

<p>The orientation of the 3D mesh is important for this function.
The function assumes the fluid flow is parallel with the y-axis.
The function also assumes the base of the cantilever over which the
bending moment acts can be approximated as an ellipse with the diameter
on the y-axis parallel with flow (dy). You can set a z_min if the base
of your mesh is not flat at the base (i.e., shift the plane upon which
the cantilever is attached upwards). The function output includes dy
and dx for monitoring anticipated values.
</p>


<h3>References</h3>

<p>Madin JS &amp; Connolly SR (2006) Ecological consequences of major hydrodynamic disturbances on coral reefs. Nature. 444:477-480.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csf(mcap, z_min = -3.65)
csf(mcap, z_min = -3.65, keep_data = TRUE)
</code></pre>

<hr>
<h2 id='dem_crop'>Crop DEM around points</h2><span id='topic+dem_crop'></span>

<h3>Description</h3>

<p>A function for sampling a DEM by cropping squares of a given size around xy coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dem_crop(data, x0, y0, L, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dem_crop_+3A_data">data</code></td>
<td>
<p>A DEM in RasterLayer format.</p>
</td></tr>
<tr><td><code id="dem_crop_+3A_x0">x0</code></td>
<td>
<p>A value or vector of central x coordinate(s).</p>
</td></tr>
<tr><td><code id="dem_crop_+3A_y0">y0</code></td>
<td>
<p>A value or vector of central y coordinate(s).</p>
</td></tr>
<tr><td><code id="dem_crop_+3A_l">L</code></td>
<td>
<p>Size of squares to cropped from the DEM.</p>
</td></tr>
<tr><td><code id="dem_crop_+3A_plot">plot</code></td>
<td>
<p>Logical. Plot the DEM and the cropped sections?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cropped RasterLayer or list of RasterLayers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># around one point
dem_cropped &lt;- dem_crop(horseshoe, -468, 1266, L = 2)
raster::plot(dem_cropped)
points(-468, 1266)

# around multiple points
points &lt;- data.frame(x = c(-467, -465, -466), y = c(1270, 1265, 1268))
dem_list &lt;- dem_crop(horseshoe, points$x, points$y, L = 1, plot = TRUE)

# plot the first element
raster::plot(dem_list[[1]])
</code></pre>

<hr>
<h2 id='dem_sample'>Sample a random DEM with specified size from a larger DEM</h2><span id='topic+dem_sample'></span>

<h3>Description</h3>

<p>Sample a random DEM with specified size from a larger DEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dem_sample(data, L, allow_NA = TRUE, plot = FALSE, max_iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dem_sample_+3A_data">data</code></td>
<td>
<p>Digital elevation model of class RasterLayer.</p>
</td></tr>
<tr><td><code id="dem_sample_+3A_l">L</code></td>
<td>
<p>Size of square to cut out of DEM.</p>
</td></tr>
<tr><td><code id="dem_sample_+3A_allow_na">allow_NA</code></td>
<td>
<p>Logical. Allow NAs in the sample? Useful when DEM is not regular.</p>
</td></tr>
<tr><td><code id="dem_sample_+3A_plot">plot</code></td>
<td>
<p>Logical. Plot the DEM and the cropped section?</p>
</td></tr>
<tr><td><code id="dem_sample_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of random crops to try when allow_NA = FALSE before failing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Digital elevation model of class RasterLayer.
</p>


<h3>Note</h3>

<p>Not allowing NAs may increase sampling time for irregular DEMs that contain a lot of NAs; e.g., structure from motion transects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem &lt;- dem_sample(horseshoe, L = 2, plot=TRUE)

</code></pre>

<hr>
<h2 id='dem_split'>Split DEM into smaller tiles</h2><span id='topic+dem_split'></span>

<h3>Description</h3>

<p>Split DEM into smaller tiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dem_split(data, size, parallel = FALSE, ncores = (parallel::detectCores() - 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dem_split_+3A_data">data</code></td>
<td>
<p>Digital elevation model of class RasterLayer.</p>
</td></tr>
<tr><td><code id="dem_split_+3A_size">size</code></td>
<td>
<p>Size of tiles, in the same unit as the RasterLayer.</p>
</td></tr>
<tr><td><code id="dem_split_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel processing? Note: parallel must be installed.</p>
</td></tr>
<tr><td><code id="dem_split_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use when parallel = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of RasterLayers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- habtools::extent(horseshoe) # size of horseshoe = 8m
size &lt;- 2 # size of target tiles
(L / size)^2 # number of target tiles = 16
dem_list &lt;- dem_split(horseshoe, 2)
length(dem_list)

</code></pre>

<hr>
<h2 id='dem_to_points'>Transform DEM to 3D pointcloud of raster corners</h2><span id='topic+dem_to_points'></span>

<h3>Description</h3>

<p>Transform DEM to 3D pointcloud of raster corners
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dem_to_points(dem, bh = NULL, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dem_to_points_+3A_dem">dem</code></td>
<td>
<p>Digital elevation model of class RasterLayer.</p>
</td></tr>
<tr><td><code id="dem_to_points_+3A_bh">bh</code></td>
<td>
<p>Border height from lowest point.</p>
</td></tr>
<tr><td><code id="dem_to_points_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel computation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D point cloud for raster cell corners.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem &lt;- sim_dem(20, 0.5)
raster::plot(dem)
pts &lt;- dem_to_points(dem)
rgl::plot3d(pts)


</code></pre>

<hr>
<h2 id='detect_drop'>Detect a sudden drop, edge, or overhang in a DEM</h2><span id='topic+detect_drop'></span>

<h3>Description</h3>

<p>Detect a sudden drop, edge, or overhang in a DEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_drop(data, d = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_drop_+3A_data">data</code></td>
<td>
<p>DEM of class RasterLayer.</p>
</td></tr>
<tr><td><code id="detect_drop_+3A_d">d</code></td>
<td>
<p>The threshold height difference to define a drop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A RasterLayer marking edges. Values indicate maximum height difference of surrounding cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edges &lt;- detect_drop(horseshoe, d = 0.2)

raster::plot(horseshoe)
raster::plot(edges)

</code></pre>

<hr>
<h2 id='extent'>Calculate extent of a 3D object</h2><span id='topic+extent'></span>

<h3>Description</h3>

<p>This function calculates the extent or largest length of the bounding box of a mesh or a DEM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extent(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extent_+3A_data">data</code></td>
<td>
<p>Digital elevation model of class RasterLayer or a triangular mesh of class mesh3d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value, the extent of the mesh or DEM.
</p>


<h3>Note</h3>

<p>There are several extent function is other packages, including
the raster package. Therefore it is recommended to use the package
namespace, see examples below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>habtools::extent(mcap)
habtools::extent(horseshoe)

</code></pre>

<hr>
<h2 id='fd'>Calculate fractal dimension</h2><span id='topic+fd'></span>

<h3>Description</h3>

<p>Calculate fractal dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd(data, method, lvec, keep_data = FALSE, diagnose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_+3A_data">data</code></td>
<td>
<p>Digital elevation model of class RasterLayer or a triangular mesh of class mesh3d.</p>
</td></tr>
<tr><td><code id="fd_+3A_method">method</code></td>
<td>
<p>If data is a RasterLayer, possible methods are:&quot;hvar&quot;, &quot;area&quot;, &quot;sd&quot;, and &quot;cubes&quot; (defaults to &quot;hvar&quot;).
If data is a mesh3d, possible methods are &quot;cubes&quot; and &quot;area&quot; (defaults to &quot;cubes&quot;).</p>
</td></tr>
<tr><td><code id="fd_+3A_lvec">lvec</code></td>
<td>
<p>Vector of scales to use for calculation.</p>
</td></tr>
<tr><td><code id="fd_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical. Keep data? Default is FALSE.</p>
</td></tr>
<tr><td><code id="fd_+3A_diagnose">diagnose</code></td>
<td>
<p>Logical. Show diagnostic plot and metrics?</p>
</td></tr>
<tr><td><code id="fd_+3A_...">...</code></td>
<td>
<p>Arguments from method-specific fd_ functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates fractal dimension using the specified method.
Note that methods are distinctly different and should not be mixed when comparing values for multiple objects.
See <code><a href="#topic+fd_hvar">fd_hvar()</a></code>, <code><a href="#topic+fd_area">fd_area()</a></code>, <code><a href="#topic+fd_cubes">fd_cubes()</a></code>, <code><a href="#topic+fd_sd">fd_sd()</a></code> for details about each method.
If <code>lvec</code> is not specified, a default based on resolution, extent, and method will be used.
The <code>cubes</code> method is not recommended if the height range is much smaller than the extent of a 3d object or DEM, which is typically the case for DEMs.
Most objects and surfaces are not perfectly fractal. It is recommended to investigate scale transitions by setting diagnose to TRUE.
</p>


<h3>Value</h3>

<p>A value for fractal dimension, typically between 2 and 3 or a list if keep_data = TRUE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd_hvar">fd_hvar()</a></code>
</p>
<p><code><a href="#topic+fd_area">fd_area()</a></code>
</p>
<p><code><a href="#topic+fd_sd">fd_sd()</a></code>
</p>
<p><code><a href="#topic+fd_cubes">fd_cubes()</a></code>
</p>
<p><code><a href="#topic+fd_diagnose">fd_diagnose()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dem &lt;- dem_crop(horseshoe, x0 = -469, y0 = 1267, L = 2, plot = TRUE)
fd(dem, method = "hvar", lvec = c(0.125, 0.25, 0.5, 1, 2))
fd(dem, method = "area", diagnose = TRUE)
fd(dem, method = "sd")
fd(mcap2, method = "cubes",  plot = TRUE)
fd(mcap2, method = "area",  diagnose = TRUE)

</code></pre>

<hr>
<h2 id='fd_area'>Calculate fractal dimension using the surface area method</h2><span id='topic+fd_area'></span>

<h3>Description</h3>

<p>Calculate fractal dimension using the surface area method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd_area(data, lvec = NULL, keep_data = FALSE, plot = FALSE, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_area_+3A_data">data</code></td>
<td>
<p>DEM of class &quot;RasterLayer&quot; or mesh of class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="fd_area_+3A_lvec">lvec</code></td>
<td>
<p>Vector of scales to use for calculation.</p>
</td></tr>
<tr><td><code id="fd_area_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical. Keep data? Default is FALSE.</p>
</td></tr>
<tr><td><code id="fd_area_+3A_plot">plot</code></td>
<td>
<p>Logical. Plot surface with area resolutions superimposed? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="fd_area_+3A_scale">scale</code></td>
<td>
<p>Logical. Rescale height values to fit the extent? Only relevant for DEMs. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates fractal dimension using the area method.
Based on values in <code>lvec</code>, the DEM or mesh is reprojected to varying scales.
Fractal dimension is defined as <code>2 - s</code> with s being the slope of the regression between the log-transformed surface areas across scales and the log-transformed scales.
Considerate bias is introduced if scales approach the extent of the object due to an edge effect.
Therefore, this approach is only appropriate when the object is large relative to the scales of interest to be used as <code>lvec</code>.
Diagnostic plots may help visualize whether bias is present for the scales chosen (i.e. points do not fall on a straight line).
</p>


<h3>Value</h3>

<p>A value for fractal dimension, typically between 2 and 3 or a list if keep_data = TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fd_area(horseshoe, lvec = c(0.125, 0.25, 0.5))

# Look at diagnostic plot
fdata &lt;- fd_area(horseshoe, lvec = c(0.05, 0.1, 0.2, 0.4), keep_data = TRUE)
fd_diagnose(fdata)
# points fall on straight line

fdata &lt;- fd_area(horseshoe, lvec = c(0.5, 1, 2, 4), keep_data = TRUE)
fd_diagnose(fdata)
# points fall on hollow curve, indicating that lvec includes values that
# are too high.


</code></pre>

<hr>
<h2 id='fd_boxes'>Calculate fractal dimension using the box counting method</h2><span id='topic+fd_boxes'></span>

<h3>Description</h3>

<p>Calculate fractal dimension using the box counting method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd_boxes(data, lvec, keep_data = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_boxes_+3A_data">data</code></td>
<td>
<p>A data frame in which the first two columns are x and y coordinates, respectively.</p>
</td></tr>
<tr><td><code id="fd_boxes_+3A_lvec">lvec</code></td>
<td>
<p>The scales to use for calculation (i.e. box sizes).</p>
</td></tr>
<tr><td><code id="fd_boxes_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical. Keep calculation data? Default = TRUE.</p>
</td></tr>
<tr><td><code id="fd_boxes_+3A_plot">plot</code></td>
<td>
<p>Logical. Plot the shape with box sizes superimposed? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates fractal dimension using the box counting method.
If <code>lvec</code> is not specified, a default based on resolution and extent will be used.
Based on lvec, boxes of different sizes are defined and the function counts boxes that capture the outline of the shape.
It is recommended to specify the maximum value of <code>lvec</code> so that the largest
box encapsulates the entire object. The smallest scale included in <code>lvec</code>
should not be smaller than the resolution of your object.
</p>


<h3>Value</h3>

<p>A value for fractal dimension, typically between 1 and 2 or a list if keep_data = TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcap_2d &lt;- mesh_to_2d(mcap)

fd_boxes(mcap_2d, plot = TRUE, keep_data = TRUE)
fd_boxes(mcap_2d, lvec = c(0.05, 0.1, 0.2, 0.4), plot = TRUE)

</code></pre>

<hr>
<h2 id='fd_cubes'>Calculate fractal dimension using the cube counting method</h2><span id='topic+fd_cubes'></span>

<h3>Description</h3>

<p>Calculate fractal dimension using the cube counting method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd_cubes(data, lvec = NULL, plot = FALSE, keep_data = FALSE, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_cubes_+3A_data">data</code></td>
<td>
<p>An object of class RasterLayer or mesh3d.</p>
</td></tr>
<tr><td><code id="fd_cubes_+3A_lvec">lvec</code></td>
<td>
<p>Vector of scales to use for calculation (i.e. cube sizes).</p>
</td></tr>
<tr><td><code id="fd_cubes_+3A_plot">plot</code></td>
<td>
<p>Planar representation of cubes superimposed on 3D mesh or DEM for visualizing <code>lvec</code>. Default = FALSE.</p>
</td></tr>
<tr><td><code id="fd_cubes_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical. Keep calculation data? Default = TRUE.</p>
</td></tr>
<tr><td><code id="fd_cubes_+3A_scale">scale</code></td>
<td>
<p>Logical. Rescale height values to the extent? Only relevant for RasterLayer objects. (Defaults to FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates fractal dimension using the cube counting method.
If <code>lvec</code> is not specified, a default based on resolution and extent will be used.
Based on lvec, cubes of different sizes are defined and the function counts mesh points that fall within each cube.
It is recommended to specify the maximum value of <code>lvec</code> so that the largest box encapsulates the entire object.
The smallest scale included in <code>lvec</code> should not be smaller than the resolution of your object.
</p>


<h3>Value</h3>

<p>A value for fractal dimension, typically between 2 and 3 or a list if keep_data = TRUE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd">fd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fd_cubes(mcap, keep_data = TRUE, plot = TRUE)
fd_cubes(mcap, lvec = c(0.05, 0.1, 0.25, 0.5), plot = TRUE)

dem &lt;- dem_crop(horseshoe, x0 = -469, y0 = 1267, L = 2, plot = TRUE)
fd_cubes(dem, plot = TRUE, keep_data = TRUE)
fd_cubes(dem, plot = TRUE, keep_data = TRUE, scale = TRUE)

</code></pre>

<hr>
<h2 id='fd_diagnose'>Diagnose fractal dimension</h2><span id='topic+fd_diagnose'></span>

<h3>Description</h3>

<p>Diagnoses fractal dimension variation across neighboring scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd_diagnose(data, keep_data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_diagnose_+3A_data">data</code></td>
<td>
<p>Output of <code><a href="#topic+fd">fd()</a></code> with option keep_data = TRUE.</p>
</td></tr>
<tr><td><code id="fd_diagnose_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical. Keep diagnostics data?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with fractal dimension across scales, mean fractal dimension, and sd of fractal dimensions across scales.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fd_data &lt;- fd(horseshoe, lvec = c(0.05, 0.1, 0.2, 0.4), method = "area", keep_data = TRUE)
fd_diagnose(fd_data)
fd_diagnose(fd_data, keep_data = FALSE)

</code></pre>

<hr>
<h2 id='fd_hvar'>Calculate fractal Dimension using the height variation method</h2><span id='topic+fd_hvar'></span>

<h3>Description</h3>

<p>Calculate fractal Dimension using the height variation method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd_hvar(
  data,
  lvec,
  regmethod = "mean",
  keep_data = FALSE,
  plot = FALSE,
  parallel = FALSE,
  ncores = (parallel::detectCores() - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_hvar_+3A_data">data</code></td>
<td>
<p>Digital elevation model of class RasterLayer or dataframe (output of hvar function)</p>
</td></tr>
<tr><td><code id="fd_hvar_+3A_lvec">lvec</code></td>
<td>
<p>Vector of scales to use for calculation.</p>
</td></tr>
<tr><td><code id="fd_hvar_+3A_regmethod">regmethod</code></td>
<td>
<p>Method to use for linear regression between scale (lvec) and height range. One of <code>raw</code> (all data), <code>mean</code> (default) <code>median</code> or <code>ends</code> (minimum and maximum scale only)</p>
</td></tr>
<tr><td><code id="fd_hvar_+3A_keep_data">keep_data</code></td>
<td>
<p>Keep the data used for fd calculation? defaults to FALSE</p>
</td></tr>
<tr><td><code id="fd_hvar_+3A_plot">plot</code></td>
<td>
<p>Logical. Show plot of scales relative to data?</p>
</td></tr>
<tr><td><code id="fd_hvar_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel processing? Note: parallel must be installed.</p>
</td></tr>
<tr><td><code id="fd_hvar_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use when parallel = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates fractal dimension using the height variation regression.
If <code>lvec</code> is not specified, a default based on resolution and extent will be used.
<code>data</code> can be a DEM or a <code>data.frame</code> with columns labeled <code>l</code> and <code>h</code> for
grid cell length and height range of that cell, respectively (output of <code><a href="#topic+hvar">hvar()</a></code>).
A rule of thumb is that <code>l</code> should range an order of magnitude.
However, large ranges also
average-out fractal dimension of a surface that might have
phase transitions, and therefore a thorough exploration of height ranges is suggested using the <code>plot</code>.
<code>regmethod</code> specifies whether data is summarized by taking the mean or median of height ranges across scales or all data is used.
<code>regmethod</code> &quot;raw&quot; is not recommended because the regression will give much more weight to the lower scales that include more points and likely underestimate D.
</p>


<h3>Value</h3>

<p>A value for fractal dimension, typically between 2 and 3 or a list if keep_data = TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dem &lt;- habtools::dem_crop(horseshoe, x0 = -469, y0 = 1267, L = 2, plot = TRUE)
fd_hvar(dem, lvec = c(0.125, 0.25, 0.5, 1, 2))
fd_hvar(dem, regmethod = "mean", plot = TRUE, keep_data = TRUE)
fd_hvar(dem, regmethod = "median", plot = TRUE, keep_data = TRUE)
fd_hvar(dem)

</code></pre>

<hr>
<h2 id='fd_sd'>Calculate fractal Dimension using the standard deviation method</h2><span id='topic+fd_sd'></span>

<h3>Description</h3>

<p>Calculate fractal Dimension using the standard deviation method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd_sd(
  data,
  lvec,
  regmethod = "mean",
  keep_data = FALSE,
  plot = FALSE,
  parallel = FALSE,
  ncores = (parallel::detectCores() - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_sd_+3A_data">data</code></td>
<td>
<p>Digital elevation model of class RasterLayer.</p>
</td></tr>
<tr><td><code id="fd_sd_+3A_lvec">lvec</code></td>
<td>
<p>Vector of scales to use for calculation.</p>
</td></tr>
<tr><td><code id="fd_sd_+3A_regmethod">regmethod</code></td>
<td>
<p>Method to use for linear regression between scale (lvec) and height range. One of <code>raw</code> (all data), <code>mean</code> (default) <code>median</code> or <code>ends</code> (minimum and maximum scale only)</p>
</td></tr>
<tr><td><code id="fd_sd_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical. Keep the data used for fd calculation? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="fd_sd_+3A_plot">plot</code></td>
<td>
<p>Logical. Show plot of scales relative to data?</p>
</td></tr>
<tr><td><code id="fd_sd_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel processing? Note: parallel must be installed.</p>
</td></tr>
<tr><td><code id="fd_sd_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use when parallel = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates fractal dimension using the standard deviation method,
an analogue of the variation method, but using the standard deviation in height per grid cell instead of the full height range.
If <code>lvec</code> is not specified, a default based on resolution and extent will be used.
A rule of thumb is that <code>lvec</code> should range at least an order of magnitude.
However, large ranges also average-out fractal dimension of a surface that might have
phase transitions, and therefore a thorough exploration of height ranges is suggested using the <code>plot</code>.
<code>regmethod</code> specifies whether data is summarized by taking the mean or median of height ranges across scales or all data is used.
<code>regmethod</code> &quot;raw&quot; is not recommended because the regression will give much more weight to the lower scales that include more points and likely underestimate D.
</p>


<h3>Value</h3>

<p>A value for fractal dimension, typically between 2 and 3 or a list if keep_data = TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dem &lt;- habtools::dem_crop(horseshoe, x0 = -469, y0 = 1267, L = 2, plot = TRUE)
fd_sd(dem, lvec = c(0.125, 0.25, 0.5, 1, 2))

</code></pre>

<hr>
<h2 id='horseshoe'>Horseshoe reef</h2><span id='topic+horseshoe'></span>

<h3>Description</h3>

<p>A digital elevation model (DEM) of a reef patch in the Great Barrier Reef.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horseshoe
</code></pre>


<h3>Format</h3>

<p>A 800 by 800 digital elevation model (of class RasterLayer).
</p>

<dl>
<dt>Values</dt><dd><p>depth</p>
</dd>
<dt>Resolution</dt><dd><p>0.01 m</p>
</dd>
<dt>Extent</dt><dd><p>8 m</p>
</dd>
</dl>
<p>...

</p>


<h3>Examples</h3>

<pre><code class='language-R'>raster::plot(habtools::horseshoe)
</code></pre>

<hr>
<h2 id='hr'>Calculate height range</h2><span id='topic+hr'></span>

<h3>Description</h3>

<p>Calculates the distance between the lowest and highest point in a 3D object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_+3A_data">data</code></td>
<td>
<p>A RasterLayer or mesh3d object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of height range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for a DEM
hr(horseshoe)

# for a 3D mesh
hr(mcap)

</code></pre>

<hr>
<h2 id='hvar'>Calculate height variation in cells at different scales</h2><span id='topic+hvar'></span>

<h3>Description</h3>

<p>This is a helper function used for calculating fractal dimension using the
height variation and standard deviation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hvar(
  data,
  lvec = NULL,
  parallel = FALSE,
  ncores = (parallel::detectCores() - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hvar_+3A_data">data</code></td>
<td>
<p>Digital elevation model of class RasterLayer.</p>
</td></tr>
<tr><td><code id="hvar_+3A_lvec">lvec</code></td>
<td>
<p>Scales to use for calculation.</p>
</td></tr>
<tr><td><code id="hvar_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel processing? Note: parallel must be installed.</p>
</td></tr>
<tr><td><code id="hvar_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use when parallel = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing height ranges of cells at different scales.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hvar(horseshoe, lvec = c(1, 2, 4, 8))
</code></pre>

<hr>
<h2 id='mcap'>Montipora capitata</h2><span id='topic+mcap'></span>

<h3>Description</h3>

<p>A laser scan of a coral colony.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcap
</code></pre>


<h3>Format</h3>

<p>mesh3d object with 5568 vertices, 10939 triangles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
plot3d(mcap)
</code></pre>

<hr>
<h2 id='mcap2'>Montipora capitata 2</h2><span id='topic+mcap2'></span>

<h3>Description</h3>

<p>A remeshed version of mcap with resolution = 0.005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcap2
</code></pre>


<h3>Format</h3>

<p>mesh3d object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
plot3d(mcap2)
</code></pre>

<hr>
<h2 id='mesh_to_2d'>Transform 3D mesh into 2D outline</h2><span id='topic+mesh_to_2d'></span>

<h3>Description</h3>

<p>Turns a 3D Mesh file into an xy data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh_to_2d(mesh, L0 = NULL, plot = FALSE, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_to_2d_+3A_mesh">mesh</code></td>
<td>
<p>A mesh3d object.</p>
</td></tr>
<tr><td><code id="mesh_to_2d_+3A_l0">L0</code></td>
<td>
<p>(Optional) The desired DEM resolution in same units at the 3D mesh.</p>
</td></tr>
<tr><td><code id="mesh_to_2d_+3A_plot">plot</code></td>
<td>
<p>logical. Plot the output?</p>
</td></tr>
<tr><td><code id="mesh_to_2d_+3A_silent">silent</code></td>
<td>
<p>logical. Defaults to not showing warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the vertices of the mesh object and projects them on the XY plane.
Then, only points that define the perimeter of the shape are maintained.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcap_2d &lt;- mesh_to_2d(mcap, plot = TRUE)

geometry::polyarea(mcap_2d$x, mcap_2d$y) # area
planar(mcap)

perimeter(mcap_2d) # perimeter
circularity(mcap_2d) # circularity
fd_boxes(mcap_2d) # fractal dimension

</code></pre>

<hr>
<h2 id='mesh_to_dem'>Transform 3D mesh to DEM</h2><span id='topic+mesh_to_dem'></span>

<h3>Description</h3>

<p>Turns a 3D mesh file into a Digital Elevation Model (DEM) of class RasterLayer
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh_to_dem(mesh, res, fill = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_to_dem_+3A_mesh">mesh</code></td>
<td>
<p>A mesh3d object.</p>
</td></tr>
<tr><td><code id="mesh_to_dem_+3A_res">res</code></td>
<td>
<p>(Optional) The desired DEM resolution in same units at the 3D mesh.</p>
</td></tr>
<tr><td><code id="mesh_to_dem_+3A_fill">fill</code></td>
<td>
<p>Logical. Fill <code>NA</code> values in raster with minimum value?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function rasterizes uses the vertices of the mesh file.
If resolution is not
given, it is calculated by finding the maximum nearest neighbor
of vertices projected
on the <code>xy</code> plane. <code>fill</code> is used when irregular 3D meshes
result in <code>NA</code> values in
raster cells. The default is to fill these cells with the
minimum, non-<code>NA</code> raster value.
</p>


<h3>Value</h3>

<p>A dem of class RasterLayer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem &lt;- mesh_to_dem(mcap)
raster::plot(dem)

dem &lt;- mesh_to_dem(mcap, res = 0.05)
raster::plot(dem)

# Don't fill empty raster cells
dem &lt;- mesh_to_dem(mcap, res = 0.02, fill = FALSE)
raster::plot(dem)

</code></pre>

<hr>
<h2 id='mesh_to_points'>Transform mesh to 3D point cloud</h2><span id='topic+mesh_to_points'></span>

<h3>Description</h3>

<p>Transform mesh to 3D point cloud
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh_to_points(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_to_points_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with XYZ coordinates.
</p>

<hr>
<h2 id='mid_find'>Find midpoint of a DEM</h2><span id='topic+mid_find'></span>

<h3>Description</h3>

<p>Find midpoint of a DEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mid_find(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mid_find_+3A_data">data</code></td>
<td>
<p>A DEM in RasterLayer format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with x and y midpoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mid_find(horseshoe)
</code></pre>

<hr>
<h2 id='packing'>Calculate packing of 3D object</h2><span id='topic+packing'></span>

<h3>Description</h3>

<p>The ratio of the surface area of the object and the surface area of the convex hull around the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packing(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="packing_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of packing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>packing(mcap)
</code></pre>

<hr>
<h2 id='perimeter'>Calculate perimeter of a 2D shape</h2><span id='topic+perimeter'></span>

<h3>Description</h3>

<p>Calculates the perimeter of a 2D shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perimeter(data, keep_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perimeter_+3A_data">data</code></td>
<td>
<p>A data frame with the first two columns ordered x and y coordinates.</p>
</td></tr>
<tr><td><code id="perimeter_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical. Keep lengths of all segments of the perimeter? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The perimeter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcap_2d &lt;- mesh_to_2d(mcap)
plot(mcap_2d)

perimeter(mcap_2d)

r &lt;- 1 # radius
circ &lt;- sim_circle(r=r) # simulate xy coordinates for a circle of radius 1
plot(circ, asp=1)
perimeter(circ)

2 * pi * r # Note xy resolution affects output

</code></pre>

<hr>
<h2 id='planar'>Calculates planar area of a mesh</h2><span id='topic+planar'></span>

<h3>Description</h3>

<p>Calculates planar area of a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planar(mesh, L0, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planar_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
<tr><td><code id="planar_+3A_l0">L0</code></td>
<td>
<p>Resolution of the planar area. Is set to the resolution of the mesh when left empty.</p>
</td></tr>
<tr><td><code id="planar_+3A_silent">silent</code></td>
<td>
<p>Logical. Suppress messages and warnings?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value for planar area.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>planar(mcap)
</code></pre>

<hr>
<h2 id='rdh'>Calculate rugosity, fractal dimension, and height for a DEM</h2><span id='topic+rdh'></span>

<h3>Description</h3>

<p>Calculate rugosity, fractal dimension, and height for a DEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdh(
  data,
  lvec,
  method_fd = "hvar",
  method_rg = "area",
  parallel = FALSE,
  ncores = (parallel::detectCores() - 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdh_+3A_data">data</code></td>
<td>
<p>A dem of class RasterLayer.</p>
</td></tr>
<tr><td><code id="rdh_+3A_lvec">lvec</code></td>
<td>
<p>Scales to use for calculation.</p>
</td></tr>
<tr><td><code id="rdh_+3A_method_fd">method_fd</code></td>
<td>
<p>method for the calculation of rugosity and fractal dimension.
Can be &quot;hvar&quot;, &quot;sd&quot;, &quot;cubes&quot;, or &quot;area&quot;. Defaults to &quot;hvar&quot;.</p>
</td></tr>
<tr><td><code id="rdh_+3A_method_rg">method_rg</code></td>
<td>
<p>Method to be used for the rugosity calculation. Defaults to &quot;area&quot;.</p>
</td></tr>
<tr><td><code id="rdh_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel processing? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="rdh_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use if parallel = TRUE.</p>
</td></tr>
<tr><td><code id="rdh_+3A_...">...</code></td>
<td>
<p>Additional arguments see <code><a href="#topic+fd">fd()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses area method for rugosity and hvar method for fractal dimension calculations as default.
</p>


<h3>Value</h3>

<p>A dataframe with the three complexity metrics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd">fd()</a></code>
</p>
<p><code><a href="#topic+rg">rg()</a></code>
</p>
<p><code><a href="#topic+hr">hr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dem &lt;- dem_sample(horseshoe, L = 1)
rdh(dem, lvec = c(0.125, 0.25, 0.5, 1))
</code></pre>

<hr>
<h2 id='rdh_theory'>Calculate metric based on geometric plane equation</h2><span id='topic+rdh_theory'></span>

<h3>Description</h3>

<p>Calculates either rugosity, fractal dimension or height
range based on the other two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdh_theory(R, D, H, L, L0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdh_theory_+3A_r">R</code>, <code id="rdh_theory_+3A_d">D</code>, <code id="rdh_theory_+3A_h">H</code></td>
<td>
<p>Two of the three variables to calculate the third.</p>
</td></tr>
<tr><td><code id="rdh_theory_+3A_l">L</code></td>
<td>
<p>Extent.</p>
</td></tr>
<tr><td><code id="rdh_theory_+3A_l0">L0</code></td>
<td>
<p>Resolution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the geometric plane equation from Torres-Pulliza
et al. (2020) to calculate one of rugosity, fractal dimension or height
range based on the other two variables.
</p>


<h3>Value</h3>

<p>A value corresponding one of the three variables not given
to the function.
</p>


<h3>References</h3>

<p>Torres-Pulliza D, Dornelas M, Pizarro O, Bewley M, Blowes SA, Boutros N, Brambilla V, Chase TJ, Frank G, Friedman A, Hoogenboom MO, Williams S, Zawada KJA, Madin JS (2020) A geometric basis for surface habitat complexity and biodiversity. <em>Nature Ecology &amp; Evolution</em> 4:1495-1501. <a href="https://doi.org/10.1038/s41559-020-1281-8">doi:10.1038/s41559-020-1281-8</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdh_theory(R=4, H=1, L=1, L0=0.01)
rdh_theory(D=2.36928, H=1, L=1, L0=0.01)
rdh_theory(D=2.36928, R=4, L=1, L0=0.01)
</code></pre>

<hr>
<h2 id='rg'>Calculate rugosity</h2><span id='topic+rg'></span>

<h3>Description</h3>

<p>Rugosity is defined as the surface area divided by the planar area. For digital elevation models, there are two methods: &quot;hvar&quot; and &quot;area&quot;.
The &quot;hvar&quot; method for calculating rugosity is described in Torres-Pulliza et al. (2004) and is based on height variations.
The &quot;area&quot; method uses the <code><a href="sp.html#topic+surfaceArea">sp::surfaceArea()</a></code> function and is detailed in Jenness (2004).
<code>method</code> is ignored if <code>data</code> is a mesh3D object.
In that case the function uses <code><a href="Rvcg.html#topic+vcgArea">Rvcg::vcgArea()</a></code> to calculate surface area of a triangular mesh of class mesh3d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rg(
  data,
  L0,
  method = "area",
  parallel = FALSE,
  ncores = (parallel::detectCores() - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rg_+3A_data">data</code></td>
<td>
<p>Digital elevation model of class RasterLayer or a triangular mesh of class mesh3d.</p>
</td></tr>
<tr><td><code id="rg_+3A_l0">L0</code></td>
<td>
<p>Grain or resolution of calculation.</p>
</td></tr>
<tr><td><code id="rg_+3A_method">method</code></td>
<td>
<p>If data is a RasterLayer methods &quot;hvar&quot; or &quot;area&quot; are allowed. Defaults to &quot;hvar&quot;.</p>
</td></tr>
<tr><td><code id="rg_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel processing? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="rg_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use if parallel = TRUE.
(Defaults to umber of available cores - 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rugosity value
</p>


<h3>References</h3>

<p>Jenness, J.S. Calculating Landscape Surface Area from Digital Elevation Models. Wildlife Society Bulletin, Vol. 32, No. 3 (Autumn, 2004), pp. 829-839n
<br /><br />
Torres-Pulliza, D., Dornelas, M.A., Pizarro, O. et al. A geometric basis for surface habitat complexity and biodiversity. Nat Ecol Evol 4, 14951501 (2020). https://doi.org/10.1038/s41559-020-1281-8
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rg(horseshoe, L0 = 0.1)
rg(mcap, L0 = 0.01)

</code></pre>

<hr>
<h2 id='sa_triangle'>Calculate surface area of triangle</h2><span id='topic+sa_triangle'></span>

<h3>Description</h3>

<p>Calculates the surface area of a triangle based on a set of XYZCoords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sa_triangle(XYZcoords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sa_triangle_+3A_xyzcoords">XYZcoords</code></td>
<td>
<p>A data frame with XYZ coordinates of three points in following order: X1,X2,X3,Y1,Y2,Y3,Z1,Z2,Z3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The surface area of the triangle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sa_triangle(c(X1 = 1, X2 = 2, X3 = 3 , Y1 = 1, Y2 = 2, Y3 = 1, Z1 = 1, Z2 = 1, Z3 = 1))
</code></pre>

<hr>
<h2 id='scale_area'>Re-scale mesh based on a fixed area</h2><span id='topic+scale_area'></span>

<h3>Description</h3>

<p>Re-scale mesh based on a fixed area
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_area(mesh, target_area = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_area_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
<tr><td><code id="scale_area_+3A_target_area">target_area</code></td>
<td>
<p>The target area of the scaled 3D mesh. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mesh with area = target_area (1 as default).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rvcg::vcgArea(mcap)
mcap_scaled &lt;- scale_area(mcap)
Rvcg::vcgArea(mcap_scaled)
</code></pre>

<hr>
<h2 id='scale_volume'>Re-scale mesh based on a fixed volume of 1</h2><span id='topic+scale_volume'></span>

<h3>Description</h3>

<p>Re-scale mesh based on a fixed volume of 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_volume(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_volume_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mesh with volume = 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rvcg::vcgVolume(mcap)
mcap_scaled &lt;- scale_volume(mcap)
Rvcg::vcgVolume(mcap_scaled)
</code></pre>

<hr>
<h2 id='set_origin'>Set the origin of a mesh</h2><span id='topic+set_origin'></span>

<h3>Description</h3>

<p>Transforms XYZ coordinates relative to a chosen origin
</p>
<p>Transforms coordinates so that the origin lies at the reference
vertex (defaults to the minimum of x, y, and z coordinates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_origin(mesh, reference = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_origin_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
<tr><td><code id="set_origin_+3A_reference">reference</code></td>
<td>
<p>Vector containing coordinates of the reference vertex.
If left empty, this will default to the minimum of x, y, and z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mesh3d object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh &lt;- set_origin(mcap)
</code></pre>

<hr>
<h2 id='sim_circle'>Simulate a circle</h2><span id='topic+sim_circle'></span>

<h3>Description</h3>

<p>Simulates xy coordinates for a circle of given radius. Created for package
testing purposes, but might be useful for others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_circle(r = 1, n = 100, mid = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_circle_+3A_r">r</code></td>
<td>
<p>Radius of the circle (default 1).</p>
</td></tr>
<tr><td><code id="sim_circle_+3A_n">n</code></td>
<td>
<p>Number of xy coordinates defining the circle (default 100).</p>
</td></tr>
<tr><td><code id="sim_circle_+3A_mid">mid</code></td>
<td>
<p>Mid point of the circle (default 0, 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of n xy-coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circ &lt;- sim_circle()
plot(circ)

circularity(circ)
perimeter(circ)

</code></pre>

<hr>
<h2 id='sim_dem'>Simulates a fractal DEM</h2><span id='topic+sim_dem'></span>

<h3>Description</h3>

<p>Simulates z-values based on the Diamond-square algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_dem(
  L,
  smoothness,
  H,
  R,
  plot = FALSE,
  prop = 0.1,
  n = 100,
  method = "area",
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_dem_+3A_l">L</code></td>
<td>
<p>The extent.</p>
</td></tr>
<tr><td><code id="sim_dem_+3A_smoothness">smoothness</code></td>
<td>
<p>A value between 0.0 and 1.0 (lower values
produce rougher DEM).</p>
</td></tr>
<tr><td><code id="sim_dem_+3A_h">H</code></td>
<td>
<p>Desired height range (optional).</p>
</td></tr>
<tr><td><code id="sim_dem_+3A_r">R</code></td>
<td>
<p>Desired rugosity value (optional).</p>
</td></tr>
<tr><td><code id="sim_dem_+3A_plot">plot</code></td>
<td>
<p>Logical. Plot the simulated DEM during simulation? Only relevant if R is provided.</p>
</td></tr>
<tr><td><code id="sim_dem_+3A_prop">prop</code></td>
<td>
<p>Proportion of cells that undergo smoothing at each iteration when R is provided.</p>
</td></tr>
<tr><td><code id="sim_dem_+3A_n">n</code></td>
<td>
<p>Number of iterations to try and reach desired R. Recommended to adapt R and H instead of increasing n if simulation fails.</p>
</td></tr>
<tr><td><code id="sim_dem_+3A_method">method</code></td>
<td>
<p>The method to be used for rugosity calculation in case R is given. Can be &quot;hvar&quot; or &quot;area&quot;</p>
</td></tr>
<tr><td><code id="sim_dem_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Use parallel processing? Defaults to FALSE. Only relevant if method = &quot;hvar&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: this function gets slow for n &gt; 128.
If H is provided, the simulated DEM is rescaled based on the value for H.
If R is provided, a DEM is simulated using the same algorithm based on R, H, and the predicted D based on <code><a href="#topic+rdh_theory">rdh_theory()</a></code>, while smoothness is ignored.
From that first simulated DEM, R is calculated and the DEM undergoes smoothing at each iteration until the rugosity approximates the inputted R.
Argument prop defined the proportion of random cells of the DEM that are smoothed by averaging the z values of cell and neighboring cells at each iteration.
Caution: When R is provided, the DEM may become increasingly less fractal as it is modified at each iteration.
</p>


<h3>Value</h3>

<p>Digital elevation model of class RasterLayer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
dem &lt;- sim_dem(L = 32, smoothness = 0.5)
plot(dem)
dem &lt;- sim_dem(L = 32, smoothness = 0.2, H = 20)
plot(dem)
</code></pre>

<hr>
<h2 id='sma'>Calculate second moment of area</h2><span id='topic+sma'></span>

<h3>Description</h3>

<p>Calculates the 2nd moment of surface area about the origin by multiplying the surface area of
each triangle in the mesh by its distance from the origin (should be set to
the attachment point of the mesh). The sum of these values is the 2nd moment
of area.#' This metric is size-dependent so to compare moments in terms of shape only, set scale = TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sma(mesh, axis = "z", scale = FALSE, origin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sma_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
<tr><td><code id="sma_+3A_axis">axis</code></td>
<td>
<p>The axis along which to calculate the second moment of area. z is the default.</p>
</td></tr>
<tr><td><code id="sma_+3A_scale">scale</code></td>
<td>
<p>Logical. Scale the object to have a volume = 1? Default = FALSE</p>
</td></tr>
<tr><td><code id="sma_+3A_origin">origin</code></td>
<td>
<p>Logical. Set the origin to the bottom left corner of bounding box? Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SMA value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sma(mcap)
sma(mcap, scale = TRUE)
</code></pre>

<hr>
<h2 id='smv'>Calculate second moment of volume</h2><span id='topic+smv'></span>

<h3>Description</h3>

<p>Calculates the 2nd moment of volume (SMV) by multiplying the volume of each
triangle in the mesh by its centroids' distance from the origin (should be set to the attachment point
of the mesh). The sum of these values is the 2nd moment of volume.
Axis is z by default, meaning it will calculate the vertical second moment, but this can be changed if needed.
This metric is size-dependent so to compare moments in terms of shape only, set scale = TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smv(mesh, axis = "z", scale = FALSE, origin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smv_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
<tr><td><code id="smv_+3A_axis">axis</code></td>
<td>
<p>The axis along which to calculate the second moment of volume z is the default.</p>
</td></tr>
<tr><td><code id="smv_+3A_scale">scale</code></td>
<td>
<p>Logical. Scale the object to have a volume = 1? Default = TRUE.</p>
</td></tr>
<tr><td><code id="smv_+3A_origin">origin</code></td>
<td>
<p>Logical. Set the origin to the bottom left corner of bounding box? Default = FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SMV value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smv(mcap)
</code></pre>

<hr>
<h2 id='sphericity'>Calculate sphericity of a 3D object</h2><span id='topic+sphericity'></span>

<h3>Description</h3>

<p>Calculates the ratio of the surface area of a sphere with the same volume as the object and the surface area of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphericity(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphericity_+3A_mesh">mesh</code></td>
<td>
<p>A triangular mesh of class mesh3d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sphericity value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circularity">circularity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sphericity(mcap)
</code></pre>

<hr>
<h2 id='surface_area'>Calculate surface area</h2><span id='topic+surface_area'></span>

<h3>Description</h3>

<p>Calculates surface area of a 3D or 2D object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface_area(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface_area_+3A_data">data</code></td>
<td>
<p>DEM in RasterLayer format, mesh3d object or data frame with xy coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Surface area value.
</p>


<h3>References</h3>

<p>Jenness, J.S. Calculating Landscape Surface Area from Digital Elevation Models. Wildlife Society Bulletin, Vol. 32, No. 3 (Autumn, 2004), pp. 829-839n
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surface_area(mcap)
surface_area(horseshoe)
surface_area(mesh_to_2d(mcap))

</code></pre>

<hr>
<h2 id='svol_triangle'>Calculate signed volume of triangle</h2><span id='topic+svol_triangle'></span>

<h3>Description</h3>

<p>Calculates the signed volume of a triangle based on a set of XYZCoords.
Signed volume means that volumes can take on a negative value depending on whether the surface normal
of the triangle is facing towards or away from the origin. When all positive and negative volumes
are integrated across the entire mesh, these values cancel out so that the final volume is an approximation
of the total volume of the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svol_triangle(XYZCoords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svol_triangle_+3A_xyzcoords">XYZCoords</code></td>
<td>
<p>A dataframe with XYZ coordinates of three points in following order: X1,X2,X3,Y1,Y2,Y3,Z1,Z2,Z3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value for the signed volume of a triangle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>svol_triangle(c(X1 = 1, X2 = 2, X3 = 3 , Y1 = 1, Y2 = 2, Y3 = 1, Z1 = 1, Z2 = 1, Z3 = 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
