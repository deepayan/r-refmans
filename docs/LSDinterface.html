<!DOCTYPE html><html><head><title>Help for package LSDinterface</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LSDinterface}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#info.details.lsd'>
<p>Get detailed information from a LSD results file</p></a></li>
<li><a href='#info.dimensions.lsd'>
<p>Dimension information for a LSD results file</p></a></li>
<li><a href='#info.distance.lsd'>
<p>Compute distance measure between LSD Monte Carlo time series and a set of references</p></a></li>
<li><a href='#info.init.lsd'>
<p>Read initial conditions from a LSD results file</p></a></li>
<li><a href='#info.names.lsd'>
<p>Read unique variable names from a LSD results file (no duplicates)</p></a></li>
<li><a href='#info.stats.lsd'>
<p>Compute Monte Carlo statistics from a set of LSD runs</p></a></li>
<li><a href='#list.files.lsd'>
<p>List results files from a set of LSD runs</p></a></li>
<li><a href='#LSDinterface-package'>
<p>Interface Tools for LSD Simulation Results Files</p></a></li>
<li><a href='#name.check.lsd'>
<p>Check a set of LSD variables names against a LSD results file</p></a></li>
<li><a href='#name.clean.lsd'><p>Get clean (R) variable name</p></a></li>
<li><a href='#name.nice.lsd'><p>Get a nice (R) variable name</p></a></li>
<li><a href='#name.r.unique.lsd'><p>Get valid unique R variable name</p></a></li>
<li><a href='#name.var.lsd'>
<p>Get original LSD variable name</p></a></li>
<li><a href='#read.3d.lsd'>
<p>Read one instance of LSD variables (time series) from multiple LSD results files into a 3D array</p></a></li>
<li><a href='#read.4d.lsd'>
<p>Read multiple instances of LSD variables (time series) from a set of LSD results file into a 4D array</p></a></li>
<li><a href='#read.list.lsd'>
<p>Read one or more instances of LSD variables (time series) from a set of LSD results file into a list</p></a></li>
<li><a href='#read.multi.lsd'>
<p>Read all instances of LSD variables (time series) from a LSD results file</p></a></li>
<li><a href='#read.raw.lsd'>
<p>Read LSD results file and clean variables names</p></a></li>
<li><a href='#read.single.lsd'>
<p>Read LSD variables (time series) from a LSD results file (a single instance of each variable only)</p></a></li>
<li><a href='#select.colattrs.lsd'>
<p>Select a subset of a LSD results matrix (by variable attributes)</p></a></li>
<li><a href='#select.colnames.lsd'>
<p>Select a subset of a LSD results matrix (by column/variable names)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface Tools for LSD Simulation Results Files</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-5-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Interfaces R with LSD simulation models. Reads object-oriented data in results files (.res[.gz]) produced by LSD and creates appropriate multi-dimensional arrays in R. Supports multiple core parallel threads of multi-file data reading for increased performance. Also provides functions to extract basic information and statistics from data files. LSD (Laboratory for Simulation Development) is free software developed by Marco Valente and Marcelo C. Pereira (documentation and downloads available at <a href="https://www.labsimdev.org/">https://www.labsimdev.org/</a>).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, boot, utils, parallel, abind, TSdist</td>
</tr>
<tr>
<td>Suggests:</td>
<td>LSDsensitivity</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-13 15:29:22 UTC; Marcelo</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcelo C. Pereira
    <a href="https://orcid.org/0000-0002-8069-2734"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcelo C. Pereira &lt;mcper@unicamp.br&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-13 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='info.details.lsd'>
Get detailed information from a LSD results file
</h2><span id='topic+info.details.lsd'></span>

<h3>Description</h3>

<p>This function reads, analyze and organize the information from a LSD results file (.res).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.details.lsd( file )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info.details.lsd_+3A_file">file</code></td>
<td>

<p>the name of the LSD results file which the data are to be read from. If it does not contain an absolute path, the file name is relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. Tilde-expansion is performed where supported. This can be a compressed file (see file) and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame containing detailed description (columns) of all variables (rows) contained in the selected results file.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+info.init.lsd">info.init.lsd</a>()</code>,
<code><a href="#topic+info.names.lsd">info.names.lsd</a>()</code>
<code><a href="#topic+info.dimensions.lsd">info.dimensions.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# get details about all variables in first file
info.details.lsd( files[ 1 ] )
</code></pre>

<hr>
<h2 id='info.dimensions.lsd'>
Dimension information for a LSD results file
</h2><span id='topic+info.dimensions.lsd'></span>

<h3>Description</h3>

<p>This function reads some dimension information from a LSD results file (.res): number of time steps, number of variables and the original column (variable) names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.dimensions.lsd( file )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info.dimensions.lsd_+3A_file">file</code></td>
<td>

<p>the name of the LSD results file which the data are to be read from. If it does not contain an absolute path, the file name is relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. Tilde-expansion is performed where supported. This can be a compressed file (see file) and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned number of time steps does not include the initial value (t = 0) for lagged variables (the second line of a .res format file).
</p>


<h3>Value</h3>

<p>Returns a list containing two integer values and a character vector describing the selected results file.
</p>
<table>
<tr><td><code>tSteps</code></td>
<td>
<p>Number of time steps in file</p>
</td></tr>
<tr><td><code>nVars</code></td>
<td>
<p>Number of variables (including duplicated instances) in file</p>
</td></tr>
<tr><td><code>varNames</code></td>
<td>
<p>Names of variables (including duplicated instances) in file, after R name conversion</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+info.details.lsd">info.details.lsd</a>()</code>,
<code><a href="#topic+info.names.lsd">info.names.lsd</a>()</code>,
<code><a href="#topic+info.init.lsd">info.init.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# get dimensions from second file
info.dimensions.lsd( files[ 2 ] )
</code></pre>

<hr>
<h2 id='info.distance.lsd'>
Compute distance measure between LSD Monte Carlo time series and a set of references
</h2><span id='topic+info.distance.lsd'></span>

<h3>Description</h3>

<p>This function reads a 3 or 4-dimensional array produced by <code><a href="#topic+read.3d.lsd">read.3d.lsd</a></code> or <code><a href="#topic+read.4d.lsd">read.4d.lsd</a></code> and computes several types of distance measures between the time series from a set of Monte Carlo runs and a set of reference time series (like the Monte Carlo average or median).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.distance.lsd( array, references, instance = 1,
                   distance = "euclidean", std.dist = FALSE,
                   std.val = FALSE, rank = FALSE, weights = 1,
                   seed = 1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info.distance.lsd_+3A_array">array</code></td>
<td>

<p>a 3D or 4D array as produced by <code><a href="#topic+read.3d.lsd">read.3d.lsd</a></code> and <code><a href="#topic+read.4d.lsd">read.4d.lsd</a></code>, where in the first dimension (rows) you have the time steps, in the second (columns), the variables and in the third/fourth dimension, the Monte Carlo experiments, and the instances in the third dimension (4D arrays only). When 4D arrays are provided, only first instances are used in the computation.
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_references">references</code></td>
<td>

<p>a 2D matrix containing the reference time series, time in rows and variable values in named columns, from which the distance measures are to be computed. Columns must be named for the exact match to the names of the desired variables (contained in <code>array</code>). Only variables contained in both <code>array</code> and <code>references</code> are considered in the computation. According to the <code>distance</code> measure chosen, the number of time steps in <code>array</code> and <code>references</code> must be the same (as in the default Euclidean distance).
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_instance">instance</code></td>
<td>

<p>integer: the instance of the variable to be read, for variables that exist in more than one object (4D <code>array</code> only). The default (1) is to read first instances.
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_distance">distance</code></td>
<td>

<p>string: the distance measure to be used. The default is to compute the Euclidean distance (<code>"euclidean"</code>). For a comprehensive list of measure options, please refer to <code><a href="TSdist.html#topic+TSDistances">TSDistances</a></code>. Measure names can be abbreviated.
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_std.dist">std.dist</code></td>
<td>

<p>a logical value indicating, if <code>TRUE</code>, that the computed distances must be standardized with respect of the number of time steps involved. The default, <code>FALSE</code>, is not standardizing distances. This is relevant for properly comparing the metrics of series containing <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_std.val">std.val</code></td>
<td>

<p>a logical value indicating, if <code>TRUE</code>, that the series values must be standardized before computing the distances. The default, <code>FALSE</code>, is not standardizing values. This is relevant for properly comparing the metrics of series for different variables which are not distributed over the same range of values.
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_rank">rank</code></td>
<td>

<p>a logical value indicating, if <code>TRUE</code>, that the Monte Carlo runs must be ranked in terms of closeness to the <code>references</code>. The default is not computing the run ranking, as this may be computationally expensive for some <code>distance</code> measures.
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_weights">weights</code></td>
<td>

<p>a numerical vector containing the weights to be used for each variable in <code>references</code> when <code>rank = TRUE</code>. If vector has named elements, the vector names must exactly match the names of variables in <code>references</code>, order is not important, If variable names not present in vector, the missing ones are not considered in the ranking. If the vector is not named, the order of the weights must be the same as the one used for the variables (columns) in the <code>references</code> matrix. If the length of <code>weigths</code> is smaller the number of variables and not named, the vector is recycled. The default is to use the same weight for all variables.
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_seed">seed</code></td>
<td>

<p>a single value, interpreted as an integer to define the pseudo-random number generator state used when sampling data, or <code>NULL</code>, to re-initialize the generator as if no seed had yet been set (a new state is created from the current time and the process ID).
</p>
</td></tr>
<tr><td><code id="info.distance.lsd_+3A_...">...</code></td>
<td>

<p>additional parameters required by the specific method (see <code><a href="TSdist.html#topic+TSDistances">TSDistances</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a front-end to the extensive <a href="TSdist.html#topic+TSdist-package">TSdist package</a> for interfacing it with LSD generated data. Please check the associated documentation for further information.
</p>
<p><a href="TSdist.html#topic+TSdist-package">TSdist package</a> provides many different distance measure alternatives, including many that allow for different number of time steps among runs and references.
</p>
<p>This function may also search the Monte Carlo run which has the overall smallest (standardized) distances from the given <code>references</code>. Irrespective of the options <code>std.dist</code> and <code>std.val</code>, the search uses always standardized values and distances for computation (this does not affect the distance measure matrix values).
</p>
<p>One typical application of distance metrics is to select runs which are closer to the Monte Carlo average or median, that is, the runs which are more representative of the Monte Carlo Experiment. As there is no single criteria to define such &quot;closeness&quot;, multiple distance measures may help to identify the set of most interesting runs.
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>a named matrix containing the distances for each Monte Carlo run (lines) and variables (columns) contained both in <code>array</code> and <code>references</code> (and <code>weights</code>, if provided)</p>
</td></tr>
<tr><td><code>close</code></td>
<td>
<p>a named matrix of Monte Carlo run (sample) names, one column per variable, sorted in increasing distance order (closest runs in first line), which can be used to index the 3D or 4D <code>array</code></p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>(only if <code>rank = TRUE</code>) a named vector of weighted Monte Carlo run standardized distances, sorted in increasing distance order (closest run first)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When comparing distance measures between different Monte Carlo runs and variables, it is important to standardize the distances and values to ensure consistency. For variables which may present <code>NA</code> values, setting <code>std.dist = TRUE</code> ensures distance comparability by dividing the absolute distance of each run-reference pair by the number of effective (non-<code>NA</code>) time steps. When comparing variables which are dimensionally heterogeneous, <code>std.val = TRUE</code> uses the relative measure (between 1 and the run value divided by the corresponding reference value) to compute the distances.
</p>
<p>When setting <code>std.val = TRUE</code>, all points in which the <code>references</code>' values are equal to zero are effectively removed from calculations. This behavior is always applied when searching for the closest Monte Carlo run(s).
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code>,
<code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code>,
<code><a href="#topic+info.stats.lsd">info.stats.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# read first instance of all variables from MC files (3D array)
inst1Array &lt;- read.3d.lsd( files )

# create statistics data frames for the variables
inst1Stats &lt;- info.stats.lsd( inst1Array )

# compute the Euclidean distance to the mean for all variables and runs
inst1dist &lt;- info.distance.lsd( inst1Array, inst1Stats$avg )
inst1dist$dist
inst1dist$close

# the same exercise but for a 4D array and Manhattan distance to the median
# plus indicating the Monte Carlo run closest to the median
allArray &lt;- read.4d.lsd( files )
allStats &lt;- info.stats.lsd( allArray, median = TRUE )
allDist &lt;- info.distance.lsd( allArray, allStats$med, distance = "manhattan",
                              rank = TRUE )
allDist$dist
allDist$close
allDist$rank
names( allDist$rank )[ 1 ]  # results file name of the closest run
</code></pre>

<hr>
<h2 id='info.init.lsd'>
Read initial conditions from a LSD results file
</h2><span id='topic+info.init.lsd'></span>

<h3>Description</h3>

<p>This function reads the initial condition values from a LSD results file (.res).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.init.lsd( file )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info.init.lsd_+3A_file">file</code></td>
<td>

<p>the name of the LSD results file which the data are to be read from. If it does not contain an absolute path, the file name is relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. Tilde-expansion is performed where supported. This can be a compressed file (see file) and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 1 line matrix containing the initial conditions (row 1) of all variables contained in the selected results file.
</p>


<h3>Note</h3>

<p>The returned matrix contains all variables in the results file, even the ones that don't have an initial condition (indicated as NA).
Only variables automatically initialized automatically by LSD in t = 1 are included here.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+info.details.lsd">info.details.lsd</a>()</code>,
<code><a href="#topic+info.names.lsd">info.names.lsd</a>()</code>
<code><a href="#topic+info.dimensions.lsd">info.dimensions.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# get initialization data from first and second files
init1 &lt;- info.init.lsd( files[ 1 ] )
init1[ , 4 : 8 ]

init2 &lt;- info.init.lsd( files[ 2 ] )
init2[ , 4 : 8 ]
</code></pre>

<hr>
<h2 id='info.names.lsd'>
Read unique variable names from a LSD results file (no duplicates)
</h2><span id='topic+info.names.lsd'></span>

<h3>Description</h3>

<p>This function reads the variable names (columns) from a LSD results file (.res). The names returned are converted to the original LSD names whenever possible and duplicates are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.names.lsd( file )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info.names.lsd_+3A_file">file</code></td>
<td>

<p>the name of the LSD results file which the data are to be read from. If it does not contain an absolute path, the file name is relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. Tilde-expansion is performed where supported. This can be a compressed file (see file) and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector containing the names of all unique variables contained in the selected results file.
</p>


<h3>Note</h3>

<p>Not all names can be automatically reconverted to the original LSD names, using LSD/C++ naming conventions.
</p>
<p>The conversion may be incorrect if the original LSD variable is named in the format &quot;X_...&quot;.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+info.details.lsd">info.details.lsd</a>()</code>,
<code><a href="#topic+info.init.lsd">info.init.lsd</a>()</code>
<code><a href="#topic+info.dimensions.lsd">info.dimensions.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# get variable names from first file
info.names.lsd( files[ 1 ] )
</code></pre>

<hr>
<h2 id='info.stats.lsd'>
Compute Monte Carlo statistics from a set of LSD runs
</h2><span id='topic+info.stats.lsd'></span>

<h3>Description</h3>

<p>This function reads a 3 or 4-dimensional array produced by <code><a href="#topic+read.3d.lsd">read.3d.lsd</a></code> or <code><a href="#topic+read.4d.lsd">read.4d.lsd</a></code> and produces a list with 2D data frames containing the (Monte Carlo) mean, the standard deviation, the maximum, the minimum, and other optional statistics for each variable, at each time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.stats.lsd( array, rows = 1, cols = 2, median = FALSE,
                ci = c( "none", "mean", "median", "auto" ),
                ci.conf = 0.95, ci.boot = NULL, boot.R = 999,
                seed = 1, na.rm = TRUE, inf.rm = TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info.stats.lsd_+3A_array">array</code></td>
<td>

<p>a 3D or 4D array as produced by <code><a href="#topic+read.3d.lsd">read.3d.lsd</a></code> and <code><a href="#topic+read.4d.lsd">read.4d.lsd</a></code>, where in the first dimension (rows) you have the time steps, in the second (columns), the variables and in the third/fourth dimension, the Monte Carlo experiments, and the instances in the third dimension (4D arrays only).
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_rows">rows</code></td>
<td>

<p>an integer array dimension to be used as the rows for the statistics matrices, default is to use first array dimension.
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_cols">cols</code></td>
<td>

<p>an integer array dimension to be used as the columns for the statistics matrices, default is to use second array dimension.
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_median">median</code></td>
<td>

<p>a logical value indicating if (<code>TRUE</code>) the median and the median absolute deviation should also be computed. The default (<code>FALSE</code>) is not to compute these statistics.
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_ci">ci</code></td>
<td>

<p>a character string specifying the type of confidence interval to compute, must be one of <code>"none"</code> (default) for no confidence interval computation, <code>"mean"</code>, to compute a confidence interval for the mean, <code>"median"</code>, for the median, or <code>"auto"</code>, to use the option set for the <code>median</code> argument (above). This option can be abbreviated.
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_ci.conf">ci.conf</code></td>
<td>

<p>confidence level of the confidence interval.
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_ci.boot">ci.boot</code></td>
<td>

<p>a character string specifying the type of bootstrap confidence interval to compute, must be one of <code>"basic"</code>, <code>"perc"</code> (percentile interval), or <code>"bca"</code> (BCa - adjusted percentile interval). If set to <code>NULL</code> or an empty string, a regular asymptotic confidence interval is produced (no bootstrap), assuming normal distribution for the mean or using a non-parametric rank test for the median. Non-bootstrap percentiles are much faster to compute but generally less accurate.
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_boot.r">boot.R</code></td>
<td>

<p>number of bootstrap replicates.
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_seed">seed</code></td>
<td>

<p>a single value, interpreted as an integer to define the pseudo-random number generator state used for the bootstrap process, or <code>NULL</code>, to re-initialize the generator as if no seed had yet been set (a new state is created from the current time and the process ID).
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether <code>NA</code> values should be stripped before the computation proceeds.
</p>
</td></tr>
<tr><td><code id="info.stats.lsd_+3A_inf.rm">inf.rm</code></td>
<td>

<p>a logical value indicating whether non-finite values should be stripped before the computation proceeds.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing four to seven matrices, with the original size and naming of the selected 2 dimensions of the argument.
</p>
<table>
<tr><td><code>avg</code></td>
<td>
<p>a matrix with the mean of the MC experiments</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>a matrix with the standard deviation of the MC experiments</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>a matrix with the maximum value of the MC experiments</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>a matrix with the minimum value of the MC experiments</p>
</td></tr>
<tr><td><code>med</code></td>
<td>
<p>a matrix with the median of the MC experiments (only present if argument <code>median = TRUE</code>)</p>
</td></tr>
<tr><td><code>mad</code></td>
<td>
<p>a matrix with the median absolute deviation of the MC experiments (only present if argument <code>median = TRUE</code>)</p>
</td></tr>
<tr><td><code>ci.hi</code></td>
<td>
<p>a matrix with the maximum value of the MC experiments (only present if argument <code>ci</code> is not set to  <code>"none"</code>)</p>
</td></tr>
<tr><td><code>ci.lo</code></td>
<td>
<p>a matrix with the minimum value of the MC experiments (only present if argument <code>ci</code> is not set to <code>"none"</code>)</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a matrix with the number of observations available for computation of statistics</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code>,
<code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code>,
<code><a href="#topic+info.dimensions.lsd">info.dimensions.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# read first instance of all variables from MC files (3D array)
inst1Array &lt;- read.3d.lsd( files )

# create statistics data frames for the variables
inst1Stats &lt;- info.stats.lsd( inst1Array )
print( inst1Stats$avg[ 10 : 20, ] )
print( inst1Stats$sd[ 10 : 20, ] )

# organize the stats, including medians, by variable (dim=2) and file (dim=3)
inst1Stats2 &lt;- info.stats.lsd( inst1Array, rows = 2, cols = 3, median = TRUE )
print( inst1Stats2$med[ , 1 : 2 ] )

# the same but for all instance of all variables (from a 4D array)
# and a normal (non-boostrap) confidence intervals for the means
allArray &lt;- read.4d.lsd( files )
allStats &lt;- info.stats.lsd( allArray, ci = "auto" )
print( allStats$ci.lo[ 3, 1 : 7 ] )
print( allStats$avg[ 3, 1 : 7 ] )
print( allStats$ci.hi[ 3, 1 : 7 ] )

# organize the stats by file (dim=4) and variable (dim=2)
# plus boostrat confidence intervals for the median
allStats2 &lt;- info.stats.lsd( allArray, rows = 4, cols = 2, median = TRUE,
                             ci = "auto", ci.boot = "bca" )
print( allStats2$ci.lo[ , 1 : 3 ] )
print( allStats2$med[ , 1 : 3 ] )
print( allStats2$ci.hi[ , 1 : 3 ] )

</code></pre>

<hr>
<h2 id='list.files.lsd'>
List results files from a set of LSD runs
</h2><span id='topic+list.files.lsd'></span>

<h3>Description</h3>

<p>This function produce a character vector of the names of results files produced after the execution of LSD simulation runs. The list can be used with all function in this package requiring the argument <code>files</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.files.lsd( path = ".", conf.name = "",
                type = c( "res", "tot", "csv" ),
                compressed = NULL, recursive = FALSE,
                join = FALSE, full.names = FALSE,
                sensitivity = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.files.lsd_+3A_path">path</code></td>
<td>

<p>a character vector of full or relative path name to the base directory from where to search the files; the default corresponds to the working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. Tilde expansion is performed. Alternatively, the full path and name of the corresponding LSD configuration file (including the <code>.lsd</code> extension) can be provided.
</p>
</td></tr>
<tr><td><code id="list.files.lsd_+3A_conf.name">conf.name</code></td>
<td>

<p>the LSD configuration file name (optionally including the <code>.lsd</code> extension) used to generate the desired results files; the default is to return all results files, irrespective of the configuration file used. Alternatively, a <a href="base.html#topic+regex">regular expression</a> can be supplied. This argument takes precedence of any configuration file name provided together with the <code>path</code> argument.
</p>
</td></tr>
<tr><td><code id="list.files.lsd_+3A_type">type</code></td>
<td>

<p>the type (format/extension) of LSD results files to use among the options <code>c( "res", "tot", "csv" )</code>, used to define the extension of the files to be considered. <code>"res"</code> is the default. This option can be abbreviated.
</p>
</td></tr>
<tr><td><code id="list.files.lsd_+3A_compressed">compressed</code></td>
<td>

<p>a logical value indicating if (<code>TRUE</code>) to look only for compressed files with <code>.gz</code> extension, or uncompressed ones otherwise (<code>FALSE</code>). The default (<code>NULL</code>) is to list files irrespective if compressed or not.
</p>
</td></tr>
<tr><td><code id="list.files.lsd_+3A_recursive">recursive</code></td>
<td>

<p>a logical value indicating if the listing should recurse into sub-directories of <code>path</code>. The default (<code>FALSE</code>) is to scan just the sub-directory with the same name as <code>conf.name</code> (without the <code>.lsd</code> extension or numeric tags), if present (regular expression in <code>conf.name</code> is not considered), and <code>path</code>. If <code>TRUE</code>, the entire sub-directory tree, starting at <code>path</code>, is scanned for files.
</p>
</td></tr>
<tr><td><code id="list.files.lsd_+3A_join">join</code></td>
<td>

<p>a logical value indicating if results files from multiple sub-directories should be joined together in the return list. The default (<code>FALSE</code>) is to list files from just a single sub-directory, the first one found during the search starting from <code>path</code>.
</p>
</td></tr>
<tr><td><code id="list.files.lsd_+3A_full.names">full.names</code></td>
<td>

<p>a logical value specifying if (<code>TRUE</code>) the file names should be expanded to absolute path names. The default (<code>FALSE</code>) is to use relative (to <code>path</code>) file names.
</p>
</td></tr>
<tr><td><code id="list.files.lsd_+3A_sensitivity">sensitivity</code></td>
<td>

<p>a logical value specifying if (<code>TRUE</code>) the target results files are part of a sensitivity analysis design of experiment (DoE), which are double numbered in a particular format (<code>conf.name_XXX_YYY.res[.gz]</code>). The default (<code>FALSE</code>) is to assume files are just single numbered, which is usually inappropriate for DoE results files. See <a href="LSDsensitivity.html#topic+LSDsensitivity-package">LSDsensitivity package documentation</a> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order by which sub-directories are explored may be relevant. By default, the function scans for results files in a sub-directory named as <code>conf.name</code>, if present, in the given initial directory <code>path</code>. Next, if <code>conf.name</code> has a numeric suffix in the format <code>name_XXX</code>, where XXX is any number of algarisms, it searches the sub-directory <code>name</code>, if present. Finally, it scans the initial <code>path</code> itself. If results files are present in more than one sub-directory, function returns only the files found in first one (except if <code>join = TRUE</code>), and issues a warning message. If <code>recursive = TRUE</code>, file search starts from <code>path</code> and proceeds until it encompasses the entire sub-directory tree. In this case, if multiple sub-directories contain the desired files, only the initial <code>path</code> takes precedence, and the rest of the tree is recurred in alphabetical order.
</p>
<p>Please note that joining files from different sub-directories (<code>join = TRUE</code>) may combine results with incompatible data which cannot be processed together by the <code>read.xxx.lsd()</code> family of functions.
</p>


<h3>Value</h3>

<p>A character vector containing the names of the found results files in the specified (sub) directories (empty if there were no files). If a path does not exist or is not a directory or is unreadable it is skipped.
</p>


<h3>Note</h3>

<p>File naming conventions are platform dependent. The pattern matching works with the case of file names as returned by the OS.
</p>
<p><code>path</code> must specify paths which can be represented in the current codepage, and files/directories below path whose names cannot be represented in that codepage will most likely not be found.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code>,
<code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code>,
<code><a href="#topic+read.raw.lsd">read.raw.lsd</a>()</code>,
<code><a href="#topic+read.single.lsd">read.single.lsd</a>()</code>,
<code><a href="#topic+read.multi.lsd">read.multi.lsd</a>()</code>,
<code><a href="#topic+read.list.lsd">read.list.lsd</a>()</code>,
<a href="LSDsensitivity.html#topic+LSDsensitivity-package">LSDsensitivity package</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the names of all files the example directory
list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# expand search to the entire example directory tree
# for results from a configuration file named "Sim1.lsd"
# and join files found in all sub-directories conatining data
list.files.lsd( system.file( "extdata", package = "LSDinterface" ),
                "Sim1.lsd", recursive = TRUE, join = TRUE )
</code></pre>

<hr>
<h2 id='LSDinterface-package'>
Interface Tools for LSD Simulation Results Files
</h2><span id='topic+LSDinterface'></span>

<h3>Description</h3>

<p>Interfaces R with LSD simulation models. Reads object-oriented data in results files (.res[.gz]) produced by LSD and creates appropriate multi-dimensional arrays in R. Supports multiple core parallel threads of multi-file data reading for increased performance. Also provides functions to extract basic information and statistics from data files. LSD (Laboratory for Simulation Development) is free software developed by Marco Valente and Marcelo C. Pereira (documentation and downloads available at &lt;https://www.labsimdev.org/&gt;).
</p>


<h3>Details</h3>

<p>There are specific <code>read.xxx.lsd()</code> functions for different types of LSD data structures.
</p>
<p><code><a href="#topic+read.raw.lsd">read.raw.lsd</a>()</code> simply import LSD saved data in tabular (data frame) format (variables in columns and time steps in rows). <code><a href="#topic+read.single.lsd">read.single.lsd</a>()</code> is appropriate to simple LSD data structures where each saved variable is single-instanced (inside an object with a single copy). <code><a href="#topic+read.multi.lsd">read.multi.lsd</a>()</code> reads all instances of all variables from the LSD results file, renaming multi-instanced variables. <code><a href="#topic+read.list.lsd">read.list.lsd</a>()</code> is similar to <code><a href="#topic+read.multi.lsd">read.multi.lsd</a>()</code> but saves  multiple-instanced variables as R lists, preventing renaming.
</p>
<p><code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code> and <code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code> are specialized versions for extracting data from multiple LSD results files simultaneously. The files must have the same structure (selected variables and number of time steps). They are frequently used to acquire data from Monte Carlo experiments or sensitivity analysis. <code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code> operates like <code><a href="#topic+read.single.lsd">read.single.lsd</a>()</code> but add each additional results file into a separate dimension of the produced 3-dimensional array (variable x time step x file). <code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code> adds the ability to read each instance of a multi-instanced variable to the fourth dimension of the generated 4D array (variable x instance x time step x file).
</p>
<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code> is a helper function to simplify the collection of results files to be used by the other functions in this package. It can be directly used to supply the <code>files</code> argument in the <code>read.xxx.lsd()</code> family of functions.
</p>
<p><code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a>()</code> and <code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a>()</code> provide methods to extract/summarize information from previously imported LSD data structures.
</p>
<p><code>info.xxx.lsd</code>() functions provide information about LSD data structures. <code>name.xxx.lsd</code>() functions offer tools for dealing with LSD variable names in R.
</p>
<p>For a complete list of exported functions, use <code>library( help = "LSDinterface" )</code>.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: NA
</p>


<h3>References</h3>

<p>LSD documentation is available at <a href="https://www.labsimdev.org/">https://www.labsimdev.org/</a>.
</p>
<p>The latest LSD binaries and source code can be downloaded at <a href="https://github.com/marcov64/Lsd/">https://github.com/marcov64/Lsd/</a>.
</p>

<hr>
<h2 id='name.check.lsd'>
Check a set of LSD variables names against a LSD results file
</h2><span id='topic+name.check.lsd'></span>

<h3>Description</h3>

<p>This function checks if all variable names in a set are valid for a LSD results file (.res). If no name is provided, the function returns all the valid unique variable names in the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.check.lsd( file, col.names = NULL, check.names = TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.check.lsd_+3A_file">file</code></td>
<td>

<p>the name of the LSD results file which the data are to be read from. If it does not contain an absolute path, the file name is relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. This can be a compressed file (see file) and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
<tr><td><code id="name.check.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables. The default is to read all (unique) variable names.
</p>
</td></tr>
<tr><td><code id="name.check.lsd_+3A_check.names">check.names</code></td>
<td>

<p>logical. If <code>TRUE</code> then the names of the variables are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted to ensure that there are no duplicates.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a string vector containing the (original) valid variable names contained in the results file, using LSD/C++ naming conventions.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+info.names.lsd">info.names.lsd</a>()</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# check all variable names
name.check.lsd( files[ 1 ] )

# check just two names
name.check.lsd( files[ 2 ], col.names = c( "GDP", "_growth1" ) )
</code></pre>

<hr>
<h2 id='name.clean.lsd'>Get clean (R) variable name</h2><span id='topic+name.clean.lsd'></span>

<h3>Description</h3>

<p>This function produces a more appropriate variable name from R initial column name conversion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.clean.lsd( r.name )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.clean.lsd_+3A_r.name">r.name</code></td>
<td>

<p>a string, a vector of strings, or an object which can be coerced to a character vector by <code>as.character</code>, from the column names produced by reading a LSD results file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function removes the extra/ending '.' characters introduced by R and introduces a '_' between time span values.
</p>


<h3>Value</h3>

<p>A string or a string vector with the same attributes as x (after possible coercion) and the format <code>NAME.POSITION.INI_END</code>.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+name.var.lsd">name.var.lsd</a>()</code>,
<code><a href="#topic+name.nice.lsd">name.nice.lsd</a>()</code>,
<code><a href="#topic+info.names.lsd">info.names.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name.clean.lsd( "Var1.1_1..1.100." )

name.clean.lsd( c( "Var1.1_1..1.100.", "Var2.1_2_3..50.70." ) )
</code></pre>

<hr>
<h2 id='name.nice.lsd'>Get a nice (R) variable name</h2><span id='topic+name.nice.lsd'></span>

<h3>Description</h3>

<p>This function produces a nicer variable name from R initial column name conversion, in particular removing leading underscores.</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.nice.lsd( r.name )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.nice.lsd_+3A_r.name">r.name</code></td>
<td>

<p>a string, a vector of strings, or an object which can be coerced to a character vector by <code>as.character</code>, from the column names produced by reading a LSD results file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function removes the extra/ending '.' characters introduced by R and introduces a '_' between time span values and deletes leading underscores ('_'), converted to 'X_' by R.
</p>


<h3>Value</h3>

<p>A string or a string vector with the same attributes as x (after possible coercion) and the format <code>NAME[.POSITION.INI_END]</code>.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+name.var.lsd">name.var.lsd</a>()</code>,
<code><a href="#topic+name.clean.lsd">name.clean.lsd</a>()</code>,
<code><a href="#topic+info.names.lsd">info.names.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name.nice.lsd( "X_Var1.1_1..1.100." )

name.nice.lsd( c( "_Var1.1_1..1.100.", "X_Var2.1_2_3..50.70." ) )

name.nice.lsd( c( "_Var1", "X_Var2" ) )
</code></pre>

<hr>
<h2 id='name.r.unique.lsd'>Get valid unique R variable name</h2><span id='topic+name.r.unique.lsd'></span>

<h3>Description</h3>

<p>This function produces a valid and unique variable name from names produced from multi-instanced LSD variables (as in <code>read.raw.lsd</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.r.unique.lsd( r.name )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.r.unique.lsd_+3A_r.name">r.name</code></td>
<td>

<p>a string, a vector of strings, or an object which can be coerced to a character vector by <code>as.character</code>, from the column names produced by reading a LSD results file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function removes the trailing '.' characters, and the text between, introduced during the conversion from LSD results files, add an 'X' prefix to names started by an '_'. After this initial transformation, all repeated variable names (originated from multi-instanced variables) are removed.
</p>
<p>The produced names are R valid variable names, similar to the original LSD/C++ variable names, but with an 'X' prepended to variables starting with an '_' (which are invalid in R).
</p>


<h3>Value</h3>

<p>A string or a string vector of converted string(s) including only non-repeated ones.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+name.var.lsd">name.var.lsd</a>()</code>,
<code><a href="#topic+name.clean.lsd">name.clean.lsd</a>()</code>,
<code><a href="#topic+name.nice.lsd">name.nice.lsd</a>()</code>,
<code><a href="#topic+info.names.lsd">info.names.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name.r.unique.lsd( "Var1.1_1.1_100" )

name.r.unique.lsd( c( "Var1.1_1.1_100", "_Var2.1_1.1_100", "_Var2.1_2.50_70" ) )
</code></pre>

<hr>
<h2 id='name.var.lsd'>
Get original LSD variable name
</h2><span id='topic+name.var.lsd'></span>

<h3>Description</h3>

<p>This function generates the original LSD variable name, as it was defined in LSD and before R adjusts the name, from a R column name (with or without position or timing information appended).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.var.lsd( r.name )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.var.lsd_+3A_r.name">r.name</code></td>
<td>

<p>a string, a vector of strings, or an object which can be coerced to a character vector by <code>as.character</code>, from the column names produced by reading a LSD results file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion may be incorrect if the original LSD variable is named in the format &quot;X_...&quot;. No checking is done to make sure the variable really exists.
</p>


<h3>Value</h3>

<p>A string or a string vector with the same attributes as x (after possible coercion).
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+name.clean.lsd">name.clean.lsd</a>()</code>,
<code><a href="#topic+info.names.lsd">info.names.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name.var.lsd( "label" )

name.var.lsd( c( "label", "X_underlinelabel" ) )
</code></pre>

<hr>
<h2 id='read.3d.lsd'>
Read one instance of LSD variables (time series) from multiple LSD results files into a 3D array
</h2><span id='topic+read.3d.lsd'></span>

<h3>Description</h3>

<p>This function reads the data series associated to a specific instance of each selected variable from a set of LSD results files (.res) and saves them into a 3-dimensional array (time step x variable x file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.3d.lsd( files, col.names = NULL, nrows = -1, skip = 0,
             check.names = TRUE, instance = 1, nnodes = 1,
             posit = NULL, posit.match = c( "fixed", "glob", "regex" ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.3d.lsd_+3A_files">files</code></td>
<td>

<p>a character vector containing the names of the LSD results files which the data are to be read from. If they do not contain an absolute path, the file names are relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. These can be compressed files and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
<tr><td><code id="read.3d.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables. The default is to read all variables.
</p>
</td></tr>
<tr><td><code id="read.3d.lsd_+3A_nrows">nrows</code></td>
<td>

<p>integer: the maximum number of time steps (rows) to read in. Negative and other invalid values are ignored. The default is to read all rows.
</p>
</td></tr>
<tr><td><code id="read.3d.lsd_+3A_skip">skip</code></td>
<td>

<p>integer: the number of time steps (rows) of the results file to skip before beginning to read data. The default is to read from the first time step (t = 1).
</p>
</td></tr>
<tr><td><code id="read.3d.lsd_+3A_check.names">check.names</code></td>
<td>

<p>logical. If <code>TRUE</code> the names of the variables are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted (by make.names) so that they are, and also to ensure that there are no duplicates.
</p>
</td></tr>
<tr><td><code id="read.3d.lsd_+3A_instance">instance</code></td>
<td>

<p>integer: the instance of the variable to be read, for variables that exist in more than one object. This number is based on the position (column) of the variable in the results file. The default (1) is to read first instances.
</p>
</td></tr>
<tr><td><code id="read.3d.lsd_+3A_nnodes">nnodes</code></td>
<td>

<p>integer: the maximum number of parallel computing nodes (parallel threads) in the current computer to be used for reading the files. The default, <code>nnodes = 1</code>, means single thread processing (no parallel threads). If equal to zero, creates up to one node per CPU core. Only <code>PSOCK</code> clusters are used, to ensure compatibility with any platform. Please note that each node requires its own memory space, so memory usage increases linearly with the number of nodes.
</p>
</td></tr>
<tr><td><code id="read.3d.lsd_+3A_posit">posit</code></td>
<td>

<p>a string, a vector of strings or an integer vector describing the LSD object position of the variable(s) to select. If an integer vector, it should define the position of a SINGLE LSD object. If a string or vector of strings, each element should define one or more different LSD objects, so the returning matrix may contain variables from more than one object. By setting <code>posit.match</code>, globbing (wildcard), and regular expressions can be used to select multiple objects at once.
</p>
</td></tr>
<tr><td><code id="read.3d.lsd_+3A_posit.match">posit.match</code></td>
<td>

<p>a string defining how the <code>posit</code> argument, if provided, should be matched against the LSD object positions. If equal to <code>"fixed"</code>, the default, only exact matching is done. <code>"glob"</code> allows using simple wildcard characters ('*' and '?') in <code>posit</code> for matching. If <code>posit.match="regex"</code> interpret <code>posit</code> as POSIX 1003.2 extended regular expression(s). See <code><a href="base.html#topic+regex">regular expressions</a></code> for details of the different types of regular expressions. Options can be abbreviated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection restriction arguments can be provided as needed; when not specified, all available cases are considered, but just one <code>instance</code> is considered.
</p>
<p>When <code>posit</code> is supplied together with <code>col.names</code> or <code>instance</code>, the selection process is done in two steps. Firstly, the column names and the instance position set by <code>col.names</code> and <code>instance</code> are selected. Secondly, the instances defined by <code>posit</code> are selected from the first selection set.
</p>
<p>See <code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a></code> and <code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a></code> for examples on how to apply advanced selection options.
</p>


<h3>Value</h3>

<p>Returns a 3D array containing data series from the selected variables.
</p>
<p>The array dimension order is: time x variable x file.
</p>


<h3>Note</h3>

<p>If the selected files don't have the same columns available (names and instances), after column selection, an error is produced.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code>,
<code><a href="#topic+read.single.lsd">read.single.lsd</a>()</code>,
<code><a href="#topic+read.multi.lsd">read.multi.lsd</a>()</code>,
<code><a href="#topic+read.list.lsd">read.list.lsd</a>()</code>,
<code><a href="#topic+read.raw.lsd">read.raw.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# read first instance of all variables from files (one level each),
# pasting the directory where the example files are (not required if in working dir)
inst1Array &lt;- read.3d.lsd( files )
print( inst1Array[ 5 : 10, 1 : 7, 1 ] )
print( inst1Array[ 5 : 10, 1 : 7, 2 ] )
print( inst1Array[ 5 : 10, 1 : 7, 3 ] )

# read first instance of a set of variables named _A1p and _growth1
ab1Array &lt;- read.3d.lsd( files, c( "_A1p", "_growth1" ) )
print( ab1Array[ 20 : 25, , 1 ] )
print( ab1Array[ 20 : 25, , 2 ] )
print( ab1Array[ 20 : 25, , 3 ] )

# read instance 2 of all variables, skipping the initial 20 time steps
# and keeping up to 30 time steps (from t = 21 up to t = 30)
inst2Array21_30 &lt;- read.3d.lsd( files, skip = 20, nrows = 30, instance = 2 )
print( inst2Array21_30[ , , "Sim1_1" ] )   # use the file name to retrieve
print( inst2Array21_30[ , , "Sim1_2" ] )

# read instance 5 of all variables in second-level objects, using up to 2 cores
inst5array2 &lt;- read.3d.lsd( files, instance = 2, posit = "*_*",
                            posit.match = "glob", nnodes = 2 )
print( inst5array2[ 11 : 20, , 1 ] )
</code></pre>

<hr>
<h2 id='read.4d.lsd'>
Read multiple instances of LSD variables (time series) from a set of LSD results file into a 4D array
</h2><span id='topic+read.4d.lsd'></span>

<h3>Description</h3>

<p>This function reads the data series associated to a set of instances of each selected variable from a set of LSD results files (.res) and saves them into a 4-dimensional array (time x variable x instance x file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.4d.lsd( files, col.names = NULL, nrows = -1, skip = 0,
             check.names = TRUE, pool = FALSE, nnodes = 1,
             posit = NULL, posit.match = c( "fixed", "glob", "regex" ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.4d.lsd_+3A_files">files</code></td>
<td>

<p>a character vector containing the names of the LSD results files which the data are to be read from. If they do not contain an absolute path, the file names are relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. These can be compressed files and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
<tr><td><code id="read.4d.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables. The default is to read all variables.
</p>
</td></tr>
<tr><td><code id="read.4d.lsd_+3A_nrows">nrows</code></td>
<td>

<p>integer: the maximum number of time steps (rows) to read in. Negative and other invalid values are ignored. The default is to read all rows.
</p>
</td></tr>
<tr><td><code id="read.4d.lsd_+3A_skip">skip</code></td>
<td>

<p>integer: the number of time steps (rows) of the results file to skip before beginning to read data. The default is to read from the first time step (t = 1).
</p>
</td></tr>
<tr><td><code id="read.4d.lsd_+3A_check.names">check.names</code></td>
<td>

<p>logical. If <code>TRUE</code> the names of the variables are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted (by make.names) so that they are, and also to ensure that there are no duplicates.
</p>
</td></tr>
<tr><td><code id="read.4d.lsd_+3A_pool">pool</code></td>
<td>

<p>logical. If <code>TRUE</code>, variables instances from all files are concatenated (by columns) as a single 3-dimensional array. If <code>FALSE</code> (the default), each file is saved as a separated dimension (fourth) in the array.
</p>
</td></tr>
<tr><td><code id="read.4d.lsd_+3A_nnodes">nnodes</code></td>
<td>

<p>integer: the maximum number of parallel computing nodes (parallel threads) in the current computer to be used for reading the files. The default, <code>nnodes = 1</code>, means single thread processing (no parallel threads). If equal to zero, creates up to one node per CPU core. Only <code>PSOCK</code> clusters are used, to ensure compatibility with any platform. Please note that each node requires its own memory space, so memory usage increases linearly with the number of nodes.
</p>
</td></tr>
<tr><td><code id="read.4d.lsd_+3A_posit">posit</code></td>
<td>

<p>a string, a vector of strings or an integer vector describing the LSD object position of the variable(s) to select. If an integer vector, it should define the position of a SINGLE LSD object. If a string or vector of strings, each element should define one or more different LSD objects, so the returning matrix will contain variables from more than one object. By setting <code>posit.match</code>, globbing (wildcard), and regular expressions can be used to select multiple objects at once; in this case, all matching objects are returned.
</p>
</td></tr>
<tr><td><code id="read.4d.lsd_+3A_posit.match">posit.match</code></td>
<td>

<p>a string defining how the <code>posit</code> argument, if provided, should be matched against the LSD object positions. If equal to <code>"fixed"</code>, the default, only exact matching is done. <code>"glob"</code> allows using simple wildcard characters ('*' and '?') in <code>posit</code> for matching. If <code>posit.match="regex"</code> interpret <code>posit</code> as POSIX 1003.2 extended regular expression(s). See <code><a href="base.html#topic+regex">regular expressions</a></code> for details of the different types of regular expressions. Options can be abbreviated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection restriction arguments can be provided as needed; when not specified, all available cases are selected.
</p>
<p>When <code>posit</code> is supplied together with <code>col.names</code>, the selection process is done in two steps. Firstly, the column names set by <code>col.names</code> are selected. Secondly, the instances defined by <code>posit</code> are selected from the first selection set.
</p>
<p>See <code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a></code> and <code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a></code> for examples on how to apply advanced selection options.
</p>


<h3>Value</h3>

<p>Returns a 4D array containing data series for each instance from the selected variables.
</p>
<p>The array dimension order is: time x variable x instance x file.
</p>
<p>When <code>pool = TRUE</code>, the produced array is 3-dimensional. Pooling require that selected columns contains EXACTLY the same variables (number of instances may be different).
</p>


<h3>Note</h3>

<p>If the selected files don't have the same columns available (names), after column selection, an error is produced.
</p>
<p>When using the option <code>pool = TRUE</code>, columns from multiple files are consolidated with their original names plus the file name, to keep all column names unique. Use <code><a href="#topic+name.var.lsd">name.var.lsd</a></code> to get just the LSD name of the variable corresponding to each column.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code>,
<code><a href="#topic+read.single.lsd">read.single.lsd</a>()</code>,
<code><a href="#topic+read.multi.lsd">read.multi.lsd</a>()</code>,
<code><a href="#topic+read.list.lsd">read.list.lsd</a>()</code>,
<code><a href="#topic+read.raw.lsd">read.raw.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# read all instances of all variables from files,
allArray &lt;- read.4d.lsd( files )
print( allArray[ 1 : 10, 1 : 7, 1, 1 ] ) # 1st instance of 1st file (7 vars and 10 times)
print( allArray[ 11 : 20, "X_A1p", , "Sim1_2" ] ) # all instances of _A1p in Sim1_2 (10 times)
print( allArray[ 50, 9, , ] ) # all instances of all files of 9th variable for t=50

# the same, but pooling all files into a single (3D!) array
allArrayPool &lt;- read.4d.lsd( files, pool = TRUE )
print( allArrayPool[ 1 : 10, 8 : 9, 3 ] ) # 3rd instances of last 2 vars (10 times)
print( allArrayPool[ 11 : 20, "X_A1p", 4 : 9 ] ) # 6 instances of _A1p variable (10 times)
print( allArrayPool[ 50, 9, 4 : 9 ] ) # 6 instances of all files of 9th variable for t=50

# read instances of a set of variables named '_A1p' and '_growth1'
abArray &lt;- read.4d.lsd( files, c( "_A1p", "_growth1" ) )
print( abArray[ 1 : 10, , 1, 2 ] ) # 1st instances of 2nd file (all vars and 10 times)
print( abArray[ 11 : 20, 2, , "Sim1_3" ] ) # all instances of 2nd variable in Sim1_3 (10 times)
print( abArray[ 50, "X_A1p", , ] ) # all instances of all files of _A1p variable for t=50

# read all variables/variables, skipping the initial 20 time steps
# and keeping up to 30 time steps (from t = 21 up to t = 30)
allArray21_30 &lt;- read.4d.lsd( files, skip = 20, nrows = 30 )
print( allArray21_30[ , "X_growth1", , 2 ] ) # all instances of _growth1 variable in 2nd file
print( allArray21_30[ 10, 8, , ] ) # all instances of all files of 8th variable for t=30

# read all variables in second-level objects, using up to 2 cores for processing
abArray2 &lt;- read.4d.lsd( files, posit = "*_*", posit.match = "glob", nnodes = 2 )
print( abArray2[ 11 : 20, , 5, "Sim1_1" ] ) # 5th instances in Sim1_1 file
</code></pre>

<hr>
<h2 id='read.list.lsd'>
Read one or more instances of LSD variables (time series) from a set of LSD results file into a list
</h2><span id='topic+read.list.lsd'></span>

<h3>Description</h3>

<p>This function reads the data series associated to a specific or a set of instances of each selected variable from a set of LSD results file (.res) and saves them into separated matrices (one per file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.list.lsd( files, col.names = NULL, nrows = -1, skip = 0,
               check.names = TRUE, instance = 0, pool = FALSE, nnodes = 1,
               posit = NULL, posit.match = c( "fixed", "glob", "regex" ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.list.lsd_+3A_files">files</code></td>
<td>

<p>a character vector containing the names of the LSD results files which the data are to be read from. If they do not contain an absolute path, the file names are relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. These can be compressed files and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables. The default is to read all variables.
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_nrows">nrows</code></td>
<td>

<p>integer: the maximum number of time steps (rows) to read in. Negative and other invalid values are ignored. The default is to read all rows.
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_skip">skip</code></td>
<td>

<p>integer: the number of time steps (rows) of the results file to skip before beginning to read data. The default is to read from the first time step (t = 1).
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_check.names">check.names</code></td>
<td>

<p>logical. If <code>TRUE</code> the names of the variables are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted (by make.names) so that they are, and also to ensure that there are no duplicates.
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_instance">instance</code></td>
<td>

<p>integer: the instance of the variable to be read, for variables that exist in more than one object. This number is based on the position (column) of the variable in the results file. The default (0) is to read all instances.
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_pool">pool</code></td>
<td>

<p>logical. If <code>TRUE</code>, variables instances from all files are concatenated (by columns) into a single matrix. If <code>FALSE</code> (the default), each file is saved as a separated matrix in a list.
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_nnodes">nnodes</code></td>
<td>

<p>integer: the maximum number of parallel computing nodes (parallel threads) in the current computer to be used for reading the files. The default, <code>nnodes = 1</code>, means single thread processing (no parallel threads). If equal to zero, creates up to one node per CPU core. Only <code>PSOCK</code> clusters are used, to ensure compatibility with any platform. Please note that each node requires its own memory space, so memory usage increases linearly with the number of nodes.
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_posit">posit</code></td>
<td>

<p>a string, a vector of strings or an integer vector describing the LSD object position of the variable(s) to select. If an integer vector, it should define the position of a SINGLE LSD object. If a string or vector of strings, each element should define one or more different LSD objects, so the returning matrix will contain variables from more than one object. By setting <code>posit.match</code>, globbing (wildcard), and regular expressions can be used to select multiple objects at once; in this case, all matching objects are returned.
</p>
</td></tr>
<tr><td><code id="read.list.lsd_+3A_posit.match">posit.match</code></td>
<td>

<p>a string defining how the <code>posit</code> argument, if provided, should be matched against the LSD object positions. If equal to <code>"fixed"</code>, the default, only exact matching is done. <code>"glob"</code> allows using simple wildcard characters ('*' and '?') in <code>posit</code> for matching. If <code>posit.match="regex"</code> interpret <code>posit</code> as POSIX 1003.2 extended regular expression(s). See <code><a href="base.html#topic+regex">regular expressions</a></code> for details of the different types of regular expressions. Options can be abbreviated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection restriction arguments can be provided as needed; when not specified, all available cases are selected.
</p>
<p>When <code>posit</code> is supplied together with <code>col.names</code> or <code>instance</code>, the selection process is done in two steps. Firstly, the column names and instance positions set by <code>col.names</code> and <code>instance</code> are selected. Secondly, the instances defined by <code>posit</code> are selected from the first selection set.
</p>
<p>See <code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a></code> and <code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a></code> for examples on how to apply advanced selection options.
</p>


<h3>Value</h3>

<p>Returns a named list of matrices with the selected variables' time series in the results files. If <code>pool = TRUE</code>, the return value is a single, consolidated matrix (column names are not unique).
</p>
<p>The matrices dimension order is: time x variable.
</p>
<p>Matrix column names are only &quot;cleaned&quot; if there are just single instanced variables selected. When multiple instanced variables are present, the column names include all the header information contained in the LSD results file. The name of the LSD variable associated to any column name can be retrieved with <code><a href="#topic+name.var.lsd">name.var.lsd</a></code>.
</p>


<h3>Note</h3>

<p>When using the option <code>pool = TRUE</code>, columns from multiple files are consolidated with their original names plus the file name, to keep all column names unique. Use <code><a href="#topic+name.var.lsd">name.var.lsd</a></code> to get just the LSD name of the variable corresponding to each column.
</p>
<p>The returned matrices may be potentially very wide, in particular if variables are not well selected(see <code>col.names</code> above) or if there is a large number of instances.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+name.var.lsd">name.var.lsd</a>()</code>
<code><a href="#topic+read.single.lsd">read.single.lsd</a>()</code>,
<code><a href="#topic+read.multi.lsd">read.multi.lsd</a>()</code>,
<code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code>,
<code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code>,
<code><a href="#topic+read.raw.lsd">read.raw.lsd</a>()</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# read all instances of all variables from three files (one matrix each),
tableList &lt;- read.list.lsd( files )
print( tableList[[ 1 ]][ 1 : 5, 1 : 7 ] )
print( tableList[[ 2 ]][ 1 : 5, 1 : 7 ] )
print( tableList[[ 3 ]][ 1 : 5, 1 : 7 ] )

# read all instances of a set of variables named '_A1p' and '_growth1'
# and pool data into a single matrix
abTable &lt;- read.list.lsd( files, c( "_A1p", "_growth1" ), pool = TRUE )
print( abTable[ 10 : 20, 10 : 12 ] )

# read instance 4 of all variables, skipping the initial 20 time steps
# and keeping up to 30 time steps (from t = 21 up to t = 30)
inst4List21_30 &lt;- read.list.lsd( files, skip = 20, nrows = 30, instance = 4 )
print( inst4List21_30[[ 1 ]] )
print( inst4List21_30[[ 2 ]] )

# read all variables in top-level objects, using up to 2 cores for processing
instTop &lt;- read.list.lsd( files, posit = 1, nnodes = 2 )
print( instTop$Sim1_1[ 11 : 20, ] )   # use the file name to retrieve list item
print( instTop$Sim1_2[ 11 : 20, ] )
</code></pre>

<hr>
<h2 id='read.multi.lsd'>
Read all instances of LSD variables (time series) from a LSD results file
</h2><span id='topic+read.multi.lsd'></span>

<h3>Description</h3>

<p>This function reads the data series associated to all instances of each selected variable from a LSD results file (.res).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.multi.lsd( file, col.names = NULL, nrows = -1, skip = 0,
                check.names = TRUE, posit = NULL,
                posit.match = c( "fixed", "glob", "regex" ),
                posit.cols = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.multi.lsd_+3A_file">file</code></td>
<td>

<p>the name of the LSD results file which the data are to be read from. If it does not contain an absolute path, the file name is relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. This can be a compressed file (see file) and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
<tr><td><code id="read.multi.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables. The default is to read all variables.
</p>
</td></tr>
<tr><td><code id="read.multi.lsd_+3A_nrows">nrows</code></td>
<td>

<p>integer: the maximum number of time steps (rows) to read in. Negative and other invalid values are ignored. The default is to read all rows.
</p>
</td></tr>
<tr><td><code id="read.multi.lsd_+3A_skip">skip</code></td>
<td>

<p>integer: the number of time steps (rows) of the results file to skip before beginning to read data. The default is to read from the first time step (t = 1).
</p>
</td></tr>
<tr><td><code id="read.multi.lsd_+3A_check.names">check.names</code></td>
<td>

<p>logical. If <code>TRUE</code> the names of the variables are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted (by make.names) so that they are, and also to ensure that there are no duplicates.
</p>
</td></tr>
<tr><td><code id="read.multi.lsd_+3A_posit">posit</code></td>
<td>

<p>a string, a vector of strings or an integer vector describing the LSD object position of the variable(s) to select. If an integer vector, it should define the position of a SINGLE LSD object. If a string or vector of strings, each element should define one or more different LSD objects, so the returning matrix will contain variables from more than one object. By setting <code>posit.match</code>, globbing (wildcard), and regular expressions can be used to select multiple objects at once; in this case, all matching objects are returned.
</p>
</td></tr>
<tr><td><code id="read.multi.lsd_+3A_posit.match">posit.match</code></td>
<td>

<p>a string defining how the <code>posit</code> argument, if provided, should be matched against the LSD object positions. If equal to <code>"fixed"</code>, the default, only exact matching is done. <code>"glob"</code> allows using simple wildcard characters ('*' and '?') in <code>posit</code> for matching. If <code>posit.match="regex"</code> interpret <code>posit</code> as POSIX 1003.2 extended regular expression(s). See <code><a href="base.html#topic+regex">regular expressions</a></code> for details of the different types of regular expressions. Options can be abbreviated.
</p>
</td></tr>
<tr><td><code id="read.multi.lsd_+3A_posit.cols">posit.cols</code></td>
<td>

<p>logical. If <code>TRUE</code> just the position information is used as the names of the columns in each variable list. If <code>FALSE</code>, the default, the column names include all the header information contained in the LSD results file (name, position and time span).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection restriction arguments can be provided as needed; when not specified, all available cases are selected.
</p>
<p>When <code>posit</code> is supplied together with <code>col.names</code>, the selection process is done in two steps. Firstly, the column names set by <code>col.names</code> are selected. Secondly, the instances defined by <code>posit</code> are selected from the first selection set.
</p>
<p>See <code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a></code> and <code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a></code> for examples on how to apply advanced selection options.
</p>


<h3>Value</h3>

<p>Returns a named list of matrices, each containing one of the selected variables' time series from the results file.
</p>
<p>Variable names are converted to valid R ones when defining list names. Matrix column names are not &quot;cleaned&quot;, even for single instanced variables. The column names include all the header information contained in the LSD results file.
</p>


<h3>Note</h3>

<p>For extracting data from multiple similar files (like sensitivity analysis results), see <code><a href="#topic+read.list.lsd">read.list.lsd</a></code>.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+read.single.lsd">read.single.lsd</a>()</code>,
<code><a href="#topic+read.list.lsd">read.list.lsd</a>()</code>,
<code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code>,
<code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code>,
<code><a href="#topic+read.raw.lsd">read.raw.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# load first .res file into a simple matrix (all instances),
macroList &lt;- read.multi.lsd( files[ 1 ] )
length( macroList )           # number of lists holding variables
names( macroList )            # name of each list
print( macroList[[ 1 ]][ 1 : 5, , drop = FALSE ] )
print( macroList$X_A1p[ 10 : 20, ] )

# read first instance of 2 variables, skipping the initial 20 time steps
# and keeping up to 30 time steps (from t = 21 up to t = 30), positions in cols
varsList21_30 &lt;- read.multi.lsd( files[ 2 ], c( "_A1p", "_growth1" ),
                                 skip = 20, nrows = 30, posit.cols = TRUE )
print( varsList21_30[[ 1 ]] )
print( varsList21_30$X_growth1 )
</code></pre>

<hr>
<h2 id='read.raw.lsd'>
Read LSD results file and clean variables names
</h2><span id='topic+read.raw.lsd'></span>

<h3>Description</h3>

<p>This function reads all the data series in a LSD results file (.res).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.raw.lsd( file, nrows = -1, skip = 0, col.names = NULL,
              check.names = TRUE, clean.names = FALSE, instance = 0,
              posit = NULL, posit.match = c( "fixed", "glob", "regex" ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.raw.lsd_+3A_file">file</code></td>
<td>

<p>the name of the LSD results file which the data are to be read from. If it does not contain an absolute path, the file name is relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. This can be a compressed file (see file) and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
<tr><td><code id="read.raw.lsd_+3A_nrows">nrows</code></td>
<td>

<p>integer: the maximum number of time steps (rows) to read in. Negative and other invalid values are ignored. The default is to read all rows.
</p>
</td></tr>
<tr><td><code id="read.raw.lsd_+3A_skip">skip</code></td>
<td>

<p>integer: the number of time steps (rows) of the results file to skip before beginning to read data. The default is to read from the first time step (t = 1).
</p>
</td></tr>
<tr><td><code id="read.raw.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables. The default is to read all variables. The names must to be in LSD/C++ format, without dots (&quot;.&quot;) in the name. Any dot (and trailing characters) will be automatically removed.
</p>
</td></tr>
<tr><td><code id="read.raw.lsd_+3A_check.names">check.names</code></td>
<td>

<p>logical. If <code>TRUE</code> the names of the variables are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted to ensure that there are no duplicates.
</p>
</td></tr>
<tr><td><code id="read.raw.lsd_+3A_clean.names">clean.names</code></td>
<td>

<p>logical. If <code>TRUE</code> the names of the variables in the columns are &quot;cleaned&quot; to remove extra information from the header in the LSD results file. This option is incompatible (and will be ignored) when multiple instances of a single variable are selected. If <code>FALSE</code>, the default, preserve extra information in the names.
</p>
</td></tr>
<tr><td><code id="read.raw.lsd_+3A_instance">instance</code></td>
<td>

<p>integer: the instance of the variable to be read, for variables that exist in more than one object. This number is based on the relative position (column) of the variable in the results file. The default (0) is to read all instances.
</p>
</td></tr>
<tr><td><code id="read.raw.lsd_+3A_posit">posit</code></td>
<td>

<p>a string, a vector of strings or an integer vector describing the LSD object position of the variable(s) to select. If an integer vector, it should define the position of a SINGLE LSD object. If a string or vector of strings, each element should define one or more different LSD objects, so the returning matrix will contain variables from more than one object. By setting <code>posit.match</code>, globbing (wildcard), and regular expressions can be used to select multiple objects at once; in this case, all matching objects are returned.
</p>
</td></tr>
<tr><td><code id="read.raw.lsd_+3A_posit.match">posit.match</code></td>
<td>

<p>a string defining how the <code>posit</code> argument, if provided, should be matched against the LSD object positions. If equal to <code>"fixed"</code>, the default, only exact matching is done. <code>"glob"</code> allows using simple wildcard characters ('*' and '?') in <code>posit</code> for matching. If <code>posit.match="regex"</code> interpret <code>posit</code> as POSIX 1003.2 extended regular expression(s). See <code><a href="base.html#topic+regex">regular expressions</a></code> for details of the different types of regular expressions. Options can be abbreviated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection restriction arguments can be provided as needed; when not specified, all available cases are selected.
</p>
<p>When <code>posit</code> is supplied together with <code>col.names</code> or <code>instance</code>, the selection process is done in two steps. Firstly, the column names and instance positions set by <code>col.names</code> and <code>instance</code> are selected. Secondly, the instances defined by <code>posit</code> are selected from the first selection set.
</p>
<p>See <code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a></code> and <code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a></code> for examples on how to apply advanced selection options.
</p>


<h3>Value</h3>

<p>Returns a single matrix containing all variables' time series contained in the results file.
</p>


<h3>Note</h3>

<p>The returned matrix may be potentially very wide.
See <code><a href="#topic+read.single.lsd">read.single.lsd</a></code> for more polished column names. To use multiple results files simultaneously, see <code><a href="#topic+read.list.lsd">read.list.lsd</a></code> and <code><a href="#topic+read.3d.lsd">read.3d.lsd</a></code>.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+read.single.lsd">read.single.lsd</a>()</code>,
<code><a href="#topic+read.multi.lsd">read.multi.lsd</a>()</code>,
<code><a href="#topic+read.list.lsd">read.list.lsd</a>()</code>,
<code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code>,
<code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code>,
<code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a>()</code>,
<code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# read all instances of all variables of first file,
bigTable &lt;- read.raw.lsd( files[ 1 ] )
print( bigTable[ 1 : 5, 1 : 7 ] )

# read all instances of all variables, skipping the initial 20 time steps
# and keeping up to 30 time steps (from t = 21 up to t = 30)
all21_30 &lt;- read.raw.lsd( files[ 2 ], skip = 20, nrows = 30 )
print( all21_30[ , 1 : 7 ] )

# read the third instances of a set of variables named '_A1p' and '_growth1'
abTable &lt;- read.raw.lsd( files[ 1 ], col.names = c( "_A1p", "_growth1" ),
                         instance = 3 )
print( abTable[ 10 : 20, ] )

# read instances of variable '_A1p' for the second and fourth objects under
# any top-level object (use globbing)
a24 &lt;- read.raw.lsd( files[ 1 ], col.names = "_A1p",
                     posit = c( "*_2", "*_4" ), posit.match = "glob" )
print( a24[ 1 : 10, ] )
</code></pre>

<hr>
<h2 id='read.single.lsd'>
Read LSD variables (time series) from a LSD results file (a single instance of each variable only)
</h2><span id='topic+read.single.lsd'></span>

<h3>Description</h3>

<p>This function reads the data series associated to one instance of each selected variable from a LSD results file (.res). Just a single instance (time series of a single LSD object) is read at each call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.single.lsd( file, col.names = NULL, nrows = -1, skip = 0,
                 check.names = TRUE, instance = 1, posit = NULL,
                 posit.match = c( "fixed", "glob", "regex" ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.single.lsd_+3A_file">file</code></td>
<td>

<p>the name of the LSD results file which the data are to be read from. If it does not contain an absolute path, the file name is relative to the current working directory, <code><a href="base.html#topic+getwd">getwd</a>()</code>. This can be a compressed file (see file) and must include the appropriated extension (usually <code>.res</code> or <code>.res.gz</code>).
</p>
</td></tr>
<tr><td><code id="read.single.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables. The default is to read all variables. The names must to be in LSD/C++ format, without dots (&quot;.&quot;) in the name. Any dot (and trailing characters) will be automatically removed.
</p>
</td></tr>
<tr><td><code id="read.single.lsd_+3A_nrows">nrows</code></td>
<td>

<p>integer: the maximum number of time steps (rows) to read in. Negative and other invalid values are ignored. The default is to read all rows.
</p>
</td></tr>
<tr><td><code id="read.single.lsd_+3A_skip">skip</code></td>
<td>

<p>integer: the number of time steps (rows) of the results file to skip before beginning to read data. The default is to read from the first time step (t = 1).
</p>
</td></tr>
<tr><td><code id="read.single.lsd_+3A_check.names">check.names</code></td>
<td>

<p>logical. If <code>TRUE</code> the names of the variables are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted to ensure that there are no duplicates.
</p>
</td></tr>
<tr><td><code id="read.single.lsd_+3A_instance">instance</code></td>
<td>

<p>integer: the instance of the variable to be read, for variables that exist in more than one object. This number is based on the relative position (column) of the variable in the results file. The default (0) is to read all instances.
</p>
</td></tr>
<tr><td><code id="read.single.lsd_+3A_posit">posit</code></td>
<td>

<p>a string, a vector of strings or an integer vector describing the LSD object position of the variable(s) to select. If an integer vector, it should define the position of a SINGLE LSD object. If a string or vector of strings, each element should define one or more different LSD objects, so the returning matrix will contain variables from more than one object. By setting <code>posit.match</code>, globbing (wildcard), and regular expressions can be used to select multiple objects at once.
</p>
</td></tr>
<tr><td><code id="read.single.lsd_+3A_posit.match">posit.match</code></td>
<td>

<p>a string defining how the <code>posit</code> argument, if provided, should be matched against the LSD object positions. If equal to <code>"fixed"</code>, the default, only exact matching is done. <code>"glob"</code> allows using simple wildcard characters ('*' and '?') in <code>posit</code> for matching. If <code>posit.match="regex"</code> interpret <code>posit</code> as POSIX 1003.2 extended regular expression(s). See <code><a href="base.html#topic+regex">regular expressions</a></code> for details of the different types of regular expressions. Options can be abbreviated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection restriction arguments can be provided as needed; when not specified, all available cases are considered, but just one <code>instance</code> is considered.
</p>
<p>When <code>posit</code> is supplied together with <code>col.names</code> or <code>instance</code>, the selection process is done in two steps. Firstly, the column names and the instance position set by <code>col.names</code> and <code>instance</code> are selected. Secondly, the instances defined by <code>posit</code> are selected from the first selection set.
</p>
<p>See <code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a></code> and <code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a></code> for examples on how to apply advanced selection options.
</p>


<h3>Value</h3>

<p>Returns a matrix containing the selected variables' time series contained in the results file.
</p>


<h3>Note</h3>

<p>This function is useful to extract time series for variables that are single instanced, like summary statistics.
For multi-instanced variables, see <code><a href="#topic+read.multi.lsd">read.multi.lsd</a></code>. For extracting data from multiple similar files (like sensitivity analysis results), see <code><a href="#topic+read.list.lsd">read.list.lsd</a></code> (multi-instanced variables) and <code><a href="#topic+read.3d.lsd">read.3d.lsd</a></code> (single-instanced variables).
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+read.multi.lsd">read.multi.lsd</a>()</code>,
<code><a href="#topic+read.list.lsd">read.list.lsd</a>()</code>,
<code><a href="#topic+read.3d.lsd">read.3d.lsd</a>()</code>,
<code><a href="#topic+read.4d.lsd">read.4d.lsd</a>()</code>,
<code><a href="#topic+read.raw.lsd">read.raw.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# load first .res file into a simple matrix (first instances only)
macroVar &lt;- read.single.lsd( files[ 1 ] )
print( macroVar[ 10 : 20, 5 : 9 ] )

# read second instance of a set of variables named '_A1p' and '_growth1'
ag2Table &lt;- read.single.lsd( files[ 2 ], col.names = c( "_A1p", "_growth1" ),
                             instance = 2 )
print( ag2Table[ 10 : 15, ] )

# read first instance of all variables, skipping the initial 20 time steps
# and keeping up to 30 time steps (from t = 21 up to t = 30)
var21_30 &lt;- read.single.lsd( files[ 3 ], skip = 20, nrows = 30 )
print( var21_30[ , 1 : 7 ] )

# read third instance of all variables at the second object level
var2_3_5 &lt;- read.single.lsd( files[ 1 ], instance = 3, posit = "*_*",
                            posit.match = "glob" )
print( var2_3_5[ 20 : 25, ] )
</code></pre>

<hr>
<h2 id='select.colattrs.lsd'>
Select a subset of a LSD results matrix (by variable attributes)
</h2><span id='topic+select.colattrs.lsd'></span>

<h3>Description</h3>

<p>This function select a subset of a LSD results matrix (as produced by <code><a href="#topic+read.raw.lsd">read.raw.lsd</a></code>) by the variable attributes, considering the LSD object position and the time span.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.colattrs.lsd( dataSet, info, col.names = NULL, init.value = NA,
                     init.time = NA, end.time = NA, posit = NULL,
                     posit.match = c( "fixed", "glob", "regex" ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.colattrs.lsd_+3A_dataset">dataSet</code></td>
<td>

<p>matrix produced by the invocation of <code><a href="#topic+read.raw.lsd">read.raw.lsd</a></code>, <code><a href="#topic+read.single.lsd">read.single.lsd</a></code>, <code><a href="#topic+read.multi.lsd">read.multi.lsd</a></code> or <code><a href="#topic+read.list.lsd">read.list.lsd</a></code> (a single matrix a time) functions.
</p>
</td></tr>
<tr><td><code id="select.colattrs.lsd_+3A_info">info</code></td>
<td>

<p>data frame produced by <code><a href="#topic+info.details.lsd">info.details.lsd</a></code> for the same results file from where <code>dataSet</code> was extracted.
</p>
</td></tr>
<tr><td><code id="select.colattrs.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables to select from. The default is to select from all variables.
</p>
</td></tr>
<tr><td><code id="select.colattrs.lsd_+3A_init.value">init.value</code></td>
<td>

<p>initial value attributed to the variable(s) to select.
</p>
</td></tr>
<tr><td><code id="select.colattrs.lsd_+3A_init.time">init.time</code></td>
<td>

<p>initial time attributed to the variable(s) to select.
</p>
</td></tr>
<tr><td><code id="select.colattrs.lsd_+3A_end.time">end.time</code></td>
<td>

<p>end time attributed to the variable(s) to select.
</p>
</td></tr>
<tr><td><code id="select.colattrs.lsd_+3A_posit">posit</code></td>
<td>

<p>a string, a vector of strings or an integer vector describing the LSD object position of the variable(s) to select. If an integer vector, it should define the position of a SINGLE LSD object. If a string or vector of strings, each element should define one or more different LSD objects, so the returning matrix will contain variables from more than one object. By setting <code>posit.match</code>, globbing (wildcard), and regular expressions can be used to select multiple objects at once; in this case, all matching objects are returned.
</p>
</td></tr>
<tr><td><code id="select.colattrs.lsd_+3A_posit.match">posit.match</code></td>
<td>

<p>a string defining how the <code>posit</code> argument, if provided, should be matched against the LSD object positions. If equal to <code>"fixed"</code>, the default, only exact matching is done. <code>"glob"</code> allows using simple wildcard characters ('*' and '?') in <code>posit</code> for matching. If <code>posit.match="regex"</code> interpret <code>posit</code> as POSIX 1003.2 extended regular expression(s). See <code><a href="base.html#topic+regex">regular expressions</a></code> for details of the different types of regular expressions. Options can be abbreviated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection restriction arguments can be provided as needed; when not specified, all available cases are selected.
</p>
<p>When <code>posit</code> is supplied together with other attribute filters, the selection process is done in two steps. Firstly, the column names set by otter attribute filters are selected. Secondly, the instances defined by <code>posit</code> are selected from the first selection set.
</p>
<p>See also the <code>read.XXXX.lsd</code> functions which may select just specific <code>posit</code> object instances when loading LSD results. If only a single set of instances is required, this would be more efficient than using this function.
</p>


<h3>Value</h3>

<p>Returns a single matrix containing the selected variables' time series contained in the original data set.
</p>


<h3>Note</h3>

<p>If only variable names selection is needed, <code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a></code> is more efficient because information pre-processing (<code><a href="#topic+info.details.lsd">info.details.lsd</a></code>) is not required.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>
<code><a href="#topic+info.details.lsd">info.details.lsd</a>()</code>,
<code><a href="#topic+select.colnames.lsd">select.colnames.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# read all instances of all variables of first file
bigTable &lt;- read.raw.lsd( files[ 1 ] )

# build the info table
info &lt;- info.details.lsd( files[ 1 ] )

# extract specific instances of a set of variables named '_A1p' and '_growth1'
abFirst2 &lt;- select.colattrs.lsd( bigTable, info, c( "_A1p", "_growth1" ),
                                 posit = c( "1_2", "1_5" ) )
print( abFirst2[ 50 : 60, ] )

# extract instances of variable '_A1p' that start at time step t = 1
# for the second and fourth objects under any top-level object (use globbing)
a24 &lt;- select.colattrs.lsd( bigTable, info, "_A1p", init.time = 1,
                            posit = c( "*_2", "*_4" ), posit.match = "glob" )
print( a24[ 1 : 10, ] )

# extract all second-level object instances of all variables
aSec &lt;- select.colattrs.lsd( bigTable, info, posit = "*_*", posit.match = "glob" )
print( aSec[ 1 : 10, ] )

# extract just top-level object instances variables
aTop &lt;- select.colattrs.lsd( bigTable, info, posit = "^[0-9]+$",
                             posit.match = "regex" )
print( aTop[ 1 : 10, ] )
</code></pre>

<hr>
<h2 id='select.colnames.lsd'>
Select a subset of a LSD results matrix (by column/variable names)
</h2><span id='topic+select.colnames.lsd'></span>

<h3>Description</h3>

<p>This function select a subset of a LSD results matrix (as produced by <code><a href="#topic+read.raw.lsd">read.raw.lsd</a></code>) by the column (variable) names, considering only the name part of the column labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.colnames.lsd( dataSet, col.names = NULL, instance = 0,
                     check.names = TRUE, posit = NULL,
                     posit.match = c( "fixed", "glob", "regex" ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.colnames.lsd_+3A_dataset">dataSet</code></td>
<td>

<p>matrix produced by the invocation of <code><a href="#topic+read.raw.lsd">read.raw.lsd</a></code>, <code><a href="#topic+read.single.lsd">read.single.lsd</a></code>, <code><a href="#topic+read.multi.lsd">read.multi.lsd</a></code> or <code><a href="#topic+read.list.lsd">read.list.lsd</a></code> (a single matrix a time) functions.
</p>
</td></tr>
<tr><td><code id="select.colnames.lsd_+3A_col.names">col.names</code></td>
<td>

<p>a vector of optional names for the variables. The default is to read all variables. The names must to be in LSD/C++ format, without dots (&quot;.&quot;) in the name. Any dot (and trailing characters) will be automatically removed.
</p>
</td></tr>
<tr><td><code id="select.colnames.lsd_+3A_instance">instance</code></td>
<td>

<p>integer: the instance of the variable to be read, for variables that exist in more than one object. This number is based on the relative position (column) of the variable in the results file. The default (0) is to read all instances.
</p>
</td></tr>
<tr><td><code id="select.colnames.lsd_+3A_check.names">check.names</code></td>
<td>

<p>logical. If <code>TRUE</code> the names of the variables are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted to ensure that there are no duplicates.
</p>
</td></tr>
<tr><td><code id="select.colnames.lsd_+3A_posit">posit</code></td>
<td>

<p>a string, a vector of strings or an integer vector describing the LSD object position of the variable(s) to select. If an integer vector, it should define the position of a SINGLE LSD object. If a string or vector of strings, each element should define one or more different LSD objects, so the returning matrix will contain variables from more than one object. By setting <code>posit.match</code>, globbing (wildcard), and regular expressions can be used to select multiple objects at once; in this case, all matching objects are returned. This option only operates if <code>dataSet</code> was generated by <code>read.raw.lsd</code> WITHOUT argument <code>clean.names = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="select.colnames.lsd_+3A_posit.match">posit.match</code></td>
<td>

<p>a string defining how the <code>posit</code> argument, if provided, should be matched against the LSD object positions. If equal to <code>"fixed"</code>, the default, only exact matching is done. <code>"glob"</code> allows using simple wildcard characters ('*' and '?') in <code>posit</code> for matching. If <code>posit.match="regex"</code> interpret <code>posit</code> as POSIX 1003.2 extended regular expression(s). See <code><a href="base.html#topic+regex">regular expressions</a></code> for details of the different types of regular expressions. Options can be abbreviated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection restriction arguments can be provided as needed; when not specified, all available cases are selected.
</p>
<p>The selection of specific <code>posit</code> object positions require full detail on <code>dataSet</code> column names, as produced by <code>read.raw.lsd</code> and <code>clean.names = TRUE</code> is NOT used. Other <code>read.XXXX.lsd</code> functions do NOT produce the required detail on the data matrices to do object position selection. If such datasets are used to feed this function and <code>posit</code> is set, the return value will be NULL. In this case, consider using <code>select.colattrs.lsd</code>, or specifying <code>posit</code> when calling <code>read.XXXX.lsd</code> functions.
</p>
<p>When <code>posit</code> is supplied together with other attribute filters, the selection process is done in two steps. Firstly, the column names set by otter attribute filters are selected. Secondly, the instances defined by <code>posit</code> are selected from the first selection set.
</p>
<p>See also the <code>read.XXXX.lsd</code> functions which may select just specific <code>col.names</code> columns, <code>instance</code> instances, or <code>posit</code> positions when loading LSD results. If only a single set of columns/instance/positions is required, this may be more efficient than using this function.
</p>


<h3>Value</h3>

<p>Returns a single matrix containing the selected variables' time series contained in the original data set.
</p>


<h3>Note</h3>

<p>The variable/column names must be valid R or LSD column names.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.files.lsd">list.files.lsd</a>()</code>,
<code><a href="#topic+select.colattrs.lsd">select.colattrs.lsd</a>()</code>,
<code><a href="#topic+read.raw.lsd">read.raw.lsd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the list of file names of example LSD results
files &lt;- list.files.lsd( system.file( "extdata", package = "LSDinterface" ) )

# read all instances of all variables in first file
bigTable &lt;- read.raw.lsd( files[ 1 ] )
print( bigTable[ 1 : 10, 1 : 7 ] )

# extract all instances of a set of variables named '_A1p' and '_growth1'
abTable &lt;- select.colnames.lsd( bigTable, c( "_A1p", "_growth1" ) )
print( abTable[ 11 : 15, ] )

# extract specific instances of a set of variables named '_A1p' and '_growth1'
abFirst2 &lt;- select.colnames.lsd( bigTable, c( "_A1p", "_growth1" ),
                                 posit = c( "1_2", "1_5" ) )
print( abFirst2[ 50 : 60, ] )

# extract all second-level object instances of all variables
aSec &lt;- select.colnames.lsd( bigTable, posit = "*_*", posit.match = "glob" )
print( aSec[ 1 : 10, ] )

# extract just top-level object instances variables
aTop &lt;- select.colnames.lsd( bigTable, posit = "^[0-9]+$", posit.match = "regex" )
print( aTop[ 1 : 10, ] )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
