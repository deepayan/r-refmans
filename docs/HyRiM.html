<!DOCTYPE html><html><head><title>Help for package HyRiM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HyRiM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.mosg'>
<p>Extract or replace parts of a game's payoff matrix</p></a></li>
<li><a href='#cdf'>
<p>(cumulative) loss distribution function</p></a></li>
<li><a href='#disappointmentRate'>
<p>computation of the disappointment rate</p></a></li>
<li><a href='#HyRiM-package'>
<p>Multicriteria Risk Management using Zero-Sum Games with Vector-Valued Payoffs that are Probability Distributions</p></a></li>
<li><a href='#lossDistribution'>
<p>construction and handling of loss distributions</p></a></li>
<li><a href='#mgss'>
<p>compute a multi-goal security strategy</p></a></li>
<li><a href='#moment'>
<p>compute moments of loss distributions</p></a></li>
<li><a href='#mosg'>
<p>Construction and handling of multi-objective security games</p></a></li>
<li><a href='#mosg.equilibrium'>
<p>embodies all information related to a lexicographic Nash equilibrium computed by the function <code>mgss</code>.</p></a></li>
<li><a href='#preference'>
<p>Decision on preferences between loss distributions</p></a></li>
<li><a href='#variance'>
<p>Computes the approximate variance of a loss distribution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multicriteria Risk Management using Zero-Sum Games with
Vector-Valued Payoffs that are Probability Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-06</td>
</tr>
<tr>
<td>Imports:</td>
<td>compare, polynom, grImport2, Rglpk, purrr, methods</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Rass, Sandra Koenig, Ali Alshawish</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>"Stefan Rass, on behalf of the Austrian Institute of Technology" &lt;stefan.rass@jku.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Construction and analysis of multivalued zero-sum matrix games over the abstract space of probability distributions, which describe the losses in each scenario of defense vs. attack action. The distributions can be compiled directly from expert opinions or other empirical data (insofar available). The package implements the methods put forth in the EU project HyRiM (Hybrid Risk Management for Utility Networks), FP7 EU Project Number 608090. The method has been published in Rass, S., König, S., Schauer, S., 2016. Decisions with Uncertain Consequences-A Total Ordering on Loss-Distributions. PLoS ONE 11, e0168583. &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0168583">doi:10.1371/journal.pone.0168583</a>&gt;, and applied for advanced persistent thread modeling in Rass, S., König, S., Schauer, S., 2017. Defending Against Advanced Persistent Threats Using Game-Theory. PLoS ONE 12, e0168675. &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0168675">doi:10.1371/journal.pone.0168675</a>&gt;. A volume covering the wider range of aspects of risk management, partially based on the theory implemented in the package is the book edited by S. Rass and S. Schauer, 2018. Game Theory for Security and Risk Management: From Theory to Practice. Springer, &lt;<a href="https://doi.org/10.1007%2F978-3-319-75268-6">doi:10.1007/978-3-319-75268-6</a>&gt;, ISBN 978-3-319-75267-9.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-06 15:46:48 UTC; AK124238</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,rmarkdown,qpdf,testthat</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-08 23:42:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.mosg'>
Extract or replace parts of a game's payoff matrix
</h2><span id='topic++5B.mosg'></span><span id='topic++5B+3C-.mosg'></span>

<h3>Description</h3>

<p>Construct a new game by taking out a specified set of rows, columns and goals from a given game <code class="reqn">G</code>. The new game inherits all descriptions (rows, cols and goals) from the <code class="reqn">G</code>, and has its list of loss distributions organized in the same way (by rows or columns) as <code class="reqn">G</code>.
</p>
<p>The extraction or substitution works like as for data frames (see <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code>).
Strategies for both players, as well as goals, can equivalently be addressed by their string-names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mosg'
x[i,j,k=NULL]

## S3 replacement method for class 'mosg'
x[i,j,k=NULL] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.mosg_+3A_x">x</code></td>
<td>

<p>a game of class <a href="#topic+mosg">mosg</a>
</p>
</td></tr>
<tr><td><code id="+2B5B.mosg_+3A_i">i</code>, <code id="+2B5B.mosg_+3A_j">j</code>, <code id="+2B5B.mosg_+3A_k">k</code></td>
<td>

<p>a numeric value or numeric vector of row incides <code>i</code>, colum indices <code>j</code>, or goals <code>k</code>.
</p>
</td></tr>
<tr><td><code id="+2B5B.mosg_+3A_value">value</code></td>
<td>

<p>a <a href="base.html#topic+list">list</a> of <a href="#topic+lossDistribution">lossDistribution</a> objects, or a game object of class <code><a href="#topic+mosg">mosg</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>[</code> extraction of elements from a payoff matrix, omitting any index dimension selects all elements in the respective dimension. Supplying negative values excludes the respective elements. For example, <code>G[c(1:3),1]</code> returns a game with only the rows 1..3 of <code>G</code>, but all column strategies that <code>G</code> had, and only the first of <code>G</code>'s goals retained.
</p>
<p>For <code>[&lt;-</code>, the list of substitute values needs to be of the same length as the number of elements addressed by the triple <code>(i,j,k)</code>, otherwise an error is returned. If the new elements come from another game object, say <code>G2</code>, only the loss distributions get replaced, but not the names of the strategies. The replacement checks if <code>G2</code> has its list of loss distributions organized in the same way as <code>G</code>, i.e., row-by-row or column-by-column. If there is a mismatch, the substitution is nonetheless done, but a warning about this issue is printed.
</p>


<h3>Value</h3>

<p><code>[</code> returns a freshly constructed game object.
</p>


<h3>Warning</h3>

<p>For <code>[&lt;-</code>, be aware that the replacement <em>does not</em> semantically check if the newly incoming loss distributions make sense as elements of the new game (e.g., they can have different supports, or be discrete/continuous while the game was continuous/discrete in its payoffs). Respective errors may only subsequently come up when the modified or extracted game is used.</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## raw data (PURELY ARTIFICIAL, for demo purposes only)
obs111&lt;-c(rep(1,40),rep(3,20),rep(5,10),rep(7,20),rep(9,10));
obs112&lt;-c(rep(1,50),rep(2,10),rep(4,10),rep(6,20),rep(8,10));
obs121&lt;-c(rep(1,20),rep(4,30),rep(6,20),rep(8,10),rep(10,20));
obs122&lt;-c(rep(1,40),rep(2.5,20),rep(5,20),rep(7.5,10),rep(9,10));
obs211&lt;-c(rep(1,30),rep(2,30),rep(5,10),rep(8,10),rep(10,20));
obs212&lt;-c(rep(1,10),rep(2,10),rep(4,20),rep(7,20),rep(10,40));
obs221&lt;-c(rep(1,30),rep(3,30),rep(4,10),rep(7,20),rep(9,10));
obs222&lt;-c(rep(1,10),rep(3,10),rep(5,50),rep(8,20),rep(10,10));
obs311&lt;-c(rep(1,40),rep(2,30),rep(4,10),rep(7,10),rep(9,10));
obs312&lt;-c(rep(1,20),rep(3,20),rep(4,20),rep(7,20),rep(10,20));
obs321&lt;-c(rep(1,10),rep(3,40),rep(4,30),rep(7,10),rep(9,10));
obs322&lt;-c(rep(1,10),rep(4,30),rep(5,30),rep(7,10),rep(10,20));
## compute payoff densities
f111&lt;-lossDistribution(obs111)
f112&lt;-lossDistribution(obs112)
f121&lt;-lossDistribution(obs121)
f122&lt;-lossDistribution(obs122)
f211&lt;-lossDistribution(obs211)
f212&lt;-lossDistribution(obs212)
f221&lt;-lossDistribution(obs221)
f222&lt;-lossDistribution(obs222)
f311&lt;-lossDistribution(obs311)
f312&lt;-lossDistribution(obs312)
f321&lt;-lossDistribution(obs321)
f322&lt;-lossDistribution(obs322)

payoffs&lt;-list(f111,f112,f121, f122,f211,f212,f221,f222, f311,f312,f321,f322)
G &lt;- mosg( n=2,
            m=3,
            payoffs,
            goals=2,
            goalDescriptions=c("g1", "g2"),
            defensesDescr = c("d1", "d2"),
            attacksDescr = c("a1", "a2", "a3"))

# modify the game by subsetting
G[,c(1,2),] # select only the first two strategies
G[,-3,] # exclude the third strategy (equivalent to before)

# replace a 2x2 subgame related to the second goal
# (replacement data is chosen arbitrarily here)
G2 &lt;- mosg(n=2, m=2, goals=1, losses = list(f111,f112,f121, f122))
G[,c(1,2),1] &lt;- G2  # replace the subgame

# construct another replacement game that is organized different (by column)
G2 &lt;- mosg(n=2, m=2, goals=1, losses = list(f111,f112,f121, f122), byrow=FALSE)
G[,c(1,2),1] &lt;- G2  # this will issue a warning

# plot a submatrix from the game
plot(G[-2,c(1,2),], goal=2)

</code></pre>

<hr>
<h2 id='cdf'>
(cumulative) loss distribution function</h2><span id='topic+cdf'></span>

<h3>Description</h3>

<p>returns the numeric values of the cumulative loss distribution <code>ld</code> evaluated at <code>x</code>, i.e., <code class="reqn">\textrm{Pr}(X \leq x)</code>, where <code class="reqn">X\sim \textrm{ld}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf(ld, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf_+3A_ld">ld</code></td>
<td>

<p>the loss distribution as obtained from <code>lossDistribution</code> or <code>mgss</code>.
</p>
</td></tr>
<tr><td><code id="cdf_+3A_x">x</code></td>
<td>

<p>the point at which the distribution function shall be evaluated (must be a numeric; vectors are not supported yet)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function internally distinguishes discrete and continous disributions only in terms of rounding its argument to the largest integer less than x. Its value is obtained by numeric integration of the internal representation of the loss distribution (in the continuous case).
</p>
<p>For discrete distributions, the function works on the internal probability mass function (which may be different from the empirical distribution in case that the loss distribution has been smoothed during its construction; see <code><a href="#topic+lossDistribution">lossDistribution</a></code>).
</p>


<h3>Value</h3>

<p>an approximation for the probability Pr(ld&lt;=x).
</p>


<h3>Note</h3>

<p>in its current version, <code>cdf</code> does not vectorize, i.e., cannot be applied to vector arguments <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>See Also</h3>

<p>suitable inputs for this function are provided by <code><a href="#topic+lossDistribution">lossDistribution</a></code> and <code><a href="#topic+mgss">mgss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cvss1base &lt;- c(10,6.4,9,7.9,7.1,9)
ld &lt;- lossDistribution(cvss1base)
cdf(ld, 4)
</code></pre>

<hr>
<h2 id='disappointmentRate'>
computation of the disappointment rate
</h2><span id='topic+disappointmentRate'></span>

<h3>Description</h3>

<p>For a minimizing player, the <em>disappointment rate</em> is the likelihood for the loss to exceed its expectation (thus disappoint the defender). For any random loss <code class="reqn">X</code>, it is given by <code class="reqn">Pr(X &gt; E(X))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disappointmentRate(d, x, y, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disappointmentRate_+3A_d">d</code></td>
<td>

<p>a <a href="#topic+lossDistribution">lossDistribution</a> object or a <a href="base.html#topic+matrix">matrix</a>; typically the assurance from a previously computed equilibrium (see <code><a href="#topic+mgss">mgss</a></code>). In that case, all other parameters are ignored.
</p>
<p>Alternatively, one can provide a matrix of real values instead, to compute the disappointment rate in the so-specified zero-sum matrix game. In that case, the other parameters are also taken into considertion.
</p>
</td></tr>
<tr><td><code id="disappointmentRate_+3A_x">x</code>, <code id="disappointmentRate_+3A_y">y</code></td>
<td>
<p>the mixed strategies under which the disappointment rate shall be computed. Usually, this would be an equilibrium of the (real-valued) matrix game. If only <code>x</code> or only <code>y</code> is supplied, the function computes a best response to the given (mixed) strategy. If both are omitted, the function internally computes an equilibrium by a call to <code><a href="#topic+mgss">mgss</a></code>.
</p>
</td></tr>
<tr><td><code id="disappointmentRate_+3A_verbose">verbose</code></td>
<td>
<p>if set to <code>FALSE</code>, suppresses all messaging.
</p>
</td></tr>
<tr><td><code id="disappointmentRate_+3A_...">...</code></td>
<td>
<p>further parameters internally passed onwards to <code><a href="#topic+mgss">mgss</a></code> to compute an equilibrium.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The disappointment rate can be taken as an auxiliary goal to optimize, though it is not supported for optimization in the current version of the package. Note that it does not make sense to consider this rate as an isolated (single) goal, since the optimal strategy would then be playing towards maximal losses (with explicit aid of the opponent) in order to minimize the mass to the left of the expected loss. However, it is a quantity of interest when the equilibrium has been computed, as it indicates how &ldquo;satisfying&rdquo; the equilibrium will be upon playing.
</p>


<h3>Value</h3>

<p>the likelihood to overshoot the expectation of the random loss <code class="reqn">X</code> with distribution <code>d</code>, i.e., <code class="reqn">Pr(X &gt; E(X))</code>.





</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>References</h3>

<p>see for example, F. Gul: &quot;A Theory of Disappointment Aversion&quot;, Econometrica, vol. 59, no. 3, p. 667, 1991.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mgss">mgss</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## raw data (PURELY ARTIFICIAL, for demo purposes only)
# N=100 observations in each category
obs111&lt;-c(rep(1,40),rep(3,20),rep(5,10),rep(7,20),rep(9,10));
obs112&lt;-c(rep(1,50),rep(2,10),rep(4,10),rep(6,20),rep(8,10));
obs121&lt;-c(rep(1,20),rep(4,30),rep(6,20),rep(8,10),rep(10,20));
obs122&lt;-c(rep(1,40),rep(2.5,20),rep(5,20),rep(7.5,10),rep(9,10));
obs211&lt;-c(rep(1,30),rep(2,30),rep(5,10),rep(8,10),rep(10,20));
obs212&lt;-c(rep(1,10),rep(2,10),rep(4,20),rep(7,20),rep(10,40));
obs221&lt;-c(rep(1,30),rep(3,30),rep(4,10),rep(7,20),rep(9,10));
obs222&lt;-c(rep(1,10),rep(3,10),rep(5,50),rep(8,20),rep(10,10));
obs311&lt;-c(rep(1,40),rep(2,30),rep(4,10),rep(7,10),rep(9,10));
obs312&lt;-c(rep(1,20),rep(3,20),rep(4,20),rep(7,20),rep(10,20));
obs321&lt;-c(rep(1,10),rep(3,40),rep(4,30),rep(7,10),rep(9,10));
obs322&lt;-c(rep(1,10),rep(4,30),rep(5,30),rep(7,10),rep(10,20));

## compute payoff densities
f111&lt;-lossDistribution(obs111)
f112&lt;-lossDistribution(obs112)
f121&lt;-lossDistribution(obs121)
f122&lt;-lossDistribution(obs122)
f211&lt;-lossDistribution(obs211)
f212&lt;-lossDistribution(obs212)
f221&lt;-lossDistribution(obs221)
f222&lt;-lossDistribution(obs222)
f311&lt;-lossDistribution(obs311)
f312&lt;-lossDistribution(obs312)
f321&lt;-lossDistribution(obs321)
f322&lt;-lossDistribution(obs322)

payoffs&lt;-list(f111,f112,f121, f122,f211,f212,f221,f222, f311,f312,f321,f322)
G &lt;- mosg( n=2,
            m=2,
            payoffs,
            goals=3,
            goalDescriptions=c("g1", "g2", "g3"),
            defensesDescr = c("d1", "d2"),
            attacksDescr = c("a1", "a2"))
eq &lt;- mgss(G,weights=c(0.25,0.5,0.25))

# get the disappointment rate for the first security goal g1
disappointmentRate(eq$assurances$g1)

############
# construct a game with one goal and related disappointment
payoffs &lt;- list(f111,f112,f121,f122)
# note that from here onwards, the code is "generic", meaning that
# exactly the same procedure would apply to *any* kind of game that
# we want to play with disappointments, as long as the input data comes
# in the variable "payoffs" (as used in the code below)
expectations &lt;- unlist(lapply(payoffs, mean))
disappointmentRates &lt;- unlist(lapply(payoffs, disappointmentRate))
# put the two goals together in a game
gameWithDisappointment &lt;- c(expectations, disappointmentRates)
G &lt;- mosg( n=2,
          m=2,
          losses=gameWithDisappointment,
          goals=2,
          goalDescriptions=c("revenue", "disappointment"),
          defensesDescr = c("d1", "d2"),
          attacksDescr = c("a1", "a2"))
eq &lt;- mgss(G,weights=c(0.1,0.9))

</code></pre>

<hr>
<h2 id='HyRiM-package'>
Multicriteria Risk Management using Zero-Sum Games with Vector-Valued Payoffs that are Probability Distributions
</h2><span id='topic+HyRiM-package'></span><span id='topic+HyRiM'></span>

<h3>Description</h3>

<p>Construction and analysis of multivalued zero-sum matrix games over the abstract space of probability distributions, which describe the losses in each scenario of defense vs. attack action. The distributions can be compiled directly from expert opinions or other empirical data (insofar available). The package implements the methods put forth in the EU project HyRiM (Hybrid Risk Management for Utility Networks), FP7 EU Project Number 608090. The method has been published in Rass, S., König, S., Schauer, S., 2016. Decisions with Uncertain Consequences-A Total Ordering on Loss-Distributions. PLoS ONE 11, e0168583. &lt;doi:10.1371/journal.pone.0168583&gt;, and applied for advanced persistent thread modeling in Rass, S., König, S., Schauer, S., 2017. Defending Against Advanced Persistent Threats Using Game-Theory. PLoS ONE 12, e0168675. &lt;doi:10.1371/journal.pone.0168675&gt;. A volume covering the wider range of aspects of risk management, partially based on the theory implemented in the package is the book edited by S. Rass and S. Schauer, 2018. Game Theory for Security and Risk Management: From Theory to Practice. Springer, &lt;doi:10.1007/978-3-319-75268-6&gt;, ISBN 978-3-319-75267-9.
</p>


<h3>Author(s)</h3>

<p>Stefan Rass, Sandra Koenig, Ali Alshawish
</p>
<p>Maintainer: &quot;Stefan Rass, on behalf of the Austrian Institute of Technology&quot; &lt;stefan.rass@jku.at&gt;
</p>


<h3>References</h3>

<p>S. Rass, S. König, S. Schauer: Games over Probability Distributions Revisited: New Equilibrium Models and Refinements, MDPI Games 2022, 13(6), 80; DOI: https://doi.org/10.3390/g13060080, online: https://www.mdpi.com/2073-4336/13/6/80
</p>
<p>S. Rass, S. König, S. Schauer, V. Bürgin, J. Epperlein, F. Wirth: On Game Theory Using Stochastic Tail Orders, arXiv:2108.00680v1 [math.PR], 2021
</p>
<p>S. Rass, A. Wiegele, S. König: Security Games over Lexicographic Orders, in: Decision and Game Theory for Security, 11th International Conference, GameSec 2020, College Park, MD, USA, October 28–30, 2020, Proceedings, Springer LNCS 12513, ISBN 978-3-030-64792-6
</p>
<p>S. Rass, S. Koenig, S. Schauer: Uncertainty in Games: Using Probability-Distributions as Payoffs. in MHR Khouzani et al. (Eds.) GameSec 2015, Springer LNCS 9406, pp. 346-357, DOI: 10.1007/978-3-319-25594-1_20.
</p>
<p>S. Rass. On Game-Theoretic Risk Management (Part One). Towards a Theory of
Games with Payoffs that are Probability-Distributions. ArXiv e-prints, June 2015.
http://arxiv.org/abs/1506.07368.
</p>
<p>S. Rass. On Game-Theoretic Risk Management (Part Two). Algorithms Algorithms to Compute Nash-Equilibria in Games with Distributions as
Payoffs, ArXiv e-prints, arXiv:1511.08591, 2015.
</p>

<hr>
<h2 id='lossDistribution'>
construction and handling of loss distributions
</h2><span id='topic+lossDistribution'></span><span id='topic+print.mosg.lossdistribution'></span><span id='topic+summary.mosg.lossdistribution'></span><span id='topic+plot.mosg.lossdistribution'></span><span id='topic+quantile.mosg.lossdistribution'></span><span id='topic+mean.mosg.lossdistribution'></span><span id='topic+density.mosg.lossdistribution'></span><span id='topic+print.summary.mosg.lossdistribution'></span>

<h3>Description</h3>

<p>Loss distributions can be constructed from both, continuous and categorical data. In any case, the input data must be a list (vector) of at least two numeric values all being <code class="reqn">\geq 1</code>. For discrete data, the function additionally takes the full range of categories, all being represented as integers (with the lowest category having the number 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># construct a loss distribution from data
lossDistribution(
  dat,
  discrete = FALSE,
  dataType = c("raw", "pdf", "cdf"),
  supp = NULL,
  smoothing = c("none", "ongaps", "always"),
  bw = NULL)
# get information about the loss distribution
## S3 method for class 'mosg.lossdistribution'
print(x, ...)
## S3 method for class 'mosg.lossdistribution'
summary(object, ...)
## S3 method for class 'summary.mosg.lossdistribution'
print(x, ...)
## S3 method for class 'mosg.lossdistribution'
plot(x, points = 100, xlab = "", ylab = "",
           main = "", p = 0.999, newPlot = TRUE, cutoff = NULL, ...)
# get quantiative information about the distribution
## S3 method for class 'mosg.lossdistribution'
quantile(x, p, eps = 0.001, ...)
## S3 method for class 'mosg.lossdistribution'
mean(x, ...)
# evaluate the loss density function
## S3 method for class 'mosg.lossdistribution'
density(x, t, ...)
# for the cumulative distribution function, see the function 'cdf'
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lossDistribution_+3A_dat">dat</code></td>
<td>

<p>a vector of at least two input observations (all <code class="reqn">\geq 1</code> required)
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_discrete">discrete</code></td>
<td>

<p>defaults to <code>FALSE</code>. If set to <code>TRUE</code>, the loss distribution is constructed as discrete. In that case, a value for <code>supp</code> is required.
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_datatype">dataType</code></td>
<td>

<p>applies only if <code>discrete=TRUE</code>, and specifies how the values in <code>dat</code> are to be interpreted. Defaults to <code>raw</code>, by which the data is taken as observations. Given as <code>pdf</code>, the values in <code>dat</code> are directly interpreted as a probability density (checked for nonnegativity and re-normalized if necessary). If the data type is specified as <code>cdf</code>, then the values in <code>dat</code> are taken as cumulative distribution function, i.e., checked to be non-decreasing, non-negative and re-normalized to 1 if necessary.
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_supp">supp</code></td>
<td>

<p>if the parameter <code>discrete</code> is set to <code>TRUE</code>, then this parameter must be set as a vector of two elements, specifying the minimal and maximal category, e.g. <code>supp=c(1,5)</code>.
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_bw">bw</code></td>
<td>

<p>the bandwidth parameter (numeric value) for kernel smoothing. Defaults internally to the result of <a href="stats.html#topic+bw.nrd0">bw.nrd0</a> if omitted.
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_x">x</code></td>
<td>

<p>a loss distribution object returned by <code>lossDistribution</code> or <code>mgss</code>, or a value within the support of a loss distribution.
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_t">t</code></td>
<td>

<p>a value within the support of <code>ld</code> or a summary object for a loss distribution.
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_object">object</code></td>
<td>

<p>a loss distribution object
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_eps">eps</code></td>
<td>

<p>the accuracy at which the quantile is approximated (see the details below).
</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_smoothing">smoothing</code></td>
<td>

<p>string; partially matched with &quot;none&quot; (default), &quot;ongaps&quot;, and &quot;always&quot;. If set to &quot;always&quot;, then the function computes a discrete kernel density estimate (using a discretized version of a Gaussian density with a bandwidth as computed by <code>bw.nrd0</code> (Silverman's rule)), to assign categories with zero probability a positive likelihood. If set to &quot;ongaps&quot;, then the smoothing is applied only if necessary (i.e., if the probability mass is zero on at least one category).
</p>
</td></tr>
</table>
<p>the function <code>plot.mosg.lossdistribution</code> takes the parameters:
</p>
<table>
<tr><td><code id="lossDistribution_+3A_points">points</code></td>
<td>
<p>the number of points at which loss densities are is evaluated (numerically) for plotting.</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x-axis in the plot.</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y-axis in the plot.</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_main">main</code></td>
<td>
<p>a title for the plot</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_p">p</code></td>
<td>
<p>a quantile that determines the plot range for the loss distribution</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_newplot">newPlot</code></td>
<td>
<p>if set to <code>TRUE</code>, then a new plot is opened. Otherwise, the plot is added to the current plot window (typcially used by <code>plot.mosg</code> to visualize game matrices).</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_cutoff">cutoff</code></td>
<td>
<p>the cutoff point at which all densities shall be truncated before plotting (note that the mass functions are rescaled towards unit mass).</p>
</td></tr>
<tr><td><code id="lossDistribution_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function internally computes a Gaussian kernel density estimator (KDE; using Silverman's rule of thumb for the bandwidth selection) on the continuous data. The distribution is truncated at the maximal observation supplied + 5*the bandwidth of the Gaussian KDE, or equivalently, at the right end of the support in case of discrete distributions.
</p>
<p>For discrete distributions, missing observations are handled by smoothing the density (by convolution with a discretized Gaussian kernel). As an alternative, a re-definition of categories may be considered.
</p>
<p>Degenerate distributions are not supported! The construction of classical games with real-valued payoffs works directly through <a href="#topic+mosg">mosg</a> by supplying a list of values rather than loss distributions. See the example given with <a href="#topic+mosg">mosg</a>.
</p>
<p>The generic functions <code>quantile</code>, <code>mean</code> and <code>density</code> both distinguish discrete from continuous distributions in the way of how values are being computed.
</p>
<p>Quantiles are computed using the direct definition as an approximation <code>y</code> so that x = Pr(ld &lt;= y). For continuous distributions, a bisective search is performed to approximate the inverse cumulative distribution function. For discret distributions, <code>quantile</code> works with cumulative sums. The accuracy parameter <code>eps</code> passed to <code>quantile</code> causes the bisective search to stop if the search interval has a length less than <code>eps</code>. In that case, the middle of the interval is returned. For discrete distributions, the computation is done by cumulative sums on the discrete probability mass function.
</p>
<p><code>mean</code> either invokes <code>moment(ld, 1)</code> to compute the first moment.
</p>
<p><code>density</code> is either a wrapper for the internal representation by the <code>function</code> object <code>lossdistr</code>, or directly accesses the probability mass function as internally stored in the field <code>dpdf</code> (see the 'values' section below).
</p>
<p>For visualization, <code>plot</code> produces a bar plot for categorical distributions (over categories as specified by the <code>supp</code> field; see the 'values' section below), and for  continous distributions, a continuous line plot is returned on the range 1...max(<code>range</code> + 5*<code>bw</code>), where the values are described below. To ease comparison and a visual inspection of the game matrix, the default plot ranges can be overridden by supplying <code>xlim</code> and <code>ylim</code> for the plot function.
</p>


<h3>Value</h3>

<p>The return values of <code>lossDistribution</code> is an object of class <code>mosg.lossdistribution</code>. The same goes for <code>lossDistribution.mosg</code>.
</p>
<table>
<tr><td><code>observations</code></td>
<td>
<p>carries over the data vector supplied to construct the distribution.</p>
</td></tr>
<tr><td><code>range</code></td>
<td>
<p>the minimal and maximal loss observed, as a 2-element vector. For loss distributions induced by games, the range is the smallest interval covering the ranges of all distributions in the game.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>the bandwidth used for the kernel density approximate.</p>
</td></tr>
<tr><td><code>lossdistr</code></td>
<td>
<p>a <code>function</code> embodying the kernel density (probability mass function) as a spline function (for continuous densities only)</p>
</td></tr>
<tr><td><code>normalizationFactor</code></td>
<td>
<p>the factor by which <code>lossdistr</code> must be multiplied (to normalize under the truncation at max(observations) + 5*bw.</p>
</td></tr>
<tr><td><code>is.mixedDistribution</code></td>
<td>
<p>a flag indicating whether or not the distribution was constructed by a call to <code>lossDistribution</code> or the generic function <code>lossDistribution.mosg</code>.</p>
</td></tr>
<tr><td><code>is.discrete</code></td>
<td>
<p>a flag set to <code>TRUE</code> if the distribution is over categories</p>
</td></tr>
<tr><td><code>dpdf</code></td>
<td>
<p>if <code>is.discrete</code> is <code>TRUE</code>, then this is a vector of probability masses over the support (field <code>supp</code>).</p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>if <code>is.discrete</code> is <code>TRUE</code>, then this is a 2-element vector specifying the minimal and maximal loss category (represented by integers).</p>
</td></tr>
</table>
<p>A <code>summary</code> returns an object of class <code>mosg.equilibrium.summary</code>, for which the generic <code>print</code> function can be applied, and which carries the following fields:
</p>
<table>
<tr><td><code>range</code></td>
<td>
<p>the minimal and maximal observation of the underlying data (if available), or the minimal and maximal losses anticipated for this distribution (e.g., in case of discrete distributions the common support).</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the first moment as computed by <code>mean</code>.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>the variance as computed by <code>variance</code>.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>a 2x5-matrix of quantiles at levels 10%, 25%, 50%, 75% and 90%.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If the plotting throws an error concerning too large figure margins, then adjusting the plot parameters using <a href="graphics.html#topic+par">par</a> may help, since the plot function does not override any of the current plot settings (e.g., issue <code>par(c(0,0,1,1) + 0.1))</code> before plotting to reduce the spacing close towards zero))
</p>
<p>In some cases, plots may require careful customization to look well, so playing arourd with the other settings as offered by <a href="graphics.html#topic+par">par</a> can be useful.
</p>
<p>If the distribution has been smoothed, then <code>mean</code>, <code>variance</code>, <code>quantile</code>, <code>density</code> and <code>cdf</code> will refer to the smoothed version of the distribution. In that case, the returned quantities are mere approximations of the analogous values obtained directly from the underlying data.
</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mosg">mosg</a></code>, <code><a href="#topic+mgss">mgss</a></code>, <code><a href="#topic+cdf">cdf</a></code>, <code><a href="#topic+variance">variance</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a loss distribution from observations (raw data)
cvss1base &lt;- c(10,6.4,9,7.9,7.1,9)
ld &lt;- lossDistribution(cvss1base)
summary(ld)
plot(ld)

# construct a loss distribution of given shape
# for example, a Poisson density with lambda = 4
x &lt;- 1:10
f &lt;- dpois(x, lambda = 4)
# construct the loss distribution by declaring the data
# to be a probability density function (pdf)
ld &lt;- lossDistribution(f, dataType = "pdf", discrete = TRUE, supp = range(x))
# note that this call throws a warning since it internally
# truncates the loss distribution to the support 1:10, and
# renormalizes the supplied density for that matter.

# for further examples, see the documentation to 'mosg' and 'mosg.equilibrium'
</code></pre>

<hr>
<h2 id='mgss'>
compute a multi-goal security strategy</h2><span id='topic+mgss'></span>

<h3>Description</h3>

<p>Finds security strategy that assures a maximal loss w.r.t. all goals of the given game, delivering a Pareto-efficient loss bound. Internally, it constructs an auxiliary one-against-all game and uses a sequence of linear programs to compute a lexicographic Nash equilibrium therein (Rass et al., 2022), using the methods described by (Lozovanu et al 2005; Rass, Wiegele &amp; König 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgss(G, weights, cutOff, ord = 5, fbr = FALSE, points = 512, tol = 0.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgss_+3A_g">G</code></td>
<td>

<p>a multi-objective game constructed using <code>mosg</code>
</p>
</td></tr>
<tr><td><code id="mgss_+3A_weights">weights</code></td>
<td>

<p>each goal in <code>G</code> can be assigned a weight to reflect its priority. If missing, the weights default to be all equal. The weights do not need to sum up to 1 (and are normalized towards a unit sum otherweise), but need to be all non-negative.
</p>
</td></tr>
<tr><td><code id="mgss_+3A_cutoff">cutOff</code></td>
<td>

<p>(only used for continuous loss distributions) the maximal loss for which no events are expected or otherwise the risk of exceeding <code>cutOff</code> are accepted. If missing, this value defaults to the maximal observation on which the loss distributions were constructed (equivalently, the right end of their common support).
</p>
</td></tr>
<tr><td><code id="mgss_+3A_ord">ord</code></td>
<td>

<p>the order up to which a continuous loss distribution shall be approximated. This value may be set to high orders when it is necessary to distinguish distributions that are similar at the tails.
</p>
</td></tr>
<tr><td><code id="mgss_+3A_fbr">fbr</code></td>
<td>

<p>if set to <code>TRUE</code>, instruct the function to additionally compute the  best replies regarding each goal individually, assuming that defender plays <code>optimalDefense</code> as a leader, and the attacker per goal follows (follower's best reply). These replies are always pure strategies.
</p>
</td></tr>
<tr><td><code id="mgss_+3A_points">points</code></td>
<td>

<p>the number of points at which the resulting equilibrium loss distributions are evaluated numerically.
</p>
</td></tr>
<tr><td><code id="mgss_+3A_tol">tol</code></td>
<td>

<p>occasionally, it was observed that the internal linear programs failed due to roundoff errors; in these cases, the function reported an &quot;internal error&quot; on the LP failure. In that case, one can supply a tolerance to go into the optimization to avoid such roundoff problems. By default, the tolerance is set to zero, to search for an &quot;exact&quot; solution, though. The GLPK status given in the error message refers to the codes for the GNU Linear Programming Kit, given at <a href="https://rdrr.io/cran/glpkAPI/man/glpkConstants.html">https://rdrr.io/cran/glpkAPI/man/glpkConstants.html</a>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For continuous loss distributions, the function uses a Gaussian kernel density approximation (constructed using the function <code>lossDistribution</code>), and computes a Taylor-polynomial approximation at the <code class="reqn">x</code> equal to <code>cutOff</code> for each distribution up to order <code>ord</code>. Preferences are decided using the methods described by (Rass, König and Schauer; 2022), and (Rass, König, Schauer, Bürgin, Epperlein and Wirth; 2021), using sign-alternating derivatives, representing a distribution by a vector with <code>ord</code> elements. Categorical distributions are represented likewise directly by the vector of their probability masses. In both cases, preferences are decided by a lexicographic comparison of vector-representations. The returned optima are Nash equilibria for single-goal games, and lexicographic Nash equilibria for multi-goal games. Constructing a game using <code>mosg</code> with vectors in the payoff description can, consequently, allows to use <code>mgss</code> to compute optimal results with explicit goal priorities in multi-criteria games.
</p>


<h3>Value</h3>

<p>An object of class <code>mosg.equilibrium</code>, containing the following fields:
</p>
<table>
<tr><td><code>optimalDefense</code></td>
<td>
<p>a discrete probability distribution over the action space of player 1 (defender)</p>
</td></tr>
<tr><td><code>optimalAttacks</code></td>
<td>
<p>a discrete probability distribution over the action space of player 2 (attacker). Note that this is <em>not</em> a best-response to the player 1's <code>optimalDefense</code>, but rather the best that the attacker could
do if the game were <em>just about the particular goal</em> that the attacker refers to. This worst-case scenario assumes that the defender would focus all its efforts to that single goal.</p>
</td></tr>
<tr><td><code>assurances</code></td>
<td>
<p>a list of loss distributions valid under the assumption that player 1 adheres to the <code>optimalDefense</code> distribution in its randomized action choices, while the opponent plays its own zero-sum equilibrium strategy in the game that is only (and exclusively) about this particular goal. This value has to be interpreted with care, as it assumes that player 1 would put all efforts into a defense for the particular goal, but in reality, will have multiple criteria to simultaneously optimize.
This means that the attacker, in turn, could adapt to the <code>optimalDefense</code> of player 1, to cause more damage. The given assurance is thus only an upper bound of the worst-possible damage, under the assumption that player 1 would focus only on this particular goal.
</p>
<p>The list can be accessed by the names for each goal as specified through the input <code>mosg</code> object <code>G</code>. Each distribution within <code>assurances</code> is a mixed loss distribution constructed using <code>lossDistribution</code></p>
</td></tr>
<tr><td><code>br_to_optimalDefense</code></td>
<td>
<p>This is a vector of best replies per goal for a leading defender playing the fixed strategy <code>optimalDefense</code>, and letting the adversary (player 2) follow. It is the (stochastically largest) damage among <code class="reqn">optimalDefense^T\cdot A_p</code>, when <code class="reqn">A_p</code> is the game structure for the <code class="reqn">p</code>-th goal; the vector <code>br_to_optimalDefense</code> contains the indices of the individually best replies, pointing into the list of attack strategies.</p>
</td></tr>





</table>


<h3>Note</h3>

<p>The output loss distributions (accessible by the list <code>assurances</code>) cannot be used to construct a subsequent game (see <code>mosg</code>), since continuous distributions are represented as a sequence of points, rather than raw data or probability masses.
</p>
<p>As of version 2.0.0 of the package, this function is no longer downwards compatible to earlier versions of itself, since the method of computation (formerly fictitious play) was replaced by linear programming to give exact solutions rather than approximations. Consequently, the parameters <code>T</code> (iteration count) and <code>eps</code> (accuracy) have become useless and have been removed after version 1.0.4.
</p>


<h3>Author(s)</h3>

<p>Sandra Koenig, Stefan Rass
</p>


<h3>References</h3>

<p>S. Rass, S. König, S. Schauer: Games over Probability Distributions Revisited: New Equilibrium Models and Refinements, MDPI Games 2022, 13(6), 80; DOI: https://doi.org/10.3390/g13060080, online: https://www.mdpi.com/2073-4336/13/6/80
</p>
<p>S. Rass, S. König, S. Schauer, V. Bürgin, J. Epperlein, F. Wirth: On Game Theory Using Stochastic Tail Orders, arXiv:2108.00680v1 [math.PR], 2021
</p>
<p>S. Rass, A. Wiegele, S. König: Security Games over Lexicographic Orders, in: Decision and Game Theory for Security, 11th International Conference, GameSec 2020, College Park, MD, USA, October 28–30, 2020, Proceedings, Springer LNCS 12513, ISBN 978-3-030-64792-6
</p>
<p>S. Rass, S. König, S. Schauer. Decisions with Uncertain Consequences-A Total Ordering on Loss-Distributions. PLoS ONE 11, e0168583. 2016, https://doi.org/10.1371/journal.pone.0168583
</p>
<p>S. Rass. On Game-Theoretic Risk Management (Part One). Towards a Theory of
Games with Payoffs that are Probability-Distributions. June 2015.
http://arxiv.org/abs/1506.07368.
</p>
<p>S. Rass. On Game-Theoretic Risk Management (Part Two). Algorithms to Compute Nash-Equilibria in Games with Distributions as Payoffs, 2015, arXiv:1511.08591v1 [q-fin.EC].
</p>
<p>D. Lozovanu, D. Solomon, and A. Zelikovsky. Multiobjective games and determining
pareto-nash equilibria. Buletinul Academiei de Stiinte a Republicii Moldova
Matematica, 3(49):115-122, 2005. ISSN 1024-7696.
</p>



<h3>See Also</h3>

<p>A brief info on the results can be obtained by <code><a href="#topic+print.mosg.equilibrium">print.mosg.equilibrium</a></code>, and a more detailed summary (showing all loss distributions in detail) is obtained by <code><a href="#topic+summary.mosg.equilibrium">summary.mosg.equilibrium</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## raw data (PURELY ARTIFICIAL, for demo purposes only)
# N=100 observations in each category
obs111&lt;-c(rep(1,40),rep(3,20),rep(5,10),rep(7,20),rep(9,10));
obs112&lt;-c(rep(1,50),rep(2,10),rep(4,10),rep(6,20),rep(8,10));
obs121&lt;-c(rep(1,20),rep(4,30),rep(6,20),rep(8,10),rep(10,20));
obs122&lt;-c(rep(1,40),rep(2.5,20),rep(5,20),rep(7.5,10),rep(9,10));
obs211&lt;-c(rep(1,30),rep(2,30),rep(5,10),rep(8,10),rep(10,20));
obs212&lt;-c(rep(1,10),rep(2,10),rep(4,20),rep(7,20),rep(10,40));
obs221&lt;-c(rep(1,30),rep(3,30),rep(4,10),rep(7,20),rep(9,10));
obs222&lt;-c(rep(1,10),rep(3,10),rep(5,50),rep(8,20),rep(10,10));
obs311&lt;-c(rep(1,40),rep(2,30),rep(4,10),rep(7,10),rep(9,10));
obs312&lt;-c(rep(1,20),rep(3,20),rep(4,20),rep(7,20),rep(10,20));
obs321&lt;-c(rep(1,10),rep(3,40),rep(4,30),rep(7,10),rep(9,10));
obs322&lt;-c(rep(1,10),rep(4,30),rep(5,30),rep(7,10),rep(10,20));

## compute payoff densities
f111&lt;-lossDistribution(obs111)
f112&lt;-lossDistribution(obs112)
f121&lt;-lossDistribution(obs121)
f122&lt;-lossDistribution(obs122)
f211&lt;-lossDistribution(obs211)
f212&lt;-lossDistribution(obs212)
f221&lt;-lossDistribution(obs221)
f222&lt;-lossDistribution(obs222)
f311&lt;-lossDistribution(obs311)
f312&lt;-lossDistribution(obs312)
f321&lt;-lossDistribution(obs321)
f322&lt;-lossDistribution(obs322)

payoffs&lt;-list(f111,f112,f121, f122,f211,f212,f221,f222, f311,f312,f321,f322)
G &lt;- mosg( n=2,
            m=2,
            payoffs,
            goals=3,
            goalDescriptions=c("g1", "g2", "g3"),
            defensesDescr = c("d1", "d2"),
            attacksDescr = c("a1", "a2"))
eq &lt;- mgss(G,weights=c(0.25,0.5,0.25))
print(eq)
summary(eq)

# construct another loss distribution from a given behavior in the game G
suboptimal &lt;- lossDistribution.mosg(G, c(0.1,0.1,0.8), c(0.2,0.3,0.5))
plot(suboptimal)

# compute an equilibrium in a standard matrix game
#     [,1] [,2]
#[1,]    3    4
#[2,]    6    1
G &lt;- mosg(n = 2, m = 2, goals = 1,
          losses = list(3,6,4,1), byrow=FALSE,
          attacksDescr = c("a1", "a2"))
mgss(G, fbr=TRUE)  # compute an equilibrium, including best replies if the adversary is a follower

# get best replies if there would be a following
# adversary per goal (taking the defender as a leader)
G$attacksDescriptions[eq$br_to_optimalDefense]
</code></pre>

<hr>
<h2 id='moment'>
compute moments of loss distributions</h2><span id='topic+moment'></span>

<h3>Description</h3>

<p>the moment of given order k is computed by numeric integration or summation (in case of discrete distributions)</p>


<h3>Usage</h3>

<pre><code class='language-R'>moment(ld, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moment_+3A_ld">ld</code></td>
<td>

<p>the loss distribution as obtained from <code>lossDistribution</code> or <code>mgss</code>.
</p>
</td></tr>
<tr><td><code id="moment_+3A_k">k</code></td>
<td>

<p>the order of the moment (must be an integer <code class="reqn">\geq 1</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the k-th order moment of the given loss distribution





</p>


<h3>Note</h3>

<p>In case of continuous distributions, the value returned is an approximation and based on the internal kernel density approximation. 
</p>
<p>For categorical distributions, the function works on the internal probability mass function (which may be different from the empirical distribution in case that the loss distribution has been smoothed during its construction; see <code><a href="#topic+lossDistribution">lossDistribution</a></code>).
</p>
<p>In its current version, <code>cdf</code> does not vectorize, i.e., cannot be applied to vector arguments <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>See Also</h3>

<p>the methods <code><a href="base.html#topic+mean">mean</a></code> and <code><a href="#topic+variance">variance</a></code> are based on this function. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cvss1base &lt;- c(10,6.4,9,7.9,7.1,9)
ld &lt;- lossDistribution(cvss1base)
cdf(ld, 4)

</code></pre>

<hr>
<h2 id='mosg'>
Construction and handling of multi-objective security games
</h2><span id='topic+mosg'></span><span id='topic+print.mosg'></span><span id='topic+plot.mosg'></span><span id='topic+lossDistribution.mosg'></span>

<h3>Description</h3>

<p>this function takes a list of loss distributions construced using <code>lossDistribution</code>, along with a specification of the game's shape (number of strategies for both players and number of goals for the first player), and returns an object suitable for analysis by <code>mgss</code> to compute a multi-goal security strategy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosg( n,
      m,
      goals,
      losses,
      byrow = TRUE,
      goalDescriptions = NULL,
      defensesDescr = NULL,
      attacksDescr = NULL)

## S3 method for class 'mosg'
print(x, ...)

## S3 method for class 'mosg'
plot(x,
     goal = 1,
     points = 100,
     cutoff = NULL,
     largeGame = FALSE,
     subPlotWidth = 2,
     subPlotHeight = 2,
     cleanUp = TRUE, ...)

# construct a loss distribution by playing a given strategy in the game G
## S3 method for class 'mosg'
lossDistribution(G, player1Strat, player2Strat, points = 512, goal = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosg_+3A_n">n</code></td>
<td>

<p>number of defense strategies (cardinality of the action space for player 1)
</p>
</td></tr>
<tr><td><code id="mosg_+3A_m">m</code></td>
<td>

<p>number of attack stratgies (cardinality of the action space for player 2)
</p>
</td></tr>
<tr><td><code id="mosg_+3A_goals">goals</code></td>
<td>

<p>number of goals for player 1 (must be <code class="reqn">\geq 1</code>)
</p>
</td></tr>
<tr><td><code id="mosg_+3A_losses">losses</code></td>
<td>

<p>a <code>list</code> with <code>n*m*goals</code> entries, which specifies a total of <code>goals</code> game matrices, each with shape <code>n</code>-by-<code>m</code>. The way in which the game matrices are filled from this list is controlled by the parameter <code>byrow</code>. Note that in every case, it is assumed that one matrix is specified after the other in the list.
</p>
<p>Furthermore, the function assumes all loss distributions having a common support. This is only explicitly verified for discrete distributions (with errors reported), but implicitly assumed to hold for continuous distributions without further checks.
</p>
<p>Typically, a game will be constructed from a list of loss distributions obtained by invocations of <code>lossDistribution</code>.
</p>
<p>Games can be defined with real-valued (scalar) payoffs if a list of numbers is provided instead. Internally, the function converts these numbers into Bernoulli distributions; a scalar payoff <code class="reqn">a</code> is converted into a Bernoulli random variable <code class="reqn">X</code> having <code class="reqn">\Pr(X=a)=p\propto a</code>. This conversion is equivalent to an invocation of <code>lossDistribution</code> with the parameters <code>dat=c(1-p, p)</code>, <code>discrete=TRUE</code>, <code>dataType="pdf"</code>, <code>smoothing="none"</code>, <code>bw = 1</code> and <code>supp=c(1,2)</code>.
</p>
<p>If the list of losses comes as a list of vectors, <code>mosg</code> will construct a game assuming a lexicographic order on the loss vectors
(with the order being determined from left to right along the coordinates). To this end, <code>mosg</code> checks for all loss vectors to have the same length (otherwise, an error is reported). Negative and zero values in the loss vector <em>are allowed</em>.
</p>
</td></tr>
<tr><td><code id="mosg_+3A_byrow">byrow</code></td>
<td>

<p>by default (<code>TRUE</code>), the game matrices are filled row-by-row from list <code>losses</code>. If set to <code>FALSE</code>, then the game matrices are filled column-by-column.
</p>
</td></tr>
<tr><td><code id="mosg_+3A_goaldescriptions">goalDescriptions</code></td>
<td>

<p>if specified, this can be any vector (e.g., textual descriptions) for the goals. Defaults to 1, 2, 3, ... if missing. The length must be equal to <code>goals</code>.
</p>
</td></tr>
<tr><td><code id="mosg_+3A_defensesdescr">defensesDescr</code></td>
<td>

<p>if specified, this can be any vector (e.g., textual descriptions) for the defense strategies. Defaults to 1, 2, 3, ... if missing. The length must be equal to <code>n</code>.</p>
</td></tr>
<tr><td><code id="mosg_+3A_attacksdescr">attacksDescr</code></td>
<td>

<p>if specified, this can be any vector (e.g., textual descriptions) for the attack strategies. Defaults to 1, 2, 3, ... if missing. The length must be equal to <code>m</code>.</p>
</td></tr>
</table>
<p>for the functions <code>print</code>, <code>summary</code> and <code>plot</code>
</p>
<table>
<tr><td><code id="mosg_+3A_x">x</code></td>
<td>
<p>a game, object of class &quot;mosg&quot;, as constructed by the function <code>mosg</code></p>
</td></tr>
</table>
<p>The function <code>plot</code> additionally takes the following parameters:
</p>
<table>
<tr><td><code id="mosg_+3A_goal">goal</code></td>
<td>
<p>an integer referring to the goal of interest (for plotting or to construct a loss distribution for). Defaults to the first goal if omitted.</p>
</td></tr>
<tr><td><code id="mosg_+3A_points">points</code></td>
<td>
<p>The number of points at which the density is evaluated (for continuous losses); this parameter is ignored for categorical losses.</p>
</td></tr>
<tr><td><code id="mosg_+3A_cutoff">cutoff</code></td>
<td>
<p>the cutoff point at which all densities shall be truncated before plotting (note that the mass functions are rescaled towards unit mass).</p>
</td></tr>
</table>
<p>The plot function overrides the following settings internally (so supplying these as parameters will raise an error): <code>xlab, ylab, main, type, names.arg</code> and <code>font.main</code> (applying differently for bar and line plots)
</p>
<table>
<tr><td><code id="mosg_+3A_largegame">largeGame</code></td>
<td>
<p>if the plot exits with the error &quot;figure margins too large&quot;, one can set this
parameter to TRUE, causing plot to write to a temporary SVG file (scalable vector graphics), to avoid the figure space issue and hence
the error. The price is a (potentially much) slower plotting, since the system creates the file, and loads it afterwards from
the harddisk (cleaning up the file after displaying it). The size of the plot is controllable by setting
the parameters <code>subPlotWidth</code> and <code>subPlotHeight</code>, see below.</p>
</td></tr>
<tr><td><code id="mosg_+3A_subplotwidth">subPlotWidth</code></td>
<td>
<p>the width in inches for each payoff distribution in the game matrix. This parameter is
ignored when <code>largeGame</code> is set to FALSE (the default).</p>
</td></tr>
<tr><td><code id="mosg_+3A_subplotheight">subPlotHeight</code></td>
<td>
<p>the height in inches for each payoff distribution in the game matrix. This parameter is
ignored when <code>largeGame</code> is set to FALSE (the default).</p>
</td></tr>
<tr><td><code id="mosg_+3A_cleanup">cleanUp</code></td>
<td>
<p>If the graph is to be used in other programs, one can supply <code>cleanUp = FALSE</code> to retain the temporary SVG file for subsequent use and prints a message where to find the file. By default, the temporary file gets deleted.</p>
</td></tr>
</table>
<p>The function <code>lossDistribution.mosg</code> can be used to play any (given) strategies for player 1 and player 2, and compute the resulting loss from the game.
</p>
<table>
<tr><td><code id="mosg_+3A_g">G</code></td>
<td>
<p>a game constructed by <code>mosg</code> to deliver the loss distribution through its game matrices.</p>
</td></tr>
<tr><td><code id="mosg_+3A_player1strat">player1Strat</code></td>
<td>
<p>a discrete distribution over the action space for the defending player 1 in the game <code>G</code></p>
</td></tr>
<tr><td><code id="mosg_+3A_player2strat">player2Strat</code></td>
<td>
<p>a discrete distribution over the action space for the attacking player 2 in the game <code>G</code></p>
</td></tr>
<tr><td><code id="mosg_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Upon input, the function does some consistency checks, such as testing the length of the parameter <code>losses</code> to be equal to n*m*goals. The loss distributions are checked for mutual consistency in terms of all being continuous or all being discrete (a mix is not allowed), and all being not mixed distributions (that is, the output distribution of a previous call to <code>mgss</code> cannot be used as input to this function).
</p>
<p>The functions <code>print.mosg</code> gives a brief overview of the game, listing only the shape and strategies for both players. For detailed information, use <code>summary</code> on a specific loss distribution in the list for the game (field <code>losses</code>).
</p>
<p>For plotting games, <code>plot.mosg</code> constructs an (n x m)-matrix of loss distributions with rows and columns in the grid being labeled by the values in <code>defensesDescr</code> and <code>attacksDescr</code>. The plot heading is the name for the specified goal. The function makes no changes to the plot parameters, so fine tuning can be done by changing the settings using the <a href="graphics.html#topic+par">par</a> function.
</p>
<p>The function <code>lossDistribution.mosg</code> can be used to compute the distribution <code class="reqn">x^T*A*y</code>, for the payoff distribution matrix <code class="reqn">A</code>, and mixed strategies <code class="reqn">x</code> (<code>player1strat</code>) and <code class="reqn">y</code> (<code>player2strat</code>) in the game. The computation is by a pointwise addition of loss distributions, with the number of points being specifiable by the parameter <code>points</code>, which defaults to 512.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>mosg</code>, usable with the function <code>mgss</code> to determine a security strategy (i.e., a lexicographic Nash equilibrium assuming a zero-sum one-against-all competition). The fields returned in the <code>mosg</code> object are filled with the input values supplied. In detail, the fields are:
</p>
<table>
<tr><td><code>nDefenses</code></td>
<td>
<p>the value of the parameter <code>n</code></p>
</td></tr>
<tr><td><code>nAttacks</code></td>
<td>
<p>the value of the parameter <code>m</code></p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>the value of the parameter <code>goals</code></p>
</td></tr>
<tr><td><code>attacksDescriptions</code>, <code>defensesDescriptions</code>, <code>goalDescriptions</code></td>
<td>
<p>if supplied, then these are filled with the values of <code>goalDescr</code>, <code>defensesDescr</code> and <code>attacksDescr</code>; otherwise, they contain the default values described above.</p>
</td></tr>
<tr><td><code>maximumLoss</code></td>
<td>
<p>the maximal loss taken over all specified loss distributions</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>a locus-function for accessing the list <code>losses</code> using a triple notation (goal,i,j), where goal addresses the game matrix and i,j are the row and column indices (starting from 1 as the smallest index). This function is used internally (only).</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Games constructed with real-valued payoffs or payoff vectors over the reals are allowed with negative or zero values in the list of losses. In that case, embeds the loss values or vector into a <a href="#topic+lossDistribution">lossDistribution</a> object after shifting and scaling the values into the strictly positive range. This operation creates a strategically equivalent game, i.e., leaves the set of equilibria unchanged, yet the resulting <a href="#topic+mosg">mosg</a> object <em>is not</em> useful with the <a href="#topic+lossDistribution.mosg">lossDistribution.mosg</a>, <a href="#topic+moment">moment</a>, <a href="#topic+cdf">cdf</a>, or any other member functions for <a href="#topic+lossDistribution">lossDistribution</a> objects obtained from equilibria. Those have to be computed manually. Be aware that there will be no warnings issued whatsoever in that case of misuse, since the <a href="#topic+lossDistribution">lossDistribution</a> objects constructed to carry the real or vector-valued payoffs of the original game carry no information about the semantics of the values or vectors that they have been created from. Hence, the <em>computation of equilibria works correctly</em> using <a href="#topic+mosg">mosg</a>, while any further analysis (including plots)  <em>needs to be done manually</em>.
</p>


<h3>Note</h3>

<p>It is important to remark that player 1 is always minimizing. To treat a maximizing player, one must reconstruct the game using regrets instead of losses, i.e., if the data for a specific loss distribution is <code class="reqn">D</code>, then the game for a maximizing player 1 must be constructed from <code>(max(D) - D)</code> instead of <code>D</code>.</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>See Also</h3>

<p>Security strategies for a <code><a href="#topic+mosg">mosg</a></code> object can be obtained by calling <code><a href="#topic+mgss">mgss</a></code>. The game itself can be constructed from the output of <code><a href="#topic+lossDistribution">lossDistribution</a></code>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(compare)

## raw data (PURELY ARTIFICIAL, for demo purposes only)
# N=100 observations in each category
obs111&lt;-c(rep(1,40),rep(3,20),rep(5,10),rep(7,20),rep(9,10));
obs112&lt;-c(rep(1,50),rep(2,10),rep(4,10),rep(6,20),rep(8,10));
obs121&lt;-c(rep(1,20),rep(4,30),rep(6,20),rep(8,10),rep(10,20));
obs122&lt;-c(rep(1,40),rep(2.5,20),rep(5,20),rep(7.5,10),rep(9,10));
obs211&lt;-c(rep(1,30),rep(2,30),rep(5,10),rep(8,10),rep(10,20));
obs212&lt;-c(rep(1,10),rep(2,10),rep(4,20),rep(7,20),rep(10,40));
obs221&lt;-c(rep(1,30),rep(3,30),rep(4,10),rep(7,20),rep(9,10));
obs222&lt;-c(rep(1,10),rep(3,10),rep(5,50),rep(8,20),rep(10,10));
obs311&lt;-c(rep(1,40),rep(2,30),rep(4,10),rep(7,10),rep(9,10));
obs312&lt;-c(rep(1,20),rep(3,20),rep(4,20),rep(7,20),rep(10,20));
obs321&lt;-c(rep(1,10),rep(3,40),rep(4,30),rep(7,10),rep(9,10));
obs322&lt;-c(rep(1,10),rep(4,30),rep(5,30),rep(7,10),rep(10,20));

## compute payoff densities
f111&lt;-lossDistribution(obs111)
f112&lt;-lossDistribution(obs112)
f121&lt;-lossDistribution(obs121)
f122&lt;-lossDistribution(obs122)
f211&lt;-lossDistribution(obs211)
f212&lt;-lossDistribution(obs212)
f221&lt;-lossDistribution(obs221)
f222&lt;-lossDistribution(obs222)
f311&lt;-lossDistribution(obs311)
f312&lt;-lossDistribution(obs312)
f321&lt;-lossDistribution(obs321)
f322&lt;-lossDistribution(obs322)

payoffs&lt;-list(f111,f112,f121, f122,f211,f212,f221,f222, f311,f312,f321,f322)
G &lt;- mosg( n=2,
            m=2,
            payoffs,
            goals=3,
            goalDescriptions=c("g1", "g2", "g3"),
            defensesDescr = c("d1", "d2"),
            attacksDescr = c("a1", "a2"))
print(G)
summary(G)
plot(G)

# construct and solve scalar valued (classical) game;
# losses are all numbers (degenerate distributions)
# the resulting matrix game has the payoff structure:
#     [,1] [,2]
#[1,]    3    4
#[2,]    6    1
G &lt;- mosg(n = 2, m = 2, goals = 1, losses = list(3,6,4,1), byrow=FALSE)
mgss(G)  # compute a lexicographic Nash equilibrium
</code></pre>

<hr>
<h2 id='mosg.equilibrium'>
embodies all information related to a lexicographic Nash equilibrium computed by the function <code>mgss</code>.
</h2><span id='topic+summary.mosg.equilibrium'></span><span id='topic+print.mosg.equilibrium'></span><span id='topic+plot.mosg.equilibrium'></span><span id='topic+print.mosg.equilibrium.summary'></span>

<h3>Description</h3>

<p>The generic functions <code>print</code> and <code>summary</code> provide brief, and detailed information about the lexicographic Nash equilibrium. The generic function <code>plot</code> can be used to visualize the equilibrium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mosg.equilibrium'
summary(object, ...)
## S3 method for class 'mosg.equilibrium.summary'
print(x, ...)
## S3 method for class 'mosg.equilibrium'
print(x, extended=FALSE, ...)
## S3 method for class 'mosg.equilibrium'
plot(x, points=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosg.equilibrium_+3A_x">x</code></td>
<td>

<p>an <code>mgss</code> object as returned by the function <code>mgss</code>.
</p>
</td></tr>
<tr><td><code id="mosg.equilibrium_+3A_object">object</code></td>
<td>

<p>an <code>mgss</code> object as returned by the function <code>mgss</code>.
</p>
</td></tr>
</table>
<p>for <code>print.mosg.equilibrium</code>, the following parameter can be supplied:
</p>
<table>
<tr><td><code id="mosg.equilibrium_+3A_extended">extended</code></td>
<td>
<p>if set to <code>TRUE</code>, then the individual assurances are printed as well.</p>
</td></tr>
</table>
<p>for <code>plot.mosg.equilibrium</code>, the following parameter can be supplied:
</p>
<table>
<tr><td><code id="mosg.equilibrium_+3A_points">points</code></td>
<td>
<p>the number of points to evaluate the density function over its support for plotting</p>
</td></tr>
<tr><td><code id="mosg.equilibrium_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result returned by the function <code>summary</code> carries the following fields:
</p>
<table>
<tr><td><code>optimalDefense</code></td>
<td>
<p>a discrete probability distribution over the action space for player 1 (the defender).</p>
</td></tr>
<tr><td><code>optimalAttacks</code></td>
<td>
<p>a discrete probability distribution over the action space for player 2 (the attacker).</p>
</td></tr>
<tr><td><code>assurances</code></td>
<td>
<p>an optimal loss distribution valid under the assumption that the defender plays <code>optimalDefense</code> as its mixed strategy. This is a list of <code>mosg.lossdistribution</code> objects, accessible through their assigend names (coming from the underlying game) or by indices.</p>
</td></tr>
</table>
<p>The action spaces for both players are defined in first place by the game for which the equilibrium was computed (via <code>mgss</code> on a game constructed by <code>mosg</code>).
</p>
<p><code>print</code> gives a shortened output restricted only to displaying the optimal defense for the defender and attack strategies per goal (as defined by the underlying game).
</p>
<p><code>summary</code> returns an object of class <code>summary.mosg.lossdistribution</code>, which has the fields:
&quot;range&quot;       &quot;mean&quot;        &quot;variance&quot;    &quot;quantiles&quot;   &quot;is.discrete&quot;
</p>
<table>
<tr><td><code>range</code></td>
<td>
<p>the minimal and maximal values of the loss (as anticipated by the observations)</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the first moment as computed by <code>mean</code></p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>the variance as computed by <code>variance</code></p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>a 2x5-matrix of quantiles at the 10%,25%,50%,75% and 90% level</p>
</td></tr>
<tr><td><code>is.discrete</code></td>
<td>
<p>a Boolean flag being <code>TRUE</code> if the loss distribution is over categories</p>
</td></tr>
</table>
<p><code>plot</code> displays a grid of plots, starting with the optimal defense behavior plotted as a discrete distribution on top of a (m x 2)-matrix of plots. Each line in this grid shows the discrete optimal attack strategy on the right side (as a bar plot), paired with the loss distribution (extracted from <code>x</code>) caused when the defender plays <code>optimalDefense</code> and the attacker plays the respective optimal attack strategy.
</p>







<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.mosg.equilibrium">print.mosg.equilibrium</a></code>, <code><a href="#topic+mgss">mgss</a></code>, <code><a href="#topic+mosg">mosg</a></code>, <code><a href="#topic+lossDistribution">lossDistribution</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## raw data (PURELY ARTIFICIAL, for demo purposes only)
# N=100 observations in each category
obs111&lt;-c(rep(1,40),rep(3,20),rep(5,10),rep(7,20),rep(9,10));
obs112&lt;-c(rep(1,50),rep(2,10),rep(4,10),rep(6,20),rep(8,10));
obs121&lt;-c(rep(1,20),rep(4,30),rep(6,20),rep(8,10),rep(10,20));
obs122&lt;-c(rep(1,40),rep(2.5,20),rep(5,20),rep(7.5,10),rep(9,10));
obs211&lt;-c(rep(1,30),rep(2,30),rep(5,10),rep(8,10),rep(10,20));
obs212&lt;-c(rep(1,10),rep(2,10),rep(4,20),rep(7,20),rep(10,40));
obs221&lt;-c(rep(1,30),rep(3,30),rep(4,10),rep(7,20),rep(9,10));
obs222&lt;-c(rep(1,10),rep(3,10),rep(5,50),rep(8,20),rep(10,10));
obs311&lt;-c(rep(1,40),rep(2,30),rep(4,10),rep(7,10),rep(9,10));
obs312&lt;-c(rep(1,20),rep(3,20),rep(4,20),rep(7,20),rep(10,20));
obs321&lt;-c(rep(1,10),rep(3,40),rep(4,30),rep(7,10),rep(9,10));
obs322&lt;-c(rep(1,10),rep(4,30),rep(5,30),rep(7,10),rep(10,20));

## compute payoff densities
f111&lt;-lossDistribution(obs111)
f112&lt;-lossDistribution(obs112)
f121&lt;-lossDistribution(obs121)
f122&lt;-lossDistribution(obs122)
f211&lt;-lossDistribution(obs211)
f212&lt;-lossDistribution(obs212)
f221&lt;-lossDistribution(obs221)
f222&lt;-lossDistribution(obs222)
f311&lt;-lossDistribution(obs311)
f312&lt;-lossDistribution(obs312)
f321&lt;-lossDistribution(obs321)
f322&lt;-lossDistribution(obs322)

payoffs&lt;-list(f111,f112,f121, f122,f211,f212,f221,f222, f311,f312,f321,f322)
G &lt;- mosg( n=2,
            m=2,
            payoffs,
            goals=3,
            goalDescriptions=c("g1", "g2", "g3"),
            defensesDescr = c("d1", "d2"),
            attacksDescr = c("a1", "a2"))
eq &lt;- mgss(G,weights=c(0.25,0.5,0.25))
print(eq)
summary(eq)
plot(eq)

# access the loss distributions computed in the game
summary(eq$assurances$g1)
mean(eq$assurance$g1)    # get the average loss in goal "g1"
</code></pre>

<hr>
<h2 id='preference'>
Decision on preferences between loss distributions
</h2><span id='topic+preference'></span>

<h3>Description</h3>

<p>This function implements the total ordering on losses, based on treating the moment sequences as hyperreal numbers, and returns the lesser of the loss distribution representatives in the hyperreal space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preference(x, y, verbose = FALSE, weights, points = 512)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preference_+3A_x">x</code></td>
<td>

<p>a loss, being either a number,a distribution or list of distributions (objects of class <code>mosg.lossdistribution</code>)</p>
</td></tr>
<tr><td><code id="preference_+3A_y">y</code></td>
<td>

<p>a loss, being either a number,a distribution or list of distributions (objects of class <code>mosg.lossdistribution</code>)</p>
</td></tr>
<tr><td><code id="preference_+3A_weights">weights</code></td>
<td>

<p>a vector of <code>n = length(x) = length(y)</code> nonzero numbers (not necessarily summing up to 1), used only if <code>x</code> and <code>y</code> are lists of <code>mosg.lossdistribution</code> objects corresponding to <code class="reqn">n&gt;1</code> goals. In that case,
the i-th goal gets assigend the weight (priority) <code>weights[[i]]</code>. Defaults to all goals having equal priority if the parameter is missing (<code>weights = rep(1/length(x), length(x))</code>).
</p>
</td></tr>
<tr><td><code id="preference_+3A_verbose">verbose</code></td>
<td>

<p>if set to <code>TRUE</code>, the function returns the preferred of its arguments directly (thus, giving back <code>x</code> or <code>y</code>). If set to <code>FALSE</code> (default), then it returns the argument index (1 = <code>x</code>, 2 = <code>y</code>) or 0 in case that <code class="reqn">x=y</code>.
</p>
</td></tr>
<tr><td><code id="preference_+3A_points">points</code></td>
<td>

<p>the number of points at which the distributions are evaluated numerically to determine the preference.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deciding the preference ordering defined in terms of moment sequence as proposed in (Rass, 2015). To avoid having to compute all moments up to an unknown order, this function decides by looking at the tails of the distribution, returning the one with faster decaying tail as the preferred distribution. This method delivers exact decisions for discrete distributions, but is only an approximate approach for continous densities.
</p>


<h3>Value</h3>

<p>the result is either a copy of the input parameter <code>x</code> or <code>y</code>, depending on which distribution is preferred. 
</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>References</h3>

<p>S. Rass. On Game-Theoretic Risk Management (Part One). Towards a Theory of
Games with Payoffs that are Probability-Distributions. ArXiv e-prints, June 2015.
http://arxiv.org/abs/1506.07368.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lossDistribution">lossDistribution</a></code>, <code>lossDistribution.mosg</code>, <code><a href="#topic+print.mosg.lossdistribution">print.mosg.lossdistribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use data from CVSS risk assessments
cvss1base &lt;- c(10,6.4,9,7.9,7.1,9)
cvss2base &lt;- c(10,7.9,8.2,7.4,10,8.5,9,9,8.7)
ld1 &lt;- lossDistribution(cvss1base)
ld2 &lt;- lossDistribution(cvss2base)
lowerRisk &lt;- preference(ld1, ld2) # get the result for later use
preference(ld1, ld2, verbose=TRUE) # view the detailed answer
</code></pre>

<hr>
<h2 id='variance'>
Computes the approximate variance of a loss distribution.
</h2><span id='topic+variance'></span>

<h3>Description</h3>

<p>The computation is based on Steiner's theorem <code class="reqn">\textrm{var}(X) = \textrm{E}(X^2) - (\textrm{E}(X))^2</code>, where the
respective first and second moments are computed using the <code>moment</code> function (from this package). Internally, these 
functions operate on the approximate kernel density estimation for both, continuous and categorical distributions
(see the <code>lossDistribution</code> function for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variance_+3A_x">x</code></td>
<td>

<p>an object of class <code>mosg.lossDistribution</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the approximate variance value





</p>


<h3>Note</h3>

<p>the function works on the internal probability mass function (which may be different from the empirical distribution in case that the loss distribution has been smoothed during its construction; see <code><a href="#topic+lossDistribution">lossDistribution</a></code>). The function delivers only an approximate variance, whose error is due to numeric roundoff errors (known to occur in Steiner's formula), and the fact that the computation is done on an approximate density (rather than the 
empirical distribution).



</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>See Also</h3>


<p><code><a href="#topic+moment">moment</a></code>, <code><a href="#topic+lossDistribution">lossDistribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>










x &lt;- c(10,6.4,9,7.9,7.1,9)
ld &lt;- lossDistribution(x)
variance(ld)
var(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
