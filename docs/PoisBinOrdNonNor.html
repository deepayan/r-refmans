<!DOCTYPE html><html lang="en"><head><title>Help for package PoisBinOrdNonNor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PoisBinOrdNonNor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PoisBinOrdNonNor-package'>
<p>Generation of up to Four Different Types of Variables</p></a></li>
<li><a href='#check.params'>
<p>Validates the adjusted marginal parameter lists</p></a></li>
<li><a href='#find.cor.mat.star'>
<p>Finds intermediate correlation matrix</p></a></li>
<li><a href='#genPBONN'>
<p>Engine (generation) function for the PoisBinOrdNonNor package</p></a></li>
<li><a href='#lower.upper.cors'>
<p>Computes lower and upper correlation bounds</p></a></li>
<li><a href='#validate.cor.mat'>
<p>Validates the target correlation matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generation of Up to Four Different Types of Variables</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Hakan Demirtas, Rachel Nordgren, Rawan Allozi, Ran Gao</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ran Gao &lt;rgao8@uic.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generation of a chosen number of count, binary, ordinal, and continuous random variables, with specified correlations and marginal properties. The details of the method are explained in Demirtas (2012) &lt;<a href="https://doi.org/10.1002%2Fsim.5362">doi:10.1002/sim.5362</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, corpcor, MASS, GenOrd, BB</td>
</tr>
<tr>
<td>Suggests:</td>
<td>moments</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-22 01:52:35 UTC; rangao</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-22 05:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PoisBinOrdNonNor-package'>
Generation of up to Four Different Types of Variables
</h2><span id='topic+PoisBinOrdNonNor-package'></span><span id='topic+PoisBinOrdNonNor'></span>

<h3>Description</h3>

<p>Simultaneous generation of a chosen number of count,
binary, ordinal, and continuous (via Fleishman polynomials) random variables, with specified correlations and marginal distributions. Throughout the package, the word 'Poisson' is used to imply count data under the assumption of Poisson distribution; and continuous variables can take any shape allowed by Fleishman polynomials. The correlation matrix and the generated data follow the order of Poisson, binary, ordinal and continuous.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> PoisBinOrdNonNor</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-03-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package consists of five public functions.  The function <code><a href="#topic+check.params">check.params</a></code> validates the input parameters to avoid obvious specification errors of the marginal parameters. The function <br /> <code><a href="#topic+validate.cor.mat">validate.cor.mat</a></code> validates an input target correlation matrix to make sure that it is a legitimate correlation matrix, and then calls <code><a href="#topic+lower.upper.cors">lower.upper.cors</a></code> with the rest of the input parameters to generate approximate maximum and minimum feasible bounds, and then checks that each entry is within its bounds. The function <code><a href="#topic+find.cor.mat.star">find.cor.mat.star</a></code> creates the intermediate correlation matrix.  Finally, given the output from <code><a href="#topic+find.cor.mat.star">find.cor.mat.star</a></code> along with the other variable specifications, the function <code><a href="#topic+genPBONN">genPBONN</a></code> generates the simultaneous random data, following the target correlation matrix and the marginal input parameters.
</p>


<h3>Note</h3>

<p>The approximation used to find the correlation for Poisson variables is not very accurate once lambda is less than 1, and becomes less accurate as lambda gets closer to 0.
</p>
<p>A flag is used to specify if ordinal probabilities are cumulative&ndash;default is FALSE.
</p>
<p>Binary variables can be listed separately or combined with ordinal variables&ndash;the results will be equivalent.  Any variables listed as ordinal are affected by the cumulative flag.
</p>


<h3>Author(s)</h3>

<p>Hakan Demirtas, Rachel Nordgren, Rawan Allozi, Ran Gao
</p>
<p>Maintainer: Ran Gao &lt;rgao8@uic.edu&gt;
</p>


<h3>References</h3>

<p>Amatya, A. &amp; Demirtas, H. (2015) Simultaneous generation of multivariate mixed
data with Poisson and normal marginals. <em>Journal of Statistical Computation and Simulation</em> <b>85:15</b>, 3129&ndash;3139.
</p>
<p>Demirtas, H. (2014). Joint generation of binary and nonnormal continuous data.
<em>Journal of Biometrics and Biostatistics</em> <b>5:3:1000199</b>, 1&ndash;9.
</p>
<p>Demirtas, H. &amp; Hedeker, D. (2011) A practical way for computing approximate
lower and upper correlation bounds. <em>American Statistician</em> <b>65:2</b>, 104&ndash;109.
</p>
<p>Demirtas, H. &amp; Hedeker, D. (2016). Computing the point-biserial correlation under
any underlying continuous distribution. <em>Communications in Statistics &ndash;
Simulation and Computation</em>, <b>45:8</b>, 2744&ndash;2751. 
</p>
<p>Demirtas, H., Hedeker, D. &amp; Mermelstein, R. J. (2012) Simulation of massive public
health data by power polynomials. <em>Statistics in Medicine</em> <b>31:27</b>, 3337&ndash;3346.
</p>

<hr>
<h2 id='check.params'>
Validates the adjusted marginal parameter lists
</h2><span id='topic+check.params'></span>

<h3>Description</h3>

<p>This function validates the lists of marginal parameters for the chosen number of Poisson, ordinal (and binary), and continuous (via Fleishman polynomials) random variables. The list for ordinal/binary variables must be cumulative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.params(no.pois = 0, no.ordbin = 0, no.nonn = 0, pois.list = list(), 
    ordbin.list = list(), nonn.list = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.params_+3A_no.pois">no.pois</code></td>
<td>

<p>The number of Poisson random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="check.params_+3A_no.ordbin">no.ordbin</code></td>
<td>

<p>The number of ordinal and binary random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="check.params_+3A_no.nonn">no.nonn</code></td>
<td>

<p>The number of continuous random variables desired, created using Fleishman polynomials. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="check.params_+3A_pois.list">pois.list</code></td>
<td>

<p>A list of the lambda values, which must be greater than 0. Length will be equal to no.pois, or an error will be thrown. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="check.params_+3A_ordbin.list">ordbin.list</code></td>
<td>

<p>A list of vectors containing the cumulative probabilities for each variable. Each vector should have entries between 0 and 1 inclusive, in increasing order. Length must be equal to no.ordbin. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="check.params_+3A_nonn.list">nonn.list</code></td>
<td>

<p>A list of vectors containing the first four moments of each variable, in order. If only two parameters are supplied, they will be assumed to be skew and excess kurtosis, with mean=0 and variance=1. If only three parameters are supplied, they will be assumed to be variance, skew and excess kurtosis, with mean=0. If less than two parameters or more than four parameters are supplied for any variable, an error will be raised. Variance must be positive, and excess kurtosis must be greater than or equal to skew^2 - 2. Length must be equal to no.nonn. Defaults to an empty list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each list of transformed parameters is sent to the appropriate helper function. Requirements for each are mentioned in the description above.
</p>


<h3>Value</h3>

<p>TRUE if all items meet necessary criteria. If not, program will have stopped with a specific error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#This pois.list will produce an error since the first entry is 0.
check.params(no.pois = 2, pois.list = list(0, 1))

#This ordbin.list will produce an error since it is not cumulative.
check.params(no.ordbin = 2, ordbin.list = list(.25, c(.25, 0, .75)))

#This ordbin.list will produce an error since the last entry is &gt; 1.
check.params(no.ordbin = 2, ordbin.list = list(.25, c(.25, .5, 1.25)))

#This ordbin.list will produce an error since the first entry &lt; 0.
check.params(no.ordbin = 2, ordbin.list = list(.25, c(-.25, .5, .75)))

#This nonn.list will produce an error since 0 &lt; 2^2 - 2
check.params(no.nonn = 2, nonn.list = list(c(2,0), c(.5, 1, 2, 0)))

#This nonn.list will produce an error since the variance = 0.
check.params(no.nonn = 2, nonn.list = list(c(0,0), c(.5, 0, 0, 0)))

## End(Not run)

check.params(no.pois = 1, pois.list = list(1), no.ordbin = 2, 
    ordbin.list = list(.25, c(.25, .25, .75)), no.nonn = 1, 
    nonn.list = list(c(0, 1, 0, 3)))
</code></pre>

<hr>
<h2 id='find.cor.mat.star'>
Finds intermediate correlation matrix
</h2><span id='topic+find.cor.mat.star'></span>

<h3>Description</h3>

<p>This function calculates an intermediate correlation matrix for a chosen number of Poisson, binary,
ordinal, and continuous (via Fleishman polynomials) random variables, with specified target
correlations and marginal properties. The correlation matrix follows the order of Poisson, binary, ordinal, continuous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.cor.mat.star(cor.mat, no.pois = 0, no.bin = 0, no.ord = 0, 
    no.nonn = 0, pois.list = list(), bin.list = list(), ord.list = list(), 
    is.ord.list.cum = FALSE, nonn.list = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.cor.mat.star_+3A_cor.mat">cor.mat</code></td>
<td>

<p>The desired target correlation matrix.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_no.pois">no.pois</code></td>
<td>

<p>The number of Poisson random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_no.bin">no.bin</code></td>
<td>

<p>The number of binary random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_no.ord">no.ord</code></td>
<td>

<p>The number of ordinal random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_no.nonn">no.nonn</code></td>
<td>

<p>The number of continuous random variables desired, created using Fleishman polynomials. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_pois.list">pois.list</code></td>
<td>

<p>A list of the lambda values, which must be greater than 0. Length will be equal to no.pois, or an error will be thrown. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_bin.list">bin.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each variable. Each vector should have 2 entries between 0 and 1 inclusive, and sum to 1. Length must be equal to no.bin. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_ord.list">ord.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each variable. If is.ord.list.cum is TRUE, each vector should have entries between 0 and 1, in increasing order. Otherwise, each vector should have entries between 0 and 1 inclusive that sum to 1. Length must be equal to no.ord. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_is.ord.list.cum">is.ord.list.cum</code></td>
<td>

<p>Flag for whether the ordinal list supplied contains cumulative probabilities. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="find.cor.mat.star_+3A_nonn.list">nonn.list</code></td>
<td>

<p>A list of vectors containing the first four moments of each variable, in order. If only two parameters are supplied, they will be assumed to be skew and excess kurtosis, with mean = 0 and variance = 1. If only three parameters are supplied, they will be assumed to be variance, skew and excess kurtosis, with mean = 0. If less than two parameters or more than four parameters are supplied for any variable, an error will be raised. Variance must be positive, and excess kurtosis must be greater than or equal to skew^2-2. Length must be equal to no.nonn. Defaults to an empty list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the target correlation matrix and input parameters are checked using <code><a href="#topic+validate.cor.mat">validate.cor.mat</a></code>.
</p>
<p>Second, the input lists are transformed and combined.
</p>
<p>Third, each entry is tranformed in order.
</p>

<ul>
<li><p> Poisson-Poisson entries follow Amatya and Demirtas (2016).
</p>
</li>
<li><p> Ordinal/Binary-Ordinal/Binary entries are transformed using a call to <em>ordcont</em> in <span class="pkg">GenOrd</span> package.
</p>
</li>
<li><p> Continuous-Continuous entries use the correlation matrix for the underlying Fleishman polynomials.
</p>
</li>
<li><p> All mixed entries use the approximation from Demirtas and Hedeker 2016: corr(X, Z) = cor(X, Y) * 
cor(Y, Z) where Y is a standard normal variable. In other words, the association between X and Z is assumed to be fully explained by the association between X and Y and the association between Y and Z.
</p>
</li></ul>

<p>Fourth, the resulting matrix is checked for validity. If it is not a valid correlation matrix, a warning message is printed and the nearest valid matrix is returned instead. (<em>nearPD</em> from <span class="pkg">Matrix)</span>
</p>


<h3>Value</h3>

<p>A (no.pois+no.bin+no.ord+no.nonn) by (no.pois+no.bin+no.ord+no.nonn) square matrix, containing the intermediate correlation values.
</p>


<h3>References</h3>

<p>Amatya, A. &amp; Demirtas, H. (2015) Simultaneous generation of multivariate mixed
data with Poisson and normal marginals. <em>Journal of Statistical Computation and Simulation</em> <b>85:15</b>, 3129&ndash;3139.
</p>
<p>Demirtas, H. (2014). Joint generation of binary and nonnormal continuous data.
<em>Journal of Biometrics and Biostatistics</em> <b>5:3:1000199</b>, 1&ndash;9.
</p>
<p>Demirtas, H. &amp; Hedeker, D. (2011) A practical way for computing approximate
lower and upper correlation bounds. <em>American Statistician</em> <b>65:2</b>, 104&ndash;109.
</p>
<p>Demirtas, H. &amp; Hedeker, D. (2016). Computing the point-biserial correlation under
any underlying continuous distribution. <em>Communications in Statistics &ndash;
Simulation and Computation</em>, <b>45:8</b>, 2744&ndash;2751. 
</p>
<p>Demirtas, H., Hedeker, D. &amp; Mermelstein, R. J. (2012) Simulation of massive public
health data by power polynomials. <em>Statistics in Medicine</em> <b>31:27</b>, 3337&ndash;3346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validate.cor.mat(cor.mat = .3 * diag(3) + .7, no.pois = 3, 
    pois.list = list(.25, .5, 1))
find.cor.mat.star(cor.mat = .3 * diag(3) + .7, no.pois = 3, 
    pois.list = list(.25, .5, 1))

validate.cor.mat(cor.mat = .8 * diag(3) + .2, no.ord = 3, 
    ord.list = list(c(.2, .8), c(.1, .2, .3, .4), c(.8, 0, .1, .1)))
find.cor.mat.star(cor.mat = .8 * diag(3) + .2, no.ord = 3, 
    ord.list = list(c(.2, .8), c(.1, .2, .3, .4), c(.8, 0, .1, .1)))

validate.cor.mat(cor.mat = .5 * diag(3) + .5, no.pois = 1, no.nonn = 1,
    no.ord = 1, pois.list = list(.5), ord.list = list(c(.8, 0, .1, .1)),
    nonn.list = list(c(0, 1, 0, 1)))
find.cor.mat.star(cor.mat = .5 * diag(3) + .5, no.pois = 1, no.nonn = 1,
    no.ord = 1, pois.list = list(.5), ord.list = list(c(.8, 0, .1, .1)),
    nonn.list = list(c(0, 1, 0, 1)))
</code></pre>

<hr>
<h2 id='genPBONN'>
Engine (generation) function for the PoisBinOrdNonNor package
</h2><span id='topic+genPBONN'></span>

<h3>Description</h3>

<p>This function generates a chosen number of Poisson, binary, ordinal, and continuous (via Fleishman
polynomials) random variables, with specified correlations and marginal properties. The correlation matrix and the generated data follow the order of Poisson, binary, ordinal and continuous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPBONN(n, cmat.star, no.pois = 0, no.bin = 0, no.ord = 0, 
    no.nonn = 0, pois.list = list(), bin.list = list(), 
    ord.list = list(), is.ord.list.cum = FALSE, nonn.list = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genPBONN_+3A_n">n</code></td>
<td>

<p>The number of rows in the generated data matrix.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_cmat.star">cmat.star</code></td>
<td>

<p>The intermediate correlation matrix.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_no.pois">no.pois</code></td>
<td>

<p>The number of Poisson random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_no.bin">no.bin</code></td>
<td>

<p>The number of binary random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_no.ord">no.ord</code></td>
<td>

<p>The number of ordinal random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_no.nonn">no.nonn</code></td>
<td>

<p>The number of continuous random variables desired, created using Fleishman polynomials. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_pois.list">pois.list</code></td>
<td>

<p>A list of the lambda values, which must be greater than 0. Length will be equal to no.pois, or an error will be thrown. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_bin.list">bin.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each variable. Each vector should have 2 entries between 0 and 1 inclusive, and sum to 1. Length must be equal to no.bin. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_ord.list">ord.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each variable. Each vector should have entries between 0 and 1 inclusive, and sum to 1. Length must be equal to no.ord. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_is.ord.list.cum">is.ord.list.cum</code></td>
<td>

<p>Flag for whether the ordinal list supplied contains cumulative probabilities. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="genPBONN_+3A_nonn.list">nonn.list</code></td>
<td>

<p>A list of vectors containing the first four moments of each variable, in order. If only two parameters are supplied, they will be assumed to be skew and excess kurtosis, with mean = 0 and variance = 1. If only three parameters are supplied, they will be assumed to be variance, skew and excess kurtosis, with mean = 0. If less than two parameters or more than four parameters are supplied for any variable, an error will be raised. Variance must be positive, and excess kurtosis must be greater than or equal to skew^2-2. Length must be equal to no.nonn. Defaults to an empty list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After transformation and checking of parameters, a n by (no.pois+no.bin+no.ord+no.nonn) matrix of standard normal random data is generated, using cmat.star as the correlation matrix.
</p>
<p>Then for each variable, the appropriate transformation is applied to each column of the data generated.
</p>


<h3>Value</h3>

<p>A n by (no.pois+no.bin+no.ord+no.nonn) matrix. Each column corresponds to a variable, and each row is one random sample.
</p>


<h3>References</h3>

<p>Amatya, A. &amp; Demirtas, H. (2015) Simultaneous generation of multivariate mixed
data with Poisson and normal marginals. <em>Journal of Statistical Computation and Simulation</em> <b>85:15</b>, 3129&ndash;3139.
</p>
<p>Demirtas, H. (2014). Joint generation of binary and nonnormal continuous data.
<em>Journal of Biometrics and Biostatistics</em> <b>5:3:1000199</b>, 1&ndash;9.
</p>
<p>Demirtas, H. &amp; Hedeker, D. (2011) A practical way for computing approximate
lower and upper correlation bounds. <em>American Statistician</em> <b>65:2</b>, 104&ndash;109.
</p>
<p>Demirtas, H. &amp; Hedeker, D. (2016). Computing the point-biserial correlation under
any underlying continuous distribution. <em>Communications in Statistics &ndash;
Simulation and Computation</em>, <b>45:8</b>, 2744&ndash;2751. 
</p>
<p>Demirtas, H., Hedeker, D. &amp; Mermelstein, R. J. (2012) Simulation of massive public
health data by power polynomials. <em>Statistics in Medicine</em> <b>31:27</b>, 3337&ndash;3346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cmat.star &lt;- find.cor.mat.star(cor.mat = .8 * diag(8) + .2, no.pois = 2, no.ord = 4, 
    no.nonn = 2, pois.list = list(1, 2), ord.list = list(c(.2, .8), c(.5, .5),
    c(.1, .2, .3, .4), c(.8, 0, .1, .1)), nonn.list = list(c(-1, 1, 0, 1), c(0, 3, 0, 2)))
mydata &lt;- genPBONN(1000, no.pois = 2, no.ord = 4, no.nonn = 2, 
    cmat.star = cmat.star, pois.list = list(1, 2), 
    ord.list = list(c(.2, .8), c(.5, .5),c(.1, .2, .3, .4),
    c(.8, 0, .1, .1)), nonn.list = list(c(-1, 1, 0, 1), c(0, 3, 0, 2)))

apply(mydata, 2, mean)
apply(mydata, 2, var)
library(moments)
apply(mydata, 2, skewness)
apply(mydata, 2, kurtosis) - 3
lapply(apply(mydata[, 1:6], 2, table), prop.table)
cor(mydata)

## End(Not run)
</code></pre>

<hr>
<h2 id='lower.upper.cors'>
Computes lower and upper correlation bounds
</h2><span id='topic+lower.upper.cors'></span>

<h3>Description</h3>

<p>This function calculates the approximate upper and lower correlation bounds for all variable pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower.upper.cors(no.pois = 0, no.bin = 0, no.ord = 0, no.nonn = 0,
    pois.list = list(), bin.list = list(), ord.list = list(), 
    is.ord.list.cum=FALSE, nonn.list = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lower.upper.cors_+3A_no.pois">no.pois</code></td>
<td>

<p>The number of Poisson random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="lower.upper.cors_+3A_no.bin">no.bin</code></td>
<td>

<p>The number of binary random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="lower.upper.cors_+3A_no.ord">no.ord</code></td>
<td>

<p>The number of ordinal random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="lower.upper.cors_+3A_no.nonn">no.nonn</code></td>
<td>

<p>The number of continuous random variables desired, created using Fleishman polynomials. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="lower.upper.cors_+3A_pois.list">pois.list</code></td>
<td>

<p>A list of the lambda values, which must be greater than 0. Length will be equal to no.pois, or an error will be thrown. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="lower.upper.cors_+3A_bin.list">bin.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each variable. Each vector should have 2 entries between 0 and 1 inclusive, and sum to 1. Length must be equal to no.bin. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="lower.upper.cors_+3A_ord.list">ord.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each variable. If is.ord.list.cum is TRUE, each vector should have entries between 0 and 1, in increasing order. Otherwise, each vector should have entries between 0 and 1 inclusive that sum to 1. Length must be equal to no.ord. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="lower.upper.cors_+3A_is.ord.list.cum">is.ord.list.cum</code></td>
<td>

<p>Flag for whether the ordinal list supplied contains cumulative probabilities. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="lower.upper.cors_+3A_nonn.list">nonn.list</code></td>
<td>

<p>A list of vectors containing the first four moments of each variable, in order. If only two parameters are supplied, they will be assumed to be skew and excess kurtosis, with mean=0 and variance=1. If only three parameters are supplied, they will be assumed to be variance, skew and excess kurtosis, with mean=0. If less than two parameters or more than four parameters are supplied for any variable, an error will be raised. Variance must be positive, and excess kurtosis must be greater than or equal to skew^2-2. Length must be equal to no.nonn. Defaults to an empty list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the parameters are transformed as necessary and then checked for validity using <code><a href="#topic+check.params">check.params</a></code>. Then, for each pair of variables, we generate approximate upper and lower correlation bounds, using Demirtas and Hedeker's method, which involves generating a large sample of data and sorting it to find approximate bounds.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>min</code></td>
<td>

<p>A (no.pois+no.bin+no.ord+no.nonn) by (no.pois+no.bin+no.ord+no.nonn) square matrix showing the calculated  lower correlation bound for each pair of variables.
</p>
</td></tr>
<tr><td><code>max</code></td>
<td>

<p>A (no.pois+no.bin+no.ord+no.nonn) by (no.pois+no.bin+no.ord+no.nonn) square matrix showing the calculated upper correlation bound for each pair of variables.  
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If (no.pois+no.bin+no.ord+no.nonn) is equal to 1, 1 is returned. (If less than 1, an error is thrown at the beginning of the function.)
</p>
<p>The correlation matrix follows the order of Poisson, binary, ordinal, continuous.
</p>


<h3>References</h3>

<p>Demirtas, H. &amp; Hedeker, D. (2011) A practical way for computing approximate
lower and upper correlation bounds. <em>American Statistician</em> <b>65:2</b>, 104&ndash;109.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lower.upper.cors(no.nonn = 2, nonn.list = list(c(0, 1, 0, 1), c(0, 1, 0, 2)))
lower.upper.cors(no.pois = 2, pois.list = list(.5, 1))
lower.upper.cors(no.ord = 3,  ord.list = list(c(.2, .8), c(.1, .2, .3, .4), 
    c(.8, 0, .1, .1)))
lower.upper.cors(no.pois = 1, no.nonn = 1, no.ord = 1, pois.list = list(.5), 
    ord.list = list(c(.8, 0, .1, .1)), nonn.list = list(c(0, 1, 0, 1)))
</code></pre>

<hr>
<h2 id='validate.cor.mat'>
Validates the target correlation matrix
</h2><span id='topic+validate.cor.mat'></span>

<h3>Description</h3>

<p>This function validates the user-inputted target correlation matrix for the chosen number of Poisson,
binary, ordinal, and continuous (via Fleishman polynomials) random variables. The correlation matrix follows the order of Poisson, binary, ordinal, continuous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate.cor.mat(cor.mat, no.pois = 0, no.bin = 0, no.ord = 0, 
    no.nonn = 0, pois.list = list(), bin.list = list(), 
    ord.list = list(), is.ord.list.cum=FALSE, nonn.list = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate.cor.mat_+3A_cor.mat">cor.mat</code></td>
<td>

<p>The desired target correlation matrix.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_no.pois">no.pois</code></td>
<td>

<p>The number of Poisson random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_no.bin">no.bin</code></td>
<td>

<p>The number of binary random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_no.ord">no.ord</code></td>
<td>

<p>The number of ordinal random variables desired. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_no.nonn">no.nonn</code></td>
<td>

<p>The number of continuous random variables desired, created using Fleishman polynomials. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_pois.list">pois.list</code></td>
<td>

<p>A list of the lambda values, which must be greater than 0. 
Length will be equal to no.pois, or an error will be thrown. 
Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_bin.list">bin.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each 
variable. Each vector should have 2 entries between 0 and 1
inclusive, and sum to 1. Length must be equal to no.bin. 
Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_ord.list">ord.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each 
variable. If is.ord.list.cum is TRUE, each vector should have
entries between 0 and 1, in increasing order. Otherwise, each 
vector should have entries between 0 and 1 inclusive that sum 
to 1. Length must be equal to no.ord. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_is.ord.list.cum">is.ord.list.cum</code></td>
<td>

<p>Flag for whether the ordinal list supplied contains 
cumulative probabilities. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="validate.cor.mat_+3A_nonn.list">nonn.list</code></td>
<td>

<p>A list of vectors containing the first four moments of each 
variable, in order. If only two parameters are supplied, they 
will be assumed to be skew and excess kurtosis, with mean = 0
and variance = 1. If only three parameters are supplied, they
will be assumed to be variance, skew and excess kurtosis, with
mean = 0. If less than two parameters or more than four 
parameters are supplied for any variable, an error will be 
raised. Variance must be positive, and excess kurtosis must be
greater than or equal to skew^2-2. Length must be equal to 
no.nonn. Defaults to an empty list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the matrix is checked for the correct dimensions, then for symmetry, and then for being positive definite. Then each entry is checked to be in [-1, 1] and the diagonal entries must be 1. If not, an error is thrown.
</p>
<p>Second, the parameters are transformed and then checked for validity using <code><a href="#topic+check.params">check.params</a></code>.
</p>
<p>Third, the minimum and maximum correlation matrices are found using <code><a href="#topic+lower.upper.cors">lower.upper.cors</a></code>. If all entries are within the bounds, TRUE is returned. Otherwise, a list of which cells are invalid and their required bounds are printed, and FALSE is returned.
</p>


<h3>Value</h3>

<p>TRUE if the correlation matrix is valid, and FALSE if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validate.cor.mat(cor.mat = .2 * diag(3) + .8, no.pois = 3, 
    pois.list = list(.25, .5, 1))
validate.cor.mat(cor.mat = .7 * diag(3) + .3, no.ord = 3, 
    ord.list = list(c(.2, .8), c(.1, .2, .3, .4), c(.8, 0, .1, .1)))
validate.cor.mat(cor.mat = .25 * diag(3) + .75, no.pois = 1, 
    no.nonn = 1, no.ord = 1, pois.list = list(.5), 
    ord.list = list(c(.8, 0, .1, .1)), nonn.list=list(c(0, 1, 0, 1)))
validate.cor.mat(cor.mat = .35 * diag(3) + .65, no.pois = 1, 
    no.nonn = 1, no.ord = 1, pois.list = list(.5), 
    ord.list = list(c(.8, 0, .1, .1)), nonn.list=list(c(0, 1, 0, 1)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
