<!DOCTYPE html><html><head><title>Help for package netie</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netie}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#netie-package'>
<p>Antigen T Cell Interaction Estimation</p></a></li>
<li><a href='#input_data'>
<p>input_data</p></a></li>
<li><a href='#netie'>
<p>Neoantigen-T cell interaction estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Antigen T Cell Interaction Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-9-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Tianshi Lu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tianshi Lu &lt;tianshi.lu@utsouthwestern.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Bayesian hierarchical model named antigen-T cell interaction estimation is to estimate the history of the immune pressure on the evolution of the tumor clones.The model is based on the estimation result from Andrew Roth (2014) &lt;<a href="https://doi.org/10.1038%2Fnmeth.2883">doi:10.1038/nmeth.2883</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/LICENSE-1.1">Apache License version 1.1</a> | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License version 2.0</a> [expanded from: Apache License]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-28 14:47:19 UTC; s171162</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-29 08:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='netie-package'>
Antigen T Cell Interaction Estimation
</h2><span id='topic+netie-package'></span>

<h3>Description</h3>

<p>The Bayesian hierarchical model named antigen-T cell interaction estimation is to estimate the history of the immune pressure on the evolution of the tumor clones.The model is based on the estimation result from Andrew Roth (2014) &lt;doi:10.1038/nmeth.2883&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> netie</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Antigen T Cell Interaction Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-9-28</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Tianshi Lu</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Tianshi Lu &lt;tianshi.lu@utsouthwestern.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> The Bayesian hierarchical model named antigen-T cell interaction estimation is to estimate the history of the immune pressure on the evolution of the tumor clones.The model is based on the estimation result from Andrew Roth (2014) &lt;doi:10.1038/nmeth.2883&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.6.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> Apache License</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
input_data              input_data
netie                   Neoantigen-T cell interaction estimation
netie-package           Antigen T Cell Interaction Estimation
</pre>
<p>~~ An overview of how to use the package, including the most important functions ~~
netie(input_data,sigma_square = 100000,alpha = 10,beta = 2,sigma_p_sqr = 0.1,sigma_a_sqr = NULL,max_iter =1000,multi_sample = T) 
Please refer to https://github.com/tianshilu/Netie for more details.
</p>


<h3>Author(s)</h3>

<p>Tianshi Lu
</p>
<p>Maintainer: Tianshi Lu &lt;tianshi.lu@utsouthwestern.edu&gt;
</p>


<h3>References</h3>

<p>https://github.com/tianshilu/Netie
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(input_data)
netie(input_data,sigma_square=100000,alpha=10,beta=2,
sigma_p_sqr=0.1,max_iter=1000,multi_sample=TRUE)
</code></pre>

<hr>
<h2 id='input_data'>
input_data
</h2><span id='topic+input_data'></span>

<h3>Description</h3>

<p>one kidney cancer patient with 2 samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("input_data")</code></pre>


<h3>Format</h3>

<p>A data frame with 297 observations on the following 7 variables.
</p>

<dl>
<dt><code>mutation_id</code></dt><dd><p>a character vector </p>
</dd>
<dt><code>sample_id</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>cluster_id</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>cellular_prevalence</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>cellular_prevalence_std</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>variant_allele_frequency</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>neo_load</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(input_data)
## maybe str(input_data) ; plot(input_data) ...
</code></pre>

<hr>
<h2 id='netie'>
Neoantigen-T cell interaction estimation
</h2><span id='topic+netie'></span>

<h3>Description</h3>

<p>The Bayesian Hierarchical Model named Neoantigen-T cell interaction estimation (Netie) is to estimate the history of the immune pressure on the evolution of the tumor clones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netie(input_one_patient,sigma_square,alpha,beta,
sigma_p_sqr,sigma_a_sqr,max_iter,multi_sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netie_+3A_input_one_patient">input_one_patient</code></td>
<td>

<p>a list with each data frame as the data for each patient. Each data frame consists 7 columns and each row is for one mutation. Please refer to https://github.com/tianshilu/Netie for more details.
</p>
</td></tr>
<tr><td><code id="netie_+3A_sigma_square">sigma_square</code></td>
<td>

<p>hyperparameters for prior distributions. Please refer to https://github.com/tianshilu/Netie for more details.
</p>
</td></tr>
<tr><td><code id="netie_+3A_alpha">alpha</code></td>
<td>

<p>hyperparameters for prior distributions. Please refer to https://github.com/tianshilu/Netie for more details.
</p>
</td></tr>
<tr><td><code id="netie_+3A_beta">beta</code></td>
<td>

<p>hyperparameters for prior distributions. Please refer to https://github.com/tianshilu/Netie for more details.
</p>
</td></tr>
<tr><td><code id="netie_+3A_sigma_p_sqr">sigma_p_sqr</code></td>
<td>

<p>hyperparameters for prior distributions. Please refer to https://github.com/tianshilu/Netie for more details.
</p>
</td></tr>
<tr><td><code id="netie_+3A_sigma_a_sqr">sigma_a_sqr</code></td>
<td>

<p>hyperparameters for prior distributions. Please refer to https://github.com/tianshilu/Netie for more details.
</p>
</td></tr>
<tr><td><code id="netie_+3A_max_iter">max_iter</code></td>
<td>

<p>the iterations of Markov chain Monte Carlo.
</p>
</td></tr>
<tr><td><code id="netie_+3A_multi_sample">multi_sample</code></td>
<td>

<p>use True if one patient has more than one sample.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a list with the information of the anti-tumor selection pressure for each clone ac and for the whole tumor a.
</p>


<h3>Author(s)</h3>

<p>Tianshi Lu
</p>


<h3>References</h3>

<p>https://github.com/tianshilu/Netie
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
data(input_data)
netie(input_data,sigma_square=100000,alpha=10,beta=2,
sigma_p_sqr=0.1,max_iter=1000,multi_sample=TRUE)
## The function is currently defined as
function (input_one_patient, sigma_square, alpha, beta, sigma_p_sqr, 
    sigma_a_sqr, max_iter, multi_sample = FALSE) 
{
    if (all(input_one_patient$neo_load[!is.na(input_one_patient$cluster_id)] == 
        0)) {
        return(NA)
    }
    input_one_patient = input_one_patient[!is.na(input_one_patient$cluster_id), 
        ]
    if (multi_sample == T) {
        mutations = unlist(sapply(input_one_patient$mutation_id, 
            function(x) paste(strsplit(x, " ")[[1]][2], strsplit(x, 
                " ")[[1]][3])))
        input_one_patient$neo_load = unlist(sapply(mutations, 
            function(x) max(input_one_patient[mutations == x, 
                "neo_load"])))
        phi = "1"
        clones = list()
        clones[[id = "1"]] = mutations[paste(input_one_patient$sample_id, 
            input_one_patient$cluster_id) == paste(input_one_patient$sample_id, 
            input_one_patient$cluster_id)[1]]
        for (each_clone in unique(paste(input_one_patient$sample_id, 
            input_one_patient$cluster_id))[-1]) {
            mutations_one_clone = mutations[paste(input_one_patient$sample_id, 
                input_one_patient$cluster_id) == each_clone]
            phi_tmp = unlist(sapply(1:length(clones), function(x) {
                uniq_clone = clones[[x]]
                shared_mutations = intersect(uniq_clone, mutations_one_clone)
                if (length(shared_mutations)/length(uniq_clone) &gt; 
                  0.5 &amp; length(shared_mutations)/length(mutations_one_clone) &gt; 
                  0.5) {
                  return(names(clones)[x])
                }
            }), use.names = FALSE)
            if (!is.null(phi_tmp)) {
                phi = c(phi, phi_tmp)
            }
            else {
                phi_tmp = max(as.numeric(names(clones))) + 1
                phi = c(phi, phi_tmp)
                clones[[id = as.character(phi_tmp)]] = mutations_one_clone
            }
        }
        names(phi) = unique(paste(input_one_patient$sample_id, 
            input_one_patient$cluster_id))
    }
    if (length(unique(input_one_patient$cluster_id)) &gt; 1) {
        if (is.null(sigma_a_sqr)) {
            non_zero_neo_avg = sapply(unique(input_one_patient$cluster_id), 
                function(x) mean(input_one_patient[input_one_patient$cluster_id == 
                  x &amp; input_one_patient$neo_load != 0, "neo_load"]))
            non_zero_neo_avg[is.nan(non_zero_neo_avg)] = 0
            sigma_a_sqr = sd(log(non_zero_neo_avg + 1))^2 * 10
            if (sigma_a_sqr == 0) {
                sigma_a_sqr = 1
            }
        }
    }
    else {
        sigma_a_sqr = 1
    }
    if (sigma_square &lt; 100 * sigma_a_sqr) {
        print("sigma square should be much more larger than sigma a square!")
        stop()
    }
    if (alpha &lt;= beta) {
        print("alpha should be larger than beta!")
        stop()
    }
    if (multi_sample == T) {
        max_vaf = unlist(sapply(mutations, function(x) max(input_one_patient[mutations == 
            x, "variant_allele_frequency"])))
        input_one_patient = input_one_patient[max_vaf &gt; 0.05, 
            ]
    }
    else {
        input_one_patient = input_one_patient[input_one_patient$variant_allele_frequency &gt; 
            0.05, ]
    }
    tmp = table(input_one_patient$cluster_id[input_one_patient$neo_load &gt; 
        0])
    tmp = names(tmp[tmp &gt;= 1])
    input_one_patient = input_one_patient[input_one_patient$cluster_id %in% 
        tmp, ]
    tmp = table(input_one_patient$cluster_id)
    tmp = names(tmp[tmp &gt;= 2])
    input_one_patient = input_one_patient[input_one_patient$cluster_id %in% 
        tmp, ]
    if (dim(input_one_patient)[1] == 0) {
        return(NA)
    }
    if (multi_sample == T) {
        input_one_patient$phi = as.numeric(phi[paste(input_one_patient$sample_id, 
            input_one_patient$cluster_id)])
        input_one_patient$cluster_id = as.numeric(factor(paste(input_one_patient$sample_id, 
            input_one_patient$cluster_id)))
        phi_cluster = input_one_patient[, c("cluster_id", "phi")]
        phi_cluster = phi_cluster[!duplicated(phi_cluster$cluster_id), 
            ]
        rownames(phi_cluster) = as.character(phi_cluster$cluster_id)
        phi_cluster = phi_cluster[as.character(unique(input_one_patient$cluster_id)), 
            ]
    }
    else {
        input_one_patient$cluster_id = as.numeric(factor(input_one_patient$cluster_id))
    }
    input_one_patient[input_one_patient$neo_load &gt; 150, "neo_load"] = 150
    ac = bc = rep(0, length(unique(input_one_patient$cluster_id)))
    pi = 0.5
    a = 0
    zck_list = list()
    ac_list = list()
    bc_list = list()
    acp_rate_ac_list = list()
    acp_rate_bc_list = list()
    a_all = c()
    pi_all = c()
    for (iter in 1:max_iter) {
        if (iter/1000 == round(iter/1000)) {
            cat(paste("Iteration", iter, "\n"))
            print(ac)
            print(ac)
            print(bc)
            print(acp_rate_ac)
            print(acp_rate_bc)
        }
        acp_rate_ac = rep(FALSE, length(unique(input_one_patient$cluster_id)))
        acp_rate_bc = rep(FALSE, length(unique(input_one_patient$cluster_id)))
        zck_df = input_one_patient[, c("mutation_id", "cluster_id")]
        zck_df$zck = 1
        if (multi_sample == T) {
            for (p in 1:length(unique(input_one_patient$phi))) {
                input_each_phi = input_one_patient[input_one_patient$phi == 
                  unique(input_one_patient$phi)[p], ]
                for (c in unique(input_each_phi$cluster_id)) {
                  input_each_clone = input_each_phi[input_each_phi$cluster_id == 
                    c, ]
                  vck = input_each_clone$variant_allele_frequency
                  lambda = exp(ac[c] * vck + bc[c])
                  nck = input_each_clone$neo_load
                  r_tmp = pi * (nck == 0)/(pi * (nck == 0) + 
                    (1 - pi) * dpois(nck, lambda, log = F))
                  r_tmp_deno = pi * (nck == 0) + (1 - pi) * dpois(nck, 
                    lambda, log = F)
                  r_tmp[r_tmp_deno == 0] = 0
                  zck = 1 * (runif(length(nck), 0, 1) &gt; r_tmp)
                  names(zck) = input_each_clone$mutation_id
                  zck_df$zck[zck_df$mutation_id %in% names(zck)] = zck
                  bc_prim = rnorm(1, bc[c], sqrt(sigma_p_sqr))
                  lambda_prim_b = exp(ac[c] * vck + bc_prim)
                  lambda = exp(ac[c] * vck + bc[c])
                  tmp_prim = sum((zck == 1) * dpois(nck, lambda_prim_b, 
                    log = T))
                  tmp = sum((zck == 1) * dpois(nck, lambda, log = T))
                  llhr_b = exp(tmp_prim - bc_prim^2/(2 * sigma_square) - 
                    tmp + bc[c]^2/(2 * sigma_square))
                  acceptance_function_b = min(1, llhr_b)
                  u = runif(1, 0, 1)
                  if (u &lt;= acceptance_function_b) {
                    bc[c] = bc_prim
                    acp_rate_bc[c] = TRUE
                  }
                }
                input_each_phi$bc = bc[input_each_phi$cluster_id]
                input_each_phi$ac = ac[c]
                vck_phi = input_each_phi$variant_allele_frequency
                lambda_phi = exp(input_each_phi$ac * vck_phi + 
                  input_each_phi$bc)
                nck_phi = input_each_phi$neo_load
                zck_phi = zck_df[input_each_phi$mutation_id, 
                  "zck"]
                ac_prim = rnorm(1, ac[c], sqrt(sigma_p_sqr))
                lambda_prim_a = exp(ac_prim * vck_phi + input_each_phi$bc)
                tmp_prim = sum((zck_phi == 1) * dpois(nck_phi, 
                  lambda_prim_a, log = T))
                tmp = sum((zck_phi == 1) * dpois(nck_phi, lambda_phi, 
                  log = T))
                if (length(table(input_one_patient$cluster_id)) == 
                  1) {
                  llhr_a = exp(tmp_prim - ac_prim^2/(2 * sigma_square) - 
                    tmp + ac[c]^2/(2 * sigma_square))
                }
                else {
                  llhr_a = exp(tmp_prim - (ac_prim - a)^2/(2 * 
                    sigma_a_sqr) - tmp + (ac[c] - a)^2/(2 * sigma_a_sqr))
                }
                acceptance_function_a = min(1, llhr_a)
                u = runif(1, 0, 1)
                if (u &lt;= acceptance_function_a) {
                  ac[phi_cluster$phi == unique(input_each_clone$phi)] = ac_prim
                  acp_rate_ac[c] = TRUE
                }
            }
            pi = rbeta(1, alpha + sum((zck_df$zck == 0) * (input_one_patient$neo_load == 
                0)), beta + sum(zck_df$zck == 1))
            A = 1/sigma_square + length(unique(input_one_patient$phi))/sigma_a_sqr
            B = sum(ac[!duplicated(phi_cluster$phi)])/sigma_a_sqr
            a = rnorm(1, B/A, sqrt(1/A))
            ac_list[[iter]] = ac
            bc_list[[iter]] = bc
            zck_list[[iter]] = zck_df$zck
            acp_rate_ac_list[[iter]] = acp_rate_ac
            acp_rate_bc_list[[iter]] = acp_rate_bc
            a_all = c(a_all, a)
            pi_all = c(pi_all, pi)
        }
        else {
            for (c in 1:length(unique(input_one_patient$cluster_id))) {
                input_each_clone = input_one_patient[input_one_patient$cluster_id == 
                  unique(input_one_patient$cluster_id)[c], ]
                vck = input_each_clone$variant_allele_frequency
                lambda = exp(ac[c] * vck + bc[c])
                nck = input_each_clone$neo_load
                r_tmp = pi * (nck == 0)/(pi * (nck == 0) + (1 - 
                  pi) * dpois(nck, lambda, log = F))
                r_tmp_deno = pi * (nck == 0) + (1 - pi) * dpois(nck, 
                  lambda, log = F)
                r_tmp[r_tmp_deno == 0] = 0
                zck = 1 * (runif(length(nck), 0, 1) &gt; r_tmp)
                names(zck) = input_each_clone$mutation_id
                zck_df$zck[zck_df$mutation_id %in% names(zck)] = zck
                ac_prim = rnorm(1, ac[c], sqrt(sigma_p_sqr))
                lambda_prim_a = exp(ac_prim * vck + bc[c])
                tmp_prim = sum((zck == 1) * dpois(nck, lambda_prim_a, 
                  log = T))
                tmp = sum((zck == 1) * dpois(nck, lambda, log = T))
                if (length(table(input_one_patient$cluster_id)) == 
                  1) {
                  llhr_a = exp(tmp_prim - ac_prim^2/(2 * sigma_square) - 
                    tmp + ac[c]^2/(2 * sigma_square))
                }
                else {
                  llhr_a = exp(tmp_prim - (ac_prim - a)^2/(2 * 
                    sigma_a_sqr) - tmp + (ac[c] - a)^2/(2 * sigma_a_sqr))
                }
                acceptance_function_a = min(1, llhr_a)
                u = runif(1, 0, 1)
                if (u &lt;= acceptance_function_a) {
                  ac[c] = ac_prim
                  acp_rate_ac[c] = TRUE
                }
                bc_prim = rnorm(1, bc[c], sqrt(sigma_p_sqr))
                lambda_prim_b = exp(ac[c] * vck + bc_prim)
                lambda = exp(ac[c] * vck + bc[c])
                tmp_prim = sum((zck == 1) * dpois(nck, lambda_prim_b, 
                  log = T))
                tmp = sum((zck == 1) * dpois(nck, lambda, log = T))
                llhr_b = exp(tmp_prim - bc_prim^2/(2 * sigma_square) - 
                  tmp + bc[c]^2/(2 * sigma_square))
                acceptance_function_b = min(1, llhr_b)
                u = runif(1, 0, 1)
                if (u &lt;= acceptance_function_b) {
                  bc[c] = bc_prim
                  acp_rate_bc[c] = TRUE
                }
            }
            pi = rbeta(1, alpha + sum((zck_df$zck == 0) * (input_one_patient$neo_load == 
                0)), beta + sum(zck_df$zck == 1))
            A = 1/sigma_square + length(unique(input_one_patient$cluster_id))/sigma_a_sqr
            B = sum(ac)/sigma_a_sqr
            a = rnorm(1, B/A, sqrt(1/A))
            ac_list[[iter]] = ac
            bc_list[[iter]] = bc
            zck_list[[iter]] = zck_df$zck
            acp_rate_ac_list[[iter]] = acp_rate_ac
            acp_rate_bc_list[[iter]] = acp_rate_bc
            a_all = c(a_all, a)
            pi_all = c(pi_all, pi)
        }
    }
    keep = round(max_iter/2):max_iter
    ac_final = Reduce("+", ac_list[keep])/length(keep)
    bc_final = Reduce("+", bc_list[keep])/length(keep)
    zck_df_final = round(Reduce("+", zck_list[keep])/length(keep))
    names(zck_df_final) = zck_df$mutation_id
    ac_rate = Reduce("+", acp_rate_ac_list[keep])/length(keep)
    bc_rate = Reduce("+", acp_rate_bc_list[keep])/length(keep)
    a_final = mean(a_all[keep])
    pi_final = mean(pi_all[keep])
    if (multi_sample == TRUE) {
        final_parameters = list(zck = data.frame(zck_df_final), 
            ac = ac_final, bc = bc_final, acp_rate_ac = ac_rate, 
            a = a_final, acp_rate_bc = bc_rate, pi = pi_final, 
            phi_cluster = phi_cluster)
    }
    else {
        final_parameters = list(zck = data.frame(zck_df_final), 
            ac = ac_final, bc = bc_final, acp_rate_ac = ac_rate, 
            a = a_final, acp_rate_bc = bc_rate, pi = pi_final)
    }
    all_parameters = list(zck = zck_list, ac = ac_list, bc = bc_list, 
        a = a_all, pi = pi_all)
    result = list(all_parameters = all_parameters, final_parameters = final_parameters)
    return(result)
  }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
