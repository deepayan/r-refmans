<!DOCTYPE html><html lang="en-GB"><head><title>Help for package vistla</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vistla}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#branches'><p>Extract all branches of the Vistla tree</p></a></li>
<li><a href='#cchain'><p>Synthetic continuous data representing a simple mediator chain</p></a></li>
<li><a href='#chain'><p>Synthetic data representing a simple mediator chain</p></a></li>
<li><a href='#collapse'><p>Collapse the vistla tree into a pairwise graph</p></a></li>
<li><a href='#ensemble'><p>Construct the value for the ensemble argument</p></a></li>
<li><a href='#flow'><p>Construct the value for the flow argument</p></a></li>
<li><a href='#hierarchy'><p>Extract the vertex hierarchy from the vistla tree</p></a></li>
<li><a href='#junction'><p>Synthetic data representing a junction</p></a></li>
<li><a href='#mi_scores'><p>Extract mutual information score matrix</p></a></li>
<li><a href='#mle_coerce'><p>Basic discretisation of numerical features</p></a></li>
<li><a href='#path_to'><p>Extract a single path</p></a></li>
<li><a href='#paths'><p>List all paths</p></a></li>
<li><a href='#plot.vistla'><p>Overview plot of the vistla tree</p></a></li>
<li><a href='#print.vistla_hierarchy'><p>Print vistla objects</p></a></li>
<li><a href='#prune'><p>Prune the vistla tree</p></a></li>
<li><a href='#vistla'><p>Influence path identification with the Vistla algorithm</p></a></li>
<li><a href='#write.dot'><p>Export tree to a Graphviz DOT format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Detecting Influence Paths with Information Theory</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Traces information spread through interactions between features, utilising information theory measures and a higher-order generalisation of the concept of widest paths in graphs.
  In particular, 'vistla' can be used to better understand the results of high-throughput biomedical experiments, by organising the effects of the investigated intervention in a tree-like hierarchy from direct to indirect ones, following the plausible information relay circuits.
  Due to its higher-order nature, 'vistla' can handle multi-modality and assign multiple roles to a single feature.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/mbq/vistla/-/issues">https://gitlab.com/mbq/vistla/-/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/mbq/vistla">https://gitlab.com/mbq/vistla</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-19 14:32:42 UTC; mbq</td>
</tr>
<tr>
<td>Author:</td>
<td>Miron B. Kursa <a href="https://orcid.org/0000-0001-7672-648X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Miron B. Kursa &lt;m@mbq.me&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-19 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='branches'>Extract all branches of the Vistla tree</h2><span id='topic+branches'></span><span id='topic+as.data.frame.vistla'></span>

<h3>Description</h3>

<p>Gives access to a list of all branches in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branches(x, suboptimal = FALSE)

## S3 method for class 'vistla'
as.data.frame(x, row.names = NULL, optional = FALSE, suboptimal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="branches_+3A_x">x</code></td>
<td>
<p>vistla object.</p>
</td></tr>
<tr><td><code id="branches_+3A_suboptimal">suboptimal</code></td>
<td>
<p>if TRUE, sub-optimal branches are included.</p>
</td></tr>
<tr><td><code id="branches_+3A_row.names">row.names</code></td>
<td>
<p>passed to <code>as.data.frame</code>.</p>
</td></tr>
<tr><td><code id="branches_+3A_optional">optional</code></td>
<td>
<p>passed to <code>as.data.frame</code>.</p>
</td></tr>
<tr><td><code id="branches_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame collecting all branches traced by vistla.
Each row corresponds to a single branch, i.e., edge between feature pairs.
This way it is a triplet of original features, names of which are stored in <code>a</code>,
<code>b</code> and <code>c</code> columns.
For instance, path <code class="reqn">I \rightarrow J \rightarrow K \rightarrow L \rightarrow M</code> 
would be stored in three rows, for <code class="reqn">(a,b,c)</code>=<code class="reqn">(I,J,K)</code>, <code class="reqn">(J,K,L)</code>
and <code class="reqn">(K,L,M)</code>.
The width of a path (minimal <code class="reqn">\iota</code> value) between root and feature pair <code class="reqn">(b,c)</code> is
stored in the <code>score</code> column.
<code>depth</code> stores the path depth, starting from 1 for pairs directly connected to the root,
and increasing by one for each additional feature.
Final column, <code>leaf</code>, is a logical path indicating whether the edge is a final segment
of the widest path between root and <code class="reqn">c</code>.
</p>


<h3>Note</h3>

<p>Pruned trees (obtained with <code><a href="#topic+prune">prune</a></code> and using <code>targets</code> argument
in the <code><a href="#topic+vistla">vistla</a></code> call) have no suboptimal branches.
</p>

<hr>
<h2 id='cchain'>Synthetic continuous data representing a simple mediator chain</h2><span id='topic+cchain'></span>

<h3>Description</h3>

<p>Chain is generated from an uniform variable X by progressively adding gaussian noise, producing a mediator chain identical to this of the <code><a href="#topic+chain">chain</a></code> data, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">Y\rightarrow M_1 \rightarrow M_2  \rightarrow M_3  \rightarrow M_4  \rightarrow T</code>
</p>

<p>The set consists of 20 observations, and is tuned to be easily deciphered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cchain)
</code></pre>


<h3>Format</h3>

<p>A data set with six numerical columns.
</p>

<hr>
<h2 id='chain'>Synthetic data representing a simple mediator chain</h2><span id='topic+chain'></span>

<h3>Description</h3>

<p>Chain is generated from a simple Bayes network,
</p>
<p style="text-align: center;"><code class="reqn">Y\rightarrow M_1 \rightarrow M_2  \rightarrow M_3  \rightarrow M_4  \rightarrow T</code>
</p>

<p>where every variable is binary.
The set consists of 11 observations, and is tuned to be easily deciphered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chain)
</code></pre>


<h3>Format</h3>

<p>A data set with six binary factor columns.
</p>

<hr>
<h2 id='collapse'>Collapse the vistla tree into a pairwise graph</h2><span id='topic+collapse'></span>

<h3>Description</h3>

<p>Collapse the vistla tree into a pairwise graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(x, aggregate = c("max", "sum", "none"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_+3A_x">x</code></td>
<td>
<p>vistla object or a vistla_hierarchy object to collapse.</p>
</td></tr>
<tr><td><code id="collapse_+3A_aggregate">aggregate</code></td>
<td>
<p>score aggregation mode.
&quot;max&quot; is the maximal score for this edge over all paths in the tree.
For raw vistla scores it means the score of the widest path this edge was a part of;
for ensemble scores, it corresponds to the count of the most often appearing path with this edge.
&quot;sum&quot; is the sum of scores. Makes little sense for raw vistla scores; for ensemble scores it corresponds
to the total count of this edge over all paths in the ensemble.
&quot;none&quot; returns a vector of scores over all paths, which can be processed anyhow the user desires.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pairlist representation of the graph resulting from the tree collapse.
The result is a data frame with the following columns.
<code>A</code> &amp; <code>B</code> are the ends of the edge, in order where A is closer to root than B
(interpretation depends on the <code>flow</code> parameter used in <code><a href="#topic+vistla">vistla</a></code> invocation);
<code>score</code> is the score aggregated according to the <code>aggregate</code> argument;
finally <code>paths</code> is the count of paths which included this edge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(junction)
 v&lt;-vistla(Y~.,data=junction)
 collapse(v)

## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble'>Construct the value for the ensemble argument</h2><span id='topic+ensemble'></span><span id='topic+print.vistla_ensemble_control'></span>

<h3>Description</h3>

<p>Vistla can be run in the ensemble mode, in which tree is built multiple times, usually on a slightly modified input data.
This mode can be triggered by passing a value to the ensemble argument of the vistla method.
This function can be used to construct the proper value for this argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble(n = 30, resample = TRUE, prune = 0)

## S3 method for class 'vistla_ensemble_control'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble_+3A_n">n</code></td>
<td>
<p>number of replications.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_resample">resample</code></td>
<td>
<p>if <code>TRUE</code>, a modified bootstrap is used; that is, algorithm draws as many objects as are in the original data, but with replacement, hence only about 63.2
If this argument is given a number, it is interpreted to randomly sample exactly this fraction of objects, without replacement.
Fraction <code>f</code> of <code>n</code> objects is interpreted as <code>round(n*f)</code>, but not less than 3 and no more than <code>n-1</code>.
If <code>FALSE</code>, no resampling is done (vistla trees are just built using different random seeds.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_prune">prune</code></td>
<td>
<p>Minimal number of iterations in which certain branch must appear not be pruned during ensemble consolidation.
Zero (default) means no pruning.
Note that <code>iomin</code> and <code>targets</code> arguments of the base algorithm can also be used to control the size of the resulting consensus tree.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_x">x</code></td>
<td>
<p>ensemble control value to print.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vistla_ensemble_control</code> object which can be passed to the <code>vistla</code> function.
</p>

<hr>
<h2 id='flow'>Construct the value for the flow argument</h2><span id='topic+flow'></span><span id='topic+print.vistla_flow'></span>

<h3>Description</h3>

<p>Vistla builds the tree by optimising the influence score over path, which is given by the iota function.
The <code>flow</code> argument of the vistla function can be used to modify the default iota and some associated behaviours.
This function can be used to construct the proper value for this argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flow(code, ..., from = TRUE, into = FALSE, down, up, forcepath)

## S3 method for class 'vistla_flow'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flow_+3A_code">code</code></td>
<td>
<p>Character code of the flow parameter, like <code>"fromdown"</code>. 
If given, overrides other arguments.</p>
</td></tr>
<tr><td><code id="flow_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="flow_+3A_from">from</code></td>
<td>
<p>if <code>TRUE</code>, paths must satisfy data processing inequality as going from the root.</p>
</td></tr>
<tr><td><code id="flow_+3A_into">into</code></td>
<td>
<p>if <code>TRUE</code>, paths must satisfy data processing inequality as going into the root.</p>
</td></tr>
<tr><td><code id="flow_+3A_down">down</code></td>
<td>
<p>if <code>TRUE</code>, subsequent features on the path must have lower mutual information with the root; by default, true when <code>from</code> is true but if both <code>from</code> and <code>into</code> are true.
Can't be true together with <code>up</code>.</p>
</td></tr>
<tr><td><code id="flow_+3A_up">up</code></td>
<td>
<p>if <code>TRUE</code>, subsequent features on the path must have higher mutual information with the root; by default, true when <code>into</code> is true but if both <code>from</code> and <code>into</code> are true.
Can't be true together with <code>down</code>.</p>
</td></tr>
<tr><td><code id="flow_+3A_forcepath">forcepath</code></td>
<td>
<p>when neither <code>up</code> or <code>down</code> is true, vistla may output walks rather than paths, i.e., sequences of features which are not unique.
Yet, when this argument is set to <code>TRUE</code>, additional condition is checked to forbid such self-intersections.
One should note that this check is computationally expensive, though.
By default true when both <code>up</code> and <code>down</code> are false.</p>
</td></tr>
<tr><td><code id="flow_+3A_x">x</code></td>
<td>
<p>flow value to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vistla_flow</code> object which can be passed to the <code>vistla</code> function; 
in practice, a single integer value.
</p>

<hr>
<h2 id='hierarchy'>Extract the vertex hierarchy from the vistla tree</h2><span id='topic+hierarchy'></span>

<h3>Description</h3>

<p>Traverses the vistla tree in a depth-first order and 
lists the visited vertices as a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchy(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierarchy_+3A_x">x</code></td>
<td>
<p>vistla object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of a class <code>vistla_hierarchy</code>.
</p>


<h3>Note</h3>

<p>This function effectively prunes the tree off suboptimal paths.
</p>

<hr>
<h2 id='junction'>Synthetic data representing a junction</h2><span id='topic+junction'></span>

<h3>Description</h3>

<p>Junction is a model of a multimodal agent, a variable that is an element of multiple separate paths.
Here, these paths are 
<code class="reqn">Y\rightarrow A_1\rightarrow A_2\rightarrow J \rightarrow A_3</code>
and 
<code class="reqn">Y\rightarrow B_1\rightarrow B_2\rightarrow J \rightarrow B_3,</code>
while <code class="reqn">J</code> is the junction.
The set consists of 50 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(junction)
</code></pre>


<h3>Format</h3>

<p>A data set with eight factor columns.
</p>

<hr>
<h2 id='mi_scores'>Extract mutual information score matrix</h2><span id='topic+mi_scores'></span>

<h3>Description</h3>

<p>Produces a matrix <code class="reqn">S</code> where <code class="reqn">S_{ij}</code> is a 
value of <code class="reqn">I(X_i;X_j)</code>.
This matrix is always calculated as an initial step of the
vistla algorithm and stored in the vistla object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi_scores(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mi_scores_+3A_x">x</code></td>
<td>
<p>vistla object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric square matrix with mutual information scores between features and root.
</p>

<hr>
<h2 id='mle_coerce'>Basic discretisation of numerical features</h2><span id='topic+mle_coerce'></span>

<h3>Description</h3>

<p>One can use this function for a quick, ad hoc discretisation of numerical features in a data frame, so that it could be passed to <code><a href="#topic+vistla">vistla</a></code> using the maximal likelihood estimation (mle, the default).
This can be used to simulate legacy behaviour of vistla, which was to automatically perform such conversion with 10 equal-width bins.
The non-numeric columns are left as they were, hence this function is idempotent and does nothing when given fully discrete data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle_coerce(x, bins = 3, equal = c("size", "width"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle_coerce_+3A_x">x</code></td>
<td>
<p>Data frame to be converted.</p>
</td></tr>
<tr><td><code id="mle_coerce_+3A_bins">bins</code></td>
<td>
<p>Number of bins to cut each numerical column into.</p>
</td></tr>
<tr><td><code id="mle_coerce_+3A_equal">equal</code></td>
<td>
<p>If given <code>"width"</code>, function performs cuts into bins of an equal width, which may thus contain substantially different number of objects.
One the other hand, when given <code>"size"</code> (default), cuts are done according to quantiles, hence provide bins with approximately the same number of objects, yet with different widths.
Both options are asymptotically equivalent when the distribution of a given column is uniform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code>, in which numerical columns have been discretised.
</p>


<h3>Note</h3>

<p>While convenient, this function does not necessary provide optimal quantisation of the data (in terms of future vistla performance); especially the bins parameter should be adjusted to the input data, either via optimisation or based on the known properties of the input or mechanisms behind it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cchain)
vistla(Y~.,data=mle_coerce(cchain,3,"size")) 

## End(Not run)
</code></pre>

<hr>
<h2 id='path_to'>Extract a single path</h2><span id='topic+path_to'></span>

<h3>Description</h3>

<p>Gives access to a vector of feature names over a path to a certain target feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_to(x, target, detailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path_to_+3A_x">x</code></td>
<td>
<p>vistla or vistla_hierarchy object.</p>
</td></tr>
<tr><td><code id="path_to_+3A_target">target</code></td>
<td>
<p>target feature name.</p>
</td></tr>
<tr><td><code id="path_to_+3A_detailed">detailed</code></td>
<td>
<p>if <code>TRUE</code>, suppresses default output and presents the same paths as a data frame featuring score.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a character vector with names of features along the path from <code>target</code> into root.
When <code>detailed</code> is set to <code>TRUE</code> and input is a vistla object, a <code>data.frame</code> in a format identical
to this produced by <code><a href="#topic+branches">branches</a></code>, yet without the <code>leaf</code> column.
</p>

<hr>
<h2 id='paths'>List all paths</h2><span id='topic+paths'></span>

<h3>Description</h3>

<p>Executes <code><a href="#topic+path_to">path_to</a></code> for all path possible targets and returns
a list with the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths(x, targets_only = !is.null(x$targets), detailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paths_+3A_x">x</code></td>
<td>
<p>vistla or vistla_hierarchy object.</p>
</td></tr>
<tr><td><code id="paths_+3A_targets_only">targets_only</code></td>
<td>
<p>if <code>TRUE</code>, only paths to targets are extracted. 
By default, turned on when <code>x</code> has targets, and off otherwise.
Ignored when <code>x</code> is a vistla_hierarchy.</p>
</td></tr>
<tr><td><code id="paths_+3A_detailed">detailed</code></td>
<td>
<p>passed to <code><a href="#topic+path_to">path_to</a></code>. If <code>TRUE</code>,
suppresses default output and presents the same paths in a form of
data frames featuring score.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with one element per leaf or target, containing
the path between this feature and root, in a format identical
to this used by the <code><a href="#topic+path_to">path_to</a></code> function.
</p>

<hr>
<h2 id='plot.vistla'>Overview plot of the vistla tree</h2><span id='topic+plot.vistla'></span><span id='topic+plot.vistla_plot'></span><span id='topic+print.vistla_plot'></span>

<h3>Description</h3>

<p>Plots a vistla tree, using layout derived by a Buchheim et al. extension of the standard Reingold-Tilford method.
The tree root is placed on the left, while the paths extend to the right, with all branches of the same depth at the same horizontal coordinate.
The path are sorted vertically, from strongest on top to weakest on the bottom.
Link weight indicates, by default, the link's score.
A feature name in parentheses indicates that is is only a way-point in a path to some other feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vistla'
plot(
  x,
  ...,
  slant,
  circular,
  asp1 = FALSE,
  pmar = c(0.05, 0.05, 0.05, 0.05),
  edge_col = 1,
  edge_lwd = "scale",
  edge_lty = 1,
  label_text = function(x) x$name,
  label_border_col = 1,
  label_border_lty = function(x) ifelse(x$leaf, 1, 2),
  label_fill = "white"
)

## S3 method for class 'vistla_plot'
plot(x, ...)

## S3 method for class 'vistla_plot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.vistla_+3A_x">x</code></td>
<td>
<p>vistla, vistla hierarchy or vistla plot object.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_slant">slant</code></td>
<td>
<p>arrange vertices in a slanted way. 
Can be given as a number, possibly negative, indicating the amount of slant, or as <code>TRUE</code>, for an auto value.
No slant is applied when set to 0 or omitted.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_circular">circular</code></td>
<td>
<p>if given <code>TRUE</code>, switches to circular layout; alternatively, can be given two numbers, then the first one will be interpreted as an angle to fit the whole graph in (<code>2*pi</code> when using <code>TRUE</code>), and the second one as an initial angle offset (0 when using <code>TRUE</code>), which can be used to rotate the whole graph around the root.
Both angles are expected to be in radians.
It is recommended to add <code>asp=TRUE</code> parameter to make this layout truly circular, otherwise lines of equal depth are going to be elliptical.
When <code>FALSE</code>, linear layout is enforced.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_asp1">asp1</code></td>
<td>
<p>if <code>TRUE</code>, scales on both axes are the same, like with <code>asp=1</code> in base graphics.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_pmar">pmar</code></td>
<td>
<p>Specifies margins as a fraction of graph size; expects a 4-element vector, in standard R bottom-left-top-right order.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_edge_col">edge_col</code></td>
<td>
<p>edge colour; can be given as vector, then mapping order adheres to the one in hierarchy object; please note that the edge towards first feature, the root, is not drawn, so the first element is effectively ignored.
If given as a function, it is called on the internally generated extended hierarchy object, and the result is used as an aesthetic.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_edge_lwd">edge_lwd</code></td>
<td>
<p>edge width; behaves similarly to <code>edge_col</code>, yet also accepts special value <code>'scale'</code>, which triggers default scaling of edge width to be proportional to score.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_edge_lty">edge_lty</code></td>
<td>
<p>edge line-type; behaves similarly to <code>edge_col</code>.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_label_text">label_text</code></td>
<td>
<p>vertex label text, feature name by default.
Behaves similarly to <code>edge_col</code>.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_label_border_col">label_border_col</code></td>
<td>
<p>vertex label border colour; behaves similarly to <code>edge_col</code>, can be set to 0 for no border.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_label_border_lty">label_border_lty</code></td>
<td>
<p>vertex label border line-type; behaves similarly to <code>edge_col</code>, can be set to 0 for no border.</p>
</td></tr>
<tr><td><code id="plot.vistla_+3A_label_fill">label_fill</code></td>
<td>
<p>vertex label fill colour; behaves similarly to <code>edge_col</code>, can be set to 0 for no fill.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Grid object with the graph.
</p>


<h3>Note</h3>

<p>The graph is rendered using the grid graphics system, in a manner similar to <code>ggplot2</code>; the output of the <code>plot.vistla</code> function is only a grid graphical object, while the actual plotting is done when this object is printed or plotted.
Yet, said object can be used with other functions in the grid ecosystem for rendering into files, being edited, combined with other plots, etc.
</p>


<h3>References</h3>

<p>&quot;Drawing rooted trees in linear time&quot; C. Buchheim, M. Jünger, S. Leipert. Software: Practice and Experience 36(6):651-665 (2006).
</p>

<hr>
<h2 id='print.vistla_hierarchy'>Print vistla objects</h2><span id='topic+print.vistla_hierarchy'></span><span id='topic+print.vistla'></span>

<h3>Description</h3>

<p>Utility functions to print vistla objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vistla_hierarchy'
print(x, ...)

## S3 method for class 'vistla'
print(x, n = 7L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.vistla_hierarchy_+3A_x">x</code></td>
<td>
<p>vistla object.</p>
</td></tr>
<tr><td><code id="print.vistla_hierarchy_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="print.vistla_hierarchy_+3A_n">n</code></td>
<td>
<p>maximal number of paths to preview.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible copy of <code>x</code>.
</p>

<hr>
<h2 id='prune'>Prune the vistla tree</h2><span id='topic+prune'></span>

<h3>Description</h3>

<p>This function allows to filter out suboptimal branches, as well as weak ones or these not in particular paths of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune(x, targets, iomin, score)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prune_+3A_x">x</code></td>
<td>
<p>vistla object or a vistla_hierarchy object.</p>
</td></tr>
<tr><td><code id="prune_+3A_targets">targets</code></td>
<td>
<p>a character vector of features.
When not missing, all branches not on lying paths to these targets are pruned.
Unreachable targets are ignored, while names not present in the analysed set cause an error.</p>
</td></tr>
<tr><td><code id="prune_+3A_iomin">iomin</code></td>
<td>
<p>a legacy name for score, valid only for vistla objects; passing a value to either of them works the same, but giving some values for both is an error.</p>
</td></tr>
<tr><td><code id="prune_+3A_score">score</code></td>
<td>
<p>a score threshold below which branches should be removed.
When given, it effectively overrides the value of <code>iomin</code> or <code>ensemble(prune,...)</code> given to the <code>vistla</code> invocation; to this end, it can only be higher then the original value, since prune only modifies the output and cannot re-run the pathfinding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pruned <code>x</code>; if both arguments are missing, this function still removes suboptimal branches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(chain)
 v&lt;-vistla(Y~.,data=chain)
 print(v)
 print(prune(v,targets="M3"))
 print(prune(v,score=0.3))

## End(Not run)
</code></pre>

<hr>
<h2 id='vistla'>Influence path identification with the Vistla algorithm</h2><span id='topic+vistla'></span><span id='topic+vistla.formula'></span><span id='topic+vistla.data.frame'></span><span id='topic+vistla.default'></span>

<h3>Description</h3>

<p>Detects influence paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vistla(x, ...)

## S3 method for class 'formula'
vistla(formula, data, ..., yn)

## S3 method for class 'data.frame'
vistla(
  x,
  y,
  ...,
  flow,
  iomin,
  targets,
  estimator = c("mle", "kt"),
  verbose = FALSE,
  yn = "Y",
  ensemble,
  threads
)

## Default S3 method:
vistla(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vistla_+3A_x">x</code></td>
<td>
<p>data frame of predictors.</p>
</td></tr>
<tr><td><code id="vistla_+3A_...">...</code></td>
<td>
<p>pass-through arguments, ignored.</p>
</td></tr>
<tr><td><code id="vistla_+3A_formula">formula</code></td>
<td>
<p>alternatively, formula describing the task, in a form <code>root~predictors</code>, which adheres to standard R behaviours.
Accepts <code>+</code> to add a predictor, <code>-</code> to omit one, and <code>.</code> to import whole <code>data</code>.
Use <code><a href="base.html#topic+I">I</a></code> to calculate new predictors.
When present in <code>data</code>, response is getting omitted from predictors.</p>
</td></tr>
<tr><td><code id="vistla_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> in context of which the formula will be executed; can be omitted when not using <code>.</code>.</p>
</td></tr>
<tr><td><code id="vistla_+3A_yn">yn</code></td>
<td>
<p>name of the root (<code>Y</code> value), used in result pretty-printing and plots. 
Must be a single-element character vector.</p>
</td></tr>
<tr><td><code id="vistla_+3A_y">y</code></td>
<td>
<p>vistla tree root, a feature from which influence paths will be traced.</p>
</td></tr>
<tr><td><code id="vistla_+3A_flow">flow</code></td>
<td>
<p>algorithm mode, specifying the iota function which gives local score to an edge of an edge graph. 
If in doubt, use the default, <code>"fromdown"</code>.
Consult the documentation of the <code><a href="#topic+flow">flow</a></code> function for more information.</p>
</td></tr>
<tr><td><code id="vistla_+3A_iomin">iomin</code></td>
<td>
<p>score threshold below which path is not considered further. 
The higher value the less paths are generated, which also lowers the time taken by the function.
The default value of 0 turns of this filtering.
The same effect can be later achieved with the <code><a href="#topic+prune">prune</a></code> function.</p>
</td></tr>
<tr><td><code id="vistla_+3A_targets">targets</code></td>
<td>
<p>a vector of target feature names.
If given, the algorithm will stop just after reaching the last feature from this list, rather than after tracing paths to all targets.
The same effect can be later achieved with the <code><a href="#topic+prune">prune</a></code> function, but restricting targets here saves computational time.</p>
</td></tr>
<tr><td><code id="vistla_+3A_estimator">estimator</code></td>
<td>
<p>mutual information estimator to use.
<code>"mle"</code> &mdash; maximal likelihood, requires all features to be discrete (factors or booleans).
<code>"kt"</code> &mdash; Kendall transformation, requires all features to be either ordinal (numeric, integer or ordered factor) or bi-valued (two-level factors or booleans).</p>
</td></tr>
<tr><td><code id="vistla_+3A_verbose">verbose</code></td>
<td>
<p>when set to <code>TRUE</code>, turns on reporting of the algorithm progress.</p>
</td></tr>
<tr><td><code id="vistla_+3A_ensemble">ensemble</code></td>
<td>
<p>used to switch vistla to the ensemble mode, in which a number of vistla models are built over permuted realisations of the input, and merged into a single consensus tree.
Should be given an output of the <code><a href="#topic+ensemble">ensemble</a></code> function; as a short-cut, one can pass a single number, which will be interpreted as the number of replications with other ensemble parameter default.
That is, <code>ensemble=30</code> is equivalent to <code>ensemble=ensemble(n=30)</code>.
Permutations are applied before estimators.</p>
</td></tr>
<tr><td><code id="vistla_+3A_threads">threads</code></td>
<td>
<p>number of threads to use. 
When missing or set to 0, vistla uses all available cores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normally, the tracing results represented as an object of a class <code>vistla</code>.
Use <code><a href="#topic+paths">paths</a></code> and <code><a href="#topic+path_to">path_to</a></code> functions to extract individual paths,
<code><a href="#topic+branches">branches</a></code> to get the whole tree and <code><a href="#topic+mi_scores">mi_scores</a></code> to get the basic score matrix.
</p>
<p>When <code>ensemble</code> argument is given, a hierarchy object with the scored being counts of times certain path was present among the replicated ensemble, possibly pruned.
</p>


<h3>Note</h3>

<p>The ensemble mode is both faster and makes better use of multithreading than replicating vistla manually.
</p>


<h3>References</h3>

<p>&quot;Vistla: identifying influence paths with information theory&quot; M.B. Kursa. Bioinformatics btaf036 (2025).
</p>
<p>&quot;Kendall transformation brings a robust categorical representation of ordinal data&quot; M.B. Kursa. SciRep 12, 8341 (2022).
</p>

<hr>
<h2 id='write.dot'>Export tree to a Graphviz DOT format</h2><span id='topic+write.dot'></span>

<h3>Description</h3>

<p>Exports the vistla tree in a DOT format, which can be later layouted and rendered by Graphviz programs like dot or neato.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.dot(
  x,
  con,
  vstyle = list(shape = function(x) ifelse(x$depth &lt; 0, "egg", ifelse(x$leaf, "box",
    "ellipse")), label = function(x) sprintf("\"%s\"", x$name)),
  estyle = list(penwidth = function(x) sprintf("%0.3f", 0.5 + x$score/max(x$score) *
    2.5)),
  gstyle = list(overlap = "\"prism\"", splines = "true"),
  direction = c("none", "fromY", "intoY")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.dot_+3A_x">x</code></td>
<td>
<p>vistla object.</p>
</td></tr>
<tr><td><code id="write.dot_+3A_con">con</code></td>
<td>
<p>connection; passed to <code>writeLines</code>.
If missing, the DOT code is returned as a character vector.</p>
</td></tr>
<tr><td><code id="write.dot_+3A_vstyle">vstyle</code></td>
<td>
<p>vertex attribute list &mdash; should be a named list of Graphviz attributes like <code>shape</code> or <code>penwidth</code>. 
For elements which are strings or numbers, the value is copied as is as an attribute value.
For elements which functions, though, the function is called on a <code>vistla_tree</code> object and should return a vector of values.</p>
</td></tr>
<tr><td><code id="write.dot_+3A_estyle">estyle</code></td>
<td>
<p>edge attribute list, behaves exactly like <code>vstyle</code>. 
When functions are called, the Y-vertex is not present.</p>
</td></tr>
<tr><td><code id="write.dot_+3A_gstyle">gstyle</code></td>
<td>
<p>graph attribute list. Functions are not supported here.</p>
</td></tr>
<tr><td><code id="write.dot_+3A_direction">direction</code></td>
<td>
<p>when set to <code>"none"</code>, graph is undirected, otherwise directed, for <code>"fromY"</code>, root is a source, while for <code>"intoY"</code>, a sink.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a missing <code>con</code> argument, a character vector with the graph in the DOT format, invisible <code>NULL</code> otherwise.
</p>


<h3>Note</h3>

<p>Graphviz attribute values can be either strings, like <code>"some vertex"</code> in <code>label</code>, or atoms, like <code>box</code> for <code>shape</code>.
When returning a string value, you must supply quotes, otherwise it will be included as an atom.
</p>
<p>The default value of <code>gstyle</code> may invoke long layout calculations in Graphviz.
Change to <code>list()</code> for a fast but less aesthetic layout.
</p>
<p>The function does no validation whether provided attributes or values are correct.
</p>


<h3>References</h3>

<p>&quot;An open graph visualization system and its applications to software engineering&quot; E.R. Gansner, S.C. North. Software: Practice and Experience 30:1203-1233 (2000).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
