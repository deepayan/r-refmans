<!DOCTYPE html><html><head><title>Help for package rbbnp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rbbnp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biasBound_condExpectation'><p>Bias bound approach for conditional expectation estimation</p></a></li>
<li><a href='#biasBound_density'><p>Bias bound approach for density estimation</p></a></li>
<li><a href='#DATA_PATH'><p>The Path to the Data Folder</p></a></li>
<li><a href='#epanechnikov_kernel'><p>Epanechnikov Kernel</p></a></li>
<li><a href='#epanechnikov_kernel_ft'><p>Fourier Transform Epanechnikov Kernel</p></a></li>
<li><a href='#EXT_DATA_PATH'><p>The Path to the External Data Folder for Non-R Data Files</p></a></li>
<li><a href='#fun_approx'><p>Approximation Function for Intensive Calculations</p></a></li>
<li><a href='#gen_sample_data'><p>Generate Sample Data</p></a></li>
<li><a href='#get_avg_f1x'><p>Kernel point estimation</p></a></li>
<li><a href='#get_avg_fyx'><p>Kernel point estimation</p></a></li>
<li><a href='#get_avg_phi'><p>Compute Sample Average of Fourier Transform Magnitude</p></a></li>
<li><a href='#get_avg_phi_log'><p>Compute log sample average of fourier transform and get mod</p></a></li>
<li><a href='#get_conditional_var'><p>get the conditional variance of Y on X for given x</p></a></li>
<li><a href='#get_est_Ar'><p>get the estimation of A and r</p></a></li>
<li><a href='#get_est_B'><p>get the estimation of B</p></a></li>
<li><a href='#get_est_b1x'><p>Estimation of bias b1x</p></a></li>
<li><a href='#get_est_byx'><p>Estimation of bias byx</p></a></li>
<li><a href='#get_est_vy'><p>get the estimation of Vy</p></a></li>
<li><a href='#get_sigma'><p>Estimation of sigma</p></a></li>
<li><a href='#get_sigma_yx'><p>Estimation of sigma_yx</p></a></li>
<li><a href='#get_xi_interval'><p>get xi interval</p></a></li>
<li><a href='#kernel_reg'><p>Kernel Regression function</p></a></li>
<li><a href='#normal_kernel'><p>Normal Kernel Function</p></a></li>
<li><a href='#normal_kernel_ft'><p>Fourier Transform of Normal Kernel</p></a></li>
<li><a href='#plot_ft'><p>Plot the Fourier Transform</p></a></li>
<li><a href='#rpoly01'><p>Generate n samples from the distribution</p></a></li>
<li><a href='#sample_data'><p>Sample Data</p></a></li>
<li><a href='#sinc'><p>Infinite Kernel Function</p></a></li>
<li><a href='#sinc_ft'><p>Define the closed form FT of the infinite order kernel sin(x)/(pi*x)</p></a></li>
<li><a href='#true_density_2fold'><p>True density of 2-fold uniform distribution</p></a></li>
<li><a href='#W_kernel'><p>Define the inverse Fourier transform function of W</p></a></li>
<li><a href='#W_kernel_ft'><p>Define the Fourier transform of a infinite kernel proposed in Schennach 2004</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Bias Bound Approach to Non-Parametric Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xinyu DAI &lt;xinyu_dai@brown.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A novel bias-bound approach for non-parametric inference is introduced, 
    focusing on both density and conditional expectation estimation. 
    It constructs valid confidence intervals that account for the presence of 
    a non-negligible bias and thus make it possible to perform inference with 
    optimal mean squared error minimizing bandwidths. 
    This package is based on Schennach (2020) &lt;<a href="https://doi.org/10.1093%2Frestud%2Frdz065">doi:10.1093/restud/rdz065</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.1093/restud/rdz065">https://doi.org/10.1093/restud/rdz065</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr, pracma, tidyr, dplyr, ggplot2, gridExtra</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 00:58:07 UTC; 53500</td>
</tr>
<tr>
<td>Author:</td>
<td>Xinyu DAI [aut, cre],
  Susanne M Schennach [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-01 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='biasBound_condExpectation'>Bias bound approach for conditional expectation estimation</h2><span id='topic+biasBound_condExpectation'></span>

<h3>Description</h3>

<p>Estimates the density at a given point or across a range, and provides visualization options for density,
bias, and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biasBound_condExpectation(
  Y,
  X,
  x = NULL,
  h = 0.09,
  alpha = 0.05,
  est_Ar = NULL,
  resol = 100,
  xi_lb = NULL,
  xi_ub = NULL,
  methods_get_xi = "Schennach",
  if_plot_ft = FALSE,
  ora_Ar = NULL,
  if_plot_conditional_mean = TRUE,
  kernel.fun = "Schennach2004",
  if_approx_kernel = TRUE,
  kernel.resol = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biasBound_condExpectation_+3A_y">Y</code></td>
<td>
<p>A numerical vector of sample data.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_x">X</code></td>
<td>
<p>A numerical vector of sample data.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_x">x</code></td>
<td>
<p>Optional. A scalar or range of points where the density is estimated. If NULL, a range is automatically generated.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_h">h</code></td>
<td>
<p>A scalar bandwidth parameter.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_alpha">alpha</code></td>
<td>
<p>Confidence level for intervals. Default is 0.05.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_est_ar">est_Ar</code></td>
<td>
<p>Optional list of estimates for A and r. If NULL, they are computed using <code>get_est_Ar()</code>.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_resol">resol</code></td>
<td>
<p>Resolution for the estimation range. Default is 100.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_xi_lb">xi_lb</code></td>
<td>
<p>Optional. Lower bound for the interval of Fourier Transform frequency xi. Used for determining the range over which A and r is estimated. If NULL, it is automatically determined based on the methods_get_xi.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_xi_ub">xi_ub</code></td>
<td>
<p>Optional. Upper bound for the interval of Fourier Transform frequency xi. Similar to xi_lb, it defines the upper range for A and r estimation. If NULL, the upper bound is determined based on the methods_get_xi.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_methods_get_xi">methods_get_xi</code></td>
<td>
<p>A string specifying the method to automatically determine the xi interval if xi_lb and xi_ub are NULL. Options are &quot;Schennach&quot; and &quot;Schennach_loose&quot;. If &quot;Schennach&quot; the range is selected based on the Theorem 2 in Schennach2020, if &quot;Schennach_loose&quot;, it is defined by the initial interval given in Theorem 2 without selecting the xi_n.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_if_plot_ft">if_plot_ft</code></td>
<td>
<p>Logical. If TRUE, plots the Fourier transform.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_ora_ar">ora_Ar</code></td>
<td>
<p>Optional list of oracle values for A and r.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_if_plot_conditional_mean">if_plot_conditional_mean</code></td>
<td>
<p>Logical. If TRUE, plots the conditional mean estimation.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_kernel.fun">kernel.fun</code></td>
<td>
<p>A string specifying the kernel function to be used. Options are &quot;Schennach2004&quot;, &quot;sinc&quot;, &quot;normal&quot;, &quot;epanechnikov&quot;.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_if_approx_kernel">if_approx_kernel</code></td>
<td>
<p>Logical. If TRUE, uses approximations for the kernel function.</p>
</td></tr>
<tr><td><code id="biasBound_condExpectation_+3A_kernel.resol">kernel.resol</code></td>
<td>
<p>The resolution for kernel function approximation. See <code><a href="#topic+fun_approx">fun_approx</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing various outputs including estimated values, plots, and intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: point estimation of conditional expectation of Y on X
biasBound_condExpectation(
 Y = sample_data$Y,
 X = sample_data$X,
 x = 1,
 h = 0.09,
 kernel.fun = "Schennach2004"
)

# Example 2: conditional expectation of Y on X with manually selected range of xi
# biasBound_condExpectation(
# Y = sample_data$Y,
#  X = sample_data$X,
#  h = 0.09,
#  xi_lb = 1,
#  xi_ub = 12,
#  kernel.fun = "Schennach2004"
# )

</code></pre>

<hr>
<h2 id='biasBound_density'>Bias bound approach for density estimation</h2><span id='topic+biasBound_density'></span>

<h3>Description</h3>

<p>Estimates the density at a given point or across a range, and provides visualization options for density,
bias, and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biasBound_density(
  X,
  x = NULL,
  h = 0.09,
  alpha = 0.05,
  resol = 100,
  xi_lb = NULL,
  xi_ub = NULL,
  methods_get_xi = "Schennach",
  if_plot_density = TRUE,
  if_plot_ft = FALSE,
  ora_Ar = NULL,
  kernel.fun = "Schennach2004",
  if_approx_kernel = TRUE,
  kernel.resol = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biasBound_density_+3A_x">X</code></td>
<td>
<p>A numerical vector of sample data.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_x">x</code></td>
<td>
<p>Optional. A scalar or range of points where the density is estimated. If NULL, a range is automatically generated.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_h">h</code></td>
<td>
<p>A scalar bandwidth parameter.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_alpha">alpha</code></td>
<td>
<p>Confidence level for intervals. Default is 0.05.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_resol">resol</code></td>
<td>
<p>Resolution for the estimation range. Default is 100.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_xi_lb">xi_lb</code></td>
<td>
<p>Optional. Lower bound for the interval of Fourier Transform frequency xi. Used for determining the range over which A and r is estimated. If NULL, it is automatically determined based on the methods_get_xi.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_xi_ub">xi_ub</code></td>
<td>
<p>Optional. Upper bound for the interval of Fourier Transform frequency xi. Similar to xi_lb, it defines the upper range for A and r estimation. If NULL, the upper bound is determined based on the methods_get_xi.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_methods_get_xi">methods_get_xi</code></td>
<td>
<p>A string specifying the method to automatically determine the xi interval if xi_lb and xi_ub are NULL. Options are &quot;Schennach&quot; and &quot;Schennach_loose&quot;. If &quot;Schennach&quot; the range is selected based on the Theorem 2 in Schennach2020, if &quot;Schennach_loose&quot;, it is defined by the initial interval given in Theorem 2 without selecting the xi_n.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_if_plot_density">if_plot_density</code></td>
<td>
<p>Logical. If TRUE, plots the density estimation.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_if_plot_ft">if_plot_ft</code></td>
<td>
<p>Logical. If TRUE, plots the Fourier transform.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_ora_ar">ora_Ar</code></td>
<td>
<p>Optional list of oracle values for A and r.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_kernel.fun">kernel.fun</code></td>
<td>
<p>A string specifying the kernel function to be used. Options are &quot;Schennach2004&quot;, &quot;sinc&quot;, &quot;normal&quot;, &quot;epanechnikov&quot;.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_if_approx_kernel">if_approx_kernel</code></td>
<td>
<p>Logical. If TRUE, uses approximations for the kernel function.</p>
</td></tr>
<tr><td><code id="biasBound_density_+3A_kernel.resol">kernel.resol</code></td>
<td>
<p>The resolution for kernel function approximation. See <code><a href="#topic+fun_approx">fun_approx</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing various outputs including estimated values, plots, and intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: Specifying x for point estimation with manually selected xi range from 1 to 12
biasBound_density(
  X = sample_data$X,
  x = 1,
  h = 0.09,
  xi_lb = 1,
  xi_ub = 12,
  if_plot_ft = TRUE,
  kernel.fun = "Schennach2004"
)

# Example 2: Density estimation with manually selected xi range from 1 to 12 xi_lb and xi_ub
# biasBound_density(
#   X = sample_data$X,
#   h = 0.09,
#   xi_lb = 1,
#   xi_ub = 12,
#   if_plot_ft = FALSE,
#   kernel.fun = "Schennach2004"
# )

# Example 3: Density estimation with automatically selected xi range via Theorem 2 in Schennach 2020
#  biasBound_density(
#   X = sample_data$X,
#   h = 0.09,
#   methods_get_xi = "Schennach",
#   if_plot_ft = TRUE,
#   kernel.fun = "Schennach2004"
# )

</code></pre>

<hr>
<h2 id='DATA_PATH'>The Path to the Data Folder</h2><span id='topic+DATA_PATH'></span>

<h3>Description</h3>

<p>This variable provides the path to the <code>data</code> folder within the package.
</p>


<h3>Value</h3>

<p>The path to the package's internal data folder as a character string.
</p>

<hr>
<h2 id='epanechnikov_kernel'>Epanechnikov Kernel</h2><span id='topic+epanechnikov_kernel'></span>

<h3>Description</h3>

<p>Epanechnikov Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epanechnikov_kernel(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epanechnikov_kernel_+3A_u">u</code></td>
<td>
<p>A numerical value or vector representing the input to the kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the Epanechnikov kernel function at the given input.
</p>

<hr>
<h2 id='epanechnikov_kernel_ft'>Fourier Transform Epanechnikov Kernel</h2><span id='topic+epanechnikov_kernel_ft'></span>

<h3>Description</h3>

<p>Fourier Transform Epanechnikov Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epanechnikov_kernel_ft(xi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epanechnikov_kernel_ft_+3A_xi">xi</code></td>
<td>
<p>A numerical value or vector representing the frequency domain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the Fourier transform of the Epanechnikov kernel at the given frequency/frequencies.
</p>

<hr>
<h2 id='EXT_DATA_PATH'>The Path to the External Data Folder for Non-R Data Files</h2><span id='topic+EXT_DATA_PATH'></span>

<h3>Description</h3>

<p>This variable provides the path to the <code>extdata</code> folder within the package,
where non-standard R data files are stored.
</p>


<h3>Value</h3>

<p>The path to the package's external data folder (for non-standard R data files) as a character string.
</p>

<hr>
<h2 id='fun_approx'>Approximation Function for Intensive Calculations</h2><span id='topic+fun_approx'></span>

<h3>Description</h3>

<p>This function provides a lookup-based approximation for calculations that are computationally intensive.
Once computed, it stores the results in an environment and uses linear interpolation for new data points
to speed up subsequent computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun_approx(u, u_lb = -100, u_ub = 100, resol = 1000, fun = W_kernel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun_approx_+3A_u">u</code></td>
<td>
<p>A vector of values where the function should be evaluated.</p>
</td></tr>
<tr><td><code id="fun_approx_+3A_u_lb">u_lb</code></td>
<td>
<p>Lower bound for the precomputed range. Defaults to -10.</p>
</td></tr>
<tr><td><code id="fun_approx_+3A_u_ub">u_ub</code></td>
<td>
<p>Upper bound for the precomputed range. Defaults to 10.</p>
</td></tr>
<tr><td><code id="fun_approx_+3A_resol">resol</code></td>
<td>
<p>The resolution or number of sample points in the precomputed range. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="fun_approx_+3A_fun">fun</code></td>
<td>
<p>A function for which the approximation is computed. Defaults to the <code>W</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fun_approx</code> function works by initially creating a lookup table of function values based on
the range specified by <code>u_lb</code> and <code>u_ub</code> and the resolution <code>resol</code>. This precomputation only happens once
for a given set of parameters (<code>u_lb</code>, <code>u_ub</code>, <code>resol</code>, and <code>fun</code>). Subsequent calls to <code>fun_approx</code> with the
same parameters use the lookup table to find the closest precomputed points to the requested <code>u</code> values
and then return an interpolated result.
</p>
<p>Linear interpolation is used between the two closest precomputed points in the lookup table. This
ensures a smooth approximation for values in between sample points.
</p>
<p>This function is especially useful for computationally intensive functions where recalculating
function values is expensive or time-consuming. By using a combination of precomputation and
interpolation, <code>fun_approx</code> provides a balance between accuracy and speed.
</p>


<h3>Value</h3>

<p>A vector of approximated function values corresponding to <code>u</code>.
</p>

<hr>
<h2 id='gen_sample_data'>Generate Sample Data</h2><span id='topic+gen_sample_data'></span>

<h3>Description</h3>

<p>This function used for generate some sample data for experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_sample_data(size, dgp, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_sample_data_+3A_size">size</code></td>
<td>
<p>control the sample size.</p>
</td></tr>
<tr><td><code id="gen_sample_data_+3A_dgp">dgp</code></td>
<td>
<p>data generating process, have options &quot;normal&quot;, &quot;chisq&quot;, &quot;mixed&quot;, &quot;poly&quot;, &quot;2_fold_uniform&quot;.</p>
</td></tr>
<tr><td><code id="gen_sample_data_+3A_seed">seed</code></td>
<td>
<p>random seed number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>size</code>. The elements of the vector
are generated according to the specified <code>dgp</code>:
</p>

<dl>
<dt>normal</dt><dd><p>Normally distributed values with mean 0 and standard deviation 2.</p>
</dd>
<dt>chisq</dt><dd><p>Chi-squared distributed values with df = 10.</p>
</dd>
<dt>mixed</dt><dd><p>Half normally distributed (mean 0, sd = 2) and half chi-squared distributed (df = 10) values.</p>
</dd>
<dt>poly</dt><dd><p>Values from a polynomial cumulative distribution function on <code>[0,1]</code>.</p>
</dd>
<dt>2_fold_uniform</dt><dd><p>Sum of two uniformly distributed random numbers.</p>
</dd>
</dl>


<hr>
<h2 id='get_avg_f1x'>Kernel point estimation</h2><span id='topic+get_avg_f1x'></span>

<h3>Description</h3>

<p>Computes the point estimate using the specified kernel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_avg_f1x(X, x, h, inf_k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_avg_f1x_+3A_x">X</code></td>
<td>
<p>A numerical vector of sample data.</p>
</td></tr>
<tr><td><code id="get_avg_f1x_+3A_x">x</code></td>
<td>
<p>A scalar representing the point where the density is estimated.</p>
</td></tr>
<tr><td><code id="get_avg_f1x_+3A_h">h</code></td>
<td>
<p>A scalar bandwidth parameter.</p>
</td></tr>
<tr><td><code id="get_avg_f1x_+3A_inf_k">inf_k</code></td>
<td>
<p>Kernel function used for the computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the kernel density estimate at point x.
</p>

<hr>
<h2 id='get_avg_fyx'>Kernel point estimation</h2><span id='topic+get_avg_fyx'></span>

<h3>Description</h3>

<p>Computes the point estimate using the specified kernel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_avg_fyx(Y, X, x, h, inf_k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_avg_fyx_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="get_avg_fyx_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_avg_fyx_+3A_x">x</code></td>
<td>
<p>A scalar representing the point where the density is estimated.</p>
</td></tr>
<tr><td><code id="get_avg_fyx_+3A_h">h</code></td>
<td>
<p>A scalar bandwidth parameter.</p>
</td></tr>
<tr><td><code id="get_avg_fyx_+3A_inf_k">inf_k</code></td>
<td>
<p>Kernel function used for the computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the kernel density estimate at point x.
</p>

<hr>
<h2 id='get_avg_phi'>Compute Sample Average of Fourier Transform Magnitude</h2><span id='topic+get_avg_phi'></span>

<h3>Description</h3>

<p>Compute Sample Average of Fourier Transform Magnitude
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_avg_phi(Y = 1, X, xi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_avg_phi_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="get_avg_phi_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_avg_phi_+3A_xi">xi</code></td>
<td>
<p>A single numerical value representing the frequency at which the Fourier transform
is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the sample estimation of expected Fourier transform at frequency <code>xi</code>.
</p>

<hr>
<h2 id='get_avg_phi_log'>Compute log sample average of fourier transform and get mod</h2><span id='topic+get_avg_phi_log'></span>

<h3>Description</h3>

<p>Compute log sample average of fourier transform and get mod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_avg_phi_log(Y = 1, X, ln_xi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_avg_phi_log_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="get_avg_phi_log_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_avg_phi_log_+3A_ln_xi">ln_xi</code></td>
<td>
<p>A single numerical value representing the log frequency at which the Fourier transform
is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log sample estimation of expected Fourier transform at frequency <code>xi</code>.
</p>

<hr>
<h2 id='get_conditional_var'>get the conditional variance of Y on X for given x</h2><span id='topic+get_conditional_var'></span>

<h3>Description</h3>

<p>get the conditional variance of Y on X for given x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_conditional_var(X, Y, x, h, kernel_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_conditional_var_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_conditional_var_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="get_conditional_var_+3A_x">x</code></td>
<td>
<p>The specific point at which the conditional variance is to be calculated.</p>
</td></tr>
<tr><td><code id="get_conditional_var_+3A_h">h</code></td>
<td>
<p>A bandwidth parameter used in the kernel function for smoothing.</p>
</td></tr>
<tr><td><code id="get_conditional_var_+3A_kernel_func">kernel_func</code></td>
<td>
<p>A kernel function used to weigh observations in the neighborhood of point x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a scalar representing the estimated conditional variance of Y given X at the point x.
</p>

<hr>
<h2 id='get_est_Ar'>get the estimation of A and r</h2><span id='topic+get_est_Ar'></span>

<h3>Description</h3>

<p>This function estimates the parameters A and r by optimizing an objective function
over a specified range of frequency values and r values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_est_Ar(Y = 1, X, xi_interval, r_stepsize = 150)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_est_Ar_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="get_est_Ar_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_est_Ar_+3A_xi_interval">xi_interval</code></td>
<td>
<p>A list with elements <code>xi_lb</code> and <code>xi_ub</code> representing the lower
and upper bounds of the frequency interval.</p>
</td></tr>
<tr><td><code id="get_est_Ar_+3A_r_stepsize">r_stepsize</code></td>
<td>
<p>An integer value representing the number of steps in the r range.
This controls the granularity of the estimation. Higher values lead to finer
granularity but increase computation time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function internally defines a range for the natural logarithm of frequency values (<code>ln_xi_range</code>)
and a range for the parameter <code>r</code> (<code>r_range</code>). It then defines an optimization function <code>optim_ln_A</code>
to minimize the integral of a given function over the <code>ln_xi_range</code>. The actual estimation is done by
finding the <code>r</code> and <code>A</code> value that minimizes the the area of the line <code class="reqn">\ln A - r \ln \xi</code> under the constraint that the line should not go below the Fourier transform curve.
</p>


<h3>Value</h3>

<p>A named vector with elements <code>est_A</code> and <code>est_r</code> representing the estimated
values of A and r, respectively.
</p>

<hr>
<h2 id='get_est_B'>get the estimation of B</h2><span id='topic+get_est_B'></span>

<h3>Description</h3>

<p>get the estimation of B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_est_B(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_est_B_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of the absolute values of the elements in Y, representing the estimated value of <code class="reqn">B</code>.
</p>

<hr>
<h2 id='get_est_b1x'>Estimation of bias b1x</h2><span id='topic+get_est_b1x'></span>

<h3>Description</h3>

<p>Computes the bias estimate for given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_est_b1x(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_est_b1x_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_est_b1x_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the bias b1x estimate.
</p>

<hr>
<h2 id='get_est_byx'>Estimation of bias byx</h2><span id='topic+get_est_byx'></span>

<h3>Description</h3>

<p>Estimation of bias byx
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_est_byx(Y, X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_est_byx_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="get_est_byx_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_est_byx_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the bias byx estimate.
</p>

<hr>
<h2 id='get_est_vy'>get the estimation of Vy</h2><span id='topic+get_est_vy'></span>

<h3>Description</h3>

<p>get the estimation of Vy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_est_vy(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_est_vy_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
</table>

<hr>
<h2 id='get_sigma'>Estimation of sigma</h2><span id='topic+get_sigma'></span>

<h3>Description</h3>

<p>Computes the sigma estimate for given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sigma(X, x, h, inf_k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sigma_+3A_x">X</code></td>
<td>
<p>A numerical vector of sample data.</p>
</td></tr>
<tr><td><code id="get_sigma_+3A_x">x</code></td>
<td>
<p>A scalar representing the point where the density is estimated.</p>
</td></tr>
<tr><td><code id="get_sigma_+3A_h">h</code></td>
<td>
<p>A scalar bandwidth parameter.</p>
</td></tr>
<tr><td><code id="get_sigma_+3A_inf_k">inf_k</code></td>
<td>
<p>Kernel function used for the computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the sigma estimate at point x.
</p>

<hr>
<h2 id='get_sigma_yx'>Estimation of sigma_yx</h2><span id='topic+get_sigma_yx'></span>

<h3>Description</h3>

<p>Estimation of sigma_yx
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sigma_yx(Y, X, x, h, inf_k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sigma_yx_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="get_sigma_yx_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_sigma_yx_+3A_x">x</code></td>
<td>
<p>The specific point at which sigma_yx is to be estimated.</p>
</td></tr>
<tr><td><code id="get_sigma_yx_+3A_h">h</code></td>
<td>
<p>A bandwidth parameter used in the kernel function for smoothing.</p>
</td></tr>
<tr><td><code id="get_sigma_yx_+3A_inf_k">inf_k</code></td>
<td>
<p>A kernel function used to weigh observations in the neighborhood of point x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a scalar representing the estimated value of sigma_yx at the point x.
</p>

<hr>
<h2 id='get_xi_interval'>get xi interval</h2><span id='topic+get_xi_interval'></span>

<h3>Description</h3>

<p>get xi interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_xi_interval(Y = 1, X, methods = "Schennach")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_xi_interval_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="get_xi_interval_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="get_xi_interval_+3A_methods">methods</code></td>
<td>
<p>A character string indicating the method to use for calculating the
xi interval. Supported methods are &quot;Schennach&quot; and &quot;Schennach_loose&quot;.
Defaults to &quot;Schennach&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;Schennach&quot; method computes the xi interval by performing a test based on the
Schennach's theorem, adjusting the upper bound <code>xi_ub</code> if the test condition is met.
The &quot;Schennach_loose&quot; method provides a looser calculation of the xi interval without
performing the Schennach's test.
</p>


<h3>Value</h3>

<p>A list containing the lower (<code>xi_lb</code>) and upper (<code>xi_ub</code>) bounds of the xi interval.
</p>

<hr>
<h2 id='kernel_reg'>Kernel Regression function</h2><span id='topic+kernel_reg'></span>

<h3>Description</h3>

<p>Kernel Regression function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_reg(X, Y, x, h, kernel_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_reg_+3A_x">X</code></td>
<td>
<p>A numerical vector representing the sample data of variable X.</p>
</td></tr>
<tr><td><code id="kernel_reg_+3A_y">Y</code></td>
<td>
<p>A numerical vector representing the sample data of variable Y.</p>
</td></tr>
<tr><td><code id="kernel_reg_+3A_x">x</code></td>
<td>
<p>The point at which the regression function is to be estimated.</p>
</td></tr>
<tr><td><code id="kernel_reg_+3A_h">h</code></td>
<td>
<p>A bandwidth parameter that determines the weight assigned to each observation in X.</p>
</td></tr>
<tr><td><code id="kernel_reg_+3A_kernel_func">kernel_func</code></td>
<td>
<p>A function that computes the weight of each observation based on its distance to x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a scalar representing the estimated value of the regression function at the point x.
</p>

<hr>
<h2 id='normal_kernel'>Normal Kernel Function</h2><span id='topic+normal_kernel'></span>

<h3>Description</h3>

<p>Normal Kernel Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_kernel(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_kernel_+3A_u">u</code></td>
<td>
<p>A numerical value or vector representing the input to the kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the Normal kernel function at the given input.
</p>

<hr>
<h2 id='normal_kernel_ft'>Fourier Transform of Normal Kernel</h2><span id='topic+normal_kernel_ft'></span>

<h3>Description</h3>

<p>Fourier Transform of Normal Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_kernel_ft(xi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_kernel_ft_+3A_xi">xi</code></td>
<td>
<p>A numerical value or vector representing the frequency domain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the Fourier transform of the Normal kernel at the given frequency/frequencies.
</p>

<hr>
<h2 id='plot_ft'>Plot the Fourier Transform</h2><span id='topic+plot_ft'></span>

<h3>Description</h3>

<p>Plot the Fourier Transform of the
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ft(X, xi_interval, ft_plot.resol = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ft_+3A_x">X</code></td>
<td>
<p>A numerical vector of sample data.</p>
</td></tr>
<tr><td><code id="plot_ft_+3A_xi_interval">xi_interval</code></td>
<td>
<p>A list containing the lower (<code>xi_lb</code>) and upper (<code>xi_ub</code>) bounds of the xi interval.</p>
</td></tr>
<tr><td><code id="plot_ft_+3A_ft_plot.resol">ft_plot.resol</code></td>
<td>
<p>An integer representing the resolution of the plot, specifically the number of points
used to represent the Fourier transform. Defaults to 500.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>C = 1, the parameter in <code class="reqn">O(1/n^{0.25})</code>, see more details in Schennach (2020) <a href="https://doi.org/10.1093/restud/rdz065">doi:10.1093/restud/rdz065</a>.
</p>


<h3>Value</h3>

<p>A ggplot object representing the plot of the Fourier transform.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_ft(
  sample_data$X,
  xi_interval = list(xi_lb = 1, xi_ub = 50),
  ft_plot.resol = 1000
)
</code></pre>

<hr>
<h2 id='rpoly01'>Generate n samples from the distribution</h2><span id='topic+rpoly01'></span>

<h3>Description</h3>

<p>Generate n samples from the distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoly01(n, k = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoly01_+3A_n">n</code></td>
<td>
<p>The number of samples to generate.</p>
</td></tr>
<tr><td><code id="rpoly01_+3A_k">k</code></td>
<td>
<p>The exponent in the distribution function, defaults to 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>n</code> samples from the specified polynomial distribution.
</p>
<p>CDF: f(x) = (x-1)^k + 1
</p>

<hr>
<h2 id='sample_data'>Sample Data</h2><span id='topic+sample_data'></span>

<h3>Description</h3>

<p>Sample Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 2 variables:
</p>

<dl>
<dt>X</dt><dd><p>Numeric vector, generated from 2 fold uniform distribution.</p>
</dd>
<dt>Y</dt><dd><p>Numeric vector, <code>Y = -X^2 + 3*X + rnorm(1000)*X</code>.</p>
</dd>
</dl>


<hr>
<h2 id='sinc'>Infinite Kernel Function</h2><span id='topic+sinc'></span>

<h3>Description</h3>

<p>Infinite Kernel Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinc(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinc_+3A_u">u</code></td>
<td>
<p>A numerical value or vector where the sinc function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the sinc function at each point in <code>u</code>.
</p>

<hr>
<h2 id='sinc_ft'>Define the closed form FT of the infinite order kernel sin(x)/(pi*x)</h2><span id='topic+sinc_ft'></span>

<h3>Description</h3>

<p>Define the closed form FT of the infinite order kernel sin(x)/(pi*x)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinc_ft(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinc_ft_+3A_x">x</code></td>
<td>
<p>A numerical value or vector where the Fourier Transform is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the Fourier Transform of the sinc function at each point in <code>x</code>.
</p>

<hr>
<h2 id='true_density_2fold'>True density of 2-fold uniform distribution</h2><span id='topic+true_density_2fold'></span>

<h3>Description</h3>

<p>True density of 2-fold uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>true_density_2fold(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="true_density_2fold_+3A_x">x</code></td>
<td>
<p>A numerical value or vector where the true density function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the true density of the 2-fold uniform distribution at each point in <code>x</code>.
</p>

<hr>
<h2 id='W_kernel'>Define the inverse Fourier transform function of W</h2><span id='topic+W_kernel'></span>

<h3>Description</h3>

<p>Define the inverse Fourier transform function of W
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_kernel(u, L = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W_kernel_+3A_u">u</code></td>
<td>
<p>A numerical value or vector representing the time or space domain.</p>
</td></tr>
<tr><td><code id="W_kernel_+3A_l">L</code></td>
<td>
<p>The limit for numerical integration, defines the range of integration as <code class="reqn">[-L, L]</code>.
Defaults to 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value or vector representing the inverse Fourier transform of the infinite
order kernel at the given time or space point(s).
</p>

<hr>
<h2 id='W_kernel_ft'>Define the Fourier transform of a infinite kernel proposed in Schennach 2004</h2><span id='topic+W_kernel_ft'></span>

<h3>Description</h3>

<p>Define the Fourier transform of a infinite kernel proposed in Schennach 2004
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_kernel_ft(xi, xi_lb = 0.5, xi_ub = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W_kernel_ft_+3A_xi">xi</code></td>
<td>
<p>A numerical value or vector representing the frequency domain.</p>
</td></tr>
<tr><td><code id="W_kernel_ft_+3A_xi_lb">xi_lb</code></td>
<td>
<p>The lower bound for the frequency domain. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="W_kernel_ft_+3A_xi_ub">xi_ub</code></td>
<td>
<p>The upper bound for the frequency domain. Defaults to 1.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value or vector representing the Fourier transform of the infinite
order kernel at the given frequency/frequencies.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
