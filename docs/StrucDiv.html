<!DOCTYPE html><html><head><title>Help for package StrucDiv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StrucDiv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Diversity'><p>Spatial Structural Diversity Metrics</p></a></li>
<li><a href='#DiversityDom'><p>Spatial Structural Diversity Metrics</p></a></li>
<li><a href='#getValuesWindow'><p>Retrieve pixel values of a defined area.</p>
The area is defined by the size of a window, which is centered on one pixel.</a></li>
<li><a href='#ndvi'><p>NDVI</p></a></li>
<li><a href='#ndvi.15gl'><p>NDVI, 15 gray levels</p></a></li>
<li><a href='#patch'><p>simulated patch data</p></a></li>
<li><a href='#strucDiv'><p>Quantify Spatial Structural Diversity in an Arbitrary Raster Layer</p></a></li>
<li><a href='#strucDivDom'><p>Returns the structural diversity value, the gray level co-occurrence matrix (GLCM) and the structural diversity</p>
matrix of the domain.</a></li>
<li><a href='#strucDivNest'><p>Quantify Spatial Structural Diversity Across Scales in an Arbitrary Raster Layer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Structural Diversity Quantification in Raster Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leila Schuh &lt;l.schuh@posteo.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial structural diversity refers to the spatial, i.e.
    horizontal arrangement of landscape elements and can reveal itself as
    landscape features, such as patches and linear features. The 'R' package
    'StrucDiv' provides methods to quantify spatial structural diversity
    in continuous remote sensing data, or in other data in raster format.
    Structure is based on the spatial arrangement of value pairs. The 'R' package 'StrucDiv'
    includes methods to combine information from different spatial scales, which allows to quantify
    multi-scale spatial structural diversity.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/leilsc/StrucDiv">https://github.com/leilsc/StrucDiv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/leilsc/StrucDiv">https://github.com/leilsc/StrucDiv</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel (&ge; 1.0.15), foreach (&ge; 1.5.0), glue, raster (&ge;
3.1.5), Rcpp (&ge; 1.0.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-13 16:35:10 UTC; leila</td>
</tr>
<tr>
<td>Author:</td>
<td>Leila Schuh <a href="https://orcid.org/0000-0001-5646-7767"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Reinhard Furrer <a href="https://orcid.org/0000-0002-6319-2332"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kalina Cherneva [ctb, ctr],
  Kirill Müller [ctr],
  Patrick Schratz [ctr],
  University Research Priority Progam Global Change and Biodiversity of
    the University of Zurich [fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-14 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Diversity'>Spatial Structural Diversity Metrics</h2><span id='topic+Diversity'></span><span id='topic+homogeneity'></span><span id='topic+dissimilarity'></span><span id='topic+contrast'></span><span id='topic+entropy'></span><span id='topic+entropyNorm'></span>

<h3>Description</h3>

<p>The functions <code>entropy</code> , <code>entropyNorm</code>, <code>contrast</code>, <code>dissimilarity</code> and <code>homogeneity</code>
are the (spatial) structural diversity metrics used in the default configurations of <code><a href="#topic+strucDiv">strucDiv</a></code> and <code><a href="#topic+strucDivNest">strucDivNest</a></code>. 
Structural diversity entropy is <code>entropy</code> with different <code>delta</code> parameters. Shannon entropy is employed, when <code>delta = 0</code>. 
Shannon entropy has a window-dependent maximum when <code><a href="#topic+strucDiv">strucDiv</a></code> is used, which may be violated when <code><a href="#topic+strucDivNest">strucDivNest</a></code> is used, 
depending on the posterior probabilities of pixel value co-occurrences.
Additionally, the value gradient is considered when <code>delta = 1</code> or <code>delta = 2</code>. 
The values of structural diversity entropy with <code>delta = 1</code> or <code>delta = 2</code> are not restricted and depend on the values of the input raster.
the metric <code>entropyNorm</code> is Shannon entropy normalized over maximum entropy, which depends on the size of the moving window when no nesting is used. 
The metric <code>entropyNorm</code> ranges between 0 and 1, when <code><a href="#topic+strucDiv">strucDiv</a></code> is used, but may be larger than 1 when <code><a href="#topic+strucDivNest">strucDivNest</a></code> is used, 
depending on the posterior probabilities of pixel value co-occurrences.
The metrics <code>contrast</code> and <code>dissimilarity</code> consider the value gradient, their values are not restricted and depend on the values of the input raster.
The metric <code>homogeneity</code> quantifies the closeness of empirical probabilities to the diagonal and ranges between 0 and 1 when <code><a href="#topic+strucDiv">strucDiv</a></code> is used, 
but may be larger than 1 when <code><a href="#topic+strucDivNest">strucDivNest</a></code> is used, depending on the posterior probabilities of pixel value co-occurrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogeneity(
  rank,
  delta,
  Hetx,
  vMat_big = NULL,
  SpatMat,
  nrp,
  narm,
  display_progress = TRUE,
  ...
)

dissimilarity(
  rank,
  delta,
  Hetx,
  vMat_big = NULL,
  SpatMat,
  nrp,
  narm,
  display_progress,
  ...
)

contrast(
  rank,
  delta,
  Hetx,
  vMat_big = NULL,
  SpatMat,
  nrp,
  narm,
  display_progress,
  ...
)

entropy(
  rank,
  delta,
  Hetx,
  vMat_big = NULL,
  SpatMat,
  nrp,
  narm,
  display_progress,
  ...
)

entropyNorm(
  rank,
  delta,
  Hetx,
  vMat_big = NULL,
  SpatMat,
  nrp,
  narm,
  display_progress,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diversity_+3A_rank">rank</code></td>
<td>
<p>logical. Should values be replaced with ranks in each co-occurrence 
matrix (GLCM)? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Diversity_+3A_delta">delta</code></td>
<td>
<p>numeric, takes 3 options: <code>0</code>, <code>1</code>, or <code>2</code>. 
The <code>delta</code> parameter defines how the differences between pixel values within a pixel 
pair are weighted.  
If <code>rank = TRUE</code>, delta defines how the differences between ranks are weighted.  
The default value is <code>0</code> (no weight). Set <code>delta = 1</code> for absolute weights, 
or <code>delta = 2</code> for squared weights. 
The <code>delta</code> parameter can only be set when the metric <code>entropy</code> is used. 
The metric <code>dissimilarity</code> automatically employs <code>delta = 1</code>, and <code>contrast</code> employs <code>delta = 2</code>.</p>
</td></tr>
<tr><td><code id="Diversity_+3A_hetx">Hetx</code></td>
<td>
<p>the structural diversity matrix that is returned by an internal function
to the <code><a href="#topic+strucDiv">strucDiv</a></code> and <code><a href="#topic+strucDivNest">strucDivNest</a></code> functions. 
The structural diversity metric is calculated on every element
of the GLCM, which generates the structural diversity matrix <code>Hetx</code>. The sum of this
matrix is assigned to the center pixel of the moving window.</p>
</td></tr>
<tr><td><code id="Diversity_+3A_vmat_big">vMat_big</code></td>
<td>
<p>matrix. The matrix containing the pixel values of the outer scale. 
Defaults to <code>NULL</code>, in which case no prior information is used.</p>
</td></tr>
<tr><td><code id="Diversity_+3A_spatmat">SpatMat</code></td>
<td>
<p>the GLCM that is returned by an internal function
to the <code><a href="#topic+strucDiv">strucDiv</a></code> and <code><a href="#topic+strucDivNest">strucDivNest</a></code> functions.</p>
</td></tr>
<tr><td><code id="Diversity_+3A_nrp">nrp</code></td>
<td>
<p>integer. The total number of pixel pairs. <code>nrp</code> is calculated internally by the 
functions <code><a href="#topic+strucDiv">strucDiv</a></code> and <code><a href="#topic+strucDivNest">strucDivNest</a></code> and passed to the structural 
diversity metric functions.</p>
</td></tr>
<tr><td><code id="Diversity_+3A_narm">narm</code></td>
<td>
<p>logical. Should NAs be removed? 
<code>narm</code> is automatically set to 0 if <code>na.handling = na.pass</code>, 
and to 1 if <code>na.handling = na.omit</code>.</p>
</td></tr>
<tr><td><code id="Diversity_+3A_display_progress">display_progress</code></td>
<td>
<p>logical. Should a progress bar be displayed?</p>
</td></tr>
<tr><td><code id="Diversity_+3A_...">...</code></td>
<td>
<p>possible further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used internally and are called 
as an argument to the <code><a href="#topic+strucDiv">strucDiv</a></code> and <code><a href="#topic+strucDivNest">strucDivNest</a></code> functions.
</p>

<hr>
<h2 id='DiversityDom'>Spatial Structural Diversity Metrics</h2><span id='topic+DiversityDom'></span><span id='topic+homogeneityDom'></span><span id='topic+dissimilarityDom'></span><span id='topic+contrastDom'></span><span id='topic+entropyDom'></span><span id='topic+entropyNormDom'></span>

<h3>Description</h3>

<p>The functions <code>entropyDom</code> , <code>entropyNormDom</code>, <code>contrastDom</code>, <code>dissimilarityDom</code> 
and <code>homogeneityDom</code> are the spatial structural diversity metrics used in the default 
configurations of <code><a href="#topic+strucDivDom">strucDivDom</a></code>. 
For programming reasons, these metrics have different name endings than the metrics used in the functions
<code><a href="#topic+strucDiv">strucDiv</a></code> and <code><a href="#topic+strucDivNest">strucDivNest</a></code>, but they have the same mathematical formulation. 
Hence, <code>entropyDom</code> is specified by the same equation as <code>entropy</code>, and so forth.
Structural diversity entropy is <code>entropyDom</code> with different <code>delta</code> parameters. 
Shannon entropy is employed, when <code>delta = 0</code>. 
The metric <code>entropyDom</code> has a scale-dependent maximum. Scale, here, refers to the extent of the domain.
The metric <code>entropyNormDom</code> is Shannon entropy normalized over maximum entropy. 
The metric <code>entropyNormDom</code> ranges between 0 and 1.
Additionally, the value gradient is considered with <code>delta = 1</code> and <code>delta = 2</code>. 
The values of structural diversity entropy with <code>delta = 1</code> or <code>delta = 2</code> are not restricted and depend on the values of the input raster.
The metric <code>dissimilarityDom</code> employs <code>delta = 1</code>, <code>contrastDom</code> employs <code>delta = 2</code>. 
The values of <code>dissimilarityDom</code> and <code>contrastDom</code> are not restricted and depend on the values of the input raster. 
The metric <code>homogeneityDom</code> quantifies the closeness of empirical probabilities to the diagonal and ranges between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogeneityDom(rank, delta, PMat, xVal, nrp)

dissimilarityDom(rank, delta, PMat, xVal, nrp)

contrastDom(rank, delta, PMat, xVal, nrp)

entropyDom(rank, delta, PMat, xVal, nrp)

entropyNormDom(rank, delta, PMat, xVal, nrp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiversityDom_+3A_rank">rank</code></td>
<td>
<p>logical. Should values be replaced with ranks in the co-occurrence 
matrix (GLCM)? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DiversityDom_+3A_delta">delta</code></td>
<td>
<p>numeric, takes 3 options: <code>0</code>, <code>1</code>, or <code>2</code>. 
The parameter <code>delta</code> is the difference weight parameter, 
it defines how the differences between pixel values within a pixel pair should be weighted.  
If <code>rank = TRUE</code>, delta defines how the differences between ranks should be weighted.  
The default value is <code>0</code> (no weight). Set <code>delta = 1</code> for absolute weights, 
or <code>delta = 2</code> for square weights. 
The <code>delta</code> parameter can only be set when the metric <code>entropyDom</code> is used. 
The metric <code>dissimilarityDom</code> automatically employs <code>delta = 1</code>, and <code>contrastDom</code> employs <code>delta = 2</code>.</p>
</td></tr>
<tr><td><code id="DiversityDom_+3A_pmat">PMat</code></td>
<td>
<p>the GLCM that is returned by an internal function
to the <code><a href="#topic+strucDivDom">strucDivDom</a></code> function.</p>
</td></tr>
<tr><td><code id="DiversityDom_+3A_xval">xVal</code></td>
<td>
<p>the unique values in the raster layer. calculated internally.</p>
</td></tr>
<tr><td><code id="DiversityDom_+3A_nrp">nrp</code></td>
<td>
<p>the normalizing constant calculated internally based on the raster dimensions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used internally and are called 
as an argument to the <code><a href="#topic+strucDivDom">strucDivDom</a></code>.
</p>

<hr>
<h2 id='getValuesWindow'>Retrieve pixel values of a defined area. 
The area is defined by the size of a window, which is centered on one pixel.</h2><span id='topic+getValuesWindow'></span>

<h3>Description</h3>

<p>Modified R Code from raster package raster::getValuesFocal.
Returns one row per pixel, which contains the values
of the pixel neighborhood that is defined by the size of the window.
The size of the window is defined by the window side length (wsl).
The window is centered on one specific pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getValuesWindow(x, wsl, padValue, aroundTheGlobe, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValuesWindow_+3A_x">x</code></td>
<td>
<p>raster layer. The input raster layer.</p>
</td></tr>
<tr><td><code id="getValuesWindow_+3A_wsl">wsl</code></td>
<td>
<p>integer. The window side length. The window is defined by <code>wsl x wsl</code>.</p>
</td></tr>
<tr><td><code id="getValuesWindow_+3A_padvalue">padValue</code></td>
<td>
<p>atomic. If a pixel is on the edge of an image, padding should be used?
Can be NA or a value.</p>
</td></tr>
<tr><td><code id="getValuesWindow_+3A_aroundtheglobe">aroundTheGlobe</code></td>
<td>
<p>logical. Does the image go around the globe?</p>
</td></tr>
<tr><td><code id="getValuesWindow_+3A_...">...</code></td>
<td>
<p>possible further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix.
The matrix contains the values of the defined window centered on the respective pixel.
</p>

<hr>
<h2 id='ndvi'>NDVI</h2><span id='topic+ndvi'></span>

<h3>Description</h3>

<p>NDVI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndvi
</code></pre>


<h3>Format</h3>

<p>A matrix with 221 rows and 1092 columns. 
Mean Normalized Difference Vegetation Index (NDVI).
</p>

<dl>
<dt><code>Modified remote sensing product</code></dt><dd><p>MOD13A1v006</p>
</dd>
<dt><code>Device</code></dt><dd><p>MODIS sensor</p>
</dd>
<dt><code>Year</code></dt><dd><p>2018</p>
</dd>
<dt><code>Aggregation</code></dt><dd><p>Mean aggregation over the growing season 2018</p>
</dd>
<dt><code>Location</code></dt><dd><p>Study region in North East Eurasia</p>
</dd>
<dt><code>Data quality</code></dt><dd><p>Only pixels with sufficient quality flags were used.</p>
</dd>
<dt><code>NA handling</code></dt><dd><p>NA gaps were filled with a local neighborhood average.</p>
</dd>
<dt><code>Value range</code></dt><dd><p>NDVI values below zero were excluded. NDVI values range between 0 and 1.</p>
</dd>
<dt><code>Data retrieval</code></dt><dd><p>Data was pre-processed and downloaded from Google Earth Engine.</p>
</dd>
</dl>

<p>For further details, see <a href="https://lpdaac.usgs.gov/products/mod13q1v006/">https://lpdaac.usgs.gov/products/mod13q1v006/</a>
and <a href="https://earthengine.google.com/">https://earthengine.google.com/</a>
</p>

<hr>
<h2 id='ndvi.15gl'>NDVI, 15 gray levels</h2><span id='topic+ndvi.15gl'></span>

<h3>Description</h3>

<p>NDVI, 15 gray levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndvi.15gl
</code></pre>


<h3>Format</h3>

<p>A matrix with 221 rows and 1092 columns.
Mean Normalized Difference Vegetation Index (NDVI), with reduced
number of gray levels (15).
</p>

<dl>
<dt><code>Modified remote sensing product</code></dt><dd><p>MOD13A2v006</p>
</dd>
<dt><code>Device</code></dt><dd><p>MODIS sensor</p>
</dd>
<dt><code>Year</code></dt><dd><p>2018</p>
</dd>
<dt><code>Aggregation</code></dt><dd><p>Mean aggregation over the growing season 2018</p>
</dd>
<dt><code>Gray level reduction</code></dt><dd><p>Data was binned into 15 bins of equal size.</p>
</dd>
<dt><code>Location</code></dt><dd><p>Study region in North East Eurasia</p>
</dd>
<dt><code>Data quality</code></dt><dd><p>Only pixels with sufficient quality flags were used.</p>
</dd>
<dt><code>NA handling</code></dt><dd><p>NA gaps were filled with a local neighborhood average.</p>
</dd>
<dt><code>Value range</code></dt><dd><p>NDVI values below zero were excluded. NDVI values range between 0 and 1.</p>
</dd>
<dt><code>Data retrieval</code></dt><dd><p>Data was pre-processed and downloaded from Google Earth Engine.</p>
</dd>
</dl>

<p>For further details, see <a href="https://lpdaac.usgs.gov/products/mod13q1v006/">https://lpdaac.usgs.gov/products/mod13q1v006/</a>
and <a href="https://earthengine.google.com/">https://earthengine.google.com/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This dataset is essentially constructed via:
nGrayLevels &lt;- 15
require(raster)
ndvi &lt;- raster(StrucDiv::ndvi)
ndvi15 &lt;- cut(ndvi, breaks=seq(minValue(ndvi), maxValue(ndvi), len=nGrayLevels + 1), 
              include.lowest=TRUE, right=FALSE)

</code></pre>

<hr>
<h2 id='patch'>simulated patch data</h2><span id='topic+patch'></span>

<h3>Description</h3>

<p>simulated patch data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patch
</code></pre>


<h3>Format</h3>

<p>A matrix with 90 rows and 90 columns. Simulated patches.
</p>

<dl>
<dt><code>Simulated random patches</code></dt><dd><p>The background is random structure, depicting no spatial correlation, and structure is also random within patches.</p>
</dd>
<dt><code>Value range</code></dt><dd><p>Data contains 20 gray levels.</p>
</dd>
</dl>


<hr>
<h2 id='strucDiv'>Quantify Spatial Structural Diversity in an Arbitrary Raster Layer</h2><span id='topic+strucDiv'></span>

<h3>Description</h3>

<p>This is a wrapper function that returns a 'spatial structural diversity map' 
as a raster layer. Spatial refers to horizontal, i.e. spatially explicit, and 
'spatial structural diversity' will hereafter be used synonymous to 'structural diversity'. 
Pixels are considered as pairs in user-specified distances and angles. 
Angles include horizontal and vertical direction, and the diagonals at 45° and 135°. 
The direction-invariant version considers all angles. 
The frequencies of pixel pairs are normalized by the total number of pixel pairs, 
which returns the gray level co-occurrence matrix (GLCM). 
The GLCM contains the empirical probabilities that pixel values are arranged in the specified way (distance and angle).
The total number of pixel pairs depends on the extent of the area within which pixel pairs are counted, i.e. on the spatial scale. 
The spatial scale is defined by the window side length (<code>wsl</code>) of a moving window. 
The values in a GLCM are the same values that occur in the area within which pixel pairs were counted, 
therefore they can differ between GLCMs.
In each GLCM, pixel values can be replaced with ranks.
Structural diversity metrics are calculated on every element of the GLCM, 
their sum is assigned to the center pixel of the moving window 
and represents spatial structural diversity of the area captured by the moving window. 
The final map is called a '(spatial) structural diversity map' and is returned as a raster layer 
with the same dimensions as the input raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strucDiv(
  x,
  wsl,
  dist = 1,
  angle = "all",
  rank = FALSE,
  fun,
  delta = 0,
  na.handling = na.pass,
  padValue = NA,
  aroundTheGlobe = FALSE,
  filename = "",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strucDiv_+3A_x">x</code></td>
<td>
<p>raster layer. Input raster layer for which 
spatial structural diversity should be calculated.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_wsl">wsl</code></td>
<td>
<p>uneven integer. The window side length, 
<code>wsl</code> x <code>wsl</code> defines the size of the moving window.
The window must be smaller than the dimensions of the input raster. 
The moving window defines the spatial scale on which spatial structural diversity is quantified.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_dist">dist</code></td>
<td>
<p>integer. The distance between two pixels that should be considered as a pair, 
defaults to <code>dist = 1</code> (direct neighbors).</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_angle">angle</code></td>
<td>
<p>string. The angle on which pixels should be considered as pairs. 
Takes 5 options: <code>"horizontal"</code>, <code>"vertical"</code>, <code>"diagonal45"</code>, <code>"diagonal135"</code>, <code>"all"</code>. 
The direction-invariant version is <code>"all"</code>, which considers all of the 4 angles. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_rank">rank</code></td>
<td>
<p>logical. Should pixel values be replaced with ranks in each GLCM? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_fun">fun</code></td>
<td>
<p>function, the structural diversity metric. Takes one of the following: <code>entropy</code>,
<code>entropyNorm</code>, <code>contrast</code>, <code>dissimilarity</code>, or <code>homogeneity</code>. 
Structural diversity entropy is entropy with different <code>delta</code> parameters. Shannon entropy is employed when <code>delta = 0</code>. 
Shannon entropy has a scale-dependent maximum.
Additionally, the value gradient is considered when <code>delta</code> = 1 or <code>delta</code> = 2. 
The values of structural diversity entropy with <code>delta</code> = 1 or <code>delta</code> = 2 are not restricted and depend on the values of the input raster.
The metric <code>entropyNorm</code> is Shannon entropy normalized over maximum entropy, which depends on the size of the moving window. 
The metric <code>entropyNorm</code> ranges between 0 and 1.
The metrics <code>contrast</code> and <code>dissimilarity</code> consider the value gradient, their values are not restricted and depend on the values of the input raster.
The metric <code>homogeneity</code> quantifies the closeness of empirical probabilities to the diagonal and ranges between 0 and 1. 
The metric <code>homogeneity</code> is 1 when all pixel pairs are the same and approaches  0 as differences increase.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_delta">delta</code></td>
<td>
<p>numeric, takes three options: <code>0</code>, <code>1</code>, or <code>2</code>. 
The <code>delta</code> parameter defines how the differences between pixel values within a pixel pair should be weighted.  
If <code>rank = TRUE</code>, delta defines how the differences between ranks should be weighted.  
The default value is <code>0</code> (no weight). Set <code>delta = 1</code> for absolute weight, 
or <code>delta = 2</code> for squared weight. 
The <code>delta</code> parameter can only be set when the metric <code>entropy</code> is used. 
The metric <code>dissimilarity</code> automatically employs <code>delta = 1</code>, and <code>contrast</code> employs <code>delta = 2</code>.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_na.handling">na.handling</code></td>
<td>
<p><code>na.omit</code> or <code>na.pass</code>. 
If <code>na.handling = na.omit</code>, NAs are ignored, structural diversity metrics are calculated with less values. 
In this case the GLCM does not sum to 1.
If <code>na.handling = na.pass</code> and if there is at least one missing value inside the moving window,
an NA is assigned to the center pixel. Therefore, the diversity map will contain more 
NAs than the input raster.
Defaults to <code>na.pass</code>.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_padvalue">padValue</code></td>
<td>
<p>numeric or <code>NA</code>. The value of the padded cells at the edges of the input raster. 
Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_aroundtheglobe">aroundTheGlobe</code></td>
<td>
<p>logical. If the input raster goes around the whole globe, 
set <code>aroundTheGlobe = TRUE</code>, and the input raster will be 'glued together' from both sides
to calculate structural diversity without edge effects.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_filename">filename</code></td>
<td>
<p>character. If the output raster should be written to a file, define file name (optional).</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>verbose = TRUE</code>, a progress bar will be visible. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="strucDiv_+3A_...">...</code></td>
<td>
<p>possible further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The memory requirement of the function is determined 
by <code>raster::canProcessInMemory()</code>. 
If the raster file cannot be processed in memory, its size needs to be reduced before <code>strucDiv</code> can be used.
</p>


<h3>Value</h3>

<p>The output is a (spatial) structural diversity map, returned as a raster layer with the same dimensions as the input raster.
When <code>na.handling = na.pass</code>, then the output map will have an NA-edge of 0.5*(<code>wsl</code>-1), 
and it will contain more missing values than the input raster.
The output represents spatial structural diversity quantified on a spatial scale defined by the 
size of the moving window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Construct a small raster file containing realizations of normal random variables:
a &lt;- raster::raster(matrix(rnorm(648), 18, 36))
raster::plot(a)
# Calculate contrast:
contrast_a &lt;- strucDiv(a, wsl = 3, fun = contrast)
raster::plot(contrast_a)

# Calculate dissimilarity:
b &lt;- raster::raster(matrix(rnorm(100), 10, 10))
raster::plot(b)
dissim_b &lt;- strucDiv(b, wsl = 5, angle = "horizontal", fun = dissimilarity)
raster::plot(dissim_b)

# Calculate structural diversity entropy with delta = 2 on NDVI data binned to 15 gray levels
ndvi.15gl &lt;- raster::raster(ndvi.15gl)
sde_ndvi15 &lt;- strucDiv(ndvi.15gl, wsl = 3, fun = entropy, delta = 2)
raster::plot(sde_ndvi15)

## End(Not run)
</code></pre>

<hr>
<h2 id='strucDivDom'>Returns the structural diversity value, the gray level co-occurrence matrix (GLCM) and the structural diversity 
matrix of the domain.</h2><span id='topic+strucDivDom'></span>

<h3>Description</h3>

<p>The function <code>strucDivDom</code> returns the spatial, i.e. horizontal, structural diversity value for the domain (i.e. the input raster). 
'Spatial structural diversity' will hereafter be used synonymous to 'structural diversity'.
The function also returns the gray level co-occurrence matrix (GLCM) and the structural diversity matrix of 
the domain. Structural diversity is calculated on every element of the GLCM,
which generates the structural diversity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strucDivDom(x, dist = 1, angle = "all", rank = FALSE, fun, delta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strucDivDom_+3A_x">x</code></td>
<td>
<p>raster layer. Input raster layer for which 
structural diversity should be calculated.</p>
</td></tr>
<tr><td><code id="strucDivDom_+3A_dist">dist</code></td>
<td>
<p>integer. The distance between two pixels that should be considered as a pair, 
defaults to <code>dist = 1</code> (direct neighbors).</p>
</td></tr>
<tr><td><code id="strucDivDom_+3A_angle">angle</code></td>
<td>
<p>string. The angle on which pixels should be considered as pairs. 
Takes 5 options: <code>"horizontal"</code>, <code>"vertical"</code>, <code>"diagonal45"</code>, <code>"diagonal135"</code>, <code>"all"</code>. 
The direction-invariant version is <code>"all"</code>, which considers all of the 4 angles. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="strucDivDom_+3A_rank">rank</code></td>
<td>
<p>logical. Should pixel values be replaced with ranks in each GLCM? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="strucDivDom_+3A_fun">fun</code></td>
<td>
<p>function, the structural diversity metric. Takes one of the following: <code>entropyDom</code>,
<code>entropyNormDom</code>, <code>contrastDom</code>, <code>dissimilarityDom</code>, or <code>homogeneityDom</code>. 
Structural diversity entropy is <code>entropyDom</code> with different <code>delta</code> parameters. 
Shannon entropy is employed when <code>delta = 0</code>. 
Shannon entropy has a scale-dependent maximum. Scale-dependent means dependent on the extent of he area within which
structural diversity is quantified, because this area defines he total number of pixel pairs.
The metric <code>entropyNormDom</code> is Shannon entropy normalized over scale-dependent maximum entropy. 
Additionally, the value gradient is considered with <code>delta = 1</code> and <code>delta = 2</code>. 
The values of structural diversity entropy with <code>delta = 1</code> or <code>delta = 2</code> are not restricted 
and depend on the values of the input raster.
The metrics <code>contrastDom</code> and <code>dissimilarityDom</code> consider the value gradient,
their values are not restricted and depend on the values of the input raster.
The metric <code>homogeneityDom</code> quantifies the closeness of empirical probabilities to the diagonal and ranges between 0 and 1.</p>
</td></tr>
<tr><td><code id="strucDivDom_+3A_delta">delta</code></td>
<td>
<p>numeric, takes three options: <code>0</code>, <code>1</code>, or <code>2</code>. 
The parameter <code>delta</code> is the difference weight, 
it defines how the differences between pixel values within a pixel pair should be weighted.  
If <code>rank = TRUE</code>, delta defines how the differences between ranks should be weighted.  
Defaults to <code>0</code> (no weight). Set <code>delta = 1</code> for absolute weights, 
or <code>delta = 2</code> for square weights. 
The <code>delta</code> parameter can only be set when the metric <code>entropy</code> is used. 
the metric <code>dissimilarity</code> automatically employs <code>delta = 1</code>, and <code>contrast</code> employs <code>delta = 2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The memory requirement of the function is determined 
by <code>raster::canProcessInMemory()</code>. 
If the raster file cannot be processed in memory, its size needs to be 
reduced before <code><a href="#topic+strucDivDom">strucDivDom</a></code> can be used.
</p>


<h3>Value</h3>

<p>The output is a list containing the structural diversity value of the domain, which can be accessed with $div. 
the list also contains the gray level co-occurrence matrix ($GLCM) and the structural diversity 
matrix ($divMat) of the domain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate entropy on simulated random patch data
a &lt;- raster::raster(matrix(rnorm(100), 10, 10))
sdivDom &lt;- strucDivDom(a, angle = "vertical", fun = entropyDom)
# Structural diversity value of the domain
div &lt;- sdivDom$div
# Gray level co-occurrence matrix
glcm &lt;- sdivDom$GLCM
# Diversity matrix
divmat &lt;- sdivDom$divMat

## End(Not run)
</code></pre>

<hr>
<h2 id='strucDivNest'>Quantify Spatial Structural Diversity Across Scales in an Arbitrary Raster Layer</h2><span id='topic+strucDivNest'></span>

<h3>Description</h3>

<p>This is a wrapper function that returns a 'spatial structural diversity map' 
as a raster layer. Spatial refers to horizontal, i.e. spatially explicit, and 
'spatial structural diversity' will hereafter be used synonymous to 'structural diversity'. 
Pixels are considered as pairs in user-specified distances and angles. 
Angles include horizontal and vertical direction, and the diagonals at 45° and 135°. 
The direction-invariant version considers all angles. 
Spatial structural diversity is quantified based on the probabilities that pixel values 
are arranged in the specified way (distance and angle). The <code><a href="#topic+strucDiv">strucDiv</a></code> function employs empirical probabilities of pixel value co-occurrence. 
The <code><a href="#topic+strucDivNest">strucDivNest</a></code> function combines information from two different scales with an empirical Bayesian approach and a Beta-Binomial model.
Two scales are nested inside each other - a larger, outer scale and a smaller, inner scale. 
Three different nesting schemes are available, whereby the inner scale is always a moving window.
The outer scale can either be another mowing window, a block, or the domain (i.e. the input raster).
The outer scale is used as prior information for data on the inner scale, and structural diversity is quantified based on
posterior probabilities of pixel value co-occurrences. 
In the Beta-Binomial model both the prior and the posterior follow a beta distribution, and the likelihood follows a conditional 
binomial distribution.
Posterior probabilities are estimated with mean estimates.
The final map is called a '(spatial) structural diversity map' and is returned as a raster layer. 
The output map represents structural diversity, quantified across different spatial scales, which are defined
by the outer scale and the inner scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strucDivNest(
  x,
  wslI = NULL,
  wslO = NULL,
  dimB = FALSE,
  oLap = NULL,
  priorB = FALSE,
  domain = FALSE,
  dist = 1,
  angle = "all",
  rank = FALSE,
  fun,
  delta = 0,
  na.handling = na.pass,
  padValue = NA,
  aroundTheGlobe = FALSE,
  ncores = 1,
  verbose = TRUE,
  filename = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strucDivNest_+3A_x">x</code></td>
<td>
<p>raster layer. Input raster layer for which 
horizontal structural diversity should be calculated.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_wsli">wslI</code></td>
<td>
<p>uneven integer. The window side length of the inner scale, 
<code>wslI</code> x <code>wslI</code> defines the size of the inner moving window.
The window must be smaller than the dimensions of the input raster and smaller than the outer scale. 
Default is NULL, in which case no prior information is used.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_wslo">wslO</code></td>
<td>
<p>uneven integer.  The window side length of the outer scale, 
<code>wslO</code> x <code>wslO</code> defines the size of the outer moving window.
The window must be smaller than the dimensions of the input raster and larger than the inner scale (i.e. <code>wslI</code>). 
Defaults to <code>NULL</code>, in which case no prior information is used.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_dimb">dimB</code></td>
<td>
<p>a vector of length 2 or logical. This defines the block size (number of rows, number of columns). 
The domain (i.e. the input raster) is divided into equal size, overlapping blocks. 
Each block provides prior information for the inner window, which moves inside each block. 
Structural diversity is quantified in each block.
Blocks are merged together in a spatially weighted manner, using linear weights.
Defaults to <code>FALSE</code>, in which case no blocks are used.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_olap">oLap</code></td>
<td>
<p>integer. This defines the size of overlap between the blocks. The overlap must
be at least <code>wslI-1</code> or bigger. Blocks can overlap by a maximum of half the 
rows of blocks in row-direction, and by half the columns of blocks in column-direction.
If oLap is not specified, the minimum overlap is used.
Defaults to <code>NULL</code> in which case no blocks are used.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_priorb">priorB</code></td>
<td>
<p>logical. Should blocks be used for prior information? 
If <code>priorB = TRUE</code>, then the spatial structure in a block serves 
as prior information for the inner scale. 
If <code>priorB = FALSE</code>, then the blocks are only used to increase speed through 
parallelization, not for prior information.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_domain">domain</code></td>
<td>
<p>logical. Should the domain (i.e. the input raster) be used for prior information?
If  <code>domain = TRUE</code>, then it is used as prior for all inner moving windows.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_dist">dist</code></td>
<td>
<p>integer. The distance between two pixels that should be considered as a pair, 
defaults to <code>dist = 1</code> (direct neighbors).</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_angle">angle</code></td>
<td>
<p>string. The angle on which pixels should be considered as pairs. 
Takes 5 options: <code>"horizontal"</code>, <code>"vertical"</code>, <code>"diagonal45"</code>, <code>"diagonal135"</code>, <code>"all"</code>. 
The direction-invariant version is <code>"all"</code>, which considers all of the 4 angles. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_rank">rank</code></td>
<td>
<p>logical. Should pixel values be replaced with ranks in each GLCM? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_fun">fun</code></td>
<td>
<p>function, the structural diversity metric. Takes one of the following: <code>entropy</code>,
<code>entropyNorm</code>, <code>contrast</code>, <code>dissimilarity</code>, or <code>homogeneity</code>. 
Structural diversity entropy is <code>entropy</code> with different <code>delta</code> parameters. Shannon entropy is employed when <code>delta = 0</code>. 
Shannon entropy has a scale-dependent maximum when <code><a href="#topic+strucDiv">strucDiv</a></code> is used, but this maximum may be violated in <code><a href="#topic+strucDivNest">strucDivNest</a></code>, 
when information from different scales is combined, depending on the posterior probabilities of pixel value co-occurrences.
Additionally, the value gradient is considered with <code>delta = 1</code> and <code>delta = 2</code>. 
The values of structural diversity entropy with <code>delta = 1</code> or <code>delta = 2</code> are not restricted and depend on the values of the input raster.
the metric <code>entropyNorm</code> is Shannon entropy normalized over maximum entropy, which depends on the size of the moving window when no scales are nested. 
When information from different scales is combined in <code><a href="#topic+strucDivNest">strucDivNest</a></code>, the metric <code>entropyNorm</code> may be larger than 1, 
depending on the posterior probabilities of pixel value co-occurrences.
The metrics <code>contrast</code> and <code>dissimilarity</code> consider the value gradient, their values are not restricted and depend on the values of the input raster.
The metric <code>homogeneity</code> quantifies the closeness of empirical probabilities to the diagonal and ranges between 0 and 1 when scales are not nested. 
When information from different scales is combined in <code><a href="#topic+strucDivNest">strucDivNest</a></code>, the metric <code>homogeneity</code> may be larger than 1, 
depending on the posterior probabilities of pixel value co-occurrences.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_delta">delta</code></td>
<td>
<p>numeric, takes three options: <code>0</code>, <code>1</code>, or <code>2</code>. 
The <code>delta</code> parameter defines how the differences between pixel values within a pixel pair should be weighted.  
If <code>rank = TRUE</code>, delta defines how the differences between ranks should be weighted.  
Defaults to <code>0</code> (no weight). Set <code>delta = 1</code> for absolute weights, 
or <code>delta = 2</code> for square weights. 
The <code>delta</code> parameter can only be set when the metric <code>entropy</code> is used. 
the metric <code>dissimilarity</code> automatically employs <code>delta = 1</code>, and <code>contrast</code> employs <code>delta = 2</code>.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_na.handling">na.handling</code></td>
<td>
<p><code>na.omit</code> or <code>na.pass</code>. 
If <code>na.handling = na.omit</code>, NAs are ignored and structural diversity metrics are calculated with less values. 
If <code>na.handling = na.pass</code> and if there is at least one missing value inside the moving window,
an NA is assigned to the center pixel. Therefore, the diversity map will contain more 
NAs than the input raster layer.
Defaults to <code>na.pass</code>.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_padvalue">padValue</code></td>
<td>
<p>numeric or <code>NA</code>. The value of the padded cells at the edges of the input raster. 
Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_aroundtheglobe">aroundTheGlobe</code></td>
<td>
<p>logical. If the input raster goes around the whole globe, 
set <code>aroundTheGlobe = TRUE</code>, and the input raster will be 'glued together' from both sides
to calculate structural diversity without edge effects.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_ncores">ncores</code></td>
<td>
<p>integer. The number of cores the computation will be parallelized on.
Parallelization is only available when blocks are used. i.e. dimB must be specified. 
Parallelization can be used independent of whether blocks are used as priors or not.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>verbose = TRUE</code>, a progress bar will be visible.</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_filename">filename</code></td>
<td>
<p>character. If the output raster should be written to a file, define file name (optional).</p>
</td></tr>
<tr><td><code id="strucDivNest_+3A_...">...</code></td>
<td>
<p>possible further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The memory requirement of the function is determined 
by <code>raster::canProcessInMemory()</code>. 
If the raster file cannot be processed in memory, its size needs to be reduced before <code><a href="#topic+strucDivNest">strucDivNest</a></code> can be used.
</p>


<h3>Value</h3>

<p>The output is a (spatial) structural diversity map, returned as a raster layer.
If the outer scale is a moving window or the domain, then the output raster has the same dimensions as the input raster.
If the outer scale is a block, then the output raster may be smaller than the input raster 
because if there are edges that do not fit inside the blocks, they are cut off.
When <code>na.handling = na.pass</code>, then the output map will have an NA-edge of 0.5*(<code>wslO</code>-1), 
and it will contain more missing values than the input raster.
The output represents spatial structural diversity quantified across different spatial scale, which are defined by the 
size of the inner and the outer scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Construct a small raster file containing realizations of normal random variables:
a &lt;- raster::raster(matrix(rnorm(400), 20, 20))
raster::plot(a)
# Calculate structural diversity entropy with delta = 2, double moving window scheme
sde_1 &lt;- strucDivNest(a, wslI = 3, wslO = 5, angle = "horizontal", fun = entropy, delta = 2)
raster::plot(sde_1)

# Calculate structural diversity entropy with delta = 1, block nesting scheme 
b &lt;- raster::raster(matrix(rnorm(2500), 50, 50))
raster::plot(b)
sde_b &lt;- strucDivNest(b, wslI = 3, dimB = c(10, 10), oLap = 4, priorB = TRUE, fun = entropy, 
    delta = 1)
raster::plot(sde_b)

# Calculate entropy on simulated random patch, domain nesting scheme 
patch &lt;- raster::raster(patch)
entropy_patch &lt;- strucDivNest(patch, wslI = 5, domain = TRUE, angle = "vertical", fun = entropy)
raster::plot(entropy_patch)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
