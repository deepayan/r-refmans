<!DOCTYPE html><html><head><title>Help for package remstats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {remstats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#actor_effects'><p>actor_effects</p></a></li>
<li><a href='#aomstats'><p>aomstats</p></a></li>
<li><a href='#average'><p>average</p></a></li>
<li><a href='#baseline'><p>baseline</p></a></li>
<li><a href='#bind_remstats'><p>Combine two or more remstats objects</p></a></li>
<li><a href='#both_male_long'><p>Exogenous Dyad Attribute in Long Format: both_male_long</p></a></li>
<li><a href='#both_male_wide'><p>Exogenous Dyad Attribute Matrix: both_male_wide</p></a></li>
<li><a href='#boxplot.aomstats'><p>Plotting Relational Event Network Statistics</p></a></li>
<li><a href='#boxplot.tomstats'><p>Plotting Relational Event Network Statistics Distributions</p></a></li>
<li><a href='#degreeDiff'><p>degreeDiff</p></a></li>
<li><a href='#degreeMax'><p>degreeMax</p></a></li>
<li><a href='#degreeMin'><p>degreeMin</p></a></li>
<li><a href='#difference'><p>difference</p></a></li>
<li><a href='#event'><p>event</p></a></li>
<li><a href='#FEtype'><p>FEtype</p></a></li>
<li><a href='#history'><p>Simulated relational event history</p></a></li>
<li><a href='#indegreeReceiver'><p>indegreeReceiver</p></a></li>
<li><a href='#indegreeSender'><p>indegreeSender</p></a></li>
<li><a href='#inertia'><p>inertia</p></a></li>
<li><a href='#info'><p>Simulated exogenous information on actors in a social network.</p></a></li>
<li><a href='#isp'><p>isp</p></a></li>
<li><a href='#itp'><p>itp</p></a></li>
<li><a href='#maximum'><p>maximum</p></a></li>
<li><a href='#minimum'><p>minimum</p></a></li>
<li><a href='#osp'><p>osp</p></a></li>
<li><a href='#otp'><p>otp</p></a></li>
<li><a href='#outdegreeReceiver'><p>outdegreeReceiver</p></a></li>
<li><a href='#outdegreeSender'><p>outdegreeSender</p></a></li>
<li><a href='#plot.aomstats'><p>Plotting Relational Event Network Statistics Trajectories</p></a></li>
<li><a href='#plot.tomstats'><p>Plotting Relational Event Network Statistics Trajectories</p></a></li>
<li><a href='#print.remstats'><p>Printing Relational Event Network Statistics</p></a></li>
<li><a href='#psABA'><p>psABA</p></a></li>
<li><a href='#psABAB'><p>psABAB</p></a></li>
<li><a href='#psABAY'><p>psABAY</p></a></li>
<li><a href='#psABB'><p>psABB</p></a></li>
<li><a href='#psABBA'><p>psABBA</p></a></li>
<li><a href='#psABBY'><p>psABBY</p></a></li>
<li><a href='#psABX'><p>psABX</p></a></li>
<li><a href='#psABXA'><p>psABXA</p></a></li>
<li><a href='#psABXB'><p>psABXB</p></a></li>
<li><a href='#psABXY'><p>psABXY</p></a></li>
<li><a href='#receive'><p>receive</p></a></li>
<li><a href='#recencyContinue'><p>recencyContinue</p></a></li>
<li><a href='#recencyReceiveReceiver'><p>recencyReceiveReceiver</p></a></li>
<li><a href='#recencyReceiveSender'><p>recencyReceiveSender</p></a></li>
<li><a href='#recencySendReceiver'><p>recencySendReceiver</p></a></li>
<li><a href='#recencySendSender'><p>recencySendSender</p></a></li>
<li><a href='#reciprocity'><p>reciprocity</p></a></li>
<li><a href='#remstats'><p>remstats</p></a></li>
<li><a href='#rrankReceive'><p>rrankReceive</p></a></li>
<li><a href='#rrankSend'><p>rrankSend</p></a></li>
<li><a href='#same'><p>same</p></a></li>
<li><a href='#send'><p>send</p></a></li>
<li><a href='#sp'><p>sp</p></a></li>
<li><a href='#spUnique'><p>spUnique</p></a></li>
<li><a href='#summary.remstats'><p>Relational Event Network Statistics Summaries</p></a></li>
<li><a href='#tie'><p>tie</p></a></li>
<li><a href='#tie_effects'><p>tie_effects</p></a></li>
<li><a href='#tomstats'><p>tomstats</p></a></li>
<li><a href='#totaldegreeDyad'><p>totaldegreeDyad</p></a></li>
<li><a href='#totaldegreeReceiver'><p>totaldegreeReceiver</p></a></li>
<li><a href='#totaldegreeSender'><p>totaldegreeSender</p></a></li>
<li><a href='#userStat'><p>userStat</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computes Statistics for Relational Event History Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giuseppe Arena &lt;g.arena@tilburguniversity.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes a variety of statistics for relational event models. Relational event models enable researchers to investigate both exogenous and endogenous factors influencing the evolution of a time-ordered sequence of events. These models are categorized into tie-oriented models (Butts, C., 2008, &lt;<a href="https://doi.org/10.1111%2Fj.1467-9531.2008.00203.x">doi:10.1111/j.1467-9531.2008.00203.x</a>&gt;), where the probability of a dyad interacting next is modeled in a single step, and actor-oriented models (Stadtfeld, C., &amp; Block, P., 2017, &lt;<a href="https://doi.org/10.15195%2Fv4.a14">doi:10.15195/v4.a14</a>&gt;), which first model the probability of a sender initiating an interaction and subsequently the probability of the sender's choice of receiver. The package is designed to compute a variety of statistics that summarize exogenous and endogenous influences on the event stream for both types of models.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tilburgnetworkgroup.github.io/remstats/">https://tilburgnetworkgroup.github.io/remstats/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TilburgNetworkGroup/remstats/issues">https://github.com/TilburgNetworkGroup/remstats/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8.3), stats, graphics, grDevices</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, remify (&ge; 3.2.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-14 15:39:19 UTC; giuseppe</td>
</tr>
<tr>
<td>Author:</td>
<td>Giuseppe Arena <a href="https://orcid.org/0000-0001-5204-3326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Marlyne Meijerink-Bosman [aut],
  Diana Karimova [ctb],
  Rumana Lakdawala [ctb],
  Mahdi Shafiee Kamalabad [ctb],
  Fabio Generoso Vieira [ctb],
  Roger Leenders [ctb],
  Joris Mulder [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-15 09:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='actor_effects'>actor_effects</h2><span id='topic+actor_effects'></span>

<h3>Description</h3>

<p>Overview of statistics in the actor-oriented model, see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actor_effects(step = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actor_effects_+3A_step">step</code></td>
<td>
<p>outputs all statistics in the sender activity step (if 'step =
sender') or receiver choice step (if 'step = receiver').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Overview of statistics in the actor-oriented model.
</p>
<p>A list of available effects and their corresponding statistics for the
<em>sender activity rate</em> step:
</p>

<ul>
<li> <p><code><a href="#topic+baseline">baseline</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+send">send</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+indegreeSender">indegreeSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+outdegreeSender">outdegreeSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+totaldegreeSender">totaldegreeSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencySendSender">recencySendSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABA">psABA</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABB">psABB</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABX">psABX</a>()</code>
</p>
</li></ul>

<p>A list of available effects and their corresponding statistics for the
<em>receiver choice</em> step:
</p>

<ul>
<li> <p><code><a href="#topic+receive">receive</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+tie">tie</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+same">same</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+difference">difference</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+average">average</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+indegreeReceiver">indegreeReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+outdegreeReceiver">outdegreeReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+totaldegreeReceiver">totaldegreeReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+inertia">inertia</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+reciprocity">reciprocity</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+otp">otp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+itp">itp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+osp">osp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+isp">isp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+rrankSend">rrankSend</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+rrankReceive">rrankReceive</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencySendReceiver">recencySendReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencyReceiveReceiver">recencyReceiveReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencyContinue">recencyContinue</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABAB">psABAB</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABBA">psABBA</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABXA">psABXA</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABXB">psABXB</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABAY">psABAY</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABBY">psABBY</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABXY">psABXY</a>()</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a list of available effects and their corresponding statistics based 
on the specified 'step' (sender or receiver).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List of available effects for both the sender and receiver step
actor_effects()

# List of available effects for the sender step
actor_effects(step = "sender")

# List of available effects for the receiver step
actor_effects(step = "receiver")

</code></pre>

<hr>
<h2 id='aomstats'>aomstats</h2><span id='topic+aomstats'></span>

<h3>Description</h3>

<p>Computes statistics for the sender activity rate step and receiver choice
step in actor-oriented relational event models (e.g., see Stadtfeld &amp; Block,
2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aomstats(
  reh,
  sender_effects = NULL,
  receiver_effects = NULL,
  attr_actors = NULL,
  attr_dyads = NULL,
  method = c("pt", "pe"),
  memory = c("full", "window", "decay", "interval"),
  memory_value = Inf,
  start = 1,
  stop = Inf,
  display_progress = FALSE,
  attr_data,
  attributes,
  edgelist
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aomstats_+3A_reh">reh</code></td>
<td>
<p>an object of class <code>"<a href="remify.html#topic+remify">remify</a>"</code> characterizing 
the relational event history.</p>
</td></tr>
<tr><td><code id="aomstats_+3A_sender_effects">sender_effects</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or
one that can be coerced to that class): a symbolic description of the
effects in the sender activity rate step of the actor-oriented model for
which statistics are computed, see &lsquo;Details&rsquo;</p>
</td></tr>
<tr><td><code id="aomstats_+3A_receiver_effects">receiver_effects</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code>
(or one that can be coerced to that class): a symbolic description of the
effects in the receiver choice step of model for which statistics are
computed, see &lsquo;Details&rsquo;</p>
</td></tr>
<tr><td><code id="aomstats_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code>"<a href="base.html#topic+data.frame">data.frame</a>"</code> that contains exogenous attributes for 
actors (see Details).</p>
</td></tr>
<tr><td><code id="aomstats_+3A_attr_dyads">attr_dyads</code></td>
<td>
<p>optionally, an object of class <code>data.frame</code> or 
<code>matrix</code> containing attribute information for dyads (see Details).</p>
</td></tr>
<tr><td><code id="aomstats_+3A_method">method</code></td>
<td>
<p>Specifies the method for managing simultaneous events, i.e., 
events occurring at the same time. The default 'method' is 'pt' (per 
timepoint), where statistics are computed once for each unique timepoint in 
the edgelist. Alternatively, you can choose 'pe' (per event), where 
statistics are computed once for each unique event observed in the edgelist.</p>
</td></tr>
<tr><td><code id="aomstats_+3A_memory">memory</code></td>
<td>
<p>The memory to be used. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="aomstats_+3A_memory_value">memory_value</code></td>
<td>
<p>Numeric value indicating the memory parameter. See
&lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="aomstats_+3A_start">start</code></td>
<td>
<p>an optional integer value, specifying the index of the first
time or event in the relational event history for which statistics must be 
computed (see 'Details')</p>
</td></tr>
<tr><td><code id="aomstats_+3A_stop">stop</code></td>
<td>
<p>an optional integer value, specifying the index of the last
time or event in the relational event history for which statistics must be 
computed (see 'Details')</p>
</td></tr>
<tr><td><code id="aomstats_+3A_display_progress">display_progress</code></td>
<td>
<p>should a progress bar for the computation of the
endogenous statistics be shown (TRUE) or not (FALSE)?</p>
</td></tr>
<tr><td><code id="aomstats_+3A_attr_data">attr_data</code></td>
<td>
<p>deprecated, please use &quot;attr_actors&quot; instead</p>
</td></tr>
<tr><td><code id="aomstats_+3A_attributes">attributes</code></td>
<td>
<p>deprecated, please use &quot;attr_data&quot; instead</p>
</td></tr>
<tr><td><code id="aomstats_+3A_edgelist">edgelist</code></td>
<td>
<p>deprecated, please use &quot;reh&quot; instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'aomstats'. List with in the first element the statistics for the sender activity rate step and in the second element the statistics for the receiver choice step. The 'aomstats' object has the 
following attributes: 
</p>

<dl>
<dt><code>model</code></dt><dd><p>Type of model that is estimated.</p>
</dd>
<dt><code>formula</code></dt><dd><p>Model formula(s), obtained from the formula(s) inputted to 'sender_effects' and/or 'receiver_effects'.</p>
</dd>
<dt><code>actors</code></dt><dd><p>The set of actors used to construct the statistics, obtained from the remify object inputted to 'reh'.</p>
</dd>
</dl>



<h3>Effects</h3>

<p>The statistics to be computed are defined symbolically and should be
supplied to the <code>sender_effects</code> and/or <code>receiver_effects</code>
arguments in the form <code>~ effects</code>. The terms are separated by +
operators. For example: <code>receiver_effects = ~ inertia() + otp()</code>.
Interactions between two effects can be included with * or :
operators. For example: <code>receivereffects = ~ inertia():otp()</code>.  A list
of available effects can be obtained with <code><a href="#topic+actor_effects">actor_effects</a>()</code>.
</p>
<p>The majority of the statistics can be scaled in some way, see
the documentation of the <code>scaling</code> argument in the separate effect
functions for more information on this.
</p>


<h3>attr_actors</h3>

<p>For the computation of the <em>exogenous</em> statistics an attributes object
with the exogenous covariate information has to be supplied to the
<code>attr_actors</code> argument in either <code>remstats()</code> or in the separate
effect functions supplied to the <code>..._effects</code> arguments (e.g., see
<code><a href="#topic+send">send</a></code>). This <code>attr_actors</code> object should be constructed as
follows: A dataframe with rows referring to the attribute value of actor
<em>i</em> at timepoint <em>t</em>. A 'name' column is required that contains the
actor name (corresponding to the actor names in the relational event
history). A 'time' column is required that contains the time when attributes
change (set to zero if none of the attributes vary over time). Subsequent
columns contain the attributes that are called in the specifications of
exogenous statistics (column name corresponding to the string supplied to
the <code>variable</code> argument in the effect function). Note that the
procedure for the exogenous effects &lsquo;tie&rsquo; and &lsquo;event&rsquo; deviates from this,
here the exogenous covariate information has to be specified in a different
way, see <code><a href="#topic+tie">tie</a></code> and <code><a href="#topic+event">event</a></code>.
</p>


<h3>attr_dyads</h3>

<p>For the computation of the <em>dyad exogenous</em> statistics with <code>tie()</code>, an attributes object with the exogenous covariates information per dyad has to be supplied. This is a <code>data.frame</code> or <code>matrix</code> containing attribute information for dyads. If <code>attr_dyads</code> is a <code>data.frame</code>, the first two columns should represent &quot;actor1&quot; and &quot;actor2&quot; (for directed events, &quot;actor1&quot; corresponds to the sender, and &quot;actor2&quot; corresponds to the receiver). Additional columns can represent dyads' exogenous attributes. If attributes vary over time, include a column named &quot;time&quot;. If <code>attr_dyads</code> is a <code>matrix</code>, the rows correspond to &quot;actor1&quot;, columns to &quot;actor2&quot;, and cells contain dyads' exogenous attributes.
</p>


<h3>Memory</h3>

<p>The default 'memory' setting is '&quot;full&quot;', which implies that at each time
point $t$ the entire event history before $t$ is included in the computation
of the statistics. Alternatively, when 'memory' is set to '&quot;window&quot;', only
the past event history within a given time window is considered (see
Mulders &amp; Leenders, 2019). This length of this time window is set by the
'memory_value' parameter. For example, when 'memory_value = 100' and 'memory
= &quot;window&quot;', at time point $t$ only the past events that happened at most
100 time units ago are included in the computation of the statistics.
A third option is to set 'memory' to '&quot;interval&quot;'. In this case, the past
event history within a given time interval is considered. For example, when
'&quot;memory_value&quot; = c(50, 100)' and 'memory = &quot;window&quot;', at time point $t$
only the past events that happened between 50 and 100 time units ago are
included in the computation of the statistics. Finally, the fourth option is
to set 'memory' to '&quot;decay&quot;'. In this case, the weight of the past event in
the computation of the statistics depend on the elapsed time between $t$ and
the past event. This weight is determined based on an exponential decay
function with half-life parameter 'memory_value' (see Brandes et al., 2009).
</p>


<h3>Event weights</h3>

<p>Note that if the relational event history contains a column that is named
&ldquo;weight&rdquo;, it is assumed that these affect the endogenous statistics. These
affect the computation of all endogenous statistics with a few exceptions
that follow logically from their definition (e.g., the recenyContinue
statistic does depend on time since the event and not on event weights).
</p>


<h3>Subset of the relational event history</h3>

<p>Optionally, statistics can be computed for a slice of the relational event
sequence - but based on the entire history. This is achieved by setting the
start and stop values equal to the index of the first and last event for
which statistics are requested. For example, start = 5 and stop = 5 computes
the statistics for only the 5th event in the relational event sequence,
based on the history that consists of events 1-4.
</p>


<h3>References</h3>

<p>Stadtfeld, C., &amp; Block, P. (2017). Interactions, actors, and
time: Dynamic network actor models for relational events. Sociological
Science, 4, 318–352. <a href="https://doi.org/10.15195/v4.a14">doi:10.15195/v4.a14</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(remstats)

# Load the data
data(history)
data(info)

# Prepare the data
reh &lt;- remify::remify(edgelist = history, model = "actor")

# Define the sender effects
seff &lt;- ~ send("extraversion")

# Define the receiver_effects
reff &lt;- ~ receive("agreeableness") + inertia() + otp()

# Compute the statistics
aomstats(
  reh = reh, sender_effects = seff, receiver_effects = reff,
  attr_actors = info
)

</code></pre>

<hr>
<h2 id='average'>average</h2><span id='topic+average'></span>

<h3>Description</h3>

<p>Specifies the statistic for an &quot;average&quot; effect in the tie-oriented model or
the receiver choice step of the actor-oriented model. An &quot;average&quot; effect
refers to an exogenous actor attribute that affects dyad <em>(i,j)</em>'s rate
of interacting (tie-oriented model) or actor <em>j</em>'s probability of being
chosen as a receiver for the event send by the active sender <em>i</em> at
time <em>t</em> (actor-oriented model) based on the average of the values of
actors <em>i</em> and <em>j</em> on this attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average(variable, attr_actors = NULL, scaling = c("none", "std"), attr_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_+3A_variable">variable</code></td>
<td>
<p>string with the name of the column in the
<code>attr_actors</code> object for which the statistic has to be computed.</p>
</td></tr>
<tr><td><code id="average_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the attribute, see
'Details.'</p>
</td></tr>
<tr><td><code id="average_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the statistic. Default is to not scale
the statistic. Alternatively, standardization of the
statistic per time point can be requested with &quot;std&quot;.</p>
</td></tr>
<tr><td><code id="average_+3A_attr_data">attr_data</code></td>
<td>
<p>Deprecated argument. Please use 'attr_actors' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic at timepoint <em>t</em> for dyad <em>(i,j)</em> is equal to the
average of the values of actor <em>i</em> and <em>j</em> on the attribute at
timepoint <em>t</em>.
</p>
<p>Construct the 'attr_actors' object as a data frame where each row represents 
the attribute value of actor <em>i</em> at timepoint <em>t</em>:
</p>

<ul>
<li><p>name: The actors' name.
</p>
</li>
<li><p>time: The time when the attribute values change.
</p>
</li>
<li><p>variable: The third column contains the attribute used in the
specification of the &quot;difference&quot; effect. The column name should correspond
to the string supplied to the <code>variable</code> argument in the 'difference()'
function.
</p>
</li></ul>

<p>Note that it is possible to omit the 'attr_actors' object in the call of
<code>difference()</code> and, instead, supply it in the call of <code>remstats()</code>
for multiple exogenous effects.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ average("extraversion")
remstats(reh = reh_tie, tie_effects = effects, attr_actors = info)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects, attr_actors = info)

</code></pre>

<hr>
<h2 id='baseline'>baseline</h2><span id='topic+baseline'></span><span id='topic+intercept'></span>

<h3>Description</h3>

<p>Specifies an intercept for the tie-oriented model or the sender activity
rate step of the actor-oriented model in the same manner as in
<code><a href="stats.html#topic+lm">lm</a></code> (see Details).
</p>


<h3>Details</h3>

<p>A baseline effect is automatically specified for the tie-oriented model and
the sender activity rate step of the actor-oriented model when the
<code>ordinal</code> argument in <code><a href="#topic+remstats">remstats</a></code>, <code><a href="#topic+tomstats">tomstats</a></code>,
<code><a href="#topic+aomstats">aomstats</a></code> is set to FALSE (default) and automatically removed
when this argument is set to TRUE. Alternatively, a baseline effect can be
explicitly specified by adding '1' to the equation or explicitly removed by
adding '-1' to the equation.
</p>
<p>The baseline effect refers to the baseline tendency to interact. In the
tie-oriented model, the log-inverse of the estimated parameter translates to
the average number of observed events per time unit per dyad. In the
actor-oriented model, the log-inverse of the estimated parameter translates
to the average number of observed events per time unit per actor. The
statistic is equal to one for all dyads resp. actors in the riskset at all
timepoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
remstats(reh = reh_tie, tie_effects = ~1)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, sender_effects = ~1)
</code></pre>

<hr>
<h2 id='bind_remstats'>Combine two or more remstats objects</h2><span id='topic+bind_remstats'></span>

<h3>Description</h3>

<p>Function to bind any number of remstats objects into one while duplicated
statistics in the combined object are removed based on their name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_remstats(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_remstats_+3A_...">...</code></td>
<td>
<p>Any number of <code><a href="#topic+remstats">remstats</a></code> objects. All the
<code>remstats</code> objects must have matching dimensions, except for the third
dimension. Note that duplicated statistics in the combined object are 
removed based on their name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>statistics </code> array with the combined statistics, where rows
refer to time points, columns refer to potential relational event (i.e.,
potential edges) in the risk set and slices refer to statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(remstats)

# Load the data
data(history)
data(info)

# Prepare the data
reh &lt;- remify::remify(edgelist = history, model = "actor")

# Obtain two different statistics objects
effects1 &lt;- ~ inertia():receive("extraversion") + otp()
stats1 &lt;- remstats(receiver_effects = effects1, reh = reh, attr_actors = info)
effects2 &lt;- ~ reciprocity()
stats2 &lt;- remstats(receiver_effects = effects2, reh = reh, attr_actors = info)

# Bind the two statistics objects
statsC &lt;- bind_remstats(stats1, stats2)

</code></pre>

<hr>
<h2 id='both_male_long'>Exogenous Dyad Attribute in Long Format: both_male_long</h2><span id='topic+both_male_long'></span>

<h3>Description</h3>

<p>A data frame representing exogenous attributes of dyads in a social network in long format. Each row indicates whether a dyad consists of two male actors (sex=0) in the original matrix 'info_both_male_wide'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(both_male_long)
</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>actor1</dt><dd><p>Numeric id of the first actor in the dyad.</p>
</dd>
<dt>actor2</dt><dd><p>Numeric id of the second actor in the dyad.</p>
</dd>
<dt>both_male</dt><dd><p>Binary indicator (1 for male-male dyads, 0 otherwise).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated exogenous information on actors in a social network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tie">tie</a></code> for the function using this data, <code><a href="#topic+both_male_wide">both_male_wide</a></code> for the data in wide format, and <code><a href="#topic+info">info</a></code> for an overview of the actor exogenous attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(both_male_long)
head(both_male_long)

</code></pre>

<hr>
<h2 id='both_male_wide'>Exogenous Dyad Attribute Matrix: both_male_wide</h2><span id='topic+both_male_wide'></span>

<h3>Description</h3>

<p>A matrix representing exogenous attributes of dyads in a social network.
The matrix indicates whether a dyad consists of two male actors (sex=0).
Rows and columns correspond to actor IDs, and cells contain binary values
(1 for male-male dyads, 0 otherwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(both_male_wide)
</code></pre>


<h3>Format</h3>

<p>A square matrix with dimensions equal to the number of unique actors.
</p>


<h3>Source</h3>

<p>Simulated exogenous information on actors in a social network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tie">tie</a></code> for the function using this data, <code><a href="#topic+both_male_long">both_male_long</a></code> for the data in long format, and <code><a href="#topic+info">info</a></code> for an overview of the actor exogenous attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(both_male_wide)
print(both_male_wide)

</code></pre>

<hr>
<h2 id='boxplot.aomstats'>Plotting Relational Event Network Statistics</h2><span id='topic+boxplot.aomstats'></span>

<h3>Description</h3>

<p>Generate boxplots for a specified effect in a <code><a href="#topic+aomstats">aomstats</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aomstats'
boxplot(
  x,
  effect,
  model,
  by = "timepoints",
  subset = NULL,
  outliers = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.aomstats_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+aomstats">aomstats</a></code> containing relational
event network statistics.</p>
</td></tr>
<tr><td><code id="boxplot.aomstats_+3A_effect">effect</code></td>
<td>
<p>A string specifying the name of the effect in 'x' or an integer
indicating the index of the effect to be plotted.</p>
</td></tr>
<tr><td><code id="boxplot.aomstats_+3A_model">model</code></td>
<td>
<p>A string indicating whether the effect is in the 'sender' model
or the 'receiver' model.</p>
</td></tr>
<tr><td><code id="boxplot.aomstats_+3A_by">by</code></td>
<td>
<p>A string indicating whether the statistic is plotted across
'timepoints' (default) or 'actors'.</p>
</td></tr>
<tr><td><code id="boxplot.aomstats_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of timepoints or actors
to be used for plotting. Per default, a maximum of 20 unique timepoints or 
actors are plotted.</p>
</td></tr>
<tr><td><code id="boxplot.aomstats_+3A_outliers">outliers</code></td>
<td>
<p>A logical value specifying whether to include outliers in the
plot.</p>
</td></tr>
<tr><td><code id="boxplot.aomstats_+3A_...">...</code></td>
<td>
<p>additional arguments passed to bxp().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces boxplots to visually represent the distribution of a
specified effect in a relational event network, as captured by a
<code><a href="#topic+aomstats">aomstats</a></code> object. The 'effect' parameter allows the user to
choose a specific effect for visualization, either by providing the effect's
name or its index within the 'aomstats' object. The 'model' parameter
indicates whether the respective effect is in the 'sender' model or the
'receiver' model. The 'by' parameter determines whether the boxplots are
created across different 'timepoints' or 'actors'. At the moment, by 'actors'
is only supported for the sender model. Additionally, an optional 'subset'
parameter allows the user to focus on specific timepoints or actors. If
'subset' is not specified, a default maximum of 20 unique timepoints or
actors are plotted. The 'outliers' argument, when set to TRUE, includes the
representation of outliers in the boxplots. If set to FALSE, outliers are
omitted from the visualization.
</p>
<p>The boxplots are based on the following summary statistics of the data: The
box in the middle represents the interquartile range (IQR) between the first
(Q1) and third quartile (Q3), and the line inside the box represents the
median. The whiskers extend from the box to the minimum and maximum values
within 1.5 times the IQR below Q1 or above Q3. Outliers beyond the whiskers
are plotted individually.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(remstats)
# Load data
data(history)
# Prepare data
reh &lt;- remify::remify(edgelist = history[,1:3], model = "actor")
# Compute effects
stats &lt;- remstats(reh, sender_effects = ~ outdegreeSender())
# Plot the 'outdegreeSender' distribution for 20 timepoints
boxplot(stats, effect = "outdegreeSender", model = "sender")
# Plot the 'inertia' distribution for all 10 actors
boxplot(stats, effect = "outdegreeSender", model = "sender", by = "actors")

</code></pre>

<hr>
<h2 id='boxplot.tomstats'>Plotting Relational Event Network Statistics Distributions</h2><span id='topic+boxplot.tomstats'></span>

<h3>Description</h3>

<p>Generate boxplots for a specified effect in a <code><a href="#topic+tomstats">tomstats</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tomstats'
boxplot(x, effect, by = "timepoints", subset = NULL, outliers = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.tomstats_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+tomstats">tomstats</a></code> containing relational
event network statistics.</p>
</td></tr>
<tr><td><code id="boxplot.tomstats_+3A_effect">effect</code></td>
<td>
<p>A character string specifying the name of the effect in 'x' or
an integer indicating the index of the effect to be plotted.</p>
</td></tr>
<tr><td><code id="boxplot.tomstats_+3A_by">by</code></td>
<td>
<p>A string indicating whether the statistic is plotted across
'timepoints' (default) or 'dyads'.</p>
</td></tr>
<tr><td><code id="boxplot.tomstats_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of timepoints or dyads
to be used for plotting. Per default, a maximum of 20 unique timepoints or 
dyads are plotted.</p>
</td></tr>
<tr><td><code id="boxplot.tomstats_+3A_outliers">outliers</code></td>
<td>
<p>A logical value specifying whether to include outliers in the
plot.</p>
</td></tr>
<tr><td><code id="boxplot.tomstats_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to bxp().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces boxplots to visually represent the distribution of a
specified effect in a relational event network, as captured by a
<code><a href="#topic+tomstats">tomstats</a></code> object. The 'effect' parameter allows the user to
choose a specific effect for visualization, either by providing the effect's
name or its index within the 'tomstats' object. The 'by' parameter determines
whether the boxplots are created across different 'timepoints' or 'dyads'.
Additionally, an optional 'subset' parameter allows the user to focus on
specific timepoints or dyads. If 'subset' is not specified, a default
maximum of 20 unique timepoints or dyads are plotted. The 'outliers'
argument, when set to TRUE, includes the representation of outliers in the
boxplots. If set to FALSE, outliers are omitted from the visualization.
</p>
<p>The boxplots are based on the following summary statistics of the data: The
box in the middle represents the interquartile range (IQR) between the first
(Q1) and third quartile (Q3), and the line inside the box represents the
median. The whiskers extend from the box to the minimum and maximum values
within 1.5 times the IQR below Q1 or above Q3. Outliers beyond the whiskers
are plotted individually.
</p>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(remstats)
# Load data
data(history)
# Prepare data
reh &lt;- remify::remify(edgelist = history[,1:3], model = "tie")
# Compute effects
stats &lt;- remstats(reh, tie_effects = ~ inertia())
# Plot the 'inertia' distribution for 20 timepoints
boxplot(stats, effect = "inertia")
# Plot the 'inertia' distribution for 20 dyads
boxplot(stats, effect = "inertia", by = "dyads")
# Plot the 'inertia' distribution for dyads 2:5
boxplot(stats, effect = "inertia", by = "dyads", subset = 2:5)

</code></pre>

<hr>
<h2 id='degreeDiff'>degreeDiff</h2><span id='topic+degreeDiff'></span>

<h3>Description</h3>

<p>Specifies the statistic for a 'degreeDiff' effect in the tie-oriented
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degreeDiff(scaling = c("none", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degreeDiff_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is to
not scale the statistic (scaling = &quot;none&quot;). Alternatively, standardization
of the degree difference per time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="degreeDiff_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A degreeDiff effect refers to the tendency for dyads to increase their
interaction rate if the absolute difference in degree for the two actors in
the pair increases. The statistic at timepoint <em>t</em> for dyad
<em>(i,j)</em> is equal to the difference between the following two values:
the number of events before timepoint <em>t</em> that involved actor <em>i</em>
and actor <em>j</em>, respectively. The degreeDiff effect is only defined for
undirected events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degreeMin">degreeMin</a></code>, <code><a href="#topic+degreeMax">degreeMax</a></code> or
<code><a href="#topic+totaldegreeDyad">totaldegreeDyad</a></code> for other types of degree effects for
undirected events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie", directed = FALSE)
effects &lt;- ~ degreeDiff()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='degreeMax'>degreeMax</h2><span id='topic+degreeMax'></span>

<h3>Description</h3>

<p>Specifies the statistic for an 'degreeMax' effect in the tie-oriented
model with undirected events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degreeMax(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degreeMax_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by two times the number of past events at
time t can be requested with 'prop' or standardization of the raw degree
counts per time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="degreeMax_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An degreeMax effect refers to the tendency for dyads to increase their
interaction rate if the total degree of the most active actor in the pair
increases. The statistic at timepoint <em>t</em> for dyad <em>(i,j)</em> is
equal to the maximum of the following two values: the number of events
before timepoint <em>t</em> that involved actor <em>i</em> and actor <em>j</em>,
respectively. Note that the degreeMax effect is only defined for undirected
events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
degree count by the total number of past events, the statistic refers to the
fraction of past events that the most active actor was involved in. At the
first time point, when no events did previously occur, it is assumed that
every actor is equally likely to be involved in an event and the statistic
is set equal to 1/n, where n refers to the number of actors.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degreeDiff">degreeDiff</a></code>, <code><a href="#topic+degreeMin">degreeMin</a></code> or
<code><a href="#topic+totaldegreeDyad">totaldegreeDyad</a></code> for other types of degree effects for
undirected events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie", directed = FALSE)
effects &lt;- ~ degreeMax()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='degreeMin'>degreeMin</h2><span id='topic+degreeMin'></span>

<h3>Description</h3>

<p>Specifies the statistic for an 'degreeMin' effect in the tie-oriented
model with undirected events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degreeMin(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degreeMin_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by two times the number of past events at
time t can be requested with 'prop' or standardization of the raw degree
counts per time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="degreeMin_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An degreeMin effect refers to the tendency for dyads to increase their
interaction rate if the total degree of the least active actor in the pair
increases. The statistic at timepoint <em>t</em> for dyad <em>(i,j)</em> is
equal to the minimum of the following two values: the number of events
before timepoint <em>t</em> that involved actor <em>i</em> and actor <em>j</em>,
respectively. Note that the degreeMin effect is only defined for undirected
events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
degree count by the total number of past events, the statistic refers to the
fraction of past events that the least active actor was involved in. At the
first time point, when no events did previously occur, it is assumed that
every actor is equally likely to be involved in an event and the statistic
is set equal to 1/n, where n refers to the number of actors.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degreeDiff">degreeDiff</a></code>, <code><a href="#topic+degreeMax">degreeMax</a></code> or
<code><a href="#topic+totaldegreeDyad">totaldegreeDyad</a></code> for other types of degree effects for
undirected events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie", directed = FALSE)
effects &lt;- ~ degreeMin()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='difference'>difference</h2><span id='topic+difference'></span>

<h3>Description</h3>

<p>Specifies the statistic for a &quot;difference&quot; effect in the tie-oriented model
or the receiver choice step of the actor-oriented model. A difference effect
refers to an exogenous actor attribute that affects dyad <em>(i,j)</em>'s rate
of interacting (tie-oriented model) or actor <em>j</em>'s probability of being
chosen as a receiver for the event send by the active sender <em>i</em> at
time <em>t</em> (actor-oriented model) based on the difference between the
values of actors <em>i</em> and <em>j</em> on this attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difference(
  variable,
  attr_actors = NULL,
  scaling = c("none", "std"),
  absolute = TRUE,
  attr_data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference_+3A_variable">variable</code></td>
<td>
<p>string with the name of the column in the
<code>attr_actors</code> object for which the statistic has to be computed.</p>
</td></tr>
<tr><td><code id="difference_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the attribute, see
'Details.'</p>
</td></tr>
<tr><td><code id="difference_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the statistic. Default is to not scale
the statistic. Alternatively, standardization of the
statistic per time point can be requested with &quot;std&quot;.</p>
</td></tr>
<tr><td><code id="difference_+3A_absolute">absolute</code></td>
<td>
<p>Logical value indicating whether the difference values
should be converted to the absolute difference (default is TRUE).</p>
</td></tr>
<tr><td><code id="difference_+3A_attr_data">attr_data</code></td>
<td>
<p>Deprecated argument. Please use 'attr_actors' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic at timepoint <em>t</em> is equal to the (absolute) difference
between the values of actor <em>i</em> and <em>j</em> on the attribute at
timepoint <em>t</em>.
</p>
<p>Construct the 'attr_actors' object as a data frame where each row represents 
the attribute value of actor <em>i</em> at timepoint <em>t</em>:
</p>

<ul>
<li><p>name: The actors' name.
</p>
</li>
<li><p>time: The time when the attribute values change.
</p>
</li>
<li><p>variable: The third column contains the attribute used in the
specification of the &quot;difference&quot; effect. The column name should correspond
to the string supplied to the <code>variable</code> argument in the 'difference()'
function.
</p>
</li></ul>

<p>Note that it is possible to omit the 'attr_actors' object in the call of
<code>difference()</code> and, instead, supply it in the call of <code>remstats()</code>
for multiple exogenous effects.
</p>
<p>Note that it is possible to omit the 'attr_actors' object in the call of
<code>difference()</code> and, instead, supply it in the call of <code>remstats()</code>
for multiple exogenous effects.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example for tie-oriented model
reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ difference("extraversion", absolute = TRUE)
remstats(reh = reh_tie, tie_effects = effects, attr_actors = info)

# Example for actor-oriented model
reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects, attr_actors = info)

</code></pre>

<hr>
<h2 id='event'>event</h2><span id='topic+event'></span>

<h3>Description</h3>

<p>Specifies the statistic for an &quot;event&quot; effect in the tie-oriented model. An
&quot;event&quot; effect refers to an exogenous event attribute that affects the
waiting time between events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event(x, variableName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_+3A_x">x</code></td>
<td>
<p>vector with the event attribute</p>
</td></tr>
<tr><td><code id="event_+3A_variablename">variableName</code></td>
<td>
<p>optionally, a string indicating the variable name, used
for the dimnames of the output statistics object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic at timepoint <em>t</em> is for all dyads in the risk set equal
to the attribute of the event at timepoint <em>t</em>.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FEtype">FEtype</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  reh_tie &lt;- remify::remify(history, model = "tie")
  data(history, package = "remstats")
  history$work &lt;- ifelse(history$setting == "work", 1, 0)
  effects &lt;- ~ event(x = history$work, variableName = "setting_is_work")
  remstats(reh = reh_tie, tie_effects = effects)


</code></pre>

<hr>
<h2 id='FEtype'>FEtype</h2><span id='topic+FEtype'></span>

<h3>Description</h3>

<p>Specifies the statistic for fixed effects for event types in the
tie-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEtype()
</code></pre>


<h3>Details</h3>

<p>Fixed effects for event types capture the variation in event rate across
different event types (e.g., see Butts, 2008). The specification of FEtype
results in the creation of C-1 statistics, were C is the number of different
event types in the riskset. Let one of the event types, e.g. <em>c = 1</em>,
represent the reference category. Than, for every event type
<em>c = 2, ..., C</em>, a statistic is created that at timepoint <em>t</em> for
dyad <em>(i,j,c)</em> is equal to 1 if <em>c</em> is equal to the respective
event type and equal to 0 otherwise (i.e., dummy variables are created).
Note that specifying fixed effects for event types is only available when
event types are modeled in the dependent variable.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event">event</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>history$type &lt;- history$setting
reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ FEtype()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='history'>Simulated relational event history</h2><span id='topic+history'></span>

<h3>Description</h3>

<p>A dataset containing a small example of a relational event history. Data is 
simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(history)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 115 rows and 5 variables:
</p>

<dl>
<dt>time</dt><dd><p>time of the event since onset of observation (e.g., in minutes)</p>
</dd>
<dt>actor1</dt><dd><p>the first actor involved in the event</p>
</dd>
<dt>actor2</dt><dd><p>the second actor involved in the event</p>
</dd>
<dt>setting</dt><dd><p>the setting for the event</p>
</dd>
<dt>weight</dt><dd><p>the intensity of the event (e.g., based on the duration)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated relational event history for actors in a social network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+info">info</a></code> for exogenous information on the actors in 
the social network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(history)

</code></pre>

<hr>
<h2 id='indegreeReceiver'>indegreeReceiver</h2><span id='topic+indegreeReceiver'></span>

<h3>Description</h3>

<p>Specifies the statistic for an 'indegreeReceiver' effect in the tie-oriented
model or the receiver choice step of the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indegreeReceiver(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indegreeReceiver_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by the number of past events at time t can
be requested with 'prop' or standardization of the raw degree counts per
time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="indegreeReceiver_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An indegree of the receiver effect refers to the tendency for actors to
receive events if they have received more past events. The statistic at
timepoint <em>t</em> for dyad <em>(i,j)</em> (tie-oriented model) or
receiver <em>j</em> (actor-oriented model) is equal to the number of events
received by actor <em>j</em> before timepoint <em>t</em>. Note that the
'indegreeReceiver' effect is only defined for directed events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
degree count by the total number of past events, the statistic refers to the
fraction of past events that were received by actor j. At the first time
point, when no events did previously occur, it is assumed that every actor
is equally likely to receive a message and the statistic is set equal to 1/
n, where n refers to the number of actors.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indegreeSender">indegreeSender</a></code>, <code><a href="#topic+outdegreeSender">outdegreeSender</a></code>,
<code><a href="#topic+outdegreeReceiver">outdegreeReceiver</a></code>, <code><a href="#topic+totaldegreeSender">totaldegreeSender</a></code>, or
<code><a href="#topic+totaldegreeReceiver">totaldegreeReceiver</a></code> for other types of degree effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ indegreeReceiver()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='indegreeSender'>indegreeSender</h2><span id='topic+indegreeSender'></span><span id='topic+degree'></span><span id='topic+indegree'></span>

<h3>Description</h3>

<p>Specifies the statistic for an 'indegreeSender' effect in the tie-oriented
model or the sender activity rate step of the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indegreeSender(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indegreeSender_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by the number of past events at time t can
be requested with 'prop' or standardization of the raw degree counts per
time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="indegreeSender_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An indegree of the sender effect refers to the tendency for actors to send
events if they have received more past events. The statistic at timepoint
<em>t</em> for dyad <em>(i,j)</em> (tie-oriented model) or sender <em>i</em>
(actor-oriented model) is equal to the number of events received by
actor <em>i</em> before timepoint <em>t</em>. Note that the 'indegreeSender'
effect is only defined for directed events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
degree count by the total number of past events, the statistic refers to the
fraction of past events that were received by actor i. At the first time
point, when no events did previously occur, it is assumed that every actor
is equally likely to send a message and the statistic is set equal to 1/n,
where n refers to the number of actors.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indegreeReceiver">indegreeReceiver</a></code>, <code><a href="#topic+outdegreeSender">outdegreeSender</a></code>,
<code><a href="#topic+outdegreeReceiver">outdegreeReceiver</a></code>, <code><a href="#topic+totaldegreeSender">totaldegreeSender</a></code>, or
<code><a href="#topic+totaldegreeReceiver">totaldegreeReceiver</a></code> for other types of degree effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ indegreeSender()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, sender_effects = effects)

</code></pre>

<hr>
<h2 id='inertia'>inertia</h2><span id='topic+inertia'></span>

<h3>Description</h3>

<p>Specifies the statistic for an inertia effect in the tie-oriented model or
the receiver choice step of the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inertia(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inertia_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the inertia statistic. Default is to
not scale the statistic (scaling = &quot;none&quot;). Alternatively, the
statistics can be scaled by specifying 'prop', in which raw counts are
divided by the outdegree of the sender at time t (see 'details') or
standardization of the raw counts per time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="inertia_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the number of past
events separately for each event type (TRUE, default) or sum across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An inertia effect refers to the tendency for dyads to repeatedly interact
with each other (tie-oriented model) or for actors to repeatedly choose the
same actor as receiver of their events (actor-oriented model). The statistic
at timepoint <em>t</em> for dyad <em>(i,j)</em> resp. receiver <em>j</em> is
equal to the number of <em>(i,j)</em> events before timepoint <em>t</em>.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
inertia count by the outdegree of the sender (&quot;prop&quot;), the statistic refers
to the fraction of messages send by actor i that were send to actor j. If
actor i hasn't send any messages yet it can be assumed that every actor is
equally likely to receive a message from i and the statistic is set equal to
1/(n-1), where n refers to the number of actors. The resulting statistic is
similar to the &quot;FrPSndSnd&quot; statistic in the R package 'relevent', or the
persistence statistic in Section 2.2.2 of Butts (2008). Note that this
scaling method is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ inertia()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='info'>Simulated exogenous information on actors in a social network.</h2><span id='topic+info'></span>

<h3>Description</h3>

<p>A dataset containing exogenous information on the actors in the social 
network of a relational event history. Data is simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(info)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 10 rows and 5 variables:
</p>

<dl>
<dt>id</dt><dd><p>numeric id of the actor</p>
</dd>
<dt>time</dt><dd><p>numeric value, describes when the value of the covariate 
changes, if it changes</p>
</dd>
<dt>age</dt><dd><p>dichotomized age of the actor (e.g., 0 = below 25, 1 = 25 or 
older)</p>
</dd>
<dt>sex</dt><dd><p>dichotomized sex of the actor (e.g., 0 = male, 1 = female)</p>
</dd>
<dt>extraversion</dt><dd><p>standardized extraversion score of the actor</p>
</dd>
<dt>agreeableness</dt><dd><p>standardized agreeableness score of the actor</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated exogenous information on actors in a social network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+history">history</a></code> for the relational event history.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(info)

</code></pre>

<hr>
<h2 id='isp'>isp</h2><span id='topic+isp'></span>

<h3>Description</h3>

<p>Specifies the statistic for an incoming shared partners effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isp(unique = FALSE, scaling = c("none", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isp_+3A_unique">unique</code></td>
<td>
<p>A logical value indicating whether to sum the minimum of
events with third actors (FALSE, default) or the number of third actors that
create a new, unique shared partner (TRUE). See details for more information.</p>
</td></tr>
<tr><td><code id="isp_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the triad statistic. Default is to not
scale the statistic but keep the raw 'counts'. Alternatively,
standardization of the raw counts per time point can be requested
with 'std'.</p>
</td></tr>
<tr><td><code id="isp_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the shared partners
separately for each event type (TRUE, default) or sum across different event
types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The incoming shared partners effect describes the propensity of dyads to
interact based on the number of past incoming shared partners between them.
By default, the statistic at timepoint t for the dyad (i,j) is computed as
the sum of the minimum occurrences of past (h,i) and (h,j) events across all
actors h.
</p>
<p>When the unique parameter is set to TRUE, a different approach is taken.
In this case, the statistic counts the number of actors h that contribute to
the creation of a new, distinct shared partner between actors i and j.
</p>
<p>Additionally, it is possible to specify a scaling method using the scaling
parameter.
</p>
<p>Please note that the incoming shared partners effect, 'isp', is exclusively
defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>References</h3>

<p>Butts, C. (2008). A relational event framework for social
action. Sociological Methodology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+otp">otp</a></code>, <code><a href="#topic+itp">itp</a></code>, or <code><a href="#topic+osp">osp</a></code> for
other types of triadic effects for directed relational events and
<code><a href="#topic+sp">sp</a></code> for triadic effects for undirected relational events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ isp()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='itp'>itp</h2><span id='topic+itp'></span>

<h3>Description</h3>

<p>Specifies the statistic for an incoming two-path effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itp(unique = FALSE, scaling = c("none", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itp_+3A_unique">unique</code></td>
<td>
<p>A logical value indicating whether to sum the minimum of
events with third actors (FALSE, default) or the number of third actors that
create a new, unique two-path (TRUE). See details for more information.</p>
</td></tr>
<tr><td><code id="itp_+3A_scaling">scaling</code></td>
<td>
<p>The method for scaling the triad statistic. The default value
is &quot;none&quot;, which means the statistic is not scaled. Alternatively, you can
set it to &quot;std&quot; to request standardization of the raw counts per time point.</p>
</td></tr>
<tr><td><code id="itp_+3A_consider_type">consider_type</code></td>
<td>
<p>A logical value indicating whether to count the
two-paths separately for each event type (TRUE, default) or sum across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The incoming two-path effect describes the propensity of dyads to interact
based on the number of past incoming two-paths between them. By default, the
statistic at timepoint t for the dyad (i,j) is computed as the sum of the
minimum occurrences of past (j,h) and (h,i) events across all actors h.
</p>
<p>When the unique parameter is set to TRUE, a different approach is taken.
In this case, the statistic counts the number of actors h that contribute to
the creation of a new, distinct two-path between actors i and j.
</p>
<p>Additionally, it is possible to specify a scaling method using the scaling
parameter.
</p>
<p>Please note that the incoming two-path effect, 'itp', is exclusively defined
for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>References</h3>

<p>Butts, C. (2008). A relational event framework for social
action. Sociological Methodology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+otp">otp</a></code>, <code><a href="#topic+osp">osp</a></code>, or <code><a href="#topic+isp">isp</a></code> for
other types of triadic effects for directed relational events and
<code><a href="#topic+sp">sp</a></code> for triadic effects for undirected relational events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ itp()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='maximum'>maximum</h2><span id='topic+maximum'></span>

<h3>Description</h3>

<p>Specifies the statistic for a &quot;maximum&quot; effect in the tie-oriented model. A
&quot;maximum&quot; effect refers to an exogenous actor attribute that affects dyad
<em>(i,j)</em>'s rate of interacting based on the maximum of the values of
actors <em>i</em> and <em>j</em> on this attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximum(variable, attr_actors = NULL, scaling = c("none", "std"), attr_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximum_+3A_variable">variable</code></td>
<td>
<p>string with the name of the column in the
<code>attr_actors</code> object for which the statistic has to be computed.</p>
</td></tr>
<tr><td><code id="maximum_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the attribute, see
'Details.'</p>
</td></tr>
<tr><td><code id="maximum_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the statistic. Default is to not scale
the statistic. Alternatively, standardization of the
statistic per time point can be requested with &quot;std&quot;.</p>
</td></tr>
<tr><td><code id="maximum_+3A_attr_data">attr_data</code></td>
<td>
<p>Deprecated argument. Please use 'attr_actors' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic at timepoint <em>t</em> for dyad <em>(i,j)</em> is equal to the
maximum of the values of actor <em>i</em> and <em>j</em> on the attribute at
timepoint <em>t</em>.
</p>
<p>Construct the 'attr_actors' object as a data frame where each row represents 
the attribute value of actor <em>i</em> at timepoint <em>t</em>:
</p>

<ul>
<li><p>name: The actors' name.
</p>
</li>
<li><p>time: The time when the attribute values change.
</p>
</li>
<li><p>variable: The third column contains the attribute used in the
specification of the &quot;difference&quot; effect. The column name should correspond
to the string supplied to the <code>variable</code> argument in the 'difference()'
function.
</p>
</li></ul>

<p>Note that it is possible to omit the 'attr_actors' object in the call of
<code>difference()</code> and, instead, supply it in the call of <code>remstats()</code>
for multiple exogenous effects.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie", directed = FALSE)
effects &lt;- ~ maximum("extraversion")
remstats(reh = reh_tie, tie_effects = effects, attr_actors = info)

</code></pre>

<hr>
<h2 id='minimum'>minimum</h2><span id='topic+minimum'></span>

<h3>Description</h3>

<p>Specifies the statistic for a &quot;minimum&quot; effect in the tie-oriented model. A
&quot;minimum&quot; effect refers to an exogenous actor attribute that affects dyad
<em>(i,j)</em>'s rate of interacting based on the minimum of the values of
actors <em>i</em> and <em>j</em> on this attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimum(variable, attr_actors = NULL, scaling = c("none", "std"), attr_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimum_+3A_variable">variable</code></td>
<td>
<p>string with the name of the column in the
<code>attr_actors</code> object for which the statistic has to be computed.</p>
</td></tr>
<tr><td><code id="minimum_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the attribute, see
'Details.'</p>
</td></tr>
<tr><td><code id="minimum_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the statistic. Default is to not scale
the statistic. Alternatively, standardization of the
statistic per time point can be requested with &quot;std&quot;.</p>
</td></tr>
<tr><td><code id="minimum_+3A_attr_data">attr_data</code></td>
<td>
<p>Deprecated argument. Please use 'attr_actors' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic at timepoint <em>t</em> for dyad <em>(i,j)</em> is equal to the
minimum of the values of actor <em>i</em> and <em>j</em> on the attribute at
timepoint <em>t</em>.
</p>
<p>Construct the 'attr_actors' object as a data frame where each row represents 
the attribute value of actor <em>i</em> at timepoint <em>t</em>:
</p>

<ul>
<li><p>name: The actors' name.
</p>
</li>
<li><p>time: The time when the attribute values change.
</p>
</li>
<li><p>variable: The third column contains the attribute used in the
specification of the &quot;difference&quot; effect. The column name should correspond
to the string supplied to the <code>variable</code> argument in the 'difference()'
function.
</p>
</li></ul>

<p>Note that it is possible to omit the 'attr_actors' object in the call of
<code>difference()</code> and, instead, supply it in the call of <code>remstats()</code>
for multiple exogenous effects.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie", directed = FALSE)
effects &lt;- ~ minimum("extraversion")
remstats(reh = reh_tie, tie_effects = effects, attr_actors = info)

</code></pre>

<hr>
<h2 id='osp'>osp</h2><span id='topic+osp'></span>

<h3>Description</h3>

<p>Specifies the statistic for an outgoing shared partners effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osp(unique = FALSE, scaling = c("none", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osp_+3A_unique">unique</code></td>
<td>
<p>A logical value indicating whether to sum the minimum of
events with third actors (FALSE, default) or the number of third actors that
create a new, unique shared partner (TRUE). See details for more information.</p>
</td></tr>
<tr><td><code id="osp_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the triad statistic. Default is to not
scale the statistic but keep the raw 'counts'. Alternatively,
standardization of the raw counts per time point can be requested
with 'std'.</p>
</td></tr>
<tr><td><code id="osp_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the shared partners
separately for each event type (TRUE, default) or sum across different event
types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outgoing shared partners effect describes the propensity of dyads to
interact based on the number of past outgoing shared partners between them.
By default, the statistic at timepoint t for the dyad (i,j) is computed as
the sum of the minimum occurrences of past (i,h) and (j,h) events across all
actors h.
</p>
<p>When the unique parameter is set to TRUE, a different approach is taken.
In this case, the statistic counts the number of actors h that contribute to
the creation of a new, distinct shared partner between actors i and j.
</p>
<p>Additionally, it is possible to specify a scaling method using the scaling
parameter.
</p>
<p>Please note that the outgoing shared partners effect, 'osp', is exclusively
defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>References</h3>

<p>Butts, C. (2008). A relational event framework for social
action. Sociological Methodology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+otp">otp</a></code>, <code><a href="#topic+itp">itp</a></code>, or <code><a href="#topic+isp">isp</a></code> for
other types of triadic effects for directed relational events and
<code><a href="#topic+sp">sp</a></code> for triadic effects for undirected relational events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ osp()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='otp'>otp</h2><span id='topic+otp'></span><span id='topic+triad'></span>

<h3>Description</h3>

<p>Specifies the statistic for an outgoing two-path effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp(unique = FALSE, scaling = c("none", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_+3A_unique">unique</code></td>
<td>
<p>A logical value indicating whether to sum the minimum of
events with third actors (FALSE, default) or the number of third actors that
create a new, unique two-path (TRUE). See details for more information.</p>
</td></tr>
<tr><td><code id="otp_+3A_scaling">scaling</code></td>
<td>
<p>The method for scaling the triad statistic. The default value
is &quot;none&quot;, which means the statistic is not scaled. Alternatively, you can
set it to &quot;std&quot; to request standardization of the raw counts per time point.</p>
</td></tr>
<tr><td><code id="otp_+3A_consider_type">consider_type</code></td>
<td>
<p>A logical value indicating whether to count the
two-paths separately for each event type (TRUE, default) or sum across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outgoing two-path effect describes the propensity of dyads to interact
based on the number of past outgoing two-paths between them. By default, the
statistic at timepoint t for the dyad (i,j) is computed as the sum of the
minimum occurrences of past (i,h) and (h,j) events across all actors h.
</p>
<p>When the unique parameter is set to TRUE, a different approach is taken.
In this case, the statistic counts the number of actors h that contribute to
the creation of a new, distinct two-path between actors i and j.
</p>
<p>Additionally, it is possible to specify a scaling method using the scaling
parameter.
</p>
<p>Please note that the outgoing two-path effect, 'otp', is exclusively defined
for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>References</h3>

<p>Butts, C. (2008). A relational event framework for social
action. Sociological Methodology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itp">itp</a></code>, <code><a href="#topic+osp">osp</a></code>, or <code><a href="#topic+isp">isp</a></code> for
other types of triadic effects for directed relational events and
<code><a href="#topic+sp">sp</a></code> for triadic effects for undirected relational events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ otp()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='outdegreeReceiver'>outdegreeReceiver</h2><span id='topic+outdegreeReceiver'></span>

<h3>Description</h3>

<p>Specifies the statistic for an 'outdegreeReceiver' effect in the
tie-oriented model or the receiver choice step of the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outdegreeReceiver(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outdegreeReceiver_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by the number of past events at time t can
be requested with 'prop' or standardization of the raw degree counts per
time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="outdegreeReceiver_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An outdegree of the receiver effect refers to the tendency for actors to
receive events if they have send more past events. The statistic at
timepoint <em>t</em> for dyad <em>(i,j)</em> (tie-oriented model) or
receiver <em>j</em> (actor-oriented model) is equal to the number of events
send by actor <em>j</em> before timepoint <em>t</em>. Note that the
'outdegreeReceiver' effect is only defined for directed events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
degree count by the total number of past events, the statistic refers to the
fraction of past events that were send by actor j. At the first time
point, when no events did previously occur, it is assumed that every actor
is equally likely to receive a message and the statistic is set equal to
1/n, where n refers to the number of actors.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indegreeSender">indegreeSender</a></code>, <code><a href="#topic+indegreeReceiver">indegreeReceiver</a></code>,
<code><a href="#topic+outdegreeSender">outdegreeSender</a></code>, <code><a href="#topic+totaldegreeSender">totaldegreeSender</a></code>, or
<code><a href="#topic+totaldegreeReceiver">totaldegreeReceiver</a></code> for other types of degree effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ outdegreeReceiver()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='outdegreeSender'>outdegreeSender</h2><span id='topic+outdegreeSender'></span><span id='topic+outdegree'></span>

<h3>Description</h3>

<p>Specifies the statistic for an 'outdegreeSender' effect in the tie-oriented
model or the sender activity rate step of the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outdegreeSender(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outdegreeSender_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by the number of past events at time t can
be requested with 'prop' or standardization of the raw degree counts per
time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="outdegreeSender_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An outdegree of the sender effect refers to the tendency for actors to send
events if they have send more past events. The statistic at timepoint
<em>t</em> for dyad <em>(i,j)</em> (tie-oriented model) or sender <em>i</em>
(actor-oriented model) is equal to the number of events send by
actor <em>i</em> before timepoint <em>t</em>. Note that the 'outdegreeSender'
effect is only defined for directed events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
degree count by the total number of past events, the statistic refers to the
fraction of past events that were send by actor i. At the first time
point, when no events did previously occur, it is assumed that every actor
is equally likely to send a message and the statistic is set equal to 1/n,
where n refers to the number of actors.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indegreeSender">indegreeSender</a></code>, <code><a href="#topic+indegreeReceiver">indegreeReceiver</a></code>,
<code><a href="#topic+outdegreeReceiver">outdegreeReceiver</a></code>, <code><a href="#topic+totaldegreeSender">totaldegreeSender</a></code>, or
<code><a href="#topic+totaldegreeReceiver">totaldegreeReceiver</a></code> for other types of degree effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ outdegreeSender()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, sender_effects = effects)

</code></pre>

<hr>
<h2 id='plot.aomstats'>Plotting Relational Event Network Statistics Trajectories</h2><span id='topic+plot.aomstats'></span>

<h3>Description</h3>

<p>Generate line plots to visualize the trajectories of a specified effect in 
the sender model of a <code><a href="#topic+aomstats">aomstats</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aomstats'
plot(x, effect, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.aomstats_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+aomstats">aomstats</a></code> containing relational
event network statistics.</p>
</td></tr>
<tr><td><code id="plot.aomstats_+3A_effect">effect</code></td>
<td>
<p>A character string specifying the name of the effect in 'x' or
an integer indicating the index of the effect to be plotted.</p>
</td></tr>
<tr><td><code id="plot.aomstats_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of actors to be used for
plotting. By default, a maximum of 5 unique actors are used for plotting.</p>
</td></tr>
<tr><td><code id="plot.aomstats_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to plot().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates line plots to illustrate the temporal trajectories of a
specified effect in a relational event network, as captured in the sender 
model by a <code><a href="#topic+aomstats">aomstats</a></code> object. The 'effect' parameter allows users 
to choose a specific effect for visualization, either by providing the effect's 
name or its index within the 'aomstats' object. An optional 'subset' parameter 
enables users to focus on specific actors. If 'subset' is not specified, a 
default maximum of 5 unique actors is plotted. These actors are randomly selected 
to represent trajectories across the range of different endpoints for the effect
(excluding zero).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(remstats)
# Load data
data(history)
# Prepare data
reh &lt;- remify::remify(edgelist = history[,1:3], model = "actor")
# Compute effects
stats &lt;- remstats(reh, sender_effects = ~ outdegreeSender())
# Plot the 'outdegreeSender' trajectories 5 actors
plot(stats, effect = "outdegreeSender")
# Plot the 'outdegreeSender' trajectory for a specific actor
plot(stats, effect = "outdegreeSender", subset = 10)

</code></pre>

<hr>
<h2 id='plot.tomstats'>Plotting Relational Event Network Statistics Trajectories</h2><span id='topic+plot.tomstats'></span>

<h3>Description</h3>

<p>Generate line plots to visualize the trajectories of a specified effect in a
<code><a href="#topic+tomstats">tomstats</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tomstats'
plot(x, effect, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tomstats_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+tomstats">tomstats</a></code> containing relational
event network statistics.</p>
</td></tr>
<tr><td><code id="plot.tomstats_+3A_effect">effect</code></td>
<td>
<p>A character string specifying the name of the effect in 'x' or
an integer indicating the index of the effect to be plotted.</p>
</td></tr>
<tr><td><code id="plot.tomstats_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of dyads to be used for
plotting. By default, a maximum of 5 unique dyads are used for plotting.</p>
</td></tr>
<tr><td><code id="plot.tomstats_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to plot().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates line plots to illustrate the temporal trajectories of a
specified effect in a relational event network, as captured by a
<code><a href="#topic+tomstats">tomstats</a></code> object. The 'effect' parameter allows users to choose a
specific effect for visualization, either by providing the effect's name or
its index within the 'tomstats' object. An optional 'subset' parameter enables
users to focus on specific dyads. If 'subset' is not specified, a default
maximum of 5 unique dyads is plotted. These dyads are randomly selected to
represent trajectories across the range of different endpoints for the effect
(excluding zero).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(remstats)
# Load data
data(history)
# Prepare data
reh &lt;- remify::remify(edgelist = history[,1:3], model = "tie")
# Compute effects
stats &lt;- remstats(reh, tie_effects = ~ inertia())
# Plot the 'inertia' trajectories for 5 dyads
plot(stats, effect = "inertia")
# Plot the 'inertia' trajectory for a specific dyad
plot(stats, effect = "inertia", subset = 60)

</code></pre>

<hr>
<h2 id='print.remstats'>Printing Relational Event Network Statistics</h2><span id='topic+print.remstats'></span>

<h3>Description</h3>

<p>Print a <code><a href="#topic+remstats">remstats</a></code> object in a user-friendly format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remstats'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.remstats_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+remstats">remstats</a></code>.</p>
</td></tr>
<tr><td><code id="print.remstats_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function prints formatted information about the remstats object to the console, presenting details about the relational event network statistics in a user-friendly format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rehObject &lt;- remify::remify(edgelist = history, model = "tie")
remstatsObject &lt;- remstats::remstats(reh = rehObject, tie_effects = ~ remstats::inertia())
print(remstatsObject)

rehObject &lt;- remify::remify(edgelist = history, model = "actor")
remstatsObject &lt;- remstats::remstats(reh = rehObject, receiver_effects = ~ inertia())
print(remstatsObject)

</code></pre>

<hr>
<h2 id='psABA'>psABA</h2><span id='topic+psABA'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-A in the sender step of
the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABA()
</code></pre>


<h3>Details</h3>

<p>Refers to the tendency for the same actor to keep initiating events: The
next sender is equal to the previous sender. For each timepoint t, the psABA
statistic is equal to one for the actor that will create the participation
shift if they would occur in the edgelist as the sender at time t and equal
to zero for the actors that will not create this participation shift. If
multiple events in the edgelist occur at the same time point, the order of
these events determines whether the p-shift is observed.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABB">psABB</a></code> or <code><a href="#topic+psABX">psABX</a></code> for exploring
alternative participation shifts in the sender step of the actor-oriented
model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_actor &lt;- remify::remify(history, model = "actor")
remstats(sender_effects = ~ psABA(), reh = reh_actor)

</code></pre>

<hr>
<h2 id='psABAB'>psABAB</h2><span id='topic+psABAB'></span>

<h3>Description</h3>

<p>Specifies the statistic for a pshift AB-AB effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABAB(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psABAB_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to consider the event type
in determining which dyads create a pshift (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refers to the tendency for the same dyads to keep interacting. For directed
events, the next sender and receiver are equal to the previous sender and
receiver. For undirected events, the next actor pair is equal to the current
actor pair. For each timepoint t, the psABAB statistic is equal to one for
the dyads that will create the participation shift if they would occur in
the edgelist at time t and equal to zero for the dyads that will not create
this participation shift. If consider_type is set to TRUE, the type of the
two subsequent AB events have to be equal. If it is set to FALSE, the
participation shift is set to one for every AB event, regardless of the
event type. If multiple events in the edgelist occur at the same time point,
the order of these events determines whether the p-shift is observed.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABBA">psABBA</a></code>, <code><a href="#topic+psABBY">psABBY</a></code>, <code><a href="#topic+psABXA">psABXA</a></code>,
<code><a href="#topic+psABXB">psABXB</a></code>, <code><a href="#topic+psABXY">psABXY</a></code> or <code><a href="#topic+psABAY">psABAY</a></code> for other dyadic participation shifts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie", directed = FALSE)
effects &lt;- ~ psABAB()
remstats(tie_effects = effects, reh = reh_tie)

</code></pre>

<hr>
<h2 id='psABAY'>psABAY</h2><span id='topic+psABAY'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-AY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABAY(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psABAY_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to consider the event type
in determining which dyads create a pshift (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of Gibson's (2003) dyadic participation shifts. The AB-AY participation
shift refers to a tendency for <em>turn continuing</em>. For directed events,
the sender (A) in the current event is the same as the sender in the
previous event (A), and the receiver (Y) is different from the previous
receiver (B). In undirected events, one of the current actors (A) matches
one of the actors in the previous events (A or B), while the other actor (Y)
is different.
</p>
<p>To identify these shifts, a statistic 'psABAY' is calculated for each pair
of actors at a given timepoint (t). If the pair's interaction follows the
AB-AY pattern, the statistic is set equal to one; otherwise, it's set to
zero.
</p>
<p>Additionally, the types of the AB and AY events can be taken into account. If
'consider_type' is 'TRUE', the type of the AB event and the type of the AY
event must match for the shift to occur. If 'consider_type' is 'FALSE', the
shift happens for every AY event, regardless of the event type.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABBA">psABBA</a></code>, <code><a href="#topic+psABBY">psABBY</a></code>, <code><a href="#topic+psABXA">psABXA</a></code>,
<code><a href="#topic+psABXB">psABXB</a></code>, <code><a href="#topic+psABXY">psABXY</a></code> or <code><a href="#topic+psABAB">psABAB</a></code> for other
dyadic participation shifts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ psABAY()
remstats(reh = reh, tie_effects = effects)

</code></pre>

<hr>
<h2 id='psABB'>psABB</h2><span id='topic+psABB'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-B in the sender step of the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABB()
</code></pre>


<h3>Details</h3>

<p>The AB-B participation shift refers to the tendency for immediate reciprocation (the next sender is the previous receiver). For each timepoint t, the psABBA statistic is equal to one for the actor (i.e, the previous event receiver) that will create the participation shift if it would occur as sender in the edgelist at time t and equal to zero for the actors that will not create this participation shift. If multiple events in the edgelist occur at the same time point, the order of these events determines whether the p-shift is observed.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABA">psABA</a></code> or <code><a href="#topic+psABX">psABX</a></code> for exploring alternative participation shifts in the sender step of the actor-oriented model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, sender_effects = ~ psABB())

</code></pre>

<hr>
<h2 id='psABBA'>psABBA</h2><span id='topic+psABBA'></span><span id='topic+pshift'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-BA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABBA(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psABBA_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to consider the event type
in determining which dyads create a pshift (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AB-BA pshift effect refers to one of Gibson's (2003) dyadic participation shifts. The AB-BA pshift refers to the tendency for immediate reciprocation (the next sender is the previous receiver and the next receiver is the previous sender). For each timepoint t, the psABBA statistic is equal to one for the dyad that will create the participation shift if it would occur in the edgelist at time t and equal to zero for the dyads that will not create this participation shift. If consider_type is set to TRUE, the type of the AB event and the type of the BA event have to be equal. If it is set to FALSE, the participation shift is set to one for every BA event, regardless of the event type. If multiple events in the edgelist occur at the same time point, the order of these events determines whether the p-shift is observed. Note that the AB-BA pshift is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABBY">psABBY</a></code>, <code><a href="#topic+psABXA">psABXA</a></code>, <code><a href="#topic+psABXB">psABXB</a></code>,
<code><a href="#topic+psABXY">psABXY</a></code> or <code><a href="#topic+psABAY">psABAY</a></code> for other dyadic participation
shifts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ psABBA()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='psABBY'>psABBY</h2><span id='topic+psABBY'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-BY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABBY(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psABBY_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to consider the event type
in determining which dyads create a pshift (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AB-BY participation shift refers to one of Gibson's (2003) dyadic participation shifts. The AB-BY pshift refers to a tendency for turn receiving (here, the next sender is the previous receiver and the next receiver is not in the current previous). For each timepoint t, the psABBY statistic is equal to one for the dyads that will create the participation shift if they would occur in the edgelist at time t and equal to zero for the dyads that will not create this participation shift. If consider_type is set to TRUE, the type of the AB event and the type of the BY events have to be equal. If it is set to FALSE, the participation shift is set to one for every BY event, regardless of the event type. If multiple events in the edgelist occur at the same time point, the order of these events determines whether the p-shift is observed. Note that the AB-BY pshift is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABBA">psABBA</a></code>, <code><a href="#topic+psABXA">psABXA</a></code>, <code><a href="#topic+psABXB">psABXB</a></code>,
<code><a href="#topic+psABXY">psABXY</a></code> or <code><a href="#topic+psABAY">psABAY</a></code> for other dyadic participation
shifts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ psABBY()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='psABX'>psABX</h2><span id='topic+psABX'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-X in the sender step of
the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABX()
</code></pre>


<h3>Details</h3>

<p>The AB-X participation shift refers to a tendency for turn usurping (here,
the next sender is not in the previous event). For each timepoint t, the
psABX statistic is equal to one for the actors that will create the
participation shift if they would occur as the sender in the edgelist at
time t and equal to zero for the actors that will not create this
participation shift. If multiple events in the edgelist occur at the same
time point, the order of these events determines whether the p-shift is
observed.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABA">psABA</a></code> or <code><a href="#topic+psABB">psABB</a></code> for exploring
alternative participation shifts in the sender step of the actor-oriented
model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, sender_effects = ~ psABX())

</code></pre>

<hr>
<h2 id='psABXA'>psABXA</h2><span id='topic+psABXA'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-XA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABXA(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psABXA_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to consider the event type
in determining which dyads create a pshift (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AB-XA participation shift refers to one of Gibson's (2003) dyadic participation shifts. The AB-XA pshift refers to a tendency for turn usurping (here, the next sender is not in the previous event and the next receiver is the previous sender). For each timepoint t, the psABXA statistic is equal to one for the dyads that will create the participation shift if they would occur in the edgelist at time t and equal to zero for the dyads that will not create this participation shift. If consider_type is set to TRUE, the type of the AB event and the type of the XA events have to be equal. If it is set to FALSE, the participation shift is set to one for every XA event, regardless of the event type. If multiple events in the edgelist occur at the same time point, the order of these events determines whether the pshift is observed. Note that the AB-XA pshift is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABBA">psABBA</a></code>, <code><a href="#topic+psABBY">psABBY</a></code>, <code><a href="#topic+psABXB">psABXB</a></code>, <code><a href="#topic+psABXY">psABXY</a></code> or <code><a href="#topic+psABAY">psABAY</a></code> for other dyadic participation shifts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ psABXA()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='psABXB'>psABXB</h2><span id='topic+psABXB'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-XB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABXB(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psABXB_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to consider the event type
in determining which dyads create a pshift (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AB-XB participation shift refers to one of Gibson's (2003) dyadic participation shifts. The AB-XB pshift refers to a tendency for turn usurping (here, the next sender is not in the previous event and the next receiver is the previous receiver). For each timepoint t, the psABXB statistic is equal to one for the dyads that will create the participation shift if they would occur in the edgelist at time t and equal to zero for the dyads that will not create this participation shift. If consider_type is set to TRUE, the type of the AB event and the type of the XB events have to be equal. If it is set to FALSE, the participation shift is set to one for every XB event, regardless of the event type. If multiple events in the edgelist occur at the same time point, the order of these events determines whether the p-shift is observed. Note that the AB-XB pshift is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABBA">psABBA</a></code>, <code><a href="#topic+psABBY">psABBY</a></code>, <code><a href="#topic+psABXA">psABXA</a></code>,
<code><a href="#topic+psABXY">psABXY</a></code> or <code><a href="#topic+psABAY">psABAY</a></code> for other dyadic participation
shifts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ psABXB()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='psABXY'>psABXY</h2><span id='topic+psABXY'></span>

<h3>Description</h3>

<p>Specifies the statistic for a participation shift AB-XY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psABXY(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psABXY_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to consider the event type
in determining which dyads create a pshift (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AB-XY participation shift refers to one of Gibson's (2003) dyadic participation shifts. The AB-XY pshift refers to a tendency for turn usurping (here, the next sender and the next receiver are not in the previous event). For each timepoint t, the psABXY statistic is equal to one for the dyads that will create the participation shift if they would occur in the edgelist at time t and equal to zero for the dyads that will not create this participation shift. If consider_type is set to TRUE, the type of the AB event and the type of the XY events have to be equal. If it is set to FALSE, the participation shift is set to one for every XY event, regardless of the event type. If multiple events in the edgelist occur at the same time point, the order of these events determines whether the p-shift is observed. Note that the AB-XY pshift is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psABBA">psABBA</a></code>, <code><a href="#topic+psABBY">psABBY</a></code>, <code><a href="#topic+psABXA">psABXA</a></code>,
<code><a href="#topic+psABXB">psABXB</a></code> or <code><a href="#topic+psABAY">psABAY</a></code> for other dyadic participation
shifts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ psABXY()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='receive'>receive</h2><span id='topic+receive'></span>

<h3>Description</h3>

<p>Specifies the statistic for a &quot;receive&quot; effect in the tie-oriented model or
the receiver choice step of the actor-oriented model. A &quot;receive&quot; effect
refers to an exogenous actor attribute that affects actor <em>i</em>'s rate of
receiving events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>receive(variable, attr_actors = NULL, scaling = c("none", "std"), attr_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="receive_+3A_variable">variable</code></td>
<td>
<p>string with the name of the column in the
<code>attr_actors</code> object for which the statistic has to be computed.</p>
</td></tr>
<tr><td><code id="receive_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the attribute, see
'Details.'</p>
</td></tr>
<tr><td><code id="receive_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the statistic. Default is to not scale
the statistic. Alternatively, standardization of the
statistic per time point can be requested with &quot;std&quot;.</p>
</td></tr>
<tr><td><code id="receive_+3A_attr_data">attr_data</code></td>
<td>
<p>Deprecated argument. Please use 'attr_actors' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic at timepoint <em>t</em> is equal to the value of the exogenous
attribute for actor <em>i</em> at time <em>t</em> for all dyads in the riskset
that have actor <em>i</em> as receiver. Note that a &quot;receive&quot; effect is only
defined for directed relational events.
</p>
<p>Construct the 'attr_actors' object as a data frame where each row represents 
the attribute value of actor <em>i</em> at timepoint <em>t</em>:
</p>

<ul>
<li><p>name: The actors' name.
</p>
</li>
<li><p>time: The time when the attribute values change.
</p>
</li>
<li><p>variable: The third column contains the attribute used in the
specification of the &quot;difference&quot; effect. The column name should correspond
to the string supplied to the <code>variable</code> argument in the 'difference()'
function.
</p>
</li></ul>

<p>Note that it is possible to omit the 'attr_actors' object in the call of
<code>difference()</code> and, instead, supply it in the call of <code>remstats()</code>
for multiple exogenous effects.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(history)
data(info)

# Tie-oriented model
reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ receive("extraversion")
remstats(reh = reh_tie, tie_effects = effects, attr_actors = info)

# Actor-oriented model
reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects, attr_actors = info)

</code></pre>

<hr>
<h2 id='recencyContinue'>recencyContinue</h2><span id='topic+recencyContinue'></span><span id='topic+recency'></span>

<h3>Description</h3>

<p>Specifies the statistic for a recency continue effect in the
<code>effects</code> argument of <code><a href="#topic+tomstats">tomstats</a></code> or the
<code>receiver_effects</code> argument of <code><a href="#topic+aomstats">aomstats</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recencyContinue(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recencyContinue_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to compute the recency
separately for each event type (TRUE, default) or regardless of event types
(FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recencyContinue effect refers to a recency statistic similar to what is
described in Vu et al. (2017) and Mulder and Leenders (2019). For each
timepoint t, for directed dyad (i,j) the statistic is equal to 1/(the time
that has past since the dyad was last active + 1).
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrankSend">rrankSend</a></code>, <code><a href="#topic+rrankReceive">rrankReceive</a></code>,
<code><a href="#topic+recencySendSender">recencySendSender</a></code>, <code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a></code>,
<code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a></code> and <code><a href="#topic+recencyReceiveReceiver">recencyReceiveReceiver</a></code>
for other type of recency effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>effects &lt;- ~ recencyContinue()
reh_tie &lt;- remify::remify(history, model = "tie")
remstats(tie_effects = effects, reh = reh_tie)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(receiver_effects = effects, reh = reh_actor)

</code></pre>

<hr>
<h2 id='recencyReceiveReceiver'>recencyReceiveReceiver</h2><span id='topic+recencyReceiveReceiver'></span>

<h3>Description</h3>

<p>Specifies the statistic for a recency receive of receiver effect in the
<code>effects</code> argument of <code><a href="#topic+tomstats">tomstats</a></code> or the
<code>receiver_effects</code> argument of <code><a href="#topic+aomstats">aomstats</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recencyReceiveReceiver(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recencyReceiveReceiver_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to compute the recency
separately for each event type (TRUE, default) or regardless of event types
(FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recencyReceiveReceiver effect refers to a recency statistic similar to
what is described in Vu et al. (2017) and Mulder and Leenders (2019). For
each timepoint t, for directed dyad (i,j) the statistic is equal to 1/(the
time that has past since receiver j was last active as receiver + 1). Note
that the 'recencyReceiveReceiver' effect is only defined for directed
events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrankSend">rrankSend</a></code>, <code><a href="#topic+rrankReceive">rrankReceive</a></code>,
<code><a href="#topic+recencySendSender">recencySendSender</a></code>, <code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a></code>,
<code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a></code> and <code><a href="#topic+recencyContinue">recencyContinue</a></code> for
other type of recency effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>effects &lt;- ~ recencyReceiveReceiver()
reh_tie &lt;- remify::remify(history, model = "tie")
remstats(tie_effects = effects, reh = reh_tie)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(receiver_effects = effects, reh = reh_actor)

</code></pre>

<hr>
<h2 id='recencyReceiveSender'>recencyReceiveSender</h2><span id='topic+recencyReceiveSender'></span>

<h3>Description</h3>

<p>Specifies the statistic for a recency receive of sender effect in the
<code>effects</code> argument of <code><a href="#topic+tomstats">tomstats</a></code> or the
<code>sender_effects</code> argument of <code><a href="#topic+aomstats">aomstats</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recencyReceiveSender(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recencyReceiveSender_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to compute the recency
separately for each event type (TRUE, default) or regardless of event types
(FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recencyReceiveSender effect refers to a recency statistic similar to
what is described in Vu et al. (2017) and Mulder and Leenders (2019). For
each timepoint t, for directed dyad (i,j) the statistic is equal to 1/(the
time that has past since sender i was last active as receiver + 1). Note
that the 'recencyReceiveSender' effect is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrankSend">rrankSend</a></code>, <code><a href="#topic+rrankReceive">rrankReceive</a></code>,
<code><a href="#topic+recencySendSender">recencySendSender</a></code>, <code><a href="#topic+recencySendReceiver">recencySendReceiver</a></code>,
<code><a href="#topic+recencyReceiveReceiver">recencyReceiveReceiver</a></code> and <code><a href="#topic+recencyContinue">recencyContinue</a></code> for
other type of recency effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>effects &lt;- ~ recencyReceiveSender()
reh_tie &lt;- remify::remify(history, model = "tie")
remstats(tie_effects = effects, reh = reh_tie)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(sender_effects = effects, reh = reh_actor)

</code></pre>

<hr>
<h2 id='recencySendReceiver'>recencySendReceiver</h2><span id='topic+recencySendReceiver'></span>

<h3>Description</h3>

<p>Specifies the statistic for a recency send of receiver effect in the
<code>effects</code> argument of <code><a href="#topic+tomstats">tomstats</a></code> or the
<code>receiver_effects</code> argument of <code><a href="#topic+aomstats">aomstats</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recencySendReceiver(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recencySendReceiver_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to compute the recency
separately for each event type (TRUE, default) or regardless of event types
(FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recencySendReceiver effect refers to a recency statistic similar to what
is described in Vu et al. (2017) and Mulder and Leenders (2019). For each
timepoint t, for directed dyad (i,j) the statistic is equal to 1/(the time
that has past since receiver j was last active as sender + 1). Note that the
'recencySendReceiver' effect is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrankSend">rrankSend</a></code>, <code><a href="#topic+rrankReceive">rrankReceive</a></code>,
<code><a href="#topic+recencySendSender">recencySendSender</a></code>, <code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a></code>,
<code><a href="#topic+recencyReceiveReceiver">recencyReceiveReceiver</a></code> and <code><a href="#topic+recencyContinue">recencyContinue</a></code> for
other type of recency effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>effects &lt;- ~ recencySendReceiver()
reh_tie &lt;- remify::remify(history, model = "tie")
remstats(tie_effects = effects, reh = reh_tie)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(receiver_effects = effects, reh = reh_actor)

</code></pre>

<hr>
<h2 id='recencySendSender'>recencySendSender</h2><span id='topic+recencySendSender'></span>

<h3>Description</h3>

<p>Specifies the statistic for a recency send of sender effect in the
<code>effects</code> argument of <code><a href="#topic+tomstats">tomstats</a></code> or the <code>sender_effects</code>
argument of <code><a href="#topic+aomstats">aomstats</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recencySendSender(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recencySendSender_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to compute the recency
separately for each event type (TRUE, default) or regardless of event types
(FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recencySendSender effect refers to a recency statistic similar to what
is described in Vu et al. (2017) and Mulder and Leenders (2019). For each
timepoint t, for directed dyad (i,j) the statistic is equal to 1/(the time
that has past since sender i was last active as sender + 1). Note that the
'recencySendSender' effect is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrankSend">rrankSend</a></code>, <code><a href="#topic+rrankReceive">rrankReceive</a></code>,
<code><a href="#topic+recencySendReceiver">recencySendReceiver</a></code>, <code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a></code>,
<code><a href="#topic+recencyReceiveReceiver">recencyReceiveReceiver</a></code> and <code><a href="#topic+recencyContinue">recencyContinue</a></code> for
other type of recency effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>effects &lt;- ~ recencySendSender()
reh_tie &lt;- remify::remify(history, model = "tie")
remstats(tie_effects = effects, reh = reh_tie)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(sender_effects = effects, reh = reh_actor)

</code></pre>

<hr>
<h2 id='reciprocity'>reciprocity</h2><span id='topic+reciprocity'></span>

<h3>Description</h3>

<p>Specifies the statistic for a reciprocity effect in the tie-oriented model
or the receiver choice step of the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the reciprocity statistic. Default is
to not scale the statistic but keep the raw 'counts'. Alternatively, the
statistics can be scaled by 'prop', in which raw counts are
divided by the indegree of the sender at time t (see 'details') or
standardization of the raw counts per time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="reciprocity_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the number of past
reciprocal events separately for each event type (TRUE, default) or sum
across different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A reciprocity effect refers to the tendency for actors to reciprocate past
interactions. The statistic at timepoint <em>t</em> for dyad <em>(i,j)</em>
(tie-oriented model) or receiver <em>j</em> (actor-oriented model) is equal to
the number of <em>(j,i)</em> events before timepoint <em>t</em>. Note that a
reciprocity effect is only defined for directed events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>.  By scaling the
reciprocity count by the indegree of the sender, the statistic refers to the
fraction of messages received by actor i that were received from actor j. If
actor i hasn't received any messages yet it can be assumed that actor i is
equally likely to receive a message from every actor and the statistic is
set equal to 1/(n-1), where n refers to the number of actors. The resulting
statistic is similar to the &quot;FrRecSnd&quot; statistic in the R package 'relevent'.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ reciprocity()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='remstats'>remstats</h2><span id='topic+remstats'></span>

<h3>Description</h3>

<p>Computes statistics for modeling relational events with a tie-oriented or 
actor-oriented approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remstats(
  reh,
  tie_effects = NULL,
  sender_effects = NULL,
  receiver_effects = NULL,
  attr_actors = NULL,
  attr_dyads = NULL,
  method = c("pt", "pe"),
  memory = c("full", "window", "decay", "interval"),
  memory_value = NA,
  start = 1,
  stop = Inf,
  display_progress = FALSE,
  adjmat = NULL,
  get_adjmat = FALSE,
  attr_data,
  attributes,
  edgelist
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remstats_+3A_reh">reh</code></td>
<td>
<p>an object of class <code>"<a href="remify.html#topic+remify">remify</a>"</code> characterizing 
the relational event history.</p>
</td></tr>
<tr><td><code id="remstats_+3A_tie_effects">tie_effects</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one
that can be coerced to that class): a symbolic description of the effects in
the tie-oriented model for which statistics are computed, see 'Details' for
the available effects and their corresponding statistics</p>
</td></tr>
<tr><td><code id="remstats_+3A_sender_effects">sender_effects</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or
one that can be coerced to that class): a symbolic description of the
effects in the sender activity rate step of the actor-oriented model for
which statistics are computed, see &lsquo;Details&rsquo;</p>
</td></tr>
<tr><td><code id="remstats_+3A_receiver_effects">receiver_effects</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code>
(or one that can be coerced to that class): a symbolic description of the
effects in the receiver choice step of model for which statistics are
computed, see &lsquo;Details&rsquo;</p>
</td></tr>
<tr><td><code id="remstats_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code>"<a href="base.html#topic+data.frame">data.frame</a>"</code> that contains exogenous attributes for 
actors (see Details).</p>
</td></tr>
<tr><td><code id="remstats_+3A_attr_dyads">attr_dyads</code></td>
<td>
<p>optionally, an object of class <code>data.frame</code> or 
<code>matrix</code> containing attribute information for dyads (see Details).</p>
</td></tr>
<tr><td><code id="remstats_+3A_method">method</code></td>
<td>
<p>Specifies the method for managing simultaneous events, i.e., 
events occurring at the same time. The default 'method' is 'pt' (per 
timepoint), where statistics are computed once for each unique timepoint in 
the edgelist. Alternatively, you can choose 'pe' (per event), where 
statistics are computed once for each unique event observed in the edgelist.</p>
</td></tr>
<tr><td><code id="remstats_+3A_memory">memory</code></td>
<td>
<p>The memory to be used. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="remstats_+3A_memory_value">memory_value</code></td>
<td>
<p>Numeric value indicating the memory parameter. See
&lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="remstats_+3A_start">start</code></td>
<td>
<p>an optional integer value, specifying the index of the first
time or event in the relational event history for which statistics must be 
computed (see 'Details')</p>
</td></tr>
<tr><td><code id="remstats_+3A_stop">stop</code></td>
<td>
<p>an optional integer value, specifying the index of the last
time or event in the relational event history for which statistics must be 
computed (see 'Details')</p>
</td></tr>
<tr><td><code id="remstats_+3A_display_progress">display_progress</code></td>
<td>
<p>should a progress bar for the computation of the
endogenous statistics be shown (TRUE) or not (FALSE)?</p>
</td></tr>
<tr><td><code id="remstats_+3A_adjmat">adjmat</code></td>
<td>
<p>optionally, for a tie-oriented model a previously computed 
adjacency matrix with on the rows the time points and on the columns the 
risk set entries</p>
</td></tr>
<tr><td><code id="remstats_+3A_get_adjmat">get_adjmat</code></td>
<td>
<p>for a tie-oriented model, whether the adjmat computed by 
remstats should be outputted as an attribute of the statistics.</p>
</td></tr>
<tr><td><code id="remstats_+3A_attr_data">attr_data</code></td>
<td>
<p>deprecated, please use &quot;attr_actors&quot; instead</p>
</td></tr>
<tr><td><code id="remstats_+3A_attributes">attributes</code></td>
<td>
<p>deprecated, please use &quot;attr_data&quot; instead</p>
</td></tr>
<tr><td><code id="remstats_+3A_edgelist">edgelist</code></td>
<td>
<p>deprecated, please use &quot;reh&quot; instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'remstats'. In case of the 
tie-oriented model, an array with the computed statistics, where rows refer 
to time points, columns refer to potential relational event (i.e., potential 
edges) in the risk set and slices refer to statistics. In case of the 
actor-oriented model, list with in the first element the statistics for the 
sender activity rate step and in the second element the statistics for the 
receiver choice step, where rows refer to time points, columns refer to 
potential senders or receivers, respectively. The 'remstats' object has the 
following attributes: 
</p>

<dl>
<dt><code>model</code></dt><dd><p>Type of model that is estimated, obtained from the 
remify object inputted to 'reh'.</p>
</dd>
<dt><code>formula</code></dt><dd><p>Model formula, obtained from the formula inputted 
to 'tie_effects', 'sender_effects' and/or 'receiver_effects', depending 
on the model.</p>
</dd>
<dt><code>riskset</code></dt><dd><p>For the tie-oriented model, the risk set used to 
construct the statistics.</p>
</dd>
<dt><code>actors</code></dt><dd><p>For the actor-oriented model, the set of actors 
used to construct the statistics, obtained from the remify object 
inputted to 'reh'.</p>
</dd>
<dt><code>adjmat</code></dt><dd><p>[Optional], for the tie-oriented model, if 
&quot;get_adjmat = TRUE&quot;, the matrix with the accumulated event weights for 
each time point (on the rows) and each dyad (in the columns).</p>
</dd>
</dl>



<h3>Effects</h3>

<p>The statistics to be computed are defined symbolically and should be
supplied to the <code>tie_effects</code> (for the tie-oriented model), or
<code>sender_effects</code> and/or <code>receiver_effects</code> (for the actor-oriented
model) argument in the form <code>~ effects</code>. The terms are separated by +
operators. For example: <code>effects = ~ inertia() + otp()</code>. Interactions
between two effects can be included with * or : operators. For example:
<code>effects = ~ inertia():otp()</code>. A list of available effects
can be obtained with <code><a href="#topic+tie_effects">tie_effects</a>()</code> and
<code><a href="#topic+actor_effects">actor_effects</a>()</code>.
</p>
<p>The majority of the statistics can be scaled in some way, see
the documentation of the <code>scaling</code> argument in the separate effect
functions for more information on this.
</p>
<p>The majority of the statistics can account for the event type
included as a dependent variable, see the documentation of the
<code>consider_type</code> argument in the separate effect functions for more
information on this. Note that this option is only available for the
tie-oriented model.
</p>
<p>Note that events in the relational event history can be directed or
undirected. Some statistics are only defined for either directed or
undirected events (see the documentation of the statistics). Note that
undirected events are only available for the tie-oriented model.
</p>


<h3>attr_actors</h3>

<p>For the computation of the <em>exogenous</em> statistics an attributes 
object with the exogenous covariate information has to be supplied to the
<code>attr_actors</code> argument in either <code>remstats()</code> or in the separate
effect functions supplied to the <code>..._effects</code> arguments (e.g., see
<code><a href="#topic+send">send</a></code>). This <code>attr_actors</code> object should be constructed as
follows: A dataframe with rows referring to the attribute value of actor
<em>i</em> at timepoint <em>t</em>. A 'name' column is required that contains the
actor name (corresponding to the actor names in the relational event
history). A 'time' column is required that contains the time when attributes
change (set to zero if none of the attributes vary over time). Subsequent
columns contain the attributes that are called in the specifications of
exogenous statistics (column name corresponding to the string supplied to
the <code>variable</code> argument in the effect function). Note that the
procedure for the exogenous effects &lsquo;tie&rsquo; and &lsquo;event&rsquo; deviates from this,
here the exogenous covariate information has to be specified in a different
way, see <code><a href="#topic+tie">tie</a></code> and <code><a href="#topic+event">event</a></code>.
</p>


<h3>attr_dyads</h3>

<p>For the computation of the <em>dyad exogenous</em> statistics with 
<code>tie()</code>, an attributes object with the exogenous covariates information 
per dyad has to be supplied. This is a <code>data.frame</code> or <code>matrix</code> 
containing attribute information for dyads. If <code>attr_dyads</code> is a 
<code>data.frame</code>, the first two columns should represent &quot;actor1&quot; and 
&quot;actor2&quot; (for directed events, &quot;actor1&quot; corresponds to the sender, and 
&quot;actor2&quot; corresponds to the receiver). Additional columns can represent 
dyads' exogenous attributes. If attributes vary over time, include a column 
named &quot;time&quot;. If <code>attr_dyads</code> is a <code>matrix</code>, the rows correspond 
to &quot;actor1&quot;, columns to &quot;actor2&quot;, and cells contain dyads' exogenous 
attributes.
</p>


<h3>Memory</h3>

<p>The default 'memory' setting is '&quot;full&quot;', which implies that at each time
point $t$ the entire event history before $t$ is included in the computation
of the statistics. Alternatively, when 'memory' is set to '&quot;window&quot;', only
the past event history within a given time window is considered (see
Mulders &amp; Leenders, 2019). This length of this time window is set by the
'memory_value' parameter. For example, when 'memory_value = 100' and 'memory
= &quot;window&quot;', at time point $t$ only the past events that happened at most
100 time units ago are included in the computation of the statistics.
A third option is to set 'memory' to '&quot;interval&quot;'. In this case, the past
event history within a given time interval is considered. For example, when
'&quot;memory_value&quot; = c(50, 100)' and 'memory = &quot;window&quot;', at time point $t$
only the past events that happened between 50 and 100 time units ago are
included in the computation of the statistics. Finally, the fourth option is
to set 'memory' to '&quot;decay&quot;'. In this case, the weight of the past event in
the computation of the statistics depend on the elapsed time between $t$ and
the past event. This weight is determined based on an exponential decay
function with half-life parameter 'memory_value' (see Brandes et al., 2009).
</p>


<h3>Event weights</h3>

<p>Note that if the relational event history contains a column that is named
&ldquo;weight&rdquo;, it is assumed that these affect the endogenous statistics. These
affect the computation of all endogenous statistics with a few exceptions
that follow logically from their definition (e.g., the recenyContinue
statistic does depend on time since the event and not on event weights).
</p>


<h3>Subset the event history using 'start' and 'stop'</h3>

<p>It is possible to compute statistics for a segment of the relational event 
sequence, based on the entire event history. This is done by specifying the 
'start' and 'stop' values as the indices for the first and last event times 
for which statistics are needed. For instance, setting 'start = 5' and 'stop 
= 5' calculates statistics for the 5th event in the relational event 
sequence, considering events 1-4 in the history. Note that in cases of 
simultaneous events with the 'method' set to 'pt' (per timepoint), 'start' 
and 'stop' should correspond to the indices of the first and last 
<em>unique</em> event timepoints for which statistics are needed. For example, 
if 'start = 5' and 'stop = 5', statistics are computed for the 5th unique 
timepoint in the relational event sequence, considering all events occurring 
at unique timepoints 1-4.
</p>


<h3>Adjacency matrix</h3>

<p>Optionally, a previously computed adjacency matrix can be supplied. Note
that the endogenous statistics will be computed based on this adjacency
matrix. Hence, supplying a previously computed adjacency matrix can reduce
computation time but the user should be absolutely sure the adjacency matrix
is accurate.
</p>


<h3>References</h3>

<p>Butts, C. T. (2008). A relational event framework for social
action. Sociological Methodology, 38(1), 155–200.
<a href="https://doi.org/10.1111/j.1467-9531.2008.00203.x">doi:10.1111/j.1467-9531.2008.00203.x</a>,
Stadtfeld, C., &amp; Block, P. (2017). Interactions, actors, and
time: Dynamic network actor models for relational events. Sociological
Science, 4, 318–352. <a href="https://doi.org/10.15195/v4.a14">doi:10.15195/v4.a14</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(remstats)

# Tie-oriented model
eff &lt;- ~ inertia():send("extraversion") + otp()
reh_tie &lt;- remify::remify(edgelist = history, model = "tie")
remstats(reh = reh_tie, tie_effects = eff, attr_actors = info)

# Actor-oriented model
seff &lt;- ~ send("extraversion")
reff &lt;- ~ receive("agreeableness") + inertia() + otp()
reh_actor &lt;- remify::remify(edgelist = history, model = "actor")
remstats(
    reh = reh_actor, sender_effects = seff, receiver_effects = reff,
    attr_actors = info
)

</code></pre>

<hr>
<h2 id='rrankReceive'>rrankReceive</h2><span id='topic+rrankReceive'></span>

<h3>Description</h3>

<p>Specifies the statistic for a recency rank receive effect in the
<code>effects</code> argument of <code><a href="#topic+tomstats">tomstats</a></code> or the
<code>receiver_effects</code> argument of <code><a href="#topic+aomstats">aomstats</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrankReceive(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrankReceive_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to discriminate between
event types in determining the event rank (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rrankSend effect refers to a rank-based recency effect, as described in
section 2.2.5 of Butts (2008). For each timepoint t, for directed dyad (i,j)
the statistic is equal to the inverse of the rank of receiver j among the
actors from which sender i has most recently received past events. Note that
the 'rrankReceive' effect is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrankSend">rrankSend</a></code>, <code><a href="#topic+recencySendSender">recencySendSender</a></code>,
<code><a href="#topic+recencySendReceiver">recencySendReceiver</a></code>, <code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a></code>,
<code><a href="#topic+recencyReceiveReceiver">recencyReceiveReceiver</a></code> and <code><a href="#topic+recencyContinue">recencyContinue</a></code> for
other type of recency effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ rrankReceive()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(receiver_effects = effects, reh = reh_actor)

</code></pre>

<hr>
<h2 id='rrankSend'>rrankSend</h2><span id='topic+rrankSend'></span><span id='topic+recencyRank'></span><span id='topic+rrank'></span>

<h3>Description</h3>

<p>Specifies the statistic for a recency rank send effect in the
<code>effects</code> argument of <code><a href="#topic+tomstats">tomstats</a></code> or the
<code>receiver_effects</code> argument of <code><a href="#topic+aomstats">aomstats</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrankSend(consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrankSend_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to discriminate between
event types in determining the event rank (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rrankSend effect refers to a rank-based recency effect, as described in
section 2.2.5 of Butts (2008). For each timepoint t, for directed dyad (i,j)
the statistic is equal to the inverse of the rank of receiver j among the
actors to which sender i has most recently send past events. Note that the
'rrankSend' effect is only defined for directed events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrankReceive">rrankReceive</a></code>, <code><a href="#topic+recencySendSender">recencySendSender</a></code>,
<code><a href="#topic+recencySendReceiver">recencySendReceiver</a></code>, <code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a></code>,
<code><a href="#topic+recencyReceiveReceiver">recencyReceiveReceiver</a></code> and <code><a href="#topic+recencyContinue">recencyContinue</a></code> for
other type of recency effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ rrankSend()
remstats(tie_effects = effects, reh = reh_tie)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(receiver_effects = effects, reh = reh_actor)

</code></pre>

<hr>
<h2 id='same'>same</h2><span id='topic+same'></span>

<h3>Description</h3>

<p>Specifies the statistic for a &quot;same&quot; effect in the tie-oriented model or the
receiver choice step of the actor-oriented model. A &quot;same&quot; effect refers to
an exogenous actor attribute that affects dyad <em>(i,j)</em>'s rate of
interacting (tie-oriented model) or actor <em>j</em>'s probability of being
chosen as a receiver for the event send by the active sender <em>i</em> at
time <em>t</em> (actor-oriented model) based on whether actors <em>i</em> and
<em>j</em> have the same value (or not) on this attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same(variable, attr_actors = NULL, attr_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="same_+3A_variable">variable</code></td>
<td>
<p>string with the name of the column in the
<code>attr_actors</code> object for which the statistic has to be computed.</p>
</td></tr>
<tr><td><code id="same_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the attribute, see
'Details.'</p>
</td></tr>
<tr><td><code id="same_+3A_attr_data">attr_data</code></td>
<td>
<p>Deprecated argument. Please use 'attr_actors' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic at timepoint <em>t</em> is equal to one for dyads <em>(i,j)</em>
that have the same value on the attribute at timepoint <em>t</em>
(tie-oriented model) or one for receivers <em>j</em> that have the same value
on the attribute as the active sender <em>i</em> at timepoint <em>t</em>
(actor-oriented model) and equal to 0 for dyads and receivers that do not
have the same value.
</p>
<p>Construct the 'attr_actors' object as a data frame where each row represents 
the attribute value of actor <em>i</em> at timepoint <em>t</em>:
</p>

<ul>
<li><p>name: The actors' name.
</p>
</li>
<li><p>time: The time when the attribute values change.
</p>
</li>
<li><p>variable: The third column contains the attribute used in the
specification of the &quot;difference&quot; effect. The column name should correspond
to the string supplied to the <code>variable</code> argument in the 'difference()'
function.
</p>
</li></ul>

<p>Note that it is possible to omit the 'attr_actors' object in the call of
<code>difference()</code> and, instead, supply it in the call of <code>remstats()</code>
for multiple exogenous effects.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ same("age")
remstats(reh = reh_tie, tie_effects = effects, attr_actors = info)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects, attr_actors = info)

</code></pre>

<hr>
<h2 id='send'>send</h2><span id='topic+send'></span>

<h3>Description</h3>

<p>Specifies the statistic for a &quot;send&quot; effect in the tie-oriented model or the
actor activity rate step of the actor-oriented model. A &quot;send&quot; effect refers
to an exogenous actor attribute that affects actor <em>i</em>'s rate of
sending events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send(variable, attr_actors = NULL, scaling = c("none", "std"), attr_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send_+3A_variable">variable</code></td>
<td>
<p>string with the name of the column in the
<code>attr_actors</code> object for which the statistic has to be computed.</p>
</td></tr>
<tr><td><code id="send_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the attribute, see
'Details.'</p>
</td></tr>
<tr><td><code id="send_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the statistic. Default is to not scale
the statistic. Alternatively, standardization of the
statistic per time point can be requested with &quot;std&quot;.</p>
</td></tr>
<tr><td><code id="send_+3A_attr_data">attr_data</code></td>
<td>
<p>Deprecated argument. Please use 'attr_actors' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic at timepoint <em>t</em> is equal to the value of the exogenous
attribute for actor <em>i</em> at time <em>t</em> for all dyads in the risk set
that have actor <em>i</em> as sender. Note that a &quot;send&quot; effect is only
defined for directed relational events.
</p>
<p>Construct the 'attr_actors' object as a data frame where each row represents 
the attribute value of actor <em>i</em> at timepoint <em>t</em>:
</p>

<ul>
<li><p>name: The actors' name.
</p>
</li>
<li><p>time: The time when the attribute values change.
</p>
</li>
<li><p>variable: The third column contains the attribute used in the
specification of the &quot;difference&quot; effect. The column name should correspond
to the string supplied to the <code>variable</code> argument in the 'difference()'
function.
</p>
</li></ul>

<p>Note that it is possible to omit the 'attr_actors' object in the call of
<code>difference()</code> and, instead, supply it in the call of <code>remstats()</code>
for multiple exogenous effects.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(history)
data(info)

# Tie-oriented model
reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ send("extraversion")
remstats(reh = reh_tie, tie_effects = effects, attr_actors = info)

# Actor-oriented model
reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, sender_effects = effects, attr_actors = info)

</code></pre>

<hr>
<h2 id='sp'>sp</h2><span id='topic+sp'></span>

<h3>Description</h3>

<p>Specifies the statistic for a shared partners effect for undirected events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp(unique = FALSE, scaling = c("none", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_+3A_unique">unique</code></td>
<td>
<p>A logical value indicating whether to sum the minimum of
events with third actors (FALSE, default) or the number of third actors that
create a new, unique shared partner (TRUE). See details for more information.</p>
</td></tr>
<tr><td><code id="sp_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the triad statistic. Default is to not
scale the statistic but keep the raw 'counts'. Alternatively,
standardization of the raw counts per time point can be requested
with 'std'.</p>
</td></tr>
<tr><td><code id="sp_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the shared partners
separately for each event type (TRUE, default) or sum across different event
types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shared partners effect describes the propensity of dyads to interact
based on the number of past shared partners between them. By default, the
statistic at timepoint t for the undirected dyad (i,j) is computed as
the sum of the minimum occurrences of past undirected (i,h) and undirected
(j,h) events across all actors h.
</p>
<p>When the unique parameter is set to TRUE, a different approach is taken.
In this case, the statistic counts the number of actors h that contribute to
the creation of a new, distinct shared partner between actors i and j.
</p>
<p>Additionally, it is possible to specify a scaling method using the scaling
parameter.
</p>
<p>Please note that the shared partners effect, 'sp', is exclusively defined
for undirected events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+otp">otp</a></code>, <code><a href="#topic+itp">itp</a></code>, <code><a href="#topic+osp">osp</a></code>, or
<code><a href="#topic+isp">isp</a></code> for triadic effects for directed relational events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie", directed = FALSE)
effects &lt;- ~ sp()
remstats(tie_effects = effects, reh = reh_tie)

</code></pre>

<hr>
<h2 id='spUnique'>spUnique</h2><span id='topic+spUnique'></span>

<h3>Description</h3>

<p>Deprecated. Use <code><a href="#topic+sp">sp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spUnique()
</code></pre>


<h3>Value</h3>

<p>Warning.
</p>

<hr>
<h2 id='summary.remstats'>Relational Event Network Statistics Summaries</h2><span id='topic+summary.remstats'></span>

<h3>Description</h3>

<p>Produce summaries of each statistic from a <code><a href="#topic+remstats">remstats</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remstats'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.remstats_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+remstats">remstats</a></code>.</p>
</td></tr>
<tr><td><code id="summary.remstats_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summaries provide information for each statistic included in the 
remstats object, offering insights into the distribution and characteristics 
of the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rehObject &lt;- remify::remify(edgelist = history, model = "tie")
remstatsObject &lt;- remstats::remstats(reh = rehObject, tie_effects = ~ remstats::inertia())
summary(remstatsObject)

rehObject &lt;- remify::remify(edgelist = history, model = "actor")
remstatsObject &lt;- remstats::remstats(reh = rehObject, receiver_effects = ~ inertia())
summary(remstatsObject)

</code></pre>

<hr>
<h2 id='tie'>tie</h2><span id='topic+tie'></span><span id='topic+dyad'></span>

<h3>Description</h3>

<p>Specifies the statistic for a &quot;tie&quot; (or, &quot;dyad&quot;) effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tie(variable, attr_dyads = NULL, scaling = c("none", "std"), x, variableName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tie_+3A_variable">variable</code></td>
<td>
<p>A string specifying the attribute to compute the statistic. If <code>attr_dyads</code> is a <code>data.frame</code>, this refers to the column name in <code>attr_actors</code>. If <code>attr_dyads</code> is a <code>matrix</code>, this corresponds to the name of the exogenous attribute, used to label the statistic in the resulting <code>remstats</code> object.</p>
</td></tr>
<tr><td><code id="tie_+3A_attr_dyads">attr_dyads</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> containing attribute information for dyads. If <code>attr_dyads</code> is a <code>data.frame</code>, the first two columns should represent &quot;actor1&quot; and &quot;actor2&quot; (for directed events, &quot;actor1&quot; corresponds to the sender, and &quot;actor2&quot; corresponds to the receiver). Additional columns can represent dyads' exogenous attributes. If attributes vary over time, include a column named &quot;time&quot;. If <code>attr_dyads</code> is a <code>matrix</code>, the rows correspond to &quot;actor1&quot;, columns to &quot;actor2&quot;, and cells contain dyads' exogenous attributes.</p>
</td></tr>
<tr><td><code id="tie_+3A_scaling">scaling</code></td>
<td>
<p>The method for scaling the statistic. The default is no scaling. Alternatively, standardization of the statistic per time point can be requested with &quot;std&quot;.</p>
</td></tr>
<tr><td><code id="tie_+3A_x">x</code></td>
<td>
<p>Deprecated argument. Please use 'attr_dyads' instead.</p>
</td></tr>
<tr><td><code id="tie_+3A_variablename">variableName</code></td>
<td>
<p>Deprecated argument. Please use 'variable' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;tie&quot; effect or &quot;dyad&quot; effect refers to an exogenous dyad attribute that influences dyad <em>(i,j)</em>'s interaction rate (in tie-oriented models) or the probability of actor <em>j</em> being chosen as a receiver for the event sent by the active sender <em>i</em> (in actor-oriented models). The statistic represents the value of the exogenous attribute for dyad <em>(i,j)</em> in the <code>attr_dyads</code> data.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(history)
data(both_male_long)
effect &lt;- ~ tie(variable = "both_male", attr_dyads = both_male_long)
reh &lt;- remify::remify(history, model = "tie")
remstats(reh = reh, tie_effects = effect)

data(both_male_wide)
effect &lt;- ~ tie(variable = "both_male", attr_dyads = both_male_wide)
reh &lt;- remify::remify(history, model = "tie")
remstats(reh = reh, tie_effects = effect)

</code></pre>

<hr>
<h2 id='tie_effects'>tie_effects</h2><span id='topic+tie_effects'></span>

<h3>Description</h3>

<p>Overview of statistics in the tie-oriented model, see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tie_effects(directed = NULL, endogenous = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tie_effects_+3A_directed">directed</code></td>
<td>
<p>logical value. The function outputs all statistics in the 
tie-oriented model for directed events if true, or all statistics in the 
tie-oriented model for undirected events if false.</p>
</td></tr>
<tr><td><code id="tie_effects_+3A_endogenous">endogenous</code></td>
<td>
<p>logical value. The function outputs all endogenous 
statistics in the tie-oriented model if true, or all exogenous statistics if 
false</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Overview of statistics in the tie-oriented model.
</p>
<p>Baseline:
</p>

<ul>
<li> <p><code><a href="#topic+baseline">baseline</a></code>
</p>
</li></ul>

<p>Exogenous statistics:
</p>

<ul>
<li> <p><code><a href="#topic+send">send</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+receive">receive</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+tie">tie</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+same">same</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+difference">difference</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+average">average</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+minimum">minimum</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+maximum">maximum</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+event">event</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+userStat">userStat</a>()</code>
</p>
</li></ul>

<p>Endogenous statistics:
</p>

<ul>
<li> <p><code><a href="#topic+indegreeSender">indegreeSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+indegreeReceiver">indegreeReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+outdegreeSender">outdegreeSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+outdegreeReceiver">outdegreeReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+totaldegreeSender">totaldegreeSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+totaldegreeReceiver">totaldegreeReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+totaldegreeDyad">totaldegreeDyad</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+degreeMin">degreeMin</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+degreeMax">degreeMax</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+degreeDiff">degreeDiff</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+inertia">inertia</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+reciprocity">reciprocity</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+otp">otp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+itp">itp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+osp">osp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+isp">isp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+sp">sp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABBA">psABBA</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABBY">psABBY</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABXA">psABXA</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABXB">psABXB</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABXY">psABXY</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABAY">psABAY</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+psABAB">psABAB</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+rrankSend">rrankSend</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+rrankReceive">rrankReceive</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencySendSender">recencySendSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencySendReceiver">recencySendReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencyReceiveSender">recencyReceiveSender</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencyReceiveReceiver">recencyReceiveReceiver</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+recencyContinue">recencyContinue</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+FEtype">FEtype</a>()</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a list of available effects and their corresponding statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List of available effects 
tie_effects()

# List of available effects for undirected networks
tie_effects(directed = FALSE)

# List of available endogenous effects for undirected networks
tie_effects(directed = FALSE, endogenous = TRUE)

</code></pre>

<hr>
<h2 id='tomstats'>tomstats</h2><span id='topic+tomstats'></span>

<h3>Description</h3>

<p>Computes statistics for modeling relational event history data
with the tie-oriented relational event model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tomstats(
  effects,
  reh,
  attr_actors = NULL,
  attr_dyads = NULL,
  method = c("pt", "pe"),
  memory = c("full", "window", "decay", "interval"),
  memory_value = NA,
  start = 1,
  stop = Inf,
  display_progress = FALSE,
  adjmat = NULL,
  get_adjmat = FALSE,
  attr_data,
  attributes,
  edgelist
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tomstats_+3A_effects">effects</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one
that can be coerced to that class): a symbolic description of the effects in
the model for which statistics are computed, see 'Details' for the available
effects and their corresponding statistics</p>
</td></tr>
<tr><td><code id="tomstats_+3A_reh">reh</code></td>
<td>
<p>an object of class <code>"<a href="remify.html#topic+remify">remify</a>"</code> characterizing 
the relational event history.</p>
</td></tr>
<tr><td><code id="tomstats_+3A_attr_actors">attr_actors</code></td>
<td>
<p>optionally, an object of class
<code>"<a href="base.html#topic+data.frame">data.frame</a>"</code> that contains exogenous attributes for 
actors (see Details).</p>
</td></tr>
<tr><td><code id="tomstats_+3A_attr_dyads">attr_dyads</code></td>
<td>
<p>optionally, an object of class <code>data.frame</code> or 
<code>matrix</code> containing attribute information for dyads (see Details).</p>
</td></tr>
<tr><td><code id="tomstats_+3A_method">method</code></td>
<td>
<p>Specifies the method for managing simultaneous events, i.e., 
events occurring at the same time. The default 'method' is 'pt' (per 
timepoint), where statistics are computed once for each unique timepoint in 
the edgelist. Alternatively, you can choose 'pe' (per event), where 
statistics are computed once for each unique event observed in the edgelist.</p>
</td></tr>
<tr><td><code id="tomstats_+3A_memory">memory</code></td>
<td>
<p>The memory to be used. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="tomstats_+3A_memory_value">memory_value</code></td>
<td>
<p>Numeric value indicating the memory parameter. See
&lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="tomstats_+3A_start">start</code></td>
<td>
<p>an optional integer value, specifying the index of the first
time or event in the relational event history for which statistics must be 
computed (see 'Details')</p>
</td></tr>
<tr><td><code id="tomstats_+3A_stop">stop</code></td>
<td>
<p>an optional integer value, specifying the index of the last
time or event in the relational event history for which statistics must be 
computed (see 'Details')</p>
</td></tr>
<tr><td><code id="tomstats_+3A_display_progress">display_progress</code></td>
<td>
<p>should a progress bar for the computation of the
endogenous statistics be shown (TRUE) or not (FALSE)?</p>
</td></tr>
<tr><td><code id="tomstats_+3A_adjmat">adjmat</code></td>
<td>
<p>optionally, a previously computed adjacency matrix with on the
rows the time points and on the columns the risk set entries</p>
</td></tr>
<tr><td><code id="tomstats_+3A_get_adjmat">get_adjmat</code></td>
<td>
<p>whether the adjmat computed by tomstats should be
outputted as an attribute of the statistics.</p>
</td></tr>
<tr><td><code id="tomstats_+3A_attr_data">attr_data</code></td>
<td>
<p>deprecated, please use &quot;attr_actors&quot; instead</p>
</td></tr>
<tr><td><code id="tomstats_+3A_attributes">attributes</code></td>
<td>
<p>deprecated, please use &quot;attr_data&quot; instead</p>
</td></tr>
<tr><td><code id="tomstats_+3A_edgelist">edgelist</code></td>
<td>
<p>deprecated, please use &quot;reh&quot; instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'tomstats'. Array with the computed statistics,
where rows refer to time points, columns refer to potential relational event
(i.e., potential edges) in the risk set and slices refer to statistics. The
'tomstats' object has the following attributes:
</p>

<dl>
<dt><code>model</code></dt><dd><p>Type of model that is estimated.</p>
</dd>
<dt><code>formula</code></dt><dd><p>Model formula, obtained from the formula inputted to 'tie_effects'.</p>
</dd>
<dt><code>riskset</code></dt><dd><p>The risk set used to construct the statistics.</p>
</dd>
<dt><code>adjmat</code></dt><dd><p>[Optional], if &quot;get_adjmat = TRUE&quot;, the matrix with the accumulated event weights for each time point (on the rows) and each dyad (in the columns).</p>
</dd>
</dl>



<h3>Effects</h3>

<p>The statistics to be computed are defined symbolically and should be
supplied to the <code>effects</code> argument in the form <code>~ effects</code>. The
terms are separated by + operators. For example:
<code>effects = ~ inertia() + otp()</code>. Interactions between two effects
can be included with * operators. For example:
<code>effects = ~ inertia()*otp()</code>. A list of available effects can be
obtained with <code><a href="#topic+tie_effects">tie_effects</a>()</code>.
</p>
<p>The majority of the statistics can be scaled in some way, see
the documentation of the <code>scaling</code> argument in the separate effect
functions for more information on this.
</p>
<p>The majority of the statistics can account for the event type
included as a dependent variable, see the documentation of the
<code>consider_type</code> argument in the separate effect functions for more
information on this.
</p>
<p>Note that events in the relational event history can be directed or
undirected. Some statistics are only defined for either directed or
undirected events (see the documentation of the statistics). Note that
undirected events are only available for the tie-oriented model.
</p>


<h3>attr_actors</h3>

<p>For the computation of the <em>exogenous</em> statistics an attributes object
with the exogenous covariate information has to be supplied to the
<code>attr_actors</code> argument in either <code>remstats()</code> or in the separate
effect functions supplied to the <code>..._effects</code> arguments (e.g., see
<code><a href="#topic+send">send</a></code>). This <code>attr_actors</code> object should be constructed as
follows: A dataframe with rows referring to the attribute value of actor
<em>i</em> at timepoint <em>t</em>. A 'name' column is required that contains the
actor name (corresponding to the actor names in the relational event
history). A 'time' column is required that contains the time when attributes
change (set to zero if none of the attributes vary over time). Subsequent
columns contain the attributes that are called in the specifications of
exogenous statistics (column name corresponding to the string supplied to
the <code>variable</code> argument in the effect function). Note that the
procedure for the exogenous effects &lsquo;tie&rsquo; and &lsquo;event&rsquo; deviates from this,
here the exogenous covariate information has to be specified in a different
way, see <code><a href="#topic+tie">tie</a></code> and <code><a href="#topic+event">event</a></code>.
</p>


<h3>attr_dyads</h3>

<p>For the computation of the <em>dyad exogenous</em> statistics with <code>tie()</code>, an attributes object with the exogenous covariates information per dyad has to be supplied. This is a <code>data.frame</code> or <code>matrix</code> containing attribute information for dyads. If <code>attr_dyads</code> is a <code>data.frame</code>, the first two columns should represent &quot;actor1&quot; and &quot;actor2&quot; (for directed events, &quot;actor1&quot; corresponds to the sender, and &quot;actor2&quot; corresponds to the receiver). Additional columns can represent dyads' exogenous attributes. If attributes vary over time, include a column named &quot;time&quot;. If <code>attr_dyads</code> is a <code>matrix</code>, the rows correspond to &quot;actor1&quot;, columns to &quot;actor2&quot;, and cells contain dyads' exogenous attributes.
</p>


<h3>Memory</h3>

<p>The default 'memory' setting is '&quot;full&quot;', which implies that at each time
point $t$ the entire event history before $t$ is included in the computation
of the statistics. Alternatively, when 'memory' is set to '&quot;window&quot;', only
the past event history within a given time window is considered (see
Mulders &amp; Leenders, 2019). This length of this time window is set by the
'memory_value' parameter. For example, when 'memory_value = 100' and 'memory
= &quot;window&quot;', at time point $t$ only the past events that happened at most
100 time units ago are included in the computation of the statistics.
A third option is to set 'memory' to '&quot;interval&quot;'. In this case, the past
event history within a given time interval is considered. For example, when
'&quot;memory_value&quot; = c(50, 100)' and 'memory = &quot;window&quot;', at time point $t$
only the past events that happened between 50 and 100 time units ago are
included in the computation of the statistics. Finally, the fourth option is
to set 'memory' to '&quot;decay&quot;'. In this case, the weight of the past event in
the computation of the statistics depend on the elapsed time between $t$ and
the past event. This weight is determined based on an exponential decay
function with half-life parameter 'memory_value' (see Brandes et al., 2009).
</p>


<h3>Event weights</h3>

<p>Note that if the relational event history contains a column that is named
&ldquo;weight&rdquo;, it is assumed that these affect the endogenous statistics. These
affect the computation of all endogenous statistics with a few exceptions
that follow logically from their definition (e.g., the recenyContinue
statistic does depend on time since the event and not on event weights).
</p>


<h3>Subset the event history using 'start' and 'stop'</h3>

<p>It is possible to compute statistics for a segment of the relational event 
sequence, based on the entire event history. This is done by specifying the 
'start' and 'stop' values as the indices for the first and last event times 
for which statistics are needed. For instance, setting 'start = 5' and 'stop 
= 5' calculates statistics for the 5th event in the relational event 
sequence, considering events 1-4 in the history. Note that in cases of 
simultaneous events with the 'method' set to 'pt' (per timepoint), 'start' 
and 'stop' should correspond to the indices of the first and last 
<em>unique</em> event timepoints for which statistics are needed. For example, 
if 'start = 5' and 'stop = 5', statistics are computed for the 5th unique 
timepoint in the relational event sequence, considering all events occurring 
at unique timepoints 1-4.
</p>


<h3>Adjacency matrix</h3>

<p>Optionally, a previously computed adjacency matrix can be supplied. Note
that the endogenous statistics will be computed based on this adjacency
matrix. Hence, supplying a previously computed adjacency matrix can reduce
computation time but the user should be absolutely sure the adjacency matrix
is accurate.
</p>


<h3>References</h3>

<p>Butts, C. T. (2008). A relational event framework for social
action. Sociological Methodology, 38(1), 155–200.
<a href="https://doi.org/10.1111/j.1467-9531.2008.00203.x">doi:10.1111/j.1467-9531.2008.00203.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(remstats)

# Load data
data(history)
data(info)

# Prepare data
reh &lt;- remify::remify(edgelist = history, model = "tie")

# Compute effects
effects &lt;- ~ inertia():send("extraversion") + otp()
tomstats(effects, reh = reh, attr_actors = info)

</code></pre>

<hr>
<h2 id='totaldegreeDyad'>totaldegreeDyad</h2><span id='topic+totaldegreeDyad'></span>

<h3>Description</h3>

<p>Specifies the statistic for a 'totaldegreeDyad' effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totaldegreeDyad(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totaldegreeDyad_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by two times the number of past events at
time t can be requested with 'prop' or standardization of the raw degree
counts per time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="totaldegreeDyad_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'totaldegreeDyad' effect refers to the tendency of pairs of actors
(dyads) to increase their interaction rate as the total degree (number of
interactions) of both actors in the pair goes up. To calculate this effect
for a specific pair (i,j) at a given timepoint (t), we sum the degrees of
the two actors in the dyad (i,j).
</p>
<p>Additionally, there is an optional scaling method, which can be chosen using
the 'scaling' method. When the 'prop' scaling method is applied, the degree
count is divided by two times the total number of past events. This scaling
converts the statistic into a fraction, representing the proportion of past
events in which at least one actor in the dyad was involved. For the first
timepoint, where no events have previously occurred, it is assumed that each
actor is equally likely to be involved in an event. In this case, the
statistic is set to 1 divided by the total number of actors (N).
</p>
<p>The totaldegreeDyad effect is defined for the tie-oriented model and is
applicable to both directed and undirected events.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ totaldegreeDyad()
remstats(reh = reh_tie, tie_effects = effects)

</code></pre>

<hr>
<h2 id='totaldegreeReceiver'>totaldegreeReceiver</h2><span id='topic+totaldegreeReceiver'></span>

<h3>Description</h3>

<p>Specifies the statistic for an 'totaldegreeReceiver' effect in the
tie-oriented model or the receiver choice step of the actor-oriented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totaldegreeReceiver(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totaldegreeReceiver_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by two times the number of past events at
time t can be requested with 'prop' or standardization of the raw degree
counts per time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="totaldegreeReceiver_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A total degree of the receiver effect refers to the tendency for actors to
receive events if they have send and received more past events. The
statistic at timepoint <em>t</em> for dyad <em>(i,j)</em> (tie-oriented model)
or receiver <em>j</em> (actor-oriented model) is equal to the number
of events send and received by actor <em>j</em> before timepoint <em>t</em>.
Note that the 'totaldegreeReceiver' effect is only defined for directed
events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
degree count by the total number of past events times two, the statistic
refers to the fraction of past events times two that involved actor j. At
the first time point, when no events did previously occur, it is assumed
that every actor is equally likely to receive a message and the statistic is
set equal to 1/n, where n refers to the number of actors.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indegreeSender">indegreeSender</a></code>, <code><a href="#topic+indegreeReceiver">indegreeReceiver</a></code>,
<code><a href="#topic+outdegreeSender">outdegreeSender</a></code>, <code><a href="#topic+outdegreeReceiver">outdegreeReceiver</a></code>, or
<code><a href="#topic+totaldegreeSender">totaldegreeSender</a></code> for other types of degree effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reh_tie &lt;- remify::remify(history, model = "tie")
effects &lt;- ~ totaldegreeReceiver()
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, receiver_effects = effects)

</code></pre>

<hr>
<h2 id='totaldegreeSender'>totaldegreeSender</h2><span id='topic+totaldegreeSender'></span><span id='topic+totaldegree'></span>

<h3>Description</h3>

<p>Specifies the statistic for an 'totaldegreeSender' effect in the
tie-oriented model or the sender activity rate step of the actor-oriented
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totaldegreeSender(scaling = c("none", "prop", "std"), consider_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totaldegreeSender_+3A_scaling">scaling</code></td>
<td>
<p>the method for scaling the degree statistic. Default is
to not scale the statistic (scaling = &quot;none&quot;). Alternatively,
scaling of the raw degree counts by two times the number of past events at
time t can be requested with 'prop' or standardization of the raw degree
counts per time point can be requested with 'std'.</p>
</td></tr>
<tr><td><code id="totaldegreeSender_+3A_consider_type">consider_type</code></td>
<td>
<p>logical, indicates whether to count the degrees
separately for each event type (TRUE, default) or sum degrees across
different event types (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A total degree of the sender effect refers to the tendency for actors to
send events if they have send and received more past events. The statistic
at timepoint <em>t</em> for dyad <em>(i,j)</em> (tie-oriented model) or sender
<em>i</em> (actor-oriented model) is equal to the number of events
send and received by actor <em>i</em> before timepoint <em>t</em>. Note that the
'totaldegreeSender' effect is only defined for directed events.
</p>
<p>Optionally, a scaling method can be set with <code>scaling</code>. By scaling the
degree count by the total number of past events times two, the statistic
refers to the fraction of past events times two that involved actor i. At
the first time point, when no events did previously occur, it is assumed
that every actor is equally likely to send a message and the statistic is
set equal to 1/n, where n refers to the number of actors.
</p>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to compute the statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indegreeSender">indegreeSender</a></code>, <code><a href="#topic+indegreeReceiver">indegreeReceiver</a></code>,
<code><a href="#topic+outdegreeSender">outdegreeSender</a></code>, <code><a href="#topic+outdegreeReceiver">outdegreeReceiver</a></code>, or
<code><a href="#topic+totaldegreeReceiver">totaldegreeReceiver</a></code> for other types of degree effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>effects &lt;- ~ totaldegreeSender()
reh_tie &lt;- remify::remify(history, model = "tie")
remstats(reh = reh_tie, tie_effects = effects)

reh_actor &lt;- remify::remify(history, model = "actor")
remstats(reh = reh_actor, sender_effects = effects)

</code></pre>

<hr>
<h2 id='userStat'>userStat</h2><span id='topic+userStat'></span>

<h3>Description</h3>

<p>Allows the user to add its own pre-computed statistic to the statistics
object and, optionally, interact this statistic with other statistics in the
formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>userStat(x, variableName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="userStat_+3A_x">x</code></td>
<td>
<p>Matrix with number of rows equal to the number of events and number
of columns equal to the number of dyads in the network (tie-oriented model) 
or the number of actors in the network (actor-oriented model)</p>
</td></tr>
<tr><td><code id="userStat_+3A_variablename">variableName</code></td>
<td>
<p>Optionally, a string with the name of the statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with all information required by 'remstats::remstats()' to 
compute the statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 reh &lt;- remify::remify(history, model = "tie")
 actor101Events &lt;- which(history$actor1 == "101" | history$actor2 == "101")
 actor101_stat &lt;- t(sapply(seq_len(nrow(history)), function(i) {
   rep(i %in% actor101Events, reh$D)
 }))
 
 # Main effects only
 effects &lt;- ~ userStat(x = actor101_stat, variableName = "actor101event")
 remstats(reh = reh, tie_effects = effects)
 
 # Model with interaction effects
 interaction_effects &lt;- ~ inertia() *
   userStat(x = actor101_stat, variableName = "actor101event")
 remstats(reh = reh, tie_effects = interaction_effects)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
