<!DOCTYPE html><html><head><title>Help for package bang</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bang}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bang-package'><p>bang: Bayesian Analysis, No Gibbs</p></a></li>
<li><a href='#coagulation'><p>Coagulation time data</p></a></li>
<li><a href='#hanova1'><p>Posterior sampling for a 1-way hierarchical ANOVA</p></a></li>
<li><a href='#hef'><p>Hierarchical Exponential Family Model</p></a></li>
<li><a href='#plot.hef'><p>Plot diagnostics for a hef object</p></a></li>
<li><a href='#pp_check.hef'><p>Posterior predictive checks for a hef object</p></a></li>
<li><a href='#print.hef'><p>Print method for objects of class &quot;hef&quot;</p></a></li>
<li><a href='#print.summary.hef'><p>Print method for objects of class &quot;summary.hef&quot;</p></a></li>
<li><a href='#pump'><p>Pump-failure data</p></a></li>
<li><a href='#rat'><p>Rat tumor data</p></a></li>
<li><a href='#set_user_prior'><p>Set a user-defined prior</p></a></li>
<li><a href='#sim_pred_beta_binom'><p>Simulate from a beta-binomial posterior predictive distribution</p></a></li>
<li><a href='#sim_pred_gamma_pois'><p>Simulate from a gamma-Poisson posterior predictive distribution</p></a></li>
<li><a href='#sim_pred_hanova1'><p>Simulate from a one-way hierarchical ANOVA posterior predictive distribution</p></a></li>
<li><a href='#summary.hef'><p>Summarizing hef objects</p></a></li>
<li><a href='#temp1'><p>Mid 21st Century Global Temperature Projection Data</p></a></li>
<li><a href='#temp2'><p>Late 21st Century Global Temperature Projection Data</p></a></li>
<li><a href='#weight_gain'><p>Weight Gained by Rats</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Analysis, No Gibbs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for the Bayesian analysis of some simple 
    commonly-used models, without using Markov Chain Monte Carlo (MCMC) 
    methods such as Gibbs sampling.  The 'rust' package
    <a href="https://cran.r-project.org/package=rust">https://cran.r-project.org/package=rust</a> is used to simulate a random 
    sample from the required posterior distribution, using the generalized 
    ratio-of-uniforms method.  See Wakefield, Gelfand and Smith (1991) 
    &lt;<a href="https://doi.org/10.1007%2FBF01889987">doi:10.1007/BF01889987</a>&gt; for details. At the moment three conjugate 
    hierarchical models are available: beta-binomial, gamma-Poisson and a 1-way 
    analysis of variance (ANOVA).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bayesplot (&ge; 1.1.0), graphics, rust (&ge; 1.2.2), stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2 (&ge; 2.2.1), knitr, MASS, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paulnorthrop.github.io/bang/">https://paulnorthrop.github.io/bang/</a>,
<a href="https://github.com/paulnorthrop/bang">https://github.com/paulnorthrop/bang</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paulnorthrop/bang/issues">https://github.com/paulnorthrop/bang/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-02 18:13:27 UTC; Paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul J. Northrop [aut, cre, cph],
  Benjamin D. Hall [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul J. Northrop &lt;p.northrop@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-02 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bang-package'>bang: Bayesian Analysis, No Gibbs</h2><span id='topic+bang'></span><span id='topic+bang-package'></span>

<h3>Description</h3>

<p>Performs Bayesian analyses using some simple commonly-used models.
The multivariate generalized ratio-of-uniforms method is used to simulate
random samples from the required posterior distribution.
The user can either choose hyperparameter values of a default prior
distribution or specify their own prior distribution.
</p>


<h3>Details</h3>

<p>Currently three conjugate hierarchical models are available:
beta-binomial, gamma-Poisson and 1-way Analysis of Variance (ANOVA).
The function <code><a href="#topic+hef">hef</a></code> produces random posterior samples from for the
beta-binomial and gamma-Poisson models.  The function <code><a href="#topic+hanova1">hanova1</a></code>
does this for the 1-way Analysis of Variance (ANOVA).
The <a href="https://cran.r-project.org/package=rust">rust</a> package is used to
produce these samples.
</p>
<p>See
vignette(&quot;bang-a-vignette&quot;, package = &quot;bang&quot;) for a brief introduction
to the package and
vignette(&quot;bang-b-hef-vignette&quot;, package = &quot;bang&quot;) and
vignette(&quot;bang-c-anova-vignette&quot;, package = &quot;bang&quot;) for illustrations
of the use of the <code><a href="#topic+hef">hef</a></code> and <code><a href="#topic+hanova1">hanova1</a></code> functions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul J. Northrop <a href="mailto:p.northrop@ucl.ac.uk">p.northrop@ucl.ac.uk</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Benjamin D. Hall <a href="mailto:benjamin.hall.16@ucl.ac.uk">benjamin.hall.16@ucl.ac.uk</a> [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>Northrop, P. J. (2017). rust: Ratio-of-Uniforms Simulation with
Transformation. R package version 1.2.3.
<a href="https://cran.r-project.org/package=rust">https://cran.r-project.org/package=rust</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hef">hef</a></code> for hierarchical exponential family models.
</p>
<p><code><a href="#topic+hanova1">hanova1</a></code> for hierarchical one-way analysis of
variance (ANOVA).
</p>
<p><code><a href="#topic+set_user_prior">set_user_prior</a></code> to set a user-defined prior.
</p>

<hr>
<h2 id='coagulation'>Coagulation time data</h2><span id='topic+coagulation'></span>

<h3>Description</h3>

<p>Coagulation time in seconds for blood drawn from 24 animals randomly
allocated to four different diets from Box, Hunter, and Hunter (1978).
The data frame <code>coagulation</code> has 24 rows and 2 columns.
Each row relates to a different animal.
Column 1 contains the coagulation times.
Column 2 contains a label for the type of diet: one of A, B, C or D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coagulation
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 2 columns.
</p>


<h3>Source</h3>

<p>Table 11.2 of Gelman, A., Carlin, J. B., Stern, H. S. Dunson, D. B.,
Vehtari, A. and Rubin, D. B. (2014) <em>Bayesian Data Analysis</em>.
Chapman &amp; Hall / CRC.
<a href="http://www.stat.columbia.edu/~gelman/book/">http://www.stat.columbia.edu/~gelman/book/</a>
</p>


<h3>References</h3>

<p>Box, G. E. P., Hunter, W. G., and Hunter, J. S. (1978).
Statistics for Experimenters. New York: Wiley.
</p>

<hr>
<h2 id='hanova1'>Posterior sampling for a 1-way hierarchical ANOVA</h2><span id='topic+hanova1'></span>

<h3>Description</h3>

<p>Produces random samples from the posterior distribution of the parameters
of a 1-way hierarchical ANOVA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hanova1(
  n = 1000,
  resp,
  fac,
  ...,
  prior = "default",
  hpars = NULL,
  param = c("trans", "original"),
  init = NULL,
  mu0 = 0,
  sigma0 = Inf,
  nrep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hanova1_+3A_n">n</code></td>
<td>
<p>A numeric scalar.  The size of posterior sample required.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_resp">resp</code></td>
<td>
<p>A numeric vector.  Response values.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_fac">fac</code></td>
<td>
<p>A vector of class <code><a href="base.html#topic+factor">factor</a></code> indicating the group from
which the corresponding element of <code>resp</code> originates.
Must have the same length as <code>resp</code>.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_...">...</code></td>
<td>
<p>Optional further arguments to be passed to
<code><a href="rust.html#topic+ru">ru</a></code>.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_prior">prior</code></td>
<td>
<p>The log-prior for the parameters of the hyperprior
distribution.  If the user wishes to specify their own prior then
<code>prior</code> must be an object returned from a call to
<code><a href="#topic+set_user_prior">set_user_prior</a></code>.
Otherwise, <code>prior</code> is a character scalar giving the name of the
required in-built prior.
If <code>prior</code> is not supplied then a default prior is used.
See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_hpars">hpars</code></td>
<td>
<p>A numeric vector.  Used to set parameters (if any) in
an in-built prior.  If <code>prior = cauchy</code> then <code>hpars</code> is
a numeric vector of length 2 giving the respective scale parameters
of the half-Cauchy priors for <code class="reqn">\sigma_\alpha</code> and <code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_param">param</code></td>
<td>
<p>A character scalar.
If <code>param = "trans"</code> (the default) then the marginal posterior
of hyperparameter vector <code class="reqn">\phi</code> is reparameterized in terms of
<code class="reqn">log \sigma_\alpha, log \sigma</code>.
If <code>param = "original"</code> the original parameterization,
i.e. <code class="reqn">\sigma_\alpha, \sigma</code> is used.
The former tends to make the optimizations involved in the
ratio-of-uniforms algorithm more stable and to increase the probability
of acceptance, but at the expense of slower function evaluations.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_init">init</code></td>
<td>
<p>A numeric vector. Optional initial estimates sent to
<code><a href="rust.html#topic+ru">ru</a></code> in the search for the mode of the posterior
density of (perhaps a subset of) the hyperparameter vector <code class="reqn">\phi</code>.
If an in-built prior is used then <code>ru</code> is used to sample from the
marginal posterior density of <code class="reqn">(\sigma_\alpha, \sigma)</code>, so
<code>init</code> must have length 2.  Otherwise, <code>init</code> has length
equal to the argument <code>anova_d</code> supplied to
<code><a href="#topic+set_user_prior">set_user_prior</a></code>.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_mu0">mu0</code>, <code id="hanova1_+3A_sigma0">sigma0</code></td>
<td>
<p>A numeric scalar.  Mean and standard deviation of a
normal prior for <code class="reqn">\mu</code>.  Only used if an in-built prior is used
or if <code>anova_d = 2</code> is supplied in a call to
<code><a href="#topic+set_user_prior">set_user_prior</a></code> to set a user-defined prior.
The default, <code>sigma0 = Inf</code>, sets an improper uniform prior
for <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code id="hanova1_+3A_nrep">nrep</code></td>
<td>
<p>A numeric scalar.  If <code>nrep</code> is not <code>NULL</code> then
<code>nrep</code> gives the number of replications of the original dataset
simulated from the posterior predictive distribution.
Each replication is based on one of the samples from the posterior
distribution.  Therefore, <code>nrep</code> must not be greater than <code>n</code>.
In that event <code>nrep</code> is set equal to <code>n</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider <code class="reqn">I</code> independent experiments in which the <code class="reqn">ni</code> responses
<strong><code class="reqn">y</code></strong><code class="reqn">i</code> from experiment/group <code class="reqn">i</code> are normally
distributed with mean <code class="reqn">\theta i</code> and standard deviation <code class="reqn">\sigma</code>.
The population parameters <code class="reqn">\theta</code>1, ...,
<code class="reqn">\theta</code><code class="reqn">I</code> are modelled as random samples from a normal
distribution with mean <code class="reqn">\mu</code> and standard deviation
<code class="reqn">\sigma_\alpha</code>.  Let <code class="reqn">\phi = (\mu, \sigma_\alpha, \sigma)</code>.
Conditionally on <code class="reqn">\theta</code>1, ..., <code class="reqn">\theta</code><code class="reqn">I</code>,
<strong><code class="reqn">y</code></strong>1, ..., <strong><code class="reqn">y</code></strong><code class="reqn">I</code>
are independent of each other and are independent of <code class="reqn">\phi</code>.
A <em>hyperprior</em> is placed on <code class="reqn">\phi</code>.
The user can either choose parameter values of a default hyperprior or
specify their own hyperprior using <code><a href="#topic+set_user_prior">set_user_prior</a></code>.
</p>
<p>The <code><a href="rust.html#topic+ru">ru</a></code> function in the <code><a href="rust.html#topic+rust">rust</a></code>
package is used to draw a random sample from the marginal posterior
of the hyperparameter vector <code class="reqn">\phi</code>.
Then, conditional on these values, population parameters are sampled
directly from the conditional posterior density of
<code class="reqn">\theta</code>1, ..., <code class="reqn">\theta</code><code class="reqn">I</code> given <code class="reqn">\phi</code> and the data.
See the vignette(&quot;bang-c-anova-vignette&quot;, package = &quot;bang&quot;)
for details.
</p>
<p>The following priors are specified up to proportionality.
</p>
<p><em>Priors:</em>
</p>
<p><code>prior = "bda"</code> (the default):
<code class="reqn">\pi(\mu, \sigma_\alpha, \sigma) = 1/\sigma,</code>
that is, a uniform prior for <code class="reqn">(\mu, \sigma_\alpha, log \sigma)</code>,
for <code class="reqn">\sigma_\alpha &gt; 0</code> and <code class="reqn">\sigma &gt; 0</code>.
The data must contain at least 3 groups, that is, <code>fac</code> must have
at least 3 levels, for a proper posterior density to be obtained.
[See Sections 5.7 and  11.6 of Gelman et al. (2014).]
</p>
<p><code>prior = "unif"</code>:
<code class="reqn">\pi(\mu, \sigma_\alpha, \sigma) = 1,</code>
that is, a uniform prior for <code class="reqn">(\mu, \sigma_\alpha, \sigma)</code>,
for <code class="reqn">\sigma_\alpha &gt; 0</code> and <code class="reqn">\sigma &gt; 0</code>.
[See Section 11.6 of Gelman et al. (2014).]
</p>
<p><code>prior = "cauchy"</code>: independent half-Cauchy priors for
<code class="reqn">\sigma_\alpha</code> and <code class="reqn">\sigma</code> with respective scale parameters
<code class="reqn">A_\alpha</code> and <code class="reqn">A</code>, that is,
<code class="reqn">\pi(\sigma_\alpha, \sigma) =
  1 / [(1 + \sigma_\alpha^2 / A_\alpha^2) (1 + \sigma^2 / A^2)].</code>
[See Gelman (2006).]  The scale parameters (<code class="reqn">A_\alpha</code>, <code class="reqn">A</code>)
are specified using <code>hpars</code> = (<code class="reqn">A_\alpha</code>, <code class="reqn">A</code>).
The default setting is <code>hpars = c(10, 10).</code>
</p>
<p><em>Parameterizations for sampling:</em>
</p>
<p><code>param = "original"</code> is (<code class="reqn">\mu, \sigma_\alpha, \sigma</code>),
<code>param = "trans"</code> (the default) is
<code class="reqn">\phi1 = \mu, \phi2 = log \sigma_\alpha, \phi3 = log \sigma</code>.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"hef"</code>, which has the same
structure as an object of class &quot;ru&quot; returned from <code><a href="rust.html#topic+ru">ru</a></code>.
In particular, the columns of the <code>n</code>-row matrix <code>sim_vals</code>
contain the simulated values of <code class="reqn">\phi</code>.
In addition this list contains the arguments <code>model</code>, <code>resp</code>,
<code>fac</code> and <code>prior</code> detailed above and an <code>n</code> by <code class="reqn">I</code>
matrix <code>theta_sim_vals</code>: column <code class="reqn">i</code> contains the simulated
values of  <code class="reqn">\theta</code><code class="reqn">i</code>.  Also included are
<code>data = cbind(resp, fac)</code> and <code>summary_stats</code> a list
containing: the number of groups <code>I</code>; the numbers of responses
each group <code>ni</code>; the total number of observations; the sample mean
response in each group; the sum of squared deviations from the
group means <code>s</code>; the arguments to <code>hanova1</code> <code>mu0</code> and
<code>sigma0</code>; <code>call</code>: the matched call to <code>hanova1</code>.
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S. Dunson, D. B.,
Vehtari, A. and Rubin, D. B. (2014) <em>Bayesian Data Analysis</em>.
Chapman &amp; Hall / CRC.
</p>
<p>Gelman, A. (2006) Prior distributions for variance
parameters in hierarchical models. <em>Bayesian Analysis</em>,
<strong>1</strong>(3), 515-533. <a href="https://doi.org/10.1214/06-BA117A">doi:10.1214/06-BA117A</a>.
</p>


<h3>See Also</h3>

<p>The <code><a href="rust.html#topic+ru">ru</a></code> function in the <code>rust</code>
package for details of the arguments that can be passed to <code>ru</code> via
<code>hanova1</code>.
</p>
<p><code><a href="#topic+hef">hef</a></code> for hierarchical exponential family models.
</p>
<p><code><a href="#topic+set_user_prior">set_user_prior</a></code> to set a user-defined prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ======= Late 21st Century Global Temperature Data =======

# Extract data for RCP2.6
RCP26_2 &lt;- temp2[temp2$RCP == "rcp26", ]

# Sample from the posterior under the default `noninformative' flat prior
# for (mu, sigma_alpha, log(sigma)).  Ratio-of-uniforms is used to sample
# from the marginal posterior for (log(sigma_alpha), log(sigma)).
temp_res &lt;- hanova1(resp = RCP26_2[, 1], fac = RCP26_2[, 2])

# Plot of sampled values of (sigma_alpha, sigma)
plot(temp_res, params = "ru")

# Plot of sampled values of (log(sigma_alpha), log(sigma))
# (centred at (0,0))
plot(temp_res, ru_scale = TRUE)

# Plot of sampled values of (mu, sigma_alpha, sigma)
plot(temp_res)

# Estimated marginal posterior densities of the mean for each GCM
plot(temp_res, params = "pop", which_pop = "all", one_plot = TRUE)

# Posterior sample quantiles
probs &lt;- c(2.5, 25, 50, 75, 97.5) / 100
round(t(apply(temp_res$sim_vals, 2, quantile, probs = probs)), 2)

# Ratio-of-uniforms information and posterior sample summaries
summary(temp_res)

# ======= Coagulation time data, from Table 11.2 Gelman et al (2014) =======

# With only 4 groups the posterior for sigma_alpha has a heavy right tail if
# the default `noninformative' flat prior for (mu, sigma_alpha, log(sigma))
# is used.  If we try to sample from the marginal posterior for
# (sigma_alpha, sigma) using the default generalized ratio-of-uniforms
# runing parameter value r = 1/2 then the acceptance region is not bounded.

# Two remedies: reparameterize the posterior and/or increase the value of r.

# (log(sigma_alpha), log(sigma)) parameterization, ru parameter r = 1/2
coag1 &lt;- hanova1(resp = coagulation[, 1], fac = coagulation[, 2])

# (sigma_alpha, sigma) parameterization, ru parameter r = 1
coag2 &lt;- hanova1(resp = coagulation[, 1], fac = coagulation[, 2],
               param = "original", r = 1)

# Values to compare to those in Table 11.3 of Gelman et al (2014)
all1 &lt;- cbind(coag1$theta_sim_vals, coag1$sim_vals)
all2 &lt;- cbind(coag2$theta_sim_vals, coag2$sim_vals)
round(t(apply(all1, 2, quantile, probs = probs)), 1)
round(t(apply(all2, 2, quantile, probs = probs)), 1)

# Pairwise plots of posterior samples from the group means
plot(coag1, which_pop = "all", plot_type = "pairs")

# Independent half-Cauchy priors for sigma_alpha and sigma
coag3 &lt;- hanova1(resp = coagulation[, 1], fac = coagulation[, 2],
                 param = "original", prior = "cauchy", hpars = c(10, 1e6))

</code></pre>

<hr>
<h2 id='hef'>Hierarchical Exponential Family Model</h2><span id='topic+hef'></span>

<h3>Description</h3>

<p>Produces random samples from the posterior distribution of the parameters
of certain hierarchical exponential family models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hef(
  n = 1000,
  model = c("beta_binom", "gamma_pois"),
  data,
  ...,
  prior = "default",
  hpars = NULL,
  param = c("trans", "original"),
  init = NULL,
  nrep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hef_+3A_n">n</code></td>
<td>
<p>An integer scalar.  The size of the posterior sample required.</p>
</td></tr>
<tr><td><code id="hef_+3A_model">model</code></td>
<td>
<p>A character string.  Abbreviated name for the
response-population distribution combination.
For a hierarchical normal model see <code><a href="#topic+hanova1">hanova1</a></code>
(hierarchical one-way analysis of variance (ANOVA)).</p>
</td></tr>
<tr><td><code id="hef_+3A_data">data</code></td>
<td>
<p>A numeric matrix.  The format depends on <code>model</code>.
See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="hef_+3A_...">...</code></td>
<td>
<p>Optional further arguments to be passed to
<code><a href="rust.html#topic+ru">ru</a></code>.</p>
</td></tr>
<tr><td><code id="hef_+3A_prior">prior</code></td>
<td>
<p>The log-prior for the parameters of the hyperprior
distribution.  If the user wishes to specify their own prior then
<code>prior</code> must be an object returned from a call to
<code><a href="#topic+set_user_prior">set_user_prior</a></code>.
Otherwise, <code>prior</code> is a character scalar giving the name of the
required in-built prior.
If <code>prior</code> is not supplied then a default prior is used.
See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="hef_+3A_hpars">hpars</code></td>
<td>
<p>A numeric vector.  Used to set parameters (if any) in
an in-built prior.</p>
</td></tr>
<tr><td><code id="hef_+3A_param">param</code></td>
<td>
<p>A character scalar.
If <code>param = "trans"</code> (the default) then the marginal posterior
of hyperparameter vector <code class="reqn">\phi</code> is reparameterized in a way
designed to improve the efficiency of sampling from this posterior.
If <code>param = "original"</code> the original parameterization is used.
The former tends to make the optimizations involved in the
ratio-of-uniforms algorithm more stable and to increase the probability
of acceptance, but at the expense of slower function evaluations.</p>
</td></tr>
<tr><td><code id="hef_+3A_init">init</code></td>
<td>
<p>A numeric vector of length 2.  Optional initial estimates
for the search for the mode of the posterior density of the
hyperparameter vector <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id="hef_+3A_nrep">nrep</code></td>
<td>
<p>A numeric scalar.  If <code>nrep</code> is not <code>NULL</code> then
<code>nrep</code> gives the number of replications of the original dataset
simulated from the posterior predictive distribution.
Each replication is based on one of the samples from the posterior
distribution.  Therefore, <code>nrep</code> must not be greater than <code>n</code>.
In that event <code>nrep</code> is set equal to <code>n</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditional on population-specific parameter vectors
<code class="reqn">\theta</code>1, ..., <code class="reqn">\theta</code><code class="reqn">J</code>
the observed <em>response</em> data <code class="reqn">y</code>1, ..., <code class="reqn">y</code>J within each
population are modelled as random samples from a distribution in an
exponential family. The population parameters <code class="reqn">\theta</code>1, ...,
<code class="reqn">\theta</code><code class="reqn">J</code> are modelled as random samples from a common
<em>population distribution</em>, chosen to be conditionally conjugate
to the response distribution, with <em>hyperparameter</em> vector
<code class="reqn">\phi</code>.  Conditionally on
<code class="reqn">\theta</code>1, ..., <code class="reqn">\theta</code><code class="reqn">J</code>, <code class="reqn">y</code>1, ..., <code class="reqn">y</code><code class="reqn">J</code>
are independent of each other and are independent of <code class="reqn">\phi</code>.
A <em>hyperprior</em> is placed on <code class="reqn">\phi</code>.  The user can either
choose parameter values of a default hyperprior or specify their own
hyperprior using <code><a href="#topic+set_user_prior">set_user_prior</a></code>.
</p>
<p>The <code><a href="rust.html#topic+ru">ru</a></code> function in the <code><a href="rust.html#topic+rust">rust</a></code>
package is used to draw a random sample
from the marginal posterior of the hyperparameter vector <code class="reqn">\phi</code>.
Then, conditional on these values, population parameters are sampled
directly from the conditional posterior density of
<code class="reqn">\theta</code>1, ..., <code class="reqn">\theta</code><code class="reqn">J</code> given <code class="reqn">\phi</code> and the data.
</p>
<p>We outline each <code>model</code>, specify the format of the
<code>data</code>, give the default (log-)priors (up to an additive constant)
and detail the choices of ratio-of-uniforms parameterization
<code>param</code>.
</p>
<p><strong>Beta-binomial:</strong> For <code class="reqn">j = 1, ..., J</code>,
<code class="reqn">Yj | pj</code> are i.i.d binomial<code class="reqn">(nj, pj)</code>,
where <code class="reqn">pj</code> is the probability of success in group <code class="reqn">j</code>
and <code class="reqn">nj</code> is the number of trials in group <code class="reqn">j</code>.
<code class="reqn">pj</code> are i.i.d. beta<code class="reqn">(\alpha, \beta)</code>, so
and <code class="reqn">\phi = (\alpha, \beta)</code>.
<code>data</code> is a 2-column matrix: the numbers of successes in column 1
and the corresponding numbers of trials in column 2.
</p>
<p><em>Priors:</em>
</p>
<p><code>prior = "bda"</code> (the default):
<code class="reqn">log \pi(\alpha, \beta) = - 2.5 log(\alpha + \beta),
  \alpha &gt; 0, \beta &gt; 0.</code> [See Section 5.3 of Gelman et al. (2014).]
</p>
<p><code>prior = "gamma"</code>: independent gamma priors on <code class="reqn">\alpha</code>
and <code class="reqn">\beta</code>, i.e.
<code class="reqn">log \pi(\alpha, \beta) =
  (s1 - 1)log\alpha - r1 \alpha +
  (s2 - 1)log\beta - r2 \beta,  \alpha &gt; 0, \beta &gt; 0.</code>
where the respective shape (<code class="reqn">s1</code>, <code class="reqn">s2</code>) and rate
(<code class="reqn">r1</code>, <code class="reqn">r2</code>) parameters are specified using
<code>hpars</code> = <code class="reqn">(s1, r1, s2, r2)</code>.  The default setting is
<code>hpars = c(1, 0.01, 1, 0.01).</code>
</p>
<p><em>Parameterizations for sampling:</em>
</p>
<p><code>param = "original"</code> is (<code class="reqn">\alpha, \beta</code>),
<code>param = "trans"</code> (the default) is
<code class="reqn">\phi1 = logit(\alpha/(\alpha+\beta)) = log(\alpha/\beta),
  \phi2 = log(\alpha+\beta)</code>.
See Section 5.3 of Gelman et al. (2014).
</p>
<p><strong>Gamma-Poisson:</strong> For <code class="reqn">j = 1, ..., J</code>,
<code class="reqn">Yj | \lambda</code>j are i.i.d Poisson(<code class="reqn">e</code>j<code class="reqn">\lambda</code>j),
where
<code class="reqn">ej</code> is the <em>exposure</em> in group <code class="reqn">j</code>, based on the
total length of observation time and/or size of the population at
risk of the event of interest and <code class="reqn">\lambda</code>j is the mean number
of events per unit of exposure.
<code class="reqn">\lambda</code>j are i.i.d. gamma<code class="reqn">(\alpha, \beta)</code>, so
<code class="reqn">\phi = (\alpha, \beta)</code>.
<code>data</code> is a 2-column matrix: the counts <code class="reqn">yj</code> of the numbers of
events in column 1 and the corresponding exposures <code class="reqn">ej</code> in column 2.
</p>
<p><em>Priors:</em>
</p>
<p><code>prior = "gamma"</code> (the default): independent gamma priors
on <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>, i.e.
<code class="reqn">log \pi(\alpha, \beta) =
  (s1 - 1)log\alpha - r1 \alpha +
  (s2 - 1)log\beta - r2 \beta,  \alpha &gt; 0, \beta &gt; 0.</code>
where the respective shape (<code class="reqn">s1</code>, <code class="reqn">s2</code>) and rate
(<code class="reqn">r1</code>, <code class="reqn">r2</code>) parameters are specified using
<code>hpars</code> = <code class="reqn">(s1, r1, s2, r2)</code>.  The default setting is
<code>hpars = c(1, 0.01, 1, 0.01).</code>
</p>
<p><em>Parameterizations for sampling:</em>
</p>
<p><code>param = "original"</code> is (<code class="reqn">\alpha, \beta</code>),
<code>param = "trans"</code> (the default) is
<code class="reqn">\phi1 = log(\alpha/\beta), \phi2 = log(\beta).</code>
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"hef"</code>, which has the same
structure as an object of class &quot;ru&quot; returned from <code><a href="rust.html#topic+ru">ru</a></code>.
In particular, the columns of the <code>n</code>-row matrix <code>sim_vals</code>
contain the simulated values of <code class="reqn">\phi</code>.
In addition this list contains the arguments <code>model</code>, <code>data</code>
and <code>prior</code> detailed above, an <code>n</code> by <code class="reqn">J</code> matrix
<code>theta_sim_vals</code>: column <code class="reqn">j</code> contains the simulated values of
<code class="reqn">\theta</code><code class="reqn">j</code> and <code>call</code>: the matched call to <code>hef</code>.
</p>
<p>If <code>nrep</code> is not <code>NULL</code> then this list also contains
<code>data_rep</code>, a numerical matrix with <code>nrep</code> columns.
Each column contains a replication of the first column of the original
data <code>data[, 1]</code>, simulated from the posterior predictive
distribution.
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S. Dunson, D. B.,
Vehtari, A. and Rubin, D. B. (2014) <em>Bayesian Data Analysis</em>.
Chapman &amp; Hall / CRC.
<a href="http://www.stat.columbia.edu/~gelman/book/">http://www.stat.columbia.edu/~gelman/book/</a>
</p>


<h3>See Also</h3>

<p>The <code><a href="rust.html#topic+ru">ru</a></code> function in the <code>rust</code>
package for details of the arguments that can be passed to <code>ru</code> via
<code>hef</code>.
</p>
<p><code><a href="#topic+hanova1">hanova1</a></code> for hierarchical one-way analysis of
variance (ANOVA).
</p>
<p><code><a href="#topic+set_user_prior">set_user_prior</a></code> to set a user-defined prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################ Beta-binomial #################################

# ------------------------- Rat tumor data ------------------------------- #

# Default prior, sampling on (rotated) (log(mean), log(alpha + beta)) scale
rat_res &lt;- hef(model = "beta_binom", data = rat)

# Hyperparameters alpha and beta
plot(rat_res)
# Parameterization used for sampling
plot(rat_res, ru_scale = TRUE)

summary(rat_res)

# Choose rats with extreme sample probabilities
pops &lt;- c(which.min(rat[, 1] / rat[, 2]), which.max(rat[, 1] / rat[, 2]))
# Population-specific posterior samples: separate plots
plot(rat_res, params = "pop", plot_type = "both", which_pop = pops)
# Population-specific posterior samples: one plot
plot(rat_res, params = "pop", plot_type = "dens", which_pop = pops,
     one_plot = TRUE, add_legend = TRUE)

# Default prior, sampling on (rotated) (alpha, beta) scale
rat_res &lt;- hef(model = "beta_binom", data = rat, param = "original")

plot(rat_res)
plot(rat_res, ru_scale = TRUE)

summary(rat_res)

# To produce a plot akin to Figure 5.3 of Gelman et al. (2014) we
# (a) Use the same prior for (alpha, beta)
# (b) Don't use axis rotation (rotate = FALSE)
# (c) Plot on the scale used for ratio-of-uniforms sampling (ru_scale = TRUE)
# (d) Note that the mode is relocated to (0, 0) in the plot
rat_res &lt;- hef(model = "beta_binom", data = rat, rotate = FALSE)

plot(rat_res, ru_scale = TRUE)

# This is the estimated location of the posterior mode
rat_res$f_mode

# User-defined prior, passing parameters
# (equivalent to prior = "gamma" with hpars = c(1, 0.01, 1, 0.01))
user_prior &lt;- function(x, hpars) {
  return(dexp(x[1], hpars[1], log = TRUE) + dexp(x[2], hpars[2], log = TRUE))
}
user_prior_fn &lt;- set_user_prior(user_prior, hpars = c(0.01, 0.01))
rat_res &lt;- hef(model = "beta_binom", data = rat, prior = user_prior_fn)

plot(rat_res)

summary(rat_res)

############################ Gamma-Poisson #################################

# ------------------------ Pump failure data ------------------------------ #

pump_res &lt;- hef(model = "gamma_pois", data = pump)
# Hyperparameters alpha and beta

plot(pump_res)

# Parameterization used for sampling
plot(pump_res, ru_scale = TRUE)
summary(pump_res)

# Choose pumps with extreme sample rates
pops &lt;- c(which.min(pump[, 1] / pump[, 2]), which.max(pump[, 1] / pump[, 2]))
plot(pump_res, params = "pop", plot_type = "dens", which_pop = pops)
</code></pre>

<hr>
<h2 id='plot.hef'>Plot diagnostics for a hef object</h2><span id='topic+plot.hef'></span>

<h3>Description</h3>

<p><code>plot</code> method for class &quot;hef&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hef'
plot(
  x,
  y,
  ...,
  params = c("hyper", "ru", "pop"),
  which_pop = NULL,
  plot_type = NULL,
  one_plot = FALSE,
  add_legend = FALSE,
  legend_position = "topright",
  legend_text = NULL,
  num = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hef_+3A_x">x</code></td>
<td>
<p>an object of class &quot;hef&quot;, a result of a call to
<code><a href="rust.html#topic+ru">ru</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hef_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.hef_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rust.html#topic+plot.ru">plot.ru</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code> or <code><a href="graphics.html#topic+pairs">pairs</a></code>.
In particular, <code>ru_scale = TRUE</code> produces a plot using the
parameterization used for ratio-of-uniforms sampling.</p>
</td></tr>
<tr><td><code id="plot.hef_+3A_params">params</code></td>
<td>
<p>A character scalar that determines to which parameters the
plots relate.
</p>

<ul>
<li> <p><code>"hyper"</code>: the posterior sample of <em>all</em> hyperparameter
values in <code class="reqn">\phi</code> is plotted using <code><a href="rust.html#topic+plot.ru">plot.ru</a></code>.
</p>
</li>
<li> <p><code>"ru"</code>: only the posterior sample generated using
<code><a href="rust.html#topic+ru">ru</a></code> is plotted using <code><a href="rust.html#topic+plot.ru">plot.ru</a></code>.
This produces a different plot to <code>params = "hyper"</code> if <code>ru</code>
is used only on a subset of <code class="reqn">\phi</code>.  For example, this may be
the case if <code>x</code> is the result of a call to <code><a href="#topic+hanova1">hanova1</a></code>.
See vignette(&quot;bang-c-anova-vignette&quot;, package = &quot;bang&quot;) for
information.
</p>
</li>
<li> <p><code>"pop"</code>: posterior samples and/or densities of the
population-specific parameter <code class="reqn">\theta</code> are plotted.  The
population(s) included are determined by <code>which_pop</code> and the
type of plot is determined by <code>plot_type</code>.
If <code>plot_type</code> is not supplied then it is set to <code>"dens"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.hef_+3A_which_pop">which_pop</code></td>
<td>
<p>An integer vector or character scalar.
If <code>params = "pop"</code> then <code>which_pop</code> indicates which
populations to include in the plot.  If <code>which_pop</code> is supplied then
<code>params</code> is set to &quot;pop&quot;.  If <code>which_pop = "all"</code>
then all populations are included.  If there are many populations then
this may fail if <code>plot_type = "pairs"</code> and/or
<code>one_plot = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.hef_+3A_plot_type">plot_type</code></td>
<td>
<p>A character scalar that determines the type of plot
produced when <code>params = "pop"</code>.  If <code>plot_type</code> is supplied
then <code>params</code> is set automatically to <code>"pop"</code>.
</p>

<ul>
<li> <p><code>"sim"</code>: histograms of the posterior samples
of <code class="reqn">\theta</code> for the populations in <code>which_pop</code>.
</p>
</li>
<li> <p><code>"dens"</code>: estimates of the marginal posterior
densities of <code class="reqn">\theta</code> for the populations in <code>which_pop</code>.
</p>
</li>
<li> <p><code>"both"</code>: both the histograms and estimated posterior densities.
</p>
</li>
<li> <p><code>"pairs"</code>: pairwise scatter plots of the posterior samples of
<code class="reqn">\theta</code> for the populations in <code>which_pop</code>, which must have
length greater than one.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.hef_+3A_one_plot">one_plot</code>, <code id="plot.hef_+3A_add_legend">add_legend</code>, <code id="plot.hef_+3A_legend_position">legend_position</code>, <code id="plot.hef_+3A_legend_text">legend_text</code></td>
<td>
<p>Only relevant if
<code>plot_type = "dens"</code>.  If <code>one_plot = TRUE</code> then the estimated
marginal posterior densities are plotted in the same graph and if
<code>add_legend = TRUE</code> then a legend is added to this plot using
<code><a href="graphics.html#topic+legend">legend</a></code> in the position indicated by
the character scalar <code>legend_position</code>.
A character vector <code>legend_text</code> may be used to override the
default legend text.</p>
</td></tr>
<tr><td><code id="plot.hef_+3A_num">num</code></td>
<td>
<p>A numeric scalar.  If <code>plot_type == "dens"</code> or
<code>plot_type == "both"</code> then <code>num</code> gives the number of
points at which the marginal densities are evaluated to produce plots.</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>See the examples in <code><a href="#topic+hef">hef</a></code> and <code><a href="#topic+hanova1">hanova1</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="rust.html#topic+plot.ru">plot.ru</a></code> for arguments that may be passed
via ...., in particular <code>ru_scale</code>.
</p>

<hr>
<h2 id='pp_check.hef'>Posterior predictive checks for a hef object</h2><span id='topic+pp_check.hef'></span><span id='topic+pp_check'></span>

<h3>Description</h3>

<p><code>pp_check</code> method for class &quot;hef&quot;.  This provides an interface
to the functions that perform posterior predictive checks in the
<strong>bayesplot</strong> package.  See <a href="bayesplot.html#topic+PPC-overview">PPC-overview</a> for
details of these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hef'
pp_check(object, fun = NULL, raw = FALSE, nrep = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_check.hef_+3A_object">object</code></td>
<td>
<p>An object of class &quot;hef&quot;, a result of a call to
<code><a href="#topic+hef">hef</a></code> or <code><a href="#topic+hanova1">hanova1</a></code>.</p>
</td></tr>
<tr><td><code id="pp_check.hef_+3A_fun">fun</code></td>
<td>
<p>The plotting function to call.
Can be any of the functions detailed at <a href="bayesplot.html#topic+PPC-overview">PPC-overview</a>.
The &quot;ppc_&quot; prefix can optionally be dropped if fun is specified
as a string.</p>
</td></tr>
<tr><td><code id="pp_check.hef_+3A_raw">raw</code></td>
<td>
<p>Only relevant if <code>object$model = "beta_binom"</code> or
<code>object$model = "gamma_pois"</code>.
If <code>raw = TRUE</code> then the raw responses are used in the plots.
Otherwise, the <em>proportions</em> of successes are used in the
<code>beta_binom</code> case and the <em>exposure-adjusted rate</em> in the
<code>gamma_pois</code> case.  In both cases the values used are
<code>object$data[, 1] / object$data[, 2]</code> and the equivalent
in <code>object$data_rep</code>.</p>
</td></tr>
<tr><td><code id="pp_check.hef_+3A_nrep">nrep</code></td>
<td>
<p>The number of predictive replicates to use.  If <code>nrep</code>
is supplied then the first <code>nrep</code> rows of <code>object$data_rep</code>
are used.  Otherwise, or if <code>nrep</code> is greater than
<code>nrow(object$data_rep)</code>, then all rows are used.</p>
</td></tr>
<tr><td><code id="pp_check.hef_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to bayesplot functions.
See <strong>Examples</strong> below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of these functions see <a href="bayesplot.html#topic+PPC-overview">PPC-overview</a>.
See also the vignettes
<a href="https://CRAN.R-project.org/package=bang">Conjugate Hierarchical Models</a>,
<a href="https://CRAN.R-project.org/package=bang">Hierarchical 1-way Analysis of Variance</a>
and the <strong>bayesplot</strong> vignette
<a href="https://CRAN.R-project.org/package=bayesplot">Graphical posterior predictive checks</a>.
</p>
<p>The general idea is to compare the observed data <code>object$data</code>
with a matrix <code>object$data_rep</code> in which each row is a
replication of the observed data simulated from the posterior predictive
distribution.  For greater detail see Chapter 6 of Gelman et al. (2013).
</p>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the
<strong>ggplot2</strong> package.
</p>


<h3>References</h3>

<p>Jonah Gabry (2016). bayesplot: Plotting for Bayesian
Models. R package version 1.1.0.
<a href="https://CRAN.R-project.org/package=bayesplot">https://CRAN.R-project.org/package=bayesplot</a>
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B.,
Vehtari, A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis</em>.
Chapman &amp; Hall/CRC Press, London, third edition. (Chapter 6).
<a href="http://www.stat.columbia.edu/~gelman/book/">http://www.stat.columbia.edu/~gelman/book/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hef">hef</a></code> and <code><a href="#topic+hanova1">hanova1</a></code> for sampling
from posterior distributions of hierarchical models.
</p>
<p><strong>bayesplot</strong> functions <a href="bayesplot.html#topic+PPC-overview">PPC-overview</a>,
<a href="bayesplot.html#topic+PPC-distributions">PPC-distributions</a>,
<a href="bayesplot.html#topic+PPC-test-statistics">PPC-test-statistics</a>,
<a href="bayesplot.html#topic+PPC-intervals">PPC-intervals</a>,
<a href="bayesplot.html#topic+pp_check">pp_check</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################ Beta-binomial #################################

# ------------------------- Rat tumor data ------------------------------- #

rat_res &lt;- hef(model = "beta_binom", data = rat, nrep = 50)

# Overlaid density estimates
pp_check(rat_res)

# Overlaid distribution function estimates
pp_check(rat_res, fun = "ecdf_overlay")

# Multiple histograms
pp_check(rat_res, fun = "hist", nrep = 8)

# Multiple boxplots
pp_check(rat_res, fun = "boxplot")
# Predictive medians vs observed median
pp_check(rat_res, fun = "stat", stat = "median")

# Predictive (mean, sd) vs observed (mean, sd)
pp_check(rat_res, fun = "stat_2d", stat = c("mean", "sd"))

############################ Gamma-Poisson #################################

# ------------------------ Pump failure data ------------------------------ #

pump_res &lt;- hef(model = "gamma_pois", data = pump, nrep = 50)


# Overlaid density estimates
pp_check(pump_res)
# Predictive (mean, sd) vs observed (mean, sd)
pp_check(pump_res, fun = "stat_2d", stat = c("mean", "sd"))


###################### One-way Hierarchical ANOVA ##########################

#----------------- Late 21st Century Global Temperature Data ------------- #

RCP26_2 &lt;- temp2[temp2$RCP == "rcp26", ]
temp_res &lt;- hanova1(resp = RCP26_2[, 1], fac = RCP26_2[, 2], nrep = 50)

# Overlaid density estimates
pp_check(temp_res)
# Predictive (mean, sd) vs observed (mean, sd)
pp_check(temp_res, fun = "stat_2d", stat = c("mean", "sd"))

</code></pre>

<hr>
<h2 id='print.hef'>Print method for objects of class &quot;hef&quot;</h2><span id='topic+print.hef'></span>

<h3>Description</h3>

<p><code>print</code> method for class &quot;hef&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hef'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hef_+3A_x">x</code></td>
<td>
<p>an object of class &quot;hef&quot;, a result of a call to
<code><a href="#topic+hef">hef</a></code> or <code><a href="#topic+hanova1">hanova1</a></code>.</p>
</td></tr>
<tr><td><code id="print.hef_+3A_...">...</code></td>
<td>
<p>Additional optional arguments. At present no optional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the original call to <code><a href="#topic+hef">hef</a></code> or
<code><a href="#topic+hanova1">hanova1</a></code>, the name of the model and the number of populations
in the hierarchical model.
</p>


<h3>Value</h3>

<p>The argument <code>x</code>, invisibly, as for all <code><a href="base.html#topic+print">print</a></code>
methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hef">hef</a></code> for hierarchical exponential family models.
</p>
<p><code><a href="#topic+hanova1">hanova1</a></code> for hierarchical one-way analysis of
variance (ANOVA).
</p>

<hr>
<h2 id='print.summary.hef'>Print method for objects of class &quot;summary.hef&quot;</h2><span id='topic+print.summary.hef'></span>

<h3>Description</h3>

<p><code>print</code> method for class &quot;summary.hef&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.hef'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.hef_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.hef&quot;, a result of a call to
<code><a href="#topic+summary.hef">summary.hef</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.hef_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed to
<code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>What is printed depends on the argument <code>params</code> supplied
to <code><a href="#topic+summary.hef">summary.hef</a></code>.
</p>


<h3>Value</h3>

<p>The argument <code>x</code>, invisibly, as for all <code><a href="base.html#topic+print">print</a></code>
methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.hef">summary.hef</a></code>: <code>summary</code> method for class &quot;hef&quot;.
</p>
<p><code><a href="#topic+hef">hef</a></code> for hierarchical exponential family models.
</p>
<p><code><a href="#topic+hanova1">hanova1</a></code> for hierarchical one-way analysis of
variance (ANOVA).
</p>

<hr>
<h2 id='pump'>Pump-failure data</h2><span id='topic+pump'></span>

<h3>Description</h3>

<p>Data on pump failures from Gaver, D. P. and O'Muircheartaigh, I. G. (1987).
The matrix <code>pump</code> has 10 rows and 2 columns.
Each row relates to a different pump system.
The first column contains the number of pump failures.
The second column contains the length of operating time, in
thousands of hours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump
</code></pre>


<h3>Format</h3>

<p>A matrix 10 rows and 2 columns.
</p>


<h3>Source</h3>

<p>Table 3 of Gaver, D. P. and O'Muircheartaigh, I. G. (1987).
See also Gelfand, A. E. and Smith, A. F. M. (1990).
</p>


<h3>References</h3>

<p>Gaver, D. P. and O'Muircheartaigh, I. G. (1987)
Robust Empirical Bayes Analyses of Event Rates. <em>Technometrics</em>,
<strong>29</strong>, 1-15. <a href="https://doi.org/10.1080/00401706.1987.10488178">doi:10.1080/00401706.1987.10488178</a>
</p>
<p>Gelfand, A. E. and Smith, A. F. M. (1990)
Sampling-Based Approaches to Calculating Marginal Densities.
<em>Journal of the American Statistical Association</em>, <strong>85</strong>(410),
398-409. <a href="https://doi.org/10.1080/01621459.1990.10476213">doi:10.1080/01621459.1990.10476213</a>
</p>

<hr>
<h2 id='rat'>Rat tumor data</h2><span id='topic+rat'></span>

<h3>Description</h3>

<p>Tumor incidence in 71 groups of rate from Tarone (1982).
The matrix <code>rat</code> has 71 rows and 2 columns.
Each row relates to a different group of rats.
The first column (<code>y</code>) contains the number of rats with tumors.
The second column (<code>n</code>) contains the total number of rats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rat
</code></pre>


<h3>Format</h3>

<p>A matrix with 71 rows and 2 columns.
</p>


<h3>Source</h3>

<p>Table 5.1 of Gelman, A., Carlin, J. B., Stern, H. S. Dunson, D. B.,
Vehtari, A. and Rubin, D. B. (2014) <em>Bayesian Data Analysis</em>,
Chapman &amp; Hall / CRC.
<a href="http://www.stat.columbia.edu/~gelman/book/data/rats.asc">http://www.stat.columbia.edu/~gelman/book/data/rats.asc</a>
</p>


<h3>References</h3>

<p>Tarone, R. E. (1982) The use of historical information in
testing for a trend in proportions. <em>Biometrics</em>, <strong>38</strong>,
215-220. <a href="https://doi.org/10.2307/2530304">doi:10.2307/2530304</a>
</p>

<hr>
<h2 id='set_user_prior'>Set a user-defined prior</h2><span id='topic+set_user_prior'></span>

<h3>Description</h3>

<p>Constructs a user-defined prior distribution for use as the argument
<code>prior</code> in <code><a href="#topic+hef">hef</a></code> or <code><a href="#topic+hanova1">hanova1</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_user_prior(
  prior,
  ...,
  model = c("beta_binom", "gamma_pois", "anova1"),
  anova_d = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_user_prior_+3A_prior">prior</code></td>
<td>
<p>An R function returning <strong>the log of</strong> the prior density
for of (perhaps a subset of) the hyperparameter vector <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id="set_user_prior_+3A_...">...</code></td>
<td>
<p>Further arguments giving the names and values of any
parameters involved in the function <code>prior</code>.</p>
</td></tr>
<tr><td><code id="set_user_prior_+3A_model">model</code></td>
<td>
<p>A character string.  Abbreviated name of the model:
&quot;beta_binom&quot; for beta-binomial and &quot;gamma_pois&quot; for gamma-Poisson
(see <code><a href="#topic+hef">hef</a></code>), &quot;anova1&quot; for 1-way ANOVA (see
<code><a href="#topic+hanova1">hanova1</a></code>).</p>
</td></tr>
<tr><td><code id="set_user_prior_+3A_anova_d">anova_d</code></td>
<td>
<p>An integer scalar.  Only relevant if <code>model = anova1</code>.
If <code>anova_d = 2</code> then <code>prior</code> must return the log-prior
density for the standard deviations <code class="reqn">(\sigma_\alpha, \sigma)</code>
and a normal prior with mean <code>mu0</code> and standard deviation
<code>sigma0</code> is used for <code class="reqn">\mu</code>.  The values of <code>mu0 = 0</code> and
<code>sigma0 = Inf</code> are set in the call to <code>hanova1</code>, with default
values <code>mu0 = 0</code> and <code>sigma0 = Inf</code>.
If <code>anova_d = 3</code> then <code>prior</code> must return the log-prior
density for <code class="reqn">(\mu, \sigma_\alpha, \sigma)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the hyperparameters in <code class="reqn">\phi</code> see the
<strong>Details</strong> section of <code><a href="#topic+hef">hef</a></code> for the models
<code>beta_binom</code> and <code>gamma_pois</code> and of <code><a href="#topic+hanova1">hanova1</a></code>
for the model <code>anova1</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"bang_prior"</code>.  Will contain the component
<code>prior</code>, the user-supplied function to evaluate the log of the prior,
and any arguments supplied in ....
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hef">hef</a></code> for hierarchical exponential family models.
</p>
<p><code><a href="#topic+hanova1">hanova1</a></code> for hierarchical one-way analysis of
variance (ANOVA).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># User-defined prior, passing parameters
# (equivalent to prior = "gamma" with hpars = c(1, 0.01, 1, 0.01))
user_prior &lt;- function(x, hpars) {
  return(dexp(x[1], hpars[1], log = TRUE) + dexp(x[2], hpars[2], log = TRUE))
}
user_prior_fn &lt;- set_user_prior(user_prior, hpars = c(0.01, 0.01))
</code></pre>

<hr>
<h2 id='sim_pred_beta_binom'>Simulate from a beta-binomial posterior predictive distribution</h2><span id='topic+sim_pred_beta_binom'></span>

<h3>Description</h3>

<p>Simulates <code>nrep</code> draws from the posterior predictive distribution
of the beta-binomial model described in <code><a href="#topic+hef">hef</a></code>.
This function is called within <code><a href="#topic+hef">hef</a></code> when the argument
<code>nrep</code> is supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pred_beta_binom(theta_sim_vals, data, nrep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_pred_beta_binom_+3A_theta_sim_vals">theta_sim_vals</code></td>
<td>
<p>A numeric matrix with <code>nrow(data)</code> columns.
Each row of <code>theta_sim_vals</code> contains binomial success probabilities
simulated from their posterior distribution.</p>
</td></tr>
<tr><td><code id="sim_pred_beta_binom_+3A_data">data</code></td>
<td>
<p>A 2-column numeric matrix: the numbers of successes in column 1
and the corresponding numbers of trials in column 2.</p>
</td></tr>
<tr><td><code id="sim_pred_beta_binom_+3A_nrep">nrep</code></td>
<td>
<p>A numeric scalar.  The number of replications of the original
dataset simulated from the posterior predictive distribution.
If <code>nrep</code> is greater than <code>nrow(theta_sim_vals)</code> then
<code>nrep</code> is set equal to <code>nrow(theta_sim_vals)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>nrep</code> columns.  Each column contains
a draw from the posterior predictive distribution of the number of
successes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rat_res &lt;- hef(model = "beta_binom", data = rat)
rat_sim_pred &lt;- sim_pred_beta_binom(rat_res$theta_sim_vals, rat, 50)
</code></pre>

<hr>
<h2 id='sim_pred_gamma_pois'>Simulate from a gamma-Poisson posterior predictive distribution</h2><span id='topic+sim_pred_gamma_pois'></span>

<h3>Description</h3>

<p>Simulates <code>nrep</code> draws from the posterior predictive distribution
of the beta-binomial model described in <code><a href="#topic+hef">hef</a></code>.
This function is called within <code><a href="#topic+hef">hef</a></code> when the argument
<code>nrep</code> is supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pred_gamma_pois(theta_sim_vals, data, nrep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_pred_gamma_pois_+3A_theta_sim_vals">theta_sim_vals</code></td>
<td>
<p>A numeric matrix with <code>nrow(data)</code> columns.
Each row of <code>theta_sim_vals</code> contains binomial success probabilities
simulated from their posterior distribution.</p>
</td></tr>
<tr><td><code id="sim_pred_gamma_pois_+3A_data">data</code></td>
<td>
<p>A 2-column numeric matrix: the numbers of successes in column 1
and the corresponding numbers of trials in column 2.</p>
</td></tr>
<tr><td><code id="sim_pred_gamma_pois_+3A_nrep">nrep</code></td>
<td>
<p>A numeric scalar.  The number of replications of the original
dataset simulated from the posterior predictive distribution.
If <code>nrep</code> is greater than <code>nrow(theta_sim_vals)</code> then
<code>nrep</code> is set equal to <code>nrow(theta_sim_vals)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>nrep</code> columns.  Each column contains
a draw from the posterior predictive distribution of the number of
successes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pump_res &lt;- hef(model = "gamma_pois", data = pump)
pump_sim_pred &lt;- sim_pred_gamma_pois(pump_res$theta_sim_vals, pump, 50)
</code></pre>

<hr>
<h2 id='sim_pred_hanova1'>Simulate from a one-way hierarchical ANOVA posterior predictive distribution</h2><span id='topic+sim_pred_hanova1'></span>

<h3>Description</h3>

<p>Simulates <code>nrep</code> draws from the posterior predictive distribution
of the one-way hierarchical ANOVA model described in <code><a href="#topic+hanova1">hanova1</a></code>.
This function is called within <code><a href="#topic+hanova1">hanova1</a></code> when the argument
<code>nrep</code> is supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pred_hanova1(theta_sim_vals, sim_vals, fac, nrep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_pred_hanova1_+3A_theta_sim_vals">theta_sim_vals</code></td>
<td>
<p>A numeric matrix with <code>length(fac)</code> columns.
Each row of <code>theta_sim_vals</code> contains normal means simulated from
their posterior distribution.</p>
</td></tr>
<tr><td><code id="sim_pred_hanova1_+3A_sim_vals">sim_vals</code></td>
<td>
<p>A numeric matrix with <code>length(fac)</code> columns.
Each row of <code>sim_vals</code> contains normal standard deviations <code class="reqn">\sigma</code>
simulated from their posterior distribution.</p>
</td></tr>
<tr><td><code id="sim_pred_hanova1_+3A_fac">fac</code></td>
<td>
<p>The argument <code>fac</code> to <code><a href="#topic+hanova1">hanova1</a></code>, that is,
a vector of class <a href="base.html#topic+factor">factor</a> indicating group membership.</p>
</td></tr>
<tr><td><code id="sim_pred_hanova1_+3A_nrep">nrep</code></td>
<td>
<p>A numeric scalar.  The number of replications of the original
dataset simulated from the posterior predictive distribution.
If <code>nrep</code> is greater than <code>nrow(theta_sim_vals)</code> then
<code>nrep</code> is set equal to <code>nrow(theta_sim_vals)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>nrep</code> columns.  Each column contains
a draw from the posterior predictive distribution of the number of
successes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RCP26_2 &lt;- temp2[temp2$RCP == "rcp26", ]
temp_res &lt;- hanova1(resp = RCP26_2[, 1], fac = RCP26_2[, 2])
sim_pred &lt;- sim_pred_hanova1(temp_res$theta_sim_vals, temp_res$sim_vals,
                             RCP26_2[, 2], 50)
</code></pre>

<hr>
<h2 id='summary.hef'>Summarizing hef objects</h2><span id='topic+summary.hef'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;hef&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hef'
summary(
  object,
  ...,
  params = c("hyper", "pop"),
  which_pop = 1:ncol(object$theta_sim_vals)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hef_+3A_object">object</code></td>
<td>
<p>an object of class &quot;hef&quot;, a result of a call to
<code><a href="#topic+hef">hef</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hef_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="rust.html#topic+summary.ru">summary.ru</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hef_+3A_params">params</code></td>
<td>
<p>A character scalar.
</p>
<p>If <code>params = "hyper"</code> then the posterior samples of all
hyperparameter values in <code class="reqn">\phi</code> are summarized using
<code><a href="rust.html#topic+summary.ru">summary.ru</a></code>.
</p>
<p>If <code>params = "pop"</code> then only posterior samples of the populations
specified in <code>which_pop</code> are summarized.</p>
</td></tr>
<tr><td><code id="summary.hef_+3A_which_pop">which_pop</code></td>
<td>
<p>An integer vector.  If <code>params = "pop"</code> then
<code>which_pop</code> indicates which populations, i.e. which columns
of <code>object$theta_sim_vals</code> to summarize, using
<code><a href="base.html#topic+summary">summary</a></code>.  The default is all populations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Beta-binomial model, rat data
rat_res &lt;- hef(model = "beta_binom", data = rat)

# Posterior summaries of the hyperparameters alpha and beta
summary(rat_res)

# Posterior summaries of the binomial probability for rats 1 to 3
summary(rat_res, params = "pop", which_pop = 1:3)
</code></pre>

<hr>
<h2 id='temp1'>Mid 21st Century Global Temperature Projection Data</h2><span id='topic+temp1'></span>

<h3>Description</h3>

<p>Indices of global temperature change from late 20th century (1970-1999)
to mid 21st century (2020-2049) based on data produced by the Fifth
Coupled Model Intercomparison Project (CMIP5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp1
</code></pre>


<h3>Format</h3>

<p>A data frame with 270 rows and 4 columns.
</p>

<ul>
<li><p> Column 1, <code>index</code>: anomaly of 2020-2049 mean relative to
the 1970-1999 mean.
</p>
</li>
<li><p> Column 2, <code>GCM</code>: Abbreviated name of General Circulation
Model.
</p>
</li>
<li><p> Column 3, <code>RCP</code>: Representative Concentration Pathway.
One of rcp26, rcp45, rcp60, rcp85.
</p>
</li>
<li><p> Column 4, <code>run</code>: Simulation run number.
</p>
</li></ul>



<h3>Details</h3>

<p>The data frame <code>temp1</code> data frame has 270 rows and 4 columns.
Each row relates to a climate projection run from one of 38 different
General Circulation Models (GCMs) under a particular
Representative Concentration Pathway (RCP).
Use <code>table(temp1[, c("GCM", "RCP")])</code> to see the numbers of
runs under each RCP for each GCM.
See Van Vuuren et al (2011) for an overview of RCPs
and Northrop and Chandler (2014) for analyses of a similar
older dataset (CMIP3).
Column 1 contains the anomaly of the mean global temperature over
the time period 2020-2049 relative to the mean global temperature
over 1970-1999, i.e. the latter subtracted from the former.
Column 2 contains an abbreviation for the name of the climate modelling
research group and the GCM.
Column 3 contains the RCP in the format <code>rcpxx</code> where <code>xx</code>
is a radiative forcing level resulting from an anticipated future
greenhouse gas emissions.
Column 4 is the simulation run number.
</p>


<h3>Source</h3>

<p>The raw data from which the indices are calculated are monthly
CMIP5 scenario runs for global surface air temperature (tas)
downloaded from the KNMI Climate Explorer (<a href="https://climexp.knmi.nl/">https://climexp.knmi.nl/</a>)
on 4/3/2015.
</p>


<h3>References</h3>

<p>Northrop, P.J. and R.E. Chandler (2014). Quantifying
Sources of Uncertainty in Projections of Future Climate.
<em>Journal of Climate</em>, <strong>27</strong>, 8793-8808.
<a href="https://doi.org/10.1175/JCLI-D-14-00265.1">doi:10.1175/JCLI-D-14-00265.1</a>
</p>
<p>Van Vuuren, D. P., Edmonds, J., Kainuma, M., Riahi, K.
Thomson, A., Hibbard, K., Hurtt, G. C., Kram, T., Krey, V.,
Lamarque, J.-F. (2011). The representative concentration pathways:
an overview. <em>Climatic change</em>, <strong>109</strong>, 5-31.
<a href="https://doi.org/10.1007/s10584-011-0148-z">doi:10.1007/s10584-011-0148-z</a>
</p>

<hr>
<h2 id='temp2'>Late 21st Century Global Temperature Projection Data</h2><span id='topic+temp2'></span>

<h3>Description</h3>

<p>Indices of global temperature change from late 20th century (1970-1999)
to late 21st century (2069-2098) based on data produced by the Fifth
Coupled Model Intercomparison Project (CMIP5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp2
</code></pre>


<h3>Format</h3>

<p>A data frame with 270 rows and 4 columns.
</p>

<ul>
<li><p> Column 1, <code>index</code>: anomaly of 2069-2098 mean relative to
the 1970-1999 mean.
</p>
</li>
<li><p> Column 2, <code>GCM</code>: Abbreviated name of General Circulation
Model.
</p>
</li>
<li><p> Column 3, <code>RCP</code>: Representative Concentration Pathway.
One of rcp26, rcp45, rcp60, rcp85.
</p>
</li>
<li><p> Column 4, <code>run</code>: Simulation run number.
</p>
</li></ul>



<h3>Details</h3>

<p>The data frame <code>temp2</code> data frame has 270 rows and 4 columns.
Each row relates to a climate projection run from one of 38 different
General Circulation Models (GCMs) under a particular
Representative Concentration Pathway (RCP).
Use <code>table(temp2[, c("GCM", "RCP")])</code> to see the numbers of
runs under each RCP for each GCM.
See Van Vuuren et al (2011) for an overview of RCPs
and Northrop and Chandler (2014) for analyses of a similar
older dataset (CMIP3).
Column 1 contains the anomaly of the mean global temperature over
the time period 2069-2098 relative to the mean global temperature
over 1970-1999, i.e. the latter subtracted from the former.
Column 2 contains an abbreviation for the name of the climate modelling
research group and the GCM.
Column 3 contains the RCP in the format <code>rcpxx</code> where <code>xx</code>
is a radiative forcing level resulting from an anticipated future
greenhouse gas emissions.
Column 4 is the simulation run number.
</p>


<h3>Source</h3>

<p>The raw data from which the indices are calculated are monthly
CMIP5 scenario runs for global surface air temperature (tas)
downloaded from the KNMI Climate Explorer (<a href="https://climexp.knmi.nl/">https://climexp.knmi.nl/</a>)
on 4/3/2015.
</p>


<h3>References</h3>

<p>Northrop, P.J. and R.E. Chandler (2014). Quantifying
Sources of Uncertainty in Projections of Future Climate.
<em>Journal of Climate</em>, <strong>27</strong>, 8793-8808.
<a href="https://doi.org/10.1175/JCLI-D-14-00265.1">doi:10.1175/JCLI-D-14-00265.1</a>
</p>
<p>Van Vuuren, D. P., Edmonds, J., Kainuma, M., Riahi, K.
Thomson, A., Hibbard, K., Hurtt, G. C., Kram, T., Krey, V.,
Lamarque, J.-F. (2011). The representative concentration pathways:
an overview. <em>Climatic change</em>, <strong>109</strong>, 5-31.
<a href="https://doi.org/10.1007/s10584-011-0148-z">doi:10.1007/s10584-011-0148-z</a>
</p>

<hr>
<h2 id='weight_gain'>Weight Gained by Rats</h2><span id='topic+weight_gain'></span>

<h3>Description</h3>

<p>Data from an experiment to study weight gained by 10 rats fed on four different
diets, defined by a combination of the amount of protein (low and high)
and by the source of protein (beef and cereal).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_gain
</code></pre>


<h3>Format</h3>

<p>A data frame with 40 rows and 3 columns.
</p>

<ul>
<li><p> Column 1, <code>source</code>: source of protein, a factor with levels
<code>Beef</code> and <code>Cereal</code>.
</p>
</li>
<li><p> Column 2, <code>type</code>: amount of protein, a factor with levels
<code>High</code> and <code>Low</code>.
</p>
</li>
<li><p> Column 3, <code>weightgain</code>: weight gained, in grams.
</p>
</li></ul>



<h3>Source</h3>

<p>D. J. Hand, A. D. Lunn, K. J. McConway, and E. Ostrowski (1994).
<em>A Handbook of Small Datasets</em>, Chapman and Hall/CRC, London.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
