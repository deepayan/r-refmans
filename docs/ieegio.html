<!DOCTYPE html><html lang="en-US"><head><title>Help for package ieegio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ieegio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_ieegio_surface'><p>Convert other surface formats to <code>ieegio</code> surface</p></a></li>
<li><a href='#as_ieegio_volume'><p>Convert objects to <code>'ieegio'</code> image volumes</p></a></li>
<li><a href='#burn_volume'><p>Burn image at given positions</p></a></li>
<li><a href='#ieegio_sample_data'><p>Download sample files</p></a></li>
<li><a href='#imaging-surface'><p>Read and write surface files</p></a></li>
<li><a href='#imaging-volume'><p>Read and write volume data</p></a></li>
<li><a href='#io_h5_valid'><p>Check whether a 'HDF5' file can be opened for read/write</p></a></li>
<li><a href='#io_read_h5'><p>Lazy Load 'HDF5' File via <code>hdf5r-package</code></p></a></li>
<li><a href='#io_write_h5'><p>Save objects to 'HDF5' file without trivial checks</p></a></li>
<li><a href='#LazyH5'><p>Lazy 'HDF5' file loader</p></a></li>
<li><a href='#low-level-read-write'><p>Low-level file read and write</p></a></li>
<li><a href='#merge.ieegio_surface'><p>Merge two <code>'ieegio'</code> surfaces</p></a></li>
<li><a href='#merge.ieegio_volume'><p>Merge <code>'ieegio'</code> volumes</p></a></li>
<li><a href='#NWBHDF5IO'><p>Creates a <code>NWBHDF5IO</code> file container</p></a></li>
<li><a href='#plot.ieegio_surface'><p>Plot '3D' surface objects</p></a></li>
<li><a href='#plot.ieegio_volume'><p>Plot '3D' volume in anatomical slices</p></a></li>
<li><a href='#pynwb_module'><p>Install <code>'NWB'</code> via <code>'pynwb'</code></p></a></li>
<li><a href='#read_bci2000'><p>Read 'BCI2000' data file</p></a></li>
<li><a href='#read_brainvis'><p>Read 'BrainVision' data</p></a></li>
<li><a href='#read_edf'><p>Read 'EDF' or 'BDF' data file</p></a></li>
<li><a href='#read_nsx'><p>Read ('BlackRock') 'NEV' 'NSx' data</p></a></li>
<li><a href='#read_nwb'><p>Read 'NWB' format</p></a></li>
<li><a href='#resample_volume'><p>Down-sample or super-sample volume</p></a></li>
<li><a href='#SignalDataCache'><p>Class definition for signal cache</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>File IO for Intracranial Electroencephalography</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Integrated toolbox supporting common file formats used for intracranial 
    Electroencephalography (iEEG) and deep-brain stimulation (DBS) study.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://dipterix.org/ieegio/">http://dipterix.org/ieegio/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dipterix/ieegio/issues">https://github.com/dipterix/ieegio/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.16.0), digest, fastmap, filearray (&ge; 0.1.8),
freesurferformats, fs, fst (&ge; 0.9.0), gifti (&ge; 0.8.0),
grDevices, hdf5r, jsonlite, oro.nifti, R.matlab (&ge; 3.7.0), R6,
readNSx (&ge; 0.0.5), rpyANTs (&ge; 0.0.3), stringr, utils, yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>reticulate, ravetools, rgl, RNifti (&ge; 1.7.0), rpymat (&ge;
0.1.7), xml2, knitr, r3js, rmarkdown, tools, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 19:56:40 UTC; dipterix</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhengjia Wang <a href="https://orcid.org/0000-0001-5629-1116"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhengjia Wang &lt;dipterix.wang@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-07 20:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_ieegio_surface'>Convert other surface formats to <code>ieegio</code> surface</h2><span id='topic+as_ieegio_surface'></span><span id='topic+as_ieegio_surface.default'></span><span id='topic+as_ieegio_surface.character'></span><span id='topic+as_ieegio_surface.ieegio_surface'></span><span id='topic+as_ieegio_surface.mesh3d'></span><span id='topic+as_ieegio_surface.fs.surface'></span>

<h3>Description</h3>

<p>Convert other surface formats to <code>ieegio</code> surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ieegio_surface(x, ...)

## Default S3 method:
as_ieegio_surface(
  x,
  vertices = x,
  faces = NULL,
  face_start = NA,
  transform = NULL,
  vertex_colors = NULL,
  annotation_labels = NULL,
  annotation_values = NULL,
  measurements = NULL,
  time_series_slice_duration = NULL,
  time_series_value = NULL,
  name = NULL,
  ...
)

## S3 method for class 'character'
as_ieegio_surface(x, ...)

## S3 method for class 'ieegio_surface'
as_ieegio_surface(x, ...)

## S3 method for class 'mesh3d'
as_ieegio_surface(x, ...)

## S3 method for class 'fs.surface'
as_ieegio_surface(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_ieegio_surface_+3A_x">x</code></td>
<td>
<p>R object or file path</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_...">...</code></td>
<td>
<p>passed to default method</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_vertices">vertices</code></td>
<td>
<p><code>n</code> by 3 matrix, each row is a vertex node position</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_faces">faces</code></td>
<td>
<p>(optional) face index, either zero or one-indexed
(<code>Matlab</code> and <code>R</code> start counting from 1 while <code>C</code> and
<code>Python</code> start indices from 0); one-index face order is recommended</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_face_start">face_start</code></td>
<td>
<p>(optional) either 0 or 1, indicating whether
<code>faces</code> is zero or one-indexed; default is <code>NA</code>,
which will check whether the minimum value of <code>faces</code> is 0.
If so, then <code>faces</code> will be bumped by 1 internally</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_transform">transform</code></td>
<td>
<p>(optional) a 4 by 4 matrix indicating the vertex position to
scanner <code>RAS</code> transform. Default is missing (identity matrix), i.e.
the vertex positions are already in the scanner <code>RAS</code> coordinate
system.</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_vertex_colors">vertex_colors</code></td>
<td>
<p>(optional) integer or color (hex) vector indicating the
vertex colors</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_annotation_labels">annotation_labels</code></td>
<td>
<p>(optional) a data frame containing at the following
columns. Though optional, <code>annotation_labels</code> must be provided
when <code>annotation_values</code> is provided
</p>

<dl>
<dt><code>"Key"</code></dt><dd><p>unique integers to appear in <code>annotation_values</code>,
indicating the key of the annotation label</p>
</dd>
<dt><code>"Label"</code></dt><dd><p>a character vector (strings) of human-readable labels
of the corresponding key</p>
</dd>
<dt><code>"Color"</code></dt><dd><p>hex string indicating the color of the key/label</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_annotation_values">annotation_values</code></td>
<td>
<p>(optional) an integer table where each column is
a vector of annotation key (for example, 'FreeSurfer' segmentation key)
and each row corresponds to a vertex node</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_measurements">measurements</code></td>
<td>
<p>(optional) a numeric table where each column represents
a variable (for example, curvature) and each row corresponds to a
vertex node. Unlike annotations, which is for discrete node values,
<code>measurements</code> is for continuous values</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_time_series_slice_duration">time_series_slice_duration</code></td>
<td>
<p>(optional) a numeric vector indicating
the duration of each slice; default is <code>NA</code></p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_time_series_value">time_series_value</code></td>
<td>
<p>(optional) a numeric matrix (<code>n</code> by <code>m</code>)
where <code>n</code> is the number of vertices and <code>m</code> is the number of time
points, hence each column is a time slice and each row is a vertex node.</p>
</td></tr>
<tr><td><code id="as_ieegio_surface_+3A_name">name</code></td>
<td>
<p>(optional) name of the geometry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ieeg_surface</code> object; see <code><a href="#topic+read_surface">read_surface</a></code> or
'Examples'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# ---- Simple usage
# vertices only
dodecahedron_vert &lt;- matrix(
  ncol = 3, byrow = TRUE,
  c(-0.62, -0.62, -0.62, 0.62, -0.62, -0.62, -0.62, 0.62, -0.62,
    0.62, 0.62, -0.62, -0.62, -0.62, 0.62, 0.62, -0.62, 0.62,
    -0.62, 0.62, 0.62, 0.62, 0.62, 0.62, 0.00, -0.38, 1.00,
    0.00, 0.38, 1.00, 0.00, -0.38, -1.00, 0.00, 0.38, -1.00,
    -0.38, 1.00, 0.00, 0.38, 1.00, 0.00, -0.38, -1.00, 0.00,
    0.38, -1.00, 0.00, 1.00, 0.00, -0.38, 1.00, 0.00, 0.38,
    -1.00, 0.00, -0.38, -1.00, 0.00, 0.38)
)

point_cloud &lt;- as_ieegio_surface(dodecahedron_vert)
plot(point_cloud, col = "red")

# with face index
dodecahedron_face &lt;- matrix(
  ncol = 3L, byrow = TRUE,
  c(1, 11, 2, 1, 2, 16, 1, 16, 15, 1, 15, 5, 1, 5, 20, 1, 20, 19,
    1, 19, 3, 1, 3, 12, 1, 12, 11, 2, 11, 12, 2, 12, 4, 2, 4, 17,
    2, 17, 18, 2, 18, 6, 2, 6, 16, 3, 13, 14, 3, 14, 4, 3, 4, 12,
    3, 19, 20, 3, 20, 7, 3, 7, 13, 4, 14, 8, 4, 8, 18, 4, 18, 17,
    5, 9, 10, 5, 10, 7, 5, 7, 20, 5, 15, 16, 5, 16, 6, 5, 6, 9,
    6, 18, 8, 6, 8, 10, 6, 10, 9, 7, 10, 8, 7, 8, 14, 7, 14, 13)
)
mesh &lt;- as_ieegio_surface(dodecahedron_vert,
                          faces = dodecahedron_face)
plot(mesh)

# with vertex colors
mesh &lt;- as_ieegio_surface(dodecahedron_vert,
                          faces = dodecahedron_face,
                          vertex_colors = sample(20))
plot(mesh, name = "color")

# with annotations
mesh &lt;- as_ieegio_surface(
  dodecahedron_vert,
  faces = dodecahedron_face,
  annotation_labels = data.frame(
    Key = 1:3,
    Label = c("A", "B", "C"),
    Color = c("red", "green", "blue")
  ),
  annotation_values = data.frame(
    MyVariable = c(rep(1, 7), rep(2, 7), rep(3, 6))
  )
)
plot(mesh, name = "annotations")

# with measurements
mesh &lt;- as_ieegio_surface(
  dodecahedron_vert,
  faces = dodecahedron_face,
  measurements = data.frame(
    MyVariable = dodecahedron_vert[, 1]
  )
)
plot(mesh, name = "measurements",
     col = c("blue", "gray", "red"))



</code></pre>

<hr>
<h2 id='as_ieegio_volume'>Convert objects to <code>'ieegio'</code> image volumes</h2><span id='topic+as_ieegio_volume'></span><span id='topic+as_ieegio_volume.character'></span><span id='topic+as_ieegio_volume.ieegio_volume'></span><span id='topic+as_ieegio_volume.array'></span><span id='topic+as_ieegio_volume.niftiImage'></span><span id='topic+as_ieegio_volume.nifti'></span><span id='topic+as_ieegio_volume.ants.core.ants_image.ANTsImage'></span>

<h3>Description</h3>

<p>Convert array, path, or 'NIfTI' images in other formats to <code>'ieegio'</code>
image volume instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ieegio_volume(x, ...)

## S3 method for class 'character'
as_ieegio_volume(x, ...)

## S3 method for class 'ieegio_volume'
as_ieegio_volume(x, ...)

## S3 method for class 'array'
as_ieegio_volume(x, vox2ras = NULL, as_color = is.character(x), ...)

## S3 method for class 'niftiImage'
as_ieegio_volume(x, ...)

## S3 method for class 'nifti'
as_ieegio_volume(x, ...)

## S3 method for class 'ants.core.ants_image.ANTsImage'
as_ieegio_volume(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_ieegio_volume_+3A_x">x</code></td>
<td>
<p>R object such as array, image path, or objects such as
<code>'RNifti'</code> or <code>'oro.nifti'</code> image instances</p>
</td></tr>
<tr><td><code id="as_ieegio_volume_+3A_...">...</code></td>
<td>
<p>passed to other methods</p>
</td></tr>
<tr><td><code id="as_ieegio_volume_+3A_vox2ras">vox2ras</code></td>
<td>
<p>a <code>4x4</code> 'affine' matrix representing the transform
from 'voxel' index (column-row-slice) to 'RAS'
(right-anterior-superior) coordinate. This transform is often called
<code>'xform'</code>, <code>'sform'</code>, <code>'qform'</code> in 'NIfTI' terms, or
<code>'Norig'</code> in 'FreeSurfer'</p>
</td></tr>
<tr><td><code id="as_ieegio_volume_+3A_as_color">as_color</code></td>
<td>
<p>for converting arrays to volume, whether to treat <code>x</code>
as array of colors; default is true when <code>x</code> is a raster matrix (
matrix of color strings) and false when <code>x</code> is not a character array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ieegio</code> volume object; see <code><a href="#topic+imaging-volume">imaging-volume</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

shape &lt;- c(50, 50, 50)
vox2ras &lt;- matrix(
  c(-1, 0, 0, 25,
    0, 0, 1, -25,
    0, -1, 0, 25,
    0, 0, 0, 1),
  nrow = 4, byrow = TRUE
)

# continuous
x &lt;- array(rnorm(125000), shape)

volume &lt;- as_ieegio_volume(x, vox2ras = vox2ras)
plot(volume, zoom = 3, pixel_width = 0.5)

# color rgb(a)
x &lt;- array(
  sample(c("red","blue", "green", "cyan", "yellow"),
         12500, replace = TRUE),
  shape
)
rgb &lt;- as_ieegio_volume(x, vox2ras = vox2ras)
plot(rgb, zoom = 3, pixel_width = 0.5)



</code></pre>

<hr>
<h2 id='burn_volume'>Burn image at given positions</h2><span id='topic+burn_volume'></span>

<h3>Description</h3>

<p>Burn image at given positions with given color and radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>burn_volume(
  image,
  ras_position,
  col = "red",
  radius = 1,
  reshape = FALSE,
  alpha = FALSE,
  blank_underlay = FALSE,
  ...,
  preview = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="burn_volume_+3A_image">image</code></td>
<td>
<p>volume</p>
</td></tr>
<tr><td><code id="burn_volume_+3A_ras_position">ras_position</code></td>
<td>
<p>image-defined right-anterior-posterior positions, an
<code>nx3</code> matrix, each row is an 'RAS' coordinate</p>
</td></tr>
<tr><td><code id="burn_volume_+3A_col">col</code></td>
<td>
<p>vector of integer or characters, color of each contact</p>
</td></tr>
<tr><td><code id="burn_volume_+3A_radius">radius</code></td>
<td>
<p>vector of positive number indicating the burning radius</p>
</td></tr>
<tr><td><code id="burn_volume_+3A_reshape">reshape</code></td>
<td>
<p>whether to reshape the image at a different resolution;
default is false; can be <code>TRUE</code> (image resolution will be doubled),
a single number (size of isotropic volume along one side), or
a length of three defining the new shape.</p>
</td></tr>
<tr><td><code id="burn_volume_+3A_alpha">alpha</code></td>
<td>
<p>whether to include alpha (transparent) channel. Default is
false for compatibility concerns (legacy software might not support
reading alpha channel). In this case, the background will be black.
If <code>alpha=TRUE</code> is set, then the background will be fully transparent.</p>
</td></tr>
<tr><td><code id="burn_volume_+3A_blank_underlay">blank_underlay</code></td>
<td>
<p>whether to use blank image or the input
<code>image</code> as underlay; default is <code>FALSE</code> (using <code>image</code>
as underlay); alternative is <code>TRUE</code>, and use black or transparent
background</p>
</td></tr>
<tr><td><code id="burn_volume_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+as_ieegio_volume">as_ieegio_volume</a></code>, useful if <code>image</code>
is an array</p>
</td></tr>
<tr><td><code id="burn_volume_+3A_preview">preview</code></td>
<td>
<p>indices (integer) of the position to visualize; default is
<code>NULL</code> (no preview)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color image that is burnt; see <code><a href="#topic+imaging-volume">imaging-volume</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()) {

dim &lt;- c(6, 6, 6)
image &lt;- as_ieegio_volume(
  array(rnorm(prod(dim)), dim),
  vox2ras = rbind(cbind(diag(1, 3), -dim / 2),
                  c(0, 0, 0, 1))
)

ras_positions &lt;- rbind(c(1, -1, 1.5), c(-2.25, -1, -0.75))


burned &lt;- burn_volume(
  image,
  ras_positions,
  col = c("red", "green"),
  radius = 0.5,
  reshape = c(24, 24, 24)
)

plot(
  burned,
  position = ras_positions[1, ],
  zoom = 15,
  pixel_width = 0.25
)

}
</code></pre>

<hr>
<h2 id='ieegio_sample_data'>Download sample files</h2><span id='topic+ieegio_sample_data'></span>

<h3>Description</h3>

<p>Download sample files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ieegio_sample_data(file, test = FALSE, cache_ok = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ieegio_sample_data_+3A_file">file</code></td>
<td>
<p>file to download; set to <code>NULL</code> to view all possible files</p>
</td></tr>
<tr><td><code id="ieegio_sample_data_+3A_test">test</code></td>
<td>
<p>test whether the sample file exists instead of downloading them;
default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ieegio_sample_data_+3A_cache_ok">cache_ok</code></td>
<td>
<p>whether to use cache</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>test</code> is false, returns downloaded file path
(character); when <code>test</code> is true, returns whether the expected
sample exists (logical).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# list available files
ieegio_sample_data()

# check if file edfPlusD.edf exists
ieegio_sample_data("edfPlusD.edf", test = TRUE)

## Not run: 

ieegio_sample_data("edfPlusD.edf")


## End(Not run)

</code></pre>

<hr>
<h2 id='imaging-surface'>Read and write surface files</h2><span id='topic+imaging-surface'></span><span id='topic+read_surface'></span><span id='topic+write_surface'></span><span id='topic+io_read_fs'></span><span id='topic+io_read_gii'></span><span id='topic+io_write_gii'></span>

<h3>Description</h3>

<p>Supports surface geometry, annotation, measurement, and
time-series data.
Please use the high-level function <code>read_surface</code>, which calls
other low-level functions internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_surface(file, format = "auto", type = NULL, ...)

write_surface(
  x,
  con,
  format = c("gifti", "freesurfer"),
  type = c("geometry", "annotations", "measurements", "color", "time_series"),
  ...,
  name = 1
)

io_read_fs(
  file,
  type = c("geometry", "annotations", "measurements"),
  format = "auto",
  name = basename(file),
  ...
)

io_read_gii(file)

io_write_gii(x, con, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imaging-surface_+3A_file">file</code>, <code id="imaging-surface_+3A_con">con</code></td>
<td>
<p>path the file</p>
</td></tr>
<tr><td><code id="imaging-surface_+3A_format">format</code></td>
<td>
<p>format of the file, for <code>write_surface</code>, this is either
<code>'gifti'</code> or <code>'freesurfer'</code>; for <code>read_surface</code>, see
'Arguments' section in <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>
(when file type is <code>'geometry'</code>) and
<code><a href="freesurferformats.html#topic+read.fs.curv">read.fs.curv</a></code>
(when file type is <code>'measurements'</code>)</p>
</td></tr>
<tr><td><code id="imaging-surface_+3A_type">type</code></td>
<td>
<p>type of the data; ignored if the file format is 'GIfTI'. For
'FreeSurfer' files, supported types are
</p>

<dl>
<dt><code>'geometry'</code></dt><dd><p>contains positions of mesh vertex nodes and face
indices;</p>
</dd>
<dt><code>'annotations'</code></dt><dd><p>annotation file (usually with file extension
<code>'annot'</code>) containing a color look-up table and an array of color keys.
These files are used to display discrete values on the surface such as
brain atlas;</p>
</dd>
<dt><code>'measurements'</code></dt><dd><p>measurement file such as <code>'sulc'</code> and
<code>'curv'</code> files, containing numerical values (often with continuous
domain) for each vertex node</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="imaging-surface_+3A_...">...</code></td>
<td>
<p>for <code>read_surface</code>, the arguments will be passed to
<code>io_read_fs</code> if the file is a 'FreeSurfer' file.</p>
</td></tr>
<tr><td><code id="imaging-surface_+3A_x">x</code></td>
<td>
<p>surface (geometry, annotation, measurement) data</p>
</td></tr>
<tr><td><code id="imaging-surface_+3A_name">name</code></td>
<td>
<p>name of the data; for <code>io_read_fs</code>, this argument must be
a character, and default is the file name; for <code>write_surface</code>, this
argument can be an integer or a character, representing the
index or name of the corresponding measurement or annotation column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A surface object container for <code>read_surface</code>, and
the file path for <code>write_surface</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ieegio)

# geometry
geom_file &lt;- "gifti/GzipBase64/sujet01_Lwhite.surf.gii"

# measurements
shape_file &lt;- "gifti/GzipBase64/sujet01_Lwhite.shape.gii"

# time series
ts_file &lt;- "gifti/GzipBase64/fmri_sujet01_Lwhite_projection.time.gii"

if(ieegio_sample_data(geom_file, test = TRUE)) {

  geometry &lt;- read_surface(ieegio_sample_data(geom_file))
  print(geometry)

  measurement &lt;- read_surface(ieegio_sample_data(shape_file))
  print(measurement)

  time_series &lt;- read_surface(ieegio_sample_data(ts_file))
  print(time_series)

  # merge measurement &amp; time_series into geometry
  merged &lt;- merge(geometry, measurement, time_series)
  print(merged)

  # make sure you install `rgl` package
  plot(merged, name = c("measurements", "Shape001"))

  plot(merged, name = "time_series",
       slice_index = c(1, 11, 21, 31))

}


</code></pre>

<hr>
<h2 id='imaging-volume'>Read and write volume data</h2><span id='topic+imaging-volume'></span><span id='topic+read_volume'></span><span id='topic+write_volume'></span><span id='topic+io_read_mgz'></span><span id='topic+io_write_mgz'></span><span id='topic+io_write_mgz.ieegio_volume'></span><span id='topic+io_write_mgz.ieegio_mgh'></span><span id='topic+io_write_mgz.nifti'></span><span id='topic+io_write_mgz.niftiImage'></span><span id='topic+io_write_mgz.ants.core.ants_image.ANTsImage'></span><span id='topic+io_write_mgz.array'></span><span id='topic+io_read_nii'></span><span id='topic+io_write_nii'></span><span id='topic+io_write_nii.ieegio_nifti'></span><span id='topic+io_write_nii.ants.core.ants_image.ANTsImage'></span><span id='topic+io_write_nii.niftiImage'></span><span id='topic+io_write_nii.nifti'></span><span id='topic+io_write_nii.ieegio_mgh'></span><span id='topic+io_write_nii.array'></span>

<h3>Description</h3>

<p>Read and write volume data ('MRI', 'CT', etc.) in 'NIfTI' or 'MGH' formats.
Please use <code>read_volume</code> and <code>write_volume</code> for high-level
function. These functions
will call other low-level functions internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_volume(file, header_only = FALSE, format = c("auto", "nifti", "mgh"), ...)

write_volume(x, con, format = c("auto", "nifti", "mgh"), ...)

io_read_mgz(file, header_only = FALSE)

io_write_mgz(x, con, ...)

## S3 method for class 'ieegio_volume'
io_write_mgz(x, con, ...)

## S3 method for class 'ieegio_mgh'
io_write_mgz(x, con, ...)

## S3 method for class 'nifti'
io_write_mgz(x, con, ...)

## S3 method for class 'niftiImage'
io_write_mgz(x, con, ...)

## S3 method for class 'ants.core.ants_image.ANTsImage'
io_write_mgz(x, con, ...)

## S3 method for class 'array'
io_write_mgz(x, con, vox2ras = NULL, ...)

io_read_nii(
  file,
  method = c("rnifti", "oro", "ants"),
  header_only = FALSE,
  ...
)

io_write_nii(x, con, ...)

## S3 method for class 'ieegio_nifti'
io_write_nii(x, con, ...)

## S3 method for class 'ants.core.ants_image.ANTsImage'
io_write_nii(x, con, ...)

## S3 method for class 'niftiImage'
io_write_nii(x, con, ...)

## S3 method for class 'nifti'
io_write_nii(x, con, gzipped = NA, ...)

## S3 method for class 'ieegio_mgh'
io_write_nii(x, con, ...)

## S3 method for class 'array'
io_write_nii(
  x,
  con,
  vox2ras = NULL,
  datatype_code = NULL,
  xyzt_units = c("NIFTI_UNITS_MM", "NIFTI_UNITS_SEC"),
  intent_code = "NIFTI_INTENT_NONE",
  ...,
  gzipped = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imaging-volume_+3A_file">file</code></td>
<td>
<p>file path to read volume data</p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_header_only">header_only</code></td>
<td>
<p>whether to read header data only;
default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_format">format</code></td>
<td>
<p>format of the file to be written; choices are <code>'auto'</code>,
<code>'nifti'</code> or <code>'mgh'</code>; default is to <code>'auto'</code>
detect the format based on file names, which will save as a 'MGH' file
when file extension is <code>'mgz'</code> or <code>'mgh'</code>, otherwise 'NIfTI'
format. We recommend explicitly setting this argument</p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_...">...</code></td>
<td>
<p>passed to other methods</p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_x">x</code></td>
<td>
<p>volume data (such as 'NIfTI' image, array, or 'MGH')
to be saved</p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_con">con</code></td>
<td>
<p>file path to store image</p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_vox2ras">vox2ras</code></td>
<td>
<p>a <code>4x4</code> transform matrix from voxel indexing (column,
row, slice) to scanner (often 'T1-weighted' image) 'RAS'
(right-anterior-superior) coordinate</p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_method">method</code></td>
<td>
<p>method to read the file; choices are <code>'oro'</code> (using
<code><a href="oro.nifti.html#topic+readNIfTI">readNIfTI</a></code>), <code>'rnifti'</code> (using
<code><a href="RNifti.html#topic+readNifti">readNifti</a></code>), and <code>'ants'</code> (using
<code><a href="rpyANTs.html#topic+as_ANTsImage">as_ANTsImage</a></code>).</p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_gzipped">gzipped</code></td>
<td>
<p>for writing <code>'nii'</code> data: whether the file needs to be
compressed; default is inferred from the file name. When the file ends
with <code>'nii'</code>, then no compression is used; otherwise the file will
be compressed. If the file name does not end with <code>'nii'</code> nor
<code>'nii.gz'</code>, then the file extension will be added automatically.</p>
</td></tr>
<tr><td><code id="imaging-volume_+3A_datatype_code">datatype_code</code>, <code id="imaging-volume_+3A_xyzt_units">xyzt_units</code>, <code id="imaging-volume_+3A_intent_code">intent_code</code></td>
<td>
<p>additional flags for
'NIfTI' headers, for advanced users</p>
</td></tr>
</table>


<h3>Format</h3>

<p>format of the file; default is auto-detection, other choices are
<code>'nifti'</code> and <code>'mgh'</code>;
</p>


<h3>Value</h3>

<p>Imaging readers return <code>ieegio_volume</code> objects. The writers
return the file path to where the file is saved to.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ieegio)

nifti_file &lt;- "brain.demosubject.nii.gz"

# Use `ieegio_sample_data(nifti_file)`
#   to download sample data


if( ieegio_sample_data(nifti_file, test = TRUE) ) {

# ---- NIfTI examples ---------------------------------------------

file &lt;- ieegio_sample_data(nifti_file)

# basic read
vol &lt;- read_volume(file)

# voxel to scanner RAS
vol$transforms$vox2ras

# to freesurfer surface
vol$transforms$vox2ras_tkr

# to FSL
vol$transforms$vox2fsl

plot(vol, position = c(10, 0, 30))

# ---- using other methods --------------------------------------
# default
vol &lt;- read_volume(file, method = "rnifti", format = "nifti")
vol$header

# lazy-load nifti
vol2 &lt;- read_volume(file, method = "oro", format = "nifti")
vol2$header

## Not run: 
# requires additional python environment

# Using ANTsPyx
vol3 &lt;- read_volume(file, method = "ants", format = "nifti")
vol3$header


## End(Not run)

# ---- write --------------------------------------------------------

# write as NIfTI
f &lt;- tempfile(fileext = ".nii.gz")

write_volume(vol, f, format = "nifti")

# alternative method
write_volume(vol$header, f, format = "nifti")

# write to mgz/mgh
f2 &lt;- tempfile(fileext = ".mgz")

write_volume(vol, f, format = "mgh")

# clean up
unlink(f)
unlink(f2)

}

</code></pre>

<hr>
<h2 id='io_h5_valid'>Check whether a 'HDF5' file can be opened for read/write</h2><span id='topic+io_h5_valid'></span><span id='topic+io_h5_names'></span>

<h3>Description</h3>

<p>Check whether a 'HDF5' file can be opened for read/write
</p>


<h3>Usage</h3>

<pre><code class='language-R'>io_h5_valid(file, mode = c("r", "w"), close_all = FALSE)

io_h5_names(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="io_h5_valid_+3A_file">file</code></td>
<td>
<p>path to file</p>
</td></tr>
<tr><td><code id="io_h5_valid_+3A_mode">mode</code></td>
<td>
<p><code>'r'</code> for read access and <code>'w'</code> for write access</p>
</td></tr>
<tr><td><code id="io_h5_valid_+3A_close_all">close_all</code></td>
<td>
<p>whether to close all connections or just close current
connection; default is false. Set this to <code>TRUE</code> if you want to
close all other connections to the file</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>io_h5_valid</code> returns a logical value indicating whether the
file can be opened. <code>io_h5_names</code> returns a character vector of
dataset names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- array(1:27, c(3,3,3))
f &lt;- tempfile()

# No data written to the file, hence invalid
io_h5_valid(f, 'r')

io_write_h5(x, f, 'dset')
io_h5_valid(f, 'w')

# Open the file and hold a connection
ptr &lt;- hdf5r::H5File$new(filename = f, mode = 'w')

# Can read, but cannot write
io_h5_valid(f, 'r')  # TRUE
io_h5_valid(f, 'w')  # FALSE

# However, this can be reset via `close_all=TRUE`
io_h5_valid(f, 'r', close_all = TRUE)
io_h5_valid(f, 'w')  # TRUE

# Now the connection is no longer valid
ptr

# clean up
unlink(f)

</code></pre>

<hr>
<h2 id='io_read_h5'>Lazy Load 'HDF5' File via <code><a href="hdf5r.html#topic+hdf5r-package">hdf5r-package</a></code></h2><span id='topic+io_read_h5'></span>

<h3>Description</h3>

<p>Wrapper for class <code><a href="#topic+LazyH5">LazyH5</a></code>, which load data with
&quot;lazy&quot; mode - only read part of dataset when needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>io_read_h5(file, name, read_only = TRUE, ram = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="io_read_h5_+3A_file">file</code></td>
<td>
<p>'HDF5' file</p>
</td></tr>
<tr><td><code id="io_read_h5_+3A_name">name</code></td>
<td>
<p><code>group/data_name</code> path to dataset (<code>H5D</code> data)</p>
</td></tr>
<tr><td><code id="io_read_h5_+3A_read_only">read_only</code></td>
<td>
<p>only used if <code>ram=FALSE</code>, whether the returned
<code><a href="#topic+LazyH5">LazyH5</a></code> instance should be read only</p>
</td></tr>
<tr><td><code id="io_read_h5_+3A_ram">ram</code></td>
<td>
<p>load data to memory immediately, default is false</p>
</td></tr>
<tr><td><code id="io_read_h5_+3A_quiet">quiet</code></td>
<td>
<p>whether to suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>ram</code> is true, then return data as arrays, otherwise return
a <code><a href="#topic+LazyH5">LazyH5</a></code> instance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+io_write_h5">io_write_h5</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- tempfile()
x &lt;- array(1:120, dim = c(4,5,6))

# save x to file with name /group/dataset/1
io_write_h5(x, file, '/group/dataset/1', quiet = TRUE)

# read data
y &lt;- io_read_h5(file, '/group/dataset/1', ram = TRUE)
class(y)   # array

z &lt;- io_read_h5(file, '/group/dataset/1', ram = FALSE)
class(z)   # LazyH5

dim(z)

# clean up
unlink(file)

</code></pre>

<hr>
<h2 id='io_write_h5'>Save objects to 'HDF5' file without trivial checks</h2><span id='topic+io_write_h5'></span>

<h3>Description</h3>

<p>Save objects to 'HDF5' file without trivial checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>io_write_h5(
  x,
  file,
  name,
  chunk = "auto",
  level = 4,
  replace = TRUE,
  new_file = FALSE,
  ctype = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="io_write_h5_+3A_x">x</code></td>
<td>
<p>an array, a matrix, or a vector</p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_file">file</code></td>
<td>
<p>path to 'HDF5' file</p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_name">name</code></td>
<td>
<p>path/name of the data; for example, <code>"group/data_name"</code></p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_chunk">chunk</code></td>
<td>
<p>chunk size</p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_level">level</code></td>
<td>
<p>compress level from 0 - no compression to 10 - max compression</p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_replace">replace</code></td>
<td>
<p>should data be replaced if exists</p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_new_file">new_file</code></td>
<td>
<p>should removing the file if old one exists</p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_ctype">ctype</code></td>
<td>
<p>data type such as &quot;character&quot;, &quot;integer&quot;, or &quot;numeric&quot;. If
set to <code>NULL</code> then automatically detect types. Note for complex data
please store separately the real and imaginary parts.</p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_quiet">quiet</code></td>
<td>
<p>whether to suppress messages, default is false</p>
</td></tr>
<tr><td><code id="io_write_h5_+3A_...">...</code></td>
<td>
<p>passed to other <code>LazyH5$save</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Absolute path of the file saved
</p>


<h3>See Also</h3>

<p><code><a href="#topic+io_read_h5">io_read_h5</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file &lt;- tempfile()
x &lt;- array(1:120, dim = 2:5)

# save x to file with name /group/dataset/1
io_write_h5(x, file, '/group/dataset/1', chunk = dim(x))

# load data
y &lt;- io_read_h5(file, '/group/dataset/1')

# read data to memory
y[]

# clean up
unlink(file)

</code></pre>

<hr>
<h2 id='LazyH5'>Lazy 'HDF5' file loader</h2><span id='topic+LazyH5'></span>

<h3>Description</h3>

<p>Provides hybrid data structure for 'HDF5' file. The class is
not intended for direct-use. Please see <code><a href="#topic+io_read_h5">io_read_h5</a></code> and
<code><a href="#topic+io_write_h5">io_write_h5</a></code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>quiet</code></dt><dd><p>whether to suppress messages</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LazyH5-finalize"><code>LazyH5$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-LazyH5-print"><code>LazyH5$print()</code></a>
</p>
</li>
<li> <p><a href="#method-LazyH5-new"><code>LazyH5$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LazyH5-save"><code>LazyH5$save()</code></a>
</p>
</li>
<li> <p><a href="#method-LazyH5-open"><code>LazyH5$open()</code></a>
</p>
</li>
<li> <p><a href="#method-LazyH5-close"><code>LazyH5$close()</code></a>
</p>
</li>
<li> <p><a href="#method-LazyH5-subset"><code>LazyH5$subset()</code></a>
</p>
</li>
<li> <p><a href="#method-LazyH5-get_dims"><code>LazyH5$get_dims()</code></a>
</p>
</li>
<li> <p><a href="#method-LazyH5-get_type"><code>LazyH5$get_type()</code></a>
</p>
</li></ul>


<hr>
<a id="method-LazyH5-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>garbage collection method
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$finalize()</pre></div>



<h5>Returns</h5>

<p>none
</p>


<hr>
<a id="method-LazyH5-print"></a>



<h4>Method <code>print()</code></h4>

<p>overrides print method
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$print()</pre></div>



<h5>Returns</h5>

<p>self instance
</p>


<hr>
<a id="method-LazyH5-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$new(file_path, data_name, read_only = FALSE, quiet = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file_path</code></dt><dd><p>where data is stored in 'HDF5' format</p>
</dd>
<dt><code>data_name</code></dt><dd><p>the data stored in the file</p>
</dd>
<dt><code>read_only</code></dt><dd><p>whether to open the file in read-only mode. It's highly
recommended to set this to be true, otherwise the file connection is
exclusive.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>whether to suppress messages, default is false</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>self instance
</p>


<hr>
<a id="method-LazyH5-save"></a>



<h4>Method <code>save()</code></h4>

<p>save data to a 'HDF5' file
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$save(
  x,
  chunk = "auto",
  level = 7,
  replace = TRUE,
  new_file = FALSE,
  force = TRUE,
  ctype = NULL,
  size = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector, matrix, or array</p>
</dd>
<dt><code>chunk</code></dt><dd><p>chunk size, length should matches with data dimension</p>
</dd>
<dt><code>level</code></dt><dd><p>compress level, from 1 to 9</p>
</dd>
<dt><code>replace</code></dt><dd><p>if the data exists in the file, replace the file or not</p>
</dd>
<dt><code>new_file</code></dt><dd><p>remove the whole file if exists before writing?</p>
</dd>
<dt><code>force</code></dt><dd><p>if you open the file in read-only mode, then saving
objects to the file will raise error. Use <code>force=TRUE</code> to force
write data</p>
</dd>
<dt><code>ctype</code></dt><dd><p>data type, see <code><a href="base.html#topic+mode">mode</a></code>, usually the data type
of <code>x</code>. Try <code>mode(x)</code> or <code>storage.mode(x)</code> as hints.</p>
</dd>
<dt><code>size</code></dt><dd><p>deprecated, for compatibility issues</p>
</dd>
<dt><code>...</code></dt><dd><p>passed to self <code>open()</code> method</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LazyH5-open"></a>



<h4>Method <code>open()</code></h4>

<p>open connection
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$open(new_dataset = FALSE, robj, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_dataset</code></dt><dd><p>only used when the internal pointer is closed, or
to write the data</p>
</dd>
<dt><code>robj</code></dt><dd><p>data array to save</p>
</dd>
<dt><code>...</code></dt><dd><p>passed to <code>createDataSet</code> in <code>hdf5r</code> package</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LazyH5-close"></a>



<h4>Method <code>close()</code></h4>

<p>close connection
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$close(all = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>all</code></dt><dd><p>whether to close all connections associated to the data file.
If true, then all connections, including access from other programs,
will be closed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LazyH5-subset"></a>



<h4>Method <code>subset()</code></h4>

<p>subset data
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$subset(..., drop = FALSE, stream = FALSE, envir = parent.frame())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>drop</code></dt><dd><p>whether to apply <code><a href="base.html#topic+drop">drop</a></code> the subset</p>
</dd>
<dt><code>stream</code></dt><dd><p>whether to read partial data at a time</p>
</dd>
<dt><code>envir</code></dt><dd><p>if <code>i,j,...</code> are expressions, where should the
expression be evaluated</p>
</dd>
<dt><code>i, j, ...</code></dt><dd><p>index along each dimension</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>subset of data
</p>


<hr>
<a id="method-LazyH5-get_dims"></a>



<h4>Method <code>get_dims()</code></h4>

<p>get data dimension
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$get_dims(stay_open = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stay_open</code></dt><dd><p>whether to leave the connection opened</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>dimension of the array
</p>


<hr>
<a id="method-LazyH5-get_type"></a>



<h4>Method <code>get_type()</code></h4>

<p>get data type
</p>


<h5>Usage</h5>

<div class="r"><pre>LazyH5$get_type(stay_open = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stay_open</code></dt><dd><p>whether to leave the connection opened</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data type, currently only character, integer, raw,
double, and complex are available, all other types will yield &quot;unknown&quot;
</p>



<hr>
<h2 id='low-level-read-write'>Low-level file read and write</h2><span id='topic+low-level-read-write'></span><span id='topic+io_read_fst'></span><span id='topic+io_write_fst'></span><span id='topic+io_read_ini'></span><span id='topic+io_read_json'></span><span id='topic+io_write_json'></span><span id='topic+io_read_mat'></span><span id='topic+io_write_mat'></span><span id='topic+io_read_yaml'></span><span id='topic+io_write_yaml'></span>

<h3>Description</h3>

<p>Interfaces to read from or write to files with common formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>io_read_fst(
  con,
  method = c("proxy", "data_table", "data_frame", "header_only"),
  ...,
  old_format = FALSE
)

io_write_fst(x, con, compress = 50, ...)

io_read_ini(con, ...)

io_read_json(con, ...)

io_write_json(
  x,
  con = stdout(),
  ...,
  digits = ceiling(-log10(.Machine$double.eps)),
  pretty = TRUE,
  serialize = TRUE
)

io_read_mat(
  con,
  method = c("auto", "R.matlab", "pymatreader", "mat73"),
  verbose = TRUE,
  on_convert_error = c("warning", "error", "ignore"),
  ...
)

io_write_mat(x, con, method = c("R.matlab", "scipy"), ...)

io_read_yaml(con, ...)

io_write_yaml(x, con, ..., sorted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="low-level-read-write_+3A_con">con</code></td>
<td>
<p>connection or file</p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_method">method</code></td>
<td>
<p>method to read table. For <code>'fst'</code>, the choices are
</p>

<dl>
<dt><code>'proxy'</code></dt><dd><p>do not read data to memory, query the table when
needed;</p>
</dd>
<dt><code>'data_table'</code></dt><dd><p>read as <code><a href="data.table.html#topic+data.table">data.table</a></code>;</p>
</dd>
<dt><code>'data_frame'</code></dt><dd><p>read as <code><a href="base.html#topic+data.frame">data.frame</a></code>;</p>
</dd>
<dt><code>'header_only'</code></dt><dd><p>read <code>'fst'</code> table header.</p>
</dd>
</dl>

<p>For <code>'mat'</code>, the choices are
</p>

<dl>
<dt><code>'auto'</code></dt><dd><p>automatically try the native option, and then
<code>'pymatreader'</code> if fails;</p>
</dd>
<dt><code>'R.matlab'</code></dt><dd><p>use the native method (provided
by <code><a href="R.matlab.html#topic+readMat">readMat</a></code>); only support 'MAT 5.0' format;</p>
</dd>
<dt><code>'pymatreader'</code></dt><dd><p>use 'Python' library <code>'pymatreader'</code>;</p>
</dd>
<dt><code>'mat73'</code></dt><dd><p>use 'Python' library <code>'mat73'</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_...">...</code></td>
<td>
<p>passed to internal function calls</p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_old_format">old_format</code></td>
<td>
<p>see <code><a href="fst.html#topic+fst">fst</a></code></p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_x">x</code></td>
<td>
<p>data to write to disk</p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_compress">compress</code></td>
<td>
<p>compress level from 0 to 100; default is 50</p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_digits">digits</code>, <code id="low-level-read-write_+3A_pretty">pretty</code></td>
<td>
<p>for writing numeric values to 'json' format</p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_serialize">serialize</code></td>
<td>
<p>set to <code>TRUE</code> to serialize the data to 'json' format
(with the data types, default); or <code>FALSE</code> to save the
values without types</p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_verbose">verbose</code></td>
<td>
<p>whether to print out the process</p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_on_convert_error">on_convert_error</code></td>
<td>
<p>for reading <code>'mat'</code> files with 'Python' modules,
the results will be converted to R objects in the end. Not all objects
can be converted. This input defines the behavior when the conversion fails;
choices are <code>"error"</code>, <code>"warning"</code>, or <code>"ignore"</code></p>
</td></tr>
<tr><td><code id="low-level-read-write_+3A_sorted">sorted</code></td>
<td>
<p>whether to sort the list; default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reader functions returns the data extracted from files, mostly
as R objects, with few exceptions on some 'Matlab' files. When reading a
'Matlab' file requires using 'Python' modules, <code>io_read_mat</code> will
try its best effort to convert 'Python' objects to R. However, such
conversion might fail. In this case, the result might partially contain
'Python' objects with warnings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---- fst ----------------------------------------------------------------


f &lt;- tempfile(fileext = ".fst")
x &lt;- data.frame(
  a = 1:10,
  b = rnorm(10),
  c = letters[1:10]
)

io_write_fst(x, con = f)

# default reads in proxy
io_read_fst(f)

# load as data.table
io_read_fst(f, "data_table")

# load as data.frame
io_read_fst(f, "data_frame")

# get header
io_read_fst(f, "header_only")

# clean up
unlink(f)



# ---- json ---------------------------------------------------------------
f &lt;- tempfile(fileext = ".json")

x &lt;- list(a = 1L, b = 2.3, c = "a", d = 1+1i)

# default is serialize
io_write_json(x, f)

io_read_json(f)

cat(readLines(f), sep = "\n")

# just values
io_write_json(x, f, serialize = FALSE, pretty = FALSE)

io_read_json(f)

cat(readLines(f), sep = "\n")

# clean up
unlink(f)



# ---- Matlab .mat --------------------------------------------------------

## Not run: 

f &lt;- tempfile(fileext = ".mat")

x &lt;- list(a = 1L, b = 2.3, c = "a", d = 1+1i)

# save as MAT 5.0
io_write_mat(x, f)

io_read_mat(f)

# require setting up Python environment

io_read_mat(f, method = "pymatreader")

# MAT 7.3 example
sample_data &lt;- ieegio_sample_data("mat_v73.mat")
io_read_mat(sample_data)

# clean up
unlink(f)


## End(Not run)



# ---- yaml ---------------------------------------------------------------

f &lt;- tempfile(fileext = ".yaml")

x &lt;- list(a = 1L, b = 2.3, c = "a")
io_write_yaml(x, f)

io_read_yaml(f)

# clean up
unlink(f)

</code></pre>

<hr>
<h2 id='merge.ieegio_surface'>Merge two <code>'ieegio'</code> surfaces</h2><span id='topic+merge.ieegio_surface'></span>

<h3>Description</h3>

<p>Either merge surface objects by attributes or merge geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ieegio_surface'
merge(
  x,
  y,
  ...,
  merge_type = c("attribute", "geometry"),
  merge_space = c("model", "world"),
  transform_index = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge.ieegio_surface_+3A_x">x</code>, <code id="merge.ieegio_surface_+3A_y">y</code>, <code id="merge.ieegio_surface_+3A_...">...</code></td>
<td>
<p><code>'ieegio'</code> surface objects, see
<code><a href="#topic+as_ieegio_surface">as_ieegio_surface</a></code> or <code><a href="#topic+read_surface">read_surface</a></code>. Object
<code>x</code> must contain geometry information.</p>
</td></tr>
<tr><td><code id="merge.ieegio_surface_+3A_merge_type">merge_type</code></td>
<td>
<p>type of merge:
</p>

<dl>
<dt><code>"attribute"</code></dt><dd><p>merge <code>y,...</code> into x by attributes such
as color, measurements, annotations, or time-series data, assuming
<code>x,y,...</code> all refer to the same geometry, hence the underlying
number of vertices should be the same.</p>
</dd>
<dt><code>"geometry"</code></dt><dd><p>merge <code>y,...</code> into x by geometry; this
requires the surfaces to merge have geometries and cannot be only surface
attributes. Two mesh objects will be merged into one, and face index will
be re-calculated. The merge happens in transformed space, Notice the attributes will be ignored and eventually
discarded during merge.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="merge.ieegio_surface_+3A_merge_space">merge_space</code></td>
<td>
<p>space to merge the geometries; only used when
<code>merge_type</code> is <code>"geometry"</code>. Default is to directly merge the
surfaces in <code>"model"</code> space, i.e. assuming the surfaces share the same
transform; alternatively, if the model to world transforms are different,
users can choose to merge in <code>"world"</code> space, then all the surfaces
will be transformed into world space and mapped back to the model space
in <code>x</code></p>
</td></tr>
<tr><td><code id="merge.ieegio_surface_+3A_transform_index">transform_index</code></td>
<td>
<p>which local-to-world transform to use when merging
geometries in the world space; default is the first transform for each
surface object. The transform list can be obtained from
<code>surface$geometry$transforms</code> and <code>transform_index</code> indicates the
index of the transform matrices. The length of <code>transform_index</code> can be
either 1 (same for all surfaces) or the length of all the surfaces, (i.e.
length of <code>list(x,y,...)</code>), when the index needs to be set for each
surface respectively. If any index is set to <code>NA</code>, then it means no
transform is to be applied and that surface will be merged assuming its
model space is the world space.</p>
</td></tr>
<tr><td><code id="merge.ieegio_surface_+3A_verbose">verbose</code></td>
<td>
<p>whether to verbose the messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged surface object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Construct example geometry
dodecahedron_vert &lt;- matrix(
  ncol = 3, byrow = TRUE,
  c(-0.62, -0.62, -0.62, 0.62, -0.62, -0.62, -0.62, 0.62, -0.62,
    0.62, 0.62, -0.62, -0.62, -0.62, 0.62, 0.62, -0.62, 0.62,
    -0.62, 0.62, 0.62, 0.62, 0.62, 0.62, 0.00, -0.38, 1.00,
    0.00, 0.38, 1.00, 0.00, -0.38, -1.00, 0.00, 0.38, -1.00,
    -0.38, 1.00, 0.00, 0.38, 1.00, 0.00, -0.38, -1.00, 0.00,
    0.38, -1.00, 0.00, 1.00, 0.00, -0.38, 1.00, 0.00, 0.38,
    -1.00, 0.00, -0.38, -1.00, 0.00, 0.38)
)

dodecahedron_face &lt;- matrix(
  ncol = 3L, byrow = TRUE,
  c(1, 11, 2, 1, 2, 16, 1, 16, 15, 1, 15, 5, 1, 5, 20, 1, 20, 19,
    1, 19, 3, 1, 3, 12, 1, 12, 11, 2, 11, 12, 2, 12, 4, 2, 4, 17,
    2, 17, 18, 2, 18, 6, 2, 6, 16, 3, 13, 14, 3, 14, 4, 3, 4, 12,
    3, 19, 20, 3, 20, 7, 3, 7, 13, 4, 14, 8, 4, 8, 18, 4, 18, 17,
    5, 9, 10, 5, 10, 7, 5, 7, 20, 5, 15, 16, 5, 16, 6, 5, 6, 9,
    6, 18, 8, 6, 8, 10, 6, 10, 9, 7, 10, 8, 7, 8, 14, 7, 14, 13)
)

x0 &lt;- as_ieegio_surface(dodecahedron_vert, faces = dodecahedron_face)

plot(x0)


# ---- merge by attributes -----------------------------------

# point-cloud but with vertex measurements
y1 &lt;- as_ieegio_surface(
  dodecahedron_vert,
  measurements = data.frame(MyVariable = dodecahedron_vert[, 1]),
  transform = diag(c(2,1,0.5,1))
)

plot(y1)

# the geometry of `y1` will be discarded and only attributes
# (in this case, measurements:MyVariable) will be merged to `x`

z1 &lt;- merge(x0, y1, merge_type = "attribute")

plot(z1)

# ---- merge by geometry ----------------------------------------

y2 &lt;- as_ieegio_surface(
  dodecahedron_vert + 4, faces = dodecahedron_face,
  transform = diag(c(2, 1, 0.5, 1))
)

plot(y2)

# merge directly in model space: transform matrix of `y2` will be ignored
z2 &lt;- merge(x0, y2, merge_type = "geometry", merge_space = "model")

plot(z2)

# merge x, y2 in the world space where transforms will be respected
z3 &lt;- merge(x0, y2, merge_type = "geometry", merge_space = "world")

plot(z3)



</code></pre>

<hr>
<h2 id='merge.ieegio_volume'>Merge <code>'ieegio'</code> volumes</h2><span id='topic+merge.ieegio_volume'></span>

<h3>Description</h3>

<p>Merge volume data into base image. The images must be static 3-dimensional
volume data. Currently time-series or 4-dimensional data is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ieegio_volume'
merge(x, y, ..., thresholds = 0, reshape = dim(x), na_fill = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge.ieegio_volume_+3A_x">x</code></td>
<td>
<p>base image to be merged</p>
</td></tr>
<tr><td><code id="merge.ieegio_volume_+3A_y">y</code>, <code id="merge.ieegio_volume_+3A_...">...</code></td>
<td>
<p>images to be merged into <code>x</code></p>
</td></tr>
<tr><td><code id="merge.ieegio_volume_+3A_thresholds">thresholds</code></td>
<td>
<p>numerical threshold for <code>y,...</code>, can be length of one
or more, if images to overlay is more than one. The image values lower
than the threshold will be trimmed out</p>
</td></tr>
<tr><td><code id="merge.ieegio_volume_+3A_reshape">reshape</code></td>
<td>
<p>output shape, default is the dimension of <code>x</code>; if
changed, then the underlay will be sampled into the new shape</p>
</td></tr>
<tr><td><code id="merge.ieegio_volume_+3A_na_fill">na_fill</code></td>
<td>
<p>how to handle missing values; default is <code>NA</code>; for
compatibility, you might want to set to 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Merged volume with dimension <code>reshape</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base_array &lt;- array(0, c(15, 15, 15))
base_array[4:6, 4:6, 4:6] &lt;- runif(27) * 255

# generate a 15x15x15 mask with 1mm spacing
vox2ras1 &lt;- diag(1, 4)
vox2ras1[1:3, 4] &lt;- -5
x &lt;- as_ieegio_volume(base_array, vox2ras = vox2ras1)


# 15x15x15 mask with 0.5mmx1mmx1mm spacing but oblique to `x`
vox2ras2 &lt;- matrix(
  nrow = 4, byrow = TRUE,
  c(
    2, 0.2, -0.1, -3,
    -0.2, 1, 0.4, -4,
    0.3, -0.1, 1, -1,
    0, 0, 0, 1
  )
)
# vox2ras2[1:3, 4] &lt;- c(-3,-4, -1)
base_array[4:6, 4:6, 4:6] &lt;- runif(27) * 255
y &lt;- as_ieegio_volume(base_array, vox2ras = vox2ras2)


# merge y into x and up-sample mask to 64^3 volume
# set to higher number to get better interpolation quality
# Only voxels of y&gt;0 will be merged to x
z &lt;- merge(x, y, reshape = c(64, 64, 64), thresholds = 0)

# Visualize

oldpar &lt;- par(mfrow = c(1, 3), mar = c(0, 0, 2, 0))

zoom &lt;- 10
crosshair_ras &lt;- c(0, 0, 0)
pixel_width &lt;- 2

plot(x,
     zoom = zoom,
     position = crosshair_ras,
     pixel_width = pixel_width,
     main = "Original - underlay")
plot(y,
     zoom = zoom,
     position = crosshair_ras,
     pixel_width = pixel_width,
     main = "Original - overlay")
plot(
  z,
  zoom = zoom,
  position = crosshair_ras,
  pixel_width = pixel_width,
  main = "Merged &amp; up-sampled")

# reset graphical state
par(oldpar)


</code></pre>

<hr>
<h2 id='NWBHDF5IO'>Creates a <code>NWBHDF5IO</code> file container</h2><span id='topic+NWBHDF5IO'></span>

<h3>Description</h3>

<p>Class definition for 'PyNWB' container; use <code><a href="#topic+read_nwb">read_nwb</a></code>
for construction function.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>opened</code></dt><dd><p>Whether the container is opened.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NWBHDF5IO-new"><code>NWBHDF5IO$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NWBHDF5IO-get_handler"><code>NWBHDF5IO$get_handler()</code></a>
</p>
</li>
<li> <p><a href="#method-NWBHDF5IO-open"><code>NWBHDF5IO$open()</code></a>
</p>
</li>
<li> <p><a href="#method-NWBHDF5IO-close"><code>NWBHDF5IO$close()</code></a>
</p>
</li>
<li> <p><a href="#method-NWBHDF5IO-close_linked_files"><code>NWBHDF5IO$close_linked_files()</code></a>
</p>
</li>
<li> <p><a href="#method-NWBHDF5IO-read"><code>NWBHDF5IO$read()</code></a>
</p>
</li>
<li> <p><a href="#method-NWBHDF5IO-with"><code>NWBHDF5IO$with()</code></a>
</p>
</li>
<li> <p><a href="#method-NWBHDF5IO-clone"><code>NWBHDF5IO$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-NWBHDF5IO-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the class
</p>


<h5>Usage</h5>

<div class="r"><pre>NWBHDF5IO$new(path = NULL, mode = c("r", "w", "r+", "a", "w-", "x"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path to a <code>'.nwb'</code> file</p>
</dd>
<dt><code>mode</code></dt><dd><p>Mode for opening the file</p>
</dd>
<dt><code>...</code></dt><dd><p>Other parameters passed to <code>nwb$NWBHDF5IO</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-NWBHDF5IO-get_handler"></a>



<h4>Method <code>get_handler()</code></h4>

<p>Get internal file handler. Please make sure you close the handler
correctly.
</p>


<h5>Usage</h5>

<div class="r"><pre>NWBHDF5IO$get_handler()</pre></div>



<h5>Returns</h5>

<p>File handler, i.e. 'PyNWB' <code>NWBHDF5IO</code> instance.
</p>


<hr>
<a id="method-NWBHDF5IO-open"></a>



<h4>Method <code>open()</code></h4>

<p>Open the connections, must be used together with <code>$close</code> method.
For high-level method, see <code>$with</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>NWBHDF5IO$open()</pre></div>



<h5>Returns</h5>

<p>container itself
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{

# low-level method to open NWB file, for safer methods, see
# `container$with()` below

container$open()

data &lt;- container$read()

# process data...

# Make sure the container is closed!
container$close()

}
</pre>
</div>


<hr>
<a id="method-NWBHDF5IO-close"></a>



<h4>Method <code>close()</code></h4>

<p>Close the connections (low-level method, see 'with' method below)
</p>


<h5>Usage</h5>

<div class="r"><pre>NWBHDF5IO$close(close_links = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>close_links</code></dt><dd><p>Whether to close all files linked to from this
file; default is true</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing
</p>


<hr>
<a id="method-NWBHDF5IO-close_linked_files"></a>



<h4>Method <code>close_linked_files()</code></h4>

<p>Close all opened, linked-to files. <code>'MacOS'</code> and <code>'Linux'</code>
automatically release the linked-to file after the linking file is
closed, but <code>'Windows'</code> does not, which prevents the linked-to
file from being deleted or truncated. Use this method to close all
opened, linked-to files.
</p>


<h5>Usage</h5>

<div class="r"><pre>NWBHDF5IO$close_linked_files()</pre></div>



<h5>Returns</h5>

<p>Nothing
</p>


<hr>
<a id="method-NWBHDF5IO-read"></a>



<h4>Method <code>read()</code></h4>

<p>Read the <code>'NWB'</code> file from the 'IO' source. Please use along with
<code>'$with'</code> method
</p>


<h5>Usage</h5>

<div class="r"><pre>NWBHDF5IO$read()</pre></div>



<h5>Returns</h5>

<p><code>'NWBFile'</code> container
</p>


<hr>
<a id="method-NWBHDF5IO-with"></a>



<h4>Method <code>with()</code></h4>

<p>Safe wrapper for reading and handling <code>'NWB'</code> file. See class examples.
</p>


<h5>Usage</h5>

<div class="r"><pre>NWBHDF5IO$with(expr, quoted = FALSE, envir = parent.frame())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt><dd><p>R expression to evaluate</p>
</dd>
<dt><code>quoted</code></dt><dd><p>Whether <code>expr</code> is quoted; default is false</p>
</dd>
<dt><code>envir</code></dt><dd><p>environment for <code>expr</code> to evaluate; default is the
parent frame (see <code>parent.frame</code>)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Whatever results generated by <code>expr</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{

container$with({
  data &lt;- container$read()
  # process data
})

}
</pre>
</div>


<hr>
<a id="method-NWBHDF5IO-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NWBHDF5IO$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Running this example requires a .nwb file

library(rnwb)
container &lt;- NWBHDF5IO$new(path = file)
container$with({

  data &lt;- container$read()
  electrode_table &lt;- data$electrodes[convert = TRUE]

})

print(electrode_table)


## End(Not run)

## ------------------------------------------------
## Method `NWBHDF5IO$open`
## ------------------------------------------------

## Not run: 

# low-level method to open NWB file, for safer methods, see
# `container$with()` below

container$open()

data &lt;- container$read()

# process data...

# Make sure the container is closed!
container$close()


## End(Not run)

## ------------------------------------------------
## Method `NWBHDF5IO$with`
## ------------------------------------------------

## Not run: 

container$with({
  data &lt;- container$read()
  # process data
})


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ieegio_surface'>Plot '3D' surface objects</h2><span id='topic+plot.ieegio_surface'></span>

<h3>Description</h3>

<p>Plot '3D' surface objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ieegio_surface'
plot(
  x,
  method = c("auto", "r3js", "rgl_basic", "rgl_full"),
  transform = 1L,
  name = "auto",
  vlim = NULL,
  col = c("black", "white"),
  slice_index = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ieegio_surface_+3A_x">x</code></td>
<td>
<p><code>'ieegio_surface'</code> object, see <code><a href="#topic+read_surface">read_surface</a></code></p>
</td></tr>
<tr><td><code id="plot.ieegio_surface_+3A_method">method</code></td>
<td>
<p>plot method; <code>'basic'</code> for just rendering the surfaces;
<code>'full'</code> for rendering with axes and title</p>
</td></tr>
<tr><td><code id="plot.ieegio_surface_+3A_transform">transform</code></td>
<td>
<p>which transform to use, can be a 4-by-4 matrix; if
the surface contains transform matrix, then this argument can be
an integer index of the transform embedded, or the target
(transformed) space name; print <code>names(x$transforms)</code> for
choices</p>
</td></tr>
<tr><td><code id="plot.ieegio_surface_+3A_name">name</code></td>
<td>
<p>attribute and name used for colors, options can be <code>'color'</code>
if the surface has color matrix; <code>c('annotations', varname)</code> for
rendering colors from annotations with variable <code>varname</code>;
<code>c('measurements', varname)</code> for rendering colors from measurements
with variable <code>varname</code>; <code>'time_series'</code> for
plotting time series slices; or <code>"flat"</code> for flat color;
default is <code>'auto'</code>, which will
plot the first available data. More details see 'Examples'.</p>
</td></tr>
<tr><td><code id="plot.ieegio_surface_+3A_vlim">vlim</code></td>
<td>
<p>when plotting with continuous data (<code>name</code> is measurements
or time-series), the value limit used to generate color palette; default is
<code>NULL</code>: the range of the values. This argument can be length of 1 (
creating symmetric value range) or 2. If set, then values exceeding the
range will be trimmed to the limit</p>
</td></tr>
<tr><td><code id="plot.ieegio_surface_+3A_col">col</code></td>
<td>
<p>color or colors to form the color palette when value data is
continuous; when <code>name="flat"</code>, the last color will be used</p>
</td></tr>
<tr><td><code id="plot.ieegio_surface_+3A_slice_index">slice_index</code></td>
<td>
<p>when plotting the <code>name="time_series"</code> data,
the slice indices to plot; default is to select a maximum of 4 slices</p>
</td></tr>
<tr><td><code id="plot.ieegio_surface_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>



library(ieegio)

# geometry
geom_file &lt;- "gifti/GzipBase64/sujet01_Lwhite.surf.gii"

# measurements
shape_file &lt;- "gifti/GzipBase64/sujet01_Lwhite.shape.gii"

# time series
ts_file &lt;- "gifti/GzipBase64/fmri_sujet01_Lwhite_projection.time.gii"

if(ieegio_sample_data(geom_file, test = TRUE)) {

  geometry &lt;- read_surface(ieegio_sample_data(geom_file))
  measurement &lt;- read_surface(ieegio_sample_data(shape_file))
  time_series &lt;- read_surface(ieegio_sample_data(ts_file))
  ts_demean &lt;- apply(
    time_series$time_series$value,
    MARGIN = 1L,
    FUN = function(x) {
      x - mean(x)
    }
  )
  time_series$time_series$value &lt;- t(ts_demean)

  # merge measurement &amp; time_series into geometry (optional)
  merged &lt;- merge(geometry, measurement, time_series)
  print(merged)

  # ---- plot method/style ------------------------------------
  plot(merged)

  # ---- plot data --------------------------------------------

  ## Measurements or annotations

  # the first column of `measurements`
  plot(merged, name = "measurements")

  # equivalent to
  plot(merged, name = list("measurements", 1L))

  # equivalent to
  measurement_names &lt;- names(merged$measurements$data_table)
  plot(merged, name = list("measurements", measurement_names[[1]]))

  ## Time-series

  # automatically select 4 slices, trim the color palette
  # from -25 to 25
  plot(merged, name = "time_series", vlim = c(-25, 25),
       slice_index = 1L)

  plot(
    merged,
    name = "time_series",
    vlim = c(-25, 25),
    slice_index = 64,
    col = c("#053061", "#2166ac", "#4393c3",
            "#92c5de", "#d1e5f0", "#ffffff",
            "#fddbc7", "#f4a582", "#d6604d",
            "#b2182b", "#67001f")
  )


}



</code></pre>

<hr>
<h2 id='plot.ieegio_volume'>Plot '3D' volume in anatomical slices</h2><span id='topic+plot.ieegio_volume'></span>

<h3>Description</h3>

<p>Plot '3D' volume in anatomical slices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ieegio_volume'
plot(
  x,
  position = c(0, 0, 0),
  center_position = FALSE,
  which = c("coronal", "axial", "sagittal"),
  slice_index = 1L,
  transform = "vox2ras",
  zoom = 1,
  pixel_width = max(zoom/2, 1),
  col = c("black", "white"),
  alpha = NA,
  crosshair_gap = 4,
  crosshair_lty = 2,
  crosshair_col = "#00FF00A0",
  label_col = crosshair_col,
  continuous = TRUE,
  vlim = NULL,
  add = FALSE,
  main = "",
  axes = FALSE,
  background = col[[1]],
  foreground = col[[length(col)]],
  ...,
  .xdata = x$data
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ieegio_volume_+3A_x">x</code></td>
<td>
<p><code>'ieegio_volume'</code> object; see <code><a href="#topic+read_volume">read_volume</a></code></p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_position">position</code></td>
<td>
<p>position in <code>'RAS'</code> (right-anterior-superior) coordinate
system on which cross-hair should focus</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_center_position">center_position</code></td>
<td>
<p>whether to center canvas at <code>position</code>,
default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_which">which</code></td>
<td>
<p>which slice to plot; choices are <code>"coronal"</code>,
<code>"axial"</code>, and <code>"sagittal"</code></p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_slice_index">slice_index</code></td>
<td>
<p>length of 1: if <code>x</code> has fourth dimension
(e.g. 'fMRI'), then which slice index to draw</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_transform">transform</code></td>
<td>
<p>which transform to apply, can be a 4-by-4 matrix,
an integer or name indicating the matrix in <code>x$transforms</code>; this needs
to be the transform matrix from voxel index to 'RAS'
(right-anterior-superior coordinate system), often called <code>'xform'</code>,
<code>'sform'</code>, <code>'qform'</code> in 'NIfTI' terms, or <code>'Norig'</code> in
'FreeSurfer'</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_zoom">zoom</code></td>
<td>
<p>zoom-in level</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_pixel_width">pixel_width</code></td>
<td>
<p>pixel size, ranging from <code>0.05</code> to <code>50</code>;
default is the half of <code>zoom</code> or <code>1</code>, whichever is greater;
the unit of <code>pixel_width</code> divided by <code>zoom</code> is milliliter</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_col">col</code></td>
<td>
<p>color palette for continuous <code>x</code> values</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_alpha">alpha</code></td>
<td>
<p>opacity value if the image is to be displayed with transparency</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_crosshair_gap">crosshair_gap</code></td>
<td>
<p>the cross-hair gap in milliliter</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_crosshair_lty">crosshair_lty</code></td>
<td>
<p>the cross-hair line type</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_crosshair_col">crosshair_col</code></td>
<td>
<p>the cross-hair color; set to <code>NA</code> to hide</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_label_col">label_col</code></td>
<td>
<p>the color of anatomical axis labels (i.e. <code>"R"</code> for
right, <code>"A"</code> for anterior, and <code>"S"</code> for superior); default is
the same as <code>crosshair_col</code></p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_continuous">continuous</code></td>
<td>
<p>reserved</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_vlim">vlim</code></td>
<td>
<p>the range limit of the data; default is computed from range of
<code>x$data</code>; data values exceeding the range will be trimmed</p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_add">add</code></td>
<td>
<p>whether to add the plot to existing underlay;
default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_main">main</code>, <code id="plot.ieegio_volume_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="graphics.html#topic+image">image</a></code></p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_axes">axes</code></td>
<td>
<p>whether to draw axes; default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_background">background</code>, <code id="plot.ieegio_volume_+3A_foreground">foreground</code></td>
<td>
<p>background and foreground colors; default is
the first and last elements of <code>col</code></p>
</td></tr>
<tr><td><code id="plot.ieegio_volume_+3A_.xdata">.xdata</code></td>
<td>
<p>default is <code>x$data</code>, used to speed up the calculation
when multiple different angles are to be plotted</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ieegio)

nifti_file &lt;- "nifti/rnifti_example.nii.gz"
nifti_rgbfile &lt;- "nifti/rnifti_example_rgb.nii.gz"

# Use
#   `ieegio_sample_data(nifti_file)`
# and
#   `ieegio_sample_data(nifti_rgbfile)`
# to download sample data


if(
  ieegio_sample_data(nifti_file, test = TRUE) &amp;&amp;
  ieegio_sample_data(nifti_rgbfile, test = TRUE)
) {

# ---- NIfTI examples ---------------------------------------------

underlay_path &lt;- ieegio_sample_data(nifti_file)
overlay_path &lt;- ieegio_sample_data(nifti_rgbfile)

# basic read
underlay &lt;- read_volume(underlay_path)
overlay &lt;- read_volume(overlay_path)

par(mfrow = c(1, 3), mar = c(0, 0, 3.1, 0))

ras_position &lt;- c(50, -10, 15)

ras_str &lt;- paste(sprintf("%.0f", ras_position), collapse = ",")

for(which in c("coronal", "axial", "sagittal")) {
  plot(x = underlay, position = ras_position, crosshair_gap = 10,
       crosshair_lty = 2, zoom = 3, which = which,
       main = sprintf("%s T1RAS=[%s]", which, ras_str))
  plot(x = overlay, position = ras_position,
       crosshair_gap = 10, label_col = NA,
       add = TRUE, alpha = 0.9, zoom = 5, which = which)
}


}

</code></pre>

<hr>
<h2 id='pynwb_module'>Install <code>'NWB'</code> via <code>'pynwb'</code></h2><span id='topic+pynwb_module'></span><span id='topic+install_pynwb'></span>

<h3>Description</h3>

<p>Install <code>'NWB'</code> via <code>'pynwb'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_pynwb(python_ver = "auto", verbose = TRUE)

pynwb_module(force = FALSE, error_if_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pynwb_module_+3A_python_ver">python_ver</code></td>
<td>
<p>'Python' version, see <code><a href="rpymat.html#topic+configure_conda">configure_conda</a></code>;
default is <code>"auto"</code>, which is suggested</p>
</td></tr>
<tr><td><code id="pynwb_module_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the installation messages</p>
</td></tr>
<tr><td><code id="pynwb_module_+3A_force">force</code></td>
<td>
<p>whether to force-reload the module</p>
</td></tr>
<tr><td><code id="pynwb_module_+3A_error_if_missing">error_if_missing</code></td>
<td>
<p>whether to raise errors when the module fails to
load; default is true</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'Python' module <code>pynwb</code>.
</p>

<hr>
<h2 id='read_bci2000'>Read 'BCI2000' data file</h2><span id='topic+read_bci2000'></span>

<h3>Description</h3>

<p>Read 'BCI2000' data file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bci2000(
  file,
  extract_path = getOption("ieegio.extract_path", NULL),
  header_only = FALSE,
  cache_ok = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_bci2000_+3A_file">file</code></td>
<td>
<p>file path to the data file</p>
</td></tr>
<tr><td><code id="read_bci2000_+3A_extract_path">extract_path</code></td>
<td>
<p>location to where the extracted information is to be
stored</p>
</td></tr>
<tr><td><code id="read_bci2000_+3A_header_only">header_only</code></td>
<td>
<p>whether to only load header data</p>
</td></tr>
<tr><td><code id="read_bci2000_+3A_cache_ok">cache_ok</code></td>
<td>
<p>whether existing cache should be reused; default is
<code>TRUE</code>. This input can speed up reading large data files; set to
<code>FALSE</code> to delete cache before importing.</p>
</td></tr>
<tr><td><code id="read_bci2000_+3A_verbose">verbose</code></td>
<td>
<p>whether to print processing messages; default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cached object that is readily to be loaded to memory; see
<code><a href="#topic+SignalDataCache">SignalDataCache</a></code> for class definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if( ieegio_sample_data("bci2k.dat", test = TRUE) ) {
  file &lt;- ieegio_sample_data("bci2k.dat")

  x &lt;- read_bci2000(file)
  print(x)

  channel &lt;- x$get_channel(1)

  plot(
    channel$time,
    channel$value,
    type = "l",
    main = channel$info$Label,
    xlab = "Time",
    ylab = channel$info$Unit
  )
}


</code></pre>

<hr>
<h2 id='read_brainvis'>Read 'BrainVision' data</h2><span id='topic+read_brainvis'></span>

<h3>Description</h3>

<p>Read 'BrainVision' data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_brainvis(
  file,
  extract_path = getOption("ieegio.extract_path", NULL),
  header_only = FALSE,
  cache_ok = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_brainvis_+3A_file">file</code></td>
<td>
<p>file path to the data file</p>
</td></tr>
<tr><td><code id="read_brainvis_+3A_extract_path">extract_path</code></td>
<td>
<p>location to where the extracted information is to be
stored</p>
</td></tr>
<tr><td><code id="read_brainvis_+3A_header_only">header_only</code></td>
<td>
<p>whether to only load header data</p>
</td></tr>
<tr><td><code id="read_brainvis_+3A_cache_ok">cache_ok</code></td>
<td>
<p>whether existing cache should be reused; default is
<code>TRUE</code>. This input can speed up reading large data files; set to
<code>FALSE</code> to delete cache before importing.</p>
</td></tr>
<tr><td><code id="read_brainvis_+3A_verbose">verbose</code></td>
<td>
<p>whether to print processing messages; default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cached object that is readily to be loaded to memory; see
<code><a href="#topic+SignalDataCache">SignalDataCache</a></code> for class definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if( ieegio_sample_data("brainvis.dat", test = TRUE) ) {
  # ensure the header and marker files are downloaded as well
  ieegio_sample_data("brainvis.vhdr")
  ieegio_sample_data("brainvis.dat")
  file &lt;- ieegio_sample_data("brainvis.vmrk")

  x &lt;- read_brainvis(file)
  print(x)

  x$get_header()

  x$get_channel_table()

  x$get_annotations()

  channel &lt;- x$get_channel(10)

  plot(
    channel$time,
    channel$value,
    type = "l",
    main = channel$info$Label,
    xlab = "Time",
    ylab = channel$info$Unit
  )
}

</code></pre>

<hr>
<h2 id='read_edf'>Read 'EDF' or 'BDF' data file</h2><span id='topic+read_edf'></span>

<h3>Description</h3>

<p>Read 'EDF' or 'BDF' data file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_edf(
  con,
  extract_path = getOption("ieegio.extract_path", NULL),
  header_only = FALSE,
  cache_ok = TRUE,
  begin = 0,
  end = Inf,
  convert = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_edf_+3A_con">con</code></td>
<td>
<p>file or connection to the data file</p>
</td></tr>
<tr><td><code id="read_edf_+3A_extract_path">extract_path</code></td>
<td>
<p>location to where the extracted information is to be
stored</p>
</td></tr>
<tr><td><code id="read_edf_+3A_header_only">header_only</code></td>
<td>
<p>whether to only load header data</p>
</td></tr>
<tr><td><code id="read_edf_+3A_cache_ok">cache_ok</code></td>
<td>
<p>whether existing cache should be reused; default is
<code>TRUE</code>. This input can speed up reading large data files; set to
<code>FALSE</code> to delete cache before importing.</p>
</td></tr>
<tr><td><code id="read_edf_+3A_begin">begin</code>, <code id="read_edf_+3A_end">end</code></td>
<td>
<p>begin and end of the data to read</p>
</td></tr>
<tr><td><code id="read_edf_+3A_convert">convert</code></td>
<td>
<p>whether to convert digital numbers to analog signals; default
is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="read_edf_+3A_verbose">verbose</code></td>
<td>
<p>whether to print processing messages; default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cached object that is readily to be loaded to memory; see
<code><a href="#topic+SignalDataCache">SignalDataCache</a></code> for class definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---- EDF/BDF(+) ---------------------------------------------------------

# Run `ieegio_sample_data("edfPlusD.edf")` to download sample data

# Tun example if the sample data exists
if(ieegio_sample_data("edfPlusD.edf", test = TRUE)) {

  edf_path &lt;- ieegio_sample_data("edfPlusD.edf")

  data &lt;- read_edf(edf_path)

  data$get_header()

  data$get_annotations()

  data$get_channel_table()

  channel &lt;- data$get_channel(1)

  plot(
    channel$time,
    channel$value,
    type = "l",
    main = channel$info$Label,
    xlab = "Time",
    ylab = channel$info$Unit
  )

}


</code></pre>

<hr>
<h2 id='read_nsx'>Read ('BlackRock') 'NEV' 'NSx' data</h2><span id='topic+read_nsx'></span>

<h3>Description</h3>

<p>Read ('BlackRock') 'NEV' 'NSx' data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_nsx(
  file,
  extract_path = getOption("ieegio.extract_path", NULL),
  header_only = FALSE,
  cache_ok = TRUE,
  include_waveform = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_nsx_+3A_file">file</code></td>
<td>
<p>file path to the data file</p>
</td></tr>
<tr><td><code id="read_nsx_+3A_extract_path">extract_path</code></td>
<td>
<p>location to where the extracted information is to be
stored</p>
</td></tr>
<tr><td><code id="read_nsx_+3A_header_only">header_only</code></td>
<td>
<p>whether to only load header data</p>
</td></tr>
<tr><td><code id="read_nsx_+3A_cache_ok">cache_ok</code></td>
<td>
<p>whether existing cache should be reused; default is
<code>TRUE</code>. This input can speed up reading large data files; set to
<code>FALSE</code> to delete cache before importing.</p>
</td></tr>
<tr><td><code id="read_nsx_+3A_include_waveform">include_waveform</code></td>
<td>
<p>whether to include 'waveform' data (usually for
online spike sorting); default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="read_nsx_+3A_verbose">verbose</code></td>
<td>
<p>whether to print processing messages; default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cached object that is readily to be loaded to memory; see
<code><a href="#topic+SignalDataCache">SignalDataCache</a></code> for class definition.
</p>

<hr>
<h2 id='read_nwb'>Read 'NWB' format</h2><span id='topic+read_nwb'></span>

<h3>Description</h3>

<p>Life cycle: experimental.
Read &quot;Neurodata Without Borders&quot; ('NWB' format) file. Unlike other readers
<code>read_nwb</code> returns low-level 'Python' class handler via <code>pynwb</code>
module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_nwb(file, mode = c("r", "w", "r+", "a", "w-", "x"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_nwb_+3A_file">file</code></td>
<td>
<p>path to 'NWB' file</p>
</td></tr>
<tr><td><code id="read_nwb_+3A_mode">mode</code></td>
<td>
<p>file open mode; default is <code>'r'</code> (read-only)</p>
</td></tr>
<tr><td><code id="read_nwb_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+NWBHDF5IO">NWBHDF5IO</a></code> initialize function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+NWBHDF5IO">NWBHDF5IO</a></code> instance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if(ieegio_sample_data("nwb_sample.nwb", test = TRUE)) {
  file &lt;- ieegio_sample_data("nwb_sample.nwb")

  # Create NWBIO container
  container &lt;- read_nwb(file)

  # Open connection
  container$open()

  # read meta data
  data &lt;- container$read()
  data

  # get `test_timeseries` data
  ts_data &lt;- data$get_acquisition("test_timeseries")
  ts_data

  # read timeseries data into memory
  ts_arr &lt;- ts_data$data[]
  ts_arr

  # Convert Python array to R
  # using `rpymat::py_to_r(ts_arr)` or
  as.numeric(ts_arr)

  # Make sure you close the connection
  container$close()

}


# Requires setting up Python environment
# run `ieegio::install_pynwb()` to set up environment first

## Not run: 


# Replicating tutorial
# https://pynwb.readthedocs.io/en/stable/tutorials/general/plot_file.html

library(rpymat)

# Load Python module
pynwb &lt;- import("pynwb")
uuid &lt;- import("uuid")
datetime &lt;- import("datetime")
np &lt;- import("numpy")
tz &lt;- import("dateutil.tz")



# 2018L is 2018 as integer
session_start_time &lt;- datetime$datetime(
  2018L, 4L, 25L, 2L, 30L, 3L,
  tzinfo=tz$gettz("US/Pacific"))

#  ---- Create NWB file object ------------------------
nwbfile &lt;- pynwb$NWBFile(
  session_description="Mouse exploring a closed field",
  identifier=py_str(uuid$uuid4()),
  session_start_time=session_start_time,
  session_id="session_4321",
  experimenter=py_list(c("Baggins, Frodo")),
  lab="Bag End Laboratory",
  institution="University of Middle Earth at the Shire",
  experiment_description="Thank you Bilbo Baggins.",
  keywords=py_list(c("behavior", "exploration"))
)

# ---- Add subject ------------------------------------
subject &lt;- pynwb$file$Subject(
  subject_id="001",
  age="P90D",
  description="mouse 5",
  species="Mus musculus",
  sex="M"
)

nwbfile$subject &lt;- subject

nwbfile

# ---- Add TimeSeries ------------------------------------
data &lt;- seq(100, 190, by = 10)
time_series_with_rate &lt;- pynwb$TimeSeries(
  name="test_timeseries",
  description="an example time series",
  data=data,
  unit="m",
  starting_time=0.0,
  rate=1.0
)
time_series_with_rate

nwbfile$add_acquisition(time_series_with_rate)

# ---- New Spatial positions ------------------------------------
position_data &lt;- cbind(
  seq(0, 10, length.out = 50),
  seq(0, 9, length.out = 50)
)
position_timestamps = seq(0, 49) / 200

spatial_series_obj = pynwb$behavior$SpatialSeries(
  name="SpatialSeries",
  description="(x,y) position in open field",
  data=position_data,
  timestamps=position_timestamps,
  reference_frame="(0,0) is bottom left corner",
)
spatial_series_obj

position_obj = pynwb$behavior$Position(
  spatial_series=spatial_series_obj)
position_obj

# ---- Behavior Processing Module ------------------------------
behavior_module &lt;- nwbfile$create_processing_module(
  name="behavior", description="processed behavioral data"
)
behavior_module$add(position_obj)

nwbfile$processing$behavior

# omit some process

# ---- Write ---------------------------------------------------
f &lt;- normalizePath(tempfile(fileext = ".nwb"),
                   winslash = "/",
                   mustWork = FALSE)
io &lt;- pynwb$NWBHDF5IO(f, mode = "w")
io$write(nwbfile)
io$close()




## End(Not run)


</code></pre>

<hr>
<h2 id='resample_volume'>Down-sample or super-sample volume</h2><span id='topic+resample_volume'></span>

<h3>Description</h3>

<p>Using nearest-neighbor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_volume(x, new_dim, na_fill = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_volume_+3A_x">x</code></td>
<td>
<p>image volume</p>
</td></tr>
<tr><td><code id="resample_volume_+3A_new_dim">new_dim</code></td>
<td>
<p>new dimension</p>
</td></tr>
<tr><td><code id="resample_volume_+3A_na_fill">na_fill</code></td>
<td>
<p>value to fill if missing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new volume with desired shape
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---- Toy example ----------------------------

dm &lt;- c(6, 6, 6)
arr &lt;- array(seq_len(prod(dm)) + 0.5, dm)
orig &lt;- as_ieegio_volume(
  arr, vox2ras = cbind(diag(1, nrow = 4, ncol = 3), c(-dm / 2, 1)))

# resample
downsampled &lt;- resample_volume(orig, new_dim = c(3, 3, 3))
dim(downsampled)

# up-sample on coronal
upsampled &lt;- resample_volume(orig, new_dim = c(20, 20, 24))
dim(upsampled)

par(mfrow = c(2, 2), mar = c(0, 0, 2.1, 0.1))
plot(orig, pixel_width = 0.5, zoom = 20, main = "Original")
plot(downsampled, pixel_width = 0.5, zoom = 20, main = "Down-sampled")
plot(upsampled, pixel_width = 0.5, zoom = 20, main = "Super-sampled")
plot(
  orig,
  main = "Overlay super-sample (diff)",
  col = c("black", "white"),
  pixel_width = 0.5, zoom = 20
)
plot(
  upsampled,
  add = TRUE,
  col = c("white", "black"),
  pixel_width = 0.5, zoom = 20,
  alpha = 0.5
)

# ---- Real example ---------------------------
nifti_file &lt;- "brain.demosubject.nii.gz"

if( ieegio_sample_data(nifti_file, test = TRUE) ) {

  orig &lt;- read_volume(ieegio_sample_data(nifti_file))
  dim(orig)

  # resample
  downsampled &lt;- resample_volume(orig, new_dim = c(30, 30, 30))
  dim(downsampled)

  # up-sample on coronal
  upsampled &lt;- resample_volume(orig, new_dim = c(300, 300, 64))
  dim(upsampled)

  par(mfrow = c(2, 2), mar = c(0, 0, 2.1, 0.1))
  plot(orig, main = "Original")
  plot(downsampled, main = "Down-sampled")
  plot(upsampled, main = "Super-sampled")
  plot(
    orig,
    main = "Overlay super-sample",
    col = c("black", "white"),
    zoom = 2,
    vlim = c(0, 255)
  )
  plot(
    upsampled,
    add = TRUE,
    col = c("white", "black"),
    zoom = 2,
    alpha = 0.5,
    vlim = c(0, 255)
  )


}

</code></pre>

<hr>
<h2 id='SignalDataCache'>Class definition for signal cache</h2><span id='topic+SignalDataCache'></span>

<h3>Description</h3>

<p>This class is an internal abstract class
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FileCache-get_header"><code>SignalDataCache$get_header()</code></a>
</p>
</li>
<li> <p><a href="#method-FileCache-get_annotations"><code>SignalDataCache$get_annotations()</code></a>
</p>
</li>
<li> <p><a href="#method-FileCache-get_channel_table"><code>SignalDataCache$get_channel_table()</code></a>
</p>
</li>
<li> <p><a href="#method-FileCache-get_channel"><code>SignalDataCache$get_channel()</code></a>
</p>
</li>
<li> <p><a href="#method-FileCache-delete"><code>SignalDataCache$delete()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FileCache-get_header"></a>



<h4>Method <code>get_header()</code></h4>

<p>Get header information, often small list object
</p>


<h5>Usage</h5>

<div class="r"><pre>SignalDataCache$get_header(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>passed to child methods</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FileCache-get_annotations"></a>



<h4>Method <code>get_annotations()</code></h4>

<p>Get annotation information, often a large table
</p>


<h5>Usage</h5>

<div class="r"><pre>SignalDataCache$get_annotations(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>passed to child methods</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FileCache-get_channel_table"></a>



<h4>Method <code>get_channel_table()</code></h4>

<p>Get channel table
</p>


<h5>Usage</h5>

<div class="r"><pre>SignalDataCache$get_channel_table(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>passed to child methods</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FileCache-get_channel"></a>



<h4>Method <code>get_channel()</code></h4>

<p>Get channel data
</p>


<h5>Usage</h5>

<div class="r"><pre>SignalDataCache$get_channel(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>channel order or label</p>
</dd>
<dt><code>...</code></dt><dd><p>passed to child methods</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Channel signal with time-stamps inheriting class
<code>'ieegio_get_channel'</code>
</p>


<hr>
<a id="method-FileCache-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Delete file cache
</p>


<h5>Usage</h5>

<div class="r"><pre>SignalDataCache$delete(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>passed to child methods</p>
</dd>
</dl>

</div>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
