<!DOCTYPE html><html><head><title>Help for package exreport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {exreport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#expCombine'><p>Combine two experiments with different outputs</p></a></li>
<li><a href='#expConcat'><p>Concatenate rows of matching experiments</p></a></li>
<li><a href='#expCreate'><p>Load data and create an exreport experiment</p></a></li>
<li><a href='#expCreateFromTable'><p>Create an exreport experiment from a tabular representation</p></a></li>
<li><a href='#expExtend'><p>Extend an experiment by adding new parameters</p></a></li>
<li><a href='#expExtract'><p>Extract statistically equivalent methods from a multiple comparison test</p></a></li>
<li><a href='#expGetDuplicated'><p>Create a new experiment with only the duplicated rows</p></a></li>
<li><a href='#expInstantiate'><p>Instatiate the methods in the experiment for each one of the different</p>
parameter configurations.</a></li>
<li><a href='#expReduce'><p>Reduce a parameter by a function for each method, problem and remaining</p>
parameter configuration interaction</a></li>
<li><a href='#expRemoveDuplicated'><p>Remove duplicated rows from an experiment</p></a></li>
<li><a href='#expRename'><p>Change the name of elements that an experiment contains</p></a></li>
<li><a href='#expReorder'><p>Change the order of elements that an experiment contains</p></a></li>
<li><a href='#expSubset'><p>Obtains a subset of an experiment matching the given conditions</p></a></li>
<li><a href='#exreport'><p>Create a new exreport document</p></a></li>
<li><a href='#exreportAdd'><p>Add elements to an existing exreport document</p></a></li>
<li><a href='#exreportRender'><p>Render an exreport document</p></a></li>
<li><a href='#plotCumulativeRank'><p>Area plot for the rank distribution from a multiple test</p></a></li>
<li><a href='#plotExpSummary'><p>Barplot for summarizing an experiment output variable</p></a></li>
<li><a href='#plotRankDistribution'><p>Boxplot for the ranks distribution and control hypotheses from multiple test</p></a></li>
<li><a href='#tabularExpSummary'><p>Summarize the experiment with a table for given outputs</p></a></li>
<li><a href='#tabularTestPairwise'><p>Display pairwise information about a multiple test between the methods</p></a></li>
<li><a href='#tabularTestSummary'><p>Summarize the result of a multiple comparison statistical test in a table</p></a></li>
<li><a href='#testMultipleControl'><p>Multiple Comparison Statistical Test (Friedman + Control Holm PostHoc)</p></a></li>
<li><a href='#testMultiplePairwise'><p>Multiple Comparison Statistical Test (Friedman + Pairwise Shaffer PostHoc)</p></a></li>
<li><a href='#testPaired'><p>Paired Wilcoxon statistical test</p></a></li>
<li><a href='#wekaExperiment'><p>Problem: Comparison between several Machine Learning algorithms from the Weka library</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast, Reliable and Elegant Reproducible Research</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of experimental results and automatic report generation in both interactive HTML and LaTeX. This package ships with a rich interface for data modeling and built in functions for the rapid application of statistical tests and generation of common plots and tables with publish-ready quality.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, grDevices, methods, reshape2, stats, tools, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-01-13 10:14:17 UTC; jcozar</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacinto Arias [aut, cre],
  Javier Cozar [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jacinto Arias &lt;jacinto.arias@uclm.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-02-01 22:01:15</td>
</tr>
</table>
<hr>
<h2 id='expCombine'>Combine two experiments with different outputs</h2><span id='topic+expCombine'></span>

<h3>Description</h3>

<p>This fuctions joints two experiments sharing the same configuration
of methods, problems and parameters but different outputs. The resulting
experiment includes the common rows for both experiments with all the
output columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expCombine(e1, e2, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expCombine_+3A_e1">e1</code></td>
<td>
<p>First experiment to combine.</p>
</td></tr>
<tr><td><code id="expCombine_+3A_e2">e2</code></td>
<td>
<p>An second experiment to combine, must share the same
config as e1.</p>
</td></tr>
<tr><td><code id="expCombine_+3A_name">name</code></td>
<td>
<p>Optional name for the resulting experiment. If not specified
the new experiment will be called &quot;e1_name U e2_name&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An new experiment with common rows and all columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example we turn the wekaExperiment into two different experiments,
# with different outputs to combine them:

df_acc  &lt;- wekaExperiment[,
           c("method", "problem", "fold", "featureSelection", "accuracy")]
df_time &lt;- wekaExperiment[,
           c("method", "problem", "fold", "featureSelection", "trainingTime")]

exp_acc &lt;- expCreate(df_acc, name="acc", parameter="fold")
exp_time &lt;- expCreate(df_time, name="time", parameter="fold")

# With expCombine we can mix the two experiments:
expCombine(exp_acc, exp_time)
</code></pre>

<hr>
<h2 id='expConcat'>Concatenate rows of matching experiments</h2><span id='topic+expConcat'></span>

<h3>Description</h3>

<p>This function concatenates two experiments with the same configuration
of parameter an outputs. At least one common output must be present,
the rest of them will be removed from the resulting experiment.
Different methods and problems can be present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expConcat(e1, e2, name = NULL, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expConcat_+3A_e1">e1</code></td>
<td>
<p>First experiment object to concat.</p>
</td></tr>
<tr><td><code id="expConcat_+3A_e2">e2</code></td>
<td>
<p>Second experiment object to concat. Must have the same configuration
than e1.</p>
</td></tr>
<tr><td><code id="expConcat_+3A_name">name</code></td>
<td>
<p>Optional name, if not provided the new experiment will be called
&quot;e1_name + e2_name&quot;</p>
</td></tr>
<tr><td><code id="expConcat_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for duplicate checking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An experiment object having all the rows of e1 and e2
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example we turn the wekaExperiment into two different experiments,
# with different parameter values to combine them:

df_no  &lt;- wekaExperiment[wekaExperiment$featureSelection=="no",]
df_yes &lt;- wekaExperiment[wekaExperiment$featureSelection=="yes",]

exp_yes &lt;- expCreate(df_yes, name="fss-yes", parameter="fold")
exp_no &lt;- expCreate(df_no, name="fss-no", parameter="fold")

expConcat(exp_yes, exp_no)
</code></pre>

<hr>
<h2 id='expCreate'>Load data and create an exreport experiment</h2><span id='topic+expCreate'></span>

<h3>Description</h3>

<p>This function loads a data.frame, checks its properties and formats an
exreport experiment object. The columns of an experiments must contain at
least two categorical columns to be identified as the method and problem
variables and a thrid numerical column to be identified as an output variable.
Additional columns can be added as parameters or additional outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expCreate(data, methods = "method", problems = "problem",
  parameters = c(), respectOrder = FALSE, name, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expCreate_+3A_data">data</code></td>
<td>
<p>A data.frame object satisfying the experiment format</p>
</td></tr>
<tr><td><code id="expCreate_+3A_methods">methods</code></td>
<td>
<p>The name of the variable which contains the methods, by default
is searches for a column named &quot;method&quot;.</p>
</td></tr>
<tr><td><code id="expCreate_+3A_problems">problems</code></td>
<td>
<p>The name of the variable which contains the problems, by
default is searches for a column named &quot;problem&quot;.</p>
</td></tr>
<tr><td><code id="expCreate_+3A_parameters">parameters</code></td>
<td>
<p>A list of the columns names to be identified as parameters.
By default the remaining categorical columns
are identified as parameters, so this list is useful only to identify numeric
columns.</p>
</td></tr>
<tr><td><code id="expCreate_+3A_respectorder">respectOrder</code></td>
<td>
<p>A logical parameter which indicates if the order of the
elements of the method and problem columns must be respected by appearance or
ordered alphabeticaly. It affects to the look of data representations.</p>
</td></tr>
<tr><td><code id="expCreate_+3A_name">name</code></td>
<td>
<p>A string which will identify the experiment in the report.</p>
</td></tr>
<tr><td><code id="expCreate_+3A_tol">tol</code></td>
<td>
<p>Tolerance factor to identify repeated experiments for duplicated
rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new exreport experiment object.
</p>


<h3>See Also</h3>

<p>expCreateFromTable
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates experiment specifying column names and the numerical variables that
# are parameters

expCreate(wekaExperiment,
methods="method",
problems="problem",
parameters="fold",
name="Test Experiment")
</code></pre>

<hr>
<h2 id='expCreateFromTable'>Create an exreport experiment from a tabular representation</h2><span id='topic+expCreateFromTable'></span>

<h3>Description</h3>

<p>Create an exreport experiment object from a tabular representation.
The input data must be a table having methods as rows and problems as columns.
The values in such table correspond to a particular output.
The resulting experiment can be characterized with static parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expCreateFromTable(data, output, name, parameters = list(),
  respectOrder = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expCreateFromTable_+3A_data">data</code></td>
<td>
<p>Input tabular data satisfying the previous constraints.</p>
</td></tr>
<tr><td><code id="expCreateFromTable_+3A_output">output</code></td>
<td>
<p>String indicating the name of the output that the table values
represent.</p>
</td></tr>
<tr><td><code id="expCreateFromTable_+3A_name">name</code></td>
<td>
<p>A string which will identify the experiment in the report.</p>
</td></tr>
<tr><td><code id="expCreateFromTable_+3A_parameters">parameters</code></td>
<td>
<p>A list of strings containing the names and values for the
static configuration
of the algorithm. The name of each element of the list will correspond with
the name of a parameter
and the element with the value asigned.</p>
</td></tr>
<tr><td><code id="expCreateFromTable_+3A_respectorder">respectOrder</code></td>
<td>
<p>A logical parameter which indicates if the order of the
elements of the method and problem columns must be respected by appearance or
ordered alphabeticaly. It affects to the look of data representations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new exreport experiment object.
</p>


<h3>See Also</h3>

<p>expCreate
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We generate a data frame where the methods are rows and the problems columns
# from the wekaExperiment problem. (This is only an example, normally you
# would prefer to load a proper experiment and process it.)

library(reshape2)
df &lt;- dcast(wekaExperiment[wekaExperiment$featureSelection=="no",],
method ~ problem,
value.var="accuracy",
fun.aggregate = mean)

# We can create it and parametrice accordingly:
expCreateFromTable(df, output="accuracy", name="weka")

# Optionally we can set a fixed value for parameters, and ordered by appearance:
expCreateFromTable(df, output="accuracy", name="weka",
parameters=list(featureSelection = "no"), respectOrder=TRUE)
</code></pre>

<hr>
<h2 id='expExtend'>Extend an experiment by adding new parameters</h2><span id='topic+expExtend'></span>

<h3>Description</h3>

<p>This function extends an existing exreport experiment object by adding new
parameters with fixed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expExtend(e, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expExtend_+3A_e">e</code></td>
<td>
<p>Input experiment</p>
</td></tr>
<tr><td><code id="expExtend_+3A_parameters">parameters</code></td>
<td>
<p>A list of strings containing the values of the new
parameters, the name for each one of them will be given by the name of the
corresponding object in the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified exreport experiment object with additional parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We load the wekaExperiment problem as an experiment and then add a new param
# with a default value.

experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
expExtend(experiment, list(discretization = "no"))
</code></pre>

<hr>
<h2 id='expExtract'>Extract statistically equivalent methods from a multiple comparison test</h2><span id='topic+expExtract'></span>

<h3>Description</h3>

<p>This functions generates a new experiment incluing the methods that obtained
an equivalent performance with statisticall significance in the multiple
comparison test i.e. those whose hypotheses were not rejected
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expExtract(ph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expExtract_+3A_ph">ph</code></td>
<td>
<p>A testMultipleControl test object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an experiment object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we create an experiment from the wekaExperiment problem and prepare
# it to apply the test:
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
experiment &lt;- expReduce(experiment, "fold", mean)
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Then we perform a testMultiplePairwise test procedure
test &lt;- testMultipleControl(experiment, "trainingTime", "min")

expExtract(test)
</code></pre>

<hr>
<h2 id='expGetDuplicated'>Create a new experiment with only the duplicated rows</h2><span id='topic+expGetDuplicated'></span>

<h3>Description</h3>

<p>This function computes the duplicated rows attending to the method, problem
and input parameters (but not the outputs). The resulting experiment will
contain these duplicated rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expGetDuplicated(e, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expGetDuplicated_+3A_e">e</code></td>
<td>
<p>The experiment to check for duplicated rows</p>
</td></tr>
<tr><td><code id="expGetDuplicated_+3A_tol">tol</code></td>
<td>
<p>The tolerance for numeric values to check if two outputs are
numerically equal or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If duplicated rows show different outputs the function will launch a
a warning message indicating how many of them differ in the outputs from the
original row, the extent to what two rows are divergent in their output can be
parametrized.
</p>
<p>This function is useful to determine the consistency of the experiment, as a
measure to sanitice the original data source if needed,
</p>


<h3>Value</h3>

<p>A new experiment containing the duplicated rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We duplicate some of the rows of a given experiment:
e &lt;- expCreate(wekaExperiment, parameters="fold", name="Test Experiment")
redundant &lt;- expCreate(wekaExperiment[wekaExperiment$method=="NaiveBayes",],
                       parameters="fold", name="Test Experiment")
e2 &lt;- expConcat(e,redundant)

# Now we check for duplicates:
expGetDuplicated(e2)
</code></pre>

<hr>
<h2 id='expInstantiate'>Instatiate the methods in the experiment for each one of the different
parameter configurations.</h2><span id='topic+expInstantiate'></span>

<h3>Description</h3>

<p>When performing statistical tests or summarizing an experiment for a given
output variable there can be different parameter configuration for each
interaction of method and problem. Once applied the desired transformations
this function can be used to remove unary parameters from the experiment or to
instantiate the methods for each configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expInstantiate(e, parameters = NULL, removeUnary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expInstantiate_+3A_e">e</code></td>
<td>
<p>The experiment object to be instantiated</p>
</td></tr>
<tr><td><code id="expInstantiate_+3A_parameters">parameters</code></td>
<td>
<p>A vector indicating the parameters to be instantiaded.
If NULL or default all parameters would be considered.</p>
</td></tr>
<tr><td><code id="expInstantiate_+3A_removeunary">removeUnary</code></td>
<td>
<p>Boolean value indicating if the unary parameters will be
used in an instantiation or if the column can be erased.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any method is instantiated the cartesian product of the method and the
selected parameters is performed and included in the resulting experiment as
the methods variable. The name of the corresponding value will indicate the
name of the former method and the value of each parameter instantiated.
</p>


<h3>Value</h3>

<p>an experiment object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an experiment from the wekaExperiment
experiment &lt;- expCreate(wekaExperiment, name="test-exp", parameter="fold")

# We would like to reduce the fold parameter by its mean value. It becomes an
# unary parameter.
experiment &lt;- expReduce(experiment, "fold", mean)

# Now we instantiate the experiment by the featureSelection parameter and
# remove the unary fold parameter
expInstantiate(experiment, removeUnary=TRUE)
</code></pre>

<hr>
<h2 id='expReduce'>Reduce a parameter by a function for each method, problem and remaining
parameter configuration interaction</h2><span id='topic+expReduce'></span>

<h3>Description</h3>

<p>This functions reduces a parameter by aggregating the outputs variables for each
value and for each configuration of method, problem and remaining parameters.
By default it computes the mean of the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expReduce(e, parameters = NULL, FUN = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expReduce_+3A_e">e</code></td>
<td>
<p>An input experiment object.</p>
</td></tr>
<tr><td><code id="expReduce_+3A_parameters">parameters</code></td>
<td>
<p>The parameter or parameters to be reduced, if NULL or
default all parameters are considered.</p>
</td></tr>
<tr><td><code id="expReduce_+3A_fun">FUN</code></td>
<td>
<p>The function used to agregate the ouput values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An experiment object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an experiment from the wekaExperiment
experiment &lt;- expCreate(wekaExperiment, name="test-exp", parameter="fold")

# We would like to reduce the fold parameter by its mean value. This way
expReduce(experiment, "fold", mean)
</code></pre>

<hr>
<h2 id='expRemoveDuplicated'>Remove duplicated rows from an experiment</h2><span id='topic+expRemoveDuplicated'></span>

<h3>Description</h3>

<p>This function removes duplicated rows of a given experiment attending to the
interaction of methods, problems and parameters (but no outputs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expRemoveDuplicated(e, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expRemoveDuplicated_+3A_e">e</code></td>
<td>
<p>The experiment to be analised</p>
</td></tr>
<tr><td><code id="expRemoveDuplicated_+3A_tol">tol</code></td>
<td>
<p>The tolerance for numeric values to check if two outputs are
numerically equal or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The duplicated rows found are compared among themselves to determine if there
is divergence between the outputs, if the rows are not consistent a warning is
raised to note this difference.
</p>


<h3>Value</h3>

<p>an experiment object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We duplicate some of the rows of a given experiment:
e &lt;- expCreate(wekaExperiment, parameters="fold", name="Test Experiment")
redundant &lt;- expCreate(wekaExperiment[wekaExperiment$method=="NaiveBayes",],
                       parameters="fold", name="Test Experiment")
e2 &lt;- expConcat(e,redundant)

# Now we remove those duplicates:
expRemoveDuplicated(e2)
</code></pre>

<hr>
<h2 id='expRename'>Change the name of elements that an experiment contains</h2><span id='topic+expRename'></span>

<h3>Description</h3>

<p>This function change the name of problems, methods or parameter values that
an existing experiment object contains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expRename(e, elements = list(), name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expRename_+3A_e">e</code></td>
<td>
<p>Input experiment</p>
</td></tr>
<tr><td><code id="expRename_+3A_elements">elements</code></td>
<td>
<p>A list of arrays of strings containing the new names. The old
name will be specified as the name of the element in such array, and the name
for the parameter, method or problem will be given by the name of the
corresponding object in the list.
If a name is not present in the set of parameter names or parameter values,
it will be ignored.</p>
</td></tr>
<tr><td><code id="expRename_+3A_name">name</code></td>
<td>
<p>The name of the new experiment. If NULL, the previous name will
be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified exreport experiment object with some changes on the name of
the elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We load the wekaExperiment problem as an experiment and then change the name
# of one value for the parameter discretization and for one method.

experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
expRename(experiment, list(featureSelection = c("no"="false"),
                           method=c("RandomForest"="RndForest")))
</code></pre>

<hr>
<h2 id='expReorder'>Change the order of elements that an experiment contains</h2><span id='topic+expReorder'></span>

<h3>Description</h3>

<p>This function change the order of problems, methods or parameter values that
an existing experiment object contains. The order affects the look of the
data representation (as tables and plots).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expReorder(e, elements, placeRestAtEnd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expReorder_+3A_e">e</code></td>
<td>
<p>Input experiment</p>
</td></tr>
<tr><td><code id="expReorder_+3A_elements">elements</code></td>
<td>
<p>A list of arrays of strings containing the ordered names.
The name for the parameter, method or problem will be given by the name of the
corresponding object in the list.
The names which have not been specified will be placed at the begining or at
the end (depending on the parameter placeRestAtEnd).
If a name is not present in the set of parameter values, it will be ignored.</p>
</td></tr>
<tr><td><code id="expReorder_+3A_placerestatend">placeRestAtEnd</code></td>
<td>
<p>Logical value which indicates if the non specified
value names have to be placed after the specified ones (TRUE) or before (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified exreport experiment object with some changes on the name of
the elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We load the wekaExperiment problem as an experiment and then change the order
# of the values for the parameter featureSelection and for one valoue for the method.

experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
expReorder(experiment, list(featureSelection = c("yes","no"),
                           method=c("OneR")))
</code></pre>

<hr>
<h2 id='expSubset'>Obtains a subset of an experiment matching the given conditions</h2><span id='topic+expSubset'></span>

<h3>Description</h3>

<p>This function receives a named list indicating variables and values to filter
the input experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expSubset(e, columns, invertSelection = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expSubset_+3A_e">e</code></td>
<td>
<p>The experiment to be subsetted</p>
</td></tr>
<tr><td><code id="expSubset_+3A_columns">columns</code></td>
<td>
<p>A named list containing the variables to be filtered and the
valid values.</p>
</td></tr>
<tr><td><code id="expSubset_+3A_invertselection">invertSelection</code></td>
<td>
<p>If the filtering must match the inversion of the
specified conditions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the elements in the list correspond with the variables to be
filtered, indicating either the methos or problem variables as well as
parameters. The values of the list correspond with the valid states for the
filtering.
</p>


<h3>Value</h3>

<p>a filtered experiment object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We create a new experiment from the wekaExperiment problem
e &lt;- expCreate(wekaExperiment, parameters="fold", name="Test Experiment")

# We can filter the experiment to reduce the number of methods.
e &lt;- expSubset(e, list(method = c("J48", "NaiveBayes")))
e

# We can filter the experiment to remove a given problem
e &lt;- expSubset(e, list(problem = "iris"), invertSelection=TRUE)
e

# We can subset the experiment to obtain a specific parameter configuration
e &lt;- expSubset(e, list("featureSelection" = "no"))
e
</code></pre>

<hr>
<h2 id='exreport'>Create a new exreport document</h2><span id='topic+exreport'></span>

<h3>Description</h3>

<p>This function inits a new exreport document to start adding elements for
later rendering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exreport(title)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exreport_+3A_title">title</code></td>
<td>
<p>A string representing a short title for this document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an empty exreport document
</p>


<h3>See Also</h3>

<p>exreportRender, exreportAdd
</p>

<hr>
<h2 id='exreportAdd'>Add elements to an existing exreport document</h2><span id='topic+exreportAdd'></span>

<h3>Description</h3>

<p>This function allows to add one or more reportable objects to an exisiting
exreport document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exreportAdd(rep, elem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exreportAdd_+3A_rep">rep</code></td>
<td>
<p>an exreport object in which the elem will be added</p>
</td></tr>
<tr><td><code id="exreportAdd_+3A_elem">elem</code></td>
<td>
<p>a reportable object or a list of them</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an extended exreport document
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an empty document:
report &lt;- exreport("Test document")

# Create a reportable object (an experiment)
experiment &lt;- expCreate(wekaExperiment, name="test-exp", parameter="fold")

# Add this object to the document
exreportAdd(report, experiment)
</code></pre>

<hr>
<h2 id='exreportRender'>Render an exreport document</h2><span id='topic+exreportRender'></span>

<h3>Description</h3>

<p>This function renders an existing exreport object to a given file and format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exreportRender(rep, destination = NULL, target = "html", safeMode = TRUE,
  visualize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exreportRender_+3A_rep">rep</code></td>
<td>
<p>The exreport object to be rendered</p>
</td></tr>
<tr><td><code id="exreportRender_+3A_destination">destination</code></td>
<td>
<p>Path to the rendered file. If NULL, it uses a temporary directory</p>
</td></tr>
<tr><td><code id="exreportRender_+3A_target">target</code></td>
<td>
<p>The format of the target rendering. HTML and PDF are allowed.</p>
</td></tr>
<tr><td><code id="exreportRender_+3A_safemode">safeMode</code></td>
<td>
<p>Denies or allows (TRUE or FALSE) output files overwriting</p>
</td></tr>
<tr><td><code id="exreportRender_+3A_visualize">visualize</code></td>
<td>
<p>Visualize the generated output or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an experiment object
</p>

<hr>
<h2 id='plotCumulativeRank'>Area plot for the rank distribution from a multiple test</h2><span id='topic+plotCumulativeRank'></span>

<h3>Description</h3>

<p>This function builds an area plot from a testMultiple object displaying the
cumulative value for each method for all the evaluated problems. The value
for the rankings is obtained from the Friedman test independently of the scope
of the test (control or pairwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCumulativeRank(testMultiple, grayscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCumulativeRank_+3A_testmultiple">testMultiple</code></td>
<td>
<p>Statistical test from which the plot is generated. The
rankings are obtained from the Friedman test.</p>
</td></tr>
<tr><td><code id="plotCumulativeRank_+3A_grayscale">grayscale</code></td>
<td>
<p>Configure the plot using a grayscale palette.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an exPlot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we create an experiment from the wekaExperiment problem and prepare
# it to apply the test:
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
experiment &lt;- expReduce(experiment, "fold", mean)
experiment &lt;- expSubset(experiment, list(featureSelection = "no"))
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Then we perform a Friedman test included ina a testMultipleControl
# test procedure
test &lt;- testMultipleControl(experiment, "accuracy")

# Finally we obtain the plot
plotCumulativeRank(test)
cat()
</code></pre>

<hr>
<h2 id='plotExpSummary'>Barplot for summarizing an experiment output variable</h2><span id='topic+plotExpSummary'></span>

<h3>Description</h3>

<p>This function builds a barplot for a given experiment output variable,
summarizing its distribution according to the different methods and problems.
The aspect of the plot can be parametrized in several ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotExpSummary(exp, output, columns = 0, freeScale = FALSE,
  fun = identity, grayscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotExpSummary_+3A_exp">exp</code></td>
<td>
<p>- The experiment object to take the data from</p>
</td></tr>
<tr><td><code id="plotExpSummary_+3A_output">output</code></td>
<td>
<p>- A string identifying the name of the output variable to be
plotted</p>
</td></tr>
<tr><td><code id="plotExpSummary_+3A_columns">columns</code></td>
<td>
<p>- Integer number, 0 for a wide aspect plot and any other value
to include n columns of facets separating the problems.</p>
</td></tr>
<tr><td><code id="plotExpSummary_+3A_freescale">freeScale</code></td>
<td>
<p>- Boolean, if using facets sets the scale of each one
independent or not</p>
</td></tr>
<tr><td><code id="plotExpSummary_+3A_fun">fun</code></td>
<td>
<p>- A function to be applied to the selected output variables before
being plotted.</p>
</td></tr>
<tr><td><code id="plotExpSummary_+3A_grayscale">grayscale</code></td>
<td>
<p>- Defaulted to False. True for a plot in grayscale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please notice that the plot function requires that an unique configuration
of parameters is present in the experiment. So the user must have processed and
instantiated the experiment before.
</p>


<h3>Value</h3>

<p>an exPlot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example plots the distribution of the trainingTime variable in the
# wekaExperiment problem.

# First we create the experiment from the problem.
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")

# Next we must process it to have an unique parameter configuration:
# We select a value for the parameter featureSelection:
experiment &lt;- expSubset(experiment, list(featureSelection = "yes"))
# Then we reduce the fold parameter:
experiment &lt;- expReduce(experiment, "fold", mean)
# Finally we remove unary parameters by instantiation:
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Now we can generate several plots:

# Default plot:
plotExpSummary(experiment, "accuracy")

# We can include faceting in the plot by dividing it into columns:
plotExpSummary(experiment, "accuracy", columns=3)

# If we want to show the independent interaction for the output variable
# in each experiment we can make the scales for example, remark the difference
# in :
plotExpSummary(experiment, "trainingTime", columns=3, freeScale=FALSE)
plotExpSummary(experiment, "trainingTime", columns=3, freeScale=TRUE)
</code></pre>

<hr>
<h2 id='plotRankDistribution'>Boxplot for the ranks distribution and control hypotheses from multiple test</h2><span id='topic+plotRankDistribution'></span>

<h3>Description</h3>

<p>This function generates a boxplot from a testMultiple statistical test
showing the ordered distrubution of rankings for each method computed for
the Friedman test. If the input test features a control multiple comparison
then the rejected hypotheses by the Holm methd are also indicates in the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRankDistribution(testMultiple)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRankDistribution_+3A_testmultiple">testMultiple</code></td>
<td>
<p>The statistical test from which the plot is generated.
The functions accepts either control and pairwise multiple tests.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an experiment object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we create an experiment from the wekaExperiment problem and prepare
# it to apply the test:
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
experiment &lt;- expReduce(experiment, "fold", mean)
experiment &lt;- expSubset(experiment, list(featureSelection = "yes"))
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Then we perform a Friedman test included ina a testMultipleControl
# test procedure
test &lt;- testMultipleControl(experiment, "accuracy")

# Finally we obtain the plot
plotRankDistribution(test)
cat()
</code></pre>

<hr>
<h2 id='tabularExpSummary'>Summarize the experiment with a table for given outputs</h2><span id='topic+tabularExpSummary'></span>

<h3>Description</h3>

<p>This function generates a table for the given outputs of the experiment,
comparing all methods for each one of the problems. In addition the function
can highlight the best results for each problem as well as display a range of
parameters for the posterior renderization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabularExpSummary(exp, outputs, boldfaceColumns = "none", format = "f",
  digits = 4, tableSplit = 1, rowsAsMethod = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabularExpSummary_+3A_exp">exp</code></td>
<td>
<p>The ource experiment to generate the table from</p>
</td></tr>
<tr><td><code id="tabularExpSummary_+3A_outputs">outputs</code></td>
<td>
<p>A given variable or list of them to be the target of the table</p>
</td></tr>
<tr><td><code id="tabularExpSummary_+3A_boldfacecolumns">boldfaceColumns</code></td>
<td>
<p>Indicate (&quot;none&quot;,&quot;max&quot; or &quot;min&quot;) to highlight the
method optimizing the variables for each problem.</p>
</td></tr>
<tr><td><code id="tabularExpSummary_+3A_format">format</code></td>
<td>
<p>Indicates the format of the numeric output using C formatting
styles. Defaults to 'f'</p>
</td></tr>
<tr><td><code id="tabularExpSummary_+3A_digits">digits</code></td>
<td>
<p>The number of decimal digits to include for the numeric output.</p>
</td></tr>
<tr><td><code id="tabularExpSummary_+3A_tablesplit">tableSplit</code></td>
<td>
<p>Indicates the number of parititions of the table that
will be rendered. Usefull when the the table is excessivelly wide.</p>
</td></tr>
<tr><td><code id="tabularExpSummary_+3A_rowsasmethod">rowsAsMethod</code></td>
<td>
<p>Display the methods as the rows of the table, indicate
FALSE for a transpose table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An extabular object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example plots the distribution of the trainingTime variable in the
# wekaExperiment problem.

# First we create the experiment from the problem.
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")

# Next we must process it to have an unique parameter configuration:
# We select a value for the parameter featureSelection:
experiment &lt;- expSubset(experiment, list(featureSelection = "yes"))
# Then we reduce the fold parameter:
experiment &lt;- expReduce(experiment, "fold", mean)
# Finally we remove unary parameters by instantiation:
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Generate the default table:
tabularExpSummary(experiment, "accuracy")
</code></pre>

<hr>
<h2 id='tabularTestPairwise'>Display pairwise information about a multiple test between the methods</h2><span id='topic+tabularTestPairwise'></span>

<h3>Description</h3>

<p>This function obtain a pairwise table comparing the methods among themselves
for the specified metrics. It takes an testMultiplePairwise object as an
input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabularTestPairwise(ph, value = "pvalue", charForNAs = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabularTestPairwise_+3A_ph">ph</code></td>
<td>
<p>The input testMultiplePairwise object</p>
</td></tr>
<tr><td><code id="tabularTestPairwise_+3A_value">value</code></td>
<td>
<p>Indicates the metric to be displayed (&quot;pvalue&quot;, &quot;wtl&quot;)</p>
</td></tr>
<tr><td><code id="tabularTestPairwise_+3A_charfornas">charForNAs</code></td>
<td>
<p>Indicates the character included when there is not
comparison available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An extabular object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we create an experiment from the wekaExperiment problem and prepare
# it to apply the test:
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
experiment &lt;- expReduce(experiment, "fold", mean)
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Then we perform a a testMultiplePairwise test procedure
test &lt;- testMultiplePairwise(experiment, "accuracy", "max")

# Different tables can be obtained by using a range of metrics
tabularTestPairwise(test, "pvalue")

tabularTestPairwise(test, "wtl")
</code></pre>

<hr>
<h2 id='tabularTestSummary'>Summarize the result of a multiple comparison statistical test in a table</h2><span id='topic+tabularTestSummary'></span>

<h3>Description</h3>

<p>This function builds a table from a testMultiple object, either control or
pairwise. The htpotheses are added and compared in the table showing the
methods and a range of different metrics than can be added to the table.
Also the table shows information about rejected hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabularTestSummary(ph, columns = c("pvalue"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabularTestSummary_+3A_ph">ph</code></td>
<td>
<p>The input testMultiple from which the table is generated</p>
</td></tr>
<tr><td><code id="tabularTestSummary_+3A_columns">columns</code></td>
<td>
<p>A vector indicating the metrics that will be shown in the table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an extabular object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we create an experiment from the wekaExperiment problem and prepare
# it to apply the test:
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
experiment &lt;- expReduce(experiment, "fold", mean)
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Then we perform a a testMultiplePairwise test procedure
test &lt;- testMultipleControl(experiment, "accuracy", "min")

# Different tables can be obtained by using a range of metrics
tabularTestSummary(test, c("pvalue"))

tabularTestSummary(test, c("rank", "pvalue", "wtl"))
</code></pre>

<hr>
<h2 id='testMultipleControl'>Multiple Comparison Statistical Test (Friedman + Control Holm PostHoc)</h2><span id='topic+testMultipleControl'></span>

<h3>Description</h3>

<p>This function perfoms a multiple comparison statistical test for the given
experiment. First of all it performs a Friedman Test over all methods. In the
case this test is rejected, meaning that significant differences are present
among the methods a post-hoc test is then executed. For that, a comparison
using the best method as a control is performed for each other method,
finally a Holm familywise error correction is applied to the resulting
p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMultipleControl(e, output, rankOrder = "max", alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMultipleControl_+3A_e">e</code></td>
<td>
<p>Input experiment</p>
</td></tr>
<tr><td><code id="testMultipleControl_+3A_output">output</code></td>
<td>
<p>The output for which the tet will be performed.</p>
</td></tr>
<tr><td><code id="testMultipleControl_+3A_rankorder">rankOrder</code></td>
<td>
<p>The optimization strategy, can be either maximizing &quot;max&quot;
or minimizing &quot;min&quot; the target output variable.</p>
</td></tr>
<tr><td><code id="testMultipleControl_+3A_alpha">alpha</code></td>
<td>
<p>The significance level used for the whole testing procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an testMultipleControl object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we create an experiment from the wekaExperiment problem and prepare
# it to apply the test:
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
experiment &lt;- expReduce(experiment, "fold", mean)
experiment &lt;- expSubset(experiment, list(featureSelection = "yes"))
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Then we perform a testMultiplePairwise test procedure
test &lt;- testMultipleControl(experiment, "accuracy", "max")

summary(test)
</code></pre>

<hr>
<h2 id='testMultiplePairwise'>Multiple Comparison Statistical Test (Friedman + Pairwise Shaffer PostHoc)</h2><span id='topic+testMultiplePairwise'></span>

<h3>Description</h3>

<p>This function perfoms a multiple comparison statistical test for the given
experiment. First of all it performs a Friedman Test over all methods. In the
case this test is rejected, meaning that significant differences are present
among the methods a post-hoc test is then executed. For that, each pair of
methods are compared between each other, and finally a Shaffer familywise
error correction is applied to the resulting p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMultiplePairwise(e, output, rankOrder = "max", alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMultiplePairwise_+3A_e">e</code></td>
<td>
<p>Input experiment</p>
</td></tr>
<tr><td><code id="testMultiplePairwise_+3A_output">output</code></td>
<td>
<p>The output for which the tet will be performed.</p>
</td></tr>
<tr><td><code id="testMultiplePairwise_+3A_rankorder">rankOrder</code></td>
<td>
<p>The optimization strategy, can be either maximizing &quot;max&quot;
or minimizing &quot;min&quot; the target output variable.</p>
</td></tr>
<tr><td><code id="testMultiplePairwise_+3A_alpha">alpha</code></td>
<td>
<p>The significance level used for the whole testing procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an testMultiplePairwise object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we create an experiment from the wekaExperiment problem and prepare
# it to apply the test:
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
experiment &lt;- expReduce(experiment, "fold", mean)
experiment &lt;- expSubset(experiment, list(featureSelection = "yes"))
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Then we perform a testMultiplePairwise test procedure
test &lt;- testMultiplePairwise(experiment, "accuracy", "max")

summary(test)
</code></pre>

<hr>
<h2 id='testPaired'>Paired Wilcoxon statistical test</h2><span id='topic+testPaired'></span>

<h3>Description</h3>

<p>This function performs a Wilcoxon paired test to compare the methods of an
experiment consisting exactly on two of them. If more methods are present,
then a multiple comparison test must be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testPaired(e, output, rankOrder = "max", alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testPaired_+3A_e">e</code></td>
<td>
<p>Input experiment</p>
</td></tr>
<tr><td><code id="testPaired_+3A_output">output</code></td>
<td>
<p>The output for which the tet will be performed.</p>
</td></tr>
<tr><td><code id="testPaired_+3A_rankorder">rankOrder</code></td>
<td>
<p>The optimization strategy, can be either maximizing &quot;max&quot;
or minimizing &quot;min&quot; the target output variable.</p>
</td></tr>
<tr><td><code id="testPaired_+3A_alpha">alpha</code></td>
<td>
<p>The significance level used for the whole testing procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a testPaired object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we create an experiment from the wekaExperiment problem and prepare
# it to apply the test, we must subset it to only two methods:
experiment &lt;- expCreate(wekaExperiment, name="test", parameter="fold")
experiment &lt;- expSubset(experiment, list(method = c("J48", "NaiveBayes")))
experiment &lt;- expSubset(experiment, list(featureSelection = c("no")))
experiment &lt;- expReduce(experiment, "fold", mean)
experiment &lt;- expInstantiate(experiment, removeUnary=TRUE)

# Then we perform a Wilcoxon test procedure
test &lt;- testPaired(experiment, "accuracy", "max")

summary(test)
</code></pre>

<hr>
<h2 id='wekaExperiment'>Problem: Comparison between several Machine Learning algorithms from the Weka library</h2><span id='topic+wekaExperiment'></span>

<h3>Description</h3>

<p>A problem containing experimental data obtaining by comparing several instances
of Machine Algorithms from the Weka library. The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wekaExperiment)
</code></pre>


<h3>Format</h3>

<p>A data frame with</p>


<h3>Details</h3>


<ul>
<li><p> method. Classification algorithms used in the experimen (NaiveBayes, J48, IBk)
</p>
</li>
<li><p> problem. Problems used as benchmark in the comparison, up to 12.
</p>
</li>
<li><p> featureSelection. Boolean parameter indicating if the data was preprocessed
</p>
</li>
<li><p> fold. For each configuration a 10-fold cross validation was performed. This variable is a numeric value ranging from 1 to 10.
</p>
</li>
<li><p> accuracy. This is a measure of the performance of each algorithm. Representing the percentage of correctly classified instances.
</p>
</li>
<li><p> trainingTime. A second measure of performance. This one indicates the time in seconds that took the algorithm to build the model.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
