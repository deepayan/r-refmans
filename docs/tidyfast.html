<!DOCTYPE html><html lang="en-US"><head><title>Help for package tidyfast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyfast}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidyfast-package'><p>tidyfast: Fast Tidying of Data</p></a></li>
<li><a href='#dt_case_when'><p>Case When with data.table</p></a></li>
<li><a href='#dt_count'><p>Count</p></a></li>
<li><a href='#dt_fill'><p>Fill with data.table</p></a></li>
<li><a href='#dt_hoist'><p>Hoist: Fast Unnesting of Vectors</p></a></li>
<li><a href='#dt_nest'><p>Fast Nesting</p></a></li>
<li><a href='#dt_pivot_longer'><p>Pivot data from wide to long</p></a></li>
<li><a href='#dt_pivot_wider'><p>Pivot data from long to wide</p></a></li>
<li><a href='#dt_print_options'><p>Set Print Method</p></a></li>
<li><a href='#dt_separate'><p>Separate columns with data.table</p></a></li>
<li><a href='#dt_starts_with'><p>Select helpers</p></a></li>
<li><a href='#dt_uncount'><p>Uncount</p></a></li>
<li><a href='#dt_unnest'><p>Unnest: Fast Unnesting of Data Tables</p></a></li>
<li><a href='#fcase'><p>fcase from data.table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fast Tidying of Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tidying functions built on 'data.table'
    to provide quick and efficient data manipulation with
    minimal overhead.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.13.4), cpp11</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, magrittr, remotes, spelling, testthat (&ge;
3.0.0), tidyr, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.2.6)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-02 08:53:21 UTC; tysonbarrett</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyson Barrett <a href="https://orcid.org/0000-0002-2137-1391"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mark Fairbanks [ctb],
  Ivan Leung [ctb],
  Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Twitter: @patilindrajeets)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyson Barrett &lt;t.barrett88@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 09:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidyfast-package'>tidyfast: Fast Tidying of Data</h2><span id='topic+tidyfast'></span><span id='topic+tidyfast-package'></span>

<h3>Description</h3>

<p>Tidying functions built on 'data.table' to provide quick and efficient data manipulation with minimal overhead.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tyson Barrett <a href="mailto:t.barrett88@gmail.com">t.barrett88@gmail.com</a> (<a href="https://orcid.org/0000-0002-2137-1391">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Mark Fairbanks [contributor]
</p>
</li>
<li><p> Ivan Leung [contributor]
</p>
</li>
<li><p> Indrajeet Patil <a href="mailto:patilindrajeet.science@gmail.com">patilindrajeet.science@gmail.com</a> (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) (@patilindrajeets) [contributor]
</p>
</li></ul>


<hr>
<h2 id='dt_case_when'>Case When with data.table</h2><span id='topic+dt_case_when'></span>

<h3>Description</h3>

<p>Does what <code>dplyr::case_when()</code> does, with the same syntax, but with
<code>data.table::fcase()</code> under the hood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_case_when(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_case_when_+3A_...">...</code></td>
<td>
<p>statements of the form: <code>condition ~ label</code>, where the label is applied if the condition is met</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the same size as the input vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100)
dt_case_when(
  x &lt; median(x) ~ "low",
  x &gt;= median(x) ~ "high",
  is.na(x) ~ "other"
)

library(data.table)
temp &lt;- data.table(
  pseudo_id = c(1, 2, 3, 4, 5),
  x = sample(1:5, 5, replace = TRUE)
)
temp[, y := dt_case_when(
  pseudo_id == 1 ~ x * 1,
  pseudo_id == 2 ~ x * 2,
  pseudo_id == 3 ~ x * 3,
  pseudo_id == 4 ~ x * 4,
  pseudo_id == 5 ~ x * 5
)]
</code></pre>

<hr>
<h2 id='dt_count'>Count</h2><span id='topic+dt_count'></span>

<h3>Description</h3>

<p>Count the numbers of observations within groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_count(dt_, ..., na.rm = FALSE, wt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_count_+3A_dt_">dt_</code></td>
<td>
<p>the data table to uncount</p>
</td></tr>
<tr><td><code id="dt_count_+3A_...">...</code></td>
<td>
<p>groups</p>
</td></tr>
<tr><td><code id="dt_count_+3A_na.rm">na.rm</code></td>
<td>
<p>should any rows with missingness be removed before the count? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dt_count_+3A_wt">wt</code></td>
<td>
<p>the wt assigned to the counts (same number of rows as the data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with counts for each group (or combination of groups)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
dt &lt;- data.table(
  x = rnorm(1e5),
  y = runif(1e5),
  grp = sample(1L:3L, 1e5, replace = TRUE),
  wt = runif(1e5, 1, 100)
)

dt_count(dt, grp)
dt_count(dt, grp, na.rm = TRUE)
dt_count(dt, grp, na.rm = TRUE, wt = wt)
</code></pre>

<hr>
<h2 id='dt_fill'>Fill with data.table</h2><span id='topic+dt_fill'></span>

<h3>Description</h3>

<p>Fills in values, similar to <code>tidyr::fill()</code>, by within <code>data.table</code>. This function relies on the
<code>Rcpp</code> functions that drive <code>tidyr::fill()</code> but applies them within <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_fill(
  dt_,
  ...,
  id = NULL,
  .direction = c("down", "up", "downup", "updown"),
  immutable = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_fill_+3A_dt_">dt_</code></td>
<td>
<p>the data table (or if not a data.table then it is coerced with as.data.table)</p>
</td></tr>
<tr><td><code id="dt_fill_+3A_...">...</code></td>
<td>
<p>the columns to fill</p>
</td></tr>
<tr><td><code id="dt_fill_+3A_id">id</code></td>
<td>
<p>the grouping variable(s) to fill within</p>
</td></tr>
<tr><td><code id="dt_fill_+3A_.direction">.direction</code></td>
<td>
<p>either &quot;down&quot; or &quot;up&quot; (down fills values down, up fills values up), or &quot;downup&quot; (down first then up) or &quot;updown&quot; (up first then down)</p>
</td></tr>
<tr><td><code id="dt_fill_+3A_immutable">immutable</code></td>
<td>
<p>If <code>TRUE</code>, <code>dt_</code> is treated as immutable (it will not be modified in place). Alternatively, you can set <code>immutable = FALSE</code> to modify the input object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with listed columns having values filled in
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(84322)
library(data.table)

x &lt;- 1:10
dt &lt;- data.table(
  v1 = x,
  v2 = shift(x),
  v3 = shift(x, -1L),
  v4 = sample(c(rep(NA, 10), x), 10),
  grp = sample(1:3, 10, replace = TRUE)
)
dt_fill(dt, v2, v3, v4, id = grp, .direction = "downup")
dt_fill(dt, v2, v3, v4, id = grp)
dt_fill(dt, .direction = "up")
</code></pre>

<hr>
<h2 id='dt_hoist'>Hoist: Fast Unnesting of Vectors</h2><span id='topic+dt_hoist'></span><span id='topic+dt_unnest_vec'></span>

<h3>Description</h3>

<p>Quickly unnest vectors nested in list columns. Still experimental (has some potentially unexpected behavior in some situations)!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_hoist(dt_, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_hoist_+3A_dt_">dt_</code></td>
<td>
<p>the data table to unnest</p>
</td></tr>
<tr><td><code id="dt_hoist_+3A_...">...</code></td>
<td>
<p>the columns to unnest (must all be the sample length when unnested); use bare names of the variables</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
dt &lt;- data.table(
  x = rnorm(1e5),
  y = runif(1e5),
  nested1 = lapply(1:10, sample, 10, replace = TRUE),
  nested2 = lapply(c("thing1", "thing2"), sample, 10, replace = TRUE),
  id = 1:1e5
)

dt_hoist(dt, nested1, nested2)
</code></pre>

<hr>
<h2 id='dt_nest'>Fast Nesting</h2><span id='topic+dt_nest'></span>

<h3>Description</h3>

<p>Quickly nest data tables (similar to <code>dplyr::group_nest()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_nest(dt_, ..., .key = "data")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_nest_+3A_dt_">dt_</code></td>
<td>
<p>the data table to nest</p>
</td></tr>
<tr><td><code id="dt_nest_+3A_...">...</code></td>
<td>
<p>the variables to group by</p>
</td></tr>
<tr><td><code id="dt_nest_+3A_.key">.key</code></td>
<td>
<p>the name of the list column; default is &quot;data&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with a list column containing data.tables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
dt &lt;- data.table(
  x = rnorm(1e5),
  y = runif(1e5),
  grp = sample(1L:3L, 1e5, replace = TRUE)
)

dt_nest(dt, grp)
</code></pre>

<hr>
<h2 id='dt_pivot_longer'>Pivot data from wide to long</h2><span id='topic+dt_pivot_longer'></span>

<h3>Description</h3>

<p><code>dt_pivot_wider()</code> &quot;widens&quot; data, increasing the number of columns and
decreasing the number of rows. The inverse transformation is
<code>dt_pivot_longer()</code>. Syntax based on the <code>tidyr</code> equivalents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_pivot_longer(
  dt_,
  cols = NULL,
  names_to = "name",
  values_to = "value",
  values_drop_na = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_pivot_longer_+3A_dt_">dt_</code></td>
<td>
<p>The data table to pivot longer</p>
</td></tr>
<tr><td><code id="dt_pivot_longer_+3A_cols">cols</code></td>
<td>
<p>Column selection. If empty, uses all columns. Can use -colname to unselect column(s)</p>
</td></tr>
<tr><td><code id="dt_pivot_longer_+3A_names_to">names_to</code></td>
<td>
<p>Name of the new &quot;names&quot; column. Must be a string.</p>
</td></tr>
<tr><td><code id="dt_pivot_longer_+3A_values_to">values_to</code></td>
<td>
<p>Name of the new &quot;values&quot; column. Must be a string.</p>
</td></tr>
<tr><td><code id="dt_pivot_longer_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If TRUE, rows will be dropped that contain NAs.</p>
</td></tr>
<tr><td><code id="dt_pivot_longer_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'melt.data.table()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reshaped data.table into longer format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
example_dt &lt;- data.table(x = c(1, 2, 3), y = c(4, 5, 6), z = c("a", "b", "c"))

dt_pivot_longer(example_dt,
  cols = c(x, y),
  names_to = "stuff",
  values_to = "things"
)

dt_pivot_longer(example_dt,
  cols = -z,
  names_to = "stuff",
  values_to = "things"
)
</code></pre>

<hr>
<h2 id='dt_pivot_wider'>Pivot data from long to wide</h2><span id='topic+dt_pivot_wider'></span>

<h3>Description</h3>

<p><code>dt_pivot_wider()</code> &quot;widens&quot; data, increasing the number of columns and
decreasing the number of rows. The inverse transformation is
<code>dt_pivot_longer()</code>. Syntax based on the <code>tidyr</code> equivalents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_pivot_wider(dt_, id_cols = NULL, names_from, names_sep = "_", values_from)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_pivot_wider_+3A_dt_">dt_</code></td>
<td>
<p>the data table to widen</p>
</td></tr>
<tr><td><code id="dt_pivot_wider_+3A_id_cols">id_cols</code></td>
<td>
<p>A set of columns that uniquely identifies each observation. Defaults to all columns in the data table except for the columns specified in <code>names_from</code> and <code>values_from</code>. Typically used when you have additional variables that is directly related.</p>
</td></tr>
<tr><td><code id="dt_pivot_wider_+3A_names_from">names_from</code></td>
<td>
<p>A pair of arguments describing which column (or columns) to get the name of the output column (<code>name_from</code>), and which column (or columns) to get the cell values from (<code>values_from</code>).</p>
</td></tr>
<tr><td><code id="dt_pivot_wider_+3A_names_sep">names_sep</code></td>
<td>
<p>the separator between the names of the columns</p>
</td></tr>
<tr><td><code id="dt_pivot_wider_+3A_values_from">values_from</code></td>
<td>
<p>A pair of arguments describing which column (or columns) to get the name of the output column (<code>name_from</code>), and which column (or columns) to get the cell values from (<code>values_from</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reshaped data.table into wider format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
example_dt &lt;- data.table(
  z = rep(c("a", "b", "c"), 2),
  stuff = c(rep("x", 3), rep("y", 3)),
  things = 1:6
)

dt_pivot_wider(example_dt, names_from = stuff, values_from = things)
dt_pivot_wider(example_dt, names_from = stuff, values_from = things, id_cols = z)
</code></pre>

<hr>
<h2 id='dt_print_options'>Set Print Method</h2><span id='topic+dt_print_options'></span>

<h3>Description</h3>

<p>The function allows the user to define options relating to the print method for <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_print_options(
  class = TRUE,
  topn = 5,
  rownames = TRUE,
  nrows = 100,
  trunc.cols = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_print_options_+3A_class">class</code></td>
<td>
<p>should the variable class be printed? (<code>options("datatable.print.class")</code>)</p>
</td></tr>
<tr><td><code id="dt_print_options_+3A_topn">topn</code></td>
<td>
<p>the number of rows to print (both head and tail) if <code>nrows(DT) &gt; nrows</code>. (<code>options("datatable.print.topn")</code>)</p>
</td></tr>
<tr><td><code id="dt_print_options_+3A_rownames">rownames</code></td>
<td>
<p>should rownames be printed? (<code>options("datatable.print.rownames")</code>)</p>
</td></tr>
<tr><td><code id="dt_print_options_+3A_nrows">nrows</code></td>
<td>
<p>total number of rows to print (<code>options("datatable.print.nrows")</code>)</p>
</td></tr>
<tr><td><code id="dt_print_options_+3A_trunc.cols">trunc.cols</code></td>
<td>
<p>if <code>TRUE</code>, only the columns that fit in the console are printed (with a message stating the variables not shown, similar to <code>tibbles</code>; <code>options("datatable.print.trunc.cols")</code>). This only works on <code>data.table</code> versions higher than <code>1.12.6</code> (i.e. not currently available but anticipating the eventual release).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. This function is used for its side effect of changing options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dt_print_options(
  class = TRUE,
  topn = 5,
  rownames = TRUE,
  nrows = 100,
  trunc.cols = TRUE
)
</code></pre>

<hr>
<h2 id='dt_separate'>Separate columns with data.table</h2><span id='topic+dt_separate'></span>

<h3>Description</h3>

<p>Separates a column of data into others, by splitting based a separator or regular expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_separate(
  dt_,
  col,
  into,
  sep = ".",
  remove = TRUE,
  fill = NA,
  fixed = TRUE,
  immutable = TRUE,
  dev = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_separate_+3A_dt_">dt_</code></td>
<td>
<p>the data table (or if not a data.table then it is coerced with as.data.table)</p>
</td></tr>
<tr><td><code id="dt_separate_+3A_col">col</code></td>
<td>
<p>the column to separate</p>
</td></tr>
<tr><td><code id="dt_separate_+3A_into">into</code></td>
<td>
<p>the names of the new columns created from splitting <code>col</code>.</p>
</td></tr>
<tr><td><code id="dt_separate_+3A_sep">sep</code></td>
<td>
<p>the regular expression stating how <code>col</code> should be separated. Default is <code>.</code>.</p>
</td></tr>
<tr><td><code id="dt_separate_+3A_remove">remove</code></td>
<td>
<p>should <code>col</code> be removed in the returned data table? Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="dt_separate_+3A_fill">fill</code></td>
<td>
<p>if empty, fill is inserted. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="dt_separate_+3A_fixed">fixed</code></td>
<td>
<p>logical. If TRUE match split exactly, otherwise use regular expressions. Has priority over perl.</p>
</td></tr>
<tr><td><code id="dt_separate_+3A_immutable">immutable</code></td>
<td>
<p>If <code>TRUE</code>, <code>.dt</code> is treated as immutable (it will not be modified in place). Alternatively, you can set <code>immutable = FALSE</code> to modify the input object.</p>
</td></tr>
<tr><td><code id="dt_separate_+3A_dev">dev</code></td>
<td>
<p>If <code>TRUE</code>, the function can be used within other functions. It bypasses the usual non-standard evaluation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dt_separate_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>data.table::tstrplit()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with a column split into multiple columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
d &lt;- data.table(
  x = c("A.B", "A", "B", "B.A"),
  y = 1:4
)

# defaults
dt_separate(d, x, c("c1", "c2"))

# can keep the original column with `remove = FALSE`
dt_separate(d, x, c("c1", "c2"), remove = FALSE)

# need to assign when `immutable = TRUE`
separated &lt;- dt_separate(d, x, c("c1", "c2"), immutable = TRUE)
separated

# don't need to assign when `immutable = FALSE` (default)
dt_separate(d, x, c("c1", "c2"), immutable = FALSE)
d
</code></pre>

<hr>
<h2 id='dt_starts_with'>Select helpers</h2><span id='topic+dt_starts_with'></span><span id='topic+dt_contains'></span><span id='topic+dt_ends_with'></span><span id='topic+dt_everything'></span>

<h3>Description</h3>

<p>These functions allow you to select variables based on their names.
</p>

<ul>
<li> <p><code>dt_starts_with()</code>: Starts with a prefix
</p>
</li>
<li> <p><code>dt_starts_with()</code>: Ends with a suffix
</p>
</li>
<li> <p><code>dt_contains()</code>: Contains a literal string
</p>
</li>
<li> <p><code>dt_everything()</code>: Matches all variables
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dt_starts_with(match)

dt_contains(match)

dt_ends_with(match)

dt_everything()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_starts_with_+3A_match">match</code></td>
<td>
<p>a character string to match to variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. To be used within the <code style="white-space: pre;">&#8288;dt_pivot_*&#8288;</code> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)

# example of using it with `dt_pivot_longer()`
df &lt;- data.table(row = 1, var = c("x", "y"), a = 1:2, b = 3:4)
pv &lt;- dt_pivot_wider(df,
  names_from = var,
  values_from = c(dt_starts_with("a"), dt_ends_with("b"))
)
</code></pre>

<hr>
<h2 id='dt_uncount'>Uncount</h2><span id='topic+dt_uncount'></span>

<h3>Description</h3>

<p>Uncount a counted data table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_uncount(dt_, weights, .remove = TRUE, .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_uncount_+3A_dt_">dt_</code></td>
<td>
<p>the data table to uncount</p>
</td></tr>
<tr><td><code id="dt_uncount_+3A_weights">weights</code></td>
<td>
<p>the counts for each</p>
</td></tr>
<tr><td><code id="dt_uncount_+3A_.remove">.remove</code></td>
<td>
<p>should the weights variable be removed?</p>
</td></tr>
<tr><td><code id="dt_uncount_+3A_.id">.id</code></td>
<td>
<p>an optional new id variable, providing a unique id for each row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with a row for each uncounted column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)

dt_count &lt;- data.table(
  x = LETTERS[1:3],
  w = c(2, 1, 4)
)
uncount &lt;- dt_uncount(dt_count, w, .id = "id")
uncount[] # note that `[]` forces the printing
</code></pre>

<hr>
<h2 id='dt_unnest'>Unnest: Fast Unnesting of Data Tables</h2><span id='topic+dt_unnest'></span>

<h3>Description</h3>

<p>Quickly unnest data tables, particularly those nested by <code>dt_nest()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_unnest(dt_, col, keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_unnest_+3A_dt_">dt_</code></td>
<td>
<p>the data table to unnest</p>
</td></tr>
<tr><td><code id="dt_unnest_+3A_col">col</code></td>
<td>
<p>the column to unnest</p>
</td></tr>
<tr><td><code id="dt_unnest_+3A_keep">keep</code></td>
<td>
<p>whether to keep the nested column, default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
dt &lt;- data.table(
  x = rnorm(1e5),
  y = runif(1e5),
  grp = sample(1L:3L, 1e5, replace = TRUE)
)

nested &lt;- dt_nest(dt, grp)
dt_unnest(nested, col = data)
</code></pre>

<hr>
<h2 id='fcase'>fcase from data.table</h2><span id='topic+fcase'></span>

<h3>Description</h3>

<p>See <code>data.table::<a href="data.table.html#topic+fcase">fcase()</a></code> for details.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
