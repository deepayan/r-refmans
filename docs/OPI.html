<!DOCTYPE html><html><head><title>Help for package OPI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OPI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OPI-package'><p>OPI: Open Perimetry Interface</p></a></li>
<li><a href='#.OpiEnv'><p>Environment holding the state of the OPI</p></a></li>
<li><a href='#cdTodb'><p>Convert cd/<code class="reqn">\mbox{m}^2</code> to perimetric dB.</p></a></li>
<li><a href='#chooseOpi'><p>Choose an implementation of the OPI</p></a></li>
<li><a href='#dbTocd'><p>Convert perimetric dB to cd/<code class="reqn">\mbox{m}^2</code></p></a></li>
<li><a href='#degTopix'><p>Convert degrees to pixels for machine 'machine'</p></a></li>
<li><a href='#fourTwo.start'><p>4-2 Staircase</p></a></li>
<li><a href='#FT'><p>Full Threshold</p></a></li>
<li><a href='#MOCS'><p>Method of Constant Stimuli (MOCS)</p></a></li>
<li><a href='#opi.implementations'><p>FOR INTERNAL USE ONLY</p></a></li>
<li><a href='#opiClose'><p>Close using OPI</p></a></li>
<li><a href='#opiGetParams'><p>Get OPI method parameters</p></a></li>
<li><a href='#opiInitialize'><p>Initialize OPI</p></a></li>
<li><a href='#opiKineticStimulus'><p>Stimulus parameter list</p></a></li>
<li><a href='#opiPresent'><p>Use OPI to present stimulus</p></a></li>
<li><a href='#opiQueryDevice'><p>Query device using OPI</p></a></li>
<li><a href='#opiSetBackground'><p>Set background using OPI</p></a></li>
<li><a href='#opiStaticStimulus'><p>Stimulus parameter list</p></a></li>
<li><a href='#opiTemporalStimulus'><p>Stimulus parameter list</p></a></li>
<li><a href='#pixTodeg'><p>Convert pixels to degrees for machine 'machine'</p></a></li>
<li><a href='#QUESTP'><p>QUEST+</p></a></li>
<li><a href='#RtDbUnits'><p>Response times to white-on-white Goldmann Size III targets for 12 subjects</p>
in dB units</a></li>
<li><a href='#RtSigmaUnits'><p>Response times to white-on-white Goldmann Size III targets for 12 subjects</p>
in sigma units</a></li>
<li><a href='#ZEST'><p>ZEST</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Open Perimetry Interface</td>
</tr>
<tr>
<td>Version:</td>
<td>2.11.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Turpin [cre, aut, cph],
  David Lawson [ctb, cph],
  Matthias Muller [ctb],
  Jonathan Dennis [ctb, cph],
  Astrid Zeman [ctb],
  Ivan Marin-Franch [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Turpin &lt;andrew.turpin@lei.org.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Open Perimetry Interface (OPI) for simulating and controlling visual field machines using R. The OPI is a standard for interfacing with visual field testing machines (perimeters) first started as an open source project with support of Haag-Streit in 2010. It specifies basic functions that allow many visual field tests to be constructed. As of February 2022 it is fully implemented on the Haag-Streit Octopus 900 with partial implementations on the Centervue Compass, Kowa AP 7000, Android phones and the CrewT IMO. It also has a cousin: the R package 'visualFields', which has tools for analysing and manipulating visual field data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://people.eng.unimelb.edu.au/aturpin/opi/index.html">https://people.eng.unimelb.edu.au/aturpin/opi/index.html</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, Rfast, abind, grDevices, openssl</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>OPI-package.r opi.r compassClient.r displayClient.r
daydreamClient.r dbTocd.r fourTwo.r full_threshold.r
imoClient.r kowaAP7000Client.r mocs.r octopus600.r
octopus900Client.r pix2deg.r phoneHMD.r QUESTP.r simDisplay.r
simG.r simH.r simH_RT.r simNo.r simYes.r zest.r
data-RtDbUnits.r data-RtSigmaUnits.r opiKineticStimulus.r
opiStaticStimulus.r opiTemporalStimulus.r</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 08:39:53 UTC; aturpin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 09:12:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='OPI-package'>OPI: Open Perimetry Interface</h2><span id='topic+OPI'></span><span id='topic+OPI-package'></span>

<h3>Description</h3>

<p>Implementation of the Open Perimetry Interface (OPI) for simulating and controlling visual field machines using R. The OPI is a standard for interfacing with visual field testing machines (perimeters) first started as an open source project with support of Haag-Streit in 2010. It specifies basic functions that allow many visual field tests to be constructed. As of February 2022 it is fully implemented on the Haag-Streit Octopus 900 with partial implementations on the Centervue Compass, Kowa AP 7000, Android phones and the CrewT IMO. It also has a cousin: the R package 'visualFields', which has tools for analysing and manipulating visual field data.
</p>


<h3>Note</h3>

<p><code>.OpiEnv$machine_name</code> is set to the name of the chosen OPI set by the <code>chooseOPI</code> function call.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andrew Turpin <a href="mailto:andrew.turpin@lei.org.au">andrew.turpin@lei.org.au</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> David Lawson [contributor, copyright holder]
</p>
</li>
<li><p> Matthias Muller [contributor]
</p>
</li>
<li><p> Jonathan Dennis [contributor, copyright holder]
</p>
</li>
<li><p> Astrid Zeman [contributor]
</p>
</li>
<li><p> Ivan Marin-Franch [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://people.eng.unimelb.edu.au/aturpin/opi/index.html">https://people.eng.unimelb.edu.au/aturpin/opi/index.html</a>
</p>
</li></ul>


<hr>
<h2 id='.OpiEnv'>Environment holding the state of the OPI</h2><span id='topic+.OpiEnv'></span>

<h3>Description</h3>

<p>Holds the chosen machine and any parameters forming the state of the machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.OpiEnv
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 13.
</p>

<hr>
<h2 id='cdTodb'>Convert cd/<code class="reqn">\mbox{m}^2</code> to perimetric dB.</h2><span id='topic+cdTodb'></span>

<h3>Description</h3>

<p>Given a value in cd/<code class="reqn">\mbox{m}^2</code>, return the equivalent dB value.
Default is to use HFA units, so maximum stimulus is 10000 apostilbs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdTodb(cd, maxStim = 10000/pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdTodb_+3A_cd">cd</code></td>
<td>
<p>Value to convert to dB in cd/<code class="reqn">\mbox{m}^2</code>. Must be &gt; 0.</p>
</td></tr>
<tr><td><code id="cdTodb_+3A_maxstim">maxStim</code></td>
<td>
<p>Stimulus value for 0dB in cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dB value for <code>cd</code> cd/<code class="reqn">\mbox{m}^2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># candela to decibels
dB &lt;- cdTodb(10000/pi)  # 0 dB
dB &lt;- cdTodb(1000/pi)   # 10 dB
dB &lt;- cdTodb(100/pi)    # 20 dB
dB &lt;- cdTodb(10/pi)     # 30 dB
dB &lt;- cdTodb(1/pi)      # 40 dB
dB &lt;- cdTodb(0.1/pi)    # 50 dB
</code></pre>

<hr>
<h2 id='chooseOpi'>Choose an implementation of the OPI</h2><span id='topic+chooseOpi'></span><span id='topic+chooseOPI'></span>

<h3>Description</h3>

<p>Chooses an implementation of the OPI to use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseOpi(opiImplementation)

chooseOPI(opiImplementation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseOpi_+3A_opiimplementation">opiImplementation</code></td>
<td>
<p>A character string that is one of the following.
</p>

<ul>
<li> <p><code>"SimNo"</code> for a simulator that always doesn't see.
</p>
</li>
<li> <p><code>"SimYes"</code> for a simulator that always does see.
</p>
</li>
<li> <p><code>"SimHenson"</code> for a simulator that uses a cummulative gaussian psychometric function with standard deviation according to Henson et al (2000) where variability increases as true threshold (Humphrey dB) value decreases.
</p>
</li>
<li> <p><code>"SimHensonRT"</code> as for SimHenson, but response times in ms are sampled from a supplied response time data set for each true positive response.
</p>
</li>
<li> <p><code>"SimGaussian"</code> for a simulator that uses a cummulative gaussian psychometric function with standard deviation supplied in opiInitialize().
</p>
</li>
<li> <p><code>"Octopus900"</code> for interfacing with the Octopus 900.
</p>
</li>
<li> <p><code>"Octopus900F310"</code> for interfacing with the Octopus 900 using Logitech F310 controller.
</p>
</li>
<li> <p><code>"Octopus600"</code> for interfacing with the Octopus 600.
</p>
</li>
<li> <p><code>"HEP"</code>        not working so well in HEPs.
</p>
</li>
<li> <p><code>"KowaAP7000"</code> for interfacing with Kowa AP-7000.
</p>
</li>
<li> <p><code>"Imo"</code> for interfacing with CrewT's Imo head mounted perimeter.
</p>
</li>
<li> <p><code>"DayDream"</code> for interfacing with an Android phone in a Google Daydream
</p>
</li>
<li> <p><code>"Display"</code> for interfacing with a shiny plot area on the current machine.
</p>
</li>
<li> <p><code>"PhoneHMD"</code> for interfacing with phones using VR. At the moment, only Android compatible phones are working. The VR headset must be compatible with Cardboard
</p>
</li>
<li> <p><code>NULL</code>         print a list of available OPI implementations.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if successful, FALSE otherwise.
</p>


<h3>References</h3>

<p>David B. Henson, Shaila Chaudry, Paul H. Artes, E. Brian Faragher, and Alec Ansons.
Response Variability in the Visual Field: Comparison of Optic Neuritis, Glaucoma,
Ocular Hypertension, and Normal Eyes. Investigative Ophthalmology &amp; Visual Science,
February 2000, Vol. 41(2).
</p>
<p>A.M. McKendrick, J. Denniss and A. Turpin. &quot;Response times across the visual field:
empirical observations and application to threshold determination&quot;. Vision Research,
101, 2014.
</p>
<p>A. Turpin, P.H. Artes and A.M. McKendrick. &quot;The Open Perimetry Interface: An
enabling tool for clinical visual psychophysics&quot;, Journal of Vision 12(11) 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!chooseOpi("SimHenson"))
  warnings()
</code></pre>

<hr>
<h2 id='dbTocd'>Convert perimetric dB to cd/<code class="reqn">\mbox{m}^2</code></h2><span id='topic+dbTocd'></span>

<h3>Description</h3>

<p>Given a value in dB, return the cd/<code class="reqn">\mbox{m}^2</code>
equivalent. Default is to use HFA units, so maximum stimulus is 10000
apostilbs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbTocd(db, maxStim = 10000/pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbTocd_+3A_db">db</code></td>
<td>
<p>Value to convert to cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
<tr><td><code id="dbTocd_+3A_maxstim">maxStim</code></td>
<td>
<p>Stimulus value for 0dB in cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cd/<code class="reqn">\mbox{m}^2</code> value for <code>db</code> dB.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># decibels to candela
cd &lt;- dbTocd(0)   # 10000/pi
cd &lt;- dbTocd(10)  # 1000/pi
cd &lt;- dbTocd(20)  # 100/pi
cd &lt;- dbTocd(30)  # 10/pi
cd &lt;- dbTocd(40)  # 1/pi
</code></pre>

<hr>
<h2 id='degTopix'>Convert degrees to pixels for machine 'machine'</h2><span id='topic+degTopix'></span>

<h3>Description</h3>

<p>Convert degrees to pixels for machine 'machine'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degTopix(xy, machine = "compass")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degTopix_+3A_xy">xy</code></td>
<td>
<p>a 2 element vector c(x,y) where x and y are in pixels</p>
</td></tr>
<tr><td><code id="degTopix_+3A_machine">machine</code></td>
<td>
<p>&quot;compass&quot; or ...?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xy converted to pixels (top-left is (0,0)) for the machine or
<code>NA</code> if machine is unknown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>degTopix(c(0, 0), machine="compass")  # c(960, 960) pixels
degTopix(c(-15, 2)) # c(495, 898) pixels
</code></pre>

<hr>
<h2 id='fourTwo.start'>4-2 Staircase</h2><span id='topic+fourTwo.start'></span><span id='topic+fourTwo.step'></span><span id='topic+fourTwo.stop'></span><span id='topic+fourTwo.final'></span>

<h3>Description</h3>

<p>fourTwo is a 4-2 dB staircase beginning at level <code>est</code>
terminating after two reversals. The final estimate is the average of the
last two presentations. It also terminates if the <code>minStimulus</code> is
not seen twice, or the <code>maxStimulus</code> is seen twice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourTwo.start(est = 25, instRange = c(0, 40), verbose = FALSE, makeStim, ...)

fourTwo.step(state, nextStim = NULL)

fourTwo.stop(state)

fourTwo.final(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourTwo.start_+3A_est">est</code></td>
<td>
<p>Starting estimate in dB</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_instrange">instRange</code></td>
<td>
<p>Dynamic range of the instrument c(min,max) in dB</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_verbose">verbose</code></td>
<td>
<p>True if you want each presentation printed</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a dB value and numPresentations
and returns an OPI datatype ready for passing to opiPresent</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_state">state</code></td>
<td>
<p>Current state of the fourTwo returned by
<code>fourTwo.start</code> and <code>fourTwo.step</code></p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_nextstim">nextStim</code></td>
<td>
<p>A valid object for <code>opiPresent</code> to
use as its <code>nextStim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of a 4-2 1-up 1-down staircase. The
initial staircase starts at <code>est</code> and proceeds in steps of 4 dB until
the first reversal, and 2dB until the next reversal. The mean of the last
two presentations is taken as the threshold value. Note this function will
repeatedly call <code>opiPresent</code> for a stimulus until <code>opiPresent</code>
returns <code>NULL</code> (ie no error occured). If more than one fourTwo is to
be interleaved (for example, testing multiple locations), then the
<code>fourTwo.start</code>, <code>fourTwo.step</code>, <code>fourTwo.stop</code> and
<code>fourTwo.final</code> calls can maintain the state of the fourTwo after
each presentation, and should be used. See examples below.
</p>


<h3>Value</h3>



<h4>Multilple locations</h4>

<p><code>fourTwo.start</code> returns a list that can be passed to <code>fourTwo.step</code>,
<code>fourTwo.stop</code>, and <code>fourTwo.final</code>. It represents the state of a fourTwo
at a single location at a point in time and contains the following.
* <code>name</code>, <code>fourTwo</code>.
* <code>startingEstimate=est</code>, input param.
* <code>currentLevel</code>, the next stimulus to present.
* <code>minStimulus=instRange[1]</code>, input param.
* <code>maxStimulus=instRange[2]</code>, input param.
* <code>makeStim</code>, input param.
* <code>lastSeen</code>, the last seen stimulus.
* <code>lastResponse</code>, the last response given.
* <code>stairResult</code>, The final result if finished (initially <code>NA</code>).
* <code>finished</code>, <code>"Not"</code> if staircase has not finished, or one of
<code>"Rev"</code> (finished due to 2 reversals),
<code>"Max"</code> (finished due to 2 <code>maxStimulus</code> seen),
<code>"Min"</code> (finished due to 2 <code>minStimulus</code> not seen).
* <code>verbose</code>, number of reversals so far.
* <code>numberOfReversals</code>, number of reversals so far.
* <code>currSeenLimit</code>, number of times <code>maxStimulus</code> has been seen.
* <code>currNotSeenLimit</code>, number of times <code>minStimulus</code> not seen.
* <code>numPresentations</code>, number of presentations so far.
* <code>stimuli</code>, vector of stimuli shown at each call to <code>fourTwo.step</code>.
* <code>responses</code>, vector of responses received (1 seen, 0 not) received at each call to <code>fourTwo.step</code>.
* <code>responseTimes</code>, vector of response times received at each call to <code>fourTwo.step</code>.
* <code>opiParams=list(...)</code>, input param
</p>
<p><code>fourTwo.step</code> returns a list containing
* <code>state</code>, the new state after presenting a stimuli and getting a response.
* <code>resp</code>, the return from the <code>opiPresent</code> call that was made.
</p>
<p><code>fourTwo.stop</code> returns <code>TRUE</code> if the staircase is finished (2 reversals, or <code>maxStimulus</code>
is seen twice or <code>minStimulus</code> is not seen twice).
</p>
<p><code>fourTwo.final</code> returns the final estimate of threshold (mean of last
two reversals). This issues a warning if called before the staircase has
finished, but still returns a value.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>, <code><a href="#topic+FT">FT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}
chooseOpi("SimHenson")
if (!is.null(opiInitialize(type="C", cap=6)))
  stop("opiInitialize failed")

##############################################
# This section is for multiple fourTwos
##############################################
makeStimHelper &lt;- function(db,n, x, y) {  # returns a function of (db,n)
  ff &lt;- function(db, n) db+n
  body(ff) &lt;- substitute({
    s &lt;- list(x=x, y=y, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500)
    class(s) &lt;- "opiStaticStimulus"
    return(s)}, list(x=x,y=y))
  return(ff)
}
# List of (x, y, true threshold) triples
locations &lt;- list(c(9,9,30), c(-9,-9,32), c(9,-9,31), c(-9,9,33))

# Setup starting states for each location
states &lt;- lapply(locations, function(loc) {
  fourTwo.start(makeStim=makeStimHelper(db,n,loc[1],loc[2]),
                tt=loc[3], fpr=0.03, fnr=0.01)})

# Loop through until all states are "stop"
while(!all(st &lt;- unlist(lapply(states, fourTwo.stop)))) {
  i &lt;- which(!st)                         # choose a random, 
  i &lt;- i[runif(1, min=1, max=length(i))]  # unstopped state
  r &lt;- fourTwo.step(states[[i]])               # step it
  states[[i]] &lt;- r$state                  # update the states
}

finals &lt;- lapply(states, fourTwo.final)    # get final estimates of threshold
for(i in 1:length(locations)) {
  cat(sprintf("Location (%+2d,%+2d) ",locations[[i]][1], locations[[i]][2]))
      cat(sprintf("has threshold %4.2f\n", finals[[i]]))
}

if (!is.null(opiClose()))
  warning("opiClose() failed")
</code></pre>

<hr>
<h2 id='FT'>Full Threshold</h2><span id='topic+FT'></span><span id='topic+FT.start'></span><span id='topic+FT.step'></span><span id='topic+FT.stop'></span><span id='topic+FT.final'></span>

<h3>Description</h3>

<p>FT begins with a 4-2dB staircase beginning at level
<code>est</code>. If the final estimate (last seen) is more than 4dB away
from <code>est</code>, a second 4-2 staircase is completed beginning at the
estimate returned from the first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FT(est = 25, instRange = c(0, 40), verbose = FALSE, makeStim, ...)

FT.start(est = 25, instRange = c(0, 40), makeStim, ...)

FT.step(state, nextStim = NULL)

FT.stop(state)

FT.final(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FT_+3A_est">est</code></td>
<td>
<p>Starting estimate in dB</p>
</td></tr>
<tr><td><code id="FT_+3A_instrange">instRange</code></td>
<td>
<p>Dynamic range of the instrument c(min,max) in dB</p>
</td></tr>
<tr><td><code id="FT_+3A_verbose">verbose</code></td>
<td>
<p>True if you want each presentation printed</p>
</td></tr>
<tr><td><code id="FT_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a dB value and numPresentations
and returns an OPI datatype ready for passing to opiPresent</p>
</td></tr>
<tr><td><code id="FT_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="FT_+3A_state">state</code></td>
<td>
<p>Current state of the FT returned by <code>FT.start</code> and
<code>FT.step</code></p>
</td></tr>
<tr><td><code id="FT_+3A_nextstim">nextStim</code></td>
<td>
<p>A valid object for <code>opiPresent</code> to use as its
<code>nextStim</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of a 4-2 1-up 1-down staircase as
implemented in the first Humphrey Field Analyzer. The initial staircase
starts at <code>est</code> and proceeds in steps of 4 dB until the first
reversal, and 2dB until the next reversal. The last seen stimulus is
taken as the threshold value. If, after the first staircase, the
threshold is more than 4 dB away from the starting point, then a second
staircase is initiated with a starting point equal to the threshold
found with the first staircase.
</p>
<p>Note this function will repeatedly call <code>opiPresent</code> for a stimulus
until <code>opiPresent</code> returns <code>NULL</code> (ie no error occured)
</p>
<p>If more than one FT is to be interleaved (for example, testing multiple
locations), then the <code>FT.start</code>, <code>FT.step</code>, <code>FT.stop</code>
and <code>FT.final</code> calls can maintain the state of the FT after each
presentation, and should be used. If only a single FT is required, then
the simpler <code>FT</code> can be used. See examples below
</p>


<h3>Value</h3>



<h4>Single location</h4>

<p>Returns a list containing
* <code>npres</code>, total number of presentations.
* <code>respSeq</code>, response sequence stored as a list of (seen,dB) pairs.
* <code>first</code>, first staircase estimate in dB.
* <code>final</code>, final threshold estimate in dB.
</p>



<h4>Multilple locations</h4>

<p><code>FT.start</code> returns a list that can be passed to <code>FT.step</code>,
<code>FT.stop</code>, and <code>FT.final</code>. It represents the state of a FT
at a single location at a point in time and contains the following.
* <code>name</code>, <code>FT</code>.
* <code>startingEstimate=est</code>, input param.
* <code>currentLevel</code>, the next stimulus to present.
* <code>minStimulus=instRange[1]</code>, input param.
* <code>maxStimulus=instRange[2]</code>, input param.
* <code>makeStim</code>, input param.
* <code>lastSeen</code>, the last seen stimulus.
* <code>lastResponse</code>, the last response given.
* <code>stairResult</code>, The final result if finished (initially <code>NA</code>).
* <code>finished</code>, <code>"Not"</code> if staircase has not finished, or one of
<code>"Rev"</code> (finished due to 2 reversals),
<code>"Max"</code> (finished due to 2 <code>maxStimulus</code> seen),
<code>"Min"</code> (finished due to 2 <code>minStimulus</code> not seen).
* <code>verbose</code>, number of reversals so far.
* <code>numberOfReversals</code>, number of reversals so far.
* <code>currSeenLimit</code>, number of times <code>maxStimulus</code> has been seen.
* <code>currNotSeenLimit</code>, number of times <code>minStimulus</code> not seen.
* <code>numPresentations</code>, number of presentations so far.
* <code>stimuli</code>, vector of stimuli shown at each call to <code>FT.step</code>.
* <code>responses</code>, vector of responses received (1 seen, 0 not) received at each call to <code>FT.step</code>.
* <code>responseTimes</code>, vector of response times received at each call to <code>FT.step</code>.
* <code>opiParams=list(...)</code>, input param
* <code>finished</code>, <code>TRUE</code> if staircase has finished (2 reversals, or max/min seen/not-seen twice).
</p>
<p><code>FT.step</code> returns a list containing
</p>

<ul>
<li> <p><code>state</code>, the new state after presenting a stimuli and getting a response.
</p>
</li>
<li> <p><code>resp</code>, the return from the <code>opiPresent</code> call that was made.
</p>
</li></ul>

<p><code>FT.stop</code> returns <code>TRUE</code> if the first staircase has had 2 reversals, or
<code>maxStimulus</code> is seen twice or <code>minStimulus</code> is not seen twice and the
final estimate is within 4 dB of the starting stimulus. Returns <code>TRUE</code> if
the second staircase has had 2 reversals, or <code>maxStimulus</code> is seen twice or
<code>minStimulus</code> is not seen twice
</p>
<p><code>FT.final</code> returns the final estimate of threshold based on state, which is
the last seen in the second staircase, if it ran, or the first staircase otherwise
</p>
<p><code>FT.final.details</code> returns a list containing
</p>

<ul>
<li> <p><code>final</code>, the final threshold.
</p>
</li>
<li> <p><code>first</code>, the threshold determined by the first staircase (might be different from final).
</p>
</li>
<li> <p><code>stopReason</code>, either <code>Reversals</code>, <code>Max</code>, or <code>Min</code> which are the three ways in which FT can terminate.
</p>
</li>
<li> <p><code>np</code>, number of presentation for the whole procedure (including both staircases if run).
</p>
</li></ul>




<h3>References</h3>

<p>A. Turpin, P.H. Artes and A.M. McKendrick. &quot;The Open Perimetry
Interface: An enabling tool for clinical visual psychophysics&quot;, Journal
of Vision 12(11) 2012.
</p>
<p>H. Bebie, F. Fankhauser and J. Spahr. &quot;Static perimetry: strategies&quot;,
Acta Ophthalmology 54 1976.
</p>
<p>C.A. Johnson, B.C. Chauhan, and L.R. Shapiro. &quot;Properties of staircase
procedures for estimating thresholds in automated perimetry&quot;,
Investagative Ophthalmology and Vision Science 33 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>, <code><a href="#topic+fourTwo.start">fourTwo.start</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}
chooseOpi("SimHenson")
if (!is.null(opiInitialize(type="C", cap=6)))
  stop("opiInitialize failed")

result &lt;- FT(makeStim=makeStim, tt=30, fpr=0.15, fnr=0.01)
if (!is.null(opiClose()))
  warning("opiClose() failed")

##############################################
# This section is for multiple FTs
##############################################
makeStimHelper &lt;- function(db,n, x, y) {  # returns a function of (db,n)
  ff &lt;- function(db, n) db+n
  body(ff) &lt;- substitute({
    s &lt;- list(x=x, y=y, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500)
    class(s) &lt;- "opiStaticStimulus"
    return(s)
  }, list(x=x,y=y))
  return(ff)
}

# List of (x, y, true threshold) triples
locations &lt;- list(c(9,9,30), c(-9,-9,32), c(9,-9,31), c(-9,9,33))
# Setup starting states for each location
states &lt;- lapply(locations, function(loc) {
  FT.start(makeStim=makeStimHelper(db,n,loc[1],loc[2]),
           tt=loc[3], fpr=0.03, fnr=0.01)})

# Loop through until all states are "stop"
while(!all(st &lt;- unlist(lapply(states, FT.stop)))) {
  i &lt;- which(!st)                         # choose a random,
  i &lt;- i[runif(1, min=1, max=length(i))]  # unstopped state
  r &lt;- FT.step(states[[i]])               # step it
  states[[i]] &lt;- r$state                  # update the states
}

finals &lt;- lapply(states, FT.final)    # get final estimates of threshold
for(i in 1:length(locations)) {
  cat(sprintf("Location (%+2d,%+2d) ",locations[[i]][1], locations[[i]][2]))
  cat(sprintf("has threshold %4.2f\n", finals[[i]]))
}

if(!is.null(opiClose()))
  warning("opiClose() failed")
</code></pre>

<hr>
<h2 id='MOCS'>Method of Constant Stimuli (MOCS)</h2><span id='topic+MOCS'></span>

<h3>Description</h3>

<p>MOCS performs either a yes/no or n-interval-forced-choice Method of
Constant Stimuli test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOCS(
  params = NA,
  order = "random",
  responseWindowMeth = "constant",
  responseFloor = 1500,
  responseHistory = 5,
  keyHandler = function(correct, ret) return(list(seen = TRUE, time = 0, err = NULL)),
  interStimMin = 200,
  interStimMax = 500,
  beep_function,
  makeStim,
  stim_print,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOCS_+3A_params">params</code></td>
<td>
<p>A matrix where each row is <code>x y i n correct_n ll1 ll2 ... llm</code> where
</p>

<ul>
<li> <p><code>x</code> is X coordinate of location.
</p>
</li>
<li> <p><code>y</code> is Y coordinate of location.
</p>
</li>
<li> <p><code>i</code> is a location number (assigned by caller).
</p>
</li>
<li> <p><code>n</code> is Number of times this location/luminance(s) should be repeated.
</p>
</li>
<li> <p><code>correct_n</code> is the index i of the luminance level (<code>lli</code>) that
should be treated as a &ldquo;correct&rdquo; response (the correct interval). For a
standard MOCS, this will be 1; for a 2AFC, this will be 1 or 2. This number will
be in the range <code>[1,m]</code>.
</p>
</li>
<li> <p><code>lli</code> is the i'th luminance level to be used at this location for
interval i of the presentation in cd/<code class="reqn">\mbox{m}^2</code>. For a standard MOCS,
i=1, and the <code>params</code> matrix will have 5 columns. For a 2AFC, there will be
two lli's, and <code>params</code> will have 6 columns.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MOCS_+3A_order">order</code></td>
<td>
<p>Control the order in which the stimuli are presented.
</p>

<ul>
<li> <p><code>"random"</code> Randomise the order of trials/locations.
</p>
</li>
<li> <p><code>"fixed"</code> Present each row of <code>params</code> in order of <code>1:nrow(params)</code>, ignoring the <code>n</code> (4th) column in <code>params</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MOCS_+3A_responsewindowmeth">responseWindowMeth</code></td>
<td>
<p>Control time perimeter waits for response.
</p>

<ul>
<li> <p><code>"speed"</code> After an average of the last <code>speedHistory</code> response times, with a minimum of <code>responseFloor</code>. Initially <code>responseFloor</code>.
</p>
</li>
<li> <p><code>"constant"</code> Always use <code>responseFloor</code>.
</p>
</li>
<li> <p><code>"forceKey"</code> Wait for a keyboard input.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MOCS_+3A_responsefloor">responseFloor</code></td>
<td>
<p>Minimum response window (for any <code>responseWindowMeth</code> except <code>"forceKey"</code>).</p>
</td></tr>
<tr><td><code id="MOCS_+3A_responsehistory">responseHistory</code></td>
<td>
<p>Number of past yeses to average to get response window
(only used if <code>responseWindowMeth</code> is <code>"speed"</code>).</p>
</td></tr>
<tr><td><code id="MOCS_+3A_keyhandler">keyHandler</code></td>
<td>
<p>Function to get a keyboard input and returns as for <code>opiPresent</code>:
<code>list(err={NULL|msg}, seen={TRUE|FALSE}, time</code>. The parameters passed to
the function are the correct interval number (column 4 of <code>params</code>), and the
result of <code>opiPresent</code>. See Examples.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_interstimmin">interStimMin</code></td>
<td>
<p>Regardless of response, wait <code>runif(interStimMin, interStimMax)</code> ms.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_interstimmax">interStimMax</code></td>
<td>
<p>Regardless of response, wait <code>runif(interStimMin, interStimMax)</code> ms.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_beep_function">beep_function</code></td>
<td>
<p>A function that takes the string <code>'correct'</code>, the string
<code>'incorrect'</code>, or a stimulus number and plays an appropriate sound.  See examples.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_makestim">makeStim</code></td>
<td>
<p>A helper function to take a row of <code>params</code> and a response window length
in ms, and create a list of OPI stimuli types for passing to opiPresent. This may include a
<code>checkFixationOK</code> function. See Example.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_stim_print">stim_print</code></td>
<td>
<p>A function that takes an <code>opiStaticStimulus</code> and return list from
<code>opiPresent</code> and returns a string to print for each presentation. It is called
immediately after each <code>opiPresent</code>, and the string is prepended with the
(x,y) coordinates of the presentation and ends with a newline.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whether the test is yes/no or forced-choice is determined by the number of columns
in <code>params</code>. The code simply presents all columns from 5 onwards and collects a
response at the end. So if there is only 5 columns, it is a yes/no task. If there are 6
columns it is a 2-interval-forced-choice. Generally, an nIFC experiment has 4+n columns in
<code>params</code>.
</p>
<p>Note that when the <code>order</code> is <code>"random"</code>, the number of trials in the test will be
the sum of the 3rd column of <code>params</code>. When the <code>order</code> is <code>"fixed"</code>, there is
only one presentation per row, regardless of the value in the 3rd column of <code>params</code>.
</p>
<p>If a response is received before the final trial in a nIFC experiment, it is ignored.
</p>
<p>If the <code>checkFixationOK</code> function is present in a stimulus, then it is called after each
presentation, and the result is &ldquo;anded&rdquo; with each stimulus in a trial to get a TRUE/FALSE
for fixating on all stimuli in a trial.
</p>


<h3>Value</h3>

<p>Returns a data.frame with one row per stimulus copied from params with extra columns
appended: checkFixation checks, and the return values from <code>opiPresent()</code>
(see example). These last values will differ depending on which
machine/simulation you are running (as chosen with <code>chooseOpi()</code>.
</p>

<ul>
<li><p> column 1: x
</p>
</li>
<li><p> column 2: y
</p>
</li>
<li><p> column 3: location number
</p>
</li>
<li><p> column 4: number of times to repeat this stim
</p>
</li>
<li><p> column 5: correct stimulus index
</p>
</li>
<li><p> column 6: TRUE/FALSE was fixating for all presentations in this trial according to <code>checkFixationOK</code>
</p>
</li>
<li><p> column 7...: columns from params
</p>
</li>
<li><p> ...: columns from opiPresent return
</p>
</li></ul>



<h3>References</h3>

<p>A. Turpin, P.H. Artes and A.M. McKendrick. &quot;The Open Perimetry Interface: An enabling tool for
clinical visual psychophysics&quot;, Journal of Vision 12(11) 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the Octopus 900
# Check if pupil centre is within 10 pixels of (160,140)
checkFixationOK &lt;- function(ret) return(sqrt((ret$pupilX - 160)^2 + (ret$pupilY - 140)^2) &lt; 10)

# Return a list of opi stim objects (list of class opiStaticStimulus) for each level (dB) in
# p[5:length(p)]. Each stim has responseWindow BETWEEN_FLASH_TIME, except the last which has
# rwin. This one assumes p is on old Octopus 900 dB scale (0dB == 4000 cd/m^2).
makeStim &lt;- function(p, rwin) {
  BETWEEN_FLASH_TIME &lt;- 750   # ms
  res &lt;- NULL
  for(i in 5:length(p)) {
    s &lt;- list(x=p[1], y=p[2], level=dbTocd(p[i],4000/pi), size=0.43, duration=200,
              responseWindow=ifelse(i &lt; length(p), BETWEEN_FLASH_TIME, rwin),
              checkFixationOK=NULL)
    class(s) &lt;- "opiStaticStimulus"
    res &lt;- c(res, list(s))
  }
  return(res)
}

################################################################
# Read in a key press 'z' is correct==1, 'm' otherwise
#    correct is either 1 or 2, whichever is the correct interval
#
# Return list(seen={TRUE|FALSE}, time=time, err=NULL))
#        seen is TRUE if correct key pressed
################################################################
## Not run: 
  if (length(dir(".", "getKeyPress.py")) &lt; 1)
    stop('Python script getKeyPress.py missing?')

## End(Not run)

keyHandler &lt;- function(correct, ret) {
  return(list(seen=TRUE, time=0, err=NULL))
  ONE &lt;- "b'z'"
  TWO &lt;- "b'm'"
  time &lt;- Sys.time()
  key &lt;- 'q'
  while (key != ONE &amp;&amp; key != TWO) {
    a &lt;- system('python getKeyPress.py', intern=TRUE)
    key &lt;- a # substr(a, nchar(a), nchar(a))
    print(paste('Key pressed: ',key,'from',a))
    if (key == "b'8'")
      stop('Key 8 pressed')
  }
  time &lt;- Sys.time() - time
  if ((key == ONE &amp;&amp; correct == 1) || (key == TWO &amp;&amp; correct == 2))
    return(list(seen=TRUE, time=time, err=NULL))
  else
    return(list(seen=FALSE, time=time, err=NULL))
}

################################################################
# Read in return value from opipresent with F310 controller.
# First param is correct, next is 1 for left button, 2 for right button
# Left button (LB) is correct for interval 1, RB for interval 2
#    correct is either 1 or 2, whichever is the correct interval
#
# Return list(seen={TRUE|FALSE}, time=time, err=NULL))
#        seen is TRUE if correct key pressed
################################################################
F310Handler &lt;- function(correct, opiResult) {
  z &lt;- opiResult$seen == correct
  opiResult$seen &lt;- z
  return(opiResult)
}

################################################################
# 2 example beep_function
################################################################
## Not run: 
  require(beepr)
  myBeep &lt;- function(type='None') {
    if (type == 'correct') {
      beepr::beep(2)  # coin noise
      Sys.sleep(0.5)
    }
    if (type == 'incorrect') {
      beepr::beep(1) # system("rundll32 user32.dll,MessageBeep -1") # system beep
      #Sys.sleep(0.0)
    }
  }
  require(audio)
  myBeep &lt;- function(type="None") {
    if (type == 'correct') {
      wait(audio::play(sin(1:10000/10)))
    }
    if (type == 'incorrect') {
      wait(audio::play(sin(1:10000/20)))
    }
  }

## End(Not run)

################################################################
# An example stim_print function
################################################################
## Not run: 
  stim_print &lt;- function(s, ret) {
    sprintf("%4.1f %2.0f",cdTodb(s$level,10000/pi), ret$seen)
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='opi.implementations'>FOR INTERNAL USE ONLY</h2><span id='topic+opi.implementations'></span><span id='topic+opiDistributor'></span>

<h3>Description</h3>

<p>The method <code>opiDistributor</code> searches for the specific
method of a general OPI <code>operation</code>, which depends on the OPI
implementation selected with <code><a href="#topic+chooseOpi">chooseOpi</a></code>. It returns an error if no
OPI implementation has been selected yet. A catalog of all specific methods are
listed in <code>opi.implementations</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opi.implementations

opiDistributor(operation, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opi.implementations_+3A_operation">operation</code></td>
<td>
<p>A general OPI operation of the following methods to: <code>opiInitialize</code>,
<code>opiPresent</code> <code>opiClose</code>, <code>opiSetBackground</code>,
<code>opiQueryDevice</code></p>
</td></tr>
<tr><td><code id="opi.implementations_+3A_...">...</code></td>
<td>
<p>other parameters to pass to the methods</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code>opi.implementations</code> is a <code>list</code> containing a catalog of
all specific methods that are dependent on the OPI implementation selected
with chooseOpi
</p>

<hr>
<h2 id='opiClose'>Close using OPI</h2><span id='topic+opiClose'></span><span id='topic+compass.opiClose'></span><span id='topic+display.opiClose'></span><span id='topic+daydream.opiClose'></span><span id='topic+imo.opiClose'></span><span id='topic+kowaAP7000.opiClose'></span><span id='topic+octo600.opiClose'></span><span id='topic+octo900.opiClose'></span><span id='topic+PhoneHMD.opiClose'></span><span id='topic+simG.opiClose'></span>

<h3>Description</h3>

<p>Generic function for closing the chosen OPI implementation that is set
with <code>chooseOpi()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiClose(...)

compass.opiClose()

display.opiClose()

daydream.opiClose()

imo.opiClose()

kowaAP7000.opiClose()

octo600.opiClose()

octo900.opiClose()

PhoneHMD.opiClose()

simG.opiClose()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiClose_+3A_...">...</code></td>
<td>
<p>Implementation specific parameters. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL if close succeeded, otherwise an implementation-dependent
error.
</p>


<h4>Compass</h4>

<p>Returns a list of <code>err</code>, which is an error code, and <code>fixations</code>,
which is a matrix with three columns: <code>time</code> (same as <code>time_hw</code>
in <code>opiPresent</code>), <code>x</code> (degrees relative to the centre of the image
returned by <code>opiInitialise</code> - not the PRL), <code>y</code> (as for x), and one row
per fixation.
</p>



<h4>Display</h4>

<p>Shuts the display.
</p>



<h4>Daydream</h4>

<p>DETAILS
</p>



<h4>imo</h4>

<p>DETAILS
</p>



<h4>KowaAP7000</h4>

<p>DETAILS
</p>



<h4>Octopus600</h4>

<p>Always returns NULL
</p>



<h4>Octopus900</h4>

<p>Returns NULL.
</p>



<h4>PhoneHMD</h4>

<p>Closes the socket connection with the PhoneHMD
</p>



<h4>SimGaussian</h4>

<p>DETAILS
</p>



<h3>See Also</h3>

<p><code><a href="#topic+chooseOpi">chooseOpi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("SimGaussian")
if (!is.null(opiInitialize(sd=2)))
  stop("opiInitialize failed")
if (!is.null(opiClose()))
  stop("opiClose failed, which is very surprising!")
</code></pre>

<hr>
<h2 id='opiGetParams'>Get OPI method parameters</h2><span id='topic+opiGetParams'></span>

<h3>Description</h3>

<p>Get parameters of OPI functions which depends on the
implementation set with <code>chooseOPI()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiGetParams(method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiGetParams_+3A_method">method</code></td>
<td>
<p>Method for which to get parameters and defaults.</p>
</td></tr>
<tr><td><code id="opiGetParams_+3A_...">...</code></td>
<td>
<p>Implementation specific parameters. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of parameters and their default vlues of the
method <code>method</code> depending on the OPI implementation selected with
<code>chooseOPI()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("SimHenson")
opiGetParams("opiInitialize")
opiGetParams("opiPresent")
</code></pre>

<hr>
<h2 id='opiInitialize'>Initialize OPI</h2><span id='topic+opiInitialize'></span><span id='topic+opiInitialise'></span><span id='topic+compass.opiInitialize'></span><span id='topic+display.opiInitialize'></span><span id='topic+daydream.opiInitialize'></span><span id='topic+imo.opiInitialize'></span><span id='topic+kowaAP7000.opiInitialize'></span><span id='topic+octo600.opiInitialize'></span><span id='topic+octo900.opiInitialize'></span><span id='topic+PhoneHMD.opiInitialize'></span><span id='topic+simG.opiInitialize'></span><span id='topic+simH.opiInitialize'></span><span id='topic+simH_RT.opiInitialize'></span>

<h3>Description</h3>

<p>Generic function for initialization of the chosen OPI
implementation that is set with <code>chooseOpi()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiInitialize(...)

opiInitialise(...)

compass.opiInitialize(ip = "192.168.1.2", port = 44965)

display.opiInitialize(
  width,
  height,
  ppi,
  viewdist,
  lut = seq(0, 400, length.out = 256)
)

daydream.opiInitialize(
  ip = "127.0.0.1",
  port = 50008,
  lut = seq(0, 400, length.out = 256),
  fovy = 90
)

imo.opiInitialize(
  ip = "localhost",
  port = 1234,
  ppd = 16,
  tracking = FALSE,
  tracktol = 2
)

kowaAP7000.opiInitialize(ip = "192.168.1.2", port = 44965)

octo600.opiInitialize(
  ipAddress = "",
  eye = "",
  pupilTracking = FALSE,
  pulsar = FALSE,
  eyeControl = 0
)

octo900.opiInitialize(
  serverPort = 50001,
  eyeSuiteSettingsLocation = "C:/ProgramData/Haag-Streit/EyeSuite/",
  eye = "",
  gazeFeed = "",
  bigWheel = FALSE,
  pres_buzzer = 0,
  resp_buzzer = 0,
  zero_dB_is_10000_asb = TRUE
)

PhoneHMD.opiInitialize(ip, port = 50008, lut = seq(0, 400, length.out = 256))

simG.opiInitialize(sd = 2, display = NA, maxStim = 10000/pi)

simH.opiInitialize(
  type = "C",
  A = -0.081,
  B = 3.27,
  cap = 6,
  display = NA,
  maxStim = 10000/pi
)

simH_RT.opiInitialize(
  type = "C",
  cap = 6,
  A = -0.081,
  B = 3.27,
  display = NA,
  maxStim = 10000/pi,
  rtData = NULL,
  rtFP = 1:1600
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialize_+3A_...">...</code></td>
<td>
<p>Implementation specific parameters. See details.</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_ip">ip</code></td>
<td>
<p>IP address on which server is listening for PhoneHMD</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_port">port</code></td>
<td>
<p>Port number on which server is listening for PhoneHMD. Default is 50008</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_width">width</code></td>
<td>
<p>Width of the screen in pixels</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_height">height</code></td>
<td>
<p>Height of the screen in pixels</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_ppi">ppi</code></td>
<td>
<p>Pixels per inch of the display</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_viewdist">viewdist</code></td>
<td>
<p>Viewing distance in cm</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_lut">lut</code></td>
<td>
<p>Look up table mapping pixel values to cd/m2</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_fovy">fovy</code></td>
<td>
<p>Field of view in degrees in the y-axis. It is different depending on the device.
For Daydream view, it is 90 degrees, for, Daydream view 2 is 100 degrees. Default is 90.</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_ppd">ppd</code></td>
<td>
<p>pixels size as in pixels per degree</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_tracking">tracking</code></td>
<td>
<p>tracking on or off</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_tracktol">tracktol</code></td>
<td>
<p>tolerance during tracking in degrees of visual angle</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_ipaddress">ipAddress</code></td>
<td>
<p>IP address of Octopus 600 machine</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_eye">eye</code></td>
<td>
<p>eye; &quot;right&quot; or &quot;left&quot; for &quot;Octopus900&quot;, &quot;Octopus600&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_pupiltracking">pupilTracking</code></td>
<td>
<p>pupil tracking</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_pulsar">pulsar</code></td>
<td>
<p>DETAILS</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_eyecontrol">eyeControl</code></td>
<td>
<p>DETAILS</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_serverport">serverPort</code></td>
<td>
<p>port number on which server is listening for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_eyesuitesettingslocation">eyeSuiteSettingsLocation</code></td>
<td>
<p>dir name containing EyeSuite settings for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_gazefeed">gazeFeed</code></td>
<td>
<p>NA or a folder name for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_bigwheel">bigWheel</code></td>
<td>
<p>FALSE (standard machine), TRUE for modified apeture wheel for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_pres_buzzer">pres_buzzer</code></td>
<td>
<p>0 (no buzzer),1, 2, 3 (max volume) for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_resp_buzzer">resp_buzzer</code></td>
<td>
<p>0 (no buzzer),1, 2, 3 (max volume) for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_zero_db_is_10000_asb">zero_dB_is_10000_asb</code></td>
<td>
<p>Is 0 dB 10000 apostilb (TRUE) or or 4000 (FALSE) for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_sd">sd</code></td>
<td>
<p>standard deviation for the Gaussian</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_display">display</code></td>
<td>
<p>Dimensions of plot area (-x,+x,-y,+y) to display stim. No display if NULL.
For &quot;SimHenson&quot;, &quot;SimHensonRT&quot;, &quot;SimGaussian&quot;, &quot;SimNo&quot;, &quot;SimYes&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_maxstim">maxStim</code></td>
<td>
<p>Maximum stimulus value in cd/m^2 used for db &lt;-&gt; cd/m^2 conversions for
&quot;SimHenson&quot;, &quot;SimHensonRT&quot;, &quot;SimGaussian&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_type">type</code></td>
<td>
<p>N|G|C for the three Henson params for &quot;SimHenson&quot;, &quot;SimHensonRT&quot;. Type 'X'
to specify your own A and B values (eg different dB scale)</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_a">A</code></td>
<td>
<p>parameter A for &quot;SimHenson&quot;, &quot;SimHensonRT&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_b">B</code></td>
<td>
<p>parameter B for &quot;SimHenson&quot;, &quot;SimHensonRT&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_cap">cap</code></td>
<td>
<p>dB value for capping stdev form Henson formula for &quot;SimHenson&quot;, &quot;SimHensonRT&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_rtdata">rtData</code></td>
<td>
<p>data.frame with colnames == &quot;Rt&quot;, &quot;Dist&quot;, &quot;Person&quot; for &quot;SimHensonRT&quot;</p>
</td></tr>
<tr><td><code id="opiInitialize_+3A_rtfp">rtFP</code></td>
<td>
<p>response time for false positives ??? for &quot;SimHensonRT&quot;</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Compass</h4>

<p><code>opiInitialize(ip, port)</code>
</p>
<p>If the chosen OPI implementation is <code>Compass</code>, then you must specify
the IP address and port of the Compass server.
</p>

<ul>
<li> <p><code>ip</code> is the IP address of the Compass server as a string.
</p>
</li>
<li> <p><code>port</code> is the TCP/IP port of the Compass server as a number.
Warning: this returns a list, not a single error code.
</p>
</li></ul>




<h4>Display</h4>

<p><code>opiInitialize((width, height, ppi, viewdist, lut = .OpiEnv$Display$LUT)
  )</code>
</p>
<p>If the chosen OPI implementation is <code>Display</code>, then you can specify
the limits of the plot area and the background color of the plot area.
Note that this assumes <code>link{X11()}</code> is available on the platform.
</p>
<p>We need to know the physical dimensions of the screen and the window
generated in order to calculate stimulus position and size in degrees
of visual angle. The physical dimensions in inches are calculated from
width, height, and ppi. The pixel size pix per degree is then obtained
using viewdist. A gamma function for the screen should be obtained and
its lut passed to convert from luminance in cd/m2 to 8-bit pixel value
(256 levels).
</p>



<h3>Value</h3>

<p>Returns NULL if initialization succeeded, otherwise an
implementation-dependent error.
</p>


<h4>Compass</h4>

<p>Returns a list with elements:
* <code>err</code> NULL if successful, not otherwise.
* <code>prl</code> a pair giving the (x,y) in degrees of the Preferred Retinal Locus detected in the initial alignment.
* <code>onh</code> a pair giving the (x,y) in degrees of the ONH as selected by the user.
* <code>image</code> raw bytes being the JPEG compressed infra-red image acquired during alignment encoded using
<code>openssl::base64_encode()</code>.
</p>



<h4>Display</h4>

<p>Always returns NULL.
</p>



<h4>Daydream</h4>

<p>Always returns NULL.
</p>



<h4>imo</h4>

<p>Always returns NULL. Will <code>stop</code> if there is an error.
</p>



<h4>Kowa AP-7000</h4>

<p>Always returns NULL.
</p>



<h4>Octopus600</h4>

<p>Returns NULL if successful, or an Octopus 600 error code. The default
background and stimulus setup is to white-on-white perimetry.
</p>



<h4>Octopus900</h4>

<p>Returns NULL if successful, 1 if Octopus900 is already initialised by a
previous call to <code>opiInitialize</code>, and 2 if some error occurred that
prevented initialisation. The default background and stimulus setup is
to white-on-white perimetry. Use <code>opiSetBackground</code> to change the
background and stimulus colors.
</p>



<h4>PhoneHMD</h4>

<p>Returns NULL if connection is made, otherwise, it returns a text with the error.
</p>



<h3>Daydream</h3>

<p><code>opiInitialize(ip="127.0.0.1", port=50008, lut= seq(0, 400, length.out = 256), fovy = 90)</code>
</p>
<p>If the chosen OPI implementation is <code>Daydream</code>, then you must specify
the IP address of the Android phone that is in the Daydream, and the port on
which the server running on the phone is listening.
</p>

<ul>
<li> <p><code>ip</code> is the IP address of the Daydream server as a string
</p>
</li>
<li> <p><code>port</code> is the TCP/IP port of the Daydream server as a number
</p>
</li>
<li> <p><code>lut</code> is a vector of 256 luminance values, with <code>lut[i]</code> being the cd/<code class="reqn">\mbox{m}^2</code> value for grey level i. Default is <code>seq(0, 4000, length.out = 256)</code>
</p>
</li>
<li> <p><code>fovy</code> Field of view in degrees in the y-axis. It is different depending on the device. For Daydream view, it is 90 degrees, for, Daydream view 2 is 100 degrees. Default is 90.
</p>
</li></ul>



<h3>imo</h3>

<p><code>opiInitialize(ip, port, ppd = 16, tracking = FALSE, tracktol = 2)</code>
</p>
<p>If the chosen OPI implementation is <code>imo</code>, then you must specify the IP
address and port of the imo server.
</p>
<div class="sourceCode"><pre>* \code{ip} is the IP address of the imo server as a string.
* \code{port} is the TCP/IP port of the imo server as a number.
* \code{ppd} Pixel size in pixels per degree. Default is 16 ppd.
* \code{tracking} Whether to use tracking during stimulus presentation. Default is FALSE.
* \code{tracktol} Tolerance during tracking in degrees of visual angle.  The system does not show any stimulus if eye is not within \code{tracktol} degrees of visual angle from fixation point. Default is 2 degrees.
</pre></div>


<h3>KowaAP7000</h3>

<p><code>opiInitialize(ip, port)</code>
</p>
<p>If the chosen OPI implementation is <code>KowaAP7000</code>, then you must specify
the IP address and port of the AP-7000 server.
</p>

<ul>
<li> <p><code>ipAddress</code> is the IP address of the AP-7000 server as a string.
</p>
</li>
<li> <p><code>port</code> is the TCP/IP port of the AP-7000 server as a number.
</p>
</li></ul>



<h3>Octopus600</h3>

<p><code>opiInitialize(ipAddress, eye, pupilTracking=FALSE, pulsar=FALSE, eyeControl=0)</code>
</p>
<p>If the chosen OPI implementation is <code>Octopus600</code>, then you must specify
the IP address of the Octopus 600 and the eye to test.
</p>
<p><code>ipAddress</code> is the IP address of the Octopus 600 as a string.
</p>
<p><code>eye</code> must be either &quot;left&quot; or &quot;right&quot;.
</p>
<p><code>pupilTracking</code> is TRUE to turn on IR illumination and set pupil
black level (which happens at the first stimulus presentation).
</p>
<p><code>pulsar</code> is TRUE for pulsar stimulus, FALSE for size III white-on-white.
</p>
<p><code>eyeControl</code>
* 0 is off
* 1 is eye blink
* 2 is eye blink, forehead rest, fixation control
* 3 is eye blink, forehead rest, fixation control, fast eye movements
</p>


<h3>Octopus900</h3>

<p><code>opiInitialize(serverPort=50001,eyeSuiteSettingsLocation, eye, gazeFeed=NA, bigWheel=FALSE,pres_buzzer=0, resp_buzzer=0, zero_dB_is_10000_asb=TRUE)</code>
</p>
<p>If the chosen OPI implementation is <code>Octopus900</code>, then you must specify
a directory and the eye to be tested.
</p>
<p><code>serverPort</code> is the TCP/IP port on which the server is listening (on
localhost).
</p>
<p><code>eyeSuiteSettingsLocation</code> is the folder name containing the EyeSuite
setting files, and should include the trailing slash.
</p>
<p><code>eye</code> must be either &quot;left&quot; or &quot;right&quot;.
</p>
<p><code>gazeFeed</code> is the name of an existing folder into which the video frames
of eye tracker are recorded. Set to <code>NA</code> for no recording.
</p>
<p><code>bigWheel</code> is <code>FALSE</code> for a standard Octopus 900 machine. Some
research machines are fitted with an alternate aperture wheel that has 24
sizes, which are accessed with <code>bigWheel</code> is <code>TRUE</code>. The mapping
from size to 'hole on wheel' is hard coded; see code for details.
</p>
<p>If <code>pres_buzzer</code> is greater than zero, a buzzer will sound with each
stimuli presented.
</p>
<p>If <code>resp_buzzer</code> is greater than zero, a buzzer will sound with each
button press (response). The volume can be one of 0 (no buzzer), 1, 2, or 3
(max volume). If both buzzers are more than zero, the maximum of the two will
be used as the volume.
</p>
<p>If <code>zero_dB_is_10000_asb</code> is <code>TRUE</code> then 0 dB is taken as 10000
apostilbs, otherwise 0 dB is taken as 4000 apostilbs.
</p>


<h3>PhoneHMD</h3>

<p><code>opiInitialize(serverPort, port = 50008, lut = seq(0, 400, length.out = 256))</code>
If the chosen OPI implementation is <code>PhoneHMD</code>, then you must specify
the IP address of the Android PhoneHMD that is in the PhoneHMD, and the port on
which the server running on the PhoneHMD is listening.
</p>

<ul>
<li> <p><code>ip</code> is the IP address of the PhoneHMD server as a string
</p>
</li>
<li> <p><code>port</code> is the TCP/IP port of the PhoneHMD server as a number
</p>
</li>
<li> <p><code>lut</code> is a vector of 256 luminance values, with <code>lut[i]</code> being the
cd/<code class="reqn">\mbox{m}^2</code> value for grey level i. Default is
<code>seq(0, 4000, length.out = 256)</code>
</p>
</li></ul>



<h3>SimGaussian</h3>

<p><code>opiInitialize(sd, display=NA, maxStim=10000/pi)</code>
</p>
<p>If the chosen OPI implementation is <code>SimGaussian</code>, then <code>sd</code> is the
standard deviation value that the simulator will use for the slope/spread of
the psychometric function.
</p>
<p><code>display</code> and <code>maxStim</code> is as for SimHenson.
</p>


<h3>SimHenson</h3>

<p><code>opiInitialize(type="C", A=NA, B=NA, cap=6, maxStim=10000/pi)</code>
</p>
<p>If the chosen OPI implementation is <code>SimHenson</code>, then <code>type</code>
can be one of: <code>"N"</code>, for normal patients; <code>"G"</code>, for POAG
patients; and <code>"C"</code>, for a combination. See Table 1 in Henson et al
(2000).
</p>
<p>If <code>type</code> is <code>"X"</code> then <code>A</code> and <code>B</code> should be
specified and are used in place of one of the three A/B combinations as in
Henson et al (2000). <code>cap</code> is the maximum standard deviation value that
the simulator will use for the slope/spread of the psychometric function.
</p>
<p>If <code>display</code> is a vector of four numbers <code>c(xlow, xhi, ylow, yhi)</code>,
then a plot area is created of dimension <code>xlim=range(xlow, xhi)</code> and
<code>ylim=range(ylow, yhi)</code> and each call to <code>opiPresent</code> will display
a point on the area. The color of the plot area can be set with
<code>opiSetBackground</code>, and the color of the displayed point is determined
by the stimulus passed to <code>opiPresent</code>.
</p>
<p><code>maxStim</code> is the maximum stimuls value in cd/<code class="reqn">\mbox{m}^2</code>.
This is used in converting cd/<code class="reqn">\mbox{m}^2</code> to dB values, and
vice versa.
</p>


<h3>SimHensonRT</h3>

<p><code>opiInitialize(type="C", A=NA, B=NA, cap=6, display=NA, maxStim=10000/pi, rtData, rtFP=1:1600)</code>
</p>
<p>If the chosen OPI implementation is <code>SimHensonRT</code>, then the first six
parameters are as in <code>SimHenson</code>, and <code>rtData</code> is a data frame
with at least 2 columns: <code>"Rt"</code>, reponse time; and <code>"Dist"</code>,
signifying that distance between assumed threshold and stimulus value in
your units.
</p>
<p>This package contains <code>RtSigmaUnits</code> or <code>RtDbUnits</code> that can be
loaded with the commands <code>data(RtSigmaUnits)</code> or <code>data(RtDbUnits)</code>,
and are suitable to pass as values for <code>rtData</code>.
</p>
<p><code>rtFp</code> gives the vector of values in milliseconds from which a response
time for a false positive response is randomly sampled.
</p>


<h3>References</h3>

<p>David B. Henson, Shaila Chaudry, Paul H. Artes, E. Brian Faragher, and Alec
Ansons. Response Variability in the Visual Field: Comparison of Optic Neuritis,
Glaucoma, Ocular Hypertension, and Normal Eyes. Investigative Ophthalmology &amp;
Visual Science, February 2000, Vol. 41(2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseOpi">chooseOpi</a></code>, <code><a href="#topic+opiSetBackground">opiSetBackground</a></code>,
<code><a href="#topic+opiClose">opiClose</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Set up the Compass
  chooseOpi("Compass")
  result &lt;- opiInitialize(ip="192.168.1.7", port=44965)
  if (is.null(result$err))
    print(result$prl)

## End(Not run)
## Not run: 
  # Set up a Display and wait for a key press in it.
  chooseOpi("Display")
  if (!is.null(opiInitialize(width = 1680, height = 1050, ppi = 128, viewdist = 25)))
    stop("opiInitialize failed")

  opiSetBackground(lum = 100, color = "white", fixation = "Circle")

  opiClose()

## End(Not run)
## Not run: 
  # Set up the imo
  chooseOpi("imo")
  opiInitialize(ip = "192.168.1.7", port = 1234)

## End(Not run)
## Not run: 
  # Set up the Kowa AP-7000
  chooseOpi("KowaAP7000")
  opiInitialize(ip="192.168.1.7", port=44965)

## End(Not run)
## Not run: 
  # Set up the Octopus 900
  chooseOpi("Octopus900")
  if (!is.null(opiInitialize(
       eyeSuiteSettingsLocation="C:/ProgramData/Haag-Streit/EyeSuite/",
       eye="left")))
    stop("opiInitialize failed")

## End(Not run)
# Set up a simulation using a psychometric function that is
# a cumulative gaussian of standard deviation 2
chooseOpi("SimGaussian")
if (!is.null(opiInitialize(sd=2)))
  stop("opiInitialize failed")
# Set up a simple simulation for white-on-white perimetry
chooseOpi("SimHenson")
if (!is.null(opiInitialize(type="C", cap=6)))
  stop("opiInitialize failed")

# Set up a simple simulation for white-on-white perimetry
# and display the stimuli in a plot region
chooseOpi("SimHenson")
if (!is.null(opiInitialize(type="C", cap=6)))
  stop("opiInitialize failed")
# Set up a simple simulation for white-on-white perimetry
# and display the stimuli in a plot region and simulate response times
chooseOpi("SimHensonRT")
data(RtSigmaUnits)
oi &lt;- opiInitialize(type="C", cap=6, display=NA, rtData=RtSigmaUnits, rtFP=1:100)
if (!is.null(oi))
  stop("opiInitialize failed")
</code></pre>

<hr>
<h2 id='opiKineticStimulus'>Stimulus parameter list</h2><span id='topic+opiKineticStimulus'></span>

<h3>Description</h3>

<p>List containing stimulus parameters with an S3 class attribute
of <code>opiKineticStimulus</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"See details"
</code></pre>


<h3>Details</h3>

<p>The list should be of class opiKineticStimulus and contain the
following elements.
</p>

<ul>
<li> <p><code>path</code> list of (x,y) coordinates in degrees that is usable by <code>xy.coords()</code>
</p>
</li>
<li> <p><code>image</code> <code>image[i]</code> is the image to display (in a machine specific format) in the section of the path specified by <code>path[i]..path[i+1]</code>.
</p>
</li>
<li> <p><code>levels</code> if <code>is.na(image)</code> then <code>levels[i]</code> is the stimulus level in cd/<code class="reqn">\mbox{m}^2</code> in the section of the path specified by <code>path[i]..path[i+1]</code>
</p>
</li>
<li> <p><code>sizes</code> <code>sizes[i]</code> is the size of stimulus (diameter in degrees) to use for the section of path specified by <code>path[i]..path[i+1]</code>, or a scaling factor for <code>images[i]</code>.
</p>
</li>
<li> <p><code>colors</code> <code>colors[i]</code> is the color to use for the stimulus in the section of path specified by <code>path[i]..path[i+1]</code>. Ignored if !is.na(image).
</p>
</li>
<li> <p><code>speeds</code><code>speeds[i]</code> is the speed (degrees per second) for the stimulus to traverse the path specified by <code>path[i]..path[i+1]</code>.
</p>
</li>
<li> <p><code>...</code> machine specific parameters
</p>
</li></ul>



<h3>Octopus 900</h3>

<p><code>x</code> and <code>y</code> are in degrees, with precision to three decimal places
recognised.
</p>
<p><code>image</code> is not possible on an Octopus 900.
</p>
<p><code>levels</code> are in cd/<code class="reqn">\mbox{m}^2</code>, and are rounded to the nearest
one tenth of a dB for display.
</p>
<p><code>colors</code> are ignored. Use <code>opiSetBackground()</code> to alter stimulus color.
</p>
<p><code>sizes</code> are in degrees, but are rounded to the nearest Goldmann Size I..V
for display.
</p>


<h3>Kowa AP 7000</h3>

<p>Only a simple path with a start and an end point is supported by the AP-7000.
</p>
<p><code>x</code> and <code>y</code> are in degrees and should only be length 2. (precision?)
</p>
<p><code>image</code> is not possible on an Kowa AP 7000.
</p>
<p><code>levels</code> are in cd/<code class="reqn">\mbox{m}^2</code> in the range 0.03 to 3183, and are
rounded to the nearest one tenth of a dB for display. (precision?)
</p>
<p><code>colors</code> one of <code>.OpiEnv$KowaAP7000$COLOR_WHITE</code>,
<code>.OpiEnv$KowaAP7000$COLOR_GREEN</code>, <code>.OpiEnv$KowaAP7000$COLOR_BLUE</code>, and
<code>.OpiEnv$KowaAP7000$COLOR_RED</code>.
</p>
<p><code>sizes</code> are in degrees, but are rounded to the nearest Goldmann Size I..V
for display.
</p>
<p><code>speeds</code> are in degrees per second in the range 3 to 5.
</p>


<h3>Compass</h3>

<p>Not implemented.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opiSetBackground">opiSetBackground</a></code>, <code><a href="#topic+opiStaticStimulus">opiStaticStimulus</a></code>,
<code><a href="#topic+opiTemporalStimulus">opiTemporalStimulus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A Size III white kinetic stimuli on a bilinear path {(27,27), (15,20), (0,0)}
stim &lt;- list(path=list(x=c(27,15,0), y=c(27,20,0)),
             izes=rep(0.43,2),
             colors=rep("white",2),
             levels=rep(318,2),
             speeds=c(4,3))
class(stim) &lt;- "opiKineticStimulus"
</code></pre>

<hr>
<h2 id='opiPresent'>Use OPI to present stimulus</h2><span id='topic+opiPresent'></span><span id='topic+compass.opiPresent'></span><span id='topic+display.opiPresent'></span><span id='topic+daydream.opiPresent'></span><span id='topic+imo.opiPresent'></span><span id='topic+kowaAP7000.opiPresent'></span><span id='topic+octo600.opiPresent'></span><span id='topic+octo900.opiPresentF310'></span><span id='topic+PhoneHMD.opiPresent'></span><span id='topic+simG.opiPresent'></span><span id='topic+simH.opiPresent'></span><span id='topic+simH_RT.opiPresent'></span><span id='topic+simNo.opiPresent'></span><span id='topic+simYes.opiPresent'></span>

<h3>Description</h3>

<p>Generic function for presentation of stimulus stim. Depending on
your choice of OPI implementation set using <code>chooseOpi()</code>, different
parameters are available for <code>opiPresent</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiPresent(stim, nextStim = NULL, ...)

compass.opiPresent(stim, nextStim = NULL)

display.opiPresent(stim, nextStim = NULL)

daydream.opiPresent(stim, nextStim = NULL)

imo.opiPresent(stim, nextStim = NULL)

kowaAP7000.opiPresent(stim, nextStim = NULL)

octo600.opiPresent(stim, nextStim = NULL)

octo900.opiPresentF310(stim, nextStim = NULL)

PhoneHMD.opiPresent(stim, nextStim = NULL)

simG.opiPresent(stim, nextStim = NULL, fpr = 0.03, fnr = 0.01, tt = 30)

simH.opiPresent(
  stim,
  nextStim = NULL,
  fpr = 0.03,
  fnr = 0.01,
  tt = 30,
  criteria = 0.97,
  rt_shape = 5.3,
  rt_rate = 1.4,
  rt_scale = 0.1
)

simH_RT.opiPresent(
  stim,
  nextStim = NULL,
  fpr = 0.03,
  fnr = 0.01,
  tt = 30,
  notSeenToSeen = TRUE
)

simNo.opiPresent(stim, nextStim = NULL)

simYes.opiPresent(stim, nextStim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_+3A_stim">stim</code></td>
<td>
<p>a list of class <code><a href="#topic+opiStaticStimulus">opiStaticStimulus</a></code>,
<code><a href="#topic+opiKineticStimulus">opiKineticStimulus</a></code>, or <code><a href="#topic+opiTemporalStimulus">opiTemporalStimulus</a></code> to be presented.</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_nextstim">nextStim</code></td>
<td>
<p>unused - included for compliance with OPI standard.</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_...">...</code></td>
<td>
<p>Parameters specific to your chosen opi implementation</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_fpr">fpr</code></td>
<td>
<p>false positive rate for OPI implementation &quot;SimHenson&quot;</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_fnr">fnr</code></td>
<td>
<p>false negative rate for OPI implementation &quot;SimHenson&quot;</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_tt">tt</code></td>
<td>
<p>SOMETHING for OPI implementation &quot;SimHenson&quot;</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_criteria">criteria</code></td>
<td>
<p>CRITERIA for OPI implementation &quot;SimHenson&quot;</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_rt_shape">rt_shape</code></td>
<td>
<p>response time shape parameter for OPI implementation &quot;SimHenson&quot;</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_rt_rate">rt_rate</code></td>
<td>
<p>response time rate parameter  for OPI implementation &quot;SimHenson&quot;</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_rt_scale">rt_scale</code></td>
<td>
<p>response time scale parameter for OPI implementation &quot;SimHenson&quot;</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_notseentoseen">notSeenToSeen</code></td>
<td>
<p>SOMETHING for OPI implementation &quot;SimHensonRT&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+opiPresent">opiPresent</a></code> is blocking in that it will not return
until either a response is obtained, or at least the responseWindow
milliseconds has expired. (Note that more time might have expired.)
Specifying <code>nextStim</code> allows the implementing machine to use the time
waiting for a response to <code>stim</code> to make preparations for the next
stimuli. (For example retargeting the projector or moving aperture and/or
filter wheels.) There is no guarantee that the next call to
<code><a href="#topic+opiPresent">opiPresent</a></code> will have <code>nextStim</code> as the first argument;
this could be checked by the machine specific implementations (but currently
is not, I think).
</p>
<p>Also note that to allow for different parameters depending on the
implementation chosen with <code>chooseOpi</code>, every parameter MUST be named in
a call to <code><a href="#topic+opiPresent">opiPresent</a></code>.
</p>


<h4>Display</h4>

<p>Present a circle of radius <code>stim$size</code> and color <code>stim$color</code>
at <code>(stim$x, stim$y)</code> for <code>stim$duration</code> ms and wait for a keyboard
or mouse response for <code>stim$responseWindow</code> ms.
</p>
<p><code>stim$size</code>, <code>sitm$x</code> and <code>stim$y</code> are in the same units
as <code>xlim</code> and <code>ylim</code> as specified in <code><a href="#topic+opiInitialise">opiInitialise</a></code>.
</p>
<p>If the chosen OPI implementation is <code>Display</code>, then <code>nextStim</code>
is ignored.
</p>
<p>Duration and response window are rounded to the nearest 5 ms.
</p>
<p>Currently only implemented for <code>opiStaticStimulus</code>.
</p>



<h4>Daydream</h4>

<p>If the chosen OPI implementation is <code>Daydream</code>, then <code>nextStim</code>
is ignored.
</p>
<p>Note that the dB level is rounded to the nearest cd/<code class="reqn">\mbox{m}^2</code>
that is in the <code>lut</code> specified in <code>opiInitialise</code>.
</p>
<p>Currently uses the most simple algorithm for drawing a 'circle'
(ie not Bresenham's).
</p>
<p>Currently only implemented for <code>opiStaticStimulus</code>.
</p>



<h4>imo</h4>

<p>DETAILS HERE
</p>



<h4>KowaAP7000</h4>

<p><code>opiPresent(stim, nextStim=NULL)</code>
</p>
<p>If the chosen OPI implementation is <code>KowaAP7000</code>, then <code>nextStim</code>
is ignored.
</p>



<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if no error occurred, otherwise a machine-specific error message.
This should include errors when the specified size cannot be achieved by
the device (for example, in a projection system with an aperture wheel of
predefined sizes.) If <code>stim</code> is <code>NULL</code>, then <code>err</code> contains
the status of the machine.
</p>
</li>
<li> <p><code>seen</code> <code>TRUE</code> if a response was detected in the allowed
<code>responseWindow</code>, <code>FALSE</code> otherwise. (Note, see
Octopus900F310 above).
</p>
</li>
<li> <p><code>time</code> The time in milliseconds from the onset (or offset,
machine-specific) of the presentation until the response from the subject
if <code>seen</code> is <code>TRUE</code>. If <code>seen</code> is <code>FALSE</code>, this value is undefined.
For kinetic perimetry on the O900, this value is unknown... (what does this mean!?)
</p>
</li></ul>



<h4>O600</h4>

<p><code>answer</code> only returned for <code>Octopus600</code>. Can be the following values:
</p>

<ul>
<li><p> 0 = stimulus not seen;
</p>
</li>
<li><p> 1 = stimulus seen;
</p>
</li>
<li><p> 132 = Response button was pressed before stimulus presentation (Patient needs a break - hold on examination);
</p>
</li>
<li><p> 36 = Eye is closed before stimulus presentation;
</p>
</li>
<li><p> 68 = Fixation lost before stimulus presentation (pupil center is out of green window in video image);
</p>
</li>
<li><p> 260 = Forehead rest lost before stimulus presentation;
</p>
</li>
<li><p> 516 = Fast Eye movements before stimulus presentation;
</p>
</li>
<li><p> 258 = Forehead rest lost during stimulus presentation;
</p>
</li>
<li><p> 66 = Fixation lost during stimulus presentation (pupil center is out of green window in video image);
</p>
</li>
<li><p> 34 = Eye was closed during stimulus presentation;
</p>
</li>
<li><p> 18 = Patient answer was too early (&lt;=100ms after stimulus presentation) - lucky punch;
</p>
</li>
<li><p> 514 = Fast Eye movements during stimulus presentation
</p>
</li></ul>




<h4>Kowa AP7000</h4>


<ul>
<li> <p><code>pupilX</code> Only returned for KowaAP7000 (in pixels) and an
opiStaticStimulus or O900 (in degrees) and static/kinetic if gazeFeed==1.
x-coordinate of centre of pupil during presentation.
</p>
</li>
<li> <p><code>pupilY</code> Only returned for KowaAP7000 (in pixels) and an
opiStaticStimulus or O900 (in degrees) and static/kinetic if gazeFeed==1.
y-coordinate of centre of pupil during presentation.
</p>
</li>
<li> <p><code>purkinjeX</code> Only returned for KowaAP7000 and an opiStaticStimulus.  x-coordinate of centre of Purkinje Image in pixels during presentation.
</p>
</li>
<li> <p><code>purkinjeY</code> Only returned for KowaAP7000 and an opiStaticStimulus.  y-coordinate of centre of Purkinje Image in pixels during presentation.
</p>
</li></ul>




<h4>Kowa AP7000 and Octopus O900</h4>


<ul>
<li> <p><code>x</code> Only returned for KowaAP7000 or Octopus900 and an opiKineticStimulus. x coordinate of stimuli when button is pressed.
</p>
</li>
<li> <p><code>y</code> Only returned for KowaAP7000 or Octopus900 and an opiKineticStimulus. y coordinate of stimuli when button is pressed.
</p>
</li></ul>




<h4>Compass</h4>


<ul>
<li> <p><code>time_rec</code> Time since epoch that the opiPresent command was received by the Compass in ms.
</p>
</li>
<li> <p><code>time_hw</code> Hardware time of button press or response window expired (integer ms).
To get the hardware time that a presentation began, subtract
responseWindow from <code>th</code> (for aligning with fixation data returned
by <code>opiClose()</code>.
</p>
</li>
<li> <p><code>time_resp</code> Time since epoch that the response was received or response window expired (in ms).
</p>
</li>
<li> <p><code>num_track_events</code> The number of tracking events associated with this presentation.
</p>
</li>
<li> <p><code>num_motor_fails</code> The number of time the motor could not keep pace with eye movements.
</p>
</li>
<li> <p><code>pupil_diam</code> The diameter of the pupil on millimeters on presentation.
</p>
</li>
<li> <p><code>loc_x</code> The x location in pixels of the presentation on the retinal image returned by <code>opiInitialize</code>.
</p>
</li>
<li> <p><code>loc_y</code> The y location in pixels of the presentation on the retinal image returned by <code>opiInitialize</code>.
</p>
</li></ul>




<h4>Compass</h4>

<p>A list containing
</p>

<ul>
<li> <p><code>err</code> 0 all clear, &gt;= 1 some error codes (eg cannot track, etc) (integer)
</p>
</li>
<li> <p><code>seen</code> <code>FALSE</code> for not seen, <code>TRUE</code> for seen (button pressed in response window)
</p>
</li>
<li> <p><code>time</code> response time in ms (integer) since stimulus onset, -1 for not seen
</p>
</li>
<li> <p><code>time_rec</code> time since epoch when command was received at Compass (integer ms)
</p>
</li>
<li> <p><code>time_pres</code> time since epoch that stimulus was presented (integer ms)
</p>
</li>
<li> <p><code>num_track_events</code> number of tracking events that occurred during presentation (integer)
</p>
</li>
<li> <p><code>num_motor_fails</code> number of times motor could not follow fixation movement during presentation (integer)
</p>
</li>
<li> <p><code>pupil_diam</code> pupil diameter in mm (float)
</p>
</li>
<li> <p><code>loc_x</code> pixels integer, location in image of presentation (integer)
</p>
</li>
<li> <p><code>loc_y</code> pixels integer, location in image of presentation (integer)
</p>
</li></ul>




<h3>Compass</h3>

<p><code>opiPresent(stim, nextStim=NULL)</code>
</p>
<p>If the chosen OPI implementation is <code>Compass</code>, then <code>nextStim</code>
is ignored. Note that the dB level is rounded to the nearest integer.
</p>
<p>If tracking is on, then this will block until the tracking is obtained,
and the stimulus presented.
</p>


<h3>Octopus600</h3>

<p><code>opiPresent(stim, nextStim=NULL)</code>
</p>
<p>If the chosen OPI implementation is <code>Octopus600</code>, then nextStim is
ignored. If <code>eyeControl</code> is non-zero, as set in <code>opiInitialize</code>,
answer codes describing patient state may arise (see <code>answer</code> field
in the Value section).
</p>


<h3>Octopus900F310</h3>

<p><code>opiPresent(stim, nextStim=NULL)</code>
</p>
<p>This functions as for the Octopus900, but responses are taken from the F310
Controller.
</p>
<p>If the L button is pressed, <code>seen</code> is set to 1.
</p>
<p>If the R button is pressed, <code>seen</code> is set to 2.
</p>
<p>If no button is pressed within <code>responseWindow</code>, then <code>seen</code> is set to 0.
</p>


<h3>PhoneHMD</h3>

<p>If the chosen OPI implementation is <code>PhoneHMD</code>, then <code>nextStim</code>
is ignored. PhonVR
</p>


<h3>SimGaussian</h3>

<p><code>opiPresent(stim, nextStim=NULL, fpr=0.03, fnr=0.01, tt=30)</code>
</p>
<p>If the chosen OPI implementation is <code>SimGaussian</code>, then the response
to a stimuli is determined by sampling from a Frequency-of-Seeing (FoS)
curve (also known as the psychometric function) with formula
<code>fpr+(1-fpr-fnr)*(1-pnorm(x, tt, simG.global.sd))</code>, where <code>x</code>
is the stimulus value in Humphrey dB, and <code>simG.global.sd</code> is
set with <code>opiInitialize</code>.
</p>


<h3>SimHenson</h3>

<p><code>opiPresent(stim, nextStim=NULL, fpr=0.03, fnr=0.01, tt=30)</code>
</p>
<p>If the chosen OPI implementation is <code>SimHenson</code>, then the response to a
stimuli is determined by sampling from a Frequency-of-Seeing (FoS) curve
(also known as the psychometric function) with formula
</p>
<p style="text-align: center;"><code class="reqn">\mbox{fpr}+(1-\mbox{fpr}-\mbox{fnr})(1-\mbox{pnorm}(x, \mbox{tt}</code>
</p>
<p>,
where <code class="reqn">x</code> is the stimulus value in Humphrey dB, and pxVar is
</p>
<p style="text-align: center;"><code class="reqn">\min\left(\mbox{simH.global.cap}, e^{A\times\mbox{tt}+B}\right).</code>
</p>

<p>The ceiling <code>simH.global.cap</code> is set with the call to
<code>opiInitialize</code>, and <code>A</code> and <code>B</code> are from Table 1 in Henson
et al (2000). Which values are used is determined by <code>simH.type</code> which
is also set in the call to <code>opiInitialize</code>.
</p>
<p>Note that if the stimulus value is less than zero, then the Henson formula
is not used. The probability of seeing is <code>fpr</code>.
</p>
<p><code>opiPresent(stim, nextStim=NULL, fpr=0.03, fnr=0.01, tt=NULL,
                   criteria=0.95, rt_shape=5.3, rt_rate=1.4, rt_scale=0.1)</code>
</p>
<p>For determinng seen/not-seen for kinetic, the first location (to a fidelity
of 0.01 degrees) on the path (it only works for single paths now) where the
probability of seeing is equal to <code>criteria</code> is found. If no such
location exists, then the stimuli is not seen. The probability of seeing at
each location is determined using a frequency-of-seeing curve defined as a
cumulative Gaussian with parameters controlled by <code>tt</code> and
<code>opiInitialize</code>. At each location along the path, the mean of the FoS
is taken from the <code>tt</code> function, which takes a distance-along-path
(in degrees) as an argument, and returns a dB value which is the static
threshold at that distance along the path.
</p>
<p>Function <code>tt</code> can return NA for not thresholds that are always not
seen. At each location along the path, the standard deviation of the FoS
is sampled from a Gaussion with mean taken from the formula of Henson et
al (2000), as parametrised by <code>opiInitialize</code>, and standard deviation
0.25.
</p>
<p>The location of a false positive response (for the total kinetic path) is
sampled uniformly from the start of the path to the 'seeing' location, or
the entire path if the stimuli is not seen.
</p>
<p>Note that the false positive rate <code>fpr</code> and the false negative rate
<code>fnr</code> are specified for the whole path, and not for the individual
static responses along the way.
</p>
<p>The actual location returned for a seen response is the location where the
probability of seeing equals <code>criteria</code>, plus a response time sampled
from a Gamma distribution parameterised by <code>rt_shape</code> and <code>rt_rate</code>
and multiplied by <code>rt_scale</code>.That is:
<code>rgamma(1, shape=rt_shape, rate=rt_rate) / rt_scale</code>.
</p>


<h3>SimHensonRT</h3>

<p><code>opiPresent(stim, nextStim=NULL, fpr=0.03, fnr=0.01, tt=30, dist=stim$level - tt)</code>
</p>
<p>For static stimuli, this function is the same as for <code>SimHenson</code>, but
reaction times are determined by sampling from <code>rtData</code> as passed to
<code>opiInitialize</code>.  The <code>dist</code> parameter is the distance of the
stimulus level from the true threshold, and should be in the same units as
the <code>Dist</code> column of <code>rtData</code>. The default is just the straight
difference between the stimulus level and the true threshold, but you might
want it scaled somehow to match <code>rtData</code>.
</p>


<h3>SimNo</h3>

<p><code>opiPresent(stim, nextStim=NULL)</code>
</p>
<p>If the chosen OPI implementation is <code>SimNo</code>, then the response to a
stimuli is always no, hence <code><a href="#topic+opiPresent">opiPresent</a></code> always returns
<code>err=NULL</code>, <code>seen=FALSE</code>, and <code>time=0</code>.
</p>


<h3>SimYes</h3>

<p><code>opiPresent(stim, nextStim=NULL)</code>
</p>
<p>If the chosen OPI implementation is <code>SimYes</code>, then the response to a
stimuli is always yes, hence <code><a href="#topic+opiPresent">opiPresent</a></code> always returns
<code>err=NULL</code>, <code>seen=TRUE</code>, and <code>time=0</code>.
</p>


<h3>References</h3>

<p>David B. Henson, Shaila Chaudry, Paul H. Artes, E. Brian Faragher, and
Alec Ansons. Response Variability in the Visual Field: Comparison of Optic
Neuritis, Glaucoma, Ocular Hypertension, and Normal Eyes. Investigative
Ophthalmology &amp; Visual Science, February 2000, Vol. 41(2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opiStaticStimulus">opiStaticStimulus</a></code>, <code><a href="#topic+opiKineticStimulus">opiKineticStimulus</a></code>,
<code><a href="#topic+opiTemporalStimulus">opiTemporalStimulus</a></code>, <code><a href="#topic+chooseOpi">chooseOpi</a></code>,
<code><a href="#topic+opiInitialize">opiInitialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Display a spot
 chooseOpi("Display")
 if(!is.null(opiInitialize(width = 1680, height = 1050, ppi = 128, viewdist = 25)))
   stop("opiInitialize failed")
 opiSetBackground(lum = 50, color = "white", fixation = "Cross")

 makeStim &lt;- function(db) {
   s &lt;- list(x = 9, y = 9, level = dbTocd(db, 400), size = 1.72, color = "white",
             duration = 1000, responseWindow = 1000)
   class(s) &lt;- "opiStaticStimulus"
   return(s)
 }
 result &lt;- opiPresent(makeStim(0))

 opiClose()

## End(Not run)
# Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(db, 10000/pi), size=0.43, color="white",
            duration=200, responseWindow=1500)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}

chooseOpi("SimHenson")
if (!is.null(opiInitialize(type="C", cap=6)))
  stop("opiInitialize failed")

result &lt;- opiPresent(stim=makeStim(10,0), tt=30, fpr=0.15, fnr=0.01)

# Will not work as 'stim' is not named
#result &lt;- opiPresent(makeStim(10,0), tt=30, fpr=0.15, fnr=0.01)

if (!is.null(opiClose()))
  warning("opiClose() failed")
# Same but with simulated reaction times
chooseOpi("SimHensonRT")
data(RtSigmaUnits)
if (!is.null(opiInitialize(type="C", cap=6, rtData=RtSigmaUnits)))
  stop("opiInitialize failed")

dist &lt;- (10 - 30)/min(exp(-0.098 * 30 + 3.62), 6)
result &lt;- opiPresent(stim=makeStim(10,0), tt=30, fpr=0.15, fnr=0.01, dist=dist)

if (!is.null(opiClose()))
  warning("opiClose() failed")
</code></pre>

<hr>
<h2 id='opiQueryDevice'>Query device using OPI</h2><span id='topic+opiQueryDevice'></span><span id='topic+compass.opiQueryDevice'></span><span id='topic+display.opiQueryDevice'></span><span id='topic+daydream.opiQueryDevice'></span><span id='topic+imo.opiQueryDevice'></span><span id='topic+kowaAP7000.opiQueryDevice'></span><span id='topic+octo600.opiQueryDevice'></span><span id='topic+octo900.opiQueryDevice'></span><span id='topic+PhoneHMD.opiQueryDevice'></span><span id='topic+simG.opiQueryDevice'></span>

<h3>Description</h3>

<p>Generic function for getting details of the chosen OPI
implementation that is set with <code>chooseOpi()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiQueryDevice(...)

compass.opiQueryDevice()

display.opiQueryDevice()

daydream.opiQueryDevice()

imo.opiQueryDevice()

kowaAP7000.opiQueryDevice()

octo600.opiQueryDevice()

octo900.opiQueryDevice()

PhoneHMD.opiQueryDevice()

simG.opiQueryDevice()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiQueryDevice_+3A_...">...</code></td>
<td>
<p>Implementation specific parameters. See details.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Compass</h4>

<p>Return a list of all the constants used in the OPI Compass module.
</p>



<h4>Display</h4>

<p>Returns all constants in <code>.OpiEnv$Display</code> as a list.
</p>



<h4>Display</h4>

<p>Returns values in use by Display.
</p>



<h4>Daydream</h4>

<p>Returns all constants in <code>.OpiEnv$DayDream</code> as a list.
</p>



<h4>Daydream</h4>

<p>DETAILS
</p>



<h3>Value</h3>

<p>Returns a list that contains <code>isSim</code> and implementation-dependent
data.
</p>
<p><code>isSim</code> is <code>TRUE</code> if the device is a simulation, or <code>FALSE</code> if
the device is a physical machine.
</p>


<h4>Compass</h4>

<p>A list containing constants and their valuse used in the OPI Compass module.
</p>



<h4>Octopus600</h4>

<p>Returns a list of 10 items:
* <code>answerButton</code> {0 = not pressed, 1 = pressed }
* <code>headSensor</code> {0 = no forehead detected, 1 = forehead detected }
* <code>eyeLidClosureLeft</code> {0 = eye is open, 1 = eye is closed}
* <code>eyeLidClosureRight</code> {0 = eye is open, 1 = eye is closed}
* <code>fixationLostLeft</code> {1 = eye pos lost, 0 = eye pos ok}
* <code>fixationLostRight</code> {1 = eye pos lost, 0 = eye pos ok}
* <code>pupilPositionXLeft</code> (in px)
* <code>pupilPositionYLeft</code> (in px)
* <code>pupilPositionXRight</code> (in px)
* <code>pupilPositionYRight</code> (in px)
</p>



<h4>Octopus900</h4>

<p>list containing <code>isSim=FALSE</code>.
</p>



<h3>KowaAP7000</h3>

<p>If the chosen OPI is <code>KowaAP7000</code>, then this function returns the current
location of the pupil. See the Value section for details.
</p>
<p>Returns a list of 4 items:
</p>

<ul>
<li> <p><code>pupilX</code>, the x-coordinate of the pupil position in pixels.
</p>
</li>
<li> <p><code>pupilY</code>, the y-coordinate of the pupil position in pixels.
</p>
</li>
<li> <p><code>purkinjeX</code>, the x-coordinate of the purkinje position in pixels.
</p>
</li>
<li> <p><code>purkinjeY</code>, the y-coordinate of the purkinje position in pixels.
</p>
</li></ul>

<p>It also prints a list of constants that OPI knows about for the AP-7000.
</p>


<h3>Octopus600</h3>

<p>If the chosen OPI is <code>Octopus600</code>, then this function returns
information about the patient. See the Value section for details.
</p>


<h3>Octopus900</h3>

<p>Prints defined constants in OPI package pertaining to Octopus 900.
</p>


<h3>PhoneHMD</h3>

<p>Returns all constants in <code>.OpiEnv$PhoneHMD</code> as a list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseOpi">chooseOpi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("SimGaussian")
if (!is.null(opiInitialize(sd=2)))
  stop("opiInitialize failed")
print(opiQueryDevice())
</code></pre>

<hr>
<h2 id='opiSetBackground'>Set background using OPI</h2><span id='topic+opiSetBackground'></span><span id='topic+compass.opiSetBackground'></span><span id='topic+display.opiSetBackground'></span><span id='topic+daydream.opiSetBackground'></span><span id='topic+imo.opiSetBackground'></span><span id='topic+kowaAP7000.opiSetBackground'></span><span id='topic+octo600.opiSetBackground'></span><span id='topic+octo900.opiSetBackground'></span><span id='topic+PhoneHMD.opiSetBackground'></span><span id='topic+simG.opiSetBackground'></span><span id='topic+simH.opiSetBackground'></span><span id='topic+simH_RT.opiSetBackground'></span><span id='topic+simNo.opiSetBackground'></span><span id='topic+simYes.opiSetBackground'></span>

<h3>Description</h3>

<p>Generic function for setting background of the chosen OPI
implementation that is set with <code>chooseOpi()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiSetBackground(...)

compass.opiSetBackground(lum = NA, color = NA, fixation = NA, tracking_on = NA)

display.opiSetBackground(
  lum = .OpiEnv$Display$background_lum,
  color = .OpiEnv$Display$background_color,
  fixation = .OpiEnv$Display$fixation,
  fix_cx = .OpiEnv$Display$fix_cx,
  fix_cy = .OpiEnv$Display$fix_cy,
  fix_sx = .OpiEnv$Display$fix_sx,
  fix_sy = .OpiEnv$Display$fix_sy,
  fix_color = .OpiEnv$Display$fix_color
)

daydream.opiSetBackground(
  eye,
  lum = 10,
  color = "white",
  fixation = "None",
  fix_cx = 0,
  fix_cy = 0,
  fix_sx = 2,
  fix_sy = 2,
  fix_color = "green"
)

imo.opiSetBackground(
  bgl = 30,
  tgl = 1,
  tgldb = 25,
  tglx = 0,
  tgly = 0,
  bgr = 30,
  tgr = 1,
  tgrdb = 25,
  tgrx = 0,
  tgry = 0
)

kowaAP7000.opiSetBackground(lum = NA, color = NA, fixation = NA)

octo600.opiSetBackground(
  bgColor = NA,
  fixType = NA,
  fixColor = NA,
  fixIntensity = 255
)

octo900.opiSetBackground(
  lum = NA,
  color = NA,
  fixation = NA,
  fixIntensity = NA
)

PhoneHMD.opiSetBackground(
  bgeye,
  bglum = 10,
  bgcol = "white",
  fixeye,
  fixtype = "none",
  fixcx = 0,
  fixcy = 0,
  fixsx = 2,
  fixsy = 2,
  fixtheta = 0,
  fixlum = 100,
  fixcol = "green"
)

simG.opiSetBackground(col, gridCol)

simH.opiSetBackground(col, gridCol)

simH_RT.opiSetBackground(col, gridCol)

simNo.opiSetBackground(col, gridCol)

simYes.opiSetBackground(col, gridCol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetBackground_+3A_...">...</code></td>
<td>
<p>Implementation specific parameters. See details.</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_lum">lum</code></td>
<td>
<p>Luminance level in cd/m^2</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_color">color</code></td>
<td>
<p>Stimulus color</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixation">fixation</code></td>
<td>
<p>fixation target</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tracking_on">tracking_on</code></td>
<td>
<p><code>TRUE</code> for tracking on, <code>FALSE</code> for off</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fix_cx">fix_cx</code></td>
<td>
<p>fixation x position in degrees of visual angle. Default is 0</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fix_cy">fix_cy</code></td>
<td>
<p>fixation y position in degrees of visual angle. Default is 0</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fix_sx">fix_sx</code></td>
<td>
<p>fixation horizontal size in degrees of visual angle. Default is 1</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fix_sy">fix_sy</code></td>
<td>
<p>fixation vertical size in degrees of visual angle. Default is 1</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fix_color">fix_color</code></td>
<td>
<p>fixation color</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_eye">eye</code></td>
<td>
<p>eye</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_bgl">bgl</code></td>
<td>
<p>left eye background luminance in dB Default is 25</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tgl">tgl</code></td>
<td>
<p>left eye fixation target. Default is 1</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tgldb">tgldb</code></td>
<td>
<p>left eye fixation target luminance in dB. Default is 20</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tglx">tglx</code></td>
<td>
<p>left eye fixation target x-position in degrees. Default is 0.</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tgly">tgly</code></td>
<td>
<p>left eye fixation target y-position in degrees. Default is 0.</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_bgr">bgr</code></td>
<td>
<p>right eye background luminance in dB. Default is 25</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tgr">tgr</code></td>
<td>
<p>right eye target type. Default is 1</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tgrdb">tgrdb</code></td>
<td>
<p>right eye target luminance in dB. Default is 20</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tgrx">tgrx</code></td>
<td>
<p>right eye fixation target x-position in degrees. Default is 0.</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_tgry">tgry</code></td>
<td>
<p>right eye fixation target y-position in degrees. Default is 0.</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_bgcolor">bgColor</code></td>
<td>
<p>Background color</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixtype">fixType</code></td>
<td>
<p>fixation type</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixcolor">fixColor</code></td>
<td>
<p>fixation color</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixintensity">fixIntensity</code></td>
<td>
<p>fixation point intensity</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_bgeye">bgeye</code></td>
<td>
<p>eye where to display the background, can be left, right, or both</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_bglum">bglum</code></td>
<td>
<p>background luminance</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_bgcol">bgcol</code></td>
<td>
<p>background color. Either a color name that R can understand
or a vector with R, G, B, and alpha channels</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixeye">fixeye</code></td>
<td>
<p>eye for the fixation target, can be left, right, or both</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixtype">fixtype</code></td>
<td>
<p>the target of the fixation</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixcx">fixcx</code></td>
<td>
<p>fixation x position in degrees of visual angle. Default is 0</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixcy">fixcy</code></td>
<td>
<p>fixation y position in degrees of visual angle. Default is 0</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixsx">fixsx</code></td>
<td>
<p>fixation horizontal size in degrees of visual angle. Default is 1</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixsy">fixsy</code></td>
<td>
<p>fixation vertical size in degrees of visual angle. Default is 1</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixtheta">fixtheta</code></td>
<td>
<p>angle of rotation of the fixation targert in degrees. Default is 0</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixlum">fixlum</code></td>
<td>
<p>fixation luminance</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_fixcol">fixcol</code></td>
<td>
<p>fixation color. Same specifications as background color</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_col">col</code></td>
<td>
<p>DESCRIPTION for OPI implementations based on simulations</p>
</td></tr>
<tr><td><code id="opiSetBackground_+3A_gridcol">gridCol</code></td>
<td>
<p>DESCRIPTION for OPI implementation based on simulations</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Compass</h4>

<p><code>opiSetBackground(fixation=NA, tracking_on=NA)</code>
</p>

<ul>
<li><p><code>fixation</code>=c(x,y,t) where
</p>

<ul>
<li><p><code>x</code> is one of -20, -6, -3, 0, 3, 6, 20 degrees.
</p>
</li>
<li><p><code>y</code> is 0 degrees.
</p>
</li>
<li><p><code>t</code> is 0 for a spot fixation marker at <code>c(x,y)</code>, or 1 for a
square centred on one of <code>(-3,0)</code>, <code>(0,0)</code>, <code>(+3,0)</code>.
</p>
</li></ul>

</li>
<li><p><code>tracking_on</code> is either 0 (tracking off) or 1 (tracking on).
</p>
</li></ul>

<p>Note: tracking will be relative to the PRL established with the fixation
marker used at setup (call to OPI-OPEN), so when tracking is on you should
use the same fixation location as in the setup.
</p>



<h4>imo</h4>

<p>DETAILS
</p>



<h3>Value</h3>

<p>Returns NULL if succeeded, otherwise an implementation-dependent
error as follows.
</p>


<h4>Compass</h4>

<p>A list contining <code>error</code> which is <code>NULL</code> for success, or some string description for fail.
</p>



<h4>Display</h4>

<p>Changes the background and the fixation marker.
</p>



<h4>Daydream</h4>

<p>Returns NULL or an error string.
</p>



<h4>imo</h4>

<p>DETAILS
</p>



<h4>KowaAP7000</h4>

<p>Always returns NULL
</p>



<h4>Octopus600</h4>


<ul>
<li><p> -1 to be implemented
</p>
</li>
<li><p> -2 O600 sent back an error; bad background parameters
</p>
</li>
<li><p> -3 O600 sent back an error; bad fixation parameters
</p>
</li>
<li><p> NULL Success
</p>
</li></ul>




<h4>Octopus900</h4>


<ul>
<li><p> -1 indicates <code>opiInitialize</code> has not been called.
</p>
</li>
<li><p> -2 indicates could not set the background color.
</p>
</li>
<li><p> -3 indicates could not set the fixation marker.
</p>
</li>
<li><p> -4 indicates that all input parameters were NA.
</p>
</li></ul>




<h4>PhoneHMD</h4>

<p>Sets background for left, right, or both eyes in PhoneHMD.
</p>



<h3>Display</h3>

<p><code>opiSetBackground(TODO)</code>
</p>


<h3>Daydream</h3>

<p><code>opiSetBackground(eye, lum=10, color="white", fixation="Cross", fix_cx=0, fix_cy=0, fix_sx=2, fix_sy=2, fix_lum=10, fix_color="green")</code>
</p>

<ul>
<li> <p><code>lum</code> background luminance in cd/<code class="reqn">\mbox{m}^2</code> is set to nearest grey value in <code>lut</code> from <code>opiInitialize</code>. Default is 10 cd/<code class="reqn">\mbox{m}^2</code>
</p>
</li>
<li> <p><code>color</code> color of the background. It can be <code>'white'</code> (default) or <code>'green'</code>.
</p>
</li>
<li> <p><code>fixation</code> can only be <code>'Cross'</code> at the moment.
</p>
</li>
<li> <p><code>fix_cx</code>, <code>fix_cy</code> fixation (x, y) position in degrees of visual angle.
</p>
</li>
<li> <p><code>fix_sx</code>, <code>fix_sy</code> dimensions of fixation target in degrees of visual angle.
</p>
</li>
<li> <p><code>fix_lum</code> luminance of the fixation target in cd/<code class="reqn">\mbox{m}^2</code> is set to nearest grey value in <code>lut</code> from <code>opiInitialize</code>. Default is 15 cd/<code class="reqn">\mbox{m}^2</code>.
</p>
</li>
<li> <p><code>fix_color</code> color of the fixation target. It can be <code>'white'</code> or <code>'green'</code> (default).
</p>
</li></ul>



<h3>KowaAP7000</h3>

<p><code>opiSetBackground(lum, color, fixation)</code>
</p>
<p><code>lum</code> and <code>color</code> are dependant for the Kowa AP-7000. A white
background must be 10 cd/<code class="reqn">\mbox{m}^2</code>, and a yellow background must
be 100 cd/<code class="reqn">\mbox{m}^2</code>.
</p>
<p>If <code>lum</code> is 10 and <code>color</code> is not set, then
<code>.OpiEnv$KowaAP7000$BACKGROUND_WHITE</code> is assumed.
</p>
<p>If <code>lum</code> is 100 and <code>color</code> is not set,
then <code>.OpiEnv$KowaAP7000$BACKGROUND_YELLOW</code> is assumed.
</p>
<p>If both <code>lum</code> and <code>color</code> is set, then <code>lum</code> is ignored
(a warning will be generated
</p>
<p>if <code>lum</code> is incompatible with <code>color</code>).
</p>
<p><code>fixation</code> is one of
* <code>.OpiEnv$KowaAP7000$FIX_CENTER</code>, fixation marker in the centre.
* <code>.OpiEnv$KowaAP7000$FIX_CENTRE</code>, fixation marker in the centre.
* <code>.OpiEnv$KowaAP7000$FIX_AUX</code>,    fixation marker is ???.
* <code>.OpiEnv$KowaAP7000$FIX_MACULA</code>, fixation marker is a circle(?).
* <code>.OpiEnv$KowaAP7000$FIX_AUX_LEFT</code>, fixation marker is as for AUX but only lower left.
</p>


<h3>Octopus600</h3>

<p>This function has no effect.
</p>


<h3>Octopus900</h3>

<p><code>opiSetBackground(lum=NA, color=NA, fixation=NA, fixIntensity=NA)</code>
</p>
<p><code>lum</code> is intensity of the background and can be one of
*  <code>.OpiEnv$O900$BG_OFF</code>, which turns background off.
*  <code>.OpiEnv$O900$BG_1</code>, background of 1.27 cd/<code class="reqn">\mbox{m}^2</code>.
*  <code>.OpiEnv$O900$BG_10</code>, background of 10 cd/<code class="reqn">\mbox{m}^2</code>.
*  <code>.OpiEnv$O900$BG_100</code>, background of 100 cd/<code class="reqn">\mbox{m}^2</code>.
</p>
<p><code>color</code> can be one of the following choices.
* <code>.OpiEnv$O900$MET_COL_WW</code> for white-on-white
* <code>.OpiEnv$O900$MET_COL_RW</code> for red-on-white
* <code>.OpiEnv$O900$MET_COL_BW</code> for blue-on-white
* <code>.OpiEnv$O900$MET_COL_WY</code> for white-on-yellow
* <code>.OpiEnv$O900$MET_COL_RY</code> for red-on-yellow
* <code>.OpiEnv$O900$MET_COL_BY</code> for blue-on-yellow
</p>
<p><code>fixation</code> is one of
* <code>.OpiEnv$O900$FIX_CENTRE</code> or <code>.OpiEnv$O900$FIX_CENTER</code>
* <code>.OpiEnv$O900$FIX_CROSS</code>
* <code>.OpiEnv$O900$FIX_RING</code>
</p>
<div class="sourceCode"><pre>\code{fixIntensity} is a percentage between 0 and 100. 0 is off, 100 the brightest.
</pre></div>
<p>Note if you specify <code>fixation</code> you also have to specify <code>fixIntensity</code>.
</p>


<h3>PhoneHMD</h3>

<p><code>opiSetBackground(bgeye, bglum = 10, bgcol = "white", fixeye = eye, fixtype = "Cross", fixlum = 100, fixcol = "green", fixcx = 0, fixcy = 0, fixsx = 2, fix_sy = 2)</code>
</p>

<ul>
<li> <p><code>bgeye</code> eye for the background. Can be &quot;R&quot;, &quot;L&quot;, or &quot;B&quot; for right, left, or both
</p>
</li>
<li> <p><code>bglum</code> background luminance in cd/<code class="reqn">\mbox{m}^2</code> is set to nearest grey value in <code>lut</code> from <code>opiInitialize</code>. Default is 10 cd/<code class="reqn">\mbox{m}^2</code>
</p>
</li>
<li> <p><code>bgcol</code> color of the background. Default is white
</p>
</li>
<li> <p><code>fixeye</code> eye for the background. Takes the same values as <code>eye</code> (default)
</p>
</li>
<li> <p><code>fixtype</code> fixation target
</p>
</li>
<li> <p><code>fixcx</code>, <code>fixcy</code> fixation (x, y) position in degrees of visual angle
</p>
</li>
<li> <p><code>fixsx</code>, <code>fixsy</code> dimensions of fixation target in degrees of visual angle
</p>
</li>
<li> <p><code>fixtheta</code> angle of rotation of the fixation target
</p>
</li>
<li> <p><code>fixlum</code> luminance of the fixation target. Default is 100 cd/<code class="reqn">\mbox{m}^2</code>
</p>
</li>
<li> <p><code>fixcol</code> color of the fixation target. Default is green
</p>
</li></ul>



<h3>SimGaussian</h3>

<p><code>opiSetBackground(col, gridCol)</code>
</p>
<p><code>col</code> is the background color of the plot area used for displaying
stimuli, and <code>gridCol</code> the color of the gridlines. Note the plot area
will only be displayed if <code>opiInitialize</code> is called with a valid display
argument.
</p>


<h3>SimHenson</h3>

<p><code>opiSetBackground(col, gridCol)</code>
</p>
<p><code>col</code> is the background color of the plot area used for displaying
stimuli, and <code>gridCol</code> the color of the gridlines. Note the plot area
will only be displayed if <code>opiInitialize</code> is called with a valid display
argument.
</p>


<h3>SimHensonRT</h3>

<p><code>opiSetBackground(col, gridCol)</code>
</p>
<p><code>col</code> is the background color of the plot area used for displaying
stimuli, and <code>gridCol</code> the color of the gridlines. Note the plot area
will only be displayed if <code>opiInitialize</code> is called with a valid display
argument.
</p>


<h3>SimNo</h3>

<p>DETAILS
</p>


<h3>SimYes</h3>

<p>DETAILS
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseOpi">chooseOpi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Set up a Display and wait for a key press in it.
  chooseOpi("Display")
  if (!is.null(opiInitialize(width = 1680, height = 1050, ppi = 128, viewdist = 25)))
    stop("opiInitialize failed")

  opiSetBackground()
  opiSetBackground(lum = 100, color = "white", fixation = "Circle")
  opiSetBackground(lum = 100, color = "white", fixation = "Cross", fix_color = "red",
                   fix_cx = 2, fix_cy = 5, fix_sx = 1, fix_sy = 2)
  opiClose()

## End(Not run)
## Not run: 
  chooseOpi("Octopus900")
  oi &lt;- opiInitialize(eyeSuiteJarLocation="c:/EyeSuite/",
                      eyeSuiteSettingsLocation="c:/Documents and Settings/All Users/Haag-Streit/",
                      eye="left")
  if(!is.null(oi))
    stop("opiInitialize failed")
  if(!is.null(opiSetBackground(fixation=.OpiEnv$O900$FIX_CENTRE)))
    stop("opiSetBackground failed")
  if(!is.null(opiSetBackground(fixation=.OpiEnv$O900$FIX_RING, fixIntensity=0)))
    stop("opiSetBackground failed")
  if(!is.null(opiSetBackground(color=.OpiEnv$O900$MET_COL_BY)))
    stop("opiSetBackground failed")
  if(!is.null(opiSetBackground(lum=.OpiEnv$O900$BG_100, color=.OpiEnv$O900$MET_COL_RW)))
    stop("opiSetBackground failed")
  opiClose()

## End(Not run)
chooseOpi("SimGaussian")
if (!is.null(opiInitialize(sd=2)))
  stop("opiInitialize failed")
if (!is.null(opiSetBackground(col="white",gridCol="grey")))
  stop("opiSetBackground failed, which is very surprising!")
</code></pre>

<hr>
<h2 id='opiStaticStimulus'>Stimulus parameter list</h2><span id='topic+opiStaticStimulus'></span>

<h3>Description</h3>

<p>List containing stimulus parameters with an S3 class attribute
of <code>opiStaticStimulus</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"See details"
</code></pre>


<h3>Details</h3>

<p>The list should be of class opiStaticStimulus and contain the following elements.
</p>

<ul>
<li> <p><code>x</code> coordinate of the center of stimulus in degrees relative to fixation
</p>
</li>
<li> <p><code>y</code> coordinate of the center of stimulus in degrees relative to fixation
</p>
</li>
<li> <p><code>image</code> an image to display in a machine specific format
</p>
</li>
<li> <p><code>level</code> stimulus level in cd/<code class="reqn">\mbox{m}^2</code> (ignored if !is.na(image))
</p>
</li>
<li> <p><code>size</code> diameter of target in degrees, or scaling factor for image if specified
</p>
</li>
<li> <p><code>color</code> machine specific stimulus color settings (ignored if !is.na(image))
</p>
</li>
<li> <p><code>duration</code> total stimulus duration in milliseconds maximum <code>responseWindow</code> time (&gt;= 0) in milliseconds to wait for a response from the onset of the stimulus presentation
</p>
</li>
<li> <p><code>...</code> machine-specific parameters
</p>
</li></ul>



<h3>SimHenson and SimGaussian</h3>

<p>Only <code>level</code> is used.
</p>
<p>Duration and location are ignored, <code>color</code> is assumed &quot;white&quot; and
<code>size</code> is assumed to be 26/60 (Goldmann III).
</p>


<h3>Octopus 900</h3>

<p><code>x</code> and <code>y</code> are in degrees, with precision to one decimal place recognised.
</p>
<p><code>image</code> is not possible on an Octopus 900.
</p>
<p><code>level</code> is in cd/<code class="reqn">\mbox{m}^2</code>, and is rounded to the nearest one
tenth of a dB for display.
</p>
<p><code>color</code> is ignored. Use <code>opiSetBackground()</code> to alter stimulus color
</p>
<p><code>checkFixationOK</code> is a function that takes the return value from
<code>opiPresent</code>  and returns either <code>TRUE</code>, indicating that fixation
was good for the presentation; or <code>FALSE</code>, indicating that fixation
was not good for the presentation.
</p>


<h3>Octopus 900 F310 Controller</h3>

<p>As for the Octopus 900, but a <code>responseWindow</code> of -1 means that the
Octopus 900 server will wait until either the L and R button is pressed in the
controller until returning.
</p>


<h3>Kowa AP7000</h3>

<p><code>x</code> and <code>y</code> are in degrees. (precision?)
</p>
<p><code>image</code> is not possible on an Kowa AP 7000.
</p>
<p><code>level</code> are in cd/<code class="reqn">\mbox{m}^2</code> in the range 0.03 to 3183,
nearest one tenth of a dB for display.
</p>
<p><code>size</code> is in degrees, but is rounded to the nearest Goldmann Size I..V
for display.
</p>
<p><code>color</code> one of <code>.OpiEnv$KowaAP7000$COLOR_WHITE</code>,
<code>.OpiEnv$KowaAP7000$COLOR_GREEN</code>, <code>.OpiEnv$KowaAP7000$COLOR_BLUE</code>, and
<code>.OpiEnv$KowaAP7000$COLOR_RED</code>.
</p>


<h3>imo</h3>

<p><code>x</code>, <code>y</code>, <code>level</code>, <code>size</code>, and <code>color</code> are not used.
</p>
<p><code>image</code> is a list of two matrices: the first for the right eye, the
second for the left. Each image is a 1080x1080 matrix with each element in
the range 0 to 80, which maps onto 0dB to 40dB in steps of 0.5dB. Thus 0 is
0dB, 3283.048 cd/<code class="reqn">\mbox{m}^2</code>; 1 is 0.5dB; and 80 is 40dB, 10 cd/<code class="reqn">\mbox{m}^2</code>.
</p>
<p><code>tracking</code> is <code>TRUE</code> if auto image placement to keep pupil centred is
used, or <code>FALSE</code> to turn off imo auto-image placement to keep centred
on pupil.
</p>


<h3>Compass</h3>

<p><code>x</code> and <code>y</code> are in degrees (floating point) (range -30 to 30 inclusive).
</p>
<p><code>level</code> is in cd/<code class="reqn">\mbox{m}^2</code>, and is rounded to the nearest
whole dB for display (range 0 to 50). 0dB is 10000aps.
</p>
<p><code>responseWindow</code> is in millliseconds (range 0 to 2680). Parameter
<code>duration</code> is assumed to be 200ms, <code>size</code> is assumed to be
Goldmann III (0.43),  and <code>color</code> is assumed to be white.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opiSetBackground">opiSetBackground</a></code>, <code><a href="#topic+opiKineticStimulus">opiKineticStimulus</a></code>,
<code><a href="#topic+opiTemporalStimulus">opiTemporalStimulus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stim &lt;- list(x=9, y=9, image=NA, 314, size=0.43, color="white",
             duration=200, responseWindow=1500)
class(stim) &lt;- "opiStaticStimulus"
</code></pre>

<hr>
<h2 id='opiTemporalStimulus'>Stimulus parameter list</h2><span id='topic+opiTemporalStimulus'></span>

<h3>Description</h3>

<p>List containing stimulus parameters with an S3 class attribute
of <code>opiTemporalStimulus</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"See details"
</code></pre>


<h3>Details</h3>

<p>The list should be of class opiTemporalStimulus and contain the
following elements.
</p>

<ul>
<li> <p><code>x</code> coordinate of the center of stimulus in degrees relative to fixation
</p>
</li>
<li> <p><code>y</code> coordinate of the center of stimulus in degrees relative to fixation
</p>
</li>
<li> <p><code>image</code> an image to display in a machine specific format
</p>
</li>
<li> <p><code>lut</code> if <code>is.na(image)</code> then this is a lookup table (vector) for stimulus level at
each step of rate Hz in cd/<code class="reqn">\mbox{m}^2</code>. If image is specified, then
this is a list of images, in the same format as image, that is stepped through at
rate Hz.
</p>
</li>
<li> <p><code>size</code> diameter of target in degrees, or scaling factor for
image if specified
</p>
</li>
<li> <p><code>color</code> machine specific stimulus color settings (ignored if <code>!is.na(image)</code>)
</p>
</li>
<li> <p><code>rate</code> frequency with which lut is processed in Hz
</p>
</li>
<li> <p><code>duration</code>total length of stimulus flash in milliseconds. There is no
guarantee that <code>duration %% length(lut)/rate == 0</code>. That is, the
onus is on the user to ensure the duration is a multiple of the period of the
stimuli.
</p>
</li>
<li> <p><code>responseWindow</code> maximum time (&gt;= 0) in milliseconds to wait for a
response from the onset of the stimulus presentation
</p>
</li>
<li> <p><code>...</code> machine specific parameters
</p>
</li></ul>



<h3>Octopus 900</h3>

<p><code>x</code> and <code>y</code> are in degrees, with precision to one decimal place
recognised.
</p>
<p><code>image</code> is not possible on an Octopus 900.
</p>
<p><code>lut</code> is not possible on an Octopus 900. Stimulus is at 0 dB.
</p>
<p><code>rate</code> is in Hz, with precision to one decimal place recognised.
</p>
<p><code>color</code> is ignored. Use <code>opiSetBackground()</code> to alter stimulus color.
</p>


<h3>Kowa AP7000</h3>

<p>Not supported.
</p>


<h3>Compass</h3>

<p>Not implemented.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opiSetBackground">opiSetBackground</a></code>, <code><a href="#topic+opiStaticStimulus">opiStaticStimulus</a></code>,
<code><a href="#topic+opiKineticStimulus">opiKineticStimulus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A Size III flickering with a 10Hz square wave at location (7,7) with luminance
# 10 dB (HFA) 
stim &lt;- list(x=7, y=7, size=0.43, color="white",
             rate=20,        # one lut step per 50 ms
             lut=c(0,318),   # so one full lut per 100 ms == 10Hz
             duration=400,   # and 4 cycles per stimulus
             responseWindow=1500)
class(stim) &lt;- "opiTemporalStimulus"
</code></pre>

<hr>
<h2 id='pixTodeg'>Convert pixels to degrees for machine 'machine'</h2><span id='topic+pixTodeg'></span>

<h3>Description</h3>

<p>Convert pixels to degrees for machine 'machine'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixTodeg(xy, machine = "compass")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixTodeg_+3A_xy">xy</code></td>
<td>
<p>a 2 element vector c(x,y) where x and y are in pixels</p>
</td></tr>
<tr><td><code id="pixTodeg_+3A_machine">machine</code></td>
<td>
<p>&quot;compass&quot; or ...?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xy converted to degrees of visual field with the usual conventions or <code>NA</code> if machine is unknown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pixTodeg(c(1000, 200), machine="compass") # c(1.290323, 24.516129) degrees
pixTodeg(c(1920/2, 1920/2)) # c(0,0) degrees
</code></pre>

<hr>
<h2 id='QUESTP'>QUEST+</h2><span id='topic+QUESTP'></span><span id='topic+QUESTP.Prior'></span><span id='topic+QUESTP.Likelihood'></span><span id='topic+QUESTP.start'></span><span id='topic+getTargetStim'></span><span id='topic+QUESTP.step'></span><span id='topic+QUESTP.stop'></span><span id='topic+QUESTP.final'></span><span id='topic+QUESTP.stdev'></span><span id='topic+QUESTP.entropy'></span>

<h3>Description</h3>

<p>An implementation of the Bayesian test procedure QUEST+ by AB Watson.
This is mostly a translation of the MATLAB implementation by P Jones (see References).
Its use is similar to ZEST. The objective is to estimate parameters of a function
that defines the probability of responding stimuli. The steps are optimized based on entropy rather than
the mean or the mode of the current pdfs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QUESTP(
  Fun,
  stimDomain,
  paramDomain,
  likelihoods = NULL,
  priors = NULL,
  stopType = "H",
  stopValue = 4,
  maxSeenLimit = 2,
  minNotSeenLimit = 2,
  minPresentations = 1,
  maxPresentations = 100,
  minInterStimInterval = NA,
  maxInterStimInterval = NA,
  verbose = 0,
  makeStim,
  ...
)

QUESTP.Prior(state, priors = NULL)

QUESTP.Likelihood(state)

QUESTP.start(
  Fun,
  stimDomain,
  paramDomain,
  likelihoods = NULL,
  priors = NULL,
  stopType = "H",
  stopValue = 4,
  maxSeenLimit = 2,
  minNotSeenLimit = 2,
  minPresentations = 1,
  maxPresentations = 100,
  makeStim,
  ...
)

getTargetStim(state)

QUESTP.step(state, nextStim = NULL)

QUESTP.stop(state)

QUESTP.final(state, Choice = "mean")

QUESTP.stdev(state, WhichP = NULL)

QUESTP.entropy(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QUESTP_+3A_fun">Fun</code></td>
<td>
<p>Function to be evaluated, of the form <code>pseen = function(stim, param){...}</code>. Outputs a probability of seen.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_stimdomain">stimDomain</code></td>
<td>
<p>Domain of values for the stimulus. Can be multi-dimensional (list, one element per dimension)</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_paramdomain">paramDomain</code></td>
<td>
<p>Domain of values for pdfs of the parameters in Fun. Can be multi-parametric (list, one element per parameter).</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_likelihoods">likelihoods</code></td>
<td>
<p>Pre-computed likelihoods if available (for QUESTP.start)</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_priors">priors</code></td>
<td>
<p>Starting probability distributions for the parameter domains (list, one element per parameter)</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_stoptype">stopType</code></td>
<td>
<p><code>N</code>, for number of presentations; <code>S</code>, for standard deviation
of the pdf; and <code>H</code>, for the entropy  of the pdf (default).</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_stopvalue">stopValue</code></td>
<td>
<p>Value for number of presentations (<code>stopType=N</code>), standard deviation
(<code>stopType=S)</code> or Entropy (<code>stopType=H</code>).</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_maxseenlimit">maxSeenLimit</code></td>
<td>
<p>Will terminate if <code>maxStimulus</code> value is seen this many times.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_minnotseenlimit">minNotSeenLimit</code></td>
<td>
<p>Will terminate if <code>minStimulus</code> value is not seen this many times.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_minpresentations">minPresentations</code></td>
<td>
<p>Minimum number of presentations</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_maxpresentations">maxPresentations</code></td>
<td>
<p>Maximum number of presentations regarless of <code>stopType</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_mininterstiminterval">minInterStimInterval</code></td>
<td>
<p>If both <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>
are not <code>NA</code>, then between each stimuli there is a random wait period drawn uniformly
between <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_maxinterstiminterval">maxInterStimInterval</code></td>
<td>
<p><code>minInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_verbose">verbose</code></td>
<td>
<p><code>verbose=0</code> does nothing, <code>verbose=1</code> stores pdfs for returning,
and <code>verbose=2</code> stores pdfs and also prints each presentaion.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a dB value and numPresentations and returns an OPI datatype
ready for passing to opiPresent. See examples.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_state">state</code></td>
<td>
<p>Current state of the QUESTP returned by <code>QUESTP.start</code> and <code>QUESTP.step</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_nextstim">nextStim</code></td>
<td>
<p>A valid object for <code>opiPresent</code> to use as its <code>nextStim</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_choice">Choice</code></td>
<td>
<p>How to compute final values in QUESTP.final (&quot;mean&quot;,&quot;mode&quot;,&quot;median&quot;)</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_whichp">WhichP</code></td>
<td>
<p>Which parameter (numeric index) to monitor when calling QUESTP.stdev directly
(returns max(stdev) if unspecified)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of the Bayesian test procedure QUEST+ by AB Watson.
This is mostly a translation of the MATLAB implementation by P Jones (see References).
Its use is similar to ZEST. The objective is to estimate parameters of a function
that defines the probability of responding to stimuli. The steps are optimized based on entropy rather than
the mean or the mode of the current pdfs.
</p>
<p>The stimulus, parameter and response domain are separate and can be multidimensional.
Each parameter has its own pdf. For evaluation, the pdfs are chained as a long vector
(so no co-variances are considered). More complex functions will require larger combined pdfs
and longer computation time for likelihoods and updating at each step. In these cases, it is recommended
to pre-calculate the likelihoods using QUESTP.Likelihood and store them.
</p>
<p>The function to be fitted needs to output a probability of seen (i.e. <code>pseen = function(stim, param){...}</code>)
and must take <code>stim</code> and <code>param</code> as inputs. <code>stim</code> is a vector with length = number of stimulus dimensions
(in simple one-dimensional cases, the intensity in dB). <code>param</code> is a vector with length = number
of parameters to be fitted in Fun.
</p>
<p>For example, QUEST+ can fit a Gaussian psychometric function with stimDomain = <code>{0, 1,..., 39, 40}</code> dB
and paramDomain = <code>({0, 1,..., 39, 40}; {0.5, 1,..., 5.5, 6})</code> dB for the mean and
standard deviation respectively. A standard ZEST procedure can be replicated by setting
stimDomain = <code>{0, 1,..., 39, 40}</code> dB and paramDomain = <code>({0, 1,..., 39, 40}; {1})</code> dB, i.e. by setting the
stimDomain = paramDomain for the mean and by having a static standard deviation = 1 dB. Note however that
the stimulus selection is always based on entropy and not on the mean/mode of the current pdf. See examples below
</p>
<p>Note this function will repeatedly call <code>opiPresent</code> for a stimulus until <code>opiPresent</code>
returns <code>NULL</code> (ie no error occurred).
</p>
<p>The <code>checkFixationOK</code> function is called (if present in stim made from <code>makeStim</code>)
after each presentation, and if it returns FALSE, the pdf for that location is not changed
(ie the presentation is ignored), but the stim, number of presentations etc is recorded in
the state.
</p>
<p>If more than one QUESTP is to be interleaved (for example, testing multiple locations), then the
<code>QUESTP.start</code>, <code>QUESTP.step</code>, <code>QUESTP.stop</code> and <code>QUESTP.final</code> calls can maintain
the state of the QUESTP after each presentation, and should be used. If only a single QUESTP is
required, then the simpler <code>QUESTP</code> can be used, which is a wrapper for the four functions
that maintain state. See examples below.
</p>


<h3>Value</h3>



<h4>Single location</h4>

<p><code>QUESTP</code> returns a list containing
</p>

<ul>
<li> <p><code>npres</code> Total number of presentations used.
</p>
</li>
<li> <p><code>respSeq</code> Response sequence stored as a data frame: column 1 is a string identified of a (potentially)
multidimensional stimulus values of stimuli (dimensions chained into a string), column 2
is 1/0 for seen/not-seen, column 3 is fixated 1/0 (always 1 if <code>checkFixationOK</code> not
present in stim objects returned from <code>makeStim</code>). All additional columns report each stimulus
dimension, one for each row.
</p>
</li>
<li> <p><code>pdfs</code> If <code>verbose</code> is bigger than 0, then this is a list of the pdfs used for each presentation, otherwise NULL.
</p>
</li>
<li> <p><code>final</code> The mean (default, strongly suggested)/median/mode of the parameters' pdf, depending on <code>Choice</code>.
</p>
</li>
<li> <p><code>opiResp</code> A list of responses received from each successful call to <code>opiPresent</code> within <code>QUESTP</code>.
</p>
</li></ul>




<h4>Multiple locations</h4>

<p><code>QUESTP.start</code> returns a list that can be passed to <code>QUESTP.step</code>, <code>QUESTP.stop</code>, and
<code>QUESTP.final</code>. It represents the state of a QUESTP at a single location at a point in time and contains the following.
</p>

<ul>
<li> <p><code>name</code> <code>QUESTP</code>
</p>
</li>
<li><p> A copy of all of the parameters supplied to QUESTP.start: <code>stimDomain</code>,
<code>paramDomain</code>, <code>likelihoods</code>, <code>priors</code>, <code>stopType</code>, <code>stopValue</code>,
<code>maxSeenLimit</code>, <code>minNotSeenLimit</code>, <code>minPresentations</code>, <code>maxPresentations</code>,
<code>makeStim</code>, and <code>opiParams</code>.
</p>
</li>
<li> <p><code>pdf</code> Current pdf: vector of probabilities, collating all parameter domains.
</p>
</li>
<li> <p><code>priorsP</code> List of starting pdfs, one for each parameter.
</p>
</li>
<li> <p><code>numPresentations</code> The number of times <code>QUESTP.step</code> has been called on this state.
</p>
</li>
<li> <p><code>stimuli</code> A vector containing the stimuli used at each call of <code>QUESTP.step</code>.
</p>
</li>
<li> <p><code>responses</code> A vector containing the responses received at each call of <code>QUESTP.step</code>.
</p>
</li>
<li> <p><code>responseTimes</code> A vector containing the response times received at each call of <code>QUESTP.step</code>.
</p>
</li>
<li> <p><code>fixated</code> A vector containing TRUE/FALSE if fixation was OK according to
<code>checkFixationOK</code> for each call of <code>QUESTP.step</code> (defaults to TRUE if
<code>checkFixationOK</code> not present).
</p>
</li>
<li> <p><code>opiResp</code>A list of responses received from each call to <code>opiPresent</code> within <code>QUESTP.step</code>.
</p>
</li></ul>

<p><code>QUESTP.step</code> returns a list containing
</p>

<ul>
<li> <p><code>state</code> The new state after presenting a stimuli and getting a response.
</p>
</li>
<li> <p><code>resp</code> The return from the <code>opiPresent</code> call that was made.
</p>
</li></ul>

<p><code>QUESTP.stop</code> returns <code>TRUE</code> if the QUESTP has reached its stopping criteria, and <code>FALSE</code> otherwise.
</p>
<p><code>QUESTP.final</code> returns an estimate of parameters based on state. If <code>state$Choice</code>
is <code>mean</code> then the mean is returned (the only one that really makes sense for QUEST+).
If <code>state$Choice</code> is <code>mode</code> then the
mode is returned. If <code>state$Choice</code> is <code>median</code> then the median is returned.
</p>



<h3>References</h3>

<p>Andrew B. Watson; QUEST+: A general multidimensional Bayesian adaptive psychometric method.
Journal of Vision 2017;17(3):10. doi: https://doi.org/10.1167/17.3.10.
</p>
<p>Jones, P. R. (2018). QuestPlus: a MATLAB implementation of the QUEST+ adaptive psychometric
method, Journal of Open Research Software, 6(1):27. doi: http://doi.org/10.5334/jors.195
</p>
<p>A. Turpin, P.H. Artes and A.M. McKendrick &quot;The Open Perimetry Interface: An enabling tool for
clinical visual psychophysics&quot;, Journal of Vision 12(11) 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("SimHenson")
if(!is.null(opiInitialize(type="C", cap=6)))
    stop("opiInitialize failed")

#########################################################
# This section is for single location QUESTP
# This example fits a FoS curve
# Note: only fitting threshold and slope,
# modify the domain for FPR and FNR to fit those as well
#########################################################
# Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
    s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500, checkFixationOK=NULL)
    class(s) &lt;- "opiStaticStimulus"
    return(s)
}

#True parameters (variability is determined according to Henson et al. based on threshold)
loc &lt;- list(threshold = 20, fpr = 0.05, fnr = 0.05)

#Function to fit (Gaussian psychometric function)
pSeen &lt;- function(x, params){return(params[3] +
                                        (1 - params[3] - params[4]) *
                                        (1 - pnorm(x, params[1], params[2])))}
#QUEST+
QP &lt;- QUESTP(Fun = pSeen,
             stimDomain = list(0:50),
             paramDomain = list(seq(0, 40, 1), #Domain for the 50% threshold (Mean)
                                seq(.5, 8, .5), #Domain for the slope (SD)
                                seq(0.05, 0.05, 0.05), #Domain for the FPR (static)
                                seq(0.05, 0.05, 0.05)), #Domain for the FNR (static)
             stopType="H", stopValue=4, maxPresentations=500,
             makeStim = makeStim,
             tt=loc$threshold, fpr=loc$fpr, fnr=loc$fnr,
             verbose = 2)

#Plots results
#Henson's FoS function (as implemented in OPI - ground truth)
HensFunction &lt;- function(Th){
    SD &lt;- exp(-0.081*Th + 3.27)
    SD[SD &gt; 6] &lt;- 6
    return(SD)
}

#Stimulus domain
dB_Domain &lt;- 0:50
FoS &lt;- pSeen(dB_Domain, params = QP$final) # Estimated FoS
FoS_GT &lt;- pSeen(dB_Domain, params = c(loc$threshold, HensFunction(loc$threshold),
                                      loc$fpr, loc$fnr)) #Ground truth FoS (based on Henson et al.)

#Plot (seen stimuli at the top, unseen stimuli at the bottom)
plot(dB_Domain, FoS_GT, type = "l", ylim = c(0, 1), xlab = "dB", ylab = "% seen", col = "blue")
lines(dB_Domain, FoS, col = "red")
points(QP$respSeq$stimuli, QP$respSeq$responses, pch = 16,
       col = rgb(red = 1, green = 0, blue = 0, alpha = 0.1))
legend("top", inset = c(0, -.2),legend = c("True","Estimated","Stimuli"),
       col=c("blue", "red","red"), lty=c(1,1,0),
       pch = c(16, 16, 16), pt.cex = c(0, 0, 1),
       horiz = TRUE, xpd = TRUE, xjust = 0)

if (!is.null(opiClose()))
  warning("opiClose() failed")



chooseOpi("SimHenson")
if(!is.null(opiInitialize(type="C", cap=6)))
    stop("opiInitialize failed")

######################################################################
# This section is for single location QUESTP
# This example shows that QUEST+ can replicate a ZEST procedure
# by fitting a FoS curve with fixed Slope, FPR and FNR
# Compared with ZEST
# Note that QUEST+ should be  marginally more efficient in selecting
# the most informative stimulus
######################################################################
# Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
    s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500, checkFixationOK=NULL)
    class(s) &lt;- "opiStaticStimulus"
    return(s)
}

#True parameters (variability is determined according to Henson et al. based on threshold)
loc &lt;- list(threshold = 30, fpr = 0.03, fnr = 0.03)

#Function to fit (Gaussian psychometric function - Fixed slope (same as default likelihood in ZEST))
pSeen &lt;- function(domain, tt){{0.03+(1-0.03-0.03)*(1-pnorm(domain,tt,1))}}

# ZEST-like QUEST+ procedure
QP &lt;- QUESTP(Fun = pSeen,
             stimDomain = list(0:40),
             paramDomain = list(seq(0, 40, 1)),
             stopType="S", stopValue=1.5, maxPresentations=500,
             makeStim = makeStim,
             tt=loc$threshold, fpr=loc$fpr, fnr=loc$fnr,
             verbose = 2)

# ZEST
ZE &lt;- ZEST(domain = 0:40,
           stopType="S", stopValue=1.5, maxPresentations=500,
           makeStim = makeStim,
           tt=loc$threshold, fpr=loc$fpr, fnr=loc$fnr,
           verbose = 2)

#Plots results
#Henson's FoS function (as implemented in OPI - ground truth)
HensFunction &lt;- function(Th){
    SD &lt;- exp(-0.081*Th + 3.27)
    SD[SD &gt; 6] &lt;- 6
    return(SD)
}

#Stimulus domain
dB_Domain &lt;- 0:50
FoS_QP &lt;- pSeen(domain = dB_Domain, tt = QP$final) # Estimated FoS
FoS_ZE &lt;- pSeen(domain = dB_Domain, tt = ZE$final) # Estimated FoS

#Plot (seen stimuli at the top, unseen stimuli at the bottom)
plot(dB_Domain, FoS_QP, type = "l", ylim = c(0, 1), xlab = "dB", ylab = "% seen", col = "blue")
lines(dB_Domain, FoS_ZE, col = "red")
points(QP$respSeq$stimuli, QP$respSeq$responses, pch = 16,
       col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5))
points(ZE$respSeq[1,], ZE$respSeq[2,], pch = 16,
       col = rgb(red = 1, green = 0, blue = 0, alpha = 0.5))
legend("bottomleft", legend = c("QUEST+","ZEST","Stimuli QUEST+", "Stimuli ZEST"),
       col=c("blue", "red","blue","red"), lty=c(1,1,0,0),
       pch = c(16, 16, 16, 16), pt.cex = c(0, 0, 1, 1),
       horiz = FALSE, xpd = TRUE, xjust = 0)
abline(v = loc$threshold, lty = "dashed")

if (!is.null(opiClose()))
  warning("opiClose() failed")


chooseOpi("SimHenson")
if(!is.null(opiInitialize(type="C", cap=6)))
  stop("opiInitialize failed")

#########################################################
# This section is for single location QUESTP
# This example fits a broken stick spatial summation function
# with a multi-dimensional stimulus (varying in size and intensity).
# Stimulus sizes are limited to GI, GII, GIII, GIV and GV.
# The example also shows how to use a helper function to
# simulate responses to multi-dimensional stimuli
# (here, the simulated threshold varies based on stimulus size)
#########################################################
makeStim &lt;- function(stim, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(stim[1]), size=stim[2], color="white",
            duration=200, responseWindow=1500, checkFixationOK=NULL)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}

# Helper function for true threshold (depends on log10(stimulus size),
# diameter assumed to be the second element of stim vector)
ttHelper_SS &lt;- function(location) {  # returns a function of (stim)
  ff &lt;- function(stim) stim

  body(ff) &lt;- substitute(
    {return(SensF(log10(pi*(stim[2]/2)^2), c(location$Int1, location$Int2, location$Slo2)))}
  )
  return(ff)
}

# Function of sensivity vs SSize (log10(stimulus area))
SensF &lt;- function(SSize, params){
  Sens &lt;- numeric(length(SSize))
  for (i in 1:length(SSize)){
    Sens[i] &lt;- min(c(params[1] + 10*SSize[i], params[2] + params[3]*SSize[i]))
  }
  Sens[Sens &lt; 0] &lt;- 0
  return(Sens)
}

Sizes &lt;- c(0.1, 0.21, 0.43, 0.86, 1.72)

#True parameters (variability is determined according to Henson et al. based on threshold)
loc &lt;- list(Int1 = 32, Int2 = 28, Slo2 = 2.5, fpr = 0.05, fnr = 0.05, x = 9, y = 9)


# Function to fit (probability of seen given a certain stimulus intensity and size,
# for different parameters)
pSeen &lt;- function(stim, params){

  Th &lt;- SensF(log10(pi*(stim[2]/2)^2), params)

  return(0.03 +
           (1 - 0.03 - 0.03) *
           (1 - pnorm(stim[1], Th, 1)))
}


set.seed(111)
#QUEST+ - takes some time to calculate likelihoods
## Not run: 
QP &lt;- QUESTP(Fun = pSeen,
             stimDomain = list(0:50, Sizes),
             paramDomain = list(seq(0, 40, 1), # Domain for total summation intercept
                                seq(0, 40, 1), # Domain for partial summation intercept
                                seq(0, 3, 1)), # Domain for partial summation slope
             stopType="H", stopValue=1, maxPresentations=500,
             makeStim = makeStim,
             ttHelper=ttHelper_SS(loc), tt = 30,
             fpr=loc$fpr, fnr=loc$fnr,
             verbose = 2)

#Stimulus sizes
G &lt;- log10(c(pi*(0.1/2)^2, pi*(0.21/2)^2, pi*(0.43/2)^2, pi*(0.86/2)^2, pi*(1.72/2)^2));
SizesP &lt;- seq(min(G), max(G), .05)

# True and estimated response
Estim_Summation &lt;- SensF(SizesP, params = QP$final) # Estimated spatial summation
GT_Summation &lt;- SensF(SizesP, params = c(loc$Int1, loc$Int2, loc$Slo2)) # True spatial summation

#Plot
plot(10^SizesP, GT_Summation, type = "l", ylim = c(0, 40), log = "x",
     xlab = "Stimulus area (deg^2)", ylab = "Sensitivity (dB)", col = "blue")
lines(10^SizesP, Estim_Summation, col = "red")
points(pi*(QP$respSeq$stimuli.2/2)^2, QP$respSeq$stimuli.1, pch = 16,
       col = rgb(red = 1, green = 0, blue = 0, alpha = 0.3))
legend("top", inset = c(0, -.2),legend = c("True","Estimated","Stimuli"),
       col=c("blue", "red","red"), lty=c(1,1,0),
       pch = c(16, 16, 16), pt.cex = c(0, 0, 1),
       horiz = TRUE, xpd = TRUE, xjust = 0)

## End(Not run)

if (!is.null(opiClose()))
  warning("opiClose() failed")

</code></pre>

<hr>
<h2 id='RtDbUnits'>Response times to white-on-white Goldmann Size III targets for 12 subjects
in dB units</h2><span id='topic+RtDbUnits'></span>

<h3>Description</h3>

<p>Response times to white-on-white Goldmann Size III targets for 12
subjects. The second column is the distance of the stimuli from measured
threshold in HFA dB units. The threshold was determined by post-hoc fit of FoS
curves to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RtDbUnits
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 30620 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A data frame with 30620 observations on the following 3 variables.
</p>

<ul>
<li> <p><code>Rt</code> Reaction time in ms.
</p>
</li>
<li> <p><code>Dist</code> Distance of stimuli from threshold in dB.
</p>
</li>
<li> <p><code>Person</code> Identifier of each subject.
</p>
</li></ul>



<h3>References</h3>

<p>A.M. McKendrick, J. Denniss and A. Turpin. &quot;Response times across the visual
field: empirical observations and application to threshold determination&quot;.
Vision Research 101 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RtSigmaUnits">RtSigmaUnits</a></code>
</p>

<hr>
<h2 id='RtSigmaUnits'>Response times to white-on-white Goldmann Size III targets for 12 subjects
in sigma units</h2><span id='topic+RtSigmaUnits'></span>

<h3>Description</h3>

<p>Response times to white-on-white Goldmann Size III targets for 12
subjects. The second column is the distance of the stimuli from measured threshold
in 'sigma' units. The threshold was determined by post-hoc fit of a cumulative
gaussian FoS curve to the data for each location and subject. Sigma is the
standard deviation of the fitted FoS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RtSigmaUnits
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 30620 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A data frame with 30620 observations on the following 3 variables.
</p>

<ul>
<li> <p><code>Rt</code> Reaction time in ms.
</p>
</li>
<li> <p><code>Dist</code> Distance of stimuli from threshold in sigma units.
</p>
</li>
<li> <p><code>Person</code> Identifier of each subject.
</p>
</li></ul>



<h3>References</h3>

<p>A.M. McKendrick, J. Denniss and A. Turpin. &quot;Response times across the visual
field: empirical observations and application to threshold determination&quot;.
Vision Research 101 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RtDbUnits">RtDbUnits</a></code>
</p>

<hr>
<h2 id='ZEST'>ZEST</h2><span id='topic+ZEST'></span><span id='topic+ZEST.start'></span><span id='topic+ZEST.step'></span><span id='topic+ZEST.stop'></span><span id='topic+ZEST.final'></span>

<h3>Description</h3>

<p>An implementation of the Bayesian test procedures of King-Smith et al.
and Watson and Pelli. Note that we use the term <code>pdf</code> throughout as in the
original paper, even though they are discrete probability functions in this
implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZEST(
  domain = 0:40,
  prior = rep(1/length(domain), length(domain)),
  likelihood = sapply(domain, function(tt) 0.03 + (1 - 0.03 - 0.03) * (1 -
    stats::pnorm(domain, tt, 1))),
  stopType = "S",
  stopValue = 1.5,
  minStimulus = utils::head(domain, 1),
  maxStimulus = utils::tail(domain, 1),
  maxSeenLimit = 2,
  minNotSeenLimit = 2,
  maxPresentations = 100,
  minInterStimInterval = NA,
  maxInterStimInterval = NA,
  verbose = 0,
  makeStim,
  stimChoice = "mean",
  ...
)

ZEST.start(
  domain = 0:40,
  prior = rep(1/length(domain), length(domain)),
  likelihood = sapply(domain, function(tt) 0.03 + (1 - 0.03 - 0.03) * (1 -
    stats::pnorm(domain, tt, 1))),
  stopType = "S",
  stopValue = 1.5,
  minStimulus = utils::head(domain, 1),
  maxStimulus = utils::tail(domain, 1),
  maxSeenLimit = 2,
  minNotSeenLimit = 2,
  maxPresentations = 100,
  makeStim,
  stimChoice = "mean",
  ...
)

ZEST.step(state, nextStim = NULL, fixedStimValue = NA)

ZEST.stop(state)

ZEST.final(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZEST_+3A_domain">domain</code></td>
<td>
<p>Vector of values over which pdf is kept.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_prior">prior</code></td>
<td>
<p>Starting probability distribution over domain. Same length as <code>domain</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_likelihood">likelihood</code></td>
<td>
<p>Matrix where <code>likelihood[s,t]</code> is likelihood of seeing <code>s</code>
given <code>t</code> is the true threshold. That is, Pr(s|t) where <code>s</code> and <code>t</code> are
indexes into <code>domain</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_stoptype">stopType</code></td>
<td>
<p><code>N</code>, for number of presentations; <code>S</code>, for standard deviation
of the pdf; and <code>H</code>, for the entropy  of the pdf.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_stopvalue">stopValue</code></td>
<td>
<p>Value for number of presentations (<code>stopType=N</code>), standard deviation
(<code>stopType=S)</code> or Entropy (<code>stopType=H</code>).</p>
</td></tr>
<tr><td><code id="ZEST_+3A_minstimulus">minStimulus</code></td>
<td>
<p>The smallest stimuli that will be presented. Could be different from
<code>domain[1]</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_maxstimulus">maxStimulus</code></td>
<td>
<p>The largest stimuli that will be presented. Could be different from
<code>tail(domain,1)</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_maxseenlimit">maxSeenLimit</code></td>
<td>
<p>Will terminate if <code>maxStimulus</code> value is seen this many times.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_minnotseenlimit">minNotSeenLimit</code></td>
<td>
<p>Will terminate if <code>minStimulus</code> value is not seen this many times.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_maxpresentations">maxPresentations</code></td>
<td>
<p>Maximum number of presentations regardless of <code>stopType</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_mininterstiminterval">minInterStimInterval</code></td>
<td>
<p>If both <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>
are not <code>NA</code>, then between each stimuli there is a random wait period drawn uniformly
between <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_maxinterstiminterval">maxInterStimInterval</code></td>
<td>
<p><code>minInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_verbose">verbose</code></td>
<td>
<p><code>verbose=0</code> does nothing, <code>verbose=1</code> stores pdfs for returning,
and <code>verbose=2</code> stores pdfs and also prints each presentation.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a dB value and numPresentations and returns an OPI datatype
ready for passing to opiPresent. See examples.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_stimchoice">stimChoice</code></td>
<td>
<p>A true ZEST procedure uses the <code>"mean"</code> of the current pdf as the stimulus,
but <code>"median"</code> and <code>"mode"</code> (as used in a QUEST procedure) are provided for your
enjoyment.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="ZEST_+3A_state">state</code></td>
<td>
<p>Current state of the ZEST returned by <code>ZEST.start</code> and <code>ZEST.step</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_nextstim">nextStim</code></td>
<td>
<p>A valid object for <code>opiPresent</code> to use as its <code>nextStim</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_fixedstimvalue">fixedStimValue</code></td>
<td>
<p>A number in <code>state$domain</code> that, is <code>!is.na</code>, will be used as the stimulus value
overriding <code>state$minStimulus</code>, <code>state$maxStimulus</code> and <code>state$stimChoice</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of King-Smith et al.'s ZEST procedure and Watson and Pelli's
QUEST procedure. All presentations are rounded to an element of the supplied domain.
</p>
<p>Note this function will repeatedly call <code>opiPresent</code> for a stimulus until <code>opiPresent</code>
returns <code>NULL</code> (ie no error occurred).
</p>
<p>The <code>checkFixationOK</code> function is called (if present in stim made from <code>makeStim</code>)
after each presentation, and if it returns FALSE, the pdf for that location is not changed
(ie the presentation is ignored), but the stim, number of presentations etc is recorded in
the state.
</p>
<p>If more than one ZEST is to be interleaved (for example, testing multiple locations), then the
<code>ZEST.start</code>, <code>ZEST.step</code>, <code>ZEST.stop</code> and <code>ZEST.final</code> calls can maintain
the state of the ZEST after each presentation, and should be used. If only a single ZEST is
required, then the simpler <code>ZEST</code> can be used, which is a wrapper for the four functions
that maintain state. See examples below.
</p>


<h3>Value</h3>



<h4>Single location</h4>

<p><code>ZEST</code> returns a list containing
</p>

<ul>
<li> <p><code>npres</code> Total number of presentations used.
</p>
</li>
<li> <p><code>respSeq</code> Response sequence stored as a matrix: row 1 is dB values of stimuli, row 2
</p>
</li>
<li><p> is 1/0 for seen/not-seen, row 3 is fixated 1/0 (always 1 if <code>checkFixationOK</code> not
</p>
</li>
<li><p> present in stim objects returned from <code>makeStim</code>).
</p>
</li>
<li> <p><code>pdfs</code> If <code>verbose</code> is bigger than 0, then this is a list of the pdfs used for each presentation, otherwise NULL.
</p>
</li>
<li> <p><code>final</code> The mean/median/mode of the final pdf, depending on <code>stimChoice</code>, which is the determined threshold.
</p>
</li>
<li> <p><code>opiResp</code> A list of responses received from each successful call to <code>opiPresent</code> within <code>ZEST</code>.
</p>
</li></ul>




<h4>Multilple locations</h4>

<p><code>ZEST.start</code> returns a list that can be passed to <code>ZEST.step</code>, <code>ZEST.stop</code>, and
<code>ZEST.final</code>. It represents the state of a ZEST at a single location at a point in time
and contains the following.
</p>

<ul>
<li> <p><code>name</code> <code>ZEST</code>.
</p>
</li>
<li> <p><code>pdf</code> Current pdf: vector of probabilities the same length as <code>domain</code>.
</p>
</li>
<li> <p><code>numPresentations</code> The number of times <code>ZEST.step</code> has been called on this state.
</p>
</li>
<li> <p><code>stimuli</code> A vector containing the stimuli used at each call of <code>ZEST.step</code>.
</p>
</li>
<li> <p><code>responses</code> A vector containing the responses received at each call of <code>ZEST.step</code>.
</p>
</li>
<li> <p><code>responseTimes</code> A vector containing the response times received at each call of <code>ZEST.step</code>.
</p>
</li>
<li> <p><code>fixated</code> A vector containing TRUE/FALSE if fixation was OK according to
<code>checkFixationOK</code> for each call of <code>ZEST.step</code> (defaults to TRUE if
<code>checkFixationOK</code> not present).
</p>
</li>
<li> <p><code>opiResp</code> A list of responses received from each call to <code>opiPresent</code> within <code>ZEST.step</code>.
</p>
</li>
<li><p> A copy of all of the parameters supplied to ZEST.start: <code>domain</code>,
<code>likelihood</code>, <code>stopType</code>, <code>stopValue</code>, <code>minStimulus</code>, <code>maxStimulus</code>,
<code>maxSeenLimit</code>, <code>minNotSeenLimit</code>, <code>maxPresentations</code>, <code>makeStim</code>,
<code>stimChoice</code>, <code>currSeenLimit</code>, <code>currNotSeenLimit</code>, and <code>opiParams</code>.
</p>
</li></ul>

<p><code>ZEST.step</code> returns a list containing
* <code>state</code> The new state after presenting a stimuli and getting a response.
* <code>resp</code> The return from the <code>opiPresent</code> call that was made.
</p>
<p><code>ZEST.stop</code> returns <code>TRUE</code> if the ZEST has reached its stopping criteria, and <code>FALSE</code> otherwise.
</p>
<p><code>ZEST.final</code> returns an estimate of threshold based on state. If <code>state$stimChoice</code>
is <code>mean</code> then the mean is returned. If <code>state$stimChoice</code> is <code>mode</code> then the
mode is returned. If <code>state$stimChoice</code> is <code>median</code> then the median is returned.
</p>



<h3>References</h3>

<p>P.E. King-Smith, S.S. Grigsny, A.J. Vingrys, S.C. Benes, and A. Supowit. &quot;Efficient and Unbiased
Modifications of the QUEST Threshold Method: Theory, Simulations, Experimental Evaluation and
Practical Implementation&quot;, Vision Research 34(7) 1994. Pages 885-912.
</p>
<p>A.B. Watson and D.G. Pelli. &quot;QUEST: A Bayesian adaptive psychophysical method&quot;, Perception and
Psychophysics 33 1983. Pages 113-l20.
</p>
<p>A. Turpin, P.H. Artes and A.M. McKendrick &quot;The Open Perimetry Interface: An enabling tool for
clinical visual psychophysics&quot;, Journal of Vision 12(11) 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("SimHenson")
if(!is.null(opiInitialize(type="C", cap=6)))
  stop("opiInitialize failed")

##############################################
# This section is for single location ZESTs
##############################################
# Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500, checkFixationOK=NULL)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}

repp &lt;- function(...) sapply(1:50, function(i) ZEST(makeStim=makeStim, ...))
a &lt;- repp(stopType="H", stopValue=  3, verbose=0, tt=30, fpr=0.03)
b &lt;- repp(stopType="S", stopValue=1.5, verbose=0, tt=30, fpr=0.03)
c &lt;- repp(stopType="S", stopValue=2.0, verbose=0, tt=30, fpr=0.03)
d &lt;- repp(stopType="N", stopValue= 50, verbose=0, tt=30, fpr=0.03)
e &lt;- repp(prior=dnorm(0:40,m=0,s=5), tt=30, fpr=0.03)
f &lt;- repp(prior=dnorm(0:40,m=10,s=5), tt=30, fpr=0.03)
g &lt;- repp(prior=dnorm(0:40,m=20,s=5), tt=30, fpr=0.03)
h &lt;- repp(prior=dnorm(0:40,m=30,s=5), tt=30, fpr=0.03)

layout(matrix(1:2,1,2))
boxplot(lapply(list(a,b,c,d,e,f,g,h), function(x) unlist(x["final",])))
boxplot(lapply(list(a,b,c,d,e,f,g,h), function(x) unlist(x["npres",])))

##############################################
# This section is for multiple ZESTs
##############################################
makeStimHelper &lt;- function(db,n, x, y) {  # returns a function of (db,n)
  ff &lt;- function(db, n) db+n
  body(ff) &lt;- substitute({
    s &lt;- list(x=x, y=y, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500, checkFixationOK=NULL)
    class(s) &lt;- "opiStaticStimulus"
    return(s)
  }, list(x=x,y=y))
  return(ff)
}

# List of (x, y, true threshold) triples
locations &lt;- list(c(9,9,30), c(-9,-9,32), c(9,-9,31), c(-9,9,33))

# Setup starting states for each location
states &lt;- lapply(locations, function(loc) {
  ZEST.start(
    domain=-5:45,
    minStimulus=0,
    maxStimulus=40,
    makeStim=makeStimHelper(db,n,loc[1],loc[2]),
    stopType="S", stopValue= 1.5, tt=loc[3], fpr=0.03, fnr=0.01)})

# Loop through until all states are "stop"
while(!all(st &lt;- unlist(lapply(states, ZEST.stop)))) {
  i &lt;- which(!st)                         # choose a random,
  i &lt;- i[runif(1, min=1, max=length(i))]  # unstopped state
  r &lt;- ZEST.step(states[[i]])             # step it
  states[[i]] &lt;- r$state                  # update the states
}

finals &lt;- lapply(states, ZEST.final)    # get final estimates of threshold
for(i in 1:length(locations)) {
  #cat(sprintf("Location (%+2d,%+2d) ",locations[[i]][1], locations[[i]][2]))
  #cat(sprintf("has threshold %4.2f\n", finals[[i]]))
}

if (!is.null(opiClose()))
  warning("opiClose() failed")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
