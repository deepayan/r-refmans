<!DOCTYPE html><html><head><title>Help for package OPI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OPI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OPI-package'><p>OPI: Open Perimetry Interface</p></a></li>
<li><a href='#.opi_env'><p>Global environment for OPI to hold machine specific constants, etc.</p></a></li>
<li><a href='#cdTodb'><p>Convert cd/<code class="reqn">\mbox{m}^2</code> to perimetric dB.</p></a></li>
<li><a href='#chooseOPI'><p>chooseOPI selects an OPI machine to use.</p></a></li>
<li><a href='#dbTocd'><p>Convert perimetric dB to cd/<code class="reqn">\mbox{m}^2</code></p></a></li>
<li><a href='#degTopix'><p>Convert degrees to pixels for machine 'machine'</p></a></li>
<li><a href='#fourTwo.start'><p>4-2 Staircase</p></a></li>
<li><a href='#FT'><p>Full Threshold</p></a></li>
<li><a href='#kowa.presentKinetic'><p>Present kinetic on Kowa AP7000 (internal use)</p></a></li>
<li><a href='#kowa.presentStatic'><p>Present static on Kowa AP7000 (internal use)</p></a></li>
<li><a href='#kowa.presentTemporal'><p>Present temporal stim on Kowa AP7000 (internal use)</p></a></li>
<li><a href='#KTPsi'><p>An implementation of Kontsevich and Tyler <code class="reqn">\Psi</code> algorithm.</p></a></li>
<li><a href='#MOCS'><p>Method of Constant Stimuli (MOCS)</p></a></li>
<li><a href='#octo900.presentKinetic'><p>Present Kinetic stimuli on O900 (internal use)</p></a></li>
<li><a href='#octo900.presentStatic'><p>Present static on O900 (internal use)</p></a></li>
<li><a href='#octo900.presentTemporal'><p>Present Temporal stimuli on O900 (internal use)</p></a></li>
<li><a href='#open_socket'><p>Open a socket on ip and port.</p></a></li>
<li><a href='#opiClose'><p>Calls opiClose_for_MACHINE as appropriate.</p></a></li>
<li><a href='#opiClose_for_Compass'><p>Implementation of opiClose for the Compass machine.</p></a></li>
<li><a href='#opiClose_for_Display'><p>Implementation of opiClose for the Display machine.</p></a></li>
<li><a href='#opiClose_for_ImoVifa'><p>Implementation of opiClose for the ImoVifa machine.</p></a></li>
<li><a href='#opiClose_for_KowaAP7000'><p>Implementation of opiClose for the Kowa AP7000 machine.</p></a></li>
<li><a href='#opiClose_for_O600'><p>Implementation of opiClose for the O600 machine.</p></a></li>
<li><a href='#opiClose_for_Octopus900'><p>Implementation of opiClose for the Octopus900 machine.</p></a></li>
<li><a href='#opiClose_for_PhoneHMD'><p>Implementation of opiClose for the PhoneHMD machine.</p></a></li>
<li><a href='#opiClose_for_PicoVR'><p>Implementation of opiClose for the PicoVR machine.</p></a></li>
<li><a href='#opiClose_for_SimGaussian'><p>opiClose_for_SimGaussian</p></a></li>
<li><a href='#opiClose_for_SimHenson'><p>opiClose_for_SimHenson</p></a></li>
<li><a href='#opiClose_for_SimHensonRT'><p>opiClose_for_SimHensonRT</p></a></li>
<li><a href='#opiClose_for_SimNo'><p>opiClose_for_SimNo</p></a></li>
<li><a href='#opiClose_for_SimYes'><p>opiClose_for_SimYes</p></a></li>
<li><a href='#opiInitialise'><p>Calls opiInitialise_for_MACHINE as appropriate.</p></a></li>
<li><a href='#opiInitialise_for_Compass'><p>Implementation of opiInitialise for the ImoVifa machine.</p></a></li>
<li><a href='#opiInitialise_for_Display'><p>Implementation of opiInitialise for the Display machine.</p></a></li>
<li><a href='#opiInitialise_for_ImoVifa'><p>Implementation of opiInitialise for the ImoVifa machine.</p></a></li>
<li><a href='#opiInitialise_for_KowaAP7000'><p>Implementation of opiInitialise for the Octopus900 machine.</p></a></li>
<li><a href='#opiInitialise_for_O600'><p>Implementation of opiInitialise for the O600 machine.</p></a></li>
<li><a href='#opiInitialise_for_Octopus900'><p>Implementation of opiInitialise for the Octopus900 machine.</p></a></li>
<li><a href='#opiInitialise_for_PhoneHMD'><p>Implementation of opiInitialise for the PhoneHMD machine.</p></a></li>
<li><a href='#opiInitialise_for_PicoVR'><p>Implementation of opiInitialise for the PicoVR machine.</p></a></li>
<li><a href='#opiInitialise_for_SimGaussian'><p>opiInitialize_for_SimGaussian</p></a></li>
<li><a href='#opiInitialise_for_SimHenson'><p>opiInitialise_for_SimHenson</p></a></li>
<li><a href='#opiInitialise_for_SimHensonRT'><p>opiInitialise_for_SimHensonRT</p></a></li>
<li><a href='#opiInitialise_for_SimNo'><p>opiInitialise_for_SimNo</p></a></li>
<li><a href='#opiInitialise_for_SimYes'><p>opiInitialise_for_SimYes</p></a></li>
<li><a href='#opiKineticStimulus'><p>For backwards compatibility. Used by Octopus900 and KowaAP7000.</p></a></li>
<li><a href='#opiPresent'><p>Calls opiPresent_for_MACHINE as appropriate.</p></a></li>
<li><a href='#opiPresent_for_Compass'><p>Implementation of opiPresent for the Compass machine.</p></a></li>
<li><a href='#opiPresent_for_Display'><p>Implementation of opiPresent for the Display machine.</p></a></li>
<li><a href='#opiPresent_for_ImoVifa'><p>Implementation of opiPresent for the ImoVifa machine.</p></a></li>
<li><a href='#opiPresent_for_KowaAP7000'><p>Implementation of opiPresent for the KowaAP7000 machine.</p></a></li>
<li><a href='#opiPresent_for_O600'><p>Implementation of opiPresent for the O600 machine.</p></a></li>
<li><a href='#opiPresent_for_Octopus900'><p>Implementation of opiPresent for the Octopus090 machine.</p></a></li>
<li><a href='#opiPresent_for_PhoneHMD'><p>Implementation of opiPresent for the PhoneHMD machine.</p></a></li>
<li><a href='#opiPresent_for_PicoVR'><p>Implementation of opiPresent for the PicoVR machine.</p></a></li>
<li><a href='#opiPresent_for_SimGaussian'><p>opiPresent_for_SimGaussian</p></a></li>
<li><a href='#opiPresent_for_SimHenson'><p>opiPresent_for_SimHenson</p></a></li>
<li><a href='#opiPresent_for_SimHensonRT'><p>opiPresent_for_SimHensonRT</p></a></li>
<li><a href='#opiPresent_for_SimNo'><p>opiPresent_for_SimNo</p></a></li>
<li><a href='#opiPresent_for_SimYes'><p>opiPresent_for_SimYes</p></a></li>
<li><a href='#opiQueryDevice'><p>Calls opiQueryDevice_for_MACHINE as appropriate.</p></a></li>
<li><a href='#opiQueryDevice_for_Compass'><p>Implementation of opiQueryDevice for the ImoVifa machine.</p></a></li>
<li><a href='#opiQueryDevice_for_Display'><p>Implementation of opiQueryDevice for the Display machine.</p></a></li>
<li><a href='#opiQueryDevice_for_ImoVifa'><p>Implementation of opiQueryDevice for the ImoVifa machine.</p></a></li>
<li><a href='#opiQueryDevice_for_KowaAP7000'><p>Implementation of opiQueryDevice for the Kowa AP7000 machine.</p></a></li>
<li><a href='#opiQueryDevice_for_O600'><p>Implementation of opiQueryDevice for the O600 machine.</p></a></li>
<li><a href='#opiQueryDevice_for_Octopus900'><p>Implementation of opiQueryDevice for the Octopus900 machine.</p></a></li>
<li><a href='#opiQueryDevice_for_PhoneHMD'><p>Implementation of opiQueryDevice for the PhoneHMD machine.</p></a></li>
<li><a href='#opiQueryDevice_for_PicoVR'><p>Implementation of opiQueryDevice for the PicoVR machine.</p></a></li>
<li><a href='#opiQueryDevice_for_SimGaussian'><p>opiQueryDevice_for_SimGaussian</p></a></li>
<li><a href='#opiQueryDevice_for_SimHenson'><p>opiQueryDevice_for_SimHenson</p></a></li>
<li><a href='#opiQueryDevice_for_SimHensonRT'><p>opiQueryDevice_for_SimHensonRT</p></a></li>
<li><a href='#opiQueryDevice_for_SimNo'><p>opiQueryDevice_for_SimNo</p></a></li>
<li><a href='#opiQueryDevice_for_SimYes'><p>opiQueryDevice_for_SimYes</p></a></li>
<li><a href='#opiSetBackground'><p>Deprecated. Use <code>opiSetup()</code>.</p></a></li>
<li><a href='#opiSetup'><p>Calls opiSetup_for_MACHINE as appropriate.</p></a></li>
<li><a href='#opiSetup_for_Compass'><p>Implementation of opiSetup for the Compass machine.</p></a></li>
<li><a href='#opiSetup_for_Display'><p>Implementation of opiSetup for the Display machine.</p></a></li>
<li><a href='#opiSetup_for_ImoVifa'><p>Implementation of opiSetup for the ImoVifa machine.</p></a></li>
<li><a href='#opiSetup_for_KowaAP7000'><p>opiSetBackground</p></a></li>
<li><a href='#opiSetup_for_O600'><p>opiSetup for the O600 machine.</p></a></li>
<li><a href='#opiSetup_for_Octopus900'><p>Implementation of opiSetup for the Octopus900 machine.</p></a></li>
<li><a href='#opiSetup_for_PhoneHMD'><p>Implementation of opiSetup for the PhoneHMD machine.</p></a></li>
<li><a href='#opiSetup_for_PicoVR'><p>Implementation of opiSetup for the PicoVR machine.</p></a></li>
<li><a href='#opiSetup_for_SimGaussian'><p>opiSetup_for_SimGaussian</p></a></li>
<li><a href='#opiSetup_for_SimHenson'><p>opiSetup_for_SimHenson</p></a></li>
<li><a href='#opiSetup_for_SimHensonRT'><p>opiSetup_for_SimHensonRT</p></a></li>
<li><a href='#opiSetup_for_SimNo'><p>opiSetup_for_SimNo</p></a></li>
<li><a href='#opiSetup_for_SimYes'><p>opiSetup_for_SimYes</p></a></li>
<li><a href='#opiStaticStimulus'><p>For backwards compatibility. Used by Octopus900 and KowaAP7000.</p></a></li>
<li><a href='#opiTemporalStimulus'><p>For backwards compatibility. Used by Octopus900 and KowaAP7000.</p></a></li>
<li><a href='#pixTodeg'><p>Convert pixels to degrees for machine 'machine'</p></a></li>
<li><a href='#QUESTP'><p>QUEST+</p></a></li>
<li><a href='#RtDbUnits'><p>Response times to white-on-white Goldmann Size III targets for 12 subjects</p>
in dB units</a></li>
<li><a href='#RtSigmaUnits'><p>Response times to white-on-white Goldmann Size III targets for 12 subjects</p>
in sigma units</a></li>
<li><a href='#ZEST'><p>ZEST</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Open Perimetry Interface</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Open Perimetry Interface (OPI) for simulating and controlling visual field machines using R. The OPI is a standard for interfacing with visual field testing machines (perimeters) first started as an open source project with support of Haag-Streit in 2010. It specifies basic functions that allow many visual field tests to be constructed. As of February 2022 it is fully implemented on the Haag-Streit Octopus 900 and 'CrewT ImoVifa' ('Topcon Tempo') with partial implementations on the Centervue Compass, Kowa AP 7000 and Android phones. It also has a cousin: the R package 'visualFields', which has tools for analysing and manipulating visual field data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://opi.lei.org.au/">https://opi.lei.org.au/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>jsonlite, Rfast, abind, openssl</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>opi.r Display.r PicoVR.r PhoneHMD.r ImoVifa.r dbTocd.r
data-RtDbUnits.r data-RtSigmaUnits.r SimYes.r SimNo.r
SimHenson.r SimGaussian.r zest.r mocs.r fourTwo.r
full_threshold.r pix2deg.r QUESTP.r KTPsi.r Compass.r
Octopus900.r Octopus600.r OPI-package.r SimHensonRT.r
KowaAP7000Client.r</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-08 03:30:29 UTC; aturpin</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Turpin [cre, aut, cph] (ORCID: 0000-0003-2559-8769),
  David Lawson [ctb, cph],
  Ivan Marin-Franch [ctb, cph],
  Matthias Muller [ctb],
  Jonathan Denniss [ctb, cph],
  Astrid Zeman [ctb],
  Giovanni Montesano [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Turpin &lt;andrew.turpin@lei.org.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-09 15:00:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='OPI-package'>OPI: Open Perimetry Interface</h2><span id='topic+OPI'></span><span id='topic+OPI-package'></span>

<h3>Description</h3>

<p>Implementation of the Open Perimetry Interface (OPI) for simulating and controlling visual field machines using R. The OPI is a standard for interfacing with visual field testing machines (perimeters) first started as an open source project with support of Haag-Streit in 2010. It specifies basic functions that allow many visual field tests to be constructed. As of February 2022 it is fully implemented on the Haag-Streit Octopus 900 and 'CrewT ImoVifa' ('Topcon Tempo') with partial implementations on the Centervue Compass, Kowa AP 7000 and Android phones. It also has a cousin: the R package 'visualFields', which has tools for analysing and manipulating visual field data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andrew Turpin <a href="mailto:andrew.turpin@lei.org.au">andrew.turpin@lei.org.au</a> (ORCID: 0000-0003-2559-8769) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> David Lawson [contributor, copyright holder]
</p>
</li>
<li><p> Ivan Marin-Franch [contributor, copyright holder]
</p>
</li>
<li><p> Matthias Muller [contributor]
</p>
</li>
<li><p> Jonathan Denniss [contributor, copyright holder]
</p>
</li>
<li><p> Astrid Zeman [contributor]
</p>
</li>
<li><p> Giovanni Montesano [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://opi.lei.org.au/">https://opi.lei.org.au/</a>
</p>
</li></ul>


<hr>
<h2 id='.opi_env'>Global environment for OPI to hold machine specific constants, etc.</h2><span id='topic+.opi_env'></span>

<h3>Description</h3>

<p>Global environment for OPI to hold machine specific constants, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.opi_env
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 10.
</p>

<hr>
<h2 id='cdTodb'>Convert cd/<code class="reqn">\mbox{m}^2</code> to perimetric dB.</h2><span id='topic+cdTodb'></span>

<h3>Description</h3>

<p>Given a value in cd/<code class="reqn">\mbox{m}^2</code>, return the equivalent dB value.
Default is to use HFA units, so maximum stimulus is 10000 apostilbs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdTodb(cd, maxStim = 10000/pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdTodb_+3A_cd">cd</code></td>
<td>
<p>Value to convert to dB in cd/<code class="reqn">\mbox{m}^2</code>. Must be &gt; 0.</p>
</td></tr>
<tr><td><code id="cdTodb_+3A_maxstim">maxStim</code></td>
<td>
<p>Stimulus value for 0dB in cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dB value for <code>cd</code> cd/<code class="reqn">\mbox{m}^2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># candela to decibels
dB &lt;- cdTodb(10000/pi)  # 0 dB
dB &lt;- cdTodb(1000/pi)   # 10 dB
dB &lt;- cdTodb(100/pi)    # 20 dB
dB &lt;- cdTodb(10/pi)     # 30 dB
dB &lt;- cdTodb(1/pi)      # 40 dB
dB &lt;- cdTodb(0.1/pi)    # 50 dB
</code></pre>

<hr>
<h2 id='chooseOPI'>chooseOPI selects an OPI machine to use.</h2><span id='topic+chooseOPI'></span><span id='topic+chooseOpi'></span>

<h3>Description</h3>

<p>It should be called before any other OPI functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseOPI(machine = NULL)

chooseOpi(machine = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseOPI_+3A_machine">machine</code></td>
<td>
<p>Machine name to use. Set to NULL to get a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL on success or list of machines otherwise.
</p>

<hr>
<h2 id='dbTocd'>Convert perimetric dB to cd/<code class="reqn">\mbox{m}^2</code></h2><span id='topic+dbTocd'></span>

<h3>Description</h3>

<p>Given a value in dB, return the cd/<code class="reqn">\mbox{m}^2</code>
equivalent. Default is to use HFA units, so maximum stimulus is 10000
apostilbs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbTocd(db, maxStim = 10000/pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbTocd_+3A_db">db</code></td>
<td>
<p>Value to convert to cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
<tr><td><code id="dbTocd_+3A_maxstim">maxStim</code></td>
<td>
<p>Stimulus value for 0dB in cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cd/<code class="reqn">\mbox{m}^2</code> value for <code>db</code> dB.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># decibels to candela
cd &lt;- dbTocd(0)   # 10000/pi
cd &lt;- dbTocd(10)  # 1000/pi
cd &lt;- dbTocd(20)  # 100/pi
cd &lt;- dbTocd(30)  # 10/pi
cd &lt;- dbTocd(40)  # 1/pi
</code></pre>

<hr>
<h2 id='degTopix'>Convert degrees to pixels for machine 'machine'</h2><span id='topic+degTopix'></span>

<h3>Description</h3>

<p>Convert degrees to pixels for machine 'machine'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degTopix(xy, machine = "compass")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degTopix_+3A_xy">xy</code></td>
<td>
<p>a 2 element vector c(x,y) where x and y are in pixels</p>
</td></tr>
<tr><td><code id="degTopix_+3A_machine">machine</code></td>
<td>
<p>&quot;compass&quot; or ...?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xy converted to pixels (top-left is (0,0)) for the machine or
<code>NA</code> if machine is unknown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>degTopix(c(0, 0), machine="compass")  # c(960, 960) pixels
degTopix(c(-15, 2)) # c(495, 898) pixels
</code></pre>

<hr>
<h2 id='fourTwo.start'>4-2 Staircase</h2><span id='topic+fourTwo.start'></span><span id='topic+fourTwo.step'></span><span id='topic+fourTwo.stop'></span><span id='topic+fourTwo.final'></span>

<h3>Description</h3>

<p>fourTwo is a 4-2 dB staircase beginning at level <code>est</code>
terminating after two reversals. The final estimate is the average of the
last two presentations. It also terminates if the <code>minStimulus</code> is
not seen twice, or the <code>maxStimulus</code> is seen twice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourTwo.start(est = 25, instRange = c(0, 40), verbose = FALSE, makeStim, ...)

fourTwo.step(state, nextStim = NULL)

fourTwo.stop(state)

fourTwo.final(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourTwo.start_+3A_est">est</code></td>
<td>
<p>Starting estimate in dB</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_instrange">instRange</code></td>
<td>
<p>Dynamic range of the instrument c(min,max) in dB</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_verbose">verbose</code></td>
<td>
<p>True if you want each presentation printed</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a dB value and numPresentations
and returns an OPI datatype ready for passing to opiPresent</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_state">state</code></td>
<td>
<p>Current state of the fourTwo returned by
<code>fourTwo.start</code> and <code>fourTwo.step</code></p>
</td></tr>
<tr><td><code id="fourTwo.start_+3A_nextstim">nextStim</code></td>
<td>
<p>A valid object for <code>opiPresent</code> to
use as its <code>nextStim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of a 4-2 1-up 1-down staircase. The
initial staircase starts at <code>est</code> and proceeds in steps of 4 dB until
the first reversal, and 2dB until the next reversal. The mean of the last
two presentations is taken as the threshold value. Note this function will
repeatedly call <code>opiPresent</code> for a stimulus until <code>opiPresent</code>
returns <code>NULL</code> (ie no error occurred). If more than one fourTwo is to
be interleaved (for example, testing multiple locations), then the
<code>fourTwo.start</code>, <code>fourTwo.step</code>, <code>fourTwo.stop</code> and
<code>fourTwo.final</code> calls can maintain the state of the fourTwo after
each presentation, and should be used. See examples below.
</p>


<h3>Value</h3>



<h4>Multiple locations</h4>

<p><code>fourTwo.start</code> returns a list that can be passed to <code>fourTwo.step</code>,
<code>fourTwo.stop</code>, and <code>fourTwo.final</code>. It represents the state of a fourTwo
at a single location at a point in time and contains the following.
</p>

<ul>
<li> <p><code>name</code> <code>fourTwo</code>
</p>
</li>
<li><p> A copy of all of the parameters supplied to fourTwo.start: <code>startingEstimate=est</code>, <code>minStimulus=instRange[1]</code>, <code>maxStimulus=instRange[2]</code>, <code>makeStim</code>, and <code>opiParams=list(...)</code>
</p>
</li>
<li> <p><code>currentLevel</code> The next stimulus to present.
</p>
</li>
<li> <p><code>lastSeen</code> The last seen stimulus.
</p>
</li>
<li> <p><code>lastResponse</code> The last response given.
</p>
</li>
<li> <p><code>stairResult</code> The final result if finished (initially <code>NA</code>).
</p>
</li>
<li> <p><code>finished</code> <code>"Not"</code> if staircase has not finished, or one of <code>"Rev"</code> (finished due to 2 reversals), <code>"Max"</code> (finished due to 2 <code>maxStimulus</code> seen), <code>"Min"</code> (finished due to 2 <code>minStimulus</code> not seen)
</p>
</li>
<li> <p><code>numberOfReversals</code> Number of reversals so far.
</p>
</li>
<li> <p><code>currSeenLimit</code> Number of times <code>maxStimulus</code> has been seen.
</p>
</li>
<li> <p><code>currNotSeenLimit</code> Number of times <code>minStimulus</code> not seen.
</p>
</li>
<li> <p><code>numPresentations</code> Number of presentations so far.
</p>
</li>
<li> <p><code>stimuli</code> Vector of stimuli shown at each call to <code>fourTwo.step</code>.
</p>
</li>
<li> <p><code>responses</code> Vector of responses received (1 seen, 0 not) received at each call to <code>fourTwo.step</code>.
</p>
</li>
<li> <p><code>responseTimes</code> Vector of response times received at each call to <code>fourTwo.step</code>.
</p>
</li></ul>

<p><code>fourTwo.step</code> returns a list containing
</p>

<ul>
<li> <p><code>state</code> The new state after presenting a stimuli and getting a response.
</p>
</li>
<li> <p><code>resp</code> The return from the <code>opiPresent</code> call that was made.
</p>
</li></ul>

<p><code>fourTwo.stop</code> returns <code>TRUE</code> if the staircase is finished (2 reversals, or <code>maxStimulus</code>
is seen twice or <code>minStimulus</code> is not seen twice).
</p>
<p><code>fourTwo.final</code> returns the final estimate of threshold (mean of last
two reversals). This issues a warning if called before the staircase has
finished, but still returns a value.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>, <code><a href="#topic+FT">FT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}
chooseOpi("SimHenson")
if (!is.null(opiInitialize(type="C", cap=6)$err))
  stop("opiInitialize failed")

##############################################
# This section is for multiple fourTwos
##############################################
makeStimHelper &lt;- function(db,n, x, y) {  # returns a function of (db,n)
  ff &lt;- function(db, n) db+n
  body(ff) &lt;- substitute({
    s &lt;- list(x=x, y=y, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500)
    class(s) &lt;- "opiStaticStimulus"
    return(s)}, list(x=x,y=y))
  return(ff)
}
# List of (x, y, true threshold) triples
locations &lt;- list(c(9,9,30), c(-9,-9,32), c(9,-9,31), c(-9,9,33))

# Setup starting states for each location
states &lt;- lapply(locations, function(loc) {
  fourTwo.start(makeStim=makeStimHelper(db,n,loc[1],loc[2]),
                tt=loc[3], fpr=0.03, fnr=0.01)})

# Loop through until all states are "stop"
while(!all(st &lt;- unlist(lapply(states, fourTwo.stop)))) {
  i &lt;- which(!st)                         # choose a random,
  i &lt;- i[runif(1, min=1, max=length(i))]  # unstopped state
  r &lt;- fourTwo.step(states[[i]])               # step it
  states[[i]] &lt;- r$state                  # update the states
}

finals &lt;- lapply(states, fourTwo.final)    # get final estimates of threshold
for(i in 1:length(locations)) {
  cat(sprintf("Location (%+2d,%+2d) ",locations[[i]][1], locations[[i]][2]))
      cat(sprintf("has threshold %4.2f\n", finals[[i]]))
}

if (!is.null(opiClose()$err))
  warning("opiClose() failed")
</code></pre>

<hr>
<h2 id='FT'>Full Threshold</h2><span id='topic+FT'></span><span id='topic+FT.start'></span><span id='topic+FT.step'></span><span id='topic+FT.stop'></span><span id='topic+FT.final'></span>

<h3>Description</h3>

<p>FT begins with a 4-2dB staircase beginning at level
<code>est</code>. If the final estimate (last seen) is more than 4dB away
from <code>est</code>, a second 4-2 staircase is completed beginning at the
estimate returned from the first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FT(est = 25, instRange = c(0, 40), verbose = FALSE, makeStim, ...)

FT.start(est = 25, instRange = c(0, 40), makeStim, ...)

FT.step(state, nextStim = NULL)

FT.stop(state)

FT.final(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FT_+3A_est">est</code></td>
<td>
<p>Starting estimate in dB</p>
</td></tr>
<tr><td><code id="FT_+3A_instrange">instRange</code></td>
<td>
<p>Dynamic range of the instrument c(min,max) in dB</p>
</td></tr>
<tr><td><code id="FT_+3A_verbose">verbose</code></td>
<td>
<p>True if you want each presentation printed</p>
</td></tr>
<tr><td><code id="FT_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a dB value and numPresentations
and returns an OPI datatype ready for passing to opiPresent</p>
</td></tr>
<tr><td><code id="FT_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="FT_+3A_state">state</code></td>
<td>
<p>Current state of the FT returned by <code>FT.start</code> and
<code>FT.step</code></p>
</td></tr>
<tr><td><code id="FT_+3A_nextstim">nextStim</code></td>
<td>
<p>A valid object for <code>opiPresent</code> to use as its
<code>nextStim</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of a 4-2 1-up 1-down staircase as
implemented in the first Humphrey Field Analyzer. The initial staircase
starts at <code>est</code> and proceeds in steps of 4 dB until the first
reversal, and 2dB until the next reversal. The last seen stimulus is
taken as the threshold value. If, after the first staircase, the
threshold is more than 4 dB away from the starting point, then a second
staircase is initiated with a starting point equal to the threshold
found with the first staircase.
</p>
<p>Note this function will repeatedly call <code>opiPresent</code> for a stimulus
until <code>opiPresent</code> returns <code>NULL</code> (ie no error occurred)
</p>
<p>If more than one FT is to be interleaved (for example, testing multiple
locations), then the <code>FT.start</code>, <code>FT.step</code>, <code>FT.stop</code>
and <code>FT.final</code> calls can maintain the state of the FT after each
presentation, and should be used. If only a single FT is required, then
the simpler <code>FT</code> can be used. See examples below
</p>


<h3>Value</h3>



<h4>Single location</h4>

<p>Returns a list containing
</p>

<ul>
<li> <p><code>npres</code> Total number of presentations
</p>
</li>
<li> <p><code>respSeq</code> Response sequence stored as a list of (seen,dB) pairs
</p>
</li>
<li> <p><code>first</code> First staircase estimate in dB
</p>
</li>
<li> <p><code>final</code> Final threshold estimate in dB
</p>
</li></ul>




<h4>Multiple locations</h4>

<p><code>FT.start</code> returns a list that can be passed to <code>FT.step</code>,
<code>FT.stop</code>, and <code>FT.final</code>. It represents the state of a FT
at a single location at a point in time and contains the following.
</p>

<ul>
<li> <p><code>name</code> <code>FT</code>
</p>
</li>
<li><p> A copy of all of the parameters supplied to FT.start:
<code>startingEstimate=est</code>, <code>minStimulus=instRange[1]</code>,
<code>maxStimulus=instRange[2]</code>, <code>makeStim</code>, and <code>opiParams=list(...)</code>.
</p>
</li>
<li> <p><code>currentLevel</code> The next stimulus to present.
</p>
</li>
<li> <p><code>lastSeen</code> The last seen stimulus.
</p>
</li>
<li> <p><code>lastResponse</code> The last response given.
</p>
</li>
<li> <p><code>firstStairResult</code> The result of the first staircase (initially <code>NA</code>).
</p>
</li>
<li> <p><code>secondStairResult</code> The result of the first staircase (initially <code>NA</code>,
and could remain <code>NA</code>).
</p>
</li>
<li> <p><code>finished</code> <code>TRUE</code> if staircase has finished (2 reversals, or max/min
seen/not-seen twice).
</p>
</li>
<li> <p><code>numberOfReversals</code> Number of reversals so far.
</p>
</li>
<li> <p><code>currSeenLimit</code> Number of times <code>maxStimulus</code> has been seen.
</p>
</li>
<li> <p><code>currNotSeenLimit</code> Number of times <code>minStimulus</code> not seen.
</p>
</li>
<li> <p><code>numPresentations</code> Number of presentations so far.
</p>
</li>
<li> <p><code>stimuli</code> Vector of stimuli shown at each call to <code>FT.step</code>.
</p>
</li>
<li> <p><code>responses</code> Vector of responses received (1 seen, 0 not) received at each
call to <code>FT.step</code>.
</p>
</li>
<li> <p><code>responseTimes</code> Vector of response times received at each call to<code>FT.step</code>.
</p>
</li></ul>

<p><code>FT.step</code> returns a list containing
</p>

<ul>
<li> <p><code>state</code> The new state after presenting a stimuli and getting a response.
</p>
</li>
<li> <p><code>resp</code> The return from the <code>opiPresent</code> call that was made.
</p>
</li></ul>

<p><code>FT.stop</code> returns <code>TRUE</code> if the first staircase has had 2 reversals, or
<code>maxStimulus</code> is seen twice or <code>minStimulus</code> is not seen twice and the
final estimate is within 4 dB of the starting stimulus. Returns <code>TRUE</code> if
the second staircase has had 2 reversals, or <code>maxStimulus</code> is seen twice or
<code>minStimulus</code> is not seen twice
</p>
<p><code>FT.final</code> returns the final estimate of threshold based on state, which is
the last seen in the second staircase, if it ran, or the first staircase otherwise
</p>
<p><code>FT.final.details</code> returns a list containing
</p>

<ul>
<li> <p><code>final</code> The final threshold.
</p>
</li>
<li> <p><code>first</code> The threshold determined by the first staircase (might be
different from final).
</p>
</li>
<li> <p><code>stopReason</code> Either <code>Reversals</code>, <code>Max</code>, or <code>Min</code> which
are the three ways in which FT can terminate.
</p>
</li>
<li> <p><code>np</code> Number of presentation for the whole procedure (including both
staircases if run).
</p>
</li></ul>




<h3>References</h3>

<p>A. Turpin, P.H. Artes and A.M. McKendrick. &quot;The Open Perimetry
Interface: An enabling tool for clinical visual psychophysics&quot;, Journal
of Vision 12(11) 2012.
</p>
<p>H. Bebie, F. Fankhauser and J. Spahr. &quot;Static perimetry: strategies&quot;,
Acta Ophthalmology 54 1976.
</p>
<p>C.A. Johnson, B.C. Chauhan, and L.R. Shapiro. &quot;Properties of staircase
procedures for estimating thresholds in automated perimetry&quot;,
Investigative Ophthalmology and Vision Science 33 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>, <code><a href="#topic+fourTwo.start">fourTwo.start</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}
chooseOpi("SimHenson")
if (!is.null(opiInitialize(type="C", cap=6)$err))
  stop("opiInitialize failed")

result &lt;- FT(makeStim=makeStim, tt=30, fpr=0.15, fnr=0.01)
if (!is.null(opiClose()$err))
  warning("opiClose() failed")

##############################################
# This section is for multiple FTs
##############################################
makeStimHelper &lt;- function(db,n, x, y) {  # returns a function of (db,n)
  ff &lt;- function(db, n) db+n
  body(ff) &lt;- substitute({
    s &lt;- list(x=x, y=y, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500)
    class(s) &lt;- "opiStaticStimulus"
    return(s)
  }, list(x=x,y=y))
  return(ff)
}

# List of (x, y, true threshold) triples
locations &lt;- list(c(9,9,30), c(-9,-9,32), c(9,-9,31), c(-9,9,33))
# Setup starting states for each location
states &lt;- lapply(locations, function(loc) {
  FT.start(makeStim=makeStimHelper(db,n,loc[1],loc[2]),
           tt=loc[3], fpr=0.03, fnr=0.01)})

# Loop through until all states are "stop"
while(!all(st &lt;- unlist(lapply(states, FT.stop)))) {
  i &lt;- which(!st)                         # choose a random,
  i &lt;- i[runif(1, min=1, max=length(i))]  # unstopped state
  r &lt;- FT.step(states[[i]])               # step it
  states[[i]] &lt;- r$state                  # update the states
}

finals &lt;- lapply(states, FT.final)    # get final estimates of threshold
for(i in 1:length(locations)) {
  cat(sprintf("Location (%+2d,%+2d) ",locations[[i]][1], locations[[i]][2]))
  cat(sprintf("has threshold %4.2f\n", finals[[i]]))
}

if(!is.null(opiClose()$err))
  warning("opiClose() failed")
</code></pre>

<hr>
<h2 id='kowa.presentKinetic'>Present kinetic on Kowa AP7000 (internal use)</h2><span id='topic+kowa.presentKinetic'></span>

<h3>Description</h3>

<p>Implementation of opiPresent for the Kowa AP7000 machine.
Version for opiKineticStimulus.
</p>
<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with
<code>stim</code> as class <code>opiStaticStimulus</code> and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="kowa.presentKinetic_+3A_stim">stim</code></td>
<td>
<p>Stimulus to present (a list, see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stim</code> is a list containing at least the following 3 elements:
</p>

<ul>
<li> <p><code>path</code>, a list containing <code>x</code> 2 x-coordinate in degrees (floating point) (range $[-80,80]$) and <code>y</code>, list of 2 y-coordinate in degrees (floating point) (range $[-70,65]$).
</p>
</li>
<li> <p><code>sizes</code> list of 1 size; one of <code>.opi_env$KowaAP7000$SIZES_DEGREES</code>.
</p>
</li>
<li> <p><code>colors</code> list of 1 color; one of <code>.opi_env$KowaAP7000$COLOR_WHITE</code>, <code>.opi_env$KowaAP7000$COLOR_GREEN</code>, <code>.opi_env$KowaAP7000$COLOR_BLUE</code>, or <code>.opi_env$KowaAP7000$COLOR_RED</code>
</p>
</li>
<li> <p><code>levels</code> list of 1 level; luminance in cd/<code class="reqn">\mbox{m}^2</code>, and is rounded to the nearest whole dB for display (range 0 to 50). 0dB is 10000aps.
</p>
</li>
<li> <p><code>speeds</code> list of 1 speed; degrees per second range $[3, 5]$.
</p>
</li>
<li> <p><code>duration</code> of stimulus on in milliseconds (range $[100, 1200]$).
</p>
</li>
<li> <p><code>responseWindow</code> from start of stimulus presentation in milliseconds (max 5000).
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>err</code>  String message or NULL for no error.
</p>
</li>
<li> <p><code>seen</code> 1 if seen, 0 otherwise.
</p>
</li>
<li> <p><code>time</code> Reaction time (if seen).
</p>
</li>
<li> <p><code>x</code> Location of button press in degrees.
</p>
</li>
<li> <p><code>y</code> Location of button press in degrees.
</p>
</li></ul>


<hr>
<h2 id='kowa.presentStatic'>Present static on Kowa AP7000 (internal use)</h2><span id='topic+kowa.presentStatic'></span>

<h3>Description</h3>

<p>Implementation of opiPresent for the Kowa AP7000 machine.
Version for opiStaticStimulus.
</p>
<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with
<code>stim</code> as class <code>opiStaticStimulus</code> and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="kowa.presentStatic_+3A_stim">stim</code></td>
<td>
<p>Stimulus to present (a list, see details).</p>
</td></tr>
<tr><td><code id="kowa.presentStatic_+3A_nextstim">nextStim</code></td>
<td>
<p>The stimulus to present after stim
(it is not presented, but projector can move to it during response window)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stim</code> is a list containing at least the following 3 elements:
</p>

<ul>
<li> <p><code>x</code>, x-coordinate in degrees (floating point) (range $[-80,80]$).
</p>
</li>
<li> <p><code>y</code>, y-coordinate in degrees (floating point) (range $[-70,65]$).
</p>
</li>
<li> <p><code>level</code> is luminance in cd/<code class="reqn">\mbox{m}^2</code>, and is rounded to the nearest
whole dB for display (range 0 to 50). 0dB is 10000aps.
</p>
</li>
<li> <p><code>duration</code> of stimulus on in milliseconds (range $[100, 1200]$).
</p>
</li>
<li> <p><code>responseWindow</code> from start of stimulus presentation in milliseconds (max 5000).
</p>
</li>
<li> <p><code>size</code> one of <code>.opi_env$KowaAP7000$SIZES_DEGREES</code>.
</p>
</li>
<li> <p><code>color</code> one of <code>.opi_env$KowaAP7000$COLOR_WHITE</code>, <code>.opi_env$KowaAP7000$COLOR_GREEN</code>, <code>.opi_env$KowaAP7000$COLOR_BLUE</code>, or <code>.opi_env$KowaAP7000$COLOR_RED</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>err</code>  String message or NULL for no error.
</p>
</li>
<li> <p><code>seen</code> 1 if seen, 0 otherwise.
</p>
</li>
<li> <p><code>time</code> Reaction time (if seen).
</p>
</li>
<li> <p><code>pupilX</code>
</p>
</li>
<li> <p><code>pupilY</code>
</p>
</li>
<li> <p><code>purkinjeX</code>
</p>
</li>
<li> <p><code>purkinjeY</code>
</p>
</li></ul>


<hr>
<h2 id='kowa.presentTemporal'>Present temporal stim on Kowa AP7000 (internal use)</h2><span id='topic+kowa.presentTemporal'></span>

<h3>Description</h3>

<p>Implementation of opiPresent for the Kowa AP7000 machine.
Version for opiKineticStimulus.
</p>
<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with
<code>stim</code> as class <code>opiStaticStimulus</code> and you will get the Value back.
</p>

<hr>
<h2 id='KTPsi'>An implementation of Kontsevich and Tyler <code class="reqn">\Psi</code> algorithm.</h2><span id='topic+KTPsi'></span><span id='topic+KTPsi.start'></span><span id='topic+KTPsi.step'></span><span id='topic+KTPsi.final'></span><span id='topic+KTPsi.stop'></span>

<h3>Description</h3>

<p>An implementation of Kontsevich and Tyler (Vis Res 39 (1999) pages 2729&ndash;2737
default parameterised for Standard Automated Perimetry.
based on
A. Turpin, D. Jankovic and A.M. McKendrick,
&quot;Identifying Steep Psychometric Function Slope Quickly in Clinical Applications&quot;,
Vision Research, 50(23). November 2010. Pages 2476-2485
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KTPsi(
  domains = list(slopes = 1:5, thresholds = 20:40, fps = c(0, 0.025, 0.05, 0.1, 0.2), fns
    = c(0, 0.025, 0.05, 0.1, 0.2)),
  priors = list(slopes = rep(1, length(domains$slopes))/length(domains$slopes),
    thresholds = rep(1, length(domains$thresholds))/length(domains$thresholds), fps =
    rep(1, length(domains$fps))/length(domains$fps), fns = rep(1,
    length(domains$fns))/length(domains$fns)),
  stimValues = 17:40,
  stopType = "N",
  stopValue = 140,
  maxPresentations = 200,
  minInterStimInterval = NA,
  maxInterStimInterval = NA,
  verbose = 0,
  makeStim,
  ...
)

KTPsi.start(
  domains = list(slopes = 1:5, thresholds = 20:40, fps = c(0, 0.025, 0.05, 0.1, 0.2), fns
    = c(0, 0.025, 0.05, 0.1, 0.2)),
  priors = list(slopes = rep(1, length(domains$slopes))/length(domains$slopes),
    thresholds = rep(1, length(domains$thresholds))/length(domains$thresholds), fps =
    rep(1, length(domains$fps))/length(domains$fps), fns = rep(1,
    length(domains$fns))/length(domains$fns)),
  stimValues = 17:40,
  stopType = "N",
  stopValue = 140,
  maxPresentations = 200,
  minInterStimInterval = NA,
  maxInterStimInterval = NA,
  verbose = 0,
  makeStim,
  ...
)

KTPsi.step(state, nextStim = NULL, fixedStimValue = NA)

KTPsi.final(state, method = "expectation")

KTPsi.stop(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KTPsi_+3A_domains">domains</code></td>
<td>
<p>A list of 4 vectors:
</p>

<ul>
<li> <p><code>slopes</code> The valid slopes in the domain of psychometric functions.
</p>
</li>
<li> <p><code>thresholds</code> The valid thresholds in the domain of psychometric functions.
</p>
</li>
<li> <p><code>fps</code> The valid upper asymptotes (false positives) in the domain of psychometric functions.
</p>
</li>
<li> <p><code>fns</code> The valid lower asymptotes (false negatives) in the domain of psychometric functions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="KTPsi_+3A_priors">priors</code></td>
<td>
<p>A list of 4 vectors:
</p>

<ul>
<li> <p><code>slopes</code> The prior probability vector for <code>domains$slopes</code>.
</p>
</li>
<li> <p><code>thresholds</code> The prior probability vector for <code>domains$thresholds</code>.
</p>
</li>
<li> <p><code>fps</code> The prior probability vector for <code>domains$fps</code>.
</p>
</li>
<li> <p><code>fns</code> The prior probability vector for <code>domains$fns</code>.
</p>
</li></ul>

<p>Each prior should the same length as its <code>domains</code> counterpart and sum to 1.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_stimvalues">stimValues</code></td>
<td>
<p>Vector of allowable stimulus values.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_stoptype">stopType</code></td>
<td>
<p><code>N</code>, for number of presentations and <code>H</code>, for the entropy  of the pdf.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_stopvalue">stopValue</code></td>
<td>
<p>Value for number of presentations (<code>stopType=N</code>), or Entropy (<code>stopType=H</code>).</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_maxpresentations">maxPresentations</code></td>
<td>
<p>Maximum number of presentations regardless of <code>stopType</code>.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_mininterstiminterval">minInterStimInterval</code></td>
<td>
<p>If both <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>
are not <code>NA</code>, then between each stimuli there is a random wait period drawn uniformly
between <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_maxinterstiminterval">maxInterStimInterval</code></td>
<td>
<p><code>minInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_verbose">verbose</code></td>
<td>
<p><code>verbose=0</code> does nothing, <code>verbose=1</code> stores pdfs for returning,
and <code>verbose=2</code> stores pdfs and also prints each presentation.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a stimulus value and numPresentations and returns an OPI datatype
ready for passing to opiPresent. See examples.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_state">state</code></td>
<td>
<p>Current state of the KTPsi as returned by (eg) <code>KTPsi.start</code>.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_nextstim">nextStim</code></td>
<td>
<p>The next stimulus to present in a suitable format for passing to <code><a href="#topic+opiPresent">opiPresent</a></code></p>
</td></tr>
<tr><td><code id="KTPsi_+3A_fixedstimvalue">fixedStimValue</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="KTPsi_+3A_method">method</code></td>
<td>
<p>Either <code>"expectation"</code> or <code>"MAP"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assumed psychometric function is the cumulative Gaussian:
</p>
<p style="text-align: center;"><code class="reqn">\mbox{fp}+(1-\mbox{fp}-\mbox{fn})(1-\mbox{pnorm}(x, \mbox{threshold}, \mbox{slope})</code>
</p>

<p>hence <code>domain$slopes</code> are standard deviations and <code>domain$thresholds</code> are the mean.
</p>
<p>While it is assumed that <code>domains$thresholds</code> and <code>stimValues</code> are in dB, this need not be the case.
As long as the <code>makeStim</code> function converts <code>stimValues</code> into cd/<code class="reqn">\mbox{m}^2</code>
for the <code>opiPresent</code> function, then any units should work.
</p>
<p>The <code>checkFixationOK</code> function is called (if present in stim made from <code>makeStim</code>)
after each presentation, and if it returns FALSE, the pdf for that state is not changed
(ie the presentation is ignored), but the stim, number of presentations etc is recorded in
the state.
</p>
<p>If more than one KTPsi is to be interleaved (for example, testing multiple locations), then thePsi
<code>KTPsi.start</code>, <code>KTPsi.step</code>, <code>KTPsi.stop</code> and <code>KTPsi.final</code> calls can maintain
the state of the KTPsi after each presentation, and should be used. If only a single KTPsi is
required, then the simpler <code>KTPsi</code> function can be used, which is a wrapper for the four functions
that maintain state. See examples below.
</p>


<h3>Value</h3>



<h4>Single location</h4>

<p><code>KTPsi</code> returns a list containing
</p>

<ul>
<li> <p><code>npres</code> Total number of presentations used.
</p>
</li>
<li> <p><code>respSeq</code> Response sequence stored as a matrix: row 1 is dB values of stimuli, row 2 is 1/0 for seen/not-seen, row 3 is fixated 1/0 (always 1 if <code>checkFixationOK</code> not present in stim objects returned from <code>makeStim</code>).
</p>
</li>
<li> <p><code>pdfs</code> If <code>verbose</code> is bigger than 0, then this is a list of the pdfs used for each presentation, otherwise NULL.
</p>
</li>
<li> <p><code>final</code> The mean/median/mode of the final pdf, depending on <code>stimChoice</code>, which is the determined threshold.
</p>
</li>
<li> <p><code>opiResp</code> A list of responses received from each successful call to <code>opiPresent</code> within <code>KTPsi</code>.
</p>
</li></ul>




<h4>Multilple locations</h4>

<p><code>KTPsi.start</code> returns a list that can be passed to <code>KTPsi.step</code>, <code>KTPsi.stop</code>, and <code>KTPsi.final</code>. It represents the state of a KTPsi at a single location at a point in time and contains the following.
</p>

<ul>
<li> <p><code>name</code> <code>KTPsi</code>
</p>
</li>
<li><p> A copy of all of the parameters supplied to KTPsi.start: <code>domains</code>, <code>priors</code>, <code>stimValues</code>, <code>stopType</code>, <code>stopValue</code>, <code>maxPresentations</code>, <code>makeStim</code> and <code>opiParams</code>.
</p>
</li>
<li> <p><code>psi</code> A matrix where <code>psi[domain_index, stim]</code> is the probability of seeing <code>stim</code> assuming the psychometric function for the domain index <code>domain_index</code>.
</p>
</li>
<li> <p><code>labels</code> A text representation of <code>psi[domain_index, ]</code>, or the the psychometric function for the domain index <code>domain_index</code>.
</p>
</li>
<li> <p><code>pdf</code> Current pdf: vector of probabilities the same length as product of lengths of <code>domain</code> elements.
</p>
</li>
<li> <p><code>numPresentations</code> The number of times <code>KTPsi.step</code> has been called on this state.
</p>
</li>
<li> <p><code>stimuli</code> A vector containing the stimuli used at each call of <code>KTPsi.step</code>.
</p>
</li>
<li> <p><code>responses</code> A vector containing the responses received at each call of <code>KTPsi.step</code>.
</p>
</li>
<li> <p><code>responseTimes</code> A vector containing the response times received at each call of <code>KTPsi.step</code>.
</p>
</li>
<li> <p><code>fixated</code> A vector containing TRUE/FALSE if fixation was OK according to <code>checkFixationOK</code> for each call of <code>KTPsi.step</code> (defaults to TRUE if <code>checkFixationOK</code> not present).
</p>
</li>
<li> <p><code>opiResp</code> A list of responses received from each call to <code>opiPresent</code> within <code>KTPsi.step</code>.
</p>
</li></ul>

<p><code>KTPsi.step</code> returns a list containing
</p>

<ul>
<li> <p><code>stat:</code> The new state after presenting a stimuli and getting a response.
</p>
</li>
<li> <p><code>resp</code> The return from the <code>opiPresent</code> call that was made.
</p>
</li></ul>

<p><code>KTPsi.stop</code> returns <code>TRUE</code> if the KTPsi has reached its stopping criteria, and <code>FALSE</code> otherwise.
</p>
<p><code>KTPsi.final</code> returns an estimate of threshold based on state based on its parameter.
</p>

<p>TRUE if the <code>state</code> has reached its stopping criteria, and FALSE otherwise.
</p>


<h3>References</h3>

<p>Kontsevich and Tyler. Vision Research 39 (1999) pages 2729&ndash;2737.
</p>
<p>A. Turpin, D. Jankovic and A.M. McKendrick,
&quot;Identifying Steep Psychometric Function Slope Quickly in Clinical Applications&quot;,
Vision Research, 50(23). November 2010. Pages 2476-2485
</p>
<p>A. Turpin, P.H. Artes and A.M. McKendrick &quot;The Open Perimetry Interface: An enabling tool for
clinical visual psychophysics&quot;, Journal of Vision 12(11) 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("SimGaussian")
if(!is.null(opiInitialize(sd = 2)$err))
  stop("opiInitialize failed")

     # This section is for single location KTPsi
     # Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500, checkFixationOK=NULL)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}

KTPsi(makeStim = makeStim, stopType="H", stopValue=  3, tt=30, fpr=0.03)
KTPsi(makeStim = makeStim, stopType="N", stopValue= 27, verbose = 0, tt=30, fpr=0.03)

     # For multiple locations...
## Not run: 
states &lt;- lapply(1:10, function(loc) KTPsi.start(makeStim = makeStim))
unfinished &lt;- 1:10
while (length(unfinished) &gt; 0) {
     loc &lt;- unfinished[[1]]
     states[[loc]] &lt;- KTPsi.step(states[[loc]])$state
     if (KTPsi.stop(states[[loc]]))
         unfinished &lt;- unfinished[-1]
}

## End(Not run)

</code></pre>

<hr>
<h2 id='MOCS'>Method of Constant Stimuli (MOCS)</h2><span id='topic+MOCS'></span>

<h3>Description</h3>

<p>MOCS performs either a yes/no or n-interval-forced-choice Method of
Constant Stimuli test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOCS(
  params = NA,
  order = "random",
  responseWindowMeth = "constant",
  responseFloor = 1500,
  responseHistory = 5,
  keyHandler = function(correct, ret) return(list(seen = TRUE, time = 0, err = NULL)),
  interStimMin = 200,
  interStimMax = 500,
  beep_function,
  makeStim,
  stim_print,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOCS_+3A_params">params</code></td>
<td>
<p>A matrix where each row is <code>x y i n correct_n ll1 ll2 ... llm</code> where
</p>

<ul>
<li> <p><code>x</code> is X coordinate of location
</p>
</li>
<li> <p><code>y</code> is Y coordinate of location
</p>
</li>
<li> <p><code>i</code> is a location number (assigned by caller)
</p>
</li>
<li> <p><code>n</code> is Number of times this location/luminance(s) should be repeated
</p>
</li>
<li> <p><code>correct_n</code> is the index i of the luminance level (<code>lli</code>) that
should be treated as a &ldquo;correct&rdquo; response (the correct interval). For a
standard MOCS, this will be 1; for a 2AFC, this will be 1 or 2. This number will
be in the range <code>[1,m]</code>.
</p>
</li>
<li> <p><code>lli</code> is the i'th luminance level to be used at this location for
interval i of the presentation in cd/<code class="reqn">\mbox{m}^2</code>. For a standard MOCS,
i=1, and the <code>params</code> matrix will have 5 columns. For a 2AFC, there will be
two lli's, and <code>params</code> will have 6 columns.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MOCS_+3A_order">order</code></td>
<td>
<p>Control the order in which the stimuli are presented.
</p>

<ul>
<li> <p><code>"random"</code> Randomise the order of trials/locations.
</p>
</li>
<li> <p><code>"fixed"</code> Present each row of <code>params</code> in order of <code>1:nrow(params)</code>, ignoring the <code>n</code> (4th) column in <code>params</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MOCS_+3A_responsewindowmeth">responseWindowMeth</code></td>
<td>
<p>Control time perimeter waits for response.
</p>

<ul>
<li> <p><code>"speed"</code> After an average of the last <code>speedHistory</code> response times, with a minimum of <code>responseFloor</code>. Initially #'       <code>responseFloor</code>.
</p>
</li>
<li> <p><code>"constant"</code> Always use <code>responseFloor</code>.
</p>
</li>
<li> <p><code>"forceKey"</code> Wait for a keyboard input.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MOCS_+3A_responsefloor">responseFloor</code></td>
<td>
<p>Minimum response window (for any <code>responseWindowMeth</code> except <code>"forceKey"</code>).</p>
</td></tr>
<tr><td><code id="MOCS_+3A_responsehistory">responseHistory</code></td>
<td>
<p>Number of past yeses to average to get response window
(only used if <code>responseWindowMeth</code> is <code>"speed"</code>).</p>
</td></tr>
<tr><td><code id="MOCS_+3A_keyhandler">keyHandler</code></td>
<td>
<p>Function to get a keyboard input and returns as for <code>opiPresent</code>:
<code>err</code>, <code>seen</code> and <code>time</code>. The parameters passed to
the function are the correct interval number (column 4 of <code>params</code>), and the
result of <code>opiPresent</code>. See Examples.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_interstimmin">interStimMin</code></td>
<td>
<p>Regardless of response, wait <code>runif(interStimMin, interStimMax)</code> ms.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_interstimmax">interStimMax</code></td>
<td>
<p>Regardless of response, wait <code>runif(interStimMin, interStimMax)</code> ms.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_beep_function">beep_function</code></td>
<td>
<p>A function that takes the string <code>'correct'</code>, the string
<code>'incorrect'</code>, or a stimulus number and plays an appropriate sound.  See examples.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_makestim">makeStim</code></td>
<td>
<p>A helper function to take a row of <code>params</code> and a response window length
in ms, and create a list of OPI stimuli types for passing to opiPresent. This may include a
<code>checkFixationOK</code> function. See Example.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_stim_print">stim_print</code></td>
<td>
<p>A function that takes an <code>opiStaticStimulus</code> and return list from
<code>opiPresent</code> and returns a string to print for each presentation. It is called
immediately after each <code>opiPresent</code>, and the string is prepended with the
(x,y) coordinates of the presentation and ends with a newline.</p>
</td></tr>
<tr><td><code id="MOCS_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whether the test is yes/no or forced-choice is determined by the number of columns
in <code>params</code>. The code simply presents all columns from 5 onwards and collects a
response at the end. So if there is only 5 columns, it is a yes/no task. If there are 6
columns it is a 2-interval-forced-choice. Generally, an nIFC experiment has 4+n columns in
<code>params</code>.
</p>
<p>Note that when the <code>order</code> is <code>"random"</code>, the number of trials in the test will be
the sum of the 3rd column of <code>params</code>. When the <code>order</code> is <code>"fixed"</code>, there is
only one presentation per row, regardless of the value in the 3rd column of <code>params</code>.
</p>
<p>If a response is received before the final trial in a nIFC experiment, it is ignored.
</p>
<p>If the <code>checkFixationOK</code> function is present in a stimulus, then it is called after each
presentation, and the result is &ldquo;anded&rdquo; with each stimulus in a trial to get a TRUE/FALSE
for fixating on all stimuli in a trial.
</p>


<h3>Value</h3>

<p>Returns a data.frame with one row per stimulus copied from params with extra columns
appended: checkFixation checks, and the return values from <code>opiPresent()</code>
(see example). These last values will differ depending on which
machine/simulation you are running (as chosen with <code>chooseOpi()</code>.
</p>

<ul>
<li><p> column 1: x
</p>
</li>
<li><p> column 2: y
</p>
</li>
<li><p> column 3: location number
</p>
</li>
<li><p> column 4: number of times to repeat this stim
</p>
</li>
<li><p> column 5: correct stimulus index
</p>
</li>
<li><p> column 6: TRUE/FALSE was fixating for all presentations in this trial according to <code>checkFixationOK</code>
</p>
</li>
<li><p> column 7...: columns from params
</p>
</li>
<li><p> ...: columns from opiPresent return
</p>
</li></ul>



<h3>References</h3>

<p>A. Turpin, P.H. Artes and A.M. McKendrick. &quot;The Open Perimetry Interface: An enabling tool for
clinical visual psychophysics&quot;, Journal of Vision 12(11) 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the Octopus 900
# Check if pupil centre is within 10 pixels of (160,140)
checkFixationOK &lt;- function(ret) return(sqrt((ret$pupilX - 160)^2 + (ret$pupilY - 140)^2) &lt; 10)

# Return a list of opi stim objects (list of class opiStaticStimulus) for each level (dB) in
# p[5:length(p)]. Each stim has responseWindow BETWEEN_FLASH_TIME, except the last which has
# rwin. This one assumes p is on old Octopus 900 dB scale (0dB == 4000 cd/m^2).
makeStim &lt;- function(p, rwin) {
  BETWEEN_FLASH_TIME &lt;- 750   # ms
  res &lt;- NULL
  for(i in 5:length(p)) {
    s &lt;- list(x=p[1], y=p[2], level=dbTocd(p[i],4000/pi), size=0.43, duration=200,
              responseWindow=ifelse(i &lt; length(p), BETWEEN_FLASH_TIME, rwin),
              checkFixationOK=NULL)
    class(s) &lt;- "opiStaticStimulus"
    res &lt;- c(res, list(s))
  }
  return(res)
}

################################################################
# Read in a key press 'z' is correct==1, 'm' otherwise
#    correct is either 1 or 2, whichever is the correct interval
#
# Return list(seen={TRUE|FALSE}, time=time, err=NULL))
#        seen is TRUE if correct key pressed
################################################################
## Not run: 
  if (length(dir(".", "getKeyPress.py")) &lt; 1)
    stop('Python script getKeyPress.py missing?')

## End(Not run)

keyHandler &lt;- function(correct, ret) {
  return(list(seen=TRUE, time=0, err=NULL))
  ONE &lt;- "b'z'"
  TWO &lt;- "b'm'"
  time &lt;- Sys.time()
  key &lt;- 'q'
  while (key != ONE &amp;&amp; key != TWO) {
    a &lt;- system('python getKeyPress.py', intern=TRUE)
    key &lt;- a # substr(a, nchar(a), nchar(a))
    print(paste('Key pressed: ',key,'from',a))
    if (key == "b'8'")
      stop('Key 8 pressed')
  }
  time &lt;- Sys.time() - time
  if ((key == ONE &amp;&amp; correct == 1) || (key == TWO &amp;&amp; correct == 2))
    return(list(seen=TRUE, time=time, err=NULL))
  else
    return(list(seen=FALSE, time=time, err=NULL))
}

################################################################
# Read in return value from opipresent with F310 controller.
# First param is correct, next is 1 for left button, 2 for right button
# Left button (LB) is correct for interval 1, RB for interval 2
#    correct is either 1 or 2, whichever is the correct interval
#
# Return list(seen={TRUE|FALSE}, time=time, err=NULL))
#        seen is TRUE if correct key pressed
################################################################
F310Handler &lt;- function(correct, opiResult) {
  z &lt;- opiResult$seen == correct
  opiResult$seen &lt;- z
  return(opiResult)
}

################################################################
# 2 example beep_function
################################################################
## Not run: 
  require(beepr)
  myBeep &lt;- function(type='None') {
    if (type == 'correct') {
      beepr::beep(2)  # coin noise
      Sys.sleep(0.5)
    }
    if (type == 'incorrect') {
      beepr::beep(1) # system("rundll32 user32.dll,MessageBeep -1") # system beep
      #Sys.sleep(0.0)
    }
  }
  require(audio)
  myBeep &lt;- function(type="None") {
    if (type == 'correct') {
      wait(audio::play(sin(1:10000/10)))
    }
    if (type == 'incorrect') {
      wait(audio::play(sin(1:10000/20)))
    }
  }

## End(Not run)

################################################################
# An example stim_print function
################################################################
## Not run: 
  stim_print &lt;- function(s, ret) {
    sprintf("%4.1f %2.0f",cdTodb(s$level,10000/pi), ret$seen)
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='octo900.presentKinetic'>Present Kinetic stimuli on O900 (internal use)</h2><span id='topic+octo900.presentKinetic'></span>

<h3>Description</h3>

<p>Implementation of opiPresent for Kinetic stimuli on the Octopus090 machine.
</p>
<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with
these Arguments and <code>stim</code> as class <code>opiKineticStimulus</code>
and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="octo900.presentKinetic_+3A_stim">stim</code></td>
<td>
<p>Stimulus to present (a list, see details).</p>
</td></tr>
<tr><td><code id="octo900.presentKinetic_+3A_nextstim">nextStim</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stim</code> is a list containing at least the following 3 elements:
</p>

<ul>
<li> <p><code>path</code>, A list of $(x,y)$ coordinates in degrees that is usable by <code>xy.coords()</code>.
</p>
</li>
<li> <p><code>sizes</code>, A list where <code>sizes[i]</code> is the size of stimulus (diameter in degrees)
to use for the section of path specified by <code>path[i]..path[i+1]</code>.
Rounded to nearest Goldmann size.
</p>
</li>
<li> <p><code>levels</code> A list where <code>levels[i]</code> is the stimulus luminance in cd/<code class="reqn">\mbox{m}^2</code>
to use for the section of path specified by <code>path[i]..path[i+1]</code>.
</p>
</li>
<li> <p><code>speeds</code> A list where <code>speeds[i]</code> is the speed in degrees per second
to use for the section of path specified by <code>path[i]..path[i+1]</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>err</code>  String message or NULL for no error.
</p>
</li>
<li> <p><code>seen</code> 1 if seen, 0 otherwise.
</p>
</li>
<li> <p><code>time</code> Reaction time (if seen).
</p>
</li>
<li> <p><code>x</code> Coordinate where button was pressed (degrees - i guess).
</p>
</li>
<li> <p><code>y</code> Coordinate where button was pressed (degrees - i guess).
</p>
</li></ul>


<hr>
<h2 id='octo900.presentStatic'>Present static on O900 (internal use)</h2><span id='topic+octo900.presentStatic'></span>

<h3>Description</h3>

<p>Implementation of opiPresent for the Octopus090 machine.
Version for opiStaticStimulus.
</p>
<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with
<code>stim</code> as class <code>opiStaticStimulus</code> and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="octo900.presentStatic_+3A_stim">stim</code></td>
<td>
<p>Stimulus to present (a list, see details).</p>
</td></tr>
<tr><td><code id="octo900.presentStatic_+3A_nextstim">nextStim</code></td>
<td>
<p>The stimulus to present after stim
(it is not presented, but projector can move to it during response window)</p>
</td></tr>
<tr><td><code id="octo900.presentStatic_+3A_f310">F310</code></td>
<td>
<p>If <code>F310</code> is <code>FALSE</code>, response is taken from internal button.
If <code>F310</code> is <code>TRUE</code> , response is taken from external controller</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stim</code> is a list containing at least the following 3 elements:
</p>

<ul>
<li> <p><code>x</code>, x-coordinate in degrees (floating point) (range $[-30,30]$).
</p>
</li>
<li> <p><code>y</code>, y-coordinate in degrees (floating point) (range $[-30,30]$).
</p>
</li>
<li> <p><code>level</code> is luminance in cd/<code class="reqn">\mbox{m}^2</code>, and is rounded to the nearest
whole dB for display (range 0 to 50). 0dB is 10000aps.
</p>
</li></ul>

<p>It can also contain:
</p>

<ul>
<li> <p><code>responseWindow</code> from start of stimulus presentation in milliseconds (default is 1500).
</p>
</li>
<li> <p><code>duration</code> of stimulus on in milliseconds (default 200).
</p>
</li>
<li> <p><code>color</code> one of <code>.opi_env$O900$STIM_WHITE</code>, <code>.opi_env$O900$STIM_BLUE</code> or
<code>.opi_env$O900$STIM_RED</code>.  It must be same as that initialised
by <code><a href="#topic+opiSetup">opiSetup()</a></code> or <code><a href="#topic+opiInitialize">opiInitialize()</a></code>
(default <code>.opi_env$O900$STIM_WHITE</code>).
</p>
</li>
<li> <p><code>size</code> of stimulus diameter in degrees (default Size III == 0.43).
This is rounded to the nearest support Goldmann size.
</p>
</li></ul>

<p>If responses are taken from the F310 Controller then
</p>

<ul>
<li><p> If the L button is pressed, <code>seen</code> is set to 1.
</p>
</li>
<li><p> If the R button is pressed, <code>seen</code> is set to 2.
</p>
</li>
<li><p> If no button is pressed within <code>responseWindow</code>, then <code>seen</code> is set to 0.
</p>
</li></ul>

<p>If stim is null, always return err = NULL status.
</p>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>err</code>  String message or NULL for no error.
</p>
</li>
<li> <p><code>seen</code> 1 if seen, 0 otherwise. (See details for F310)
</p>
</li>
<li> <p><code>time</code> Reaction time (if seen).
</p>
</li></ul>


<hr>
<h2 id='octo900.presentTemporal'>Present Temporal stimuli on O900 (internal use)</h2><span id='topic+octo900.presentTemporal'></span>

<h3>Description</h3>

<p>Implementation of opiPresent for Temporal stimuli on the Octopus090 machine.
</p>
<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with
these Arguments (<code>stim</code> as class <code>opiTemporalStimulus</code>)
and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="octo900.presentTemporal_+3A_stim">stim</code></td>
<td>
<p>Stimulus to present (a list, see details).</p>
</td></tr>
<tr><td><code id="octo900.presentTemporal_+3A_nextstim">nextStim</code></td>
<td>
<p>The stimulus to present after stim
(it is not presented, but projector can move to it during response window)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stim</code> is a list containing at least the following 3 elements:
</p>

<ul>
<li> <p><code>x</code>, x-coordinate in degrees (floating point) (range $[-30,30]$).
</p>
</li>
<li> <p><code>y</code>, y-coordinate in degrees (floating point) (range $[-30,30]$).
</p>
</li>
<li> <p><code>rate</code> is frequency in Hz.
</p>
</li></ul>

<p>It can also contain:
</p>

<ul>
<li> <p><code>responseWindow</code> from start of stimulus presentation in milliseconds (default is 1500).
</p>
</li>
<li> <p><code>duration</code> of stimulus on in milliseconds (default 200).
</p>
</li>
<li> <p><code>size</code> of stimulus diameter in degrees (default Size III == 0.43).
This is rounded to the nearest support Goldmann size.
</p>
</li></ul>

<p>If stim is null, always return <code>err = NULL</code> status.
</p>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>err</code>  String message or NULL for no error.
</p>
</li>
<li> <p><code>seen</code> 1 if seen, 0 otherwise.
</p>
</li>
<li> <p><code>time</code> Reaction time (if seen).
</p>
</li></ul>


<hr>
<h2 id='open_socket'>Open a socket on ip and port.</h2><span id='topic+open_socket'></span>

<h3>Description</h3>

<p>Internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>open_socket(ip, port, machineName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="open_socket_+3A_ip">ip</code></td>
<td>
<p>IP address of socket</p>
</td></tr>
<tr><td><code id="open_socket_+3A_port">port</code></td>
<td>
<p>TCP port of socket</p>
</td></tr>
<tr><td><code id="open_socket_+3A_machinename">machineName</code></td>
<td>
<p>Machine name for error message</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Socket or NULL on error
</p>

<hr>
<h2 id='opiClose'>Calls opiClose_for_MACHINE as appropriate.</h2><span id='topic+opiClose'></span>

<h3>Description</h3>

<p>Specific parameters and return values can be seen in the machine specific versions
listed below in the See Also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiClose()
</code></pre>


<h3>Value</h3>

<p>Each implementation should(!) return a list with at least the following elements:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if no error, otherwise a string describing the error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiClose_for_Compass">opiClose_for_Compass()</a></code>,
<code><a href="#topic+opiClose_for_Octopus900">opiClose_for_Octopus900()</a></code>,
<code><a href="#topic+opiClose_for_ImoVifa">opiClose_for_ImoVifa()</a></code>,
<code><a href="#topic+opiClose_for_PhoneHMD">opiClose_for_PhoneHMD()</a></code>, <code><a href="#topic+opiClose_for_Display">opiClose_for_Display()</a></code>, <code><a href="#topic+opiClose_for_PicoVR">opiClose_for_PicoVR()</a></code>,
<code><a href="#topic+opiClose_for_SimNo">opiClose_for_SimNo()</a></code>, <code><a href="#topic+opiClose_for_SimYes">opiClose_for_SimYes()</a></code>, <code><a href="#topic+opiClose_for_SimHenson">opiClose_for_SimHenson()</a></code>,
<code><a href="#topic+opiClose_for_SimGaussian">opiClose_for_SimGaussian()</a></code>
</p>

<hr>
<h2 id='opiClose_for_Compass'>Implementation of opiClose for the Compass machine.</h2><span id='topic+opiClose_for_Compass'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiClose">opiClose()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Value</h3>

<p>A list with elements
</p>

<ul>
<li> <p><code>err</code>, which is an error code, NULL for no error
</p>
</li>
<li> <p><code>fixations</code>, which is a matrix one row per fixation and three columns:
</p>

<ul>
<li> <p><code>time</code> (same as <code>time_hw</code> in <code>opiPresent</code>)
</p>
</li>
<li> <p><code>x</code> (degrees relative to the centre of the image returned by <code>opiInitialise</code> - not the PRL)
</p>
</li>
<li> <p><code>y</code> (as for x)
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='opiClose_for_Display'>Implementation of opiClose for the Display machine.</h2><span id='topic+opiClose_for_Display'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiClose">opiClose()</a></code> after
<code>chooseOPI("Display")</code> to call this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiClose">opiClose()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("Display")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiClose()

</code></pre>

<hr>
<h2 id='opiClose_for_ImoVifa'>Implementation of opiClose for the ImoVifa machine.</h2><span id='topic+opiClose_for_ImoVifa'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiClose">opiClose()</a></code> after
<code>chooseOPI("ImoVifa")</code> to call this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiClose">opiClose()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("ImoVifa")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiClose()

</code></pre>

<hr>
<h2 id='opiClose_for_KowaAP7000'>Implementation of opiClose for the Kowa AP7000 machine.</h2><span id='topic+opiClose_for_KowaAP7000'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiClose">opiClose()</a></code> with the same parameters.
</p>


<h3>Value</h3>

<p>Returns <code>list(err = NULL)</code>.
</p>

<hr>
<h2 id='opiClose_for_O600'>Implementation of opiClose for the O600 machine.</h2><span id='topic+opiClose_for_O600'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiClose">opiClose()</a></code> with the same parameters.
</p>


<h3>Value</h3>

<p>Returns <code>list(err = NULL)</code>.
</p>

<hr>
<h2 id='opiClose_for_Octopus900'>Implementation of opiClose for the Octopus900 machine.</h2><span id='topic+opiClose_for_Octopus900'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiClose">opiClose()</a></code> with the same parameters.
</p>


<h3>Value</h3>

<p>Returns <code>list(err = NULL)</code>.
</p>

<hr>
<h2 id='opiClose_for_PhoneHMD'>Implementation of opiClose for the PhoneHMD machine.</h2><span id='topic+opiClose_for_PhoneHMD'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiClose">opiClose()</a></code> after
<code>chooseOPI("PhoneHMD")</code> to call this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiClose">opiClose()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PhoneHMD")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiClose()

</code></pre>

<hr>
<h2 id='opiClose_for_PicoVR'>Implementation of opiClose for the PicoVR machine.</h2><span id='topic+opiClose_for_PicoVR'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiClose">opiClose()</a></code> after
<code>chooseOPI("PicoVR")</code> to call this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiClose">opiClose()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PicoVR")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiClose()

</code></pre>

<hr>
<h2 id='opiClose_for_SimGaussian'>opiClose_for_SimGaussian</h2><span id='topic+opiClose_for_SimGaussian'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>error</code> Always <code>FALSE</code>.
</p>
</li>
<li> <p><code>msg</code> A string &quot;Close OK&quot;.
</p>
</li></ul>


<hr>
<h2 id='opiClose_for_SimHenson'>opiClose_for_SimHenson</h2><span id='topic+opiClose_for_SimHenson'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiClose_for_SimHensonRT'>opiClose_for_SimHensonRT</h2><span id='topic+opiClose_for_SimHensonRT'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiClose_for_SimNo'>opiClose_for_SimNo</h2><span id='topic+opiClose_for_SimNo'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>error</code> Always <code>FALSE</code>.
</p>
</li>
<li> <p><code>msg</code> A string &quot;Close OK&quot;.
</p>
</li></ul>


<hr>
<h2 id='opiClose_for_SimYes'>opiClose_for_SimYes</h2><span id='topic+opiClose_for_SimYes'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiInitialise'>Calls opiInitialise_for_MACHINE as appropriate.</h2><span id='topic+opiInitialise'></span><span id='topic+opiInitialize'></span>

<h3>Description</h3>

<p>Establishes connection with the device and a Monitor (aka Server) if appropriate.
Sends any startup parameters that might be needed by the machine.
Specific parameters and return values can be seen in the machine specific versions
listed below in the See Also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiInitialise(...)

opiInitialize(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_+3A_...">...</code></td>
<td>
<p>Parameters specific to each machine as described in the 'See Also' functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing at least the following elements:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if no error, otherwise a string describing the error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiInitialise_for_ImoVifa">opiInitialise_for_ImoVifa()</a></code>,
<code><a href="#topic+opiInitialise_for_PhoneHMD">opiInitialise_for_PhoneHMD()</a></code>, <code><a href="#topic+opiInitialise_for_Display">opiInitialise_for_Display()</a></code>, <code><a href="#topic+opiInitialise_for_PicoVR">opiInitialise_for_PicoVR()</a></code>,
<code><a href="#topic+opiInitialise_for_Octopus900">opiInitialise_for_Octopus900()</a></code>,
<code><a href="#topic+opiInitialise_for_Compass">opiInitialise_for_Compass()</a></code>,
<code><a href="#topic+opiInitialise_for_SimNo">opiInitialise_for_SimNo()</a></code>, <code><a href="#topic+opiInitialise_for_SimYes">opiInitialise_for_SimYes()</a></code>, <code><a href="#topic+opiInitialise_for_SimHenson">opiInitialise_for_SimHenson()</a></code>,
<code><a href="#topic+opiInitialise_for_SimGaussian">opiInitialise_for_SimGaussian()</a></code>
</p>

<hr>
<h2 id='opiInitialise_for_Compass'>Implementation of opiInitialise for the ImoVifa machine.</h2><span id='topic+opiInitialise_for_Compass'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiInitialise">opiInitialise()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_Compass_+3A_ip">ip</code></td>
<td>
<p>IP address on which server is listening as a string</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Compass_+3A_port">port</code></td>
<td>
<p>Port number on which server is listening</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Compass_+3A_...">...</code></td>
<td>
<p>Could be used for fake compass, simulations, etc</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: this returns a list, not a single error code.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> NULL if successful, not otherwise.
</p>
</li>
<li> <p><code>prl</code> A pair giving the (x,y) in degrees of the Preferred Retinal
Locus detected in the initial alignment.
</p>
</li>
<li> <p><code>onh</code> a pair giving the (x,y) in degrees of the ONH as selected by
the user.
</p>
</li>
<li> <p><code>image</code> raw bytes being the JPEG compressed infra-red image acquired
during alignment.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Set up the Compass
  chooseOpi("Compass")
  result &lt;- opiInitialize(ip = "192.168.1.7", port = 44965)
  if (is.null(result$err))
    print(result$prl)

## End(Not run)
</code></pre>

<hr>
<h2 id='opiInitialise_for_Display'>Implementation of opiInitialise for the Display machine.</h2><span id='topic+opiInitialise_for_Display'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiInitialise">opiInitialise()</a></code> after
<code>chooseOPI("Display")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_Display_+3A_address">address</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>port</code> TCP port of the OPI Monitor.
</p>
</li>
<li> <p><code>ip</code> IP Address of the OPI Monitor.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>port</code> can take on values in the range <code>[0, 65535]</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiInitialise">opiInitialise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("Display")
result &lt;- opiInitialise(address = list(port = 50001, ip = "localhost"))

</code></pre>

<hr>
<h2 id='opiInitialise_for_ImoVifa'>Implementation of opiInitialise for the ImoVifa machine.</h2><span id='topic+opiInitialise_for_ImoVifa'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiInitialise">opiInitialise()</a></code> after
<code>chooseOPI("ImoVifa")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_ImoVifa_+3A_address">address</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>port</code> TCP port of the OPI Monitor.
</p>
</li>
<li> <p><code>ip</code> IP Address of the OPI Monitor.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>port</code> can take on values in the range <code>[0, 65535]</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiInitialise">opiInitialise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("ImoVifa")
result &lt;- opiInitialise(address = list(port = 50001, ip = "localhost"))

</code></pre>

<hr>
<h2 id='opiInitialise_for_KowaAP7000'>Implementation of opiInitialise for the Octopus900 machine.</h2><span id='topic+opiInitialise_for_KowaAP7000'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiInitialise">opiInitialise()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_KowaAP7000_+3A_ip">ip</code></td>
<td>
<p>IP address of AP7000 machine (as string)</p>
</td></tr>
<tr><td><code id="opiInitialise_for_KowaAP7000_+3A_port">port</code></td>
<td>
<p>Port number on which AP7000 server is listening</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the chosen OPI implementation is <code>KowaAP7000</code>, then you must specify
the IP address and port of the AP-7000 server.
</p>


<h3>Value</h3>

<p><code>list(err = NULL)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Set up the Kowa AP-7000
  chooseOpi("KowaAP7000")
  opiInitialize(ip="192.168.1.7", port=44965)

## End(Not run)
</code></pre>

<hr>
<h2 id='opiInitialise_for_O600'>Implementation of opiInitialise for the O600 machine.</h2><span id='topic+opiInitialise_for_O600'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiInitialise">opiInitialise()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_O600_+3A_ipaddress">ipAddress</code></td>
<td>
<p>The IP address of the O600 as a string.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_O600_+3A_eye">eye</code></td>
<td>
<p>Either &quot;left&quot; or &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_O600_+3A_pupiltracking">pupilTracking</code></td>
<td>
<p>TRUE to turn on IR illumination and set pupil
black level (which happens at the first stimulus presentation).</p>
</td></tr>
<tr><td><code id="opiInitialise_for_O600_+3A_pulsar">pulsar</code></td>
<td>
<p>TRUE for pulsar stimulus, FALSE for size III white-on-white.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_O600_+3A_eyecontrol">eyeControl</code></td>
<td>
<p>One of
</p>
<div class="sourceCode"><pre>* 0 is off
* 1 is eye blink
* 2 is eye blink, forehead rest, fixation control
* 3 is eye blink, forehead rest, fixation control, fast eye movements
</pre></div></td></tr>
</table>


<h3>Details</h3>

<p>The default
background and stimulus setup is to white-on-white perimetry.
</p>
<p>Uses port 50000 on the O600.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Set up the O600
  chooseOpi("O600")
  opiInitialize(ip="192.168.1.7", eye = "left")

## End(Not run)
</code></pre>

<hr>
<h2 id='opiInitialise_for_Octopus900'>Implementation of opiInitialise for the Octopus900 machine.</h2><span id='topic+opiInitialise_for_Octopus900'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiInitialise">opiInitialise()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_Octopus900_+3A_serverport">serverPort</code></td>
<td>
<p>port number on which server is listening for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Octopus900_+3A_eyesuitesettingslocation">eyeSuiteSettingsLocation</code></td>
<td>
<p>dir name containing EyeSuite settings for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Octopus900_+3A_eye">eye</code></td>
<td>
<p>eye; &quot;right&quot; or &quot;left&quot; for &quot;Octopus900&quot;, &quot;Octopus600&quot;</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Octopus900_+3A_gazefeed">gazeFeed</code></td>
<td>
<p>NA or a folder name for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Octopus900_+3A_bigwheel">bigWheel</code></td>
<td>
<p>FALSE (standard machine), TRUE for modified aperture wheel for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Octopus900_+3A_pres_buzzer">pres_buzzer</code></td>
<td>
<p>0 (no buzzer),1, 2, 3 (max volume) for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Octopus900_+3A_resp_buzzer">resp_buzzer</code></td>
<td>
<p>0 (no buzzer),1, 2, 3 (max volume) for &quot;Octopus900&quot;</p>
</td></tr>
<tr><td><code id="opiInitialise_for_Octopus900_+3A_zero_db_is_10000_asb">zero_dB_is_10000_asb</code></td>
<td>
<p>Is 0 dB 10000 apostilb (TRUE) or or 4000 (FALSE) for &quot;Octopus900&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the chosen OPI implementation is <code>Octopus900</code>, then you must specify
a directory and the eye to be tested.
</p>
<p><code>serverPort</code> is the TCP/IP port on which the server is listening (on
localhost).
</p>
<p><code>eyeSuiteSettingsLocation</code> is the folder name containing the EyeSuite
setting files, and should include the trailing slash.
</p>
<p><code>eye</code> must be either &quot;left&quot; or &quot;right&quot;.
</p>
<p><code>gazeFeed</code> is the name of an existing folder into which the video frames
of eye tracker are recorded. Set to <code>NA</code> for no recording.
</p>
<p><code>bigWheel</code> is <code>FALSE</code> for a standard Octopus 900 machine. Some
research machines are fitted with an alternate aperture wheel that has 24
sizes, which are accessed with <code>bigWheel</code> is <code>TRUE</code>. The mapping
from size to 'hole on wheel' is hard coded; see code for details.
</p>
<p>If <code>pres_buzzer</code> is greater than zero, a buzzer will sound with each
stimuli presented.
</p>
<p>If <code>resp_buzzer</code> is greater than zero, a buzzer will sound with each
button press (response). The volume can be one of 0 (no buzzer), 1, 2, or 3
(max volume). If both buzzers are more than zero, the maximum of the two will
be used as the volume.
</p>
<p>If <code>zero_dB_is_10000_asb</code> is <code>TRUE</code> then 0 dB is taken as 10000
apostilbs, otherwise 0 dB is taken as 4000 apostilbs.
</p>


<h3>Value</h3>

<p>A list containing <code>err</code> which is
</p>

<ul>
<li><p> NULL if successful
</p>
</li>
<li><p> 1 if Octopus900 is already initialised by a previous call to <code>opiInitialize</code>
</p>
</li>
<li><p> 2 if some error occurred that prevented initialisation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  chooseOpi("Octopus900")
  res &lt;- opiInitialize(serverPort = 50001,
                       eyeSuiteSettingsLocation = "C:/ProgramData/Haag-Streit/EyeSuite/",
                       eye = "", gazeFeed = "", bigWheel = FALSE,
                       pres_buzzer = 0, resp_buzzer = 0, zero_dB_is_10000_asb = TRUE)
  if (!is.null(res$err))
      stop("opiInitialize failed")

## End(Not run)
</code></pre>

<hr>
<h2 id='opiInitialise_for_PhoneHMD'>Implementation of opiInitialise for the PhoneHMD machine.</h2><span id='topic+opiInitialise_for_PhoneHMD'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiInitialise">opiInitialise()</a></code> after
<code>chooseOPI("PhoneHMD")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_PhoneHMD_+3A_address">address</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>port</code> TCP port of the OPI Monitor.
</p>
</li>
<li> <p><code>ip</code> IP Address of the OPI Monitor.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>port</code> can take on values in the range <code>[0, 65535]</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiInitialise">opiInitialise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PhoneHMD")
result &lt;- opiInitialise(address = list(port = 50001, ip = "localhost"))

</code></pre>

<hr>
<h2 id='opiInitialise_for_PicoVR'>Implementation of opiInitialise for the PicoVR machine.</h2><span id='topic+opiInitialise_for_PicoVR'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiInitialise">opiInitialise()</a></code> after
<code>chooseOPI("PicoVR")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_PicoVR_+3A_address">address</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>port</code> TCP port of the OPI Monitor.
</p>
</li>
<li> <p><code>ip</code> IP Address of the OPI Monitor.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>port</code> can take on values in the range <code>[0, 65535]</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiInitialise">opiInitialise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PicoVR")
result &lt;- opiInitialise(address = list(port = 50001, ip = "localhost"))

</code></pre>

<hr>
<h2 id='opiInitialise_for_SimGaussian'>opiInitialize_for_SimGaussian</h2><span id='topic+opiInitialise_for_SimGaussian'></span>

<h3>Description</h3>

<p>Simulates responses using a Frequency of Seeing (FoS) curve.
</p>
<p>The FoS is modelled as a cumulative Gaussian function with standard deviation
equal to <code>sd</code> as provided and the mean as the true threshold given as <code>tt</code>
<a href="#topic+opiPresent">opiPresent</a>.
All values are in dB relative to <code>maxStim</code>.
</p>
<p>This is for internal use only, use <code><a href="#topic+opiInitialize">opiInitialize()</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_SimGaussian_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of Cumulative Gaussian.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimGaussian_+3A_maxstim">maxStim</code></td>
<td>
<p>The maximum stimuls value (0 dB) in cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimGaussian_+3A_...">...</code></td>
<td>
<p>Any other parameters you like, they are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> NULL if initialised, a message otherwise
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    # Set up a simple simulation for white-on-white perimetry
chooseOpi("SimGaussian")
res &lt;- opiInitialize(sd = 2.5)
if (!is.null(res$err))
  stop(paste("opiInitialize() failed:", res$msg))

</code></pre>

<hr>
<h2 id='opiInitialise_for_SimHenson'>opiInitialise_for_SimHenson</h2><span id='topic+opiInitialise_for_SimHenson'></span>

<h3>Description</h3>

<p>Simulates responses using a Frequency of Seeing (FoS) curve.
</p>
<p>For internal use only, use <code>opiInitialize()</code>.
</p>
<p>The FoS is modelled as a cumulative Gaussian function over dB with
standard deviation equal to <code>min(cap, exp( A * t + B))</code>, where
t is the threshold/mean of the FoS in dB.
All values are in dB relative to <code>maxStim</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_SimHenson_+3A_type">type</code></td>
<td>
<p>A single character that is:
</p>

<ul>
<li> <p><code>N</code> for using the A and B values from the Normals in Henson et al (2000)
</p>
</li>
<li> <p><code>G</code> for using the A and B values from the Glaucomas in Henson et al (2000)
</p>
</li>
<li> <p><code>C</code> for using the A and B values from the Combined in Henson et al (2000)
</p>
</li>
<li> <p><code>X</code> to specify your own A and B values as parameters
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHenson_+3A_a">A</code></td>
<td>
<p>Coefficient of <code>t</code> in the formula (ignored if <code>type != 'X'</code>).</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHenson_+3A_b">B</code></td>
<td>
<p>Addend of <code>t</code> in the formula (ignored if <code>type != 'X'</code>).</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHenson_+3A_cap">cap</code></td>
<td>
<p>Maximum dB value for the stdev of the FoS curve.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHenson_+3A_maxstim">maxStim</code></td>
<td>
<p>The maximum stimulus value (0 dB) in cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHenson_+3A_...">...</code></td>
<td>
<p>Any other parameters you like, they are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> NULL if initialised, msg otherwise
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    # Set up a simple simulation for white-on-white perimetry
chooseOpi("SimHenson")
res &lt;- opiInitialize(type = "C", cap = 6)
if (!is.null(res$err))
  stop(paste("opiInitialize() failed:", res$err))

</code></pre>

<hr>
<h2 id='opiInitialise_for_SimHensonRT'>opiInitialise_for_SimHensonRT</h2><span id='topic+opiInitialise_for_SimHensonRT'></span>

<h3>Description</h3>

<p>Simulates responses using a Frequency of Seeing (FoS) curve.
</p>
<p>For internal use only, use <code>opiInitialize()</code>.
</p>
<p>The FoS is modelled as a cumulative Gaussian function over dB with
standard deviation equal to <code>min(cap, exp( A * t + B))</code>, where
t is the threshold/mean of the FoS in dB.
All values are in dB relative to <code>maxStim</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_SimHensonRT_+3A_type">type</code></td>
<td>
<p>A single character that is:
</p>

<ul>
<li> <p><code>N</code> for using the A and B values from the Normals in Henson et al (2000)
</p>
</li>
<li> <p><code>G</code> for using the A and B values from the Glaucomas in Henson et al (2000)
</p>
</li>
<li> <p><code>C</code> for using the A and B values from the Combined in Henson et al (2000)
</p>
</li>
<li> <p><code>X</code> to specify your own A and B values as parameters
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHensonRT_+3A_a">A</code></td>
<td>
<p>Coefficient of <code>t</code> in the formula (ignored if <code>type != 'X'</code>).</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHensonRT_+3A_b">B</code></td>
<td>
<p>Addend of <code>t</code> in the formula (ignored if <code>type != 'X'</code>).</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHensonRT_+3A_cap">cap</code></td>
<td>
<p>Maximum dB value for the stdev of the FoS curve.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHensonRT_+3A_maxstim">maxStim</code></td>
<td>
<p>The maximum stimulus value (0 dB) in cd/<code class="reqn">\mbox{m}^2</code>.</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHensonRT_+3A_rtdata">rtData</code></td>
<td>
<p>A data.frame with colnames == &quot;Rt&quot;, &quot;Dist&quot;, &quot;Person&quot; (or NULL for default).</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHensonRT_+3A_rtfp">rtFP</code></td>
<td>
<p>A response time for false positives ??? for &quot;SimHensonRT&quot;</p>
</td></tr>
<tr><td><code id="opiInitialise_for_SimHensonRT_+3A_...">...</code></td>
<td>
<p>Any other parameters you like, they are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the chosen OPI implementation is <code>SimHensonRT</code>, then the first six
parameters are as in <code>SimHenson</code>, and <code>rtData</code> is a data frame
with at least 2 columns: <code>"Rt"</code>, response time; and <code>"Dist"</code>,
signifying that distance between assumed threshold and stimulus value in
your units.
</p>
<p>This package contains <code>RtSigmaUnits</code> or <code>RtDbUnits</code> that can be
loaded with the commands <code>data(RtSigmaUnits)</code> or <code>data(RtDbUnits)</code>,
and are suitable to pass as values for <code>rtData</code>.
</p>
<p><code>rtFp</code> gives the vector of values in milliseconds from which a response
time for a false positive response is randomly sampled.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> NULL if initialised, string msg otherwise
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Set up a simple simulation for white-on-white perimetry
# and display the stimuli in a plot region and simulate response times
chooseOpi("SimHensonRT")
data(RtSigmaUnits)
oi &lt;- opiInitialize(type="C", cap=6, display=NA, rtData=RtSigmaUnits, rtFP=1:100)
if (!is.null(oi$err))
  stop("opiInitialize failed")

    # Set up a simple simulation for white-on-white perimetry
chooseOpi("SimHenson")
res &lt;- opiInitialize(type = "C", cap = 6)
if (!is.null(res$err))
  stop(paste("opiInitialize() failed:", res$err))

</code></pre>

<hr>
<h2 id='opiInitialise_for_SimNo'>opiInitialise_for_SimNo</h2><span id='topic+opiInitialise_for_SimNo'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_SimNo_+3A_...">...</code></td>
<td>
<p>Any object you like, it is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiInitialise_for_SimYes'>opiInitialise_for_SimYes</h2><span id='topic+opiInitialise_for_SimYes'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiInitialise_for_SimYes_+3A_...">...</code></td>
<td>
<p>Any object you like, it is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiKineticStimulus'>For backwards compatibility. Used by Octopus900 and KowaAP7000.</h2><span id='topic+opiKineticStimulus'></span>

<h3>Description</h3>

<p>For backwards compatibility. Used by Octopus900 and KowaAP7000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiKineticStimulus()
</code></pre>

<hr>
<h2 id='opiPresent'>Calls opiPresent_for_MACHINE as appropriate.</h2><span id='topic+opiPresent'></span>

<h3>Description</h3>

<p>Specific parameters and return values can be seen in the machine specific versions
listed below in the See Also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiPresent(stim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_+3A_stim">stim</code></td>
<td>
<p>A stimulus object or list as described for each machine in the 'See Also' methods.</p>
</td></tr>
<tr><td><code id="opiPresent_+3A_...">...</code></td>
<td>
<p>Other arguments that might be needed by each machine in the 'See Also' methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each implementation should(!) return a list with at least the following elements:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if no error, otherwise a string describing the error.
</p>
</li>
<li> <p><code>seen</code> <code>TRUE</code> if stimulus seen, <code>FALSE</code> otherwise
</p>
</li>
<li> <p><code>time</code> Response time from onset of stimulus in milliseconds.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiPresent_for_Compass">opiPresent_for_Compass()</a></code>,
<code><a href="#topic+opiPresent_for_Octopus900">opiPresent_for_Octopus900()</a></code>,
<code><a href="#topic+opiPresent_for_ImoVifa">opiPresent_for_ImoVifa()</a></code>,
<code><a href="#topic+opiPresent_for_PhoneHMD">opiPresent_for_PhoneHMD()</a></code>, <code><a href="#topic+opiPresent_for_Display">opiPresent_for_Display()</a></code>, <code><a href="#topic+opiPresent_for_PicoVR">opiPresent_for_PicoVR()</a></code>,
<code><a href="#topic+opiPresent_for_SimNo">opiPresent_for_SimNo()</a></code>, <code><a href="#topic+opiPresent_for_SimYes">opiPresent_for_SimYes()</a></code>, <code><a href="#topic+opiPresent_for_SimHenson">opiPresent_for_SimHenson()</a></code>,
<code><a href="#topic+opiPresent_for_SimGaussian">opiPresent_for_SimGaussian()</a></code>
</p>

<hr>
<h2 id='opiPresent_for_Compass'>Implementation of opiPresent for the Compass machine.</h2><span id='topic+opiPresent_for_Compass'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiSetup">opiSetup()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_Compass_+3A_stim">stim</code></td>
<td>
<p>A list of stimulus parameters (see Details).</p>
</td></tr>
<tr><td><code id="opiPresent_for_Compass_+3A_nextstim">nextStim</code></td>
<td>
<p>Unused - included for compliance with OPI standard.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the chosen OPI implementation is <code>Compass</code>, then <code>nextStim</code>
is ignored. Note that the dB level is rounded to the nearest integer.
</p>
<p>If tracking is on, then this will block until the tracking is obtained,
and the stimulus presented.
</p>
<p><code>stim</code> is a list containing some or all of the following elements:
</p>

<ul>
<li> <p><code>x</code>, x-coordinate in degrees (floating point) (range $[-30,30]$).
</p>
</li>
<li> <p><code>y</code>, y-coordinate in degrees (floating point) (range $[-30,30]$).
</p>
</li>
<li> <p><code>level</code> is luminance in cd/<code class="reqn">\mbox{m}^2</code>, and is rounded to the nearest
whole dB for display (range 0 to 50). 0dB is 10000aps.
</p>
</li>
<li> <p><code>responseWindow</code> is in milliseconds (range 0 to 2680).
</p>
</li></ul>

<p>Stimulus duration is assumed to be 200ms, and size is assumed to be
Goldmann III (0.43 degrees diameter),  color is assumed to be white.
These cannot be changed.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> 0 all clear, &gt;= 1 some error codes (eg cannot track, etc) (integer)
</p>
</li>
<li> <p><code>seen</code> <code>FALSE</code> for not seen, <code>TRUE</code> for seen (button pressed in response window)
</p>
</li>
<li> <p><code>time</code> Response time in ms (integer) since stimulus onset, -1 for not seen
</p>
</li>
<li> <p><code>time_rec</code> Time since epoch when command was received at Compass (integer ms)
</p>
</li>
<li> <p><code>time_pres</code> Time since epoch that stimulus was presented (integer ms)
</p>
</li>
<li> <p><code>num_track_events</code> Number of tracking events that occurred during presentation (integer)
</p>
</li>
<li> <p><code>num_motor_fails</code> Number of times motor could not follow fixation movement during presentation (integer)
</p>
</li>
<li> <p><code>pupil_diam</code> Pupil diameter in mm (float)
</p>
</li>
<li> <p><code>loc_x</code> Pixels integer, location in image of presentation (integer)
</p>
</li>
<li> <p><code>loc_y</code> Pixels integer, location in image of presentation (integer)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Set up the Compass
  chooseOpi("Compass")
  result &lt;- opiInitialize(ip = "192.168.1.7", port = 44965)
  if (!is.null(result$err))
    stop("Initialisation failed")

   #' @param x X location of stim in degrees
   #' @param y Y location of stim in degrees
   #' @param size If 3, Goldmann III, else V
   #' @param db Value in dB
   #' @return stim object ready for opiPresent
   makeStim &lt;- function(x, y, size, db) {
       s &lt;- list(x = x, y = y, level = dbTocd(db, 10000 / pi),
           size = ifelse(size == 3, 0.43, 1.77),
           duration = 200, responseWindow = 1500)
       class(s) &lt;- "opiStaticStimulus"
       return(s)
   }

   result &lt;- opiPresent(makeStim(9, 9, 3, 10))

## End(Not run)

</code></pre>

<hr>
<h2 id='opiPresent_for_Display'>Implementation of opiPresent for the Display machine.</h2><span id='topic+opiPresent_for_Display'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> after
<code>chooseOPI("Display")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_Display_+3A_stim">stim</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>lum</code> List of stimuli luminances (cd/m^2).
</p>
</li>
<li> <p><code>stim.length</code> The number of elements in this stimuli.
</p>
</li>
<li> <p><code>color1</code> List of stimulus colors for FLAT shapes and patterns.
</p>
</li>
<li> <p><code>sx</code> List of diameters along major axis of ellipse (degrees).
</p>
</li>
<li> <p><code>sy</code> List of diameters along minor axis of ellipse (degrees).
</p>
</li>
<li> <p><code>eye</code> The eye for which to apply the settings.
</p>
</li>
<li> <p><code>t</code> List of stimuli presentation times (ms). If 0, then the next stim
list element will be shown simultaneously.
</p>
</li>
<li> <p><code>w</code> Time to wait for response including presentation time (ms).
</p>
</li>
<li> <p><code>x</code> List of x co-ordinates of stimuli (degrees).
</p>
</li>
<li> <p><code>y</code> List of y co-ordinates of stimuli (degrees).
</p>
</li>
<li> <p><code>envSdx</code> (Optional) List of envelope sd in x direction in degrees.
Only useful if envType != NONE
</p>
</li>
<li> <p><code>envSdy</code> (Optional) List of envelope sd in y direction in degrees.
Only useful if envType != NONE
</p>
</li>
<li> <p><code>envRotation</code> (Optional) List of envelope rotations in degrees. Only useful if envType != NONE
</p>
</li>
<li> <p><code>type</code> (Optional) Stimulus type. Values include FLAT, SINE,
CHECKERBOARD, SQUARESINE, G1, G2, G3, IMAGE
</p>
</li>
<li> <p><code>frequency</code> (Optional) List of frequencies (in cycles per degrees)
for generation of spatial patterns. Only useful if type != FLAT
</p>
</li>
<li> <p><code>color2</code> (Optional) List of second colors for non-FLAT shapes
</p>
</li>
<li> <p><code>fullFoV</code> (Optional) If !0 fullFoV scales image to full field of view
and sx/sy are ignored.
</p>
</li>
<li> <p><code>phase</code> (Optional) List of phases (in degrees) for generation of
spatial patterns. Only useful if type != FLAT
</p>
</li>
<li> <p><code>imageFilename</code> (Optional) If type == IMAGE, the filename on the
local filesystem of the machine running JOVP of the image to use
</p>
</li>
<li> <p><code>shape</code> (Optional) Stimulus shape. Values include CROSS, TRIANGLE,
CIRCLE, SQUARE, OPTOTYPE.
</p>
</li>
<li> <p><code>rotation</code> (Optional) List of angles of rotation of stimuli
(degrees). Only useful if sx != sy specified.
</p>
</li>
<li> <p><code>texRotation</code> (Optional) List of angles of rotation of stimuli
(degrees). Only useful if type != FLAT
</p>
</li>
<li> <p><code>defocus</code> (Optional) List of defocus values in Diopters for stimulus post-processing.
</p>
</li>
<li> <p><code>envType</code> (Optional) List of envelope types to apply to the stims).
Only useful if type != FLAT
</p>
</li>
<li> <p><code>contrast</code> (Optional) List of stimulus contrasts (from 0 to 1). Only
useful if type != FLAT.
</p>
</li>
<li> <p><code>optotype</code> (Optional) If shape == OPTOTYPE, the letter A to Z to use
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiPresent_for_Display_+3A_...">...</code></td>
<td>
<p>Parameters for other opiPresent implementations that are ignored here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements in <code>lum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>stim.length</code> can take on values in the range <code>[1, 2147483647]</code>.
</p>
<p>Elements in <code>color1</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>sx</code> can take on values in the range <code>[0.0, 180.0]</code>.
</p>
<p>Elements in <code>sy</code> can take on values in the range <code>[0.0, 180.0]</code>.
</p>
<p>Elements in <code>eye</code> can take on values in the set
<code>{"left", "right", "both", "none"}</code>.
</p>
<p>Elements in <code>t</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>w</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>x</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>y</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>envSdx</code> can take on values in the range
<code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>envSdy</code> can take on values in the range
<code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>envRotation</code> can take on values in
the range <code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>type</code> can take on values in the set
<code>{"flat", "checkerboard", "sine", "squaresine", "g1",
                 "g2", "g3", "text", "image"}</code>.
</p>
<p>Elements in <code>frequency</code> can take on values in the
range <code>[0.0, 300.0]</code>.
</p>
<p>Elements in <code>color2</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>fullFoV</code> can take on values in the
range <code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>phase</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>shape</code> can take on values in the set
<code>{"triangle", "square", "polygon", "hollow_triangle",
                  "hollow_square", "hollow_polygon", "cross", "maltese",
                  "circle", "annulus", "optotype", "text", "model"}</code>.
</p>
<p>Elements in <code>rotation</code> can take on values in the range <code>[0.0, 360.0]</code>.
</p>
<p>Elements in <code>texRotation</code> can take on values in
the range <code>[0.0, 360.0]</code>.
</p>
<p>Elements in <code>defocus</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>envType</code> can take on values in the set
<code>{"none", "square", "circle", "gaussian"}</code>.
</p>
<p>Elements in <code>contrast</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>optotype</code> can take on values in the
set <code>{"a", "b", "c", "d", "e", "f", "g", "h", "i",
                     "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
                     "u", "v", "w", "x", "y", "z"}</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li>
<li> <p><code>time</code> Response time from stimulus onset if button pressed (ms).
</p>
</li>
<li> <p><code>seen</code> '1' if seen, '0' if not.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiPresent">opiPresent()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("Display")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiPresent(stim = list(lum = list(300.0), stim.length = 1, color1 = list(list(1.0,
                  1.0, 1.0)), sx = list(1.72), sy = list(1.72),
                  eye = list("LEFT"), t = list(200.0), w = 1500.0, x = list(0.0), y = list(0.0)))

</code></pre>

<hr>
<h2 id='opiPresent_for_ImoVifa'>Implementation of opiPresent for the ImoVifa machine.</h2><span id='topic+opiPresent_for_ImoVifa'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> after
<code>chooseOPI("ImoVifa")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_ImoVifa_+3A_stim">stim</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>lum</code> List of stimuli luminances (cd/m^2).
</p>
</li>
<li> <p><code>stim.length</code> The number of elements in this stimuli.
</p>
</li>
<li> <p><code>color1</code> List of stimulus colors for FLAT shapes and patterns.
</p>
</li>
<li> <p><code>sx</code> List of diameters along major axis of ellipse (degrees).
</p>
</li>
<li> <p><code>sy</code> List of diameters along minor axis of ellipse (degrees).
</p>
</li>
<li> <p><code>eye</code> The eye for which to apply the settings.
</p>
</li>
<li> <p><code>t</code> List of stimuli presentation times (ms). If 0, then the next stim
list element will be shown simultaneously.
</p>
</li>
<li> <p><code>w</code> Time to wait for response including presentation time (ms).
</p>
</li>
<li> <p><code>x</code> List of x co-ordinates of stimuli (degrees).
</p>
</li>
<li> <p><code>y</code> List of y co-ordinates of stimuli (degrees).
</p>
</li>
<li> <p><code>envSdx</code> (Optional) List of envelope sd in x direction in degrees.
Only useful if envType != NONE
</p>
</li>
<li> <p><code>envSdy</code> (Optional) List of envelope sd in y direction in degrees.
Only useful if envType != NONE
</p>
</li>
<li> <p><code>envRotation</code> (Optional) List of envelope rotations in degrees. Only useful if envType != NONE
</p>
</li>
<li> <p><code>type</code> (Optional) Stimulus type. Values include FLAT, SINE,
CHECKERBOARD, SQUARESINE, G1, G2, G3, IMAGE
</p>
</li>
<li> <p><code>frequency</code> (Optional) List of frequencies (in cycles per degrees)
for generation of spatial patterns. Only useful if type != FLAT
</p>
</li>
<li> <p><code>color2</code> (Optional) List of second colors for non-FLAT shapes
</p>
</li>
<li> <p><code>fullFoV</code> (Optional) If !0 fullFoV scales image to full field of view
and sx/sy are ignored.
</p>
</li>
<li> <p><code>phase</code> (Optional) List of phases (in degrees) for generation of
spatial patterns. Only useful if type != FLAT
</p>
</li>
<li> <p><code>imageFilename</code> (Optional) If type == IMAGE, the filename on the
local filesystem of the machine running JOVP of the image to use
</p>
</li>
<li> <p><code>shape</code> (Optional) Stimulus shape. Values include CROSS, TRIANGLE,
CIRCLE, SQUARE, OPTOTYPE.
</p>
</li>
<li> <p><code>rotation</code> (Optional) List of angles of rotation of stimuli
(degrees). Only useful if sx != sy specified.
</p>
</li>
<li> <p><code>texRotation</code> (Optional) List of angles of rotation of stimuli
(degrees). Only useful if type != FLAT
</p>
</li>
<li> <p><code>defocus</code> (Optional) List of defocus values in Diopters for stimulus post-processing.
</p>
</li>
<li> <p><code>envType</code> (Optional) List of envelope types to apply to the stims).
Only useful if type != FLAT
</p>
</li>
<li> <p><code>contrast</code> (Optional) List of stimulus contrasts (from 0 to 1). Only
useful if type != FLAT.
</p>
</li>
<li> <p><code>optotype</code> (Optional) If shape == OPTOTYPE, the letter A to Z to use
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiPresent_for_ImoVifa_+3A_...">...</code></td>
<td>
<p>Parameters for other opiPresent implementations that are ignored here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements in <code>lum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>stim.length</code> can take on values in the range <code>[1, 2147483647]</code>.
</p>
<p>Elements in <code>color1</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>sx</code> can take on values in the range <code>[0.0, 180.0]</code>.
</p>
<p>Elements in <code>sy</code> can take on values in the range <code>[0.0, 180.0]</code>.
</p>
<p>Elements in <code>eye</code> can take on values in the set
<code>{"left", "right", "both", "none"}</code>.
</p>
<p>Elements in <code>t</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>w</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>x</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>y</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>envSdx</code> can take on values in the range
<code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>envSdy</code> can take on values in the range
<code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>envRotation</code> can take on values in
the range <code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>type</code> can take on values in the set
<code>{"flat", "checkerboard", "sine", "squaresine", "g1",
                 "g2", "g3", "text", "image"}</code>.
</p>
<p>Elements in <code>frequency</code> can take on values in the
range <code>[0.0, 300.0]</code>.
</p>
<p>Elements in <code>color2</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>fullFoV</code> can take on values in the
range <code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>phase</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>shape</code> can take on values in the set
<code>{"triangle", "square", "polygon", "hollow_triangle",
                  "hollow_square", "hollow_polygon", "cross", "maltese",
                  "circle", "annulus", "optotype", "text", "model"}</code>.
</p>
<p>Elements in <code>rotation</code> can take on values in the range <code>[0.0, 360.0]</code>.
</p>
<p>Elements in <code>texRotation</code> can take on values in
the range <code>[0.0, 360.0]</code>.
</p>
<p>Elements in <code>defocus</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>envType</code> can take on values in the set
<code>{"none", "square", "circle", "gaussian"}</code>.
</p>
<p>Elements in <code>contrast</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>optotype</code> can take on values in the
set <code>{"a", "b", "c", "d", "e", "f", "g", "h", "i",
                     "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
                     "u", "v", "w", "x", "y", "z"}</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li>
<li> <p><code>eyedStart</code> Diameter of pupil at stimulus onset (pixels).
</p>
</li>
<li> <p><code>eyexEnd</code> x co-ordinate of pupil at button press (pixels from image
centre. Image is 640x480, left &lt; 0). Note that for
multi-part stimuli (t=0), the eye taken is the <em>last</em> eye
in the list of components.
</p>
</li>
<li> <p><code>eyeyEnd</code> y co-ordinate (pixels). See eyexEnd for more details. (up &gt; 0)
</p>
</li>
<li> <p><code>eyedEnd</code> Diameter of pupil at button press or response window expiry (pixels).
</p>
</li>
<li> <p><code>eyexStart</code> x co-ordinates of pupil at stimulus onset (pixels from
image centre. Image is 640x480, left &lt; 0). For a
multi-part stimulus (t=0), the eye taken is the <em>first</em>
eye in the list of components.
</p>
</li>
<li> <p><code>time</code> Response time from stimulus onset if button pressed (ms).
</p>
</li>
<li> <p><code>seen</code> '1' if seen, '0' if not.
</p>
</li>
<li> <p><code>eyeyStart</code> y co-ordinates (pixels from image centre). See eyexStart
for more details. (up &gt; 0)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiPresent">opiPresent()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("ImoVifa")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiPresent(stim = list(lum = list(300.0), stim.length = 1, color1 = list(list(1.0,
                  1.0, 1.0)), sx = list(1.72), sy = list(1.72),
                  eye = list("LEFT"), t = list(200.0), w = 1500.0, x = list(0.0), y = list(0.0)))

</code></pre>

<hr>
<h2 id='opiPresent_for_KowaAP7000'>Implementation of opiPresent for the KowaAP7000 machine.</h2><span id='topic+opiPresent_for_KowaAP7000'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with the same arguments and
the class of <code>stim</code> as one of <code>opiStaticStimulus</code>, <code>opiTemporalStimulus</code>, or <code>opiKineticStimulus</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_KowaAP7000_+3A_stim">stim</code></td>
<td>
<p>Stimulus to present (a list, see <code>kowa.*</code> for details).</p>
</td></tr>
<tr><td><code id="opiPresent_for_KowaAP7000_+3A_nextstim">nextStim</code></td>
<td>
<p>The stimulus to present after stim
(it is not presented, but projector can move to it during response window)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <a href="#topic+kowa.presentStatic">kowa.presentStatic</a>, <a href="#topic+kowa.presentTemporal">kowa.presentTemporal</a>, or <a href="#topic+kowa.presentKinetic">kowa.presentKinetic</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+kowa.presentStatic">kowa.presentStatic</a>, <a href="#topic+kowa.presentTemporal">kowa.presentTemporal</a>, <a href="#topic+kowa.presentKinetic">kowa.presentKinetic</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  chooseOpi("KowaAP7000")
  if (!is.null(opiInitialize()$err))
      stop("opiInitialize failed")
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500, checkFixationOK=NULL)
  class(s) &lt;- "opiStaticStimulus"
  print(opiPresent(s, NULL))

## End(Not run)

</code></pre>

<hr>
<h2 id='opiPresent_for_O600'>Implementation of opiPresent for the O600 machine.</h2><span id='topic+opiPresent_for_O600'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with the same arguments.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_O600_+3A_stim">stim</code></td>
<td>
<p>Stimulus to present which is a list with the following elements:
</p>

<ul>
<li> <p><code>x</code>  positionX (in 1/10deg)
</p>
</li>
<li> <p><code>y</code>  positionY (in 1/10deg)
</p>
</li>
<li> <p><code>level</code> dLog (intensity; 0dB is 4000 apostilbs) (in 1/10 dB)
</p>
</li>
<li> <p><code>duration</code> Stimulus presentation duration in ms, for W/W 100ms, for pulsar 500ms
</p>
</li>
<li> <p><code>responseWindow</code> Maximal allowed reaction time in ms, &gt;=500ms and &lt;4s
</p>
</li>
<li> <p><code>sound</code> # Bit 1 = sound for patient response button ON; Bit2=1 sound for fixation lost ON
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiPresent_for_O600_+3A_nextstim">nextStim</code></td>
<td>
<p>The stimulus to present after stim
(it is not presented, but projector can move to it during response window)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>err</code>  String message or NULL for no error.
</p>
</li>
<li> <p><code>seen</code> 1 if seen, 0 otherwise.
</p>
</li>
<li> <p><code>time</code> Reaction time (if seen).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  chooseOpi("O600")
  if (!is.null(opiInitialize()$err))
      stop("opiInitialize failed")
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500, checkFixationOK=NULL)
  print(opiPresent(s, NULL))

## End(Not run)


</code></pre>

<hr>
<h2 id='opiPresent_for_Octopus900'>Implementation of opiPresent for the Octopus090 machine.</h2><span id='topic+opiPresent_for_Octopus900'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> with the same arguments and
the class of <code>stim</code> as one of <code>opiStaticStimulus</code>, <code>opiTemporalStimulus</code>, or <code>opiKineticStimulus</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_Octopus900_+3A_stim">stim</code></td>
<td>
<p>Stimulus to present (a list, see <code>octo900.present*</code> for details).</p>
</td></tr>
<tr><td><code id="opiPresent_for_Octopus900_+3A_nextstim">nextStim</code></td>
<td>
<p>The stimulus to present after stim
(it is not presented, but projector can move to it during response window)</p>
</td></tr>
<tr><td><code id="opiPresent_for_Octopus900_+3A_f310">F310</code></td>
<td>
<p>If <code>F310</code> is <code>FALSE</code>, response is taken from O900 button.
If <code>F310</code> is <code>TRUE</code>, response is taken from external controller for (static stimuli only).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+octo900.presentStatic">octo900.presentStatic</a>, <a href="#topic+octo900.presentTemporal">octo900.presentTemporal</a>, <a href="#topic+octo900.presentKinetic">octo900.presentKinetic</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  chooseOpi("Octopus900")
  if (!is.null(opiInitialize()$err))
      stop("opiInitialize failed")
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500, checkFixationOK=NULL)
  class(s) &lt;- "opiStaticStimulus"
  print(opiPresent(s, NULL))

## End(Not run)

</code></pre>

<hr>
<h2 id='opiPresent_for_PhoneHMD'>Implementation of opiPresent for the PhoneHMD machine.</h2><span id='topic+opiPresent_for_PhoneHMD'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> after
<code>chooseOPI("PhoneHMD")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_PhoneHMD_+3A_stim">stim</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>lum</code> List of stimuli luminances (cd/m^2).
</p>
</li>
<li> <p><code>stim.length</code> The number of elements in this stimuli.
</p>
</li>
<li> <p><code>color1</code> List of stimulus colors for FLAT shapes and patterns.
</p>
</li>
<li> <p><code>sx</code> List of diameters along major axis of ellipse (degrees).
</p>
</li>
<li> <p><code>sy</code> List of diameters along minor axis of ellipse (degrees).
</p>
</li>
<li> <p><code>eye</code> The eye for which to apply the settings.
</p>
</li>
<li> <p><code>t</code> List of stimuli presentation times (ms). If 0, then the next stim
list element will be shown simultaneously.
</p>
</li>
<li> <p><code>w</code> Time to wait for response including presentation time (ms).
</p>
</li>
<li> <p><code>x</code> List of x co-ordinates of stimuli (degrees).
</p>
</li>
<li> <p><code>y</code> List of y co-ordinates of stimuli (degrees).
</p>
</li>
<li> <p><code>envSdx</code> (Optional) List of envelope sd in x direction in degrees.
Only useful if envType != NONE
</p>
</li>
<li> <p><code>envSdy</code> (Optional) List of envelope sd in y direction in degrees.
Only useful if envType != NONE
</p>
</li>
<li> <p><code>envRotation</code> (Optional) List of envelope rotations in degrees. Only useful if envType != NONE
</p>
</li>
<li> <p><code>type</code> (Optional) Stimulus type. Values include FLAT, SINE,
CHECKERBOARD, SQUARESINE, G1, G2, G3, IMAGE
</p>
</li>
<li> <p><code>frequency</code> (Optional) List of frequencies (in cycles per degrees)
for generation of spatial patterns. Only useful if type != FLAT
</p>
</li>
<li> <p><code>color2</code> (Optional) List of second colors for non-FLAT shapes
</p>
</li>
<li> <p><code>fullFoV</code> (Optional) If !0 fullFoV scales image to full field of view
and sx/sy are ignored.
</p>
</li>
<li> <p><code>phase</code> (Optional) List of phases (in degrees) for generation of
spatial patterns. Only useful if type != FLAT
</p>
</li>
<li> <p><code>imageFilename</code> (Optional) If type == IMAGE, the filename on the
local filesystem of the machine running JOVP of the image to use
</p>
</li>
<li> <p><code>shape</code> (Optional) Stimulus shape. Values include CROSS, TRIANGLE,
CIRCLE, SQUARE, OPTOTYPE.
</p>
</li>
<li> <p><code>rotation</code> (Optional) List of angles of rotation of stimuli
(degrees). Only useful if sx != sy specified.
</p>
</li>
<li> <p><code>texRotation</code> (Optional) List of angles of rotation of stimuli
(degrees). Only useful if type != FLAT
</p>
</li>
<li> <p><code>defocus</code> (Optional) List of defocus values in Diopters for stimulus post-processing.
</p>
</li>
<li> <p><code>envType</code> (Optional) List of envelope types to apply to the stims).
Only useful if type != FLAT
</p>
</li>
<li> <p><code>contrast</code> (Optional) List of stimulus contrasts (from 0 to 1). Only
useful if type != FLAT.
</p>
</li>
<li> <p><code>optotype</code> (Optional) If shape == OPTOTYPE, the letter A to Z to use
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiPresent_for_PhoneHMD_+3A_...">...</code></td>
<td>
<p>Parameters for other opiPresent implementations that are ignored here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements in <code>lum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>stim.length</code> can take on values in the range <code>[1, 2147483647]</code>.
</p>
<p>Elements in <code>color1</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>sx</code> can take on values in the range <code>[0.0, 180.0]</code>.
</p>
<p>Elements in <code>sy</code> can take on values in the range <code>[0.0, 180.0]</code>.
</p>
<p>Elements in <code>eye</code> can take on values in the set
<code>{"left", "right", "both", "none"}</code>.
</p>
<p>Elements in <code>t</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>w</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>x</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>y</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>envSdx</code> can take on values in the range
<code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>envSdy</code> can take on values in the range
<code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>envRotation</code> can take on values in
the range <code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>type</code> can take on values in the set
<code>{"flat", "checkerboard", "sine", "squaresine", "g1",
                 "g2", "g3", "text", "image"}</code>.
</p>
<p>Elements in <code>frequency</code> can take on values in the
range <code>[0.0, 300.0]</code>.
</p>
<p>Elements in <code>color2</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>fullFoV</code> can take on values in the
range <code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>phase</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>shape</code> can take on values in the set
<code>{"triangle", "square", "polygon", "hollow_triangle",
                  "hollow_square", "hollow_polygon", "cross", "maltese",
                  "circle", "annulus", "optotype", "text", "model"}</code>.
</p>
<p>Elements in <code>rotation</code> can take on values in the range <code>[0.0, 360.0]</code>.
</p>
<p>Elements in <code>texRotation</code> can take on values in
the range <code>[0.0, 360.0]</code>.
</p>
<p>Elements in <code>defocus</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>envType</code> can take on values in the set
<code>{"none", "square", "circle", "gaussian"}</code>.
</p>
<p>Elements in <code>contrast</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>optotype</code> can take on values in the
set <code>{"a", "b", "c", "d", "e", "f", "g", "h", "i",
                     "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
                     "u", "v", "w", "x", "y", "z"}</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li>
<li> <p><code>time</code> Response time from stimulus onset if button pressed (ms).
</p>
</li>
<li> <p><code>seen</code> '1' if seen, '0' if not.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiPresent">opiPresent()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PhoneHMD")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiPresent(stim = list(lum = list(300.0), stim.length = 1, color1 = list(list(1.0,
                  1.0, 1.0)), sx = list(1.72), sy = list(1.72),
                  eye = list("LEFT"), t = list(200.0), w = 1500.0, x = list(0.0), y = list(0.0)))

</code></pre>

<hr>
<h2 id='opiPresent_for_PicoVR'>Implementation of opiPresent for the PicoVR machine.</h2><span id='topic+opiPresent_for_PicoVR'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiPresent">opiPresent()</a></code> after
<code>chooseOPI("PicoVR")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_PicoVR_+3A_stim">stim</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>lum</code> List of stimuli luminances (cd/m^2).
</p>
</li>
<li> <p><code>stim.length</code> The number of elements in this stimuli.
</p>
</li>
<li> <p><code>color1</code> List of stimulus colors for FLAT shapes and patterns.
</p>
</li>
<li> <p><code>sx</code> List of diameters along major axis of ellipse (degrees).
</p>
</li>
<li> <p><code>sy</code> List of diameters along minor axis of ellipse (degrees).
</p>
</li>
<li> <p><code>eye</code> The eye for which to apply the settings.
</p>
</li>
<li> <p><code>t</code> List of stimuli presentation times (ms). If 0, then the next stim
list element will be shown simultaneously.
</p>
</li>
<li> <p><code>w</code> Time to wait for response including presentation time (ms).
</p>
</li>
<li> <p><code>x</code> List of x co-ordinates of stimuli (degrees).
</p>
</li>
<li> <p><code>y</code> List of y co-ordinates of stimuli (degrees).
</p>
</li>
<li> <p><code>envSdx</code> (Optional) List of envelope sd in x direction in degrees.
Only useful if envType != NONE
</p>
</li>
<li> <p><code>envSdy</code> (Optional) List of envelope sd in y direction in degrees.
Only useful if envType != NONE
</p>
</li>
<li> <p><code>envRotation</code> (Optional) List of envelope rotations in degrees. Only useful if envType != NONE
</p>
</li>
<li> <p><code>type</code> (Optional) Stimulus type. Values include FLAT, SINE,
CHECKERBOARD, SQUARESINE, G1, G2, G3, IMAGE
</p>
</li>
<li> <p><code>frequency</code> (Optional) List of frequencies (in cycles per degrees)
for generation of spatial patterns. Only useful if type != FLAT
</p>
</li>
<li> <p><code>color2</code> (Optional) List of second colors for non-FLAT shapes
</p>
</li>
<li> <p><code>fullFoV</code> (Optional) If !0 fullFoV scales image to full field of view
and sx/sy are ignored.
</p>
</li>
<li> <p><code>phase</code> (Optional) List of phases (in degrees) for generation of
spatial patterns. Only useful if type != FLAT
</p>
</li>
<li> <p><code>imageFilename</code> (Optional) If type == IMAGE, the filename on the
local filesystem of the machine running JOVP of the image to use
</p>
</li>
<li> <p><code>shape</code> (Optional) Stimulus shape. Values include CROSS, TRIANGLE,
CIRCLE, SQUARE, OPTOTYPE.
</p>
</li>
<li> <p><code>rotation</code> (Optional) List of angles of rotation of stimuli
(degrees). Only useful if sx != sy specified.
</p>
</li>
<li> <p><code>texRotation</code> (Optional) List of angles of rotation of stimuli
(degrees). Only useful if type != FLAT
</p>
</li>
<li> <p><code>defocus</code> (Optional) List of defocus values in Diopters for stimulus post-processing.
</p>
</li>
<li> <p><code>envType</code> (Optional) List of envelope types to apply to the stims).
Only useful if type != FLAT
</p>
</li>
<li> <p><code>contrast</code> (Optional) List of stimulus contrasts (from 0 to 1). Only
useful if type != FLAT.
</p>
</li>
<li> <p><code>optotype</code> (Optional) If shape == OPTOTYPE, the letter A to Z to use
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiPresent_for_PicoVR_+3A_...">...</code></td>
<td>
<p>Parameters for other opiPresent implementations that are ignored here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements in <code>lum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>stim.length</code> can take on values in the range <code>[1, 2147483647]</code>.
</p>
<p>Elements in <code>color1</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>sx</code> can take on values in the range <code>[0.0, 180.0]</code>.
</p>
<p>Elements in <code>sy</code> can take on values in the range <code>[0.0, 180.0]</code>.
</p>
<p>Elements in <code>eye</code> can take on values in the set
<code>{"left", "right", "both", "none"}</code>.
</p>
<p>Elements in <code>t</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>w</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>x</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>y</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>envSdx</code> can take on values in the range
<code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>envSdy</code> can take on values in the range
<code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>envRotation</code> can take on values in
the range <code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>type</code> can take on values in the set
<code>{"flat", "checkerboard", "sine", "squaresine", "g1",
                 "g2", "g3", "text", "image"}</code>.
</p>
<p>Elements in <code>frequency</code> can take on values in the
range <code>[0.0, 300.0]</code>.
</p>
<p>Elements in <code>color2</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>fullFoV</code> can take on values in the
range <code>[-1.0E10, 1.0E10]</code>.
</p>
<p>Elements in <code>phase</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>shape</code> can take on values in the set
<code>{"triangle", "square", "polygon", "hollow_triangle",
                  "hollow_square", "hollow_polygon", "cross", "maltese",
                  "circle", "annulus", "optotype", "text", "model"}</code>.
</p>
<p>Elements in <code>rotation</code> can take on values in the range <code>[0.0, 360.0]</code>.
</p>
<p>Elements in <code>texRotation</code> can take on values in
the range <code>[0.0, 360.0]</code>.
</p>
<p>Elements in <code>defocus</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p>Elements in <code>envType</code> can take on values in the set
<code>{"none", "square", "circle", "gaussian"}</code>.
</p>
<p>Elements in <code>contrast</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p>Elements in <code>optotype</code> can take on values in the
set <code>{"a", "b", "c", "d", "e", "f", "g", "h", "i",
                     "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
                     "u", "v", "w", "x", "y", "z"}</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li>
<li> <p><code>time</code> Response time from stimulus onset if button pressed (ms).
</p>
</li>
<li> <p><code>seen</code> '1' if seen, '0' if not.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiPresent">opiPresent()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PicoVR")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiPresent(stim = list(lum = list(300.0), stim.length = 1, color1 = list(list(1.0,
                  1.0, 1.0)), sx = list(1.72), sy = list(1.72),
                  eye = list("LEFT"), t = list(200.0), w = 1500.0, x = list(0.0), y = list(0.0)))

</code></pre>

<hr>
<h2 id='opiPresent_for_SimGaussian'>opiPresent_for_SimGaussian</h2><span id='topic+opiPresent_for_SimGaussian'></span>

<h3>Description</h3>

<p>Determine the response to a stimuli by sampling from a cumulative Gaussian
Frequency-of-Seeing (FoS) curve (also known as the psychometric function).
</p>
<p>The FoS has formula
</p>
<p style="text-align: center;"><code class="reqn">\mbox{fpr}+(1-\mbox{fpr}-\mbox{fnr})(1-\mbox{pnorm}(x, \mbox{tt}, \mbox{sd})</code>
</p>

<p>where <code class="reqn">x</code> is the stimulus value in dB, and <code>sd</code> is
set by <code>opiInitialize</code> and <code>tt</code>, <code>fpr</code> and <code>fnr</code>
are parameters.
</p>
<p>This is for internal use only, use <code><a href="#topic+opiPresent">opiPresent()</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_SimGaussian_+3A_stim">stim</code></td>
<td>
<p>A list that contains at least:
</p>

<ul>
<li> <p><code>level</code> which is the stim value in cd/<code class="reqn">\mbox{m}^2</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiPresent_for_SimGaussian_+3A_fpr">fpr</code></td>
<td>
<p>false positive rate for the FoS curve (range 0..1).</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimGaussian_+3A_fnr">fnr</code></td>
<td>
<p>false negative rate for the FoS curve (range 0..1).</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimGaussian_+3A_tt">tt</code></td>
<td>
<p>mean of the assumed FoS curve in dB.</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimGaussian_+3A_...">...</code></td>
<td>
<p>Any other parameters you like, they are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if no error, a string message otherwise.
</p>
</li>
<li> <p><code>seen</code> <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li> <p><code>time</code> Always <code>NA</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    # Stimulus is Size III white-on-white as in the HFA
chooseOpi("SimGaussian")
res &lt;- opiInitialize(sd = 1.6)
if (!is.null(res$err))
  stop(paste("opiInitialize() failed:", res$err))

result &lt;- opiPresent(stim = list(level = dbTocd(20)), tt = 30, fpr = 0.15, fnr = 0.01)
print(paste("Seen:", result$seen, quote = FALSE))

res &lt;- opiClose()
if (!is.null(res$err))
  warning(paste("opiClose() failed:", res$err))

</code></pre>

<hr>
<h2 id='opiPresent_for_SimHenson'>opiPresent_for_SimHenson</h2><span id='topic+opiPresent_for_SimHenson'></span>

<h3>Description</h3>

<p>Determine the response to a stimuli by sampling from a cumulative Gaussian
Frequency-of-Seeing (FoS) curve (also known as the psychometric function).
</p>
<p>For internal use only, use <code>opiPresent()</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_SimHenson_+3A_stim">stim</code></td>
<td>
<p>A list that contains at least:
</p>

<ul>
<li> <p><code>level</code> which is the stim value in cd/<code class="reqn">\mbox{m}^2</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiPresent_for_SimHenson_+3A_fpr">fpr</code></td>
<td>
<p>false positive rate for the FoS curve (range 0..1).</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimHenson_+3A_fnr">fnr</code></td>
<td>
<p>false negative rate for the FoS curve (range 0..1).</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimHenson_+3A_tt">tt</code></td>
<td>
<p>mean of the assumed FoS curve in dB.</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimHenson_+3A_...">...</code></td>
<td>
<p>Any other parameters you like, they are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FoS formula is
</p>
<p style="text-align: center;"><code class="reqn">\mbox{fpr}+(1-\mbox{fpr}-\mbox{fnr})(1-\mbox{pnorm}(x, \mbox{tt}, \mbox{pxVar})</code>
</p>

<p>where <code>x</code> is the stimulus value in dB, and <code>pxVar</code> is
</p>
<p style="text-align: center;"><code class="reqn">\min(\mbox{cap}, e^{A\times\mbox{tt}+B}).</code>
</p>

<p>The ceiling <code>cap</code> is set with the call to
<code>opiInitialize</code>, and <code>A</code> and <code>B</code> are from Table 1 in Henson
et al (2000), also set in the call to <code>opiInitialise</code> using the <code>type</code> parameter.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if no error, a string message otherwise.
</p>
</li>
<li> <p><code>seen</code> <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li> <p><code>time</code> Always <code>NA</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    # Stimulus is Size III white-on-white as in the HFA
chooseOpi("SimHenson")
res &lt;- opiInitialize(type = "C", cap = 6)
if (!is.null(res$err))
  stop(paste("opiInitialize() failed:", res$err))

result &lt;- opiPresent(stim = list(level = dbTocd(20)), tt = 30, fpr = 0.15, fnr = 0.01)
print(paste("Seen:", result$seen, quote = FALSE))

res &lt;- opiClose()
if (!is.null(res$err))
  stop(paste("opiClose() failed:", res$err))

</code></pre>

<hr>
<h2 id='opiPresent_for_SimHensonRT'>opiPresent_for_SimHensonRT</h2><span id='topic+opiPresent_for_SimHensonRT'></span>

<h3>Description</h3>

<p>Determine the response to a stimuli by sampling from a cumulative Gaussian
Frequency-of-Seeing (FoS) curve (also known as the psychometric function).
</p>
<p>For internal use only, use <code>opiPresent()</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_SimHensonRT_+3A_stim">stim</code></td>
<td>
<p>A list that contains at least:
</p>

<ul>
<li> <p><code>level</code> which is the stim value in cd/<code class="reqn">\mbox{m}^2</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="opiPresent_for_SimHensonRT_+3A_fpr">fpr</code></td>
<td>
<p>false positive rate for the FoS curve (range 0..1).</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimHensonRT_+3A_fnr">fnr</code></td>
<td>
<p>false negative rate for the FoS curve (range 0..1).</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimHensonRT_+3A_tt">tt</code></td>
<td>
<p>mean of the assumed FoS curve in dB.</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimHensonRT_+3A_dist">dist</code></td>
<td>
<p>The distance of the stimulus level from <code>tt</code> in appropriate units (same as <code>rtData$Dist</code>).</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimHensonRT_+3A_...">...</code></td>
<td>
<p>Any other parameters you like, they are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the response time returned for a false positive is determined
separately from a positive response, we first check for a false response.
If there is no false response, we use the FoS formula
</p>
<p style="text-align: center;"><code class="reqn">1-\mbox{pnorm}(x, \mbox{tt}, \mbox{pxVar})</code>
</p>

<p>where <code>x</code> is the stimulus value in dB, and <code>pxVar</code> is
</p>
<p style="text-align: center;"><code class="reqn">\min(\mbox{cap}, e^{A\times\mbox{tt}+B}).</code>
</p>

<p>The ceiling <code>cap</code> is set with the call to
<code>opiInitialize</code>, and <code>A</code> and <code>B</code> are from Table 1 in Henson
et al (2000), also set in the call to <code>opiInitialise</code> using the <code>type</code> parameter.
</p>
<p>Thus, this function is the same as for <code>SimHenson</code>, but
reaction times are determined by sampling from <code>rtData</code> as passed to
<code>opiInitialize</code>.  The <code>dist</code> parameter is the distance of the
stimulus level from the true threshold, and should be in the same units as
the <code>Dist</code> column of <code>rtData</code>. The default is just the straight
difference between the stimulus level and the true threshold, but you might
want it scaled somehow to match <code>rtData</code>.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if no error, a string message otherwise.
</p>
</li>
<li> <p><code>seen</code> <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li> <p><code>time</code> The response time.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    # Stimulus is Size III white-on-white as in the HFA
chooseOpi("SimHensonRt")
data(RtSigmaUnits)
res &lt;- opiInitialize(type = "C", cap = 6, rtData = RtSigmaUnits)
if (!is.null(res$err))
  stop(paste("opiInitialize() failed:", res$err))

dist &lt;- (10 - 30) / min(exp(-0.098 * 30 + 3.62), 6)
result &lt;- opiPresent(stim = list(level = dbTocd(20)), tt = 30, fpr = 0.15, fnr = 0.01, dist=dist)
print(result, quote = FALSE)

res &lt;- opiClose()
if (!is.null(res$err))
  stop(paste("opiClose() failed:", res$err))


if (!is.null(opiClose()))
  warning("opiClose() failed")
</code></pre>

<hr>
<h2 id='opiPresent_for_SimNo'>opiPresent_for_SimNo</h2><span id='topic+opiPresent_for_SimNo'></span>

<h3>Description</h3>

<p>Always respond 'not seen' to any parameter.
No checking is done on the validity of <code>stim</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_SimNo_+3A_stim">stim</code></td>
<td>
<p>Anything you like, it is ignored.</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimNo_+3A_...">...</code></td>
<td>
<p>Any parameters you like, they are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li>
<li> <p><code>time</code> Always <code>NA</code>.
</p>
</li></ul>


<hr>
<h2 id='opiPresent_for_SimYes'>opiPresent_for_SimYes</h2><span id='topic+opiPresent_for_SimYes'></span>

<h3>Description</h3>

<p>Always respond 'yes' immediately to any parameter.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiPresent_for_SimYes_+3A_stim">stim</code></td>
<td>
<p>Anything you like, it is ignored.</p>
</td></tr>
<tr><td><code id="opiPresent_for_SimYes_+3A_...">...</code></td>
<td>
<p>Any parameters you like, they are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>FALSE</code>.
</p>
</li>
<li> <p><code>seen</code> Always <code>TRUE</code>.
</p>
</li>
<li> <p><code>time</code> Always <code>NA</code>.
</p>
</li></ul>


<hr>
<h2 id='opiQueryDevice'>Calls opiQueryDevice_for_MACHINE as appropriate.</h2><span id='topic+opiQueryDevice'></span>

<h3>Description</h3>

<p>Returns a list that describes the current state of the machine.
Specific parameters and return values can be seen in the machine specific versions
listed below in the See Also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiQueryDevice()
</code></pre>


<h3>Value</h3>

<p>A list specific to each machine.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opiQueryDevice_for_ImoVifa">opiQueryDevice_for_ImoVifa()</a></code>,
<code><a href="#topic+opiQueryDevice_for_Compass">opiQueryDevice_for_Compass()</a></code>,
<code><a href="#topic+opiQueryDevice_for_Octopus900">opiQueryDevice_for_Octopus900()</a></code>,
<code><a href="#topic+opiQueryDevice_for_PhoneHMD">opiQueryDevice_for_PhoneHMD()</a></code>, <code><a href="#topic+opiQueryDevice_for_Display">opiQueryDevice_for_Display()</a></code>, <code><a href="#topic+opiQueryDevice_for_PicoVR">opiQueryDevice_for_PicoVR()</a></code>,
<code><a href="#topic+opiQueryDevice_for_SimNo">opiQueryDevice_for_SimNo()</a></code>, <code><a href="#topic+opiQueryDevice_for_SimYes">opiQueryDevice_for_SimYes()</a></code>, <code><a href="#topic+opiQueryDevice_for_SimHenson">opiQueryDevice_for_SimHenson()</a></code>,
<code><a href="#topic+opiQueryDevice_for_SimGaussian">opiQueryDevice_for_SimGaussian()</a></code>
</p>

<hr>
<h2 id='opiQueryDevice_for_Compass'>Implementation of opiQueryDevice for the ImoVifa machine.</h2><span id='topic+opiQueryDevice_for_Compass'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Value</h3>

<p>A list containing constants and their values used in the OPI Compass module.
</p>

<hr>
<h2 id='opiQueryDevice_for_Display'>Implementation of opiQueryDevice for the Display machine.</h2><span id='topic+opiQueryDevice_for_Display'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code> after
<code>chooseOPI("Display")</code> to call this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("Display")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiQueryDevice()

</code></pre>

<hr>
<h2 id='opiQueryDevice_for_ImoVifa'>Implementation of opiQueryDevice for the ImoVifa machine.</h2><span id='topic+opiQueryDevice_for_ImoVifa'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code> after
<code>chooseOPI("ImoVifa")</code> to call this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li>
<li> <p><code>rightEyex</code> x co-ordinates of right pupil (pixels from image centre, left &lt; 0)
</p>
</li>
<li> <p><code>rightEyey</code> y co-ordinates of right pupil (pixels from image centre, up &gt; 0)
</p>
</li>
<li> <p><code>leftEyex</code> x co-ordinates of left pupil (pixels from image centre, left &lt; 0)
</p>
</li>
<li> <p><code>leftEyey</code> y co-ordinates of left pupil (pixels from image centre, up &gt; 0)
</p>
</li>
<li> <p><code>leftEyed</code> Diameter of left pupil (pixels)
</p>
</li>
<li> <p><code>rightEyed</code> Diameter of right pupil (pixels)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("ImoVifa")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiQueryDevice()

</code></pre>

<hr>
<h2 id='opiQueryDevice_for_KowaAP7000'>Implementation of opiQueryDevice for the Kowa AP7000 machine.</h2><span id='topic+opiQueryDevice_for_KowaAP7000'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Details</h3>

<p>Prints defined constants in OPI package pertaining to Kowa AP7000.
</p>


<h3>Value</h3>

<p>List containing
</p>

<ul>
<li> <p><code>isSim = FALSE</code>.
</p>
</li>
<li> <p><code>pupilX</code>, the x-coordinate of the pupil position in pixels.
</p>
</li>
<li> <p><code>pupilY</code>, the y-coordinate of the pupil position in pixels.
</p>
</li>
<li> <p><code>purkinjeX</code>, the x-coordinate of the purkinje position in pixels.
</p>
</li>
<li> <p><code>purkinjeY</code>, the y-coordinate of the purkinje position in pixels.
</p>
</li></ul>


<hr>
<h2 id='opiQueryDevice_for_O600'>Implementation of opiQueryDevice for the O600 machine.</h2><span id='topic+opiQueryDevice_for_O600'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Details</h3>

<p>Prints defined constants in OPI package pertaining to O600.
</p>


<h3>Value</h3>

<p>Returns a list of 10 items:
</p>
<div class="sourceCode"><pre>* \code{answerButton} 0 = not pressed, 1 = pressed
* \code{headSensor} 0 = no forehead detected, 1 = forehead detected
* \code{eyeLidClosureLeft} 0 = eye is open, 1 = eye is closed
* \code{eyeLidClosureRight} 0 = eye is open, 1 = eye is closed
* \code{fixationLostLeft} 1 = eye pos lost, 0 = eye pos ok
* \code{fixationLostRight} 1 = eye pos lost, 0 = eye pos ok
* \code{pupilPositionXLeft} (in px)
* \code{pupilPositionYLeft} (in px)
* \code{pupilPositionXRight} (in px)
* \code{pupilPositionYRight} (in px)
</pre></div>

<hr>
<h2 id='opiQueryDevice_for_Octopus900'>Implementation of opiQueryDevice for the Octopus900 machine.</h2><span id='topic+opiQueryDevice_for_Octopus900'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Details</h3>

<p>Prints defined constants in OPI package pertaining to Octopus 900.
</p>


<h3>Value</h3>

<p>List containing <code>isSim = FALSE</code>.
</p>

<hr>
<h2 id='opiQueryDevice_for_PhoneHMD'>Implementation of opiQueryDevice for the PhoneHMD machine.</h2><span id='topic+opiQueryDevice_for_PhoneHMD'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code> after
<code>chooseOPI("PhoneHMD")</code> to call this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PhoneHMD")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiQueryDevice()

</code></pre>

<hr>
<h2 id='opiQueryDevice_for_PicoVR'>Implementation of opiQueryDevice for the PicoVR machine.</h2><span id='topic+opiQueryDevice_for_PicoVR'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code> after
<code>chooseOPI("PicoVR")</code> to call this function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiQueryDevice">opiQueryDevice()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PicoVR")
opiInitialise(list(port = 50001, ip = "localhost"))
opiSetup(list(eye = "BOTH"))
result &lt;- opiQueryDevice()

</code></pre>

<hr>
<h2 id='opiQueryDevice_for_SimGaussian'>opiQueryDevice_for_SimGaussian</h2><span id='topic+opiQueryDevice_for_SimGaussian'></span>

<h3>Description</h3>

<p>Returns a simple list.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>
</p>
</li>
<li> <p><code>machine</code> that is set to <code>"SimGaussian"</code>.
</p>
</li></ul>


<hr>
<h2 id='opiQueryDevice_for_SimHenson'>opiQueryDevice_for_SimHenson</h2><span id='topic+opiQueryDevice_for_SimHenson'></span>

<h3>Description</h3>

<p>Returns name of the machine.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>isSim</code> Always <code>TRUE</code>.
</p>
</li>
<li> <p><code>machine</code> that is set to <code>"SimHenson"</code>.
</p>
</li></ul>


<hr>
<h2 id='opiQueryDevice_for_SimHensonRT'>opiQueryDevice_for_SimHensonRT</h2><span id='topic+opiQueryDevice_for_SimHensonRT'></span>

<h3>Description</h3>

<p>Returns name of the machine.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>isSim</code> Always <code>TRUE</code>.
</p>
</li>
<li> <p><code>machine</code> that is set to <code>"SimHensonRT"</code>.
</p>
</li></ul>


<hr>
<h2 id='opiQueryDevice_for_SimNo'>opiQueryDevice_for_SimNo</h2><span id='topic+opiQueryDevice_for_SimNo'></span>

<h3>Description</h3>

<p>Returns name of the machine.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>machine</code> that is set to <code>"SimNo"</code>.
</p>
</li>
<li> <p><code>isSim</code> that is set to TRUE.
</p>
</li></ul>


<hr>
<h2 id='opiQueryDevice_for_SimYes'>opiQueryDevice_for_SimYes</h2><span id='topic+opiQueryDevice_for_SimYes'></span>

<h3>Description</h3>

<p>Returns name of the machine.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>isSim</code> Always <code>TRUE</code>.
</p>
</li>
<li> <p><code>machine</code> that is set to <code>"SimYes"</code>.
</p>
</li></ul>


<hr>
<h2 id='opiSetBackground'>Deprecated. Use <code><a href="#topic+opiSetup">opiSetup()</a></code>.</h2><span id='topic+opiSetBackground'></span>

<h3>Description</h3>

<p>In older OPIs it set background color and luminance in both eyes.
Deprecated for OPI &gt;= v3.0.0 and replaced with <code><a href="#topic+opiSetup">opiSetup()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opiSetup">opiSetup()</a></code>
</p>

<hr>
<h2 id='opiSetup'>Calls opiSetup_for_MACHINE as appropriate.</h2><span id='topic+opiSetup'></span>

<h3>Description</h3>

<p>Specific parameters and return values can be seen in the machine specific versions
listed below in the See Also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiSetup(settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_+3A_settings">settings</code></td>
<td>
<p>A list containing specific settings for a machine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each implementation should(!) return a list with at least the following elements:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if no error, otherwise a string describing the error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiSetup_for_Compass">opiSetup_for_Compass()</a></code>,
<code><a href="#topic+opiSetup_for_Octopus900">opiSetup_for_Octopus900()</a></code>,
<code><a href="#topic+opiSetup_for_ImoVifa">opiSetup_for_ImoVifa()</a></code>,
<code><a href="#topic+opiSetup_for_PhoneHMD">opiSetup_for_PhoneHMD()</a></code>, <code><a href="#topic+opiSetup_for_Display">opiSetup_for_Display()</a></code>, <code><a href="#topic+opiSetup_for_PicoVR">opiSetup_for_PicoVR()</a></code>,
<code><a href="#topic+opiSetup_for_SimNo">opiSetup_for_SimNo()</a></code>, <code><a href="#topic+opiSetup_for_SimYes">opiSetup_for_SimYes()</a></code>, <code><a href="#topic+opiSetup_for_SimHenson">opiSetup_for_SimHenson()</a></code>,
<code><a href="#topic+opiSetup_for_SimGaussian">opiSetup_for_SimGaussian()</a></code>
</p>

<hr>
<h2 id='opiSetup_for_Compass'>Implementation of opiSetup for the Compass machine.</h2><span id='topic+opiSetup_for_Compass'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiSetup">opiSetup()</a></code> with
these Arguments and you will get the Value back.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_Compass_+3A_settings">settings</code></td>
<td>
<p>is a list that could contain:
</p>

<ul>
<li> <p><code>fixation</code> <code>c(x,y,t)</code> where
</p>

<ul>
<li> <p><code>x</code> is one of -20, -6, -3, 0, 3, 6, 20 degrees.
</p>
</li>
<li> <p><code>y</code> is 0 degrees.
</p>
</li>
<li> <p><code>t</code> is 0 for a spot fixation marker at <code>c(x,y)</code>, or 1 for a
square centred on one of <code>(-3,0)</code>, <code>(0,0)</code>, <code>(+3,0)</code>.
</p>
</li></ul>

</li>
<li> <p><code>tracking_on</code> <code>TRUE</code> for tracking on, <code>FALSE</code> for off
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: tracking will be relative to the PRL established with the fixation
marker used at setup (call to OPI-OPEN), so when tracking is on you should
use the same fixation location as in the setup.
</p>


<h3>Value</h3>

<p>A list containing <code>err</code> which is <code>NULL</code> for success, or some string description for fail.
</p>

<hr>
<h2 id='opiSetup_for_Display'>Implementation of opiSetup for the Display machine.</h2><span id='topic+opiSetup_for_Display'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiSetup">opiSetup()</a></code> after
<code>chooseOPI("Display")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_Display_+3A_settings">settings</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>eye</code> The eye for which to apply the settings.
</p>
</li>
<li> <p><code>bgImageFilename</code> (Optional) If present, display the image in the
background for eye (scaled to fill fov, bgLum and bgCol ignored)
</p>
</li>
<li> <p><code>fixShape</code> (Optional) Fixation target type for eye.
</p>
</li>
<li> <p><code>fixLum</code> (Optional) Fixation target luminance for eye.
</p>
</li>
<li> <p><code>fixType</code> (Optional) Fixation target texture for eye.
</p>
</li>
<li> <p><code>fixCx</code> (Optional) x-coordinate of fixation target (degrees).
</p>
</li>
<li> <p><code>fixCy</code> (Optional) y-coordinate of fixation target (degrees).
</p>
</li>
<li> <p><code>fixCol</code> (Optional) Fixation target color for eye.
</p>
</li>
<li> <p><code>bgLum</code> (Optional) Background luminance for eye (cd/m^2).
</p>
</li>
<li> <p><code>tracking</code> (Optional) Whether to correct stimulus location based on eye position.
</p>
</li>
<li> <p><code>bgCol</code> (Optional) Background color for eye (rgb).
</p>
</li>
<li> <p><code>fixSx</code> (Optional) diameter along major axis of ellipse (degrees). 0
to hide fixation marker.
</p>
</li>
<li> <p><code>fixSy</code> (Optional) diameter along minor axis of ellipse (degrees). If
not received, then sy = sx.
</p>
</li>
<li> <p><code>fixRotation</code> (Optional) Angles of rotation of fixation target
(degrees). Only useful if sx != sy specified.
</p>
</li>
<li> <p><code>fixImageFilename</code> (Optional) If fixType == IMAGE, the filename on
the local filesystem of the machine running JOVP of the image to use
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eye</code> can take on values in the set <code>{"left", "right", "both",
     "none"}</code>.
</p>
<p><code>fixShape</code> can take on values in the set <code>{"triangle",
          "square", "polygon", "hollow_triangle", "hollow_square",
          "hollow_polygon", "cross", "maltese", "circle", "annulus",
          "optotype", "text", "model"}</code>.
</p>
<p><code>fixLum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixType</code> can take on values in the set <code>{"flat",
         "checkerboard", "sine", "squaresine", "g1", "g2", "g3", "text", "image"}</code>.
</p>
<p><code>fixCx</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p><code>fixCy</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>fixCol</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p><code>bgLum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>tracking</code> can take on values in the range <code>[0, 1]</code>.
</p>
<p>Elements in <code>bgCol</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p><code>fixSx</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixSy</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixRotation</code> can take on values in the range <code>[0.0, 360.0]</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiSetup">opiSetup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("Display")
opiInitialise(list(port = 50001, ip = "localhost"))
result &lt;- opiSetup(settings = list(eye = "BOTH"))

</code></pre>

<hr>
<h2 id='opiSetup_for_ImoVifa'>Implementation of opiSetup for the ImoVifa machine.</h2><span id='topic+opiSetup_for_ImoVifa'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiSetup">opiSetup()</a></code> after
<code>chooseOPI("ImoVifa")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_ImoVifa_+3A_settings">settings</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>eye</code> The eye for which to apply the settings.
</p>
</li>
<li> <p><code>bgImageFilename</code> (Optional) If present, display the image in the
background for eye (scaled to fill fov, bgLum and bgCol ignored)
</p>
</li>
<li> <p><code>fixShape</code> (Optional) Fixation target type for eye.
</p>
</li>
<li> <p><code>fixLum</code> (Optional) Fixation target luminance for eye.
</p>
</li>
<li> <p><code>fixType</code> (Optional) Fixation target texture for eye.
</p>
</li>
<li> <p><code>fixCx</code> (Optional) x-coordinate of fixation target (degrees).
</p>
</li>
<li> <p><code>fixCy</code> (Optional) y-coordinate of fixation target (degrees).
</p>
</li>
<li> <p><code>fixCol</code> (Optional) Fixation target color for eye.
</p>
</li>
<li> <p><code>bgLum</code> (Optional) Background luminance for eye (cd/m^2).
</p>
</li>
<li> <p><code>tracking</code> (Optional) Whether to correct stimulus location based on eye position.
</p>
</li>
<li> <p><code>bgCol</code> (Optional) Background color for eye (rgb).
</p>
</li>
<li> <p><code>fixSx</code> (Optional) diameter along major axis of ellipse (degrees). 0
to hide fixation marker.
</p>
</li>
<li> <p><code>fixSy</code> (Optional) diameter along minor axis of ellipse (degrees). If
not received, then sy = sx.
</p>
</li>
<li> <p><code>fixRotation</code> (Optional) Angles of rotation of fixation target
(degrees). Only useful if sx != sy specified.
</p>
</li>
<li> <p><code>fixImageFilename</code> (Optional) If fixType == IMAGE, the filename on
the local filesystem of the machine running JOVP of the image to use
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eye</code> can take on values in the set <code>{"left", "right", "both",
     "none"}</code>.
</p>
<p><code>fixShape</code> can take on values in the set <code>{"triangle",
          "square", "polygon", "hollow_triangle", "hollow_square",
          "hollow_polygon", "cross", "maltese", "circle", "annulus",
          "optotype", "text", "model"}</code>.
</p>
<p><code>fixLum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixType</code> can take on values in the set <code>{"flat",
         "checkerboard", "sine", "squaresine", "g1", "g2", "g3", "text", "image"}</code>.
</p>
<p><code>fixCx</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p><code>fixCy</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>fixCol</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p><code>bgLum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>tracking</code> can take on values in the range <code>[0, 1]</code>.
</p>
<p>Elements in <code>bgCol</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p><code>fixSx</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixSy</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixRotation</code> can take on values in the range <code>[0.0, 360.0]</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiSetup">opiSetup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("ImoVifa")
opiInitialise(list(port = 50001, ip = "localhost"))
result &lt;- opiSetup(settings = list(eye = "BOTH"))

</code></pre>

<hr>
<h2 id='opiSetup_for_KowaAP7000'>opiSetBackground</h2><span id='topic+opiSetup_for_KowaAP7000'></span>

<h3>Description</h3>

<p>Implementation of opiSetup for the Kowa AP7000 machine.
</p>
<p>This is for internal use only. Use <code><a href="#topic+opiSetup">opiSetup()</a></code> with these Arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiSetup_for_KowaAP7000(lum = NA, color = NA, fixation = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_KowaAP7000_+3A_lum">lum</code></td>
<td>
<p>Must be 10 for a white background and 100 for a yellow.</p>
</td></tr>
<tr><td><code id="opiSetup_for_KowaAP7000_+3A_color">color</code></td>
<td>
<p>One of <code>.opi_env$KowaAP7000$BACKGROUND_WHITE</code> or <code>.opi_env$KowaAP7000$BACKGROUND_YELLOW</code>.</p>
</td></tr>
<tr><td><code id="opiSetup_for_KowaAP7000_+3A_fixation">fixation</code></td>
<td>
<p>One of
* <code>.opi_env$KowaAP7000$FIX_CENTER</code>, fixation marker in the centre.
* <code>.opi_env$KowaAP7000$FIX_CENTRE</code>, fixation marker in the centre.
* <code>.opi_env$KowaAP7000$FIX_AUX</code>,    fixation marker is ???.
* <code>.opi_env$KowaAP7000$FIX_MACULA</code>, fixation marker is a circle(?).
* <code>.opi_env$KowaAP7000$FIX_AUX_LEFT</code>, fixation marker is as for AUX but only lower left.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lum</code> is 10 and <code>color</code> is not set, then
<code>.opi_env$KowaAP7000$BACKGROUND_WHITE</code> is assumed.
</p>
<p>If <code>lum</code> is 100 and <code>color</code> is not set,
then <code>.opi_env$KowaAP7000$BACKGROUND_YELLOW</code> is assumed.
</p>
<p>If both <code>lum</code> and <code>color</code> is set, then <code>lum</code> is ignored
(a warning will be generated
</p>
<p>If <code>lum</code> is incompatible with <code>color</code>).
</p>


<h3>Value</h3>

<p>Always returns <code>list(err = NULL)</code>
</p>

<hr>
<h2 id='opiSetup_for_O600'>opiSetup for the O600 machine.</h2><span id='topic+opiSetup_for_O600'></span>

<h3>Description</h3>

<p>Implementation of opiSetup for the O600 machine.
</p>
<p>This is for internal use only. Use <code><a href="#topic+opiSetup">opiSetup()</a></code> with these Arguments.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_O600_+3A_bgcolor">bgColor</code></td>
<td>
<p>Background color 0 to 255.</p>
</td></tr>
<tr><td><code id="opiSetup_for_O600_+3A_fixtype">fixType</code></td>
<td>
<p>fixation type 1, 2, 3 or 4.</p>
</td></tr>
<tr><td><code id="opiSetup_for_O600_+3A_fixcolor">fixColor</code></td>
<td>
<p>fixation color 0, 2, 4 or 5.</p>
</td></tr>
<tr><td><code id="opiSetup_for_O600_+3A_fixintensity">fixIntensity</code></td>
<td>
<p>fixation point intensity 0 to 255.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing one of the following
</p>

<ul>
<li> <p><code>err = -1</code> to be implemented
</p>
</li>
<li> <p><code>err = -2</code> O600 sent back an error; bad background parameters
</p>
</li>
<li> <p><code>err = -3</code> O600 sent back an error; bad fixation parameters
</p>
</li>
<li> <p><code>err = NULL</code> Success
</p>
</li></ul>


<hr>
<h2 id='opiSetup_for_Octopus900'>Implementation of opiSetup for the Octopus900 machine.</h2><span id='topic+opiSetup_for_Octopus900'></span>

<h3>Description</h3>

<p>This is for internal use only.
Use <code><a href="#topic+opiSetup">opiSetup()</a></code> with the same parameters.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_Octopus900_+3A_lum">lum</code></td>
<td>
<p>Luminance level in cd/m^2</p>
</td></tr>
<tr><td><code id="opiSetup_for_Octopus900_+3A_color">color</code></td>
<td>
<p>Stimulus color (see details)</p>
</td></tr>
<tr><td><code id="opiSetup_for_Octopus900_+3A_fixation">fixation</code></td>
<td>
<p>fixation target</p>
</td></tr>
<tr><td><code id="opiSetup_for_Octopus900_+3A_fixintensity">fixIntensity</code></td>
<td>
<p>fixation point intensity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allowable <code>lum</code> and <code>color</code> are defined in the <code>.opi_env$O900</code> environment.
</p>

<ul>
<li> <p><code>lum</code> is intensity of the background and can be one of
</p>

<ul>
<li> <p><code>.opi_env$O900$BG_OFF</code>, which turns background off.
</p>
</li>
<li> <p><code>.opi_env$O900$BG_1</code>, background of 1.27 cd/<code class="reqn">\mbox{m}^2</code>.
</p>
</li>
<li> <p><code>.opi_env$O900$BG_10</code>, background of 10 cd/<code class="reqn">\mbox{m}^2</code>.
</p>
</li>
<li> <p><code>.opi_env$O900$BG_100</code>, background of 100 cd/<code class="reqn">\mbox{m}^2</code>.
</p>
</li></ul>

</li>
<li> <p><code>color</code> can be one of the following choices.
</p>

<ul>
<li> <p><code>.opi_env$O900$MET_COL_WW</code> for white-on-white
</p>
</li>
<li> <p><code>.opi_env$O900$MET_COL_RW</code> for red-on-white
</p>
</li>
<li> <p><code>.opi_env$O900$MET_COL_BW</code> for blue-on-white
</p>
</li>
<li> <p><code>.opi_env$O900$MET_COL_WY</code> for white-on-yellow
</p>
</li>
<li> <p><code>.opi_env$O900$MET_COL_RY</code> for red-on-yellow
</p>
</li>
<li> <p><code>.opi_env$O900$MET_COL_BY</code> for blue-on-yellow
</p>
</li></ul>

</li>
<li> <p><code>fixation</code> is one of
</p>

<ul>
<li> <p><code>.opi_env$O900$FIX_CENTRE</code> or <code>.opi_env$O900$FIX_CENTER</code>
</p>
</li>
<li> <p><code>.opi_env$O900$FIX_CROSS</code>
</p>
</li>
<li> <p><code>.opi_env$O900$FIX_RING</code>
</p>
</li></ul>

</li>
<li> <p><code>fixIntensity</code> is a percentage between 0 and 100. 0 is off, 100 the brightest.
</p>
</li></ul>

<p>Note if you specify <code>fixation</code> you also have to specify <code>fixIntensity</code>.
</p>


<h3>Value</h3>

<p>A list with element <code>err</code> which is
</p>

<ul>
<li><p> NULL on success
</p>
</li>
<li><p> -1 indicates <code>opiInitialize</code> has not been called.
</p>
</li>
<li><p> -2 indicates could not set the background color.
</p>
</li>
<li><p> -3 indicates could not set the fixation marker.
</p>
</li>
<li><p> or a string message about bad parameters
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  chooseOpi("Octopus900")
  oi &lt;- opiInitialize(eyeSuiteJarLocation="c:/EyeSuite/",
                      eyeSuiteSettingsLocation="c:/Documents and Settings/All Users/Haag-Streit/",
                      eye="left")
  if(!is.null(oi$err))
      stop("opiInitialize failed")
  if(!is.null(opiSetup(fixation=.opi_env$O900$FIX_CENTRE)$err))
      stop("opiSetup failed")
  if(!is.null(opiSetup(fixation=.opi_env$O900$FIX_RING, fixIntensity=0)$err))
      stop("opiSetup failed")
  if(!is.null(opiSetup(color=.opi_env$O900$MET_COL_BY)$err))
      stop("opiSetup failed")
  if(!is.null(opiSetup(lum=.opi_env$O900$BG_100, color=.opi_env$O900$MET_COL_RW)$err))
      stop("opiSetup failed")
  opiClose()

## End(Not run)
</code></pre>

<hr>
<h2 id='opiSetup_for_PhoneHMD'>Implementation of opiSetup for the PhoneHMD machine.</h2><span id='topic+opiSetup_for_PhoneHMD'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiSetup">opiSetup()</a></code> after
<code>chooseOPI("PhoneHMD")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_PhoneHMD_+3A_settings">settings</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>eye</code> The eye for which to apply the settings.
</p>
</li>
<li> <p><code>bgImageFilename</code> (Optional) If present, display the image in the
background for eye (scaled to fill fov, bgLum and bgCol ignored)
</p>
</li>
<li> <p><code>fixShape</code> (Optional) Fixation target type for eye.
</p>
</li>
<li> <p><code>fixLum</code> (Optional) Fixation target luminance for eye.
</p>
</li>
<li> <p><code>fixType</code> (Optional) Fixation target texture for eye.
</p>
</li>
<li> <p><code>fixCx</code> (Optional) x-coordinate of fixation target (degrees).
</p>
</li>
<li> <p><code>fixCy</code> (Optional) y-coordinate of fixation target (degrees).
</p>
</li>
<li> <p><code>fixCol</code> (Optional) Fixation target color for eye.
</p>
</li>
<li> <p><code>bgLum</code> (Optional) Background luminance for eye (cd/m^2).
</p>
</li>
<li> <p><code>tracking</code> (Optional) Whether to correct stimulus location based on eye position.
</p>
</li>
<li> <p><code>bgCol</code> (Optional) Background color for eye (rgb).
</p>
</li>
<li> <p><code>fixSx</code> (Optional) diameter along major axis of ellipse (degrees). 0
to hide fixation marker.
</p>
</li>
<li> <p><code>fixSy</code> (Optional) diameter along minor axis of ellipse (degrees). If
not received, then sy = sx.
</p>
</li>
<li> <p><code>fixRotation</code> (Optional) Angles of rotation of fixation target
(degrees). Only useful if sx != sy specified.
</p>
</li>
<li> <p><code>fixImageFilename</code> (Optional) If fixType == IMAGE, the filename on
the local filesystem of the machine running JOVP of the image to use
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eye</code> can take on values in the set <code>{"left", "right", "both",
     "none"}</code>.
</p>
<p><code>fixShape</code> can take on values in the set <code>{"triangle",
          "square", "polygon", "hollow_triangle", "hollow_square",
          "hollow_polygon", "cross", "maltese", "circle", "annulus",
          "optotype", "text", "model"}</code>.
</p>
<p><code>fixLum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixType</code> can take on values in the set <code>{"flat",
         "checkerboard", "sine", "squaresine", "g1", "g2", "g3", "text", "image"}</code>.
</p>
<p><code>fixCx</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p><code>fixCy</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>fixCol</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p><code>bgLum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>tracking</code> can take on values in the range <code>[0, 1]</code>.
</p>
<p>Elements in <code>bgCol</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p><code>fixSx</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixSy</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixRotation</code> can take on values in the range <code>[0.0, 360.0]</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiSetup">opiSetup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PhoneHMD")
opiInitialise(list(port = 50001, ip = "localhost"))
result &lt;- opiSetup(settings = list(eye = "BOTH"))

</code></pre>

<hr>
<h2 id='opiSetup_for_PicoVR'>Implementation of opiSetup for the PicoVR machine.</h2><span id='topic+opiSetup_for_PicoVR'></span>

<h3>Description</h3>

<p>This is for internal use only. Use <code><a href="#topic+opiSetup">opiSetup()</a></code> after
<code>chooseOPI("PicoVR")</code> to call this function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_PicoVR_+3A_settings">settings</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>eye</code> The eye for which to apply the settings.
</p>
</li>
<li> <p><code>bgImageFilename</code> (Optional) If present, display the image in the
background for eye (scaled to fill fov, bgLum and bgCol ignored)
</p>
</li>
<li> <p><code>fixShape</code> (Optional) Fixation target type for eye.
</p>
</li>
<li> <p><code>fixLum</code> (Optional) Fixation target luminance for eye.
</p>
</li>
<li> <p><code>fixType</code> (Optional) Fixation target texture for eye.
</p>
</li>
<li> <p><code>fixCx</code> (Optional) x-coordinate of fixation target (degrees).
</p>
</li>
<li> <p><code>fixCy</code> (Optional) y-coordinate of fixation target (degrees).
</p>
</li>
<li> <p><code>fixCol</code> (Optional) Fixation target color for eye.
</p>
</li>
<li> <p><code>bgLum</code> (Optional) Background luminance for eye (cd/m^2).
</p>
</li>
<li> <p><code>tracking</code> (Optional) Whether to correct stimulus location based on eye position.
</p>
</li>
<li> <p><code>bgCol</code> (Optional) Background color for eye (rgb).
</p>
</li>
<li> <p><code>fixSx</code> (Optional) diameter along major axis of ellipse (degrees). 0
to hide fixation marker.
</p>
</li>
<li> <p><code>fixSy</code> (Optional) diameter along minor axis of ellipse (degrees). If
not received, then sy = sx.
</p>
</li>
<li> <p><code>fixRotation</code> (Optional) Angles of rotation of fixation target
(degrees). Only useful if sx != sy specified.
</p>
</li>
<li> <p><code>fixImageFilename</code> (Optional) If fixType == IMAGE, the filename on
the local filesystem of the machine running JOVP of the image to use
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eye</code> can take on values in the set <code>{"left", "right", "both",
     "none"}</code>.
</p>
<p><code>fixShape</code> can take on values in the set <code>{"triangle",
          "square", "polygon", "hollow_triangle", "hollow_square",
          "hollow_polygon", "cross", "maltese", "circle", "annulus",
          "optotype", "text", "model"}</code>.
</p>
<p><code>fixLum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixType</code> can take on values in the set <code>{"flat",
         "checkerboard", "sine", "squaresine", "g1", "g2", "g3", "text", "image"}</code>.
</p>
<p><code>fixCx</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p><code>fixCy</code> can take on values in the range <code>[-90.0, 90.0]</code>.
</p>
<p>Elements in <code>fixCol</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p><code>bgLum</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>tracking</code> can take on values in the range <code>[0, 1]</code>.
</p>
<p>Elements in <code>bgCol</code> can take on values in the range <code>[0.0, 1.0]</code>.
</p>
<p><code>fixSx</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixSy</code> can take on values in the range <code>[0.0, 1.0E10]</code>.
</p>
<p><code>fixRotation</code> can take on values in the range <code>[0.0, 360.0]</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>err</code> <code>NULL</code> if there was no error, a string message if there is an error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+opiSetup">opiSetup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("PicoVR")
opiInitialise(list(port = 50001, ip = "localhost"))
result &lt;- opiSetup(settings = list(eye = "BOTH"))

</code></pre>

<hr>
<h2 id='opiSetup_for_SimGaussian'>opiSetup_for_SimGaussian</h2><span id='topic+opiSetup_for_SimGaussian'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_SimGaussian_+3A_...">...</code></td>
<td>
<p>Any object you like, it is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiSetup_for_SimHenson'>opiSetup_for_SimHenson</h2><span id='topic+opiSetup_for_SimHenson'></span>

<h3>Description</h3>

<p>Does nothing.
For internal use only, use <code>opiSetup()</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_SimHenson_+3A_...">...</code></td>
<td>
<p>Any object you like, it is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiSetup_for_SimHensonRT'>opiSetup_for_SimHensonRT</h2><span id='topic+opiSetup_for_SimHensonRT'></span>

<h3>Description</h3>

<p>Does nothing.
For internal use only, use <code>opiSetup()</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_SimHensonRT_+3A_...">...</code></td>
<td>
<p>Any object you like, it is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiSetup_for_SimNo'>opiSetup_for_SimNo</h2><span id='topic+opiSetup_for_SimNo'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_SimNo_+3A_settings">settings</code></td>
<td>
<p>Anything you like, it is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiSetup_for_SimYes'>opiSetup_for_SimYes</h2><span id='topic+opiSetup_for_SimYes'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="opiSetup_for_SimYes_+3A_settings">settings</code></td>
<td>
<p>Any object you like, it is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>err</code> Always <code>NULL</code>.
</p>
</li></ul>


<hr>
<h2 id='opiStaticStimulus'>For backwards compatibility. Used by Octopus900 and KowaAP7000.</h2><span id='topic+opiStaticStimulus'></span>

<h3>Description</h3>

<p>For backwards compatibility. Used by Octopus900 and KowaAP7000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiStaticStimulus()
</code></pre>

<hr>
<h2 id='opiTemporalStimulus'>For backwards compatibility. Used by Octopus900 and KowaAP7000.</h2><span id='topic+opiTemporalStimulus'></span>

<h3>Description</h3>

<p>For backwards compatibility. Used by Octopus900 and KowaAP7000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opiTemporalStimulus()
</code></pre>

<hr>
<h2 id='pixTodeg'>Convert pixels to degrees for machine 'machine'</h2><span id='topic+pixTodeg'></span>

<h3>Description</h3>

<p>Convert pixels to degrees for machine 'machine'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixTodeg(xy, machine = "compass")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixTodeg_+3A_xy">xy</code></td>
<td>
<p>a 2 element vector c(x,y) where x and y are in pixels</p>
</td></tr>
<tr><td><code id="pixTodeg_+3A_machine">machine</code></td>
<td>
<p>&quot;compass&quot; or ...?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xy converted to degrees of visual field with the usual conventions or <code>NA</code> if machine is unknown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pixTodeg(c(1000, 200), machine="compass") # c(1.290323, 24.516129) degrees
pixTodeg(c(1920/2, 1920/2)) # c(0,0) degrees
</code></pre>

<hr>
<h2 id='QUESTP'>QUEST+</h2><span id='topic+QUESTP'></span><span id='topic+QUESTP.Prior'></span><span id='topic+QUESTP.Likelihood'></span><span id='topic+QUESTP.start'></span><span id='topic+getTargetStim'></span><span id='topic+QUESTP.step'></span><span id='topic+QUESTP.stop'></span><span id='topic+QUESTP.final'></span><span id='topic+QUESTP.stdev'></span><span id='topic+QUESTP.entropy'></span>

<h3>Description</h3>

<p>An implementation of the Bayesian test procedure QUEST+ by AB Watson.
This is mostly a translation of the MATLAB implementation by P Jones (see References).
Its use is similar to ZEST. The objective is to estimate parameters of a function
that defines the probability of responding stimuli. The steps are optimized based on entropy rather than
the mean or the mode of the current pdfs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QUESTP(
  Fun,
  stimDomain,
  paramDomain,
  likelihoods = NULL,
  priors = NULL,
  stopType = "H",
  stopValue = 4,
  maxSeenLimit = 2,
  minNotSeenLimit = 2,
  minPresentations = 1,
  maxPresentations = 100,
  minInterStimInterval = NA,
  maxInterStimInterval = NA,
  verbose = 0,
  makeStim,
  ...
)

QUESTP.Prior(state, priors = NULL)

QUESTP.Likelihood(state)

QUESTP.start(
  Fun,
  stimDomain,
  paramDomain,
  likelihoods = NULL,
  priors = NULL,
  stopType = "H",
  stopValue = 4,
  maxSeenLimit = 2,
  minNotSeenLimit = 2,
  minPresentations = 1,
  maxPresentations = 100,
  makeStim,
  ...
)

getTargetStim(state)

QUESTP.step(state, nextStim = NULL)

QUESTP.stop(state)

QUESTP.final(state, Choice = "mean")

QUESTP.stdev(state, WhichP = NULL)

QUESTP.entropy(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QUESTP_+3A_fun">Fun</code></td>
<td>
<p>Function to be evaluated, of the form <code>pseen = function(stim, param){...}</code>. Outputs a probability of seen.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_stimdomain">stimDomain</code></td>
<td>
<p>Domain of values for the stimulus. Can be multi-dimensional (list, one element per dimension)</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_paramdomain">paramDomain</code></td>
<td>
<p>Domain of values for pdfs of the parameters in Fun. Can be multi-parametric (list, one element per parameter).</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_likelihoods">likelihoods</code></td>
<td>
<p>Pre-computed likelihoods if available (for QUESTP.start)</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_priors">priors</code></td>
<td>
<p>Starting probability distributions for the parameter domains (list, one element per parameter)</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_stoptype">stopType</code></td>
<td>
<p><code>N</code>, for number of presentations; <code>S</code>, for standard deviation
of the pdf; and <code>H</code>, for the entropy  of the pdf (default).</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_stopvalue">stopValue</code></td>
<td>
<p>Value for number of presentations (<code>stopType=N</code>), standard deviation
(<code>stopType=S)</code> or Entropy (<code>stopType=H</code>).</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_maxseenlimit">maxSeenLimit</code></td>
<td>
<p>Will terminate if <code>maxStimulus</code> value is seen this many times.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_minnotseenlimit">minNotSeenLimit</code></td>
<td>
<p>Will terminate if <code>minStimulus</code> value is not seen this many times.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_minpresentations">minPresentations</code></td>
<td>
<p>Minimum number of presentations</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_maxpresentations">maxPresentations</code></td>
<td>
<p>Maximum number of presentations regarless of <code>stopType</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_mininterstiminterval">minInterStimInterval</code></td>
<td>
<p>If both <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>
are not <code>NA</code>, then between each stimuli there is a random wait period drawn uniformly
between <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_maxinterstiminterval">maxInterStimInterval</code></td>
<td>
<p><code>minInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_verbose">verbose</code></td>
<td>
<p><code>verbose=0</code> does nothing, <code>verbose=1</code> stores pdfs for returning,
and <code>verbose=2</code> stores pdfs and also prints each presentaion.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a dB value and numPresentations and returns an OPI datatype
ready for passing to opiPresent. See examples.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_state">state</code></td>
<td>
<p>Current state of the QUESTP returned by <code>QUESTP.start</code> and <code>QUESTP.step</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_nextstim">nextStim</code></td>
<td>
<p>A valid object for <code>opiPresent</code> to use as its <code>nextStim</code>.</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_choice">Choice</code></td>
<td>
<p>How to compute final values in QUESTP.final (&quot;mean&quot;,&quot;mode&quot;,&quot;median&quot;)</p>
</td></tr>
<tr><td><code id="QUESTP_+3A_whichp">WhichP</code></td>
<td>
<p>Which parameter (numeric index) to monitor when calling QUESTP.stdev directly
(returns max(stdev) if unspecified)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of the Bayesian test procedure QUEST+ by AB Watson.
This is mostly a translation of the MATLAB implementation by P Jones (see References).
Its use is similar to ZEST. The objective is to estimate parameters of a function
that defines the probability of responding to stimuli. The steps are optimized based on entropy rather than
the mean or the mode of the current pdfs.
</p>
<p>The stimulus, parameter and response domain are separate and can be multidimensional.
Each parameter has its own pdf. For evaluation, the pdfs are chained as a long vector
(so no co-variances are considered). More complex functions will require larger combined pdfs
and longer computation time for likelihoods and updating at each step. In these cases, it is recommended
to pre-calculate the likelihoods using QUESTP.Likelihood and store them.
</p>
<p>The function to be fitted needs to output a probability of seen (i.e. <code>pseen = function(stim, param){...}</code>)
and must take <code>stim</code> and <code>param</code> as inputs. <code>stim</code> is a vector with length = number of stimulus dimensions
(in simple one-dimensional cases, the intensity in dB). <code>param</code> is a vector with length = number
of parameters to be fitted in Fun.
</p>
<p>For example, QUEST+ can fit a Gaussian psychometric function with stimDomain = <code>{0, 1,..., 39, 40}</code> dB
and paramDomain = <code>({0, 1,..., 39, 40}; {0.5, 1,..., 5.5, 6})</code> dB for the mean and
standard deviation respectively. A standard ZEST procedure can be replicated by setting
stimDomain = <code>{0, 1,..., 39, 40}</code> dB and paramDomain = <code>({0, 1,..., 39, 40}; {1})</code> dB, i.e. by setting the
stimDomain = paramDomain for the mean and by having a static standard deviation = 1 dB. Note however that
the stimulus selection is always based on entropy and not on the mean/mode of the current pdf. See examples below
</p>
<p>Note this function will repeatedly call <code>opiPresent</code> for a stimulus until <code>opiPresent</code>
returns <code>NULL</code> (ie no error occurred).
</p>
<p>The <code>checkFixationOK</code> function is called (if present in stim made from <code>makeStim</code>)
after each presentation, and if it returns FALSE, the pdf for that location is not changed
(ie the presentation is ignored), but the stim, number of presentations etc is recorded in
the state.
</p>
<p>If more than one QUESTP is to be interleaved (for example, testing multiple locations), then the
<code>QUESTP.start</code>, <code>QUESTP.step</code>, <code>QUESTP.stop</code> and <code>QUESTP.final</code> calls can maintain
the state of the QUESTP after each presentation, and should be used. If only a single QUESTP is
required, then the simpler <code>QUESTP</code> can be used, which is a wrapper for the four functions
that maintain state. See examples below.
</p>


<h3>Value</h3>

<p>##Single location
<code>QUESTP</code> returns a list containing
</p>

<ul>
<li> <p><code>npres</code> Total number of presentations used.
</p>
</li>
<li> <p><code>respSeq</code> Response sequence stored as a data frame: column 1 is a string identified of a (potentially)
multidimensional stimulus values of stimuli (dimensions chained into a string), column 2
is 1/0 for seen/not-seen, column 3 is fixated 1/0 (always 1 if <code>checkFixationOK</code> not
present in stim objects returned from <code>makeStim</code>). All additional columns report each stimulus
dimension, one for each row.
</p>
</li>
<li> <p><code>pdfs</code> If <code>verbose</code> is bigger than 0, then this is a list of the pdfs
used for each presentation, otherwise NULL.
</p>
</li>
<li> <p><code>final</code> The mean (default, strongly suggested)/median/mode of the
parameters' pdf, depending on <code>Choice</code>.
</p>
</li>
<li> <p><code>opiResp</code>A list of responses received from each successful call to <code>opiPresent</code> within <code>QUESTP</code>.
</p>
</li></ul>



<h4>Multiple locations</h4>

<p><code>QUESTP.start</code> returns a list that can be passed to <code>QUESTP.step</code>, <code>QUESTP.stop</code>, and
<code>QUESTP.final</code>. It represents the state of a QUESTP at a single location at a point in time
and contains the following.
</p>

<ul>
<li> <p><code>name</code> <code>QUESTP</code>
</p>
</li>
<li><p> A copy of all of the parameters supplied to QUESTP.start: <code>stimDomain</code>,
<code>paramDomain</code>, <code>likelihoods</code>, <code>priors</code>, <code>stopType</code>, <code>stopValue</code>,
<code>maxSeenLimit</code>, <code>minNotSeenLimit</code>, <code>minPresentations</code>, <code>maxPresentations</code>,
<code>makeStim</code>, and <code>opiParams</code>.
</p>
</li>
<li> <p><code>pdf</code> Current pdf: vector of probabilities, collating all parameter domains.
</p>
</li>
<li> <p><code>priorsP</code> List of starting pdfs, one for each parameter.
</p>
</li>
<li> <p><code>numPresentations</code> The number of times <code>QUESTP.step</code> has been called on this state.
</p>
</li>
<li> <p><code>stimuli</code> A vector containing the stimuli used at each call of <code>QUESTP.step</code>.
</p>
</li>
<li> <p><code>responses</code> A vector containing the responses received at each call of <code>QUESTP.step</code>.
</p>
</li>
<li> <p><code>responseTimes</code> A vector containing the response times received at each call of <code>QUESTP.step</code>.
</p>
</li>
<li> <p><code>fixated</code> A vector containing TRUE/FALSE if fixation was OK according to
<code>checkFixationOK</code> for each call of <code>QUESTP.step</code> (defaults to TRUE if
<code>checkFixationOK</code> not present).
</p>
</li>
<li> <p><code>opiResp</code> A list of responses received from each call to <code>opiPresent</code> within <code>QUESTP.step</code>.
</p>
</li></ul>

<p><code>QUESTP.step</code> returns a list containing
</p>

<ul>
<li> <p><code>state</code> The new state after presenting a stimuli and getting a response.
</p>
</li>
<li> <p><code>resp</code> The return from the <code>opiPresent</code> call that was made.
</p>
</li></ul>

<p><code>QUESTP.stop</code> returns <code>TRUE</code> if the QUESTP has reached its stopping criteria, and <code>FALSE</code> otherwise.
</p>
<p><code>QUESTP.final</code> returns an estimate of parameters based on state. If <code>state$Choice</code>
is <code>mean</code> then the mean is returned (the only one that really makes sense for QUESTP).
If <code>state$Choice</code> is <code>mode</code> then the
mode is returned. If <code>state$Choice</code> is <code>median</code> then the median is returned.
</p>



<h3>References</h3>

<p>Andrew B. Watson; QUEST+: A general multidimensional Bayesian adaptive psychometric method.
Journal of Vision 2017;17(3):10. doi: https://doi.org/10.1167/17.3.10.
</p>
<p>Jones, P. R. (2018). QuestPlus: a MATLAB implementation of the QUEST+ adaptive psychometric
method, Journal of Open Research Software, 6(1):27. doi: http://doi.org/10.5334/jors.195
</p>
<p>A. Turpin, P.H. Artes and A.M. McKendrick &quot;The Open Perimetry Interface: An enabling tool for
clinical visual psychophysics&quot;, Journal of Vision 12(11) 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("SimHenson")
if(!is.null(opiInitialize(type="C", cap=6)$err))
    stop("opiInitialize failed")

#########################################################
# This section is for single location QUESTP
# This example fits a FoS curve
# Note: only fitting threshold and slope,
# modify the domain for FPR and FNR to fit those as well
#########################################################
# Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
    s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500, checkFixationOK=NULL)
    class(s) &lt;- "opiStaticStimulus"
    return(s)
}

#True parameters (variability is determined according to Henson et al. based on threshold)
loc &lt;- list(threshold = 20, fpr = 0.05, fnr = 0.05)

#Function to fit (Gaussian psychometric function)
pSeen &lt;- function(x, params){return(params[3] +
                                        (1 - params[3] - params[4]) *
                                        (1 - pnorm(x, params[1], params[2])))}
#QUEST+
QP &lt;- QUESTP(Fun = pSeen,
             stimDomain = list(0:50),
             paramDomain = list(seq(0, 40, 1), #Domain for the 50% threshold (Mean)
                                seq(.5, 8, .5), #Domain for the slope (SD)
                                seq(0.05, 0.05, 0.05), #Domain for the FPR (static)
                                seq(0.05, 0.05, 0.05)), #Domain for the FNR (static)
             stopType="H", stopValue=4, maxPresentations=500,
             makeStim = makeStim,
             tt=loc$threshold, fpr=loc$fpr, fnr=loc$fnr,
             verbose = 2)

#Plots results
#Henson's FoS function (as implemented in OPI - ground truth)
HensFunction &lt;- function(Th){
    SD &lt;- exp(-0.081*Th + 3.27)
    SD[SD &gt; 6] &lt;- 6
    return(SD)
}

#Stimulus domain
dB_Domain &lt;- 0:50
FoS &lt;- pSeen(dB_Domain, params = QP$final) # Estimated FoS
FoS_GT &lt;- pSeen(dB_Domain, params = c(loc$threshold, HensFunction(loc$threshold),
                                      loc$fpr, loc$fnr)) #Ground truth FoS (based on Henson et al.)

#Plot (seen stimuli at the top, unseen stimuli at the bottom)
plot(dB_Domain, FoS_GT, type = "l", ylim = c(0, 1), xlab = "dB", ylab = "% seen", col = "blue")
lines(dB_Domain, FoS, col = "red")
points(QP$respSeq$stimuli, QP$respSeq$responses, pch = 16,
       col = rgb(red = 1, green = 0, blue = 0, alpha = 0.1))
legend("top", inset = c(0, -.2),legend = c("True","Estimated","Stimuli"),
       col=c("blue", "red","red"), lty=c(1,1,0),
       pch = c(16, 16, 16), pt.cex = c(0, 0, 1),
       horiz = TRUE, xpd = TRUE, xjust = 0)

if (!is.null(opiClose()$err))
  warning("opiClose() failed")



chooseOpi("SimHenson")
if(!is.null(opiInitialize(type="C", cap=6)$err))
    stop("opiInitialize failed")

######################################################################
# This section is for single location QUESTP
# This example shows that QUEST+ can replicate a ZEST procedure
# by fitting a FoS curve with fixed Slope, FPR and FNR
# Compared with ZEST
# Note that QUEST+ should be  marginally more efficient in selecting
# the most informative stimulus
######################################################################
# Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
    s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500, checkFixationOK=NULL)
    class(s) &lt;- "opiStaticStimulus"
    return(s)
}

#True parameters (variability is determined according to Henson et al. based on threshold)
loc &lt;- list(threshold = 30, fpr = 0.03, fnr = 0.03)

#Function to fit (Gaussian psychometric function - Fixed slope (same as default likelihood in ZEST))
pSeen &lt;- function(domain, tt){{0.03+(1-0.03-0.03)*(1-pnorm(domain,tt,1))}}

# ZEST-like QUEST+ procedure
QP &lt;- QUESTP(Fun = pSeen,
             stimDomain = list(0:40),
             paramDomain = list(seq(0, 40, 1)),
             stopType="S", stopValue=1.5, maxPresentations=500,
             makeStim = makeStim,
             tt=loc$threshold, fpr=loc$fpr, fnr=loc$fnr,
             verbose = 2)

# ZEST
ZE &lt;- ZEST(domain = 0:40,
           stopType="S", stopValue=1.5, maxPresentations=500,
           makeStim = makeStim,
           tt=loc$threshold, fpr=loc$fpr, fnr=loc$fnr,
           verbose = 2)

#Plots results
#Henson's FoS function (as implemented in OPI - ground truth)
HensFunction &lt;- function(Th){
    SD &lt;- exp(-0.081*Th + 3.27)
    SD[SD &gt; 6] &lt;- 6
    return(SD)
}

#Stimulus domain
dB_Domain &lt;- 0:50
FoS_QP &lt;- pSeen(domain = dB_Domain, tt = QP$final) # Estimated FoS
FoS_ZE &lt;- pSeen(domain = dB_Domain, tt = ZE$final) # Estimated FoS

#Plot (seen stimuli at the top, unseen stimuli at the bottom)
plot(dB_Domain, FoS_QP, type = "l", ylim = c(0, 1), xlab = "dB", ylab = "% seen", col = "blue")
lines(dB_Domain, FoS_ZE, col = "red")
points(QP$respSeq$stimuli, QP$respSeq$responses, pch = 16,
       col = rgb(red = 0, green = 0, blue = 1, alpha = 0.5))
points(ZE$respSeq[1,], ZE$respSeq[2,], pch = 16,
       col = rgb(red = 1, green = 0, blue = 0, alpha = 0.5))
legend("bottomleft", legend = c("QUEST+","ZEST","Stimuli QUEST+", "Stimuli ZEST"),
       col=c("blue", "red","blue","red"), lty=c(1,1,0,0),
       pch = c(16, 16, 16, 16), pt.cex = c(0, 0, 1, 1),
       horiz = FALSE, xpd = TRUE, xjust = 0)
abline(v = loc$threshold, lty = "dashed")

if (!is.null(opiClose()$err))
  warning("opiClose() failed")


chooseOpi("SimHenson")
if(!is.null(opiInitialize(type="C", cap=6)$err))
  stop("opiInitialize failed")

#########################################################
# This section is for single location QUESTP
# This example fits a broken stick spatial summation function
# with a multi-dimensional stimulus (varying in size and intensity).
# Stimulus sizes are limited to GI, GII, GIII, GIV and GV.
# The example also shows how to use a helper function to
# simulate responses to multi-dimensional stimuli
# (here, the simulated threshold varies based on stimulus size)
#########################################################
makeStim &lt;- function(stim, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(stim[1]), size=stim[2], color="white",
            duration=200, responseWindow=1500, checkFixationOK=NULL)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}

# Helper function for true threshold (depends on log10(stimulus size),
# diameter assumed to be the second element of stim vector)
ttHelper_SS &lt;- function(location) {  # returns a function of (stim)
  ff &lt;- function(stim) stim

  body(ff) &lt;- substitute(
    {return(SensF(log10(pi*(stim[2]/2)^2), c(location$Int1, location$Int2, location$Slo2)))}
  )
  return(ff)
}

# Function of sensivity vs SSize (log10(stimulus area))
SensF &lt;- function(SSize, params){
  Sens &lt;- numeric(length(SSize))
  for (i in 1:length(SSize)){
    Sens[i] &lt;- min(c(params[1] + 10*SSize[i], params[2] + params[3]*SSize[i]))
  }
  Sens[Sens &lt; 0] &lt;- 0
  return(Sens)
}

Sizes &lt;- c(0.1, 0.21, 0.43, 0.86, 1.72)

#True parameters (variability is determined according to Henson et al. based on threshold)
loc &lt;- list(Int1 = 32, Int2 = 28, Slo2 = 2.5, fpr = 0.05, fnr = 0.05, x = 9, y = 9)


# Function to fit (probability of seen given a certain stimulus intensity and size,
# for different parameters)
pSeen &lt;- function(stim, params){

  Th &lt;- SensF(log10(pi*(stim[2]/2)^2), params)

  return(0.03 +
           (1 - 0.03 - 0.03) *
           (1 - pnorm(stim[1], Th, 1)))
}


## Not run: 
set.seed(111)
#QUEST+ - takes some time to calculate likelihoods
QP &lt;- QUESTP(Fun = pSeen,
             stimDomain = list(0:50, Sizes),
             paramDomain = list(seq(0, 40, 1), # Domain for total summation intercept
                                seq(0, 40, 1), # Domain for partial summation intercept
                                seq(0, 3, 1)), # Domain for partial summation slope
             stopType="H", stopValue=1, maxPresentations=500,
             makeStim = makeStim,
             ttHelper=ttHelper_SS(loc), tt = 30,
             fpr=loc$fpr, fnr=loc$fnr,
             verbose = 2)
#Stimulus sizes
G &lt;- log10(c(pi*(0.1/2)^2, pi*(0.21/2)^2, pi*(0.43/2)^2, pi*(0.86/2)^2, pi*(1.72/2)^2));
SizesP &lt;- seq(min(G), max(G), .05)

# True and estimated response
Estim_Summation &lt;- SensF(SizesP, params = QP$final) # Estimated spatial summation
GT_Summation &lt;- SensF(SizesP, params = c(loc$Int1, loc$Int2, loc$Slo2)) # True spatial summation

#Plot
plot(10^SizesP, GT_Summation, type = "l", ylim = c(0, 40), log = "x",
     xlab = "Stimulus area (deg^2)", ylab = "Sensitivity (dB)", col = "blue")
lines(10^SizesP, Estim_Summation, col = "red")
points(pi*(QP$respSeq$stimuli.2/2)^2, QP$respSeq$stimuli.1, pch = 16,
       col = rgb(red = 1, green = 0, blue = 0, alpha = 0.3))
legend("top", inset = c(0, -.2),legend = c("True","Estimated","Stimuli"),
       col=c("blue", "red","red"), lty=c(1,1,0),
       pch = c(16, 16, 16), pt.cex = c(0, 0, 1),
       horiz = TRUE, xpd = TRUE, xjust = 0)


## End(Not run)
if (!is.null(opiClose()$err))
  warning("opiClose() failed")

</code></pre>

<hr>
<h2 id='RtDbUnits'>Response times to white-on-white Goldmann Size III targets for 12 subjects
in dB units</h2><span id='topic+RtDbUnits'></span>

<h3>Description</h3>

<p>Response times to white-on-white Goldmann Size III targets for 12
subjects. The second column is the distance of the stimuli from measured
threshold in HFA dB units. The threshold was determined by post-hoc fit of FoS
curves to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RtDbUnits
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 30620 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A data frame with 30620 observations on the following 3 variables.
</p>

<dl>
<dt><code>Rt</code></dt><dd><p>Reaction time in ms.</p>
</dd>
<dt><code>Dist</code></dt><dd><p>Distance of stimuli from threshold in dB.</p>
</dd>
<dt><code>Person</code></dt><dd><p>Identifier of each subject.</p>
</dd>
</dl>



<h3>References</h3>

<p>A.M. McKendrick, J. Denniss and A. Turpin. &quot;Response times across the visual
field: empirical observations and application to threshold determination&quot;.
Vision Research 101 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RtSigmaUnits">RtSigmaUnits</a></code>
</p>

<hr>
<h2 id='RtSigmaUnits'>Response times to white-on-white Goldmann Size III targets for 12 subjects
in sigma units</h2><span id='topic+RtSigmaUnits'></span>

<h3>Description</h3>

<p>Response times to white-on-white Goldmann Size III targets for 12
subjects. The second column is the distance of the stimuli from measured threshold
in 'sigma' units. The threshold was determined by post-hoc fit of a cummulative
gaussian FoS curve to the data for each location and subject. Sigma is the
standard deviation of the fitted FoS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RtSigmaUnits
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 30620 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A data frame with 30620 observations on the following 3 variables.
</p>

<dl>
<dt><code>Rt</code></dt><dd><p>Reaction time in ms.</p>
</dd>
<dt><code>Dist</code></dt><dd><p>Distance of stimuli from threshold in sigma units.</p>
</dd>
<dt><code>Person</code></dt><dd><p>Identifier of each subject.</p>
</dd>
</dl>



<h3>References</h3>

<p>A.M. McKendrick, J. Denniss and A. Turpin. &quot;Response times across the visual
field: empirical observations and application to threshold determination&quot;.
Vision Research 101 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RtDbUnits">RtDbUnits</a></code>
</p>

<hr>
<h2 id='ZEST'>ZEST</h2><span id='topic+ZEST'></span><span id='topic+ZEST.start'></span><span id='topic+ZEST.step'></span><span id='topic+ZEST.stop'></span><span id='topic+ZEST.final'></span>

<h3>Description</h3>

<p>An implementation of the Bayesian test procedures of King-Smith et al.
and Watson and Pelli. Note that we use the term <code>pdf</code> throughout as in the
original paper, even though they are discrete probability functions in this
implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZEST(
  domain = 0:40,
  prior = rep(1/length(domain), length(domain)),
  likelihood = sapply(domain, function(tt) 0.03 + (1 - 0.03 - 0.03) * (1 -
    stats::pnorm(domain, tt, 1))),
  stopType = "S",
  stopValue = 1.5,
  minStimulus = utils::head(domain, 1),
  maxStimulus = utils::tail(domain, 1),
  maxSeenLimit = 2,
  minNotSeenLimit = 2,
  maxPresentations = 100,
  minInterStimInterval = NA,
  maxInterStimInterval = NA,
  verbose = 0,
  makeStim,
  stimChoice = "mean",
  ...
)

ZEST.start(
  domain = 0:40,
  prior = rep(1/length(domain), length(domain)),
  likelihood = sapply(domain, function(tt) 0.03 + (1 - 0.03 - 0.03) * (1 -
    stats::pnorm(domain, tt, 1))),
  stopType = "S",
  stopValue = 1.5,
  minStimulus = utils::head(domain, 1),
  maxStimulus = utils::tail(domain, 1),
  maxSeenLimit = 2,
  minNotSeenLimit = 2,
  maxPresentations = 100,
  makeStim,
  stimChoice = "mean",
  ...
)

ZEST.step(state, nextStim = NULL, fixedStimValue = NA, fixedResponse = NA)

ZEST.stop(state)

ZEST.final(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZEST_+3A_domain">domain</code></td>
<td>
<p>Vector of values over which pdf is kept.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_prior">prior</code></td>
<td>
<p>Starting probability distribution over domain. Same length as <code>domain</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_likelihood">likelihood</code></td>
<td>
<p>Matrix where <code>likelihood[s,t]</code> is likelihood of seeing <code>s</code>
given <code>t</code> is the true threshold. That is, Pr(s|t) where <code>s</code> and <code>t</code> are
indexes into <code>domain</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_stoptype">stopType</code></td>
<td>
<p><code>N</code>, for number of presentations; <code>S</code>, for standard deviation
of the pdf; and <code>H</code>, for the entropy  of the pdf.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_stopvalue">stopValue</code></td>
<td>
<p>Value for number of presentations (<code>stopType=N</code>), standard deviation
(<code>stopType=S)</code> or Entropy (<code>stopType=H</code>).</p>
</td></tr>
<tr><td><code id="ZEST_+3A_minstimulus">minStimulus</code></td>
<td>
<p>The smallest stimuli that will be presented. Could be different from
<code>domain[1]</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_maxstimulus">maxStimulus</code></td>
<td>
<p>The largest stimuli that will be presented. Could be different from
<code>tail(domain,1)</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_maxseenlimit">maxSeenLimit</code></td>
<td>
<p>Will terminate if <code>maxStimulus</code> value is seen this many times.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_minnotseenlimit">minNotSeenLimit</code></td>
<td>
<p>Will terminate if <code>minStimulus</code> value is not seen this many times.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_maxpresentations">maxPresentations</code></td>
<td>
<p>Maximum number of presentations regardless of <code>stopType</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_mininterstiminterval">minInterStimInterval</code></td>
<td>
<p>If both <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>
are not <code>NA</code>, then between each stimuli there is a random wait period drawn uniformly
between <code>minInterStimInterval</code> and <code>maxInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_maxinterstiminterval">maxInterStimInterval</code></td>
<td>
<p><code>minInterStimInterval</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_verbose">verbose</code></td>
<td>
<p><code>verbose=0</code> does nothing, <code>verbose=1</code> stores pdfs for returning,
and <code>verbose=2</code> stores pdfs and also prints each presentation.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_makestim">makeStim</code></td>
<td>
<p>A function that takes a dB value and numPresentations and returns an OPI datatype
ready for passing to opiPresent. See examples.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_stimchoice">stimChoice</code></td>
<td>
<p>A true ZEST procedure uses the <code>"mean"</code> of the current pdf as the stimulus,
but <code>"median"</code> and <code>"mode"</code> (as used in a QUEST procedure) are provided for your
enjoyment.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to the opiPresent function</p>
</td></tr>
<tr><td><code id="ZEST_+3A_state">state</code></td>
<td>
<p>Current state of the ZEST returned by <code>ZEST.start</code> and <code>ZEST.step</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_nextstim">nextStim</code></td>
<td>
<p>A valid object for <code>opiPresent</code> to use as its <code>nextStim</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_fixedstimvalue">fixedStimValue</code></td>
<td>
<p>A number in <code>state$domain</code> that, is <code>!is.na</code>, will be used as the stimulus value
overriding <code>state$minStimulus</code>, <code>state$maxStimulus</code> and <code>state$stimChoice</code>.</p>
</td></tr>
<tr><td><code id="ZEST_+3A_fixedresponse">fixedResponse</code></td>
<td>
<p>Ignored if <code>!is.na</code> otherwise used as the response to the stim shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of King-Smith et al.'s ZEST procedure and Watson and Pelli's
QUEST procedure. All presentations are rounded to an element of the supplied domain.
</p>
<p>Note this function will repeatedly call <code>opiPresent</code> for a stimulus until <code>opiPresent</code>
returns <code>NULL</code> (ie no error occurred).
</p>
<p>The <code>checkFixationOK</code> function is called (if present in stim made from <code>makeStim</code>)
after each presentation, and if it returns FALSE, the pdf for that location is not changed
(ie the presentation is ignored), but the stim, number of presentations etc is recorded in
the state.
</p>
<p>If more than one ZEST is to be interleaved (for example, testing multiple locations), then the
<code>ZEST.start</code>, <code>ZEST.step</code>, <code>ZEST.stop</code> and <code>ZEST.final</code> calls can maintain
the state of the ZEST after each presentation, and should be used. If only a single ZEST is
required, then the simpler <code>ZEST</code> can be used, which is a wrapper for the four functions
that maintain state. See examples below.
</p>


<h3>Value</h3>



<h4>Single location</h4>

<p><code>ZEST</code> returns a list containing
</p>

<ul>
<li> <p><code>npres</code> Total number of presentations used.
</p>
</li>
<li> <p><code>respSeq</code> Response sequence stored as a matrix: row 1 is dB values of stimuli, row 2
</p>
</li>
<li><p> is 1/0 for seen/not-seen, row 3 is fixated 1/0 (always 1 if <code>checkFixationOK</code> not
</p>
</li>
<li><p> present in stim objects returned from <code>makeStim</code>).
</p>
</li>
<li> <p><code>pdfs</code> If <code>verbose</code> is bigger than 0, then this is a list of the pdfs used for each presentation, otherwise NULL.
</p>
</li>
<li> <p><code>final</code> The mean/median/mode of the final pdf, depending on <code>stimChoice</code>, which is the determined threshold.
</p>
</li>
<li> <p><code>opiResp</code> A list of responses received from each successful call to <code>opiPresent</code> within <code>ZEST</code>.
</p>
</li></ul>




<h4>Multilple locations</h4>

<p><code>ZEST.start</code> returns a list that can be passed to <code>ZEST.step</code>, <code>ZEST.stop</code>, and
<code>ZEST.final</code>. It represents the state of a ZEST at a single location at a point in time
and contains the following.
</p>

<ul>
<li> <p><code>name</code> <code>ZEST</code>.
</p>
</li>
<li> <p><code>pdf</code> Current pdf: vector of probabilities the same length as <code>domain</code>.
</p>
</li>
<li> <p><code>numPresentations</code> The number of times <code>ZEST.step</code> has been called on this state.
</p>
</li>
<li> <p><code>stimuli</code> A vector containing the stimuli used at each call of <code>ZEST.step</code>.
</p>
</li>
<li> <p><code>responses</code> A vector containing the responses received at each call of <code>ZEST.step</code>.
</p>
</li>
<li> <p><code>responseTimes</code> A vector containing the response times received at each call of <code>ZEST.step</code>.
</p>
</li>
<li> <p><code>fixated</code> A vector containing TRUE/FALSE if fixation was OK according to
<code>checkFixationOK</code> for each call of <code>ZEST.step</code> (defaults to TRUE if
<code>checkFixationOK</code> not present).
</p>
</li>
<li> <p><code>opiResp</code> A list of responses received from each call to <code>opiPresent</code> within <code>ZEST.step</code>.
</p>
</li>
<li><p> A copy of all of the parameters supplied to ZEST.start: <code>domain</code>,
<code>likelihood</code>, <code>stopType</code>, <code>stopValue</code>, <code>minStimulus</code>, <code>maxStimulus</code>,
<code>maxSeenLimit</code>, <code>minNotSeenLimit</code>, <code>maxPresentations</code>, <code>makeStim</code>,
<code>stimChoice</code>, <code>currSeenLimit</code>, <code>currNotSeenLimit</code>, and <code>opiParams</code>.
</p>
</li></ul>

<p><code>ZEST.step</code> returns a list containing
* <code>state</code> The new state after presenting a stimuli and getting a response.
* <code>resp</code> The return from the <code>opiPresent</code> call that was made.
</p>
<p><code>ZEST.stop</code> returns <code>TRUE</code> if the ZEST has reached its stopping criteria, and <code>FALSE</code> otherwise.
</p>
<p><code>ZEST.final</code> returns an estimate of threshold based on state. If <code>state$stimChoice</code>
is <code>mean</code> then the mean is returned. If <code>state$stimChoice</code> is <code>mode</code> then the
mode is returned. If <code>state$stimChoice</code> is <code>median</code> then the median is returned.
</p>

<p>A list containing
* <code>state</code> The new state after presenting a stimuli and getting a response.
* <code>resp</code> The return from the <code>opiPresent</code> call that was made.
</p>


<h3>References</h3>

<p>P.E. King-Smith, S.S. Grigsny, A.J. Vingrys, S.C. Benes, and A. Supowit. &quot;Efficient and Unbiased
Modifications of the QUEST Threshold Method: Theory, Simulations, Experimental Evaluation and
Practical Implementation&quot;, Vision Research 34(7) 1994. Pages 885-912.
</p>
<p>A.B. Watson and D.G. Pelli. &quot;QUEST: A Bayesian adaptive psychophysical method&quot;, Perception and
Psychophysics 33 1983. Pages 113-l20.
</p>
<p>A. Turpin, P.H. Artes and A.M. McKendrick &quot;The Open Perimetry Interface: An enabling tool for
clinical visual psychophysics&quot;, Journal of Vision 12(11) 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbTocd">dbTocd</a></code>, <code><a href="#topic+opiPresent">opiPresent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseOpi("SimHenson")
if(!is.null(opiInitialize(type="C", cap=6)$err))
  stop("opiInitialize failed")

##############################################
# This section is for single location ZESTs
##############################################
# Stimulus is Size III white-on-white as in the HFA
makeStim &lt;- function(db, n) {
  s &lt;- list(x=9, y=9, level=dbTocd(db), size=0.43, color="white",
            duration=200, responseWindow=1500, checkFixationOK=NULL)
  class(s) &lt;- "opiStaticStimulus"
  return(s)
}

repp &lt;- function(...) sapply(1:50, function(i) ZEST(makeStim=makeStim, ...))
a &lt;- repp(stopType="H", stopValue=  3, verbose=0, tt=30, fpr=0.03)
b &lt;- repp(stopType="S", stopValue=1.5, verbose=0, tt=30, fpr=0.03)
c &lt;- repp(stopType="S", stopValue=2.0, verbose=0, tt=30, fpr=0.03)
d &lt;- repp(stopType="N", stopValue= 50, verbose=0, tt=30, fpr=0.03)
e &lt;- repp(prior=dnorm(0:40,m=0,s=5), tt=30, fpr=0.03)
f &lt;- repp(prior=dnorm(0:40,m=10,s=5), tt=30, fpr=0.03)
g &lt;- repp(prior=dnorm(0:40,m=20,s=5), tt=30, fpr=0.03)
h &lt;- repp(prior=dnorm(0:40,m=30,s=5), tt=30, fpr=0.03)

layout(matrix(1:2,1,2))
boxplot(lapply(list(a,b,c,d,e,f,g,h), function(x) unlist(x["final",])))
boxplot(lapply(list(a,b,c,d,e,f,g,h), function(x) unlist(x["npres",])))

##############################################
# This section is for multiple ZESTs
##############################################
makeStimHelper &lt;- function(db,n, x, y) {  # returns a function of (db,n)
  ff &lt;- function(db, n) db+n
  body(ff) &lt;- substitute({
    s &lt;- list(x=x, y=y, level=dbTocd(db), size=0.43, color="white",
              duration=200, responseWindow=1500, checkFixationOK=NULL)
    class(s) &lt;- "opiStaticStimulus"
    return(s)
  }, list(x=x,y=y))
  return(ff)
}

# List of (x, y, true threshold) triples
locations &lt;- list(c(9,9,30), c(-9,-9,32), c(9,-9,31), c(-9,9,33))

# Setup starting states for each location
states &lt;- lapply(locations, function(loc) {
  ZEST.start(
    domain=-5:45,
    minStimulus=0,
    maxStimulus=40,
    makeStim=makeStimHelper(db,n,loc[1],loc[2]),
    stopType="S", stopValue= 1.5, tt=loc[3], fpr=0.03, fnr=0.01)})

# Loop through until all states are "stop"
while(!all(st &lt;- unlist(lapply(states, ZEST.stop)))) {
  i &lt;- which(!st)                         # choose a random,
  i &lt;- i[runif(1, min=1, max=length(i))]  # unstopped state
  r &lt;- ZEST.step(states[[i]])             # step it
  states[[i]] &lt;- r$state                  # update the states
}

finals &lt;- lapply(states, ZEST.final)    # get final estimates of threshold
for(i in 1:length(locations)) {
  #cat(sprintf("Location (%+2d,%+2d) ",locations[[i]][1], locations[[i]][2]))
  #cat(sprintf("has threshold %4.2f\n", finals[[i]]))
}

if (!is.null(opiClose()$err))
  warning("opiClose() failed")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
