<!DOCTYPE html><html><head><title>Help for package gamCopula</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gamCopula}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC.gamBiCop'><p>Akaike's An Information Criterion for a gamBiCop Object</p></a></li>
<li><a href='#BIC.gamBiCop'><p>Schwarz's Bayesian Information Criterion for a gamBiCop Object</p></a></li>
<li><a href='#BiCopEta2Par'><p>Copula Parameter of a Bivariate Copula for a Given Value of the Calibration</p>
Function</a></li>
<li><a href='#BiCopPar2Eta'><p>Calibration Function of a Bivariate Copula for a Given Parameter's Value</p></a></li>
<li><a href='#condBiCopSim'><p>Simulation from a Conditional Bivariate Copula</p></a></li>
<li><a href='#dim.gamVine'><p>Dimension of an Object of the Class gamVine</p></a></li>
<li><a href='#EDF'><p>Equivalent Degrees of Freedom for an Object of the Class gamBiCop</p></a></li>
<li><a href='#formula.gamBiCop'><p>Model Formula of the gamBiCop Object</p></a></li>
<li><a href='#gamBiCop'><p>Construction of a gamBiCop Class Object</p></a></li>
<li><a href='#gamBiCop-class'><p>The gamBiCop Class</p></a></li>
<li><a href='#gamBiCopCDF'><p>Conditional distribution function of a Generalized Additive model for the</p>
copula parameter or Kendall's tau</a></li>
<li><a href='#gamBiCopFit'><p>Maximum penalized likelihood estimation of a Generalized Additive model</p>
for the copula parameter or Kendall's tau.</a></li>
<li><a href='#gamBiCopPDF'><p>Conditional density function of a Generalized Additive model for the copula</p>
parameter or Kendall's tau</a></li>
<li><a href='#gamBiCopPredict'><p>Predict method of a Generalized Additive model for the copula parameter</p>
or Kendall's tau</a></li>
<li><a href='#gamBiCopSelect'><p>Selection and Maximum penalized likelihood estimation of a Generalized</p>
Additive model (gam) for the copula parameter or Kendall's tau.</a></li>
<li><a href='#gamBiCopSimulate'><p>Simulate from <code>gamBiCop-class</code> object</p></a></li>
<li><a href='#gamCopula-package'>
<p>Generalized Additive Models for Bivariate Conditional Dependence Structures and</p>
Vine Copulas</a></li>
<li><a href='#gamVine'><p>Construction of a gamVine Class Object</p></a></li>
<li><a href='#gamVine-class'><p>The gamVine Class</p></a></li>
<li><a href='#gamVineCopSelect'><p>Sequential pair-copula selection and maximum penalized likelihood estimation</p>
of a GAM-Vine model.</a></li>
<li><a href='#gamVineFamily'><p>Family Matrix of an Object of the Class gamVine</p></a></li>
<li><a href='#gamVineNormalize'><p>Normalize an Object of the Class gamVine</p></a></li>
<li><a href='#gamVinePDF'><p>Conditional density function of a gamVine</p></a></li>
<li><a href='#gamVineSeqFit'><p>Sequential maximum penalized likelihood estimation of a GAM-Vine model.</p></a></li>
<li><a href='#gamVineSimulate'><p>Simulation from a <code>gamVine-class</code> object</p></a></li>
<li><a href='#gamVineStructureSelect'><p>Structure selection and estimation of a GAM-Vine model.</p></a></li>
<li><a href='#logLik.gamBiCop'><p>Extract the Log-likelihood from a gamBiCop Object</p></a></li>
<li><a href='#nobs.gamBiCop'><p>Extract the Number of Observations from gamBiCop Object</p></a></li>
<li><a href='#plot.gamBiCop'><p>Plot a gamBiCop Object</p></a></li>
<li><a href='#plot.gamVine'><p>Plot an Object of the Class gamVine</p></a></li>
<li><a href='#RVM2GVC'><p>Transform an Object of the Class R-Vine into an Object of the Class gamVine</p></a></li>
<li><a href='#summary.gamBiCop'><p>Summary for a gamBiCop Object</p></a></li>
<li><a href='#summary.gamVine'><p>Summary for an Object of the Class gamVine</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Additive Models for Bivariate Conditional Dependence
Structures and Vine Copulas</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thibault Vatter &lt;thibault.vatter@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, VineCopula (&ge; 2.0.0), mgcv, MASS,
gsl, numDeriv, methods, copula, igraph (&ge; 1.0.0), parallel,
foreach, doParallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of various inference and simulation tools to
    apply generalized additive models to bivariate dependence structures and
    non-simplified vine copulas.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tvatter/gamCopula/issues">https://github.com/tvatter/gamCopula/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tvatter/gamCopula">https://github.com/tvatter/gamCopula</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-05 14:43:01 UTC; tvatter</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Nagler [aut],
  Thibault Vatter [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-05 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC.gamBiCop'>Akaike's An Information Criterion for a gamBiCop Object</h2><span id='topic+AIC.gamBiCop'></span><span id='topic+AIC+2CgamBiCop-method'></span>

<h3>Description</h3>

<p>Function calculating Akaike's 'An Information Criterion' (AIC) for an object
of the class <code><a href="#topic+gamBiCop-class">gamBiCop</a></code>
(note that the models are usually fitted by penalized likelihood
maximization).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamBiCop'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.gamBiCop_+3A_object">object</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
<tr><td><code id="AIC.gamBiCop_+3A_...">...</code></td>
<td>
<p>un-used in this class</p>
</td></tr>
<tr><td><code id="AIC.gamBiCop_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default
<code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value with the corresponding AIC.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>.
</p>

<hr>
<h2 id='BIC.gamBiCop'>Schwarz's Bayesian Information Criterion for a gamBiCop Object</h2><span id='topic+BIC.gamBiCop'></span><span id='topic+BIC+2CgamBiCop-method'></span>

<h3>Description</h3>

<p>Function calculating the Schwarz's Bayesian Information Criterion (BIC)
for an object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code> (note that the models are
usually fitted by penalized likelihood maximization).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamBiCop'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.gamBiCop_+3A_object">object</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
<tr><td><code id="BIC.gamBiCop_+3A_...">...</code></td>
<td>
<p>un-used in this class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value with the corresponding BIC.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>.
</p>

<hr>
<h2 id='BiCopEta2Par'>Copula Parameter of a Bivariate Copula for a Given Value of the Calibration
Function</h2><span id='topic+BiCopEta2Par'></span>

<h3>Description</h3>

<p>Computes the (first) copula parameter of a bivariate copula for a given
value of the calibration function (eta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopEta2Par(family, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopEta2Par_+3A_family">family</code></td>
<td>
<p>A copula family:
<code>1</code> Gaussian,
<code>2</code> Student t,
<code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>404</code> Double Gumbel type IV (survival and rotated 270 degrees).</p>
</td></tr>
<tr><td><code id="BiCopEta2Par_+3A_eta">eta</code></td>
<td>
<p>The calibration function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the first copula parameter, depending on the copula
parameter and family as:
</p>

<ul>
<li> <p><code>1</code> Gaussian, <code>f(x) = tanh(x/2)</code>
</p>
</li>
<li> <p><code>2</code> Student t, <code>f(x) = tanh(x/2)</code>
</p>
</li>
<li> <p><code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>f(x) = x</code>
</p>
</li>
<li> <p><code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>f(x) = x</code>
</p>
</li>
<li> <p><code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>f(x) = x</code>
</p>
</li>
<li> <p><code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>f(x) = x</code>
</p>
</li>
<li> <p><code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>f(x) = x*(1+abs(x))/abs(x)</code>
</p>
</li>
<li> <p><code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>f(x) = x*(1+abs(x))/abs(x)</code>
</p>
</li>
<li> <p><code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>f(x) = x*(1+abs(x))/abs(x)</code>
</p>
</li>
<li> <p><code>404</code> Double Gumbel type IV (survival and rotated 270 degrees)
<code>f(x) = x*(1+abs(x))/abs(x)</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+BiCopEta2Par">BiCopEta2Par</a></code> or <code>BiCopPar2Tau</code> and
<code>BiCopTau2Par</code> from
<code><a href="VineCopula.html#topic+VineCopula-package">VineCopula</a></code>.
</p>

<hr>
<h2 id='BiCopPar2Eta'>Calibration Function of a Bivariate Copula for a Given Parameter's Value</h2><span id='topic+BiCopPar2Eta'></span>

<h3>Description</h3>

<p>Computes the calibration function (eta) of a bivariate copula for a given
value of the (first) copula parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopPar2Eta(family, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopPar2Eta_+3A_family">family</code></td>
<td>
<p>A copula family:
<code>1</code> Gaussian,
<code>2</code> Student t,
<code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>404</code> Double Gumbel type IV (survival and rotated 270 degrees).</p>
</td></tr>
<tr><td><code id="BiCopPar2Eta_+3A_par">par</code></td>
<td>
<p>The (first) copula parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the calibration function, depending on the copula
parameter and family as:
</p>

<ul>
<li> <p><code>1</code> Gaussian, <code>f(x) = 2*atanh(x)</code>
</p>
</li>
<li> <p><code>2</code> Student t, <code>f(x) = 2*atanh(x)</code>
</p>
</li>
<li> <p><code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>f(x) = x</code>
</p>
</li>
<li> <p><code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>f(x) = x</code>
</p>
</li>
<li> <p><code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>f(x) = x</code>
</p>
</li>
<li> <p><code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>f(x) = x</code>
</p>
</li>
<li> <p><code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>f(x) = x*(1-1/abs(x))</code>
</p>
</li>
<li> <p><code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>f(x) = x*(1-1/abs(x))</code>
</p>
</li>
<li> <p><code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>f(x) = x*(1-1/abs(x))</code>
</p>
</li>
<li> <p><code>404</code> Double Gumbel type IV (survival and rotated 270 degrees)
<code>f(x) = x*(1-1/abs(x))</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+BiCopEta2Par">BiCopEta2Par</a></code> or <code>BiCopPar2Tau</code> and
<code>BiCopTau2Par</code> from
<code><a href="VineCopula.html#topic+VineCopula-package">VineCopula</a></code>.
</p>

<hr>
<h2 id='condBiCopSim'>Simulation from a Conditional Bivariate Copula</h2><span id='topic+condBiCopSim'></span>

<h3>Description</h3>

<p>Simulates from a conditional bivariate copula, where each copula parameter
takes a different value, depending on the calibration
function and covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condBiCopSim(family, calib.fnc, X, par2 = 0, return.par = TRUE, tau = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condBiCopSim_+3A_family">family</code></td>
<td>
<p>family A copula family:
<code>1</code> Gaussian,
<code>2</code> Student t,
<code>3</code> Clayton,
<code>4</code> Gumbel,
<code>5</code> Frank,
<code>13</code> Survival Clayton,
<code>14</code> Survival Gumbel,
<code>23</code> Rotated (90 degrees) Clayton,
<code>24</code> Rotated (90 degrees) Gumbel,
<code>33</code> Rotated (270 degrees) Clayton and
<code>34</code> Rotated (270 degrees) Gumbel.</p>
</td></tr>
<tr><td><code id="condBiCopSim_+3A_calib.fnc">calib.fnc</code></td>
<td>
<p>A calibration function.</p>
</td></tr>
<tr><td><code id="condBiCopSim_+3A_x">X</code></td>
<td>
<p>A vector (if <code>calib.fnc</code> takes a single argument) or matrix
(if <code>calib.fnc</code> takes multiple arguments) of covariates values.</p>
</td></tr>
<tr><td><code id="condBiCopSim_+3A_par2">par2</code></td>
<td>
<p>The second copula parameter (for the Student t), default
<code>par2 = 0</code>.</p>
</td></tr>
<tr><td><code id="condBiCopSim_+3A_return.par">return.par</code></td>
<td>
<p>Should the parameter (and calibration function) be returned
as well (default <code>return.par = TRUE</code>)?</p>
</td></tr>
<tr><td><code id="condBiCopSim_+3A_tau">tau</code></td>
<td>
<p>Should the calibration function (and the model) be specified for
the copula parameter or Kendall's tau (default <code>tau = TRUE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.par = TRUE</code>, then the function returns a list with:
</p>

<ul>
<li> <p><code>data</code>, a matrix with two columns containing the simulated data,
</p>
</li>
<li> <p><code>par</code>, a vector containing the values of the copula parameter,
</p>
</li>
<li><p> and <code>eta</code>, a vector containing the values of the
calibration function.
</p>
</li></ul>

<p>If <code>return.par = FALSE</code>, then the function simply returns <code>data</code>,
a matrix with two columns containing the simulated data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamBiCopFit">gamBiCopFit</a></code> and <code><a href="#topic+gamBiCopSimulate">gamBiCopSimulate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(copula)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Gaussian copula family)
n &lt;- 2e2
rho &lt;- 0.5
fam &lt;- 1


## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## Display the calibration surface
par(mfrow = c(1, 3), pty = "s", mar = c(1, 1, 4, 1))
u &lt;- seq(0, 1, length.out = 100)
sel &lt;- matrix(c(1, 1, 2, 2, 3, 3), ncol = 2)
jet.colors &lt;- colorRamp(c(
  "#00007F", "blue", "#007FFF", "cyan", "#7FFF7F",
  "yellow", "#FF7F00", "red", "#7F0000"
))
jet &lt;- function(x) rgb(jet.colors(exp(x / 3) / (1 + exp(x / 3))),
    maxColorValue = 255
  )
for (k in 1:3) {
  tmp &lt;- outer(u, u, function(x, y)
    eta0 + calib.surf[[sel[k, 1]]](x) + calib.surf[[sel[k, 2]]](y))
  persp(u, u, tmp,
    border = NA, theta = 60, phi = 30, zlab = "",
    col = matrix(jet(tmp), nrow = 100),
    xlab = paste("X", sel[k, 1], sep = ""),
    ylab = paste("X", sel[k, 2], sep = ""),
    main = paste("eta0+f", sel[k, 1],
      "(X", sel[k, 1], ") +f", sel[k, 2],
      "(X", sel[k, 2], ")",
      sep = ""
    )
  )
}

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Display the data
dev.off()
plot(data[, "u1"], data[, "u2"], xlab = "U1", ylab = "U2")
</code></pre>

<hr>
<h2 id='dim.gamVine'>Dimension of an Object of the Class gamVine</h2><span id='topic+dim.gamVine'></span><span id='topic+dim+2CgamVine-method'></span>

<h3>Description</h3>

<p>Retrieve the dimension of an object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamVine'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.gamVine_+3A_x">x</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dimension of the
<code><a href="#topic+gamVine-class">gamVine</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>

<hr>
<h2 id='EDF'>Equivalent Degrees of Freedom for an Object of the Class gamBiCop</h2><span id='topic+EDF'></span>

<h3>Description</h3>

<p>Function calculating the Equivalent Degrees of Freedom (EDF)
for a <code><a href="#topic+gamBiCop-class">gamBiCop</a></code> object.
It basically sums the edf of the <code><a href="mgcv.html#topic+gamObject">gamObject</a></code>
for each smooth component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EDF(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EDF_+3A_object">object</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated degrees of freedom for each smooth component.
</p>

<hr>
<h2 id='formula.gamBiCop'>Model Formula of the gamBiCop Object</h2><span id='topic+formula.gamBiCop'></span><span id='topic+formula+2CgamBiCop-method'></span>

<h3>Description</h3>

<p>Extracts the <code><a href="mgcv.html#topic+gam">gam</a></code> formula from an object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.
This function is a wrapper to <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>
from the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamBiCop'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.gamBiCop_+3A_x">x</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
<tr><td><code id="formula.gamBiCop_+3A_...">...</code></td>
<td>
<p>un-used in this class</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> function
from the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.
</p>

<hr>
<h2 id='gamBiCop'>Construction of a gamBiCop Class Object</h2><span id='topic+gamBiCop'></span>

<h3>Description</h3>

<p>Constructs an object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamBiCop(family, model, par2 = 0, tau = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamBiCop_+3A_family">family</code></td>
<td>
<p>A copula family: <code>1</code> Gaussian,
<code>2</code> Student t,
<code>5</code> Frank,
<code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>404</code> Double Gumbel type IV (survival and rotated 270 degrees).</p>
</td></tr>
<tr><td><code id="gamBiCop_+3A_model">model</code></td>
<td>
<p>A <code><a href="mgcv.html#topic+gamObject">gamObject</a></code> as return by the
<code><a href="mgcv.html#topic+gam">gam</a></code> function
from the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.</p>
</td></tr>
<tr><td><code id="gamBiCop_+3A_par2">par2</code></td>
<td>
<p>Second parameter for the Student t-copula.</p>
</td></tr>
<tr><td><code id="gamBiCop_+3A_tau">tau</code></td>
<td>
<p><code>FALSE</code> for a calibration function specified
for the Copula parameter or <code>TRUE</code> (default) for a calibration
function specified for Kendall's tau.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamBiCop-class">gamBiCop</a></code>,
<code><a href="#topic+gamBiCopFit">gamBiCopFit</a></code>, <code><a href="#topic+gamBiCopPredict">gamBiCopPredict</a></code> and
<code><a href="#topic+gamBiCopSimulate">gamBiCopSimulate</a></code>.
</p>

<hr>
<h2 id='gamBiCop-class'>The gamBiCop Class</h2><span id='topic+gamBiCop-class'></span>

<h3>Description</h3>

<p>gamBiCop is an S4 class to store
a Generalized Additive Model for bivariate copula a parameter or
Kendall's tau. Objects can be created by calls of the form
<code>new("gamBiCop", ...)</code>, or by function <code><a href="#topic+gamBiCop">gamBiCop</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>family</code></dt><dd><p>A copula family: <code>1</code> Gaussian,
<code>2</code> Student t,
<code>5</code> Frank,
<code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>404</code> Double Gumbel type IV (survival and rotated 270 degrees).</p>
</dd>
<dt><code>model</code></dt><dd><p>A <code><a href="mgcv.html#topic+gamObject">gamObject</a></code> as return by the
<code><a href="mgcv.html#topic+gam">gam</a></code> function
from the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.</p>
</dd>
<dt><code>par2</code></dt><dd><p>Second parameter for the Studen t-copula.</p>
</dd>
<dt><code>tau</code></dt><dd><p><code>FALSE</code> (default) for a calibration fonction
specified for the Copula parameter
or <code>TRUE</code> for a calibration function specified for Kendall's tau.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+gamBiCopFit">gamBiCopFit</a></code>,
<code><a href="#topic+gamBiCopPredict">gamBiCopPredict</a></code> and <code><a href="#topic+gamBiCopSimulate">gamBiCopSimulate</a></code>.
</p>

<hr>
<h2 id='gamBiCopCDF'>Conditional distribution function of a Generalized Additive model for the
copula parameter or Kendall's tau</h2><span id='topic+gamBiCopCDF'></span>

<h3>Description</h3>

<p>This function returns the distribution function of a bivariate conditional
copula, where either the copula parameter or the Kendall's tau is modeled
as a function of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamBiCopCDF(object, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamBiCopCDF_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+gamBiCop-class">gamBiCop-class</a></code> object.</p>
</td></tr>
<tr><td><code id="gamBiCopCDF_+3A_newdata">newdata</code></td>
<td>
<p>(Same as in <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> from the
<code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package) A matrix or data frame
containing the values of the model covariates at which predictions are
required. If this is not provided then the distribution corresponding to the
original data are returned. If <code>newdata</code> is provided then it should contain all
the variables needed for prediction: a warning is generated if not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The conditional density.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamBiCop">gamBiCop</a></code> and <code><a href="#topic+gamBiCopPredict">gamBiCopPredict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(copula)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Gaussian copula family)
n &lt;- 2e2
rho &lt;- 0.5
fam &lt;- 1

## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)
colnames(X) &lt;- paste("x", 1:3, sep = "")

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Model fit with penalized cubic splines (via min GCV)
basis &lt;- c(3, 10, 10)
formula &lt;- ~ s(x1, k = basis[1], bs = "cr") +
  s(x2, k = basis[2], bs = "cr") +
  s(x3, k = basis[3], bs = "cr")
system.time(fit &lt;- gamBiCopFit(data, formula, fam))

## Evaluate the conditional density
gamBiCopCDF(fit$res)
</code></pre>

<hr>
<h2 id='gamBiCopFit'>Maximum penalized likelihood estimation of a Generalized Additive model
for the copula parameter or Kendall's tau.</h2><span id='topic+gamBiCopFit'></span>

<h3>Description</h3>

<p>This function estimates the parameter(s) of a Generalized Additive model
(gam) for the copula parameter or Kendall's tau.
It solves the maximum penalized likelihood estimation for the copula families
supported in this package by reformulating each Newton-Raphson iteration as
a generalized ridge regression, which is solved using
the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamBiCopFit(
  data,
  formula = ~1,
  family = 1,
  tau = TRUE,
  method = "FS",
  tol.rel = 0.001,
  n.iters = 10,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamBiCopFit_+3A_data">data</code></td>
<td>
<p>A list, data frame or matrix containing the model responses,
(u1,u2) in [0,1]x[0,1], and covariates required by the formula.</p>
</td></tr>
<tr><td><code id="gamBiCopFit_+3A_formula">formula</code></td>
<td>
<p>A gam formula (see <code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> and <code><a href="mgcv.html#topic+gam.models">gam.models</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>).</p>
</td></tr>
<tr><td><code id="gamBiCopFit_+3A_family">family</code></td>
<td>
<p>A copula family: <code>1</code> Gaussian,
<code>2</code> Student t,
<code>5</code> Frank,
<code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>404</code> Double Gumbel type IV (survival and rotated 270 degrees).</p>
</td></tr>
<tr><td><code id="gamBiCopFit_+3A_tau">tau</code></td>
<td>
<p><code>FALSE</code> (default) for a calibration function specified for
the Copula parameter or <code>TRUE</code> for a calibration function specified
for Kendall's tau.</p>
</td></tr>
<tr><td><code id="gamBiCopFit_+3A_method">method</code></td>
<td>
<p><code>'NR'</code> for Newton-Raphson
and  <code>'FS'</code> for Fisher-scoring (default).</p>
</td></tr>
<tr><td><code id="gamBiCopFit_+3A_tol.rel">tol.rel</code></td>
<td>
<p>Relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamBiCopFit_+3A_n.iters">n.iters</code></td>
<td>
<p>Maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamBiCopFit_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> if informations should be printed during the
estimation and <code>FALSE</code> (default) for a silent version.</p>
</td></tr>
<tr><td><code id="gamBiCopFit_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="mgcv.html#topic+gam">gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gamBiCopFit</code> returns a list consisting of
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>S4 <code><a href="#topic+gamBiCop-class">gamBiCop-class</a></code> object.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>'FS'</code> for Fisher-scoring (default) and
<code>'NR'</code> for Newton-Raphson.</p>
</td></tr>
<tr><td><code>tol.rel</code></td>
<td>
<p>relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code>n.iters</code></td>
<td>
<p>maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>the estimation procedure's trace.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p><code>0</code> if the algorithm converged and <code>1</code> otherwise.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gamBiCop">gamBiCop</a></code> and <code><a href="#topic+gamBiCopSimulate">gamBiCopSimulate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(copula)
require(mgcv)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Gaussian copula family)
n &lt;- 5e2
rho &lt;- 0.5
fam &lt;- 1


## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## Display the calibration surface
par(mfrow = c(1, 3), pty = "s", mar = c(1, 1, 4, 1))
u &lt;- seq(0, 1, length.out = 100)
sel &lt;- matrix(c(1, 1, 2, 2, 3, 3), ncol = 2)
jet.colors &lt;- colorRamp(c(
  "#00007F", "blue", "#007FFF", "cyan", "#7FFF7F",
  "yellow", "#FF7F00", "red", "#7F0000"
))
jet &lt;- function(x) rgb(jet.colors(exp(x / 3) / (1 + exp(x / 3))),
    maxColorValue = 255
  )
for (k in 1:3) {
  tmp &lt;- outer(u, u, function(x, y)
    eta0 + calib.surf[[sel[k, 1]]](x) + calib.surf[[sel[k, 2]]](y))
  persp(u, u, tmp,
    border = NA, theta = 60, phi = 30, zlab = "",
    col = matrix(jet(tmp), nrow = 100),
    xlab = paste("X", sel[k, 1], sep = ""),
    ylab = paste("X", sel[k, 2], sep = ""),
    main = paste("eta0+f", sel[k, 1],
      "(X", sel[k, 1], ") +f", sel[k, 2],
      "(X", sel[k, 2], ")",
      sep = ""
    )
  )
}

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Display the data
dev.off()
plot(data[, "u1"], data[, "u2"], xlab = "U1", ylab = "U2")

## Model fit with a basis size (arguably) too small
## and unpenalized cubic spines
pen &lt;- FALSE
basis0 &lt;- c(3, 4, 4)
formula &lt;- ~ s(x1, k = basis0[1], bs = "cr", fx = !pen) +
  s(x2, k = basis0[2], bs = "cr", fx = !pen) +
  s(x3, k = basis0[3], bs = "cr", fx = !pen)
system.time(fit0 &lt;- gamBiCopFit(data, formula, fam))

## Model fit with a better basis size and penalized cubic splines (via min GCV)
pen &lt;- TRUE
basis1 &lt;- c(3, 10, 10)
formula &lt;- ~ s(x1, k = basis1[1], bs = "cr", fx = !pen) +
  s(x2, k = basis1[2], bs = "cr", fx = !pen) +
  s(x3, k = basis1[3], bs = "cr", fx = !pen)
system.time(fit1 &lt;- gamBiCopFit(data, formula, fam))

## Extract the gamBiCop objects and show various methods
(res &lt;- sapply(list(fit0, fit1), function(fit) {
  fit$res
}))
metds &lt;- list("logLik" = logLik, "AIC" = AIC, "BIC" = BIC, "EDF" = EDF)
lapply(res, function(x) sapply(metds, function(f) f(x)))


## Comparison between fitted, true smooth and spline approximation for each
## true smooth function for the two basis sizes
fitted &lt;- lapply(res, function(x) gamBiCopPredict(x, data.frame(x1 = u, x2 = u, x3 = u),
    type = "terms"
  )$calib)
true &lt;- vector("list", 3)
for (i in 1:3) {
  y &lt;- eta0 + calib.surf[[i]](u)
  true[[i]]$true &lt;- y - eta0
  temp &lt;- gam(y ~ s(u, k = basis0[i], bs = "cr", fx = TRUE))
  true[[i]]$approx &lt;- predict.gam(temp, type = "terms")
  temp &lt;- gam(y ~ s(u, k = basis1[i], bs = "cr", fx = FALSE))
  true[[i]]$approx2 &lt;- predict.gam(temp, type = "terms")
}

## Display results
par(mfrow = c(1, 3), pty = "s")
yy &lt;- range(true, fitted)
yy[1] &lt;- yy[1] * 1.5
for (k in 1:3) {
  plot(u, true[[k]]$true,
    type = "l", ylim = yy,
    xlab = paste("Covariate", k), ylab = paste("Smooth", k)
  )
  lines(u, true[[k]]$approx, col = "red", lty = 2)
  lines(u, fitted[[1]][, k], col = "red")
  lines(u, fitted[[2]][, k], col = "green")
  lines(u, true[[k]]$approx2, col = "green", lty = 2)
  legend("bottomleft",
    cex = 0.6, lty = c(1, 1, 2, 1, 2),
    c("True", "Fitted", "Appox 1", "Fitted 2", "Approx 2"),
    col = c("black", "red", "red", "green", "green")
  )
}
</code></pre>

<hr>
<h2 id='gamBiCopPDF'>Conditional density function of a Generalized Additive model for the copula
parameter or Kendall's tau</h2><span id='topic+gamBiCopPDF'></span>

<h3>Description</h3>

<p>This function returns the density of a bivariate conditional copula, where
either the copula parameter or the Kendall's tau is modeled as a function
of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamBiCopPDF(object, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamBiCopPDF_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+gamBiCop-class">gamBiCop-class</a></code> object.</p>
</td></tr>
<tr><td><code id="gamBiCopPDF_+3A_newdata">newdata</code></td>
<td>
<p>(Same as in <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> from the
<code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package) A matrix or data frame
containing the values of the model covariates at which predictions are
required, along with two columns named '&quot;u1&quot;' and '&quot;u2&quot;'.
If this is not provided then the density corresponding to the
original data are returned. If <code>newdata</code> is provided then it should contain all
the variables needed for prediction: a warning is generated if not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The conditional density.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamBiCop">gamBiCop</a></code> and <code><a href="#topic+gamBiCopPredict">gamBiCopPredict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(copula)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Gaussian copula family)
n &lt;- 2e2
rho &lt;- 0.5
fam &lt;- 1

## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)
colnames(X) &lt;- paste("x", 1:3, sep = "")

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Model fit with penalized cubic splines (via min GCV)
basis &lt;- c(3, 10, 10)
formula &lt;- ~ s(x1, k = basis[1], bs = "cr") +
  s(x2, k = basis[2], bs = "cr") +
  s(x3, k = basis[3], bs = "cr")
system.time(fit &lt;- gamBiCopFit(data, formula, fam))

## Evaluate the conditional density
gamBiCopPDF(fit$res)
</code></pre>

<hr>
<h2 id='gamBiCopPredict'>Predict method of a Generalized Additive model for the copula parameter
or Kendall's tau</h2><span id='topic+gamBiCopPredict'></span>

<h3>Description</h3>

<p>Predict method of a Generalized Additive model for the copula parameter
or Kendall's tau
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamBiCopPredict(
  object,
  newdata = NULL,
  target = "calib",
  alpha = 0,
  type = "link"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamBiCopPredict_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+gamBiCop-class">gamBiCop-class</a></code> object.</p>
</td></tr>
<tr><td><code id="gamBiCopPredict_+3A_newdata">newdata</code></td>
<td>
<p>(Same as in <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> from the
<code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package) A matrix or data frame
containing the values of the model covariates at which predictions are
required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then it should contain all
the variables needed for prediction: a warning is generated if not.</p>
</td></tr>
<tr><td><code id="gamBiCopPredict_+3A_target">target</code></td>
<td>
<p>Either <code>'calib'</code>, <code>'par'</code> or <code>'tau'</code> or a
combination of those. <code>'calib'</code> (default) corresponds to the calibration
function, <code>'par'</code> to the copula parameter and
<code>'tau'</code> to Kendall's tau.</p>
</td></tr>
<tr><td><code id="gamBiCopPredict_+3A_alpha">alpha</code></td>
<td>
<p>In (0,1) to return the corresponding confidence interval.</p>
</td></tr>
<tr><td><code id="gamBiCopPredict_+3A_type">type</code></td>
<td>
<p>(Similar as in <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> from the
<code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package, only active for
<code>type = 'calib'</code>). When this has the value <code>'link'</code> (default), the
calibration function is returned.  When <code>type = 'terms'</code> each component
of the linear predictor is returned separately (possibly with standard
errors): this includes parametric model components, followed by each smooth
component, but excludes any offset and any intercept. When
<code>type = 'lpmatrix'</code> then a matrix is returned which yields the values of
the linear predictor (minus any offset) when post-multiplied by the parameter
vector (in this case alpha is ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>target = 'calib'</code>, then a list with 1 item <code>calib</code>.
If <code>target = 'par'</code>, <code>target = 'tau'</code> or
<code>target = c('par', 'tau')</code>,
then a list with 2, 2 or 3 items, namely <code>calib</code> and <code>par</code>,
<code>tau</code> and <code>par</code>, or  <code>calib</code>, <code>tau</code> and <code>par</code>.
</p>
<p>If <code>alpha</code> is in (0,1), then a additional items of the list are
<code>calib.CI</code> as well as e.g. <code>par.CI</code> and/or <code>tau.CI</code> depending
on the value of <code>target</code>.
</p>
<p>Otherwise, if <code>type = 'lpmatrix'</code> (only active for
<code>type = 'calib'</code>), then a matrix is returned which will give a vector of
linear predictor values (minus any offset) at the supplied covariate values,
when applied to the model coefficient vector (similar as
<code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> from the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamBiCop">gamBiCop</a></code> and <code><a href="#topic+gamBiCopFit">gamBiCopFit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(copula)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Clayton copula family)
n &lt;- 5e2
rho &lt;- 0.5
fam &lt;- 1

## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)
colnames(X) &lt;- paste("x", 1:3, sep = "")

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Model fit with penalized cubic splines (via min GCV)
basis &lt;- c(3, 10, 10)
formula &lt;- ~ s(x1, k = basis[1], bs = "cr") +
  s(x2, k = basis[2], bs = "cr") +
  s(x3, k = basis[3], bs = "cr")
system.time(fit &lt;- gamBiCopFit(data, formula, fam))

## Extract the gamBiCop objects and show various methods
(res &lt;- fit$res)
EDF(res)
pred &lt;- gamBiCopPredict(fit$res, X, target = c("calib", "par", "tau"))
</code></pre>

<hr>
<h2 id='gamBiCopSelect'>Selection and Maximum penalized likelihood estimation of a Generalized
Additive model (gam) for the copula parameter or Kendall's tau.</h2><span id='topic+gamBiCopSelect'></span>

<h3>Description</h3>

<p>This function selects an appropriate bivariate copula family for given
bivariate copula data using one of a range of methods. The corresponding
parameter estimates are obtained by maximum penalized  likelihood estimation,
where each Newton-Raphson iteration is reformulated as a generalized ridge
regression solved using the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamBiCopSelect(
  udata,
  lin.covs = NULL,
  smooth.covs = NULL,
  familyset = NA,
  rotations = TRUE,
  familycrit = "AIC",
  level = 0.05,
  edf = 1.5,
  tau = TRUE,
  method = "FS",
  tol.rel = 0.001,
  n.iters = 10,
  parallel = FALSE,
  verbose = FALSE,
  select.once = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamBiCopSelect_+3A_udata">udata</code></td>
<td>
<p>A matrix or data frame containing the model responses, (u1,u2) in
[0,1]x[0,1]</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_lin.covs">lin.covs</code></td>
<td>
<p>A matrix or data frame containing the parametric (i.e.,
linear) covariates.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_smooth.covs">smooth.covs</code></td>
<td>
<p>A matrix or data frame containing the non-parametric
(i.e., smooth) covariates.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_familyset">familyset</code></td>
<td>
<p>(Similar to <code>BiCopSelect</code> from the
<code><a href="VineCopula.html#topic+VineCopula-package">VineCopula</a></code> package)
Vector of bivariate copula families to select from.
If <code>familyset = NA</code> (default), selection
among all possible families is performed.   Coding of bivariate copula
families:
<code>1</code> Gaussian,
<code>2</code> Student t,
<code>5</code> Frank,
<code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>404</code> Double Gumbel type IV (survival and rotated 270 degrees).</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_rotations">rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in familyset
are included.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_familycrit">familycrit</code></td>
<td>
<p>Character indicating the criterion for bivariate copula
selection. Possible choices: <code>familycrit = 'AIC'</code> (default) or
<code>'BIC'</code>, as in <code>BiCopSelect</code> from the
<code><a href="VineCopula.html#topic+VineCopula-package">VineCopula</a></code> package.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_level">level</code></td>
<td>
<p>Numerical; significance level of the test for removing individual
predictors (default: <code>level = 0.05</code>).</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_edf">edf</code></td>
<td>
<p>Numerical; if the estimated EDF for individual predictors is
smaller than <code>edf</code> but the predictor is still significant, then
it is set as linear (default: <code>edf = 1.5</code>).</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_tau">tau</code></td>
<td>
<p><code>FALSE</code> for a calibration function specified for
the Copula parameter or <code>TRUE</code> (default) for a calibration function
specified for Kendall's tau.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_method">method</code></td>
<td>
<p><code>'FS'</code> for Fisher-scoring (default) and
<code>'NR'</code> for Newton-Raphson.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_tol.rel">tol.rel</code></td>
<td>
<p>Relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_n.iters">n.iters</code></td>
<td>
<p>Maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_parallel">parallel</code></td>
<td>
<p><code>TRUE</code> for a parallel estimation across copula families.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> prints informations during the estimation.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_select.once">select.once</code></td>
<td>
<p>if <code>TRUE</code> the GAM structure is only selected once,
for the family that appears first in <code>familyset</code>.</p>
</td></tr>
<tr><td><code id="gamBiCopSelect_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="mgcv.html#topic+gam">gam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gamBiCopFit</code> returns a list consisting of
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>S4 <code><a href="#topic+gamBiCop-class">gamBiCop-class</a></code> object.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>'FS'</code> for Fisher-scoring and
<code>'NR'</code> for Newton-Raphson.</p>
</td></tr>
<tr><td><code>tol.rel</code></td>
<td>
<p>relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code>n.iters</code></td>
<td>
<p>maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>the estimation procedure's trace.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p><code>0</code> if the algorithm converged and <code>1</code> otherwise.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gamBiCop">gamBiCop</a></code> and <code><a href="#topic+gamBiCopFit">gamBiCopFit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(copula)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Student copula with 4 degrees of freedom)
n &lt;- 5e2
rho &lt;- 0.9
fam &lt;- 2
par2 &lt;- 4

## A calibration surface depending on four variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.lin &lt;- function(t, Ti = 0, Tf = 1, b = 2) {
    return(-2 + 4 * t)
  },
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## 6-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 6),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)
colnames(X) &lt;- paste("x", 1:6, sep = "")

## U in [0,1]x[0,1] depending on the four first columns of X
U &lt;- condBiCopSim(fam, function(x1, x2, x3, x4) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3, x4)))
}, X[, 1:4], par2 = 4, return.par = TRUE)
## Not run: 
## Selection using AIC (about 30sec on single core)
## Use parallel = TRUE to speed-up....
system.time(best &lt;- gamBiCopSelect(U$data, smooth.covs = X))
print(best$res)
EDF(best$res) ## The first function is linear
## Plot only the smooth component
par(mfrow = c(2, 2))
plot(best$res)

## End(Not run)
</code></pre>

<hr>
<h2 id='gamBiCopSimulate'>Simulate from <code><a href="#topic+gamBiCop-class">gamBiCop-class</a></code> object</h2><span id='topic+gamBiCopSimulate'></span>

<h3>Description</h3>

<p>Simulate from <code><a href="#topic+gamBiCop-class">gamBiCop-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamBiCopSimulate(
  object,
  newdata = NULL,
  N = NULL,
  return.calib = FALSE,
  return.par = FALSE,
  return.tau = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamBiCopSimulate_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+gamBiCop-class">gamBiCop-class</a></code> object.</p>
</td></tr>
<tr><td><code id="gamBiCopSimulate_+3A_newdata">newdata</code></td>
<td>
<p>(same as in <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> from the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package) A matrix or data frame containing the values of the model covariates at which simulations are required.
If this is not provided then simulations corresponding to the original data are returned.</p>
</td></tr>
<tr><td><code id="gamBiCopSimulate_+3A_n">N</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="gamBiCopSimulate_+3A_return.calib">return.calib</code></td>
<td>
<p>should the calibration function (<code>TRUE</code>) be returned or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="gamBiCopSimulate_+3A_return.par">return.par</code></td>
<td>
<p>should the copula parameter (<code>TRUE</code>) be returned or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="gamBiCopSimulate_+3A_return.tau">return.tau</code></td>
<td>
<p>should the Kendall's tau (<code>TRUE</code>) be returned or not (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 1 item <code>data</code>.  When <code>N</code> is smaller or larger than the <code>newdata</code>'s number of rows
(or the number of rows in the original data if <code>newdata</code> is not provided),
then <code>N</code> observations are sampled uniformly (with replacement) among the row of <code>newdata</code>
(or the rows of the original data if <code>newdata</code> is not provided).
</p>
<p>If <code>return.calib = TRUE</code>, <code>return.par = TRUE</code>
and/or <code>return.tau = TRUE</code>, then the list also contains respectively items
<code>calib</code>, <code>par</code> and/or <code>tau</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(copula)
set.seed(1)

## Simulation parameters (sample size, correlation between covariates,
## Gaussian copula family)
n &lt;- 5e2
rho &lt;- 0.5
fam &lt;- 1

## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)
colnames(X) &lt;- paste("x", 1:3, sep = "")

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Model fit with penalized cubic splines (via min GCV)
basis &lt;- c(3, 10, 10)
formula &lt;- ~ s(x1, k = basis[1], bs = "cr") +
  s(x2, k = basis[2], bs = "cr") +
  s(x3, k = basis[3], bs = "cr")
system.time(fit &lt;- gamBiCopFit(data, formula, fam))

## Extract the gamBiCop objects and show various methods
(res &lt;- fit$res)
EDF(res)
sim &lt;- gamBiCopSimulate(fit$res, X)
</code></pre>

<hr>
<h2 id='gamCopula-package'>
Generalized Additive Models for Bivariate Conditional Dependence Structures and 
Vine Copulas
</h2><span id='topic+gamCopula-package'></span><span id='topic+gamCopula'></span><span id='topic+gamCopula.package'></span>

<h3>Description</h3>

<p>This package implements inference and simulation tools to apply generalized additive models to bivariate dependence structures and vine copulas.
</p>
<p>More references in Vatter and Chavez-Demoulin (2015), and Vatter and Nagler (2016).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> gamCopula</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-02-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Thibault Vatter and Thomas Nagler
</p>
<p>Maintainer: Thibault Vatter &lt;thibault.vatter@gmail.com&gt;
</p>


<h3>References</h3>

<p>Aas, K., C. Czado, A. Frigessi, and H. Bakken (2009)
Pair-copula constructions of multiple dependence.
Insurance: Mathematics and Economics 44 (2), 182-198.
</p>
<p>Brechmann, E. C., C. Czado, and K. Aas (2012)
Truncated regular vines in high dimensions with applications to financial data.
Canadian Journal of Statistics 40 (1), 68-85.
</p>
<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka (2013)
Selecting and estimating regular vine copulae and application to financial returns.
Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>
<p>Vatter, T. and V. Chavez-Demoulin (2015)
Generalized Additive Models for Conditional Dependence Structures.
Journal of Multivariate Analysis, 141, 147-167.
</p>
<p>Vatter, T. and T. Nagler (2016)
Generalized additive models for non-simplified pair-copula constructions.
<a href="https://arxiv.org/abs/1608.01593">https://arxiv.org/abs/1608.01593</a>
</p>
<p>Wood, S.N. (2004)
Stable and efficient multiple smoothing parameter estimation for generalized additive models. 
Journal of the American Statistical Association, 99, 673-686. 
</p>
<p>Wood, S.N. (2006) 
Generalized Additive Models: an introduction with R.
Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p>The present package is heavily relying on the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> and <code>VineCopula</code> packages, as it basically extends and mix both of them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### A gamBiCop example
require(copula)
require(mgcv)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Gaussian copula family)
n &lt;- 5e2
rho &lt;- 0.5
fam &lt;- 1

## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti)/2
    a &lt;- -(b/3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
  return(a + b * (t - Tm)^2)},
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi/(f * Tf * pi +
                                 cos(2 * f * pi * (Tf - Ti))
                               - cos(2 * f * pi * Ti)))
    return((a + b)/2 + (b - a) * sin(2 * f * pi * (t - Ti))/2)},
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf/8) {
    Tm &lt;- (Tf - Ti)/2
    a &lt;- (b * s * sqrt(2 * pi)/Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2/(2 * s^2)))})

## Display the calibration surface
par(mfrow = c(1, 3), pty = "s", mar = c(1, 1, 4, 1))
u &lt;- seq(0, 1, length.out = 100)
sel &lt;- matrix(c(1, 1, 2, 2, 3, 3), ncol = 2)
jet.colors &lt;- colorRamp(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", 
                          "yellow", "#FF7F00", "red", "#7F0000"))
jet &lt;- function(x) rgb(jet.colors(exp(x/3)/(1 + exp(x/3))), 
                       maxColorValue = 255)
for (k in 1:3) {
    tmp &lt;- outer(u, u, function(x, y) 
      eta0 + calib.surf[[sel[k,1]]](x) + calib.surf[[sel[k, 2]]](y))
    persp(u, u, tmp, border = NA, theta = 60, phi = 30, zlab = "", 
          col = matrix(jet(tmp), nrow = 100), 
          xlab = paste("X", sel[k, 1], sep = ""), 
          ylab = paste("X", sel[k,2], sep = ""), 
          main = paste("eta0+f", sel[k, 1], 
                       "(X", sel[k, 1], ") +f",sel[k, 2], 
                       "(X", sel[k, 2], ")", sep = ""))
}

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
                                 c("unif"), list(list(min = 0, max = 1)),
                                 marginsIdentical = TRUE)
X &lt;- rMvdc(n, covariates.distr)

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1,x2,x3) {eta0+sum(mapply(function(f,x)
  f(x), calib.surf, c(x1,x2,x3)))}, X[,1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data,X)
names(data) &lt;- c(paste("u",1:2,sep=""),paste("x",1:3,sep=""))

## Display the data
dev.off()
plot(data[, "u1"], data[, "u2"], xlab = "U1", ylab = "U2")

## Model fit with a basis size (arguably) too small 
## and unpenalized cubic spines
pen &lt;- FALSE
basis0 &lt;- c(3, 4, 4)
formula &lt;- ~s(x1, k = basis0[1], bs = "cr", fx = !pen) + 
  s(x2, k = basis0[2], bs = "cr", fx = !pen) + 
  s(x3, k = basis0[3], bs = "cr", fx = !pen)
system.time(fit0 &lt;- gamBiCopFit(data, formula, fam))

## Model fit with a better basis size and penalized cubic splines (via min GCV)
pen &lt;- TRUE
basis1 &lt;- c(3, 10, 10)
formula &lt;- ~s(x1, k = basis1[1], bs = "cr", fx = !pen) + 
  s(x2, k = basis1[2], bs = "cr", fx = !pen) + 
  s(x3, k = basis1[3], bs = "cr", fx = !pen)
system.time(fit1 &lt;- gamBiCopFit(data, formula, fam))

## Extract the gamBiCop objects and show various methods
(res &lt;- sapply(list(fit0,fit1), function(fit){fit$res}))
metds &lt;- list('logLik'=logLik,'AIC'=AIC,'BIC'=BIC,'EDF'=EDF)
lapply(res, function(x) sapply(metds, function(f) f(x)))


## Comparison between fitted, true smooth and spline approximation for each
## true smooth function for the two basis sizes
fitted &lt;- lapply(res, function(x) gamBiCopPredict(x, data.frame(x1=u,x2=u,x3=u), 
                                               type = "terms")$calib)
true &lt;- vector("list", 3)
for (i in 1:3) {
    y &lt;- eta0+calib.surf[[i]](u)   
    true[[i]]$true &lt;- y - eta0   
    temp &lt;- gam(y ~ s(u, k = basis0[i], bs = "cr", fx = TRUE))
    true[[i]]$approx &lt;- predict.gam(temp, type = "terms")
    temp &lt;- gam(y ~s(u, k = basis1[i], bs = "cr", fx = FALSE))
    true[[i]]$approx2 &lt;- predict.gam(temp, type = "terms")
}

## Display results
par(mfrow = c(1, 3), pty = "s")
yy &lt;- range(true, fitted)
yy[1] &lt;- yy[1] * 1.5
for(k in 1:3){
  plot(u, true[[k]]$true, type = "l", ylim = yy, 
       xlab = paste("Covariate",k), ylab = paste("Smooth",k))
  lines(u, true[[k]]$approx, col = "red", lty = 2)
  lines(u, fitted[[1]][, k], col = "red")
  lines(u, fitted[[2]][, k], col = "green")
  lines(u, true[[k]]$approx2, col = "green", lty = 2)
  legend("bottomleft", cex = 0.6, lty = c(1, 1, 2, 1, 2),
         c("True", "Fitted", "Appox 1", "Fitted 2", "Approx 2"), 
         col = c("black", "red", "red", "green", "green"))
}

##### A gamVine example
set.seed(0)

##  Simulation parameters
# Sample size
n &lt;- 1e3
# Copula families
familyset &lt;- c(1:2,301:304,401:404)
# Define a 4-dimensional R-vine tree structure matrix
d &lt;- 4
Matrix &lt;- c(2,3,4,1,0,3,4,1,0,0,4,1,0,0,0,1)
Matrix &lt;- matrix(Matrix,d,d)
nnames &lt;- paste("X", 1:d, sep = "")

## A function factory
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti)/2
    a &lt;- -(b/3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)},
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi/(f * Tf * pi +
                                 cos(2 * f * pi * (Tf - Ti))
                               - cos(2 * f * pi * Ti)))
    return((a + b)/2 + (b - a) * sin(2 * f * pi * (t - Ti))/2)},
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf/8) {
    Tm &lt;- (Tf - Ti)/2
    a &lt;- (b * s * sqrt(2 * pi)/Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2/(2 * s^2)))})

##  Create the model
# Define gam-vine model list
count &lt;- 1
model &lt;- vector(mode = "list", length = d*(d-1)/2)
sel &lt;- seq(d,d^2-d, by = d)

# First tree
for (i in 1:(d-1)) {
  # Select a copula family
  family &lt;- sample(familyset, 1)
  model[[count]]$family &lt;- family
  
  # Use the canonical link and a randomly generated parameter 
  if (is.element(family,c(1,2))) {
    model[[count]]$par &lt;- tanh(rnorm(1)/2)
    if (family == 2) {
      model[[count]]$par2 &lt;- 2+exp(rnorm(1))
    }  
  } else {
    if (is.element(family,c(401:404))) {
      rr &lt;- rnorm(1)
      model[[count]]$par &lt;- sign(rr)*(1+abs(rr))
    } else {
      model[[count]]$par &lt;- rnorm(1)
    }
    model[[count]]$par2 &lt;- 0
  }
  count &lt;- count + 1
}

# A dummy dataset
data &lt;- data.frame(u1 = runif(1e2), u2 = runif(1e2), matrix(runif(1e2*d),1e2,d))

# Trees 2 to (d-1)
for(j in 2:(d-1)){
  for(i in 1:(d-j)){ 
    # Select a copula family
    family &lt;- sample(familyset, 1)  
    
    # Select the conditiong set and create a model formula
    cond &lt;- nnames[sort(Matrix[(d-j+2):d,i])]
    tmpform &lt;- paste("~",paste(paste("s(", cond, ", k=10, bs='cr')",
                                     sep = ""), collapse=" + "))
    l &lt;- length(cond)
    temp &lt;- sample(3, l, replace = TRUE)
    
    # Spline approximation of the true function
    m &lt;- 1e2
    x &lt;- matrix(seq(0,1,length.out=m), nrow = m, ncol = 1)
    if(l != 1){  
      tmp.fct &lt;- paste("function(x){eta0+",
                       paste(sapply(1:l, function(x) 
                         paste("calib.surf[[",temp[x],"]](x[",x,"])",
                               sep="")), collapse="+"),"}",sep="")
      tmp.fct &lt;- eval(parse(text = tmp.fct))
      x &lt;- eval(parse(text = paste0("expand.grid(",
                                   paste0(rep("x",l), collapse = ","),")", 
                                   collapse = "")))
      y &lt;- apply(x,1,tmp.fct)
    }else{
      tmp.fct &lt;- function(x) eta0+calib.surf[[temp]](x)  
      colnames(x) &lt;- cond
      y &lt;- tmp.fct(x)
    }
    
    # Estimate the gam model
    form &lt;- as.formula(paste0("y", tmpform))
    dd &lt;- data.frame(y, x)
    names(dd) &lt;- c("y", cond)
    b &lt;- gam(form, data = dd)
    #plot(x[,1],(y-fitted(b))/y)
    
    # Create a dummy gamBiCop object
    tmp &lt;- gamBiCopFit(data = data, formula = form, family = 1, n.iters = 1)$res
    
    # Update the copula family and the model coefficients
    attr(tmp, "model")$coefficients &lt;- coefficients(b)
    attr(tmp, "model")$smooth &lt;- b$smooth
    attr(tmp, "family") &lt;- family
    if (family == 2) {
      attr(tmp, "par2") &lt;- 2+exp(rnorm(1))
    }
    model[[count]] &lt;- tmp
    count &lt;- count+1  
  } 
}

# Create the gamVineCopula object
GVC &lt;- gamVine(Matrix=Matrix,model = model,names=nnames)
print(GVC)

## Not run: 
## Simulate and fit the model
sim &lt;- gamVineSimulate(n, GVC)
fitGVC &lt;- gamVineSeqFit(sim, GVC, verbose = TRUE)
fitGVC2 &lt;- gamVineCopSelect(sim, Matrix, verbose = TRUE)

## Plot the results
par(mfrow=c(3,4))
plot(GVC, ylim = c(-2.5,2.5))

plot(fitGVC, ylim = c(-2.5,2.5))

plot(fitGVC2, ylim = c(-2.5,2.5))
## End(Not run)

</code></pre>

<hr>
<h2 id='gamVine'>Construction of a gamVine Class Object</h2><span id='topic+gamVine'></span>

<h3>Description</h3>

<p>Constructs an object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVine(Matrix, model, names = NA, covariates = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamVine_+3A_matrix">Matrix</code></td>
<td>
<p>lower triangular d x d matrix that defines the tree structure.</p>
</td></tr>
<tr><td><code id="gamVine_+3A_model">model</code></td>
<td>
<p>list containing d x (d-1)/2 lists with three numeric items
(family, par and par2) and/or objects of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
<tr><td><code id="gamVine_+3A_names">names</code></td>
<td>
<p>vector of d names.</p>
</td></tr>
<tr><td><code id="gamVine_+3A_covariates">covariates</code></td>
<td>
<p>vector of names for the covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamVine-class">gamVine</a></code>,
<code>RVineMatrix</code>, <code><a href="#topic+gamBiCop-class">gamBiCop</a></code>
<code><a href="#topic+gamVineSeqFit">gamVineSeqFit</a></code>, <code><a href="#topic+gamVineCopSelect">gamVineCopSelect</a></code>,
<code><a href="#topic+gamVineStructureSelect">gamVineStructureSelect</a></code> and <code><a href="#topic+gamVineSimulate">gamVineSimulate</a></code>.
</p>

<hr>
<h2 id='gamVine-class'>The gamVine Class</h2><span id='topic+gamVine-class'></span>

<h3>Description</h3>

<p>gamVine is an S4 class to store a conditional and potentially
non-simplified pair-copula construction. Objects can be created by calls of
the form <code>new("gamVine", ...)</code>, or by function <code><a href="#topic+gamVine">gamVine</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Matrix</code></dt><dd><p>Lower triangular d x d matrix that defines the tree structure.</p>
</dd>
<dt><code>model</code></dt><dd><p>list containing d x (d-1)/2 lists with three numeric items
(family, par and par2) and/or
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code> objects.</p>
</dd>
<dt><code>names</code></dt><dd><p>vector of d names.</p>
</dd>
<dt><code>covariates</code></dt><dd><p>vector of names for the exogenous covariates.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+gamVine">gamVine</a></code>,
<code>RVineMatrix</code>, <code><a href="#topic+gamBiCop-class">gamBiCop</a></code>
<code><a href="#topic+gamVineSeqFit">gamVineSeqFit</a></code>, <code><a href="#topic+gamVineCopSelect">gamVineCopSelect</a></code>,
<code><a href="#topic+gamVineStructureSelect">gamVineStructureSelect</a></code> and <code><a href="#topic+gamVineSimulate">gamVineSimulate</a></code>.
</p>

<hr>
<h2 id='gamVineCopSelect'>Sequential pair-copula selection and maximum penalized likelihood estimation
of a GAM-Vine model.</h2><span id='topic+gamVineCopSelect'></span>

<h3>Description</h3>

<p>This function select the copula family and estimates the parameter(s) of a
Generalized Additive model
(GAM) Vine model, where GAMs for individual edges are specified either for
the copula parameter or Kendall's tau.
It solves the maximum penalized likelihood estimation for the copula families
supported in this package by reformulating each Newton-Raphson iteration as
a generalized ridge regression, which is solved using
the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVineCopSelect(
  data,
  Matrix,
  lin.covs = NULL,
  smooth.covs = NULL,
  simplified = FALSE,
  familyset = NA,
  rotations = TRUE,
  familycrit = "AIC",
  level = 0.05,
  trunclevel = NA,
  tau = TRUE,
  method = "FS",
  tol.rel = 0.001,
  n.iters = 10,
  parallel = FALSE,
  verbose = FALSE,
  select.once = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamVineCopSelect_+3A_data">data</code></td>
<td>
<p>A matrix or data frame containing the data in [0,1]^d.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_matrix">Matrix</code></td>
<td>
<p>Lower triangular <code>d x d</code> matrix that defines the R-vine
tree structure.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_lin.covs">lin.covs</code></td>
<td>
<p>A matrix or data frame containing the parametric (i.e.,
linear) covariates (default: <code>lin.covs = NULL</code>).</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_smooth.covs">smooth.covs</code></td>
<td>
<p>A matrix or data frame containing the non-parametric
(i.e., smooth) covariates (default: <code>smooth.covs = NULL</code>).</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_simplified">simplified</code></td>
<td>
<p>If <code>TRUE</code>, then a simplified vine is fitted (which is
possible only if there are exogenous covariates). If <code>FALSE</code> (default),
then a non-simplified vine is fitted.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_familyset">familyset</code></td>
<td>
<p>An integer vector of pair-copula families to select from
(the independence copula MUST NOT be specified in this vector unless one
wants to fit an independence vine!). The vector has to include at least one
pair-copula family that allows for positive and one that allows for negative
dependence. Not listed copula families might be included to better handle
limit cases. If <code>familyset = NA</code> (default), selection among all
possible families is performed. Coding of pair-copula families:
<code>1</code> Gaussian, <code>2</code> Student t,
<code>3</code> Clayton, <code>4</code> Gumbel, <code>13</code> Survival Clayton,
<code>14</code> Survival Gumbel,  <code>23</code> Rotated (90 degrees) Clayton,
<code>24</code> Rotated (90 degrees) Gumbel,
<code>33</code> Rotated (270 degrees) Clayton and
<code>34</code> Rotated (270 degrees) Gumbel.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_rotations">rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in familyset
are included.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_familycrit">familycrit</code></td>
<td>
<p>Character indicating the criterion for bivariate copula
selection. Possible choices: <code>familycrit = 'AIC'</code> (default) or
<code>'BIC'</code>, as in <code>BiCopSelect</code> from the
<code><a href="VineCopula.html#topic+VineCopula-package">VineCopula</a></code> package.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_level">level</code></td>
<td>
<p>Numerical; Passed to <code><a href="#topic+gamBiCopSelect">gamBiCopSelect</a></code>, it is the
significance level of the test for removing individual
predictors (default: <code>level = 0.05</code>) for each conditional pair-copula.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_trunclevel">trunclevel</code></td>
<td>
<p>Integer; level of truncation.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_tau">tau</code></td>
<td>
<p><code>TRUE</code> (default) for a calibration function specified for
Kendall's tau or <code>FALSE</code> for a calibration function specified
for the Copula parameter.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_method">method</code></td>
<td>
<p><code>'NR'</code> for Newton-Raphson
and  <code>'FS'</code> for Fisher-scoring (default).</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_tol.rel">tol.rel</code></td>
<td>
<p>Relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_n.iters">n.iters</code></td>
<td>
<p>Maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_parallel">parallel</code></td>
<td>
<p><code>TRUE</code> (default) for parallel selection of copula
family at each edge or <code>FALSE</code> for the sequential version.
for the Copula parameter.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> if informations should be printed during the
estimation and <code>FALSE</code> (default) for a silent version.
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_select.once">select.once</code></td>
<td>
<p>if <code>TRUE</code> the GAM structure is only selected once,
for the family that appears first in <code>familyset</code>.</p>
</td></tr>
<tr><td><code id="gamVineCopSelect_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="mgcv.html#topic+gam">gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gamVineCopSelect</code> returns a <code><a href="#topic+gamVine-class">gamVine-class</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamVineSeqFit">gamVineSeqFit</a></code>,<code><a href="#topic+gamVineStructureSelect">gamVineStructureSelect</a></code>,
<code><a href="#topic+gamVine-class">gamVine-class</a></code>, <code><a href="#topic+gamVineSimulate">gamVineSimulate</a></code> and
<code><a href="#topic+gamBiCopFit">gamBiCopFit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(mgcv)
set.seed(0)

##  Simulation parameters
# Sample size
n &lt;- 1e3
# Copula families
familyset &lt;- c(1:2, 301:304, 401:404)
# Define a 4-dimensional R-vine tree structure matrix
d &lt;- 4
Matrix &lt;- c(2, 3, 4, 1, 0, 3, 4, 1, 0, 0, 4, 1, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, d, d)
nnames &lt;- paste("X", 1:d, sep = "")

## A function factory
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

##  Create the model
# Define gam-vine model list
count &lt;- 1
model &lt;- vector(mode = "list", length = d * (d - 1) / 2)
sel &lt;- seq(d, d^2 - d, by = d)

# First tree
for (i in 1:(d - 1)) {
  # Select a copula family
  family &lt;- sample(familyset, 1)
  model[[count]]$family &lt;- family

  # Use the canonical link and a randomly generated parameter
  if (is.element(family, c(1, 2))) {
    model[[count]]$par &lt;- tanh(rnorm(1) / 2)
    if (family == 2) {
      model[[count]]$par2 &lt;- 2 + exp(rnorm(1))
    }
  } else {
    if (is.element(family, c(401:404))) {
      rr &lt;- rnorm(1)
      model[[count]]$par &lt;- sign(rr) * (1 + abs(rr))
    } else {
      model[[count]]$par &lt;- rnorm(1)
    }
    model[[count]]$par2 &lt;- 0
  }
  count &lt;- count + 1
}

# A dummy dataset
data &lt;- data.frame(u1 = runif(1e2), u2 = runif(1e2), matrix(runif(1e2 * d), 1e2, d))

# Trees 2 to (d-1)
for (j in 2:(d - 1)) {
  for (i in 1:(d - j)) {
    # Select a copula family
    family &lt;- sample(familyset, 1)

    # Select the conditiong set and create a model formula
    cond &lt;- nnames[sort(Matrix[(d - j + 2):d, i])]
    tmpform &lt;- paste("~", paste(paste("s(", cond, ", k=10, bs='cr')",
      sep = ""
    ), collapse = " + "))
    l &lt;- length(cond)
    temp &lt;- sample(3, l, replace = TRUE)

    # Spline approximation of the true function
    m &lt;- 1e2
    x &lt;- matrix(seq(0, 1, length.out = m), nrow = m, ncol = 1)
    if (l != 1) {
      tmp.fct &lt;- paste("function(x){eta0+",
        paste(sapply(1:l, function(x)
          paste("calib.surf[[", temp[x], "]](x[", x, "])",
            sep = ""
          )), collapse = "+"), "}",
        sep = ""
      )
      tmp.fct &lt;- eval(parse(text = tmp.fct))
      x &lt;- eval(parse(text = paste0("expand.grid(",
        paste0(rep("x", l), collapse = ","), ")",
        collapse = ""
      )))
      y &lt;- apply(x, 1, tmp.fct)
    } else {
      tmp.fct &lt;- function(x) eta0 + calib.surf[[temp]](x)
      colnames(x) &lt;- cond
      y &lt;- tmp.fct(x)
    }

    # Estimate the gam model
    form &lt;- as.formula(paste0("y", tmpform))
    dd &lt;- data.frame(y, x)
    names(dd) &lt;- c("y", cond)
    b &lt;- gam(form, data = dd)
    # plot(x[,1],(y-fitted(b))/y)

    # Create a dummy gamBiCop object
    tmp &lt;- gamBiCopFit(data = data, formula = form, family = 1, n.iters = 1)$res

    # Update the copula family and the model coefficients
    attr(tmp, "model")$coefficients &lt;- coefficients(b)
    attr(tmp, "model")$smooth &lt;- b$smooth
    attr(tmp, "family") &lt;- family
    if (family == 2) {
      attr(tmp, "par2") &lt;- 2 + exp(rnorm(1))
    }
    model[[count]] &lt;- tmp
    count &lt;- count + 1
  }
}

# Create the gamVineCopula object
GVC &lt;- gamVine(Matrix = Matrix, model = model, names = nnames)
print(GVC)
## Not run: 
## Simulate and fit the model
sim &lt;- gamVineSimulate(n, GVC)
fitGVC &lt;- gamVineSeqFit(sim, GVC, verbose = TRUE)
fitGVC2 &lt;- gamVineCopSelect(sim, Matrix, verbose = TRUE)

## Plot the results
par(mfrow = c(3, 4))
plot(GVC, ylim = c(-2.5, 2.5))

plot(fitGVC, ylim = c(-2.5, 2.5))

plot(fitGVC2, ylim = c(-2.5, 2.5))

## End(Not run)

</code></pre>

<hr>
<h2 id='gamVineFamily'>Family Matrix of an Object of the Class gamVine</h2><span id='topic+gamVineFamily'></span>

<h3>Description</h3>

<p>Return the matrix of copula family (see
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>)
corresponding to the model list in the
<code><a href="#topic+gamVine-class">gamVine</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVineFamily(GVC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamVineFamily_+3A_gvc">GVC</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of copula families corresponding to the model list in the
<code><a href="#topic+gamVine-class">gamVine</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>

<hr>
<h2 id='gamVineNormalize'>Normalize an Object of the Class gamVine</h2><span id='topic+gamVineNormalize'></span>

<h3>Description</h3>

<p>Change the R-vine matrix in the natural order,
i.e. with d:1 on the diagonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVineNormalize(GVC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamVineNormalize_+3A_gvc">GVC</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized <code><a href="#topic+gamVine-class">gamVine</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>

<hr>
<h2 id='gamVinePDF'>Conditional density function of a gamVine</h2><span id='topic+gamVinePDF'></span>

<h3>Description</h3>

<p>This function returns the density of a conditional pair-copula constructions,
where either the copula parameters or the Kendall's taus are modeled as a function
of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVinePDF(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamVinePDF_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+gamVine-class">gamVine-class</a></code> object.</p>
</td></tr>
<tr><td><code id="gamVinePDF_+3A_data">data</code></td>
<td>
<p>(Same as in <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> from the
<code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package) A matrix or data frame
containing the values of the model covariates at which predictions are
required, along with a number of additional columns corresponding to the
variables in the pair copula decomposition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The conditional density.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamVine">gamVine</a></code>, <code><a href="#topic+gamVineCopSelect">gamVineCopSelect</a></code>,
<code><a href="#topic+gamVineStructureSelect">gamVineStructureSelect</a></code>, <code><a href="#topic+gamVine-class">gamVine-class</a></code>,
<code><a href="#topic+gamVineSimulate">gamVineSimulate</a></code> and <code><a href="#topic+gamBiCopFit">gamBiCopFit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(mgcv)
set.seed(0)

##  Simulation parameters
# Sample size
n &lt;- 1e3
# Copula families
familyset &lt;- c(1:2, 301:304, 401:404)
# Define a 4-dimensional R-vine tree structure matrix
d &lt;- 4
Matrix &lt;- c(2, 3, 4, 1, 0, 3, 4, 1, 0, 0, 4, 1, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, d, d)
nnames &lt;- paste("X", 1:d, sep = "")

## A function factory
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

##  Create the model
# Define gam-vine model list
count &lt;- 1
model &lt;- vector(mode = "list", length = d * (d - 1) / 2)
sel &lt;- seq(d, d^2 - d, by = d)

# First tree
for (i in 1:(d - 1)) {
  # Select a copula family
  family &lt;- sample(familyset, 1)
  model[[count]]$family &lt;- family

  # Use the canonical link and a randomly generated parameter
  if (is.element(family, c(1, 2))) {
    model[[count]]$par &lt;- tanh(rnorm(1) / 2)
    if (family == 2) {
      model[[count]]$par2 &lt;- 2 + exp(rnorm(1))
    }
  } else {
    if (is.element(family, c(401:404))) {
      rr &lt;- rnorm(1)
      model[[count]]$par &lt;- sign(rr) * (1 + abs(rr))
    } else {
      model[[count]]$par &lt;- rnorm(1)
    }
    model[[count]]$par2 &lt;- 0
  }
  count &lt;- count + 1
}

# A dummy dataset
data &lt;- data.frame(u1 = runif(1e2), u2 = runif(1e2), matrix(runif(1e2 * d), 1e2, d))

# Trees 2 to (d-1)
for (j in 2:(d - 1)) {
  for (i in 1:(d - j)) {
    # Select a copula family
    family &lt;- sample(familyset, 1)

    # Select the conditiong set and create a model formula
    cond &lt;- nnames[sort(Matrix[(d - j + 2):d, i])]
    tmpform &lt;- paste("~", paste(paste("s(", cond, ", k=10, bs='cr')",
      sep = ""
    ), collapse = " + "))
    l &lt;- length(cond)
    temp &lt;- sample(3, l, replace = TRUE)

    # Spline approximation of the true function
    m &lt;- 1e2
    x &lt;- matrix(seq(0, 1, length.out = m), nrow = m, ncol = 1)
    if (l != 1) {
      tmp.fct &lt;- paste("function(x){eta0+",
        paste(sapply(1:l, function(x)
          paste("calib.surf[[", temp[x], "]](x[", x, "])",
            sep = ""
          )), collapse = "+"), "}",
        sep = ""
      )
      tmp.fct &lt;- eval(parse(text = tmp.fct))
      x &lt;- eval(parse(text = paste0("expand.grid(",
        paste0(rep("x", l), collapse = ","), ")",
        collapse = ""
      )))
      y &lt;- apply(x, 1, tmp.fct)
    } else {
      tmp.fct &lt;- function(x) eta0 + calib.surf[[temp]](x)
      colnames(x) &lt;- cond
      y &lt;- tmp.fct(x)
    }

    # Estimate the gam model
    form &lt;- as.formula(paste0("y", tmpform))
    dd &lt;- data.frame(y, x)
    names(dd) &lt;- c("y", cond)
    b &lt;- gam(form, data = dd)
    # plot(x[,1],(y-fitted(b))/y)

    # Create a dummy gamBiCop object
    tmp &lt;- gamBiCopFit(data = data, formula = form, family = 1, n.iters = 1)$res

    # Update the copula family and the model coefficients
    attr(tmp, "model")$coefficients &lt;- coefficients(b)
    attr(tmp, "model")$smooth &lt;- b$smooth
    attr(tmp, "family") &lt;- family
    if (family == 2) {
      attr(tmp, "par2") &lt;- 2 + exp(rnorm(1))
    }
    model[[count]] &lt;- tmp
    count &lt;- count + 1
  }
}

# Create the gamVineCopula object
GVC &lt;- gamVine(Matrix = Matrix, model = model, names = nnames)
print(GVC)
## Not run: 
## Simulate and fit the model
sim &lt;- gamVineSimulate(n, GVC)
fitGVC &lt;- gamVineSeqFit(sim, GVC, verbose = TRUE)
fitGVC2 &lt;- gamVineCopSelect(sim, Matrix, verbose = TRUE)
(gamVinePDF(GVC, sim[1:10, ]))

## Plot the results
dev.off()
par(mfrow = c(3, 4))
plot(GVC, ylim = c(-2.5, 2.5))

plot(fitGVC, ylim = c(-2.5, 2.5))

plot(fitGVC2, ylim = c(-2.5, 2.5))

## End(Not run)

</code></pre>

<hr>
<h2 id='gamVineSeqFit'>Sequential maximum penalized likelihood estimation of a GAM-Vine model.</h2><span id='topic+gamVineSeqFit'></span>

<h3>Description</h3>

<p>This function estimates the parameter(s) of a Generalized Additive model
(GAM) Vine model, where GAMs for individual edges are specified either for
the copula parameter or Kendall's tau.
It solves the maximum penalized likelihood estimation for the copula families
supported in this package by reformulating each Newton-Raphson iteration as
a generalized ridge regression, which is solved using
the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVineSeqFit(
  data,
  GVC,
  covariates = NA,
  method = "FS",
  tol.rel = 0.001,
  n.iters = 10,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamVineSeqFit_+3A_data">data</code></td>
<td>
<p>A matrix or data frame containing the data in [0,1]^d.</p>
</td></tr>
<tr><td><code id="gamVineSeqFit_+3A_gvc">GVC</code></td>
<td>
<p>A <code><a href="#topic+gamVine-class">gamVine</a></code> object.</p>
</td></tr>
<tr><td><code id="gamVineSeqFit_+3A_covariates">covariates</code></td>
<td>
<p>Vector of names for the covariates.</p>
</td></tr>
<tr><td><code id="gamVineSeqFit_+3A_method">method</code></td>
<td>
<p><code>'NR'</code> for Newton-Raphson
and  <code>'FS'</code> for Fisher-scoring (default).</p>
</td></tr>
<tr><td><code id="gamVineSeqFit_+3A_tol.rel">tol.rel</code></td>
<td>
<p>Relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamVineSeqFit_+3A_n.iters">n.iters</code></td>
<td>
<p>Maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamVineSeqFit_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> if informations should be printed during the
estimation and <code>FALSE</code> (default) for a silent version.</p>
</td></tr>
<tr><td><code id="gamVineSeqFit_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="mgcv.html#topic+gam">gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gamVineSeqFit</code> returns a
<code><a href="#topic+gamVine-class">gamVine</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamVineCopSelect">gamVineCopSelect</a></code> and
<code><a href="#topic+gamVineStructureSelect">gamVineStructureSelect</a></code>
</p>
<p><code><a href="#topic+gamVineCopSelect">gamVineCopSelect</a></code>,<code><a href="#topic+gamVineStructureSelect">gamVineStructureSelect</a></code>,
<code><a href="#topic+gamVine-class">gamVine-class</a></code>, <code><a href="#topic+gamVineSimulate">gamVineSimulate</a></code> and
<code><a href="#topic+gamBiCopFit">gamBiCopFit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(mgcv)
set.seed(0)

##  Simulation parameters
# Sample size
n &lt;- 1e3
# Copula families
familyset &lt;- c(1:2, 301:304, 401:404)
# Define a 4-dimensional R-vine tree structure matrix
d &lt;- 4
Matrix &lt;- c(2, 3, 4, 1, 0, 3, 4, 1, 0, 0, 4, 1, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, d, d)
nnames &lt;- paste("X", 1:d, sep = "")

## A function factory
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

##  Create the model
# Define gam-vine model list
count &lt;- 1
model &lt;- vector(mode = "list", length = d * (d - 1) / 2)
sel &lt;- seq(d, d^2 - d, by = d)

# First tree
for (i in 1:(d - 1)) {
  # Select a copula family
  family &lt;- sample(familyset, 1)
  model[[count]]$family &lt;- family

  # Use the canonical link and a randomly generated parameter
  if (is.element(family, c(1, 2))) {
    model[[count]]$par &lt;- tanh(rnorm(1) / 2)
    if (family == 2) {
      model[[count]]$par2 &lt;- 2 + exp(rnorm(1))
    }
  } else {
    if (is.element(family, c(401:404))) {
      rr &lt;- rnorm(1)
      model[[count]]$par &lt;- sign(rr) * (1 + abs(rr))
    } else {
      model[[count]]$par &lt;- rnorm(1)
    }
    model[[count]]$par2 &lt;- 0
  }
  count &lt;- count + 1
}

# A dummy dataset
data &lt;- data.frame(u1 = runif(1e2), u2 = runif(1e2), matrix(runif(1e2 * d), 1e2, d))

# Trees 2 to (d-1)
for (j in 2:(d - 1)) {
  for (i in 1:(d - j)) {
    # Select a copula family
    family &lt;- sample(familyset, 1)

    # Select the conditiong set and create a model formula
    cond &lt;- nnames[sort(Matrix[(d - j + 2):d, i])]
    tmpform &lt;- paste("~", paste(paste("s(", cond, ", k=10, bs='cr')",
      sep = ""
    ), collapse = " + "))
    l &lt;- length(cond)
    temp &lt;- sample(3, l, replace = TRUE)

    # Spline approximation of the true function
    m &lt;- 1e2
    x &lt;- matrix(seq(0, 1, length.out = m), nrow = m, ncol = 1)
    if (l != 1) {
      tmp.fct &lt;- paste("function(x){eta0+",
        paste(sapply(1:l, function(x)
          paste("calib.surf[[", temp[x], "]](x[", x, "])",
            sep = ""
          )), collapse = "+"), "}",
        sep = ""
      )
      tmp.fct &lt;- eval(parse(text = tmp.fct))
      x &lt;- eval(parse(text = paste0("expand.grid(",
        paste0(rep("x", l), collapse = ","), ")",
        collapse = ""
      )))
      y &lt;- apply(x, 1, tmp.fct)
    } else {
      tmp.fct &lt;- function(x) eta0 + calib.surf[[temp]](x)
      colnames(x) &lt;- cond
      y &lt;- tmp.fct(x)
    }

    # Estimate the gam model
    form &lt;- as.formula(paste0("y", tmpform))
    dd &lt;- data.frame(y, x)
    names(dd) &lt;- c("y", cond)
    b &lt;- gam(form, data = dd)
    # plot(x[,1],(y-fitted(b))/y)

    # Create a dummy gamBiCop object
    tmp &lt;- gamBiCopFit(data = data, formula = form, family = 1, n.iters = 1)$res

    # Update the copula family and the model coefficients
    attr(tmp, "model")$coefficients &lt;- coefficients(b)
    attr(tmp, "model")$smooth &lt;- b$smooth
    attr(tmp, "family") &lt;- family
    if (family == 2) {
      attr(tmp, "par2") &lt;- 2 + exp(rnorm(1))
    }
    model[[count]] &lt;- tmp
    count &lt;- count + 1
  }
}

# Create the gamVineCopula object
GVC &lt;- gamVine(Matrix = Matrix, model = model, names = nnames)
print(GVC)
## Not run: 
## Simulate and fit the model
sim &lt;- gamVineSimulate(n, GVC)
fitGVC &lt;- gamVineSeqFit(sim, GVC, verbose = TRUE)
fitGVC2 &lt;- gamVineCopSelect(sim, Matrix, verbose = TRUE)
(gamVinePDF(GVC, sim[1:10, ]))

## Plot the results
dev.off()
par(mfrow = c(3, 4))
plot(GVC, ylim = c(-2.5, 2.5))

plot(fitGVC, ylim = c(-2.5, 2.5))

plot(fitGVC2, ylim = c(-2.5, 2.5))

## End(Not run)

</code></pre>

<hr>
<h2 id='gamVineSimulate'>Simulation from a <code><a href="#topic+gamVine-class">gamVine-class</a></code> object</h2><span id='topic+gamVineSimulate'></span>

<h3>Description</h3>

<p>Simulation from a <code><a href="#topic+gamVine-class">gamVine-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVineSimulate(n, GVC, U = NULL, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamVineSimulate_+3A_n">n</code></td>
<td>
<p>number of d-dimensional observations to simulate.</p>
</td></tr>
<tr><td><code id="gamVineSimulate_+3A_gvc">GVC</code></td>
<td>
<p>A <code><a href="#topic+gamVine-class">gamVine</a></code> object.</p>
</td></tr>
<tr><td><code id="gamVineSimulate_+3A_u">U</code></td>
<td>
<p>If not <code>NULL</code>, <code>U</code> is an (N,d)-matrix of U[0,1] random
variates to be transformed to the copula sample.</p>
</td></tr>
<tr><td><code id="gamVineSimulate_+3A_newdata">newdata</code></td>
<td>
<p>If not <code>NULL</code>, which is mandatory when
the attribute <code>covariates</code> from <code>GVC</code> is not <code>NA</code>,
<code>newdata</code> is a data frame containing the values of
the model covariates at which simulations are required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of data simulated from the given
<code><a href="#topic+gamVine-class">gamVine</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(VineCopula)

## Example adapted from RVineSim

## Define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(
  5, 2, 3, 1, 4,
  0, 2, 3, 4, 1,
  0, 0, 3, 4, 1,
  0, 0, 0, 4, 1,
  0, 0, 0, 0, 1
)
Matrix &lt;- matrix(Matrix, 5, 5)

## Define R-vine pair-copula family matrix
family &lt;- c(
  0, 1, 3, 4, 4,
  0, 0, 3, 4, 1,
  0, 0, 0, 4, 1,
  0, 0, 0, 0, 3,
  0, 0, 0, 0, 0
)
family &lt;- matrix(family, 5, 5)

## Define R-vine pair-copula parameter matrix
par &lt;- c(
  0, 0.2, 0.9, 1.5, 3.9,
  0, 0, 1.1, 1.6, 0.9,
  0, 0, 0, 1.9, 0.5,
  0, 0, 0, 0, 4.8,
  0, 0, 0, 0, 0
)
par &lt;- matrix(par, 5, 5)

## Define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

## Define RVineMatrix object
RVM &lt;- RVineMatrix(
  Matrix = Matrix, family = family,
  par = par, par2 = par2,
  names = c("V1", "V2", "V3", "V4", "V5")
)

## Convert to gamVine object
GVC &lt;- RVM2GVC(RVM)

## U[0,1] random variates to be transformed to the copula sample
n &lt;- 1e2
d &lt;- 5
U &lt;- matrix(runif(n * d), nrow = n)

## The output of gamVineSimulate correspond to that of RVineSim
sampleRVM &lt;- RVineSim(n, RVM, U)
sampleGVC &lt;- gamVineSimulate(n, GVC, U)
all.equal(sampleRVM, sampleGVC)

## Fit the two models and compare the estimated parameter
fitRVM &lt;- RVM2GVC(RVineSeqEst(sampleRVM, RVM))
fitGVC &lt;- gamVineSeqFit(sampleGVC, GVC)
all.equal(
  simplify2array(attr(fitRVM, "model")),
  simplify2array(attr(fitGVC, "model"))
)
</code></pre>

<hr>
<h2 id='gamVineStructureSelect'>Structure selection and estimation of a GAM-Vine model.</h2><span id='topic+gamVineStructureSelect'></span>

<h3>Description</h3>

<p>This function select the structure and estimates the parameter(s) of a
Generalized Additive model
(GAM) Vine model, where GAMs for individual edges are specified either for
the copula parameter or Kendall's tau.
It solves the maximum penalized likelihood estimation for the copula families
supported in this package by reformulating each Newton-Raphson iteration as
a generalized ridge regression, which is solved using
the <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVineStructureSelect(
  udata,
  lin.covs = NULL,
  smooth.covs = NULL,
  simplified = TRUE,
  type = 0,
  familyset = NA,
  rotations = TRUE,
  familycrit = "AIC",
  treecrit = "tau",
  level = 0.05,
  trunclevel = NA,
  tau = TRUE,
  method = "FS",
  tol.rel = 0.001,
  n.iters = 10,
  parallel = FALSE,
  verbose = FALSE,
  select.once = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamVineStructureSelect_+3A_udata">udata</code></td>
<td>
<p>A matrix or data frame containing the data in [0,1]^d.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_lin.covs">lin.covs</code></td>
<td>
<p>A matrix or data frame containing the parametric (i.e.,
linear) covariates (default: <code>lin.covs = NULL</code>).</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_smooth.covs">smooth.covs</code></td>
<td>
<p>A matrix or data frame containing the non-parametric
(i.e., smooth) covariates (default: <code>smooth.covs = NULL</code>).</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_simplified">simplified</code></td>
<td>
<p>If <code>TRUE</code> (default), then a simplified vine is fitted
(which is possible only if there are exogenous covariates). If <code>FALSE</code>,
then a non-simplified vine is fitted.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_type">type</code></td>
<td>
<p><code>type = 0</code> (default) for a R-Vine and <code>type = 1</code> for a
C-Vine.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_familyset">familyset</code></td>
<td>
<p>An integer vector of pair-copula families to select from
(the independence copula MUST NOT be specified in this vector unless one
wants to fit an independence vine!).
Not listed copula families might be included to better handle
limit cases. If <code>familyset = NA</code> (default), selection among all
possible families is performed. Coding of pair-copula families:
<code>1</code> Gaussian,
<code>2</code> Student t,
<code>5</code> Frank,
<code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>404</code> Double Gumbel type IV (survival and rotated 270 degrees).</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_rotations">rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in familyset
are included.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_familycrit">familycrit</code></td>
<td>
<p>Character indicating the criterion for bivariate copula
selection. Possible choices: <code>familycrit = 'AIC'</code> (default) or
<code>'BIC'</code>, as in <code>BiCopSelect</code> from the
<code><a href="VineCopula.html#topic+VineCopula-package">VineCopula</a></code> package.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_treecrit">treecrit</code></td>
<td>
<p>Character indicating how pairs are selected in each tree.
<code>treecrit = "tau"</code> uses the maximum spanning tree of the Kendall's tau
(i.e., the tree of maximal overall dependence), <code>treecrit = "rho"</code>
uses the Spearman's rho.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_level">level</code></td>
<td>
<p>Numerical; Passed to <code><a href="#topic+gamBiCopSelect">gamBiCopSelect</a></code>, it is the
significance level of the test for removing individual
predictors (default: <code>level = 0.05</code>) for each conditional pair-copula.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_trunclevel">trunclevel</code></td>
<td>
<p>Integer; level of truncation.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_tau">tau</code></td>
<td>
<p><code>TRUE</code> (default) for a calibration function specified for
Kendall's tau or <code>FALSE</code> for a calibration function specified
for the Copula parameter.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_method">method</code></td>
<td>
<p><code>'NR'</code> for Newton-Raphson
and  <code>'FS'</code> for Fisher-scoring (default).</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_tol.rel">tol.rel</code></td>
<td>
<p>Relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_n.iters">n.iters</code></td>
<td>
<p>Maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_parallel">parallel</code></td>
<td>
<p><code>TRUE</code> (default) for parallel selection of copula
family at each edge or <code>FALSE</code> for the sequential version.
for the Copula parameter.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> if informations should be printed during the
estimation and <code>FALSE</code> (default) for a silent version.
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>.</p>
</td></tr>
<tr><td><code id="gamVineStructureSelect_+3A_select.once">select.once</code></td>
<td>
<p>if <code>TRUE</code> the GAM structure is only selected once,
for the family that appears first in <code>familyset</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gamVineSeqFit</code> returns a <code><a href="#topic+gamVine-class">gamVine-class</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamVineSeqFit">gamVineSeqFit</a></code>,<code><a href="#topic+gamVineCopSelect">gamVineCopSelect</a></code>,
<code><a href="#topic+gamVine-class">gamVine-class</a></code>, <code><a href="#topic+gamVineSimulate">gamVineSimulate</a></code> and
<code><a href="#topic+gamBiCopSelect">gamBiCopSelect</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(VineCopula)
set.seed(0)


## An example with a 3-dimensional GAM-Vine

# Sample size
n &lt;- 1e3

# Define a R-vine tree structure matrix
d &lt;- 3
Matrix &lt;- c(2, 3, 1, 0, 3, 1, 0, 0, 1)
Matrix &lt;- matrix(Matrix, d, d)
nnames &lt;- paste("x", 1:d, sep = "")

# Copula families for each edge
fam &lt;- c(301, 401, 1)

# Parameters for the first tree (two unconditional copulas)
par &lt;- c(1, 2)

# Pre-allocate the GAM-Vine model list
count &lt;- 1
model &lt;- vector(mode = "list", length = d * (d - 1) / 2)

# The first tree contains only the two unconditional copulas
for (i in 1:(d - 1)) {
  model[[count]] &lt;- list(family = fam[count], par = par[count], par2 = 0)
  count &lt;- count + 1
}

# The second tree contains a unique conditional copula
# In this first example, we take a linear calibration function (10*x-5)

# Set-up a dummy dataset
tmp &lt;- data.frame(u1 = runif(1e2), u2 = runif(1e2), x1 = runif(1e2))

# Set-up an arbitrary linear model for the calibration function
model[[count]] &lt;- gamBiCopFit(tmp, ~x1, fam[count])$res

# Update the coefficients of the model
attr(model[[count]], "model")$coefficients &lt;- c(-5, 10)

# Define gamVine object
GVC &lt;- gamVine(Matrix = Matrix, model = model, names = nnames)
GVC
## Not run: 
# Simulate new data
simData &lt;- data.frame(gamVineSimulate(n, GVC))
colnames(simData) &lt;- nnames

# Fit data using sequential estimation assuming true model known
summary(fitGVC &lt;- gamVineSeqFit(simData, GVC))

# Fit data using structure selection and sequential estimation
summary(fitGVC2 &lt;- gamVineStructureSelect(simData, simplified = FALSE))

## End(Not run)

</code></pre>

<hr>
<h2 id='logLik.gamBiCop'>Extract the Log-likelihood from a gamBiCop Object</h2><span id='topic+logLik.gamBiCop'></span><span id='topic+logLik+2CgamBiCop-method'></span>

<h3>Description</h3>

<p>Function to extract the log-likelihood from an object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code> (note that the models are
usually fitted by penalized likelihood maximization).
This function is used by <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamBiCop'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.gamBiCop_+3A_object">object</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.gamBiCop_+3A_...">...</code></td>
<td>
<p>un-used in this class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard <code>logLik</code> object: see <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>.
</p>

<hr>
<h2 id='nobs.gamBiCop'>Extract the Number of Observations from gamBiCop Object</h2><span id='topic+nobs.gamBiCop'></span><span id='topic+nobs+2CgamBiCop-method'></span>

<h3>Description</h3>

<p>Extract the number of 'observations' from a model fit.
This is principally intended to be used in computing the BIC
(see <code><a href="stats.html#topic+AIC">AIC</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamBiCop'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.gamBiCop_+3A_object">object</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
<tr><td><code id="nobs.gamBiCop_+3A_...">...</code></td>
<td>
<p>un-used in this class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number, normally an integer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>.
</p>

<hr>
<h2 id='plot.gamBiCop'>Plot a gamBiCop Object</h2><span id='topic+plot.gamBiCop'></span><span id='topic+plot+2CgamBiCop+2CANY-method'></span>

<h3>Description</h3>

<p>Plot from an object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.
The function is based on (see <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamBiCop,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gamBiCop_+3A_x">x</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gamBiCop_+3A_y">y</code></td>
<td>
<p>Not used with this class.</p>
</td></tr>
<tr><td><code id="plot.gamBiCop_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function simply generates plots.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code> from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>).
</p>

<hr>
<h2 id='plot.gamVine'>Plot an Object of the Class gamVine</h2><span id='topic+plot.gamVine'></span><span id='topic+plot+2CgamVine+2CANY-method'></span>

<h3>Description</h3>

<p>Plot an object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.
The function is based on (see <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamVine,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gamVine_+3A_x">x</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gamVine_+3A_y">y</code></td>
<td>
<p>Not used with this class.</p>
</td></tr>
<tr><td><code id="plot.gamVine_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function simply generates plots.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code> from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>).
</p>

<hr>
<h2 id='RVM2GVC'>Transform an Object of the Class R-Vine into an Object of the Class gamVine</h2><span id='topic+RVM2GVC'></span>

<h3>Description</h3>

<p>Transform an object of the class <code>RVineMatrix</code>
into an object of the class <code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVM2GVC(RVM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVM2GVC_+3A_rvm">RVM</code></td>
<td>
<p>An object of the class <code>RVineMatrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>


<h3>See Also</h3>

<p><code>RVineMatrix</code> and
<code><a href="#topic+gamVine-class">gamVine</a></code>.
</p>

<hr>
<h2 id='summary.gamBiCop'>Summary for a gamBiCop Object</h2><span id='topic+summary.gamBiCop'></span><span id='topic+summary+2CgamBiCop-method'></span>

<h3>Description</h3>

<p>Takes a <code><a href="#topic+gamBiCop-class">gamBiCop</a></code> object and produces
various useful summaries from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamBiCop'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gamBiCop_+3A_object">object</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamBiCop-class">gamBiCop</a></code>.</p>
</td></tr>
<tr><td><code id="summary.gamBiCop_+3A_...">...</code></td>
<td>
<p>unused in this class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A useful summary (see <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> for more details).
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>
</p>

<hr>
<h2 id='summary.gamVine'>Summary for an Object of the Class gamVine</h2><span id='topic+summary.gamVine'></span><span id='topic+summary+2CgamVine-method'></span>

<h3>Description</h3>

<p>Takes an object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code> and produces various
useful summaries from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gamVine'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gamVine_+3A_object">object</code></td>
<td>
<p>An object of the class
<code><a href="#topic+gamVine-class">gamVine</a></code>.</p>
</td></tr>
<tr><td><code id="summary.gamVine_+3A_...">...</code></td>
<td>
<p>unused in this class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A useful summary (see <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code> for more details).
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code>
from <code><a href="mgcv.html#topic+mgcv-package">mgcv</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
