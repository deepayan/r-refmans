<!DOCTYPE html><html lang="en-US"><head><title>Help for package aglm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aglm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aglm-package'><p>aglm: Accurate Generalized Linear Model</p></a></li>
<li><a href='#AccurateGLM-class'><p>Class for results of <code>aglm()</code> and <code>cv.aglm()</code></p></a></li>
<li><a href='#aglm'><p>Fit an AGLM model with no cross-validation</p></a></li>
<li><a href='#AGLM_Input-class'><p>S4 class for input</p></a></li>
<li><a href='#coef.AccurateGLM'><p>Get coefficients</p></a></li>
<li><a href='#createEqualFreqBins'><p>Create bins (equal frequency binning)</p></a></li>
<li><a href='#createEqualWidthBins'><p>Create bins (equal width binning)</p></a></li>
<li><a href='#cv.aglm'><p>Fit an AGLM model with cross-validation for <code class="reqn">\lambda</code></p></a></li>
<li><a href='#CVA_AccurateGLM-class'><p>Class for results of <code>cva.aglm()</code></p></a></li>
<li><a href='#cva.aglm'><p>Fit an AGLM model with cross-validation for both <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code></p></a></li>
<li><a href='#deviance.AccurateGLM'><p>Get deviance</p></a></li>
<li><a href='#executeBinning'><p>Binning the data to given bins.</p></a></li>
<li><a href='#getLVarMatForOneVec'><p>Create L-variable matrix for one variable</p></a></li>
<li><a href='#getODummyMatForOneVec'><p>Create a O-dummy matrix for one variable</p></a></li>
<li><a href='#getUDummyMatForOneVec'><p>Create a U-dummy matrix for one variable</p></a></li>
<li><a href='#plot.AccurateGLM'><p>Plot contribution of each variable and residuals</p></a></li>
<li><a href='#predict.AccurateGLM'><p>Make predictions for new data</p></a></li>
<li><a href='#print.AccurateGLM'><p>Display textual information of the model</p></a></li>
<li><a href='#residuals.AccurateGLM'><p>Get residuals of various types</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Accurate Generalized Linear Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to fit Accurate Generalized Linear Model (AGLM) models, visualize them, and predict for new data. AGLM is defined as a regularized GLM which applies a sort of feature transformations using a discretization of numerical features and specific coding methodologies of dummy variables. For more information on AGLM, see Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa (2020) <a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;amp;fg=1">https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kkondo1981/aglm">https://github.com/kkondo1981/aglm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kkondo1981/aglm/issues">https://github.com/kkondo1981/aglm/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet (&ge; 4.0.2), assertthat, methods, mathjaxr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, MASS, faraway</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-09 02:14:52 UTC; kkond</td>
</tr>
<tr>
<td>Author:</td>
<td>Kenji Kondo [aut, cre, cph],
  Kazuhisa Takahashi [ctb],
  Hikari Banno [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kenji Kondo &lt;kkondo.odnokk@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-09 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aglm-package'>aglm: Accurate Generalized Linear Model</h2><span id='topic+aglm-package'></span>

<h3>Description</h3>

<p>Provides functions to fit Accurate Generalized Linear Model (AGLM) models,
visualize them, and predict for new data. AGLM is defined as a regularized GLM
which applies a sort of feature transformations using a discretization of numerical
features and specific coding methodologies of dummy variables.
For more information on AGLM, see
<a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa (2020)</a>.
</p>


<h3>Details</h3>

<p>The collection of functions provided by the <code>aglm</code> package has almost the same structure as the famous <code>glmnet</code> package,
so users familiar with the <code>glmnet</code> package will be able to handle it easily.
In fact, this structure is reasonable in implementation, because what the <code>aglm</code> package does is
applying appropriate transformations to the given data and passing it to the <code>glmnet</code> package as a backend.
</p>


<h3>Fitting functions</h3>

<p>The <code>aglm</code> package provides three different fitting functions, depending on how users want to handle hyper-parameters of AGLM models.
</p>
<p>Because AGLM is based on regularized GLM, the regularization term of the loss function can be expressed as follows:
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[
R(\lbrace \beta_{jk} \rbrace; \lambda, \alpha)
= \lambda \left\lbrace
(1 - \alpha)\sum_{j=1}^{p} \sum_{k=1}^{m_j}|\beta_{jk}|^2 + \alpha \sum_{j=1}^{p} \sum_{k=1}^{m_j} |\beta_{jk}|
\right\rbrace,
\]
where <code class="reqn">\beta_jk</code> is the k-th coefficient of auxiliary variables for the j-th column in data,
<code class="reqn">\alpha</code> is a weight which controls how L1 and L2 regularization terms are mixed,
and <code class="reqn">\lambda</code> determines the strength of the regularization.
</p>
<p>Searching hyper-parameters <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code> is often useful to get better results, but usually time-consuming.
That's why the <code>aglm</code> package provides three fitting functions with different strategies for specifying hyper-parameters as follows:
</p>

<ul>
<li> <p><a href="#topic+aglm">aglm</a>: A basic fitting function with given <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code> (s).
</p>
</li>
<li> <p><a href="#topic+cv.aglm">cv.aglm</a>: A fitting function with given <code class="reqn">\alpha</code> and cross-validation for <code class="reqn">\lambda</code>.
</p>
</li>
<li> <p><a href="#topic+cva.aglm">cva.aglm</a>: A fitting function with cross-validation for both <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>.
</p>
</li></ul>

<p>Generally speaking, setting an appropriate <code class="reqn">\lambda</code> is often important to get meaningful results,
and using <code>cv.aglm()</code> with default <code class="reqn">\alpha=1</code> (LASSO) is usually enough.
Since <code>cva.aglm()</code> is much time-consuming than <code>cv.aglm()</code>, it is better to use it only if particularly better results are needed.
</p>
<p>The following S4 classes are defined to store results of the fitting functions.
</p>

<ul>
<li> <p><a href="#topic+AccurateGLM-class">AccurateGLM-class</a>: A class for results of <code>aglm()</code> and <code>cv.aglm()</code>
</p>
</li>
<li> <p><a href="#topic+CVA_AccurateGLM-class">CVA_AccurateGLM-class</a>: A class for results of <code>cva.aglm()</code>
</p>
</li></ul>



<h3>Using the fitted model</h3>

<p>Users can use models obtained from fitting functions in various ways, by passing them to following functions:
</p>

<ul>
<li> <p><a href="#topic+predict.AccurateGLM">predict</a>: Make predictions for new data
</p>
</li>
<li> <p><a href="#topic+plot.AccurateGLM">plot</a>: Plot contribution of each variable and residuals
</p>
</li>
<li> <p><a href="#topic+print.AccurateGLM">print</a>: Display textual information of the model
</p>
</li>
<li> <p><a href="#topic+coef.AccurateGLM">coef</a>: Get coefficients
</p>
</li>
<li> <p><a href="#topic+deviance.AccurateGLM">deviance</a>: Get deviance
</p>
</li>
<li> <p><a href="#topic+residuals.AccurateGLM">residuals</a>: Get residuals of various types
</p>
</li></ul>

<p>We emphasize that <code>plot()</code> is particularly useful to understand the fitted model,
because it presents a visual representation of how variables in the original data are used by the model.
</p>


<h3>Other functions</h3>

<p>The following functions are basically for internal use, but exported as utility functions for convenience.
</p>

<ul>
<li><p> Functions for creating feature vectors
</p>

<ul>
<li> <p><a href="#topic+getUDummyMatForOneVec">getUDummyMatForOneVec</a>
</p>
</li>
<li> <p><a href="#topic+getODummyMatForOneVec">getODummyMatForOneVec</a>
</p>
</li>
<li> <p><a href="#topic+getLVarMatForOneVec">getLVarMatForOneVec</a>
</p>
</li></ul>

</li>
<li><p> Functions for binning
</p>

<ul>
<li> <p><a href="#topic+createEqualWidthBins">createEqualWidthBins</a>
</p>
</li>
<li> <p><a href="#topic+createEqualFreqBins">createEqualFreqBins</a>
</p>
</li>
<li> <p><a href="#topic+executeBinning">executeBinning</a>
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>


<ul>
<li><p> Kenji Kondo,
</p>
</li>
<li><p> Kazuhisa Takahashi and Hikari Banno (worked on L-Variable related features)
</p>
</li></ul>



<h3>References</h3>

<p>Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa. (2020)
<em>AGLM: A Hybrid Modeling Method of GLM and Data Science Techniques</em>, <br />
<a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1</a> <br />
<em>Actuarial Colloquium Paris 2020</em>
</p>

<hr>
<h2 id='AccurateGLM-class'>Class for results of <code>aglm()</code> and <code>cv.aglm()</code></h2><span id='topic+AccurateGLM-class'></span>

<h3>Description</h3>

<p>Class for results of <code>aglm()</code> and <code>cv.aglm()</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>backend_models</code></dt><dd><p>The fitted backend <code>glmnet</code> model is stored.</p>
</dd>
<dt><code>vars_info</code></dt><dd><p>A list, each of whose element is information of one variable.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>cvm</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>cvsd</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>cvup</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>cvlo</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>nzero</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>name</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>lambda.min</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>lambda.1se</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>fit.preval</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>foldid</code></dt><dd><p>Same as in the result of cv.glmnet.</p>
</dd>
<dt><code>call</code></dt><dd><p>An object of class <code>call</code>, corresponding to the function call when this <code>AccurateGLM</code> object is created.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='aglm'>Fit an AGLM model with no cross-validation</h2><span id='topic+aglm'></span>

<h3>Description</h3>

<p>A basic fitting function with given <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code> (s).
See <a href="#topic+aglm-package">aglm-package</a> for more details on <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aglm(
  x,
  y,
  qualitative_vars_UD_only = NULL,
  qualitative_vars_both = NULL,
  qualitative_vars_OD_only = NULL,
  quantitative_vars = NULL,
  use_LVar = FALSE,
  extrapolation = "default",
  add_linear_columns = TRUE,
  add_OD_columns_of_qualitatives = TRUE,
  add_interaction_columns = FALSE,
  OD_type_of_quantitatives = "C",
  nbin.max = NULL,
  bins_list = NULL,
  bins_names = NULL,
  family = c("gaussian", "binomial", "poisson"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aglm_+3A_x">x</code></td>
<td>
<p>A design matrix.
Usually a <code>data.frame</code> object is expected, but a <code>matrix</code> object is fine if all columns are of a same class.
Each column may have one of the following classes, and <code>aglm</code> will automatically determine how to handle it:
</p>

<ul>
<li> <p><code>numeric</code>: interpreted as a quantitative variable. <code>aglm</code> performs discretization by binning, and creates dummy variables suitable for ordered values (named O-dummies/L-variables).
</p>
</li>
<li> <p><code>factor</code> (unordered) or <code>logical</code> : interpreted as a qualitative variable without order. <code>aglm</code> creates dummy variables suitable for unordered values (named U-dummies).
</p>
</li>
<li> <p><code>ordered</code>: interpreted as a qualitative variable with order. <code>aglm</code> creates both O-dummies and U-dummies.
</p>
</li></ul>

<p>These dummy variables are added to <code>x</code> and form a larger matrix, which is used internally as an actual design matrix.
See <a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">our paper</a> for more details on O-dummies, U-dummies, and L-variables.
</p>
<p>If you need to change the default behavior, use the following options: <code>qualitative_vars_UD_only</code>, <code>qualitative_vars_both</code>, <code>qualitative_vars_OD_only</code>, and <code>quantitative_vars</code>.</p>
</td></tr>
<tr><td><code id="aglm_+3A_y">y</code></td>
<td>
<p>A response variable.</p>
</td></tr>
<tr><td><code id="aglm_+3A_qualitative_vars_ud_only">qualitative_vars_UD_only</code></td>
<td>
<p>Used to change the default behavior of <code>aglm</code> for given variables.
Variables specified by this parameter are considered as qualitative variables and only U-dummies are created as auxiliary columns.
This parameter may have one of the following classes:
</p>

<ul>
<li> <p><code>integer</code>: specifying variables by index.
</p>
</li>
<li> <p><code>character</code>: specifying variables by name.
</p>
</li></ul>
</td></tr>
<tr><td><code id="aglm_+3A_qualitative_vars_both">qualitative_vars_both</code></td>
<td>
<p>Same as <code>qualitative_vars_UD_only</code>, except that both O-dummies and U-dummies are created for specified variables.</p>
</td></tr>
<tr><td><code id="aglm_+3A_qualitative_vars_od_only">qualitative_vars_OD_only</code></td>
<td>
<p>Same as <code>qualitative_vars_UD_only</code>, except that both only O-dummies are created for specified variables.</p>
</td></tr>
<tr><td><code id="aglm_+3A_quantitative_vars">quantitative_vars</code></td>
<td>
<p>Same as <code>qualitative_vars_UD_only</code>, except that specified variables are considered as quantitative variables.</p>
</td></tr>
<tr><td><code id="aglm_+3A_use_lvar">use_LVar</code></td>
<td>
<p>Set to use L-variables.
By default, <code>aglm</code> uses O-dummies as the representation of a quantitative variable.
If <code>use_LVar=TRUE</code>, L-variables are used instead.</p>
</td></tr>
<tr><td><code id="aglm_+3A_extrapolation">extrapolation</code></td>
<td>
<p>Used to control values of linear combination for quantitative variables, outside where the data exists.
By default, values of a linear combination outside the data is extended based on the slope of the edges of the region where the data exists.
You can set <code>extrapolation="flat"</code> to get constant values outside the data instead.</p>
</td></tr>
<tr><td><code id="aglm_+3A_add_linear_columns">add_linear_columns</code></td>
<td>
<p>By default, for quantitative variables, <code>aglm</code> expands them by adding dummies and the original columns, i.e. the linear effects, are remained in the resulting model.
You can set <code>add_linear_columns=FALSE</code> to drop linear effects.</p>
</td></tr>
<tr><td><code id="aglm_+3A_add_od_columns_of_qualitatives">add_OD_columns_of_qualitatives</code></td>
<td>
<p>Set to <code>FALSE</code> if you do not want to use O-dummies for qualitative variables with order (usually, columns with <code>ordered</code> class).</p>
</td></tr>
<tr><td><code id="aglm_+3A_add_interaction_columns">add_interaction_columns</code></td>
<td>
<p>If this parameter is set to <code>TRUE</code>, <code>aglm</code> creates an additional auxiliary variable <code>x_i * x_j</code> for each pair <code style="white-space: pre;">&#8288;(x_i, x_j)&#8288;</code> of variables.</p>
</td></tr>
<tr><td><code id="aglm_+3A_od_type_of_quantitatives">OD_type_of_quantitatives</code></td>
<td>
<p>Used to control the shape of linear combinations obtained by O-dummies for quantitative variables (deprecated).</p>
</td></tr>
<tr><td><code id="aglm_+3A_nbin.max">nbin.max</code></td>
<td>
<p>An integer representing the maximum number of bins when <code>aglm</code> perform binning for quantitative variables.</p>
</td></tr>
<tr><td><code id="aglm_+3A_bins_list">bins_list</code></td>
<td>
<p>Used to set custom bins for variables with O-dummies.</p>
</td></tr>
<tr><td><code id="aglm_+3A_bins_names">bins_names</code></td>
<td>
<p>Used to set custom bins for variables with O-dummies.</p>
</td></tr>
<tr><td><code id="aglm_+3A_family">family</code></td>
<td>
<p>A <code>family</code> object or a string representing the type of the error distribution.
Currently <code>aglm</code> supports <code>gaussian</code>, <code>binomial</code>, and <code>poisson</code>.</p>
</td></tr>
<tr><td><code id="aglm_+3A_...">...</code></td>
<td>
<p>Other arguments are passed directly when calling <code>glmnet()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model object fitted to the data.
Functions such as <code>predict</code> and <code>plot</code> can be applied to the returned object.
See <a href="#topic+AccurateGLM-class">AccurateGLM-class</a> for more details.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Kenji Kondo,
</p>
</li>
<li><p> Kazuhisa Takahashi and Hikari Banno (worked on L-Variable related features)
</p>
</li></ul>



<h3>References</h3>

<p>Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa. (2020)
<em>AGLM: A Hybrid Modeling Method of GLM and Data Science Techniques</em>, <br />
<a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1</a> <br />
<em>Actuarial Colloquium Paris 2020</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################### Gaussian case ####################

library(MASS) # For Boston
library(aglm)

## Read data
xy &lt;- Boston # xy is a data.frame to be processed.
colnames(xy)[ncol(xy)] &lt;- "y" # Let medv be the objective variable, y.

## Split data into train and test
n &lt;- nrow(xy) # Sample size.
set.seed(2018) # For reproducibility.
test.id &lt;- sample(n, round(n/4)) # ID numbders for test data.
test &lt;- xy[test.id,] # test is the data.frame for testing.
train &lt;- xy[-test.id,] # train is the data.frame for training.
x &lt;- train[-ncol(xy)]
y &lt;- train$y
newx &lt;- test[-ncol(xy)]
y_true &lt;- test$y

## Fit the model
model &lt;- aglm(x, y)  # alpha=1 (the default value)

## Predict for various alpha and lambda
lambda &lt;- 0.1
y_pred &lt;- predict(model, newx=newx, s=lambda)
rmse &lt;- sqrt(mean((y_true - y_pred)^2))
cat(sprintf("RMSE for lambda=%.2f: %.5f \n\n", lambda, rmse))

lambda &lt;- 1.0
y_pred &lt;- predict(model, newx=newx, s=lambda)
rmse &lt;- sqrt(mean((y_true - y_pred)^2))
cat(sprintf("RMSE for lambda=%.2f: %.5f \n\n", lambda, rmse))

alpha &lt;- 0
model &lt;- aglm(x, y, alpha=alpha)

lambda &lt;- 0.1
y_pred &lt;- predict(model, newx=newx, s=lambda)
rmse &lt;- sqrt(mean((y_true - y_pred)^2))
cat(sprintf("RMSE for alpha=%.2f and lambda=%.2f: %.5f \n\n", alpha, lambda, rmse))

#################### Binomial case ####################

library(aglm)
library(faraway)

## Read data
xy &lt;- nes96

## Split data into train and test
n &lt;- nrow(xy) # Sample size.
set.seed(2018) # For reproducibility.
test.id &lt;- sample(n, round(n/5)) # ID numbders for test data.
test &lt;- xy[test.id,] # test is the data.frame for testing.
train &lt;- xy[-test.id,] # train is the data.frame for training.
x &lt;- train[, c("popul", "TVnews", "selfLR", "ClinLR", "DoleLR", "PID", "age", "educ", "income")]
y &lt;- train$vote
newx &lt;- test[, c("popul", "TVnews", "selfLR", "ClinLR", "DoleLR", "PID", "age", "educ", "income")]

## Fit the model
model &lt;- aglm(x, y, family="binomial")

## Make the confusion matrix
lambda &lt;- 0.1
y_true &lt;- test$vote
y_pred &lt;- levels(y_true)[as.integer(predict(model, newx, s=lambda, type="class"))]

print(table(y_true, y_pred))

#################### use_LVar and extrapolation ####################

library(MASS) # For Boston
library(aglm)

## Randomly created train and test data
set.seed(2021)
sd &lt;- 0.2
x &lt;- 2 * runif(1000) + 1
f &lt;- function(x){x^3 - 6 * x^2 + 13 * x}
y &lt;- f(x) + rnorm(1000, sd = sd)
xy &lt;- data.frame(x=x, y=y)
x_test &lt;- seq(0.75, 3.25, length.out=101)
y_test &lt;- f(x_test) + rnorm(101, sd=sd)
xy_test &lt;- data.frame(x=x_test, y=y_test)

## Plot
nbin.max &lt;- 10
models &lt;- c(cv.aglm(x, y, use_LVar=FALSE, extrapolation="default", nbin.max=nbin.max),
            cv.aglm(x, y, use_LVar=FALSE, extrapolation="flat", nbin.max=nbin.max),
            cv.aglm(x, y, use_LVar=TRUE, extrapolation="default", nbin.max=nbin.max),
            cv.aglm(x, y, use_LVar=TRUE, extrapolation="flat", nbin.max=nbin.max))

titles &lt;- c("O-Dummies with extrapolation=\"default\"",
            "O-Dummies with extrapolation=\"flat\"",
            "L-Variables with extrapolation=\"default\"",
            "L-Variables with extrapolation=\"flat\"")

par.old &lt;- par(mfrow=c(2, 2))
for (i in 1:4) {
  model &lt;- models[[i]]
  title &lt;- titles[[i]]

  pred &lt;- predict(model, newx=x_test, s=model@lambda.min, type="response")

  plot(x_test, y_test, pch=20, col="grey", main=title)
  lines(x_test, f(x_test), lty="dashed", lwd=2)  # the theoretical line
  lines(x_test, pred, col="blue", lwd=3)  # the smoothed line by the model
}
par(par.old)
</code></pre>

<hr>
<h2 id='AGLM_Input-class'>S4 class for input</h2><span id='topic+AGLM_Input-class'></span>

<h3>Description</h3>

<p>S4 class for input
</p>


<h3>Slots</h3>


<dl>
<dt><code>vars_info</code></dt><dd><p>A list, each of whose element is information of one variable.</p>
</dd>
<dt><code>data</code></dt><dd><p>The original data.</p>
</dd>
</dl>

<hr>
<h2 id='coef.AccurateGLM'>Get coefficients</h2><span id='topic+coef.AccurateGLM'></span>

<h3>Description</h3>

<p>Get coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AccurateGLM'
coef(object, index = NULL, name = NULL, s = NULL, exact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.AccurateGLM_+3A_object">object</code></td>
<td>
<p>A model object obtained from <code>aglm()</code> or <code>cv.aglm()</code>.</p>
</td></tr>
<tr><td><code id="coef.AccurateGLM_+3A_index">index</code></td>
<td>
<p>An integer value representing the index of variable whose coefficients are required.</p>
</td></tr>
<tr><td><code id="coef.AccurateGLM_+3A_name">name</code></td>
<td>
<p>A string representing the name of variable whose coefficients are required.
Note that if both <code>index</code> and <code>name</code> are set, <code>index</code> is discarded.</p>
</td></tr>
<tr><td><code id="coef.AccurateGLM_+3A_s">s</code></td>
<td>
<p>Same as in coef.glmnet.</p>
</td></tr>
<tr><td><code id="coef.AccurateGLM_+3A_exact">exact</code></td>
<td>
<p>Same as in coef.glmnet.</p>
</td></tr>
<tr><td><code id="coef.AccurateGLM_+3A_...">...</code></td>
<td>
<p>Other arguments are passed directly to <code>coef.glmnet()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>index</code> or <code>name</code> is given, the function returns a list with the one or combination
of the following fields, consisting of coefficients related to the specified variable.
</p>

<ul>
<li> <p><code>coef.linear</code>: A coefficient of the linear term. (If any)
</p>
</li>
<li> <p><code>coef.OD</code>: Coefficients of O-dummies. (If any)
</p>
</li>
<li> <p><code>coef.UD</code>: Coefficients of U-dummies. (If any)
</p>
</li>
<li> <p><code>coef.LV</code>: Coefficients of L-variables. (If any)
</p>
</li></ul>

<p>If both <code>index</code> and <code>name</code> are not given, the function returns entire coefficients
corresponding to the internal designed matrix.
</p>


<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='createEqualFreqBins'>Create bins (equal frequency binning)</h2><span id='topic+createEqualFreqBins'></span>

<h3>Description</h3>

<p>Create bins (equal frequency binning)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEqualFreqBins(x_vec, nbin.max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createEqualFreqBins_+3A_x_vec">x_vec</code></td>
<td>
<p>A numeric vector, whose quantiles are used as breaks.</p>
</td></tr>
<tr><td><code id="createEqualFreqBins_+3A_nbin.max">nbin.max</code></td>
<td>
<p>The maximum number of bins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing breaks obtained by binning.
Note that the number of bins is equal to <code>min(nbin.max, length(x_vec))</code>.
</p>


<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='createEqualWidthBins'>Create bins (equal width binning)</h2><span id='topic+createEqualWidthBins'></span>

<h3>Description</h3>

<p>Create bins (equal width binning)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEqualWidthBins(left, right, nbin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createEqualWidthBins_+3A_left">left</code></td>
<td>
<p>The leftmost value of the interval to be binned.</p>
</td></tr>
<tr><td><code id="createEqualWidthBins_+3A_right">right</code></td>
<td>
<p>The rightmost value of the interval to be binned.</p>
</td></tr>
<tr><td><code id="createEqualWidthBins_+3A_nbin">nbin</code></td>
<td>
<p>The number of bins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing breaks obtained by binning.
</p>


<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='cv.aglm'>Fit an AGLM model with cross-validation for <code class="reqn">\lambda</code></h2><span id='topic+cv.aglm'></span>

<h3>Description</h3>

<p>A fitting function with given <code class="reqn">\alpha</code> and cross-validation for <code class="reqn">\lambda</code>.
See <a href="#topic+aglm-package">aglm-package</a> for more details on <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.aglm(
  x,
  y,
  qualitative_vars_UD_only = NULL,
  qualitative_vars_both = NULL,
  qualitative_vars_OD_only = NULL,
  quantitative_vars = NULL,
  use_LVar = FALSE,
  extrapolation = "default",
  add_linear_columns = TRUE,
  add_OD_columns_of_qualitatives = TRUE,
  add_interaction_columns = FALSE,
  OD_type_of_quantitatives = "C",
  nbin.max = NULL,
  bins_list = NULL,
  bins_names = NULL,
  family = c("gaussian", "binomial", "poisson"),
  keep = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.aglm_+3A_x">x</code></td>
<td>
<p>A design matrix.
See <a href="#topic+aglm">aglm</a> for more details.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_y">y</code></td>
<td>
<p>A response variable.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_qualitative_vars_ud_only">qualitative_vars_UD_only</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_qualitative_vars_both">qualitative_vars_both</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_qualitative_vars_od_only">qualitative_vars_OD_only</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_quantitative_vars">quantitative_vars</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_use_lvar">use_LVar</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_extrapolation">extrapolation</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_add_linear_columns">add_linear_columns</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_add_od_columns_of_qualitatives">add_OD_columns_of_qualitatives</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_add_interaction_columns">add_interaction_columns</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_od_type_of_quantitatives">OD_type_of_quantitatives</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_nbin.max">nbin.max</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_bins_list">bins_list</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_bins_names">bins_names</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_family">family</code></td>
<td>
<p>Same as in <a href="#topic+aglm">aglm</a>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_keep">keep</code></td>
<td>
<p>Set to <code>TRUE</code> if you need the <code>fit.preval</code> field in the returned value, as in <code>cv.glmnet()</code>.</p>
</td></tr>
<tr><td><code id="cv.aglm_+3A_...">...</code></td>
<td>
<p>Other arguments are passed directly when calling <code>cv.glmnet()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model object fitted to the data with cross-validation results.
Functions such as <code>predict</code> and <code>plot</code> can be applied to the returned object, same as the result of <code>aglm()</code>.
See <a href="#topic+AccurateGLM-class">AccurateGLM-class</a> for more details.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Kenji Kondo,
</p>
</li>
<li><p> Kazuhisa Takahashi and Hikari Banno (worked on L-Variable related features)
</p>
</li></ul>



<h3>References</h3>

<p>Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa. (2020)
<em>AGLM: A Hybrid Modeling Method of GLM and Data Science Techniques</em>, <br />
<a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1</a> <br />
<em>Actuarial Colloquium Paris 2020</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################### Cross-validation for lambda ####################

library(aglm)
library(faraway)

## Read data
xy &lt;- nes96

## Split data into train and test
n &lt;- nrow(xy) # Sample size.
set.seed(2018) # For reproducibility.
test.id &lt;- sample(n, round(n/5)) # ID numbders for test data.
test &lt;- xy[test.id,] # test is the data.frame for testing.
train &lt;- xy[-test.id,] # train is the data.frame for training.
x &lt;- train[, c("popul", "TVnews", "selfLR", "ClinLR", "DoleLR", "PID", "age", "educ", "income")]
y &lt;- train$vote
newx &lt;- test[, c("popul", "TVnews", "selfLR", "ClinLR", "DoleLR", "PID", "age", "educ", "income")]

# NOTE: Codes bellow will take considerable time, so run it when you have time.


## Fit the model
model &lt;- cv.aglm(x, y, family="binomial")

## Make the confusion matrix
lambda &lt;- model@lambda.min
y_true &lt;- test$vote
y_pred &lt;- levels(y_true)[as.integer(predict(model, newx, s=lambda, type="class"))]

cat(sprintf("Confusion matrix for lambda=%.5f:\n", lambda))
print(table(y_true, y_pred))


</code></pre>

<hr>
<h2 id='CVA_AccurateGLM-class'>Class for results of <code>cva.aglm()</code></h2><span id='topic+CVA_AccurateGLM-class'></span>

<h3>Description</h3>

<p>Class for results of <code>cva.aglm()</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>models_list</code></dt><dd><p>A list consists of <code>cv.glmnet()</code>'s results for all <code class="reqn">\alpha</code> values.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Same as in <a href="#topic+cv.aglm">cv.aglm</a>.</p>
</dd>
<dt><code>nfolds</code></dt><dd><p>Same as in <a href="#topic+cv.aglm">cv.aglm</a>.</p>
</dd>
<dt><code>alpha.min.index</code></dt><dd><p>The index of <code>alpha.min</code> in the vector <code>alpha</code>.</p>
</dd>
<dt><code>alpha.min</code></dt><dd><p>The <code class="reqn">\alpha</code> value achieving the minimum loss among all the values of <code>alpha</code>.</p>
</dd>
<dt><code>lambda.min</code></dt><dd><p>The <code class="reqn">\lambda</code> value achieving the minimum loss when <code class="reqn">\alpha</code> is equal to <code>alpha.min</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>An object of class <code>call</code>, corresponding to the function call when this <code>CVA_AccurateGLM</code> object is created.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='cva.aglm'>Fit an AGLM model with cross-validation for both <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code></h2><span id='topic+cva.aglm'></span>

<h3>Description</h3>

<p>A fitting function with cross-validation for both <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>.
See <a href="#topic+aglm-package">aglm-package</a> for more details on <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cva.aglm(
  x,
  y,
  alpha = seq(0, 1, len = 11)^3,
  nfolds = 10,
  foldid = NULL,
  parallel.alpha = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cva.aglm_+3A_x">x</code></td>
<td>
<p>A design matrix.
See <a href="#topic+aglm">aglm</a> for more details.</p>
</td></tr>
<tr><td><code id="cva.aglm_+3A_y">y</code></td>
<td>
<p>A response variable.</p>
</td></tr>
<tr><td><code id="cva.aglm_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector representing <code class="reqn">\alpha</code> values to be examined in cross-validation.</p>
</td></tr>
<tr><td><code id="cva.aglm_+3A_nfolds">nfolds</code></td>
<td>
<p>An integer value representing the number of folds.</p>
</td></tr>
<tr><td><code id="cva.aglm_+3A_foldid">foldid</code></td>
<td>
<p>An integer vector with the same length as observations.
Each element should take a value from 1 to <code>nfolds</code>, identifying which fold it belongs.</p>
</td></tr>
<tr><td><code id="cva.aglm_+3A_parallel.alpha">parallel.alpha</code></td>
<td>
<p>(not used yet)</p>
</td></tr>
<tr><td><code id="cva.aglm_+3A_...">...</code></td>
<td>
<p>Other arguments are passed directly to <code>cv.aglm()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object storing fitted models and information of cross-validation.
See <a href="#topic+CVA_AccurateGLM-class">CVA_AccurateGLM-class</a> for more details.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Kenji Kondo,
</p>
</li>
<li><p> Kazuhisa Takahashi and Hikari Banno (worked on L-Variable related features)
</p>
</li></ul>



<h3>References</h3>

<p>Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa. (2020)
<em>AGLM: A Hybrid Modeling Method of GLM and Data Science Techniques</em>, <br />
<a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1</a> <br />
<em>Actuarial Colloquium Paris 2020</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################### Cross-validation for alpha and lambda ####################

library(aglm)
library(faraway)

## Read data
xy &lt;- nes96

## Split data into train and test
n &lt;- nrow(xy) # Sample size.
set.seed(2018) # For reproducibility.
test.id &lt;- sample(n, round(n/5)) # ID numbders for test data.
test &lt;- xy[test.id,] # test is the data.frame for testing.
train &lt;- xy[-test.id,] # train is the data.frame for training.
x &lt;- train[, c("popul", "TVnews", "selfLR", "ClinLR", "DoleLR", "PID", "age", "educ", "income")]
y &lt;- train$vote
newx &lt;- test[, c("popul", "TVnews", "selfLR", "ClinLR", "DoleLR", "PID", "age", "educ", "income")]

# NOTE: Codes bellow will take considerable time, so run it when you have time.


## Fit the model
cva_result &lt;- cva.aglm(x, y, family="binomial")

alpha &lt;- cva_result@alpha.min
lambda &lt;- cva_result@lambda.min

mod_idx &lt;- cva_result@alpha.min.index
model &lt;- cva_result@models_list[[mod_idx]]

## Make the confusion matrix
y_true &lt;- test$vote
y_pred &lt;- levels(y_true)[as.integer(predict(model, newx, s=lambda, type="class"))]

cat(sprintf("Confusion matrix for alpha=%.5f and lambda=%.5f:\n", alpha, lambda))
print(table(y_true, y_pred))


</code></pre>

<hr>
<h2 id='deviance.AccurateGLM'>Get deviance</h2><span id='topic+deviance.AccurateGLM'></span>

<h3>Description</h3>

<p>Get deviance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AccurateGLM'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance.AccurateGLM_+3A_object">object</code></td>
<td>
<p>A model object obtained from <code>aglm()</code> or <code>cv.aglm()</code>.</p>
</td></tr>
<tr><td><code id="deviance.AccurateGLM_+3A_...">...</code></td>
<td>
<p>Other arguments are passed directly to <code>deviance.glmnet()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of deviance extracted from the object <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='executeBinning'>Binning the data to given bins.</h2><span id='topic+executeBinning'></span>

<h3>Description</h3>

<p>Binning the data to given bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>executeBinning(x_vec, breaks = NULL, nbin.max = 100, method = "freq")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="executeBinning_+3A_x_vec">x_vec</code></td>
<td>
<p>The data to be binned.</p>
</td></tr>
<tr><td><code id="executeBinning_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector representing breaks of bins (If <code>NULL</code>, automatically generated).</p>
</td></tr>
<tr><td><code id="executeBinning_+3A_nbin.max">nbin.max</code></td>
<td>
<p>The maximum number of bins (used only if <code>breaks=NULL</code>).</p>
</td></tr>
<tr><td><code id="executeBinning_+3A_method">method</code></td>
<td>
<p><code>"freq"</code> for equal frequency binning or <code>"width"</code> for equal width binning (used only if <code>breaks=NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>labels</code>: An integer vector with same length as <code>x_vec</code>, where <code>labels[i]==k</code> means the i-th element of <code>x_vec</code> is in the k-th bin.
</p>
</li>
<li> <p><code>breaks</code>: Breaks of bins used for binning.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='getLVarMatForOneVec'>Create L-variable matrix for one variable</h2><span id='topic+getLVarMatForOneVec'></span>

<h3>Description</h3>

<p>Create L-variable matrix for one variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLVarMatForOneVec(x_vec, breaks = NULL, nbin.max = 100, only_info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLVarMatForOneVec_+3A_x_vec">x_vec</code></td>
<td>
<p>A numeric vector representing original variable.</p>
</td></tr>
<tr><td><code id="getLVarMatForOneVec_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector representing breaks of bins (If <code>NULL</code>, automatically generated).</p>
</td></tr>
<tr><td><code id="getLVarMatForOneVec_+3A_nbin.max">nbin.max</code></td>
<td>
<p>The maximum number of bins (used only if <code>breaks=NULL</code>).</p>
</td></tr>
<tr><td><code id="getLVarMatForOneVec_+3A_only_info">only_info</code></td>
<td>
<p>If <code>TRUE</code>, only information fields of returned values are filled and no dummy matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>breaks</code>: Same as input
</p>
</li>
<li> <p><code>dummy_mat</code>: The created L-variable matrix (only if <code>only_info=FALSE</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='getODummyMatForOneVec'>Create a O-dummy matrix for one variable</h2><span id='topic+getODummyMatForOneVec'></span>

<h3>Description</h3>

<p>Create a O-dummy matrix for one variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getODummyMatForOneVec(
  x_vec,
  breaks = NULL,
  nbin.max = 100,
  only_info = FALSE,
  dummy_type = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getODummyMatForOneVec_+3A_x_vec">x_vec</code></td>
<td>
<p>A numeric vector representing original variable.</p>
</td></tr>
<tr><td><code id="getODummyMatForOneVec_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector representing breaks of bins (If <code>NULL</code>, automatically generated).</p>
</td></tr>
<tr><td><code id="getODummyMatForOneVec_+3A_nbin.max">nbin.max</code></td>
<td>
<p>The maximum number of bins (used only if <code>breaks=NULL</code>).</p>
</td></tr>
<tr><td><code id="getODummyMatForOneVec_+3A_only_info">only_info</code></td>
<td>
<p>If <code>TRUE</code>, only information fields of returned values are filled and no dummy matrix is returned.</p>
</td></tr>
<tr><td><code id="getODummyMatForOneVec_+3A_dummy_type">dummy_type</code></td>
<td>
<p>Used to control the shape of linear combinations obtained by O-dummies for quantitative variables (deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>breaks</code>: Same as input
</p>
</li>
<li> <p><code>dummy_mat</code>: The created O-dummy matrix (only if <code>only_info=FALSE</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='getUDummyMatForOneVec'>Create a U-dummy matrix for one variable</h2><span id='topic+getUDummyMatForOneVec'></span>

<h3>Description</h3>

<p>Create a U-dummy matrix for one variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUDummyMatForOneVec(
  x_vec,
  levels = NULL,
  drop_last = TRUE,
  only_info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getUDummyMatForOneVec_+3A_x_vec">x_vec</code></td>
<td>
<p>A vector representing original variable.
The class of <code>x_vec</code> should be one of <code>integer</code>, <code>character</code>, or <code>factor</code>.</p>
</td></tr>
<tr><td><code id="getUDummyMatForOneVec_+3A_levels">levels</code></td>
<td>
<p>A character vector representing values of <code>x_vec</code> used to create U-dummies.
If <code>NULL</code>, all the unique values of <code>x_vec</code> are used to create dummies.</p>
</td></tr>
<tr><td><code id="getUDummyMatForOneVec_+3A_drop_last">drop_last</code></td>
<td>
<p>If <code>TRUE</code>, the last column of the resulting matrix is dropped to avoid multicollinearity.</p>
</td></tr>
<tr><td><code id="getUDummyMatForOneVec_+3A_only_info">only_info</code></td>
<td>
<p>If <code>TRUE</code>, only information fields of returned values are filled and no dummy matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>levels</code>: Same as input.
</p>
</li>
<li> <p><code>drop_last</code>: Same as input.
</p>
</li>
<li> <p><code>dummy_mat</code>: The created U-dummy matrix (only if <code>only_info=FALSE</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='plot.AccurateGLM'>Plot contribution of each variable and residuals</h2><span id='topic+plot.AccurateGLM'></span>

<h3>Description</h3>

<p>Plot contribution of each variable and residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AccurateGLM'
plot(
  x,
  vars = NULL,
  verbose = TRUE,
  s = NULL,
  resid = FALSE,
  smooth_resid = TRUE,
  smooth_resid_fun = NULL,
  ask = TRUE,
  layout = c(2, 2),
  only_plot = FALSE,
  main = "",
  add_rug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.AccurateGLM_+3A_x">x</code></td>
<td>
<p>A model object obtained from <code>aglm()</code> or <code>cv.aglm()</code>.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_vars">vars</code></td>
<td>
<p>Used to specify variables to be plotted (<code>NULL</code> means all the variables).
This parameter may have one of the following classes:
</p>

<ul>
<li> <p><code>integer</code>: specifying variables by index.
</p>
</li>
<li> <p><code>character</code>: specifying variables by name.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>FALSE</code> if textual outputs are not needed.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_s">s</code></td>
<td>
<p>A numeric value specifying <code class="reqn">\lambda</code> at which plotting is required.
Note that plotting for multiple <code class="reqn">\lambda</code>'s are not allowed and <code>s</code> always should be a single value.
When the model is trained with only a single <code class="reqn">\lambda</code> value, just set it to <code>NULL</code> to plot for that value.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_resid">resid</code></td>
<td>
<p>Used to display residuals in plots.
This parameter may have one of the following classes:
</p>

<ul>
<li> <p><code>logical</code>(single value): If <code>TRUE</code>, working residuals are plotted.
</p>
</li>
<li> <p><code>character</code>(single value): type of residual to be plotted. See <a href="#topic+residuals.AccurateGLM">residuals.AccurateGLM</a> for more details on types of residuals.
</p>
</li>
<li> <p><code>numerical</code>(vector): residual values to be plotted.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_smooth_resid">smooth_resid</code></td>
<td>
<p>Used to display smoothing lines of residuals for quantitative variables.
This parameter may have one of the following classes:
</p>

<ul>
<li> <p><code>logical</code>: If <code>TRUE</code>, smoothing lines are drawn.
</p>
</li>
<li> <p><code>character</code>:
</p>

<ul>
<li> <p><code>smooth_resid="both"</code>: Balls and smoothing lines are drawn.
</p>
</li>
<li> <p><code>smooth_resid="smooth_only"</code>: Only smoothing lines are drawn.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_smooth_resid_fun">smooth_resid_fun</code></td>
<td>
<p>Set if users need custom smoothing functions.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_ask">ask</code></td>
<td>
<p>By default, <code>plot()</code> stops and waits inputs each time plotting for each variable is completed.
Users can set <code>ask=FALSE</code> to avoid this.
It is useful, for example, when using devices as <code>bmp</code> to create image files.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_layout">layout</code></td>
<td>
<p>Plotting multiple variables for each page is allowed.
To achieve this, set it to a pair of integer, which indicating number of rows and columns, respectively.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_only_plot">only_plot</code></td>
<td>
<p>Set to <code>TRUE</code> if no automatic graphical configurations are needed.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_main">main</code></td>
<td>
<p>Used to specify the title of plotting.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_add_rug">add_rug</code></td>
<td>
<p>Set to <code>TRUE</code> for rug plots.</p>
</td></tr>
<tr><td><code id="plot.AccurateGLM_+3A_...">...</code></td>
<td>
<p>Other arguments are currently not used and just discarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Kenji Kondo,
</p>
</li>
<li><p> Kazuhisa Takahashi and Hikari Banno (worked on L-Variable related features)
</p>
</li></ul>



<h3>References</h3>

<p>Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa. (2020)
<em>AGLM: A Hybrid Modeling Method of GLM and Data Science Techniques</em>, <br />
<a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1</a> <br />
<em>Actuarial Colloquium Paris 2020</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################### using plot() and predict() ####################

library(MASS) # For Boston
library(aglm)

## Read data
xy &lt;- Boston # xy is a data.frame to be processed.
colnames(xy)[ncol(xy)] &lt;- "y" # Let medv be the objective variable, y.

## Split data into train and test
n &lt;- nrow(xy) # Sample size.
set.seed(2018) # For reproducibility.
test.id &lt;- sample(n, round(n/4)) # ID numbders for test data.
test &lt;- xy[test.id,] # test is the data.frame for testing.
train &lt;- xy[-test.id,] # train is the data.frame for training.
x &lt;- train[-ncol(xy)]
y &lt;- train$y
newx &lt;- test[-ncol(xy)]
y_true &lt;- test$y

## With the result of aglm()
model &lt;- aglm(x, y)
lambda &lt;- 0.1

plot(model, s=lambda, resid=TRUE, add_rug=TRUE,
     verbose=FALSE, layout=c(3, 3))

y_pred &lt;- predict(model, newx=newx, s=lambda)
plot(y_true, y_pred)

## With the result of cv.aglm()
model &lt;- cv.aglm(x, y)
lambda &lt;- model@lambda.min

plot(model, s=lambda, resid=TRUE, add_rug=TRUE,
     verbose=FALSE, layout=c(3, 3))

y_pred &lt;- predict(model, newx=newx, s=lambda)
plot(y_true, y_pred)


</code></pre>

<hr>
<h2 id='predict.AccurateGLM'>Make predictions for new data</h2><span id='topic+predict.AccurateGLM'></span>

<h3>Description</h3>

<p>Make predictions for new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AccurateGLM'
predict(
  object,
  newx = NULL,
  s = NULL,
  type = c("link", "response", "coefficients", "nonzero", "class"),
  exact = FALSE,
  newoffset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.AccurateGLM_+3A_object">object</code></td>
<td>
<p>A model object obtained from <code>aglm()</code> or <code>cv.aglm()</code>.</p>
</td></tr>
<tr><td><code id="predict.AccurateGLM_+3A_newx">newx</code></td>
<td>
<p>A design matrix for new data.
See the description of <code>x</code> in <a href="#topic+aglm">aglm</a> for more details.</p>
</td></tr>
<tr><td><code id="predict.AccurateGLM_+3A_s">s</code></td>
<td>
<p>Same as in predict.glmnet.</p>
</td></tr>
<tr><td><code id="predict.AccurateGLM_+3A_type">type</code></td>
<td>
<p>Same as in predict.glmnet.</p>
</td></tr>
<tr><td><code id="predict.AccurateGLM_+3A_exact">exact</code></td>
<td>
<p>Same as in predict.glmnet.</p>
</td></tr>
<tr><td><code id="predict.AccurateGLM_+3A_newoffset">newoffset</code></td>
<td>
<p>Same as in predict.glmnet.</p>
</td></tr>
<tr><td><code id="predict.AccurateGLM_+3A_...">...</code></td>
<td>
<p>Other arguments are passed directly when calling <code>predict.glmnet()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object depends on <code>type</code>.
See predict.glmnet for more details.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Kenji Kondo,
</p>
</li>
<li><p> Kazuhisa Takahashi and Hikari Banno (worked on L-Variable related features)
</p>
</li></ul>



<h3>References</h3>

<p>Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa. (2020)
<em>AGLM: A Hybrid Modeling Method of GLM and Data Science Techniques</em>, <br />
<a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1</a> <br />
<em>Actuarial Colloquium Paris 2020</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################### using plot() and predict() ####################

library(MASS) # For Boston
library(aglm)

## Read data
xy &lt;- Boston # xy is a data.frame to be processed.
colnames(xy)[ncol(xy)] &lt;- "y" # Let medv be the objective variable, y.

## Split data into train and test
n &lt;- nrow(xy) # Sample size.
set.seed(2018) # For reproducibility.
test.id &lt;- sample(n, round(n/4)) # ID numbders for test data.
test &lt;- xy[test.id,] # test is the data.frame for testing.
train &lt;- xy[-test.id,] # train is the data.frame for training.
x &lt;- train[-ncol(xy)]
y &lt;- train$y
newx &lt;- test[-ncol(xy)]
y_true &lt;- test$y

## With the result of aglm()
model &lt;- aglm(x, y)
lambda &lt;- 0.1

plot(model, s=lambda, resid=TRUE, add_rug=TRUE,
     verbose=FALSE, layout=c(3, 3))

y_pred &lt;- predict(model, newx=newx, s=lambda)
plot(y_true, y_pred)

## With the result of cv.aglm()
model &lt;- cv.aglm(x, y)
lambda &lt;- model@lambda.min

plot(model, s=lambda, resid=TRUE, add_rug=TRUE,
     verbose=FALSE, layout=c(3, 3))

y_pred &lt;- predict(model, newx=newx, s=lambda)
plot(y_true, y_pred)


</code></pre>

<hr>
<h2 id='print.AccurateGLM'>Display textual information of the model</h2><span id='topic+print.AccurateGLM'></span>

<h3>Description</h3>

<p>Display textual information of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AccurateGLM'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.AccurateGLM_+3A_x">x</code></td>
<td>
<p>A model object obtained from <code>aglm()</code> or <code>cv.aglm()</code>.</p>
</td></tr>
<tr><td><code id="print.AccurateGLM_+3A_digits">digits</code></td>
<td>
<p>Used to control significant digits in printout.</p>
</td></tr>
<tr><td><code id="print.AccurateGLM_+3A_...">...</code></td>
<td>
<p>Other arguments are passed directly to <code>print.glmnet()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

<hr>
<h2 id='residuals.AccurateGLM'>Get residuals of various types</h2><span id='topic+residuals.AccurateGLM'></span>

<h3>Description</h3>

<p>Get residuals of various types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AccurateGLM'
residuals(
  object,
  x = NULL,
  y = NULL,
  offset = NULL,
  weights = NULL,
  type = c("working", "pearson", "deviance"),
  s = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.AccurateGLM_+3A_object">object</code></td>
<td>
<p>A model object obtained from <code>aglm()</code> or <code>cv.aglm()</code>.</p>
</td></tr>
<tr><td><code id="residuals.AccurateGLM_+3A_x">x</code></td>
<td>
<p>A design matrix.
If not given, <code>x</code> for fitting is used.</p>
</td></tr>
<tr><td><code id="residuals.AccurateGLM_+3A_y">y</code></td>
<td>
<p>A response variable.
If not given, <code>y</code> for fitting is used.</p>
</td></tr>
<tr><td><code id="residuals.AccurateGLM_+3A_offset">offset</code></td>
<td>
<p>An offset values.
If not given, <code>offset</code> for fitting is used.</p>
</td></tr>
<tr><td><code id="residuals.AccurateGLM_+3A_weights">weights</code></td>
<td>
<p>Sample weights.
If not given, <code>weights</code> for fitting is used.</p>
</td></tr>
<tr><td><code id="residuals.AccurateGLM_+3A_type">type</code></td>
<td>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>A string representing type of deviance:
</p>

<ul>
<li> <p><code>"working"</code> get working residual
\[r^W_i = (y_i - \mu_i) \left(\frac{\partial \eta}{\partial \mu}\right)_{\mu=\mu_i},\]
where <code class="reqn">y_i</code> is a response value, <code class="reqn">\mu</code> is GLM mean, and <code class="reqn">\eta=g^{-1}(\mu)</code> with the link function <code class="reqn">g</code>.
</p>
</li>
<li> <p><code>"pearson"</code> get Pearson residuals
\[r^P_i = \frac{y_i - \mu_i}{\sqrt{V(\mu_i)}},\]
where <code class="reqn">V</code> is the variance function.
</p>
</li>
<li> <p><code>"deviance"</code> get deviance residuals
\[r^D_i = {\rm sign}(y_i - \mu_i) \sqrt{d_i},\]
where <code class="reqn">d_i</code> is the contribution to deviance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="residuals.AccurateGLM_+3A_s">s</code></td>
<td>
<p>A numeric value specifying <code class="reqn">\lambda</code> at which residuals are calculated.</p>
</td></tr>
<tr><td><code id="residuals.AccurateGLM_+3A_...">...</code></td>
<td>
<p>Other arguments are currently not used and just discarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing calculated residuals.
</p>


<h3>Author(s)</h3>

<p>Kenji Kondo
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
