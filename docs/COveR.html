<!DOCTYPE html><html lang="en"><head><title>Help for package COveR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {COveR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.array.interval'><p>Converts an interval object to an array representation.</p></a></li>
<li><a href='#as.data.frame.interval'><p>Converts an interval object to a data frame representation.</p></a></li>
<li><a href='#as.interval'><p>A generic function to convert various R objects into interval objects.</p></a></li>
<li><a href='#as.interval.array'><p>Converts an array to an interval object.</p></a></li>
<li><a href='#as.interval.default'><p>Provides a default method for converting unsupported data types to interval.</p></a></li>
<li><a href='#as.interval.interval'><p>Identity Conversion for Interval</p></a></li>
<li><a href='#as.interval.matrix'><p>Converts a matrix to an interval object.</p></a></li>
<li><a href='#as.interval.numeric'><p>Converts a numeric vector to an interval object.</p></a></li>
<li><a href='#as.matrix.interval'><p>Converts an interval object to a matrix representation.</p></a></li>
<li><a href='#as.vector.interval'><p>Converts an interval object to its vector representation.</p></a></li>
<li><a href='#cluster_color'><p>Generate Colors for Clustering Visualization</p></a></li>
<li><a href='#degree2logical'><p>Transforms a matrix of membership degrees into a logical matrix based on a</p>
specified threshold.</a></li>
<li><a href='#fuzzy_icmeans'><p>Performs fuzzy c-means clustering on interval data, allowing for soft</p>
clustering of data points into multiple clusters.</a></li>
<li><a href='#iaggregate'><p>Aggregates data into a 3D interval array based on a specified column.</p></a></li>
<li><a href='#ibind'><p>Combines multiple interval objects into a single interval object.</p></a></li>
<li><a href='#igenerate'><p>Creates intervals from Normal Distribution using specified mean and standard</p>
deviation values for both the center and half-size of the intervals.</a></li>
<li><a href='#ikmeans'><p>Performs k-means clustering on interval data, allowing for partitioning of</p>
data points into distinct clusters.</a></li>
<li><a href='#ineokm'><p>Performs clustering on interval data using the Neo-KM algorithm, which allows</p>
for overlapping and non-exhaustive cluster membership.</a></li>
<li><a href='#inter_city'><p>Temperature by month and humidity in european city.</p></a></li>
<li><a href='#inter_emotions'><p>Emotions in music aggregate on BPM to interval multi label data.</p></a></li>
<li><a href='#inter_wine'><p>Results of a chemical analysis of wines grown in the same region in Italy but</p>
derived from three different cultivars, aggregate on sulfur dioxide to
interval simple label data.</a></li>
<li><a href='#iokm'><p>Clusters interval data using the OKM (Overlapping K-means) algorithm.</p></a></li>
<li><a href='#is.interval'><p>Determines if an object is a strictly valid interval object.</p></a></li>
<li><a href='#measure'><p>Plots the overlap of membership degrees in a matrix as a function of a</p>
threshold.</a></li>
<li><a href='#neokm'><p>Clusters data using the NEOKM (Non-Exhaustive Overlapping K-means) algorithm.</p></a></li>
<li><a href='#okm'><p>Clusters data using the OKM (Overlapping K-Means) clustering algorithm.</p></a></li>
<li><a href='#plot.interval'><p>Generates a visual representation of interval data as rectangles on a plot.</p></a></li>
<li><a href='#print.icmeans'><p>Displays the results of fuzzy icmeans clustering in a readable format.</p></a></li>
<li><a href='#print.ikmeans'><p>Displays the results of ikmeans clustering in a readable format.</p></a></li>
<li><a href='#print.ineokm'><p>Displays the results of Neo-KM clustering in a user-friendly format.</p></a></li>
<li><a href='#print.interval'><p>Custom print method for displaying interval objects in a readable format.</p></a></li>
<li><a href='#print.iokm'><p>Displays the results of IOKM clustering in a user-friendly format.</p></a></li>
<li><a href='#print.neokm'><p>Displays the results of NEOKM clustering in a user-friendly format.</p></a></li>
<li><a href='#print.okm'><p>Displays the results of OKM clustering in a readable format.</p></a></li>
<li><a href='#print.r1okm'><p>Displays the results of R1-OKM clustering in a readable format.</p></a></li>
<li><a href='#print.r2okm'><p>Displays the results of R2-OKM clustering in a readable format.</p></a></li>
<li><a href='#r1okm'><p>Cluster data using the R1-OKM algorithm.</p></a></li>
<li><a href='#r2okm'><p>Cluster data using the R2-OKM algorithm.</p></a></li>
<li><a href='#read.interval'><p>Reads a CSV file and converts the data into a 3D interval array.</p></a></li>
<li><a href='#write.interval'><p>Writes an interval object to a CSV file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Clustering with Overlaps</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide functions for overlaps clustering, fuzzy clustering and interval-valued data manipulation. The package implement the following algorithms:
	OKM (Overlapping Kmeans) from Cleuziou, G. (2007) &lt;<a href="https://doi.org/10.1109%2Ficpr.2008.4761079">doi:10.1109/icpr.2008.4761079</a>&gt; ;
	NEOKM (Non-exhaustive overlapping Kmeans) from Whang, J. J., Dhillon, I. S., and Gleich, D. F. (2015) &lt;<a href="https://doi.org/10.1137%2F1.9781611974010.105">doi:10.1137/1.9781611974010.105</a>&gt; ;
	Fuzzy Cmeans from Bezdek, J. C. (1981) &lt;<a href="https://doi.org/10.1007%2F978-1-4757-0450-1">doi:10.1007/978-1-4757-0450-1</a>&gt; ;
	Fuzzy I-Cmeans from de A.T. De Carvalho, F. (2005) &lt;<a href="https://doi.org/10.1016%2Fj.patrec.2006.08.014">doi:10.1016/j.patrec.2006.08.014</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Gnu Scientific Library version &gt;= 1.12</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-13 11:02:19 UTC; hiot</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillaume Cleuziou [aut],
  Nicolas Hiot <a href="https://orcid.org/0000-0003-4318-4906"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Hiot &lt;nicolas.hiot@univ-orleans.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-13 13:00:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.array.interval'>Converts an interval object to an array representation.</h2><span id='topic+as.array.interval'></span>

<h3>Description</h3>

<p>Converts an interval object to an array representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interval'
as.array(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.array.interval_+3A_x">x</code></td>
<td>
<p>An interval object to be converted.</p>
</td></tr>
<tr><td><code id="as.array.interval_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to as.array().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array representation of the interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.array(inter_city)
</code></pre>

<hr>
<h2 id='as.data.frame.interval'>Converts an interval object to a data frame representation.</h2><span id='topic+as.data.frame.interval'></span>

<h3>Description</h3>

<p>Converts an interval object to a data frame representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interval'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.interval_+3A_x">x</code></td>
<td>
<p>An interval object to be converted.</p>
</td></tr>
<tr><td><code id="as.data.frame.interval_+3A_...">...</code></td>
<td>
<p>dditional arguments to be passed to as.data.frame().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame representation of the interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.data.frame(inter_city)
</code></pre>

<hr>
<h2 id='as.interval'>A generic function to convert various R objects into interval objects.</h2><span id='topic+as.interval'></span>

<h3>Description</h3>

<p>A generic function to convert various R objects into interval objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.interval(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.interval_+3A_x">x</code></td>
<td>
<p>An R object to be converted to an interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interval object constructed from the R object or NULL if the type
is not supported.
</p>

<hr>
<h2 id='as.interval.array'>Converts an array to an interval object.</h2><span id='topic+as.interval.array'></span>

<h3>Description</h3>

<p>The array must have three
dimensions, with the second dimension of size 2, representing the minimum
and maximum values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
as.interval(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.interval.array_+3A_x">x</code></td>
<td>
<p>An array to be converted to an interval object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interval object constructed from the array if it meets the
requirements, otherwise attempts to convert it to a matrix first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.interval(array(1:12, dim = c(2, 2, 3)))
</code></pre>

<hr>
<h2 id='as.interval.default'>Provides a default method for converting unsupported data types to interval.</h2><span id='topic+as.interval.default'></span>

<h3>Description</h3>

<p>Provides a default method for converting unsupported data types to interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
as.interval(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.interval.default_+3A_x">x</code></td>
<td>
<p>An object that does not have a supported conversion method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'NULL', indicating no conversion is possible.
</p>

<hr>
<h2 id='as.interval.interval'>Identity Conversion for Interval</h2><span id='topic+as.interval.interval'></span>

<h3>Description</h3>

<p>Identity Conversion for Interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interval'
as.interval(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.interval.interval_+3A_x">x</code></td>
<td>
<p>An interval object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input interval object, without modification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.interval(inter_city)
</code></pre>

<hr>
<h2 id='as.interval.matrix'>Converts a matrix to an interval object.</h2><span id='topic+as.interval.matrix'></span>

<h3>Description</h3>

<p>The number of columns in the matrix must be even, representing pairs of
minimum and maximum values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
as.interval(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.interval.matrix_+3A_x">x</code></td>
<td>
<p>A matrix where each pair of columns represents the minimum and
maximum bounds of intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interval object constructed from the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.interval(matrix(1:12, 3, 4))
</code></pre>

<hr>
<h2 id='as.interval.numeric'>Converts a numeric vector to an interval object.</h2><span id='topic+as.interval.numeric'></span>

<h3>Description</h3>

<p>The length of the numeric vector must be even, representing pairs of minimum
and maximum values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
as.interval(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.interval.numeric_+3A_x">x</code></td>
<td>
<p>A numeric vector where each consecutive pair of values represents
an interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interval object constructed from the numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.interval(1:6)
</code></pre>

<hr>
<h2 id='as.matrix.interval'>Converts an interval object to a matrix representation.</h2><span id='topic+as.matrix.interval'></span>

<h3>Description</h3>

<p>Each interval is expanded into its minimum and maximum bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interval'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.interval_+3A_x">x</code></td>
<td>
<p>An interval object to be converted.</p>
</td></tr>
<tr><td><code id="as.matrix.interval_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to as.vector().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representation of the interval, with two columns for each
interval's minimum and maximum values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.matrix(inter_city)
</code></pre>

<hr>
<h2 id='as.vector.interval'>Converts an interval object to its vector representation.</h2><span id='topic+as.vector.interval'></span>

<h3>Description</h3>

<p>Converts an interval object to its vector representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interval'
as.vector(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.vector.interval_+3A_x">x</code></td>
<td>
<p>An interval object to be converted.</p>
</td></tr>
<tr><td><code id="as.vector.interval_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to as.vector().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where each consecutive pair of values represents
an interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.vector(inter_city)
</code></pre>

<hr>
<h2 id='cluster_color'>Generate Colors for Clustering Visualization</h2><span id='topic+cluster_color'></span>

<h3>Description</h3>

<p>Generates a color for each data point based on its clustering assignment,
facilitating visual distinction of clusters in plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_color(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_color_+3A_x">x</code></td>
<td>
<p>A clustering vector or a matrix. If a vector is provided, it
represents the cluster assignments for each data point. If a matrix is
provided, each row should represent a data point's membership across multiple
clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of colors (in hexadecimal format) corresponding to
the clustering assignments, suitable for use in plotting functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(iris[, 1:2], col = cluster_color(neokm(iris, 2, 0.2, 0.05)$cluster))
</code></pre>

<hr>
<h2 id='degree2logical'>Transforms a matrix of membership degrees into a logical matrix based on a
specified threshold.</h2><span id='topic+degree2logical'></span>

<h3>Description</h3>

<p>Transforms a matrix of membership degrees into a logical matrix based on a
specified threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree2logical(x, t = min(apply(x, 1, max)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="degree2logical_+3A_x">x</code></td>
<td>
<p>A matrix of membership degrees.</p>
</td></tr>
<tr><td><code id="degree2logical_+3A_t">t</code></td>
<td>
<p>Threshold value for converting the degrees to logical values. By
default, it uses the minimum of the maximum values in each row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix where each element is 'TRUE' if it meets or exceeds
the threshold, and 'FALSE' otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>degrees &lt;- matrix(runif(9), nrow = 3)
degree2logical(degrees, t = 0.5)
</code></pre>

<hr>
<h2 id='fuzzy_icmeans'>Performs fuzzy c-means clustering on interval data, allowing for soft
clustering of data points into multiple clusters.</h2><span id='topic+fuzzy_icmeans'></span>

<h3>Description</h3>

<p>Performs fuzzy c-means clustering on interval data, allowing for soft
clustering of data points into multiple clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_icmeans(
  x,
  centers,
  m = 2,
  nstart = 2,
  distance = "euclid",
  trace = FALSE,
  iter.max = 40
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzy_icmeans_+3A_x">x</code></td>
<td>
<p>A 3D interval array representing the data to be clustered.</p>
</td></tr>
<tr><td><code id="fuzzy_icmeans_+3A_centers">centers</code></td>
<td>
<p>Either the number of clusters or a set of pre-initialized
cluster centers. If a number is provided, it specifies how many clusters to
create.</p>
</td></tr>
<tr><td><code id="fuzzy_icmeans_+3A_m">m</code></td>
<td>
<p>A number greater than 1 that controls the degree of fuzziness in the
clustering process (default is 2).</p>
</td></tr>
<tr><td><code id="fuzzy_icmeans_+3A_nstart">nstart</code></td>
<td>
<p>Number of times to run the clustering algorithm with different
starting values to find the best solution (default is 2).</p>
</td></tr>
<tr><td><code id="fuzzy_icmeans_+3A_distance">distance</code></td>
<td>
<p>A string specifying the distance metric to use, either
'euclid' for Euclidean distance or 'hausdorff' for Hausdorff distance
(default is 'euclid').</p>
</td></tr>
<tr><td><code id="fuzzy_icmeans_+3A_trace">trace</code></td>
<td>
<p>Logical, if 'TRUE', tracing information on the progress of the
algorithm is displayed (default is 'FALSE').</p>
</td></tr>
<tr><td><code id="fuzzy_icmeans_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed for the clustering
algorithm (default is 40).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clustering results, including:
- 'cluster': The membership matrix indicating the degree of belonging of
each data point to each cluster.
- 'centers': The final cluster centers.
- 'totss': Total sum of squares.
- 'withinss': Within-cluster sum of squares by cluster.
- 'tot.withinss': Total within-cluster sum of squares.
- 'betweenss': Between-cluster sum of squares.
- 'size': Sizes of each cluster.
- 'iter': Number of iterations run by the algorithm.
- 'overlaps': The average overlap among clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fuzzy_icmeans(iaggregate(iris, col = 5), 2)
fuzzy_icmeans(iaggregate(iris, col = 5), iaggregate(iris, col = 5))
</code></pre>

<hr>
<h2 id='iaggregate'>Aggregates data into a 3D interval array based on a specified column.</h2><span id='topic+iaggregate'></span>

<h3>Description</h3>

<p>Aggregates data into a 3D interval array based on a specified column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iaggregate(data, col = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iaggregate_+3A_data">data</code></td>
<td>
<p>The data frame to aggregate.</p>
</td></tr>
<tr><td><code id="iaggregate_+3A_col">col</code></td>
<td>
<p>The index of the column to aggregate by.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structured interval object representing the aggregated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iaggregate(iris, col = 5)
iaggregate(rock, col = 4)
iaggregate(cars, col = 1)
</code></pre>

<hr>
<h2 id='ibind'>Combines multiple interval objects into a single interval object.</h2><span id='topic+ibind'></span>

<h3>Description</h3>

<p>Combines multiple interval objects into a single interval object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibind(..., class = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibind_+3A_...">...</code></td>
<td>
<p>Interval objects to bind together.</p>
</td></tr>
<tr><td><code id="ibind_+3A_class">class</code></td>
<td>
<p>Logical value indicating whether to assign a new class label to
each interval object when binding. If 'TRUE', each set of intervals will have
a distinct class label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new interval object containing the combined intervals from the
input objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ibind(iaggregate(iris, 5), iaggregate(iris, 5))
ibind(iaggregate(iris, 5), iaggregate(iris, 5), iaggregate(iris, 5),
class = TRUE)
</code></pre>

<hr>
<h2 id='igenerate'>Creates intervals from Normal Distribution using specified mean and standard
deviation values for both the center and half-size of the intervals.</h2><span id='topic+igenerate'></span>

<h3>Description</h3>

<p>Creates intervals from Normal Distribution using specified mean and standard
deviation values for both the center and half-size of the intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igenerate(n, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="igenerate_+3A_n">n</code></td>
<td>
<p>Number of intervals to generate.</p>
</td></tr>
<tr><td><code id="igenerate_+3A_...">...</code></td>
<td>
<p>Vectors representing parameters for generating intervals: each
vector should contain four values ('center mean', 'center sd',
'half-size mean', 'half-size sd').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interval object containing the generated intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>igenerate(1, c(0, 1, 2, 1))
igenerate(1, c(0, 1, 2, 1), c(100, 1, 2, 1))
</code></pre>

<hr>
<h2 id='ikmeans'>Performs k-means clustering on interval data, allowing for partitioning of
data points into distinct clusters.</h2><span id='topic+ikmeans'></span>

<h3>Description</h3>

<p>Performs k-means clustering on interval data, allowing for partitioning of
data points into distinct clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ikmeans(
  x,
  centers,
  nstart = 10,
  distance = "euclid",
  trace = FALSE,
  iter.max = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ikmeans_+3A_x">x</code></td>
<td>
<p>A 3D interval array representing the data to be clustered.</p>
</td></tr>
<tr><td><code id="ikmeans_+3A_centers">centers</code></td>
<td>
<p>Either the number of clusters to create or a set of
pre-initialized cluster centers. If a number is provided, it specifies how
many clusters to create.</p>
</td></tr>
<tr><td><code id="ikmeans_+3A_nstart">nstart</code></td>
<td>
<p>The number of times to run the k-means algorithm with different
starting values in order to find the best solution (default is 10).</p>
</td></tr>
<tr><td><code id="ikmeans_+3A_distance">distance</code></td>
<td>
<p>A string specifying the distance metric to use: 'euclid' for
Euclidean distance or 'hausdorff' for Hausdorff distance (default is
'euclid').</p>
</td></tr>
<tr><td><code id="ikmeans_+3A_trace">trace</code></td>
<td>
<p>Logical value indicating whether to show progress of the
algorithm (default is 'FALSE').</p>
</td></tr>
<tr><td><code id="ikmeans_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed for the k-means
algorithm (default is 20).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clustering results, including:
- 'cluster': A vector indicating the cluster assignment of each data point.
- 'centers': The final cluster centers.
- 'totss': Total sum of squares.
- 'withinss': Within-cluster sum of squares by cluster.
- 'tot.withinss': Total within-cluster sum of squares.
- 'betweenss': Between-cluster sum of squares.
- 'size': The number of points in each cluster.
- 'iter': Number of iterations the algorithm executed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ikmeans(iaggregate(iris, col = 5), 2)
ikmeans(iaggregate(iris, col = 5), iaggregate(iris, col = 5))
</code></pre>

<hr>
<h2 id='ineokm'>Performs clustering on interval data using the Neo-KM algorithm, which allows
for overlapping and non-exhaustive cluster membership.</h2><span id='topic+ineokm'></span>

<h3>Description</h3>

<p>Performs clustering on interval data using the Neo-KM algorithm, which allows
for overlapping and non-exhaustive cluster membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ineokm(
  x,
  centers,
  alpha = 0.3,
  beta = 0.05,
  nstart = 10,
  trace = FALSE,
  iter.max = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ineokm_+3A_x">x</code></td>
<td>
<p>A 3D interval array representing the data to be clustered.</p>
</td></tr>
<tr><td><code id="ineokm_+3A_centers">centers</code></td>
<td>
<p>Either the number of clusters to create or a set of
pre-initialized cluster centers. If a number is provided, it specifies how
many clusters to create.</p>
</td></tr>
<tr><td><code id="ineokm_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value that controls the degree of overlap between
clusters (default is 0.3).</p>
</td></tr>
<tr><td><code id="ineokm_+3A_beta">beta</code></td>
<td>
<p>A numeric value that controls the non-exhaustiveness of clusters
(default is 0.05).</p>
</td></tr>
<tr><td><code id="ineokm_+3A_nstart">nstart</code></td>
<td>
<p>The number of times to run the Neo-KM algorithm with different
starting values in order to find the best solution (default is 10).</p>
</td></tr>
<tr><td><code id="ineokm_+3A_trace">trace</code></td>
<td>
<p>Logical value indicating whether to show the progress of the
algorithm (default is 'FALSE').</p>
</td></tr>
<tr><td><code id="ineokm_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed for the Neo-KM algorithm
(default is 20).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clustering results, including:
- 'cluster': A vector indicating the cluster assignment of each data point.
- 'centers': The final cluster centers.
- 'totss': Total sum of squares.
- 'withinss': Within-cluster sum of squares by cluster.
- 'tot.withinss': Total within-cluster sum of squares.
- 'betweenss': Between-cluster sum of squares.
- 'size': The number of points in each cluster.
- 'iter': Number of iterations the algorithm executed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ineokm(iaggregate(iris, col = 5), 3)
ineokm(iaggregate(iris, col = 5), iaggregate(iris, col = 5), 1, 2)
</code></pre>

<hr>
<h2 id='inter_city'>Temperature by month and humidity in european city.</h2><span id='topic+inter_city'></span>

<h3>Description</h3>

<p>Temperature by month and humidity in european city.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_city
</code></pre>


<h3>Format</h3>

<p>A interval structure with 68 rows and 13 variables divided in min
and max with 17 class:
</p>

<dl>
<dt>temp.jan</dt><dd></dd>
<dt>temp.fev</dt><dd></dd>
<dt>temp.mars</dt><dd></dd>
<dt>temp.avr</dt><dd></dd>
<dt>temp.mai</dt><dd></dd>
<dt>temp.juin</dt><dd></dd>
<dt>temp.juil</dt><dd></dd>
<dt>temp.aout</dt><dd></dd>
<dt>temp.sep</dt><dd></dd>
<dt>temp.oct</dt><dd></dd>
<dt>temp.nov</dt><dd></dd>
<dt>temp.dec</dt><dd></dd>
<dt>humid</dt><dd></dd>
</dl>

<p>Class :
</p>

<dl>
<dt>Allemagne</dt><dd></dd>
<dt>Angleterre</dt><dd></dd>
<dt>Autriche</dt><dd></dd>
<dt>Belgique</dt><dd></dd>
<dt>Bulgarie</dt><dd></dd>
<dt>Croatie</dt><dd></dd>
<dt>Danemark</dt><dd></dd>
<dt>Espagne</dt><dd></dd>
<dt>France</dt><dd></dd>
<dt>Italie</dt><dd></dd>
<dt>Pays-Bas</dt><dd></dd>
<dt>Pologne</dt><dd></dd>
<dt>Portugal</dt><dd></dd>
<dt>Roumanie</dt><dd></dd>
<dt>Russie</dt><dd></dd>
<dt>Turquie</dt><dd></dd>
<dt>Ukraine</dt><dd></dd>
</dl>


<hr>
<h2 id='inter_emotions'>Emotions in music aggregate on BPM to interval multi label data.</h2><span id='topic+inter_emotions'></span>

<h3>Description</h3>

<p>Emotions in music aggregate on BPM to interval multi label data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_emotions
</code></pre>


<h3>Format</h3>

<p>A interval structure with 59 rows and 71 variables divided in min
and max with 6 class:
</p>

<dl>
<dt>Mean_Acc1298_Mean_Mem40_Centroid</dt><dd></dd>
<dt>Mean_Acc1298_Mean_Mem40_Rolloff</dt><dd></dd>
<dt>Mean_Acc1298_Mean_Mem40_Flux</dt><dd></dd>
<dt>Mean_Acc1298_Mean_Mem40_MFCC_0</dt><dd></dd>
</dl>
<p>...
</p>
<dl>
<dt>Mean_Acc1298_Mean_Mem40_MFCC_12</dt><dd></dd>
<dt>Mean_Acc1298_Std_Mem40_Centroid</dt><dd></dd>
<dt>Mean_Acc1298_Std_Mem40_Rolloff</dt><dd></dd>
<dt>Mean_Acc1298_Std_Mem40_Flux</dt><dd></dd>
<dt>Mean_Acc1298_Std_Mem40_MFCC_0</dt><dd></dd>
</dl>
<p>...
</p>
<dl>
<dt>Mean_Acc1298_Std_Mem40_MFCC_12</dt><dd></dd>
<dt>Std_Acc1298_Mean_Mem40_Centroid</dt><dd></dd>
<dt>Std_Acc1298_Mean_Mem40_Rolloff</dt><dd></dd>
<dt>Std_Acc1298_Mean_Mem40_Flux</dt><dd></dd>
<dt>Std_Acc1298_Mean_Mem40_MFCC_0</dt><dd></dd>
</dl>
<p>...
</p>
<dl>
<dt>Std_Acc1298_Mean_Mem40_MFCC_12</dt><dd></dd>
<dt>Std_Acc1298_Std_Mem40_Centroid</dt><dd></dd>
<dt>Std_Acc1298_Std_Mem40_Rolloff</dt><dd></dd>
<dt>Std_Acc1298_Std_Mem40_Flux</dt><dd></dd>
<dt>Std_Acc1298_Std_Mem40_MFCC_0</dt><dd></dd>
</dl>
<p>...
</p>
<dl>
<dt>Std_Acc1298_Std_Mem40_MFCC_12</dt><dd></dd>
<dt>BH_LowPeakAmp</dt><dd></dd>
<dt>BH_LowPeakBPM</dt><dd></dd>
<dt>BH_HighPeakAmp</dt><dd></dd>
<dt>BH_HighLowRatio</dt><dd></dd>
<dt>BHSUM1</dt><dd></dd>
<dt>BHSUM2</dt><dd></dd>
<dt>BHSUM3</dt><dd></dd>
</dl>

<p>Class :
</p>

<dl>
<dt>amazed.suprised</dt><dd></dd>
<dt>happy.pleased</dt><dd></dd>
<dt>relaxing.calm</dt><dd></dd>
<dt>quiet.still</dt><dd></dd>
<dt>sad.lonely</dt><dd></dd>
<dt>angry.aggresive</dt><dd></dd>
</dl>



<h3>Source</h3>

<p><a href="https://mulan.sourceforge.net/datasets-mlc.html">https://mulan.sourceforge.net/datasets-mlc.html</a>
</p>

<hr>
<h2 id='inter_wine'>Results of a chemical analysis of wines grown in the same region in Italy but
derived from three different cultivars, aggregate on sulfur dioxide to
interval simple label data.</h2><span id='topic+inter_wine'></span>

<h3>Description</h3>

<p>Results of a chemical analysis of wines grown in the same region in Italy but
derived from three different cultivars, aggregate on sulfur dioxide to
interval simple label data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_wine
</code></pre>


<h3>Format</h3>

<p>A interval structure with 132 rows and 10 variables divided in min
and max with 7 class:
</p>

<dl>
<dt>fixed.acidity</dt><dd></dd>
<dt>volatile.acidity</dt><dd></dd>
<dt>citric.acid</dt><dd></dd>
<dt>residual.sugar</dt><dd></dd>
<dt>chlorides</dt><dd></dd>
<dt>total.sulfur.dioxide</dt><dd></dd>
<dt>density</dt><dd></dd>
<dt>pH</dt><dd></dd>
<dt>sulphates</dt><dd></dd>
<dt>alcohol</dt><dd></dd>
</dl>

<p>Class :
</p>

<dl>
<dt>Class3</dt><dd></dd>
<dt>Class4</dt><dd></dd>
<dt>Class5</dt><dd></dd>
<dt>Class6</dt><dd></dd>
<dt>Class7</dt><dd></dd>
<dt>Class8</dt><dd></dd>
<dt>Class9</dt><dd></dd>
</dl>



<h3>Source</h3>

<p><a href="https://archive.ics.uci.edu/dataset/186/wine+quality">https://archive.ics.uci.edu/dataset/186/wine+quality</a>
</p>

<hr>
<h2 id='iokm'>Clusters interval data using the OKM (Overlapping K-means) algorithm.</h2><span id='topic+iokm'></span>

<h3>Description</h3>

<p>Clusters interval data using the OKM (Overlapping K-means) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iokm(
  x,
  centers,
  nstart = 10,
  distance = "euclid",
  algorithm = "std",
  update = "mean",
  trace = FALSE,
  iter.max = 20,
  secure = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iokm_+3A_x">x</code></td>
<td>
<p>A 3D interval array representing the data to be clustered.</p>
</td></tr>
<tr><td><code id="iokm_+3A_centers">centers</code></td>
<td>
<p>Either the number of clusters to create or a set of
pre-initialized cluster centers. If a number is provided, it indicates how
many clusters to create.</p>
</td></tr>
<tr><td><code id="iokm_+3A_nstart">nstart</code></td>
<td>
<p>The number of times to run the OKM algorithm with different
starting values to find the best result (default is 10).</p>
</td></tr>
<tr><td><code id="iokm_+3A_distance">distance</code></td>
<td>
<p>A string specifying the distance metric to use: 'euclid' for
Euclidean distance or 'hausdorff' for Hausdorff distance (default is
'euclid').</p>
</td></tr>
<tr><td><code id="iokm_+3A_algorithm">algorithm</code></td>
<td>
<p>A string specifying the algorithm type to use: 'std' for the
standard algorithm or 'matrix' for matrix-based algorithm (default is 'std').</p>
</td></tr>
<tr><td><code id="iokm_+3A_update">update</code></td>
<td>
<p>A string specifying the update method for cluster centers.
Either: 'mean', 'sum', 'join' or 'meet' (default is 'mean').</p>
</td></tr>
<tr><td><code id="iokm_+3A_trace">trace</code></td>
<td>
<p>Logical value indicating whether to show progress of the
algorithm (default is 'FALSE').</p>
</td></tr>
<tr><td><code id="iokm_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed for the OKM algorithm
(default is 20).</p>
</td></tr>
<tr><td><code id="iokm_+3A_secure">secure</code></td>
<td>
<p>Logical value indicating whether to ensure that the minimum is
less than or equal to the maximum in intervals (default is 'FALSE').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clustering results, including:
- 'cluster': Matrix indicating the cluster assignment for each data point.
- 'centers': The final cluster centers.
- 'totss': Total sum of squares.
- 'withinss': Within-cluster sum of squares by elements.
- 'tot.withinss': Total within-cluster sum of squares.
- 'betweenss': Between-cluster sum of squares.
- 'size': The number of points in each cluster.
- 'iter': The number of iterations the algorithm executed.
- 'overlaps': The average overlap across clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iokm(iaggregate(iris, col = 5), 2)
iokm(iaggregate(iris, col = 5), iaggregate(iris, col = 5))
</code></pre>

<hr>
<h2 id='is.interval'>Determines if an object is a strictly valid interval object.</h2><span id='topic+is.interval'></span>

<h3>Description</h3>

<p>Determines if an object is a strictly valid interval object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.interval(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.interval_+3A_x">x</code></td>
<td>
<p>An R object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the object is a valid interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.interval(inter_city)
is.interval(1:4)
</code></pre>

<hr>
<h2 id='measure'>Plots the overlap of membership degrees in a matrix as a function of a
threshold.</h2><span id='topic+measure'></span>

<h3>Description</h3>

<p>Plots the overlap of membership degrees in a matrix as a function of a
threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure(x, min = 0, max = 1, step = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_+3A_x">x</code></td>
<td>
<p>A matrix of membership degrees.</p>
</td></tr>
<tr><td><code id="measure_+3A_min">min</code></td>
<td>
<p>Minimum threshold value for the plot (default is 0).</p>
</td></tr>
<tr><td><code id="measure_+3A_max">max</code></td>
<td>
<p>Maximum threshold value for the plot (default is 1).</p>
</td></tr>
<tr><td><code id="measure_+3A_step">step</code></td>
<td>
<p>Step size for the threshold values (default is 0.1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it plot the overlap as a function of the threshold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>membership_matrix &lt;- matrix(runif(20), nrow = 5)
measure(membership_matrix, min = 0, max = 1, step = 0.2)
</code></pre>

<hr>
<h2 id='neokm'>Clusters data using the NEOKM (Non-Exhaustive Overlapping K-means) algorithm.</h2><span id='topic+neokm'></span>

<h3>Description</h3>

<p>Clusters data using the NEOKM (Non-Exhaustive Overlapping K-means) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neokm(
  x,
  centers,
  alpha = 0.3,
  beta = 0.05,
  nstart = 10,
  trace = FALSE,
  iter.max = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neokm_+3A_x">x</code></td>
<td>
<p>A numeric matrix or data frame containing the data to be clustered.</p>
</td></tr>
<tr><td><code id="neokm_+3A_centers">centers</code></td>
<td>
<p>Either the number of clusters to create or a set of
pre-initialized cluster centers.
If a number is provided, it indicates how many clusters to create.</p>
</td></tr>
<tr><td><code id="neokm_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value representing the degree of overlap allowed
between clusters (default is 0.3).</p>
</td></tr>
<tr><td><code id="neokm_+3A_beta">beta</code></td>
<td>
<p>A numeric value representing non-exhaustiveness, which affects
the cluster formation (default is 0.05).</p>
</td></tr>
<tr><td><code id="neokm_+3A_nstart">nstart</code></td>
<td>
<p>The number of times to run the NEOKM algorithm with different
starting values to find the best result (default is 10).</p>
</td></tr>
<tr><td><code id="neokm_+3A_trace">trace</code></td>
<td>
<p>Logical value indicating whether to show progress of the
algorithm (default is 'FALSE').</p>
</td></tr>
<tr><td><code id="neokm_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed for the NEOKM algorithm
(default is 20).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clustering results, including:
- 'cluster': Matrix indicating the cluster assignment for each data point.
- 'centers': The final cluster centers.
- 'totss': Total sum of squares.
- 'withinss': Within-cluster sum of squares by elements.
- 'tot.withinss': Total within-cluster sum of squares.
- 'betweenss': Between-cluster sum of squares.
- 'size': The number of points in each cluster.
- 'iter': The number of iterations the algorithm executed.
- 'overlaps': The average overlap across clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>neokm(iris[, -5], 3)
neokm(iris[, -5], iris[, -5], 1, 2)
</code></pre>

<hr>
<h2 id='okm'>Clusters data using the OKM (Overlapping K-Means) clustering algorithm.</h2><span id='topic+okm'></span>

<h3>Description</h3>

<p>Clusters data using the OKM (Overlapping K-Means) clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>okm(x, centers, iter.max = 10, nstart = 1, trace = FALSE, method = "euclid")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="okm_+3A_x">x</code></td>
<td>
<p>A numeric data matrix or data frame containing the data to be
clustered.</p>
</td></tr>
<tr><td><code id="okm_+3A_centers">centers</code></td>
<td>
<p>Either a positive integer indicating the number of clusters to
create or a matrix of pre-initialized cluster centers.</p>
</td></tr>
<tr><td><code id="okm_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed for the clustering
algorithm (default is 10).</p>
</td></tr>
<tr><td><code id="okm_+3A_nstart">nstart</code></td>
<td>
<p>Number of random initializations to find the best result
(default is 1).</p>
</td></tr>
<tr><td><code id="okm_+3A_trace">trace</code></td>
<td>
<p>Logical value indicating whether to display the progress of the
algorithm (default is 'FALSE').</p>
</td></tr>
<tr><td><code id="okm_+3A_method">method</code></td>
<td>
<p>A string specifying the distance metric to use; options are
'euclid' (Euclidean distance) or 'manhattan' (Manhattan distance)
(default is &quot;euclid&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the clustering results, including:
- 'cluster': Matrix indicating the cluster assignments for each data point.
- 'centers': The final cluster centers.
- 'tot.withinss': Total within-cluster sum of squares.
- 'overlaps': The measure of overlap among clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>okm(iris[, -5], 3)
</code></pre>

<hr>
<h2 id='plot.interval'>Generates a visual representation of interval data as rectangles on a plot.</h2><span id='topic+plot.interval'></span>

<h3>Description</h3>

<p>Generates a visual representation of interval data as rectangles on a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interval'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.interval_+3A_x">x</code></td>
<td>
<p>An interval object to be plotted.</p>
</td></tr>
<tr><td><code id="plot.interval_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters such as 'col' and 'add'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it plot the interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(iaggregate(iris, 5))
plot(iaggregate(iris, 5), col = 4)
plot(iaggregate(iris, 5), add = TRUE)
</code></pre>

<hr>
<h2 id='print.icmeans'>Displays the results of fuzzy icmeans clustering in a readable format.</h2><span id='topic+print.icmeans'></span>

<h3>Description</h3>

<p>Displays the results of fuzzy icmeans clustering in a readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icmeans'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.icmeans_+3A_x">x</code></td>
<td>
<p>An 'icmeans' object resulting from the 'fuzzy_icmeans' function.</p>
</td></tr>
<tr><td><code id="print.icmeans_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the clustering results to the console.
</p>

<hr>
<h2 id='print.ikmeans'>Displays the results of ikmeans clustering in a readable format.</h2><span id='topic+print.ikmeans'></span>

<h3>Description</h3>

<p>Displays the results of ikmeans clustering in a readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ikmeans'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ikmeans_+3A_x">x</code></td>
<td>
<p>An 'ikmeans' object resulting from the 'ikmeans' function.</p>
</td></tr>
<tr><td><code id="print.ikmeans_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the clustering results to the console.
</p>

<hr>
<h2 id='print.ineokm'>Displays the results of Neo-KM clustering in a user-friendly format.</h2><span id='topic+print.ineokm'></span>

<h3>Description</h3>

<p>Displays the results of Neo-KM clustering in a user-friendly format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ineokm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ineokm_+3A_x">x</code></td>
<td>
<p>An 'ineokm' object resulting from the 'ineokm' function.</p>
</td></tr>
<tr><td><code id="print.ineokm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the clustering results to the console.
</p>

<hr>
<h2 id='print.interval'>Custom print method for displaying interval objects in a readable format.</h2><span id='topic+print.interval'></span>

<h3>Description</h3>

<p>Custom print method for displaying interval objects in a readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interval'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.interval_+3A_x">x</code></td>
<td>
<p>An interval object to be printed.</p>
</td></tr>
<tr><td><code id="print.interval_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying print() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the interval to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(inter_city)
</code></pre>

<hr>
<h2 id='print.iokm'>Displays the results of IOKM clustering in a user-friendly format.</h2><span id='topic+print.iokm'></span>

<h3>Description</h3>

<p>Displays the results of IOKM clustering in a user-friendly format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iokm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.iokm_+3A_x">x</code></td>
<td>
<p>An 'iokm' object resulting from the 'iokm' function.</p>
</td></tr>
<tr><td><code id="print.iokm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the clustering results to the console.
</p>

<hr>
<h2 id='print.neokm'>Displays the results of NEOKM clustering in a user-friendly format.</h2><span id='topic+print.neokm'></span>

<h3>Description</h3>

<p>Displays the results of NEOKM clustering in a user-friendly format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neokm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.neokm_+3A_x">x</code></td>
<td>
<p>A 'neokm' object resulting from the 'neokm' function.</p>
</td></tr>
<tr><td><code id="print.neokm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the clustering results to the console.
</p>

<hr>
<h2 id='print.okm'>Displays the results of OKM clustering in a readable format.</h2><span id='topic+print.okm'></span>

<h3>Description</h3>

<p>Displays the results of OKM clustering in a readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'okm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.okm_+3A_x">x</code></td>
<td>
<p>An OKM object resulting from the 'okm' function.</p>
</td></tr>
<tr><td><code id="print.okm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the clustering results to the console.
</p>

<hr>
<h2 id='print.r1okm'>Displays the results of R1-OKM clustering in a readable format.</h2><span id='topic+print.r1okm'></span>

<h3>Description</h3>

<p>Displays the results of R1-OKM clustering in a readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'r1okm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.r1okm_+3A_x">x</code></td>
<td>
<p>An R1-OKM object resulting from the 'r1okm' function.</p>
</td></tr>
<tr><td><code id="print.r1okm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the clustering results to the console.
</p>

<hr>
<h2 id='print.r2okm'>Displays the results of R2-OKM clustering in a readable format.</h2><span id='topic+print.r2okm'></span>

<h3>Description</h3>

<p>Displays the results of R2-OKM clustering in a readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'r2okm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.r2okm_+3A_x">x</code></td>
<td>
<p>An R2-OKM object resulting from the 'r2okm' function.</p>
</td></tr>
<tr><td><code id="print.r2okm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it prints the clustering results to the console.
</p>

<hr>
<h2 id='r1okm'>Cluster data using the R1-OKM algorithm.</h2><span id='topic+r1okm'></span>

<h3>Description</h3>

<p>Cluster data using the R1-OKM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r1okm(x, centers, alpha = 0, nstart = 10, trace = FALSE, iter.max = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r1okm_+3A_x">x</code></td>
<td>
<p>A numeric data matrix or data frame containing the data to be
clustered.</p>
</td></tr>
<tr><td><code id="r1okm_+3A_centers">centers</code></td>
<td>
<p>Either a positive integer indicating the number of clusters to
create or a matrix of initial cluster centers.</p>
</td></tr>
<tr><td><code id="r1okm_+3A_alpha">alpha</code></td>
<td>
<p>A numeric parameter controlling the clustering behavior,
influencing the degree of overlap between clusters (default is 0).</p>
</td></tr>
<tr><td><code id="r1okm_+3A_nstart">nstart</code></td>
<td>
<p>Number of random initializations to find the best clustering
result (default is 10).</p>
</td></tr>
<tr><td><code id="r1okm_+3A_trace">trace</code></td>
<td>
<p>Logical value indicating whether to display progress information
during execution (default is 'FALSE').</p>
</td></tr>
<tr><td><code id="r1okm_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed for the clustering
algorithm (default is 20).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the clustering results, including:
- 'cluster': Matrix indicating the cluster assignments for each data point.
- 'centers': The final cluster centers.
- 'totss': Total sum of squares.
- 'withinss': Within-cluster sum of squares for each cluster.
- 'tot.withinss': Total within-cluster sum of squares.
- 'betweenss': Between-cluster sum of squares.
- 'size': Number of data points in each cluster.
- 'iter': Number of iterations performed.
- 'overlaps': Average number of clusters that each point overlaps with.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1okm(iris[, -5], 3)
r1okm(iris[, -5], 3, alpha = -0.5)
r1okm(iris[, -5], iris[, -5], alpha = 1)
</code></pre>

<hr>
<h2 id='r2okm'>Cluster data using the R2-OKM algorithm.</h2><span id='topic+r2okm'></span>

<h3>Description</h3>

<p>Cluster data using the R2-OKM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2okm(x, centers, lambda = 0, nstart = 10, trace = FALSE, iter.max = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r2okm_+3A_x">x</code></td>
<td>
<p>A numeric data matrix or data frame containing the data to be
clustered.</p>
</td></tr>
<tr><td><code id="r2okm_+3A_centers">centers</code></td>
<td>
<p>Either a positive integer specifying the number of clusters
to create or a matrix of initial cluster centers.</p>
</td></tr>
<tr><td><code id="r2okm_+3A_lambda">lambda</code></td>
<td>
<p>A numeric parameter that controls the clustering behavior,
influencing the shape and separation of clusters (default is 0).</p>
</td></tr>
<tr><td><code id="r2okm_+3A_nstart">nstart</code></td>
<td>
<p>Number of random initializations to find the best clustering
result (default is 10).</p>
</td></tr>
<tr><td><code id="r2okm_+3A_trace">trace</code></td>
<td>
<p>Logical value indicating whether to display progress information
during execution (default is 'FALSE').</p>
</td></tr>
<tr><td><code id="r2okm_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed for the clustering
algorithm (default is 20).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the clustering results, which includes:
- 'cluster': Matrix indicating the cluster assignments for each data point.
- 'centers': The final cluster centers.
- 'totss': Total sum of squares.
- 'withinss': Within-cluster sum of squares for each cluster.
- 'tot.withinss': Total within-cluster sum of squares.
- 'betweenss': Between-cluster sum of squares.
- 'size': Number of data points in each cluster.
- 'iter': Number of iterations performed.
- 'overlaps': Average number of clusters that each point overlaps with.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r2okm(iris[, -5], 3)
r2okm(iris[, -5], 3, lambda = 0.3)
r2okm(iris[, -5], iris[, -5], lambda = 1)
</code></pre>

<hr>
<h2 id='read.interval'>Reads a CSV file and converts the data into a 3D interval array.</h2><span id='topic+read.interval'></span>

<h3>Description</h3>

<p>Reads a CSV file and converts the data into a 3D interval array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.interval(..., row.names = FALSE, class = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.interval_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to read.csv().</p>
</td></tr>
<tr><td><code id="read.interval_+3A_row.names">row.names</code></td>
<td>
<p>Logical indicating if the first column contains row names.</p>
</td></tr>
<tr><td><code id="read.interval_+3A_class">class</code></td>
<td>
<p>The column index of class labels (set to 'NULL' if not present).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structured interval object representing the data from the CSV file.
</p>

<hr>
<h2 id='write.interval'>Writes an interval object to a CSV file.</h2><span id='topic+write.interval'></span>

<h3>Description</h3>

<p>Writes an interval object to a CSV file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.interval(x, ..., class = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.interval_+3A_x">x</code></td>
<td>
<p>An interval object to be saved.</p>
</td></tr>
<tr><td><code id="write.interval_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to write.csv().</p>
</td></tr>
<tr><td><code id="write.interval_+3A_class">class</code></td>
<td>
<p>Logical indicating whether to add the class column in the CSV.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, it saves the interval to the given CSV file.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
