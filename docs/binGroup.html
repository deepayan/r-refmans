<!DOCTYPE html><html><head><title>Help for package binGroup</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {binGroup}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binGroup-package'>
<p>Statistical Methods for Group Testing.</p></a></li>
<li><a href='#accuracy.dorf'><p>Accuracy measures for informative Dorfman testing</p></a></li>
<li><a href='#Array.Measures'><p>Operating characteristics for array testing without master pooling</p></a></li>
<li><a href='#beta.dist'><p>Expected value of order statistics from a beta distribution</p></a></li>
<li><a href='#bgtCI'><p> Confidence Intervals for One Proportion in Binomial Group Testing</p></a></li>
<li><a href='#bgtPower'><p>Power to Reject a Hypothesis in Binomial Group Testing for One Proportion</p></a></li>
<li><a href='#bgtTest'><p> Hypothesis Test for One Proportion in Binomial Group Testing</p></a></li>
<li><a href='#bgtvs'><p> Confidence Interval for One Proportion in Group Testing with Variable Group Sizes</p></a></li>
<li><a href='#bgtWidth'><p> Expected Width of Confidence Intervals in Binomial Group Testing</p></a></li>
<li><a href='#binCI'><p> Confidence Intervals for One Binomial Proportion</p></a></li>
<li><a href='#binDesign'><p>Sample Size Iteration for One Parameter Binomial Problem</p></a></li>
<li><a href='#binPower'><p>Power Calculation for One Parameter Binomial Problem</p></a></li>
<li><a href='#binTest'><p> Hypothesis tests for One Binomial Proportion</p></a></li>
<li><a href='#binWidth'><p>Expected Confidence Interval Width for One Binomial Proportion</p></a></li>
<li><a href='#characteristics.pool'><p>Testing expenditure for informative Dorfman testing</p></a></li>
<li><a href='#estDesign'><p>Sample Size Iteration Depending on Minimal MSE in One-Parameter Group Testing</p></a></li>
<li><a href='#gt.control'>
<p>Auxiliary for Controlling Group Testing Regression</p></a></li>
<li><a href='#gtreg'>
<p>Fitting Group Testing Models</p></a></li>
<li><a href='#gtreg.halving'>
<p>Fitting Group Testing Models Under the Halving Protocol</p></a></li>
<li><a href='#gtreg.mp'>
<p>Fitting Group Testing Models in Matrix Pooling Setting</p></a></li>
<li><a href='#hierarchical.desc2'><p>Operating characteristics for hierarchical group testing</p></a></li>
<li><a href='#hivsurv'><p>Data from an HIV surveillance project</p></a></li>
<li><a href='#Inf.Array'><p>Find the optimal testing configuration for informative</p>
array testing without master pooling</a></li>
<li><a href='#Inf.D3'><p>Find the optimal testing configuration for informative</p>
three-stage hierarchical testing</a></li>
<li><a href='#Inf.Dorf'><p>Find the optimal testing configuration for informative</p>
two-stage hierarchical (Dorfman) testing</a></li>
<li><a href='#inf.dorf.measures'><p>Operating characteristics for informative two-stage</p>
hierarchical (Dorfman) testing</a></li>
<li><a href='#Informative.array.prob'><p>Arrange a matrix of probabilities for informative array testing</p></a></li>
<li><a href='#MasterPool.Array.Measures'><p>Operating characteristics for array testing with master pooling</p></a></li>
<li><a href='#nDesign'><p>Iterate Sample Size in One Parameter Group Testing</p></a></li>
<li><a href='#NI.A2M'><p>Find the optimal testing configuration for non-informative</p>
array testing with master pooling</a></li>
<li><a href='#NI.Array'><p>Find the optimal testing configuration for non-informative</p>
array testing without master pooling</a></li>
<li><a href='#NI.D3'><p>Find the optimal testing configuration for non-informative</p>
three-stage hierarchical testing</a></li>
<li><a href='#NI.Dorf'><p>Find the optimal testing configuration for non-informative</p>
two-stage hierarchical testing</a></li>
<li><a href='#opt.info.dorf'><p>Find the characteristics of an informative two-stage</p>
hierarchical (Dorfman) algorithm</a></li>
<li><a href='#opt.pool.size'><p>Find the optimal pool size for Optimal Dorfman or</p>
Thresholded Optimal Dorfman</a></li>
<li><a href='#OTC'><p>Find the optimal testing configuration</p></a></li>
<li><a href='#p.vec.func'><p>Generate a vector of probabilities for informative group</p>
testing algorithms.</a></li>
<li><a href='#plot.bgtDesign'><p>Plot Results of nDesign or sDesign</p></a></li>
<li><a href='#plot.binDesign'><p>Plot Results of binDesign</p></a></li>
<li><a href='#plot.poolbin'>
<p>Diagnostic line fit for pool.bin objects</p></a></li>
<li><a href='#pool.specific.dorf'><p>Find the optimal pool sizes for Pool-Specific Optimal Dorfman</p>
(PSOD) testing</a></li>
<li><a href='#pooledBin'>
<p>Confidence intervals for a single proportion</p></a></li>
<li><a href='#pooledBinDiff'>
<p>Confidence intervals for the difference of proportions</p></a></li>
<li><a href='#predict.gt'>
<p>Predict Method for Group Testing Model Fits</p></a></li>
<li><a href='#print.bgt'><p> Print Functions for Group Testing CIs and Tests for One Proportion</p></a></li>
<li><a href='#print.bgtDesign'><p>Print Functions for nDesign and sDesign</p></a></li>
<li><a href='#print.binDesign'><p> Print Function for binDesign</p></a></li>
<li><a href='#print.gt'>
<p>Print methods for objects of classes &quot;gt&quot; and &quot;gt.mp&quot;</p></a></li>
<li><a href='#print.poolbindiff'>
<p>Print methods for classes &quot;poolbin&quot; and &quot;poolbindiff&quot;</p></a></li>
<li><a href='#print.summary.gt'>
<p>Print Functions for summary.gt.mp and summary.gt</p></a></li>
<li><a href='#residuals.gt'>
<p>Extract Model Residuals From a Fitted Group Testing Model</p></a></li>
<li><a href='#sDesign'><p>Iterate Group Size for a One-Parameter Group Testing Problem</p></a></li>
<li><a href='#sim.gt'>
<p>Simulation Function for Group Testing Data</p></a></li>
<li><a href='#sim.halving'>
<p>Simulation Function for Group Testing Data for the Halving Protocol</p></a></li>
<li><a href='#sim.mp'>
<p>Simulation Function for Group Testing Data with Matrix Pooling Design</p></a></li>
<li><a href='#summary.gt'>
<p>Summary Method for Group Testing Model (Simple Pooling) Fits</p></a></li>
<li><a href='#summary.gt.mp'>
<p>Summary Method for Group Testing Model (Matrix Pooling) Fits</p></a></li>
<li><a href='#summary.poolbindiff'><p>Summary methods for &quot;poolbin&quot; and &quot;poolbindiff&quot;</p></a></li>
<li><a href='#thresh.val.dorf'><p>Find the optimal threshold value for Thresholded Optimal</p>
Dorfman testing</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Evaluation and Experimental Design for Binomial Group Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-08-24</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frank Schaarschmidt &lt;schaarschmidt@biostat.uni-hannover.de&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, partitions, Rdpack, stats, utils</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for estimation and hypothesis testing of proportions
 in group testing designs: methods for estimating a proportion in a single
        population (assuming sensitivity and specificity equal to 1 in designs
        with equal group sizes), as well as hypothesis tests and
        functions for experimental design for this situation. For
        estimating one proportion or the difference of proportions, a
        number of confidence interval methods are included, which can
        deal with various different pool sizes. Further, regression
        methods are implemented for simple pooling and matrix pooling
        designs.
        Methods for identification of positive items in group
        testing designs: Optimal testing configurations can be found 
        for hierarchical and array-based algorithms. Operating 
        characteristics can be calculated for testing configurations 
        across a wide variety of situations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-24 08:51:07 UTC; Schaarschmidt</td>
</tr>
<tr>
<td>Author:</td>
<td>Boan Zhang [aut],
  Christopher Bilder [aut],
  Brad Biggerstaff [aut],
  Frank Schaarschmidt [aut, cre],
  Brianna Hitt [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-24 11:24:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='binGroup-package'>
Statistical Methods for Group Testing.
</h2><span id='topic+binGroup-package'></span><span id='topic+binGroup'></span>

<h3>Description</h3>

<p>This package provides methods for estimation and hypothesis testing of proportions in group testing designs. It involves methods for estimating a proportion in a single population (assuming sensitivity and specificity 1 in designs with equal group sizes), as well as hypothesis tests and functions for experimental design for this situation. For estimating one proportion or the difference of proportions, a number of confidence interval methods are included, which can deal with various different pool sizes. Further, regression methods are implemented for simple pooling and matrix pooling designs. <br /> <br />
This package also provides methods for identification of positive items in a number of group testing algorithms. Optimal testing configurations can be found for hierarchical and array-based algorithms. Operating characteristics can be calculated for testing configurations across a wide variety of situations.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> binGroup</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.2-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-07-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=3)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>1) One-sample case
</p>
<p>Methods for calculating confidence intervals for a single population proportion from designs with equal group sizes (as described by Tebbs and Bilder, 2004 and Schaarschmidt, 2007) are implemented in the function <code><a href="#topic+bgtCI">bgtCI</a></code>.
</p>
<p>For the problem of choosing an adequate experimental design in the one-sample case with only one group size, the functions <code><a href="#topic+estDesign">estDesign</a></code>, <code><a href="#topic+sDesign">sDesign</a></code>, <code><a href="#topic+nDesign">nDesign</a></code> implement different iterative approaches, as examplified by Swallow (1985) and Schaarschmidt (2007).
</p>
<p>If a confidence interval for a single proportion shall be calculated based on a design involving groups of different group sizes, a number of methods described by Hepworth (1999) is available in the function <code><a href="#topic+pooledBin">pooledBin</a></code>. The exact method described by Hepworth (1996) is implemented in the function <code><a href="#topic+bgtvs">bgtvs</a></code>.
</p>
<p>2) Two-sample case
</p>
<p>The function <code><a href="#topic+pooledBinDiff">pooledBinDiff</a></code> provides a number of confidence interval methods for estimating the difference of proportions from two independent samples, allowing for groups of different group size (Biggerstaff, 2008).
</p>
<p>3) Regression models
</p>
<p>Two approaches (by Vansteelandt et al., 2000 and Xie, 2001) to estimate parameters of group testing regression models can be applied by calling <code><a href="#topic+gtreg">gtreg</a></code>. Once fitted, corresponding methods to extract residuals, calculate predictions and summarize the parameter estimates (including hypotheses tests) are available in the S3 methods <code><a href="#topic+residuals.gt">residuals.gt</a></code>, <code><a href="#topic+predict.gt">predict.gt</a></code> and <code><a href="#topic+summary.gt">summary.gt</a></code>.
</p>
<p>Group testing regression models in settings with matrix pooling (Xie, 2001) can be fit using <code><a href="#topic+gtreg.mp">gtreg.mp</a></code>. 
</p>
<p>4) Identification using hierarchical and array-based group testing algorithms
</p>
<p>The function <code><a href="#topic+OTC">OTC</a></code> implements a number of group testing algorithms, described in Hitt et al. (2018), which calculate the operating characteristics and find the optimal testing configuration over a range of possible initial pool sizes and/or testing configurations (sets of subsequent pool sizes).
</p>


<h3>Author(s)</h3>

<p>Boan Zhang, Christopher Bilder, Brad Biggerstaff, Brianna Hitt, Frank Schaarschmidt
</p>
<p>Maintainer: Frank Schaarschmidt &lt;schaarschmidt@biostat.uni-hannover.de&gt;
</p>


<h3>References</h3>

<p><em>Biggerstaff, B.J. (2008)</em>: Confidence interval for the difference of proportions estmimated from pooled samples. <em>Journal of Agricultural Biological and Environmental Statistics, 13(4), 478-496.</em>
</p>
<p><em>Hepworth, G. (1996)</em> Exact confidence intervals for proportions estimated by group testing. <em>Biometrics 52, 1134-1146.</em>
</p>
<p><em>Hepworth, G. (1999)</em>: <em>Estimation of proportions by group testing.</em> PhD Dissertation. Melbourne, Australia: The University of Melbourne.
</p>
<p><em>Hitt, B., Bilder, C., Tebbs, J. &amp; McMahan, C. (2018)</em> The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!. Manuscript submitted for publication. http://www.chrisbilder.com/grouptesting
</p>
<p><em>Schaarschmidt, F. (2007)</em> Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing.  <em>Communications in Biometry and Crop Science 2 (1), 32-40.</em> http://agrobiol.sggw.waw.pl/cbcs/
</p>
<p><em>Swallow, W.H. (1985)</em> Group testing for estimating infection rates and probabilities of disease transmission.  <em>Phytopathology 75 (8), 882-889.</em>
</p>
<p><em>Tebbs, J.M. &amp; Bilder, C.R. (2004)</em> Confidence interval procedures for the probability of disease transmission in multiple-vector-transfer designs.  <em>Journal of Agricultural, Biological and Environmental Statistics 9 (1), 75-90.</em>
</p>
<p><em>Vansteelandt, S., Goetghebeur, E., and Verstraeten, T. (2000)</em> Regression models for disease prevalence with diagnostic tests on pools of serum samples, <em>Biometrics, 56, 1126-1133.</em>
</p>
<p><em>Xie, M. (2001)</em> Regression analysis of group testing samples, <em>Statistics in Medicine, 20, 1957-1969.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1) One-sample problem

# 1.1) Confidence intervals for designs with equal group size (pool size),
# where 
#  n denotes the number of groups (pools),
#  s denotes the common group size (number of individuals pooled per group),
#  y denotes the number of groups tested positive.

# The following call reproduces the example given 
# by Tebbs and Bilder (2004) for the two-sided 95-percent 
# exact (Clopper-Pearson) interval:

bgtCI(n=24, y=3, s=7, conf.level=0.95,
 alternative="two.sided", method="CP")

# 1.2) Confidence intervals for designs with unequal group size (pool size):
# Keeping notation as above but allowing for (a limited number of) different
# group size s, the examples given in Hepworth (1996), Table 5 can be 
# reproduced by calling:

 bgtvs(n=c(2,3), s=c(5,2), y=c(0,0))
 bgtvs(n=c(2,3), s=c(5,2), y=c(0,1))

# The function pooledBin provides different methods for the same problem,
# where x is the number of positive groups, m is the size of the groups and
# n is the number of groups with the correesponding sizes:

pooledBin(x=c(0,1), m=c(5,2), n=c(2,3), ci.method="score")
pooledBin(x=c(0,1), m=c(5,2), n=c(2,3), ci.method="lrt")
pooledBin(x=c(0,1), m=c(5,2), n=c(2,3), ci.method="bc-skew-score")

# 1.3) For experimental design based on the bias of the point estimate,
# as proposed by Swallow (1985): The values in Table 1 (Swallow, 1985),
# p.885 can be reproduced by calling:

estDesign(n=10, smax=100, p.tr=0.001)
estDesign(n=10, smax=100, p.tr=0.01)

# 2) Two-sample comparison

# Assume a design, where pools 5, 1, 1, 30, and 20 pools of size 10, 4, 1, 25, 50, 
# respectively, are used to estimate the prevalence in two populations.
# In population 1, one out of 5 pools with 10 units is positive,
# while in population 2, two out of five pools with 10 units is positive as well as 
# the one pool with only 1 unit.
# The difference of proportions is to be estimated.

x1 &lt;- c(1,0,0,0,0)
m1 &lt;- c(10,4,1,25,50)
n1 &lt;- c(5,1,1,30,20)

x2 &lt;- c(2,0,1,0,0)
m2 &lt;- c(10,4,1,25,50)
n2 &lt;- c(5,1,1,30,20)

pooledBinDiff(x1=x1, m1=m1,x2=x2, m2=m2, n1=n1, n2=n2, ci.method="lrt")


# 3) Regression models

# 3.1) Fitting a regression model
# A HIV surveillance data (used by Vansteelandt et al. 2000)
# can be analysed for the dependence of HIV prevalence
# on covariates AGE and EDUC., with sensitivity and specificity
# assumed to be 0.9 each.

data(hivsurv)
fit1 &lt;- gtreg(formula = groupres ~ AGE + EDUC., data = hivsurv,
  groupn = gnum, sens = 0.9, spec = 0.9, method = "Xie")
summary(fit1)


# 3.2) Fitting a regression model for matrix pooling data
# The function sim.mp is used to simulate a matrix pooling data set:

set.seed(9128)
sa1a&lt;-sim.mp(par=c(-7,0.1), n.row=c(5,4), n.col=c(6,5),
 sens=0.95, spec=0.95)

str(sa1a)
sa1&lt;-sa1a$dframe


## Not run: 
fit2 &lt;- gtreg.mp(formula = cbind(col.resp, row.resp) ~ x, data = sa1, 
                 coln = coln, rown = rown, arrayn = arrayn, 
                 sens = 0.95, spec = 0.95, n.gibbs = 2000, trace = TRUE)
fit2
summary(fit2)

## End(Not run)

# 4) Identification using hierarchical and array-based group testing algorithms

# 4.1) Finding the optimal testing configuration over a range of initial 
# group sizes, using non-informative three-stage hierarchical testing, where 
#   p denotes the overall prevalence of disease,
#   Se denotes the sensitivity of the diagnostic test, 
#   Sp denotes the specificity of the diagnostic test,
#   group.sz denotes the range of initial pool sizes for consideration, and
#   obj.fn specifies the objective functions for which to find results.

# The following call reproduces results given by Hitt et al. (2018) for 
# informative three-stage hierarchical testing with an overall disease 
# prevalence of E(p_i) = 0.01 and sensitivity and specificity equal to 0.95.

# This example takes approximately 2.5 minutes to run.

## Not run: 
set.seed(1002)
results1 &lt;- OTC(algorithm="ID3", p=0.01, Se=0.95, Sp=0.95, group.sz=3:40, 
obj.fn=c("ET", "MAR"), alpha=2)
results1$opt.ET$OTC
results1$opt.ET$ET/results1$opt.ET$OTC$Stage1
results1$opt.MAR$OTC
results1$opt.MAR$ET/results1$opt.MAR$OTC$Stage1

## End(Not run)

# 4.2) Finding the optimal testing configuration using non-informative
# array testing without master pooling

# The following call reproduces results given by Hitt et al. (2018) for
# non-informative array testing without master pooling with an overall
# disease prevalence of p=0.01 and sensitivity and specificity equal 
# to 0.90.

# This example takes approximately 7 minutes to run.

## Not run: 
results2 &lt;- OTC(algorithm="A2", p=0.01, Se=0.90, Sp=0.90, group.sz=3:40, 
obj.fn=c("ET", "MAR"))
results2$opt.ET$OTC
results2$opt.ET$ET/results2$opt.ET$OTC$Array.sz
results2$opt.MAR$OTC
results2$opt.MAR$ET/results2$opt.MAR$OTC$Array.sz

## End(Not run)

</code></pre>

<hr>
<h2 id='accuracy.dorf'>Accuracy measures for informative Dorfman testing</h2><span id='topic+accuracy.dorf'></span>

<h3>Description</h3>

<p>Calculate the accuracy measures for each individual 
in a pool used with informative Dorfman testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy.dorf(p, se, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy.dorf_+3A_p">p</code></td>
<td>
<p>a vector of each individual's probability of infection.</p>
</td></tr>
<tr><td><code id="accuracy.dorf_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="accuracy.dorf_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the pooling sensitivity, pooling
specificity, pooling positive predictive value, and pooling negative
predictive value for each individual belonging to a pool of size 
greater than or equal to one used with informative Dorfman testing. 
Calculations of these measures are done using the equations presented 
in McMahan et al. (2012).
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>PSe</code></td>
<td>
<p>a vector containing each individual's pooling sensitivity.</p>
</td></tr>
<tr><td><code>PSp</code></td>
<td>
<p>a vector containing each individual's pooling specificity.</p>
</td></tr>
<tr><td><code>PPV</code></td>
<td>
<p>a vector containing each individual's pooling positive 
predictive value.</p>
</td></tr>
<tr><td><code>NPV</code></td>
<td>
<p>a vector containing each individual's pooling negative 
predictive value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher S. 
McMahan for McMahan et al. (2012). The function was obtained 
from <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>


<h3>See Also</h3>

<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Informative Dorfman functions: <code><a href="#topic+characteristics.pool">characteristics.pool</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>,
<code><a href="#topic+opt.info.dorf">opt.info.dorf</a></code>, <code><a href="#topic+opt.pool.size">opt.pool.size</a></code>,
<code><a href="#topic+pool.specific.dorf">pool.specific.dorf</a></code>,
<code><a href="#topic+thresh.val.dorf">thresh.val.dorf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8135)
p.vec &lt;- p.vec.func(p=0.02, alpha=1, grp.sz=10)
accuracy.dorf(p=p.vec[1:3], se=0.90, sp=0.90)
</code></pre>

<hr>
<h2 id='Array.Measures'>Operating characteristics for array testing without master pooling</h2><span id='topic+Array.Measures'></span>

<h3>Description</h3>

<p>Calculate the expected number of tests and accuracy measures
for each individual using array testing without master pooling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Array.Measures(p, se, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Array.Measures_+3A_p">p</code></td>
<td>
<p>matrix of probabilities corresponding to each individual's risk 
of disease.</p>
</td></tr>
<tr><td><code id="Array.Measures_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Array.Measures_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the operating characteristics for
array testing without master pooling. Operating characteristics calculated
are expected number of tests, pooling sensitivity, pooling specificity, 
pooling positive predictive value, and pooling negative predictive value 
for each individual.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>T</code></td>
<td>
<p>the expected number of tests for the array.</p>
</td></tr>
<tr><td><code>PSe</code></td>
<td>
<p>a matrix containing each individual's pooling sensitivity, 
corresponding to the input matrix of individual probabilities.</p>
</td></tr>
<tr><td><code>PSp</code></td>
<td>
<p>a matrix containing each individual's pooling specificity, 
corresponding to the input matrix of individual probabilities.</p>
</td></tr>
<tr><td><code>PPV</code></td>
<td>
<p>a matrix containing each individual's pooling positive predictive
value, corresponding to the input matrix of individual probabilities.</p>
</td></tr>
<tr><td><code>NPV</code></td>
<td>
<p>a matrix containing each individual's pooling negative predictive
value, corresponding to the input matrix of individual probabilities.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals in the array even though these
measures are diagnostic specific; i.e., PPV (NPV) should only be considered
for those individuals who have tested positive (negative).
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher S. McMahan for 
McMahan et al. (2012). The function was obtained from 
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Two-Dimensional Informative Array Testing.&rdquo;
<em>Biometrics</em>, <b>68</b>(3), 793&ndash;804.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01726.x">10.1111/j.1541-0420.2011.01726.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MasterPool.Array.Measures">MasterPool.Array.Measures</a></code> for calculating operating 
characteristics under non-informative array testing with master pooling, 
<code><a href="#topic+hierarchical.desc2">hierarchical.desc2</a></code> for three-stage hierarchical and 
non-informative two-stage hierarchical testing, and 
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code> for informative two-stage hierarchical 
testing. See <code><a href="#topic+p.vec.func">p.vec.func</a></code> for generating a vector of 
individual risk probabilities for informative group testing and 
<code><a href="#topic+Informative.array.prob">Informative.array.prob</a></code> for arranging individual risk
probabilities in a matrix for informative array testing.  
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Operating characteristic functions: <code><a href="#topic+MasterPool.Array.Measures">MasterPool.Array.Measures</a></code>,
<code><a href="#topic+hierarchical.desc2">hierarchical.desc2</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the operating characteristics for 
#   non-informative array testing without master
#   pooling, with a 5x5 array and an overall disease 
#   risk of p = 0.02.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
p.mat &lt;- matrix(data=0.02, ncol=5, nrow=5)
Array.Measures(p=p.mat, se=0.95, sp=0.95)

# Calculate the operating characteristics for 
#   informative array testing without master
#   pooling, with a 3x3 array and an overall disease
#   risk of p = 0.03 and alpha = 2.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8791)
p.vec &lt;- p.vec.func(p=0.03, alpha=2, grp.sz=9)
p.mat &lt;- Informative.array.prob(prob.vec=p.vec, nr=3, 
nc=3, method="gd")
Array.Measures(p=p.mat, se=0.99, sp=0.99)
</code></pre>

<hr>
<h2 id='beta.dist'>Expected value of order statistics from a beta distribution</h2><span id='topic+beta.dist'></span>

<h3>Description</h3>

<p>Get the expected value of order statistics, E(p(i)), 
from a beta distribution by specifying an average probability 
and shape parameters for the beta distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.dist(p = 0.05, alpha = 1, beta = NULL, grp.sz = 10,
  simul = FALSE, plot = FALSE, rel.tol = ifelse(a &gt;= 1,
  .Machine$double.eps^0.25, .Machine$double.eps^0.1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.dist_+3A_p">p</code></td>
<td>
<p>average probability, <code class="reqn">\frac{\alpha}{\alpha + \beta}</code>.</p>
</td></tr>
<tr><td><code id="beta.dist_+3A_alpha">alpha</code></td>
<td>
<p>the alpha parameter for the beta distribution. The 
details of the specification of <kbd>alpha</kbd> are given under 'Details'.</p>
</td></tr>
<tr><td><code id="beta.dist_+3A_beta">beta</code></td>
<td>
<p>the beta parameter for the beta distribution, which is
calculated from the average probability, <kbd>p</kbd>, if it is not
specified. The details of the specification of <kbd>beta</kbd> are 
given under 'Details'.</p>
</td></tr>
<tr><td><code id="beta.dist_+3A_grp.sz">grp.sz</code></td>
<td>
<p>the number of individuals in the group.</p>
</td></tr>
<tr><td><code id="beta.dist_+3A_simul">simul</code></td>
<td>
<p>a logical value indicating whether to use simulation. 
If simulation is used, the vector of probabilities is found by 
simulating 10,000 values from a beta distribution with
the specified shape parameters. If simulation is not used, 
the vector of individual probabilities is found using integration.</p>
</td></tr>
<tr><td><code id="beta.dist_+3A_plot">plot</code></td>
<td>
<p>a logical value indicating whether to plot the 
distribution with p(i) marked.</p>
</td></tr>
<tr><td><code id="beta.dist_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance used for integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <kbd>alpha</kbd> = 0, this function uses an extreme value 
distribution based on a Bernoulli(p) distribution to  find the 
individual probabilities, p_i. If <kbd>alpha</kbd> is infinite, this 
function uses <code class="reqn">p_i=p</code> for all i.
</p>
<p>If <kbd>beta</kbd> is not specified, it is calculated from the average
probability <kbd>p</kbd> as <code class="reqn">b=a*\frac{1}{p-1}</code>. If <kbd>beta</kbd> is 
specified, this function ignores <kbd>p</kbd> unless <kbd>alpha</kbd> is 
infinite.
</p>
<p>Depending on the specified probability, alpha level, and overall 
group size, simulation may be necessary in order to generate the 
vector of individual probabilities. In this case, the user should
specify <kbd>simul=TRUE</kbd> and set a seed in order to reproduce results. 
See Black et al. (2015) for additional details.
</p>


<h3>Value</h3>

<p>A vector of ordered probabilities, p_i.
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Michael S. 
Black for Black et al. (2015). The function was obtained 
from <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>Black, M., Bilder, C., Tebbs, J. (2015).
&ldquo;Optimal retesting configurations for hierarchical group testing.&rdquo;
<em>Journal of the Royal Statistical Society. Series C: Applied Statistics</em>, <b>64</b>(4), 693&ndash;710.
ISSN 14679876, doi: <a href="https://doi.org/10.1111/rssc.12097">10.1111/rssc.12097</a>.
</p>


<h3>See Also</h3>

<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p><code><a href="#topic+p.vec.func">p.vec.func</a></code> for generating a vector of individual
risk probabilities for informative group testing (after checking 
whether simulation is needed) and <code><a href="#topic+Informative.array.prob">Informative.array.prob</a></code> 
for arranging a vector of individual risk probabilities in a matrix 
for informative array testing without master pooling.
</p>
<p>Other Individual risk probability functions: <code><a href="#topic+Informative.array.prob">Informative.array.prob</a></code>,
<code><a href="#topic+p.vec.func">p.vec.func</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8791)
beta.dist(p=0.05, alpha=1, grp.sz=30)

# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(1002)
beta.dist(p=0.02, alpha=2, grp.sz=50, simul=TRUE)

# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(5732)
beta.dist(alpha=2, beta=5, grp.sz=15, plot=TRUE)
</code></pre>

<hr>
<h2 id='bgtCI'> Confidence Intervals for One Proportion in Binomial Group Testing  </h2><span id='topic+bgtCI'></span><span id='topic+bgtCP'></span><span id='topic+bgtBlaker'></span><span id='topic+bgtAC'></span><span id='topic+bgtWilson'></span><span id='topic+bgtWald'></span><span id='topic+bgtSOC'></span>

<h3>Description</h3>

<p> Calculates the point estimate, the exact Clopper-Pearson and Blaker CI, the Score test derived 
Wilson and Agresti-Coull CI, the asymptotic second-order corrected interval fo Cai and the Wald CI for
a single binomial proportion estimated from a binomial group testing trial. Assumes equal group sizes, 
an assay method classifying a group as positive if at least one unit in the group is positive, individuals
units randomly assigned to the groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgtCI(n, s, y, conf.level = 0.95,
 alternative = "two.sided", method = "CP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgtCI_+3A_n">n</code></td>
<td>
<p>integer, specifying the number of groups (i.e. assays i.e. observations) </p>
</td></tr>
<tr><td><code id="bgtCI_+3A_s">s</code></td>
<td>
<p>integer, specifying the common size of groups i.e. the number of individual units in each group </p>
</td></tr>
<tr><td><code id="bgtCI_+3A_y">y</code></td>
<td>
<p>integer, specifying the number of positive groups </p>
</td></tr>
<tr><td><code id="bgtCI_+3A_conf.level">conf.level</code></td>
<td>
<p>nominal confidence level of the interval </p>
</td></tr>
<tr><td><code id="bgtCI_+3A_alternative">alternative</code></td>
<td>
<p>character string defining the alternative hypothesis, either 'two.sided', 'less' or 'greater'
where 'less' gives the only an upper bound with confidence level=conf.level
'greater' gives the only a lower bound with confidence level=conf.level
and 'two.sided' gives a two-sided confidence interval with confidence level=conf.level</p>
</td></tr>
<tr><td><code id="bgtCI_+3A_method">method</code></td>
<td>
<p> character string defining the method for CI calculation, where: 
<kbd>"CP"</kbd> is Clopper-Pearson, an exact tail interval showing symmetric coverage probability (inversion of two one-sided tests),
<kbd>"Blaker"</kbd> is the Blaker interval, an exact interval, inversion of one two.sided test, therefore defined only two.sided, but shorter
than the two-sided Clopper-Pearson CI. Both guarantee to contain the true parameter with at least conf.level*100 percent
probability,
<kbd>"AC"</kbd> is the Agresti-Coull (generalized Agresti-Coull) interval, asymptotic method,
<kbd>"Score"</kbd> is Wilson Score, asymptotic method derived from inversion of the Score test,
<kbd>"SOC"</kbd> is the second order corrected interval, asymptotic method for one-sided problems (for details see Cai, 2005),
and <kbd>"Wald"</kbd> the Wald interval, which cannot be recommended.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the computation of confidence intervals for binomial group testing as described in Tebbs &amp; Bilder (2004) and Schaarschmidt (2007).
If an actual confidence level greater or equal to that specified in the conf.level argument shall always be guaranteed, the exact method of 
Clopper-Pearson (<kbd>method="CP"</kbd>) can be recommended for one-sided and the improved method of Blaker (2000) (<kbd>method="Blaker"</kbd>) can be recommended for two-sided
hypotheses. If a mean confidence level close to that specified in the argument conf.level is required, but moderate violation of this level is acceptable,
the Second-Order corrected (<kbd>method="SOC"</kbd>), Wilson Score (<kbd>method="Score"</kbd>) or Agresti-Coull (<kbd>method="AC"</kbd>) might be used (Brown, Cai, DasGupta, 2001; Cai 2005).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the proportion</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the point estimator of the proportion</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

<p><em>Blaker H (2000)</em>. Confidence curves and improved exact confidence intervals for discrete distributions. <em>The Canadian Journal of Statistics 28 (4), 783-798.</em>
</p>
<p><em>Brown LD, Cai TT, DasGupta A (2001)</em>. Interval estimation for a binomial proportion. <em>Statistical Science 16 (2), 101-133.</em>
</p>
<p><em>Cai TT (2005)</em>. One-sided confidence intervals in discrete distributions. <em>Journal of Statistical Planning and Inference 131, 63-88.</em>
</p>
<p><em>Schaarschmidt F (2007).</em> Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing. <em>Communications in Biometry and Crop Science 2 (1), 32-40.</em> http://agrobiol.sggw.waw.pl/cbcs/
</p>
<p><em>Tebbs JM &amp; Bilder CR (2004)</em>. Confidence interval procedures for the probability of disease transmission in multiple-vector-transfer designs. <em>Journal of Agricultural, Biological and Environmental Statistics, 9 (1), 75-90.</em>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+pooledBin">pooledBin</a></code> for asymptotic confidence intervals and <code><a href="#topic+bgtvs">bgtvs</a></code> for an exact confidence interval when designs with different group sizes are used
</p>
<p><code><a href="#topic+bgtTest">bgtTest</a></code>: for hypothesis tests in binomial group testing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See the example in Tebbs and Bilder (2004)
# the two.sided 95-percent 
# Clopper-Pearson as default method:

bgtCI(n=24,y=3,s=7)
bgtCI(n=24,y=3,s=7,conf.level=0.95,
 alternative="two.sided", method="CP")

# other methods:
# Blaker CI is exact but shorter
# than Clopper-Pearson, only two.sided

bgtCI(n=24,y=3,s=7, alternative="two.sided",
 method="Blaker")

# the asymptotic Wilson CI might even
# be shorter: 

bgtCI(n=24,y=3,s=7, alternative="two.sided",
 method="Score")

# one-sided confidence intervals:

bgtCI(n=24,y=3,s=7, alternative="less", method="CP")

# Wilson Score interval is less conservative 
bgtCI(n=24,y=3,s=7, alternative="less", method="Score")

# the second-order corrected CI is even shorter
# in this situation:
bgtCI(n=24,y=3,s=7, alternative="less", method="SOC")

</code></pre>

<hr>
<h2 id='bgtPower'>Power to Reject a Hypothesis in Binomial Group Testing for One Proportion</h2><span id='topic+bgtPower'></span><span id='topic+bgtPowerI'></span>

<h3>Description</h3>

<p>Closed calculation of the Power to reject a hypothesis in a binomial group testing 
experiment using confidence intervals for decision. Closed calculation of bias of the point estimator 
for a given experimental design n, s and the true, unknown proportion. </p>


<h3>Usage</h3>

<pre><code class='language-R'>bgtPower(n, s, delta, p.hyp, conf.level = 0.95,
 method = "CP", alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgtPower_+3A_n">n</code></td>
<td>
<p>integer, giving the number of groups i.e. assays i.e. observations, a vector of integers is also allowed </p>
</td></tr>
<tr><td><code id="bgtPower_+3A_s">s</code></td>
<td>
<p>integer, giving the common size of groups i.e. the number of individual units in each group, a vector of integers is also allowed  </p>
</td></tr>
<tr><td><code id="bgtPower_+3A_delta">delta</code></td>
<td>
<p>absolute difference between the threshold and the true proportion which shall be detectable with specified power, a vector is also allowed  </p>
</td></tr>
<tr><td><code id="bgtPower_+3A_p.hyp">p.hyp</code></td>
<td>
<p>number between 0 and 1, specifying the threshold proportion in the hypotheses </p>
</td></tr>
<tr><td><code id="bgtPower_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level required for the decision on the hypotheses </p>
</td></tr>
<tr><td><code id="bgtPower_+3A_method">method</code></td>
<td>
<p>character string, specifying the Confidence interval method (see <code><a href="#topic+bgtCI">bgtCI</a></code>) to be used </p>
</td></tr>
<tr><td><code id="bgtPower_+3A_alternative">alternative</code></td>
<td>
<p>character string, defining the alternative hypothesis, either 'two.sided', 'less' or 'greater'
where 'less' calculates the probability that <kbd>p.hyp</kbd> is excluded by an upper confidence limit for a true proportion p.hyp-delta,
'greater' calculates the probability that <kbd>p.hyp</kbd> is excluded by a lower confidence limit for a true proportion p.hyp+delta,
'two.sided' calculates min(power(p.hyp-delta, p.hyp+delta)) for a two-sided CI, thus can result in much lower power.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power of a confidence interval here is defined as the probability that a confidence interval or limit excludes the threshold parameter (p.hyp) of the null hypothesis, as described in Schaarschmidt(2007). 
I.e., the null hypothesis H0: p &gt;= p.hyp might be rejected, if an upper confidence limit for p does not contain p.hyp.
Due to discreteness, the power does not increase monotone for increasing  number of groups n or group size s, but exhibits local maxima and minima, depending on n,s, conf.level, p.hyp.
The power can be identical for different methods, depending on the particular combination of n, s, p.hyp, conf.level.
Note that coverage probability and power are not necessarily symmetric for upper and lower bounds of binomial CI, 
especially for Wald, Wilson Score and Agresti-Coull CI.
</p>
<p>Additional to the power, bias of the point estimator is calculated according to Swallow (1985).
</p>
<p>If vectors are specified for n, s, and (or) delta, a matrix will be constructed and power and bias are calculated for each line in this matrix. 
</p>


<h3>Value</h3>

<p>A matrix containing the columns
</p>
<table>
<tr><td><code>ns</code></td>
<td>
<p>a vector of total sample size n*s resulting from the latter</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a vector of number of groups</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>a vector of group sizes</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>a vector of delta</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p> the power to reject the given null hypothesis, with the specified method and parameters of the first 4 columns</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>the bias of the estimator for the specified n, s, and the true proportion</p>
</td></tr>
</table>


<h3>References</h3>

<p><em>Schaarschmidt F (2007).</em> Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing. Communications in Biometry and Crop Science 2 (1), 32-40.
http://agrobiol.sggw.waw.pl/cbcs/
</p>
<p><em>Swallow WH (1985).</em> Group testing for estimating infection rates and probabilities of disease transmission. Phytopathology Vol.75, N.8, 882-889.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+nDesign">nDesign</a></code>:  stepwise increasing n (for a fixed group size s) until a certain power is reached within a restriction of bias of the estimator
<code><a href="#topic+sDesign">sDesign</a></code>:  stepwise increasing s (for a fixed number of groups) until a certain power is reached within a restriction of bias of the estimator 
<code><a href="#topic+estDesign">estDesign</a></code>: selection of an appropriate design to achieve minimal mean square error of the estimator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Calculate the power for the design
# in the example given in Tebbs and Bilder(2004):
# n=24 groups each containing 7 insects
# if the true proportion of virus vectors
# in the population would be 0.04 (4 percent),
# the power to reject H0: p&gt;=0.1 using an
# upper Clopper-Pearson ("CP") confidence interval
# can be calculated using the following call:

bgtPower(n=24, s=7, delta=0.06, p.hyp=0.1,
 conf.level=0.95, alternative="less", method="CP")


# c(), seq() or rep() might be used to explore development
# of power and bias for varying n, s, delta. How much can
# we decrease the number of groups (costly assays to be performed)
# by pooling the same number of 320 individuals to groups of
# increasing size without largely decreasing power?

bgtPower(n=c(320,160,80,64,40,32,20,10,5),
 s=c(1,2,4,5,8,10,16,32,64),
 delta=0.01, p.hyp=0.02)


# How does power develop for increasing differences
# delta between the true proportion and the threshold proportion?

bgtPower(n=50, s=10, delta=seq(from=0, to=0.01, by=0.001),
 p.hyp=0.01, method="CP")


# use a more liberal method:

bgtPower(n=50, s=10, delta=seq(from=0, to=0.01, by=0.001),
 p.hyp=0.01, method="SOC")

</code></pre>

<hr>
<h2 id='bgtTest'> Hypothesis Test for One Proportion in Binomial Group Testing </h2><span id='topic+bgtTest'></span>

<h3>Description</h3>

<p> Calculates p values for hypotheses tests of binomial proportions 
estimated from binomial group testing experiments against a threshold proportion
in the hypotheses. Exact test, Score test and Wald test are available methods. 
Assumes equal group sizes, 100 percent sensitivity and specificity of the assays to test the groups,
and individuals units randomly assigned to the groups with identical true probability of success.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgtTest(n, y, s, p.hyp, alternative = "two.sided",
 method = "Exact")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgtTest_+3A_n">n</code></td>
<td>
<p>integer, number of  groups (i.e. assays i.e. observations)</p>
</td></tr>
<tr><td><code id="bgtTest_+3A_y">y</code></td>
<td>
<p>integer, number of positive groups </p>
</td></tr>
<tr><td><code id="bgtTest_+3A_s">s</code></td>
<td>
<p>integer, common size of groups i.e. the number of individual units in each group</p>
</td></tr>
<tr><td><code id="bgtTest_+3A_p.hyp">p.hyp</code></td>
<td>
<p>number between 0 and 1, specifying the hypothetical threshold proportion to test against</p>
</td></tr>
<tr><td><code id="bgtTest_+3A_alternative">alternative</code></td>
<td>
<p> character string defining the alternative hypothesis, either 'two.sided', 'less' or 'greater' </p>
</td></tr>
<tr><td><code id="bgtTest_+3A_method">method</code></td>
<td>
<p> character string defining the test method to be used:
can be one of 'Exact' for an exact test corresponding to the Clopper-Pearson confidence interval
'Score' for a Score test, corresponding to the Wilson confidence interval
'Wald' for a Wald test corresponding to the Wald confidence interval, not recommended</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>the p value of the test</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated proportion</p>
</td></tr>
<tr><td><code>p.hyp</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>as input</p>
</td></tr>
</table>


<h3>References</h3>

 
<p><em>Swallow WH (1985)</em> Group testing for estimating infection rates and probabilities of disease transmission. <em>Phytopathology 75 (8), 882-889.</em>
</p>
<p><em>Blyth, C and Still, H. (1983)</em> Binomial confidence intervals. <em>Journal of the American Statistical Association 78, 108-116.</em>
</p>
<p><em>Santner TJ and Duffy DE (1989)</em> The statistical analysis of discrete data. Springer New York.
</p>
<p><em>Remund KM, Dixon DA, Wright DL, Holden LR (2001)</em> Statistical considerations on seed purity testing on transgenic traits. <em>Seed Science Research (11), 101-119.</em>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bgtCI">bgtCI</a></code> for confidence intervals in binomial group testing</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Assume the experiment: Assays are performed on
# n=10 groups, each group is a bulk sample
# of s=100 individuals, aim is to show that 
# less than 0.5 percent ('p&lt;0.005') of the units
# of the population show a detrimental trait (positive assay).
# The assay is senstive to show a positive result if only 1
# unit in the bulk sample of 100 units is positive.
# y=1 positive assay and 9 negative assays are observed.

bgtTest(n=10,y=1,s=100,alternative="less",method="Exact",p.hyp=0.005)

# The exact test corresponds to the 
# limits of the Clopper-Pearson confidence interval
# in the example of Tebbs and Bilder(2004):

bgtTest(n=24, y=3, s=7, alternative="two.sided",
 method="Exact", p.hyp=0.0543)

bgtTest(n=24, y=3, s=7, alternative="two.sided",
 method="Exact", p.hyp=0.0038)

# Further methods:

bgtTest(n=24, y=3, s=7, alternative="two.sided",
 method="Score", p.hyp=0.0516)

bgtTest(n=24, y=3, s=7, alternative="two.sided",
 method="Wald", p.hyp=0.0401)
</code></pre>

<hr>
<h2 id='bgtvs'> Confidence Interval for One Proportion in Group Testing with Variable Group Sizes </h2><span id='topic+bgtvs'></span>

<h3>Description</h3>

<p>Calculates confidence intervals for a single proportion in binomial group testing
if groups of different size are evaluated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgtvs(n, s, y, conf.level = 0.95, alternative = "two.sided",
 maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgtvs_+3A_n">n</code></td>
<td>
<p>vector of integer values, specifying the number of groups of the different sizes </p>
</td></tr>
<tr><td><code id="bgtvs_+3A_s">s</code></td>
<td>
<p>vector of integer values, specifying the group sizes, must be of same length as <code>n</code> </p>
</td></tr>
<tr><td><code id="bgtvs_+3A_y">y</code></td>
<td>
<p>vector of integer values, specifying the number of positive groups among the <code>n</code> groups tested</p>
</td></tr>
<tr><td><code id="bgtvs_+3A_conf.level">conf.level</code></td>
<td>
<p>a single numeric value, the confidence level of the interval </p>
</td></tr>
<tr><td><code id="bgtvs_+3A_alternative">alternative</code></td>
<td>
<p>a character string, with options &quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot; </p>
</td></tr>
<tr><td><code id="bgtvs_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number steps in iteration of confidence limits </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hepworth (1996) describes methods for constructing confidence intervals in binomial group testing,
if groups of different size are used. Currently, only the exact method (Hepworth, 1996, equation5, Table.5)
is implemented. Note, that the algorithm becomes computationally very expensive if the number of different
groups becomes larger than 3.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>conf.int</code></td>
<td>
<p>a numeric vector, the lower and upper limits of the confidence interval</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the point estimate</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>as imput</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>a matrix containing the input values of n (number of groups), s (group size), and y (number of positive pools)</p>
</td></tr>
</table>
<p>moreover, some of the input arguments.
</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

 <p><em>Hepworth, G (1996):</em> Exact confidence intervals for proportions estimated by group testing. <em>Biometrics 52, 1134-1146.</em>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pooledBin">pooledBin</a></code> for asymptotic methods to calculate confidence intervals for one proportion in designs with a number of different pool sizes. Note that <code>pooledBin</code> can handle larger number of different pool sizes than <code>bgtvs</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider a very simple example,
# given in Hepworth (1996), table 5:
# 2 groups each containing 5 units,
# and 3 groups, each containing 2 units

# In the first setting (n=2, s=5) y=1 positive group 
# has been observed, in the second setting (n=3, s=2),
# y=2 positive have been observed.

bgtvs(n=c(2,3), s=c(5,2), y=c(1,2)) 

###############################################

# Recalculate the example given in
# Hepworth (1996), table 5:

 bgtvs(n=c(2,3), s=c(5,2), y=c(0,0))
 bgtvs(n=c(2,3), s=c(5,2), y=c(0,1))
 bgtvs(n=c(2,3), s=c(5,2), y=c(0,2))
 bgtvs(n=c(2,3), s=c(5,2), y=c(0,3))
 bgtvs(n=c(2,3), s=c(5,2), y=c(1,0))
 bgtvs(n=c(2,3), s=c(5,2), y=c(1,1))
 bgtvs(n=c(2,3), s=c(5,2), y=c(1,2))
 bgtvs(n=c(2,3), s=c(5,2), y=c(1,3))
 bgtvs(n=c(2,3), s=c(5,2), y=c(2,0))
 bgtvs(n=c(2,3), s=c(5,2), y=c(2,1))
 bgtvs(n=c(2,3), s=c(5,2), y=c(2,2))
 bgtvs(n=c(2,3), s=c(5,2), y=c(2,3))

</code></pre>

<hr>
<h2 id='bgtWidth'> Expected Width of Confidence Intervals in Binomial Group Testing </h2><span id='topic+bgtWidth'></span><span id='topic+bgtWidthI'></span>

<h3>Description</h3>

<p> Calculation of expected value of the width of confidence intervals for one proportion in binomial group testing,
in dependence of the number of groups, group size, confidence level and an assumed true proportion.
Available for the confidence interval methods in bgtCI(binGroup).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgtWidth(n, s, p, conf.level = 0.95, alternative = "two.sided",
 method = "CP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgtWidth_+3A_n">n</code></td>
<td>
<p> integer, giving the number of groups i.e. assays i.e. observations, vector of integers is also allowed</p>
</td></tr>
<tr><td><code id="bgtWidth_+3A_s">s</code></td>
<td>
<p> integer, giving the common size of groups i.e. the number of individual units in each group, vector of integers is also allowed </p>
</td></tr>
<tr><td><code id="bgtWidth_+3A_p">p</code></td>
<td>
<p> assumed true proportion of individuals showing the trait to be estimated, vector is also allowed </p>
</td></tr>
<tr><td><code id="bgtWidth_+3A_conf.level">conf.level</code></td>
<td>
<p> required confidence level of the interval </p>
</td></tr>
<tr><td><code id="bgtWidth_+3A_alternative">alternative</code></td>
<td>
<p> character string, defining the alternative hypothesis, either 'two.sided', 'less' or 'greater'
where 'less' calculates the expected width between the assumed true proportion p and the upper conf.level*100 percent-bound of a one-sided CI,
'greater' calculates the expected width between the true assumed proportion p and the lower conf.level*100 percent-bound of a one-sided CI,
'two.sided' calculates the expected width between the lower and the upper bound of a two-sided conf.level*100 percent-CI.</p>
</td></tr>
<tr><td><code id="bgtWidth_+3A_method">method</code></td>
<td>
<p> character string as in the method argumnet in <code><a href="#topic+bgtCI">bgtCI</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For calculation of expected interval width in the standard binomial estimation see, e.g., Brown et al. (2001).
The calculation in case of binomial group testing is simply done by replacing the binomial probabilities by the
probabilities P(Y=y) for group testing (see Tebbs and Bilder, 2004)  
</p>


<h3>Value</h3>

<p> A matrix containing the columns
</p>
<table>
<tr><td><code>ns</code></td>
<td>
<p>the resulting total number of units n*s</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of groups</p>
</td></tr> 
<tr><td><code>s</code></td>
<td>
<p>group size</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the assumed true proportion </p>
</td></tr>
</table>
<p>and the calculated 
</p>
<table>
<tr><td><code>expCIWidth</code></td>
<td>
<p>expected value of CI width as defined under argument alternative</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

<p><em>Brown LD, Cai TT, DasGupta A (2001)</em> Interval estimation for a binomial proportion. <em>Statistical Science 16 (2), 101-133.</em>
</p>
<p><em>Schaarschmidt F (2007)</em> Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing. <em>Communications in Biometry and Crop Science 2 (1), 32-40.</em>
http://agrobiol.sggw.waw.pl/cbcs/
</p>
<p><em>Tebbs JM &amp; Bilder CR (2004)</em> Confidence interval procedures for the probability of disease transmission in multiple-vector-transfer designs. <em>Journal of Agricultural, Biological and Environmental Statistics 9 (1), 75-90.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# There is a minimal expected CI length, if 
# group size s is increased (fixed other parameters)
# the corresponding group size might be chosen:

bgtWidth(n=20, s=seq(from=1, to=200, by=10),
 p=0.01, alternative="less", method="CP" )

# and this depends largely on the assumed proportion p: 

bgtWidth(n=20, s=seq(from=1, to=200, by=10),
 p=0.05, alternative="less", method="CP" )

bgtWidth(n=20, s=seq(from=1, to=200, by=10),
 p=0.005, alternative="less", method="CP" )
</code></pre>

<hr>
<h2 id='binCI'> Confidence Intervals for One Binomial Proportion </h2><span id='topic+binCI'></span><span id='topic+binCP'></span><span id='topic+binBlaker'></span><span id='topic+binSOC'></span><span id='topic+binAC'></span><span id='topic+binWilson'></span><span id='topic+binWald'></span>

<h3>Description</h3>

<p>Calculates the exact Clopper-Pearson and Blaker, the asymptotic second-order corrected,
Wilson, Agresti-Coull and Wald confidence interval for a single binomial proportion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binCI(n, y, conf.level = 0.95, alternative = "two.sided",
 method = "CP")

binCP(n, y, conf.level=0.95, alternative="two.sided")
binBlaker(n,y,conf.level=0.95, tolerance=1e-04, alternative="two.sided")
binAC(n, y, conf.level=0.95, alternative="two.sided")
binSOC(n, y,conf.level=0.95,alternative="two.sided")
binWald(n, y, conf.level=0.95, alternative="two.sided")
binWilson(n, y,conf.level=0.95,alternative="two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binCI_+3A_n">n</code></td>
<td>
<p> number of trials (number of individuals under observation) </p>
</td></tr>
<tr><td><code id="binCI_+3A_y">y</code></td>
<td>
<p> number of successes (number of individuals showing the trait of interest) </p>
</td></tr>
<tr><td><code id="binCI_+3A_conf.level">conf.level</code></td>
<td>
<p> nominal confidence level </p>
</td></tr>
<tr><td><code id="binCI_+3A_alternative">alternative</code></td>
<td>
<p> character string defining the alternative hypothesis, either 'two.sided', 'less' or 'greater'
where 'less' gives the only an upper bound with confidence level=conf.level
'greater' gives the only a lower bound with confidence level=conf.level
and 'two.sided' gives a two-sided confidence interval with confidence level=conf.level </p>
</td></tr>
<tr><td><code id="binCI_+3A_method">method</code></td>
<td>
<p>character string defining the method for CI calculation:
where &quot;CP&quot; is Clopper-Pearson, an exact tail interval showing symmetric coverage probability (inversion of two one-sided tests),
&quot;Blaker&quot; is the Blaker interval, an exact interval, inversion of one two.sided test, therefore defined only two.sided, but shorter
than the two-sided Clopper-Pearson CI. Both guarantee to contain the true parameter with at least conf.level*100 percent
probability,
&quot;AC&quot; is Agresti-Coull, generalized Agresti-Coull interval, asymptotic method,
&quot;Score&quot; is Wilson Score, asymptotic method derived from inversion of the Score test,
&quot;SOC&quot; is the second order corrected interval, asymptotic method for one-sided problems (for details see Cai, 2005),
and &quot;Wald&quot; the Wald interval, which cannot be recommended.</p>
</td></tr>
<tr><td><code id="binCI_+3A_tolerance">tolerance</code></td>
<td>
<p>precision of computation for the bounds of the Blaker interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows computation of confidence intervals for a binomial proportion from a standard binomial experiment.
If an actual confidence level greater or equal to that specified in the conf.level argument shall always be guaranteed, the exact method of 
Clopper-Pearson (method=&quot;CP&quot;) can be recommended for one-sided and the improved method of Blaker (method=&quot;Blaker&quot;) can be recommended for two-sided
hypotheses. If a mean confidence level close to that specified in the argument conf.level is required, but moderate violation of this level is acceptable,
the Second-Order corrected (method=&quot;SOC&quot;), Wilson Score (method=&quot;Wilson&quot;) or Agresti-Coull (method=&quot;AC&quot;) might be used, where SOC has the most symmetric
coverage and Wilson and Agresti-Coull are in tendency conservative for the upper bound and proportions close to 0 and for the lower bound and proportions
close to 1. The Wald CI might be used for large number of observations n&gt;10000 or intermediate proportions.
</p>
<p>For discussion of CI for a single binomial proportion see Brown et al. (2001) for two-sided and Cai (2005) for one-sided intervals.
</p>


<h3>Value</h3>

<p> A list containing:
</p>
<table>
<tr><td><code>conf.int</code></td>
<td>
<p>the estimated confidence interval</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the point estimator</p>
</td></tr>
</table>
<p>And the method, conf.level and alternative specified in the function call.
</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

 
<p><em>Blaker H (2000)</em> Confidence curves and improved exact confidence intervals for discrete distributions. <em>The Canadian Journal of Statistics 28 (4), 783-798.</em>
</p>
<p><em>Brown LD, Cai TT, DasGupta A (2001)</em> Interval estimation for a binomial proportion. <em>Statistical Science 16 (2), 101-133.</em>
</p>
<p><em>Cai TT(2005)</em> One-sided confidence intervals in discrete distributions. <em>Journal of Statistical Planning and Inference 131, 63-88.</em>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+binom.test">binom.test</a></code> for the exact confidence interval and test,
<code><a href="#topic+binTest">binTest</a></code> to calculate p.values of the exact, Score and Wald test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Default method is the two-sided 95% Clopper-Pearson CI:

binCI(n=200, y=10)

# other methods might result in 
# shorter intervals (but asymetric coverage):

binCI(n=200,y=10, method="Blaker")
binCI(n=200,y=10, method="Score")

</code></pre>

<hr>
<h2 id='binDesign'>Sample Size Iteration for One Parameter Binomial Problem</h2><span id='topic+binDesign'></span>

<h3>Description</h3>

<p>This function increases the sample size until a maximal sample size or a prespecified power is achieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binDesign(nmax, delta, p.hyp, conf.level = 0.95,
 power = 0.8, method = "CP", alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binDesign_+3A_nmax">nmax</code></td>
<td>
<p> integer, maximal number of trials (individuals under observation) allowed in the iteration </p>
</td></tr>
<tr><td><code id="binDesign_+3A_delta">delta</code></td>
<td>
<p> absolute difference between the threshold and the true proportion which shall be detectable with the specified power </p>
</td></tr>
<tr><td><code id="binDesign_+3A_p.hyp">p.hyp</code></td>
<td>
<p> threshold proportion to test against in the hypothesis, specify as a value between 0 and 1 </p>
</td></tr>
<tr><td><code id="binDesign_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level of the decision, default is 0.95 </p>
</td></tr>
<tr><td><code id="binDesign_+3A_power">power</code></td>
<td>
<p> Level of power to be achieved to be specified as a probability between 0 and 1 </p>
</td></tr>
<tr><td><code id="binDesign_+3A_method">method</code></td>
<td>
<p> character string specifying the CImethod to be used for evaluation, see argument method in bgtCI </p>
</td></tr>
<tr><td><code id="binDesign_+3A_alternative">alternative</code></td>
<td>
<p> character string, defining the alternative hypothesis, either <kbd>'two.sided'</kbd>, <kbd>'less'</kbd> or <kbd>'greater'</kbd>
where <kbd>'less'</kbd> calculates the probability that p.hyp is excluded by an upper confidence limit given that the true proportion is p.hyp-delta,
<kbd>'greater'</kbd> calculates the probability that p.hyp is excluded by a lower confidence limit given that the true proportion is p.hyp+delta.
<kbd>'two.sided'</kbd> calculates min(power(p.hyp-delta, p.hyp+delta)) for a two-sided CI, thus can result in much lower power.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power of a confidence interval here is defined as the probability that a confidence interval or limit excludes the threshold parameter (<kbd>p.hyp</kbd>) of the hypothesis. 
</p>
<p>This function increases the number of trials (number of individuals under observation) until a pre-specified power is reached.
Since the power does not increase monotone with increasing n for binomial proportions but oscillates between local maxima and minima, 
the simple iteration given here will generally result in selecting those n, for which the given CI method shows a local minimum of 
coverage if the null hypothesis is true. The power can be identical for different methods, depending on the particular combination of n, p.hyp, conf.level.
</p>
<p>Especially for large n, the calculation time may become large (particularly for Blaker). Then only the range of sample size which is of interest
can be specified in nmax, f.e. as: nmax=c(150,300). Alternatively, the function binPower might be used instead
to calculate power and bias only for some particular combinations of n, delta, p.hyp,... . 
</p>
<p>Note that coverage probability and power are not necessarily symmetric for upper and lower bound of binomial CI.
</p>
<p>The results can be visualized by application of the function plot() to the returned object of this function.
</p>


<h3>Value</h3>

<p>a list 
</p>
<table>
<tr><td><code>powerout</code></td>
<td>
<p> power value, either the power of the first n exceeding the pre-specified power,
or the maximal power achieved in the specified range of n if the specified power has not been reached</p>
</td></tr>
<tr><td><code>nout</code></td>
<td>
<p>corresponding sample size n (the number of trials) for which the prespecified power is reached,
or the sample size n for which the maximal power has been reached within the specified range,
if pre-specified power has not been reached.</p>
</td></tr>
</table>
<p>and additional input and iteration values needed only for the function plot.binDesign. 
</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

 
<p><em>Schaarschmidt, F. (2007).</em> Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing. <em>Communications in Biometry and Crop Science 2 (1), 32-40.</em>
http://agrobiol.sggw.waw.pl/cbcs/
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+binPower">binPower</a></code> for calculation of power, <code><a href="#topic+plot.binDesign">plot.binDesign</a></code> for plot of the results </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Find a sample size for which the power to
# reject H0: p &gt;= 0.1 in favor of HA: p &lt; 0.1 is
# at least 0.9 (90 percent) in case that the
# true proportion is 0.04 (i.e. an absolute delta 
# of 0.06 to the threshold proportion p.hyp=0.1)
# The exact one sided Clopper-Pearson CI shall be
# used with default confidence level = 0.95.


sasi&lt;-binDesign( nmax=200, delta=0.06,
 p.hyp=0.1, alternative="less", method="CP", power=0.9)
sasi

#### One can also plot the result:

 plot(sasi)


# For larger sample sizes iteration can be very time consuming.
# Better to use only a smaller range of n then:

sasi&lt;-binDesign( nmax=c(200,300), delta=0.03, p.hyp=0.1,
 alternative="less", method="CP", power=0.9)
sasi


</code></pre>

<hr>
<h2 id='binPower'>Power Calculation for One Parameter Binomial Problem</h2><span id='topic+binPower'></span><span id='topic+binPowerI'></span>

<h3>Description</h3>

<p>Closed calculation of the power to reject a hypothesis using confidence intervals for a single 
binomial proportion, for specified sample size n, conf.level and an assumed absolute difference to the
threshold parameter under the null hypothesis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binPower(n, delta, p.hyp, conf.level = 0.95, 
alternative = "two.sided", method = "CP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binPower_+3A_n">n</code></td>
<td>
<p>number of trials n in the binomial experiment, specify as a single integer  </p>
</td></tr>
<tr><td><code id="binPower_+3A_delta">delta</code></td>
<td>
<p>assumed absolute difference of the true proportion to the threshold proportion under the null hypothesis  </p>
</td></tr>
<tr><td><code id="binPower_+3A_p.hyp">p.hyp</code></td>
<td>
<p>threshold proportion under the null hypothesis </p>
</td></tr>
<tr><td><code id="binPower_+3A_conf.level">conf.level</code></td>
<td>
<p>nominal confidence level of the interval </p>
</td></tr>
<tr><td><code id="binPower_+3A_alternative">alternative</code></td>
<td>
<p>character string, defining the alternative hypothesis, either <kbd>'two.sided'</kbd>, <kbd>'less'</kbd> or <kbd>'greater'</kbd>
where <kbd>'less'</kbd> calculates the 'power of the upper confidence limit' for a true proportion <kbd>p.hyp</kbd> - <kbd>delta</kbd>,
<kbd>'greater'</kbd> calculates the 'power of the lower confidece limit' for a true proportion of <kbd>p.hyp</kbd> + <kbd>delta</kbd>.
<kbd>'two.sided'</kbd> calculates min(power(<kbd>p.hyp</kbd> - <kbd>delta</kbd>, <kbd>p.hyp</kbd> + <kbd>delta</kbd>)) for a two-sided CI, thus can result in much lower power.
</p>
</td></tr>
<tr><td><code id="binPower_+3A_method">method</code></td>
<td>
<p> Character string, specifying the confidence interval method (see <code><a href="#topic+binCI">binCI</a></code>) to be used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power of a confidence interval here is defined as the probability that a confidence interval or limit excludes the threshold parameter (<kbd>p.hyp</kbd>) of the null hypothesis. 
E.g., the null hypothesis H0: p&gt;= 0.005 can be rejected, if an upper confidence limit for p does not contain p.hyp=0.005.
In case that a delta of 0.002 shall be detectable, this function calculates the probability, that an interval of a given method will
exclude p.hyp=0.005 if the true proportion = 0.003.
Due to discreteness, the power does not increase monotone for increasing sample size (number of trials or indivoiduals under observation) n,
but exhibits local maxima and minima, depending on n, conf.level and p.hyp.
The power can be identical for different methods, depending on the particular combination of n, p.hyp, conf.level.
Note, that coverage probability and power are not necessarily symmetric for upper and lower bound of binomial CI, 
especially for Wald, Wilson Score and Agresti-Coull CI.
</p>


<h3>Value</h3>

<p> A list containing
</p>
<table>
<tr><td><code>power</code></td>
<td>
<p>the power which is achieved for the specified parameters and method</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+binDesign">binDesign</a></code> for iteration of a sample size n for which a specified power is reached  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# What is the probability to reject the null hypothesis
# H0: p &gt;= 0.02 in order to show that the alternative
# hypothesis HA: p &lt; 0.02 is very likely in the first
# example of if 200 seeds are taken from a seed lot and
# are checked for the proportion of defectives.
# Assume a true proportion under the alternative:
# p = 0.01, i.e. a absolute difference delta = 0.01 
# to the threshold proportion p.hyp=0.02.
# The null hypothesis can be rejected if the threshold
# p.hyp=0.02 is excluded by an 95 percent upper bound of the 
# Clopper-Pearson CI. What is the probability  of this event?

binPower(n=200, delta=0.01, p.hyp=0.02,
 alternative="less", method="CP")

# Assuming a lower true proportion (if one is satisfied
# also with the situation that we can only reject H0
# in case that the seed lot has a very high purity, e.g.
# only a proportion of 0.001 defectives )

binPower(n=200, delta=0.019, p.hyp=0.02,
 alternative="less", method="CP")

# Or use a higher sample size:

binPower(n=600, delta=0.01, p.hyp=0.02,
 alternative="less", method="CP")

</code></pre>

<hr>
<h2 id='binTest'> Hypothesis tests for One Binomial Proportion </h2><span id='topic+binTest'></span>

<h3>Description</h3>

<p>Calculates p-values for hypothesis tests of a single binomial proportion. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binTest(n, y, p.hyp, alternative = "two.sided",
 method = "Exact")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binTest_+3A_n">n</code></td>
<td>
<p>single integer value, number of trials (number of individuals under observation)</p>
</td></tr>
<tr><td><code id="binTest_+3A_y">y</code></td>
<td>
<p>single integer value, number of successes (number of individuals showing the trait of interest)</p>
</td></tr>
<tr><td><code id="binTest_+3A_p.hyp">p.hyp</code></td>
<td>
<p>single numeric value between 0 and 1, specifying the hypothetical threshold proportion to test against</p>
</td></tr>
<tr><td><code id="binTest_+3A_alternative">alternative</code></td>
<td>
<p> character string defining the alternative hypothesis, either 'two.sided', 'less' or 'greater' </p>
</td></tr>
<tr><td><code id="binTest_+3A_method">method</code></td>
<td>
<p>character string defining the test method to be used:
can be one of <kbd>"Exact"</kbd> for an exact test corresponding to the Clopper-Pearson confidence interval, uses <kbd>binom.test(stats)</kbd>
<kbd>"Score"</kbd> for a Score test, corresponding to the Wilson confidence interval
<kbd>"Wald"</kbd> for a Wald test corresponding to the Wald confidence interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>the p value of the test</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated proportion</p>
</td></tr>
<tr><td><code>p.hyp</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>as input</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

 <p><em>Santner, T.J. and Duffy, D.E. (1989)</em> The statistical analysis of discrete data. Springer Verlag New York Berlin Heidelberg. Chapter 2.1.  </p>


<h3>See Also</h3>

 <p><kbd>binom.test(stats)</kbd> for the exact test and corresponding confindence interval </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 200 seeds are taken from a seed lot.
# 2 are found to be defective.
# H0: p &gt;= 0.02  shall be rejected in favor of  HA: p &lt; 0.02.
# The exact test shall be used for decision:

binTest(n=200, y=2, p.hyp=0.02, alternative="less", method="Exact" )

</code></pre>

<hr>
<h2 id='binWidth'>Expected Confidence Interval Width for One Binomial Proportion </h2><span id='topic+binWidth'></span>

<h3>Description</h3>

<p>Calculation of expected value of the width of confidence intervals in a binomial experiment,
in dependence of the number of trials (number of individuals under observation),  confidence level and an assumed true proportion.
Available for the confidence interval methods in binCI(binGroup).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binWidth(n, p, conf.level = 0.95,
 alternative = "two.sided", method = "CP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binWidth_+3A_n">n</code></td>
<td>
<p> integer, giving the number of trials (i.e. number of individuals under observation) </p>
</td></tr>
<tr><td><code id="binWidth_+3A_p">p</code></td>
<td>
<p> assumed true proportion of individuals showing the trait to be estimated </p>
</td></tr>
<tr><td><code id="binWidth_+3A_conf.level">conf.level</code></td>
<td>
<p> required confidence level of the interval </p>
</td></tr>
<tr><td><code id="binWidth_+3A_alternative">alternative</code></td>
<td>
<p> character string, defining the alternative hypothesis, either 'two.sided', 'less' or 'greater'
where 'less' calculates the expected width between the assumed true proportion p and the upper conf.level*100 percent-bound of a one-sided CI,
'greater' calculates the expected width between the assumed true proportion p and the lower conf.level*100 percent-bound of a one-sided CI,
'two.sided' calculates the expected width between the lower and the upper bound of a two-sided conf.level*100 percent-CI.</p>
</td></tr>
<tr><td><code id="binWidth_+3A_method">method</code></td>
<td>
<p> character string defining the method for CI calculation:
where <kbd>"CP"</kbd> is Clopper-Pearson, an exact tail interval showing symmetric coverage probability (inversion of two one-sided tests),
<kbd>"Blaker"</kbd> is the Blaker interval, an exact interval, inversion of one two.sided test, therefore defined only two.sided, but shorter
than the two-sided Clopper-Pearson CI. Both guarantee to contain the true parameter with at least conf.level*100 percent
probability,
<kbd>"AC"</kbd> is Agresti-Coull, generalized Agresti-Coull interval, asymptotic method,
<kbd>"Score"</kbd> is Wilson Score, asymptotic method derived from inversion of the Score test,
<kbd>"SOC"</kbd> is the second order corrected interval, asymptotic method for one-sided problems (for details see Cai, 2005),
and <kbd>"Wald"</kbd> the simple Wald-type interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For calculation of expected interval width in the standard binomial estimation see Brown et al. (2001).
</p>


<h3>Value</h3>

<p> A list containing:
</p>
<table>
<tr><td><code>expCIWidth</code></td>
<td>
<p>the expected value of the width of the confidence interval for the specified arguments</p>
</td></tr>
</table>
<p>and the alternative, p and n which are specified in the function call.
</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+binDesign">binDesign</a></code> for experimental design for hypothesis testing </p>


<h3>Examples</h3>

<pre><code class='language-R'>

# methods differ slightly in length when sample sizes are large:

binWidth(n=200,p=0.02,alternative="two.sided",
 method="CP")$expCIWidth

binWidth(n=200,p=0.02,alternative="two.sided",
 method="Blaker")$expCIWidth

binWidth(n=200,p=0.02,alternative="two.sided",
 method="Score")$expCIWidth

# but do more for small sample sizes and intermediate p:

binWidth(n=20,p=0.2,alternative="two.sided",
 method="CP")$expCIWidth

binWidth(n=20,p=0.2,alternative="two.sided",
 method="Blaker")$expCIWidth

binWidth(n=20,p=0.2,alternative="two.sided",
 method="Score")$expCIWidth

</code></pre>

<hr>
<h2 id='characteristics.pool'>Testing expenditure for informative Dorfman testing</h2><span id='topic+characteristics.pool'></span>

<h3>Description</h3>

<p>Calculate the expectation and variation of the testing
expenditure of a pool used with informative Dorfman testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>characteristics.pool(p, se, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="characteristics.pool_+3A_p">p</code></td>
<td>
<p>a vector of each individual's probability of infection.</p>
</td></tr>
<tr><td><code id="characteristics.pool_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="characteristics.pool_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the expected value and variance
of the testing expenditure of a pool of size greater than or equal 
to one used with informative Dorfman testing. Calculations of these 
measures are done using the equations presented in McMahan et al. (2012).
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>e</code></td>
<td>
<p>the expected testing expenditure of the pool.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the variation of the testing expenditure of the pool.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher S. 
McMahan for McMahan et al. (2012). The function was obtained 
from <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>


<h3>See Also</h3>

<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Informative Dorfman functions: <code><a href="#topic+accuracy.dorf">accuracy.dorf</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>,
<code><a href="#topic+opt.info.dorf">opt.info.dorf</a></code>, <code><a href="#topic+opt.pool.size">opt.pool.size</a></code>,
<code><a href="#topic+pool.specific.dorf">pool.specific.dorf</a></code>,
<code><a href="#topic+thresh.val.dorf">thresh.val.dorf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8135)
p.vec &lt;- p.vec.func(p=0.02, alpha=1, grp.sz=10)
characteristics.pool(p=p.vec[1:3], se=0.90, sp=0.90)
</code></pre>

<hr>
<h2 id='estDesign'>Sample Size Iteration Depending on Minimal MSE in One-Parameter Group Testing</h2><span id='topic+estDesign'></span><span id='topic+msep'></span>

<h3>Description</h3>

<p>Find the group size s for a fixed number of assays n and an assumed true proportion p.tr for which
the mean squared error (mse) of the point estimator is minimal and bias is within a restriction. For experimental design in binomial group testing
as recommended by Swallow (1985), if main objective is estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estDesign(n, smax, p.tr, biasrest = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estDesign_+3A_n">n</code></td>
<td>
<p> integer, fixed sample size (number of assays) </p>
</td></tr>
<tr><td><code id="estDesign_+3A_smax">smax</code></td>
<td>
<p> integer, maximal group size allowed in planning of the design </p>
</td></tr>
<tr><td><code id="estDesign_+3A_p.tr">p.tr</code></td>
<td>
<p> assumed true proportion of the 'positive' trait in the population to be tested, specify as a value between 0 and 1 </p>
</td></tr>
<tr><td><code id="estDesign_+3A_biasrest">biasrest</code></td>
<td>
<p> value between 0 and 1 specifying the absolute bias maximally allowed </p>
</td></tr>
</table>


<h3>Details</h3>

<p> Swallow (1985) recommends to use the upper bound of the expected range of true proportion p.tr for optimization of tzhe design.
For further details see the reference.
Up to now, specify n&lt;1020.
</p>


<h3>Value</h3>

<p>the group size s, for which the mse of the estimator is minimal for the given n, p.tr
or the group size s for which bias restriction biasrest is just not violated,
and for this particular group size s: a list containing:
</p>
<table>
<tr><td><code>varp</code></td>
<td>
<p>the variance of the estimator </p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>the mean square error of the estimator </p>
</td></tr> 
<tr><td><code>bias</code></td>
<td>
<p>the bias of the estimator </p>
</td></tr>
<tr><td><code>exp</code></td>
<td>
<p>the expected value of the estimator </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

 <p><em>Swallow WH (1985)</em> Group testing for estimating infection rates and probabilities of disease transmission. Phytopathology Vol.75, N.8, 882-889.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nDesign">nDesign</a></code>, <code><a href="#topic+sDesign">sDesign</a></code> for choice of the binomial group testing design according to the power in a hypothesis test </p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Compare table 1 in Swallow(1985),885:

estDesign(n=10, smax=100, p.tr=0.001)

estDesign(n=10, smax=100, p.tr=0.01)

estDesign(n=25, smax=100, p.tr=0.05)

estDesign(n=40, smax=100, p.tr=0.25)

estDesign(n=200, smax=100, p.tr=0.3)


</code></pre>

<hr>
<h2 id='gt.control'>
Auxiliary for Controlling Group Testing Regression
</h2><span id='topic+gt.control'></span>

<h3>Description</h3>

<p>Auxiliary function to control fitting parameters of EM algorithm used internally in <code><a href="#topic+gtreg.mp">gtreg.mp</a></code> and <code><a href="#topic+EM.mp">EM.mp</a></code> or <code><a href="#topic+gtreg">gtreg</a></code>, <code><a href="#topic+EM">EM</a></code>, and <code><a href="#topic+EM.ret">EM.ret</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
gt.control(tol = 0.0001, n.gibbs = 1000, n.burnin = 20,
 maxit = 500, trace = FALSE, time = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gt.control_+3A_tol">tol</code></td>
<td>

<p>convergence criterion 
</p>
</td></tr>
<tr><td><code id="gt.control_+3A_n.gibbs">n.gibbs</code></td>
<td>

<p>the Gibbs sample size to be used in each E step for the EM algorithm (default is 1000), for matrix pooling
</p>
</td></tr>
<tr><td><code id="gt.control_+3A_n.burnin">n.burnin</code></td>
<td>

<p>the number of samples in the burn-in period (default is 20), for matrix pooling
</p>
</td></tr>
<tr><td><code id="gt.control_+3A_maxit">maxit</code></td>
<td>

<p>maximal number of iterations in the EM algorithm
</p>
</td></tr>
<tr><td><code id="gt.control_+3A_trace">trace</code></td>
<td>

<p>logical indicating if output should be printed for each iteration, defaults to <kbd>FALSE</kbd>
</p>
</td></tr>
<tr><td><code id="gt.control_+3A_time">time</code></td>
<td>

<p>logical indicating if the length of time for the model fitting should be printed, defaults to <kbd>TRUE</kbd></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components named as the arguments</p>


<h3>Examples</h3>

<pre><code class='language-R'># The default settings:
gt.control()

</code></pre>

<hr>
<h2 id='gtreg'>
Fitting Group Testing Models
</h2><span id='topic+gtreg'></span><span id='topic+gtreg.fit'></span><span id='topic+EM'></span><span id='topic+EM.ret'></span>

<h3>Description</h3>

<p><kbd>gtreg</kbd> is a function to fit the group testing regression model specified through a symbolic description of the linear predictor and descriptions of the group testing setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtreg(formula, data, groupn, retest = NULL, sens = 1,
 spec = 1, linkf = c("logit", "probit", "cloglog"),
 method = c("Vansteelandt", "Xie"), sens.ind = NULL,
 spec.ind = NULL, start = NULL, control = gt.control(...), ...)

gtreg.fit(Y, X, groupn, sens, spec, linkf, start=NULL)

EM(Y, X, groupn, sens, spec, linkf, start = NULL,
 control = gt.control())

EM.ret(Y, X, groupn, ret, sens, spec, linkf, sens.ind,
 spec.ind, start = NULL, control = gt.control())

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtreg_+3A_formula">formula</code></td>
<td>

<p>an object of class <kbd>"formula"</kbd> (or one that can be coerced to that class): a symbolic description of 
the model to be fitted. The details of model specification are given under 'Details'.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by <kbd>as.data.frame</kbd> to a data 
frame) containing the variables in the model. If not found in data, the variables are taken from 
<kbd>environment(formula)</kbd>, typically the environment from which <kbd>gtreg</kbd> is called.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_groupn">groupn</code></td>
<td>

<p>a vector, list or data frame of the group numbers that designates individuals to groups.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_retest">retest</code></td>
<td>

<p>a vector, list or data frame of individual retest results for Dorfman's retesting procedure. Default value is <kbd>NULL</kbd> for no retests. See 'Details' for how to code it.
</p>
</td></tr>  
<tr><td><code id="gtreg_+3A_sens">sens</code></td>
<td>

<p>sensitivity of the test, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_spec">spec</code></td>
<td>

<p>specificity of the test, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_sens.ind">sens.ind</code></td>
<td>

<p>sensitivity of the individual retests, set to be equal to <kbd>sens</kbd> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_spec.ind">spec.ind</code></td>
<td>

<p>specificity of the individual retests, set to be equal to <kbd>spec</kbd> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_linkf">linkf</code></td>
<td>

<p>a character string specifying one of the three link functions for a binomial model: <kbd>"logit"</kbd> 
(default) or <kbd>"probit"</kbd> or <kbd>"cloglog"</kbd>.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_method">method</code></td>
<td>

<p>The method to fit the model, must be one of <kbd>"Vansteelandt"</kbd> (default) or <kbd>"Xie"</kbd>. The option 
<kbd>"Vansteelandt"</kbd> finds estimates by directly maximizing the likelihood function based on the group responses while the option <kbd>"Xie"</kbd> uses the EM algorithm to maximize the likelihood function in terms of the unobserved individual responses.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_start">start</code></td>
<td>

<p>starting values for the parameters in the linear predictor.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_control">control</code></td>
<td>

<p>a list of parameters for controlling the fitting process in method <kbd>"Xie"</kbd>. See the documentation for <code><a href="#topic+gt.control">gt.control</a></code> for details.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_y">Y</code></td>
<td>

<p>For <kbd>gtreg.fit</kbd>, <kbd>EM</kbd> and <kbd>EM.ret</kbd>: the vector of the group responses.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_x">X</code></td>
<td>

<p>For <kbd>gtreg.fit</kbd>, <kbd>EM</kbd> and <kbd>EM.ret</kbd>: the design matrix of the covariates.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_ret">ret</code></td>
<td>

<p>For <kbd>EM.ret</kbd>: a vector containing individual retest results.
</p>
</td></tr>
<tr><td><code id="gtreg_+3A_...">...</code></td>
<td>
<p>arguments to be passed by default to <code><a href="#topic+gt.control">gt.control</a></code>: see argument <kbd>control</kbd> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical predictor has the form <kbd>groupresp ~ covariates</kbd> where response is the (numeric) group response vector and <kbd>covariates</kbd> is a series of terms which specifies a linear predictor for individual responses. Note that it is actually the unobserved individual responses, not the observed group responses, which are modeled by the covariates here. In <kbd>groupresp</kbd>, a 0 denotes a negative response and a 1 denotes a positive response, where the probability of an individual positive response is being modeled directly.  A terms specification of the form <kbd>first + second</kbd> indicates all the terms in <kbd>first</kbd> together with all the terms in <kbd>second</kbd> with duplicates removed. The <kbd>terms</kbd> in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on; to avoid this pass a terms object as the formula.
</p>
<p>A specification of the form <kbd>first:second</kbd> indicates the set of terms obtained by taking the interactions of all terms in <kbd>first</kbd> with all terms in <kbd>second</kbd>. The specification <kbd>first*second</kbd> indicates the cross of <kbd>first</kbd> and <kbd>second</kbd>. This is the same as <kbd>first + second + first:second</kbd>. 
</p>
<p>Three workhorse functions <kbd>gtreg.fit</kbd>, <kbd>EM</kbd> and <kbd>EM.ret</kbd>, where the first corresponds to Vansteelandt's method and the last two corresponds to Xie's method, are called by <kbd>gtreg</kbd> to carry out the model fitting. The <kbd>gtreg.fit</kbd> function uses the <kbd>optim</kbd> function with default method <kbd>"Nelder-Mead"</kbd> to maximize the likelihood function of the observed group responses. If this optimization method produces a Hessian matrix of all zero elements, the <kbd>"SANN"</kbd> method in <kbd>optim</kbd> is employed to find the coefficients and Hessian matrix. For <kbd>"SANN"</kbd> method, the number of iterations in <kbd>optim</kbd> is set to be 10000.
</p>
<p>The <kbd>EM</kbd> and <kbd>EM.ret</kbd> function apply Xie's EM algorithm to the likelihood function written in terms of the unobserved individual responses; the functions use <kbd>glm.fit</kbd> to update the parameter estimates within each M step. The <kbd>EM</kbd> function is used when there are no retests and <kbd>EM.ret</kbd> is used when individual retests are available. Thus, within <kbd>retest</kbd>, individual observations in observed positive groups are 0 (negative) or 1 (positive); the remaining individual observations are <kbd>NA</kbd>s meaning that no retest is performed for them. Retests cannot be used with Vansteelandt's method; a warning message will be given in this case, and the individual retests will be ignored in the model fitting. There could be slight differences in the estimates between the Vansteelandt's and Xie's methods (when retests are not available) due to different convergence criteria. 
</p>
<p>The data used here should be in the form of simple pooling - meaning that each individual appears in exactly one pool. When only the group responses are observed, the null degrees of freedom are the number of groups minus 1 and the residual degrees of freedom are the number of groups minus the number of parameters. When individual retests are observed too, it is an open research question for what the degrees of freedom and the deviance for the null model should
be; therefore the degrees of freedom and <kbd>null.deviance</kbd> will not be displayed.
</p>
<p>For the background on the use of <kbd>optim</kbd>, see <kbd>help(optim)</kbd>.
</p>


<h3>Value</h3>

<p><kbd>gtreg</kbd> returns an object of class <kbd>"gt"</kbd>. See later in this section. 
The function <kbd>summary</kbd> (i.e., <code><a href="#topic+summary.gt">summary.gt</a></code>) can be used to obtain or print a summary of the results. 
The group testing functions <kbd>predict</kbd> (i.e., <code><a href="#topic+predict.gt">predict.gt</a></code>) and <kbd>residuals</kbd> (i.e., <code><a href="#topic+residuals.gt">residuals.gt</a></code>) can be used to extract various useful features of the value returned by <kbd>gtreg</kbd>. 
An object of class <kbd>"gt"</kbd> is a list containing at least the following components: 
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector of coefficients </p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> estimated Hessian matrix of the negative log likelihood function, serves as an estimate of the information matrix </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> the response residuals, difference of the observed group responses and the fitted group responses. </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> the fitted mean values of group responses. </p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> the deviance between the fitted model and the saturated model. </p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p> Akaike's An Information Criterion, minus twice the maximized log-likelihood plus twice the number of coefficients </p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p> The deviance for the null model, comparable with <kbd>deviance</kbd>. The null model will include only the intercept if there is one in the model. </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> For Vansteelandt's method: the number of iterations in <kbd>optim</kbd>; For Xie's method: the number of iterations in the EM algorithm.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p> the residual degrees of freedom. </p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p> the residual degrees of freedom for the null model. </p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p> the vector of group responses. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> the formula supplied. </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> the terms object used. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> the method (<kbd>"Vansteelandt"</kbd> or <kbd>"Xie"</kbd>) used to fit the model. </p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p> the link function used in the model. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>References</h3>

<p><em>Xie, M. (2001)</em>, Regression analysis of group testing samples, <em>Statistics in Medicine, 20, 1957-1969.</em>
</p>
<p><em>Vansteelandt, S., Goetghebeur, E., and Verstraeten, T. (2000)</em>, Regression models for disease prevalence with diagnostic tests on pools of serum samples, <em>Biometrics, 56, 1126-1133.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.gt">summary.gt</a></code>, <code><a href="#topic+predict.gt">predict.gt</a></code> and <code><a href="#topic+residuals.gt">residuals.gt</a></code> for <kbd>gt</kbd> methods.
<code><a href="#topic+gtreg.mp">gtreg.mp</a></code> for the group testing regression model in the matrix pooling setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(hivsurv)

fit1 &lt;- gtreg(formula = groupres ~ AGE + EDUC., data = hivsurv,
           groupn = gnum, sens = 0.9, spec = 0.9, method = "Xie")
fit1

## --- Continuing the Example from  '?sim.gt':

set.seed(46)
gt.data &lt;- sim.gt(par = c(-12, 0.2), sample.size = 700, group.size = 5)
fit2 &lt;- gtreg(formula = gres ~ x, data = gt.data, groupn = groupn)
fit2

set.seed(21)
gt.data &lt;- sim.gt(par = c(-12, 0.2), sample.size = 700, group.size = 6,
               sens = 0.95, spec = 0.95, sens.ind = 0.98, spec.ind = 0.98)
fit1 &lt;- gtreg(formula = gres ~ x, data = gt.data, groupn = groupn, 
        retest = retest, method = "X", sens = 0.95, spec = 0.95, sens.ind = 0.98,
        spec.ind = 0.98, trace = TRUE)
summary(fit1)


</code></pre>

<hr>
<h2 id='gtreg.halving'>
Fitting Group Testing Models Under the Halving Protocol
</h2><span id='topic+gtreg.halving'></span><span id='topic+EM.halving'></span>

<h3>Description</h3>

<p><kbd>gtreg.halving</kbd> is a function to fit the group testing regression model under the halving protocol specified through a symbolic description of the linear predictor and descriptions of the group testing setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtreg.halving(formula, data, groupn, subg, retest, sens = 1,
 spec = 1, linkf = c("logit", "probit", "cloglog"),
 sens.ind = NULL, spec.ind = NULL, start = NULL, control = gt.control(...), ...)

EM.halving(Y, X, groupn, subg, ret, sens, spec, linkf, sens.ind,
 spec.ind, start = NULL, control = gt.control())

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtreg.halving_+3A_formula">formula</code></td>
<td>

<p>an object of class <kbd>"formula"</kbd> (or one that can be coerced to that class): a symbolic description of 
the model to be fitted. The details of model specification are given under 'Details'.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by <kbd>as.data.frame</kbd> to a data 
frame) containing the variables in the model. If not found in data, the variables are taken from 
<kbd>environment(formula)</kbd>, typically the environment from which <kbd>gtreg.halving</kbd> is called.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_groupn">groupn</code></td>
<td>

<p>a vector, list or data frame of the group numbers that designates individuals to groups.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_subg">subg</code></td>
<td>

<p>a vector, list or data frame of the group numbers that designates individuals to subgroups.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_retest">retest</code></td>
<td>

<p>a vector, list or data frame of individual retest results within a subgroup that tests positive.
</p>
</td></tr>  
<tr><td><code id="gtreg.halving_+3A_sens">sens</code></td>
<td>

<p>sensitivity of the test, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_spec">spec</code></td>
<td>

<p>specificity of the test, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_sens.ind">sens.ind</code></td>
<td>

<p>sensitivity of the individual retests, set to be equal to <kbd>sens</kbd> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_spec.ind">spec.ind</code></td>
<td>

<p>specificity of the individual retests, set to be equal to <kbd>spec</kbd> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_linkf">linkf</code></td>
<td>

<p>a character string specifying one of the three link functions for a binomial model: <kbd>"logit"</kbd> 
(default) or <kbd>"probit"</kbd> or <kbd>"cloglog"</kbd>.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_start">start</code></td>
<td>

<p>starting values for the parameters in the linear predictor.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_control">control</code></td>
<td>

<p>a list of parameters for controlling the fitting process. See the documentation for <code><a href="#topic+gt.control">gt.control</a></code> for details.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_y">Y</code></td>
<td>

<p>For <kbd>EM.halving</kbd>: the vector of the group responses.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_x">X</code></td>
<td>

<p>For <kbd>EM.halving</kbd>: the design matrix of the covariates.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_ret">ret</code></td>
<td>

<p>For <kbd>EM.halving</kbd>: a vector containing individual retest results.
</p>
</td></tr>
<tr><td><code id="gtreg.halving_+3A_...">...</code></td>
<td>
<p>arguments to be passed by default to <code><a href="#topic+gt.control">gt.control</a></code>: see argument <kbd>control</kbd> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical predictor has the form <kbd>groupresp ~ covariates</kbd> where response is the (numeric) group response vector and <kbd>covariates</kbd> is a series of terms which specifies a linear predictor for individual responses. Note that it is actually the unobserved individual responses, not the observed group responses, which are modeled by the covariates here. In <kbd>groupresp</kbd>, a 0 denotes a negative response and a 1 denotes a positive response, where the probability of an individual positive response is being modeled directly.  A terms specification of the form <kbd>first + second</kbd> indicates all the terms in <kbd>first</kbd> together with all the terms in <kbd>second</kbd> with duplicates removed. The <kbd>terms</kbd> in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on; to avoid this pass a terms object as the formula.
</p>
<p>A specification of the form <kbd>first:second</kbd> indicates the set of terms obtained by taking the interactions of all terms in <kbd>first</kbd> with all terms in <kbd>second</kbd>. The specification <kbd>first*second</kbd> indicates the cross of <kbd>first</kbd> and <kbd>second</kbd>. This is the same as <kbd>first + second + first:second</kbd>. 
</p>
<p>The <kbd>EM.halving</kbd> function apply Xie's EM algorithm to the likelihood function written in terms of the unobserved individual responses; the functions use <kbd>glm.fit</kbd> to update the parameter estimates within each M step. In the halving protocol, if the initial group tests positive, it is split into two subgroups. The two subgroups are subsequently tested and if either subgroup tests positive, the third and final step is to test all individuals within the subgroup. Thus, within <kbd>subg</kbd>, subgroup responses in observed positive groups are 0 (negative) or 1 (positive); the remaining subgroup responses are <kbd>NA</kbd>s meaning that no tests are performed for them. The individual retests are similarly coded. 
</p>


<h3>Value</h3>

<p><kbd>gtreg.halving</kbd> returns an object of class <kbd>"gt"</kbd>. See later in this section. 
The function <kbd>summary</kbd> (i.e., <code><a href="#topic+summary.gt">summary.gt</a></code>) can be used to obtain or print a summary of the results. 
The group testing functions <kbd>predict</kbd> (i.e., <code><a href="#topic+predict.gt">predict.gt</a></code>) and <kbd>residuals</kbd> (i.e., <code><a href="#topic+residuals.gt">residuals.gt</a></code>) can be used to extract various useful features of the value returned by <kbd>gtreg.halving</kbd>. 
An object of class <kbd>"gt"</kbd> is a list containing at least the following components: 
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector of coefficients </p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> estimated Hessian matrix of the negative log likelihood function, serves as an estimate of the information matrix </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> the response residuals, difference of the observed group responses and the fitted group responses. </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> the fitted mean values of group responses. </p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> the deviance between the fitted model and the saturated model. </p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p> Akaike's An Information Criterion, minus twice the maximized log-likelihood plus twice the number of coefficients </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> the number of iterations in the EM algorithm.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p> the vector of group responses. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> the formula supplied. </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> the terms object used. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> the method <kbd>"Xie"</kbd> used to fit the model. </p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p> the link function used in the model. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>References</h3>

<p><em>Xie, M. (2001)</em>, Regression analysis of group testing samples, <em>Statistics in Medicine, 20, 1957-1969.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.gt">summary.gt</a></code>, <code><a href="#topic+predict.gt">predict.gt</a></code> and <code><a href="#topic+residuals.gt">residuals.gt</a></code> for <kbd>gt</kbd> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## --- Continuing the Example from  '?sim.halving':

set.seed(46)
gt.data &lt;- sim.halving(par = c(-6, .1), gshape = 17, gscale = 1.4,
               sample.size = 5000, group.size = 5,
               sens = 0.95, spec = 0.95)
fit1 &lt;- gtreg.halving(formula = gres ~ x, data = gt.data, groupn = groupn,
        start = c(-6, .1), subg = subgroup, retest = retest,
        sens = .95, spec = .95, trace = TRUE)
summary(fit1)

</code></pre>

<hr>
<h2 id='gtreg.mp'>
Fitting Group Testing Models in Matrix Pooling Setting
</h2><span id='topic+gtreg.mp'></span><span id='topic+EM.mp'></span>

<h3>Description</h3>

<p><kbd>gtreg.mp</kbd> is a function to fit the group testing regression model in the matrix pooling setting specified through a symbolic description of the linear predictor and descriptions of the group testing setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtreg.mp(formula, data, coln, rown, arrayn, retest = NULL,
 sens = 1, spec = 1,  linkf = c("logit", "probit", "cloglog"),
 sens.ind = NULL, spec.ind = NULL,  start = NULL,
 control = gt.control(...), ...)

EM.mp(col.resp, row.resp, X, coln, rown, sqn, ret, sens, spec,
 linkf, sens.ind, spec.ind, start = NULL, control = gt.control())

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtreg.mp_+3A_formula">formula</code></td>
<td>

<p>an object of class <kbd>"formula"</kbd> (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by <kbd>as.data.frame</kbd> to a data frame) containing the variables in the model. If not found in <kbd>data</kbd>, the variables are taken from <kbd>environment(formula)</kbd>, typically the environment from which <kbd>gtreg.mp</kbd> is called.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_coln">coln</code></td>
<td>

<p>a vector, list or data frame that specifies column group number for each sample
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_rown">rown</code></td>
<td>

<p>a vector, list or data frame that specifies row group number for each sample
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_arrayn">arrayn</code></td>
<td>

<p>a vector, list or data frame that specifies array number for each sample
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_retest">retest</code></td>
<td>

<p>a vector, list or data frame of individual retest results. A 0 denotes negative and 1 denotes positive. A <code>NA</code> denotes that no retest is performed for that individual. Default value is <code>NULL</code> for no retests. 
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_sens">sens</code></td>
<td>

<p>sensitivity of the group tests, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_spec">spec</code></td>
<td>

<p>specificity of the group tests, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_sens.ind">sens.ind</code></td>
<td>

<p>sensitivity of the individual retests, set to be equal to <kbd>sens</kbd> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_spec.ind">spec.ind</code></td>
<td>

<p>specificity of the individual retests, set to be equal to <kbd>spec</kbd> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_linkf">linkf</code></td>
<td>

<p>a character string specifying one of the three link functions for a binomial model: <kbd>"logit"</kbd> (default) or <kbd>"probit"</kbd> or <kbd>"cloglog"</kbd>.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_start">start</code></td>
<td>

<p>starting values for the parameters in the linear predictor.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. See the documentation for <code><a href="#topic+gt.control">gt.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_col.resp">col.resp</code></td>
<td>

<p>For <kbd>EM.mp</kbd>: vector of group responses of column pools for all samples. 0 denotes negative and 1 denotes positive.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_row.resp">row.resp</code></td>
<td>

<p>For <kbd>EM.mp</kbd>: vector of group responses of row pools for all samples. 0 denotes negative and 1 denotes positive.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_x">X</code></td>
<td>

<p>For <kbd>EM.mp</kbd>: the design matrix of the covariates.
</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_sqn">sqn</code></td>
<td>
<p>For <kbd>EM.mp</kbd>: a vector that specifies array number</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_ret">ret</code></td>
<td>
<p>For <kbd>EM.mp</kbd>: a vector containing individual retest results</p>
</td></tr>
<tr><td><code id="gtreg.mp_+3A_...">...</code></td>
<td>

<p>arguments to be passed to <code><a href="#topic+gt.control">gt.control</a></code>: see argument <kbd>control</kbd></p>
</td></tr>
</table>


<h3>Details</h3>

<p>With matrix pooling, individual samples are placed in a matrix-like grid where samples are pooled within each row and within each column. This leads to two kinds of group responses: row and column group responses. Thus, a typical predictor has the form <kbd>cbind(col.resp, row.resp)</kbd> <kbd>~ covariates</kbd> where <kbd>col.resp</kbd> is the (numeric) column group response vector and <kbd>row.resp</kbd> is the (numeric) row group response vector.
The covariates term is a series of terms which specifies a linear predictor for individual responses. Note that it is actually the unobserved individual responses, not the observed group responses, which are modeled by the covariates. In <kbd>col.resp</kbd> and <kbd>row.resp</kbd>, a 0 denotes a negative response and 1 denotes a positive response, where the probability of an individual positive response is being modeled directly. A terms specification of the form <kbd>first + second</kbd> indicates all the terms in <kbd>first</kbd> together with all the terms in <kbd>second</kbd> with duplicates removed. The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on; to avoid this pass a <kbd>terms</kbd> object as the formula.
</p>
<p>A specification of the form <kbd>first:second</kbd> indicates the set of terms obtained by taking the interactions of all terms in <kbd>first</kbd> with all terms in <kbd>second</kbd>. The specification <kbd>first*second</kbd> indicates the cross of <kbd>first</kbd> and <kbd>second</kbd>. This is the same as <kbd>first + second + first:second</kbd>. 
</p>
<p><kbd>EM.mp</kbd> is the workhorse function. It applies Xie's EM algorithm to the likelihood function written in terms of the unobserved individual responses. In each E step, the Gibbs sampling technique is used to estimate the conditional probabilities. Because of the large number of Gibbs samples needed to achieve convergence, the model fitting process could be quite slow, especially when multiple positive rows and columns are observed. In this case, we can either increase the Gibbs sample size to help achieve convergence or loosen the convergence criteria by increasing <kbd>tol</kbd> at the expense of perhaps poorer estimates. If follow-up retests are performed, the retest results going into the model will help achieve convergence faster with the same Gibbs sample size and convergence criteria. In each M step, we use <kbd>glm.fit</kbd> to update the parameter estimates
</p>


<h3>Value</h3>

<p><kbd>gtreg.mp</kbd> returns an object of class <kbd>"gt.mp"</kbd> which inherits from the class <kbd>"gt"</kbd>. See later in this section. 
The function <kbd>summary</kbd> (i.e., <kbd>summary.gt.mp</kbd>) can be used to obtain or print a summary of the results. 
The group testing function <kbd>predict</kbd> (i.e., <kbd>predict.gt</kbd>) can be used to make predictions on <kbd>"gt.mp"</kbd> objects. 
An object of class <kbd>"gt.mp"</kbd> is a list containing at least the following components: 
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector of coefficients. </p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> estimated Hessian matrix of the negative log likelihood function, serves as an estimate of the information matrix </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> the number of iterations performed in the EM algorithm. </p>
</td></tr>
<tr><td><code>Gibbs.sample.size</code></td>
<td>
<p> the number of Gibbs samples generated in each E step. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> the formula supplied. </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> the terms object used. </p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p> the link function used in the model. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>References</h3>

<p><em>Xie, M. (2001)</em>, Regression analysis of group testing samples, <em>Statistics in Medicine, 20, 1957-1969.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.gt.mp">summary.gt.mp</a></code> and <code><a href="#topic+predict.gt">predict.gt</a></code> for <kbd>gt.mp</kbd> methods.
<code><a href="#topic+gtreg">gtreg</a></code> for the group testing regression model in the simple pooling setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- Continuing the Example from  '?sim.mp':
# 5*6 and 4*5 matrix
set.seed(9128)
sa1a&lt;-sim.mp(par=c(-7,0.1), n.row=c(5,4), n.col=c(6,5),
 sens=0.95, spec=0.95)
sa1&lt;-sa1a$dframe


## Not run: 
fit1 &lt;- gtreg.mp(formula = cbind(col.resp, row.resp) ~ x, data = sa1, 
                 coln = coln, rown = rown, arrayn = arrayn, 
                 sens = 0.95, spec = 0.95, tol = 0.005, n.gibbs = 2000, trace = TRUE)
fit1
summary(fit1)


## End(Not run)

## Here is an example of how long this fitting process may take. For the 
## following simulated data, it takes a computer with 2.2GHZ processor and 
## 3GB RAM about 6 minutes to achieve convergence.
set.seed(9012)
sa2a&lt;-sim.mp(par=c(-7,0.1), n.row=c(10,10,10,10), n.col=c(10,10,10,10), 
             sens=0.95, spec=0.95)
sa2&lt;-sa2a$dframe

## Not run: 
fit2 &lt;- gtreg.mp(formula = cbind(col.resp, row.resp) ~ x, data = sa2, 
                 coln = coln, rown = rown, arrayn = arrayn, retest = retest,
                 sens = 0.95, spec = 0.95, start = c(-7, 0.1), tol = 0.005)

fit2
summary(fit2)


## End(Not run)

</code></pre>

<hr>
<h2 id='hierarchical.desc2'>Operating characteristics for hierarchical group testing</h2><span id='topic+hierarchical.desc2'></span>

<h3>Description</h3>

<p>Calculate operating characteristics for hierarchical 
group testing with up to four stages, given a vector of individual 
probabilities and a testing configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchical.desc2(p, I2 = NULL, I3 = NULL, se = 1, sp = 1,
  order.p = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarchical.desc2_+3A_p">p</code></td>
<td>
<p>vector of probabilities corresponding to each individual's 
risk of disease.</p>
</td></tr>
<tr><td><code id="hierarchical.desc2_+3A_i2">I2</code></td>
<td>
<p>a numeric vector of pool sizes for stage 2 testing (used in 
hierarchical testing with at least three stages).</p>
</td></tr>
<tr><td><code id="hierarchical.desc2_+3A_i3">I3</code></td>
<td>
<p>a numeric vector of pool sizes for stage 3 testing (used in 
hierarchical testing with at least four stages).</p>
</td></tr>
<tr><td><code id="hierarchical.desc2_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="hierarchical.desc2_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="hierarchical.desc2_+3A_order.p">order.p</code></td>
<td>
<p>a logical value indicating whether the vector of 
individual probabilities needs to be sorted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the operating characteristics for
hierarchical group testing with up to four stages of testing. 
Operating characteristics calculated are expected number of tests, 
and pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value, for each 
individual and for the configuration overall.
</p>
<p>If <kbd>I2</kbd> is NULL, there are two stages of testing. If <kbd>I3</kbd> 
is NULL but <kbd>I2</kbd> has values, there are three stages of testing.
If both <kbd>I2</kbd> and <kbd>I3</kbd> have values, there are four stages 
of testing.
</p>
<p>Vectors <kbd>I2</kbd> and <kbd>I3</kbd> should be entered using notation
that keeps track of all individuals through all stages (e.g. for
a group of 10 individuals that splits into 5, 4, and 1 individual
at stage 2, then into 3, 2, 2, 1, and 1 individual at stage 3
before individual testing at stage 4, then I2=c(5,4,1) and 
I3=c(3,2,2,1,1,1) so that the specimen that was tested 
individually at stage 2 is still numbered at stage 3 even though
it will not be tested again).
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>ET</code></td>
<td>
<p>the expected number of tests.</p>
</td></tr>
<tr><td><code>stages</code></td>
<td>
<p>the number of stages in the testing algorithm.</p>
</td></tr>
<tr><td><code>group.size</code></td>
<td>
<p>the total number of individuals tested in the 
algorithm.</p>
</td></tr>
<tr><td><code>I2</code></td>
<td>
<p>pool sizes for the second stage of testing, or
&quot;individual testing&quot; if there are only two stages of testing.</p>
</td></tr>
<tr><td><code>I3</code></td>
<td>
<p>pool sizes for the third stage of testing, or
&quot;individual testing&quot; if there are only three stages of testing.</p>
</td></tr>
<tr><td><code>m1</code></td>
<td>
<p>the initial (stage 1) group size for two stage testing, 
or the number of subgroups originating from the initial group.</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>the number of subgroups for each preceding group 
containing more than one individual, or &quot;individual testing&quot; 
if there are only two stages of testing.</p>
</td></tr>
<tr><td><code>m3</code></td>
<td>
<p>the number of subgroups for each preceding group 
containing more than one individual, or &quot;individual testing&quot; 
if there are only three stages of testing. NULL if there are 
only two stages of testing.</p>
</td></tr>
<tr><td><code>individual.testerror</code></td>
<td>
<p>a data frame containing:
</p>

<dl>
<dt>pse.vec</dt><dd><p>a vector containing each individual's pooling 
sensitivity.</p>
</dd>
<dt>psp.vec</dt><dd><p>a vector containing each individual's pooling 
specificity.</p>
</dd>
<dt>pppv.vec</dt><dd><p>a vector containing each individual's pooling 
positive predictive value.</p>
</dd>
<dt>pnpv.vec</dt><dd><p>a vector containing each individual's pooling
negative predictive value.</p>
</dd></dl>
</td></tr>
<tr><td><code>group.testerror</code></td>
<td>
<p>a vector containing:
</p>

<dl>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm. 
Further details are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm. 
Further details are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value 
for the algorithm. Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value
for the algorithm. Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
<tr><td><code>individual.probabilities</code></td>
<td>
<p>a vector containing each 
individual's probability of disease. If <kbd>order.p=TRUE</kbd>, this
is the sorted vector of individual probabilities.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals even though these measures are 
diagnostic specific; i.e., PPPV (PNPV) should only be considered
for those individuals who have tested positive (negative).
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Michael S. 
Black for Black et al. (2015). The function was obtained from 
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>. Minor modifications were made 
to the function for inclusion in the binGroup package.
</p>


<h3>References</h3>

<p>Black, M., Bilder, C., Tebbs, J. (2015).
&ldquo;Optimal retesting configurations for hierarchical group testing.&rdquo;
<em>Journal of the Royal Statistical Society. Series C: Applied Statistics</em>, <b>64</b>(4), 693&ndash;710.
ISSN 14679876, doi: <a href="https://doi.org/10.1111/rssc.12097">10.1111/rssc.12097</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Array.Measures">Array.Measures</a></code> for calculating operating characteristics
under array testing without master pooling, 
<code><a href="#topic+MasterPool.Array.Measures">MasterPool.Array.Measures</a></code> for non-informative array 
testing with master pooling, and <code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code> 
for informative two-stage hierarchical testing. See 
<code><a href="#topic+p.vec.func">p.vec.func</a></code> for generating a vector of 
individual risk probabilities for informative group testing.  
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Operating characteristic functions: <code><a href="#topic+Array.Measures">Array.Measures</a></code>,
<code><a href="#topic+MasterPool.Array.Measures">MasterPool.Array.Measures</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the operating characteristics for 
#   non-informative two-stage hierarchical testing
#   with an overall disease prevalence of p = 0.015
#   and an initial group size of 12.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
p.vec &lt;- rep(x=0.015, times=12)
hierarchical.desc2(p=p.vec, I2=NULL, I3=NULL, se=0.95, 
sp=0.95, order.p=FALSE)

# Calculate the operating characteristics for 
#   non-informative three-stage hierarchical testing
#   with an overall disease prevalence of p = 0.04, 
#   where an initial group of 20 individuals is 
#   split into equally sized subgroups of 5 each.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
p.vec &lt;- rep(x=0.04, times=20)
hierarchical.desc2(p=p.vec, I2=rep(x=5, times=4),
I3=NULL, se=0.99, sp=0.99, order.p=FALSE)

# Calculate the operating characteristics for 
#   informative three-stage hierarchical testing
#   where an initial group of 10 individuals is 
#   split into subsequent groups of 5, 4, and 1 
#   individual.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta 
#   distribution with p = 0.02 and a heterogeneity level 
#   of alpha = 0.5. Depending on the specified probability, 
#   alpha level, and overall group size, simulation may 
#   be necessary in order to generate the vector of individual
#   probabilities. This is done using p.vec.func() and 
#   requires the user to set a seed in order to reproduce 
#   results.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(1002)
p.vec &lt;- p.vec.func(p=0.02, alpha=0.5, grp.sz=10)
hierarchical.desc2(p=p.vec, I2=c(5,4,1), I3=NULL,
se=0.90, sp=0.90, order.p=TRUE)
</code></pre>

<hr>
<h2 id='hivsurv'>Data from an HIV surveillance project</h2><span id='topic+hivsurv'></span>

<h3>Description</h3>

<p>The <kbd>hivsurv</kbd> data set comes from an HIV surveillance project discussed in Verstraeten et al. (1998) and Vansteelandt et al. (2000). The purpose of the study was to estimate the HIV prevalence among pregnant Kenyan women in four rural locations of the country, using both individual and group testing responses. Blood tests were administered to each participating woman, and 4 covariates were obtained on each woman. Because the original group responses are unavailable, individuals are artificially put into groups of 5 here to form group responses. Only the 428 complete observations are given here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hivsurv)</code></pre>


<h3>Format</h3>

<p>A data frame with 428 observations on the following 8 variables.
</p>

<dl>
<dt><code>DATE</code></dt><dd><p>the date when each sample was collected</p>
</dd>
<dt><code>PAR.</code></dt><dd><p>parity (number of children)</p>
</dd>
<dt><code>AGE</code></dt><dd><p>age (in years)</p>
</dd>
<dt><code>MA.ST.</code></dt><dd><p>marital status (1: single; 2: married (polygamous); 3: married (monogamous); 4: divorced; 5: widow)</p>
</dd>
<dt><code>EDUC.</code></dt><dd><p>highest attained education level (1: no schooling; 2: primary school; 3: secondary school; 4: higher)</p>
</dd>
<dt><code>HIV</code></dt><dd><p>individual response of HIV diagnosis (0: negative; 1: positive)</p>
</dd>
<dt><code>gnum</code></dt><dd><p>the group number that designates individuals into groups</p>
</dd>
<dt><code>groupres</code></dt><dd><p>the group response calculated from artificially formed groups</p>
</dd>
</dl>



<h3>Source</h3>

<p><em>Verstraeten, T., Farah, B., Duchateau, L., Matu, R. (1998),</em> Pooling sera to reduce the cost of HIV surveillance: a feasibility study in a rural Kenyan district, <em> Tropical Medicine &amp; International Health, 3, 747-750.</em>
</p>
<p><em>Vansteelandt, S., Goetghebeur, E., and Verstraeten, T. (2000),</em> Regression models for disease prevalence with diagnostic tests on pools of serum samples, <em> Biometrics, 56, 1126-1133.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hivsurv)

str(hivsurv)

</code></pre>

<hr>
<h2 id='Inf.Array'>Find the optimal testing configuration for informative 
array testing without master pooling</h2><span id='topic+Inf.Array'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) for
informative array testing without master pooling and calculate
the associated operating characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Inf.Array(p, Se, Sp, group.sz, obj.fn, weights = NULL, alpha = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inf.Array_+3A_p">p</code></td>
<td>
<p>the probability of disease, which can be specified as an overall 
probability of disease, from which a heterogeneous vector of individual 
probabilities will be generated, or a heterogeneous vector of individual 
probabilities specified by the user.</p>
</td></tr>
<tr><td><code id="Inf.Array_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Inf.Array_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Inf.Array_+3A_group.sz">group.sz</code></td>
<td>
<p>a single group size (representing the row/column size)
for which to calculate the operating characteristics, or a range of group
(row/column) sizes over which to find the OTC.</p>
</td></tr>
<tr><td><code id="Inf.Array_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always 
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot; 
(the expected number of tests divided by the expected number of correct 
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot; 
(a linear combination of the expected number of tests, the number of 
misclassified negatives, and the number of misclassified positives, 
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details.</p>
</td></tr>
<tr><td><code id="Inf.Array_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function. 
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
<tr><td><code id="Inf.Array_+3A_alpha">alpha</code></td>
<td>
<p>a scale parameter for the beta distribution that specifies 
the degree of heterogeneity for the generated probability vector. If a 
heterogeneous vector of individual probabilities is specified by the user, 
<kbd>alpha</kbd> can be specified as <kbd>NA</kbd> or will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC and computes the associated 
operating characteristics for informative array testing without 
master pooling, implemented using the gradient arrangement described 
in McMahan et al. (2012). Array testing without master pooling involves 
amalgamating specimens in rows and columns for the first stage of testing. 
This function uses only square arrays, which is the way array-based group 
testing is carried out in most real-world applications. Operating 
characteristics calculated are expected number of tests, pooling sensitivity, 
pooling specificity, pooling positive predictive value, and pooling negative 
predictive value for the algorithm. See Hitt et al. (2018)
or McMahan et al. (2012) at <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> 
for additional details on the implementaion of informative array 
testing without master pooling.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial group 
(row/column) size. If a single value is provided for <kbd>group.sz</kbd>, operating
characteristics will be calculated and no optimization will be performed.
If a range of group sizes is specified, the OTC will be found over all 
group sizes.
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm, or 
within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease, as specified by the user.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the level of heterogeneity used to generate the vector of individual
probabilities.</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list for each objective function specified 
by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration, 
which include:
</p>

<dl>
<dt>Array.dim</dt><dd><p>the row/column size for the first stage of testing.</p>
</dd>
<dt>Array.sz</dt><dd><p>the overall array size (the square of the row/column size).</p>
</dd></dl>
</dd>
<dt>p.mat</dt><dd><p>the sorted matrix of individual probabilities, arranged using 
the gradient method described by McMahan et al. (2012).</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value for the algorithm.
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>(1), 113&ndash;122.
ISSN 15372723, doi: <a href="https://doi.org/10.1080/00401706.1972.10488888">10.1080/00401706.1972.10488888</a>, <a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888">https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888</a>.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2018).
&ldquo;The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!&rdquo;
Manuscript submitted for publication.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>(1), 299&ndash;302.
ISSN 15410420, doi: <a href="https://doi.org/10.1111/biom.12385">10.1111/biom.12385</a>.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Two-Dimensional Informative Array Testing.&rdquo;
<em>Biometrics</em>, <b>68</b>(3), 793&ndash;804.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01726.x">10.1111/j.1541-0420.2011.01726.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NI.Array">NI.Array</a></code> for non-informative array testing without master 
pooling, <code><a href="#topic+NI.A2M">NI.A2M</a></code> for non-informative array testing with master 
pooling, and <code><a href="#topic+OTC">OTC</a></code> for finding the optimal testing configuration for
a number of standard group testing algorithms.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other OTC functions: <code><a href="#topic+Inf.D3">Inf.D3</a></code>,
<code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code>, <code><a href="#topic+NI.A2M">NI.A2M</a></code>,
<code><a href="#topic+NI.Array">NI.Array</a></code>, <code><a href="#topic+NI.D3">NI.D3</a></code>,
<code><a href="#topic+NI.Dorf">NI.Dorf</a></code>, <code><a href="#topic+OTC">OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for informative array testing without 
#   master pooling over a range of group (row/column) sizes.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta 
#   distribution with p = 0.03 and a heterogeneity level 
#   of alpha = 2. Depending on the specified probability, 
#   alpha level, and overall group size, simulation may 
#   be necessary in order to generate the vector of individual
#   probabilities. This is done using p.vec.func() and 
#   requires the user to set a seed in order to reproduce 
#   results.
# This examples takes approximately 30 seconds to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
set.seed(1002)
Inf.Array(p=0.03, Se=0.99, Sp=0.99, group.sz=3:20, 
obj.fn=c("ET", "MAR"), alpha=2)
## End(Not run)

# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(1002)
Inf.Array(p=0.03, Se=0.99, Sp=0.99, group.sz=3:5, 
obj.fn=c("ET", "MAR"), alpha=2)

# Find the OTC for a specified group (row/column) size 
#   for informative array testing without master pooling.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(14849)
Inf.Array(p=p.vec.func(p=0.05, alpha=0.5, grp.sz=100), 
Se=0.95, Sp=0.95, group.sz=10, obj.fn=c("ET", "MAR", "GR"),
weights=matrix(data=c(1,1,10,10), nrow=2, ncol=2, byrow=TRUE),
alpha=NA)
</code></pre>

<hr>
<h2 id='Inf.D3'>Find the optimal testing configuration for informative 
three-stage hierarchical testing</h2><span id='topic+Inf.D3'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) for 
informative three-stage hierarchical testing and calculate the 
associated operating charcteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Inf.D3(p, Se, Sp, group.sz, obj.fn, weights = NULL, alpha = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inf.D3_+3A_p">p</code></td>
<td>
<p>the probability of disease, which can be specified as an overall 
probability of disease, from which a heterogeneous vector of individual 
probabilities will be generated, or a heterogeneous vector of individual 
probabilities specified by the user.</p>
</td></tr>
<tr><td><code id="Inf.D3_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Inf.D3_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Inf.D3_+3A_group.sz">group.sz</code></td>
<td>
<p>a single group size over which to find the OTC
out of all possible testing configurations, or a range of group sizes
over which to find the OTC.</p>
</td></tr>
<tr><td><code id="Inf.D3_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always 
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot; 
(the expected number of tests divided by the expected number of correct 
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot; 
(a linear combination of the expected number of tests, the number of 
misclassified negatives, and the number of misclassified positives, 
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details.</p>
</td></tr>
<tr><td><code id="Inf.D3_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function. 
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
<tr><td><code id="Inf.D3_+3A_alpha">alpha</code></td>
<td>
<p>a scale parameter for the beta distribution that specifies 
the degree of heterogeneity for the generated probability vector. If a 
heterogeneous vector of individual probabilities is specified by the user, 
<kbd>alpha</kbd> can be specified as <kbd>NA</kbd> or will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC and computes the associated 
operating characteristics for informative three-stage hierarchical testing. 
This function finds the optimal testing configuration by considering all 
possible testing configurations. Operating characteristics calculated are
expected number of tests, pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value for the algorithm.
See Hitt et al. (2018) or Black et al. (2015) at 
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details on the 
implementation of informative three-stage hierarchical testing.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial (stage 1) 
group size. If a single value is provided for <kbd>group.sz</kbd>, the OTC 
will be found over all possible testing configurations for that initial 
group size. If a range of group sizes is specified, the OTC will be found 
over all group sizes.
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm, or 
within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease, as specified by the user.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the level of heterogeneity used to generate the vector of individual
probabilities.</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list for each objective function specified 
by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration, 
which include:
</p>

<dl>
<dt>Stage1</dt><dd><p>pool size for the first stage of testing, i.e. the initial
group size.</p>
</dd>
<dt>Stage2</dt><dd><p>pool sizes for the second stage of testing.</p>
</dd></dl>
</dd>
<dt>p.vec</dt><dd><p>the sorted vector of individual probabilities.</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value for the algorithm.
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Black, M., Bilder, C., Tebbs, J. (2015).
&ldquo;Optimal retesting configurations for hierarchical group testing.&rdquo;
<em>Journal of the Royal Statistical Society. Series C: Applied Statistics</em>, <b>64</b>(4), 693&ndash;710.
ISSN 14679876, doi: <a href="https://doi.org/10.1111/rssc.12097">10.1111/rssc.12097</a>.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>(1), 113&ndash;122.
ISSN 15372723, doi: <a href="https://doi.org/10.1080/00401706.1972.10488888">10.1080/00401706.1972.10488888</a>, <a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888">https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888</a>.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2018).
&ldquo;The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!&rdquo;
Manuscript submitted for publication.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>(1), 299&ndash;302.
ISSN 15410420, doi: <a href="https://doi.org/10.1111/biom.12385">10.1111/biom.12385</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NI.D3">NI.D3</a></code> for non-informative three-stage hierarchical testing
and <code><a href="#topic+OTC">OTC</a></code> for finding the optimal testing configuration for a
number of standard group testing algorithms.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other OTC functions: <code><a href="#topic+Inf.Array">Inf.Array</a></code>,
<code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code>, <code><a href="#topic+NI.A2M">NI.A2M</a></code>,
<code><a href="#topic+NI.Array">NI.Array</a></code>, <code><a href="#topic+NI.D3">NI.D3</a></code>,
<code><a href="#topic+NI.Dorf">NI.Dorf</a></code>, <code><a href="#topic+OTC">OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for informative three-stage hierarchical 
#   testing over a range of group sizes.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta 
#   distribution with p = 0.05 and a heterogeneity level 
#   of alpha = 0.5. Depending on the specified probability, 
#   alpha level, and overall group size, simulation may 
#   be necessary in order to generate the vector of individual
#   probabilities. This is done using p.vec.func() and 
#   requires the user to set a seed in order to reproduce 
#   results.
# This example takes approximately 20 seconds to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
set.seed(8318)
Inf.D3(p=0.05, Se=0.99, Sp=0.99, group.sz=3:30, 
obj.fn=c("ET", "MAR"), alpha=0.5)
## End(Not run)

# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8318)
Inf.D3(p=0.05, Se=0.99, Sp=0.99, group.sz=10:15, 
obj.fn=c("ET", "MAR"), alpha=0.5)

# Find the OTC out of all possible testing configurations
#   for a specified group size and vector of individual 
#   probabilities.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(1216)
p.vec &lt;- p.vec.func(p=0.10, alpha=2, grp.sz=12)
Inf.D3(p=p.vec, Se=0.99, Sp=0.99, group.sz=12,
obj.fn=c("ET", "MAR", "GR"), weights=matrix(data=c(1,1), 
nrow=1, ncol=2, byrow=TRUE), alpha=NA)
</code></pre>

<hr>
<h2 id='Inf.Dorf'>Find the optimal testing configuration for informative 
two-stage hierarchical (Dorfman) testing</h2><span id='topic+Inf.Dorf'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) for 
informative two-stage hierarchical (Dorfman) testing and 
calculate the associated operating characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Inf.Dorf(p, Se, Sp, group.sz, obj.fn, weights = NULL, alpha = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inf.Dorf_+3A_p">p</code></td>
<td>
<p>the probability of disease, which can be specified as an overall 
probability of disease, from which a heterogeneous vector of individual 
probabilities will be generated, or a heterogeneous vector of individual 
probabilities specified by the user.</p>
</td></tr>
<tr><td><code id="Inf.Dorf_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Inf.Dorf_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Inf.Dorf_+3A_group.sz">group.sz</code></td>
<td>
<p>a single block size for which to find the OTC
out of all possible configurations, or a range of block sizes over 
which to find the OTC.</p>
</td></tr>
<tr><td><code id="Inf.Dorf_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always 
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot; 
(the expected number of tests divided by the expected number of correct 
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot; 
(a linear combination of the expected number of tests, the number of 
misclassified negatives, and the number of misclassified positives, 
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details.</p>
</td></tr>
<tr><td><code id="Inf.Dorf_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function. 
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
<tr><td><code id="Inf.Dorf_+3A_alpha">alpha</code></td>
<td>
<p>a scale parameter for the beta distribution that specifies 
the degree of heterogeneity for the generated probability vector. If a 
heterogeneous vector of individual probabilities is specified by the user, 
<kbd>alpha</kbd> can be specified as <kbd>NA</kbd> or will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC and computes the associated operating 
characteristics for informative two-stage hierarchical (Dorfman) testing, 
implemented via the pool-specific optimal Dorfman (PSOD) method described in 
McMahan et al. (2012). This function finds the optimal testing configuration 
by considering all possible testing configurations instead of using the greedy 
algorithm proposed for PSOD testing. Operating characteristics calculated are
expected number of tests, pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value for the algorithm.
See Hitt et al. (2018) or McMahan et al. (2012) at 
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details on the 
implementation of informative two-stage hierarchical (Dorfman) testing.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the overall block size 
used in the pool-specific optimal Dorfman (PSOD) method, where the overall group 
size is not tested. Instead, multiple initial pool sizes within this block are 
found and tested in the first stage of testing. The second stage of testing consists 
of individual retesting. For more details on informative two-stage hierarchical testing 
implemented via the PSOD method, see Hitt et al. (2018) and McMahan et al. (2012).
</p>
<p>If a single value is provided for <kbd>group.sz</kbd>, the OTC will be  
found over all possible testing configurations. If a range of group sizes is 
specified, the OTC will be found over all group sizes.
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm, or 
within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease, as specified by the user.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the level of heterogeneity used to generate the vector of individual
probabilities.</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list for each objective function specified 
by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration, 
which include:
</p>

<dl>
<dt>Block.sz</dt><dd><p>the block size/overall group size, which is not tested.</p>
</dd>
<dt>pool.szs</dt><dd><p>pool sizes for the first stage of testing.</p>
</dd></dl>
</dd>
<dt>p.vec</dt><dd><p>the sorted vector of individual probabilities.</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm. 
Further details are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm. 
Further details are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value for the algorithm. 
Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value for the algorithm. 
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Dorfman, R. (1943).
&ldquo;The Detection of Defective Members of Large Populations.&rdquo;
<em>The Annals of Mathematical Statistics</em>, <b>14</b>(4), 436&ndash;440.
ISSN 0003-4851, doi: <a href="https://doi.org/10.1214/aoms/1177731363">10.1214/aoms/1177731363</a>, <a href="https://www.jstor.org/stable/2235930">https://www.jstor.org/stable/2235930</a>.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>(1), 113&ndash;122.
ISSN 15372723, doi: <a href="https://doi.org/10.1080/00401706.1972.10488888">10.1080/00401706.1972.10488888</a>, <a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888">https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888</a>.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2018).
&ldquo;The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!&rdquo;
Manuscript submitted for publication.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>(1), 299&ndash;302.
ISSN 15410420, doi: <a href="https://doi.org/10.1111/biom.12385">10.1111/biom.12385</a>.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NI.Dorf">NI.Dorf</a></code> for non-informative two-stage hierarchical (Dorfman) 
testing and <code><a href="#topic+OTC">OTC</a></code> for finding the optimal testing configuration 
for a number of standard group testing algorithms.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other OTC functions: <code><a href="#topic+Inf.Array">Inf.Array</a></code>,
<code><a href="#topic+Inf.D3">Inf.D3</a></code>, <code><a href="#topic+NI.A2M">NI.A2M</a></code>,
<code><a href="#topic+NI.Array">NI.Array</a></code>, <code><a href="#topic+NI.D3">NI.D3</a></code>,
<code><a href="#topic+NI.Dorf">NI.Dorf</a></code>, <code><a href="#topic+OTC">OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for informative two-stage hierarchical 
#   (Dorfman) testing.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta 
#   distribution with p = 0.01 and a heterogeneity level 
#   of alpha = 2. Depending on the specified probability, 
#   alpha level, and overall group size, simulation may 
#   be necessary in order to generate the vector of individual
#   probabilities. This is done using p.vec.func() and 
#   requires the user to set a seed in order to reproduce 
#   results.
# This example takes approximately 20 seconds to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
set.seed(9245)
Inf.Dorf(p=0.01, Se=0.95, Sp=0.95, group.sz=3:30, 
obj.fn=c("ET", "MAR"), alpha=2)
## End(Not run)

# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(9245)
Inf.Dorf(p=0.01, Se=0.95, Sp=0.95, group.sz=5:10, 
obj.fn=c("ET", "MAR"), alpha=2)

# Find the OTC for informative two-stage hierarchical 
#   (Dorfman) testing, for a specified block size.
# This example uses rbeta() to generate random probabilities 
#   and requires the user to set a seed in order to reproduce 
#   results.
# This example takes approximately 2.5 minutes to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
set.seed(8791)
Inf.Dorf(p=p.vec.func(p=0.03, alpha=0.5, grp.sz=50), 
Se=0.90, Sp=0.90, group.sz=50, obj.fn=c("ET", "MAR", "GR"),
weights=matrix(data=c(1,1,10,10), nrow=2, ncol=2, byrow=TRUE),
alpha=NA)
## End(Not run)
</code></pre>

<hr>
<h2 id='inf.dorf.measures'>Operating characteristics for informative two-stage 
hierarchical (Dorfman) testing</h2><span id='topic+inf.dorf.measures'></span>

<h3>Description</h3>

<p>Calculate the expected number of tests and accuracy 
measures for each individual using informative two-stage 
hierarchical (Dorfman) testing, given a vector of individual 
probabilities and a testing configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inf.dorf.measures(prob, se, sp, N, pool.sizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inf.dorf.measures_+3A_prob">prob</code></td>
<td>
<p>vector of probabilities corresponding to each individual's 
risk of disease.</p>
</td></tr>
<tr><td><code id="inf.dorf.measures_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="inf.dorf.measures_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="inf.dorf.measures_+3A_n">N</code></td>
<td>
<p>block size/initial group size that is not tested. This
is the total number of individuals being tested. The 
details of <kbd>block.sz</kbd> are given under 'Details'.</p>
</td></tr>
<tr><td><code id="inf.dorf.measures_+3A_pool.sizes">pool.sizes</code></td>
<td>
<p>a vector of pool sizes for the first stage 
of testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes the equations given by McMahan et al. 
(2012) for informative two-stage hierarchical (Dorfman) testing. 
It also repurposes functions written by Christopher S. McMahan (see
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>)
for the implementation of informative Dorfman testing and directly 
uses functions written for the calculation of the associated operating 
characteristics. This function calculates the operating characteristics 
for informative two-stage hierarchical (Dorfman) testing. Operating 
characteristics calculated are expected number of tests, and pooling 
sensitivity, pooling specificity, pooling positive predictive value, 
and pooling negative predictive value for each individual.
</p>
<p>The specified <kbd>N</kbd> represents the block size used in the pool-specific
optimal Dorfman (PSOD) method. This is the total number of individuals being
tested by the algorithm. This block is not initially tested. Instead, 
multiple initial pool sizes within this block are found and tested in 
the first stage of testing. The second stage of testing consists of individual
retesting. For more information on block size specification, see McMahan et
al. (2012).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>e</code></td>
<td>
<p>the expected number of tests needed to decode all N
individuals.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the variance of the total number of tests needed to 
decode all N individuals.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>a matrix containing the pool, probability of 
disease, pooling sensitivity, pooling specificity, pooling 
positive predictive value, and pooling negative predictive 
value for each individual. The pool column identifies which 
pool each individual is contained in for the first stage of
testing.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals even though these measures are 
diagnostic specific; i.e., PPPV (PNPV) should only be considered
for those individuals who have tested positive (negative).
</p>


<h3>Author(s)</h3>

<p>The majority of this function was originally written by 
Christopher S. McMahan for McMahan et al. (2012). The function was 
obtained from <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>. Minor modifications 
were made to the function for inclusion in the binGroup package.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Array.Measures">Array.Measures</a></code> for calculating operating characteristics
under array testing without master pooling, 
<code><a href="#topic+MasterPool.Array.Measures">MasterPool.Array.Measures</a></code> for non-informative array 
testing with master pooling, and <code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code> 
for informative two-stage hierarchical testing. See 
<code><a href="#topic+p.vec.func">p.vec.func</a></code> for generating a vector of 
individual risk probabilities for informative group testing. 
</p>
<p>This function repurposed code from <code><a href="#topic+opt.info.dorf">opt.info.dorf</a></code> so that
PSOD testing could be implemented using all possible testing configurations
instead of a greedy algorithm. This function also used
<code><a href="#topic+characteristics.pool">characteristics.pool</a></code> and <code><a href="#topic+accuracy.dorf">accuracy.dorf</a></code>
to calculate operating characteristics for the optimal set of 
pool sizes.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Operating characteristic functions: <code><a href="#topic+Array.Measures">Array.Measures</a></code>,
<code><a href="#topic+MasterPool.Array.Measures">MasterPool.Array.Measures</a></code>,
<code><a href="#topic+hierarchical.desc2">hierarchical.desc2</a></code>
</p>
<p>Other Informative Dorfman functions: <code><a href="#topic+accuracy.dorf">accuracy.dorf</a></code>,
<code><a href="#topic+characteristics.pool">characteristics.pool</a></code>,
<code><a href="#topic+opt.info.dorf">opt.info.dorf</a></code>, <code><a href="#topic+opt.pool.size">opt.pool.size</a></code>,
<code><a href="#topic+pool.specific.dorf">pool.specific.dorf</a></code>,
<code><a href="#topic+thresh.val.dorf">thresh.val.dorf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the operating characteristics for 
#   informative two-stage hierarchical (Dorfman) testing
#   with an overall disease prevalence of E(p(i)) = 0.01,
#   where a block size of 50 is split into initial pools
#   of 18, 13, 11, and 8 individuals.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8791)
inf.dorf.measures(prob=beta.dist(p=0.01, alpha=2, 
grp.sz=50, simul=TRUE), se=0.95, sp=0.95, N=50, 
pool.sizes=c(18, 13, 11, 8))
</code></pre>

<hr>
<h2 id='Informative.array.prob'>Arrange a matrix of probabilities for informative array testing</h2><span id='topic+Informative.array.prob'></span>

<h3>Description</h3>

<p>Arrange a vector of individual risk probabilities in a
matrix for informative array testing without master pooling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Informative.array.prob(prob.vec, nr, nc, method = "sd")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Informative.array.prob_+3A_prob.vec">prob.vec</code></td>
<td>
<p>vector of individual risk probabilities, of 
length nr*nc.</p>
</td></tr>
<tr><td><code id="Informative.array.prob_+3A_nr">nr</code></td>
<td>
<p>the number of rows in the array.</p>
</td></tr>
<tr><td><code id="Informative.array.prob_+3A_nc">nc</code></td>
<td>
<p>the number of columns in the array.</p>
</td></tr>
<tr><td><code id="Informative.array.prob_+3A_method">method</code></td>
<td>
<p>character string defining the method to be used
for matrix arrangement. Options include spiral (&quot;<kbd>sd</kbd>&quot;)
and gradient (&quot;<kbd>gd</kbd>&quot;) arrangement. See McMahan et al. (2012)
for additional details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities arranged according to the 
specified method.
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher S. McMahan 
for McMahan et al. (2012). The function was obtained from 
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Two-Dimensional Informative Array Testing.&rdquo;
<em>Biometrics</em>, <b>68</b>(3), 793&ndash;804.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01726.x">10.1111/j.1541-0420.2011.01726.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p.vec.func">p.vec.func</a></code> for generating a vector of individual
risk probabilities from an overall probability of disease and
<code><a href="#topic+Array.Measures">Array.Measures</a></code> for calculating operating characteristics
for informative array testing without master pooling.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Individual risk probability functions: <code><a href="#topic+beta.dist">beta.dist</a></code>,
<code><a href="#topic+p.vec.func">p.vec.func</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the gradient arrangement method to create a matrix
#   of individual risk probabilities for a 10x10 array.
# Depending on the specified probability, alpha level, 
#   and overall group size, simulation may be necessary in 
#   order to generate the vector of individual probabilities. 
#   This is done using the p.vec.func() function and requires 
#   the user to set a seed in order to reproduce results.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(1107)
p.vec1 &lt;- p.vec.func(p=0.05, alpha=2, grp.sz=100)
Informative.array.prob(prob.vec=p.vec1, nr=10, nc=10, method="gd")

# Use the spiral arrangement method to create a matrix
#   of individual risk probabilities for a 5x5 array.
# Depending on the specified probability, alpha level, 
#   and overall group size, simulation may be necessary in 
#   order to generate the vector of individual probabilities. 
#   This is done using the p.vec.func() function and requires 
#   the user to set a seed in order to reproduce results.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8791)
p.vec2 &lt;- p.vec.func(p=0.02, alpha=0.5, grp.sz=25)
Informative.array.prob(prob.vec=p.vec2, nr=5, nc=5, method="sd")
</code></pre>

<hr>
<h2 id='MasterPool.Array.Measures'>Operating characteristics for array testing with master pooling</h2><span id='topic+MasterPool.Array.Measures'></span>

<h3>Description</h3>

<p>Calculate the expected number of tests and accuracy measures
for each individual using array testing with master pooling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MasterPool.Array.Measures(results, n, pmat, Se, Sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MasterPool.Array.Measures_+3A_results">results</code></td>
<td>
<p>an object containing results (expected number of tests and 
accuracy measures) from <code><a href="#topic+Array.Measures">Array.Measures</a></code>.</p>
</td></tr>
<tr><td><code id="MasterPool.Array.Measures_+3A_n">n</code></td>
<td>
<p>size of a row/column in the square array.</p>
</td></tr>
<tr><td><code id="MasterPool.Array.Measures_+3A_pmat">pmat</code></td>
<td>
<p>matrix of individual risk probabilities.</p>
</td></tr>
<tr><td><code id="MasterPool.Array.Measures_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="MasterPool.Array.Measures_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the array is square (i.e., the row
and column size are equal) and utilizes the equations from Kim et al. 
(2007) for square array testing with master pooling. This function 
calculates the operating characteristics for array testing with master 
pooling. Operating characteristics calculated are expected number of tests, 
pooling sensitivity, pooling specificity, pooling positive predictive value, 
and pooling negative predictive value for each individual.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>ET</code></td>
<td>
<p>the expected number of tests for the array.</p>
</td></tr>
<tr><td><code>PSe</code></td>
<td>
<p>a matrix containing each individual's pooling sensitivity, 
corresponding to the input matrix of individual probabilities.</p>
</td></tr>
<tr><td><code>PSp</code></td>
<td>
<p>a matrix containing each individual's pooling specificity, 
corresponding to the input matrix of individual probabilities.</p>
</td></tr>
<tr><td><code>PPV</code></td>
<td>
<p>a matrix containing each individual's pooling positive predictive
value, corresponding to the input matrix of individual probabilities.</p>
</td></tr>
<tr><td><code>NPV</code></td>
<td>
<p>a matrix containing each individual's pooling negative predictive
value, corresponding to the input matrix of individual probabilities.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals in the array even though these
measures are diagnostic specific; i.e., PPV (NPV) should only be considered
for those individuals who have tested positive (negative).
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Kim, H., Hudgens, M., Dreyfuss, J., Westreich, D., Pilcher, C. (2007).
&ldquo;Comparison of group testing algorithms for case identification in the presence of test error.&rdquo;
<em>Biometrics</em>, <b>63</b>(4), 1152&ndash;1163.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2007.00817.x">10.1111/j.1541-0420.2007.00817.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Array.Measures">Array.Measures</a></code> for calculating operating 
characteristics under array testing without master pooling, 
<code><a href="#topic+hierarchical.desc2">hierarchical.desc2</a></code> for three-stage hierarchical and 
non-informative two-stage hierarchical testing, and 
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code> for informative two-stage hierarchical 
testing.
</p>
<p>Other Operating characteristic functions: <code><a href="#topic+Array.Measures">Array.Measures</a></code>,
<code><a href="#topic+hierarchical.desc2">hierarchical.desc2</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the operating characteristics for 
#   non-informative array testing with master
#   pooling, with a 6x6 array and an overall 
#   disease risk of p = 0.10.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
p.mat &lt;- matrix(data=0.10, ncol=6, nrow=6)
results &lt;- Array.Measures(p=p.mat, se=0.90, sp=0.90)
MasterPool.Array.Measures(results=results, n=36, 
pmat=p.mat, Se=0.90, Sp=0.90)
</code></pre>

<hr>
<h2 id='nDesign'>Iterate Sample Size in One Parameter Group Testing</h2><span id='topic+nDesign'></span>

<h3>Description</h3>

<p>Increasing number of groups (assays, bulk samples) for a fixed group size in a binomial group testing design,
until a pre-specified power is achieved. At the same time, bias of the estimator is controlled. A hypothetical
threshold proportion p.hyp and the absolute difference delta to be detected have to be specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nDesign(nmax, s, delta, p.hyp, conf.level = 0.95, 
power = 0.8, alternative = "two.sided", method = "CP", biasrest = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nDesign_+3A_nmax">nmax</code></td>
<td>
<p>either a single integer giving the maximal number of individuals n allowed in the iteration,
or a vector of two integers giving the range of n in which power shall be iterated </p>
</td></tr>
<tr><td><code id="nDesign_+3A_s">s</code></td>
<td>
<p>integer, fixed group size (number of units per group) </p>
</td></tr>
<tr><td><code id="nDesign_+3A_delta">delta</code></td>
<td>
<p>absolute difference between the threshold and the true proportion which shall be detectable with specified power </p>
</td></tr>
<tr><td><code id="nDesign_+3A_p.hyp">p.hyp</code></td>
<td>
<p>threshold proportion to test against in the hypothesis, specify as a value between 0 and 1 </p>
</td></tr>
<tr><td><code id="nDesign_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the decision, default is 0.95 </p>
</td></tr>
<tr><td><code id="nDesign_+3A_power">power</code></td>
<td>
<p>level of power to be achieved to be specified as a probability between 0 and 1 </p>
</td></tr>
<tr><td><code id="nDesign_+3A_alternative">alternative</code></td>
<td>
<p>character string, defining the alternative hypothesis, either <kbd>'two.sided'</kbd>, <kbd>'less'</kbd> or <kbd>'greater'</kbd>
where <kbd>'less'</kbd> calculates the probability that p.hyp is excluded by an upper confidence limit for a true proportion <kbd>p.hyp</kbd> - <kbd>delta</kbd>,
<kbd>'greater'</kbd> calculates the probability that p.hyp is excluded by a lower confidence limit for a true proportion <kbd>p.hyp</kbd> + <kbd>delta</kbd>.
<kbd>'two.sided'</kbd> calculates min(power(<kbd>p.hyp</kbd> - <kbd>delta</kbd>, <kbd>p.hyp</kbd> + <kbd>delta</kbd>)) for a two.sided CI, thus can result in much lower power. </p>
</td></tr>
<tr><td><code id="nDesign_+3A_method">method</code></td>
<td>
<p> character string specifying the CImethod to be used for evaluation, see argument method in bgtCI </p>
</td></tr>
<tr><td><code id="nDesign_+3A_biasrest">biasrest</code></td>
<td>
<p> value between 0 and 1 specifying the absolute bias maximally allowed </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power of a confidence interval here is defined as the probability that a confidence interval or limit excludes the threshold parameter (p.hyp) of the hypothesis. 
</p>
<p>This function increases the number of groups (i.e. number of observations or assays in binomial group testing) until a pre-specified power is reached 
or the maximal number of groups <kbd>nmax</kbd> (specified in the function call) is reached. 
Since the power does not increase monotone with increasing n for binomial proportions but oscillates between local maxima and minima, 
the simple iteration given here will generally result in selecting those n, for which the given CI method shows a local minimum of 
coverage if the null hypothesis is true.
Bias decreases monotone with increasing the number of groups (if other parameters are fixed)
The resulting Problems of chosing a number of groups which results in satisfactory power, are solved in the following manner:
</p>
<p>In case that the pre-specified power can be reached within the given range of n, the smallest n will be returned for which at least this power is reached, as
well as the actual power for this n.
</p>
<p>In case that the pre-specified power is not reached within the given value, that n is returned for which maximal power is achieved, and the corresponding value of power.
</p>
<p>In case that biasrestriction is violated even for the largest n within the given range of n, simply that n will be returned for which power was largest in the given range.
Due to discreteness of binomial distribution, power can be zero for one-sided hypothesis over a range of n. 
</p>
<p>The power can be identical for different methods, depending on the particular combination of n, s, p.hyp, conf.level.
</p>
<p>Especially for large n, the calculation time may become large (particularly for Blaker). Then only the range of sample size which is of interest
can be specified in nmax, f.e. as: nmax=c(150,300). Alternatively, the function bgtPower might be used instead
to calculate power and bias only for some particular combinations of n, s, delta, p.hyp,... . 
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>nout</code></td>
<td>
<p>the number of groups (assays or bulk samples) necessary reach the power with the specified parameters</p>
</td></tr>
<tr><td><code>powerout</code></td>
<td>
<p>the power for the specified parameters and selected number of groups n</p>
</td></tr>
<tr><td><code>biasout</code></td>
<td>
<p>the bias for the specified parameters and the selected number of groups n</p>
</td></tr>
</table>
<p>and a number of values specified in the function call or produced in the iteration, which are only necessary to apply
the function plot() on objects of class 'nDesign' 
</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

<p><em>Schaarschmidt F (2007).</em> Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing. Communications in Biometry and Crop Science 2 (1), 32-40.
http://agrobiol.sggw.waw.pl/cbcs/
</p>
<p><em>Swallow WH (1985).</em> Group testing for estimating infection rates and probabilities of disease transmission. Phytopathology Vol.75, N.8, 882-889.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nDesign">plot.nDesign</a></code> to plot the iteration of this function
</p>
<p><code><a href="#topic+bgtPower">bgtPower</a></code>: calculation of power and bias depending on n, s, delta, p.hyp, conf.level, method
<code><a href="#topic+sDesign">sDesign</a></code>:  function for stepwise increasing group size s for a given n in order to achieve sufficient power within a biasrestriction
<code><a href="#topic+estDesign">estDesign</a></code>:  function to choose group size s according to the minimal mse of the estimator, as given in Swallow (1985) </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Assume one aims to show that a proportion is smaller
## 0.005 (i.e. 0.5 per cent) with a power 
## of 0.80 (i.e. 80 per cent) if the unknown proportion
## in the population is 0.003 (i.e. 0.3 per cent),
## thus, to detect a delta of 0.002.
## The Clopper Pearson CI shall be used. 
## The maximal group size because of limited
## sensitivity of assay might be s=20 and we
## can only afford to perform maximally 100 assays:

nDesign(nmax=100, s=20, delta=0.002, p.hyp=0.005,
 alternative="less", method="CP", power=0.8)

## A power of 80 per cent can not be reached but
## only 30 percent with n=100 
## One might accept to show significance only for a 
## lower true proportion = 0.001 i.e accepting to be
## able to show significance only if true proportion 
## is delta=0.004 smaller than the threshold

nDesign(nmax=100, s=20, delta=0.004, p.hyp=0.005,
 alternative="less", method="CP", power=0.8)


test&lt;-nDesign(nmax=100, s=30, delta=0.004, p.hyp=0.005,
 alternative="less", method="CP", power=0.8)

plot(test)

</code></pre>

<hr>
<h2 id='NI.A2M'>Find the optimal testing configuration for non-informative 
array testing with master pooling</h2><span id='topic+NI.A2M'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration for
non-informative array testing with master pooling and
calculate the associated operating characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NI.A2M(p, Se, Sp, group.sz, obj.fn, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NI.A2M_+3A_p">p</code></td>
<td>
<p>the probability of disease, which can be specified as an overall
probability of disease or a homogeneous vector of individual probabilities.</p>
</td></tr>
<tr><td><code id="NI.A2M_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="NI.A2M_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="NI.A2M_+3A_group.sz">group.sz</code></td>
<td>
<p>a single group size (representing the row/column size)
for which to calculate the operating characteristics, or a range of group
(row/column) sizes over which to find the OTC.</p>
</td></tr>
<tr><td><code id="NI.A2M_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always 
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot; 
(the expected number of tests divided by the expected number of correct 
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot; 
(a linear combination of the expected number of tests, the number of 
misclassified negatives, and the number of misclassified positives, 
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details.</p>
</td></tr>
<tr><td><code id="NI.A2M_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function. 
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC and computes the associated 
operating characteristics for non-informative array testing with 
master pooling. Array testing with master pooling involves testing 
all specimens in the array together in one group before any row or 
column groups are formed. This function uses only square arrays, 
which is the way array-based group testing is carried out
in most real-world applications. Operating characteristics calculated 
are expected number of tests, pooling sensitivity, pooling specificity, 
pooling positive predictive value, and pooling negative predictive value 
for the algorithm. See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> or Kim et al. (2007) 
for additional details on the implementation of non-informative array
testing with master pooling.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the row/column size, which 
is used for the second stage of testing after the entire array is tested 
together in one group. If a single value is provided for <kbd>group.sz</kbd>, operating
characteristics will be calculated and no optimization will be performed.
If a range of group sizes is specified, the OTC will be found over all 
group sizes.
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease, as specified by the user.</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list for each objective function specified 
by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration, 
which include:
</p>

<dl>
<dt>Array.dim</dt><dd><p>the row/column size for the second stage of testing.</p>
</dd>
<dt>Array.sz</dt><dd><p>the overall array size used for the first stage of testing.</p>
</dd></dl>
</dd>
<dt>p.mat</dt><dd><p>the matrix of individual probabilities.</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value for the algorithm.
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals in the array even though these
measures are diagnostic specific; i.e., PPV (NPV) should only be considered
for those individuals who have tested positive (negative).
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>(1), 113&ndash;122.
ISSN 15372723, doi: <a href="https://doi.org/10.1080/00401706.1972.10488888">10.1080/00401706.1972.10488888</a>, <a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888">https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888</a>.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2018).
&ldquo;The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!&rdquo;
Manuscript submitted for publication.
</p>
<p>Kim, H., Hudgens, M., Dreyfuss, J., Westreich, D., Pilcher, C. (2007).
&ldquo;Comparison of group testing algorithms for case identification in the presence of test error.&rdquo;
<em>Biometrics</em>, <b>63</b>(4), 1152&ndash;1163.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2007.00817.x">10.1111/j.1541-0420.2007.00817.x</a>.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>(1), 299&ndash;302.
ISSN 15410420, doi: <a href="https://doi.org/10.1111/biom.12385">10.1111/biom.12385</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NI.Array">NI.Array</a></code> for non-informative array testing without master 
pooling, <code><a href="#topic+Inf.Array">Inf.Array</a></code> for informative array testing without 
master pooling, and <code><a href="#topic+OTC">OTC</a></code> for finding the optimal testing 
configuration for a number of standard group testing algorithms.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other OTC functions: <code><a href="#topic+Inf.Array">Inf.Array</a></code>,
<code><a href="#topic+Inf.D3">Inf.D3</a></code>, <code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code>,
<code><a href="#topic+NI.Array">NI.Array</a></code>, <code><a href="#topic+NI.D3">NI.D3</a></code>,
<code><a href="#topic+NI.Dorf">NI.Dorf</a></code>, <code><a href="#topic+OTC">OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for non-informative array testing with 
#   master pooling over a range of group (row/column) sizes.
# This example takes approximately 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
NI.A2M(p=0.04, Se=0.95, Sp=0.95, group.sz=3:10,
obj.fn=c("ET", "MAR"))

# Calculate the operating characteristics for a specified 
#   group (row/column) size for non-informative array 
#   testing with master pooling.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
NI.A2M(p=rep(0.01, 64), Se=0.90, Sp=0.90, group.sz=8,
obj.fn=c("ET", "MAR", "GR"),
weights=matrix(data=c(1,1,10,10), 
nrow=2, ncol=2, byrow=TRUE))
</code></pre>

<hr>
<h2 id='NI.Array'>Find the optimal testing configuration for non-informative 
array testing without master pooling</h2><span id='topic+NI.Array'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) for
non-informative array testing without master pooling and
calculate the associated operating characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NI.Array(p, Se, Sp, group.sz, obj.fn, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NI.Array_+3A_p">p</code></td>
<td>
<p>the probability of disease, which can be specified as an overall
probability of disease or a homogeneous vector of individual probabilities.</p>
</td></tr>
<tr><td><code id="NI.Array_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="NI.Array_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="NI.Array_+3A_group.sz">group.sz</code></td>
<td>
<p>a single group size (representing the row/column size)
for which to calculate the operating characteristics, or a range of group
(row/column) sizes over which to find the OTC.
The details of group size specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="NI.Array_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always 
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot; 
(the expected number of tests divided by the expected number of correct 
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot; 
(a linear combination of the expected number of tests, the number of 
misclassified negatives, and the number of misclassified positives, 
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details.</p>
</td></tr>
<tr><td><code id="NI.Array_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function. 
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC and computes the associated 
operating characteristics for non-informative array testing without 
master pooling. Array testing without master pooling involves 
amalgamating specimens in rows and columns for the first stage of testing. 
This function uses only square arrays, which is the way array-based group 
testing is carried out in most real-world applications. Operating 
characteristics calculated are expected number of tests, pooling sensitivity, 
pooling specificity, pooling positive predictive value, and pooling negative 
predictive value for the algorithm. See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> or Kim et al. (2007) 
for additional details on the implementation of non-informative array
testing without master pooling.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial group 
(row/column) size. If a single value is provided for <kbd>group.sz</kbd>, operating
characteristics will be calculated and no optimization will be performed.
If a range of group sizes is specified, the OTC will be found over all 
group sizes.
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease, as specified by the user.</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list for each objective function specified 
by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration, 
which include:
</p>

<dl>
<dt>Array.dim</dt><dd><p>the row/column size for the first stage of testing.</p>
</dd>
<dt>Array.sz</dt><dd><p>the overall array size (the square of the row/column size).</p>
</dd></dl>
</dd>
<dt>p.mat</dt><dd><p>the matrix of individual probabilities.</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value for the algorithm.
Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value for the algorithm.
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>(1), 113&ndash;122.
ISSN 15372723, doi: <a href="https://doi.org/10.1080/00401706.1972.10488888">10.1080/00401706.1972.10488888</a>, <a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888">https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888</a>.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2018).
&ldquo;The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!&rdquo;
Manuscript submitted for publication.
</p>
<p>Kim, H., Hudgens, M., Dreyfuss, J., Westreich, D., Pilcher, C. (2007).
&ldquo;Comparison of group testing algorithms for case identification in the presence of test error.&rdquo;
<em>Biometrics</em>, <b>63</b>(4), 1152&ndash;1163.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2007.00817.x">10.1111/j.1541-0420.2007.00817.x</a>.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>(1), 299&ndash;302.
ISSN 15410420, doi: <a href="https://doi.org/10.1111/biom.12385">10.1111/biom.12385</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Inf.Array">Inf.Array</a></code> for informative array testing without master pooling,
<code><a href="#topic+NI.A2M">NI.A2M</a></code> for non-informative array testing with master pooling, and
<code><a href="#topic+OTC">OTC</a></code> for finding the optimal testing configuration for a number
of standard group testing algorithms.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other OTC functions: <code><a href="#topic+Inf.Array">Inf.Array</a></code>,
<code><a href="#topic+Inf.D3">Inf.D3</a></code>, <code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code>,
<code><a href="#topic+NI.A2M">NI.A2M</a></code>, <code><a href="#topic+NI.D3">NI.D3</a></code>,
<code><a href="#topic+NI.Dorf">NI.Dorf</a></code>, <code><a href="#topic+OTC">OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for non-informative array testing 
#   without master pooling over a range of group
#   (row/column) sizes.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
NI.Array(p=0.04, Se=0.95, Sp=0.95, group.sz=3:10,
obj.fn=c("ET", "MAR"))

# Calculate the operating characteristics for a specified 
#   group (row/column) size for non-informative array 
#   testing without master pooling.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
NI.Array(p=rep(0.01, 64), Se=0.90, Sp=0.90, group.sz=8,
obj.fn=c("ET", "MAR", "GR"), 
weights=matrix(data=c(1,1,10,10,100,100), 
nrow=3, ncol=2, byrow=TRUE))
</code></pre>

<hr>
<h2 id='NI.D3'>Find the optimal testing configuration for non-informative 
three-stage hierarchical testing</h2><span id='topic+NI.D3'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) for
non-informative three-stage hierarchical testing and calculate
the associated operating characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NI.D3(p, Se, Sp, group.sz, obj.fn, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NI.D3_+3A_p">p</code></td>
<td>
<p>the probability of disease, which can be specified as an overall
probability of disease or a homogeneous vector of individual probabilities.</p>
</td></tr>
<tr><td><code id="NI.D3_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="NI.D3_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="NI.D3_+3A_group.sz">group.sz</code></td>
<td>
<p>a single group size over which to find the OTC
out of all possible testing configurations, or a range of
group sizes over which to find the OTC.</p>
</td></tr>
<tr><td><code id="NI.D3_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always 
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot; 
(the expected number of tests divided by the expected number of correct 
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot; 
(a linear combination of the expected number of tests, the number of 
misclassified negatives, and the number of misclassified positives, 
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details.</p>
</td></tr>
<tr><td><code id="NI.D3_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function. 
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC and computes the associated operating 
characteristics for non-informative three-stage hierarchical testing, 
by considering all possible testing configurations. 
Operating characteristics calculated are expected number of tests, pooling 
sensitivity, pooling specificity, pooling positive predictive value, and 
pooling negative predictive value for the algorithm. See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> or Kim et al. (2007) 
for additional details on the implementation of non-informative three-stage 
hierarchical testing.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial (stage 1) 
group size. If a single value is provided for <kbd>group.sz</kbd>, the OTC 
will be found over all possible testing configurations for that initial 
group size. If a range of group sizes is specified, the OTC will be found 
over all group sizes.
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease, as specified by the user.</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list for each objective function specified 
by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration, 
which include:
</p>

<dl>
<dt>Stage1</dt><dd><p>pool size for the first stage of testing, i.e. the initial
group size.</p>
</dd>
<dt>Stage2</dt><dd><p>pool sizes for the second stage of testing.</p>
</dd></dl>
</dd>
<dt>p.vec</dt><dd><p>the vector of individual probabilities</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm. Further 
details are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm. Further 
details are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value for the algorithm. 
Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value for the algorithm. 
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>(1), 113&ndash;122.
ISSN 15372723, doi: <a href="https://doi.org/10.1080/00401706.1972.10488888">10.1080/00401706.1972.10488888</a>, <a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888">https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888</a>.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2018).
&ldquo;The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!&rdquo;
Manuscript submitted for publication.
</p>
<p>Kim, H., Hudgens, M., Dreyfuss, J., Westreich, D., Pilcher, C. (2007).
&ldquo;Comparison of group testing algorithms for case identification in the presence of test error.&rdquo;
<em>Biometrics</em>, <b>63</b>(4), 1152&ndash;1163.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2007.00817.x">10.1111/j.1541-0420.2007.00817.x</a>.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>(1), 299&ndash;302.
ISSN 15410420, doi: <a href="https://doi.org/10.1111/biom.12385">10.1111/biom.12385</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Inf.D3">Inf.D3</a></code> for informative three-stage hierarchical testing, 
<code><a href="#topic+NI.Dorf">NI.Dorf</a></code> for non-informative two-stage hierarchical (Dorfman) 
testing, <code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code> for informative two-stage hierarchical 
testing, and <code><a href="#topic+OTC">OTC</a></code> for finding the optimal testing configuration 
for a number of standard group testing algorithms.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other OTC functions: <code><a href="#topic+Inf.Array">Inf.Array</a></code>,
<code><a href="#topic+Inf.D3">Inf.D3</a></code>, <code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code>,
<code><a href="#topic+NI.A2M">NI.A2M</a></code>, <code><a href="#topic+NI.Array">NI.Array</a></code>,
<code><a href="#topic+NI.Dorf">NI.Dorf</a></code>, <code><a href="#topic+OTC">OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for non-informative three-stage 
#   hierarchical testing over a range of group sizes.
# This example takes approximately 20 seconds to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
NI.D3(p=0.02, Se=0.90, Sp=0.90, group.sz=3:30, 
obj.fn=c("ET", "MAR"))
## End(Not run)

# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
NI.D3(p=0.02, Se=0.90, Sp=0.90, group.sz=3:12, 
obj.fn=c("ET", "MAR"))

# Find the OTC out of all possible configurations for 
#   a specified group size for non-informative
#   three-stage hierarchical testing.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
NI.D3(p=rep(0.005, 15), Se=0.99, Sp=0.99, group.sz=15,
obj.fn=c("ET", "MAR", "GR"), weights=matrix(data=c(1,1,10,10), 
nrow=2, ncol=2, byrow=TRUE))
</code></pre>

<hr>
<h2 id='NI.Dorf'>Find the optimal testing configuration for non-informative 
two-stage hierarchical testing</h2><span id='topic+NI.Dorf'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) for 
non-informative two-stage hierarchical (Dorfman) testing and 
calculate the associated operating characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NI.Dorf(p, Se, Sp, group.sz, obj.fn, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NI.Dorf_+3A_p">p</code></td>
<td>
<p>the probability of disease, which can be specified as an overall
probability of disease or a homogeneous vector of individual probabilities.</p>
</td></tr>
<tr><td><code id="NI.Dorf_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="NI.Dorf_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="NI.Dorf_+3A_group.sz">group.sz</code></td>
<td>
<p>a single group size for which to calculate operating
characteristics, or a range of group sizes over which to find the OTC. 
The details of group size specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="NI.Dorf_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always 
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot; 
(the expected number of tests divided by the expected number of correct 
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot; 
(a linear combination of the expected number of tests, the number of 
misclassified negatives, and the number of misclassified positives, 
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details.</p>
</td></tr>
<tr><td><code id="NI.Dorf_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function. 
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC and computes the associated 
operating characteristics for non-informative two-stage
hierarchical (Dorfman) testing. Operating characteristics calculated 
are expected number of tests, pooling sensitivity, pooling specificity, 
pooling positive predictive value, and pooling negative predictive value 
for the algorithm. See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>, Dorfman (1943), or
Kim et al. (2007) for additional details on the implementation 
of non-informative two-stage hierarchical testing.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial (stage 1) 
group size. If a single value is provided for <kbd>group.sz</kbd>, operating
characteristics will be calculated and no optimization will be performed.
If a range of group sizes is specified, the OTC will be found over all 
group sizes.
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease, as specified by the user.</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list for each objective function specified 
by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration, 
which include:
</p>

<dl>
<dt>Stage1</dt><dd><p>pool size for the first stage of testing, i.e. the initial
group size.</p>
</dd></dl>
</dd>
<dt>p.vec</dt><dd><p>the vector of individual probabilities.</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm. Further 
details are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm. Further 
details are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value for the algorithm. 
Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value for the algorithm. 
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Dorfman, R. (1943).
&ldquo;The Detection of Defective Members of Large Populations.&rdquo;
<em>The Annals of Mathematical Statistics</em>, <b>14</b>(4), 436&ndash;440.
ISSN 0003-4851, doi: <a href="https://doi.org/10.1214/aoms/1177731363">10.1214/aoms/1177731363</a>, <a href="https://www.jstor.org/stable/2235930">https://www.jstor.org/stable/2235930</a>.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>(1), 113&ndash;122.
ISSN 15372723, doi: <a href="https://doi.org/10.1080/00401706.1972.10488888">10.1080/00401706.1972.10488888</a>, <a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888">https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888</a>.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2018).
&ldquo;The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!&rdquo;
Manuscript submitted for publication.
</p>
<p>Kim, H., Hudgens, M., Dreyfuss, J., Westreich, D., Pilcher, C. (2007).
&ldquo;Comparison of group testing algorithms for case identification in the presence of test error.&rdquo;
<em>Biometrics</em>, <b>63</b>(4), 1152&ndash;1163.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2007.00817.x">10.1111/j.1541-0420.2007.00817.x</a>.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>(1), 299&ndash;302.
ISSN 15410420, doi: <a href="https://doi.org/10.1111/biom.12385">10.1111/biom.12385</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code> for informative two-stage hierarchical (Dorfman) testing, 
<code><a href="#topic+NI.D3">NI.D3</a></code> for non-informative three-stage hierarchical testing, 
<code><a href="#topic+Inf.D3">Inf.D3</a></code> for informative three-stage hierarchical testing,
and <code><a href="#topic+OTC">OTC</a></code> for finding the optimal testing configuration for a number 
of standard group testing algorithms.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other OTC functions: <code><a href="#topic+Inf.Array">Inf.Array</a></code>,
<code><a href="#topic+Inf.D3">Inf.D3</a></code>, <code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code>,
<code><a href="#topic+NI.A2M">NI.A2M</a></code>, <code><a href="#topic+NI.Array">NI.Array</a></code>,
<code><a href="#topic+NI.D3">NI.D3</a></code>, <code><a href="#topic+OTC">OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for non-informative two-stage 
#   hierarchical (Dorfman) testing over a range 
#   of group sizes.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
NI.Dorf(p=0.01, Se=0.95, Sp=0.95, group.sz=2:100, 
obj.fn=c("ET", "MAR"))

# Calculate the operating characteristics for a specified 
#   initial group size for non-informative two-stage 
#   hierarchical (Dorfman) testing.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
NI.Dorf(p=rep(0.025, 50), Se=0.90, Sp=0.90, group.sz=50,
obj.fn=c("ET", "MAR", "GR"), weights=matrix(data=c(1,1,10,10), 
nrow=2, ncol=2, byrow=TRUE))
</code></pre>

<hr>
<h2 id='opt.info.dorf'>Find the characteristics of an informative two-stage 
hierarchical (Dorfman) algorithm</h2><span id='topic+opt.info.dorf'></span>

<h3>Description</h3>

<p>Find the characteristics of an informative 
two-stage hierarchical (Dorfman) decoding process using Optimal 
Dorfman (OD), Thresholded Optimal Dorfman (TOD), or Pool-Specific 
Optimal Dorfman (PSOD) algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.info.dorf(prob, se = 1, sp = 1, method = "OD", max.pool = 15,
  thresh.pool = 8, threshold = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.info.dorf_+3A_prob">prob</code></td>
<td>
<p>a vector of all subjects' infection probabilities.</p>
</td></tr>
<tr><td><code id="opt.info.dorf_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="opt.info.dorf_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="opt.info.dorf_+3A_method">method</code></td>
<td>
<p>character string defining the specific screening
procedure for implementation of Dorfman retesting in a 
heterogeneous population. Options include Optimal Dorfman 
(&quot;<kbd>OD</kbd>&quot;), Thresholded Optimal Dorfman (&quot;<kbd>TOD</kbd>&quot;), and
Pool-Specific Optimal Dorfman (&quot;<kbd>PSOD</kbd>&quot;). Further details 
are given under 'Details'.</p>
</td></tr>
<tr><td><code id="opt.info.dorf_+3A_max.pool">max.pool</code></td>
<td>
<p>the maximum allowable pool size. Further details 
are given under 'Details'.</p>
</td></tr>
<tr><td><code id="opt.info.dorf_+3A_thresh.pool">thresh.pool</code></td>
<td>
<p>the initial pool size used for TOD, if 
<kbd>threshold</kbd> is not specified. Further details are given 
under 'Details'.</p>
</td></tr>
<tr><td><code id="opt.info.dorf_+3A_threshold">threshold</code></td>
<td>
<p>the threshold value for TOD. If a threshold
value is not specified, one is found algorithmically. Further 
details are given under 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the characteristics of an informative
two-stage hierarchical (Dorfman) decoding process. Characteristics
found include the expected expenditure of the decoding process, 
the variance of the expenditure of the decoding process, and the 
pooling sensitivity, pooling specificity, pooling positive predictive
value, and pooling negative predictive value for each individual.
Calculations of these characteristics are done using equations
presented in McMahan et al. (2012). 
</p>
<p>Optimal Dorfman (OD) is an informative Dorfman algorithm in 
which the common pool size <code class="reqn">c=c_{opt}</code> minimizes 
<code class="reqn">E(T^(c))</code>, the expected number of tests needed to decode 
all <code class="reqn">N</code> individuals when pools of size <code class="reqn">c</code> are used. 
</p>
<p>Thresholded Optimal Dorfman (TOD) is an informative Dorfman 
algorithm in which all <code class="reqn">N</code> individuals are partitioned 
into two classes, low-risk and high-risk individuals, based 
on whether their risk probability falls below or above a 
particular threshold value. The threshold can be specified 
using the <kbd>threshold</kbd> argument or the TOD algorithm can 
identify the optimal threshold value. The low-risk individuals
are tested using a optimal common pool size,  and high-risk 
individuals are tested individually.
</p>
<p>Pool-Specific Optimal Dorfman (PSOD) is an informative Dorfman
algorithm in which optimal sizes are determined for each pool. 
A total of <code class="reqn">N</code> individuals are tested in pools that minimize
the expected number of tests per individual, on a pool-by-pool 
basis. If desired, the user can add the constraint of a maximum 
allowable pool size, so that each pool will contain no more 
than the maximum allowable number of individuals.
</p>
<p>All three informative Dorfman procedures described above require
individuals to be ordered from smallest to largest probability 
of infection. See McMahan et al. (2012) for additional details
on the implementation of informative two-stage hierarchical
(Dorfman) testing algorithms.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>tv</code></td>
<td>
<p>the threshold value used for TOD, if applicable.</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>the expected expenditure of the decoding process.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the variance of the expenditure of the decoding 
process.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>a matrix of summary measures that includes
each individual's infection probability, pool (pool to which
they belong), pooling sensitivity, pooling specificity, 
pooling positive predictive value, and pooling negative
predictive value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher S. 
McMahan for McMahan et al. (2012). The function was obtained 
from <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>Dorfman, R. (1943).
&ldquo;The Detection of Defective Members of Large Populations.&rdquo;
<em>The Annals of Mathematical Statistics</em>, <b>14</b>(4), 436&ndash;440.
ISSN 0003-4851, doi: <a href="https://doi.org/10.1214/aoms/1177731363">10.1214/aoms/1177731363</a>, <a href="https://www.jstor.org/stable/2235930">https://www.jstor.org/stable/2235930</a>.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>


<h3>See Also</h3>

<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Informative Dorfman functions: <code><a href="#topic+accuracy.dorf">accuracy.dorf</a></code>,
<code><a href="#topic+characteristics.pool">characteristics.pool</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>,
<code><a href="#topic+opt.pool.size">opt.pool.size</a></code>,
<code><a href="#topic+pool.specific.dorf">pool.specific.dorf</a></code>,
<code><a href="#topic+thresh.val.dorf">thresh.val.dorf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the characteristics of an informative
#   Dorfman algorithm, using the OD procedure.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
opt.info.dorf(prob=rbeta(1000,1,10), se=1, sp=1, 
method ="OD", max.pool=15, thresh.pool=8, threshold=NULL)

# Find the characteristics of an informative 
#   Dorfman algorithm, using the TOD procedure.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(1002)
p.vec &lt;- p.vec.func(p=0.01, alpha=2, grp.sz=20)
opt.info.dorf(prob=p.vec, se=0.95, sp=0.95, 
method="TOD", max.pool=5, threshold=0.015)
</code></pre>

<hr>
<h2 id='opt.pool.size'>Find the optimal pool size for Optimal Dorfman or
Thresholded Optimal Dorfman</h2><span id='topic+opt.pool.size'></span>

<h3>Description</h3>

<p>Find the optimal common pool size for Optimal Dorfman
(OD) or Thresholded Optimal Dorfman (TOD) testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.pool.size(p, max.p, se = 1, sp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.pool.size_+3A_p">p</code></td>
<td>
<p>a vector of each individual's probability of infection.</p>
</td></tr>
<tr><td><code id="opt.pool.size_+3A_max.p">max.p</code></td>
<td>
<p>the maximum allowable pool size.</p>
</td></tr>
<tr><td><code id="opt.pool.size_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="opt.pool.size_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the optimal common pool size for OD or
TOD testing. Using OD testing, all individuals are tested using an 
optimal common pool size. Using TOD testing, individuals are partitioned 
into low-risk and high-risk groups, and all low-risk individuals are 
tested using an optimal common pool size. See McMahan et al. (2012) for 
additional details on the implementation of OD or TOD testing.
</p>


<h3>Value</h3>

<p>The optimal common pool size for OD or TOD testing.
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher S. 
McMahan for McMahan et al. (2012). The function was obtained 
from <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>


<h3>See Also</h3>

<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Informative Dorfman functions: <code><a href="#topic+accuracy.dorf">accuracy.dorf</a></code>,
<code><a href="#topic+characteristics.pool">characteristics.pool</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>,
<code><a href="#topic+opt.info.dorf">opt.info.dorf</a></code>,
<code><a href="#topic+pool.specific.dorf">pool.specific.dorf</a></code>,
<code><a href="#topic+thresh.val.dorf">thresh.val.dorf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8135)
p.vec &lt;- p.vec.func(p=0.02, alpha=1, grp.sz=10)
opt.pool.size(p=p.vec, max.p=3, se=0.95, sp=0.95)
</code></pre>

<hr>
<h2 id='OTC'>Find the optimal testing configuration</h2><span id='topic+OTC'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) for standard group testing
algorithms and calculate the associated operating characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OTC(algorithm, p = NULL, probabilities = NULL, Se = 0.99, Sp = 0.99,
  group.sz, obj.fn = c("ET", "MAR"), weights = NULL, alpha = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OTC_+3A_algorithm">algorithm</code></td>
<td>
<p>character string defining the group testing algorithm to be used.
Non-informative testing options include two-stage hierarchical (&quot;<kbd>D2</kbd>&quot;),
three-stage hierarchical (&quot;<kbd>D3</kbd>&quot;), square array testing without master 
pooling (&quot;<kbd>A2</kbd>&quot;), and square array testing without master pooling (&quot;<kbd>A2M</kbd>&quot;). 
Informative testing options include two-stage hierarchical (&quot;<kbd>ID2</kbd>&quot;),
three-stage hierarchical (&quot;<kbd>ID3</kbd>&quot;), and square array testing without 
master pooling (&quot;<kbd>IA2</kbd>&quot;).</p>
</td></tr>
<tr><td><code id="OTC_+3A_p">p</code></td>
<td>
<p>overall probability of disease that will be used to generate a
vector/matrix of individual probabilities. For non-informative algorithms, a 
homogeneous set of probabilities will be used. For informative algorithms, the 
<code><a href="#topic+p.vec.func">p.vec.func</a></code> function will be used to generate a heterogeneous 
set of probabilities. Either <kbd>p</kbd> or <kbd>probabilities</kbd> should be specified, 
but not both.</p>
</td></tr>
<tr><td><code id="OTC_+3A_probabilities">probabilities</code></td>
<td>
<p>a vector of individual probabilities, which is homogeneous 
for non-informative testing algorithms and heterogeneous for informative 
testing algorithms. Either  <kbd>p</kbd> or <kbd>probabilities</kbd> should be specified, 
but not both.</p>
</td></tr>
<tr><td><code id="OTC_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="OTC_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="OTC_+3A_group.sz">group.sz</code></td>
<td>
<p>a single group size or range of group sizes for which to 
calculate operating characteristics and/or find the OTC. The details of group 
size specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="OTC_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always 
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot; 
(the expected number of tests divided by the expected number of correct 
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot; 
(a linear combination of the expected number of tests, the number of 
misclassified negatives, and the number of misclassified positives, 
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2018) at
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a> for additional details.</p>
</td></tr>
<tr><td><code id="OTC_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function. 
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
<tr><td><code id="OTC_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter for the beta distribution that specifies the degree of
heterogeneity for the generated probability vector (for informative testing only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC and computes the
associated operating characteristics for standard group testing algorithms,
as described in Hitt et al. (2018) at 
<a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>
<p>Available algorithms include two- and three-stage hierarchical testing and
array testing with and without master pooling. Both non-informative and informative
group testing settings are allowed for each algorithm, except informative 
array testing with master pooling is unavailable because this method has not 
appeared in the group testing literature. Operating characteristics calculated are
expected number of tests, pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value for each individual.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial (stage 1) 
group size for three-stage hierarchical testing and non-informative 
two-stage hierarchical testing. For informative two-stage hierarchical testing, 
the <kbd>group.sz</kbd> specified represents the block size used in the pool-specific
optimal Dorfman (PSOD) method, where the initial group (block) is not
tested. For more details on informative two-stage hierarchical testing 
implemented via the PSOD method, see Hitt et al. (2018) and McMahan et al. (2012a).
For array testing without master pooling, the <kbd>group.sz</kbd> specified
represents the row/column size for initial (stage 1) testing. For array testing 
with master pooling, the <kbd>group.sz</kbd> specified represents the row/column size 
for stage 2 testing. The group size for initial testing is overall array size, 
given by the square of the row/column size.
</p>
<p>If a single value is provided for <kbd>group.sz</kbd> with array testing or
non-informative two-stage hierarchical testing, operating
characteristics will be calculated and no optimization will be performed.
If a single value is provided for <kbd>group.sz</kbd> with three-stage hierarchical or 
informative two-stage hierarchical, the OTC will be  
found over all possible configurations. If a range of group sizes is specified, 
the OTC will be found over all group sizes.
</p>
<p>The displayed pooling sensitivity, pooling specificity, pooling positive 
predictive value, and pooling negative predictive value are weighted 
averages of the corresponding individual accuracy measures for all 
individuals within the initial group for a hierarchical algorithm, or 
within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary 
Material for Hitt et al. (2018). These expressions are based on accuracy 
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease, as specified by the user.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>level of heterogeneity for the generated probability vector
(for informative testing only).</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list for each objective function specified
by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration, 
which may include:
</p>

<dl>
<dt>Stage1</dt><dd><p>pool size for the first stage of hierarchical testing, if applicable.</p>
</dd>
<dt>Stage2</dt><dd><p>pool sizes for the second stage of hierarchical testing, if applicable.</p>
</dd>
<dt>Block.sz</dt><dd><p>the block size/initial group size for informative Dorfman testing,
which is not tested.</p>
</dd>
<dt>pool.szs</dt><dd><p>pool sizes for the first stage of testing for informative Dorfman
testing.</p>
</dd>
<dt>Array.dim</dt><dd><p>the row/column size for array testing.</p>
</dd>
<dt>Array.sz</dt><dd><p>the overall array size for array testing (the square of the row/column size).</p>
</dd></dl>
</dd>
<dt>p.vec</dt><dd><p>the sorted vector of individual probabilities, if applicable.</p>
</dd>
<dt>p.mat</dt><dd><p>the sorted matrix of individual probabilities in gradient arrangement,
if applicable.</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>PSe</dt><dd><p>the overall pooling sensitivity for the algorithm. Further details 
are given under 'Details'.</p>
</dd>
<dt>PSp</dt><dd><p>the overall pooling specificity for the algorithm. Further details 
are given under 'Details'.</p>
</dd>
<dt>PPPV</dt><dd><p>the overall pooling positive predictive value for the algorithm. 
Further details are given under 'Details'.</p>
</dd>
<dt>PNPV</dt><dd><p>the overall pooling negative predictive value for the algorithm. 
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>(1), 113&ndash;122.
ISSN 15372723, doi: <a href="https://doi.org/10.1080/00401706.1972.10488888">10.1080/00401706.1972.10488888</a>, <a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888">https://www.tandfonline.com/doi/abs/10.1080/00401706.1972.10488888</a>.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2018).
&ldquo;The Optimal Group Size Controversy for Infectious Disease Testing: Much Ado About Nothing?!&rdquo;
Manuscript submitted for publication.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>(1), 299&ndash;302.
ISSN 15410420, doi: <a href="https://doi.org/10.1111/biom.12385">10.1111/biom.12385</a>.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Two-Dimensional Informative Array Testing.&rdquo;
<em>Biometrics</em>, <b>68</b>(3), 793&ndash;804.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01726.x">10.1111/j.1541-0420.2011.01726.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NI.Dorf">NI.Dorf</a></code> for non-informative two-stage (Dorfman) testing, <code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code> for
informative two-stage (Dorfman) testing, <code><a href="#topic+NI.D3">NI.D3</a></code> for non-informative three-stage
hierarchical testing, <code><a href="#topic+Inf.D3">Inf.D3</a></code> for informative three-stage hierarchical testing,
<code><a href="#topic+NI.Array">NI.Array</a></code> for non-informative array testing, <code><a href="#topic+Inf.Array">Inf.Array</a></code> for informative
array testing, and <code><a href="#topic+NI.A2M">NI.A2M</a></code> for non-informative array testing with master pooling.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other OTC functions: <code><a href="#topic+Inf.Array">Inf.Array</a></code>,
<code><a href="#topic+Inf.D3">Inf.D3</a></code>, <code><a href="#topic+Inf.Dorf">Inf.Dorf</a></code>,
<code><a href="#topic+NI.A2M">NI.A2M</a></code>, <code><a href="#topic+NI.Array">NI.Array</a></code>,
<code><a href="#topic+NI.D3">NI.D3</a></code>, <code><a href="#topic+NI.Dorf">NI.Dorf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for non-informative
#   two-stage hierarchical (Dorfman) testing
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
OTC(algorithm="D2", p=0.05, Se=0.99, Sp=0.99, group.sz=2:100,
obj.fn=c("ET", "MAR"))

# Find the OTC for informative
#   two-stage hierarchical (Dorfman) testing, implemented
#   via the pool-specific optimal Dorfman (PSOD) method
#   described in McMahan et al. (2012a), where the greedy
#   algorithm proposed for PSOD is replaced by considering
#   all possible testing configurations.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta 
#   distribution with p = 0.01 and a heterogeneity level 
#   of alpha = 0.5. Depending on the specified probability, 
#   alpha level, and overall group size, simulation may 
#   be necessary in order to generate the vector of individual
#   probabilities. This is done using p.vec.func() and 
#   requires the user to set a seed in order to reproduce 
#   results.
# This example takes approximately 2.5 minutes to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
set.seed(52613)
OTC(algorithm="ID2", p=0.01, Se=0.95, Sp=0.95, group.sz=50,
obj.fn=c("ET", "MAR", "GR"),
weights=matrix(data=c(1, 1, 10, 10, 0.5, 0.5), 
nrow=3, ncol=2, byrow=TRUE), alpha=0.5)
## End(Not run)

# Find the OTC over all possible
#   testing configurations for a specified group size for
#   non-informative three-stage hierarchical testing
# This example takes approximately 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
OTC(algorithm="D3", p=0.001, Se=0.95, Sp=0.95, group.sz=18,
obj.fn=c("ET", "MAR", "GR"),
weights=matrix(data=c(1, 1), nrow=1, ncol=2, byrow=TRUE))

# Find the OTC for non-informative
#   three-stage hierarchical testing
# This example takes approximately 20 seconds to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
OTC(algorithm="D3", p=0.06, Se=0.90, Sp=0.90, 
group.sz=3:30, obj.fn=c("ET", "MAR", "GR"),
weights=matrix(data=c(1, 1, 10, 10, 100, 100), 
nrow=3, ncol=2, byrow=TRUE))
## End(Not run)

# Find the OTC over all possible configurations 
#   for a specified group size, given a 
#   heterogeneous vector of probabilities.
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
OTC(algorithm="ID3", probabilities=c(0.012, 0.014, 0.011, 
0.012, 0.010, 0.015), Se=0.99, Sp=0.99, group.sz=6, 
obj.fn=c("ET","MAR","GR"), weights=matrix(data=c(1, 1), 
nrow=1, ncol=2, byrow=TRUE), alpha=0.5)

# Calculate the operating characteristics for a specified array size
#   for non-informative array testing without master pooling
# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
OTC(algorithm="A2", p=0.005, Se=0.95, Sp=0.95, group.sz=8, 
obj.fn=c("ET", "MAR"))

# Find the OTC for informative array testing without 
#   master pooling
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta 
#   distribution with p = 0.03 and a heterogeneity level 
#   of alpha = 2. The probabilities are then arranged in 
#   a matrix using the gradient method described in 
#   McMahan et al. (2012b). Depending on the specified 
#   probability, alpha level, and overall group size, 
#   simulation may be necessary in order to generate the 
#   vector of individual probabilities. This is done using 
#   p.vec.func() and requires the user to set a 
#   seed in order to reproduce results.
# This example takes approximately 30 seconds to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
set.seed(1002)
OTC(algorithm="IA2", p=0.03, Se=0.95, Sp=0.95, 
group.sz=3:20, obj.fn=c("ET", "MAR", "GR"),
weights=matrix(data=c(1, 1, 10, 10, 100, 100), 
nrow=3, ncol=2, byrow=TRUE), alpha=2)
## End(Not run)

# Find the OTC for non-informative array testing 
#   with master pooling
# This example takes approximately 20 seconds to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
OTC(algorithm="A2M", p=0.02, Se=0.90, Sp=0.90, 
group.sz=3:20, obj.fn=c("ET", "MAR", "GR"),
weights=matrix(data=c(1, 1, 10, 10, 0.5, 0.5, 2, 2, 
100, 100, 10, 100), nrow=6, ncol=2, byrow=TRUE))
## End(Not run)
</code></pre>

<hr>
<h2 id='p.vec.func'>Generate a vector of probabilities for informative group 
testing algorithms.</h2><span id='topic+p.vec.func'></span>

<h3>Description</h3>

<p>Generate a vector of individual risk probabilities
using an overall probability of disease (i.e., the expected 
value of order statistics from a beta distribution)
for use with informative group testing algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.vec.func(p, alpha, grp.sz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.vec.func_+3A_p">p</code></td>
<td>
<p>overall probability of disease that will be used to 
generate a vector of individual risk probabilities.</p>
</td></tr>
<tr><td><code id="p.vec.func_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter for the beta distribution that
specifies the degree of heterogeneity for the generated
probability vector.</p>
</td></tr>
<tr><td><code id="p.vec.func_+3A_grp.sz">grp.sz</code></td>
<td>
<p>the number of total individuals for which to 
generate risk probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses Michael Black's <code><a href="#topic+beta.dist">beta.dist</a></code>
function to generate a vector of individual risk probabilities,
ordered from least to greatest. Depending on the specified 
probability, alpha level, and overall group size, simulation 
may be necessary in order to generate the vector of individual 
probabilities. For this reason, the user should set a seed in
order to reproduce results. The <kbd>p.vec.func</kbd> function
augments the <code><a href="#topic+beta.dist">beta.dist</a></code> function by checking whether 
simulation is needed before attempting to generate the vector
of individual risk probabilities. See Black et al. (2015)
for additional details on Michael Black's <code><a href="#topic+beta.dist">beta.dist</a></code>
function.
</p>


<h3>Value</h3>

<p>A vector of individual risk probabilities.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Black, M., Bilder, C., Tebbs, J. (2015).
&ldquo;Optimal retesting configurations for hierarchical group testing.&rdquo;
<em>Journal of the Royal Statistical Society. Series C: Applied Statistics</em>, <b>64</b>(4), 693&ndash;710.
ISSN 14679876, doi: <a href="https://doi.org/10.1111/rssc.12097">10.1111/rssc.12097</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Informative.array.prob">Informative.array.prob</a></code> for arranging a vector
of individual risk probabilities in a matrix for informative
array testing without master pooling and <code><a href="#topic+beta.dist">beta.dist</a></code>
for the function on which <kbd>p.vec.func</kbd> is based on.
</p>
<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Individual risk probability functions: <code><a href="#topic+Informative.array.prob">Informative.array.prob</a></code>,
<code><a href="#topic+beta.dist">beta.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8791)
p.vec.func(p=0.03, alpha=0.5, grp.sz=100)

# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(52613)
p.vec.func(p=0.005, alpha=2, grp.sz=40)
</code></pre>

<hr>
<h2 id='plot.bgtDesign'>Plot Results of nDesign or sDesign</h2><span id='topic+plot.nDesign'></span><span id='topic+plot.sDesign'></span>

<h3>Description</h3>

<p>Plots the results of the iteration performed by <kbd>nDesign</kbd> or <kbd>sDesign</kbd> in order to find an experimental design with sufficient power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nDesign'
plot(x, ...)
## S3 method for class 'sDesign'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bgtDesign_+3A_x">x</code></td>
<td>
<p> An object of class <kbd>"nDesign"</kbd> or <kbd>"sDesign"</kbd> as can be created by <code><a href="#topic+nDesign">nDesign</a></code> and <code><a href="#topic+sDesign">sDesign</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.bgtDesign_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code> </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(nDesign(nmax=100, s=30, delta=0.004, p.hyp=0.005,
 alternative="less", method="Score", power=0.8))

</code></pre>

<hr>
<h2 id='plot.binDesign'>Plot Results of binDesign</h2><span id='topic+plot.binDesign'></span>

<h3>Description</h3>

<p>Plot function to visualize the power curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binDesign'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.binDesign_+3A_x">x</code></td>
<td>
<p> an object of class &quot;binDesign, as can be created by <code>link{binDesign}</code>&quot;</p>
</td></tr>
<tr><td><code id="plot.binDesign_+3A_...">...</code></td>
<td>
<p>plot parameters as described in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+binPower">binPower</a></code> for calculation of power </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Find a sample size for which the power to reject
# H0: p &gt;= 0.1 in favor of HA: p &lt; 0.1 
# is at least 0.9 (90 percent) in case that 
# the true proportion is 0.04 (i.e. an absolute delta 
# of 0.06 to the threshold proportion p.hyp=0.1)
# The exact one sided Clopper-Pearson CI shall be used
#  with default confidence level = 0.95.


sasi&lt;-binDesign( nmax=200, delta=0.06, p.hyp=0.1,
 alternative="less", method="CP", power=0.9)

sasi

# Plot the result
 
# plot(sasi)


# for larger sample sizes this can be very time consuming.
# Better to use only a smaller range of n then:

sasi&lt;-binDesign( nmax=c(200,300), delta=0.03, p.hyp=0.1,
 alternative="less", method="CP", power=0.9)

plot(sasi)


</code></pre>

<hr>
<h2 id='plot.poolbin'>
Diagnostic line fit for pool.bin objects
</h2><span id='topic+plot.poolbin'></span>

<h3>Description</h3>

<p>Diagnostic line fit for pool.bin objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poolbin'
plot(x, pch = 16, refline = TRUE, printR2 = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.poolbin_+3A_x">x</code></td>
<td>

<p>an object of class <code>"poolbin"</code>, as can be created by <code><a href="#topic+pooledBin">pooledBin</a></code>
</p>
</td></tr>
<tr><td><code id="plot.poolbin_+3A_pch">pch</code></td>
<td>
<p>symbol type for plotting, see <code>?pch</code>
</p>
</td></tr>
<tr><td><code id="plot.poolbin_+3A_refline">refline</code></td>
<td>

<p>logical, whether or not to add a reference line to the plot
</p>
</td></tr>
<tr><td><code id="plot.poolbin_+3A_printr2">printR2</code></td>
<td>

<p>logical, whether to print R^2 
</p>
</td></tr>
<tr><td><code id="plot.poolbin_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code>plot</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Brad: Maybe drop a line here...
</p>


<h3>Value</h3>

<p>a plot
</p>


<h3>Author(s)</h3>

<p>Brad Biggerstaff
</p>


<h3>References</h3>

<p>Brad: Any reference for this?
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test &lt;- pooledBin(x=c(8,3,1,0), m=c(50,20,10,5),
n=c(10,10,10,10), pt.method="firth", ci.method="lrt")

plot(test)
</code></pre>

<hr>
<h2 id='pool.specific.dorf'>Find the optimal pool sizes for Pool-Specific Optimal Dorfman 
(PSOD) testing</h2><span id='topic+pool.specific.dorf'></span>

<h3>Description</h3>

<p>Find the set of optimal pool sizes for Pool-Specific 
Optimal Dorfman (PSOD) testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool.specific.dorf(p, max.p, se, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.specific.dorf_+3A_p">p</code></td>
<td>
<p>a vector of each individual's probability of infection.</p>
</td></tr>
<tr><td><code id="pool.specific.dorf_+3A_max.p">max.p</code></td>
<td>
<p>the maximum allowable pool size.</p>
</td></tr>
<tr><td><code id="pool.specific.dorf_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="pool.specific.dorf_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the set of optimal pool sizes for PSOD
testing. PSOD testing uses a greedy algorithm and does not consider
all possible sets of pool sizes. See McMahan et al. (2012) for 
additional details on the implementation of PSOD testing.
</p>


<h3>Value</h3>

<p>The optimal set of pool sizes for PSOD testing.
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher S. 
McMahan for McMahan et al. (2012). The function was obtained 
from <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>


<h3>See Also</h3>

<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Informative Dorfman functions: <code><a href="#topic+accuracy.dorf">accuracy.dorf</a></code>,
<code><a href="#topic+characteristics.pool">characteristics.pool</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>,
<code><a href="#topic+opt.info.dorf">opt.info.dorf</a></code>, <code><a href="#topic+opt.pool.size">opt.pool.size</a></code>,
<code><a href="#topic+thresh.val.dorf">thresh.val.dorf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
set.seed(8135)
p.vec &lt;- p.vec.func(p=0.02, alpha=1, grp.sz=10)
pool.specific.dorf(p=p.vec, max.p=3, se=0.95, sp=0.95)
</code></pre>

<hr>
<h2 id='pooledBin'>
Confidence intervals for a single proportion
</h2><span id='topic+pooledBin'></span>

<h3>Description</h3>

<p>Calculates confidence intervals for a single proportion based on pooled testing experiments containing various different pool sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledBin(x, m, n = rep(1, length(x)),
 pt.method = c("firth", "gart", "bc-mle", "mle", "mir"),
 ci.method = c("skew-score", "bc-skew-score", "score",
 "lrt", "wald", "mir"),
 scale = 1, alpha = 0.05, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledBin_+3A_x">x</code></td>
<td>
<p> a vector, specifying the observed number of positive pools, among the number of pools tested (<code>n</code>)</p>
</td></tr>
<tr><td><code id="pooledBin_+3A_m">m</code></td>
<td>
<p> a vector of pool sizes, must have the same length as, <code>x</code></p>
</td></tr>
<tr><td><code id="pooledBin_+3A_n">n</code></td>
<td>
<p> a vector of the corresponding number of pools of sizes <code>m</code></p>
</td></tr>
<tr><td><code id="pooledBin_+3A_pt.method">pt.method</code></td>
<td>
<p> a character string, specifying the point estimate to compute, with the following options: <code>"bc-mle"</code> bias-corrected MLE, the default; <code>"mle"</code> MLE, and <code>"mir"</code> MIR. </p>
</td></tr>
<tr><td><code id="pooledBin_+3A_ci.method">ci.method</code></td>
<td>
<p> a character string, specifying the confidence interval to compute, with options: <code>"skew-score"</code> skewness-corrected, the default, <code>"score"</code> the score, <code>"bc-skew-score"</code> bias- and skewness-corrected 
<code>"lrt"</code> likelihood ratio test, <code>"wald"</code> wald, and <code>"mir"</code> MIR.</p>
</td></tr>
<tr><td><code id="pooledBin_+3A_scale">scale</code></td>
<td>
<p> a single numeric, coefficient to scale the point estimates and intervals bounds in the print and summary method (<code><a href="#topic+print.poolbin">print.poolbin</a></code>, <code><a href="#topic+summary.poolbin">summary.poolbin</a></code>) </p>
</td></tr>
<tr><td><code id="pooledBin_+3A_alpha">alpha</code></td>
<td>
<p> a single numeric, specifying the type-I-error level</p>
</td></tr>
<tr><td><code id="pooledBin_+3A_tol">tol</code></td>
<td>
<p>accuracy required for iterations in internal functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Point estimation: bias preventative (&quot;firth&quot;) and bias corrected (&quot;gart&quot;) estimators are recommended, with details described in Hepworth G, Biggerstaff BJ (2017). Use of MLE (<code>"mle"</code>), and MIR (<code>"mir"</code>) estimators is not recommended.
</p>
<p>Confidence intervals: Note, that the methods &quot;mir&quot; and &quot;wald&quot; can not be recommended, because they return too narrow intervals in relevant situations, &quot;mir&quot; because it ignores the pooling, and &quot;wald&quot; because it relies on simple large sample methods.
For computational details and simulation results of the remaining methods, see Biggerstaff (2008).</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>the estimated proportion</p>
</td></tr>
<tr><td><code>lcl</code></td>
<td>
<p>the lower confidence limit</p>
</td></tr>
<tr><td><code>ucl</code></td>
<td>
<p>the upper confidence limit</p>
</td></tr>
<tr><td><code>pt.method</code></td>
<td>
<p>the method used for point estimation </p>
</td></tr>
<tr><td><code>ci.method</code></td>
<td>
<p>the method used for interval estimation </p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the type-I-error level </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the numbers of postive pools </p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>the size of the pools </p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the numbers of pools with corresponding pool sizes m</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>Scaling coefficient for the output</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brad Biggerstaff</p>


<h3>References</h3>

<p><em>Walter SD, Hildreth SW, Beaty BJ:</em> Estimation of infection rates in population of organisms using pools of variable size. <em>Am J Epidemiol 1980, 112(1):124-128</em>
</p>
<p><em>Hepworth G: Estimation of proportions by group testing. PhD Dissertation. 
Melbourne, Australia: The University of Melbourne; 1999.</em>
</p>
<p><em>Biggerstaff BJ (2008)</em>: Confidence interval for the difference of proportions estmimated from pooled samples. <em>Journal of Agricultural Biological and Environmental Statistics 2008, 13(4):478-496.</em>
</p>
<p><em>Hepworth G, Biggerstaff BJ:</em> Bias correction in estimating Proportions by pooled testing. <em>JABES 20178, to appear.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgtvs">bgtvs</a></code> to compute exact confidence intervals for one proportion in designs with different pool sizes. Note that <code>bgtvs</code> can only deal with a limited number of different pool sizes.
</p>
<p><code><a href="#topic+bgtCI">bgtCI</a></code> to compute exact or asymptotic confidence intervals for one proportion in designs with a common pool size in all pools.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Consider an imaginary example, where pools of size
# 1, 5, 10 and 50 are tested, 5 pools of each size
# among the 5 pools with size 1 and 5, no pool is positive,
# while among the 5 pools of size 10 and 50, 1 and 2 positive
# pools are identified, respectively. 

x1 &lt;- c(0,0,1,2)
m1 &lt;- c(1,5,10,50)
n1 &lt;- c(5,5,5,5)

pooledBin(x=x1, m=m1, n=n1)
pooledBin(x=x1, m=m1, n=n1, scale=1000)

pooledBin(x=x1, m=m1, n=n1)

summary(pooledBin(x=x1, m=m1, n=n1), scale=1000)

# For another population, tested with the same design, one might find:
# 1 positive result among the pools pooling 5 elements,
# no positive result among the pools pooling 10 elements,
# 4 positive results among the pools pooling 50 elements,

x2&lt;-c(0,1,0,4)
m2 &lt;- c(1,5,10,50)
n2 &lt;- c(5,5,5,5)

pooledBin(x=x2, m=m2, n=n2)

# Some other methods for the confidence bounds:

pooledBin(x=x2, m=m2, n=n2, ci.method="lrt")


###
# Reproducing some of the estimates from Table 1 in
# Hepworth &amp; Biggerstaff (2017):

pooledBin(x=c(1,2), m=c(20,5), n=c(8,8), pt.method="firth", ci.method="lrt")

pooledBin(x=c(7,8), m=c(20,5), n=c(8,8), pt.method="firth", ci.method="lrt")

</code></pre>

<hr>
<h2 id='pooledBinDiff'>
Confidence intervals for the difference of proportions
</h2><span id='topic+pooledBinDiff'></span>

<h3>Description</h3>

<p>The function calculates confidence intervals for the difference of two proportions based on pooled testing experiments containing various different pool sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledBinDiff(x1, m1, x2, m2, n1 = rep(1, length(x1)),
 n2 = rep(1, length(x2)), 
 pt.method = c("firth", "gart", "bc-mle", "mle", "mir"), 
 ci.method = c("skew-score", "bc-skew-score", "score", "lrt", "wald", "mir"),
 scale = 1, alpha = 0.05, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledBinDiff_+3A_x1">x1</code></td>
<td>
<p> a vector, specifying the observed number of positive pools, among the number of pools tested (<code>n1</code>) in population 1</p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_m1">m1</code></td>
<td>
<p> a vector of corresponding pool sizes in population 1, must have the same length as <code>x1</code></p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_x2">x2</code></td>
<td>
<p> a vector, specifying the observed number of positive pools, among the number of pools tested (<code>n2</code>) in population 2</p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_m2">m2</code></td>
<td>
<p> a vector of corresponding pool sizes in population 2, must have the same length as <code>x2</code></p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_n1">n1</code></td>
<td>
<p> a vector of the corresponding number of pools with sizes <code>m1</code></p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_n2">n2</code></td>
<td>
<p> a vector of the corresponding number of pools with sizes <code>m2</code></p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_pt.method">pt.method</code></td>
<td>
<p>a character string, specifying the point estimator to compute, with the following options: <code>"firth"</code>: recommended bias-corrected estimator (Hepworth &amp; Biggerstaff, 2017), the default; <code>"gart"</code> bias-corrected MLE (Biggerstaff, 2008); <code>"bc-mle"</code>: same as <code>"gart"</code>, kept for backward compatibility ; <code>"mle"</code> MLE, and <code>"mir"</code> MIR. </p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_ci.method">ci.method</code></td>
<td>
<p>a character string, specifying the confidence interval to compute, with options: <code>"skew-score"</code> skewness-corrected, the default, <code>"score"</code> the score, <code>"bc-skew-score"</code> bias- and skewness-corrected 
<code>"lrt"</code> likelihood ratio test. See Biggerstaff (2008) for details. Further, the options <code>"wald"</code> wald and <code>"mir"</code> MIR are available but are not recommended.</p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_scale">scale</code></td>
<td>
<p> a single numeric, coefficient to scale the point estimates and intervals bounds in the print and summary method (<code><a href="#topic+print.poolbindiff">print.poolbindiff</a></code>, <code><a href="#topic+summary.poolbindiff">summary.poolbindiff</a></code>) </p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_alpha">alpha</code></td>
<td>
<p> a single numeric, specifying the type-I-error level</p>
</td></tr>
<tr><td><code id="pooledBinDiff_+3A_tol">tol</code></td>
<td>
<p>accuracy required for iterations in internal functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Point estimation: bias preventative (&quot;firth&quot;) and bias corrected (&quot;gart&quot;) estimators are recommended, with details described in Hepworth G, Biggerstaff BJ (2017). Use of MLE (<code>"mle"</code>), and MIR (<code>"mir"</code>) estimators is not recommended.
</p>
<p>Confidence intervals: Note, that the methods &quot;mir&quot; and &quot;wald&quot; can not be recommended, because they return too narrow intervals in relevant situations, &quot;mir&quot; because it ignores the pooling, and &quot;wald&quot; because it relies on simple large sample methods.
For computational details and simulation results of the remaining methods, see Biggerstaff (2008).</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>the estimated difference of proportions</p>
</td></tr>
<tr><td><code>lcl</code></td>
<td>
<p>the lower confidence limit</p>
</td></tr>
<tr><td><code>ucl</code></td>
<td>
<p>the upper confidence limit</p>
</td></tr>
<tr><td><code>pt.method</code></td>
<td>
<p>the method used for point estimation </p>
</td></tr>
<tr><td><code>ci.method</code></td>
<td>
<p>the method used for interval estimation </p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the type-I-error level </p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>Scaling coefficient for the output</p>
</td></tr>
<tr><td><code>x1</code></td>
<td>
<p>the numbers of postive pools in population 1</p>
</td></tr>
<tr><td><code>m1</code></td>
<td>
<p>the size of the pools in population 1</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>the numbers of pools with corresponding pool sizes m1 in population 1</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>
<p>the numbers of postive pools in population 2</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>the size of the pools in population 2</p>
</td></tr>
<tr><td><code>n2</code></td>
<td>
<p>the numbers of pools with corresponding pool sizes m1 in population 2</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brad Biggerstaff</p>


<h3>References</h3>

<p><em>Walter SD, Hildreth SW, Beaty BJ:</em> Estimation of infection rates in population of organisms using pools of variable size. <em>Am J Epidemiol 1980, 112(1):124-128</em>
</p>
<p><em>Hepworth G: Estimation of proportions by group testing. PhD Dissertation. 
Melbourne, Australia: The University of Melbourne; 1999.</em>
</p>
<p><em>Biggerstaff BJ (2008)</em>: Confidence interval for the difference of proportions estmimated from pooled samples. <em>Journal of Agricultural Biological and Environmental Statistics 2008, 13(4):478-496.</em>
</p>
<p><em>Hepworth G, Biggerstaff BJ:</em> Bias correction in estimating Proportions by pooled testing. <em>JABES 2017, to appear.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Consider an imaginary example, where pools of size
# 1, 5, 10 and 50 are tested, 5 pools of each size. The same 
# design is applied to estimate the prevalence in
# two populations: 
# In population 1, among the 5 pools with size 1 and 5,
# no positive pool is observed,
# while among the 5 pools of size 10 and 50, 1 and 2 positive
# pools are identified, respectively.
 
# In population 2, 1 positive result is observed
# among the 5 pools each pooling 5 elements,
# no positive result among the pools pooling 10 elements,
# 4 positive results among the pools pooling 50 elements,

x1 &lt;- c(0,0,1,2)
m &lt;- c(1,5,10,50)
n &lt;- c(5,5,5,5)

x2&lt;-c(0,1,0,4)

pooledBinDiff(x1=x1, m1=m, x2=x2, m2=m, n1=n, n2=n)

summary(pooledBinDiff(x1=x1, m1=m, x2=x2, m2= m, n1=n, n2=n), scale=1000)

# Compare recommended methods:

pooledBinDiff(x1=x1, m1=m, x2=x2, m2= m, n1=n, n2=n, pt.method="mle",
 ci.method="lrt")

pooledBinDiff(x1=x1, m1=m, x2=x2, m2= m, n1=n, n2=n, pt.method="mle",
 ci.method="score") 

pooledBinDiff(x1=x1, m1=m, x2=x2, m2= m, n1=n, n2=n, pt.method="mle",
 ci.method="skew-score")
  
</code></pre>

<hr>
<h2 id='predict.gt'>
Predict Method for Group Testing Model Fits
</h2><span id='topic+predict.gt'></span>

<h3>Description</h3>

<p>Obtains predictions for individual observations and optionally estimates standard errors of those predictions from objects of class <kbd>"gt"</kbd> or <kbd>"gt.mp"</kbd> returned by <kbd>gtreg</kbd> and <kbd>gtreg.mp</kbd>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gt'
predict(object, newdata, type = c("link", "response"),
 se.fit = FALSE, conf.level = NULL, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gt_+3A_object">object</code></td>
<td>

<p>a fitted object of class <kbd>"gt"</kbd> or <kbd>"gt.mp"</kbd>.  
</p>
</td></tr>
<tr><td><code id="predict.gt_+3A_newdata">newdata</code></td>
<td>

<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted linear predictors are used.
</p>
</td></tr>
<tr><td><code id="predict.gt_+3A_type">type</code></td>
<td>

<p>the type of prediction required. The option <kbd>"link"</kbd> is on the scale of the linear predictors; the alternative <kbd>"response"</kbd> is on the scale of the response variable. Thus for the binomial model the <kbd>"link"</kbd> predictions are of log-odds (probabilities on logit scale) and <kbd>type = "response"</kbd> gives the predicted probabilities. 
</p>
</td></tr>
<tr><td><code id="predict.gt_+3A_se.fit">se.fit</code></td>
<td>

<p>logical switch indicating if standard errors are required.
</p>
</td></tr>
<tr><td><code id="predict.gt_+3A_conf.level">conf.level</code></td>
<td>

<p>confidence level of the interval of the predicted values.
</p>
</td></tr>
<tr><td><code id="predict.gt_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <kbd>newdata</kbd>. The default is to predict <kbd>NA</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.gt_+3A_...">...</code></td>
<td>
<p> currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <kbd>newdata</kbd> is omitted the predictions are based on the data used for the fit. When <kbd>newdata</kbd> is present and contains missing values, how the missing values will be dealt with is determined by the <kbd>na.action</kbd> argument. In this case, if <kbd>na.action = na.omit</kbd> omitted cases will not appear, whereas if <kbd>na.action = na.exclude</kbd> they will appear (in predictions and standard errors), with value <kbd>NA</kbd>. See also <kbd>napredict</kbd>. 
</p>


<h3>Value</h3>

<p>If <kbd>se = FALSE</kbd>, a vector or matrix of predictions. If <kbd>se = TRUE</kbd>, a list with components
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p> Predictions </p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p> Estimated standard errors </p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p> Lower bound of the confidence interval if calculated </p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p> Upper bound of the confidence interval if calculated </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(hivsurv)

fit1 &lt;- gtreg(formula = groupres ~ AGE + EDUC., data = hivsurv,  
  groupn = gnum, sens = 0.9, spec = 0.9, linkf = "logit", method = "V")
pred.data &lt;- data.frame(AGE = c(15, 25, 30), EDUC. = c(1, 3, 2))
predict(object = fit1, newdata = pred.data, type = "link", se.fit = TRUE)
predict(object = fit1, newdata = pred.data, type = "response", 
  se.fit = TRUE, conf.level = 0.9)
predict(object = fit1, type = "response", se.fit = TRUE, conf.level = 0.9)


</code></pre>

<hr>
<h2 id='print.bgt'> Print Functions for Group Testing CIs and Tests for One Proportion </h2><span id='topic+print.bgtCI'></span><span id='topic+print.binCI'></span><span id='topic+print.bgtTest'></span><span id='topic+print.binTest'></span><span id='topic+print.bgtvs'></span>

<h3>Description</h3>

<p> Print objects of class <kbd>"bgtCI"</kbd>, <kbd>"bgtTest"</kbd>, <kbd>"bgtvs"</kbd>, <kbd>"binCI"</kbd>, and <kbd>"binTest"</kbd>  </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgtCI'
print(x, ...)
## S3 method for class 'binCI'
print(x, ...)
## S3 method for class 'bgtTest'
print(x, ...)
## S3 method for class 'binTest'
print(x, ...)
## S3 method for class 'bgtvs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bgt_+3A_x">x</code></td>
<td>
<p> an object of the corresponding class</p>
</td></tr>
<tr><td><code id="print.bgt_+3A_...">...</code></td>
<td>
<p>currently only <code>digits</code> is passed to <code>signif</code> for appropriate rounding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out.
</p>

<hr>
<h2 id='print.bgtDesign'>Print Functions for nDesign and sDesign</h2><span id='topic+print.nDesign'></span><span id='topic+print.sDesign'></span>

<h3>Description</h3>

<p>Print function for results of functions <code><a href="#topic+nDesign">nDesign</a></code>, <code><a href="#topic+nDesign">nDesign</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nDesign'
print(x, ...)
## S3 method for class 'sDesign'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bgtDesign_+3A_x">x</code></td>
<td>
<p> An object of class <kbd>"nDesign"</kbd> or <kbd>"sDesign"</kbd> </p>
</td></tr>
<tr><td><code id="print.bgtDesign_+3A_...">...</code></td>
<td>
<p> currently only <code>digits</code> is passed to <code>signif</code> for appropriate rounding </p>
</td></tr>
</table>

<hr>
<h2 id='print.binDesign'> Print Function for binDesign </h2><span id='topic+print.binDesign'></span>

<h3>Description</h3>

 
<p>Print objects of class <kbd>"binDesign"</kbd>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binDesign'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.binDesign_+3A_x">x</code></td>
<td>
<p> an object of class &quot;binDesign&quot;</p>
</td></tr>
<tr><td><code id="print.binDesign_+3A_...">...</code></td>
<td>
<p>currently only <code>digits</code> is passed to <code>signif</code> for appropriate rounding</p>
</td></tr>
</table>

<hr>
<h2 id='print.gt'>
Print methods for objects of classes &quot;gt&quot; and &quot;gt.mp&quot;
</h2><span id='topic+print.gt'></span>

<h3>Description</h3>

<p>Print methods for objects of classes <kbd>"gt"</kbd> and <kbd>"gt.mp"</kbd>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gt'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gt_+3A_x">x</code></td>
<td>

<p>objects of class <kbd>"gt"</kbd> and <kbd>"gt.mp"</kbd>, respectively
</p>
</td></tr>
<tr><td><code id="print.gt_+3A_digits">digits</code></td>
<td>

<p>the digits for rounding
</p>
</td></tr>
<tr><td><code id="print.gt_+3A_...">...</code></td>
<td>

<p>currently not used
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out
</p>

<hr>
<h2 id='print.poolbindiff'>
Print methods for classes &quot;poolbin&quot; and &quot;poolbindiff&quot;
</h2><span id='topic+print.poolbin'></span><span id='topic+print.poolbindiff'></span>

<h3>Description</h3>

<p>Print methods for objects of classes <code>"poolbin"</code> and <code>"poolbindiff"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poolbin'
print(x, scale = x$scale, ...)
## S3 method for class 'poolbindiff'
print(x, scale = x$scale, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.poolbindiff_+3A_x">x</code></td>
<td>
<p> An object of class &quot;poolbin&quot; or &quot;poolbindiff&quot; (<code><a href="#topic+pooledBin">pooledBin</a></code>, <code><a href="#topic+pooledBinDiff">pooledBinDiff</a></code>)</p>
</td></tr>
<tr><td><code id="print.poolbindiff_+3A_scale">scale</code></td>
<td>
<p> A coefficient to scale the point estimate and interval bounds </p>
</td></tr>
<tr><td><code id="print.poolbindiff_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out.
</p>

<hr>
<h2 id='print.summary.gt'>
Print Functions for summary.gt.mp and summary.gt
</h2><span id='topic+print.summary.gt.mp'></span><span id='topic+print.summary.gt'></span>

<h3>Description</h3>

<p>Print function for objects obtained by calling <code><a href="#topic+summary.gt.mp">summary.gt.mp</a></code> and <code><a href="#topic+summary.gt">summary.gt</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.gt.mp'
print(x, digits = max(3, getOption("digits") - 3),
 signif.stars = getOption("show.signif.stars"), ...)
## S3 method for class 'summary.gt'
print(x, digits = max(3, getOption("digits") - 3),
 signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.gt_+3A_x">x</code></td>
<td>

<p>an object of class <kbd>"summary.gt.mp"</kbd> or <kbd>"summary.gt"</kbd>
</p>
</td></tr>
<tr><td><code id="print.summary.gt_+3A_digits">digits</code></td>
<td>

<p>digits for rounding
</p>
</td></tr>
<tr><td><code id="print.summary.gt_+3A_signif.stars">signif.stars</code></td>
<td>

<p>logical, indicating whether significance stars should be shown
</p>
</td></tr>
<tr><td><code id="print.summary.gt_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <kbd>printCoefmat</kbd>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out.
</p>

<hr>
<h2 id='residuals.gt'>
Extract Model Residuals From a Fitted Group Testing Model
</h2><span id='topic+residuals.gt'></span>

<h3>Description</h3>

<p><kbd>residuals.gt</kbd> is a function which extracts model residuals from objects of class <kbd>"gt"</kbd> returned by <code><a href="#topic+gtreg">gtreg</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gt'
residuals(object, type = c("deviance", "pearson", "response"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.gt_+3A_object">object</code></td>
<td>

<p>an object of class <kbd>"gt"</kbd> from which the model residuals are to be extracted.
</p>
</td></tr>
<tr><td><code id="residuals.gt_+3A_type">type</code></td>
<td>

<p>the type of residuals which should be returned. The alternatives are: <kbd>"deviance"</kbd> (default), <kbd>"pearson"</kbd>, and <kbd>"response"</kbd>.
</p>
</td></tr>
<tr><td><code id="residuals.gt_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Residuals of group responses extracted from the object <kbd>object</kbd>.
</p>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(hivsurv)

fit1 &lt;- gtreg(formula = groupres ~ AGE * EDUC., data = hivsurv, groupn = gnum,  
              linkf = "probit")
residuals.gt(object = fit1, type = "pearson")
residuals.gt(object = fit1, type = "deviance")

</code></pre>

<hr>
<h2 id='sDesign'>Iterate Group Size for a One-Parameter Group Testing Problem</h2><span id='topic+sDesign'></span>

<h3>Description</h3>

<p>Increasing of group size s for a fixed number of groups n in a binomial group testing design,
until a pre-specified power is achieved. Control of bias during iteration. A hypothetical
threshold proportion <kbd>p.hyp</kbd> and the absolute difference <kbd>delta</kbd> to be detected have to be specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sDesign(n, smax, delta, p.hyp, conf.level = 0.95,
 power = 0.8, alternative = "two.sided", method = "CP", biasrest = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sDesign_+3A_n">n</code></td>
<td>
<p>integer, fixed sample size (number of assays) </p>
</td></tr>
<tr><td><code id="sDesign_+3A_smax">smax</code></td>
<td>
<p>integer, maximal group size allowed in planning of the design </p>
</td></tr>
<tr><td><code id="sDesign_+3A_delta">delta</code></td>
<td>
<p>absolute difference between the threshold and the true proportion which shall be detectable with specified power </p>
</td></tr>
<tr><td><code id="sDesign_+3A_p.hyp">p.hyp</code></td>
<td>
<p>threshold proportion to test against in the hypothesis, specify as a value between 0 and 1 </p>
</td></tr>
<tr><td><code id="sDesign_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the decision, default is 0.95 </p>
</td></tr>
<tr><td><code id="sDesign_+3A_power">power</code></td>
<td>
<p>level of power to be achieved to be specified as a probability between 0 and 1 </p>
</td></tr>
<tr><td><code id="sDesign_+3A_alternative">alternative</code></td>
<td>
<p>character string, defining the alternative hypothesis, either 'two.sided', 'less' or 'greater'
where <kbd>'less'</kbd> calculates the probability that p.hyp is excluded by an upper confidence limit for a true proportion <kbd>p.hyp</kbd> - <kbd>delta</kbd>,
<kbd>'greater'</kbd> calculates the probability that p.hyp is excluded by a lower confidence limit for a true proportion of <kbd>p.hyp</kbd> + <kbd>delta</kbd> .
<kbd>'two.sided'</kbd> calculates min(power(<kbd>p.hyp</kbd> - <kbd>delta</kbd>, <kbd>p.hyp</kbd> + <kbd>delta</kbd>)) for a two.sided CI, thus can result in much lower power.
Note that coverage probability and power are not necessarily symmetric for upper and lower bound of binomial CI. </p>
</td></tr>
<tr><td><code id="sDesign_+3A_method">method</code></td>
<td>
<p> character string specifying the CImethod to be used for evaluation, see argument <kbd>method</kbd> in <code><a href="#topic+bgtCI">bgtCI</a></code> </p>
</td></tr>
<tr><td><code id="sDesign_+3A_biasrest">biasrest</code></td>
<td>
<p> value between 0 and 1 specifying the absolute bias maximally allowed </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power of a confidence interval here is defined as the probability that a confidence interval or limit excludes the threshold parameter (p.hyp) of the hypothesis. 
This function increases size of groups (number of units in a bulk sample) until a pre-specified power is reached.
Since the power does not increase monotone with increasing s for binomial proportions but oscillates between local maxima and minima, 
the simple iteration given here will generally result in selecting those s, for which the given CI method shows a local minimum of 
coverage if the null hypothesis is true.
Since the positive bias of the estimator in group testing increases with increasing group size, it is checked whether bias is smaller than a 
pre-specified value (bias.rest). If bias violates this restriction for a given combination n, s, delta, s will not be further increased the
actual power of the last acceptable group size s is returned.
</p>


<h3>Value</h3>

<p> A list containing:
</p>
<table>
<tr><td><code>sout</code></td>
<td>
<p>the group size necessary to met the conditions</p>
</td></tr>
<tr><td><code>powerout</code></td>
<td>
<p>the exact power for the specified parameters and the group size</p>
</td></tr>
<tr><td><code>biasout</code></td>
<td>
<p>the bias for the specified parameters and the iterated group size</p>
</td></tr>
</table>
<p>and a number of values specified in the function call or produced in the iteration.
</p>


<h3>References</h3>

 
<p><em>Schaarschmidt F (2007)</em> Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing. <em>Communications in Biometry and Crop Science 2 (1), 32-40.</em>
http://agrobiol.sggw.waw.pl/cbcs/
</p>
<p><em>Swallow WH (1985)</em> Group testing for estimating infection rates and probabilities of disease transmission. <em>Phytopathology 75 (8), 882-889.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.sDesign">plot.sDesign</a></code> can be used to plot th iteration of this function
</p>
<p><code><a href="#topic+bgtPower">bgtPower</a></code>: calculation of power and bias depending on n, s, delta, p.hyp, conf.level, method
<code><a href="#topic+nDesign">nDesign</a></code>:  function to iteratively optimize sample size(number of groups)n for a given group size s
<code><a href="#topic+estDesign">estDesign</a></code>:  function to choose group size s according to the minimal mse of the estimator, as given in Swallow (1985)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Assume that objective is to show that a proportion
## is smaller than 0.005 (i.e. 0.5%) with a 
## power of 0.80 (i.e. 80%) if the unknown proportion
## in the population is 0.003 (i.e. 0.3%), thus a 
## delta = 0.002 shall be detected. A 95-per-cent 
## Clopper-Pearson CI (corresponding to an exact test)
## shall be used. The maximal number of groups might 
## be 30 where the assay sensitivity is not limited 
## until groupsize s = 100.

sDesign(smax=100, n=30, delta=0.002, p.hyp=0.005,
 alternative="less", method="CP", power=0.8)

## One might accept to detect delta=0.004,
## i.e. accepting to reject H0: p&gt;=0.005 with 
## power 80 per cent when the true proportion is 0.001:

sDesign(smax=100, n=30, delta=0.004, p.hyp=0.005,
 alternative="less", method="CP", power=0.8)

sDesign(smax=100, n=30, delta=0.004, p.hyp=0.005,
 alternative="less", method="Score", power=0.8)

</code></pre>

<hr>
<h2 id='sim.gt'>
Simulation Function for Group Testing Data
</h2><span id='topic+sim.gt'></span>

<h3>Description</h3>

<p>Simulates data in group testing form ready to be fit by <kbd>gtreg</kbd>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.gt(x = NULL, gshape = 20, gscale = 2, par,
     linkf = c("logit", "probit", "cloglog"),
     sample.size, group.size, sens = 1, spec = 1,
     sens.ind = NULL, spec.ind = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.gt_+3A_x">x</code></td>
<td>

<p>a matrix of user-submitted covariates to simulate the data with, defaults to <kbd>NULL</kbd> in which case a gamma distribution is used to generate the covariates automatically
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_gshape">gshape</code></td>
<td>

<p>shape parameter of gamma distribution, must be non-negative, set to be 20 by default
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_gscale">gscale</code></td>
<td>

<p>scale parameter of gamma distribution, must be strictly positive, set to be 2 by default
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_par">par</code></td>
<td>

<p>the true coefficients in the linear predictor 
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_sample.size">sample.size</code></td>
<td>

<p>sample size of simulated data 
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_linkf">linkf</code></td>
<td>

<p>a character string specifying one of the three link functions to be used: <kbd>"logit"</kbd> (default) or <kbd>"probit"</kbd> or <kbd>"cloglog"</kbd>
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_group.size">group.size</code></td>
<td>

<p>group size in pooling individual samples
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_sens">sens</code></td>
<td>

<p>sensitivity of the group tests, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_spec">spec</code></td>
<td>

<p>specificity of the group tests, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_sens.ind">sens.ind</code></td>
<td>

<p>sensitivity of the individual retests, set to be equal to <kbd>sens</kbd> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="sim.gt_+3A_spec.ind">spec.ind</code></td>
<td>

<p>specificity of the individual retests, set to be equal to <kbd>spec</kbd> if not specified otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><kbd>sim.gt</kbd> generates group testing data in simple pooling form. The covariates are either specified by the <kbd>x</kbd> argument or they are generated from a gamma distribution with a given <kbd>gshape</kbd> and <kbd>gscale</kbd>. The individual probabilities are calculated from the covariates, the coefficients given in <kbd>par</kbd>, and the link function specified through <kbd>linkf</kbd>. The true binary individual responses are then simulated from the individual probabilities. The true group responses are found from the individual responses within the groups (i.e., if at least one response is positive, the group is positive; otherwise, the group response is negative). Finally, the observed group responses are simulated using the given <kbd>sens</kbd> and <kbd>spec</kbd>. Individual retests are simulated from <kbd>sens.ind</kbd> and <kbd>spec.ind</kbd> for samples in observed positive groups. Note that with a given <kbd>group.size</kbd>, the last group may have less individuals. 
</p>


<h3>Value</h3>

<p><kbd>sim.gt</kbd> returns a data frame with the following columns:
</p>
<table>
<tr><td><code>gres</code></td>
<td>
<p>the group response</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the covariate</p>
</td></tr>
<tr><td><code>groupn</code></td>
<td>
<p>the group number</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>the actual individual response</p>
</td></tr>
<tr><td><code>retest</code></td>
<td>
<p>the results of individual retests</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtreg">gtreg</a></code>, <code><a href="#topic+gtreg.mp">gtreg.mp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(46)
gt.data &lt;- sim.gt(par = c(-12, 0.2), sample.size = 700, group.size = 5)

x1 &lt;- sort(runif(100, 0, 30))
x2 &lt;- rgamma(100, shape=17, scale=1.5)
gt.data &lt;- sim.gt(x = cbind(x1,x2), par=c(-14, 0.2, 0.3),
 group.size = 4, sens = 0.98, spec = 0.98)

</code></pre>

<hr>
<h2 id='sim.halving'>
Simulation Function for Group Testing Data for the Halving Protocol
</h2><span id='topic+sim.halving'></span>

<h3>Description</h3>

<p>Simulates data in group testing form ready to be fit by <kbd>gtreg.halving</kbd>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.halving(x = NULL, gshape = 20, gscale = 2, par,
     linkf = c("logit", "probit", "cloglog"),
     sample.size, group.size, sens = 1, spec = 1,
     sens.ind = NULL, spec.ind = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.halving_+3A_x">x</code></td>
<td>

<p>a matrix of user-submitted covariates to simulate the data with, defaults to <kbd>NULL</kbd> in which case a gamma distribution is used to generate the covariates automatically
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_gshape">gshape</code></td>
<td>

<p>shape parameter of gamma distribution, must be non-negative, set to be 20 by default
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_gscale">gscale</code></td>
<td>

<p>scale parameter of gamma distribution, must be strictly positive, set to be 2 by default
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_par">par</code></td>
<td>

<p>the true coefficients in the linear predictor 
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_sample.size">sample.size</code></td>
<td>

<p>sample size of simulated data 
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_linkf">linkf</code></td>
<td>

<p>a character string specifying one of the three link functions to be used: <kbd>"logit"</kbd> (default) or <kbd>"probit"</kbd> or <kbd>"cloglog"</kbd>
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_group.size">group.size</code></td>
<td>

<p>group size in pooling individual samples
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_sens">sens</code></td>
<td>

<p>sensitivity of the group tests, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_spec">spec</code></td>
<td>

<p>specificity of the group tests, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_sens.ind">sens.ind</code></td>
<td>

<p>sensitivity of the individual retests, set to be equal to <kbd>sens</kbd> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="sim.halving_+3A_spec.ind">spec.ind</code></td>
<td>

<p>specificity of the individual retests, set to be equal to <kbd>spec</kbd> if not specified otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><kbd>sim.halving</kbd> generates group testing data for the halving protocol. The covariates are either specified by the <kbd>x</kbd> argument or they are generated from a gamma distribution with a given <kbd>gshape</kbd> and <kbd>gscale</kbd>. The individual probabilities are calculated from the covariates, the coefficients given in <kbd>par</kbd>, and the link function specified through <kbd>linkf</kbd>. The true binary individual responses are then simulated from the individual probabilities. The group, subgroup, and individual retests are simulated using the given <kbd>sens</kbd> and <kbd>spec</kbd> under the halving protocol. 
</p>


<h3>Value</h3>

<p><kbd>sim.halving</kbd> returns a data frame with the following columns:
</p>
<table>
<tr><td><code>gres</code></td>
<td>
<p>the group response</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the covariate</p>
</td></tr>
<tr><td><code>groupn</code></td>
<td>
<p>the group number</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>the actual individual response</p>
</td></tr>
<tr><td><code>retest</code></td>
<td>
<p>the results of individual retests</p>
</td></tr>
<tr><td><code>subgroup</code></td>
<td>
<p>the subgroup number</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtreg.halving">gtreg.halving</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(46)
gt.data &lt;- sim.halving(par = c(-6, .1), gshape = 17, gscale = 1.4,
               sample.size = 5000, group.size = 5,
               sens = 0.95, spec = 0.95)

</code></pre>

<hr>
<h2 id='sim.mp'>
Simulation Function for Group Testing Data with Matrix Pooling Design
</h2><span id='topic+sim.mp'></span>

<h3>Description</h3>

<p>Simulates data in group testing form ready to be fit by <kbd>gtreg.mp</kbd>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.mp(x = NULL, gshape = 20, gscale = 2, par,
    linkf = c("logit", "probit", "cloglog"),
    n.row, n.col, sens = 1, spec = 1,
    sens.ind = NULL, spec.ind = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.mp_+3A_x">x</code></td>
<td>

<p>a matrix of user-submitted covariates to simulate the data with, defaults to <kbd>NULL</kbd> in which case a gamma distribution is used to generate the covariates automatically.
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_gshape">gshape</code></td>
<td>

<p>shape parameter of gamma distribution, must be non-negative, set to be 20 by default
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_gscale">gscale</code></td>
<td>

<p>scale parameter of gamma distribution, must be strictly positive, set to be 2 by default
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_par">par</code></td>
<td>

<p>the true coefficients in the linear predictor 
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_linkf">linkf</code></td>
<td>
<p>a character string specifying one of the three link functions to be used: <kbd>"logit"</kbd> (default) or <kbd>"probit"</kbd> or <kbd>"cloglog"</kbd>
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_n.row">n.row</code></td>
<td>

<p>a vector that specifies the number of rows in each matrix, a scalar if only one matrix is simulated
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_n.col">n.col</code></td>
<td>

<p>a vector that specifies the number of columns in each matrix, a scalar if only one matrix is simulated
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_sens">sens</code></td>
<td>

<p>sensitivity of the group tests, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_spec">spec</code></td>
<td>

<p>specificity of the group tests, set to be 1 by default.
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_sens.ind">sens.ind</code></td>
<td>

<p>sensitivity of the individual retests, set to be equal to sens if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="sim.mp_+3A_spec.ind">spec.ind</code></td>
<td>

<p>specificity of the individual retests, set to be equal to spec if not specified otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><kbd>sim.mp</kbd> generates group testing data in matrix pooling form. The covariates are either specified by the <kbd>x</kbd> argument or they are generated from a gamma distribution with a given <kbd>gshape</kbd> and <kbd>gscale</kbd>. The individual probabilities are calculated from the covariates, the coefficients given in <kbd>par</kbd> and the link function specified through <kbd>linkf</kbd>. The true binary individual responses are then simulated from the individual probabilities. The individuals are organized into (by column) one or more matrices specified by <kbd>n.row</kbd> and <kbd>n.col</kbd>, and the true group responses are found (i.e., if at least one response is positive, the group is positive; otherwise, the group response is negative). The observed row and column group responses are then simulated using the given <kbd>sens</kbd> and <kbd>spec</kbd> values. Individual retests are simulated from <kbd>sens.ind</kbd> and <kbd>spec.ind</kbd> for individuals that lie on the intersection of an observed positive row and an observed positive column. In the case where no column (row) tests positive in a matrix, all the individuals in any observed positive rows (columns) will be assigned a simulated retest result. If no column or row is observed positive, <kbd>NULL</kbd> is returned. 
</p>


<h3>Value</h3>

<p><kbd>sim.mp</kbd> returns a list with the components
<kbd>dframe</kbd>: the data frame that is actually to be fit,
<kbd>ind</kbd>: the true individual responses presented in matrices and
<kbd>prob</kbd>: the individual probabilities.
</p>
<p><kbd>dframe</kbd> is a data frame with columns
</p>
<table>
<tr><td><code>col.resp</code></td>
<td>
<p>the column group response</p>
</td></tr>
<tr><td><code>row.resp</code></td>
<td>
<p>the row group response</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the covariate</p>
</td></tr>
<tr><td><code>arrayn</code></td>
<td>
<p>the array number</p>
</td></tr>
<tr><td><code>coln</code></td>
<td>
<p>the column group number</p>
</td></tr>
<tr><td><code>rown</code></td>
<td>
<p>the row group number</p>
</td></tr>
<tr><td><code>retest</code></td>
<td>
<p>the results of individual retests</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtreg.mp">gtreg.mp</a></code> for the corresponding function to fit the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 5*6 and 4*5 matrix
set.seed(9128)
sa1a&lt;-sim.mp(par=c(-7,0.1), n.row=c(5,4), n.col=c(6,5),
 sens=0.95, spec=0.95)
sa1&lt;-sa1a$dframe


</code></pre>

<hr>
<h2 id='summary.gt'>
Summary Method for Group Testing Model (Simple Pooling) Fits
</h2><span id='topic+summary.gt'></span>

<h3>Description</h3>

<p>Produce a summary list for objects of class <kbd>"gt"</kbd> returned by <kbd>gtreg</kbd>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gt_+3A_object">object</code></td>
<td>

<p>a fitted object of class <kbd>"gt"</kbd>.  
</p>
</td></tr>
<tr><td><code id="summary.gt_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><kbd>print.summary.gt</kbd> is the print function that formats the coefficients, standard errors, etc. and additionally gives 'significance stars' if <kbd>signif.stars</kbd> is <kbd>TRUE</kbd>. The <kbd>coefficients</kbd> component of the result gives the estimated coefficients and their estimated standard errors, together with their ratio. This third column is labeled <kbd>z ratio</kbd> using Wald tests. A fourth column gives the two-tailed p-value corresponding to the z ratio based on a Wald test. (It is possible that there are no residual degrees of freedom from which to estimate it. In that case the estimate is <kbd>NaN</kbd>.) 
</p>


<h3>Value</h3>

<p><kbd>summary.gt</kbd> returns an object of class <kbd>"summary.gt"</kbd>, a list with components 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>the deviance residuals: see <code><a href="#topic+residuals.gt">residuals.gt</a></code></p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors, z-values and p-values. Aliased coefficients are omitted.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>cov.mat</code></td>
<td>
<p>the estimated covariance matrix of the estimated coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtreg">gtreg</a></code> for creating an object of class <kbd>"gt"</kbd>, 
and <code><a href="#topic+print.summary.gt">print.summary.gt</a></code> for some options of changing the print out following <kbd>summary.gt</kbd>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- Continuing the Example from '?gtreg':

data(hivsurv)

fit1 &lt;- gtreg(formula = groupres ~ AGE + EDUC., data = hivsurv,
  groupn = gnum, sens = 0.9, spec = 0.9, method = "Xie")

summary(fit1)

</code></pre>

<hr>
<h2 id='summary.gt.mp'>
Summary Method for Group Testing Model (Matrix Pooling) Fits
</h2><span id='topic+summary.gt.mp'></span>

<h3>Description</h3>

<p>Produce a summary list for objects of class <kbd>"gt.mp"</kbd> returned by <code><a href="#topic+gtreg.mp">gtreg.mp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gt.mp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gt.mp_+3A_object">object</code></td>
<td>

<p>a fitted object of class <kbd>"gt.mp"</kbd>.  
</p>
</td></tr>
<tr><td><code id="summary.gt.mp_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><kbd>print.summary.gt.mp</kbd> is the print function that formats the coefficients, standard errors, etc. and additionally gives 'significance stars' if <kbd>signif.stars</kbd> is <kbd>TRUE</kbd>. The <kbd>coefficients</kbd> component of the result gives the estimated coefficients and their estimated standard errors, together with their ratio. This third column is labeled z ratio using Wald tests. A fourth column gives the two-tailed p-value corresponding to the <kbd>z ratio</kbd> based on a Wald test. 
</p>


<h3>Value</h3>

<p><kbd>summary.gt.mp</kbd> returns an object of class <kbd>"summary.gt.mp"</kbd>, a list with components 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors, z-values and p-values.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>Gibbs.sample.size</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>cov.mat</code></td>
<td>
<p>the estimated covariance matrix of the estimated coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtreg.mp">gtreg.mp</a></code> for creating an object of class <kbd>"gtreg.mp"</kbd>,
<code><a href="#topic+print.summary.gt.mp">print.summary.gt.mp</a></code> gives some hints how to change the print-out of <kbd>summary.gt.mp</kbd>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## --- Continuing the Example from  '?sim.mp' and '?gtreg.mp':
# 5*6 and 4*5 matrix

set.seed(9128)
sa1a&lt;-sim.mp(par=c(-7,0.1), n.row=c(5,4), n.col=c(6,5),
  sens=0.95, spec=0.95)
sa1&lt;-sa1a$dframe

## Not run: 
fit1mp &lt;- gtreg.mp(formula = cbind(col.resp, row.resp) ~ x, data = sa1, 
  coln = coln, rown = rown, arrayn = arrayn, 
  sens = 0.95, spec = 0.95, linkf = "logit", n.gibbs = 1000, tol = 0.005)

summary(fit1mp)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.poolbindiff'>Summary methods for &quot;poolbin&quot; and &quot;poolbindiff&quot;</h2><span id='topic+summary.poolbin'></span><span id='topic+summary.poolbindiff'></span>

<h3>Description</h3>

<p>Summary Method for One-Sample and Two-sample confidence intervals (various pool sizes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poolbin'
summary(object, scale = object$scale, ...)
## S3 method for class 'poolbindiff'
summary(object, scale = object$scale, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.poolbindiff_+3A_object">object</code></td>
<td>
<p> An object of class &quot;poolbin&quot; or &quot;poolbindiff&quot; (<code><a href="#topic+pooledBin">pooledBin</a></code>, <code><a href="#topic+pooledBinDiff">pooledBinDiff</a></code>)</p>
</td></tr>
<tr><td><code id="summary.poolbindiff_+3A_scale">scale</code></td>
<td>
<p> A coefficient to scale the point estimate and interval bounds</p>
</td></tr>
<tr><td><code id="summary.poolbindiff_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out
</p>

<hr>
<h2 id='thresh.val.dorf'>Find the optimal threshold value for Thresholded Optimal 
Dorfman testing</h2><span id='topic+thresh.val.dorf'></span>

<h3>Description</h3>

<p>Find the optimal threshold value for Thresholded Optimal
Dorfman (TOD) testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresh.val.dorf(p, psz, se = 1, sp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresh.val.dorf_+3A_p">p</code></td>
<td>
<p>a vector of each individual's probability of infection.</p>
</td></tr>
<tr><td><code id="thresh.val.dorf_+3A_psz">psz</code></td>
<td>
<p>the initial pool size.</p>
</td></tr>
<tr><td><code id="thresh.val.dorf_+3A_se">se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="thresh.val.dorf_+3A_sp">sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the optimal threshold value for TOD 
testing for situations where the threshold value is not specified. 
See McMahan et al. (2012) for additional details on the implementation 
of TOD testing.
</p>


<h3>Value</h3>

<p>The optimal threshold value for TOD testing.
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher S. 
McMahan for McMahan et al. (2012). The function was obtained 
from <a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>(1), 287&ndash;296.
ISSN 0006341X, doi: <a href="https://doi.org/10.1111/j.1541-0420.2011.01644.x">10.1111/j.1541-0420.2011.01644.x</a>.
</p>


<h3>See Also</h3>

<p><a href="http://chrisbilder.com/grouptesting">http://chrisbilder.com/grouptesting</a>
</p>
<p>Other Informative Dorfman functions: <code><a href="#topic+accuracy.dorf">accuracy.dorf</a></code>,
<code><a href="#topic+characteristics.pool">characteristics.pool</a></code>,
<code><a href="#topic+inf.dorf.measures">inf.dorf.measures</a></code>,
<code><a href="#topic+opt.info.dorf">opt.info.dorf</a></code>, <code><a href="#topic+opt.pool.size">opt.pool.size</a></code>,
<code><a href="#topic+pool.specific.dorf">pool.specific.dorf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example takes approximately 4 seconds to run. 
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
## Not run: 
set.seed(3154)
p.vec &lt;- p.vec.func(p=0.10, alpha=0.5, grp.sz=1000)
thresh.val.dorf(p=p.vec, psz=10, se=0.95, sp=0.95)
## End(Not run)

# This example takes less than 1 second to run.
# Estimated running time was calculated using a 
#   computer with 16 GB of RAM and one core of an 
#   Intel i7-6500U processor.
p.vec &lt;- p.vec.func(p=0.15, alpha=2, grp.sz=100)
thresh.val.dorf(p=p.vec, psz=10, se=0.95, sp=0.95)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
