<!DOCTYPE html><html><head><title>Help for package mrbsizeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mrbsizeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CImap'><p>Computation of simultaneous credible intervals.</p></a></li>
<li><a href='#dctMatrix'><p>Create a n-by-n discrete cosine transform matrix.</p></a></li>
<li><a href='#dftMatrix'><p>Create a n-by-n discrete Fourier transform matrix.</p></a></li>
<li><a href='#eigenLaplace'><p>Generate eigenvalues of discrete Laplace matrix.</p></a></li>
<li><a href='#eigenQsphere'><p>Generate eigenvalues of precision matrix Q on the surface of a sphere.</p></a></li>
<li><a href='#fftshift'><p>Swap the quadrants or halves of a 2d matrix.</p></a></li>
<li><a href='#HPWmap'><p>Computation of pointwise and highest pointwise probabilities.</p></a></li>
<li><a href='#ifftshift'><p>Inverse FFT shift of a 2d matrix.</p></a></li>
<li><a href='#MinLambda'><p>Numerical optimization for finding appropriate smoothing levels.</p></a></li>
<li><a href='#mrbsizeR'><p>mrbsizeR: Scale space multiresolution analysis in R.</p></a></li>
<li><a href='#mrbsizeRgrid'><p>Multiresolution analysis of random signals.</p></a></li>
<li><a href='#mrbsizeRsphere'><p>Multiresolution analysis of random signals for spherical data.</p></a></li>
<li><a href='#plot.CImapGrid'><p>Plot of simultaneous credible intervals.</p></a></li>
<li><a href='#plot.CImapSphere'><p>Plotting of simultaneous credible intervals on a sphere.</p></a></li>
<li><a href='#plot.HPWmapGrid'><p>Plotting of pointwise and highest pointwise probabilities.</p></a></li>
<li><a href='#plot.HPWmapSphere'><p>Plotting of pointwise and highest pointwise probabilities on a sphere.</p></a></li>
<li><a href='#plot.minLambda'><p>Plot of objective function for finding appropriate smoothing parameters.</p></a></li>
<li><a href='#plot.smMeanGrid'><p>Plotting of scale-dependent features.</p></a></li>
<li><a href='#plot.smMeanSphere'><p>Plotting of scale-dependent features on a sphere.</p></a></li>
<li><a href='#rmvtDCT'><p>Sampling from marginal posterior multivariate t-distribution.</p></a></li>
<li><a href='#TaperingPlot'><p>Plot of tapering functions.</p></a></li>
<li><a href='#tridiag'><p>Generate a tridiagonal matrix.</p></a></li>
<li><a href='#turnmat'><p>Turn matrix 90 degrees counter-clockwise.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scale Space Multiresolution Analysis of Random Signals</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roman Flury &lt;roman.flury@math.uzh.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A method for the multiresolution analysis of spatial fields and images to capture scale-dependent features.
    mrbsizeR is based on scale space smoothing and uses differences of smooths at neighbouring scales for finding features on different scales.
    To infer which of the captured features are credible, Bayesian analysis is used.
    The scale space multiresolution analysis has three steps: (1) Bayesian signal reconstruction.
    (2) Using differences of smooths, scale-dependent features of the reconstructed signal can be found.
    (3) Posterior credibility analysis of the differences of smooths created.
    The method has first been proposed by Holmstrom, Pasanen, Furrer, Sain (2011) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2011.04.011">doi:10.1016/j.csda.2011.04.011</a>&gt; and extended in Flury, Gerber, Schmid and Furrer (2021) &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2020.100483">doi:10.1016/j.spasta.2020.100483</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), maps(&ge; 3.1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields (&ge; 8.10), stats (&ge; 3.0.0), grDevices(&ge; 3.0.0),
graphics(&ge; 3.0.0), methods(&ge; 3.0.0), Rcpp (&ge; 0.12.14)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/romanflury/mrbsizeR/issues">https://github.com/romanflury/mrbsizeR/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/romanflury/mrbsizeR">https://github.com/romanflury/mrbsizeR</a>,
<a href="https://romanflury.github.io/mrbsizeR/">https://romanflury.github.io/mrbsizeR/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-13 15:52:52 UTC; roflur</td>
</tr>
<tr>
<td>Author:</td>
<td>Thimo Schuster [aut],
  Roman Flury [cre, aut],
  Leena Pasanen [ctb],
  Reinhard Furrer [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 00:01:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='CImap'>Computation of simultaneous credible intervals.</h2><span id='topic+CImap'></span>

<h3>Description</h3>

<p>Simultaneous credible intervals for all differences of smooths at neighboring
scales <code class="reqn">z_{i}</code> are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CImap(smoothVec, mm, nn, prob = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CImap_+3A_smoothvec">smoothVec</code></td>
<td>
<p>Differences of smooths at neighboring scales.</p>
</td></tr>
<tr><td><code id="CImap_+3A_mm">mm</code></td>
<td>
<p>Number of rows of the original input object.</p>
</td></tr>
<tr><td><code id="CImap_+3A_nn">nn</code></td>
<td>
<p>Number of columns of the original input object.</p>
</td></tr>
<tr><td><code id="CImap_+3A_prob">prob</code></td>
<td>
<p>Credibility level for the posterior credibility analysis. 
By default <code>prob = 0.95</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CImap</code> is an internal function of <code><a href="#topic+mrbsizeRgrid">mrbsizeRgrid</a></code> and is usually
not used independently. The output can be analyzed with the plotting function 
<code><a href="#topic+plot.CImapGrid">plot.CImapGrid</a></code>.
</p>


<h3>Value</h3>

<p>An array with simultaneous credible intervals <code>VmapCI</code> and
the dimensions of the original input object, <code>mm</code> and <code>nn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data: 10 observations (5-by-2 object), 10 samples
set.seed(987)
sampleData  &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData [4:6, ] &lt;- sampleData [4:6, ] + 5

# Calculation of the simultaneous credible intervals
CImap(smoothVec = sampleData , mm = 5, nn = 2, prob = 0.95)

</code></pre>

<hr>
<h2 id='dctMatrix'>Create a n-by-n discrete cosine transform matrix.</h2><span id='topic+dctMatrix'></span>

<h3>Description</h3>

<p>The discrete cosine transform (DCT) matrix for a given dimension n is
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dctMatrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dctMatrix_+3A_n">n</code></td>
<td>
<p>Dimension for the DCT matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used for 1D- or 2D-DCT transforms of data.
</p>

<ul>
<li> <p><strong>1D:</strong> Let <code>Q</code> be a m-by-n matrix with some data. <code>D</code> is a
m-by-m DCT matrix created by <code>dctMatrix(m)</code>. Then <code>D %*% Q</code> returns the
discrete cosine transform of the columns of Q. <code>t(D) %*% Q</code> returns the
inverse DCT of the columns of Q. As D is orthogonal, <code>solve(D) = t(D)</code>.
</p>
</li>
<li> <p><strong>2D:</strong> Let <code>Q</code> be a m-by-n matrix with some data. <code>D_m</code> is a
m-by-m DCT matrix created by <code>dctMatrix(m)</code>, <code>D_n</code> a n-by-n DCT matrix
created by <code>dctMatrix(n)</code>. <code>D_m %*% Q %*% t(D_n)</code> computes the 2D-DCT
of Q. The inverse 2D-DCT of Q can be computed via <br /> <code>t(D_mm) %*% DCT_Q %*% D_n</code>.
D_m transforms along columns, D_n along rows. Since D is orthogonal, <code>solve(D) = t(D)</code>.
</p>
</li></ul>

<p>It can be faster to use <code>dctMatrix</code> than using a direct transformation,
especially when calculating several DCT's.
</p>


<h3>Value</h3>

<p>The n-by-n DCT matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- dctMatrix(5)
</code></pre>

<hr>
<h2 id='dftMatrix'>Create a n-by-n discrete Fourier transform matrix.</h2><span id='topic+dftMatrix'></span>

<h3>Description</h3>

<p>The discrete Fourier transform (DFT) matrix for a given dimension n is
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dftMatrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dftMatrix_+3A_n">n</code></td>
<td>
<p>Dimension for the DFT matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DFT matrix can be used for computing the discrete Fourier transform of 
a matrix or vector. <code>dftMatrix(n) %*% testMatrix</code> is the same as
<code>apply(testMatrix, MARGIN = 2, FUN = fft)</code>.
</p>


<h3>Value</h3>

<p>The n-by-n DFT matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987)
testMatrix &lt;- matrix(sample(1:10, size = 25, replace = TRUE), nrow = 5)
D &lt;- dftMatrix(5)

# Discrete Fourier transform with matrix multiplication:
D %*% testMatrix 

# Discrete Fourier transform with function fft: 
apply(testMatrix, MARGIN = 2, FUN = fft)

</code></pre>

<hr>
<h2 id='eigenLaplace'>Generate eigenvalues of discrete Laplace matrix.</h2><span id='topic+eigenLaplace'></span>

<h3>Description</h3>

<p>The eigenvalues of a discrete Laplace matrix with dimension (<code>mm</code>, <code>nn</code>) are
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenLaplace(mm, nn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenLaplace_+3A_mm">mm</code></td>
<td>
<p>Number of rows of the discrete Laplace matrix.</p>
</td></tr>
<tr><td><code id="eigenLaplace_+3A_nn">nn</code></td>
<td>
<p>Number of columns of the discrete Laplace matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row vector containing the eigenvalues of the discrete
laplace matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eigval &lt;- eigenLaplace(5, 5)

</code></pre>

<hr>
<h2 id='eigenQsphere'>Generate eigenvalues of precision matrix Q on the surface of a sphere.</h2><span id='topic+eigenQsphere'></span>

<h3>Description</h3>

<p>The eigenvalues of the precision matrix Q with dimension (<code>mm</code>, <code>nn</code>)
and polar angle limits <code>phimin</code>, <code>phimax</code> are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenQsphere(phimin, phimax, mm, nn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenQsphere_+3A_phimin">phimin</code></td>
<td>
<p>Polar angle minimum.</p>
</td></tr>
<tr><td><code id="eigenQsphere_+3A_phimax">phimax</code></td>
<td>
<p>Polar angle maximum.</p>
</td></tr>
<tr><td><code id="eigenQsphere_+3A_mm">mm</code></td>
<td>
<p>Number of rows of precision matrix Q.</p>
</td></tr>
<tr><td><code id="eigenQsphere_+3A_nn">nn</code></td>
<td>
<p>Number of columns of precision matrix Q.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The corresponding function for data on a grid is <code> <a href="#topic+eigenLaplace">eigenLaplace</a></code>.
</p>


<h3>Value</h3>

<p>A list containing 2 elements:
</p>

<ul>
<li><p> eigval Row vector containing the eigenvalues of Q.
</p>
</li>
<li><p> eigvec Matrix containing the eigenvectors of Q as columns.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>eig_out &lt;- eigenQsphere(phimin = 180/10, phimax = 180 - 180/10, mm = 10, nn = 20)

</code></pre>

<hr>
<h2 id='fftshift'>Swap the quadrants or halves of a 2d matrix.</h2><span id='topic+fftshift'></span>

<h3>Description</h3>

<p><code>fftshift</code> is an R equivalent to the Matlab function <code>fftshift</code> 
applied on matrices. For more information about <code>fftshift</code> see 
the Matlab documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftshift(inputMatrix, dimension = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftshift_+3A_inputmatrix">inputMatrix</code></td>
<td>
<p>Matrix to be swapped.</p>
</td></tr>
<tr><td><code id="fftshift_+3A_dimension">dimension</code></td>
<td>
<p>Which swap should be performed? 
</p>

<ul>
<li> <p><code>1</code>: swap halves along the rows.
</p>
</li>
<li> <p><code>2</code>: swap halves along the columns. 
</p>
</li>
<li> <p><code>-1</code>: swap first quadrant with third and second quadrant with fourth. 
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to swap the halves or the quadrants of the input matrix. 
Halves can be swapped along the rows (<code>dimension = 1</code>) or along the 
columns (<code>dimension = 2</code>). When swapping the quadrants, <code>fftshift</code> 
swaps the first quadrant with the third and the second quadrant with the fourth
(<code>dimension = -1</code>).
</p>


<h3>Value</h3>

<p>Swapped matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987) 
sampleMat &lt;- matrix(sample(1:10, size = 25, replace = TRUE), nrow = 5)

# Swap halves along the rows:
fftshift(sampleMat, dimension = 1)

# Swap halves along the columns:
fftshift(sampleMat, dimension = 2)

# Swap first quadrant with third and second quadrant with fourth:
fftshift(sampleMat, dimension = -1)

</code></pre>

<hr>
<h2 id='HPWmap'>Computation of pointwise and highest pointwise probabilities.</h2><span id='topic+HPWmap'></span>

<h3>Description</h3>

<p>Pointwise (PW) probabilities and highest pointwise (HPW) probabilities of
all differences of smooths at neighboring scales are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPWmap(smoothVec, mm, nn, prob = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HPWmap_+3A_smoothvec">smoothVec</code></td>
<td>
<p>Differences of smooths at neighboring scales.</p>
</td></tr>
<tr><td><code id="HPWmap_+3A_mm">mm</code></td>
<td>
<p>Number of rows of the original input image.</p>
</td></tr>
<tr><td><code id="HPWmap_+3A_nn">nn</code></td>
<td>
<p>Number of columns of the original input image.</p>
</td></tr>
<tr><td><code id="HPWmap_+3A_prob">prob</code></td>
<td>
<p>Credibility level for the posterior credibility analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HPWmap</code> is an internal function of <code><a href="#topic+mrbsizeRgrid">mrbsizeRgrid</a></code> and is usually
not used independently. The output can be analyzed with the plotting function 
<code><a href="#topic+plot.HPWmapGrid">plot.HPWmapGrid</a></code>.
</p>


<h3>Value</h3>

<p>List with two arrays:
</p>

<ul>
<li> <p><code>pw</code>: Pointwise probabilities (<code>VmapPW</code>) including the dimensions
of the original input image, <code>mm</code> and <code>nn</code>.
</p>
</li>
<li> <p><code>hpw</code>: Highest pointwise probabilities (<code>VmapHPW</code>) including
the dimensions of the original input image, <code>mm</code> and <code>nn</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data: 10 observations (5-by-2 object), 10 samples
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, ] &lt;- sampleData[4:6, ] + 5

# Calculation of the simultaneous credible intervals
HPWmap(smoothVec = sampleData, mm = 5, nn = 2, prob = 0.95)

</code></pre>

<hr>
<h2 id='ifftshift'>Inverse FFT shift of a 2d matrix.</h2><span id='topic+ifftshift'></span>

<h3>Description</h3>

<p><code>ifftshift</code> is an R equivalent to the Matlab function <code>ifftshift</code> 
applied on matrices. For more information about <code>ifftshift</code> see 
the Matlab documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifftshift(inputMatrix, dimension = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifftshift_+3A_inputmatrix">inputMatrix</code></td>
<td>
<p>Matrix to be swapped.</p>
</td></tr>
<tr><td><code id="ifftshift_+3A_dimension">dimension</code></td>
<td>
<p>Which swap should be performed? 
</p>

<ul>
<li> <p><code>1</code>: swap halves along the rows.
</p>
</li>
<li> <p><code>2</code>: swap halves along the columns. 
</p>
</li>
<li> <p><code>-1</code>: swap first quadrant with third and second quadrant with fourth. 
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ifftshift</code> is the inverse function to <code><a href="#topic+fftshift">fftshift</a></code>. For more
information see the details of <code><a href="#topic+fftshift">fftshift</a></code>
</p>


<h3>Value</h3>

<p>Swapped matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987)
sampleMat &lt;- matrix(sample(1:10, size = 25, replace = TRUE), nrow = 5)

# Swap halves along the rows:
ifftshift(sampleMat, dimension = 1)

# Swap halves along the columns:
ifftshift(sampleMat, dimension = 2)

# Swap first quadrant with third and second quadrant with fourth:
ifftshift(sampleMat, dimension = -1)

</code></pre>

<hr>
<h2 id='MinLambda'>Numerical optimization for finding appropriate smoothing levels.</h2><span id='topic+MinLambda'></span>

<h3>Description</h3>

<p>Numerical optimization of an objective function <code class="reqn">G</code> is carried out to find 
appropriate signal-dependent smoothing levels (<code class="reqn">\lambda</code>'s). This is easier 
than visual inspection via the signal-dependent tapering function in <code><a href="#topic+TaperingPlot">TaperingPlot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinLambda(Xmu, mm, nn, nGrid, nLambda = 2, lambda, sphere = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinLambda_+3A_xmu">Xmu</code></td>
<td>
<p>Posterior mean of the input object as a vector.</p>
</td></tr>
<tr><td><code id="MinLambda_+3A_mm">mm</code></td>
<td>
<p>Number of rows of the original input object.</p>
</td></tr>
<tr><td><code id="MinLambda_+3A_nn">nn</code></td>
<td>
<p>Number of columns of the original input object.</p>
</td></tr>
<tr><td><code id="MinLambda_+3A_ngrid">nGrid</code></td>
<td>
<p>Size of grid where objective function is evaluated (nGrid-by-nGrid).
This argument is ignorded if a sequence <code>lambda</code> is specified.</p>
</td></tr>
<tr><td><code id="MinLambda_+3A_nlambda">nLambda</code></td>
<td>
<p>Number of lambdas to minimize over. Possible arguments: 2 (default) or 3.</p>
</td></tr>
<tr><td><code id="MinLambda_+3A_lambda">lambda</code></td>
<td>
<p><code class="reqn">\lambda</code>-sequence which is used for optimization. If nothing is provided, <br />
<code>lambda &lt;- 10^seq(-3, 10, len = nGrid)</code> is used for data on a grid and <br />
<code>lambda &lt;- 10^seq(-6, 1, len = nGrid)</code> is used for spherical data.</p>
</td></tr>
<tr><td><code id="MinLambda_+3A_sphere">sphere</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>: Is the input object defined on a sphere?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As signal-dependent tapering functions are quiet irregular, it is hard to 
find appropriate smoothing values only by visual inspection of the tapering
function plot. A more formal approach is the numerical optimization of an 
objective function. 
</p>
<p>Optimization can be carried out with 2 or 3 smoothing parameters. As the 
smoothing parameters 0 and <code class="reqn">\infty</code> are always added, this results
in a mrbsizeR analysis with 4 or 5 smoothing parameters. 
</p>
<p>Sometimes, not all features of the input object can be extracted using the 
smoothing levels proposed by <code>MinLambda</code>. It might then be necessary to
include additional smoothing levels. 
</p>
<p><code><a href="#topic+plot.minLambda">plot.minLambda</a></code> creates a plot of the objective function <code class="reqn">G</code> 
on a grid. The minimum is indicated with a white point. The minimum values of 
the <code class="reqn">\lambda</code>'s can be extracted from the output of <code>MinLambda</code>, 
see examples.
</p>


<h3>Value</h3>

<p>A list with 3 objects:
</p>
<p><code>G</code> Value of objective function <code class="reqn">G</code>.
</p>
<p><code>lambda</code> Evaluated smoothing parameters <code class="reqn">\lambda</code>.
</p>
<p><code>minind</code> Index of minimal <code class="reqn">\lambda</code>'s. <code>lambda</code>[<code>minind</code>] 
gives the minimal values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Minimization of two lambdas on a 20-by-20-grid
minlamOut &lt;- MinLambda(Xmu = c(sampleData), mm = 10, nn = 10, 
                       nGrid = 20, nLambda = 2)

# Minimal lambda values
minlamOut$lambda[minlamOut$minind]

</code></pre>

<hr>
<h2 id='mrbsizeR'>mrbsizeR: Scale space multiresolution analysis in R.</h2><span id='topic+mrbsizeR'></span>

<h3>Description</h3>

<p><code>mrbsizeR</code> contains a method for the scale space multiresolution analysis of 
spatial fields and images to capture scale-dependent features. The name is 
an abbreviation for <strong>M</strong>ulti<strong>R</strong>esolution <strong>B</strong>ayesian <strong>SI</strong>gnificant
<strong>ZE</strong>ro crossings of derivatives in <strong>R</strong> and the method combines the 
concept of statistical scale space analysis with a Bayesian SiZer method.
</p>


<h3>Details</h3>

<p>The <code>mrbsizeR</code> analysis can be applied to data on a regular grid and to spherical 
data. For data on a grid, the scale space multiresolution analysis has three steps: 
</p>

<ol>
<li><p> Bayesian signal reconstruction. 
</p>
</li>
<li><p> Using differences of smooths, scale-dependent features of the reconstructed signal are found.
</p>
</li>
<li><p> Posterior credibility analysis of the differences of smooths created. 
</p>
</li></ol>

<p>In a first step, Bayesian signal reconstruction is used to extract an underlying 
signal from a potentially noisy observation. Samples of the resulting posterior
can be generated and used for the analysis. For finding features on different scales, 
differences of smooths at neighboring scales are used. This is an important 
distinction to other scale space methods (which usually use a wide range of smoothing 
levels without taking differences) and tries to separate the features into 
distinct scale categories more aggressively. After a successful extraction 
of the scale-different features, posterior credibility analysis is necessary
to assess whether the features found are &ldquo;really there&rdquo; or if they are artifacts
of random sampling.
</p>
<p>For spherical data, no Bayesian signal reconstruction is implemented in <code>mrbsizer</code>.
Data samples therefore need to be available beforehand. The analysis procedure 
can therefore be summarized in two steps: 
</p>

<ol>
<li><p> Using differences of smooths, scale-dependent features of the reconstructed signal are found.
</p>
</li>
<li><p> Posterior credibility analysis of the differences of smooths created. 
</p>
</li></ol>

<p>This method has first been proposed by Holmstrom, Pasanen, Furrer, Sain (2011), 
see also <br /> http://cc.oulu.fi/~lpasanen/MRBSiZer/.
</p>
<p><strong>Major Functions</strong>
</p>

<ul>
<li> <p><code><a href="#topic+TaperingPlot">TaperingPlot</a></code> Graphical estimation of useful smoothing 
levels. Can be used signal-independent and signal-dependent.
</p>
</li>
<li> <p><code><a href="#topic+MinLambda">MinLambda</a></code> Numerical estimation of useful smoothing levels.
Takes the underlying signal into account. <code><a href="#topic+plot.minLambda">plot.minLambda</a></code> can
be used for plotting the result. 
</p>
</li>
<li> <p><code><a href="#topic+rmvtDCT">rmvtDCT</a></code> Creates samples on a regular grid from a 
multivariate <code class="reqn">t_{\nu}</code>-distribution using a discrete cosine transform (DCT).
</p>
</li>
<li> <p><code><a href="#topic+mrbsizeRgrid">mrbsizeRgrid</a></code> Interface of the mrbsizeR method for data on a 
regular grid. Differences of smooths at neighboring scales are created 
and posterior credibility analysis is conducted. The results can be 
visualized using <code><a href="#topic+plot.smMeanGrid">plot.smMeanGrid</a></code>,<code><a href="#topic+plot.HPWmapGrid">plot.HPWmapGrid</a></code> 
and <code><a href="#topic+plot.CImapGrid">plot.CImapGrid</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+mrbsizeRsphere">mrbsizeRsphere</a></code> Interface of the mrbsizeR method for data on a 
sphere. Differences of smooths at neighboring scales are created 
and posterior credibility analysis is conducted. The results can be 
visualized using <code><a href="#topic+plot.smMeanSphere">plot.smMeanSphere</a></code>,<code><a href="#topic+plot.HPWmapSphere">plot.HPWmapSphere</a></code> 
and <br /> <code><a href="#topic+plot.CImapSphere">plot.CImapSphere</a></code>. 
For data on a sphere, no Bayesian signal reconstruction is implemented. 
Samples have to be provided instead. 
</p>
</li></ul>

<p><strong>Getting Started</strong>
</p>
<p>The vignette for this package offers an extensive overview of the functionality 
and the usage of <code>mrbsizeR</code>.
</p>
<p><strong>References</strong>
</p>

<ul>
<li><p> Holmstrom, L. and Pasanen, L. (2011). MRBSiZer. http://cc.oulu.fi/~lpasanen/MRBSiZer/. 
Accessed: 2017-03-04.
</p>
</li>
<li><p> Holmstrom, L., Pasanen, L., Furrer, R., and Sain, S. R. (2011). 
Scale space multiresolution analysis of random signals. 
Computational Statistics and Data Analysis, 55, 2840-2855.
&lt;DOI:10.1016/j.csda.2011.04.011&gt;.
</p>
</li>
<li><p> Holmstrom, L. and Pasanen, L. (2016). Statistical scale space methods. 
International Statistical Review. &lt;DOI:10.1111/insr.12155&gt;.
</p>
</li></ul>

<p><strong>DISCLAIMER:</strong> The author can not guarantee the correctness of any 
function or program in this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Generate samples from multivariate t-distribution
tSamp &lt;- rmvtDCT(object = sampleData, lambda = 0.2, sigma = 6, nu0 = 15,
                  ns = 1000)  
 
# mrbsizeRgrid analysis
mrbOut &lt;- mrbsizeRgrid(posteriorFile = tSamp$sample, mm = 10, nn = 10, 
                       lambdaSmoother = c(1, 1000), prob = 0.95)

# Posterior mean of the differences of smooths
plot(x = mrbOut$smMean, turn_out = TRUE)                    

# Credibility analysis using simultaneous credible intervals
plot(x = mrbOut$ciout, turn_out = TRUE) 

</code></pre>

<hr>
<h2 id='mrbsizeRgrid'>Multiresolution analysis of random signals.</h2><span id='topic+mrbsizeRgrid'></span>

<h3>Description</h3>

<p><code>mrbsizeRgrid</code> is the interface of the scale space multiresolution method
for data on a regular grid. Here, the differences of smooths as well as the posterior 
credibility analysis are computed. The output can be analyzed with the plotting
functions <code><a href="#topic+plot.smMeanGrid">plot.smMeanGrid</a></code>, <code><a href="#topic+plot.CImapGrid">plot.CImapGrid</a></code> and 
<code><a href="#topic+plot.HPWmapGrid">plot.HPWmapGrid</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrbsizeRgrid(
  posteriorFile,
  mm,
  nn,
  lambdaSmoother,
  prob = 0.95,
  smoothOut = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrbsizeRgrid_+3A_posteriorfile">posteriorFile</code></td>
<td>
<p>Matrix with posterior samples as column vectors.</p>
</td></tr>
<tr><td><code id="mrbsizeRgrid_+3A_mm">mm</code></td>
<td>
<p>Number of rows of the original object.</p>
</td></tr>
<tr><td><code id="mrbsizeRgrid_+3A_nn">nn</code></td>
<td>
<p>Number of columns of the original object.</p>
</td></tr>
<tr><td><code id="mrbsizeRgrid_+3A_lambdasmoother">lambdaSmoother</code></td>
<td>
<p>Vector consisting of the smoothing levels to be used.</p>
</td></tr>
<tr><td><code id="mrbsizeRgrid_+3A_prob">prob</code></td>
<td>
<p>Credibility level for the posterior credibility analysis.</p>
</td></tr>
<tr><td><code id="mrbsizeRgrid_+3A_smoothout">smoothOut</code></td>
<td>
<p>Should the differences of smooths at neighboring scales be 
returned as output (FALSE by default)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mrbsizeRgrid</code> conducts two steps of the scale space multiresolution analysis:
</p>

<ol>
<li><p> Extraction of scale-dependent features from the reconstructed signal.
This is done by smoothing at different smoothing levels and taking the
difference of smooths at neighboring scales.
</p>
</li>
<li><p> Posterior credibility analysis of the differences of smooths created.
Three different methods are applied: Pointwise probabilities (see <code><a href="#topic+HPWmap">HPWmap</a></code>),
highest pointwise probabilities (see <code><a href="#topic+HPWmap">HPWmap</a></code>) and simultaneous 
credible intervals (see <code><a href="#topic+CImap">CImap</a></code>).
</p>
</li></ol>

<p>The signal can be reconstructed using the build-in multivariate t-distribution
sampling <code><a href="#topic+rmvtDCT">rmvtDCT</a></code>. It is also possible to provide samples 
generated with other methods, see the parameter <code>posteriorFile</code> and the
examples.
</p>
<p>For further information and examples, see the vignette.
</p>


<h3>Value</h3>

<p>A list containing the following sublists:
</p>
<p><code>smMean</code> Posterior mean of all differences of smooths created.
</p>
<p><code>hpout</code> Pointwise (PW) and highest pointwise (HPW) probabilities 
of all differences of smooths created.
</p>
<p><code>ciout</code> Simultaneous credible intervals (CI) of all differences of
smooths created.
</p>
<p><code>smoothSamples</code> Samples of differences of smooths at neighboring scales, 
as column vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Generate samples from multivariate t-distribution
tSamp &lt;- rmvtDCT(object = sampleData, lambda = 0.2, sigma = 6, nu0 = 15,
                  ns = 1000)  
 
# mrbsizeRgrid analysis
mrbOut &lt;- mrbsizeRgrid(posteriorFile = tSamp$sample, mm = 10, nn = 10, 
                       lambdaSmoother = c(1, 1000), prob = 0.95)

</code></pre>

<hr>
<h2 id='mrbsizeRsphere'>Multiresolution analysis of random signals for spherical data.</h2><span id='topic+mrbsizeRsphere'></span>

<h3>Description</h3>

<p><code>mrbsizeRSphere</code> is the interface of the scale space multiresolution method
for spherical data. Here, the differences of smooths as well as the posterior 
credibility analysis are computed. The output can be analyzed with the plotting
functions <code><a href="#topic+plot.smMeanSphere">plot.smMeanSphere</a></code>, <code><a href="#topic+plot.CImapSphere">plot.CImapSphere</a></code> 
and <code><a href="#topic+plot.HPWmapSphere">plot.HPWmapSphere</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrbsizeRsphere(
  posteriorFile,
  mm,
  nn,
  lambdaSmoother,
  prob = 0.95,
  smoothOut = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrbsizeRsphere_+3A_posteriorfile">posteriorFile</code></td>
<td>
<p>Matrix with posterior samples as column vectors.</p>
</td></tr>
<tr><td><code id="mrbsizeRsphere_+3A_mm">mm</code></td>
<td>
<p>Number of rows of the original object.</p>
</td></tr>
<tr><td><code id="mrbsizeRsphere_+3A_nn">nn</code></td>
<td>
<p>Number of columns of the original object.</p>
</td></tr>
<tr><td><code id="mrbsizeRsphere_+3A_lambdasmoother">lambdaSmoother</code></td>
<td>
<p>Vector consisting of the smoothing levels to be used.</p>
</td></tr>
<tr><td><code id="mrbsizeRsphere_+3A_prob">prob</code></td>
<td>
<p>Credibility level for the posterior credibility analysis.</p>
</td></tr>
<tr><td><code id="mrbsizeRsphere_+3A_smoothout">smoothOut</code></td>
<td>
<p>Should the differences of smooths at neighboring scales be 
returned as output (FALSE by default)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to <code>mrbsizeRgrid</code>, <code>mrbsizeRsphere</code> does not conduct 
Bayesian signal reconstruction via sampling from a posterior distribution. 
Samples of the posterior distribution have to be provided instead. 
</p>
<p>For further information and examples, see <code><a href="#topic+mrbsizeRgrid">mrbsizeRgrid</a></code> and 
the vignette.
</p>


<h3>Value</h3>

<p>A list containing the following sublists:
</p>
<p><code>smMean</code> Posterior mean of all differences of smooths created.
</p>
<p><code>hpout</code> Pointwise (PW) and highest pointwise (HPW) probabilities 
of all differences of smooths created.
</p>
<p><code>ciout</code> Simultaneous credible intervals (CI) of all differences of
smooths created.
</p>
<p><code>smoothSamples</code> Samples of differences of smooths at neighboring scales, 
as column vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial spherical sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(2000), nrow = 200)
sampleData[50:65, ] &lt;- sampleData[50:65, ] + 5

# mrbsizeRsphere analysis
mrbOut &lt;- mrbsizeRsphere(posteriorFile = sampleData, mm = 10, nn = 20,  
                          lambdaSmoother = c(1, 1000), prob = 0.95)
</code></pre>

<hr>
<h2 id='plot.CImapGrid'>Plot of simultaneous credible intervals.</h2><span id='topic+plot.CImapGrid'></span>

<h3>Description</h3>

<p>Maps with simultaneous credible intervals for all differences of smooths
at neighboring scales <code class="reqn">z_{i}</code> are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CImapGrid'
plot(
  x,
  color = c("firebrick1", "gainsboro", "dodgerblue3"),
  turnOut = TRUE,
  title,
  aspRatio = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CImapGrid_+3A_x">x</code></td>
<td>
<p>List containing the simultaneous credible intervals for all
differences of smooths.</p>
</td></tr>
<tr><td><code id="plot.CImapGrid_+3A_color">color</code></td>
<td>
<p>Vector of length 3 containing the colors to be used in the 
credibility maps. The first color represents the credibly negative pixels, 
the second color the pixels that are not credibly different from zero
and the third color the credibly positive pixels.</p>
</td></tr>
<tr><td><code id="plot.CImapGrid_+3A_turnout">turnOut</code></td>
<td>
<p>Logical. Should the output images be turned 90 degrees 
counter-clockwise?</p>
</td></tr>
<tr><td><code id="plot.CImapGrid_+3A_title">title</code></td>
<td>
<p>Vector containing one string per plot. The required 
number of titles is equal to <code>length(mrbOut$ciout)</code>. If no <code>title</code> 
is passed, defaults are used.</p>
</td></tr>
<tr><td><code id="plot.CImapGrid_+3A_aspratio">aspRatio</code></td>
<td>
<p>Adjust the aspect ratio of the plots. The default <code>aspRatio = 1</code>
produces square plots.</p>
</td></tr>
<tr><td><code id="plot.CImapGrid_+3A_...">...</code></td>
<td>
<p>Further graphical parameters can be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default colors of the maps have the following meaning:
</p>

<ul>
<li> <p><strong>Blue</strong>: Credibly positive pixels.
</p>
</li>
<li> <p><strong>Red</strong>: Credibly negative pixels.
</p>
</li>
<li> <p><strong>Grey</strong>: Pixels that are not credibly different from zero.
</p>
</li></ul>

<p><code>x</code> corresponds to the <code>ciout</code>-part of the output 
of <code><a href="#topic+mrbsizeRgrid">mrbsizeRgrid</a></code>.
</p>


<h3>Value</h3>

<p>Plots of simultaneous credible intervals for all differences of
smooths are created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Generate samples from multivariate t-distribution
tSamp &lt;- rmvtDCT(object = sampleData, lambda = 0.2, sigma = 6, nu0 = 15,
                   ns = 1000)  
 
# mrbsizeRgrid analysis
mrbOut &lt;- mrbsizeRgrid(posteriorFile = tSamp$sample, mm = 10, nn = 10, 
                       lambdaSmoother = c(1, 1000), prob = 0.95)

# Posterior mean of the differences of smooths
plot(x = mrbOut$smMean, turnOut = TRUE)                    

# Credibility analysis using simultaneous credible intervals
plot(x = mrbOut$ciout, turnOut = TRUE)

</code></pre>

<hr>
<h2 id='plot.CImapSphere'>Plotting of simultaneous credible intervals on a sphere.</h2><span id='topic+plot.CImapSphere'></span>

<h3>Description</h3>

<p>Maps with simultaneous credible intervals for all differences of smooths
at neighboring scales <code class="reqn">z_{i}</code> are plotted. Continental lines are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CImapSphere'
plot(
  x,
  lon,
  lat,
  color = c("firebrick1", "gainsboro", "dodgerblue3"),
  turnOut = FALSE,
  title,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CImapSphere_+3A_x">x</code></td>
<td>
<p>List containing the simultaneous credible intervals of all
differences of smooths.</p>
</td></tr>
<tr><td><code id="plot.CImapSphere_+3A_lon">lon</code></td>
<td>
<p>Vector containing the longitudes of the data points.</p>
</td></tr>
<tr><td><code id="plot.CImapSphere_+3A_lat">lat</code></td>
<td>
<p>Vector containing the latitudes of the data points.</p>
</td></tr>
<tr><td><code id="plot.CImapSphere_+3A_color">color</code></td>
<td>
<p>Vector of length 3 containing the colors to be used in the 
credibility maps. The first color represents the credibly negative pixels, 
the second color the pixels that are not credibly different from zero
and the third color the credibly positive pixels.</p>
</td></tr>
<tr><td><code id="plot.CImapSphere_+3A_turnout">turnOut</code></td>
<td>
<p>Logical. Should the output images be turned 90 degrees 
counter-clockwise?</p>
</td></tr>
<tr><td><code id="plot.CImapSphere_+3A_title">title</code></td>
<td>
<p>Vector containing one string per plot. The required 
number of titles is equal to <code>length(mrbOut$ciout)</code>. If no <code>title</code> 
is passed, defaults are used.</p>
</td></tr>
<tr><td><code id="plot.CImapSphere_+3A_...">...</code></td>
<td>
<p>Further graphical parameters can be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default colors of the maps have the following meaning:
</p>

<ul>
<li> <p><strong>Blue</strong>: Credibly positive pixels.
</p>
</li>
<li> <p><strong>Red</strong>: Credibly negative pixels.
</p>
</li>
<li> <p><strong>Grey</strong>: Pixels that are not credibly different from zero.
</p>
</li></ul>

<p><code>x</code> corresponds to the <code>ciout</code>-part of the
output of <code><a href="#topic+mrbsizeRsphere">mrbsizeRsphere</a></code>.
</p>


<h3>Value</h3>

<p>Plots of simultaneous credible intervals for all differences of
smooths are created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial spherical sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(2000), nrow = 200)
sampleData[50:65, ] &lt;- sampleData[50:65, ] + 5
lon &lt;- seq(-180, 180, length.out = 20)
lat &lt;- seq(-90, 90, length.out = 10)

# mrbsizeRsphere analysis
mrbOut &lt;- mrbsizeRsphere(posteriorFile = sampleData, mm = 20, nn = 10, 
                         lambdaSmoother = c(0.1, 1), prob = 0.95)
                           
# Posterior mean of the differences of smooths
plot(x = mrbOut$smMean, lon = lon, lat = lat,
     color = fields::tim.colors()) 

# Credibility analysis using simultaneous credible intervals
plot(x = mrbOut$ciout, lon = lon, lat = lat)

</code></pre>

<hr>
<h2 id='plot.HPWmapGrid'>Plotting of pointwise and highest pointwise probabilities.</h2><span id='topic+plot.HPWmapGrid'></span>

<h3>Description</h3>

<p>Maps with pointwise (PW) probabilities and/or highest pointwise (HPW)
probabilities of all differences of smooths at neighboring scales are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HPWmapGrid'
plot(
  x,
  plotWhich = "Both",
  color = c("firebrick1", "gainsboro", "dodgerblue3"),
  turnOut = TRUE,
  title,
  aspRatio = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.HPWmapGrid_+3A_x">x</code></td>
<td>
<p>List containing the pointwise (PW) and highest pointwise (HPW)
probabilities of all differences of smooths.</p>
</td></tr>
<tr><td><code id="plot.HPWmapGrid_+3A_plotwhich">plotWhich</code></td>
<td>
<p>Which probabilities shall be plotted? <code>HPW</code>, <code>PW</code>
or <code>Both</code>?</p>
</td></tr>
<tr><td><code id="plot.HPWmapGrid_+3A_color">color</code></td>
<td>
<p>Vector of length 3 containing the colors to be used in the
credibility maps. The first color represents the credibly negative pixels,
the second color the pixels that are not credibly different from zero
and the third color the credibly positive pixels.</p>
</td></tr>
<tr><td><code id="plot.HPWmapGrid_+3A_turnout">turnOut</code></td>
<td>
<p>Logical. Should the output images be turned 90 degrees
counter-clockwise?</p>
</td></tr>
<tr><td><code id="plot.HPWmapGrid_+3A_title">title</code></td>
<td>
<p>Vector containing one string per plot. The required
number of titles is equal to <code>length(mrbOut$hpout)</code>. If no <code>title</code>
is passed, defaults are used.</p>
</td></tr>
<tr><td><code id="plot.HPWmapGrid_+3A_aspratio">aspRatio</code></td>
<td>
<p>Adjust the aspect ratio of the plots. The default <code>aspRatio = 1</code>
produces square plots.</p>
</td></tr>
<tr><td><code id="plot.HPWmapGrid_+3A_...">...</code></td>
<td>
<p>Further graphical parameters can be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default colors of the maps have the following meaning:
</p>

<ul>
<li> <p><strong>Blue</strong>: Credibly positive pixels.
</p>
</li>
<li> <p><strong>Red</strong>: Credibly negative pixels.
</p>
</li>
<li> <p><strong>Grey</strong>: Pixels that are not credibly different from zero.
</p>
</li></ul>

<p><code>x</code> corresponds to the <code>hpout</code>-part of the
output of <code><a href="#topic+mrbsizeRgrid">mrbsizeRgrid</a></code>.
</p>


<h3>Value</h3>

<p>Plots of pointwise and/or highest pointwise probabilities for all
differences of smooths are created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Generate samples from multivariate t-distribution
tSamp &lt;- rmvtDCT(object = sampleData, lambda = 0.2, sigma = 6, nu0 = 15,
                   ns = 1000)

# mrbsizeRgrid analysis
mrbOut &lt;- mrbsizeRgrid(posteriorFile = tSamp$sample, mm = 10, nn = 10,
                       lambdaSmoother = c(1, 1000), prob = 0.95)

# Posterior mean of the differences of smooths
plot(x = mrbOut$smMean, turnOut = TRUE)

# Credibility analysis using pointwise (PW) maps
plot(x = mrbOut$hpout, plotWhich = "PW", turnOut = TRUE)

# Credibility analysis using highest pointwise probability (HPW) maps
plot(x = mrbOut$hpout, plotWhich = "HPW", turnOut = TRUE)

</code></pre>

<hr>
<h2 id='plot.HPWmapSphere'>Plotting of pointwise and highest pointwise probabilities on a sphere.</h2><span id='topic+plot.HPWmapSphere'></span>

<h3>Description</h3>

<p>Maps with pointwise (PW) probabilities and/or highest pointwise (HPW) 
probabilities of all differences of smooths at neighboring scales are plotted. 
Continental lines are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HPWmapSphere'
plot(
  x,
  lon,
  lat,
  plotWhich = "Both",
  color = c("firebrick1", "gainsboro", "dodgerblue3"),
  turnOut = FALSE,
  title,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.HPWmapSphere_+3A_x">x</code></td>
<td>
<p>List containing the pointwise (PW) and highest pointwise (HPW)
probabilities of all differences of smooths.</p>
</td></tr>
<tr><td><code id="plot.HPWmapSphere_+3A_lon">lon</code></td>
<td>
<p>Vector containing the longitudes of the data points.</p>
</td></tr>
<tr><td><code id="plot.HPWmapSphere_+3A_lat">lat</code></td>
<td>
<p>Vector containing the latitudes of the data points.</p>
</td></tr>
<tr><td><code id="plot.HPWmapSphere_+3A_plotwhich">plotWhich</code></td>
<td>
<p>Which probabilities shall be plotted? <code>HPW</code>, <code>PW</code>
or <code>Both</code>?</p>
</td></tr>
<tr><td><code id="plot.HPWmapSphere_+3A_color">color</code></td>
<td>
<p>Vector of length 3 containing the colors to be used in the 
credibility maps. The first color represents the credibly negative pixels, 
the second color the pixels that are not credibly different from zero
and the third color the credibly positive pixels.</p>
</td></tr>
<tr><td><code id="plot.HPWmapSphere_+3A_turnout">turnOut</code></td>
<td>
<p>Logical. Should the output images be turned 90 degrees 
counter-clockwise?</p>
</td></tr>
<tr><td><code id="plot.HPWmapSphere_+3A_title">title</code></td>
<td>
<p>Vector containing one string per plot. The required 
number of titles is equal to <code>length(mrbOut$hpout)</code>. If no <code>title</code> 
is passed, defaults are used.</p>
</td></tr>
<tr><td><code id="plot.HPWmapSphere_+3A_...">...</code></td>
<td>
<p>Further graphical parameters can be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default colors of the maps have the following meaning:
</p>

<ul>
<li> <p><strong>Blue</strong>: Credibly positive pixels.
</p>
</li>
<li> <p><strong>Red</strong>: Credibly negative pixels.
</p>
</li>
<li> <p><strong>Grey</strong>: Pixels that are not credibly different from zero.
</p>
</li></ul>

<p><code>x</code> corresponds to the <code>hpout</code>-part of the
output of <code><a href="#topic+mrbsizeRsphere">mrbsizeRsphere</a></code>.
</p>


<h3>Value</h3>

<p>Plots of pointwise and/or highest pointwise probabilities for all
differences of smooths are created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial spherical sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(2000), nrow = 200)
sampleData[50:65, ] &lt;- sampleData[50:65, ] + 5
lon &lt;- seq(-180, 180, length.out = 20)
lat &lt;- seq(-90, 90, length.out = 10)

# mrbsizeRsphere analysis
mrbOut &lt;- mrbsizeRsphere(posteriorFile = sampleData, mm = 20, nn = 10, 
                         lambdaSmoother = c(0.1, 1), prob = 0.95)
                           
# Posterior mean of the differences of smooths
plot(x = mrbOut$smMean, lon = lon, lat = lat,
     color = fields::tim.colors()) 

# Credibility analysis using pointwise (PW) maps
plot(x = mrbOut$hpout, lon = lon, lat = lat, plotWhich = "PW")

# Credibility analysis using highest pointwise probability (HPW) maps
plot(x = mrbOut$hpout, lon = lon, lat = lat, plotWhich = "HPW")

</code></pre>

<hr>
<h2 id='plot.minLambda'>Plot of objective function for finding appropriate smoothing parameters.</h2><span id='topic+plot.minLambda'></span>

<h3>Description</h3>

<p>The objective function <code class="reqn">G</code> is plotted on a grid. The minimum is 
indicated with a white point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'minLambda'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.minLambda_+3A_x">x</code></td>
<td>
<p>Output of function <code><a href="#topic+MinLambda">MinLambda</a></code>.</p>
</td></tr>
<tr><td><code id="plot.minLambda_+3A_...">...</code></td>
<td>
<p>Further graphical parameters can be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When minimizing over 2 <code class="reqn">\lambda</code>'s, one plot is generated: (<code class="reqn">\lambda_2</code> vs <code class="reqn">\lambda_3</code>).
With 3 <code class="reqn">\lambda</code>'s, 3 plots are generated: <code class="reqn">\lambda_2</code> vs. <code class="reqn">\lambda_3</code>, 
<code class="reqn">\lambda_2</code> vs. <code class="reqn">\lambda_4</code> and <code class="reqn">\lambda_3</code> vs. <code class="reqn">\lambda_4</code>.
</p>


<h3>Value</h3>

<p>Plot of <code class="reqn">G</code> on a grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Minimization of two lambdas on a 20-by-20-grid
minLamOut &lt;- MinLambda(Xmu = c(sampleData), mm = 10, nn = 10, 
                        nGrid = 20, nLambda = 3)

# Plot of the objective function
plot(x = minLamOut)

</code></pre>

<hr>
<h2 id='plot.smMeanGrid'>Plotting of scale-dependent features.</h2><span id='topic+plot.smMeanGrid'></span>

<h3>Description</h3>

<p>Scale-dependent features are plotted using differences of smooths at
neighboring scales. The features are summarized by their posterior mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smMeanGrid'
plot(
  x,
  color.pallet = fields::tim.colors(),
  turnOut = TRUE,
  title,
  aspRatio = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smMeanGrid_+3A_x">x</code></td>
<td>
<p>List containing the posterior mean of all differences of smooths.</p>
</td></tr>
<tr><td><code id="plot.smMeanGrid_+3A_color.pallet">color.pallet</code></td>
<td>
<p>The color pallet to be used for plotting scale-dependent
features.</p>
</td></tr>
<tr><td><code id="plot.smMeanGrid_+3A_turnout">turnOut</code></td>
<td>
<p>Logical. Should the output images be turned 90 degrees 
counter-clockwise?</p>
</td></tr>
<tr><td><code id="plot.smMeanGrid_+3A_title">title</code></td>
<td>
<p>Vector containing one string per plot. The required 
number of titles is equal to <code>length(mrbOut$smMean)</code>. If no <code>title</code> 
is passed, defaults are used.</p>
</td></tr>
<tr><td><code id="plot.smMeanGrid_+3A_aspratio">aspRatio</code></td>
<td>
<p>Adjust the aspect ratio of the plots. The default <code>aspRatio = 1</code>
produces square plots.</p>
</td></tr>
<tr><td><code id="plot.smMeanGrid_+3A_...">...</code></td>
<td>
<p>Further graphical parameters can be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> corresponds to the <code>smmean</code>-part of the
output of <code><a href="#topic+mrbsizeRgrid">mrbsizeRgrid</a></code>.
</p>


<h3>Value</h3>

<p>Plots of the differences of smooths are created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Generate samples from multivariate t-distribution
tSamp &lt;- rmvtDCT(object = sampleData, lambda = 0.2, sigma = 6, nu0 = 15,
                   ns = 1000)  
 
# mrbsizeRgrid analysis
mrbOut &lt;- mrbsizeRgrid(posteriorFile = tSamp$sample, mm = 10, nn = 10, 
                       lambdaSmoother = c(1, 1000), prob = 0.95)

# Posterior mean of the differences of smooths
plot(x = mrbOut$smMean, turnOut = TRUE) 

</code></pre>

<hr>
<h2 id='plot.smMeanSphere'>Plotting of scale-dependent features on a sphere.</h2><span id='topic+plot.smMeanSphere'></span>

<h3>Description</h3>

<p>Scale-dependent features are plotted using differences of smooths at
neighboring scales. The features are summarized by their posterior mean. 
Continental lines are added to the plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smMeanSphere'
plot(
  x,
  lon,
  lat,
  color.pallet = fields::tim.colors(),
  turnOut = TRUE,
  title,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smMeanSphere_+3A_x">x</code></td>
<td>
<p>List containing the posterior mean of all differences of smooths.</p>
</td></tr>
<tr><td><code id="plot.smMeanSphere_+3A_lon">lon</code></td>
<td>
<p>Vector containing the longitudes of the data points.</p>
</td></tr>
<tr><td><code id="plot.smMeanSphere_+3A_lat">lat</code></td>
<td>
<p>Vector containing the latitudes of the data points.</p>
</td></tr>
<tr><td><code id="plot.smMeanSphere_+3A_color.pallet">color.pallet</code></td>
<td>
<p>The color pallet to be used for plotting scale-dependent
features.</p>
</td></tr>
<tr><td><code id="plot.smMeanSphere_+3A_turnout">turnOut</code></td>
<td>
<p>Logical. Should the output images be turned 90 degrees 
counter-clockwise?</p>
</td></tr>
<tr><td><code id="plot.smMeanSphere_+3A_title">title</code></td>
<td>
<p>Vector containing one string per plot. The required 
number of titles is equal to <code>length(mrbOut$smMean)</code>. If no <code>title</code> 
is passed, defaults are used.</p>
</td></tr>
<tr><td><code id="plot.smMeanSphere_+3A_...">...</code></td>
<td>
<p>Further graphical parameters can be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> corresponds to the <code>smmean</code>-part of the
output of <code><a href="#topic+mrbsizeRsphere">mrbsizeRsphere</a></code>.
</p>


<h3>Value</h3>

<p>Plots of the differences of smooths are created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial spherical sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(2000), nrow = 200)
sampleData[50:65, ] &lt;- sampleData[50:65, ] + 5
lon &lt;- seq(-180, 180, length.out = 20)
lat &lt;- seq(-90, 90, length.out = 10)

# mrbsizeRsphere analysis
mrbOut &lt;- mrbsizeRsphere(posteriorFile = sampleData, mm = 20, nn = 10, 
                         lambdaSmoother = c(0.1, 1), prob = 0.95)
                           
# Posterior mean of the differences of smooths
plot(x = mrbOut$smMean, lon = lon, lat = lat,
     color = fields::tim.colors(), turnOut = FALSE) 

</code></pre>

<hr>
<h2 id='rmvtDCT'>Sampling from marginal posterior multivariate t-distribution.</h2><span id='topic+rmvtDCT'></span>

<h3>Description</h3>

<p>Samples from a marginal posterior multivariate t-distribution with
normal-inverse-chi-squared-prior are generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvtDCT(object, lambda, sigma, nu0, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvtDCT_+3A_object">object</code></td>
<td>
<p>Observed object, as <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="rmvtDCT_+3A_lambda">lambda</code></td>
<td>
<p>Scaling parameter (<code class="reqn">\lambda</code>) of the normal-inverse-chi-squared-prior.</p>
</td></tr>
<tr><td><code id="rmvtDCT_+3A_sigma">sigma</code></td>
<td>
<p>Square root of the <code class="reqn">\sigma_{0}^{2}</code> parameter of the 
normal-inverse-chi-squared-prior.</p>
</td></tr>
<tr><td><code id="rmvtDCT_+3A_nu0">nu0</code></td>
<td>
<p>Degrees of freedom (<code class="reqn">\nu_{0}</code>) of the normal-inverse-chi-square-prior.</p>
</td></tr>
<tr><td><code id="rmvtDCT_+3A_ns">ns</code></td>
<td>
<p>Number of samples that should be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An eigenvalue decomposition is used for sampling. To speed up computations,
a 2D discrete cosine transform (DCT) has been implemented, see <code><a href="#topic+dctMatrix">dctMatrix</a></code>.
The output is a list containing
</p>

<ol>
<li><p> Samples of the marginal posterior of the input as column vectors.
</p>
</li>
<li><p> The mean of the marginal posterior of the input as a vector.
</p>
</li></ol>



<h3>Value</h3>

<p>A list containing the following elements:
</p>
<p><code>sample</code> Samples of the marginal posterior of the input.
</p>
<p><code>mu</code> Mean of the marginal posterior of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Sampling from a multivariate t-distribution
t_dist_samp &lt;- rmvtDCT(object = sampleData, lambda = 1, sigma = 10,
                       nu0 = 50, ns = 1000)
</code></pre>

<hr>
<h2 id='TaperingPlot'>Plot of tapering functions.</h2><span id='topic+TaperingPlot'></span>

<h3>Description</h3>

<p>Tapering functions corresponding to the smoothing levels in <code>lambdaSmoother</code>
are drawn. This plot helps to assess if the chosen smoothing levels are
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TaperingPlot(lambdaSmoother, mm, nn, Xmu, returnseq = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TaperingPlot_+3A_lambdasmoother">lambdaSmoother</code></td>
<td>
<p>Vector consisting of the smoothing levels to be used.</p>
</td></tr>
<tr><td><code id="TaperingPlot_+3A_mm">mm</code></td>
<td>
<p>Number of rows of the original input object.</p>
</td></tr>
<tr><td><code id="TaperingPlot_+3A_nn">nn</code></td>
<td>
<p>Number of columns of the original input object.</p>
</td></tr>
<tr><td><code id="TaperingPlot_+3A_xmu">Xmu</code></td>
<td>
<p>If availabe, posterior mean of the input object.</p>
</td></tr>
<tr><td><code id="TaperingPlot_+3A_returnseq">returnseq</code></td>
<td>
<p>instead of plotting return the tapering sequences.</p>
</td></tr>
<tr><td><code id="TaperingPlot_+3A_...">...</code></td>
<td>
<p>Further graphical parameters can be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tapering functions of the smoothing levels chosen should be generally
approximately disjoint. This will produce features which are somewhat orthogonal.
With orthogonal features, it is likely that each difference of smooths
corresponds to a different pattern in the input image.
</p>
<p>Sometimes, not all patterns of the input image can be extracted using smoothing
levels whose tapering functions are disjoint. It might then be necessary to
include additional smoothing levels, and the disjointedness might not be satisfied
anymore. The selection of appropriate smoothing levels with this method
therefore requires some user interaction. Still, choosing disjoint tapering
functions for finding appropriate smoothing levels is a good starting point.
</p>
<p>Better results could be obtained if the structure of the posterior mean of
the input is also taken into account. If the posterior mean is available,
it can be added with the argument <code>Xmu</code> and moving averages of the absolute
values of the signal-dependent tapering functions are drawn. <code><a href="#topic+MinLambda">MinLambda</a></code> 
offers a more formal approach of optimizing the disjointedness of the tapering 
functions and can help finding appropriate smoothing levels when the input 
signal is taken into account.
</p>


<h3>Value</h3>

<p>Plots of the tapering functions for all differences of smooths
at neighboring scales are created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Signal-independent tapering function plot for a 30-by-10 object with 
# the smoothing parameter sequence [0, 1, 10, 1000, inf]: 

TaperingPlot(lambdaSmoother = c(1, 10, 1000), mm = 30, nn = 10)


# Signal-dependent tapering function plot for a 30-by-10 object with 
# the smoothing parameter sequence [0, 1, 10, 1000, inf]: 

set.seed(987)
xmuExample &lt;- c(stats::rnorm(300))
TaperingPlot(lambdaSmoother = c(1, 10, 1000), mm = 30, nn = 10, 
             Xmu = xmuExample)


</code></pre>

<hr>
<h2 id='tridiag'>Generate a tridiagonal matrix.</h2><span id='topic+tridiag'></span>

<h3>Description</h3>

<p>Generate a tridiagonal matrix with <code>upperDiag</code> as superdiagonal, 
<code>lowerDiag</code> as subdiagonal and <code>mainDiag</code> as diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tridiag(mainDiag, upperDiag, lowerDiag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tridiag_+3A_maindiag">mainDiag</code></td>
<td>
<p>Diagonal of tridiagonal matrix.</p>
</td></tr>
<tr><td><code id="tridiag_+3A_upperdiag">upperDiag</code></td>
<td>
<p>Superdiagonal of tridiagonal matrix. Must have length <code>length(mainDiag) - 1</code>.</p>
</td></tr>
<tr><td><code id="tridiag_+3A_lowerdiag">lowerDiag</code></td>
<td>
<p>Subdiagonal of tridiagonal matrix. Must have length <code>length(mainDiag) - 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tridiagonal matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987)
mainDiag &lt;- sample(100:110, size = 6, replace = TRUE)
upperDiag &lt;- sample(10:20, size = 5, replace = TRUE)
lowerDiag &lt;- sample(1:10, size = 5, replace = TRUE)

tridiag(mainDiag, upperDiag, lowerDiag)  
 
</code></pre>

<hr>
<h2 id='turnmat'>Turn matrix 90 degrees counter-clockwise.</h2><span id='topic+turnmat'></span>

<h3>Description</h3>

<p>Help function to turn matrix 90 degrees counter-clockwise.
<code>turnmat</code> is used as an internal function in some of the plotting 
functions. Depending on how the data is stored, it can be necessary to turn 
the matrices 90 degrees counter-clockwise for being able to plot them correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnmat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="turnmat_+3A_x">x</code></td>
<td>
<p>Matrix to be turned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>x</code>, turned by 90 degrees counter-clockwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987)
sampleMat &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleMatTurn &lt;- turnmat(x = sampleMat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
