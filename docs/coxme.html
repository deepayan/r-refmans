<!DOCTYPE html><html><head><title>Help for package coxme</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coxme}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.coxme'><p>Analysis of Deviance for a Cox model.</p></a></li>
<li><a href='#coxme'>
<p>Fit a mixed effects Cox model</p></a></li>
<li><a href='#coxme.control'>
<p>Auxillary parameters for controlling coxme fits.</p></a></li>
<li><a href='#coxme.object'><p>Coxme regression output object</p></a></li>
<li><a href='#coxmeFull'><p>Variance family function for coxme fits.</p></a></li>
<li><a href='#coxmeMlist'><p>Coxme variance function</p></a></li>
<li><a href='#eortc'><p>Simulated data set based on an EORTC trial</p></a></li>
<li><a href='#expand.nested'><p>Expand nested factors</p></a></li>
<li><a href='#fixed.effects'><p>Import from package <span class="pkg">nlme</span></p></a></li>
<li><a href='#fixef.coxme'><p>Extraction functions for Coxme</p></a></li>
<li><a href='#fixef.lmekin'><p>Extraction functions for Lmekin</p></a></li>
<li><a href='#lmekin'><p>Fit a linear mixed effects model</p></a></li>
<li><a href='#lmekin.control'>
<p>Auxillary parameters for controlling lmekin fits.</p></a></li>
<li><a href='#lmekin.object'><p>lmekin object</p></a></li>
<li><a href='#logLik.coxme'><p>The logLik method for coxme objects</p></a></li>
<li><a href='#predict.coxme'><p>Predictions for a coxme object.</p></a></li>
<li><a href='#print.coxme'>
<p>Print method for a coxme fit.</p></a></li>
<li><a href='#print.lmekin'><p>Print function for lmekin</p></a></li>
<li><a href='#ranef'><p>Import from package <span class="pkg">nlme</span></p></a></li>
<li><a href='#summary.coxme'><p>Summary method for coxme objects</p></a></li>
<li><a href='#VarCorr'><p>Import from package <span class="pkg">nlme</span></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Mixed Effects Cox Models</td>
</tr>
<tr>
<td>Priority:</td>
<td>optional</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2-20</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival (&ge; 2.36.14), methods, bdsmatrix(&ge; 1.3), R(&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nlme, Matrix (&ge; 1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, kinship2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>bdsmatrix</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>Yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Cox proportional hazards models containing both 
 fixed and random effects.  The random effects can have a general form, of which
 familial interactions (a "kinship" matrix) is a particular special case. 
 Note that the simplest case of a mixed effects Cox model, i.e. a single random 
 per-group intercept, is also called a "frailty" model.  The approach is based
 on Ripatti and Palmgren, Biometrics 2002.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 19:55:10 UTC; therneau</td>
</tr>
<tr>
<td>Author:</td>
<td>Terry M. Therneau [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Terry M. Therneau &lt;therneau.terry@mayo.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 05:30:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.coxme'>Analysis of Deviance for a Cox model.</h2><span id='topic+anova.coxme'></span><span id='topic+anova.coxmelist'></span>

<h3>Description</h3>

<p>Compute an analysis of deviance table for one or more Cox model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxme'
anova(object, ...,  test = 'Chisq')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.coxme_+3A_object">object</code></td>
<td>
<p>An object of class <code>coxme</code> or <code>coxph</code></p>
</td></tr>
<tr><td><code id="anova.coxme_+3A_...">...</code></td>
<td>
<p>Further <code>coxme</code> objects</p>
</td></tr>
<tr><td><code id="anova.coxme_+3A_test">test</code></td>
<td>
<p>a character string. The appropriate test is a chisquare, all
other choices result in no test being done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying a single object gives a sequential analysis of deviance
table for that fit.  That is, the reductions in the model log-likelihood
as each term of the formula is added in turn are given in as
the rows of a table, plus the log-likelihoods themselves.
</p>
<p>If more than one object is specified, the table has a row for the
degrees of freedom and loglikelihood for each model. For all
but the first model, the change in degrees of freedom and loglik
is also given. (This only make statistical sense if the models are
nested.)  It is conventional to list the models from smallest to
largest, but this is up to the user.
</p>
<p>The table will optionally contain test statistics (and P values)
comparing the reduction in loglik for each row.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> inheriting from class <code>"data.frame"</code>.
</p>


<h3>Warning</h3>

<p>The comparison between two or more models by <code>anova</code> or
will only be valid if they
are fitted to the same dataset. This may be a problem if there are
missing values.</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxme">coxme</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Testing a shrunken estimate of ECOG performace status
fit1 &lt;- coxph(Surv(time, status) ~ age + sex, data=lung,
               subset=(!is.na(ph.ecog)))
fit2 &lt;- coxme(Surv(time, status) ~ age + sex + (1|ph.ecog), lung)
anova(fit1,fit2)
 </code></pre>

<hr>
<h2 id='coxme'>
Fit a mixed effects Cox model
</h2><span id='topic+coxme'></span>

<h3>Description</h3>

<p>Fit a Cox model containing mixed (random and fixed) effects.  Assume
a Gaussian distribution for the random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxme(formula, data, weights, subset, na.action, init, control,
ties = c("efron", "breslow"),
varlist, vfixed, vinit,  x = FALSE, y = TRUE,
refine.n = 0, random, fixed, variance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxme_+3A_formula">formula</code></td>
<td>

<p>a two-sided formula with a survival object as the left hand side of a
<code>~</code> operator and the fixed and random effects on the right.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables named in the <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_subset">subset</code>, <code id="coxme_+3A_weights">weights</code>, <code id="coxme_+3A_na.action">na.action</code></td>
<td>

<p>further model specifications arguments as in <code>lm</code>; see there
for details.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_init">init</code></td>
<td>

<p>optional initial values for the fixed effects.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_control">control</code></td>
<td>

<p>optional list of control options.  See <code>coxme.control</code> for details. 
</p>
</td></tr>
<tr><td><code id="coxme_+3A_ties">ties</code></td>
<td>

<p>method for handling exact ties in the survival time.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_varlist">varlist</code></td>
<td>

<p>the variance family to be used for each random term.  If there are
multiple terms it will be a list of variance functions.
The default is <code>coxmeFull</code>.
Alternatively it can be a list of matrices, in which case the
<code>coxmeMlist</code> function is used.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_vfixed">vfixed</code></td>
<td>

<p>optional named list or vector used to fix the value of one or more
of the variance terms at a constant.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_vinit">vinit</code></td>
<td>

<p>optional named list or vector giving suggested starting values for
the variance.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_x">x</code></td>
<td>

<p>if TRUE the X matrix (fixed effects) is included in the output object
</p>
</td></tr>
<tr><td><code id="coxme_+3A_y">y</code></td>
<td>

<p>if TRUE the y variable (survival time) is included in the output object
</p>
</td></tr>
<tr><td><code id="coxme_+3A_refine.n">refine.n</code></td>
<td>

<p>number of samples to be used in a monte-carlo estimate of 
possible error in the log-likelihood of the fitted model due to
inadequacy of the Laplace approximation.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_fixed">fixed</code>, <code id="coxme_+3A_random">random</code>, <code id="coxme_+3A_variance">variance</code></td>
<td>

<p>In the preliminary version of <code>coxme</code>
the fixed and random effects were separate arguments.  These arguments
are included for backwards compatability, but are depreciated.
The variance argument is a depreciated alias for vfixed.
</p>
</td></tr>
<tr><td><code id="coxme_+3A_...">...</code></td>
<td>

<p>any other arguments are passed forward to <code>coxme.control</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>coxme</code>.
</p>


<h3>Author(s)</h3>

<p>Terry Therneau
</p>


<h3>References</h3>

<p>S Ripatti and J Palmgren, Estimation of multivariate frailty 
models using penalized partial likelihood,
Biometrics, 56:1016-1022, 2000.
</p>
<p>T Therneau, P Grambsch and VS Pankratz,
Penalized survival models and frailty,
J Computational and Graphical Statistics, 12:156-175, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxmeFull">coxmeFull</a></code>, <code><a href="#topic+coxmeMlist">coxmeMlist</a></code>,
<code><a href="#topic+coxme.object">coxme.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A non-significant institution effect
fit1 &lt;- coxph(Surv(time, status) ~ ph.ecog + age, data=lung,
              subset=(!is.na(inst)))
fit2 &lt;- coxme(Surv(time, status) ~ ph.ecog + age + (1|inst), lung)
anova(fit1, fit2)

# Shrinkage effects (equivalent to ridge regression)
temp &lt;- with(lung, scale(cbind(age, wt.loss, meal.cal)))
rfit &lt;- coxme(Surv(time, status) ~ ph.ecog + (temp | 1), data=lung)
</code></pre>

<hr>
<h2 id='coxme.control'>
Auxillary parameters for controlling coxme fits.
</h2><span id='topic+coxme.control'></span>

<h3>Description</h3>

<p>Auxillary function which packages the optional parameters of a
<code>coxme</code> fit as a single list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxme.control(eps = 1e-08, toler.chol = .Machine$double.eps^0.75,
iter.max = 20, inner.iter = Quote(max(4, fit0$iter+1)),
sparse.calc = NULL,
optpar = list(method = "BFGS", control=list(reltol = 1e-5)),
refine.df=4, refine.detail=FALSE, refine.method="control",
sparse=c(50, .02), 
varinit=c(.02, .1, .4, .8)^2, corinit = c(0, .3)) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxme.control_+3A_eps">eps</code></td>
<td>

<p>convergence criteria for the partial likelihood
</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_toler.chol">toler.chol</code></td>
<td>

<p>tolerance for the underlying Cholesky decomposition.  This is used
to detect singularity (redundant variables).
</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_iter.max">iter.max</code></td>
<td>

<p>maximum number of iterations for the final fit
</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_inner.iter">inner.iter</code></td>
<td>

<p>number of iterations for the &lsquo;inner loop&rsquo; fits, i.e. when the
partial likelihood is the objective function of <code>optim</code>.
The default is to use one more iteration than the baseline coxph
model <code>fit0</code>.  The baseline model contains only the fixed
effects, and is as part of the setup by the main program.
The minimum value of 4 applies most often to the case where there
are no fixed effects.
</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_sparse.calc">sparse.calc</code></td>
<td>

<p>choice of method 1 or 2 for a particular portion of the
calculation.  This can have an effect on run time for problems with
thousands of random effects.
</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_optpar">optpar</code></td>
<td>

<p>parameters passed forward to the <code>optim</code> routine.
</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_refine.df">refine.df</code></td>
<td>
<p>the degrees of freedom for the t-distribution
used to draw random samples
for the refine.n option</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_refine.detail">refine.detail</code></td>
<td>
<p>this option is mostly for debugging.  If TRUE
then an extra component <code>refine.detail</code> will be present in
the output which contains intermediate variables from the
iterative refinement calculation.</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_refine.method">refine.method</code></td>
<td>
<p>method by which the control calculations are
done. This is a current research/development question, the option
will likely disappear at some future date, and users should ignore
it.</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_sparse">sparse</code></td>
<td>
<p>rule for deciding sparsity of a random effect, see
details below.</p>
</td></tr>  
<tr><td><code id="coxme.control_+3A_varinit">varinit</code></td>
<td>
<p>the default set of starting values for variances, used if no
<code>vinit</code> argument is supplied in the <code>coxme</code> call.</p>
</td></tr>
<tr><td><code id="coxme.control_+3A_corinit">corinit</code></td>
<td>
<p>the default set of starting values for correlations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main flow of <code>coxme</code> is to use the <code>optim</code> routine to
find the best values for the variance parameters.  For any given trial
value of the variance parameters, an inner loop maximizes the partial
likelihood to select the regression coefficients beta (fixed) and b
(random). Within this loop cholesky decomposition is used.  It is
critical that the convergence criteria of inner loops be less than
outer ones, thus toler.chol &lt; eps &lt; reltol.
</p>
<p>If no starting values are supplied for the variances of the random
effects then a grid search is performed to select initial values for
the main iteration loop.
The default values given here are based on experience but without any
formal arguments for their optimality.
We have found that the estimated standard
deviation of a random effect is often between .1 and .3, corresponding to
exp(.1)= 1.1 to exp(.3)= 1.35 fold &ldquo;average&rdquo; relative risks associated with
group membership.  This is  biologically reasonable for a latent trait.
Other common solutions ane a small random effect corresponding to only 1&ndash;5%
change in the hazard or likelihood that is maximized at the boundary
value of 0 variance.
Variances greater than 2 are very unusual.
Because we use the log(variance) as our iteration scale the 0&ndash;.001 portion of the
variance scale is stretched out giving a log-likelihood surface that is almost
flat; a Newton-Raphson iteration starting at log(.2) may have log(.0001) as its
next guess and get stuck there, never finding a true maximum that lies in the
range of .01 to .05.
Corrleation paramters seem to need fewer starting points.
</p>
<p>The sparse option controls a sparse approximation in the code.
Assume we have a mixed effects model with a random intercept per group,
and there are 1000 groups.
In a Cox model (unlike a linear mixed effects model) the resulting
second derivative matrix used during the solution will be 1000 by 1000
with no zeros, and
fitting the model can consume a large amount of both time and memory.
However, it is almost sparse, in that elements off the diagonal are
very small and can often be ignored.  Computation with a sparse
matrix approximation will be many times faster.
Luckily, as the number of groups increases the accuracy of the
approximation also increases.
If <code>sparse=c(50, .03)</code> this states that sparse approximation will
be employed for any grouping variable with 50 or more levels, and off
diagonal elements that relate any two levels both of which represent
.03 of less of the total sample will be treated as zero.
</p>


<h3>Value</h3>

<p>a list of control parameters</p>


<h3>Author(s)</h3>

<p>Terry Therneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxme">coxme</a></code>
</p>

<hr>
<h2 id='coxme.object'>Coxme regression output object
</h2><span id='topic+coxme.object'></span>

<h3>Description</h3>

<p>This contains further description of the output object created by a
<code>coxme</code> call.  Most components can be accessed with extractor
functions, which is the safer route since details of the object will
likely change over time.
</p>


<h3>Details</h3>

<p>The structure of each element of the random effects
coefficients (obtained with <code>ranef</code>) and variances
(<code>VarCorr</code>) depend on the variance functions, i.e., the functions
used in the <code>varlist</code> argument.
Since users can write their own variance functions this format can
never be completely known.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the coefficients of the fixed effects.  Use the
<code>fixef</code> function to extract them.</p>
</td></tr>
<tr><td><code>frail</code></td>
<td>
<p>the coefficients of the random effects.  Use the
<code>ranef</code> function to extract them.  These are always stored as a
list with one member per random effect; each parenthesised term in
the model is a random effect.
In a linear mixed effects model the fixed effects and the variances
of the random effects can be obtained without explicitly computing
the coefficients of the random effects, the latter are called BLUP
estimates and are computed later if at all.  This is not the case for a
Cox model, there the random effect coefficients are a required part
of the iteration process and so are always present in the final model.</p>
</td></tr>
<tr><td><code>vcoef</code></td>
<td>
<p>the variances of the random effects.  Use the
<code>VarCorr</code> function to extract them.  These are always stored as a
list with one member per random effect.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>the variance-covariance matrix of the coefficient
vector, including both fixed and random terms.  The random effects
are listed first.  This will often be a sparse matrix.
The <code>vcov</code> function
will extract the fixed effects portion, which is always dense.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the log-likelihood vector from the fit.  The first
element is the loglik at the initial values, the second is the
integrated partial likelihood at the solution (IPL), the third is
the penalized partial likelihood at the solution(PPL).</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom for the IPL and the PPL solutions.</p>
</td></tr>
<tr><td><code>hmat</code></td>
<td>
<p>sparse Cholesky factorization of the information matrix.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>outer and inner iterations performed.  For each trial
value of the variance parameters an Cox model partial likelihood
must be solved; the outer iterations is the reported number from the
optim() routine which handles the variance parameters, the inner
iterations is the cumulative number of partial likelihood
iterations.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a copy of the <code>coxph.control</code> parameters used in
the fit.</p>
</td></tr>
<tr><td><code>ties</code></td>
<td>
<p>the computational method used for ties.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the vector of first derivatives of the PPL, at the solution.</p>
</td></tr>
<tr><td><code>means</code>, <code>scale</code></td>
<td>
<p>means and scale for each predictor, used internally
to scale the problem.</p>
</td></tr>
<tr><td><code>linear.predictor</code></td>
<td>
<p>the vector of linear predictors.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>vector containing the number of events and the number of
observations in the fitting data set.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object from the fixed effects of the model
formula.  Access using the <code>terms</code> function.</p>
</td></tr>
<tr><td><code>formulaList</code></td>
<td>
<p>the fixed and random portions of the formula,
separated</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>the missing value attributes of the data, if any</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code>, <code>model</code></td>
<td>
<p>optional: the x matrix, response, for model frame.
These depend on the corresponding arguments in the call.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a copy of the call to the routine</p>
</td></tr>
</table>

<hr>
<h2 id='coxmeFull'>Variance family function for coxme fits.
</h2><span id='topic+coxmeFull'></span>

<h3>Description</h3>

<p>This function sets up the default variance family information for a
mixed effects survival model fit with <code>coxme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxmeFull(collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxmeFull_+3A_collapse">collapse</code></td>
<td>

<p>Form for fitting a nested effect, either standard or collapsed.  The
latter appears to be more numerically stable (still under research).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coxme variance families create a list with three functions: initialize,
generate, and wrapup, that determine how the variance structure of a fit
is modeled.
</p>


<h3>Value</h3>

<p>an object of class coxvar.
</p>


<h3>Author(s)</h3>

<p>Terry Therneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxme">coxme</a></code>
</p>

<hr>
<h2 id='coxmeMlist'>Coxme variance function</h2><span id='topic+coxmeMlist'></span>

<h3>Description</h3>

<p>This variance function accepts a list of matrices, which define a
correlation structure for a coxme fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxmeMlist(varlist, rescale = FALSE, pdcheck = TRUE, positive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxmeMlist_+3A_varlist">varlist</code></td>
<td>
<p>a list containing one or more matrix or bdsmatrix objects.</p>
</td></tr>
<tr><td><code id="coxmeMlist_+3A_rescale">rescale</code></td>
<td>

<p>if TRUE, each input matrix is rescaled to have a diagonal of 1.
(Kinship matrices for instance are often generated with a diagonal
of .5 and would be multiplied by 2).
</p>
</td></tr>
<tr><td><code id="coxmeMlist_+3A_pdcheck">pdcheck</code></td>
<td>

<p>check each matrix to ensure that it is positive definite
</p>
</td></tr>
<tr><td><code id="coxmeMlist_+3A_positive">positive</code></td>
<td>

<p>constrain coefficients to be positive.  This may also be a vector of
the same length as <code>varlist</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If two matrices <code class="reqn">A</code> and <code class="reqn">B</code> were given, this fits
the variance structure
<code class="reqn">V= \sigma_1^2 A + \sigma_2^2 B</code>,
where the variances <code class="reqn">\sigma_1^2</code> and <code class="reqn">\sigma_2^2</code> are
parameters that will be optimized by <code>coxme</code>,
treating <code class="reqn">A</code> and <code class="reqn">B</code> as fixed.
</p>


<h3>Value</h3>

<p>a coxme variance family object, used by <code>coxme</code> in the fitting process.
</p>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxme">coxme</a></code></p>

<hr>
<h2 id='eortc'>Simulated data set based on an EORTC trial</h2><span id='topic+eortc'></span>

<h3>Description</h3>

<p>This is a simulated surival data set for investigating random
center effects.  To make it realistic, the number of centers and
their sizes is based on an EORTC cancer trial. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eortc)</code></pre>


<h3>Format</h3>

<p>A data frame with 2323 observations on the following 4 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>survival time</p>
</dd>
<dt><code>uncens</code></dt><dd><p>0=alive, 1=dead</p>
</dd>
<dt><code>center</code></dt><dd><p>enrolling center, a number from 1 to 37</p>
</dd>
<dt><code>trt</code></dt><dd><p>treatment arm, 0 or 1</p>
</dd>
</dl>



<h3>Details</h3>

<p> This is used in the test suite for the code. </p>


<h3>Source</h3>

<p>PhD thesis work of Jose Cortinas Abrahantes</p>


<h3>References</h3>

<p>Cortinas Abrahantes, Jose; Burzykowski, Tomasz (2002), A version of the
EM algorithm for proportional hazards models with random effects ,
Published in: Lecture Notes of the ICB Seminars. p. 15-20
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eortc)
coxme(Surv(y, uncens) ~ trt + (trt| center) + strata(center), eortc)
</code></pre>

<hr>
<h2 id='expand.nested'>Expand nested factors</h2><span id='topic+expand.nested'></span>

<h3>Description</h3>

<p>Expand out the data frame for a nested factor such as (1| a/b).
This is used by the variance function routines of <code>coxme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.nested(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.nested_+3A_x">x</code></td>
<td>
<p>A data frame containing the nesting variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initialize function of a <code>coxme</code> variance family is
passed, as one of its arguments, a data frame <code>G</code> containing
the grouping variables, each of which is a factor..
Assume a nested factor <code>(1| a/b)</code> in the model formula and
a data set whose first few rows are:
</p>
<pre>
    a    b
    1    1
    1    2
    2    1
  </pre>
<p>The function will replace the second column with a variable named
<code>a/b</code> and values of 1/1, 1/2, 2/1, etc.
</p>


<h3>Value</h3>

<p>an updated data frame</p>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxme">coxme</a></code>, <code><a href="#topic+coxmeMlist">coxmeMlist</a></code>
</p>

<hr>
<h2 id='fixed.effects'>Import from package <span class="pkg">nlme</span></h2><span id='topic+fixed.effects'></span><span id='topic+fixef'></span>

<h3>Description</h3>

<p>The <code>fixed.effects</code> and <code>fixef</code> methods are
imported from package <span class="pkg">nlme</span>.
Help is available here:  <code><a href="nlme.html#topic+fixed.effects">nlme::fixed.effects</a></code>.
</p>

<hr>
<h2 id='fixef.coxme'>Extraction functions for Coxme</h2><span id='topic+fixef.coxme'></span><span id='topic+ranef.coxme'></span><span id='topic+vcov.coxme'></span><span id='topic+VarCorr.coxme'></span>

<h3>Description</h3>

<p>Extract the fixed effects, randome effects, variance of the
fixed effects, or variance of the random effects from a coxme model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxme'
fixef(object, ...)
## S3 method for class 'coxme'
ranef(object, ...)
## S3 method for class 'coxme'
vcov(object, ...)
## S3 method for class 'coxme'
VarCorr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.coxme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>coxme</code> 
representing the result of a mixed effects Cox model.
</p>
</td></tr>
<tr><td><code id="fixef.coxme_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>coxme</code> 
representing the result of a mixed effects Cox model.
</p>
</td></tr>
<tr><td><code id="fixef.coxme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the fixed effects are a vector and the variance of the fixed
effects is a matrix.  The random effects will be a list with one
element for each random effects terms, as will be their variance.</p>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxme">coxme</a></code>, <code><a href="#topic+random.effects">random.effects</a></code>,
<code><a href="#topic+fixed.effects">fixed.effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rat1 &lt;- coxme(Surv(time, status) ~ rx + (1|litter), rats)
fixed.effects(rat1)
vcov(rat1)
random.effects(rat1)[[1]]  #one value for each of the 50 litters
VarCorr(rat1)
</code></pre>

<hr>
<h2 id='fixef.lmekin'>Extraction functions for Lmekin</h2><span id='topic+fixef.lmekin'></span><span id='topic+ranef.lmekin'></span><span id='topic+vcov.lmekin'></span><span id='topic+VarCorr.lmekin'></span><span id='topic+logLik.lmekin'></span>

<h3>Description</h3>

<p>Extract the fixed effects, random effects, variance of the
fixed effects, or variance of the random effects from a linear mixed
effects model fit with lmekin.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmekin'
fixef(object, ...)
## S3 method for class 'lmekin'
ranef(object, ...)
## S3 method for class 'lmekin'
vcov(object, ...)
## S3 method for class 'lmekin'
VarCorr(x, ...)
## S3 method for class 'lmekin'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.lmekin_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>lmekin</code> 
representing the result of a mixed effects model.
</p>
</td></tr>
<tr><td><code id="fixef.lmekin_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>lmekin</code> 
representing the result of a mixed effects model.
</p>
</td></tr>
<tr><td><code id="fixef.lmekin_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>For the random effects model <code class="reqn">y = X\beta + Zb + \epsilon</code>, let <code class="reqn">\sigma^2</code> be the variance of the error term
<code class="reqn">\epsilon</code>.
Let <code class="reqn">A= \sigma^2 P</code> be the variance of the random effects
<code class="reqn">b</code>.  There is a computational advantage to solving the problem
in terms of <code class="reqn">P</code> instead of <code class="reqn">A</code>, and that is what is
stored in the returned lmekin object.
The <code>VarCorr</code> function returns elements of <code class="reqn">P</code>; the print
and summary functions report values of <code class="reqn">A</code>.
Pinhiero and Bates call <code class="reqn">P</code> the precision factor.
</p>


<h3>Value</h3>

<p>the fixed effects are a vector and vcov returns their
variance/covariance matrix.  The random effects are a list with one
element for each random effect.  The ranef component contains the
coefficients and VarCorr the estimated variance/covariance matrix.
The logLik method returns the loglikelihood along with its
degrees of freedom.</p>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>References</h3>

<p>J Pinheiro and D Bates, Mixed-effects models in S and
S-Plus. Springer, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmekin">lmekin</a></code>, <code><a href="#topic+random.effects">random.effects</a></code>,
<code><a href="#topic+fixed.effects">fixed.effects</a></code>, <code>link{vcov}</code>, <code><a href="#topic+VarCorr">VarCorr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ergoStool, package="nlme")  # use a data set from nlme
efit &lt;-  lmekin(effort ~ Type + (1|Subject), ergoStool)
ranef(efit)
</code></pre>

<hr>
<h2 id='lmekin'>Fit a linear mixed effects model</h2><span id='topic+lmekin'></span>

<h3>Description</h3>

<p>The lmekin function fits a linear mixed effects model, with random
effects specified in the same structure as in the <code>coxme</code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmekin(formula, data, weights, subset, na.action, control,
varlist, vfixed, vinit, method = c("ML", "REML"),
x = FALSE, y = FALSE, model=FALSE,
random, fixed, variance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmekin_+3A_formula">formula</code></td>
<td>

<p>a two-sided formula with the response as the left hand side of a
<code>~</code> operator and the fixed and random effects on the right.
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables named in the <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_subset">subset</code>, <code id="lmekin_+3A_weights">weights</code>, <code id="lmekin_+3A_na.action">na.action</code></td>
<td>

<p>further model specifications arguments as in <code>lm</code>; see there
for details.
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_control">control</code></td>
<td>

<p>optional list of control options.  See <code>coxme.control</code> for details. 
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_varlist">varlist</code></td>
<td>

<p>the variance family to be used for each random term.  If there are
multiple terms it will be a list of variance functions.
The default is <code>coxmeFull</code>.
Alternatively it can be a list of matrices, in which case the
<code>coxmeMlist</code> function is used.
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_vfixed">vfixed</code></td>
<td>

<p>optional named list or vector used to fix the value of one or more
of the variance terms at a constant.
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_vinit">vinit</code></td>
<td>

<p>optional named list or vector giving suggested starting values for
the variance.
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_method">method</code></td>
<td>
<p>fit using either maximum likelihood or restricted
maximum likelihood
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_x">x</code></td>
<td>

<p>if TRUE the X matrix (fixed effects) is included in the output object
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_y">y</code></td>
<td>

<p>if TRUE the y variable is included in the output object
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_model">model</code></td>
<td>

<p>if TRUE the model frame is included in the output object
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_fixed">fixed</code>, <code id="lmekin_+3A_random">random</code>, <code id="lmekin_+3A_variance">variance</code></td>
<td>

<p>In an earlier version of <code>lmekin</code>
the fixed and random effects were separate arguments.  These arguments
are included for backwards compatability, but are depreciated.
The variance argument is a depreciated alias for vfixed.
</p>
</td></tr>
<tr><td><code id="lmekin_+3A_...">...</code></td>
<td>

<p>any other arguments are passed forward to <code>coxme.control</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">A= \sigma^2 B</code> be the variance matrix of the random
effects where <code class="reqn">\sigma^2</code> is the residual variance for the
model.  Internally the routine solves for the parameters of
<code class="reqn">B</code>, computing <code class="reqn">A</code> at the end.  The <code>vinit</code> and
<code>vfixed</code> parmaters refer to <code class="reqn">B</code>, however.
</p>
<p>It is possible to specify certain models in <code>lmekin</code>
that can not be fit with lme, in particular models with
familial genetic effects, i.e., a <em>kinship</em> matrix, and hence the
name of the routine.  Using user-specified variance functions an even
wider range of models is possible.
For simple models the specification of the random effects follows the
same form as the <code>lmer</code> function.  For any model which can be fit
by both <code>lmekin</code> and <code>lmer</code>, the latter routine would
normally be prefered due to a much wider selection of post-fit tools
for residuals, prediction and plotting.
</p>
<p>Much of the underlying model code for specification and manipulation
of the random effects is shared with the <code>coxme</code> routine.  In
fact lmekin was originally written only to provide a test routine for
those codes, and no expectation that it would find wider utility.
</p>


<h3>Value</h3>

<p>An object of class <code>lmekin</code>.
</p>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmekin.object">lmekin.object</a></code>, <code><a href="#topic+coxme">coxme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ergoStool, package="nlme")  # use a data set from nlme 
  fit1 &lt;- lmekin(effort ~ Type + (1|Subject), data=ergoStool)
  ## Not run: 
  # gives the same result
  require(nlme)
  fit2 &lt;- lme(effort ~ Type, data=ergoStool, random= ~1|Subject,
            method="ML")
  
## End(Not run) 
</code></pre>

<hr>
<h2 id='lmekin.control'>
Auxillary parameters for controlling lmekin fits.
</h2><span id='topic+lmekin.control'></span>

<h3>Description</h3>

<p>Auxillary function which packages the optional parameters of a
<code>lmekin</code> fit as a single list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmekin.control(
optpar = list(method = "BFGS", control=list(reltol = 1e-8)),
varinit=c(.02, .1, .8, 1.5)^2, corinit = c(0, .3)) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmekin.control_+3A_optpar">optpar</code></td>
<td>

<p>parameters passed forward to the <code>optim</code> routine.
</p>
</td></tr>
<tr><td><code id="lmekin.control_+3A_varinit">varinit</code></td>
<td>
<p>the default grid of starting values for variances, used if no
<code>vinit</code> argument is supplied in the <code>lmekin</code> call.</p>
</td></tr>
<tr><td><code id="lmekin.control_+3A_corinit">corinit</code></td>
<td>
<p>the default grid of starting values for correlations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main flow of <code>lmekin</code> is to use the <code>optim</code> routine to
find the best values for the variance parameters.  For any given trial
value of the variance parameters, a subsidiary computation maximizes
the likelihood to select the regression coefficients beta (fixed) and b
(random).
</p>
<p>If no starting values are supplied for the variances of the random
effects then a grid search is performed to select initial values for
the main iteration loop.
The variances and correlations are all scaled by
<code class="reqn">\sigma^2</code>,
making these starting estimates scale free, e.g., replacing y by 10*y in a
data set will change <code class="reqn">\sigma</code> but not the internal
representation of any other variance parameters.
Because we use the log(variance) as our iteration scale the 0&ndash;.001
portion of the
variance scale is stretched out giving a log-likelihood surface that is almost
flat; a Newton-Raphson iteration starting at log(.2) may have log(.0001) as its
next guess and get stuck there, never finding a true maximum that lies in the
range of .01 to .05.
Corrleation paramters seem to need fewer starting points.
</p>


<h3>Value</h3>

<p>a list of control parameters</p>


<h3>Author(s)</h3>

<p>Terry Therneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmekin">lmekin</a></code>
</p>

<hr>
<h2 id='lmekin.object'>lmekin object</h2><span id='topic+lmekin.object'></span>

<h3>Description</h3>

<p>This class of object is returned by the <code>lmekin</code> function to 
represent a fittd mixed effect linear model.
Objects of this class currently have methods for <code>print</code> and
<code>residuals</code>.
</p>


<h3>Value</h3>

<p> A list with the folling components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with components <code>fixed</code> and
<code>random</code>; the first will be NULL for a model with no fixed
effects.  The <code>random</code> component is itself a list, with an
element for each random effect.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the variance matrix of the fixed effects</p>
</td></tr>
<tr><td><code>vcoef</code></td>
<td>
<p>the parameters of the variance matrix of the random
effects.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>vector of residuals from the fit</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>either &quot;ML&quot; or &quot;REML&quot;</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the log-likelihood for the fitted model</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the estimated residual error</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations used</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a copy of the call</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>this will be present if any observations were removed
due to missing values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmekin">lmekin</a></code>, <code><a href="#topic+coxmeFull">coxmeFull</a></code>,
<code><a href="#topic+coxmeMlist">coxmeMlist</a></code></p>

<hr>
<h2 id='logLik.coxme'>The logLik method for coxme objects</h2><span id='topic+logLik.coxme'></span>

<h3>Description</h3>

<p>logLik is most commonly used for a model fitted by maximum
likelihood, and some uses, e.g. by AIC.
This method allows generic functions to easily extract the
log-likelhood of a coxme model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxme'
logLik(object, type = c("penalized", "integrated"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.coxme_+3A_object">object</code></td>
<td>
<p>a fitted coxme model</p>
</td></tr>
<tr><td><code id="logLik.coxme_+3A_type">type</code></td>
<td>
<p>which of the two types of partial likelihood to extract</p>
</td></tr>
<tr><td><code id="logLik.coxme_+3A_...">...</code></td>
<td>
<p>used by other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood for a mixed effects Cox model can be viewed in two ways:
the ordinarly partial likelihood, where the random effects act only as
a penalty or constraint, or a partial likelihood where the random
effect has been integrated out.  Both are valid.
</p>


<h3>Value</h3>

<p>Returns an object of class logLik.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code></p>

<hr>
<h2 id='predict.coxme'>Predictions for a coxme object.</h2><span id='topic+predict.coxme'></span>

<h3>Description</h3>

<p>Return predicted values from a coxme fit.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxme'
predict(object, newdata, type = c("lp", "risk"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.coxme_+3A_object">object</code></td>
<td>
<p>an object of class <code>coxme</code>, 
from the fit of a mixed effects survival model</p>
</td></tr>
<tr><td><code id="predict.coxme_+3A_newdata">newdata</code></td>
<td>
<p>new data set, not yet supported</p>
</td></tr>
<tr><td><code id="predict.coxme_+3A_type">type</code></td>
<td>
<p>type of prediction</p>
</td></tr>
<tr><td><code id="predict.coxme_+3A_...">...</code></td>
<td>
<p>arguments for other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of predicted values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxme">coxme</a></code></p>

<hr>
<h2 id='print.coxme'>
Print method for a coxme fit.
</h2><span id='topic+print.coxme'></span>

<h3>Description</h3>

<p>Print out the result of a coxme fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxme'
print(x, rcoef=FALSE, digits = options()$digits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coxme_+3A_x">x</code></td>
<td>

<p>an object of class <code>coxme</code>, from the fit of a mixed effects
survival model.
</p>
</td></tr>
<tr><td><code id="print.coxme_+3A_rcoef">rcoef</code></td>
<td>
<p>print the random (penalized) coefficients, as well as
the fixed ones.</p>
</td></tr>
<tr><td><code id="print.coxme_+3A_digits">digits</code></td>
<td>

<p>number of significant digits to print</p>
</td></tr>
<tr><td><code id="print.coxme_+3A_...">...</code></td>
<td>

<p>optional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terry Therneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxme">coxme</a></code></p>

<hr>
<h2 id='print.lmekin'>Print function for lmekin</h2><span id='topic+print.lmekin'></span>

<h3>Description</h3>

<p>Print out the result of an lmekin fit.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmekin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lmekin_+3A_x">x</code></td>
<td>
<p>an object of class <code>lmekin</code>.</p>
</td></tr>
<tr><td><code id="print.lmekin_+3A_...">...</code></td>
<td>
<p>generic arguments to print, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print function current has no options.  This should one day improve.
</p>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmekin">lmekin</a></code></p>

<hr>
<h2 id='ranef'>Import from package <span class="pkg">nlme</span></h2><span id='topic+ranef'></span><span id='topic+random.effects'></span>

<h3>Description</h3>

<p>The <code>ranef</code> and <code>random.effects</code> methods are imported
from package <span class="pkg">nlme</span>.
Help is available here:  <code><a href="nlme.html#topic+random.effects">nlme::random.effects</a></code>.
</p>

<hr>
<h2 id='summary.coxme'>Summary method for coxme objects
</h2><span id='topic+summary.coxme'></span><span id='topic+print.summary.coxme'></span>

<h3>Description</h3>

<p>Create a short summary of a coxme object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxme'
summary(object, ...)
## S3 method for class 'summary.coxme'
print(x, digits = max(1L, getOption("digits") - 3L), 
    signif.stars = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.coxme_+3A_object">object</code></td>
<td>
<p>the result of a coxme fit</p>
</td></tr>
<tr><td><code id="summary.coxme_+3A_x">x</code></td>
<td>
<p>the result of a coxme fit</p>
</td></tr>
<tr><td><code id="summary.coxme_+3A_summary.coxme">summary.coxme</code></td>
<td>
<p>a result of summary.coxme</p>
</td></tr>
<tr><td><code id="summary.coxme_+3A_digits">digits</code></td>
<td>
<p>default number of digits to use</p>
</td></tr>
<tr><td><code id="summary.coxme_+3A_signif.stars">signif.stars</code></td>
<td>
<p>display the (idiotic) asterisks next to
'significant' p values</p>
</td></tr>
<tr><td><code id="summary.coxme_+3A_...">...</code></td>
<td>
<p>other options to the internal <code>printCoefmat</code> call</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary function is a useful way to get the matrix of coefficients,
for other use.
</p>


<h3>Value</h3>

<p>a <code>summary.coxme</code> object with components coefficients (a
matrix with value, standard error, z, and p), random (a data frame
containing sd of the random effects), and selected elements from the
fit object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.coxme">fixef.coxme</a></code>, <code><a href="#topic+ranef.coxme">ranef.coxme</a></code>,
<code><a href="#topic+VarCorr">VarCorr</a></code>
</p>

<hr>
<h2 id='VarCorr'>Import from package <span class="pkg">nlme</span></h2><span id='topic+VarCorr'></span>

<h3>Description</h3>

<p>The <code>VarCorr</code> method is imported from package <span class="pkg">nlme</span>.
Help is available here:  <code><a href="nlme.html#topic+VarCorr">nlme::VarCorr</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
