<!DOCTYPE html><html><head><title>Help for package BayesX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesX-package'>
<p>R Utilities Accompanying the Software Package BayesX</p></a></li>
<li><a href='#.ringDirxy'><p>Compute direction of points in a polygon.</p></a></li>
<li><a href='#add.neighbor'><p>Add Neighborhood Relations</p></a></li>
<li><a href='#bnd2gra'><p>Convert Boundary Format to Graph Format</p></a></li>
<li><a href='#createxymap'><p>Create map objects for some points and a given distance</p></a></li>
<li><a href='#delete.neighbor'><p>Delete Neighborhood Relations</p></a></li>
<li><a href='#drawmap'><p>Drawing Geographical Information</p></a></li>
<li><a href='#extractSamples'><p>Extract MCMC samples from a BayesX results directory</p></a></li>
<li><a href='#fuse'><p>Combine Regions</p></a></li>
<li><a href='#get.centroids'><p>Compute Centroids of Polygons</p></a></li>
<li><a href='#get.neighbor'><p>Obtain Neighbors of Given Regions</p></a></li>
<li><a href='#getNumbers'><p>Extract numbers from (BayesX log file) strings</p></a></li>
<li><a href='#hpd'><p>Computing Highest Posterior Density (HPD) Intervals</p></a></li>
<li><a href='#Interface+20between+20nb+20and+20gra+20format'><p>Convert nb and gra format into each other</p></a></li>
<li><a href='#Interface+20between+20sp+20and+20bnd+20format'><p>Convert sp and bnd format into each other</p></a></li>
<li><a href='#plotautocor'><p>Computing and Plotting Autocorrelation Functions</p></a></li>
<li><a href='#plotnonp'><p>Plotting Nonparametric Function Estimates</p></a></li>
<li><a href='#plotsample'><p>Plotting Sampling Paths</p></a></li>
<li><a href='#plotsurf'><p>Visualise Surface Estimates</p></a></li>
<li><a href='#read.bnd'><p>Read Geographical Information in Boundary Format</p></a></li>
<li><a href='#read.gra'><p>Read Geographical Information in Graph Format</p></a></li>
<li><a href='#shp2bnd'><p>convert a shape-file into a boundary object</p></a></li>
<li><a href='#smooth.bnd'><p>Round Boundary Information</p></a></li>
<li><a href='#write.bnd'><p>Saving Maps in Boundary Format</p></a></li>
<li><a href='#write.gra'><p>Saving Maps in Graph Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Utilities Accompanying the Software Package BayesX</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for exploring and visualising estimation results
  obtained with BayesX, a free software for estimating structured additive
  regression models (<a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>). In addition,
  functions that allow to read, write and manipulate map objects that are required in spatial
  analyses performed with BayesX.</td>
</tr>
<tr>
<td>Depends:</td>
<td>shapefiles</td>
</tr>
<tr>
<td>Imports:</td>
<td>sp, sf, colorspace, coda, splines, methods, interp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spdep</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-20 06:19:08 UTC; nik</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolaus Umlauf <a href="https://orcid.org/0000-0003-2160-9803"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Thomas Kneib [aut],
  Nadja Klein [aut],
  Felix Heinzl [ctb],
  Andreas Brezger [ctb],
  Daniel Sabanes Bove [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nikolaus Umlauf &lt;Nikolaus.Umlauf@uibk.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 07:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesX-package'>
R Utilities Accompanying the Software Package BayesX
</h2><span id='topic+BayesX-package'></span>

<h3>Description</h3>

<p>This package provides functionality for exploring and visualising
estimation results obtained with the software package <span class="pkg">BayesX</span>
for structured additive regression. It also provides functions that allow
to read, write and manipulate map objects that are required in spatial
analyses performed with <span class="pkg">BayesX</span>. 
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Nadja Klein, Felix Heinzl, Andreas Brezger, Daniel Sabanes Bove</p>


<h3>References</h3>

<p>Belitz C, Brezger A, Kneib T, Lang S (2011). <span class="pkg">BayesX</span> - Software for Bayesian Inference in 
Structured Additive Regression Models. Version 2.0.1. 
URL <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>

<hr>
<h2 id='.ringDirxy'>Compute direction of points in a polygon.</h2><span id='topic+.ringDirxy'></span>

<h3>Description</h3>

<p>This is (private, not exported) R code replacing the call to
maptools:::.ringDirxy, which links to C code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ringDirxy(xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ringDirxy_+3A_xy">xy</code></td>
<td>
<p>a two-column matrix with x and y coordinates of at least 3 points which form a polygon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the integer -1 if the direction is counter-clockwise and 1 if
the direction is clockwise.
</p>


<h3>Note</h3>

<p>The function uses vectorization and should not be very much slower
than the original.
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Create test polygon ordered clockwise.
nPoints &lt;- 200
sequence &lt;- seq(1, 10, length = nPoints)
firstHalf &lt;- sequence[1:(nPoints/2)]

test &lt;- cbind(
  "x" = c(sequence, rev(sequence)),
  "y" = c(firstHalf, rev(firstHalf), -firstHalf, -rev(firstHalf))
)

plot(test, type="n")
polygon(test)

## Compute direction with this and the original function,
BayesX:::.ringDirxy(test)

## End(Not run)</code></pre>

<hr>
<h2 id='add.neighbor'>Add Neighborhood Relations</h2><span id='topic+add.neighbor'></span>

<h3>Description</h3>

<p>Adds a neighborhhod relationship between two given regions to a map object in graph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.neighbor(map, region1, region2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.neighbor_+3A_map">map</code></td>
<td>
<p>Map object in graph format that should be modified.</p>
</td></tr>
<tr><td><code id="add.neighbor_+3A_region1">region1</code>, <code id="add.neighbor_+3A_region2">region2</code></td>
<td>
<p>Names of the regions that should be connected as neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix that represents the neighborhood structure of <code>map</code> plus the new neighborhood relation in graph format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.neighbor">get.neighbor</a></code>,<code><a href="#topic+delete.neighbor">delete.neighbor</a></code>,<code><a href="#topic+read.gra">read.gra</a></code>,<code><a href="#topic+write.gra">write.gra</a></code><code><a href="#topic+bnd2gra">bnd2gra</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>germany &lt;- read.gra(system.file("examples/germany.gra", package="BayesX"))
get.neighbor(germany, c("1001", "7339"))
germany &lt;- add.neighbor(germany, "7339", "1001")
get.neighbor(germany, c("1001", "7339"))
</code></pre>

<hr>
<h2 id='bnd2gra'>Convert Boundary Format to Graph Format</h2><span id='topic+bnd2gra'></span>

<h3>Description</h3>

<p>Converts a map in boundary format to a map in graph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bnd2gra(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bnd2gra_+3A_map">map</code></td>
<td>
<p>Map in boundary format that should be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix that represents the neighborhood structure of the map object in graph format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>References</h3>

<p>BayesX Reference Manual. Available from <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bnd">read.bnd</a></code>,<code><a href="#topic+read.gra">read.gra</a></code>,<code><a href="#topic+write.bnd">write.bnd</a></code>,<code><a href="#topic+write.gra">write.gra</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tanzania.bnd &lt;- read.bnd(system.file("examples/tanzania.bnd", package="BayesX"))
tanzania.gra &lt;- bnd2gra(tanzania.bnd)
</code></pre>

<hr>
<h2 id='createxymap'>Create map objects for some points and a given distance</h2><span id='topic+createxymap'></span>

<h3>Description</h3>

<p>Creates a map object from a list of coordinates by treating observations within a certain distance as neighbors. 
The resulting neighborhood structure is stored in a map object in graph format while a map
in boundary format is created to enable visualisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createxymap(x, y, districts=NULL, p=2, max.dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createxymap_+3A_x">x</code></td>
<td>
<p>Vector of x-coordinates of underlying points</p>
</td></tr>
<tr><td><code id="createxymap_+3A_y">y</code></td>
<td>
<p>Vector of y-coordinates of underlying points</p>
</td></tr>
<tr><td><code id="createxymap_+3A_districts">districts</code></td>
<td>
<p>Either <code>NULL</code> or a vector of names for labeling points. If <code>districts=NULL</code>, points are labelled by index.</p>
</td></tr>
<tr><td><code id="createxymap_+3A_p">p</code></td>
<td>
<p>Any p-norm with p&gt;=1 can be chosen as the distance measure with the Euclidian distance (<code>p=2</code>) being the default. For <code>p=Inf</code>, the maximum of coordinates is used. Except for <code>p=Inf</code>, calculations can fail for huge <code>p</code>.</p>
</td></tr>
<tr><td><code id="createxymap_+3A_max.dist">max.dist</code></td>
<td>
<p>Value which determines the neighborship. Points whose distance is smaller or equal than <code>max.dist</code> are considered as neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two elements: map object in graph format and map object in boundary format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.gra">read.gra</a></code>,<code><a href="#topic+read.bnd">read.bnd</a></code>,<code><a href="#topic+drawmap">drawmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(3,3,5,9.5,11,11)
y &lt;- c(2,4,4,6,4.5,5)
xymap &lt;- createxymap(x, y, districts=c("A","B","C","D","E","F"), max.dist=2)
xymap$gra
drawmap(map=xymap$bnd)
</code></pre>

<hr>
<h2 id='delete.neighbor'>Delete Neighborhood Relations</h2><span id='topic+delete.neighbor'></span>

<h3>Description</h3>

<p>Adds the neighborhhod relationship between two given regions from a map object in graph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.neighbor(map, region1, region2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete.neighbor_+3A_map">map</code></td>
<td>
<p>Map object in graph format that should be modified.</p>
</td></tr>
<tr><td><code id="delete.neighbor_+3A_region1">region1</code>, <code id="delete.neighbor_+3A_region2">region2</code></td>
<td>
<p>Names of the regions that should no longer be regarded as neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix that represents the neighborhood structure of <code>map</code> minus the deleted neighborhood relation in graph format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.neighbor">get.neighbor</a></code>,<code><a href="#topic+add.neighbor">add.neighbor</a></code>,<code><a href="#topic+read.gra">read.gra</a></code>,<code><a href="#topic+write.gra">write.gra</a></code><code><a href="#topic+bnd2gra">bnd2gra</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>germany &lt;- read.gra(system.file("examples/germany.gra", package="BayesX"))
get.neighbor(germany, c("7339"))
germany &lt;- delete.neighbor(germany, "7339", "7141")
get.neighbor(germany, c("7339"))
</code></pre>

<hr>
<h2 id='drawmap'>Drawing Geographical Information</h2><span id='topic+drawmap'></span>

<h3>Description</h3>

<p>Visualises variables that are spatially aligned according to a given map object. Each of the regions in a map will be coloured accoring to the value of the variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawmap(data, map, regionvar=2, plotvar=3, limits, cols="hcl", nrcolors=100, 
        swapcolors=FALSE, pcat=FALSE,
        hcl.par=list(h=c(120, 0), c=60, l=c(45,60), power=1.2), 
        hsv.par=list(s=1, v=1), legend=TRUE, drawnames=FALSE, cex.names=0.7, 
        cex.legend=0.7, mar.min=2, density=15, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawmap_+3A_data">data</code></td>
<td>
<p>Either the name of a file or a data frame containing the variables to be visualised. If missing, the map will be visualised without
superposition of any further information</p>
</td></tr>
<tr><td><code id="drawmap_+3A_map">map</code></td>
<td>
<p>Map object containing the required boundary information (as obtained by a call to <code><a href="#topic+read.bnd">read.bnd</a></code></p>
</td></tr>
<tr><td><code id="drawmap_+3A_regionvar">regionvar</code></td>
<td>
<p>Defines the variable specifying the geographical regions. Either the name of a variable in <code>data</code> or the index of the corresponding column.</p>
</td></tr>
<tr><td><code id="drawmap_+3A_plotvar">plotvar</code></td>
<td>
<p>Defines the variable that should be visualised. Either the name of a variable in <code>data</code> or the index of the corresponding column.</p>
</td></tr>
<tr><td><code id="drawmap_+3A_limits">limits</code></td>
<td>
<p>Restricts (or extends) the coloring scheme to a range of values.</p>
</td></tr>
<tr><td><code id="drawmap_+3A_cols">cols</code></td>
<td>
<p>Color scheme to be employed. Could be either a vector of colors or one out of the following pre-defined schemes: <code>hcl</code>, <code>hsv</code>, <code>grey</code></p>
</td></tr>
<tr><td><code id="drawmap_+3A_nrcolors">nrcolors</code></td>
<td>
<p>Number of colors (only meaningful when using one of the pre-defined colour schemes).</p>
</td></tr>
<tr><td><code id="drawmap_+3A_swapcolors">swapcolors</code></td>
<td>
<p>Reverse the order of colors (works also with user-specified colours but will be most usefule with the pre-defined schemes).</p>
</td></tr>
<tr><td><code id="drawmap_+3A_pcat">pcat</code></td>
<td>
<p>Option for the visualisation of posterior probabilities. In this case, a three-colour scheme representing significantly positive, insignificant and significantly negative values.</p>
</td></tr>
<tr><td><code id="drawmap_+3A_hcl.par">hcl.par</code></td>
<td>
<p>Parameters for the <code>hcl</code> colour scheme (see the documentation of <code>diverge_hcl</code> in package <code>vcd</code> for details).</p>
</td></tr>
<tr><td><code id="drawmap_+3A_hsv.par">hsv.par</code></td>
<td>
<p>Parameters for the <code>hsv</code> colour scheme (see the documentation of <code><a href="grDevices.html#topic+hsv">hsv</a></code> for details).</p>
</td></tr>
<tr><td><code id="drawmap_+3A_legend">legend</code></td>
<td>
<p>Should a legend be added to the figure?</p>
</td></tr>
<tr><td><code id="drawmap_+3A_drawnames">drawnames</code></td>
<td>
<p>Adds the name of each region as a text label to the plot. In most cases the result will be confusing but may be useful when checking the validity of a map.</p>
</td></tr>
<tr><td><code id="drawmap_+3A_cex.names">cex.names</code></td>
<td>
<p>Magnification to be used for the names (if <code>drawnames=TRUE</code>).</p>
</td></tr>
<tr><td><code id="drawmap_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Magnification to be used for the legend.</p>
</td></tr>
<tr><td><code id="drawmap_+3A_mar.min">mar.min</code></td>
<td>
<p>Controls the definition of boundaries. Could be either <code>NULL</code> for individual settings of <code>mar</code> or a value which defines <code>mar</code> as follows: The boundaries will be calculated according to the height to width ratio of the map with minimal boundary <code>mar.min</code>.</p>
</td></tr>
<tr><td><code id="drawmap_+3A_density">density</code></td>
<td>
<p>Regions without data will be visualised with diagonal stripes. <code>density</code> defines how dense the stripes should be.</p>
</td></tr>
<tr><td><code id="drawmap_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the plot calls that visualise the region boundaries (probably not useful at all).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib, Andreas Brezger</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bnd">read.bnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>germany &lt;- read.bnd(system.file("examples/germany.bnd", package="BayesX"))
drawmap(map=germany)
drawmap(map=germany, drawnames=TRUE)

res &lt;- read.table(system.file("examples/spatial_f_regions_spatial.res", 
                              package="BayesX"), header=TRUE)

drawmap(res, map=germany)
drawmap(res, map=germany, limits=c(-2,4))
drawmap(res, map=germany, regionvar="regions", plotvar="pmed")
drawmap(res, map=germany, legend=FALSE)
drawmap(res, map=germany, legend=FALSE, main="spatial effect")

drawmap(res, map=germany, cols="hsv")
drawmap(res, map=germany, swapcolors=TRUE, cols="hsv")
drawmap(res, map=germany, cols="grey")
drawmap(res, map=germany,
        cols=c('darkgreen','green','yellow','orange','red','darkred'))

drawmap(res, map=germany, pcat=TRUE, cols="hcl")
drawmap(res, map=germany, pcat=TRUE, cols="hsv")
drawmap(res, map=germany, pcat=TRUE, cols="grey")

drawmap(res, map=germany, nrcolors=10, cols="hcl")
drawmap(res, map=germany, nrcolors=10, cols="hsv")
drawmap(res, map=germany, nrcolors=10, cols="grey")

drawmap(res, map=germany, cols="hcl",
        hcl.par=list(h=c(0,120), c=60, l=c(45,90), power=1.2))
drawmap(res, map=germany, cols="hcl",
        hcl.par=list(h=c(300,120), c=60, l=c(45,90), power=1.2))
drawmap(res, map=germany, cols="hcl",
        hcl.par=list(h=c(40,260), c=60, l=c(45,90), power=1.2))
drawmap(res, map=germany, cols="hsv", hsv.par=list(s=0.7, v=0.7))
</code></pre>

<hr>
<h2 id='extractSamples'>Extract MCMC samples from a BayesX results directory</h2><span id='topic+extractSamples'></span>

<h3>Description</h3>

<p>This is a convenience function to extract samples from a BayesX
results directory, which processes the log file to e.g. convert the
spline coefficients samples to function values samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractSamples(directoryWithBasename, 
               logfile = file.path(dirname(directoryWithBasename), "log.txt"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractSamples_+3A_directorywithbasename">directoryWithBasename</code></td>
<td>
<p>The BayesX results directory with
basename for the files (e.g. &quot;results/test&quot;, if this was specified as
outfile in BayesX for the bayesreg object)</p>
</td></tr>
<tr><td><code id="extractSamples_+3A_logfile">logfile</code></td>
<td>
<p>The log file of the MCMC run, defaults to log.txt in
the results directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the extracted samples of effects and deviances as
well as the prediction data.frame:
</p>
<table>
<tr><td><code>&lt;function name&gt;</code></td>
<td>
<p>for P-Splines, Random Walks and spatial
effects: a list with mcmc objects 'functionSamples' and
'varianceSamples' containing the respective effects/function and
variance parameter samples.</p>
</td></tr>  
<tr><td><code>FixedEffects</code></td>
<td>
<p>an mcmc object of all fixed simple parametric
effects</p>
</td></tr>
<tr><td><code>RandomEffects</code></td>
<td>
<p>if there is at least one random effect in the
model, this is a list, with elements in the first hierarchy being
the group ID names, and elements in the second hierarchy being the
names of the covariates. The leafs are the mcmc objects
'functionSamples' and 'varianceSamples', as for the other
non-fixed terms</p>
</td></tr>  
<tr><td><code>Deviance</code></td>
<td>
<p>an mcmc object with the (unstandardized and saturated)
deviance</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>if the option <code>predictmu</code> was used, this mcmc object
contains the mean samples</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>an mcmc object with the possible scale parameter samples</p>
</td></tr>
<tr><td><code>lassoCoefficients</code></td>
<td>
<p>an mcmc object with the possible lasso regression parameter samples</p>
</td></tr>
<tr><td><code>ridgeCoefficients</code></td>
<td>
<p>an mcmc object with the possible ridge regression parameter samples</p>
</td></tr>
<tr><td><code>PredictMeans</code></td>
<td>
<p>data.frame corresponding to the possible
predictmean file in the BayesX directory</p>
</td></tr>
</table>
<p>Additionally, entries for possibly remaining lasso or ridge variance
parameters etc. are included in the return list.
</p>


<h3>Warning</h3>

<p>You should be sure that only one MCMC run is saved in the given results
directory in order to get sensible results out of this function.
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove, with contributions by Fabian Scheipl</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get the samples
samples &lt;- extractSamples(file.path(system.file("examples/samples", package="BayesX"),
                                     "res"))
str(samples)

## check deviance convergence
plot(samples$Deviance)

## fixed parametric effects
plot(samples$FixedEffects)

## nonparametric effects:

## handy plot function to get means and pointwise credible intervals
nonpPlot &lt;- function(samplesMatrix,
                     ...)
{
    x &lt;- as.numeric(colnames(samplesMatrix))

    yMeans &lt;- colMeans(samplesMatrix)
    yCredible &lt;- t(apply(samplesMatrix,
                         MARGIN=2,
                         FUN=quantile,
                         prob=c(0.025, 0.975),
                         na.rm=TRUE))
    
    matplot(x, cbind(yMeans, yCredible),
            type="l",
            lty=c(1, 2, 2),
            lwd=c(2, 1, 1),
            col=c(1, 2, 2),
            ...)
}

nonpPlot(samples$f_x1$functionSamples,
         xlab=expression(x[1]),
         ylab=expression(hat(f)(x[1])))
nonpPlot(samples$f_x2$functionSamples,
         xlab=expression(x[2]),
         ylab=expression(hat(f)(x[2])))

## spatial effect
tanzania &lt;- read.bnd(file=system.file("examples/tanzania.bnd", package="BayesX"))
drawmap(map=tanzania,
        data=
        with(samples$f_district,
             data.frame(name=colnames(functionSamples),
                        estimate=colMeans(functionSamples))),
        regionvar="name",
        plotvar="estimate")
</code></pre>

<hr>
<h2 id='fuse'>Combine Regions</h2><span id='topic+fuse'></span>

<h3>Description</h3>

<p>Combines a list of several regions of a map object in boundary format into a single region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuse(map, regions, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuse_+3A_map">map</code></td>
<td>
<p>Map object in boundary format that should be modified.</p>
</td></tr>
<tr><td><code id="fuse_+3A_regions">regions</code></td>
<td>
<p>Vector of regions to be combined</p>
</td></tr>
<tr><td><code id="fuse_+3A_name">name</code></td>
<td>
<p>Name that should be given to the region arising from fusing the specified regions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Map object in boundary format with the specified regions combined.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bnd">read.bnd</a></code>,<code><a href="#topic+write.bnd">write.bnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: map &lt;- read.bnd(system.file("examples/germany9301.bnd",
  package = "BayesX"))
drawmap(map = map, drawnames = TRUE)

## Vector of regions to be combined.
regions &lt;- c("1056","1060","1061")

## New name of combined region.
newname &lt;- "1"
newmap &lt;- fuse(map,regions,newname)
drawmap(map = newmap, drawnames = TRUE)

## Vector of regions to be combined.
germany &lt;- read.bnd(system.file("examples/germany.bnd", package="BayesX"))
drawmap(map = germany, drawnames = TRUE)
regions &lt;- c("9371","9373","9374","9471","9472","9474","9574")

## New name of combined region.
newname &lt;- "1"
newmap &lt;- fuse(germany, regions, newname)
drawmap(map = newmap, drawnames = TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='get.centroids'>Compute Centroids of Polygons</h2><span id='topic+get.centroids'></span>

<h3>Description</h3>

<p>Computes all areas and centroids of the regions of a given map in boundary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.centroids(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.centroids_+3A_map">map</code></td>
<td>
<p>Map object in boundary format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of area and centroids.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>Examples</h3>

<pre><code class='language-R'>germany &lt;- read.bnd(system.file("examples/germany.bnd", package="BayesX"))
centroids &lt;- get.centroids(germany)
centroids[1:10,]

plot(c(2100,3700),c(6800,8500),type="n", xlab="", ylab="")
for(i in 1:10){
   polygon(germany[[i]])
   region &lt;- attr(germany,"names")[i]
   text(x=centroids[i,2]+50, y=centroids[i,3]+30, region, cex=0.7)
}   
points(centroids[1:10,2:3], col='red', pch=16)
</code></pre>

<hr>
<h2 id='get.neighbor'>Obtain Neighbors of Given Regions</h2><span id='topic+get.neighbor'></span>

<h3>Description</h3>

<p>Extracts the neighbors of a number of regions from a map in graph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.neighbor(map, regions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.neighbor_+3A_map">map</code></td>
<td>
<p>Map object in graph format.</p>
</td></tr>
<tr><td><code id="get.neighbor_+3A_regions">regions</code></td>
<td>
<p>Vector of names of regions for which the neighbors should be axtracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors containing the neighbors of the elements in <code>regions</code>.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.neighbor">add.neighbor</a></code>,<code><a href="#topic+delete.neighbor">delete.neighbor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>germany &lt;- read.gra(system.file("examples/germany.gra", package="BayesX"))
get.neighbor(germany, "1001")
get.neighbor(germany, c("1001", "7339"))
</code></pre>

<hr>
<h2 id='getNumbers'>Extract numbers from (BayesX log file) strings</h2><span id='topic+getNumbers'></span>

<h3>Description</h3>

<p>This is an internal helper function for extractSamples which extracts
numbers from (BayesX log file) strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumbers(beforeStringsList, stringVector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumbers_+3A_beforestringslist">beforeStringsList</code></td>
<td>
<p>The list with the strings standing before the
numbers which shall be extracted.</p>
</td></tr>
<tr><td><code id="getNumbers_+3A_stringvector">stringVector</code></td>
<td>
<p>The vector of strings to be searched for the
numbers.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a list with the extracted numbers.
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a nice example
sampleStrings &lt;- c("Second: 385",
                   "  First:  70000 ",                   
                   "asdfkf T: 24      ")

## test the function
extractedNumbers &lt;- BayesX:::getNumbers(beforeStringsList=
                                        list(first="First:",
                                             second="Second:",
                                             third="T:"),
                                        stringVector=sampleStrings)

## and assert that the result is as expected
stopifnot(identical(extractedNumbers,
                    list(first=70000, second=385, third=24)))

## specific test
stopifnot(identical(BayesX:::getNumbers(beforeStringsList=
                                        list(Iterations = "Number of iterations:"),
                                        stringVector=
                                        "  Number of iterations: 70000 "),
                    list(Iterations=70000)))
</code></pre>

<hr>
<h2 id='hpd'>Computing Highest Posterior Density (HPD) Intervals</h2><span id='topic+hpd'></span><span id='topic+hpd.coda'></span>

<h3>Description</h3>

<p>Compute approximate HPD intervals out of MCMC-samples in BayesX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpd(data, alpha = 0.05, ...)
hpd.coda(data, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpd_+3A_data">data</code></td>
<td>
<p>Either the name of a file or a data frame containing the sample.</p>
</td></tr>
<tr><td><code id="hpd_+3A_alpha">alpha</code></td>
<td>
<p>A numeric scalar in the interval (0,1) such that 1 - alpha is the
target probability content of the intervals.. The default is alpha = 0.05.</p>
</td></tr>
<tr><td><code id="hpd_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to the internal call of <code>optim</code>
and <code>integrate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hpd</code> computes the HPD interval based on a kernel density estimate of the samples.
<code>hpd.coda</code> computes the HPD interval with the function <code>HPDinterval</code> available in
package <code>coda</code>.
</p>


<h3>Author(s)</h3>

<p>Nadja Klein</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- read.table(system.file("examples/nonparametric_f_x_pspline_sample.raw",
  package="BayesX"), header = TRUE)
hpd(res)
hpd.coda(res)
</code></pre>

<hr>
<h2 id='Interface+20between+20nb+20and+20gra+20format'>Convert nb and gra format into each other</h2><span id='topic+nb2gra'></span><span id='topic+gra2nb'></span>

<h3>Description</h3>

<p>Convert neighborhood structure objects of class &quot;nb&quot; from R-package
spdep to graph objects of class &quot;gra&quot; from R-package BayesX and vice
versa.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2gra(nbObject)
gra2nb(graObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Interface+2B20between+2B20nb+2B20and+2B20gra+2B20format_+3A_nbobject">nbObject</code></td>
<td>
<p>neighborhood structure object of class &quot;nb&quot;</p>
</td></tr>
<tr><td><code id="Interface+2B20between+2B20nb+2B20and+2B20gra+2B20format_+3A_graobject">graObject</code></td>
<td>
<p>graph object of class &quot;gra&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent object in the other format.
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove</p>


<h3>See Also</h3>

<p><code><a href="#topic+sp2bnd">sp2bnd</a></code>, <code><a href="#topic+bnd2sp">bnd2sp</a></code> for conversion
between the geographical information formats and
<code><a href="#topic+read.gra">read.gra</a></code>, <code><a href="#topic+write.gra">write.gra</a></code> for the interface to
the BayesX files.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## first nb to gra:
if(requireNamespace("sf") &amp;
   requireNamespace("spdep")) {
  library("sf")
  library("spdep")

  columbus &lt;- st_read(system.file("etc/shapes/columbus.shp",
    package = "spdep")[1])
  colNb &lt;- poly2nb(columbus)
  ## ... here manual editing is possible ...
  ## then export to graph format
  colGra &lt;- nb2gra(colNb)

  ## and save in BayesX file
  graFile &lt;- tempfile()
  write.gra(colGra, file=graFile)

  ## now back from gra to nb:
  colGra &lt;- read.gra(graFile)
  newColNb &lt;- gra2nb(colGra)
  newColNb
  ## compare this with the original
  colNb
  ## only the call attribute does not match (which is OK):
  all.equal(newColNb, colNb,
    check.attributes=FALSE)
  attr(newColNb, "call")
  attr(colNb, "call")
}

## End(Not run)</code></pre>

<hr>
<h2 id='Interface+20between+20sp+20and+20bnd+20format'>Convert sp and bnd format into each other</h2><span id='topic+sp2bnd'></span><span id='topic+bnd2sp'></span>

<h3>Description</h3>

<p>Convert geographical information objects of class &quot;SpatialPolygons&quot; (or
specializations) from R-package sp to objects of class &quot;bnd&quot; from
R-package BayesX and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2bnd(spObject, regionNames, height2width, epsilon)
bnd2sp(bndObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_spobject">spObject</code></td>
<td>
<p>object of class &quot;SpatialPolygons&quot; (or
specializations)</p>
</td></tr> 
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_regionnames">regionNames</code></td>
<td>
<p>character vector of region names (parallel to the
Polygons list in spObject), defaults to the IDs</p>
</td></tr>
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_height2width">height2width</code></td>
<td>
<p>ratio of total height to width, defaults to the
bounding box values</p>
</td></tr>
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_epsilon">epsilon</code></td>
<td>
<p>how much can two polygons differ (in maximum squared
Euclidean distance) and still match each other?, defaults to machine
precision</p>
</td></tr> 
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_bndobject">bndObject</code></td>
<td>
<p>object of class &quot;bnd&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent object in the other format.  
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove</p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2gra">nb2gra</a></code>, <code><a href="#topic+gra2nb">gra2nb</a></code> for conversion
between the neighborhood structure formats and
<code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code> for the interface to
the BayesX files.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## bnd to sp:
germany &lt;- read.bnd(system.file("examples/germany2001.bnd", package="BayesX"))
spGermany &lt;- bnd2sp(germany)

## plot the result together with the neighborhood graph
library(sp)
plot(spGermany)
library(spdep)
nbGermany &lt;- poly2nb(spGermany)
plot(nbGermany, coords=coordinates(spGermany), add=TRUE)

## example with one region inside another
spExample &lt;- spGermany[c("7211", "7235"), ]
plot(spExample)
plot(poly2nb(spExample), coords=coordinates(spExample), add=TRUE)

## now back from sp to bnd:
bndGermany &lt;- sp2bnd(spGermany)
drawmap(map=bndGermany)

## compare names and number of polygons
stopifnot(identical(names(bndGermany),
                    names(germany)),
          identical(length(bndGermany),
                    length(germany)))

## compare contains-relations
surrounding &lt;- attr(bndGermany, "surrounding")
whichInner &lt;- which(sapply(surrounding, length) &gt; 0L)
bndContainsData &lt;- data.frame(inner=names(bndGermany)[whichInner],
                              outer=unlist(surrounding))

surrounding &lt;- attr(germany, "surrounding")
whichInner &lt;- which(sapply(surrounding, length) &gt; 0L)
originalContainsData &lt;- data.frame(inner=names(germany)[whichInner],
                                   outer=unlist(surrounding))

stopifnot(all(bndContainsData[order(bndContainsData$inner), ] ==
              originalContainsData[order(originalContainsData$inner), ]))

## End(Not run)</code></pre>

<hr>
<h2 id='plotautocor'>Computing and Plotting Autocorrelation Functions</h2><span id='topic+plotautocor'></span>

<h3>Description</h3>

<p>Computes and plot autocorrelation functions for samples obtained with MCMC in BayesX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotautocor(data, ask = TRUE, lag.max=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotautocor_+3A_data">data</code></td>
<td>
<p>Either the name of a file or a data frame containing the sample.</p>
</td></tr>
<tr><td><code id="plotautocor_+3A_ask">ask</code></td>
<td>
<p><code>plotautocor</code> will plot separate autocorrelation functions for each parameter. If <code>ask=TRUE</code>, 
the user will be prompted before showing the next plot.</p>
</td></tr>
<tr><td><code id="plotautocor_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum number of lags to be considered.</p>
</td></tr>
<tr><td><code id="plotautocor_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to the internal call of <code>plot</code> such as <code>ylim</code>, etc.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- read.table(system.file("examples/nonparametric_f_x_pspline_sample.raw", 
                              package="BayesX"), header=TRUE)
plotautocor(res)
plotautocor(res, lag.max=50)
</code></pre>

<hr>
<h2 id='plotnonp'>Plotting Nonparametric Function Estimates</h2><span id='topic+plotnonp'></span>

<h3>Description</h3>

<p>Plots nonparametric function estimates obtained from BayesX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotnonp(data, x = 2, y = c(3, 4, 5, 7, 8), ylim = NULL, 
         lty = c(1, 2, 3, 2, 3), cols = rep(1, length(y)), month, year, step=12, 
         xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotnonp_+3A_data">data</code></td>
<td>
<p>Either the name of a file or a data frame containing the estimation results.</p>
</td></tr>
<tr><td><code id="plotnonp_+3A_x">x</code></td>
<td>
<p>Defines the x-axis in the plot. Either the name of a variable in <code>data</code> or the index of the corresponding column.</p>
</td></tr>
<tr><td><code id="plotnonp_+3A_y">y</code></td>
<td>
<p>Defines the variables to be plotted against <code>x</code>. May be either a vector of names of variables
in <code>data</code> or the corresponding indices. The default choice corresponds to the point estimate plus two
confidence bands.</p>
</td></tr>
<tr><td><code id="plotnonp_+3A_ylim">ylim</code></td>
<td>
<p>Since <code>plotnonp</code> plots multiple y-variables, it automatically determines the appropriate
<code>ylim</code> to make all curves visible. Argument <code>ylim</code> allows to override this default behaviour with fixed values.</p>
</td></tr>
<tr><td><code id="plotnonp_+3A_lty">lty</code></td>
<td>
<p>Vector of line types used for plotting (must have the same length as <code>y</code>). The default corresponds
to solid lines for the point estimate and dashed and dotted lines for the confidence bands.</p>
</td></tr>
<tr><td><code id="plotnonp_+3A_cols">cols</code></td>
<td>
<p>Vector of colors used for plotting (must have the same length as <code>y</code>). Default are black lines.</p>
</td></tr>
<tr><td><code id="plotnonp_+3A_month">month</code>, <code id="plotnonp_+3A_year">year</code>, <code id="plotnonp_+3A_step">step</code></td>
<td>
<p>Provide specific annotation for plotting estimation results for temporal variables. <code>month</code>
and <code>year</code> define the minimum time point whereas step specifies the type of temporal data with
<code>step=4</code>, <code>step=2</code> and <code>step=1</code> corresponding to quartely, half yearly and yearly data.</p>
</td></tr>
<tr><td><code id="plotnonp_+3A_xlab">xlab</code>, <code id="plotnonp_+3A_ylab">ylab</code></td>
<td>
<p><code>plotnonp</code> constructs default labels that can be overwritten by these arguments</p>
</td></tr>
<tr><td><code id="plotnonp_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the interval call of <code>plot</code> such as <code>type</code>, etc.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Heinzl, Andreas Brezger and Thomas Kneib</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawmap">drawmap</a></code>,<code><a href="#topic+plotautocor">plotautocor</a></code>,<code><a href="#topic+plotsample">plotsample</a></code>,<code><a href="#topic+plotsurf">plotsurf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
res &lt;- read.table(system.file("examples/nonparametric_f_x_pspline.res", 
                              package="BayesX"), header=TRUE)
plotnonp(res)
plotnonp(res, x="x")
plotnonp(res, x="x", y="pmean")
plotnonp(res, x="x", y="pmed")
plotnonp(res, x="x", y="pmed", ylim=c(-2,2))
plotnonp(res, x="x", y=c("pmean", "pqu10", "pqu90"), lty=c(1,1,1), 
         col=c("red","blue","blue"))
plotnonp(res, xlab="some variable", ylab="f(some variable)", 
         main="Nonlinear effect of some variable", sub="penalised spline")

res &lt;- read.table(system.file("examples/nonparametric2_f_time_pspline.res", 
                              package="BayesX"), header=TRUE)
plotnonp(res)
plotnonp(res, month=1, year=1980, step=12)

res &lt;- res[1:18,]                                           
plotnonp(res, month=1, year=1980, step=12)
</code></pre>

<hr>
<h2 id='plotsample'>Plotting Sampling Paths</h2><span id='topic+plotsample'></span><span id='topic+plotsample.coda'></span>

<h3>Description</h3>

<p>Plots sampling paths obtained with MCMC-sampling in BayesX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsample(data, ask = TRUE, ...)
plotsample.coda(data, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsample_+3A_data">data</code></td>
<td>
<p>Either the name of a file or a data frame containing the sample.</p>
</td></tr>
<tr><td><code id="plotsample_+3A_ask">ask</code></td>
<td>
<p><code>plotsample</code> will plot separate sampling paths for each parameter. If <code>ask=TRUE</code>, 
the user will be prompted before showing the next plot.</p>
</td></tr>
<tr><td><code id="plotsample_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to the internal call of <code>plot</code> such as <code>ylim</code>, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotsample</code> simply plots sampling paths while <code>plotsampe.coda</code> makes use of the plotting facilities available in package <code>coda</code>.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Andreas Brezger, Thomas Kneib</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawmap">drawmap</a></code>,<code><a href="#topic+plotautocor">plotautocor</a></code>,<code><a href="#topic+plotnonp">plotnonp</a></code>,<code><a href="#topic+plotsurf">plotsurf</a></code>,</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- read.table(system.file("examples/nonparametric_f_x_pspline_sample.raw",
                              package="BayesX"), header=TRUE)
plotsample(res)
</code></pre>

<hr>
<h2 id='plotsurf'>Visualise Surface Estimates</h2><span id='topic+plotsurf'></span>

<h3>Description</h3>

<p>Visualises surface estimates obtained with BayesX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsurf(data, x=2, y=3, z=4, mode=1, ticktype="detailed", 
         expand=0.75, d=100, theta=-30, phi=25, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsurf_+3A_data">data</code></td>
<td>
<p>Either the name of a file or a data frame containing the estimation results.</p>
</td></tr>
<tr><td><code id="plotsurf_+3A_x">x</code></td>
<td>
<p>Defines the x-axis in the plot. Either the name of a variable in <code>data</code> or the index of the corresponding column.</p>
</td></tr>
<tr><td><code id="plotsurf_+3A_y">y</code></td>
<td>
<p>Defines the y-axis in the plot. Either the name of a variable in <code>data</code> or the index of the corresponding column.</p>
</td></tr>
<tr><td><code id="plotsurf_+3A_z">z</code></td>
<td>
<p>Defines the z-axis in the plot. Either the name of a variable in <code>data</code> or the index of the corresponding column.</p>
</td></tr>
<tr><td><code id="plotsurf_+3A_mode">mode</code></td>
<td>
<p><code>plotsurf</code> is mostly a convenient interface to the functions <code>persp</code> (<code>mode=1</code>), <code>image</code> (<code>mode=2</code>) and
<code>contour</code> (<code>mode=3</code>).</p>
</td></tr>
<tr><td><code id="plotsurf_+3A_ticktype">ticktype</code>, <code id="plotsurf_+3A_expand">expand</code>, <code id="plotsurf_+3A_d">d</code>, <code id="plotsurf_+3A_theta">theta</code>, <code id="plotsurf_+3A_phi">phi</code></td>
<td>
<p>Overwrite the default behaviour of <code>persp</code></p>
</td></tr>
<tr><td><code id="plotsurf_+3A_...">...</code></td>
<td>
<p>Further parameteres that are parsed to the internal call to <code>persp</code>, <code>image</code> or <code>contour</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawmap">drawmap</a></code>,<code><a href="#topic+plotautocor">plotautocor</a></code>,<code><a href="#topic+plotsample">plotsample</a></code>,<code><a href="#topic+plotnonp">plotnonp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- read.table(system.file("examples/surface_f_x1_x2_pspline.res", 
                              package="BayesX"), header=TRUE)

plotsurf(res)
plotsurf(res, mode=2)
plotsurf(res, mode=3)

plotsurf(res, x="x1", y="x2", z="pmed")

plotsurf(res, ticktype="simple")

plotsurf(res, main="3D-Plot", xlab="myx", ylab="myy", zlab="f(myx,myy)")
</code></pre>

<hr>
<h2 id='read.bnd'>Read Geographical Information in Boundary Format</h2><span id='topic+read.bnd'></span>

<h3>Description</h3>

<p>Reads the geographical information provided in a file in boundary format (see Ch. 5 of the BayesX Reference Manual) and
stores it in a map object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.bnd(file, sorted=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.bnd_+3A_file">file</code></td>
<td>
<p>Name of the boundary file to be read.</p>
</td></tr>
<tr><td><code id="read.bnd_+3A_sorted">sorted</code></td>
<td>
<p>Should the regions be ordered by the numbers speciying the region names (<code>sorted=TRUE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of polygons that form the map. Additional attributes are
</p>
<table>
<tr><td><code>surrounding</code></td>
<td>
<p>Parallel list where for each polygon, the name of a possible
surrounding region is saved.</p>
</td></tr>
<tr><td><code>height2width</code></td>
<td>
<p>Ratio between height and width of the map. Allows customised drawing and storage in files by specifying the appropriate height and width.</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>Indicates whether the map is stored in boundary format (<code>bnd</code>) or graph format (<code>gra</code>). Maps returned by <code>read.bnd</code> are of class <code>bnd</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove, Felix Heinzl, Thomas Kneib, Andreas Brezger</p>


<h3>References</h3>

<p>BayesX Reference Manual. Available from <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+write.bnd">write.bnd</a></code>,<code><a href="#topic+drawmap">drawmap</a></code>,<code><a href="#topic+read.gra">read.gra</a></code>,<code><a href="#topic+write.gra">write.gra</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>germany &lt;- read.bnd(system.file("examples/germany.bnd", package="BayesX"))
drawmap(map=germany)
attributes(germany)

germany &lt;- read.bnd(system.file("examples/germany2001.bnd", package="BayesX"))
drawmap(map=germany)
attributes(germany)
</code></pre>

<hr>
<h2 id='read.gra'>Read Geographical Information in Graph Format</h2><span id='topic+read.gra'></span>

<h3>Description</h3>

<p>Reads the geographical information provided in a file in graph format (see Ch. 5 of the BayesX Reference Manual) and
stores it in a map object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gra(file, sorted=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.gra_+3A_file">file</code></td>
<td>
<p>Name of the graph file to be read.</p>
</td></tr>
<tr><td><code id="read.gra_+3A_sorted">sorted</code></td>
<td>
<p>Should the regions be ordered by the numbers speciying the region names (<code>sorted=TRUE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix that represents the neighborhood structure defined in the graph file. Additional attributes are
</p>
<table>
<tr><td><code>dim</code></td>
<td>
<p>Dimension of the (square) adjacency matrix.</p>
</td></tr>
<tr><td><code>dimnames</code></td>
<td>
<p>List of region names corresponding to rows and columns of the adjacency matrix.</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>Indicates whether the map is stored in boundary format (<code>bnd</code>) or graph format (<code>gra</code>). Maps returned by <code>read.gra</code> are of class <code>gra</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kneib, Felix Heinzl</p>


<h3>References</h3>

<p>BayesX Reference Manual. Available from <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+write.gra">write.gra</a></code>,<code><a href="#topic+read.bnd">read.bnd</a></code>,<code><a href="#topic+write.bnd">write.bnd</a></code>,<code><a href="#topic+get.neighbor">get.neighbor</a></code>,<code><a href="#topic+add.neighbor">add.neighbor</a></code>,<code><a href="#topic+delete.neighbor">delete.neighbor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>germany &lt;- read.gra(system.file("examples/germany.gra", package="BayesX"))
attributes(germany)
</code></pre>

<hr>
<h2 id='shp2bnd'>convert a shape-file into a boundary object</h2><span id='topic+shp2bnd'></span>

<h3>Description</h3>

<p>Converts the geographical information provided in a shape-file into a boundary object
(see Ch. 5 of the Reference Manual)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shp2bnd(shpname, regionnames, check.is.in = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shp2bnd_+3A_shpname">shpname</code></td>
<td>
<p>Base filename of the shape-file (including path)</p>
</td></tr>
<tr><td><code id="shp2bnd_+3A_regionnames">regionnames</code></td>
<td>
<p>Either a vector of region names or the name of the variable in the dbf-file representing these names</p>
</td></tr>
<tr><td><code id="shp2bnd_+3A_check.is.in">check.is.in</code></td>
<td>
<p>Test whether some regions are surrounded by other regions (FALSE speeds up the execution time but may result in a corrupted bnd-file)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a boundary object, i.e. a list of polygons that form the
map. See <code><a href="#topic+read.bnd">read.bnd</a></code> for more information on the format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Daniel Sabanes Bove, Thomas Kneib with contributions by Michael Hoehle and Frank Sagerer</p>


<h3>References</h3>

<p>BayesX Reference Manual. Available from <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+write.bnd">write.bnd</a></code>,<code><a href="#topic+drawmap">drawmap</a></code>,<code><a href="#topic+read.bnd">read.bnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## read shapefile into bnd object
shpName &lt;- sub(pattern="(.*)\\.dbf", replacement="\\1",
               x=system.file("examples/northamerica_adm0.dbf",
                             package="BayesX")) 
north &lt;- shp2bnd(shpname=shpName, regionnames="COUNTRY")

## draw the map
drawmap(map=north)

## compare with shipped bnd file
shippedBnd &lt;- read.bnd(system.file("examples/northamerica.bnd", package="BayesX"))
stopifnot(all.equal(north, shippedBnd))
</code></pre>

<hr>
<h2 id='smooth.bnd'>Round Boundary Information</h2><span id='topic+smooth.bnd'></span>

<h3>Description</h3>

<p>Rounds the boundary information in a map object in boundary format to a specified precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.bnd(map, digits = 2, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.bnd_+3A_map">map</code></td>
<td>
<p>Map object in boundary format that should be modified.</p>
</td></tr>
<tr><td><code id="smooth.bnd_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to.</p>
</td></tr>
<tr><td><code id="smooth.bnd_+3A_scale">scale</code></td>
<td>
<p>Scaling factor that should be applied for rounding. For example, with
<code>scale=0.1</code> all polygons are divided by 10 before rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Map object in boundary format rounded to the specified precision.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bnd">read.bnd</a></code>,<code><a href="#topic+write.bnd">write.bnd</a></code></p>

<hr>
<h2 id='write.bnd'>Saving Maps in Boundary Format</h2><span id='topic+write.bnd'></span>

<h3>Description</h3>

<p>Writes the information of a map object to a file (in boundary format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.bnd(map, file, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.bnd_+3A_map">map</code></td>
<td>
<p>Map object ot be saved (should be in boundary format).</p>
</td></tr>
<tr><td><code id="write.bnd_+3A_file">file</code></td>
<td>
<p>Name of the file to write to</p>
</td></tr>
<tr><td><code id="write.bnd_+3A_replace">replace</code></td>
<td>
<p>Should an existing file be overwritten with the new version?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kneib, Felix Heinzl</p>


<h3>References</h3>

<p>BayesX Reference Manual. Available from <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+write.gra">write.gra</a></code>,<code><a href="#topic+read.gra">read.gra</a></code>,<code><a href="#topic+read.bnd">read.bnd</a></code></p>

<hr>
<h2 id='write.gra'>Saving Maps in Graph Format</h2><span id='topic+write.gra'></span>

<h3>Description</h3>

<p>Writes the information of a map object to a file (in graph format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.gra(map, file, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.gra_+3A_map">map</code></td>
<td>
<p>Map object ot be saved (should be in graph format, see <code><a href="#topic+bnd2gra">bnd2gra</a></code> for the conversion of boundary format to graph format).</p>
</td></tr>
<tr><td><code id="write.gra_+3A_file">file</code></td>
<td>
<p>Name of the file to write to</p>
</td></tr>
<tr><td><code id="write.gra_+3A_replace">replace</code></td>
<td>
<p>Should an existing file be overwritten with the new version?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kneib, Felix Heinzl</p>


<h3>References</h3>

<p>BayesX Reference Manual. Available from <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+write.bnd">write.bnd</a></code>,<code><a href="#topic+read.gra">read.gra</a></code>,<code><a href="#topic+read.bnd">read.bnd</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
