<!DOCTYPE html><html><head><title>Help for package neatStats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {neatStats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggr_neat'><p>Aggregation, descriptives</p></a></li>
<li><a href='#anova_neat'><p>Comparison of Multiple Means: ANOVA</p></a></li>
<li><a href='#ci_from_p'><p>CI from p value</p></a></li>
<li><a href='#corr_neat'><p>Correlation Statistics</p></a></li>
<li><a href='#dems_neat'><p>Demographics</p></a></li>
<li><a href='#enum'><p>Enumerate</p></a></li>
<li><a href='#excl_neat'><p>Exclusion</p></a></li>
<li><a href='#mean_ci'><p>Confidence Interval of Mean</p></a></li>
<li><a href='#mon_conv'><p>Monitor Screen Unit Conversion</p></a></li>
<li><a href='#mon_neat'><p>Monitor Object</p></a></li>
<li><a href='#neatStats-package'><p>neatStats: an R Package for Neat and Painless Statistical Reporting</p></a></li>
<li><a href='#norm_tests'><p>Normality Tests and Plots</p></a></li>
<li><a href='#path_neat'><p>Script Path</p></a></li>
<li><a href='#peek_neat'><p>Cursory Summaries and Plots per Group</p></a></li>
<li><a href='#plot_neat'><p>Plots of Means and of Dispersion</p></a></li>
<li><a href='#props_neat'><p>Difference of Two Proportions</p></a></li>
<li><a href='#rbind_loop'><p>Merge by Columns in Loops</p></a></li>
<li><a href='#read_dir'><p>Read and Merge Files from Directory</p></a></li>
<li><a href='#ro'><p>Neat rounding</p></a></li>
<li><a href='#roc_neat'><p>Difference of Two Areas Under the Curves</p></a></li>
<li><a href='#sd_ci'><p>Confidence Interval of Standard Deviation</p></a></li>
<li><a href='#se'><p>Standard Error of Mean</p></a></li>
<li><a href='#t_neat'><p>Difference of Two Means and Area Under the Curve</p></a></li>
<li><a href='#table_neat'><p>Table, descriptives</p></a></li>
<li><a href='#var_tests'><p>Variance Equality Tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Neat and Painless Statistical Reporting</td>
</tr>
<tr>
<td>Version:</td>
<td>1.13.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-07</td>
</tr>
<tr>
<td>Description:</td>
<td>User-friendly, clear and simple statistics, primarily for
  publication in psychological science. The main functions are wrappers for
  other packages, but there are various additions as well. Every relevant step
  from data aggregation to reportable printed statistics is covered for basic
  experimental designs.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gasparl/neatstats">https://github.com/gasparl/neatstats</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>viridis, fBasics, data.table, bayestestR, pROC, MBESS, car,
ez, Exact, BayesFactor, ggplot2, ggpubr, logspline, grDevices,
stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, rstudioapi</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-07 10:37:17 UTC; gaspar</td>
</tr>
<tr>
<td>Author:</td>
<td>Gáspár Lukács <a href="https://orcid.org/0000-0001-9401-4830"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Bennett Kleinberg <a href="https://orcid.org/0000-0003-1658-9086"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Johnny van Doorn <a href="https://orcid.org/0000-0003-0270-096X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gáspár Lukács &lt;lkcsgaspar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-07 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggr_neat'>Aggregation, descriptives</h2><span id='topic+aggr_neat'></span>

<h3>Description</h3>

<p>Returns aggregated values per group for given variable. Serves
as argument in the <code><a href="#topic+table_neat">table_neat</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggr_neat(
  dat,
  values,
  method = mean,
  group_by = NULL,
  filt = NULL,
  sep = "_",
  prefix = NULL,
  new_name = NULL,
  round_to = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggr_neat_+3A_dat">dat</code></td>
<td>
<p>A data frame (or a <code><a href="data.table.html#topic+data.table">data.table</a></code>, or the name of either
as string).</p>
</td></tr>
<tr><td><code id="aggr_neat_+3A_values">values</code></td>
<td>
<p>The vector of numbers from which the statistics are to be
calculated, or the name of the column in the <code>dat</code> data frame, that
contains the vector.</p>
</td></tr>
<tr><td><code id="aggr_neat_+3A_method">method</code></td>
<td>
<p>Function of string. If function, uses the <code>values</code> to
calculate the returned value for the given function (e.g. means, as per
default, using the <code>mean</code> function). Such a function may return a
vector of results as well; see Examples. If string, one of two internal
functions will be used. If the string end with <code>"+sd"</code>, e.g.,
<code>"mean+sd"</code>, the function preceding the <code>"+"</code> sign will be
calculated along with the standard deviation, displayed in a single column,
rounded as set in the <code>round_to</code> argument. (This is primarily for use
in the <code><a href="#topic+table_neat">table_neat</a></code> function for summary tables.) If the string
does not end with <code>"+sd"</code>, a ratio for the occurrences of given
elements will be calculated. Multiple elements can by given as a vector of
strings. The number of occurrences of these elements will be the numerator
(dividend), while the entire column length (i.e., number of all elements)
will be the denominator (divisor). For example, if a column contains
elements <code>"correct"</code>, <code>"incorrect"</code>, <code>"tooslow"</code>, the ratio
of <code>"correct"</code> to all other elements (i.e., including elements
<code>"correct"</code>, <code>"incorrect"</code>, and <code>"tooslow"</code>) can be written
simply as <code>method = "correct"</code>. The complementary ratio, of
<code>"incorrect"</code> and <code>"tooslow"</code>, can be written as <code>method =
"incorrect, tooslow"</code>. (Hint: filter to get ratios of subgroups, e.g. to
include only <code>"correct"</code> and <code>"incorrect"</code> elements, and
calculate their ratio; see below.)</p>
</td></tr>
<tr><td><code id="aggr_neat_+3A_group_by">group_by</code></td>
<td>
<p>String, or vector of strings: the name(s) of the column(s) in
the <code>dat</code> data frame, containing the vector(s) of factors by which the
statistics are grouped.</p>
</td></tr>
<tr><td><code id="aggr_neat_+3A_filt">filt</code></td>
<td>
<p>An expression to filter, by column values, the entire <code>dat</code>
data frame before performing the aggregation. The expression should use
column names alone; see Examples.</p>
</td></tr>
<tr><td><code id="aggr_neat_+3A_sep">sep</code></td>
<td>
<p>String (underscore <code>"_"</code> by default) for separating group
names (and prefix, if given).</p>
</td></tr>
<tr><td><code id="aggr_neat_+3A_prefix">prefix</code></td>
<td>
<p><code>NULL</code> (default) or string. String specifies a prefix for
each group type under the <code>group</code> column.</p>
</td></tr>
<tr><td><code id="aggr_neat_+3A_new_name">new_name</code></td>
<td>
<p><code>NULL</code> (default) or string. String specifies new name
for the variable to be used as column title. If <code>NULL</code>, the name will
be <code>"aggr_value"</code> (or, if used with <code><a href="#topic+table_neat">table_neat</a></code>, the
input variable name is used).</p>
</td></tr>
<tr><td><code id="aggr_neat_+3A_round_to">round_to</code></td>
<td>
<p>Number of digits after the decimal point to round to, when
using <code>"+sd"</code> in <code>method</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> with the statistics per group, with a
single column (<code>"aggr_group"</code>) indicating the grouping.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+table_neat">table_neat</a></code> to create full tables using multiple
variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mtcars") # load base R example dataset

# overall means and SDs for wt (Weight)
aggr_neat(mtcars, wt)

# rename column
aggr_neat(mtcars, wt, new_name = 'weight')

# grouped by cyl (Number of cylinders)
aggr_neat(mtcars, wt, group_by = 'cyl')

# grouped by cyl and gear
aggr_neat(mtcars, wt, group_by = c('cyl', 'gear'))

# prefix for group names
aggr_neat(mtcars, wt, group_by = 'cyl', prefix = 'cyl')

# filter to only have cyl larger than  4
aggr_neat(mtcars, wt, group_by = 'cyl', filt = cyl &gt; 4)

# filter to only have hp (Gross horsepower) smaller than  200
aggr_neat(mtcars, wt, group_by = 'cyl', filt = hp &lt; 200)

# combine two filters above, and add prefix
aggr_neat(
    mtcars,
    wt,
    group_by = 'cyl',
    filt = (hp &lt; 200 &amp; cyl &gt; 4),
    prefix = 'filtered'
)

# add SD (and round output numbers to 2)
aggr_neat(mtcars,
          wt,
          group_by = 'cyl',
          method = 'mean+sd',
          round_to = 2)

# now medians instead of means
aggr_neat(mtcars, wt, group_by = 'cyl', method = median)

# with SD
aggr_neat(mtcars,
          wt,
          group_by = 'cyl',
          method = 'median+sd',
          round_to = 1)

# overall ratio of gear 4 (Number of gears)
aggr_neat(mtcars, gear, method = '4')

# overall ratio of gear 4 and 5
aggr_neat(mtcars, gear, method = '4, 5')

# same ratio calculated per each cyl
aggr_neat(mtcars, gear, group_by = 'cyl', method = '4, 5')

# per each cyl and per vs (engine type)
aggr_neat(mtcars,
          gear,
          group_by = c('cyl', 'vs'),
          method = '4, 5')

# ratio of gear 3 per gear 3 and 5
aggr_neat(
    mtcars,
    gear,
    group_by = 'cyl',
    method = '3',
    filt = gear %in% c(3, 5)
)

</code></pre>

<hr>
<h2 id='anova_neat'>Comparison of Multiple Means: ANOVA</h2><span id='topic+anova_neat'></span>

<h3>Description</h3>

<p><code><a href="ez.html#topic+ezANOVA">Analysis of variance</a></code> (ANOVA) F-test
results with appropriate <code><a href="stats.html#topic+oneway.test">Welch</a></code>'s and
epsilon corrections where applicable (unless specified otherwise), including
partial eta squared effect sizes with confidence intervals (CIs),
generalized eta squared, and
<code><a href="bayestestR.html#topic+bayesfactor_inclusion">inclusion Bayes factor based
on matched models</a></code> (BFs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anova_neat(
  data_per_subject,
  values,
  within_ids = NULL,
  between_vars = NULL,
  ci = 0.9,
  norm_tests = "none",
  norm_plots = FALSE,
  var_tests = FALSE,
  bf_added = FALSE,
  bf_sample = 10000,
  test_title = "--- neat ANOVA ---",
  welch = TRUE,
  e_correction = NULL,
  type = 2,
  white.adjust = FALSE,
  hush = FALSE,
  plot_means = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova_neat_+3A_data_per_subject">data_per_subject</code></td>
<td>
<p>Data frame. Should contain all values
(measurements/observations) in a single row per each subject.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_values">values</code></td>
<td>
<p>Vector of strings; column name(s) in the <code>data_per_subject</code>
data frame. Each column should contain a single dependent variable: thus, to
test repeated (within-subject) measurements, each specified column should
contain one measurement.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_within_ids">within_ids</code></td>
<td>
<p><code>NULL</code> (default), string, or named list. In case of no
within-subject factors, leave as <code>NULL</code>. In case of a single within
subject factor, a single string may be given to optionally provide custom
name for the within-subject factor (note: this is a programming variable
name, so it should not contain spaces, etc.); otherwise (if left
<code>NULL</code>) this one within-subject factor will always just be named
<code>"within_factor"</code>. In case of multiple within-subject factors, each
factor must be specified as a named list element, each with a vector of
strings that distinguish the levels within that factors. The column names
given as <code>values</code> should always contain one (and only one) of these
strings within each within-subject factor, and thus they will be assigned
the appropriate level. For example, <code>values = 'rt_s1_neg, rt_s1_pos,
rt_s2_neg, rt_s2_pos'</code> could have <code>within_ids = list( session = c('s1',
's2'), valence =  c('pos', 'neg')</code>. (Note: the strings for distinguishing
must be unambiguous. E.g., for values <code>apple_a</code> and <code>apple_b</code>, do
not set levels <code>c('a','b')</code>, because <code>'a'</code> is also found in
<code>apple_b</code>. In this case, you could choose levels <code>c('_a','_b')</code> to
make sure the values are correctly distinguished.) See also Examples.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_between_vars">between_vars</code></td>
<td>
<p><code>NULL</code> (default; in case of no between-subject
factors) or vector of strings; column name(s) in the <code>data_per_subject</code>
data frame. Each column should contain a single between-subject independent
variable (representing between-subject factors).</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_ci">ci</code></td>
<td>
<p>Numeric; confidence level for returned CIs. (Default: <code>.9</code>;
Lakens, 2014; Steiger, 2004.)</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_norm_tests">norm_tests</code></td>
<td>
<p>Normality tests for the pooled ANOVA residuals
(<code>"none"</code> by default, giving no tests). Any or all of the following
character input is accepted (as a single string or a character vector;
case-insensitive): <code>"W"</code> (Shapiro-Wilk), <code>"K2"</code> (D'Agostino),
<code>"A2"</code> (Anderson-Darling), <code>"JB"</code> (Jarque-Bera); see
<code><a href="#topic+norm_tests">norm_tests</a></code>. The option <code>"all"</code> (or <code>TRUE</code>) selects
all four previous tests at the same time.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_norm_plots">norm_plots</code></td>
<td>
<p>If <code>TRUE</code>, displays density, histogram, and Q-Q plots
(and scatter plots for paired tests) for the pooled residuals.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_var_tests">var_tests</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code> (and there
are any between-subject factors), runs variance equality tests via
<code><a href="#topic+var_tests">var_tests</a></code> for all combinations of the between-subject factors
within each level of within-subject factor combinations; see Details.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_bf_added">bf_added</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), inclusion Bayes factor is
calculated and displayed. (Note: with multiple factors and/or larger
dataset, the calculation can take considerable time.)</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_bf_sample">bf_sample</code></td>
<td>
<p>Number of samples used to estimate Bayes factor (<code>10000</code>
by default).</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_test_title">test_title</code></td>
<td>
<p>String, <code>"--- neat ANOVA ---"</code> by default. Simply displayed
in printing preceding the statistics.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_welch">welch</code></td>
<td>
<p>If <code>TRUE</code> (default), calculates Welch's ANOVA via
<code><a href="stats.html#topic+oneway.test">stats::oneway.test</a></code> in case of a single
factor (one-way) between-subject design. If <code>FALSE</code>, calculates via
<code><a href="ez.html#topic+ezANOVA">ez::ezANOVA</a></code> in such cases too (i.e., same as in
case of every other design).</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_e_correction">e_correction</code></td>
<td>
<p><code>NULL</code> (default) or one of the following strings:
<code>'gg'</code>, <code>'hf'</code>, or <code>'none'</code>. If set to <code>'gg'</code>,
Greenhouse-Geisser correction is applied in case of repeated measures
(regardless of violation of sphericity). If set to <code>'hf'</code>, Huynh-Feldt
correction is applied. If set to <code>'none'</code>, no correction is applied. If
<code>NULL</code>, Greenhouse-Geisser correction is applied when Mauchly's
sphericity test is significant and the Greenhouse-Geisser epsilon is not
larger than <code>.75</code>, while Huynh-Feldt correction is applied when
Mauchly's sphericity test is significant and the Greenhouse-Geisser epsilon
is larger than <code>.75</code> (see Girden, 1992).</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_type">type</code></td>
<td>
<p>Sum of squares type specified as a number: <code>1</code>, <code>2</code>, or
<code>3</code>. Set to <code>2</code> by default (which is generally recommended, see
e.g. Navarro, 2019, Chapter 16).</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_white.adjust">white.adjust</code></td>
<td>
<p>If not <code>FALSE</code> (default) uses a
heteroscedasticity-corrected coefficient covariance matrix; the various
values of the argument specify different corrections (<code>"hc0"</code>,
<code>"hc1"</code>, <code>"hc2"</code>, <code>"hc3"</code>, or <code>"hc4"</code>). See the
documentation for <code><a href="car.html#topic+hccm">car::hccm</a></code> for details. If set to
<code>TRUE</code> then the <code>"hc3"</code> correction is selected.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing any details to console.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_plot_means">plot_means</code></td>
<td>
<p>Logical (<code>FALSE</code> by default). If <code>TRUE</code>, creates
plots of means by factor, by passing data and factor information to
<code><a href="#topic+plot_neat">plot_neat</a></code>.</p>
</td></tr>
<tr><td><code id="anova_neat_+3A_...">...</code></td>
<td>
<p>Any additional arguments will be passed on to
<code><a href="#topic+plot_neat">plot_neat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayes factor (BF) is always calculated with the default <code>rscaleFixed</code>
of <code>0.5</code> (<code>"medium"</code>) and <code>rscaleRandom</code> of <code>1</code>
(<code>"nuisance"</code>). BF supporting null hypothesis is denoted as BF01, while
that supporting alternative hypothesis is denoted as BF10. When the BF is
smaller than 1 (i.e., supports null hypothesis), the reciprocal is calculated
(hence, BF10 = BF, but BF01 = 1/BF). When the BF is greater than or equal to
10000, scientific (exponential) form is reported for readability. (The
original full BF number is available in the returned named vector as
<code>bf</code>.)
</p>
<p>Mauchly's sphericity test is returned for repeated measures with more than two
levels. If Mauchly's test is significant, epsilon correction may be applied
(see the <code>e_correction</code> parameter).
</p>
<p>Variance equality tests (if <code>var_tests</code> is <code>TRUE</code>): Brown-Forsythe
and Fligner-Killeen tests are performed for each within-subject factor level
(or, in case of several factors, each combination) via
<code><a href="#topic+var_tests">var_tests</a></code>. Note that variance testing is generally not
recommended (see e.g., Zimmerman, 2004). In case of a one-way between-subject
ANOVA, Welch-corrected results are reported by default, which corrects for
unequal variances. In case of multiple between-subject factors, the
<code>white.adjust</code> parameter can be set to <code>TRUE</code> (or <code>"hc3"</code>) to
apply <code>"hc3"</code> correction for unequal variances. In case of a mixed ANOVA
(both between-subject and within-subject factors), if the tests are
significant and the data is unbalanced (unequal group sample sizes), you
should either consider the results respectively or choose a different test.
</p>
<p>In case of multiple values (column names) that match identical levels for all
factors, the given columns will be merged into a single column taking the mean
value of all these columns. (This is to simplify &quot;dropping&quot; a within-subject
factor and retesting the remaining factors.) Explicit warning messages are
shown in each such case.
</p>


<h3>Value</h3>

<p>Prints ANOVA statistics (including, for each model, F-test with
partial eta squared and its CI, generalized eta squared, and BF, as
specified via the corresponding parameters) in APA style. Furthermore, when
assigned, returns all calculated information details for each effect (as
<code>stat_list</code>), normality and variance tests (if any), etc.
</p>


<h3>Note</h3>

<p>The F-tests are calculated via <code><a href="ez.html#topic+ezANOVA">ez::ezANOVA</a></code>,
including Mauchly's sphericity test. (But Welch's ANOVA is
calculated in case of one-way between-subject designs via
<code><a href="stats.html#topic+oneway.test">stats::oneway.test</a></code>, unless the <code>welch</code>
parameter is set to <code>FALSE</code>.)
</p>
<p>Confidence intervals are calculated, using the F value, via
<code><a href="MBESS.html#topic+conf.limits.ncf">MBESS::conf.limits.ncf</a></code>, converting
noncentrality parameters to partial eta squared as <code>ncp/(ncp+
 df_nom+df_denom+1)</code> (Smithson, 2003).
</p>
<p>Generalized eta squared is to facilitate potential subsequent
meta-analytical comparisons (see Lakens, 2013).
</p>
<p>The inclusion Bayes factor based on matched models is calculated via
<code><a href="bayestestR.html#topic+bayesfactor_inclusion">bayestestR::bayesfactor_inclusion</a></code>,
(with <code>match_models = TRUE</code>, and using an
<code><a href="BayesFactor.html#topic+anovaBF">BayesFactor::anovaBF</a></code> object for
<code>models</code> input).
</p>


<h3>References</h3>

<p>Girden, E. (1992). ANOVA: Repeated measures. Newbury Park, CA: Sage.
</p>
<p>Kelley, K. (2007). Methods for the behavioral, educational, and social
sciences: An R package. Behavior Research Methods, 39(4), 979-984.
<a href="https://doi.org/10.3758/BF03192993">doi:10.3758/BF03192993</a>
</p>
<p>Lakens, D. (2013). Calculating and reporting effect sizes to facilitate
cumulative science: A practical primer for t-tests and ANOVAs. Frontiers in
Psychology, 4. https://doi.org/10.3389/fpsyg.2013.00863
</p>
<p>Lakens, D. (2014). Calculating confidence intervals for Cohen's d and
eta-squared using SPSS, R, and Stata [Blog post]. Retrieved from
<a href="http://daniellakens.blogspot.com/2014/06/calculating-confidence-intervals-for.html">http://daniellakens.blogspot.com/2014/06/calculating-confidence-intervals-for.html</a>
</p>
<p>Mathot. S. (2017). Bayes like a Baws: Interpreting Bayesian Repeated Measures
in JASP [Blog post]. Retrieved from
<a href="https://www.cogsci.nl/blog/interpreting-bayesian-repeated-measures-in-jasp">https://www.cogsci.nl/blog/interpreting-bayesian-repeated-measures-in-jasp</a>
</p>
<p>McDonald, J. H. 2015. Handbook of Biological Statistics (3rd ed.). Sparky
House Publishing, Baltimore, Maryland. Retrieved from
<a href="http://www.biostathandbook.com">http://www.biostathandbook.com</a>
</p>
<p>Moder, K. (2010). Alternatives to F-test in one way ANOVA in case of
heterogeneity of variances (a simulation study). Psychological Test and
Assessment Modeling, 52(4), 343-353.
</p>
<p>Navarro, D. (2019). Learning Statistics with R: A Tutorial for Psychology
Students and Other Beginners (Version 0.6.1). Retrieved from
<a href="https://learningstatisticswithr.com/">https://learningstatisticswithr.com/</a>
</p>
<p>Smithson, M. (2003). Confidence intervals. Thousand Oaks, Calif: Sage
Publications.
</p>
<p>Steiger, J. H. (2004). Beyond the F test: effect size confidence intervals and
tests of close fit in the analysis of variance and contrast analysis.
Psychological Methods, 9(2), 164-182.
<a href="https://doi.org/10.1037/1082-989X.9.2.164">doi:10.1037/1082-989X.9.2.164</a>
</p>
<p>Zimmerman, D. W. (2004). A note on preliminary tests of equality of variances.
British Journal of Mathematical and Statistical Psychology, 57(1), 173–181.
https://doi.org/10.1348/000711004849222
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_neat">plot_neat</a></code>, <code><a href="#topic+t_neat">t_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign random data in a data frame for illustration
# (note that the 'subject' is only for illustration; since each row contains the
# data of a single subject, no additional subject id is needed)
dat_1 = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    grouping1 = c(1, 1, 1, 1, 2, 2, 2, 2, 2, 2),
    grouping2 = c(1, 2, 1, 2, 2, 1, 1, 1, 2, 1),
    value_1_a = c(36.2, 45.2, 41, 24.6, 30.5, 28.2, 40.9, 45.1, 31, 16.9),
    value_2_a = c(-14.1, 58.5, -25.5, 42.2, -13, 4.4, 55.5, -28.5, 25.6, -37.1),
    value_1_b = c(83, 71, 111, 70, 92, 75, 110, 111, 110, 85),
    value_2_b = c(8.024, -14.162, 3.1, -2.1, -1.5, 0.91, 11.53, 18.37, 0.3, -0.59),
    value_1_c = c(27.4,-17.6,-32.7, 0.4, 37.2, 1.7, 18.2, 8.9, 1.9, 0.4),
    value_2_c = c(7.7, -0.8, 2.2, 14.1, 22.1, -47.7, -4.8, 8.6, 6.2, 18.2)
)
head(dat_1) # see what we have

# For example, numbers '1' and '2' in the variable names of the values can
# denote sessions in an experiment, such as '_1' for first session, and '_2 for
# second session'. The letters '_a', '_b', '_c' could denote three different
# types of techniques used within each session, to be compared to each other.
# See further below for a more verbose but more meaningful example data.

# get the between-subject effect of 'grouping1'
anova_neat(dat_1, values = 'value_1_a', between_vars = 'grouping1')

# main effects of 'grouping1', 'grouping2', and their interactions
anova_neat(dat_1,
           values = 'value_1_a',
           between_vars = c('grouping1', 'grouping2'))

# repeated measures:
# get the within-subject effect for 'value_1_a' vs. 'value_1_b'
anova_neat(dat_1, values = c('value_1_a', 'value_1_b'))

# same, but give the factor a custom variable name, and omit BF for speed
anova_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b'),
    within_ids = 'a_vs_b',
    bf_added = FALSE
)
# or
anova_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b'),
    within_ids = 'letters',
    bf_added = FALSE
)

# within-subject effect for 'value_1_a' vs. 'value_1_b' vs. 'value_1_c'
anova_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b', 'value_1_c'),
    bf_added = FALSE
)

# within-subject main effect for 'value_1_a' vs. 'value_1_b' vs. 'value_1_c',
# between-subject main effect 'grouping1', and the interaction of these two main
# effects
anova_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b', 'value_1_c'),
    between_vars = 'grouping1',
    bf_added = FALSE
)

# within-subject 'number' main effect for variables with number '1' vs. number
# '2' ('value_1_a' and 'value_1_b' vs. 'value_2_a' and 'value_2_b'), 'letter'
# main effect for variables with final letterr 'a' vs. final letter 'b'
# ('value_1_a' and 'value_2_a' vs. 'value_1_b' and 'value_2_b'), and the
# 'letter' x 'number' interaction
anova_neat(
    dat_1,
    values = c('value_1_a', 'value_2_a', 'value_1_b', 'value_2_b'),
    within_ids = list(
        letters = c('_a', '_b'),
        numbers =  c('_1', '_2')
    ),
    bf_added = FALSE
)

# same as above, but now including between-subject main effect 'grouping2' and
# its interactions
anova_neat(
    dat_1,
    values = c('value_1_a', 'value_2_a', 'value_1_b', 'value_2_b'),
    within_ids = list(
        letters = c('_a', '_b'),
        numbers =  c('_1', '_2')
    ),
    between_vars = 'grouping2',
    bf_added = FALSE
)

# same as above, but now creating a plot of means
# y_title passed add an example title (label) for the Y axis
anova_neat(
    dat_1,
    values = c('value_1_a', 'value_2_a', 'value_1_b', 'value_2_b'),
    within_ids = list(
        letters = c('_a', '_b'),
        numbers =  c('_1', '_2')
    ),
    between_vars = 'grouping2',
    bf_added = FALSE,
    plot_means = TRUE,
    y_title = 'Example Y Title'
)

# same as above, but collapsing means over the removed "numbers" factor
anova_neat(
    dat_1,
    values = c('value_1_a', 'value_2_a', 'value_1_b', 'value_2_b'),
    within_ids = list(
        letters = c('_a', '_b')
    ),
    between_vars = 'grouping2',
    bf_added = FALSE,
    plot_means = TRUE,
    y_title = 'Example Y Title'
)

# In real datasets, these could of course be more meaningful. For example, let's
# say participants rated the attractiveness of pictures with low or high levels
# of frightening and low or high levels of disgusting qualities. So there are
# four types of ratings:
# 'low disgusting, low frightening' pictures
# 'low disgusting, high frightening' pictures
# 'high disgusting, low frightening' pictures
# 'high disgusting, high frightening' pictures

# this could be meaningfully assigned e.g. as below
pic_ratings = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    rating_fright_low_disgust_low = c(36.2,45.2,41,24.6,30.5,28.2,40.9,45.1,31,16.9),
    rating_fright_high_disgust_low = c(-14.1,58.5,-25.5,42.2,-13,4.4,55.5,-28.5,25.6,-37.1),
    rating_fright_low_disgust_high = c(83,71,111,70,92,75,110,111,110,85),
    rating_fright_high_disgust_high = c(8.024,-14.162,3.1,-2.1,-1.5,0.91,11.53,18.37,0.3,-0.59)
)
head(pic_ratings) # see what we have

# the same logic applies as for the examples above, but now the
# within-subject differences can be more meaningfully specified, e.g.
# 'disgust_low' vs. 'disgust_high' for levels of disgustingness, while
# 'fright_low' vs. 'fright_high' for levels of frighteningness
anova_neat(
    pic_ratings,
    values = c(
        'rating_fright_low_disgust_low',
        'rating_fright_high_disgust_low',
        'rating_fright_low_disgust_high',
        'rating_fright_high_disgust_high'
    ),
    within_ids = list(
        disgustingness = c('disgust_low', 'disgust_high'),
        frighteningness =  c('fright_low', 'fright_high')
    ),
    bf_added = FALSE
)

# the results are the same as for the analogous test for the 'dat_1' data, only
# with different names

# now let's say the ratings were done in two separate groups
pic_ratings = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    group_id = c(1, 2, 1, 2, 2, 1, 1, 1, 2, 1),
    rating_fright_low_disgust_low = c(36.2,45.2,41,24.6,30.5,28.2,40.9,45.1,31,16.9),
    rating_fright_high_disgust_low = c(-14.1,58.5,-25.5,42.2,-13,4.4,55.5,-28.5,25.6,-37.1),
    rating_fright_low_disgust_high = c(83,71,111,70,92,75,110,111,110,85),
    rating_fright_high_disgust_high = c(8.024,-14.162,3.1,-2.1,-1.5,0.91,11.53,18.37,0.3,-0.59)
)

# now test the effect and interactions of 'group_id'
anova_neat(
    pic_ratings,
    values = c(
        'rating_fright_low_disgust_low',
        'rating_fright_high_disgust_low',
        'rating_fright_low_disgust_high',
        'rating_fright_high_disgust_high'
    ),
    within_ids = list(
        disgustingness = c('disgust_low', 'disgust_high'),
        frighteningness =  c('fright_low', 'fright_high')
    ),
    between_vars = 'group_id',
    bf_added = FALSE
)

# again, same results as with 'dat_1' (using 'grouping2' as group_id)

</code></pre>

<hr>
<h2 id='ci_from_p'>CI from p value</h2><span id='topic+ci_from_p'></span>

<h3>Description</h3>

<p>Calculates approximate confidence interval (CI) for any given
difference, based on the difference value and p value, according to Altman &amp;
Bland (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_from_p(diff, p_value, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_from_p_+3A_diff">diff</code></td>
<td>
<p>Difference (number) around which the CI is to be calculated.</p>
</td></tr>
<tr><td><code id="ci_from_p_+3A_p_value">p_value</code></td>
<td>
<p>The p value for CI calculation.</p>
</td></tr>
<tr><td><code id="ci_from_p_+3A_ci">ci</code></td>
<td>
<p>Numeric; confidence level for the returned CIs (<code>.95</code> per
default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CI limits  as named numeric vector with two elements.
</p>


<h3>Note</h3>

<p>Check the Altman &amp; Bland (2011) paper for details! (The calculation for
proportions is not implemented here.)
</p>


<h3>References</h3>

<p>Altman, D. G., &amp; Bland, J. M. (2011). How to obtain the confidence interval
from a P value. Bmj, 343(d2090). <a href="https://doi.org/10.1136/bmj.d2090">doi:10.1136/bmj.d2090</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# calculate proportion difference test
proptest_stat = prop.test(x = c(49, 40), n = c(50, 50))

# calculate proportion difference
my_diff = 49/50-40/50

# calculate approximate CI
ci_from_p(my_diff, proptest_stat$p.value)

# returned CI should be very similar to the actual CI
proptest_stat$conf.int


# Example 2
# generate random data
v1 = stats::rnorm(190, 40, 60)
v2 = stats::rnorm(170, 50, 45)

# calculate t-test
ttest_stat = stats::t.test(v1, v2)

# calculate mean difference
my_diff = mean(v1) - mean(v2)

# calculate approximate CI
ci_from_p(my_diff, ttest_stat$p.value)

# returned CI should be similar to the actual CI
ttest_stat$conf.int

</code></pre>

<hr>
<h2 id='corr_neat'>Correlation Statistics</h2><span id='topic+corr_neat'></span>

<h3>Description</h3>

<p><code><a href="stats.html#topic+cor.test">Pearson correlation</a></code> results
including confidence interval (CI) and correlation
<code><a href="BayesFactor.html#topic+correlationBF">Bayes factor</a></code> (BF). For
non-parametric version, Spearman's <code><a href="stats.html#topic+cor.test">rank
correlation</a></code> results along with corresponding rank-based BFs (as per van
Doorn et al., 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_neat(
  var1,
  var2,
  nonparametric = FALSE,
  ci = 0.95,
  bf_added = FALSE,
  direction = NULL,
  round_r = 3,
  for_table = FALSE,
  sb_correction = FALSE,
  hush = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_neat_+3A_var1">var1</code></td>
<td>
<p>Numeric vector; numbers of the first variable.</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_var2">var2</code></td>
<td>
<p>Numeric vector; numbers of the second variable.</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_nonparametric">nonparametric</code></td>
<td>
<p>Logical (<code>FALSE</code> by default). If <code>TRUE</code>, uses
nonparametric tests (Spearman's rank correlation, including BFs; see
Details).</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_ci">ci</code></td>
<td>
<p>Numeric; confidence level for the returned CI, as implemented in
<code><a href="stats.html#topic+cor.test">cor.test</a></code>.</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_bf_added">bf_added</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), Bayes factor is calculated
and displayed.</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_direction">direction</code></td>
<td>
<p><code>NULL</code> or string; optionally specifies one-sided test:
either &quot;negative&quot; (negative correlation expected) or &quot;positive&quot; (positive
correlation expected). (Short forms also work, e.g. &quot;p&quot;, &quot;pos&quot;, &quot;neg&quot;, etc.)
If <code>NULL</code> (default), the test is two-sided.</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_round_r">round_r</code></td>
<td>
<p>Number <code><a href="#topic+ro">to round</a></code> to the correlation and its
CI.</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_for_table">for_table</code></td>
<td>
<p>Logical. If <code>TRUE</code>, omits the confidence level display
from the printed text.</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_sb_correction">sb_correction</code></td>
<td>
<p>Logical. If <code>TRUE</code>, applies Spearman-Brown
correction (<code>2 * r / (1+r)</code>) to the correlation (including CI).</p>
</td></tr>
<tr><td><code id="corr_neat_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing any details to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayes factor (BF) is calculated with the default r-scale of
<code>1/3</code> for parametric test, and with the default r-scale of <code>1</code> for
nonparametric test. BF supporting null hypothesis is denoted as BF01, while
that supporting alternative hypothesis is denoted as BF10. When the BF is
smaller than 1 (i.e., supports null hypothesis), the reciprocal is
calculated (hence, BF10 = BF, but BF01 = 1/BF). When the BF is greater than
or equal to 10000, scientific (exponential) form is reported for
readability. (The original full BF number is available in the returned named
vector as <code>bf</code>.)#'
</p>


<h3>Value</h3>

<p>Prints correlation statistics (including CI and BF) in APA style.
Furthermore, when assigned, returns a named vector with the following
elements: <code>r</code> (Pearson correlation), <code>p</code> (p value), <code>bf</code>
(Bayes factor).
</p>


<h3>Note</h3>

<p>The correlation and CI is calculated via
<code><a href="stats.html#topic+cor.test">stats::cor.test</a></code>.
</p>
<p>The parametric Bayes factor is calculated via
<code><a href="BayesFactor.html#topic+correlationBF">BayesFactor::correlationBF</a></code>. The
nonparametric (rank-based) Bayes factor is a contribution by Johnny van Doorn;
the original source code is available via <a href="https://osf.io/gny35/">https://osf.io/gny35/</a>.
</p>


<h3>References</h3>

<p>Brown, W. (1910). Some experimental results in the correlation of mental
abilities. British Journal of Psychology, 1904-1920, 3(3), 296-322.
<a href="https://doi.org/10.1111/j.2044-8295.1910.tb00207.x">doi:10.1111/j.2044-8295.1910.tb00207.x</a>
</p>
<p>Eisinga, R., Grotenhuis, M. te, &amp; Pelzer, B. (2013). The reliability of a
two-item scale: Pearson, Cronbach, or Spearman-Brown? International Journal of
Public Health, 58(4), 637-642. <a href="https://doi.org/10.1007/s00038-012-0416-3">doi:10.1007/s00038-012-0416-3</a>
</p>
<p>Spearman, C. (1910). Correlation calculated from faulty data. British Journal
of Psychology, 1904-1920, 3(3), 271-295.
<a href="https://doi.org/10.1111/j.2044-8295.1910.tb00206.x">doi:10.1111/j.2044-8295.1910.tb00206.x</a>
</p>
<p>van Doorn, J., Ly, A., Marsman, M., &amp; Wagenmakers, E.-J. (2020). Bayesian
rank-based hypothesis testing for the rank sum test, the signed rank test, and
Spearman’s rho. Journal of Applied Statistics, 1–23.
<a href="https://doi.org/10.1080/02664763.2019.1709053">doi:10.1080/02664763.2019.1709053</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+t_neat">t_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign two variables
v1 = c(11, 15, 19, 43, 53, -4, 34, 8, 33, -1, 54 )
v2 = c(4, -2, 23, 13, 32, 16, 3, 29, 37, -4, 65 )

corr_neat(v1, v2) # prints statistics

# one-sided, and omitting the "95% CI" part
corr_neat(v1, v2, direction = 'pos', for_table = TRUE)

# print statistics and assign main results
results = corr_neat(v1, v2, direction = 'pos')

results['p'] # get precise p value
</code></pre>

<hr>
<h2 id='dems_neat'>Demographics</h2><span id='topic+dems_neat'></span>

<h3>Description</h3>

<p>Prints participant count, age mean and SD, and gender ratio, from
given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dems_neat(
  data_per_subject,
  group_by = NULL,
  gender_col = NULL,
  age_col = NULL,
  male = "male",
  female = "female",
  percent = FALSE,
  round_perc = 0,
  show_fem = NULL,
  age_range = FALSE,
  age_min = NULL,
  age_max = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dems_neat_+3A_data_per_subject">data_per_subject</code></td>
<td>
<p>Data frame from which demographics are to be
calculated. Should contain columns named as &quot;<code>age</code>&quot; and as
&quot;<code>gender</code>&quot; (or, alternatively, &quot;<code>sex</code>&quot;). Alternatively, these
columns can be specified via the <code>gender_col</code> and <code>age_col</code>
parameters. The <code>age</code> column must contain only numbers or <code>NA</code>,
while <code>gender</code> column must contain only <code>1</code> (= male) or <code>2</code>
(= female), either as numbers or as strings, or <code>NA</code>. Alternatively,
different gender coding can be set via the parameters <code>male</code> and
<code>female</code> (but <code>1</code>/<code>2</code> will be checked for first in any case).</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_group_by">group_by</code></td>
<td>
<p>Optionally the name(s) of column(s) from the data frame
provided as <code>data_per_subject</code> to group by.</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_gender_col">gender_col</code></td>
<td>
<p>Optionally the name of column from the data frame that
contains the gender (sex) information.</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_age_col">age_col</code></td>
<td>
<p>Optionally the name of column from the data frame that contains
the age information.</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_male">male</code></td>
<td>
<p>Alternative code for male: by default, it is the string
<code>"male"</code>. Whatever string is given, its abbreviations will also be
accepted (e.g. <code>"m"</code>). (Lettercases do not matter, e.g. <code>Male</code> or
<code>MALE</code> are both evaluated same as <code>male</code>.)</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_female">female</code></td>
<td>
<p>Alternative code for female: by default, it is the string
<code>"female"</code>. Whatever string is given, its abbreviations will also be
accepted (e.g. <code>"fem"</code>). (Lettercases do not matter.)</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_percent">percent</code></td>
<td>
<p>Logical. If <code>TRUE</code>, gender ratios (and the &quot;unknown&quot;
ratios based on <code>NA</code> values) are presented as percentage. If
<code>FALSE</code>, they are presented as counts (i.e., numbers of subjects).</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_round_perc">round_perc</code></td>
<td>
<p>Number <code><a href="#topic+ro">to round</a></code> to, when using
percentages.</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_show_fem">show_fem</code></td>
<td>
<p>Logical or <code>NULL</code>. If <code>TRUE</code>, the numbers of both
male and female are displayed. If <code>FALSE</code>, only the number of males is
displayed. If <code>NULL</code> (default), only the number of males is displayed
when there are no unknown cases, but both numbers are displayed when there
are any unknown cases.</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_age_range">age_range</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code>, also
displays age range per group (minimum and maximum ages).</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_age_min">age_min</code></td>
<td>
<p>If numeric given, removes all ages below (exclusive!) the given
number before any age calculation.#'</p>
</td></tr>
<tr><td><code id="dems_neat_+3A_age_max">age_max</code></td>
<td>
<p>If numeric given, removes all ages above (exclusive!) the given
number before any age calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>gender_col</code> and/or <code>age_col</code> are not specified, the
function will first look for columns named precisely &quot;<code>age</code>&quot; and as
&quot;<code>gender</code>&quot;. If either is not found, the function looks for the same
names but with any lettercase (e.g. &quot;<code>AGE</code>&quot; or &quot;<code>Gender</code>&quot;). If
still no &quot;<code>gender</code>&quot; column is found, the function looks for
&quot;<code>sex</code>&quot; column in the same manner. If no column is found for either,
all related values will be counted as &quot;unknown&quot; (<code>NA</code>).
</p>
<p>If <code>NA</code> values are found in either the <code>age</code> or <code>gender</code>
column, the ratio (or count) of unknown cases will be displayed everywhere.
Otherwise it will simply not be displayed anywhere.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># below is an illustrative example dataset
# (the "subject" and "measure_x" columns are not used in the function)
dat = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    conditions = c('x', 'y', 'x', 'y', 'y', 'x', 'x', 'x', 'y', 'x'),
    gender = c(2, 2, 1, 2, 1, 2, 2, 2, 1, 1),
    age = c(6, 7, 8.5, 6, 5, 16.5, 17, 16, 45.8, 77),
    measure_x = c(83, 71, 111, 70, 92, 75, 110, 111, 110, 85),
    stringsAsFactors = TRUE
)

# print demographics (age and gender) per "conditions":
dems_neat(dat, group_by = 'conditions')

# replace unlikely ages with NAs
dems_neat(dat,
          group_by = 'conditions',
          age_min = 8,
          age_max = 50)

# remove only high values, and display age ranges
dems_neat(dat,
          group_by = 'conditions',
          age_max = 45,
          age_range = TRUE)

# another dataset, with some missing values
dat = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    conditions = c('x', 'y', 'x', 'y', 'y', 'x', 'x', 'x', 'y', 'x'),
    gender = c(2, 2, NA, NA, 1, 1, 1, 2, NA, NA),
    age = c(6, 7, 8.5, 6, 5, 16, NA, 16, 45, 77),
    measure_x = c(83, 71, 111, 70, 92, 75, 110, 111, 110, 85),
    stringsAsFactors = TRUE
)
# again print demographics per "conditions":
dems_neat(dat, group_by = 'conditions')

# another dataset, with no "age"/"gender" columns
dat = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    conditions = c('x', 'y', 'x', 'y', 'y', 'x', 'x', 'x', 'y', 'x'),
    geschlecht = c(2, 2, NA, NA, 1, 1, 1, 2, NA, NA),
    alter = c(6, 7, 8.5, 6, 5, 16, NA, 16, 45, 77),
    measure_y = c(83, 71, 111, 70, 92, 75, 110, 111, 110, 85),
    stringsAsFactors = TRUE
)

# the following will return "unknowns"
dems_neat(dat, group_by = 'conditions')

# gender column specified
dems_neat(dat, group_by = 'conditions', gender_col = 'geschlecht')

# both columns specified
dems_neat(dat,
          group_by = 'conditions',
          age_col = 'alter',
          gender_col = 'geschlecht')

</code></pre>

<hr>
<h2 id='enum'>Enumerate</h2><span id='topic+enum'></span>

<h3>Description</h3>

<p>Aids enumeration and merging (via <code><a href="#topic+rbind_loop">rbind_loop</a></code>) in
loops: adds numbers to a vector input, and indicates loop start for
<code><a href="#topic+rbind_loop">rbind_loop</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enum(items, hush = FALSE, enumerate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enum_+3A_items">items</code></td>
<td>
<p>The items to be enumerated in the loop.</p>
</td></tr>
<tr><td><code id="enum_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), prints &quot;Loop started.&quot; when
executed.</p>
</td></tr>
<tr><td><code id="enum_+3A_enumerate">enumerate</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), adds numbering to the
input vector (in item pairs, see Examples). If <code>FALSE</code>, returns the
original input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with numbers added (if so set).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbind_loop">rbind_loop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my_vector = c('aa', 'bb', 'cxyz', 'last')

for (item in enum(my_vector)) {
    print(item)
}

# just to show what enum() returns
enum(my_vector)

</code></pre>

<hr>
<h2 id='excl_neat'>Exclusion</h2><span id='topic+excl_neat'></span>

<h3>Description</h3>

<p>Filters dataset by rows (normally: subjects, observations) and
prints the numbers of excluded rows and remaining rows. Returns the
filtered dataset and (optionally) also the excluded rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excl_neat(
  dat,
  filt,
  excluded = FALSE,
  group_by = NULL,
  sort_by = "exclusion",
  hush = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excl_neat_+3A_dat">dat</code></td>
<td>
<p>Data frame to be filtered.</p>
</td></tr>
<tr><td><code id="excl_neat_+3A_filt">filt</code></td>
<td>
<p>An expression to use for filtering, by column values, the
<code>dat</code> data frame. (Only the rows for which the filter expression is
<code>TRUE</code> will be kept.)</p>
</td></tr>
<tr><td><code id="excl_neat_+3A_excluded">excluded</code></td>
<td>
<p>Logical; <code>FALSE</code> by default. If <code>TRUE</code>, the
function returns not only the filtered data frame, but also a data frame
containing the excluded rows. The returned object in this case will be a
list with two elements: (1) the filtered data frame named <code>filtered</code>,
and (2) the data frame with excluded rows named <code>excluded</code> (see
Examples).</p>
</td></tr>
<tr><td><code id="excl_neat_+3A_group_by">group_by</code></td>
<td>
<p>String, or vector of strings: the name(s) of the column(s) in
the <code>dat</code> data frame, containing the vector(s) of factors by which the
printed counts are grouped.</p>
</td></tr>
<tr><td><code id="excl_neat_+3A_sort_by">sort_by</code></td>
<td>
<p>String; specifies whether the printed counts should be sorted
by exclusion (default; <code>"exclusion"</code> or its short forms, e.g.
<code>"excl"</code>), or by the factors given for <code>group_by</code> (for this, give
any other string, e.g. <code>"conditions"</code>). If <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="excl_neat_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing counts to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the rows for which the <code>filt</code> expression is
<code>TRUE</code>, or, optionally, a list with this data frame plus a data frame
with the excluded rows. At the same time, prints, by default, the count of
remaining and excluded rows.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggr_neat">aggr_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars") # load base R example dataset

# filter mtcars for mpg &gt; 20
excl_neat(mtcars, mpg &gt; 20)

# assign the same
mtcars_filtered = excl_neat(mtcars, mpg &gt; 20)
# (mtcars_filtered now contains the filtered subset)

# return and assign excluded rows too
mtcars_filtered_plus_excluded = excl_neat(mtcars, mpg &gt; 20, excluded = TRUE)

# print filtered data frame
print(mtcars_filtered_plus_excluded$filtered)

# print data frame with excluded rows
print(mtcars_filtered_plus_excluded$excluded)

# group printed count by cyl
excl_neat(mtcars, mpg &gt; 20, group_by = 'cyl')

# sort output by grouping
excl_neat(mtcars, mpg &gt; 20, group_by = 'cyl', sort_by = 'group')

# group by cyl amd carb
excl_neat(mtcars, mpg &gt; 15, group_by = c('cyl', 'carb'))

# longer filter expression
excl_neat(mtcars, mpg &gt; 15 &amp; gear == 4, group_by = 'cyl',)

</code></pre>

<hr>
<h2 id='mean_ci'>Confidence Interval of Mean</h2><span id='topic+mean_ci'></span>

<h3>Description</h3>

<p>Calculates confidence interval of a vector of numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_ci(x, distance_only = TRUE, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_ci_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="mean_ci_+3A_distance_only">distance_only</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the function returns
only the distance between the mean and either confidence interval limit.
Otherwise returns the confidence interval (i.e., both limits).</p>
</td></tr>
<tr><td><code id="mean_ci_+3A_ci">ci</code></td>
<td>
<p>Numeric; confidence level for returned CI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance of limit or confidence interval (as named vector).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+se">se</a></code>, <code><a href="#topic+plot_neat">plot_neat</a></code>, <code><a href="#topic+sd_ci">sd_ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myvec = c(11, 15, 19, 43, 53, -4, 34, 8, 33, -1, 54 )
mean_ci( myvec, FALSE )
mean_ci( myvec, FALSE, ci = .80 )
mean_ci( myvec, ci = .80 )

</code></pre>

<hr>
<h2 id='mon_conv'>Monitor Screen Unit Conversion</h2><span id='topic+mon_conv'></span>

<h3>Description</h3>

<p>Given a specific monitor object, converts specified screen units to
other specified units. The possible units to convert from and to: &quot;cm&quot;
(centimeters), &quot;pix&quot; (pixels), or &quot;deg&quot; (degrees of visual angle).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mon_conv(mon_obj, value, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mon_conv_+3A_mon_obj">mon_obj</code></td>
<td>
<p>Monitor object, as assigned with <code><a href="#topic+mon_neat">mon_neat</a></code>.</p>
</td></tr>
<tr><td><code id="mon_conv_+3A_value">value</code></td>
<td>
<p>Number; value (magnitude) of the given unit to convert from.
(Can be vector as well.)</p>
</td></tr>
<tr><td><code id="mon_conv_+3A_from">from</code></td>
<td>
<p>String; unit (&quot;cm&quot;, &quot;pix&quot;, or &quot;deg&quot;) to convert from.</p>
</td></tr>
<tr><td><code id="mon_conv_+3A_to">to</code></td>
<td>
<p>String; unit (&quot;cm&quot;, &quot;pix&quot;, or &quot;deg&quot;) to convert to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number (magnitude) in the given output (<code>to</code>) unit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mon_neat">mon_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign monitor with 50 cm distance, screen width 52 cm and 1920 pixels
my_mon = mon_neat(distance = 50, mon_width_cm = 52, mon_width_pixel = 1920)

# convert 30.4 pixels to degrees of visual angle, for the specified monitor
mon_conv(my_mon, 30.4, 'pix', 'deg') # returns 0.9434492 (degrees)

# convert 0.94 degrees of visual angle to pixels
mon_conv(my_mon, 0.94, 'deg', 'pix') # returns 30.28885 (pixels)

# convert 10 degrees of visual angle to cm
mon_conv(my_mon, 10, from = 'deg', to = 'cm')

# convert 8.748866 cm to pixels
mon_conv(my_mon, 8.748866, from = 'cm', to = 'pix')
</code></pre>

<hr>
<h2 id='mon_neat'>Monitor Object</h2><span id='topic+mon_neat'></span>

<h3>Description</h3>

<p>Assigns a monitor object, storing distance and width parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mon_neat(distance, mon_width_cm, mon_width_pixel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mon_neat_+3A_distance">distance</code></td>
<td>
<p>Viewing distance in cm (from eyes to screen).</p>
</td></tr>
<tr><td><code id="mon_neat_+3A_mon_width_cm">mon_width_cm</code></td>
<td>
<p>Monitor screen width in cm.</p>
</td></tr>
<tr><td><code id="mon_neat_+3A_mon_width_pixel">mon_width_pixel</code></td>
<td>
<p>Monitor screen width in pixels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A monitor object with the specified parameters, to be used in the
<code><a href="#topic+mon_conv">mon_conv</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mon_conv">mon_conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign monitor with 57 cm viewing distance, screen width 52 cm and 1920 pixels
my_mon = mon_neat(distance = 57, mon_width_cm = 52, mon_width_pixel = 1920)
</code></pre>

<hr>
<h2 id='neatStats-package'>neatStats: an R Package for Neat and Painless Statistical Reporting</h2><span id='topic+neatStats'></span><span id='topic+neatStats-package'></span>

<h3>Description</h3>

<p>This package focuses on user-friendly, simple functions to produce clear but
comprehensive statistics, primarily for publication in psychological science.
Most functions are wrappers for base R functions and other packages, but
there are various additions as well. Highlights are the
<code><a href="#topic+t_neat">t-test</a></code>, and the <code><a href="#topic+anova_neat">ANOVA</a></code> (both
including appropriate effect sizes with confidence intervals, and Bayes
factors, all printed in APA style), as well as the
<code><a href="#topic+table_neat">aggregate table</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gáspár Lukács <a href="mailto:lkcsgaspar@gmail.com">lkcsgaspar@gmail.com</a> (<a href="https://orcid.org/0000-0001-9401-4830">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Bennett Kleinberg <a href="mailto:bennettkleinberg@gmail.com">bennettkleinberg@gmail.com</a> (<a href="https://orcid.org/0000-0003-1658-9086">ORCID</a>) [contributor]
</p>
</li>
<li><p> Johnny van Doorn <a href="mailto:JohnnyDoorn@gmail.com">JohnnyDoorn@gmail.com</a> (<a href="https://orcid.org/0000-0003-0270-096X">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/gasparl/neatstats">https://github.com/gasparl/neatstats</a>
</p>
</li></ul>


<hr>
<h2 id='norm_tests'>Normality Tests and Plots</h2><span id='topic+norm_tests'></span>

<h3>Description</h3>

<p>Performs normality tests and creates related plots (histogram,
density, Q-Q). This is primarily a subfunction of <code><a href="#topic+t_neat">t_neat</a></code> and
<code><a href="#topic+anova_neat">anova_neat</a></code>, but here it is available separately for other
potential purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_tests(
  var1,
  var2 = NULL,
  pair = FALSE,
  norm_tests = "all",
  alpha = 0.05,
  plots = FALSE,
  aspect_ratio = 1,
  hush = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_tests_+3A_var1">var1</code></td>
<td>
<p>Numeric vector; numbers of any given variable.</p>
</td></tr>
<tr><td><code id="norm_tests_+3A_var2">var2</code></td>
<td>
<p>Optional numeric vector (or <code>NULL</code>); numbers of a second
variable.</p>
</td></tr>
<tr><td><code id="norm_tests_+3A_pair">pair</code></td>
<td>
<p>Logical; only matters if <code>var2</code> is not null. In that case, if
<code>TRUE</code> each normality test is performed for the difference values
between the two variables in case of paired samples, or, if <code>FALSE</code>,
separately for each of the two variables for unpaired samples.</p>
</td></tr>
<tr><td><code id="norm_tests_+3A_norm_tests">norm_tests</code></td>
<td>
<p>Normality tests. Any or all of the following character input
is accepted (as a single string or a character vector; case-insensitive):
<code>"W"</code> (Shapiro-Wilk), <code>"K2"</code> (D'Agostino), <code>"A2"</code>
(Anderson-Darling), <code>"JB"</code> (Jarque-Bera); see Notes. The option
<code>"all"</code> (default value) selects all four previous tests at the same
time.</p>
</td></tr>
<tr><td><code id="norm_tests_+3A_alpha">alpha</code></td>
<td>
<p>Numeric (<code>.05</code> by default), alpha level: if any p value if
below this alpha level, the function returns <code>TRUE</code>, otherwise
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="norm_tests_+3A_plots">plots</code></td>
<td>
<p>Logical: if <code>TRUE</code> adds histogram, density, and Q-Q plots.
(Note: in case of paired samples, Q-Q plots are plotted on a separate
figure. In RStudio, press on &quot;Previous plot&quot; under &quot;Plots&quot; to see these Q-Q
plots.)</p>
</td></tr>
<tr><td><code id="norm_tests_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Aspect ratio of the plots: <code>1</code> (<code>1</code>/<code>1</code>) by
default. (Set to <code>NULL</code> for dynamic aspect ratio.)</p>
</td></tr>
<tr><td><code id="norm_tests_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing any details to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints normality tests, and displays plots if so specified. Returns
<code>TRUE</code> if any of the specified tests has p value below the specified
<code>alpha</code>, otherwise returns <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>Normality tests are all calculated via
<code><a href="fBasics.html#topic+NormalityTests">fBasics::NormalityTests</a></code>, selected based
on the recommendation of Lakens (2015), quoting Yap and Sim (2011, p. 2153):
&quot;If the distribution is symmetric with low kurtosis values (i.e. symmetric
short-tailed distribution), then the D'Agostino and Shapiro-Wilkes tests have
good power. For symmetric distribution with high sample kurtosis (symmetric
long-tailed), the researcher can use the JB, Shapiro-Wilkes, or
Anderson-Darling test.&quot; See urlhttps://github.com/Lakens/perfect-t-test for
more details.
</p>


<h3>References</h3>

<p>Lakens, D. (2015). The perfect t-test (version 1.0.0). Retrieved from
https://github.com/Lakens/perfect-t-test.
<a href="https://doi.org/10.5281/zenodo.17603">doi:10.5281/zenodo.17603</a>
</p>
<p>Yap, B. W., &amp; Sim, C. H. (2011). Comparisons of various types of normality
tests. Journal of Statistical Computation and Simulation, 81(12), 2141–2155.
<a href="https://doi.org/10.1080/00949655.2010.520163">doi:10.1080/00949655.2010.520163</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+t_neat">t_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
norm_tests(stats::rnorm(100))
# should be normal...

</code></pre>

<hr>
<h2 id='path_neat'>Script Path</h2><span id='topic+path_neat'></span>

<h3>Description</h3>

<p>Gives, in RStudio, the path to the script file in which it is
executed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_neat(subdir = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_neat_+3A_subdir">subdir</code></td>
<td>
<p>String, optional. Subdirectory relative to the script's path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Script file's path as string. If <code>subdir</code> is given, it is
appended to the original path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# assuming the given script is at path "C:/script_folder/"
path_neat('') # returns "C:/script_folder/"
path_neat('my_subdir/misc/') # returns "C:/script_folder/my_subdir/misc/"

# Note: the returned string can be used as argument for base::setwd()
# e.g. setwd( path_neat() ) # sets working directory to the script's path

</code></pre>

<hr>
<h2 id='peek_neat'>Cursory Summaries and Plots per Group</h2><span id='topic+peek_neat'></span>

<h3>Description</h3>

<p>Cursory summaries and plots per group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek_neat(
  dat,
  values,
  group_by = NULL,
  filt = NULL,
  sep = ", ",
  collapse = NULL,
  f_print = FALSE,
  f_plot = NULL,
  iqr_times = 3,
  round_to = 4,
  group_n = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peek_neat_+3A_dat">dat</code></td>
<td>
<p>Data frame (or name of data frame as string).</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_values">values</code></td>
<td>
<p>String, or vector of strings: the name(s) of the column(s) in
the <code>dat</code> data frame, containing the vector(s) of values.</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_group_by">group_by</code></td>
<td>
<p>String, or vector of strings: the name(s) of the column(s) in
the <code>dat</code> data frame, containing the vector(s) of factors by which the
statistics are grouped.</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_filt">filt</code></td>
<td>
<p>An expression to filter, by column values, the entire <code>dat</code>
data frame before performing the aggregation. The expression should use
column names alone; see Examples.</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_sep">sep</code></td>
<td>
<p>String (comma by default) for separating group names.</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_collapse">collapse</code></td>
<td>
<p>Decides how to handle multiple columns of <code>values</code>. If
<code>NULL</code> (default), displays each column of values as separate groups.
Alternatively, any function can be given using which the columns are
collapsed into a single column. For example, if <code>mean</code> is given for
this parameter, a single column will be calculated based on the means of all
given values columns. (<code>NA</code> is always ignored.)</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_f_print">f_print</code></td>
<td>
<p>Printing function; see details.</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_f_plot">f_plot</code></td>
<td>
<p>Plotting function; see details. (Provide string to skip
plotting.)</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_iqr_times">iqr_times</code></td>
<td>
<p>The multiplication of IQR to calculate Tukey's fences, when
using default <code>f_print</code> function (set to <code>TRUE</code>); see Details. The
default is <code>3</code> to spot Tukey's &quot;far outliers&quot; (e.g. by comparing the
fences with min and max values). (Note that the usual fences, e.g. for box
plots, use <code>1.5</code>).</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_round_to">round_to</code></td>
<td>
<p>Number of <code><a href="#topic+ro">significant fractional
digits to round to</a></code>, when using default <code>f_print</code> function (set to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_group_n">group_n</code></td>
<td>
<p>Logical. If <code>TRUE</code>, adds sample sizes (<code>n</code>) per group
to plots when using default <code>f_plot</code> (<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="peek_neat_+3A_...">...</code></td>
<td>
<p>Any arguments to be passed to the <code>f_plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If set to <code>TRUE</code>, prints to console the following data (per group):
<code>mean</code>; 95
<code>median</code>; <code>quantile_1st</code> and <code>quantile_3rd</code> (first and third
quantiles); &quot;Tukey's fences&quot; as <code>fence_low</code> and <code>fence_upp</code>; minimum
and maximum values (<code>min</code>, <code>max</code>); number of <code>NA</code>s (<code>na</code>).
Tukey's fences are the upper and lower limits with distances of <code>X</code> times
the <code><a href="stats.html#topic+IQR">IQR</a></code> from the actual IQR, where <code>X</code> is specified
via the <code>iqr_times</code> parameter. Returns (invisibly) the same values,
unrounded, via a data frame. If alternative <code>f_print</code> is given, prints
whatever value is returned from the given function (and attempts, if possible,
to create a data frame).
</p>
<p>Creates and displays box plot(s) (per group) by default, along with overlayed
violin plot (densities proportionate to sample sizes). If alternative
<code>f_plot</code> is given, the first argument will be the values per group, and
all plots will be <code><a href="ggpubr.html#topic+ggarrange">arranged</a></code> into a single plot
and displayed together. To skip plotting, just give any character as argument
(e.g. <code>"none"</code> or just <code>""</code>).
</p>


<h3>Value</h3>

<p>Data frame with the printed values (if possible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars") # load base R example dataset

# overall info for wt (Weight)
peek_neat(mtcars, 'wt', f_print = TRUE)
#'
# now groupped by cyl (Number of cylinders)
peek_neat(mtcars, 'wt', group_by = 'cyl')

# grouped by cyl and gear
peek_neat(mtcars,
          'wt',
          group_by = c('cyl', 'gear'),
          f_print = TRUE)

# filter to only have cyl larger than  4
peek_neat(mtcars, 'wt', group_by = 'cyl', filt = cyl &gt; 4)

# without plots
peek_neat(mtcars,
          'wt',
          group_by = 'cyl',
          f_plot = "",
          f_print = TRUE)

# with histogramms etc, using plot_neat
peek_neat(mtcars, 'wt', group_by = 'cyl', f_plot = plot_neat)

# with Q-Q plots, via ggpubr
peek_neat(mtcars,
          'wt',
          group_by = 'cyl',
          f_plot = ggpubr::ggqqplot)

# skewness and kurtosis data via psych
## Not run: 
info_df = peek_neat(
    mtcars,
    'wt',
    group_by = 'cyl',
    f_print = psych::describe,
    f_plot = ""
)
info_df # contains all data returns by psych::describe

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_neat'>Plots of Means and of Dispersion</h2><span id='topic+plot_neat'></span>

<h3>Description</h3>

<p>Primarily for line and bar <code><a href="ggplot2.html#topic+ggplot">plots</a></code>
for factorial designs. Otherwise (if no <code>data_per_subject</code> is given)
descriptive dispersion plots (histogram, density, or box plots) for a
continuous variable. (For the latter, only the parameters <code>values</code>,
<code>parts</code>, <code>part_colors</code>, and <code>binwidth</code> are used, the rest are
ignored.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_neat(
  data_per_subject = NULL,
  values = NULL,
  within_ids = NULL,
  between_vars = NULL,
  factor_names = NULL,
  value_names = NULL,
  y_title = NULL,
  reverse = FALSE,
  panels = NULL,
  type = "line",
  dodge = NULL,
  bar_colors = "viridis",
  line_colors = "viridis",
  row_number = 1,
  method = mean,
  eb_method = neatStats::mean_ci,
  numerics = FALSE,
  hush = FALSE,
  parts = c("h", "d", "n", "b"),
  part_colors = NULL,
  binwidth = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_neat_+3A_data_per_subject">data_per_subject</code></td>
<td>
<p>Data frame containing all values
(measurements/observations for a factorial design) in a single row per each
subject. Otherwise, if no data frame is given (default: <code>NULL</code>),
histogram, density, or box plots will be returned for a continuous variable
(numeric vector).</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_values">values</code></td>
<td>
<p>For plots of means (factorial designs): vector of strings;
column name(s) in the <code>data_per_subject</code> data frame. Each column should
contain a single dependent variable: thus, to plot repeated (within-subject)
measurements, each specified column should contain one measurement. For
descriptive dispersion plots (if <code>data_per_subject</code> is <code>NULL</code>), a
numeric vector is expected.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_within_ids">within_ids</code></td>
<td>
<p><code>NULL</code> (default), string, or named list. In case of no
within-subject factors, leave as <code>NULL</code>. In case of a single within
subject factor, a single string may be given to optionally provide custom
name for the within-subject factor (note: this is a programming variable
name, so it should not contain spaces, etc.); otherwise (if left
<code>NULL</code>) this one within-subject factor will always just be named
<code>"within_factor"</code>. In case of multiple within-subject factors, each
factor must be specified as a named list element, each with a vector of
strings that distinguish the levels within that factors. The column names
given as <code>values</code> should always contain one (and only one) of these
strings within each within-subject factor, and thus they will be assigned
the appropriate level. For example, <code>values = 'rt_s1_neg, rt_s1_pos,
rt_s2_neg, rt_s2_pos'</code> could have <code>within_ids = list( session = c('s1',
's2'), valence =  c('pos', 'neg')</code>. (Note: the strings for distinguishing
must be unambiguous. E.g., for values <code>apple_a</code> and <code>apple_b</code>, do
not set levels <code>c('a','b')</code>, because <code>'a'</code> is also found in
<code>apple_b</code>. In this case, you could choose levels <code>c('_a','_b')</code> to
make sure the values are correctly distinguished.) See also Examples.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_between_vars">between_vars</code></td>
<td>
<p><code>NULL</code> (default; in case of no between-subject
factors) or vector of strings; column name(s) in the <code>data_per_subject</code>
data frame. Each column should contain a single between-subject independent
variable (representing between-subject factors).</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_factor_names">factor_names</code></td>
<td>
<p><code>NULL</code> or named vector. In a named vector, factor
names (either within or between) can be given a different name for display,
in a dictionary style, using original factor name as the name of a vector
element, and the element's value (as string) for the new name. For example,
to change a factor named <code>"condition"</code> to <code>"High vs. low
arousal"</code>, the vector may be given (in this case with a single element) as
<code>factor_names = c(condition = "High vs. low arousal")</code>.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_value_names">value_names</code></td>
<td>
<p><code>NULL</code> or named vector. Same as <code>factor_names</code>,
but regarding the factor values. For example, to change values
<code>"high_a"</code> and <code>"low_a"</code> to <code>"High"</code> and <code>"Low"</code> for
display, the vector may be given as <code>value_names = c(high_a = "High",
low_a = "Low")</code>.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_y_title">y_title</code></td>
<td>
<p><code>NULL</code> (default) or string. Optionally given title for the
<code>y</code> axis.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_reverse">reverse</code></td>
<td>
<p>Logical (default: <code>FALSE</code>). If <code>TRUE</code>, reverses the
default grouping of variables within the figure, or within each panel, in
case of multiple panels. (The default grouping is decided automatically by
given factor order, but always starting, when applicable, with
within-subject factors: first factor is split to adjacent bars, or
vertically aligned dots in case of line plot.)</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_panels">panels</code></td>
<td>
<p><code>NULL</code> or string. Optionally gives the factor name by which
the plot is to be split into different panels, in case of three factors. (By
default, the third given factor is used.)</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_type">type</code></td>
<td>
<p>Strong: <code>"line"</code> (default) or <code>"bar"</code>. The former gives
line plot, the latter gives bar plot.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_dodge">dodge</code></td>
<td>
<p>Number. Specifies the amount by which the adjacent bars or dots
'<code><a href="ggplot2.html#topic+position_dodge">dodge</a></code>' each other (i.e., are
displaced compared to each other). (Default is <code>0.1</code> for <code>line</code>
plots, and <code>0.9</code> for <code>bar</code> plots.)</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_bar_colors">bar_colors</code></td>
<td>
<p>Vector of strings, specifying colors from which all colors
for any number of differing adjacent bars are interpolated. (If the number
of given colors equal the number of different bars, the precise colors will
correspond to each bar.) The default <code>'viridis'</code> gives a color gradient
based on <code><a href="viridis.html#topic+viridis">viridis</a></code>. (In case of a single
factor, the first given colors is taken.)</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_line_colors">line_colors</code></td>
<td>
<p>Vector of strings, specifying colors from which all colors
for any number of differing vertically aligned dots and corresponding lines
are interpolated. The default <code>'viridis'</code> gives a color gradient based
on <code><a href="viridis.html#topic+viridis">viridis</a></code>. (In case of a single factor, the
first given colors is taken.)</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_row_number">row_number</code></td>
<td>
<p>Number. In case of multiple panels, the number of rows in
which the panels should be arranged. For example, with the default
<code>row_number = 1</code>, all panels will be displayed in one vertically
aligned row.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_method">method</code></td>
<td>
<p>A function (default: <code>mean</code>) for the calculation of the
main statistics (bar or dot heights).</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_eb_method">eb_method</code></td>
<td>
<p>A function (default: <code><a href="#topic+mean_ci">mean_ci</a></code> for 95
the calculation of the error bar size (as a single value used for both
directions of the error bar). If set to <code>NULL</code>, no error bar is
displayed.#'</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_numerics">numerics</code></td>
<td>
<p>If <code>FALSE</code> (default), returns
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object. If set to <code>TRUE</code>, returns only
the numeric aggregated data per grouping factors, as specified by
<code>method</code> and <code>eb_method</code> functions. If set to any string (e.g.
<code>"both"</code>), returns the numeric aggregated data and at the same time
<code><a href="graphics.html#topic+plot">draws</a></code> the plot.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing aggregated values.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_parts">parts</code></td>
<td>
<p>For dispersion plots only (if no <code>data_per_subject</code> is
given). A vector of characters that specify which types of overlayed types
to plot: <code>"h"</code> for histogram, <code>"d"</code> for density, <code>"n"</code>
normally distributed density (using the mean and standard deviation of the
given variable), <code>"b"</code> for boxplot. (All are included by default:
<code>parts = c("h", "d", "n", "b")</code>).</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_part_colors">part_colors</code></td>
<td>
<p>For dispersion plots only (if no <code>data_per_subject</code> is
given). A named that can specify and thereby override default colors and
alpha (transparency) of each plot type. Colors can be given by adding &quot;c&quot; to
the plot type letter, e.g. <code>c(hc = "blue")</code> for blue histogram. Alpha
can be given by adding &quot;a&quot; to the plot type letter, e.g. <code>c(ha = 0)</code>
for completely transparent histogram. Any number may be given: e.g. a dark
red transparent histogram with green boxplot would be <code>part_colors =
c(hc = "#cc0000", ha = 0.1, bc = "green")</code>.</p>
</td></tr>
<tr><td><code id="plot_neat_+3A_binwidth">binwidth</code></td>
<td>
<p>For dispersion plots only (if no <code>data_per_subject</code> is
given). Binwidth for histograms. If <code>NULL</code> (default), Freedman–Diaconis
rule is used if it produces at least 10 bins – otherwise 1bandwidth is
calculated for 10 bins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> plot object. (This object
may be further modified or adjusted via regular
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> methods.) If so set (<code>numerics</code>),
aggregated values as specified by the methods.
</p>


<h3>Note</h3>

<p>More than three factors is not allowed: it would make little sense and
it would be difficult to clearly depict in a simple figure. (However, you
can build an appropriate graph using <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
directly; but you can also just divide the data to produce several
three-factor plots, after which you can use e.g. <code>ggpubr</code>'s
<code>ggarrange</code> to easily collate the plots.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova_neat">anova_neat</a></code>, <code><a href="#topic+mean_ci">mean_ci</a></code>, <code><a href="#topic+se">se</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# assign random data in a data frame for illustration
# (note that the 'subject' is only for illustration; since each row contains the
# data of a single subject, no additional subject id is needed)
dat_1 = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14),
    grouping1 = c(1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2),
    grouping2 = c(1, 2, 1, 2, 2, 1,2, 1,2,1, 1, 1, 2, 1),
    value_1_a = c(36.2, 45.2, 41, 24.6, 30.5, 28.2, 40.9, 45.1,
                  31, 16.9, 40.1, 42.1, 41, 12.9),
    value_2_a = c(-14.1, 58.5,-25.5, 42.2,-13, 4.4, 55.5,-28.5,
                  25.6,-37.1, 55.1,-38.5, 28.6,-34.1),
    value_1_b = c(83, 71, 111, 70, 92, 75, 110, 111, 110, 85,
                  132, 121, 151, 95),
    value_2_b = c(8.024,-14.162, 3.1,-2.1,-1.5, 0.91, 11.53,
                  18.37, 0.3,-0.59, 12.53, 13.37, 2.3,-3),
    value_1_c = c(27.4, -17.6, -32.7, 0.4, 37.2, 1.7, 18.2, 8.9,
                  1.9, 0.4, 2.7, 14.2, 3.9, 4.9),
    value_2_c = c(7.7,-0.8, 2.2, 14.1, 22.1,-47.7,-4.8, 8.6,
                  6.2, 18.2,-6.8, 5.6, 7.2, 13.2)
)
head(dat_1) # see what we have

# plot for factors 'grouping1', 'grouping2'
plot_neat(
    data_per_subject = dat_1,
    values = 'value_1_a',
    between_vars = c('grouping1', 'grouping2')
)

# same as above, but with bars and renamed factors
plot_neat(
    data_per_subject = dat_1,
    values = 'value_1_a',
    between_vars = c('grouping1', 'grouping2'),
    type = 'bar',
    factor_names = c(grouping1 = 'experimental condition', grouping2 = 'gender')
)

# same, but with different (lighter) gray scale bars
plot_neat(
    dat_1,
    values = 'value_1_a',
    between_vars = c('grouping1', 'grouping2'),
    type = 'bar',
    factor_names = c(grouping1 = 'experimental condition', grouping2 = 'gender'),
    bar_colors = c('#555555', '#BBBBBB')
)

# same, but with red and blue bars
plot_neat(
    dat_1,
    values = 'value_1_a',
    between_vars = c('grouping1', 'grouping2'),
    type = 'bar',
    factor_names = c(grouping1 = 'experimental condition', grouping2 = 'gender'),
    bar_colors = c('red', 'blue') # equals c('#FF0000', '#0000FF')
)

# within-subject factor for 'value_1_a' vs. 'value_1_b' vs. 'value_1_c'
# (automatically named 'within_factor'), between-subject factor 'grouping1'
plot_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b', 'value_1_c'),
    between_vars = c('grouping1', 'grouping2')
)

# same, but panelled by 'within_factor'
plot_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b', 'value_1_c'),
    between_vars = c('grouping1', 'grouping2'),
    panels = 'within_factor'
)

# same, but SE for error bars instead of (default) SD
plot_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b', 'value_1_c'),
    between_vars = c('grouping1', 'grouping2'),
    panels = 'within_factor',
    eb_method = se
)

# same, but 95% CI for error bars instead of SE
# (arguably more meaningful than SEs)
plot_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b', 'value_1_c'),
    between_vars = c('grouping1', 'grouping2'),
    panels = 'within_factor',
    eb_method = mean_ci
)

# same, but using medians and Median Absolute Deviations
plot_neat(
    dat_1,
    values = c('value_1_a', 'value_1_b', 'value_1_c'),
    between_vars = c('grouping1', 'grouping2'),
    panels = 'within_factor',
    method = stats::median,
    eb_method = stats::mad
)

# within-subject factor 'number' for variables with number '1' vs. number '2'
# ('value_1_a' and 'value_1_b' vs. 'value_2_a' and 'value_2_b'), factor 'letter'
# for variables with final letter 'a' vs. final letter 'b' ('value_1_a' and
# 'value_2_a' vs. 'value_1_b' and 'value_2_b')
plot_neat(
    dat_1,
    values = c('value_1_a', 'value_2_a', 'value_1_b', 'value_2_b'),
    within_ids = list(
        letters = c('_a', '_b'),
        numbers =  c('_1', '_2')
    )
)

# same as above, but now including between-subject factor 'grouping2'
plot_neat(
    dat_1,
    values = c('value_1_a', 'value_2_a', 'value_1_b', 'value_2_b'),
    within_ids = list(
        letters = c('_a', '_b'),
        numbers =  c('_1', '_2')
    ),
    between_vars = 'grouping2'
)

# same as above, but renaming factors and values for display
plot_neat(
    dat_1,
    values = c('value_1_a', 'value_2_a', 'value_1_b', 'value_2_b'),
    within_ids = list(
        letters = c('_a', '_b'),
        numbers =  c('_1', '_2')
    ),
    between_vars = 'grouping2',
    factor_names = c(numbers = 'session (first vs. second)'),
    value_names = c(
        '_1' = 'first',
        '_2' = 'second',
        '1' = 'group 1',
        '2' = 'group 2'
    )
)

# In real datasets, these could of course be more meaningful. For example, let's
# say participants rated the attractiveness of pictures with low or high levels
# of frightening and low or high levels of disgusting qualities. So there are
# four types of ratings:
# 'low disgusting, low frightening' pictures
# 'low disgusting, high frightening' pictures
# 'high disgusting, low frightening' pictures
# 'high disgusting, high frightening' pictures

# this could be meaningfully assigned e.g. as below
pic_ratings = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    rating_fright_low_disgust_low = c(36.2, 45.2, 41, 24.6, 30.5, 28.2, 40.9, 45.1, 31, 16.9),
    rating_fright_high_disgust_low = c(-14.1, 58.5,-25.5, 42.2,-13, 4.4, 55.5,-28.5, 25.6,-37.1),
    rating_fright_low_disgust_high = c(83, 71, 111, 70, 92, 75, 110, 111, 110, 85),
    rating_fright_high_disgust_high = c(8.024,-14.162, 3.1,-2.1,-1.5, 0.91, 11.53, 18.37, 0.3,-0.59)
)
head(pic_ratings) # see what we have

# the same logic applies as for the examples above, but now the
# within-subject differences can be more meaningfully specified, e.g.
# 'disgust_low' vs. 'disgust_high' for levels of disgustingness, while
# 'fright_low' vs. 'fright_high' for levels of frighteningness
plot_neat(
    pic_ratings,
    values = c(
        'rating_fright_low_disgust_low',
        'rating_fright_high_disgust_low',
        'rating_fright_low_disgust_high',
        'rating_fright_high_disgust_high'
    ),
    within_ids = list(
        disgustingness = c('disgust_low', 'disgust_high'),
        frighteningness =  c('fright_low', 'fright_high')
    )
)

# now let's say the ratings were done in two separate groups
pic_ratings = data.frame(
    subject = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    group_id = c(1, 2, 1, 2, 2, 1, 1, 1, 2, 1),
    rating_fright_low_disgust_low = c(36.2, 45.2, 41, 24.6, 30.5, 28.2, 40.9, 45.1, 31, 16.9),
    rating_fright_high_disgust_low = c(-14.1, 58.5,-25.5, 42.2,-13, 4.4, 55.5,-28.5, 25.6,-37.1),
    rating_fright_low_disgust_high = c(83, 71, 111, 70, 92, 75, 110, 111, 110, 85),
    rating_fright_high_disgust_high = c(8.024,-14.162, 3.1,-2.1,-1.5, 0.91, 11.53, 18.37, 0.3,-0.59)
)

# now include the 'group_id' factor in the plot
plot_neat(
    pic_ratings,
    values = c(
        'rating_fright_low_disgust_low',
        'rating_fright_high_disgust_low',
        'rating_fright_low_disgust_high',
        'rating_fright_high_disgust_high'
    ),
    within_ids = list(
        disgustingness = c('disgust_low', 'disgust_high'),
        frighteningness =  c('fright_low', 'fright_high')
    ),
    between_vars = 'group_id'
)


## DISPERSION PLOTS

plot_neat(values = rnorm(100))

# with smaller binwidth (hence more bins)
plot_neat(values = rnorm(100), binwidth = 0.2)

# without normal distribution line
plot_neat(values = rnorm(100), parts = c('h', 'd', 'b'))

# without histrogram
plot_neat(values = rnorm(100), parts = c('d', 'n', 'b'))

# blue density, fully opaque histogram
plot_neat(values = rnorm(100),
         part_colors = c(dc = 'blue', ha = 1))

</code></pre>

<hr>
<h2 id='props_neat'>Difference of Two Proportions</h2><span id='topic+props_neat'></span>

<h3>Description</h3>

<p>Comparison of paired and unpaired proportions. For unpaired: Pearson's
<code><a href="stats.html#topic+prop.test">chi-squared test</a></code> or
<code><a href="Exact.html#topic+exact.test"> unconditional exact test</a></code>, including
confidence interval (CI) for the proportion difference, and corresponding
<code><a href="BayesFactor.html#topic+contingencyTableBF">independent multinomial
contingency table Bayes factor</a></code> (BF). (Cohen's h and its CI are also
calculated.) For paired tests, <code><a href="stats.html#topic+prop.test">classical
(asymptotic) McNemar test</a></code> (optionally with mid-P as well), including
confidence interval (CI) for the proportion difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>props_neat(
  var1 = NULL,
  var2 = NULL,
  case1 = NULL,
  case2 = NULL,
  control1 = NULL,
  control2 = NULL,
  prop1 = NULL,
  prop2 = NULL,
  n1 = NULL,
  n2 = NULL,
  pair = FALSE,
  greater = NULL,
  ci = NULL,
  bf_added = FALSE,
  round_to = 3,
  exact = FALSE,
  inverse = FALSE,
  yates = FALSE,
  midp = FALSE,
  h_added = FALSE,
  for_table = FALSE,
  hush = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="props_neat_+3A_var1">var1</code></td>
<td>
<p>First variable containing classifications, in 'group 1', for the
first proportion (see Examples). If given (strictly necessary for paired
proportions), proportions will be defined using <code>var1</code> and <code>var2</code>
(see Details). To distinguish classification ('cases' and 'controls'; e.g.
positive outcomes vs. negative outcomes), any two specific characters (or
numbers) can be used. However, more than two different elements (apart from
<code>NA</code>s) will cause error.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_var2">var2</code></td>
<td>
<p>Second variable containing classifications in, 'group 2', for the
second proportion, analogously to <code>var1</code>.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_case1">case1</code></td>
<td>
<p>Number of 'cases' (as opposed to 'controls'; e.g. positive
outcomes vs. negative outcomes) in 'group 1'. As counterpart, either control
numbers or sample sizes needs to be given (see Details).</p>
</td></tr>
<tr><td><code id="props_neat_+3A_case2">case2</code></td>
<td>
<p>Number of 'cases' in 'group 2'.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_control1">control1</code></td>
<td>
<p>Number of 'controls' in 'group 1'. As counterpart, case
numbers need to be given (see Details).</p>
</td></tr>
<tr><td><code id="props_neat_+3A_control2">control2</code></td>
<td>
<p>Number of 'controls' in 'group 2'.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_prop1">prop1</code></td>
<td>
<p>Proportion in 'group 1'. As counterpart, sample sizes need to be
given (see Details).</p>
</td></tr>
<tr><td><code id="props_neat_+3A_prop2">prop2</code></td>
<td>
<p>Proportion in 'group 2'.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_n1">n1</code></td>
<td>
<p>Number; sample size of 'group 1'.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_n2">n2</code></td>
<td>
<p>Number; sample size of 'group 2'.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_pair">pair</code></td>
<td>
<p>Logical. Set <code>TRUE</code> for paired proportions (McNemar, mid-P),
or <code>FALSE</code> (default) for unpaired (chi squared, or unconditional exact
test). Note: paired data must be given in <code>var1</code> and <code>var2</code>.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_greater">greater</code></td>
<td>
<p><code>NULL</code> or string (or number); optionally specifies
one-sided exact test: either &quot;1&quot; (<code>case1/n1</code> proportion expected to be
greater than <code>case2/n2</code> proportion) or &quot;2&quot; (<code>case2/n2</code> proportion
expected to be greater than <code>case1/n1</code> proportion). If <code>NULL</code>
(default), the test is two-sided.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_ci">ci</code></td>
<td>
<p>Numeric; confidence level for the returned CIs (proportion
difference and Cohen's h).</p>
</td></tr>
<tr><td><code id="props_neat_+3A_bf_added">bf_added</code></td>
<td>
<p>Logical. If <code>TRUE</code>, Bayes factor is calculated and
displayed. (Always two-sided!)</p>
</td></tr>
<tr><td><code id="props_neat_+3A_round_to">round_to</code></td>
<td>
<p>Number <code><a href="#topic+ro">to round</a></code> to the proportion
statistics (difference and CIs).</p>
</td></tr>
<tr><td><code id="props_neat_+3A_exact">exact</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code>,
<code><a href="Exact.html#topic+exact.test"> unconditional exact test</a></code> is calculated and
displayed, otherwise the default Pearson's
<code><a href="stats.html#topic+prop.test">chi-squared test</a></code>.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_inverse">inverse</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. When <code>var1</code> and
<code>var2</code> are given to calculate proportion from, by default the factors'
frequency determines which are 'cases' and which are 'controls' (so that the
latter are more frequent). If the <code>inverse</code> argument is <code>TRUE</code>, it
reverses the default proportion direction.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_yates">yates</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code>, Yates'
continuity correction is applied to the chi-squared (unpaired) or the
McNemar (paired) test. Some authors advise this correction for certain
specific cases (e.g., small sample), but evidence does not seem to support
this (Pembury Smith &amp; Ruxton, 2020).</p>
</td></tr>
<tr><td><code id="props_neat_+3A_midp">midp</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code>, displays an
additional 'mid-P' p value (using the formula by Pembury Smith &amp; Ruxton,
2020) for McNemar's test (Fagerland et al., 2013). This provides better
control for Type I error (less false positive findings) than the classical
McNemar test, while it is also probably not much less robust (Pembury Smith
&amp; Ruxton, 2020).</p>
</td></tr>
<tr><td><code id="props_neat_+3A_h_added">h_added</code></td>
<td>
<p>Logical. If <code>TRUE</code>, Cohen's h and its CI are calculated
and displayed. (<code>FALSE</code> by default.)</p>
</td></tr>
<tr><td><code id="props_neat_+3A_for_table">for_table</code></td>
<td>
<p>Logical. If <code>TRUE</code>, omits the confidence level display
from the printed text.</p>
</td></tr>
<tr><td><code id="props_neat_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing any details to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The proportion for the two groups can be given using any of the following
combinations (a) two vectors (<code>var1</code> and <code>var2</code>), (b) cases and
controls, (c) cases and sample sizes, or (d) proportions and sample sizes.
Whenever multiple combinations are specified, only the first parameters (as
given in the function and in the previous sentence) will be taken into
account.
</p>
<p>The Bayes factor (BF), in case of unpaired samples, is always calculated with
the default r-scale of <code>0.707</code>. BF supporting null hypothesis is denoted
as BF01, while that supporting alternative hypothesis is denoted as BF10. When
the BF is smaller than 1 (i.e., supports null hypothesis), the reciprocal is
calculated (hence, BF10 = BF, but BF01 = 1/BF). When the BF is greater than or
equal to 10000, scientific (exponential) form is reported for readability.
(The original full BF number is available in the returned named vector as
<code>bf</code>.)
</p>


<h3>Value</h3>

<p>Prints exact test statistics (including proportion difference with CI,
and BF) in APA style. Furthermore, when assigned, returns a named vector
with the following elements: <code>z</code> (Z), <code>p</code> (p value),
<code>prop_diff</code> (raw proportion difference), <code>h</code> (Cohen's h),
<code>bf</code> (Bayes factor).
</p>


<h3>Note</h3>

<p>Barnard's unconditional exact test is calculated via
<code><a href="Exact.html#topic+exact.test">Exact::exact.test</a></code> (&quot;z-pooled&quot;).
</p>
<p>The CI for the proportion difference in case of the exact test is calculated
based on the p value, as described by Altman and Bland (2011). In case of
extremely large or extremely small p values, this can be biased and
misleading.
</p>
<p>The Bayes factor is calculated via
<code><a href="BayesFactor.html#topic+contingencyTableBF">BayesFactor::contingencyTableBF</a></code>,
with <code>sampleType = "indepMulti"</code>, as appropriate when both sample
sizes (<code>n1</code> and <code>n2</code>) are known in advance (as it normally
happens). (For details, see <code><a href="BayesFactor.html#topic+contingencyTableBF">contingencyTableBF</a></code>,
or e.g. 'Chapter 17 Bayesian statistics' in Navarro, 2019.)
</p>


<h3>References</h3>

<p>Altman, D. G., &amp; Bland, J. M. (2011). How to obtain the confidence interval
from a P value. Bmj, 343(d2090). <a href="https://doi.org/10.1136/bmj.d2090">doi:10.1136/bmj.d2090</a>
</p>
<p>Barnard, G. A. (1947). Significance tests for 2x2 tables. Biometrika, 34(1/2),
123-138. <a href="https://doi.org/10.1093/biomet/34.1-2.123">doi:10.1093/biomet/34.1-2.123</a>
</p>
<p>Fagerland, M. W., Lydersen, S., &amp; Laake, P. (2013). The McNemar test for
binary matched-pairs data: Mid-p and asymptotic are better than exact
conditional. BMC Medical Research Methodology, 13(1), 91.
<a href="https://doi.org/10.1186/1471-2288-13-91">doi:10.1186/1471-2288-13-91</a>
</p>
<p>Lydersen, S., Fagerland, M. W., &amp; Laake, P. (2009). Recommended tests for
association in 2x2 tables. Statistics in medicine, 28(7), 1159-1175.
<a href="https://doi.org/10.1002/sim.3531">doi:10.1002/sim.3531</a>
</p>
<p>Navarro, D. (2019). Learning statistics with R.
<a href="https://learningstatisticswithr.com/">https://learningstatisticswithr.com/</a>
</p>
<p>Pembury Smith, M. Q. R., &amp; Ruxton, G. D. (2020). Effective use of the McNemar
test. Behavioral Ecology and Sociobiology, 74(11), 133.
<a href="https://doi.org/10.1007/s00265-020-02916-y">doi:10.1007/s00265-020-02916-y</a>
</p>
<p>Suissa, S., &amp; Shuster, J. J. (1985). Exact unconditional sample sizes for the
2 times 2 binomial trial. Journal of the Royal Statistical Society: Series A
(General), 148(4), 317-327. <a href="https://doi.org/10.2307/2981892">doi:10.2307/2981892</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
set.seed(1)
outcomes_A = sample(c(rep('x', 490), rep('y', 10)))
outcomes_B = sample(c(rep('x', 400), rep('y', 100)))

# paired proportion test (McNemar)
props_neat(var1 = outcomes_A,
           var2 = outcomes_B,
           pair = TRUE)

# unpaired chi test for the same data (two independent samples assumed)
# Yates correction applied
# cf. http://www.sthda.com/english/wiki/two-proportions-z-test-in-r
props_neat(
    var1 = outcomes_A,
    var2 = outcomes_B,
    pair = FALSE,
    yates = TRUE
)

# above data given differently for unpaired test
# (no Yates corrrection)
props_neat(
    case1 = 490,
    case2 = 400,
    control1 = 10,
    control2 = 100
)

# again differently
props_neat(
    case1 = 490,
    case2 = 400,
    n1 = 500,
    n2 = 500
)

# other example data
outcomes_A2 = c(rep(1, 707), rep(0, 212),  rep(1, 256), rep(0, 144))
outcomes_B2 = c(rep(1, 707), rep(0, 212),  rep(0, 256), rep(1, 144))

# paired test
# cf. https://www.medcalc.org/manual/mcnemartest2.php
props_neat(var1 = outcomes_A2,
           var2 = outcomes_B2,
           pair = TRUE)

# show reverse proportions (otherwise the same)
props_neat(
    var1 = outcomes_A2,
    var2 = outcomes_B2,
    pair = TRUE,
    inverse = TRUE
)


# two different sample sizes
out_chi = props_neat(
    case1 = 40,
    case2 = 70,
    n1 = 150,
    n2 = 170
)

# exact test
out_exact = props_neat(
    case1 = 40,
    case2 = 70,
    n1 = 150,
    n2 = 170,
    exact = TRUE
)

# the two p values are just tiny bit different
print(out_chi) # p 0.00638942
print(out_exact) # p 0.006481884

# one-sided test
props_neat(
    case1 = 40,
    case2 = 70,
    n1 = 150,
    n2 = 170,
    greater = '2'
)

</code></pre>

<hr>
<h2 id='rbind_loop'>Merge by Columns in Loops</h2><span id='topic+rbind_loop'></span>

<h3>Description</h3>

<p>Merges rows by columns in a loop using the <code><a href="#topic+enum">enum</a></code>
function. On first iteration, indicated by <code><a href="#topic+enum">enum</a></code>, initiates a
new <code><a href="data.table.html#topic+data.table">data.table</a></code> with the data to merge as first row. On all
following iterations, adds data to merge as subsequent rows (using
<code><a href="data.table.html#topic+rbindlist">data.table::rbindlist</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_loop(merged, ..., hush = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_loop_+3A_merged">merged</code></td>
<td>
<p>The name of the <code><a href="data.table.html#topic+data.table">data.table</a></code> for the merged data
(without quotes).</p>
</td></tr>
<tr><td><code id="rbind_loop_+3A_...">...</code></td>
<td>
<p>Any number of data to be merged. Each argument must be one of the
following: a <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>) with
either single row or two column; a named vector or a named list (with single
elements); or a single value with parameter name (e.g. date = 1989 or id =
&quot;jdoe&quot;). Data with two columns will be transposed using first column as
column names and second column as corresponding values. See Details,
Examples.</p>
</td></tr>
<tr><td><code id="rbind_loop_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), prints message when the data
frame for merging is initiated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In each call, all data passed to the function (via <code>...</code>) will
be merged into a single row, and that single row will be added to the
&quot;<code>merged</code>&quot; data table.
</p>
<p>See an extensive example via https://github.com/gasparl/neatstats.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+enum">enum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my_vector = c('aa', 'bb', 'cxyz', 'last')
for (elem in enum(my_vector)) {
    cat(elem, fill = TRUE)
    rbind_loop(
        merged_data, # data frame name for merging
        item = elem[2],
        number = elem[1],
        whatever = paste0('number (', elem[1], ')')
    )
}
# merged_data now contains all merged rows
print(merged_data)
# item number   whatever
# 1   aa      1 number (1)
# 2   bb      2 number (2)
# 3 cxyz      3 number (3)
# 4 last      4 number (4)


# example with other data types
for (elem in enum(my_vector)) {
    cat(elem, fill = TRUE)
    dframe1 = data.frame(item = elem[2],
                         number = elem[1])
    print(elem[1])
    asnum = as.numeric(elem[1])
    dframe2 = data.frame(
        my_cols = c('index', 'squared', 'multiple'),
        my_vals = c(elem[1], asnum ** 2, asnum * 10)
    )
    my_list = list(ls_item = elem[2], ls_num = elem[1])
    my_vec = c(v_item = elem[2], v_num = elem[1])
    rbind_loop(
        merged_data,
        dframe1, # data frame with single row
        dframe2, # data frame with two columns
        my_list, # named list
        my_vec, # named vector
        single_val = elem[2], # single element
        constant = "whatever" # other single element
    )
}

# again merged_data contains all merged rows
# (previous content, if any, were removed)
print(merged_data)


# example with differring columns
for (elem in enum(my_vector)) {
    cat(elem, fill = TRUE)
    dframe = data.frame(item = elem[2],
                        number = elem[1])
    asnum = as.numeric(elem[1])
    if (asnum %% 2 == 0) {
        dframe$sqr = asnum ** 2
    }
    rbind_loop(merged_data,
               dframe)
}

# merged_data contains all new merged rows
# with NAs where sqr was not added
print(merged_data)

# example with data.table added
library('data.table')
for (elem in enum(my_vector)) {
    cat(elem, fill = TRUE)
    dframe = data.frame(item = elem[2],
                        number = elem[1])
    asnum = as.numeric(elem[1])
    dtable = data.table(item2 = paste('DT', elem[2]),
                        number2 = asnum + 9)
    if (asnum %% 2 == 0) {
        dframe$sqr = asnum ** 2
    }
    rbind_loop(merged_data,
               dframe,
               dtable)
}

print(merged_data)

# an extensive example to show how to collect and aggregate raw data is
# available via the README file at the repository:
# https://github.com/gasparl/neatstats

</code></pre>

<hr>
<h2 id='read_dir'>Read and Merge Files from Directory</h2><span id='topic+read_dir'></span>

<h3>Description</h3>

<p>Reads data files from any given directory as data frames and
merges them into a single data frame (using
<code><a href="data.table.html#topic+rbindlist">data.table::rbindlist</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dir(
  pattern = "*[.]",
  path = ".",
  reader_function = data.table::fread,
  ...,
  subdirs = FALSE,
  filt = NULL,
  hush = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_dir_+3A_pattern">pattern</code></td>
<td>
<p>Regular expression (&quot;regex&quot;; as string or <code>NULL</code>) for
selecting files (passed to the <code><a href="base.html#topic+list.files">list.files</a></code> function). The
default <code>NULL</code> means that all files at the specified path will be read
in. To select, for example, a specific extension like &quot;.txt&quot;, the pattern
can be given as <code>"\.txt$"</code> (for CSV files, <code>"\.csv$"</code>, etc.).
Files ending with e.g. &quot;group2.txt&quot; can be specified as
<code>"group2\.txt$"</code>. Files starting with &quot;exp3&quot; can be specified as
<code>"^exp3"</code>. Files starting with &quot;exp3&quot; AND ending with &quot;.txt&quot; extension
can be specified as <code>"^exp3.*\.txt$"</code>. To read in a single file,
specify the full filename (e.g. <code>"exp3_subject46_group2.txt"</code>). (See
<code>?regex</code> for more details.)</p>
</td></tr>
<tr><td><code id="read_dir_+3A_path">path</code></td>
<td>
<p>Path to the directory from which the files should be selected and
read. The default <code>"."</code> means the current working directory (as
returned by <code><a href="base.html#topic+getwd">getwd</a>()</code>). Either specify correct working directory
in advance (see <code><a href="base.html#topic+setwd">setwd</a></code>, <code><a href="#topic+path_neat">path_neat</a></code>), or otherwise
enter relative or full paths (e.g. <code>"C:/research"</code> or
<code>"/home/projects"</code>, etc.).</p>
</td></tr>
<tr><td><code id="read_dir_+3A_reader_function">reader_function</code></td>
<td>
<p>A function to be used for reading the files,
<code><a href="data.table.html#topic+fread">data.table::fread</a></code> by default.</p>
</td></tr>
<tr><td><code id="read_dir_+3A_...">...</code></td>
<td>
<p>Any arguments to be passed on to the chosen <code>reader_function</code>.</p>
</td></tr>
<tr><td><code id="read_dir_+3A_subdirs">subdirs</code></td>
<td>
<p>Logical (<code>FALSE</code> by default). If <code>TRUE</code>, searches
files in subdirectories as well (relative to the given <code>path</code>).</p>
</td></tr>
<tr><td><code id="read_dir_+3A_filt">filt</code></td>
<td>
<p>An expression to filter, by column values, each data file after it
is read and before it is merged with the other data. (The expression should
use column names alone; see Examples.)</p>
</td></tr>
<tr><td><code id="read_dir_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), prints lists all data file
names as they are being read (along with related warnings).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is very similar to the <code>readbulk::read_bulk</code>
function. One important difference however is the <code><a href="data.table.html#topic+data.table">data.table</a></code>
use, which greatly speeds up the process. Another important difference is
the possibility of file selection based on any regex <code>pattern</code>.
Furthermore, this function allows pre-filtering by file (see <code>filt</code>).
Data files could include significant amount of unnecessary data, and
filtering prevents these to be merged.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+rbindlist">data.table::rbindlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# first, set current working directory
# e.g. to script's path with setwd(path_neat())

# read all text files in currect working directory
merged_df = read_dir("\\.txt$")
# merged_df now has all data

# to use utils::read.table for reading (slower than fread)
# (with some advisable options passed to it)
merged_df = read_dir(
    '\\.txt$',
    reader_function = read.table,
    header = TRUE,
    fill = TRUE,
    quote = "\"",
    stringsAsFactors = FALSE
)


</code></pre>

<hr>
<h2 id='ro'>Neat rounding</h2><span id='topic+ro'></span>

<h3>Description</h3>

<p>Rounds a given number to given number of digits after the
decimal point, returning it as string, with trailing zeros when applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ro(num, round_to = 2, leading_zero = TRUE, signi = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ro_+3A_num">num</code></td>
<td>
<p>Number to be rounded.</p>
</td></tr>
<tr><td><code id="ro_+3A_round_to">round_to</code></td>
<td>
<p>Number of fractional digits (i.e., digits after the decimal
point), to round to.</p>
</td></tr>
<tr><td><code id="ro_+3A_leading_zero">leading_zero</code></td>
<td>
<p>Logical, <code>TRUE</code> by default. If <code>FALSE</code>, omits
leading zero (e.g. returns &quot;.17&quot; instead of &quot;0.17&quot;).</p>
</td></tr>
<tr><td><code id="ro_+3A_signi">signi</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code>, rounds to a
fractional digit that allows at least the first <code>N</code> non-zero digits
displayed in all numbers, where <code>N</code> is specified by the
<code>round_to</code> parameter. (See <code><a href="base.html#topic+formatC">base:formatC</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number as string: <code>num</code> rounded to <code>round_to</code> digits, with
trailing zeros when applicable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ro( 1.2345 ) # returns "1.23"

ro( 0.12345, 1 ) # returns "0.1"

ro( 12.3, 4 ) # returns "12.3000"

# examples with vectors
to_round = c(1000, 100, 0.1, 0.01, 0.001, 0.0001)
ro(to_round)
ro(to_round, 3)
ro(to_round, 3, leading_zero = FALSE)
ro(to_round, 3, signi = TRUE)
to_round2 = c(1230.000, 100, 0.012, 0.01, 0.123, 0.012340)
ro(to_round2, 3)
ro(to_round2, 3, signi = TRUE)
ro(to_round2, 2, signi = TRUE)
ro(to_round2, 1, signi = TRUE)
ro(to_round2, 9, signi = TRUE)


</code></pre>

<hr>
<h2 id='roc_neat'>Difference of Two Areas Under the Curves</h2><span id='topic+roc_neat'></span>

<h3>Description</h3>

<p>Comparison of two <code><a href="#topic+t_neat">areas under the
receiver operating characteristic curves</a></code> (AUCs) and plotting any number of
ROC curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc_neat(
  roc1,
  roc2 = NULL,
  pair = FALSE,
  greater = NULL,
  ci = NULL,
  hush = FALSE,
  plot_rocs = FALSE,
  roc_labels = "",
  cutoff_auto = TRUE,
  cutoff_custom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc_neat_+3A_roc1">roc1</code></td>
<td>
<p>Receiver operating characteristic (ROC) <code><a href="pROC.html#topic+roc">
object</a></code>, or, for plotting only, a <code><a href="base.html#topic+list">list</a></code> including any number
of such ROC objects.</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_roc2">roc2</code></td>
<td>
<p>Receiver operating characteristic (ROC) <code><a href="pROC.html#topic+roc">
object</a></code>, or, for plotting only, leave it as <code>NULL</code> (default) and
provide list for the first parameter (<code>roc1</code>).</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_pair">pair</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the test is conducted for paired samples.
Otherwise (default) for independent samples.</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_greater">greater</code></td>
<td>
<p><code>NULL</code> or string (or number); optionally specifies
one-sided test: either &quot;1&quot; (<code>roc1</code> AUC expected to be greater than
<code>roc2</code> AUC) or &quot;2&quot; (<code>roc2</code> AUC expected to be greater than
<code>roc2</code> AUC). If <code>NULL</code> (default), the test is two-sided.</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_ci">ci</code></td>
<td>
<p>Numeric; confidence level for the returned CIs (raw difference).</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing any details to console
(and plotting).</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_plot_rocs">plot_rocs</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plots and returns ROC curves.</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_roc_labels">roc_labels</code></td>
<td>
<p>Optional character vector to provide legend label texts (in
the order of the provided ROC objects) for the ROC plot.</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_cutoff_auto">cutoff_auto</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), optimal cutoffs
on the ROC plots are displayed.</p>
</td></tr>
<tr><td><code id="roc_neat_+3A_cutoff_custom">cutoff_custom</code></td>
<td>
<p>Custom cutoff to be indicated on the plot can be given
here in a <code>list</code>. The list index must exactly correspond to the index
of the list index of the AUC (given in <code>roc1</code>) for which the given
cutoff is intended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints DeLong's test results for the comparison of the two given AUCs
in APA style, as well as corresponding CI for the AUC difference.
Furthermore, when assigned, returns a list  with <code>stat</code> (D value),
<code>p</code> (p value), and, when plot is added, ROC plot.
</p>


<h3>Note</h3>

<p>The main test statistics are calculated via
<code><a href="pROC.html#topic+roc.test">pROC::roc.test</a></code> as DeLong's test (for both
paired and unpaired). The <code>roc_neat</code> function merely prints it in APA
style. The CI is calculated based on the p value, as described by Altman and
Bland (2011).
</p>
<p>The ROC object may be calculated via <code><a href="#topic+t_neat">t_neat</a></code>, or directly with
<code><a href="pROC.html#topic+roc">pROC::roc</a></code>.
</p>


<h3>References</h3>

<p>Altman, D. G., &amp; Bland, J. M. (2011). How to obtain the confidence interval
from a P value. Bmj, 343(d2090). <a href="https://doi.org/10.1136/bmj.d2090">doi:10.1136/bmj.d2090</a>
</p>
<p>DeLong, E. R., DeLong, D. M., &amp; Clarke-Pearson, D. L. (1988). Comparing the
areas under two or more correlated receiver operating characteristic curves: a
nonparametric approach. Biometrics, 44(3), 837-845.
<a href="https://doi.org/10.2307/2531595">doi:10.2307/2531595</a>
</p>
<p>Robin, X., Turck, N., Hainard, A., Tiberti, N., Lisacek, F., Sanchez, J. C., &amp;
Muller, M. (2011). pROC: an open-source package for R and S+ to analyze and
compare ROC curves. BMC bioinformatics, 12(1), 77.
<a href="https://doi.org/10.1186/1471-2105-12-77">doi:10.1186/1471-2105-12-77</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+t_neat">t_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# calculate first AUC (from v1 and v2)
v1 = c(191, 115, 129, 43, 523,-4, 34, 28, 33,-1, 54)
v2 = c(4,-2, 23, 13, 32, 16, 3, 29, 37,-4, 65)
results1 = t_neat(v1, v2, auc_added = TRUE)

# calculate second AUC (from v3 and v4)
v3 = c(14.1, 58.5, 25.5, 42.2, 13, 4.4, 55.5, 28.5, 25.6, 37.1)
v4 = c(36.2, 45.2, 41, 24.6, 30.5, 28.2, 40.9, 45.1, 31, 16.9)
results2 = t_neat(v3, v4, auc_added = TRUE)

# one-sided comparison of the two AUCs
roc_neat(results1$roc_obj, results2$roc_obj, greater = "1")


# create a list of randomlz generated AUCs
set.seed(1)
aucs_list = list()
for (i in 1:4) {
    aucs_list[[i]] = t_neat(rnorm(50, (i-1)),
                            rnorm(50),
                            auc_added = TRUE,
                            hush = TRUE)$roc_obj
}
# depict AUCs (recognized as list)
roc_neat(aucs_list)


# with custom cutoffs depicted
roc_neat(aucs_list,
         cutoff_custom = list(0.2),
         cutoff_auto = FALSE)
roc_neat(aucs_list,
         cutoff_custom = list(.1, c(-.5, 0), NULL, c(.7, 1.6)),
         cutoff_auto = FALSE)
roc_neat(aucs_list,
         cutoff_custom = list(.6, NULL, NULL, 1.1))


</code></pre>

<hr>
<h2 id='sd_ci'>Confidence Interval of Standard Deviation</h2><span id='topic+sd_ci'></span>

<h3>Description</h3>

<p>Calculates the SD confidence interval of a vector of numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_ci(x, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_ci_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="sd_ci_+3A_ci">ci</code></td>
<td>
<p>Numeric; confidence level for returned CI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SD confidence interval (as named vector).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean_ci">mean_ci</a></code>, <code><a href="#topic+plot_neat">plot_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myvec = c(11, 15, 19, 43, 53, -4, 34, 8, 33, -1, 54 )
sd_ci( myvec )
sd_ci( myvec, ci = .80 )

</code></pre>

<hr>
<h2 id='se'>Standard Error of Mean</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>Simply calculates the standard error of a vector of numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean_ci">mean_ci</a></code>, <code><a href="#topic+plot_neat">plot_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>se( c(11, 15, 19, 43, 53, -4, 34, 8, 33, -1, 54 ) )

</code></pre>

<hr>
<h2 id='t_neat'>Difference of Two Means and Area Under the Curve</h2><span id='topic+t_neat'></span>

<h3>Description</h3>

<p>Welch's <code><a href="stats.html#topic+t.test">t-test</a></code> results including
Cohen's d with confidence interval (CI),
<code><a href="BayesFactor.html#topic+ttestBF">Bayes factor</a></code> (BF), and
<code><a href="pROC.html#topic+auc">area under the receiver operating characteristic
curve</a></code> (AUC). For non-parametric version,
<code><a href="stats.html#topic+wilcox.test">Wilcoxon test</a></code> results (Mann–Whitney U test,
aka &quot;Wilcoxon rank-sum test&quot;, for independent samples; Wilcoxon signed-rank
test for paired samples; including nonparametric &quot;location difference
estimate&quot; (see <code><a href="stats.html#topic+wilcox.test">stats::wilcox.test</a></code>); along
with corresponding rank-based BFs as per van Doorn et al., 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_neat(
  var1,
  var2,
  pair = FALSE,
  nonparametric = FALSE,
  greater = NULL,
  norm_tests = "latent",
  norm_plots = FALSE,
  ci = NULL,
  bf_added = FALSE,
  bf_rscale = sqrt(0.5),
  bf_sample = 1000,
  auc_added = FALSE,
  cutoff = NULL,
  r_added = TRUE,
  for_table = FALSE,
  test_title = NULL,
  round_descr = 2,
  round_auc = 3,
  auc_greater = "1",
  cv_rep = FALSE,
  cv_fold = 10,
  hush = FALSE,
  plots = FALSE,
  rug_size = 4,
  aspect_ratio = 1,
  y_label = "density estimate",
  x_label = "\nvalues",
  factor_name = NULL,
  var_names = c("1", "2"),
  reverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_neat_+3A_var1">var1</code></td>
<td>
<p>Numeric vector; numbers of the first variable.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_var2">var2</code></td>
<td>
<p>Numeric vector; numbers of the second variable.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_pair">pair</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all tests (t, BF, AUC) are conducted for
paired samples. If <code>FALSE</code> (default) for independent samples.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_nonparametric">nonparametric</code></td>
<td>
<p>Logical (<code>FALSE</code> by default). If <code>TRUE</code>, uses
nonparametric (rank-based, &quot;Wilcoxon&quot;) t-tests (including BFs; see Notes).</p>
</td></tr>
<tr><td><code id="t_neat_+3A_greater">greater</code></td>
<td>
<p><code>NULL</code> or string (or number); optionally specifies
one-sided tests (t and BF): either &quot;1&quot; (<code>var1</code> mean expected to be
greater than <code>var2</code> mean) or &quot;2&quot; (<code>var2</code> mean expected to be
greater than <code>var1</code> mean). If <code>NULL</code> (default), the test is
two-sided.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_norm_tests">norm_tests</code></td>
<td>
<p>Normality tests. Any or all of the following character input
is accepted (as a single string or a character vector; case-insensitive):
<code>"W"</code> (Shapiro-Wilk), <code>"K2"</code> (D'Agostino), <code>"A2"</code>
(Anderson-Darling), <code>"JB"</code> (Jarque-Bera); see Notes. Two other options
are <code>"all"</code> (same as <code>TRUE</code>; to choose all four previous tests at
the same time) or <code>"latent"</code> (default value; prints all tests only if
<code>nonparametric</code> is set to <code>FALSE</code> and any of the four tests gives
a p value below .05). Each normality test is performed for the difference
values between the two variables in case of paired samples, or for each of
the two variables for unpaired samples. Set to <code>"none"</code> to disable
(i.e., not to perform any normality tests).</p>
</td></tr>
<tr><td><code id="t_neat_+3A_norm_plots">norm_plots</code></td>
<td>
<p>If <code>TRUE</code>, displays density, histogram, and Q-Q plots
(and scatter plots for paired tests) for each of the two variable (and
differences for pairwise observations, in case of paired samples).</p>
</td></tr>
<tr><td><code id="t_neat_+3A_ci">ci</code></td>
<td>
<p>Numeric; confidence level for returned CIs for Cohen's d and AUC.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_bf_added">bf_added</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), Bayes factor is calculated
and displayed.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_bf_rscale">bf_rscale</code></td>
<td>
<p>The scale of the prior distribution (<code>0.707</code> by
default).</p>
</td></tr>
<tr><td><code id="t_neat_+3A_bf_sample">bf_sample</code></td>
<td>
<p>Number of samples used to estimate Bayes factor (<code>1000</code>
by default). More samples (e.g. <code>10000</code>) take longer time but give more
stable BF.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_auc_added">auc_added</code></td>
<td>
<p>Logical (<code>FALSE</code> by default). If <code>TRUE</code>, AUC is
calculated and displayed. Includes TPR and TNR, i.e., true positive and true
negative rates, i.e. sensitivity and specificity, using an optimal
value, i.e. threshold, that provides maximal TPR and TNR. These values may
be cross-validated: see <code>cv_rep</code>. (Note that what is designated as
&quot;positive&quot; or &quot;negative&quot; depends on the scenario: this function always
assumes <code>var1</code> as positive and <code>var2</code> as negative. If your
scenario or preference differs, you can simply switch the names or values
when reporting the results.)</p>
</td></tr>
<tr><td><code id="t_neat_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric. Custom cutoff value for AUC TPR and TNR, also to be
depicted in the plot. In case of multiple given, the first is used for
calculations, but all will be depicted in the plot.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_r_added">r_added</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), Pearson correlation is
calculated and displayed in case of paired comparison.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_for_table">for_table</code></td>
<td>
<p>Logical. If <code>TRUE</code>, omits the confidence level display
from the printed text.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_test_title">test_title</code></td>
<td>
<p><code>NULL</code> or string. If not <code>NULL</code>, simply displayed
in printing preceding the statistics. (Useful e.g. to distinguish several
different comparisons inside a <code>function</code> or a <code>for</code> loop.)</p>
</td></tr>
<tr><td><code id="t_neat_+3A_round_descr">round_descr</code></td>
<td>
<p>Number <code><a href="#topic+ro">to round</a></code> to the descriptive
statistics (means and SDs).</p>
</td></tr>
<tr><td><code id="t_neat_+3A_round_auc">round_auc</code></td>
<td>
<p>Number <code><a href="#topic+ro">to round</a></code> to the AUC and its CI.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_auc_greater">auc_greater</code></td>
<td>
<p>String (or number); specifies which variable is expected to
have greater values for 'cases' as opposed to 'controls': &quot;1&quot; (default;
<code>var1</code> expected to be greater for 'cases' than <code>var2</code> mean) or &quot;2&quot;
(<code>var2</code> expected to be greater for 'cases' than <code>var1</code>). Not to be
confused with one-sided tests; see Details.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_cv_rep">cv_rep</code></td>
<td>
<p><code>FALSE</code> (default), <code>TRUE</code>, or numeric. If <code>TRUE</code>
or numeric, a cross-validation is performed for the calculation of TPRs and
TNRs. Numeric value specifies the number of repetitions, while, if
<code>TRUE</code>, it defaults to <code>100</code> repetitions. In each repetition, the
data is divided into <code>k</code> random parts (&quot;folds&quot;; see <code>cv_fold</code>),
and the optimal accuracy is obtained k times from a k-1 training set
(<code>var1</code> and <code>var2</code> truncated to equal length, if needed, in each
case within each repetition), and the TPR and TNR are calculated from the
remaining test set (different each time).</p>
</td></tr>
<tr><td><code id="t_neat_+3A_cv_fold">cv_fold</code></td>
<td>
<p>Numeric. The number of folds into which the data is divided for
cross-validation (default: 10).</p>
</td></tr>
<tr><td><code id="t_neat_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing any details to console.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_plots">plots</code></td>
<td>
<p>Logical (or <code>NULL</code>). If <code>TRUE</code>, creates a combined
density plot (i.e., <code><a href="stats.html#topic+density">Gaussian kernel density
estimates</a></code>) from the two variables. Includes dashed vertical lines to
indicate means of each of the two variables. If <code>nonparametric</code> is set
to <code>TRUE</code>, medians are calculated for these dashed lines instead of
means. When <code>auc_added</code> is <code>TRUE</code> (and the AUC is at least .5),
the best threshold value for classification (maximal differentiation
accuracy using Youden's index) is added to the plot as solid vertical line.
(In case of multiple best thresholds with identical overall accuracy, all
are added.) If <code>NULL</code>, same as if <code>TRUE</code> except that histogram is
added to the background.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_rug_size">rug_size</code></td>
<td>
<p>Numeric (<code>4</code> by default): size of the rug ticks below the
density plot. Set to <code>0</code> (zero) to omit rug plotting.</p>
</td></tr>
<tr><td><code id="t_neat_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Aspect ratio of the plots: <code>1</code> (<code>1</code>/<code>1</code>) by
default. (Set to <code>NULL</code> for dynamic aspect ratio.)</p>
</td></tr>
<tr><td><code id="t_neat_+3A_y_label">y_label</code></td>
<td>
<p>String or <code>NULL</code>; the label for the <code>y</code> axis.
(Default: <code>"density estimate"</code>.)</p>
</td></tr>
<tr><td><code id="t_neat_+3A_x_label">x_label</code></td>
<td>
<p>String or <code>NULL</code>; the label for the <code>x</code> axis.
(Default: <code>"values"</code>.)</p>
</td></tr>
<tr><td><code id="t_neat_+3A_factor_name">factor_name</code></td>
<td>
<p>String or <code>NULL</code>; factor legend title. (Default:
<code>NULL</code>.)</p>
</td></tr>
<tr><td><code id="t_neat_+3A_var_names">var_names</code></td>
<td>
<p>A vector of two strings; the variable names to be displayed
in the legend. (Default: <code>c("1", "2")</code>.)</p>
</td></tr>
<tr><td><code id="t_neat_+3A_reverse">reverse</code></td>
<td>
<p>Logical. If <code>TRUE</code>, reverses the order of variable names
displayed in the legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayes factor (BF) supporting null hypothesis is denoted as BF01, while
that supporting alternative hypothesis is denoted as BF10. When the BF is
smaller than 1 (i.e., supports null hypothesis), the reciprocal is calculated
(hence, BF10 = BF, but BF01 = 1/BF). When the BF is greater than or equal to
10000, scientific (exponential) form is reported for readability. (The
original full BF number is available in the returned named vector as
<code>bf</code>.)
</p>
<p>For simplicity, Cohen's d is reported for nonparametric tests too: you may
however want to consider reporting alternative effect sizes in this case.
</p>
<p>The original <code><a href="pROC.html#topic+auc">pROC::auc</a></code> function, by default, always
returns an AUC greater than (or equal to) .5, assuming that the prediction
based on values in the expected direction work correctly at least at chance
level. This however may be confusing. Consider an example where we measure the
heights of persons in a specific small sample and expect that greater height
predicts masculine gender. The results are, say, 169, 175, 167, 164 (cm) for
one gender, and 176, 182, 179, 165 for the other. If the expectation is
correct (the second, greater values are for males), the AUC is .812. However,
if in this particular population females are actually taller than males, the
AUC is in fact .188. To keep things clear, the <code>t_neat</code> function always
makes an assumption about which variable is expected to be greater for correct
classification (&quot;1&quot; by default; i.e., <code>var1</code>; to be specified as
<code>auc_greater = "2"</code> for <code>var2</code> to be expected as greater). For this
example, if the first (smaller) variables are given as <code>var1</code> for
females, and second (larger), variables are given as <code>var2</code> for males, we
have to specify <code>auc_greater = "2"</code> to indicate the expectation of larger
values for males. (Or, easier, just add the expected larger values as
<code>var1</code>.)
</p>


<h3>Value</h3>

<p>Prints t-test statistics (including Cohen's d with CI, BF, and AUC, as
specified via the corresponding parameters) in APA style. Furthermore, when
assigned, returns a list, that contains a named vector '<code>stats</code>' with
the following elements: <code>t</code> (t value), <code>p</code> (p value), <code>d</code>
(Cohen's d), <code>bf</code> (Bayes factor), <code>auc</code> (AUC), <code>accuracy</code>
(overall accuracy using the optimal classification threshold), and
<code>youden</code> (Youden's index: <code>specificity + sensitivity - 1</code>). The
latter three are <code>NULL</code> when <code>auc_added</code> is <code>FALSE</code>. When
<code>auc_added</code> is <code>TRUE</code>, there are also two or three additional
elements of the list. One is '<code>roc_obj</code>', which is a
<code><a href="pROC.html#topic+roc">roc</a></code> object, to be used e.g. with the
<code><a href="#topic+roc_neat">roc_neat</a></code> function. Another is '<code>best_thresholds</code>', which
contains the best threshold value(s) for classification, along with
corresponding specificity and sensitivity. The third '<code>cv_results</code>'
contains the results, if any, of the cross-validation of TPRs and TNRs
(means per repetition). Finally, if <code>plots</code> is <code>TRUE</code> (or
<code>NULL</code>), the plot is displayed as well as returned as a
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object, named <code>t_plot</code>.
</p>


<h3>Note</h3>

<p>The Welch's t-test is calculated via
<code><a href="stats.html#topic+t.test">stats::t.test</a></code>.
</p>
<p>#'Normality tests are all calculated via
<code><a href="fBasics.html#topic+NormalityTests">fBasics::NormalityTests</a></code>, selected based
on the recommendation of Lakens (2015), quoting Yap and Sim (2011, p. 2153):
&quot;If the distribution is symmetric with low kurtosis values (i.e. symmetric
short-tailed distribution), then the D'Agostino and Shapiro-Wilkes tests have
good power. For symmetric distribution with high sample kurtosis (symmetric
long-tailed), the researcher can use the JB, Shapiro-Wilkes, or
Anderson-Darling test.&quot; See urlhttps://github.com/Lakens/perfect-t-test for
more details.
</p>
<p>Cohen's d and its confidence interval are calculated, using the t value, via
<code><a href="MBESS.html#topic+ci.smd">MBESS::ci.smd</a></code> for independent samples (as
standardized mean difference) and via <code><a href="MBESS.html#topic+ci.sm">MBESS::ci.sm</a></code>
for paired samples (as standardized mean).
</p>
<p>The parametric Bayes factor is calculated via
<code><a href="BayesFactor.html#topic+ttestBF">BayesFactor::ttestBF</a></code>. The nonparametric
(rank-based) Bayes factor is a contribution by Johnny van Doorn; the original
source code is available via <a href="https://osf.io/gny35/">https://osf.io/gny35/</a>.
</p>
<p>The correlation and its CI are calculated via
<code><a href="stats.html#topic+cor.test">stats::cor.test</a></code>, and is always two-sided, always
with 95 percent CI. For more, use <code><a href="#topic+corr_neat">corr_neat</a></code>.
</p>
<p>The AUC and its CI are calculated via <code><a href="pROC.html#topic+auc">pROC::auc</a></code>, and
the accuracy at optimal threshold via <code><a href="pROC.html#topic+coords">pROC::coords</a></code>
(<code>x = "best"</code>); both using the object <code><a href="pROC.html#topic+roc">pROC::roc</a></code>.
</p>


<h3>References</h3>

<p>Delacre, M., Lakens, D., &amp; Leys, C. (2017). Why psychologists should by
default use Welch's t-test instead of Student's t-test. International Review
of Social Psychology, 30(1). <a href="https://doi.org/10.5334/irsp.82">doi:10.5334/irsp.82</a>
</p>
<p>Kelley, K. (2007). Methods for the behavioral, educational, and social
sciences: An R package. Behavior Research Methods, 39(4), 979-984.
<a href="https://doi.org/10.3758/BF03192993">doi:10.3758/BF03192993</a>
</p>
<p>Lakens, D. (2015). The perfect t-test (version 1.0.0). Retrieved from
https://github.com/Lakens/perfect-t-test.
<a href="https://doi.org/10.5281/zenodo.17603">doi:10.5281/zenodo.17603</a>
</p>
<p>Robin, X., Turck, N., Hainard, A., Tiberti, N., Lisacek, F., Sanchez, J. C., &amp;
Muller, M. (2011). pROC: an open-source package for R and S+ to analyze and
compare ROC curves. BMC bioinformatics, 12(1), 77.
<a href="https://doi.org/10.1186/1471-2105-12-77">doi:10.1186/1471-2105-12-77</a>
</p>
<p>van Doorn, J., Ly, A., Marsman, M., &amp; Wagenmakers, E.-J. (2020). Bayesian
rank-based hypothesis testing for the rank sum test, the signed rank test, and
Spearman’s rho. Journal of Applied Statistics, 1–23.
<a href="https://doi.org/10.1080/02664763.2019.1709053">doi:10.1080/02664763.2019.1709053</a>
</p>
<p>Yap, B. W., &amp; Sim, C. H. (2011). Comparisons of various types of normality
tests. Journal of Statistical Computation and Simulation, 81(12), 2141–2155.
<a href="https://doi.org/10.1080/00949655.2010.520163">doi:10.1080/00949655.2010.520163</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corr_neat">corr_neat</a></code>, <code><a href="#topic+roc_neat">roc_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign two variables (numeric vectors)
v1 = c(191, 115, 129, 43, 523,-4, 34, 28, 33,-1, 54)
v2 = c(4,-2, 23, 13, 32, 16, 3, 29, 37,-4, 65)

t_neat(v1, v2) # prints results as independent samples
t_neat(v1, v2, pair = TRUE) # as paired samples (r added by default)
t_neat(v1, v2, pair = TRUE, greater = "1") # one-sided
t_neat(v1, v2, pair = TRUE, auc_added = TRUE ) # AUC included

# print results and assign returned list
results = t_neat(v1, v2, pair = TRUE)

results$stats['bf'] # get precise BF value

</code></pre>

<hr>
<h2 id='table_neat'>Table, descriptives</h2><span id='topic+table_neat'></span>

<h3>Description</h3>

<p>Creates a neat means (or similar descriptives) and standard
deviations table, using <code><a href="#topic+aggr_neat">aggr_neat</a></code> functions as arguments.
Alternatively, merges and transposes data frames into rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_neat(
  values_list,
  group_by = NULL,
  group_per = "rows",
  to_clipboard = FALSE,
  method = "mean+sd",
  transpose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_neat_+3A_values_list">values_list</code></td>
<td>
<p>Data frames as returned from the <code><a href="#topic+aggr_neat">aggr_neat</a></code>
function: variables from which the statistics for the table are to be
calculated. The <code>group_by</code>, <code>method</code>, and <code>prefix</code>
parameters are ignored when they are given in the <code><a href="#topic+table_neat">table_neat</a></code>
function; see Details and also an extensive example via
https://github.com/gasparl/neatstats.</p>
</td></tr>
<tr><td><code id="table_neat_+3A_group_by">group_by</code></td>
<td>
<p>String, or vector of strings: the name(s) of the column(s) in
the <code>dat</code> given data frame, containing the vector(s) of factors by
which the statistics are grouped. (Overwrites <code>group_by</code> in
<code><a href="#topic+aggr_neat">aggr_neat</a></code>; see Details.)</p>
</td></tr>
<tr><td><code id="table_neat_+3A_group_per">group_per</code></td>
<td>
<p>String, &quot;rows&quot; or &quot;columns&quot;. If set to &quot;columns&quot; (or just
&quot;c&quot; or &quot;col&quot;, etc.), each column contains statistics for one group.
Otherwise (default), each row contains statistics for one group.</p>
</td></tr>
<tr><td><code id="table_neat_+3A_to_clipboard">to_clipboard</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the table is copied to the
clipboard (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="table_neat_+3A_method">method</code></td>
<td>
<p>Function or string; overwrites the <code>method</code> argument in
<code><a href="#topic+aggr_neat">aggr_neat</a></code> when used within this function. See <code>method</code>
in the <code><a href="#topic+aggr_neat">aggr_neat</a></code> function for details. Default value:
<code>"mean+sd"</code> (to calculate means and standard deviations table).</p>
</td></tr>
<tr><td><code id="table_neat_+3A_transpose">transpose</code></td>
<td>
<p>Logical (default: <code>FALSE</code>) or string. If <code>TRUE</code> or
string, ignores all other parameters (except <code>values_list</code>), but
merges all values from given list of data frames (as returned from the
<code><a href="#topic+aggr_neat">aggr_neat</a></code>) and transposes them into a single row, using, by
default, the <code>"aggr_group"</code> column values for new headers
(corresponding to the output of <code><a href="#topic+aggr_neat">aggr_neat</a></code>; see Examples).
However, a string given as argument for the <code>transpose</code> parameter can
also specify a custom column name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>values</code>, <code>round_to</code>, and <code>new_name</code> arguments
given in the <code><a href="#topic+aggr_neat">aggr_neat</a></code> function are always applied. However,
the <code>prefix</code> parameter will be overwritten as <code>NULL</code>. If
<code>new_name</code> in <code><a href="#topic+aggr_neat">aggr_neat</a></code> is <code>NULL</code>, the given input
variable names will be used instead of <code>"aggr_value"</code>. Furthermore,
the <code>group_by</code> or <code>method</code> given in the <code><a href="#topic+aggr_neat">aggr_neat</a></code>
function are only applied when no arguments are given in the
<code><a href="#topic+table_neat">table_neat</a></code> function for the identical parameters
(<code>group_by</code> or <code>medians</code>). If either parameter is given in the
<code><a href="#topic+table_neat">table_neat</a></code> function, all separately given respective
argument(s) in the <code><a href="#topic+aggr_neat">aggr_neat</a></code> function(s) are ignored.
</p>


<h3>Value</h3>

<p>Returns a data frame with means or medians and SDs per variable and
per group.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggr_neat">aggr_neat</a></code> for more related details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mtcars") # load base R example dataset

# overall means and SDs table for disp (Displacement) and hp (Gross horsepower)
table_neat(list(aggr_neat(mtcars, disp),
                aggr_neat(mtcars, hp)))

# means and SDs table for mpg (Miles/(US) gallon), wt (Weight), and hp (Gross horsepower)
# grouped by cyl (Number of cylinders)
# each measure rounded to respective optimal number of digits
# wt renamed to weight (for the column title)
table_neat(list(
    aggr_neat(mtcars, mpg, round_to = 1),
    aggr_neat(mtcars, wt, new_name = 'weight', round_to = 2),
    aggr_neat(mtcars, hp, round_to = 0)
),
group_by = 'cyl')

# same as above, but with medians, and with groups per columns
table_neat(
    list(
        aggr_neat(mtcars, mpg, round_to = 1),
        aggr_neat(mtcars, wt, new_name = 'weight', round_to = 2),
        aggr_neat(mtcars, hp, round_to = 0)
    ),
    group_by = 'cyl',
    method = 'median+sd',
    group_per = 'columns'
)

# an extensive example to show how to collect and aggregate raw data is
# available via the README file at the repository:
# https://github.com/gasparl/neatstats

</code></pre>

<hr>
<h2 id='var_tests'>Variance Equality Tests</h2><span id='topic+var_tests'></span>

<h3>Description</h3>

<p>Displayed sample sizes and SDs and performs Brown-Forsythe and
Fligner-Killeen variance equality tests (tests of homogeneity of variances)
per group combinations. This is primarily a subfunction of
<code><a href="#topic+anova_neat">anova_neat</a></code>, but here it is available separately for other
potential purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_tests(xvar, group_by, dat = NULL, hush = FALSE, sep = ", ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_tests_+3A_xvar">xvar</code></td>
<td>
<p>Either a numeric vector (numbers of any given variable), or, if
<code>dat</code> is given, a column name specifying the variable in the given data
frame.</p>
</td></tr>
<tr><td><code id="var_tests_+3A_group_by">group_by</code></td>
<td>
<p>Either a vector of factors with which to group the <code>xvar</code>
values, or, if <code>dat</code> is given, one or more column names specifying the
columns in the given data frame.</p>
</td></tr>
<tr><td><code id="var_tests_+3A_dat">dat</code></td>
<td>
<p>Either <code>NULL</code> or a data frame from which the respective column
names should be selected for <code>xvar</code> and <code>group</code>.</p>
</td></tr>
<tr><td><code id="var_tests_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing any details to console.</p>
</td></tr>
<tr><td><code id="var_tests_+3A_sep">sep</code></td>
<td>
<p>String (underscore <code>"_"</code> by default) for separating group
names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints test results.
</p>


<h3>Note</h3>

<p>Brown-Forsythe test (i.e., Levene's test using medians) is calculated via
<code><a href="car.html#topic+leveneTest">car::leveneTest</a></code>. Fligner-Killeen test, which may
be more robust (i.e., less affected by non-normal distribution), is calculated
via <code><a href="stats.html#topic+fligner.test">stats::fligner.test</a></code>. (See also Conover
et al., 1981, p. 360.)
</p>


<h3>References</h3>

<p>Brown, M. B. &amp; Forsythe, A. B. (1974). Robust tests for the equality of
variances. Journal of the American Statistical Association, 69, pp. 364-367.
</p>
<p>Conover W. J., Johnson M. E., &amp; Johnson M. M. (1981). A comparative study of
tests for homogeneity of variances, with applications to the outer continental
shelf bidding data. Technometrics, 23, 351–361.
</p>
<p>Fligner, M. A. &amp; Killeen, T. J. (1976). Distribution-free two-sample tests for
scale. ‘Journal of the American Statistical Association. 71(353), 210-213.
</p>
<p>Fox, J. &amp; Weisberg, S. (2019) An R Companion to Applied Regression, Third
Edition, Sage.
</p>
<p>Levene, H. (1960). Robust tests for equality of variances. In I. Olkin, H.
Hotelling, et al. (eds.). Contributions to Probability and Statistics: Essays
in Honor of Harold Hotelling. Stanford University Press. pp. 278–292.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova_neat">anova_neat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("ToothGrowth") # load base R example dataset

# the statistics of the four functions below should match
var_tests(ToothGrowth$len, ToothGrowth$supp)
var_tests('len', 'supp', ToothGrowth)
car::leveneTest(len ~ supp, data = ToothGrowth)
stats::fligner.test(len ~ supp, ToothGrowth)

# again the results below should match each other
var_tests(ToothGrowth$len,
          interaction(ToothGrowth$supp, ToothGrowth$dose))
var_tests('len', c('supp', 'dose'), ToothGrowth)
car::leveneTest(len ~ supp * as.factor(dose), data = ToothGrowth)
stats::fligner.test(len ~ interaction(supp, dose), ToothGrowth)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
