<!DOCTYPE html><html lang="en-GB"><head><title>Help for package clustree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clustree-package'><p>Clustree</p></a></li>
<li><a href='#add_node_labels'><p>Add node labels</p></a></li>
<li><a href='#add_node_points'><p>Add node points</p></a></li>
<li><a href='#aggr_metadata'><p>Aggregate metadata</p></a></li>
<li><a href='#assert_colour_node_aes'><p>Assert colour node aesthetics</p></a></li>
<li><a href='#assert_node_aes'><p>Assert node aesthetics</p></a></li>
<li><a href='#assert_numeric_node_aes'><p>Assert numeric node aesthetics</p></a></li>
<li><a href='#build_tree_graph'><p>Build tree graph</p></a></li>
<li><a href='#calc_sc3_stability'><p>Calculate SC3 stability</p></a></li>
<li><a href='#calc_sc3_stability_cluster'><p>Calculate single SC3 stability</p></a></li>
<li><a href='#check_node_aes_list'><p>Check node aes list</p></a></li>
<li><a href='#clustree'><p>Plot a clustering tree</p></a></li>
<li><a href='#clustree_overlay'><p>Overlay a clustering tree</p></a></li>
<li><a href='#get_tree_edges'><p>Get tree edges</p></a></li>
<li><a href='#get_tree_nodes'><p>Get tree nodes</p></a></li>
<li><a href='#nba_clusts'><p>Clustered NBA positions dataset</p></a></li>
<li><a href='#overlay_node_points'><p>Overlay node points</p></a></li>
<li><a href='#plot_overlay_side'><p>Plot overlay side</p></a></li>
<li><a href='#sc_example'><p>Simulated scRNA-seq dataset</p></a></li>
<li><a href='#store_node_aes'><p>Store node aesthetics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualise Clusterings at Different Resolutions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Zappia &lt;luke@lazappi.id.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Deciding what resolution to use can be a difficult question when
    approaching a clustering analysis. One way to approach this problem is to
    look at how samples move as the number of clusters increases. This package
    allows you to produce clustering trees, a visualisation for interrogating
    clusterings as resolution increases.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lazappi/clustree">https://github.com/lazappi/clustree</a>,
<a href="https://lazappi.github.io/clustree/">https://lazappi.github.io/clustree/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lazappi/clustree/issues">https://github.com/lazappi/clustree/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), ggraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, igraph, dplyr, grid, ggplot2 (&ge; 3.4.0), viridis,
methods, rlang, tidygraph, ggrepel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, SingleCellExperiment,
Seurat (&ge; 2.3.0), covr, SummarizedExperiment, pkgdown,
spelling</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-05 18:40:36 UTC; luke.zappia</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Zappia <a href="https://orcid.org/0000-0001-7744-8565"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Alicia Oshlack <a href="https://orcid.org/0000-0001-9788-5690"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Andrea Rau [ctb],
  Paul Hoffman <a href="https://orcid.org/0000-0002-7693-8957"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-05 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clustree-package'>Clustree</h2><span id='topic+clustree-package'></span>

<h3>Description</h3>

<p>Deciding what resolution to use can be a difficult question when
approaching a clustering analysis. One way to approach this problem is to
look at how samples move as the number of clusters increases. This package
allows you to produce clustering trees, a visualisation for interrogating
clusterings as resolution increases.
</p>

<hr>
<h2 id='add_node_labels'>Add node labels</h2><span id='topic+add_node_labels'></span>

<h3>Description</h3>

<p>Add node labels to a clustering tree plot with the specified aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_node_labels(
  node_label,
  node_colour,
  node_label_size,
  node_label_colour,
  node_label_nudge,
  allowed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_node_labels_+3A_node_label">node_label</code></td>
<td>
<p>the name of a metadata column for node labels</p>
</td></tr>
<tr><td><code id="add_node_labels_+3A_node_colour">node_colour</code></td>
<td>
<p>either a value indicating a colour to use for all nodes or
the name of a metadata column to colour nodes by</p>
</td></tr>
<tr><td><code id="add_node_labels_+3A_node_label_size">node_label_size</code></td>
<td>
<p>size of node label text</p>
</td></tr>
<tr><td><code id="add_node_labels_+3A_node_label_colour">node_label_colour</code></td>
<td>
<p>colour of node_label text</p>
</td></tr>
<tr><td><code id="add_node_labels_+3A_node_label_nudge">node_label_nudge</code></td>
<td>
<p>numeric value giving nudge in y direction for node
labels</p>
</td></tr>
<tr><td><code id="add_node_labels_+3A_allowed">allowed</code></td>
<td>
<p>vector of allowed node attributes to use as aesthetics</p>
</td></tr>
</table>

<hr>
<h2 id='add_node_points'>Add node points</h2><span id='topic+add_node_points'></span>

<h3>Description</h3>

<p>Add node points to a clustering tree plot with the specified aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_node_points(node_colour, node_size, node_alpha, allowed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_node_points_+3A_node_colour">node_colour</code></td>
<td>
<p>either a value indicating a colour to use for all nodes or
the name of a metadata column to colour nodes by</p>
</td></tr>
<tr><td><code id="add_node_points_+3A_node_size">node_size</code></td>
<td>
<p>either a numeric value giving the size of all nodes or the
name of a metadata column to use for node sizes</p>
</td></tr>
<tr><td><code id="add_node_points_+3A_node_alpha">node_alpha</code></td>
<td>
<p>either a numeric value giving the alpha of all nodes or the
name of a metadata column to use for node transparency</p>
</td></tr>
<tr><td><code id="add_node_points_+3A_allowed">allowed</code></td>
<td>
<p>vector of allowed node attributes to use as aesthetics</p>
</td></tr>
</table>

<hr>
<h2 id='aggr_metadata'>Aggregate metadata</h2><span id='topic+aggr_metadata'></span>

<h3>Description</h3>

<p>Aggregate a metadata column to get a summarized value for a cluster node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggr_metadata(node_data, col_name, col_aggr, metadata, is_cluster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggr_metadata_+3A_node_data">node_data</code></td>
<td>
<p>data.frame containing information about a set of cluster
nodes</p>
</td></tr>
<tr><td><code id="aggr_metadata_+3A_col_name">col_name</code></td>
<td>
<p>the name of the metadata column to aggregate</p>
</td></tr>
<tr><td><code id="aggr_metadata_+3A_col_aggr">col_aggr</code></td>
<td>
<p>string naming a function used to aggregate the column</p>
</td></tr>
<tr><td><code id="aggr_metadata_+3A_metadata">metadata</code></td>
<td>
<p>data.frame providing metadata on samples</p>
</td></tr>
<tr><td><code id="aggr_metadata_+3A_is_cluster">is_cluster</code></td>
<td>
<p>logical vector indicating which rows of metadata are in the
node to be summarized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with aggregated data
</p>

<hr>
<h2 id='assert_colour_node_aes'>Assert colour node aesthetics</h2><span id='topic+assert_colour_node_aes'></span>

<h3>Description</h3>

<p>Raise error if an incorrect set of colour node parameters has been supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_colour_node_aes(
  node_aes_name,
  prefix,
  metadata,
  node_aes,
  node_aes_aggr,
  min,
  max
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_colour_node_aes_+3A_node_aes_name">node_aes_name</code></td>
<td>
<p>name of the node aesthetic to check</p>
</td></tr>
<tr><td><code id="assert_colour_node_aes_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
<tr><td><code id="assert_colour_node_aes_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing metadata on each sample that can be
used as node aesthetics</p>
</td></tr>
<tr><td><code id="assert_colour_node_aes_+3A_node_aes">node_aes</code></td>
<td>
<p>value of the node aesthetic to check</p>
</td></tr>
<tr><td><code id="assert_colour_node_aes_+3A_node_aes_aggr">node_aes_aggr</code></td>
<td>
<p>aggregation function associated with the node aesthetic</p>
</td></tr>
<tr><td><code id="assert_colour_node_aes_+3A_min">min</code></td>
<td>
<p>minimum numeric value allowed</p>
</td></tr>
<tr><td><code id="assert_colour_node_aes_+3A_max">max</code></td>
<td>
<p>maximum numeric value allowed</p>
</td></tr>
</table>

<hr>
<h2 id='assert_node_aes'>Assert node aesthetics</h2><span id='topic+assert_node_aes'></span>

<h3>Description</h3>

<p>Raise error if an incorrect set of node parameters has been supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_node_aes(node_aes_name, prefix, metadata, node_aes, node_aes_aggr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_node_aes_+3A_node_aes_name">node_aes_name</code></td>
<td>
<p>name of the node aesthetic to check</p>
</td></tr>
<tr><td><code id="assert_node_aes_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
<tr><td><code id="assert_node_aes_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing metadata on each sample that can be
used as node aesthetics</p>
</td></tr>
<tr><td><code id="assert_node_aes_+3A_node_aes">node_aes</code></td>
<td>
<p>value of the node aesthetic to check</p>
</td></tr>
<tr><td><code id="assert_node_aes_+3A_node_aes_aggr">node_aes_aggr</code></td>
<td>
<p>aggregation function associated with the node aesthetic</p>
</td></tr>
</table>

<hr>
<h2 id='assert_numeric_node_aes'>Assert numeric node aesthetics</h2><span id='topic+assert_numeric_node_aes'></span>

<h3>Description</h3>

<p>Raise error if an incorrect set of numeric node parameters has been supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_numeric_node_aes(
  node_aes_name,
  prefix,
  metadata,
  node_aes,
  node_aes_aggr,
  min,
  max
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_numeric_node_aes_+3A_node_aes_name">node_aes_name</code></td>
<td>
<p>name of the node aesthetic to check</p>
</td></tr>
<tr><td><code id="assert_numeric_node_aes_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
<tr><td><code id="assert_numeric_node_aes_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing metadata on each sample that can be
used as node aesthetics</p>
</td></tr>
<tr><td><code id="assert_numeric_node_aes_+3A_node_aes">node_aes</code></td>
<td>
<p>value of the node aesthetic to check</p>
</td></tr>
<tr><td><code id="assert_numeric_node_aes_+3A_node_aes_aggr">node_aes_aggr</code></td>
<td>
<p>aggregation function associated with the node aesthetic</p>
</td></tr>
<tr><td><code id="assert_numeric_node_aes_+3A_min">min</code></td>
<td>
<p>minimum numeric value allowed</p>
</td></tr>
<tr><td><code id="assert_numeric_node_aes_+3A_max">max</code></td>
<td>
<p>maximum numeric value allowed</p>
</td></tr>
</table>

<hr>
<h2 id='build_tree_graph'>Build tree graph</h2><span id='topic+build_tree_graph'></span>

<h3>Description</h3>

<p>Build a tree graph from a set of clusterings, metadata and associated
aesthetics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tree_graph(
  clusterings,
  prefix,
  count_filter,
  prop_filter,
  metadata,
  node_aes_list
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_tree_graph_+3A_clusterings">clusterings</code></td>
<td>
<p>numeric matrix containing clustering information, each
column contains clustering at a separate resolution</p>
</td></tr>
<tr><td><code id="build_tree_graph_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
<tr><td><code id="build_tree_graph_+3A_count_filter">count_filter</code></td>
<td>
<p>count threshold for filtering edges in the clustering
graph</p>
</td></tr>
<tr><td><code id="build_tree_graph_+3A_prop_filter">prop_filter</code></td>
<td>
<p>in proportion threshold for filtering edges in the
clustering graph</p>
</td></tr>
<tr><td><code id="build_tree_graph_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing metadata on each sample that can be
used as node aesthetics</p>
</td></tr>
<tr><td><code id="build_tree_graph_+3A_node_aes_list">node_aes_list</code></td>
<td>
<p>nested list containing node aesthetics</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="tidygraph.html#topic+tbl_graph">tidygraph::tbl_graph</a> object containing the tree graph
</p>

<hr>
<h2 id='calc_sc3_stability'>Calculate SC3 stability</h2><span id='topic+calc_sc3_stability'></span>

<h3>Description</h3>

<p>Calculate the SC3 stability index for every cluster at every resolution in a
set of clusterings. The index varies from 0 to 1, where 1 suggests that a
cluster is more stable across resolutions. See <code><a href="#topic+calc_sc3_stability_cluster">calc_sc3_stability_cluster()</a></code>
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sc3_stability(clusterings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_sc3_stability_+3A_clusterings">clusterings</code></td>
<td>
<p>numeric matrix containing clustering information, each
column contains clustering at a separate resolution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with stability score for each cluster
</p>

<hr>
<h2 id='calc_sc3_stability_cluster'>Calculate single SC3 stability</h2><span id='topic+calc_sc3_stability_cluster'></span>

<h3>Description</h3>

<p>Calculate the SC3 stability index for a single cluster in a set of
clusterings. The index varies from 0 to 1, where 1 suggests that a cluster is
more stable across resolutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sc3_stability_cluster(clusterings, res, cluster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_sc3_stability_cluster_+3A_clusterings">clusterings</code></td>
<td>
<p>numeric matrix containing clustering information, each
column contains clustering at a separate resolution</p>
</td></tr>
<tr><td><code id="calc_sc3_stability_cluster_+3A_res">res</code></td>
<td>
<p>resolution of the cluster to calculate stability for</p>
</td></tr>
<tr><td><code id="calc_sc3_stability_cluster_+3A_cluster">cluster</code></td>
<td>
<p>index of the cluster to calculate stability for</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This index was originally introduced in the <code>SC3</code> package for clustering
single-cell RNA-seq data. Clusters are awarded increased stability if they
share the same samples as a cluster at another resolution and penalised at
higher resolutions. We use a slightly different notation to describe the
score but the results are the same:
</p>
<p style="text-align: center;"><code class="reqn">
  s(c_{k, i}) =
  \frac{1}{size(L) + 1}
  \sum_{l \in L}
    \sum_{j \in N_l}
      \frac{size(c_{k, i} \cap c_{l, j})}{size(c_{l, j}) * size(N_l) ^ 2}
</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;c_{x, y}&#8288;</code> is cluster <code>y</code> at resolution <code>x</code>
</p>
</li>
<li> <p><code>k</code> is the resolution of the cluster we want to score
</p>
</li>
<li> <p><code>i</code> is the index of the cluster we want to score
</p>
</li>
<li> <p><code>L</code> is the set of all resolutions except <code>k</code>
</p>
</li>
<li> <p><code>l</code> is a resolution in <code>L</code>
</p>
</li>
<li> <p><code>N_l</code> is the set of clusters at resolution <code>l</code> that share samples with
<code style="white-space: pre;">&#8288;c_{k, i}&#8288;</code>
</p>
</li>
<li> <p><code>j</code> is a cluster in <code>N_l</code>
</p>
</li></ul>



<h3>Value</h3>

<p>SC3 stability index
</p>


<h3>See Also</h3>

<p>The documentation for the <code>calculate_stability</code> function in the
SC3 package
</p>

<hr>
<h2 id='check_node_aes_list'>Check node aes list</h2><span id='topic+check_node_aes_list'></span>

<h3>Description</h3>

<p>Warn if node aesthetic names are incorrect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_node_aes_list(node_aes_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_node_aes_list_+3A_node_aes_list">node_aes_list</code></td>
<td>
<p>List of node aesthetics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corrected node aesthetics list
</p>

<hr>
<h2 id='clustree'>Plot a clustering tree</h2><span id='topic+clustree'></span><span id='topic+clustree.matrix'></span><span id='topic+clustree.data.frame'></span><span id='topic+clustree.SingleCellExperiment'></span><span id='topic+clustree.seurat'></span><span id='topic+clustree.Seurat'></span>

<h3>Description</h3>

<p>Creates a plot of a clustering tree showing the relationship between
clusterings at different resolutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustree(x, ...)

## S3 method for class 'matrix'
clustree(
  x,
  prefix,
  suffix = NULL,
  metadata = NULL,
  count_filter = 0,
  prop_filter = 0.1,
  layout = c("tree", "sugiyama"),
  use_core_edges = TRUE,
  highlight_core = FALSE,
  node_colour = prefix,
  node_colour_aggr = NULL,
  node_size = "size",
  node_size_aggr = NULL,
  node_size_range = c(4, 15),
  node_alpha = 1,
  node_alpha_aggr = NULL,
  node_text_size = 3,
  scale_node_text = FALSE,
  node_text_colour = "black",
  node_text_angle = 0,
  node_label = NULL,
  node_label_aggr = NULL,
  node_label_size = 3,
  node_label_nudge = -0.2,
  edge_width = 1.5,
  edge_arrow = TRUE,
  edge_arrow_ends = c("last", "first", "both"),
  show_axis = FALSE,
  return = c("plot", "graph", "layout"),
  ...
)

## S3 method for class 'data.frame'
clustree(x, prefix, ...)

## S3 method for class 'SingleCellExperiment'
clustree(x, prefix, exprs = "counts", ...)

## S3 method for class 'seurat'
clustree(x, prefix = "res.", exprs = c("data", "raw.data", "scale.data"), ...)

## S3 method for class 'Seurat'
clustree(
  x,
  prefix = paste0(assay, "_snn_res."),
  exprs = c("data", "counts", "scale.data"),
  assay = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustree_+3A_x">x</code></td>
<td>
<p>object containing clustering data</p>
</td></tr>
<tr><td><code id="clustree_+3A_...">...</code></td>
<td>
<p>extra parameters passed to other methods</p>
</td></tr>
<tr><td><code id="clustree_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
<tr><td><code id="clustree_+3A_suffix">suffix</code></td>
<td>
<p>string at the end of column names containing clustering
information</p>
</td></tr>
<tr><td><code id="clustree_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing metadata on each sample that can be
used as node aesthetics</p>
</td></tr>
<tr><td><code id="clustree_+3A_count_filter">count_filter</code></td>
<td>
<p>count threshold for filtering edges in the clustering
graph</p>
</td></tr>
<tr><td><code id="clustree_+3A_prop_filter">prop_filter</code></td>
<td>
<p>in proportion threshold for filtering edges in the
clustering graph</p>
</td></tr>
<tr><td><code id="clustree_+3A_layout">layout</code></td>
<td>
<p>string specifying the &quot;tree&quot; or &quot;sugiyama&quot; layout, see
<code><a href="igraph.html#topic+layout_as_tree">igraph::layout_as_tree()</a></code> and <code><a href="igraph.html#topic+layout_with_sugiyama">igraph::layout_with_sugiyama()</a></code> for details</p>
</td></tr>
<tr><td><code id="clustree_+3A_use_core_edges">use_core_edges</code></td>
<td>
<p>logical, whether to only use core tree (edges with
maximum in proportion for a node) when creating the graph layout, all
(unfiltered) edges will still be displayed</p>
</td></tr>
<tr><td><code id="clustree_+3A_highlight_core">highlight_core</code></td>
<td>
<p>logical, whether to increase the edge width of the core
network to make it easier to see</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_colour">node_colour</code></td>
<td>
<p>either a value indicating a colour to use for all nodes or
the name of a metadata column to colour nodes by</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_colour_aggr">node_colour_aggr</code></td>
<td>
<p>if <code>node_colour</code> is a column name than a string
giving the name of a function to aggregate that column for samples in each
cluster</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_size">node_size</code></td>
<td>
<p>either a numeric value giving the size of all nodes or the
name of a metadata column to use for node sizes</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_size_aggr">node_size_aggr</code></td>
<td>
<p>if <code>node_size</code> is a column name than a string
giving the name of a function to aggregate that column for samples in each
cluster</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_size_range">node_size_range</code></td>
<td>
<p>numeric vector of length two giving the maximum and
minimum point size for plotting nodes</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_alpha">node_alpha</code></td>
<td>
<p>either a numeric value giving the alpha of all nodes or the
name of a metadata column to use for node transparency</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_alpha_aggr">node_alpha_aggr</code></td>
<td>
<p>if <code>node_aggr</code> is a column name than a string
giving the name of a function to aggregate that column for samples in each
cluster</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_text_size">node_text_size</code></td>
<td>
<p>numeric value giving the size of node text if
<code>scale_node_text</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="clustree_+3A_scale_node_text">scale_node_text</code></td>
<td>
<p>logical indicating whether to scale node text along
with the node size</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_text_colour">node_text_colour</code></td>
<td>
<p>colour value for node text (and label)</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_text_angle">node_text_angle</code></td>
<td>
<p>the rotation of the node text</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_label">node_label</code></td>
<td>
<p>additional label to add to nodes</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_label_aggr">node_label_aggr</code></td>
<td>
<p>if <code>node_label</code> is a column name than a string
giving the name of a function to aggregate that column for samples in each
cluster</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_label_size">node_label_size</code></td>
<td>
<p>numeric value giving the size of node label text</p>
</td></tr>
<tr><td><code id="clustree_+3A_node_label_nudge">node_label_nudge</code></td>
<td>
<p>numeric value giving nudge in y direction for node
labels</p>
</td></tr>
<tr><td><code id="clustree_+3A_edge_width">edge_width</code></td>
<td>
<p>numeric value giving the width of plotted edges</p>
</td></tr>
<tr><td><code id="clustree_+3A_edge_arrow">edge_arrow</code></td>
<td>
<p>logical indicating whether to add an arrow to edges</p>
</td></tr>
<tr><td><code id="clustree_+3A_edge_arrow_ends">edge_arrow_ends</code></td>
<td>
<p>string indicating which ends of the line to draw arrow
heads if <code>edge_arrow</code> is <code>TRUE</code>, one of &quot;last&quot;, &quot;first&quot;, or &quot;both&quot;</p>
</td></tr>
<tr><td><code id="clustree_+3A_show_axis">show_axis</code></td>
<td>
<p>whether to show resolution axis</p>
</td></tr>
<tr><td><code id="clustree_+3A_return">return</code></td>
<td>
<p>string specifying what to return, either &quot;plot&quot; (a <code>ggplot</code>
object), &quot;graph&quot; (a <code>tbl_graph</code> object) or &quot;layout&quot; (a <code>ggraph</code> layout
object)</p>
</td></tr>
<tr><td><code id="clustree_+3A_exprs">exprs</code></td>
<td>
<p>source of gene expression information to use as node aesthetics,
for <code>SingleCellExperiment</code> objects it must be a name in <code>assayNames(x)</code>, for
a <code>seurat</code> object it must be one of <code>data</code>, <code>raw.data</code> or <code>scale.data</code> and
for a <code>Seurat</code> object it must be one of <code>data</code>, <code>counts</code> or <code>scale.data</code></p>
</td></tr>
<tr><td><code id="clustree_+3A_assay">assay</code></td>
<td>
<p>name of assay to pull expression and clustering data from for
<code>Seurat</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Data sources</strong>
</p>
<p>Plotting a clustering tree requires information about which cluster each
sample has been assigned to at different resolutions. This information can
be supplied in various forms, as a matrix, data.frame or more specialised
object. In all cases the object provided must contain numeric columns with
the naming structure <code>PXS</code> where <code>P</code> is a prefix indicating that the column
contains clustering information, <code>X</code> is a numeric value indicating the
clustering resolution and <code>S</code> is any additional suffix to be removed. For
<code>SingleCellExperiment</code> objects this information must be in the <code>colData</code> slot
and for <code>Seurat</code> objects it must be in the <code>meta.data</code> slot. For all objects
except matrices any additional columns can be used as aesthetics, for
matrices an additional metadata data.frame can be supplied if required.
</p>
<p><strong>Filtering</strong>
</p>
<p>Edges in the graph can be filtered by adjusting the <code>count_filter</code> and
<code>prop_filter</code> parameters. The <code>count_filter</code> removes any edges that represent
less than that number of samples, while the <code>prop_filter</code> removes edges that
represent less than that proportion of cells in the node it points towards.
</p>
<p><strong>Node aesthetics</strong>
</p>
<p>The aesthetics of the plotted nodes can be controlled in various ways. By
default the colour indicates the clustering resolution, the size indicates
the number of samples in that cluster and the transparency is set to 100%.
Each of these can be set to a specific value or linked to a supplied metadata
column. For a <code>SingleCellExperiment</code> or <code>Seurat</code> object the names of genes
can also be used. If a metadata column is used than an aggregation function
must also be supplied to combine the samples in each cluster. This function
must take a vector of values and return a single value.
</p>
<p><strong>Layout</strong>
</p>
<p>The clustering tree can be displayed using either the Reingold-Tilford tree
layout algorithm or the Sugiyama layout algorithm for layered directed
acyclic graphs. These layouts were selected as the are the algorithms
available in the <code>igraph</code> package designed for trees. The Reingold-Tilford
algorithm places children below their parents while the Sugiyama places
nodes in layers while trying to minimise the number of crossing edges. See
<code><a href="igraph.html#topic+layout_as_tree">igraph::layout_as_tree()</a></code> and <code><a href="igraph.html#topic+layout_with_sugiyama">igraph::layout_with_sugiyama()</a></code> for more
details. When <code>use_core_edges</code> is <code>TRUE</code> (default) only the core tree of the
maximum in proportion edges for each node are used for constructing the
layout. This can often lead to more attractive layouts where the core tree is
more visible.
</p>


<h3>Value</h3>

<p>a <code>ggplot</code> object (default), a <code>tbl_graph</code> object or a <code>ggraph</code>
layout object depending on the value of <code>return</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nba_clusts)
clustree(nba_clusts, prefix = "K")

</code></pre>

<hr>
<h2 id='clustree_overlay'>Overlay a clustering tree</h2><span id='topic+clustree_overlay'></span><span id='topic+clustree_overlay.matrix'></span><span id='topic+clustree_overlay.data.frame'></span><span id='topic+clustree_overlay.SingleCellExperiment'></span><span id='topic+clustree_overlay.seurat'></span><span id='topic+clustree_overlay.Seurat'></span>

<h3>Description</h3>

<p>Creates a plot of a clustering tree overlaid on a scatter plot of individual
samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustree_overlay(x, ...)

## S3 method for class 'matrix'
clustree_overlay(
  x,
  prefix,
  metadata,
  x_value,
  y_value,
  suffix = NULL,
  count_filter = 0,
  prop_filter = 0.1,
  node_colour = prefix,
  node_colour_aggr = NULL,
  node_size = "size",
  node_size_aggr = NULL,
  node_size_range = c(4, 15),
  node_alpha = 1,
  node_alpha_aggr = NULL,
  edge_width = 1,
  use_colour = c("edges", "points"),
  alt_colour = "black",
  point_size = 3,
  point_alpha = 0.2,
  point_shape = 18,
  label_nodes = FALSE,
  label_size = 3,
  plot_sides = FALSE,
  side_point_jitter = 0.45,
  side_point_offset = 1,
  ...
)

## S3 method for class 'data.frame'
clustree_overlay(x, prefix, ...)

## S3 method for class 'SingleCellExperiment'
clustree_overlay(
  x,
  prefix,
  x_value,
  y_value,
  exprs = "counts",
  red_dim = NULL,
  ...
)

## S3 method for class 'seurat'
clustree_overlay(
  x,
  x_value,
  y_value,
  prefix = "res.",
  exprs = c("data", "raw.data", "scale.data"),
  red_dim = NULL,
  ...
)

## S3 method for class 'Seurat'
clustree_overlay(
  x,
  x_value,
  y_value,
  prefix = paste0(assay, "_snn_res."),
  exprs = c("data", "counts", "scale.data"),
  red_dim = NULL,
  assay = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustree_overlay_+3A_x">x</code></td>
<td>
<p>object containing clustering data</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_...">...</code></td>
<td>
<p>extra parameters passed to other methods</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing metadata on each sample that can be
used as node aesthetics</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_x_value">x_value</code></td>
<td>
<p>numeric metadata column to use as the x axis</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_y_value">y_value</code></td>
<td>
<p>numeric metadata column to use as the y axis</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_suffix">suffix</code></td>
<td>
<p>string at the end of column names containing clustering
information</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_count_filter">count_filter</code></td>
<td>
<p>count threshold for filtering edges in the clustering
graph</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_prop_filter">prop_filter</code></td>
<td>
<p>in proportion threshold for filtering edges in the
clustering graph</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_node_colour">node_colour</code></td>
<td>
<p>either a value indicating a colour to use for all nodes or
the name of a metadata column to colour nodes by</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_node_colour_aggr">node_colour_aggr</code></td>
<td>
<p>if <code>node_colour</code> is a column name than a string
giving the name of a function to aggregate that column for samples in each
cluster</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_node_size">node_size</code></td>
<td>
<p>either a numeric value giving the size of all nodes or the
name of a metadata column to use for node sizes</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_node_size_aggr">node_size_aggr</code></td>
<td>
<p>if <code>node_size</code> is a column name than a string
giving the name of a function to aggregate that column for samples in each
cluster</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_node_size_range">node_size_range</code></td>
<td>
<p>numeric vector of length two giving the maximum and
minimum point size for plotting nodes</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_node_alpha">node_alpha</code></td>
<td>
<p>either a numeric value giving the alpha of all nodes or the
name of a metadata column to use for node transparency</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_node_alpha_aggr">node_alpha_aggr</code></td>
<td>
<p>if <code>node_aggr</code> is a column name than a string
giving the name of a function to aggregate that column for samples in each
cluster</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_edge_width">edge_width</code></td>
<td>
<p>numeric value giving the width of plotted edges</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_use_colour">use_colour</code></td>
<td>
<p>one of &quot;edges&quot; or &quot;points&quot; specifying which element to
apply the colour aesthetic to</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_alt_colour">alt_colour</code></td>
<td>
<p>colour value to be used for edges or points (whichever is
NOT given by <code>use_colour</code>)</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_point_size">point_size</code></td>
<td>
<p>numeric value giving the size of sample points</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_point_alpha">point_alpha</code></td>
<td>
<p>numeric value giving the alpha of sample points</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_point_shape">point_shape</code></td>
<td>
<p>numeric value giving the shape of sample points</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_label_nodes">label_nodes</code></td>
<td>
<p>logical value indicating whether to add labels to
clustering graph nodes</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_label_size">label_size</code></td>
<td>
<p>numeric value giving the size of node labels is
<code>label_nodes</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_plot_sides">plot_sides</code></td>
<td>
<p>logical value indicating whether to produce side on plots</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_side_point_jitter">side_point_jitter</code></td>
<td>
<p>numeric value giving the y-direction spread of
points in side plots</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_side_point_offset">side_point_offset</code></td>
<td>
<p>numeric value giving the y-direction offset for
points in side plots</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_exprs">exprs</code></td>
<td>
<p>source of gene expression information to use as node aesthetics,
for <code>SingleCellExperiment</code> objects it must be a name in <code>assayNames(x)</code>, for
a <code>seurat</code> object it must be one of <code>data</code>, <code>raw.data</code> or <code>scale.data</code> and
for a <code>Seurat</code> object it must be one of <code>data</code>, <code>counts</code> or <code>scale.data</code></p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_red_dim">red_dim</code></td>
<td>
<p>dimensionality reduction to use as a source for x_value and
y_value</p>
</td></tr>
<tr><td><code id="clustree_overlay_+3A_assay">assay</code></td>
<td>
<p>name of assay to pull expression and clustering data from for
<code>Seurat</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Data sources</strong>
</p>
<p>Plotting a clustering tree requires information about which cluster each
sample has been assigned to at different resolutions. This information can
be supplied in various forms, as a matrix, data.frame or more specialised
object. In all cases the object provided must contain numeric columns with
the naming structure <code>PXS</code> where <code>P</code> is a prefix indicating that the column
contains clustering information, <code>X</code> is a numeric value indicating the
clustering resolution and <code>S</code> is any additional suffix to be removed. For
<code>SingleCellExperiment</code> objects this information must be in the <code>colData</code> slot
and for <code>Seurat</code> objects it must be in the <code>meta.data</code> slot. For all objects
except matrices any additional columns can be used as aesthetics.
</p>
<p><strong>Filtering</strong>
</p>
<p>Edges in the graph can be filtered by adjusting the <code>count_filter</code> and
<code>prop_filter</code> parameters. The <code>count_filter</code> removes any edges that represent
less than that number of samples, while the <code>prop_filter</code> removes edges that
represent less than that proportion of cells in the node it points towards.
</p>
<p><strong>Node aesthetics</strong>
</p>
<p>The aesthetics of the plotted nodes can be controlled in various ways. By
default the colour indicates the clustering resolution, the size indicates
the number of samples in that cluster and the transparency is set to 100%.
Each of these can be set to a specific value or linked to a supplied metadata
column. For a <code>SingleCellExperiment</code> or <code>Seurat</code> object the names of genes
can also be used. If a metadata column is used than an aggregation function
must also be supplied to combine the samples in each cluster. This function
must take a vector of values and return a single value.
</p>
<p><strong>Colour aesthetic</strong>
</p>
<p>The colour aesthetic can be applied to either edges or sample points by
setting <code>use_colour</code>. If &quot;edges&quot; is selected edges will be coloured according
to the clustering resolution they originate at. If &quot;points&quot; is selected they
will be coloured according to the cluster they are assigned to at the highest
resolution.
</p>
<p><strong>Dimensionality reductions</strong>
</p>
<p>For <code>SingleCellExperiment</code> and <code>Seurat</code> objects precomputed dimensionality
reductions can be used for x or y aesthetics. To do so <code>red_dim</code> must be set
to the name of a dimensionality reduction in <code>reducedDimNames(x)</code> (for a
<code>SingleCellExperiment</code>) or <code>x@dr</code> (for a <code>Seurat</code> object). <code>x_value</code> and
<code>y_value</code> can then be set to <code>red_dimX</code> when <code>red_dim</code> matches the <code>red_dim</code>
argument and <code>X</code> is the column of the dimensionality reduction to use.
</p>


<h3>Value</h3>

<p>a <code>ggplot</code> object if <code>plot_sides</code> is <code>FALSE</code> or a list of <code>ggplot</code>
objects if <code>plot_sides</code> is <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nba_clusts)
clustree_overlay(nba_clusts, prefix = "K", x_value = "PC1", y_value = "PC2")

</code></pre>

<hr>
<h2 id='get_tree_edges'>Get tree edges</h2><span id='topic+get_tree_edges'></span>

<h3>Description</h3>

<p>Extract the edges from a set of clusterings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tree_edges(clusterings, prefix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_tree_edges_+3A_clusterings">clusterings</code></td>
<td>
<p>numeric matrix containing clustering information, each
column contains clustering at a separate resolution</p>
</td></tr>
<tr><td><code id="get_tree_edges_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing edge information
</p>

<hr>
<h2 id='get_tree_nodes'>Get tree nodes</h2><span id='topic+get_tree_nodes'></span>

<h3>Description</h3>

<p>Extract the nodes from a set of clusterings and add relevant attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tree_nodes(clusterings, prefix, metadata, node_aes_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_tree_nodes_+3A_clusterings">clusterings</code></td>
<td>
<p>numeric matrix containing clustering information, each
column contains clustering at a separate resolution</p>
</td></tr>
<tr><td><code id="get_tree_nodes_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
<tr><td><code id="get_tree_nodes_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing metadata on each sample that can be
used as node aesthetics</p>
</td></tr>
<tr><td><code id="get_tree_nodes_+3A_node_aes_list">node_aes_list</code></td>
<td>
<p>nested list containing node aesthetics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing node information
</p>

<hr>
<h2 id='nba_clusts'>Clustered NBA positions dataset</h2><span id='topic+nba_clusts'></span>

<h3>Description</h3>

<p>NBA positions dataset clustered using k-means with a range of values of <code>k</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nba_clusts
</code></pre>


<h3>Format</h3>

<p><code>nba_clusts</code> is a data.frame containing the NBA positions dataset
with additional columns holding k-means clusterings at different values of
<code>k</code> and the first two principal components
</p>

<ul>
<li> <p><strong>Position</strong> - Player position
</p>
</li>
<li> <p><strong>TurnoverPct</strong> - Turnover percentage
</p>
</li>
<li> <p><strong>ReboundPct</strong> - Rebound percentage
</p>
</li>
<li> <p><strong>AssistPct</strong> - Assist percentage
</p>
</li>
<li> <p><strong>FieldGoalPct</strong> - Field goal percentage
</p>
</li>
<li> <p><strong>K1 - K5</strong> - Results of k-means clustering
</p>
</li>
<li> <p><strong>PC1</strong> - First principal component
</p>
</li>
<li> <p><strong>PC2</strong> - Second principal component
</p>
</li></ul>



<h3>Source</h3>

<p>NBA positions downloaded from <a href="https://github.com/lazappi/nba_positions">https://github.com/lazappi/nba_positions</a>.
</p>
<p>The source dataset is available from Kaggle at
<a href="https://www.kaggle.com/drgilermo/nba-players-stats/data?select=Seasons_Stats.csv">https://www.kaggle.com/drgilermo/nba-players-stats/data?select=Seasons_Stats.csv</a>
and was originally scraped from <a href="https://www.basketball-reference.com/">Basketball Reference</a>.
</p>
<p>See <a href="https://github.com/lazappi/clustree/blob/master/data-raw/nba_clusts.R">https://github.com/lazappi/clustree/blob/master/data-raw/nba_clusts.R</a>
for details of how clustering was performed.
</p>

<hr>
<h2 id='overlay_node_points'>Overlay node points</h2><span id='topic+overlay_node_points'></span>

<h3>Description</h3>

<p>Overlay clustering tree nodes on a scatter plot with the specified
aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlay_node_points(
  nodes,
  x_value,
  y_value,
  node_colour,
  node_size,
  node_alpha
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overlay_node_points_+3A_nodes">nodes</code></td>
<td>
<p>data.frame describing nodes</p>
</td></tr>
<tr><td><code id="overlay_node_points_+3A_x_value">x_value</code></td>
<td>
<p>column of nodes to use for the x position</p>
</td></tr>
<tr><td><code id="overlay_node_points_+3A_y_value">y_value</code></td>
<td>
<p>column of nodes to use for the y position</p>
</td></tr>
<tr><td><code id="overlay_node_points_+3A_node_colour">node_colour</code></td>
<td>
<p>either a value indicating a colour to use for all nodes or
the name of a metadata column to colour nodes by</p>
</td></tr>
<tr><td><code id="overlay_node_points_+3A_node_size">node_size</code></td>
<td>
<p>either a numeric value giving the size of all nodes or the
name of a metadata column to use for node sizes</p>
</td></tr>
<tr><td><code id="overlay_node_points_+3A_node_alpha">node_alpha</code></td>
<td>
<p>either a numeric value giving the alpha of all nodes or the
name of a metadata column to use for node transparency</p>
</td></tr>
</table>

<hr>
<h2 id='plot_overlay_side'>Plot overlay side</h2><span id='topic+plot_overlay_side'></span>

<h3>Description</h3>

<p>Plot the side view of a clustree overlay plot. If the ordinary plot shows the
tree from above this plot shows it from the side, highlighting either the
x or y dimension and the clustering resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_overlay_side(
  nodes,
  edges,
  points,
  prefix,
  side_value,
  graph_attr,
  node_size_range,
  edge_width,
  use_colour,
  alt_colour,
  point_size,
  point_alpha,
  point_shape,
  label_nodes,
  label_size,
  y_jitter,
  y_offset
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_overlay_side_+3A_nodes">nodes</code></td>
<td>
<p>data.frame describing nodes</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_edges">edges</code></td>
<td>
<p>data.frame describing edges</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_points">points</code></td>
<td>
<p>data.frame describing points</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_prefix">prefix</code></td>
<td>
<p>string indicating columns containing clustering information</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_side_value">side_value</code></td>
<td>
<p>string giving the metadata column to use for the x axis</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_graph_attr">graph_attr</code></td>
<td>
<p>list describing graph attributes</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_node_size_range">node_size_range</code></td>
<td>
<p>numeric vector of length two giving the maximum and
minimum point size for plotting nodes</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_edge_width">edge_width</code></td>
<td>
<p>numeric value giving the width of plotted edges</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_use_colour">use_colour</code></td>
<td>
<p>one of &quot;edges&quot; or &quot;points&quot; specifying which element to
apply the colour aesthetic to</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_alt_colour">alt_colour</code></td>
<td>
<p>colour value to be used for edges or points (whichever is
NOT given by <code>use_colour</code>)</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_point_size">point_size</code></td>
<td>
<p>numeric value giving the size of sample points</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_point_alpha">point_alpha</code></td>
<td>
<p>numeric value giving the alpha of sample points</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_point_shape">point_shape</code></td>
<td>
<p>numeric value giving the shape of sample points</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_label_nodes">label_nodes</code></td>
<td>
<p>logical value indicating whether to add labels to
clustering graph nodes</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_label_size">label_size</code></td>
<td>
<p>numeric value giving the size of node labels is
<code>label_nodes</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_y_jitter">y_jitter</code></td>
<td>
<p>numeric value giving the y-direction spread of
points in side plots</p>
</td></tr>
<tr><td><code id="plot_overlay_side_+3A_y_offset">y_offset</code></td>
<td>
<p>numeric value giving the y-direction offset for
points in side plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='sc_example'>Simulated scRNA-seq dataset</h2><span id='topic+sc_example'></span>

<h3>Description</h3>

<p>A simulated scRNA-seq dataset generated using the <code>splatter</code> package and
clustered using the <code>SC3</code> and <code>Seurat</code> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_example
</code></pre>


<h3>Format</h3>

<p><code>sc_example</code> is a list holding a simulated scRNA-seq dataset. Items
in the list included the simulated counts, normalised log counts,
tSNE dimensionality reduction and cell assignments from <code>SC3</code> and <code>Seurat</code>
clustering.
</p>


<h3>Source</h3>

<div class="sourceCode"><pre># Simulation
library("splatter") # Version 1.2.1

sim &lt;- splatSimulate(batchCells = 200, nGenes = 10000,
                     group.prob = c(0.4, 0.2, 0.2, 0.15, 0.05),
                     de.prob = c(0.1, 0.2, 0.05, 0.1, 0.05),
                     method = "groups", seed = 1)
sim_counts &lt;- counts(sim)[1:1000, ]

# SC3 Clustering
library("SC3") # Version 1.7.6
library("scater") # Version 1.6.2

sim_sc3 &lt;- SingleCellExperiment(assays = list(counts = sim_counts))
rowData(sim_sc3)$feature_symbol &lt;- rownames(sim_counts)
sim_sc3 &lt;- normalise(sim_sc3)
sim_sc3 &lt;- sc3(sim_sc3, ks = 1:8, biology = FALSE, n_cores = 1)
sim_sc3 &lt;- runTSNE(sim_sc3)

# Seurat Clustering
library("Seurat") # Version 2.2.0

sim_seurat &lt;- CreateSeuratObject(sim_counts)
sim_seurat &lt;- NormalizeData(sim_seurat, display.progress = FALSE)
sim_seurat &lt;- FindVariableGenes(sim_seurat, do.plot = FALSE,
                                display.progress = FALSE)
sim_seurat &lt;- ScaleData(sim_seurat, display.progress = FALSE)
sim_seurat &lt;- RunPCA(sim_seurat, do.print = FALSE)
sim_seurat &lt;- FindClusters(sim_seurat, dims.use = 1:6,
                           resolution = seq(0, 1, 0.1),
                           print.output = FALSE)

sc_example &lt;- list(counts = counts(sim_sc3),
                   logcounts = logcounts(sim_sc3),
                   tsne = reducedDim(sim_sc3),
                   sc3_clusters = as.data.frame(colData(sim_sc3)),
                   seurat_clusters = sim_seurat@meta.data)
</pre></div>

<hr>
<h2 id='store_node_aes'>Store node aesthetics</h2><span id='topic+store_node_aes'></span>

<h3>Description</h3>

<p>Store the names of node attributes to use as aesthetics as graph attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_node_aes(graph, node_aes_list, metadata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_node_aes_+3A_graph">graph</code></td>
<td>
<p>graph to store attributes in</p>
</td></tr>
<tr><td><code id="store_node_aes_+3A_node_aes_list">node_aes_list</code></td>
<td>
<p>nested list containing node aesthetics</p>
</td></tr>
<tr><td><code id="store_node_aes_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing metadata that can be used as aesthetics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graph with additional attributes
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
