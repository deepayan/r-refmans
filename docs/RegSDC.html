<!DOCTYPE html><html><head><title>Help for package RegSDC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RegSDC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CalculateCdirect'><p>Calculation of C by solving equation 10 in the paper</p></a></li>
<li><a href='#Cdiff'><p>Matrix difference (a-b) including checking for equal columns</p></a></li>
<li><a href='#EnsureIntercept'><p>Ensure constant term in matrix</p></a></li>
<li><a href='#EnsureMatrix'><p>Ensure that input is matrix (by as.matrix) and check number of rows (and columns)</p></a></li>
<li><a href='#FindAlpha'><p>Calculation of alpha</p></a></li>
<li><a href='#GenQR'><p>Generalized QR decomposition</p></a></li>
<li><a href='#IpsoExtra'><p>Extended variant of RegSDCipso</p></a></li>
<li><a href='#ReduceX'><p>Suppressed tabular data: Reduce dummy matrix, X (and estimate Y)</p></a></li>
<li><a href='#RegSDCadd'><p>Regression-based SDC Tools - Synthetic addition with residual correlation control</p></a></li>
<li><a href='#RegSDCaddGen'><p>Regression-based SDC Tools - Synthetic addition</p></a></li>
<li><a href='#RegSDCcomp'><p>Regression-based SDC Tools - Component score correlation control</p></a></li>
<li><a href='#RegSDCdata'><p>Function that returns a dataset</p></a></li>
<li><a href='#RegSDCgen'><p>Regression-based SDC Tools - General data generation</p></a></li>
<li><a href='#RegSDChybrid'><p>Regression-based SDC Tools - Generalized microaggregation</p></a></li>
<li><a href='#RegSDCipso'><p>Regression-based SDC Tools - Ordinary synthetic data (IPSO)</p></a></li>
<li><a href='#RegSDCnew'><p>Regression-based SDC Tools - Scores from new data</p></a></li>
<li><a href='#RegSDCromm'><p>Regression-based SDC Tools - Random orthogonal matrix masking (ROMM)</p></a></li>
<li><a href='#SuppressDec'><p>Suppressed tabular data: Inner cell frequencies as decimal numbers</p></a></li>
<li><a href='#Z2Yhat'><p>Suppressed tabular data: Yhat from X and Z</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Information Preserving Regression-Based Tools for Statistical
Disclosure Control</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Øyvind Langsrud [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Øyvind Langsrud &lt;oyl@ssb.no&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>SSBtools (&ge; 1.3.4), MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the methods described in the paper with the above title: Langsrud, Ø. (2019) &lt;<a href="https://doi.org/10.1007%2Fs11222-018-9848-9">doi:10.1007/s11222-018-9848-9</a>&gt;. The package can be used to generate synthetic or hybrid continuous microdata, and the relationship to the original data can be controlled in several ways. A function for replacing suppressed tabular cell frequencies with decimal numbers is included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/olangsrud/RegSDC">https://github.com/olangsrud/RegSDC</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/olangsrud/RegSDC/issues">https://github.com/olangsrud/RegSDC/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-19 07:32:03 UTC; oyl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CalculateCdirect'>Calculation of C by solving equation 10 in the paper</h2><span id='topic+CalculateCdirect'></span><span id='topic+CalculateC'></span>

<h3>Description</h3>

<p>The limit calculated by <code><a href="#topic+FindAlpha">FindAlpha</a></code> is used when alpha =1 cannot be chosen (warning produced). 
In output, alpha is attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateCdirect(a, b, epsAlpha = 1e-07, AlphaHandler = warning, alpha = NULL)

CalculateC(a, b, ..., viaQR = NULL, returnAlpha = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateCdirect_+3A_a">a</code></td>
<td>
<p>matrix E in paper</p>
</td></tr>
<tr><td><code id="CalculateCdirect_+3A_b">b</code></td>
<td>
<p>matrix Eg in paper</p>
</td></tr>
<tr><td><code id="CalculateCdirect_+3A_epsalpha">epsAlpha</code></td>
<td>
<p>Precision constant for alpha calculation</p>
</td></tr>
<tr><td><code id="CalculateCdirect_+3A_alphahandler">AlphaHandler</code></td>
<td>
<p>Function (warning or stop) to be used when alpha&lt;1</p>
</td></tr>
<tr><td><code id="CalculateCdirect_+3A_alpha">alpha</code></td>
<td>
<p>Possible with alpha as input instead of computing</p>
</td></tr>
<tr><td><code id="CalculateCdirect_+3A_...">...</code></td>
<td>
<p>Arguments to CalculateCdirect</p>
</td></tr>
<tr><td><code id="CalculateCdirect_+3A_viaqr">viaQR</code></td>
<td>
<p>When TRUE QR is involved. This may be needed to handle colinear data. When NULL viaQR is set to TRUE if ordinary computations fail.</p>
</td></tr>
<tr><td><code id="CalculateCdirect_+3A_returnalpha">returnAlpha</code></td>
<td>
<p>When TRUE alpha (1 or value below 1) is returned instead of C. Attribute viaQR is included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When epsAlpha=NULL calculations are performed directly (alpha=1) and alpha is not attribute.
</p>


<h3>Value</h3>

<p>Calculated C with attributes alpha and viaQR (when CalculateC)
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
y &lt;- matrix(rnorm(30) + 1:30, 10, 3)
a &lt;- residuals(lm(y ~ x))
b &lt;- residuals(lm(2 * y + matrix(rnorm(30), 10, 3) ~ x))

a1 &lt;- a
b1 &lt;- b
a1[, 3] &lt;- a[, 1] + a[, 2]
b1[, 3] &lt;- b[, 1] + b[, 2]

alpha &lt;- FindAlpha(a, b)
FindAlphaSimple(a, b)  # Same result as above
CalculateC(a, b)
CalculateCdirect(a, b)  # Same result as above without viaQR attribute 
CalculateCdirect(a, b, alpha = alpha/(1 + 1e-07))  # Same result as above since epsAlpha = 1e-07
CalculateCdirect(a, b, alpha = alpha/2)  # OK
# CalculateCdirect(a,b, alpha = 2*alpha) # Not OK

FindAlpha(a, b1)
# FindAlphaSimple(a,b1) # Not working since b1 is collinear
CalculateC(a, b1, returnAlpha = TRUE)  # Almost same alpha as above (epsAlpha cause difference)

FindAlpha(b, a)
CalculateC(b, a, returnAlpha = TRUE)  # 1 returned (not same as above)
CalculateC(b, a)

FindAlpha(b1, a)   # alpha smaller than epsAlpha is set to 0 in CalculateC
CalculateC(b1, a)  # When alpha = 0 C is calculated by GenQR insetad of chol
</code></pre>

<hr>
<h2 id='Cdiff'>Matrix difference (a-b) including checking for equal columns</h2><span id='topic+Cdiff'></span>

<h3>Description</h3>

<p>Each column is checked by <code><a href="Matrix.html#topic+all.equal">all.equal</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cdiff(a, b, tolerance = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cdiff_+3A_a">a</code></td>
<td>
<p>numerical matrix</p>
</td></tr>
<tr><td><code id="Cdiff_+3A_b">b</code></td>
<td>
<p>numerical matrix</p>
</td></tr>
<tr><td><code id="Cdiff_+3A_tolerance">tolerance</code></td>
<td>
<p>parameter to <code><a href="Matrix.html#topic+all.equal">all.equal</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(a-b) where equal columns are set to zero
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(rnorm(6), 3, 2)
b &lt;- matrix(rnorm(6), 3, 2)
a - b
Cdiff(a, b)
b[, 1] &lt;- a[, 1] + (.Machine$double.eps)^(2/3) * b[, 1]
a - b
Cdiff(a, b)
a[, 2] &lt;- b[, 2]
a - b
Cdiff(a, b)
</code></pre>

<hr>
<h2 id='EnsureIntercept'>Ensure constant term in matrix</h2><span id='topic+EnsureIntercept'></span>

<h3>Description</h3>

<p>A column of ones may be added
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EnsureIntercept(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EnsureIntercept_+3A_x">x</code></td>
<td>
<p>Input matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input matrix possibly with a column of ones added
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(5, 8, 4, 2, 7, 6), 3, 2)
EnsureIntercept(x)
EnsureIntercept(cbind(x, 2))
EnsureIntercept(cbind(x, 0))
EnsureIntercept(matrix(0, 4, 0))
</code></pre>

<hr>
<h2 id='EnsureMatrix'>Ensure that input is matrix (by as.matrix) and check number of rows (and columns)</h2><span id='topic+EnsureMatrix'></span>

<h3>Description</h3>

<p>Ensure that input is matrix (by as.matrix) and check number of rows (and columns)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EnsureMatrix(x, nRow = NULL, nCol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EnsureMatrix_+3A_x">x</code></td>
<td>
<p>NULL or input to as.matrix</p>
</td></tr>
<tr><td><code id="EnsureMatrix_+3A_nrow">nRow</code></td>
<td>
<p>Expected number of rows</p>
</td></tr>
<tr><td><code id="EnsureMatrix_+3A_ncol">nCol</code></td>
<td>
<p>Expected number of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input as a matrix
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(5, 8, 4, 2, 7, 6), 3, 2)
EnsureMatrix(x)
EnsureMatrix(x, 3)
EnsureMatrix(1:4)
EnsureMatrix(1:4, 4)
EnsureMatrix(NULL, 4)
try(EnsureMatrix(x, 4))
try(EnsureMatrix(1:3, 4))
EnsureMatrix(x, 3, 2)
try(EnsureMatrix(x, 3, 3))
try(EnsureMatrix(NULL, 3, 3))
</code></pre>

<hr>
<h2 id='FindAlpha'>Calculation of alpha</h2><span id='topic+FindAlpha'></span><span id='topic+FindAlphaSimple'></span>

<h3>Description</h3>

<p>Function to find the largest alpha that makes equation 10 in the paper solvable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindAlpha(a, b, tryViaQR = TRUE)

FindAlphaSimple(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindAlpha_+3A_a">a</code></td>
<td>
<p>matrix E in paper</p>
</td></tr>
<tr><td><code id="FindAlpha_+3A_b">b</code></td>
<td>
<p>matrix Eg in paper</p>
</td></tr>
<tr><td><code id="FindAlpha_+3A_tryviaqr">tryViaQR</code></td>
<td>
<p>When TRUE QR transformation used (to handle collinearity) 
when ordinary calculations fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>alpha
</p>


<h3>Note</h3>

<p>FindAlphaSimple performs the calculations by a simple/direct method. 
FindAlpha is made to handle problematic special cases.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p>See examples in the documentation of <code><a href="#topic+CalculateC">CalculateC</a></code>
</p>

<hr>
<h2 id='GenQR'>Generalized QR decomposition</h2><span id='topic+GenQR'></span>

<h3>Description</h3>

<p>Matrix X decomposed as Q and R (X=QR) where columns of Q are orthonormal.
Ordinary QR or SVD may be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenQR(x, doSVD = FALSE, findR = TRUE, makeunique = findR, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenQR_+3A_x">x</code></td>
<td>
<p>Matrix to be decomposed</p>
</td></tr>
<tr><td><code id="GenQR_+3A_dosvd">doSVD</code></td>
<td>
<p>When TRUE SVD instead of QR</p>
</td></tr>
<tr><td><code id="GenQR_+3A_findr">findR</code></td>
<td>
<p>When FALSE only Q returned</p>
</td></tr>
<tr><td><code id="GenQR_+3A_makeunique">makeunique</code></td>
<td>
<p>When TRUE force uniqueness by positive diagonal elements (QR) or by column sums (SVD)</p>
</td></tr>
<tr><td><code id="GenQR_+3A_tol">tol</code></td>
<td>
<p>As input to qr or, in the case of svd(), similar as input to MASS::ginv().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To handle dependency a usual decomposition of X is PX=QR where P is a permutation matrix. 
This function returns RP^T as R. When SVD, Q=U and R=SV^T.
</p>


<h3>Value</h3>

<p>List with Q and R or just Q
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   GenQR(matrix(rnorm(15),5,3))
   GenQR(matrix(rnorm(15),5,3)[,c(1,2,1,3)])
   GenQR(matrix(rnorm(15),5,3)[,c(1,2,1,3)],TRUE)
</code></pre>

<hr>
<h2 id='IpsoExtra'>Extended variant of RegSDCipso</h2><span id='topic+IpsoExtra'></span>

<h3>Description</h3>

<p>Possible to generate several y's and to re-scale residuals.
Regression fitting by a sparse matrix algorithm is also possible (see reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IpsoExtra(
  y,
  x = NULL,
  ensureIntercept = TRUE,
  returnParts = FALSE,
  nRep = 1,
  resScale = NULL,
  digits = 9,
  rmse = NULL,
  sparseLimit = 500,
  printInc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IpsoExtra_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="IpsoExtra_+3A_x">x</code></td>
<td>
<p>Matrix of non-confidential variables</p>
</td></tr>
<tr><td><code id="IpsoExtra_+3A_ensureintercept">ensureIntercept</code></td>
<td>
<p>Whether to ensure/include a constant term. Non-NULL x is subjected to <code><a href="#topic+EnsureIntercept">EnsureIntercept</a></code></p>
</td></tr>
<tr><td><code id="IpsoExtra_+3A_returnparts">returnParts</code></td>
<td>
<p>Alternative output two matrices: yHat (fitted) and yRes (generated residuals).</p>
</td></tr>
<tr><td><code id="IpsoExtra_+3A_nrep">nRep</code></td>
<td>
<p>Integer, when &gt;1, several y's will be generated. Extra columns in output.</p>
</td></tr>
<tr><td><code id="IpsoExtra_+3A_resscale">resScale</code></td>
<td>
<p>Residuals will be scaled by resScale</p>
</td></tr>
<tr><td><code id="IpsoExtra_+3A_digits">digits</code></td>
<td>
<p>Digits used to detect perfect fit (caused by fitted values as input). 
This checking will be done only when rmse is in input. When perfect fit, rmse will be used instead of resScale.</p>
</td></tr>
<tr><td><code id="IpsoExtra_+3A_rmse">rmse</code></td>
<td>
<p>Desired root mean square error (residual standard error). Will be used when resScale is 
NULL or cannot be used (see parameter digits). This parameter forces the rmse value for one y variable (the first).</p>
</td></tr>
<tr><td><code id="IpsoExtra_+3A_sparselimit">sparseLimit</code></td>
<td>
<p>Limit for the number of rows of a reduced x-matrix within the algorithm. When exceeded, a sparse algorithm is used (see reference).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated version of y
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>References</h3>

<p>Douglas Bates and R Development Core Team (2022), 
Comparing Least Squares Calculations, 
R Vignette, 
<code>vignette("Comparisons", package="Matrix")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:5, 5, 1)
y &lt;- matrix(10 * (sample(7:39, 15) + 4 * (1:15)), 5, 3)
colnames(y) &lt;- paste("y", 1:3, sep = "")
y1 &lt;- y[, 1, drop = FALSE]

IpsoExtra(y, x)  # Same as RegSDCipso(y, x)

IpsoExtra(y, x, resScale = 0)  # Fitted values (whole numbers in this case)
IpsoExtra(y, x, nRep = 2, resScale = 1e-05)  # Downscaled residuals 

ySynth &lt;- IpsoExtra(y1, x, nRep = 2, rmse = 0.25)  # Downscaled residuals 
summary(lm(ySynth ~ x))  # Identical regression results with Residual standard error: 0.25

IpsoExtra(fitted(lm(y1 ~ x)), x, nRep = 2, resScale = 0.1)  # resScale no effect since perfect fit
IpsoExtra(fitted(lm(y1 ~ x)), x, nRep = 2, resScale = 0.1, rmse = 2)  # with warning

# Using data in the paper
IpsoExtra(RegSDCdata("sec7y"), RegSDCdata("sec7x"))  # Similar to Y*
IpsoExtra(RegSDCdata("sec7y"), RegSDCdata("sec7x"), rmse = 1)
</code></pre>

<hr>
<h2 id='ReduceX'>Suppressed tabular data: Reduce dummy matrix, X (and estimate Y)</h2><span id='topic+ReduceX'></span>

<h3>Description</h3>

<p>In section 7 in the paper <code> Z = t(X) %*% Y</code> where <code>X</code> is a dummy matrix. 
Some elements of Y can be found directly as elements in Z. Corresponding rows of X will be removed. 
After removing rows, some columns will only have zeros and these will also be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReduceX(x, z = NULL, y = NULL, digits = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReduceX_+3A_x">x</code></td>
<td>
<p>X as a matrix</p>
</td></tr>
<tr><td><code id="ReduceX_+3A_z">z</code></td>
<td>
<p>Z as a matrix</p>
</td></tr>
<tr><td><code id="ReduceX_+3A_y">y</code></td>
<td>
<p>Y as a matrix</p>
</td></tr>
<tr><td><code id="ReduceX_+3A_digits">digits</code></td>
<td>
<p>When non-NULL and when NULL y input, output y estimates close to whole numbers will be rounded using 
<code>digits</code> as input to <code>RoundWhole</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To estimate Y, this function finds some values directly from Z and other values by running <code><a href="#topic+Z2Yhat">Z2Yhat</a></code> on reduced versions of X and Z.
</p>


<h3>Value</h3>

<p>A list of four elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Reduced <code>x</code></p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Corresponding reduced <code>z</code> or NULL when no <code>z</code> in input</p>
</td></tr>
<tr><td><code>yKnown</code></td>
<td>
<p>Logical vector specifying elements of y that can be found directly as elements in z</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>As <code>y</code> in input (not reduced) or estimated <code>y</code> when NULL y in input</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same data as in the paper
z &lt;- RegSDCdata("sec7z")
x &lt;- RegSDCdata("sec7x")
y &lt;- RegSDCdata("sec7y")  # Now z is t(x) %*% y 

a &lt;- ReduceX(x, z, y)
b &lt;- ReduceX(x, z)
d &lt;- ReduceX(x, z = NULL, y)  # No z in output

# Identical output for x and z
identical(a$x, b$x)
identical(a$x, d$x)
identical(a$z, b$z)

# Same y in output as input
identical(a$y, y)
identical(d$y, y)

# Estimate of y (yHat) when NULL y input
b$y

# These elements of y can be found directly in in z
y[a$yKnown, , drop = FALSE]
# They can be found by searching for unit colSums
colSums(x)[colSums(x) == 1]

# These trivial data rows can be omitted when processing data
x[!a$yKnown, ]
# Now several columns can be omitted since zero colSums
colSums0 &lt;- colSums(x[!a$yKnown, ]) == 0
# The resulting matrix is output from the function
identical(x[!a$yKnown, !colSums0], a$x)

# Output z can be computed from this output x
identical(t(a$x) %*% y[!a$yKnown, , drop = FALSE], a$z)
</code></pre>

<hr>
<h2 id='RegSDCadd'>Regression-based SDC Tools - Synthetic addition with residual correlation control</h2><span id='topic+RegSDCadd'></span>

<h3>Description</h3>

<p>Implementation of equation 6 (arbitrary residual data) and equation 7 (residual correlations) in the paper.
The alpha limit is calculated (equation 9). The limit is used when alpha =1 cannot be chosen (warning produced). 
In output, alpha is attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDCadd(y, resCorr = NULL, x = NULL, yStart = NULL, ensureIntercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDCadd_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCadd_+3A_rescorr">resCorr</code></td>
<td>
<p>Required residual correlations (possibly recycled)</p>
</td></tr>
<tr><td><code id="RegSDCadd_+3A_x">x</code></td>
<td>
<p>Matrix of non-confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCadd_+3A_ystart">yStart</code></td>
<td>
<p>Arbitrary data whose residuals will be used. Will be calculated from resCorr when NULL.</p>
</td></tr>
<tr><td><code id="RegSDCadd_+3A_ensureintercept">ensureIntercept</code></td>
<td>
<p>Whether to ensure/include a constant term. Non-NULL x is subjected to <code><a href="#topic+EnsureIntercept">EnsureIntercept</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use epsAlpha=NULL to avoid calculation of alpha. Use of alpha (&lt;1) will produce a warning. Input matrices are subjected to <code><a href="#topic+EnsureMatrix">EnsureMatrix</a></code>.
</p>


<h3>Value</h3>

<p>Generated version of y with alpha as attribute
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:10, 10, 1)
y &lt;- matrix(rnorm(30) + 1:30, 10, 3)
yOut &lt;- RegSDCadd(y, c(0.1, 0.2, 0.3), x)

# Correlations between residuals as required
diag(cor(residuals(lm(y ~ x)), residuals(lm(yOut ~ x))))

# Identical covariance matrices
cov(y) - cov(yOut)
cov(residuals(lm(y ~ x))) - cov(residuals(lm(yOut ~ x)))

# Identical regression results
summary(lm(y[, 1] ~ x))
summary(lm(yOut[, 1] ~ x))

# alpha as attribute
attr(yOut, "alpha")

# With yStart as input and alpha limit in use (warning produced)
yOut &lt;- RegSDCadd(y, NULL, x, 2 * y + matrix(rnorm(30), 10, 3))
attr(yOut, "alpha")

# Same correlation for all variables
RegSDCadd(y, 0.2, x)
# But in this case RegSDCcomp is equivalent and faster
RegSDCcomp(y, 0.2, x)


# Make nearly collinear data
y[, 3] &lt;- y[, 1] + y[, 2] + 0.001 * y[, 3]
# Not possible to achieve correlations. Small alpha with warning.
RegSDCadd(y, c(0.1, 0.2, 0.3), x)
# Exact collinear data
y[, 3] &lt;- y[, 1] + y[, 2]
# Zero alpha with warning
RegSDCadd(y, c(0.1, 0.2, 0.3), x)
</code></pre>

<hr>
<h2 id='RegSDCaddGen'>Regression-based SDC Tools - Synthetic addition</h2><span id='topic+RegSDCaddGen'></span>

<h3>Description</h3>

<p>Residuals from arbitrary data with a synthetic addition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDCaddGen(
  y,
  yStart,
  x = NULL,
  epsAlpha = 1e-07,
  AlphaHandler = warning,
  alphaAttr = TRUE,
  makeunique = TRUE,
  ensureIntercept = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDCaddGen_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCaddGen_+3A_ystart">yStart</code></td>
<td>
<p>Arbitrary data whose residuals will be used</p>
</td></tr>
<tr><td><code id="RegSDCaddGen_+3A_x">x</code></td>
<td>
<p>Matrix of non-confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCaddGen_+3A_epsalpha">epsAlpha</code></td>
<td>
<p>Precision constant for alpha calculation</p>
</td></tr>
<tr><td><code id="RegSDCaddGen_+3A_alphahandler">AlphaHandler</code></td>
<td>
<p>Function (warning or stop) to be used when alpha&lt;1</p>
</td></tr>
<tr><td><code id="RegSDCaddGen_+3A_alphaattr">alphaAttr</code></td>
<td>
<p>When TRUE alpha is attribute in output</p>
</td></tr>
<tr><td><code id="RegSDCaddGen_+3A_makeunique">makeunique</code></td>
<td>
<p>Parameter to be used in GenQR</p>
</td></tr>
<tr><td><code id="RegSDCaddGen_+3A_ensureintercept">ensureIntercept</code></td>
<td>
<p>Whether to ensure/include a constant term. Non-NULL x is subjected to <code><a href="#topic+EnsureIntercept">EnsureIntercept</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use epsAlpha=NULL to avoid calculation of alpha. Use of alpha (&lt;1) will produce a warning. Input matrices are subjected to <code><a href="#topic+EnsureMatrix">EnsureMatrix</a></code>.
</p>


<h3>Value</h3>

<p>Generated version of y
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='RegSDCcomp'>Regression-based SDC Tools - Component score correlation control</h2><span id='topic+RegSDCcomp'></span>

<h3>Description</h3>

<p>Implementation of equation 8 in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDCcomp(
  y,
  compCorr = NA,
  x = NULL,
  doSVD = FALSE,
  makeunique = TRUE,
  ensureIntercept = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDCcomp_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCcomp_+3A_compcorr">compCorr</code></td>
<td>
<p>Required component score  correlations (possibly recycled)</p>
</td></tr>
<tr><td><code id="RegSDCcomp_+3A_x">x</code></td>
<td>
<p>Matrix of non-confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCcomp_+3A_dosvd">doSVD</code></td>
<td>
<p>SVD when TRUE and QR when FALSE</p>
</td></tr>
<tr><td><code id="RegSDCcomp_+3A_makeunique">makeunique</code></td>
<td>
<p>Parameter to be used in GenQR</p>
</td></tr>
<tr><td><code id="RegSDCcomp_+3A_ensureintercept">ensureIntercept</code></td>
<td>
<p>Whether to ensure/include a constant term. Non-NULL x is subjected to <code><a href="#topic+EnsureIntercept">EnsureIntercept</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA component score correlation means independent random. Input matrices are subjected to <code><a href="#topic+EnsureMatrix">EnsureMatrix</a></code>.
</p>


<h3>Value</h3>

<p>Generated version of y
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:10, 10, 1)
y &lt;- matrix(rnorm(30) + 1:30, 10, 3)

# Same as IPSO (RegSDCipso)
RegSDCcomp(y, NA, x)

# Using QR and SVD
yQR &lt;- RegSDCcomp(y, c(0.1, 0.2, NA), x)
ySVD &lt;- RegSDCcomp(y, c(0.1, 0.2, NA), x, doSVD = TRUE)

# Calculation of residuals
r &lt;- residuals(lm(y ~ x))
rQR &lt;- residuals(lm(yQR ~ x))
rSVD &lt;- residuals(lm(ySVD ~ x))

# Correlations for two first components as required
diag(cor(GenQR(r)$Q, GenQR(rQR)$Q))
diag(cor(GenQR(r, doSVD = TRUE)$Q, GenQR(rSVD, doSVD = TRUE)$Q))

# Identical covariance matrices
cov(yQR) - cov(ySVD)
cov(rQR) - cov(rSVD)

# Identical regression results
summary(lm(y[, 1] ~ x))
summary(lm(yQR[, 1] ~ x))
summary(lm(ySVD[, 1] ~ x))
</code></pre>

<hr>
<h2 id='RegSDCdata'>Function that returns a dataset</h2><span id='topic+RegSDCdata'></span>

<h3>Description</h3>

<p>Function that returns a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDCdata(dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDCdata_+3A_dataset">dataset</code></td>
<td>
<p>Name of data set within the RegSDC package</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>sec7data:</strong> Data in section 7 of the paper as a data frame
</p>
<p><strong>sec7y:</strong> Y in section 7 of the paper as a matrix
</p>
<p><strong>sec7x:</strong> X in section 7 of the paper as a matrix
</p>
<p><strong>sec7z:</strong> Z in section 7 of the paper as a matrix
</p>
<p><strong>sec7xAll:</strong> Xall in section 7 of the paper as a matrix
</p>
<p><strong>sec7zAll:</strong> Zall in section 7 of the paper as a matrix
</p>
<p><strong>sec7zAllSupp:</strong> As Zall with suppressed values set to NA
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RegSDCdata("sec7data")
RegSDCdata("sec7y")
RegSDCdata("sec7x")
RegSDCdata("sec7z")
RegSDCdata("sec7xAll")
RegSDCdata("sec7zAll")
RegSDCdata("sec7zAllSupp")
</code></pre>

<hr>
<h2 id='RegSDCgen'>Regression-based SDC Tools - General data generation</h2><span id='topic+RegSDCgen'></span>

<h3>Description</h3>

<p>IPSO by QR or SVD, scores from arbitrary data, and ROMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDCgen(
  y,
  x = NULL,
  doSVD = FALSE,
  yNew = NULL,
  lambda = Inf,
  makeunique = TRUE,
  ensureIntercept = TRUE,
  returnParts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDCgen_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCgen_+3A_x">x</code></td>
<td>
<p>Matrix of non-confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCgen_+3A_dosvd">doSVD</code></td>
<td>
<p>SVD when TRUE and QR when FALSE</p>
</td></tr>
<tr><td><code id="RegSDCgen_+3A_ynew">yNew</code></td>
<td>
<p>Matrix of y-data for new scores (simulated when NULL)</p>
</td></tr>
<tr><td><code id="RegSDCgen_+3A_lambda">lambda</code></td>
<td>
<p>ROMM parameter</p>
</td></tr>
<tr><td><code id="RegSDCgen_+3A_makeunique">makeunique</code></td>
<td>
<p>Parameter to be used in GenQR</p>
</td></tr>
<tr><td><code id="RegSDCgen_+3A_ensureintercept">ensureIntercept</code></td>
<td>
<p>Whether to ensure/include a constant term. Non-NULL x is subjected to <code><a href="#topic+EnsureIntercept">EnsureIntercept</a></code></p>
</td></tr>
<tr><td><code id="RegSDCgen_+3A_returnparts">returnParts</code></td>
<td>
<p>Alternative output two matrices: yHat (fitted) and yRes (generated residuals).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>doSVD has effect on decomposition of y and yNew. Input matrices are subjected to <code><a href="#topic+EnsureMatrix">EnsureMatrix</a></code>.
</p>


<h3>Value</h3>

<p>Generated version of y
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exY &lt;- matrix(rnorm(15), 5, 3)
RegSDCgen(exY)
RegSDCgen(exY, yNew = exY + 0.001 * matrix(rnorm(15), 5, 3))  # Close to exY
RegSDCgen(exY, lambda = 0.001)  # Close to exY
</code></pre>

<hr>
<h2 id='RegSDChybrid'>Regression-based SDC Tools - Generalized microaggregation</h2><span id='topic+RegSDChybrid'></span>

<h3>Description</h3>

<p>Implementation of the methodology in section 6 in the paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDChybrid(
  y,
  clusters = NULL,
  xLocal = NULL,
  xGlobal = NULL,
  clusterPieces = NULL,
  xClusterPieces = NULL,
  groupedClusters = NULL,
  xGroupedClusters = NULL,
  alternative = NULL,
  alpha = NULL,
  ySim = NULL,
  returnParts = FALSE,
  epsAlpha = 1e-07,
  makeunique = TRUE,
  tolerance = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDChybrid_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_clusters">clusters</code></td>
<td>
<p>Vector of cluster coding</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_xlocal">xLocal</code></td>
<td>
<p>Matrix of x-variables to be crossed with clusters</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_xglobal">xGlobal</code></td>
<td>
<p>Matrix of x-variables NOT to be crossed with clusters</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_clusterpieces">clusterPieces</code></td>
<td>
<p>Vector of coding of cluster pieces</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_xclusterpieces">xClusterPieces</code></td>
<td>
<p>Matrix of x-variables to be crossed with cluster pieces</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_groupedclusters">groupedClusters</code></td>
<td>
<p>Vector of coding of grouped clusters</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_xgroupedclusters">xGroupedClusters</code></td>
<td>
<p>Matrix of x-variables to be crossed with grouped clusters</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_alternative">alternative</code></td>
<td>
<p>One of &quot;&quot; (default), &quot;a&quot;, &quot;b&quot; or &quot;c&quot;</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_alpha">alpha</code></td>
<td>
<p>Possible to specify parameter used internally by alternative &quot;c&quot;</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_ysim">ySim</code></td>
<td>
<p>Possible to specify the internally simulated data manually</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_returnparts">returnParts</code></td>
<td>
<p>Alternative output six matrices:
y1 and y2 (fitted),    e3s and e4s (new residuals),   e3 and e4 (original residuals)</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_epsalpha">epsAlpha</code></td>
<td>
<p>Precision constant for alpha calculation</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_makeunique">makeunique</code></td>
<td>
<p>Parameter to be used in GenQR</p>
</td></tr>
<tr><td><code id="RegSDChybrid_+3A_tolerance">tolerance</code></td>
<td>
<p>Parameter to <code><a href="#topic+Cdiff">Cdiff</a></code> used within the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input matrices are subjected to <code><a href="#topic+EnsureMatrix">EnsureMatrix</a></code>.
Necessary constant terms (intercept) are automatically included. 
That is, a column of ones is not needed in the input matrices.
</p>


<h3>Value</h3>

<p>Generated version of y
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
# Generate example data for introductory examples
################################################# 
y &lt;- matrix(rnorm(30) + 1:30, 10, 3)
x &lt;- matrix(1:10, 10, 1)  # x &lt;- 1:10 is equivalent

# Same as RegSDCipso(y)
yOut &lt;- RegSDChybrid(y)

# With a single cluster both are same as RegSDCipso(y, x)
yOut &lt;- RegSDChybrid(y, xLocal = x)
yOut &lt;- RegSDChybrid(y, xGlobal = x)

# Define two clusters
clust &lt;- rep(1:2, each = 5)

# MHa and MHb in paper
yMHa &lt;- RegSDChybrid(y, clusters = clust, xLocal = x)
yMHb &lt;- RegSDChybrid(y, clusterPieces = clust, xLocal = x)

# An extended variant of MHb as mentioned in paper paragraph below definition of MHa/MHb
yMHbExt &lt;- RegSDChybrid(y, clusterPieces = clust, xClusterPieces = x)

# Identical means within clusters
aggregate(y, list(clust = clust), mean)
aggregate(yMHa, list(clust = clust), mean)
aggregate(yMHb, list(clust = clust), mean)
aggregate(yMHbExt, list(clust = clust), mean)

# Identical global regression results
summary(lm(y[, 1] ~ x))
summary(lm(yMHa[, 1] ~ x))
summary(lm(yMHb[, 1] ~ x))
summary(lm(yMHbExt[, 1] ~ x))

# MHa: Identical local regression results
summary(lm(y[, 1] ~ x, subset = clust == 1))
summary(lm(yMHa[, 1] ~ x, subset = clust == 1))

# MHb: Different results
summary(lm(yMHb[, 1] ~ x, subset = clust == 1))

# MHbExt: Same estimates and different std. errors
summary(lm(yMHbExt[, 1] ~ x, subset = clust == 1))

###################################################
#  Generate example data for more advanced examples
###################################################
x &lt;- matrix((1:90) * (1 + runif(90)), 30, 3)
x1 &lt;- x[, 1]
x2 &lt;- x[, 2]
x3 &lt;- x[, 3]
y &lt;- matrix(rnorm(90), 30, 3) + x
clust &lt;- paste("c", rep(1:3, each = 10), sep = "")

######## Run main algorithm
z0 &lt;- RegSDChybrid(y, clusters = clust, xLocal = x3, xGlobal = cbind(x1, x2))

# Corresponding models by lm
lmy &lt;- lm(y ~ clust + x1 + x2 + x3:clust)
lm0 &lt;- lm(z0 ~ clust + x1 + x2 + x3:clust)

# Preserved regression coef (x3 within clusters)
coef(lmy) - coef(lm0)

# Preservation of x3 coef locally can also be seen by local regression
coef(lm(y ~ x3, subset = clust == "c2")) - coef(lm(z0 ~ x3, subset = clust == "c2"))

# Covariance matrix preserved
cov(resid(lmy)) - cov(resid(lm0))

# But not preserved within clusters
cov(resid(lmy)[clust == "c2", ]) - cov(resid(lm0)[clust == "c2", ])

######## Modification (a)
za &lt;- RegSDChybrid(y, clusters = clust, xLocal = x3, xGlobal = cbind(x1, x2), alternative = "a")
lma &lt;- lm(za ~ clust + x1 + x2 + x3:clust)

# Now covariance matrices preserved within clusters
cov(resid(lmy)[clust == "c2", ]) - cov(resid(lma)[clust == "c2", ])

# If we estimate coef for x1 and x2 within clusters, 
# they become identical and identical to global estimates
coef(lma)
coef(lm(za ~ clust + x1:clust + x2:clust + x3:clust))

######## Modification (c) with automatic calculation of alpha 
# The result depends on the randomly generated data
# When the result is that alpha=1, modification (b) is equivalent
zc &lt;- RegSDChybrid(y, clusters = clust, xLocal = x3, xGlobal = cbind(x1, x2), alternative = "c")
lmc &lt;- lm(zc ~ clust + x1 + x2 + x3:clust)

# Preserved regression coef as above
coef(lmy) - coef(lmc)

# Again covariance matrices preserved within clusters
cov(resid(lmy)[clust == "c2", ]) - cov(resid(lmc)[clust == "c2", ])

# If we estimate coef for x1 and x2 within clusters, 
# results are different from modification (a) above
coef(lmc)
coef(lm(zc ~ clust + x1:clust + x2:clust + x3:clust))


####################################################
# Make groups of clusters (d) and cluster pieces (e)
####################################################
clustGr &lt;- paste("gr", ceiling(rep(1:3, each = 10)/2 + 0.1), sep = "")
clustP &lt;- c("a", "a", rep("b", 28))

######## Modifications (c), (d) and (e)
zGrP &lt;- RegSDChybrid(y, clusters = clust, clusterPieces = clustP, groupedClusters = clustGr,
                     xLocal = x3, xGroupedClusters = x2, xGlobal = x1, alternative = "c")

# Corresponding models by lm
lmGrP &lt;- lm(zGrP ~ clust:clustP + x1 + x2:clustGr + x3:clust - 1)
lmY &lt;- lm(y ~ clust:clustP + x1 + x2:clustGr + x3:clust - 1)

# Preserved regression coef
coef(lmY) - coef(lmGrP)

# Identical means within cluster pieces
aggregate(y, list(clust = clust, clustP = clustP), mean)
aggregate(zGrP, list(clust = clust, clustP = clustP), mean)

# Covariance matrix preserved
cov(resid(lmY)) - cov(resid(lmGrP))

# Covariance matrices preserved within clusters
cov(resid(lmY)[clust == "c2", ]) - cov(resid(lmGrP)[clust == "c2", ])

# Covariance matrices not preserved within cluster pieces
cov(resid(lmY)[clustP == "a", ]) - cov(resid(lmGrP)[clustP == "a", ])
</code></pre>

<hr>
<h2 id='RegSDCipso'>Regression-based SDC Tools - Ordinary synthetic data (IPSO)</h2><span id='topic+RegSDCipso'></span>

<h3>Description</h3>

<p>Implementation of equation 4 in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDCipso(y, x = NULL, ensureIntercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDCipso_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCipso_+3A_x">x</code></td>
<td>
<p>Matrix of non-confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCipso_+3A_ensureintercept">ensureIntercept</code></td>
<td>
<p>Whether to ensure/include a constant term. Non-NULL x is subjected to <code><a href="#topic+EnsureIntercept">EnsureIntercept</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input matrices are subjected to <code><a href="#topic+EnsureMatrix">EnsureMatrix</a></code>.
</p>


<h3>Value</h3>

<p>Generated version of y
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:5, 5, 1)
y &lt;- matrix(rnorm(15) + 1:15, 5, 3)
ySynth &lt;- RegSDCipso(y, x)

# Identical regression results
summary(lm(y[, 1] ~ x))
summary(lm(ySynth[, 1] ~ x))

# Identical covariance matrices
cov(y) - cov(ySynth)
cov(residuals(lm(y ~ x))) - cov(residuals(lm(ySynth ~ x)))
</code></pre>

<hr>
<h2 id='RegSDCnew'>Regression-based SDC Tools - Scores from new data</h2><span id='topic+RegSDCnew'></span>

<h3>Description</h3>

<p>Implementation of equation 12 in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDCnew(y, yNew, x = NULL, doSVD = FALSE, ensureIntercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDCnew_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCnew_+3A_ynew">yNew</code></td>
<td>
<p>Matrix of y-data for new scores</p>
</td></tr>
<tr><td><code id="RegSDCnew_+3A_x">x</code></td>
<td>
<p>Matrix of non-confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCnew_+3A_dosvd">doSVD</code></td>
<td>
<p>SVD when TRUE and QR when FALSE</p>
</td></tr>
<tr><td><code id="RegSDCnew_+3A_ensureintercept">ensureIntercept</code></td>
<td>
<p>Whether to ensure/include a constant term. Non-NULL x is subjected to <code><a href="#topic+EnsureIntercept">EnsureIntercept</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>doSVD has effect on decomposition of y and yNew. Input matrices are subjected to <code><a href="#topic+EnsureMatrix">EnsureMatrix</a></code>.
</p>


<h3>Value</h3>

<p>Generated version of y
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:5, 5, 1)
y &lt;- matrix(rnorm(15) + 1:15, 5, 3)

# Same as IPSO (RegSDCipso)
RegSDCnew(y, matrix(rnorm(15), 5, 3), x)

# Close to y
RegSDCnew(y, y + 0.001 * matrix(rnorm(15), 5, 3), x)
</code></pre>

<hr>
<h2 id='RegSDCromm'>Regression-based SDC Tools - Random orthogonal matrix masking (ROMM)</h2><span id='topic+RegSDCromm'></span>

<h3>Description</h3>

<p>Implementation based on equations 11, 12 and 17 in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegSDCromm(y, lambda = Inf, x = NULL, doSVD = FALSE, ensureIntercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegSDCromm_+3A_y">y</code></td>
<td>
<p>Matrix of confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCromm_+3A_lambda">lambda</code></td>
<td>
<p>ROMM parameter</p>
</td></tr>
<tr><td><code id="RegSDCromm_+3A_x">x</code></td>
<td>
<p>Matrix of non-confidential variables</p>
</td></tr>
<tr><td><code id="RegSDCromm_+3A_dosvd">doSVD</code></td>
<td>
<p>SVD when TRUE and QR when FALSE</p>
</td></tr>
<tr><td><code id="RegSDCromm_+3A_ensureintercept">ensureIntercept</code></td>
<td>
<p>Whether to ensure/include a constant term. Non-NULL x is subjected to <code><a href="#topic+EnsureIntercept">EnsureIntercept</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>doSVD has effect on decomposition of y. 
The exact behaviour of the method depends on the choice of the decomposition method because of 
the sequentially phenomenon mentioned in the paper. 
The similarity to the original data will tend to be highest for the first component. 
Input matrices are subjected to <code><a href="#topic+EnsureMatrix">EnsureMatrix</a></code>.
</p>


<h3>Value</h3>

<p>Generated version of y
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:5, 5, 1)
y &lt;- matrix(rnorm(15) + 1:15, 5, 3)

# Same as IPSO (RegSDCipso)
RegSDCromm(y, Inf, x)

# Close to IPSO
RegSDCromm(y, 100, x)

# Close to y
RegSDCromm(y, 0.001, x)
</code></pre>

<hr>
<h2 id='SuppressDec'>Suppressed tabular data: Inner cell frequencies as decimal numbers</h2><span id='topic+SuppressDec'></span>

<h3>Description</h3>

<p>Assume that frequencies to be published, <code>z</code>, can be computed from inner 
frequencies, <code>y</code>, via <code> z = t(x) %*% y</code>, 
where <code>x</code> is a dummy matrix. 
Assuming correct suppression, this function will generate safe inner cell frequencies as decimal numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuppressDec(
  x,
  z = NULL,
  y = NULL,
  suppressed = NULL,
  digits = 9,
  nRep = 1,
  yDeduct = NULL,
  resScale = NULL,
  rmse = NULL,
  sparseLimit = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuppressDec_+3A_x">x</code></td>
<td>
<p>Dummy matrix where the dimensions matches z and/or y input. Sparse matrix (Matrix package) is possible.</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_z">z</code></td>
<td>
<p>Frequencies to be published. All, only the safe ones or with suppressed as NA.</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_y">y</code></td>
<td>
<p>Inner cell frequencies (see details).</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_suppressed">suppressed</code></td>
<td>
<p>Logical vector defining the suppressed elements of z.</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_digits">digits</code></td>
<td>
<p>Output close to whole numbers will be rounded using <code>digits</code> as input to <code>RoundWhole</code>.</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_nrep">nRep</code></td>
<td>
<p>Integer, when &gt;1, several y's will be generated. Extra columns in output.</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_ydeduct">yDeduct</code></td>
<td>
<p>Values to be subtracted from y and added back after the calculations. 
Can be used to perform the modulo method described in the paper (see examples).</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_resscale">resScale</code></td>
<td>
<p>Residuals will be scaled by resScale</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_rmse">rmse</code></td>
<td>
<p>Desired root mean square error (residual standard error). Will be used when resScale is NULL or cannot be used.</p>
</td></tr>
<tr><td><code id="SuppressDec_+3A_sparselimit">sparseLimit</code></td>
<td>
<p>Limit for the number of rows of a reduced x-matrix within the algorithm. When exceeded, a sparse algorithm is used 
(see <code><a href="#topic+IpsoExtra">IpsoExtra</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes use of <code><a href="#topic+ReduceX">ReduceX</a></code> and <code><a href="#topic+RegSDCipso">RegSDCipso</a></code>.
It is not required that <code>y</code> consists of cell frequencies. A multivariate <code>y</code> or <code>z</code> is also possible. 
Then several values are possible as <code>digits</code>, <code>resScale</code> and <code>rmse</code> input.
</p>


<h3>Value</h3>

<p>The inner cell frequencies as decimal numbers
</p>


<h3>Note</h3>

<p>Capital letters, X, Y and Z, are used in the paper.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same data as in the paper
z &lt;- RegSDCdata("sec7z")
x &lt;- RegSDCdata("sec7x")
y &lt;- RegSDCdata("sec7y")  # Now z is t(x) %*% y 
zAll &lt;- RegSDCdata("sec7zAll")
zAllSupp &lt;- RegSDCdata("sec7zAllSupp")
xAll &lt;- RegSDCdata("sec7xAll")

# When no suppression, output is identical to y
SuppressDec(xAll, zAll, y)
SuppressDec(xAll, zAll)  # y can be seen in z

# Similar to Y* in paper (but other random values)
SuppressDec(x, z, y)

# Residual standard error forced to be 1
SuppressDec(x, z, y, rmse = 1)

# Seven ways of obtaining the same output
SuppressDec(x, z, rmse = 1)  # slower, y must be estimated
SuppressDec(x, y = y, rmse = 1)
SuppressDec(xAll, zAllSupp, y, rmse = 1)
SuppressDec(xAll, zAllSupp, rmse = 1)  # slower, y must be estimated
SuppressDec(xAll, zAll, y, is.na(zAllSupp), rmse = 1)
SuppressDec(xAll, zAll, suppressed = is.na(zAllSupp), rmse = 1)  # y seen in z
SuppressDec(xAll, y = y, suppressed = is.na(zAllSupp), rmse = 1)

# YhatMod4 and YhatMod10 in Table 2 in paper
SuppressDec(xAll, zAllSupp, y, yDeduct = 4 * (y%/%4), resScale = 0)
SuppressDec(xAll, zAllSupp, y, yDeduct = 10 * (y%/%10), rmse = 0)

# As data in Table 3 in paper (but other random values)
SuppressDec(xAll, zAllSupp, y, yDeduct = 10 * (y%/%10), resScale = 0.1)

# rmse instead of resScale and 5 draws
SuppressDec(xAll, zAllSupp, y, yDeduct = 10 * (y%/%10), rmse = 1, nRep = 5)
</code></pre>

<hr>
<h2 id='Z2Yhat'>Suppressed tabular data: Yhat from X and Z</h2><span id='topic+Z2Yhat'></span>

<h3>Description</h3>

<p>Implementation of equation 21 in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Z2Yhat(z, x, digits = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Z2Yhat_+3A_z">z</code></td>
<td>
<p>Z as a matrix</p>
</td></tr>
<tr><td><code id="Z2Yhat_+3A_x">x</code></td>
<td>
<p>X as a matrix</p>
</td></tr>
<tr><td><code id="Z2Yhat_+3A_digits">digits</code></td>
<td>
<p>When non-NULL, output values close to whole numbers will be rounded using 
<code>digits</code> as input to <code>RoundWhole</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized inverse is computed by <code><a href="MASS.html#topic+ginv">ginv</a></code>.
In practise, the computations can be speeded up using reduced versions of X and Z. See <code><a href="#topic+ReduceX">ReduceX</a></code>.
</p>


<h3>Value</h3>

<p>Yhat as a matrix
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IpsoExtra">IpsoExtra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same data as in the paper
z &lt;- RegSDCdata("sec7z")
x &lt;- RegSDCdata("sec7x")
Z2Yhat(z, x)

# With y known, yHat can be computed in other ways
y &lt;- RegSDCdata("sec7y")  # Now z is t(x) %*% y 
fitted(lm(y ~ x - 1))
IpsoExtra(y, x, FALSE, resScale = 0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
