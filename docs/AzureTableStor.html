<!DOCTYPE html><html><head><title>Help for package AzureTableStor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AzureTableStor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create_table_operation'><p>Batch transactions for table storage</p></a></li>
<li><a href='#insert_table_entity'><p>Operations on table entities (rows)</p></a></li>
<li><a href='#storage_table'><p>Operations with azure tables</p></a></li>
<li><a href='#table_endpoint'><p>Table storage endpoint</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interface to the Table Storage Service in 'Azure'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface to the table storage service in 'Azure': <a href="https://azure.microsoft.com/en-us/services/storage/tables/">https://azure.microsoft.com/en-us/services/storage/tables/</a>. Supplies functionality for reading and writing data stored in tables, both as part of a storage account and from a 'CosmosDB' database with the table service API. Part of the 'AzureR' family of packages.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Azure/AzureTableStor">https://github.com/Azure/AzureTableStor</a>
<a href="https://github.com/Azure/AzureR">https://github.com/Azure/AzureR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Azure/AzureTableStor/issues">https://github.com/Azure/AzureTableStor/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, AzureRMR (&ge; 2.0.0), AzureStor (&ge; 3.0.0), jsonlite,
openssl, httr, uuid, vctrs (&ge; 0.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-28 20:15:19 UTC; hongo</td>
</tr>
<tr>
<td>Author:</td>
<td>Hong Ooi [aut, cre],
  Microsoft [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hong Ooi &lt;hongooi73@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-05 07:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='create_table_operation'>Batch transactions for table storage</h2><span id='topic+create_table_operation'></span><span id='topic+create_batch_transaction'></span><span id='topic+do_batch_transaction'></span><span id='topic+do_batch_transaction.batch_transaction'></span>

<h3>Description</h3>

<p>Batch transactions for table storage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_table_operation(
  endpoint,
  path,
  options = list(),
  headers = list(),
  body = NULL,
  metadata = c("none", "minimal", "full"),
  http_verb = c("GET", "PUT", "POST", "PATCH", "DELETE", "HEAD")
)

create_batch_transaction(endpoint, operations)

do_batch_transaction(transaction, ...)

## S3 method for class 'batch_transaction'
do_batch_transaction(
  transaction,
  batch_status_handler = c("warn", "stop", "message", "pass"),
  num_retries = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_table_operation_+3A_endpoint">endpoint</code></td>
<td>
<p>A table storage endpoint, of class <code>table_endpoint</code>.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_path">path</code></td>
<td>
<p>The path component of the operation.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_options">options</code></td>
<td>
<p>A named list giving the query parameters for the operation.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_headers">headers</code></td>
<td>
<p>A named list giving any additional HTTP headers to send to the host. AzureCosmosR will handle authentication details, so you don't have to specify these here.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_body">body</code></td>
<td>
<p>The request body for a PUT/POST/PATCH operation.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_metadata">metadata</code></td>
<td>
<p>The level of ODATA metadata to include in the response.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_http_verb">http_verb</code></td>
<td>
<p>The HTTP verb (method) for the operation.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_operations">operations</code></td>
<td>
<p>A list of individual table operation objects, each of class <code>table_operation</code>.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_transaction">transaction</code></td>
<td>
<p>For <code>do_batch_transaction</code>, an object of class <code>batch_transaction</code>.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_...">...</code></td>
<td>
<p>Arguments passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_batch_status_handler">batch_status_handler</code></td>
<td>
<p>For <code>do_batch_transaction</code>, what to do if one or more of the batch operations fails. The default is to signal a warning and return a list of response objects, from which the details of the failure(s) can be determined. Set this to &quot;pass&quot; to ignore the failure.</p>
</td></tr>
<tr><td><code id="create_table_operation_+3A_num_retries">num_retries</code></td>
<td>
<p>The number of times to retry the call, if the response is a HTTP error 429 (too many requests). The Cosmos DB endpoint tends to be aggressive at rate-limiting requests, to maintain the desired level of latency. This will generally not affect calls to an endpoint provided by a storage account.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Table storage supports batch transactions on entities that are in the same table and belong to the same partition group. Batch transactions are also known as <em>entity group transactions</em>.
</p>
<p>You can use <code>create_table_operation</code> to produce an object corresponding to a single table storage operation, such as inserting, deleting or updating an entity. Multiple such objects can then be passed to <code>create_batch_transaction</code>, which bundles them into a single atomic transaction. Call <code>do_batch_transaction</code> to send the transaction to the endpoint.
</p>
<p>Note that batch transactions are subject to some limitations imposed by the REST API:
</p>

<ul>
<li><p> All entities subject to operations as part of the transaction must have the same <code>PartitionKey</code> value.
</p>
</li>
<li><p> An entity can appear only once in the transaction, and only one operation may be performed against it.
</p>
</li>
<li><p> The transaction can include at most 100 entities, and its total payload may be no more than 4 MB in size.
</p>
</li></ul>



<h3>Value</h3>

<p><code>create_table_operation</code> returns an object of class <code>table_operation</code>.
</p>
<p>Assuming the batch transaction did not fail due to rate-limiting, <code>do_batch_transaction</code> returns a list of objects of class <code>table_operation_response</code>, representing the results of each individual operation. Each object contains elements named <code>status</code>, <code>headers</code> and <code>body</code> containing the respective parts of the response. Note that the number of returned objects may be smaller than the number of operations in the batch, if the transaction failed.
</p>


<h3>See Also</h3>

<p><a href="#topic+import_table_entities">import_table_entities</a>, which uses (multiple) batch transactions under the hood
</p>
<p><a href="https://docs.microsoft.com/en-us/rest/api/storageservices/performing-entity-group-transactions">Performing entity group transactions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

endp &lt;- table_endpoint("https://mycosmosdb.table.cosmos.azure.com:443", key="mykey")
tab &lt;- create_storage_table(endp, "mytable")

## a simple batch insert
ir &lt;- subset(iris, Species == "setosa")

# property names must be valid C# variable names
names(ir) &lt;- sub("\\.", "_", names(ir))

# create the PartitionKey and RowKey properties
ir$PartitionKey &lt;- ir$Species
ir$RowKey &lt;- sprintf("%03d", seq_len(nrow(ir)))

# generate the array of insert operations: 1 per row
ops &lt;- lapply(seq_len(nrow(ir)), function(i)
    create_table_operation(endp, "mytable", body=ir[i, ], http_verb="POST")))

# create a batch transaction and send it to the endpoint
bat &lt;- create_batch_transaction(endp, ops)
do_batch_transaction(bat)


## End(Not run)
</code></pre>

<hr>
<h2 id='insert_table_entity'>Operations on table entities (rows)</h2><span id='topic+insert_table_entity'></span><span id='topic+table_entity'></span><span id='topic+update_table_entity'></span><span id='topic+delete_table_entity'></span><span id='topic+list_table_entities'></span><span id='topic+get_table_entity'></span><span id='topic+import_table_entities'></span>

<h3>Description</h3>

<p>Operations on table entities (rows)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_table_entity(table, entity)

update_table_entity(
  table,
  entity,
  row_key = NULL,
  partition_key = NULL,
  etag = NULL
)

delete_table_entity(table, row_key, partition_key, etag = NULL)

list_table_entities(table, filter = NULL, select = NULL, as_data_frame = TRUE)

get_table_entity(table, row_key, partition_key, select = NULL)

import_table_entities(
  table,
  data,
  row_key = NULL,
  partition_key = NULL,
  batch_status_handler = c("warn", "stop", "message", "pass"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_table_entity_+3A_table">table</code></td>
<td>
<p>A table object, of class <code>storage_table</code>.</p>
</td></tr>
<tr><td><code id="insert_table_entity_+3A_entity">entity</code></td>
<td>
<p>For <code>insert_table_entity</code> and <code>update_table_entity</code>, a named list giving the properties (columns) of the entity. See 'Details' below.</p>
</td></tr>
<tr><td><code id="insert_table_entity_+3A_row_key">row_key</code>, <code id="insert_table_entity_+3A_partition_key">partition_key</code></td>
<td>
<p>For <code>get_table_entity</code>, <code>update_table_entity</code> and <code>delete_table_entity</code>, the row and partition key values that identify the entity to get, update or delete. For <code>import_table_entities</code>, the columns in the imported data to treat as the row and partition keys. The default is to use columns named 'RowKey' and 'PartitionKey' respectively.</p>
</td></tr>
<tr><td><code id="insert_table_entity_+3A_etag">etag</code></td>
<td>
<p>For <code>update_table_entity</code> and <code>delete_table_entity</code>, an optional Etag value. If this is supplied, the update or delete operation will proceed only if the target entity's Etag matches this value. This ensures that an entity is only updated/deleted if it has not been modified since it was last retrieved.</p>
</td></tr>
<tr><td><code id="insert_table_entity_+3A_filter">filter</code>, <code id="insert_table_entity_+3A_select">select</code></td>
<td>
<p>For <code>list_table_entities</code>, optional row filter and column select expressions to subset the result with. If omitted, <code>list_table_entities</code> will return all entities in the table.</p>
</td></tr>
<tr><td><code id="insert_table_entity_+3A_as_data_frame">as_data_frame</code></td>
<td>
<p>For <code>list_table_entities</code>, whether to return the results as a data frame, rather than a list of table rows.</p>
</td></tr>
<tr><td><code id="insert_table_entity_+3A_data">data</code></td>
<td>
<p>For <code>import_table_entities</code>, a data frame. See 'Details' below.</p>
</td></tr>
<tr><td><code id="insert_table_entity_+3A_batch_status_handler">batch_status_handler</code></td>
<td>
<p>For <code>import_table_entities</code>, what to do if one or more of the batch operations fails. The default is to signal a warning and return a list of response objects, from which the details of the failure(s) can be determined. Set this to &quot;pass&quot; to ignore the failure.</p>
</td></tr>
<tr><td><code id="insert_table_entity_+3A_...">...</code></td>
<td>
<p>For <code>import_table_entities</code>, further named arguments passed to <code>do_batch_transaction</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions operate on rows of a table, also known as <em>entities</em>. <code>insert</code>, <code>get</code>, <code>update</code> and <code>delete_table_entity</code> operate on an individual row. <code>import_table_entities</code> bulk-inserts multiple rows of data into the table, using batch transactions. <code>list_table_entities</code> queries the table and returns multiple rows, subsetted on the <code>filter</code> and <code>select</code> arguments.
</p>
<p>Table storage imposes the following requirements for properties (columns) of an entity:
</p>

<ul>
<li><p> There must be properties named <code>RowKey</code> and <code>PartitionKey</code>, which together form the entity's unique identifier. These properties must be of type character.
</p>
</li>
<li><p> The property <code>Timestamp</code> cannot be used (strictly speaking, it is reserved by the system).
</p>
</li>
<li><p> There can be at most 255 properties per entity, although different entities can have different properties.
</p>
</li>
<li><p> Table properties must be atomic. In particular, they cannot be nested lists.
</p>
</li></ul>

<p>Note that table storage does <em>not</em> require that all entities in a table must have the same properties.
</p>
<p>For <code>insert_table_entity</code>, <code>update_table_entity</code> and <code>import_table_entities</code>, you can also specify JSON text representing the data to insert/update/import, instead of a list or data frame.
</p>
<p><code>list_table_entities(as_data_frame=TRUE)</code> for a large table may be slow. If this is a problem, and you know that all entities in the table have the same schema, try setting <code>as_data_frame=FALSE</code> and converting to a data frame manually.
</p>


<h3>Value</h3>

<p><code>insert_table_entity</code> and <code>update_table_entity</code> return the Etag of the inserted/updated entity, invisibly.
</p>
<p><code>get_table_entity</code> returns a named list of properties for the given entity.
</p>
<p><code>list_table_entities</code> returns a data frame if <code>as_data_frame=TRUE</code>, and a list of entities (rows) otherwise.
</p>
<p><code>import_table_entities</code> invisibly returns a named list, with one component for each value of the <code>PartitionKey</code> column. Each component contains the results of the individual operations to insert each row into the table.
</p>


<h3>See Also</h3>

<p><a href="#topic+storage_table">storage_table</a>, <a href="#topic+do_batch_transaction">do_batch_transaction</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-the-table-service-data-model">Understanding the table service data model</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

endp &lt;- table_endpoint("https://mycosmosdb.table.cosmos.azure.com:443", key="mykey")
tab &lt;- create_storage_table(endp, "mytable")

insert_table_entity(tab, list(
    RowKey="row1",
    PartitionKey="partition1",
    firstname="Bill",
    lastname="Gates"
))

get_table_entity(tab, "row1", "partition1")

# specifying the entity as JSON text instead of a list
update_table_entity(tab,
'{
    "RowKey": "row1",
    "PartitionKey": "partition1",
    "firstname": "Bill",
    "lastname": "Gates"
}')

# we can import to the same table as above: table storage doesn't enforce a schema
import_table_entities(tab, mtcars,
    row_key=row.names(mtcars),
    partition_key=as.character(mtcars$cyl))

list_table_entities(tab)
list_table_entities(tab, filter="firstname eq 'Satya'")
list_table_entities(tab, filter="RowKey eq 'Toyota Corolla'")

delete_table_entity(tab, "row1", "partition1")


## End(Not run)
</code></pre>

<hr>
<h2 id='storage_table'>Operations with azure tables</h2><span id='topic+storage_table'></span><span id='topic+storage_table.table_endpoint'></span><span id='topic+list_storage_tables'></span><span id='topic+list_storage_tables.table_endpoint'></span><span id='topic+create_storage_table'></span><span id='topic+create_storage_table.table_endpoint'></span><span id='topic+create_storage_table.storage_table'></span><span id='topic+delete_storage_table'></span><span id='topic+delete_storage_table.table_endpoint'></span><span id='topic+delete_storage_table.storage_table'></span>

<h3>Description</h3>

<p>Operations with azure tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storage_table(endpoint, ...)

## S3 method for class 'table_endpoint'
storage_table(endpoint, name, ...)

list_storage_tables(endpoint, ...)

## S3 method for class 'table_endpoint'
list_storage_tables(endpoint, ...)

create_storage_table(endpoint, ...)

## S3 method for class 'table_endpoint'
create_storage_table(endpoint, name, ...)

## S3 method for class 'storage_table'
create_storage_table(endpoint, ...)

delete_storage_table(endpoint, ...)

## S3 method for class 'table_endpoint'
delete_storage_table(endpoint, name, confirm = TRUE, ...)

## S3 method for class 'storage_table'
delete_storage_table(endpoint, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storage_table_+3A_endpoint">endpoint</code></td>
<td>
<p>An object of class <code>table_endpoint</code> or, for <code>create_storage_table.storage_table</code>, an object of class <code>storage_table</code>.</p>
</td></tr>
<tr><td><code id="storage_table_+3A_...">...</code></td>
<td>
<p>Other arguments passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="storage_table_+3A_name">name</code></td>
<td>
<p>The name of a table in a storage account.</p>
</td></tr>
<tr><td><code id="storage_table_+3A_confirm">confirm</code></td>
<td>
<p>For deleting a table, whether to ask for confirmation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods are for accessing and managing tables within a storage account.
</p>


<h3>Value</h3>

<p><code>storage_table</code> and <code>create_storage_table</code> return an object of class <code>storage_table</code>. <code>list_storage_tables</code> returns a list of such objects.
</p>


<h3>See Also</h3>

<p><a href="#topic+table_endpoint">table_endpoint</a>, <a href="#topic+table_entity">table_entity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

endp &lt;- table_endpoint("https://mystorageacct.table.core.windows.net", key="mykey")

create_storage_table(endp, "mytable")
tab &lt;- storage_table(endp, "mytable2")
create_storage_table(tab)
list_storage_tables(endp)
delete_storage_table(tab)
delete_storage_table(endp, "mytable")


## End(Not run)
</code></pre>

<hr>
<h2 id='table_endpoint'>Table storage endpoint</h2><span id='topic+table_endpoint'></span><span id='topic+call_table_endpoint'></span>

<h3>Description</h3>

<p>Table storage endpoint object, and method to call it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_endpoint(
  endpoint,
  key = NULL,
  token = NULL,
  sas = NULL,
  api_version = getOption("azure_storage_api_version")
)

call_table_endpoint(
  endpoint,
  path,
  options = list(),
  headers = list(),
  body = NULL,
  ...,
  http_verb = c("GET", "DELETE", "PUT", "POST", "HEAD", "PATCH"),
  http_status_handler = c("stop", "warn", "message", "pass"),
  return_headers = (http_verb == "HEAD"),
  metadata = c("none", "minimal", "full"),
  num_retries = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_endpoint_+3A_endpoint">endpoint</code></td>
<td>
<p>For <code>table_endpoint</code>, the URL of the table service endpoint. This will be of the form <code style="white-space: pre;">&#8288;https://{account-name}.table.core.windows.net&#8288;</code> if the service is provided by a storage account in the Azure public cloud, while for a CosmosDB database, it will be of the form <code style="white-space: pre;">&#8288;https://{account-name}.table.cosmos.azure.com:443&#8288;</code>. For <code>call_table_endpoint</code>, an object of class <code>table_endpoint</code>.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_key">key</code></td>
<td>
<p>The access key for the storage account.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_token">token</code></td>
<td>
<p>An Azure Active Directory (AAD) authentication token. For compatibility with AzureStor; not used for table storage.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_sas">sas</code></td>
<td>
<p>A shared access signature (SAS) for the account. At least one of <code>key</code> or <code>sas</code> should be provided.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_api_version">api_version</code></td>
<td>
<p>The storage API version to use when interacting with the host. Defaults to &quot;2019-07-07&quot;.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_path">path</code></td>
<td>
<p>For <code>call_table_endpoint</code>, the path component of the endpoint call.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_options">options</code></td>
<td>
<p>For <code>call_table_endpoint</code>, a named list giving the query parameters for the operation.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_headers">headers</code></td>
<td>
<p>For <code>call_table_endpoint</code>, a named list giving any additional HTTP headers to send to the host. AzureCosmosR will handle authentication details, so you don't have to specify these here.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_body">body</code></td>
<td>
<p>For <code>call_table_endpoint</code>, the request body for a PUT/POST/PATCH call.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_...">...</code></td>
<td>
<p>For <code>call_table_endpoint</code>, further arguments passed to <code>AzureStor::call_storage_endpoint</code> and <code>httr::VERB</code>.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_http_verb">http_verb</code></td>
<td>
<p>For <code>call_table_endpoint</code>, the HTTP verb (method) of the operation.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_http_status_handler">http_status_handler</code></td>
<td>
<p>For <code>call_table_endpoint</code>, the R handler for the HTTP status code of the response. <code>"stop"</code>, <code>"warn"</code> or <code>"message"</code> will call the corresponding handlers in httr, while <code>"pass"</code> ignores the status code. The latter is primarily useful for debugging purposes.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_return_headers">return_headers</code></td>
<td>
<p>For <code>call_table_endpoint</code>, whether to return the (parsed) response headers instead of the body. Ignored if <code>http_status_handler="pass"</code>.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_metadata">metadata</code></td>
<td>
<p>For <code>call_table_endpoint</code>, the level of ODATA metadata to include in the response.</p>
</td></tr>
<tr><td><code id="table_endpoint_+3A_num_retries">num_retries</code></td>
<td>
<p>The number of times to retry the call, if the response is a HTTP error 429 (too many requests). The Cosmos DB endpoint tends to be aggressive at rate-limiting requests, to maintain the desired level of latency. This will generally not affect calls to an endpoint provided by a storage account.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>table_endpoint</code> returns an object of class <code>table_endpoint</code>, inheriting from <code>storage_endpoint</code>. This is the analogue of the <code>blob_endpoint</code>, <code>file_endpoint</code> and <code>adls_endpoint</code> classes provided by the AzureStor package.
</p>
<p><code>call_table_endpoint</code> returns the body of the response by default, or the headers if <code>return_headers=TRUE</code>. If <code>http_status_handler="pass"</code>, it returns the entire response object without modification.
</p>


<h3>See Also</h3>

<p><a href="#topic+storage_table">storage_table</a>, <a href="#topic+table_entity">table_entity</a>, <a href="AzureStor.html#topic+storage_call">AzureStor::call_storage_endpoint</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/rest/api/storageservices/table-service-rest-api">Table service REST API reference</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/rest/api/storageservices/authorize-requests-to-azure-storage">Authorizing requests to Azure storage services</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# storage account table endpoint
table_endpoint("https://mystorageacct.table.core.windows.net", key="mykey")

# Cosmos DB table endpoint
table_endpoint("https://mycosmosdb.table.cosmos.azure.com:443", key="mykey")


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
