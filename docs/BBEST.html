<!DOCTYPE html><html><head><title>Help for package BBEST</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BBEST}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BBEST-package'>
<p>Bayesian Background Estimation.</p></a></li>
<li><a href='#calc.Gr'><p>Calculate and plot the Pair Distribution Function</p></a></li>
<li><a href='#do.fit'><p>Estimate background</p></a></li>
<li><a href='#do.fit.banks'><p>Estimate the background for individual banks</p></a></li>
<li><a href='#do.iter'><p>Estimate the background</p></a></li>
<li><a href='#fix.merge'>
<p>Merge .fix files</p></a></li>
<li><a href='#guide'>
<p>BBEST guide</p></a></li>
<li><a href='#Internals'><p>Functions used internally</p></a></li>
<li><a href='#mPlot.results'><p>Plot the background estimate</p></a></li>
<li><a href='#mPlot.results.banks'><p>Plot the background estimate for individual banks</p></a></li>
<li><a href='#mPlot.sqa'>
<p>Plot the total normalized scattering intensity function <code>S(Q)</code> for individual detector banks</p></a></li>
<li><a href='#prepare.banks.data'>
<p>Prepare data for estimating the background</p></a></li>
<li><a href='#Progress-class'><p>Reporting progress (object-oriented API)</p></a></li>
<li><a href='#progressInit'><p>Initialize progress</p></a></li>
<li><a href='#read.data'>
<p>Read data from file</p></a></li>
<li><a href='#read.sqa'><p>Read data from a <code>.sqa</code>-file</p></a></li>
<li><a href='#read.sqb'><p>Read data from a <code>.sqb</code>-file</p></a></li>
<li><a href='#runUI'><p>Start the GUI</p></a></li>
<li><a href='#set.control'><p>Set controls for the Differential Evolution Algorithm</p></a></li>
<li><a href='#set.data'><p>Set data</p></a></li>
<li><a href='#set.Gr'><p>Add information on the low-r behaviour of G(r)</p></a></li>
<li><a href='#set.lambda'><p>Set mean signal magnitude</p></a></li>
<li><a href='#set.SB'><p>Set the coherent baseline</p></a></li>
<li><a href='#set.sigma'>
<p>Set the experimental uncertainty</p></a></li>
<li><a href='#sqa.split'>
<p>Split .sqa file into individual files for each databank</p></a></li>
<li><a href='#test.signal'><p>A random function with a smooth background</p></a></li>
<li><a href='#trim.data'>
<p>Truncate data</p></a></li>
<li><a href='#withProgress'><p>Reporting progress (functional API)</p></a></li>
<li><a href='#write.fit.results'><p>Save results of the fit</p></a></li>
<li><a href='#write.fix'>
<p>Save a correction file for individual detector banks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Author:</td>
<td>Anton Gagin and Igor Levin with contributions from Charles R. Hogg III</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anton Gagin &lt;av.gagin@gmail.com&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Estimation of Incoherent Neutron Scattering Backgrounds</td>
</tr>
<tr>
<td>Description:</td>
<td>We implemented a Bayesian-statistics approach for 
        subtraction of incoherent scattering from neutron total-scattering data. 
        In this approach, the estimated background signal associated with 
        incoherent scattering maximizes the posterior probability, which combines 
        the likelihood of this signal in reciprocal and real spaces with the prior 
        that favors smooth lines. The description of the corresponding approach 
        could be found at Gagin and Levin (2014) &lt;<a href="https://doi.org/10.1107%2FS1600576714023796">doi:10.1107/S1600576714023796</a>&gt;.</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-11-18</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>DEoptim, aws, grid, ggplot2, reshape2, shiny, methods</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-19 06:03:23 UTC; aga</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-19 13:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='BBEST-package'>
Bayesian Background Estimation.
</h2><span id='topic+BBEST-package'></span><span id='topic+BBEST'></span>

<h3>Description</h3>

<p>In this package we implemented a Bayesian-statistics approach for 
subtraction of incoherent scattering from neutron total-scattering data. 
In this approach, the estimated background signal associated with 
incoherent scattering maximizes the posterior probability, which combines 
the likelihood of this signal in reciprocal and real spaces with the prior 
that favors smooth lines.
</p>
<p>To cite the BBEST package type: &lsquo;citation(&quot;BBEST&quot;)&rsquo; (without the single quotes).
</p>
<p>For a listing of all routines in the BBEST package type: &lsquo;library(help=&quot;BBEST&quot;)&rsquo;
</p>
<p>To start the Graphical User Interface type: &lsquo;runUI()&rsquo;
</p>
<p>To start a simple command-line guide type: &lsquo;guide()&rsquo;
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> BBEST</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-08-11</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Anton Gagin and Igor Levin with contributions from Charles R. Hogg III <br />
Maintainer: Anton Gagin &lt;anton.gagin@nist.gov&gt;
</p>


<h3>References</h3>

<p>BBEST-package
</p>

<hr>
<h2 id='calc.Gr'>Calculate and plot the Pair Distribution Function</h2><span id='topic+calc.Gr'></span>

<h3>Description</h3>

<p>Calculates and plots the corrected Pair Distribution Function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.Gr(fit.results, rho.0, plot=TRUE, r.min = 0, r.max = 5, 
        dr = 0.01, Q.min = NA, Q.max = NA, nsd = 2, gr.compare=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.Gr_+3A_fit.results">fit.results</code></td>
<td>
<p>the return value of <code><a href="#topic+do.fit">do.fit</a></code>.</p>
</td></tr>
<tr><td><code id="calc.Gr_+3A_plot">plot</code></td>
<td>
<p>logical, whether to plot the PDF.</p>
</td></tr>
<tr><td><code id="calc.Gr_+3A_rho.0">rho.0</code></td>
<td>
<p>numeric, the atomic number density of the material: the number of atoms per unit cell divided by a volume of the unit cell.</p>
</td></tr>
<tr><td><code id="calc.Gr_+3A_r.min">r.min</code>, <code id="calc.Gr_+3A_r.max">r.max</code>, <code id="calc.Gr_+3A_dr">dr</code></td>
<td>
<p>numerics. Function is plotted in the region <code>[r.min, r.max]</code>.</p>
</td></tr>
<tr><td><code id="calc.Gr_+3A_q.min">Q.min</code>, <code id="calc.Gr_+3A_q.max">Q.max</code></td>
<td>
<p>numerics. To calculate the sine-Fourier transform, the total scattering function S(Q) is &quot;terminated&quot; at a certain <code>Q=Qmax</code> point. The best Qmax point to terminate S(Q) (that corresponds to the value of S(Q)-1 closest to zero) is sought in the <code>[Q.min,Q.max]</code> region.</p>
</td></tr>
<tr><td><code id="calc.Gr_+3A_nsd">nsd</code></td>
<td>
<p>numeric, the number of standard deviations to plot the uncertainty.</p>
</td></tr>
<tr><td><code id="calc.Gr_+3A_gr.compare">gr.compare</code></td>
<td>
<p>numeric vector. If not <code>NA</code>, specifies the function to add to the plot. Should correspond to the same grid (<code>[r.min, r.max, dr]</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code>ggplot2</code> package for plotting. <code>ggplot2</code> package can be installed by typing <code>install.packges("ggplot2")</code>.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>numeric vector of grid points</p>
</td></tr>
<tr><td><code>gr</code></td>
<td>
<p>numeric vector, indicates the corrected Pair Distribution Function.</p>
</td></tr>
<tr><td><code>stdev</code></td>
<td>
<p>numeric vector, indicates estimated standard deviation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+do.fit">do.fit</a></code>
</p>

<hr>
<h2 id='do.fit'>Estimate background</h2><span id='topic+do.fit'></span>

<h3>Description</h3>

<p><code>do.fit</code> estimates the background using the Bayesian approach and Differential Evolution algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.fit(data, bounds.lower, bounds.upper, scale=c(1,1), knots.x=NA,
       knots.n=NA, analytical=FALSE, stdev=TRUE, control=list(), p.bkg=.5,
	   save.to="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.fit_+3A_data">data</code></td>
<td>
<p>an object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_bounds.lower">bounds.lower</code>, <code id="do.fit_+3A_bounds.upper">bounds.upper</code></td>
<td>
<p>numerics specifying the lower and upper bounds for the fitted spline values.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_scale">scale</code></td>
<td>
<p>numeric vector which, if applicable, determines the bounds for the fitted scale parameter. The default value of <code>c(1,1)</code> means a no-scale fit. See details.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_knots.x">knots.x</code></td>
<td>
<p>numeric vector which, if not <code>NA</code>, specifies the knot positions.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_knots.n">knots.n</code></td>
<td>
<p>numeric, the number of knots. If <code>knots.x</code> is <code>NA</code> then <code>knots.n</code> equidistant knots will be created.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_analytical">analytical</code></td>
<td>
<p>logical. If <code>TRUE</code> background is approximated by an analytical function <code class="reqn">f(x)=P_1\exp(-P_2x)x^{P_3} + P_4/[(x-P_5)^2+P_6^2]</code>.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_stdev">stdev</code></td>
<td>
<p>logical, whether to calculate the uncertainty for the estimated background. Should be set to <code>FALSE</code> if <code>analytical=TRUE</code>.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_control">control</code></td>
<td>
<p>list, the return value of <code><a href="#topic+set.control">set.control</a></code>. Specifies various parameters of the Differential Evolution optimization algorithm implemented in <code>DEoptim</code>.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_p.bkg">p.bkg</code></td>
<td>
<p>numeric, the probability that a single pixel contains &quot;only&quot; a background.</p>
</td></tr>
<tr><td><code id="do.fit_+3A_save.to">save.to</code></td>
<td>
<p>character, a filename for saving the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If information on the low-r behavior of G(r) is provided, the global intensity scale  and atomic displacement parameters can be fitted along with the positions of the knots,  (<code><a href="#topic+set.Gr">set.Gr</a></code>). To fit normalization parameter set bounds in <code>scale</code> for the desired values. To fit Atomic Displacement Parameters see <code><a href="#topic+set.SB">set.SB</a></code>.
</p>
<p>In most cases <code>p.bkg</code> should be set to its default value 0.5.
</p>
<p>For further details see <code><a href="#topic+BBEST-package">BBEST-package</a></code>.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>numeric vector of grid points</p>
</td></tr>
<tr><td><code>curves</code></td>
<td>
<p>list, see below.</p>
</td></tr>
<tr><td><code>uncrt</code></td>
<td>
<p>list, see below.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>list with elements <code>x</code> and <code>y</code> that specify the positions of the knots and the corresponding fitted intensity values, respectively.</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>numeric vector. If the background is approximated using the analytical function, contains all the relevant parameters <code>P</code>.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>fitted value of the <code>scale</code> parameter, if used.</p>
</td></tr>
<tr><td><code>ADP</code></td>
<td>
<p>fitted values of the atomic displacement parameters, if applicable.</p>
</td></tr>
<tr><td><code>fit.details</code></td>
<td>
<p>list, see below.</p>
</td></tr>
</table>
<p>Element <code>curves</code> is a list with sub-elements:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>numeric vector of the (normalized) function values.</p>
</td></tr>
<tr><td><code>bkg</code></td>
<td>
<p>numeric vector, the estimated background.</p>
</td></tr>
<tr><td><code>SB</code></td>
<td>
<p>numeric vector, the (fitted) coherent baseline.</p>
</td></tr>
</table>
<p>Element <code>uncrt</code> is a list with sub-elements:
</p>
<table>
<tr><td><code>stdev</code></td>
<td>
<p>numeric vector, indicates estimated standard deviations for the reconstructed signal.</p>
</td></tr>
<tr><td><code>stdev.r</code></td>
<td>
<p>numeric vector, indicates estimated standard deviations for a reconstructed signal in r-space.</p>
</td></tr>
<tr><td><code>hess</code></td>
<td>
<p>Hessian matrix for a <code class="reqn">\psi(c)</code> function.</p>
</td></tr>
<tr><td><code>cov.matrix</code></td>
<td>
<p>covariance matrix, i.e. the inverse of the Hessian.</p>
</td></tr>
<tr><td><code>cov.matrix.r</code></td>
<td>
<p>covariance matrix in r-space.</p>
</td></tr>
</table>
<p>Element <code>fit.details</code> is a list with sub-elements:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>numeric vector, the estimated mean magnitude of the signal.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>numeric vector, the estimated Gaussian noise.</p>
</td></tr>
<tr><td><code>knots.n</code></td>
<td>
<p>the number of knots used in the fit.</p>
</td></tr>
<tr><td><code>knots.x</code></td>
<td>
<p>knot positions used in the fit.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>see the <code>control</code> argument.</p>
</td></tr>
<tr><td><code>Gr</code></td>
<td>
<p>list contacting information on the low-r behaviour of G(r) . See <code><a href="#topic+set.Gr">set.Gr</a></code> for details.</p>
</td></tr>
<tr><td><code>n.atoms</code></td>
<td>
<p>numeric vector, number of different atoms per unit cell.</p>
</td></tr>
<tr><td><code>scatter.length</code></td>
<td>
<p>numeric vector, atomic scattering factors.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ardia, D., Mullen, K., Peterson, B. &amp; Ulrich, J. (2011): DEoptim. R Package Version 2.2-2. <a href="https://CRAN.R-project.org/package=DEoptim">https://CRAN.R-project.org/package=DEoptim</a>.
</p>
<p>Mullen, K.M., Ardia, D., Gil, D., Windover, D., Cline, J. (2011): DEoptim: An R Package for Global Optimization by Differential Evolution. <em>J. Stat. Softw.</em>, <b>40</b>(6), 1-26. <a href="https://www.jstatsoft.org/article/view/v040i06">https://www.jstatsoft.org/article/view/v040i06</a>.
</p>

<hr>
<h2 id='do.fit.banks'>Estimate the background for individual banks</h2><span id='topic+do.fit.banks'></span>

<h3>Description</h3>

<p><code>do.fit</code> estimates the background for individual banks according to the Bayesian approach using the Differential Evolution algorithm </p>


<h3>Usage</h3>

<pre><code class='language-R'>do.fit.banks(data, bounds.lower, bounds.upper, knots.n.left, 
             knots.n.right, x.boundary, analytical=FALSE, control, 
             save.to="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.fit.banks_+3A_data">data</code></td>
<td>
<p>an object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>
</td></tr>
<tr><td><code id="do.fit.banks_+3A_bounds.lower">bounds.lower</code>, <code id="do.fit.banks_+3A_bounds.upper">bounds.upper</code></td>
<td>
<p>numerics, lower and upper bounds for the fitted spline values.</p>
</td></tr>
<tr><td><code id="do.fit.banks_+3A_knots.n.left">knots.n.left</code>, <code id="do.fit.banks_+3A_knots.n.right">knots.n.right</code>, <code id="do.fit.banks_+3A_x.boundary">x.boundary</code></td>
<td>
<p>numerics that specify the number of knots. <code>knots.n.left</code> and <code>knots.n.right</code> knots are created on the left and on the right of <code>x.boundary</code> point, respectively.</p>
</td></tr>
<tr><td><code id="do.fit.banks_+3A_analytical">analytical</code></td>
<td>
<p>logical. If <code>TRUE</code> background is approximated by an analytical function <code class="reqn">f(x)=P_1\exp(-P_2x)x^{P_3} + P_4/[(x-P_5)^2+P_6^2]</code>.</p>
</td></tr>
<tr><td><code id="do.fit.banks_+3A_control">control</code></td>
<td>
<p>list, the return value of <code><a href="#topic+set.control">set.control</a></code>. Specifies various parameters of the Differential Evolution optimization algorithm implemented in <code>DEoptim</code>. </p>
</td></tr>
<tr><td><code id="do.fit.banks_+3A_save.to">save.to</code></td>
<td>
<p>character, a filename for saving the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simplifies the procedure for estimating the background for several detector banks by a multiple call of <code><a href="#topic+do.fit">do.fit</a></code>. Other relevant parameters are set to: <code>stdev=FALSE,  scale=NA,  p.bkg=.5</code>. 
</p>
<p>For neutron scattering, the incoherent background exhibits a broad peak at low Q and decays gradually at higher Q. Hence, we suggest to use different numbers of knots for the low- and high-Q  regions. See <code><a href="#topic+BBEST-package">BBEST-package</a></code> for details. 
</p>


<h3>Value</h3>

<p>A list of elements. Each element contains a return value of <code><a href="#topic+do.fit">do.fit</a></code> for the corresponding data bank.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+do.fit">do.fit</a></code>, <code><a href="#topic+BBEST-package">BBEST-package</a></code>
</p>

<hr>
<h2 id='do.iter'>Estimate the background</h2><span id='topic+do.iter'></span>

<h3>Description</h3>

<p><code>do.iter</code> performs adaptive Bayesian  estimation of the background.</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.iter(fit.results, local = TRUE, eps = 1e-04, 
        n.iter = 10000, save.to = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.iter_+3A_fit.results">fit.results</code></td>
<td>
<p>list. The return value of <code><a href="#topic+do.fit">do.fit</a></code>.</p>
</td></tr>
<tr><td><code id="do.iter_+3A_local">local</code></td>
<td>
<p>logical. If <code>TRUE</code>, gradient descent method is used to find background estimation. If <code>FALSE</code>, Differential Evolution is used.</p>
</td></tr>
<tr><td><code id="do.iter_+3A_eps">eps</code></td>
<td>
<p>numeric, the desired accuracy for spline values.</p>
</td></tr>
<tr><td><code id="do.iter_+3A_n.iter">n.iter</code></td>
<td>
<p>numeric, number of iterations for a gradient descent method, see details.</p>
</td></tr>
<tr><td><code id="do.iter_+3A_save.to">save.to</code></td>
<td>
<p>character, the filename for saving the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An adaptation of neutron scattering data for a Bayesian background separation procedure. The method is detailed elsewhere*.
</p>
<p>First, use the function <code><a href="#topic+do.fit">do.fit</a></code> to estimate the background <em>from</em> the low-r information in G(r). <code>do.iter</code> procedure estimates the background <em>without</em> low-r information, calculates the difference between the two estimates, subtracts this difference from the scattering data and finds the new estimate of the background. 
</p>


<h3>Value</h3>

 
<p>An object <code>fit.results</code> with modified elements <code>fit.results$curves$bkg</code>, 	<code>fit.results$curves$y</code>	and <code>fit.results$curves$corr</code>. See <code><a href="#topic+do.fit">do.fit</a></code> for details.  
</p>


<h3>References</h3>

<p>*Gagin, A. and Levin, I. Hydrogen background estimation in neutron total scattering experiments. Submitted for publication.
</p>

<hr>
<h2 id='fix.merge'>
Merge .fix files
</h2><span id='topic+fix.merge'></span>

<h3>Description</h3>

<p><code>fix.merge</code> merges several .fix files into a specified file in a form suitable for <em>PDFgetN</em>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.merge(outfile, infile1, infile2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.merge_+3A_outfile">outfile</code></td>
<td>
<p>character, the filename for saving the data.</p>
</td></tr>
<tr><td><code id="fix.merge_+3A_infile1">infile1</code>, <code id="fix.merge_+3A_infile2">infile2</code>, <code id="fix.merge_+3A_...">...</code></td>
<td>
<p>files to merge.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+write.fix">write.fix</a></code>, <code><a href="#topic+read.sqa">read.sqa</a></code>, <code><a href="#topic+do.fit.banks">do.fit.banks</a></code>, <code><a href="#topic+BBEST-package">BBEST-package</a></code>
</p>

<hr>
<h2 id='guide'>
BBEST guide
</h2><span id='topic+guide'></span>

<h3>Description</h3>

<p><code>guide</code> is a function that guides through the Bayesian procedure for estimating the background 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide()
</code></pre>


<h3>Value</h3>

 
<p>A list with elements:
</p>
<table>
<tr><td><code>fit.res</code></td>
<td>
<p>the return value of <code><a href="#topic+do.fit">do.fit</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>an object of type <code>data</code>, see <code><a href="#topic+set.data">set.data</a></code>.</p>
</td></tr>
<tr><td><code>gr</code></td>
<td>
<p>the return value of <code><a href="#topic+calc.Gr">calc.Gr</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Internals'>Functions used internally</h2><span id='topic+Internals'></span><span id='topic+basisMatrix'></span><span id='topic+basisSpline'></span><span id='topic+DMatrix'></span><span id='topic+Dx'></span><span id='topic+bkg.analyt'></span><span id='topic+fplot.Gr'></span><span id='topic+get.bkg'></span><span id='topic+get.deriv'></span><span id='topic+get.deriv.numerically'></span><span id='topic+get.hess.numerically'></span><span id='topic+get.hess'></span><span id='topic+get.posterior'></span><span id='topic+golden.search'></span><span id='topic+grad.descent'></span><span id='topic+invert.order'></span><span id='topic+logLikelihoodBkg'></span><span id='topic+logLikelihoodBkgAnalyt'></span><span id='topic+logLikelihoodGrCorr'></span><span id='topic+logLikelihoodGrGauss'></span><span id='topic+logLikelihoodSignal'></span><span id='topic+logLikelihoodSignalAnalyt'></span><span id='topic+logPosterior'></span><span id='topic+logPosteriorAnalyt'></span><span id='topic+logPriorBkgRGP'></span><span id='topic+logPriorBkgRSmooth'></span><span id='topic+logPriorF'></span><span id='topic+logProbabilityBkgR'></span><span id='topic+noise.cov.matrix.r'></span><span id='topic+noise.cov.r'></span><span id='topic+noise.cov.vector.r'></span><span id='topic+regularized.cholesky'></span><span id='topic+sineFT.matrix'></span><span id='topic+sineFT'></span><span id='topic+step1'></span><span id='topic+step2'></span><span id='topic+step3'></span><span id='topic+step5'></span><span id='topic+step6'></span><span id='topic+step7'></span><span id='topic+step8'></span><span id='topic+step9'></span><span id='topic+step10'></span><span id='topic+set.DEoptim.control'></span><span id='topic+row.outer.product'></span><span id='topic+covMatrixSE'></span><span id='topic+covMatrix.DI'></span><span id='topic+whatIsSpecified'></span><span id='topic+fpe'></span>

<h3>Description</h3>

<p>Functions used internally</p>

<hr>
<h2 id='mPlot.results'>Plot the background estimate</h2><span id='topic+mPlot.results'></span>

<h3>Description</h3>

<p>Plots the estimated background and the corrected function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPlot.results(fit.results, label.x = "x", label.y = "y",
              xlim=NA, ylim=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPlot.results_+3A_fit.results">fit.results</code></td>
<td>
<p>the return value of <code><a href="#topic+do.fit">do.fit</a></code>.</p>
</td></tr>
<tr><td><code id="mPlot.results_+3A_label.x">label.x</code>, <code id="mPlot.results_+3A_label.y">label.y</code></td>
<td>
<p>characters, titles for x and y axes.</p>
</td></tr>
<tr><td><code id="mPlot.results_+3A_xlim">xlim</code>, <code id="mPlot.results_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors with two entries. If not <code>NA</code>, specify x- and y-axis limits. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code>ggplot2</code> and <code>gridExtra</code> packages for plotting. Packages can be installed by typing <code>install.packges("ggplot2")</code> and <code>install.packges("gridExtra")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+do.fit">do.fit</a></code></p>

<hr>
<h2 id='mPlot.results.banks'>Plot the background estimate for individual banks</h2><span id='topic+mPlot.results.banks'></span>

<h3>Description</h3>

<p>Plots the background estimate for individual detector banks. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPlot.results.banks(fit.results, label.x = "x", label.y = "y",
                    xlim=NA, ylim=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPlot.results.banks_+3A_fit.results">fit.results</code></td>
<td>
<p>the return value of <code><a href="#topic+do.fit.banks">do.fit.banks</a></code>.</p>
</td></tr>
<tr><td><code id="mPlot.results.banks_+3A_label.x">label.x</code>, <code id="mPlot.results.banks_+3A_label.y">label.y</code></td>
<td>
<p>characters, titles for x and y axes.</p>
</td></tr>
<tr><td><code id="mPlot.results.banks_+3A_xlim">xlim</code>, <code id="mPlot.results.banks_+3A_ylim">ylim</code></td>
<td>
<p>numeric matrices of size <code>(NB, 2)</code>, where <code>NB</code> is the number of data banks. If not <code>NA</code>, specify x- and y-axis limits. </p>
</td></tr>  
</table>


<h3>See Also</h3>

<p><code><a href="#topic+do.fit.banks">do.fit.banks</a></code></p>

<hr>
<h2 id='mPlot.sqa'>
Plot the total normalized scattering intensity function <code>S(Q)</code> for individual detector banks
</h2><span id='topic+mPlot.sqa'></span>

<h3>Description</h3>

<p>The function plots the total scattering functions <code>S(Q)</code> returned by <code>PDFgetN</code> in <code><a href="#topic+read.sqa">read.sqa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPlot.sqa(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPlot.sqa_+3A_data">data</code></td>
<td>
<p>list, the return value of <code><a href="#topic+read.sqa">read.sqa</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read.sqa">read.sqa</a></code></p>

<hr>
<h2 id='prepare.banks.data'>
Prepare data for estimating the background 
</h2><span id='topic+prepare.banks.data'></span>

<h3>Description</h3>

<p><code>prepare.banks.data</code> sets all the fit parameters, such as <code>sigma</code>, <code>lambda</code> and <code>SB</code> for a set of detector banks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.banks.data(data, n.banks=4, lambda_1, lambda_2, lambda_0, 
                   x_1, x_2, n.atoms, scatter.length, ADP, n.regions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.banks.data_+3A_data">data</code></td>
<td>
<p>list of objects of type <code>data</code>. See <code><a href="#topic+read.sqa">read.sqa</a></code> and <code><a href="#topic+set.data">set.data</a></code> for details.</p>
</td></tr>
<tr><td><code id="prepare.banks.data_+3A_n.banks">n.banks</code></td>
<td>
<p>numeric, number of banks.</p>
</td></tr>
<tr><td><code id="prepare.banks.data_+3A_lambda_1">lambda_1</code>, <code id="prepare.banks.data_+3A_lambda_2">lambda_2</code>, <code id="prepare.banks.data_+3A_lambda_0">lambda_0</code>, <code id="prepare.banks.data_+3A_x_1">x_1</code>, <code id="prepare.banks.data_+3A_x_2">x_2</code></td>
<td>
<p>parameters to be passed to <code><a href="#topic+set.lambda">set.lambda</a></code>.</p>
</td></tr>
<tr><td><code id="prepare.banks.data_+3A_n.atoms">n.atoms</code>, <code id="prepare.banks.data_+3A_scatter.length">scatter.length</code>, <code id="prepare.banks.data_+3A_adp">ADP</code></td>
<td>
<p>parameters to be passed to <code><a href="#topic+set.SB">set.SB</a></code>.</p>
</td></tr>
<tr><td><code id="prepare.banks.data_+3A_n.regions">n.regions</code></td>
<td>
<p>parameter to be passed to <code><a href="#topic+set.sigma">set.sigma</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simplifies setting the fit parameters for a set of detector banks by a multiple call of <code><a href="#topic+set.sigma">set.sigma</a></code>, <code><a href="#topic+set.SB">set.SB</a></code>, and <code><a href="#topic+set.lambda">set.lambda</a></code>.
</p>


<h3>Value</h3>

<p>A list of objects of type <code>data</code> suitable for <code><a href="#topic+do.fit.banks">do.fit.banks</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.sigma">set.sigma</a></code>, <code><a href="#topic+set.SB">set.SB</a></code>, <code><a href="#topic+set.lambda">set.lambda</a></code> 
</p>

<hr>
<h2 id='Progress-class'>Reporting progress (object-oriented API)</h2><span id='topic+Progress-class'></span><span id='topic+Progress'></span>

<h3>Description</h3>

<p>Reports progress to the user during long-running operations.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Progress-class_+3A_session">session</code></td>
<td>
<p>The Shiny session object, as provided by
<code>shinyServer</code> to the server function.</p>
</td></tr>
<tr><td><code id="Progress-class_+3A_min">min</code></td>
<td>
<p>The value that represents the starting point of the
progress bar. Must be less than <code>max</code>.</p>
</td></tr>
<tr><td><code id="Progress-class_+3A_max">max</code></td>
<td>
<p>The value that represents the end of the progress bar.
Must be greater than <code>min</code>.</p>
</td></tr>
<tr><td><code id="Progress-class_+3A_message">message</code></td>
<td>
<p>A single-element character vector; the message to be
displayed to the user, or <code>NULL</code> to hide the current message
(if any).</p>
</td></tr>
<tr><td><code id="Progress-class_+3A_detail">detail</code></td>
<td>
<p>A single-element character vector; the detail message
to be displayed to the user, or <code>NULL</code> to hide the current
detail message (if any). The detail message will be shown with a
de-emphasized appearance relative to <code>message</code>.</p>
</td></tr>
<tr><td><code id="Progress-class_+3A_value">value</code></td>
<td>
<p>Single-element numeric vector; the value at which to set
the progress bar, relative to <code>min</code> and <code>max</code>.
<code>NULL</code> hides the progress bar, if it is currently visible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package exposes two distinct programming APIs for working with
progress. <code><a href="#topic+withProgress">withProgress</a></code> and <code><a href="#topic+setProgress">setProgress</a></code>
together provide a simple function-based interface, while the
<code>Progress</code> reference class provides an object-oriented API.
</p>
<p>Instantiating a <code>Progress</code> object causes a progress panel to be
created, and it will be displayed the first time the <code>set</code>
method is called. Calling <code>close</code> will cause the progress panel
to be removed.
</p>
<p><strong>Methods</strong>
</p>

<dl>
<dt><code>initialize(session, min = 0, max = 1)</code></dt><dd>
<p>Creates a new progress panel (but does not display it).
</p>
</dd>
<dt><code>set(message = NULL, detail = NULL, value = NULL)</code></dt><dd>
<p>Updates the progress panel. When called the first time, the
progress panel is displayed.
</p>
</dd>
<dt><code>close()</code></dt><dd>
<p>Removes the progress panel. Future calls to <code>set</code> and
<code>close</code> will be ignored.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+progressInit">progressInit</a></code>, <code><a href="#topic+withProgress">withProgress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# server.R
shinyServer(function(input, output, session) {
  output$plot &lt;- renderPlot({
    progress &lt;- Progress$new(session, min=1, max=15)
    on.exit(progress$close())

    progress$set(message = 'Calculation in progress',
                 detail = 'This may take a while...')

    for (i in 1:15) {
      progress$set(value = i)
      Sys.sleep(0.5)
    }
    plot(cars)
  })
})

## End(Not run)
</code></pre>

<hr>
<h2 id='progressInit'>Initialize progress</h2><span id='topic+progressInit'></span>

<h3>Description</h3>

<p>Call this function in your <code>shinyUI</code> definition if you intend
to use progress in <code>server.R</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progressInit()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+withProgress">withProgress</a></code>, <code><a href="#topic+Progress">Progress</a></code>
</p>

<hr>
<h2 id='read.data'>
Read data from file
</h2><span id='topic+read.data'></span>

<h3>Description</h3>

<p>Reads data from a text file with columns &quot;x&quot;, &quot;y&quot;, and, optionally, &quot;lambda&quot;, &quot;sigma&quot; and &quot;SB&quot;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.data(file = stop("'file' must be specified"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.data_+3A_file">file</code></td>
<td>
<p>character, the name of the file which the data are to be read from.</p>
</td></tr>
<tr><td><code id="read.data_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>read.table</code> (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements one of the ways to load experimental data. The <code>file</code> must consist of a header with column names and several columns below. First two columns in <code>file</code> must be <code>x</code> and <code>y</code> values. The others could specify <code>lambda</code>, <code>sigma</code> and <code>SB</code>.
</p>


<h3>Value</h3>

<p>An object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.
</p>

<hr>
<h2 id='read.sqa'>Read data from a <code>.sqa</code>-file</h2><span id='topic+read.sqa'></span>

<h3>Description</h3>

<p>This function reads .sqa-files generated by <em>PDFgetN</em>, which contain corrected total-scattering functions bank by bank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.sqa(file = stop("'file' must be specified"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.sqa_+3A_file">file</code></td>
<td>
<p>character, the name of the file which the data are to be read from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List those elements are objects of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>


<h3>References</h3>

<p>Peterson, P.F., Gutmann, M., Proffen, TH. &amp; Billinge, S.J.L. (2000): PDFgetN: A User-Friendly Program to Extract the Total Scattering Structure Function and the Pair Distribution Function from Neutron Powder Diffraction Data. <em>J. Appl. Cryst.</em>, <b>33</b>, 1192. <a href="https://web.pa.msu.edu/cmp/billinge-group/programs/pdfgetn/pdfgetn_jac.pdf">https://web.pa.msu.edu/cmp/billinge-group/programs/pdfgetn/pdfgetn_jac.pdf</a>.
</p>
<p>Proffen, TH., Peterson, P.F., Gutmann, M. &amp; Billinge, S.J.L. (2009): PDFgetN Users Guide Version 1.6.6. <a href="http://pdfgetn.sourceforge.net/">http://pdfgetn.sourceforge.net/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mPlot.sqa">mPlot.sqa</a></code></p>

<hr>
<h2 id='read.sqb'>Read data from a <code>.sqb</code>-file</h2><span id='topic+read.sqb'></span>

<h3>Description</h3>

<p>This function reads .sqb-files generated by <em>PDFgetN</em>, which contain the corrected and blended total-scattering function S(Q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.sqb(file = stop("'file' must be specified"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.sqb_+3A_file">file</code></td>
<td>
<p>character, the name of the file which the data are to be read from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>


<h3>References</h3>

<p>Peterson, P.F., Gutmann, M., Proffen, TH. &amp; Billinge, S.J.L. (2000): PDFgetN: A User-Friendly Program to Extract the Total Scattering Structure Function and the Pair Distribution Function from Neutron Powder Diffraction Data. <em>J. Appl. Cryst.</em>, <b>33</b>, 1192. <a href="https://web.pa.msu.edu/cmp/billinge-group/programs/pdfgetn/pdfgetn_jac.pdf">https://web.pa.msu.edu/cmp/billinge-group/programs/pdfgetn/pdfgetn_jac.pdf</a>.
</p>
<p>Proffen, TH., Peterson, P.F., Gutmann, M. &amp; Billinge, S.J.L. (2009): PDFgetN Users Guide Version 1.6.6. <a href="http://pdfgetn.sourceforge.net/">http://pdfgetn.sourceforge.net/</a>.
</p>

<hr>
<h2 id='runUI'>Start the GUI</h2><span id='topic+runUI'></span>

<h3>Description</h3>

<p>Starts the application and opens up the default web browser to view it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runUI()
</code></pre>


<h3>Details</h3>

<p>Runs a <b>Shiny</b> application. This function normally does not return; interrupt boldR to stop the application (usually by pressing Ctrl+C or Esc).
</p>

<hr>
<h2 id='set.control'>Set controls for the Differential Evolution Algorithm</h2><span id='topic+set.control'></span>

<h3>Description</h3>

<p>Specifies various parameters of the Differential Evolution optimization algorithm implemented in <code>DEoptim</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control(CR=.85, F=.7, NP=300, itermax=2000, parallelType=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.control_+3A_cr">CR</code></td>
<td>
<p>numeric, crossover probability from interval [0,1].</p>
</td></tr>
<tr><td><code id="set.control_+3A_f">F</code></td>
<td>
<p>numeric, differential weighting factor from interval [0,2].</p>
</td></tr>
<tr><td><code id="set.control_+3A_np">NP</code></td>
<td>
<p>numeric, number of population members</p>
</td></tr>
<tr><td><code id="set.control_+3A_itermax">itermax</code></td>
<td>
<p>numeric, the number of iterations</p>
</td></tr>
<tr><td><code id="set.control_+3A_paralleltype">parallelType</code></td>
<td>
<p>numeric, defines the type of parallelization to employ. <code>0</code> for a single-core run. If <code>parallelType=1</code> the program will use all the available cores, via the <code>parallel</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the most tasks, it is best to set <code>NP</code> to at least 10-15 times the length of the parameter vector.</p>


<h3>Value</h3>

<p>a list of elements suitable for <code><a href="#topic+do.fit">do.fit</a></code> and <code><a href="#topic+do.fit.banks">do.fit.banks</a></code>.</p>


<h3>References</h3>

<p>Mullen, K.M., Ardia, D., Gil, D., Windover, D., Cline, J. (2011): DEoptim: An R Package for Global Optimization by Differential Evolution. <em>J. Stat. Softw.</em>, <b>40</b>(6), 1-26. <a href="https://www.jstatsoft.org/article/view/v040i06">https://www.jstatsoft.org/article/view/v040i06</a>.
</p>

<hr>
<h2 id='set.data'>Set data</h2><span id='topic+set.data'></span>

<h3>Description</h3>

<p>The function sets key parameters necessary for the fit, such as <code>sigma</code>, <code>lambda</code> and <code>SB</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>set.data(x, y, sigma=NA, lambda=NA, SB=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.data_+3A_x">x</code></td>
<td>
<p>numeric vector, specifies grid points.</p>
</td></tr>
<tr><td><code id="set.data_+3A_y">y</code></td>
<td>
<p>numeric vector, specifies function values.</p>
</td></tr>
<tr><td><code id="set.data_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector, if not <code>NA</code>, specifies estimated noise.</p>
</td></tr>
<tr><td><code id="set.data_+3A_lambda">lambda</code></td>
<td>
<p>numeric vector, if not <code>NA</code>, specifies estimated mean signal magnitude.</p>
</td></tr>
<tr><td><code id="set.data_+3A_sb">SB</code></td>
<td>
<p>numeric vector, if not <code>NA</code>, specifies estimated coherent baseline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One way (not the simplest) to prepare experimental data for the fit. This function returns a list of the above parameters &ndash; an object of type <code>data</code>. Objects of that type are used as arguments for some functions implemented in the package. In most cases only the elements <code>x</code> and <code>y</code> are required in the object <code>data</code>. However, all 5 elements (and one optional, see <code><a href="#topic+set.Gr">set.Gr</a></code>) must be specified to execute the fit, i.e. prior to the <code><a href="#topic+do.fit">do.fit</a></code> call.
</p>
<p>The object of that type can also be created via <code><a href="#topic+read.data">read.data</a></code>, <code><a href="#topic+read.sqa">read.sqa</a></code> and <code><a href="#topic+read.sqb">read.sqb</a></code>. Parameters &quot;sigma&quot;, &quot;lamdba&quot; and &quot;SB&quot; can be determined automatically, see <code>set data</code> keyword.
</p>
<p>The general recipe for setting an object <code>data</code> is the following. If vectors <code>x</code> and <code>y</code> are stored in the text file, use  <code><a href="#topic+read.data">read.data</a></code>. If they are stored in a <code>.sqb</code>-file, call <code><a href="#topic+read.sqb">read.sqb</a></code>. If they are stored in the memory, use <code><a href="#topic+set.data">set.data</a></code>. Then use functions <code><a href="#topic+set.sigma">set.sigma</a></code>, <code><a href="#topic+set.lambda">set.lambda</a></code>, and <code><a href="#topic+set.SB">set.SB</a></code>) to specify the remaining parameters.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>numeric vector, specifies gridpoints.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>numeric vector, specifies function values.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>numeric vector, specifies estimated noise.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>numeric vector, specifies estimated mean signal magnitude.</p>
</td></tr>
<tr><td><code>SB</code></td>
<td>
<p>numeric vector, specifies estimated coherent baseline.</p>
</td></tr>
</table>

<hr>
<h2 id='set.Gr'>Add information on the low-r behaviour of G(r)</h2><span id='topic+set.Gr'></span>

<h3>Description</h3>

<p>Function to incorporate information on the low-r  behaviour of G(r) into the Bayesian model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.Gr(data, r1=seq(0, 1, 0.005), r2=NA, rho.0,
       type1="gaussianNoise", type2=NA, sigma.f=NA, l=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.Gr_+3A_data">data</code></td>
<td>
<p>an object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>
</td></tr>
<tr><td><code id="set.Gr_+3A_r1">r1</code>, <code id="set.Gr_+3A_r2">r2</code></td>
<td>
<p>numeric vectors, specify grids on which the G(r) behaviour is controlled.</p>
</td></tr>
<tr><td><code id="set.Gr_+3A_rho.0">rho.0</code></td>
<td>
<p>numeric, atomic number density of the material: a number of atoms per unit cell divided by a volume of the unit cell.</p>
</td></tr>
<tr><td><code id="set.Gr_+3A_type1">type1</code>, <code id="set.Gr_+3A_type2">type2</code></td>
<td>
<p>characters, specify the way to control the behavior of G(r). See details.</p>
</td></tr>
<tr><td><code id="set.Gr_+3A_sigma.f">sigma.f</code>, <code id="set.Gr_+3A_l">l</code></td>
<td>
<p>numerics or numeric vectors, specify parameters for a squared-exponential covariance function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>type1</code> can be either &quot;gaussianNoise&quot; or &quot;correlatedNoise&quot;. G(r) is restricted to the <code class="reqn">-4\pi\rho.0r1</code> line plus independent Gaussian noise or correlated Gaussian noise, respectively.
</p>
<p><code>type2</code> can be either &quot;secondDeriv&quot; or &quot;gaussianProcess&quot; to impose smoothness conditions over the interval <code>r2</code>. If <code>type2</code> is &quot;secondDeriv&quot;, a minimum of the second derivative is sought. If <code>type2</code> is &quot;gaussianProcess&quot;, the smoothness is controlled via the Gaussian process using parameters  sigma.f and l.
</p>
<p>According to our experience, the most efficient way is to impose <code>type1="gaussianNoise"</code> and <code>type2=NA</code> conditions.
</p>


<h3>Value</h3>

<p>An object of type <code>data</code>.
</p>

<hr>
<h2 id='set.lambda'>Set mean signal magnitude</h2><span id='topic+set.lambda'></span>

<h3>Description</h3>

<p><code>set.lambda</code> sets the mean height of the peaks over region x.</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.lambda(data, lambda=NA, lambda_1=NA, lambda_2=NA, 
           lambda_0=NA, x_1=NA, x_2=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.lambda_+3A_data">data</code></td>
<td>
<p>an object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>
</td></tr>
<tr><td><code id="set.lambda_+3A_lambda">lambda</code></td>
<td>
<p>numeric vector. If not <code>NA</code>, specifies (approximate) the mean magnitude of the signal. This estimate does not need to be accurate. <code>lambda</code> can be estimated as a smooth function that crosses centres of the signal peaks. </p>
</td></tr>
<tr><td><code id="set.lambda_+3A_lambda_1">lambda_1</code>, <code id="set.lambda_+3A_lambda_2">lambda_2</code>, <code id="set.lambda_+3A_lambda_0">lambda_0</code>, <code id="set.lambda_+3A_x_1">x_1</code>, <code id="set.lambda_+3A_x_2">x_2</code></td>
<td>
<p>numerics. If <code>lambda</code> is <code>NA</code> help to estimate <code>lambda</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lambda</code> is calculated as a linear piecewise function which is equal to <code>lambda_0</code> outside the <code>[x_1,x_2]</code> region. Inside this region, <code>lambda</code> is approximated by a line connecting points <code>(x_1;lambda_1)</code> and <code>(x_2;lambda_2)</code>.
</p>


<h3>Value</h3>

<p>An object of type <code>data</code>. Element
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>numeric vector containing an approximate mean magnitude of the signal.</p>
</td></tr>
</table>
<p>is replaced with its new value.
</p>

<hr>
<h2 id='set.SB'>Set the coherent baseline</h2><span id='topic+set.SB'></span>

<h3>Description</h3>

<p><code>set.SB</code> sets the baseline, describing coherent neutron scattering caused by uncorrelated atomic motion or any other baseline that needs to be preserved in the recovered signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>			 
set.SB(data, SB=NA, n.atoms=NA, scatter.length=NA, ADP=NA, 
       fit=FALSE, oneADP=TRUE, ADP.lim = c(0, 0.05))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.SB_+3A_data">data</code></td>
<td>
<p>an object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>
</td></tr>
<tr><td><code id="set.SB_+3A_sb">SB</code></td>
<td>
<p>numeric vector which, if not <code>NA</code>, determines the baseline. See <code><a href="#topic+BBEST-package">BBEST-package</a></code> for details.</p>
</td></tr>
<tr><td><code id="set.SB_+3A_n.atoms">n.atoms</code>, <code id="set.SB_+3A_scatter.length">scatter.length</code>, <code id="set.SB_+3A_adp">ADP</code></td>
<td>
<p>numerics. Specify the number of atoms of each atomtype in the unit cell, atomic scattering factors and atomic displacement parameters (ADP), respectively.</p>
</td></tr>
<tr><td><code id="set.SB_+3A_fit">fit</code></td>
<td>
<p>logical, whether to fit ADP.</p>
</td></tr>
<tr><td><code id="set.SB_+3A_oneadp">oneADP</code></td>
<td>
<p>logical. If <code>TRUE</code> a single parameter is used for all the APDs.</p>
</td></tr>
<tr><td><code id="set.SB_+3A_adp.lim">ADP.lim</code></td>
<td>
<p>numeric vector that specifies the lower and upper bounds for the fitted ADP.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Baseline <code>SB</code> has to be specified. If no baseline is needed fill <code>SB</code> with zeroes. If <code>n.atoms, scatter.length</code> and <code>ADP</code> parameters are specified, the baseline is calculated according to
</p>
<p style="text-align: center;"><code class="reqn"> SB(x) = 1 - \frac{ \sum_i{N_i f_i^2 e^{-ADP_i x^2}} }{ N&lt;f^2&gt; }(1 - \frac{&lt;f&gt;^2-&lt;f^2&gt;}{&lt;f&gt;^2}). </code>
</p>

<p>If <code>ADP</code> parameters are to be fitted, indicate <code>n.atoms</code>, <code>scatter.length</code> and set parameter <code>fit</code> to <code>TRUE</code>. Set <code>oneADP</code> to the desired value. 
</p>


<h3>Value</h3>

<p>An object of type <code>data</code>. Element
</p>
<table>
<tr><td><code>SB</code></td>
<td>
<p>numeric vector containing the baseline.</p>
</td></tr>
</table>
<p>is replaced with its new value. Element
</p>
<table>
<tr><td><code>fitADP</code></td>
<td>
<p>a list of values.</p>
</td></tr>
</table>
<p>might be added to describe the fit details.
</p>

<hr>
<h2 id='set.sigma'>
Set the experimental uncertainty
</h2><span id='topic+set.sigma'></span>

<h3>Description</h3>

<p>This function either sets the pointwise experimental uncertainty or estimates it using <code>aws</code> library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.sigma(data, sigma=NA, x.bkg.only=NA, n.regions=10, hmax=250, sigma2=c(0.1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.sigma_+3A_data">data</code></td>
<td>
<p>an object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>
</td></tr>
<tr><td><code id="set.sigma_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector which, if not <code>NA</code>, determines the pointwise experimental uncertainty.</p>
</td></tr>
<tr><td><code id="set.sigma_+3A_x.bkg.only">x.bkg.only</code></td>
<td>
<p>if parameter <code>sigma</code> is <code>NA</code>, determines the peak-free region used to estimate the noise.</p>
</td></tr>
<tr><td><code id="set.sigma_+3A_n.regions">n.regions</code></td>
<td>
<p>if both parameters <code>sigma</code> and <code>x.bkg.only</code> are <code>NA</code>, the grid is split into <code>n.regions</code> equal regions. The noise is then estimated for each of these regions. See details</p>
</td></tr>
<tr><td><code id="set.sigma_+3A_hmax">hmax</code></td>
<td>
<p>specifies the maximal bandwidth</p>
</td></tr>
<tr><td><code id="set.sigma_+3A_sigma2">sigma2</code></td>
<td>
<p>specifies the estimation of the signal's variance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume the experimental uncertainty to have  a Gaussian distribution with x-dependent amplitude. Splitting the grid into <code>n.regions</code> segments and estimating Gaussian standard deviations over each of these segments allows us to approximate the true distribution.
</p>
<p>The function uses <code>aws</code> package that uses a Propagation-Separation Approach for signal smoothing. The use of <code>sigma2</code> argument allows to obtain a smoother or rougher result.
</p>


<h3>Value</h3>

<p>An object of type <code>data</code>. Elements
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>numeric vector containing the estimated noise level.</p>
</td></tr>
<tr><td><code>smoothed</code></td>
<td>
<p>if both parameters <code>sigma</code> and <code>x.bkg.only</code> are <code>NA</code> contains a smoothed estimate of the regression function.</p>
</td></tr>
</table>
<p>are replaced with their new values.
</p>


<h3>References</h3>

<p>Polzehl J, Papafitsoros K, Tabelow K (2020). Patch-Wise Adaptive Weights Smoothing in R. Journal of Statistical Software, 95(6), 1-27.
Joerg Polzehl, Felix Anker (2020): aws: Adaptive Weights Smoothing. Version 2.5. <a href="https://CRAN.R-project.org/package=aws">https://CRAN.R-project.org/package=aws</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Setting x and y
x &lt;- seq(.7, 30, 0.01)
y &lt;- sin(x)
# Adding x-dependent noise
y &lt;- y + rnorm(sd=0.05+x/240, n=length(x))

# estimating noise
dat &lt;- list(x=x, y=y)
dat &lt;- set.sigma(dat, n.regions=1, sigma2 = 0.005)
# use
# dat &lt;- set.sigma(dat, n.regions=5)
# to see the difference


# Plotting results: noisy function and a
# smoothed estimate +/- 2 standard deviations
plot(x, y, t="l")
lines(dat$x, dat$smoothed, col=3, lwd=2)
lines(dat$x, dat$smoothed+2*dat$sigma, col=2)
lines(dat$x, dat$smoothed-2*dat$sigma, col=2)
abline(v=seq(min(x), max(x),length=5), col=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='sqa.split'>
Split .sqa file into individual files for each databank 
</h2><span id='topic+sqa.split'></span>

<h3>Description</h3>

<p><code>sqa.split</code> splits <em>PDFgetN</em> .<em>sqa</em>-file into individual files for each databank. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqa.split(file = stop("'file' must be specified"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqa.split_+3A_file">file</code></td>
<td>
<p>character, name of the source file.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read.sqa">read.sqa</a></code>, <code><a href="#topic+do.fit.banks">do.fit.banks</a></code>, <code><a href="#topic+BBEST-package">BBEST-package</a></code>
</p>

<hr>
<h2 id='test.signal'>A random function with a smooth background</h2><span id='topic+test.signal'></span>

<h3>Description</h3>

<p><code>test.signal</code> creates a random function that consists of peaks, a smooth background, and a Gaussian noise. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.signal(x, lambda, sigma, x.delta, knots.n, peaks.widthRange, peaks.n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.signal_+3A_x">x</code></td>
<td>
<p>numeric vector, the x-points where data should be generated.</p>
</td></tr>
<tr><td><code id="test.signal_+3A_lambda">lambda</code></td>
<td>
<p>numeric, the mean signal magnitude.</p>
</td></tr>
<tr><td><code id="test.signal_+3A_sigma">sigma</code></td>
<td>
<p>numeric, the noise level.</p>
</td></tr>
<tr><td><code id="test.signal_+3A_x.delta">x.delta</code></td>
<td>
<p>numeric, the minimum spacing allowed between spline knots. Defines background smoothness.</p>
</td></tr>
<tr><td><code id="test.signal_+3A_knots.n">knots.n</code></td>
<td>
<p>numeric, a number of spline knots to generate.</p>
</td></tr>
<tr><td><code id="test.signal_+3A_peaks.widthrange">peaks.widthRange</code></td>
<td>
<p>numeric vector, specifies range in peak widths.</p>
</td></tr>
<tr><td><code id="test.signal_+3A_peaks.n">peaks.n</code></td>
<td>
<p>numeric, the number of peaks to generate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The background is calculated as a sum of fundamental splines on the randomly generated knots. The function is a sum of the background, random peaks, and Gaussian noise.
</p>


<h3>Value</h3>

<p>An object of type <code>data</code> (see <code><a href="#topic+set.data">set.data</a></code>) with the following elements added: 
</p>
<table>
<tr><td><code>knots</code></td>
<td>
<p>list with elements <code>x</code> and <code>y</code> that specify the knot positions and knot values, respectively.</p>
</td></tr>
<tr><td><code>bkg</code></td>
<td>
<p>numeric vector containing the generated background.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Create test function 
f &lt;- test.signal(x=seq(0,30,0.01), lambda=5, 
         sigma=0.1, x.delta=1.0, knots.n=5, 
         peaks.widthRange=c(0.1, 0.3), peaks.n=7)
	
# 2. Plot results
plot(f$x, f$y, t="l", xlab="x", ylab="f")
lines(f$x, f$bkg, col=2)
lines(f$x, f$y - f$bkg, col="gray")
legend(20, .9*max(f$y), c("test function", "background", 
       "peaks+noise"), lty=1, col=c(1,2,"gray"))

</code></pre>

<hr>
<h2 id='trim.data'>
Truncate data
</h2><span id='topic+trim.data'></span>

<h3>Description</h3>

<p>The function truncates the data (deletes low- and high-x information).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim.data(data, x.min, x.max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.data_+3A_data">data</code></td>
<td>
<p>an object of type <code>data</code>. See <code><a href="#topic+set.data">set.data</a></code> for details.</p>
</td></tr>
<tr><td><code id="trim.data_+3A_x.min">x.min</code>, <code id="trim.data_+3A_x.max">x.max</code></td>
<td>
<p>numeric values determining the region to keep.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Frequently, the experimental data need to be truncated to remove unwanted ranges.</p>


<h3>Value</h3>

<p>an object of type <code>data</code> with all functions cropped to the region <code>[x.min, x.max]</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare data
x &lt;- seq(0, 50, 0.01)
y &lt;- .8*exp(-x)*x^4 
dat &lt;- list(x=x, y=y)
# truncate
dat &lt;- trim.data(dat, 1, 25)
# plot results
plot(x,y,t="l",lwd=4, col=4)
lines(dat$x, dat$y, lwd=4, col=2)
legend(15,3,c("initial", "truncated"), lty=1, col=c(4,2))
</code></pre>

<hr>
<h2 id='withProgress'>Reporting progress (functional API)</h2><span id='topic+withProgress'></span><span id='topic+setProgress'></span>

<h3>Description</h3>

<p>Reports progress to the user during long-running operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withProgress(
  session,
  expr,
  min = 0,
  max = 1,
  env = parent.frame(),
  quoted = FALSE
)

setProgress(message = NULL, detail = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="withProgress_+3A_session">session</code></td>
<td>
<p>The Shiny session object, as provided by
<code>shinyServer</code> to the server function.</p>
</td></tr>
<tr><td><code id="withProgress_+3A_expr">expr</code></td>
<td>
<p>The work to be done. This expression should contain calls
to <code>setProgress</code>.</p>
</td></tr>
<tr><td><code id="withProgress_+3A_min">min</code></td>
<td>
<p>The value that represents the starting point of the
progress bar. Must be less than <code>max</code>.</p>
</td></tr>
<tr><td><code id="withProgress_+3A_max">max</code></td>
<td>
<p>The value that represents the end of the progress bar.
Must be greater than <code>min</code>.</p>
</td></tr>
<tr><td><code id="withProgress_+3A_env">env</code></td>
<td>
<p>The environment in which <code>expr</code> should be evaluated.</p>
</td></tr>
<tr><td><code id="withProgress_+3A_quoted">quoted</code></td>
<td>
<p>Whether <code>expr</code> is a quoted expression (this is not
common).</p>
</td></tr>
<tr><td><code id="withProgress_+3A_message">message</code></td>
<td>
<p>A single-element character vector; the message to be
displayed to the user, or <code>NULL</code> to hide the current message
(if any).</p>
</td></tr>
<tr><td><code id="withProgress_+3A_detail">detail</code></td>
<td>
<p>A single-element character vector; the detail message
to be displayed to the user, or <code>NULL</code> to hide the current
detail message (if any). The detail message will be shown with a
de-emphasized appearance relative to <code>message</code>.</p>
</td></tr>
<tr><td><code id="withProgress_+3A_value">value</code></td>
<td>
<p>Single-element numeric vector; the value at which to set
the progress bar, relative to <code>min</code> and <code>max</code>.
<code>NULL</code> hides the progress bar, if it is currently visible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package exposes two distinct programming APIs for working with
progress. <code>withProgress</code> and <code>setProgress</code> together provide
a simple function-based interface, while the <code><a href="#topic+Progress">Progress</a></code>
reference class provides an object-oriented API.
</p>
<p>Use <code>withProgress</code> to wrap the scope of your work; doing so will
cause a new progress panel to be created, and it will be displayed the
first time <code>setProgress</code> is called. When <code>withProgress</code> exits,
the corresponding progress panel will be removed.
</p>
<p>Generally, <code>withProgress</code>/<code>setProgress</code> should be
sufficient; the exception is if the work to be done is asynchronous
(this is not common) or otherwise cannot be encapsulated by a single
scope. In that case, you can use the <code>Progress</code> reference class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+progressInit">progressInit</a></code>, <code><a href="#topic+Progress">Progress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# server.R
shinyServer(function(input, output, session) {
  output$plot &lt;- renderPlot({
    withProgress(session, min=1, max=15, {
      setProgress(message = 'Calculation in progress',
                  detail = 'This may take a while...')
      for (i in 1:15) {
        setProgress(value = i)
        Sys.sleep(0.5)
      }
    })
    plot(cars)
  })
})

## End(Not run)
</code></pre>

<hr>
<h2 id='write.fit.results'>Save results of the fit
</h2><span id='topic+write.fit.results'></span>

<h3>Description</h3>

<p><code>write.fit.results</code> writes the returned value of <code><a href="#topic+do.fit">do.fit</a></code> to a specified text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fit.results(fit.results, file = stop("'file' must be specified"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fit.results_+3A_fit.results">fit.results</code></td>
<td>
<p>list, the return value of <code><a href="#topic+do.fit">do.fit</a></code>.</p>
</td></tr>
<tr><td><code id="write.fit.results_+3A_file">file</code></td>
<td>
<p>character, the filename for saving the data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+do.fit">do.fit</a></code>, <code><a href="#topic+BBEST-package">BBEST-package</a></code>
</p>

<hr>
<h2 id='write.fix'>
Save a correction file for individual detector banks
</h2><span id='topic+write.fix'></span>

<h3>Description</h3>

<p><code>write.fix</code> writes corrections obtained using <code><a href="#topic+do.fit.banks">do.fit.banks</a></code> to a specified file in a form suitable for <em>PDFgetN</em>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fix(fit.results, file = stop("'file' must be specified"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fix_+3A_fit.results">fit.results</code></td>
<td>
<p>list, the return value of <code><a href="#topic+do.fit.banks">do.fit.banks</a></code>.</p>
</td></tr>
<tr><td><code id="write.fix_+3A_file">file</code></td>
<td>
<p>character, the filename for saving the data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read.sqa">read.sqa</a></code>, <code><a href="#topic+do.fit.banks">do.fit.banks</a></code>, <code><a href="#topic+BBEST-package">BBEST-package</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
