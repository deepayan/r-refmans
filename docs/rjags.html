<!DOCTYPE html><html><head><title>Help for package rjags</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rjags}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adapt'><p>Adaptive phase for JAGS models</p></a></li>
<li><a href='#coda.samples'><p>Generate posterior samples in mcmc.list format</p></a></li>
<li><a href='#control'><p>Advanced control over JAGS</p></a></li>
<li><a href='#dic.samples'><p>Generate penalized deviance samples</p></a></li>
<li><a href='#diffdic'><p>Differences in penalized deviance</p></a></li>
<li><a href='#jags.model'><p>Create a JAGS model object</p></a></li>
<li><a href='#jags.module'><p>Dynamically load JAGS modules</p></a></li>
<li><a href='#jags.object'><p>Functions for manipulating jags model objects</p></a></li>
<li><a href='#jags.samples'><p>Generate posterior samples</p></a></li>
<li><a href='#jags.version'><p>JAGS version</p></a></li>
<li><a href='#line'><p>Linear regression example</p></a></li>
<li><a href='#mcarray.object'><p>Objects for representing MCMC output</p></a></li>
<li><a href='#parallel'><p>Get initial values for parallel RNGs</p></a></li>
<li><a href='#read.jagsdata'><p>Read data files for jags models</p></a></li>
<li><a href='#rjags-deprecated'><p>Deprecated Functions in the rjags package</p></a></li>
<li><a href='#rjags-package'>
<p>Bayesian graphical models using MCMC</p></a></li>
<li><a href='#update'><p>Update jags models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4-15</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Graphical Models using MCMC</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), coda (&ge; 0.13)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS 4.x.y</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mcmc-jags.sourceforge.io">https://mcmc-jags.sourceforge.io</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>tcltk</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface to the JAGS MCMC library.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL (== 2)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 14:49:37 UTC; martyn</td>
</tr>
<tr>
<td>Author:</td>
<td>Martyn Plummer [aut, cre],
  Alexey Stukalov [ctb],
  Matt Denwood [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martyn Plummer &lt;martyn.plummer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 17:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='adapt'>Adaptive phase for JAGS models</h2><span id='topic+adapt'></span>

<h3>Description</h3>

<p>Update the model in adaptive mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt(object, n.iter, end.adaptation=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapt_+3A_object">object</code></td>
<td>
<p>a <code>jags</code> model object</p>
</td></tr>
<tr><td><code id="adapt_+3A_n.iter">n.iter</code></td>
<td>
<p>length of the adaptive phase</p>
</td></tr>
<tr><td><code id="adapt_+3A_end.adaptation">end.adaptation</code></td>
<td>
<p>logical flag. If <code>TRUE</code> then adaptive
mode will be turned off on exit.</p>
</td></tr>
<tr><td><code id="adapt_+3A_...">...</code></td>
<td>
<p>additional arguments to the update method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not normally called by the user.  It is called by the
<code>jags.model</code> function when the model object is created.
</p>
<p>When a JAGS model is compiled, it may require an initial sampling
phase during which the samplers adapt their behaviour to maximize
their efficiency (e.g. a Metropolis-Hastings random walk algorithm may
change its step size).  The sequence of samples generated during this
adaptive phase is not a Markov chain, and therefore may not be used
for posterior inference on the model.
</p>
<p>The <code>adapt</code> function updates the model for <code>n.iter</code>
iterations in adaptive mode. Then each sampler reports whether it
has acheived optimal performance (e.g. whether the rejection rate of a
Metropolis-Hasting sampler is close to the theoretical optimum). If
any sampler reports failure of this test then <code>adapt</code> returns
<code>FALSE</code>.
</p>
<p>If <code>end.adaptation = TRUE</code>, then adaptive mode is turned off on
exit, and further calls to <code>adapt()</code> do nothing. The model may be
maintained in adaptive mode with the default option <code>end.adaptation =
  FALSE</code> so that successive calls to <code>adapt()</code> may be made until
adaptation is satisfactory.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if all the samplers in the model have successfully
adapted their behaviour to optimum performance and <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>

<hr>
<h2 id='coda.samples'>Generate posterior samples in mcmc.list format</h2><span id='topic+coda.samples'></span>

<h3>Description</h3>

<p>This is a wrapper function for <code>jags.samples</code> which sets a trace
monitor for all requested nodes, updates the model, and coerces the
output to a single <code>mcmc.list</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coda.samples(model, variable.names, n.iter, thin = 1, na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coda.samples_+3A_model">model</code></td>
<td>
<p>a jags model object</p>
</td></tr>
<tr><td><code id="coda.samples_+3A_variable.names">variable.names</code></td>
<td>
<p>a character vector giving the names of variables
to be monitored</p>
</td></tr>
<tr><td><code id="coda.samples_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations to monitor</p>
</td></tr>
<tr><td><code id="coda.samples_+3A_thin">thin</code></td>
<td>
<p>thinning interval for monitors</p>
</td></tr>
<tr><td><code id="coda.samples_+3A_na.rm">na.rm</code></td>
<td>
<p>logical flag that indicates whether variables
containing missing values should be omitted. See details.</p>
</td></tr>
<tr><td><code id="coda.samples_+3A_...">...</code></td>
<td>
<p>optional arguments that are passed to the update method
for jags model objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>na.rm=TRUE</code> (the default) then elements of a variable that
are missing (<code>NA</code>) for any iteration in at least one chain will
be dropped.
</p>
<p>This argument was added to handle incompletely defined variables.
From JAGS version 4.0.0, users may monitor variables that are not
completely defined in the BUGS language description of the model,
e.g. if <code>y[i]</code> is defined in a <code>for</code> loop starting from
<code>i=3</code> then <code>y[1], y[2]</code> are not defined. The user may still
monitor variable <code>y</code> and the monitored values corresponding to
<code>y[1], y[2]</code> will have value <code>NA</code> for all iterations in all
chains. Most of the functions in the <span class="pkg">coda</span> package cannot handle
missing values so these variables are dropped by default.
</p>


<h3>Value</h3>

<p>An <code>mcmc.list</code> object.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+jags.samples">jags.samples</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LINE)
LINE$recompile()
LINE.out &lt;- coda.samples(LINE, c("alpha","beta","sigma"), n.iter=1000)
summary(LINE.out)
</code></pre>

<hr>
<h2 id='control'>Advanced control over JAGS</h2><span id='topic+list.factories'></span><span id='topic+set.factory'></span>

<h3>Description</h3>

<p>JAGS modules contain factory objects for samplers, monitors, and
random number generators for a JAGS model.  These functions allow
fine-grained control over which factories are active.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.factories(type)
set.factory(name, type, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_+3A_name">name</code></td>
<td>
<p>name of the factory to set</p>
</td></tr>
<tr><td><code id="control_+3A_type">type</code></td>
<td>
<p>type of factory to query or set. Possible values are
<code>"sampler"</code>, <code>"monitor"</code>, or <code>"rng"</code></p>
</td></tr>
<tr><td><code id="control_+3A_state">state</code></td>
<td>
<p>a logical. If <code>TRUE</code> then the factory will be
active, otherwise the factory will become inactive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list.factories</code> returns a data frame with two columns, the first
column shows the names of the factory objects in the currently loaded
modules, and the second column is a logical vector indicating whether
the corresponding factory is active or not.
</p>
<p><code>set.factory</code> is called to change the future behaviour of factory
objects. If a factory is set to inactive then it will be skipped.
</p>


<h3>Note</h3>

<p>When a module is loaded, all of its factory objects are active. This
is also true if a module is unloaded and then reloaded.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.factories("sampler")
list.factories("monitor")
list.factories("rng")
set.factory("base::Slice", "sampler", FALSE)
list.factories("sampler")
set.factory("base::Slice", "sampler", TRUE)
</code></pre>

<hr>
<h2 id='dic.samples'>Generate penalized deviance samples</h2><span id='topic+dic'></span><span id='topic+dic.samples'></span>

<h3>Description</h3>

<p>Function to extract random samples of the penalized deviance from
a <code>jags</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dic.samples(model, n.iter, thin = 1, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dic.samples_+3A_model">model</code></td>
<td>
<p>a jags model object</p>
</td></tr>
<tr><td><code id="dic.samples_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations to monitor</p>
</td></tr>
<tr><td><code id="dic.samples_+3A_thin">thin</code></td>
<td>
<p>thinning interval for monitors</p>
</td></tr>
<tr><td><code id="dic.samples_+3A_type">type</code></td>
<td>
<p>type of penalty to use</p>
</td></tr>
<tr><td><code id="dic.samples_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the update method for jags
model objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dic.samples</code> function generates penalized deviance
statistics for use in model comparison.  The two alternative penalized
deviance statistics generated by <code>dic.samples</code> are the deviance
information criterion (DIC) and the penalized expected deviance.
These are chosen by giving the values &ldquo;pD&rdquo; and &ldquo;popt&rdquo; respectively
as the <code>type</code> argument.
</p>
<p>DIC (Spiegelhalter et al 2002) is calculated by adding the &ldquo;effective
number of parameters&rdquo; (<code>pD</code>) to the expected deviance. The
definition of <code>pD</code> used by <code>dic.samples</code> is the one proposed
by Plummer (2002) and requires two or more parallel chains in the
model.
</p>
<p>DIC is an approximation to the penalized plug-in deviance, which is
used when only a point estimate of the parameters is of interest. The
DIC approximation only holds asymptotically when the effective number
of parameters is much smaller than the sample size, and the model
parameters have a normal posterior distribution.
</p>
<p>The penalized expected deviance (Plummer 2008) is calculated by adding
the optimism (<code>popt</code>) to the expected deviance.  The <code>popt</code>
penalty is at least twice the size of the <code>pD</code> penalty, and
penalizes complex models more severely.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;dic&rdquo;. This is a list containing the following
elements:
</p>
<table>
<tr><td><code>deviance</code></td>
<td>
<p>A numeric vector, with one element for each 
observed stochastic node, containing the mean deviance for that node</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>A numeric vector, with one element for each 
observed stochastic node, containing an estimate of the contribution
towards the penalty</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A string identifying the type of penalty: &ldquo;pD&rdquo; or
&ldquo;popt&rdquo;</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>popt</code> penalty is estimated by importance weighting, and may
be numerically unstable.  
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>References</h3>

<p>Spiegelhalter, D., N. Best, B. Carlin, and A. van der Linde (2002),
Bayesian measures of model complexity and fit (with discussion).
<em>Journal of the Royal Statistical Society Series B</em>
<b>64</b>, 583-639.
</p>
<p>Plummer, M. (2002),
Discussion of the paper by Spiegelhalter et al.
<em>Journal of the Royal Statistical Society Series B</em>
<b>64</b>, 620.
</p>
<p>Plummer, M. (2008)
Penalized loss functions for Bayesian model comparison.
<em>Biostatistics</em>
doi: 10.1093/biostatistics/kxm049
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffdic">diffdic</a></code></p>

<hr>
<h2 id='diffdic'>Differences in penalized deviance</h2><span id='topic+diffdic'></span>

<h3>Description</h3>

<p>Compare two models by the difference of two <code>dic</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dic1 - dic2
diffdic(dic1, dic2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffdic_+3A_dic1">dic1</code>, <code id="diffdic_+3A_dic2">dic2</code></td>
<td>
<p>Objects inheriting from class &ldquo;dic&rdquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>diffdic</code> object represents the difference in penalized
deviance between two models. A negative value indicates that
<code>dic1</code> is preferred and vice versa.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;diffdic&rdquo;. This is a numeric vector with
an element for each observed stochastic node in the model.
</p>
<p>The <code>diffdic</code> class has its own print method, which will
display the sum of the differences, and its sample standard
deviation.
</p>


<h3>Note</h3>

<p>The problem of determining what is a noteworthy difference
in DIC (or other penalized deviance) between two models is
currently unsolved.  Following the results of Ripley (1996) on
the Akaike Information Criterion, Plummer (2008) argues that 
there is no absolute scale for comparison of two penalized
deviance statistics, and proposes that the difference should
be calibrated with respect to the sample standard deviation
of the individual contributions from each observed stochastic
node.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>References</h3>

<p>Ripley, B. (1996)
<em>Statistical Pattern Recognition and Neural Networks.</em> 
Cambridge University Press.
</p>
<p>Plummer, M. (2008)
Penalized loss functions for Bayesian model comparison.
<em>Biostatistics</em>
doi: 10.1093/biostatistics/kxm049
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dic">dic</a></code></p>

<hr>
<h2 id='jags.model'>Create a JAGS model object</h2><span id='topic+jags.model'></span>

<h3>Description</h3>

<p><code>jags.model</code> is used to create an object representing a
Bayesian graphical model, specified with a BUGS-language description
of the prior distribution, and a set of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> jags.model(file, data, inits,
            n.chains = 1, n.adapt=1000, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jags.model_+3A_file">file</code></td>
<td>
<p>the name of the file containing a description of the model in the
JAGS dialect of the BUGS language.
</p>
<p>Alternatively, <code>file</code> can be a readable text-mode connection,
or a complete URL.</p>
</td></tr>
<tr><td><code id="jags.model_+3A_data">data</code></td>
<td>
<p>a list or environment containing the data. Any numeric
objects in <code>data</code> corresponding to node arrays used in
<code>file</code> are taken to represent the values of observed nodes
in the model.</p>
</td></tr>
<tr><td><code id="jags.model_+3A_inits">inits</code></td>
<td>
<p>optional specification of initial values in the form of a
list or a function (see <code>Initialization</code> below). If omitted,
initial values will be generated automatically.  It is an error to
supply an initial value for an observed node.</p>
</td></tr>
<tr><td><code id="jags.model_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of parallel chains for the model</p>
</td></tr>
<tr><td><code id="jags.model_+3A_n.adapt">n.adapt</code></td>
<td>
<p>the number of iterations for adaptation. See 
<code><a href="#topic+adapt">adapt</a></code> for details. If <code>n.adapt = 0</code> then no 
adaptation takes place.</p>
</td></tr>
<tr><td><code id="jags.model_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code> then messages generated during compilation
will be suppressed, as well as the progress bar during adaptation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>jags.model</code> returns an object inheriting from class <code>jags</code>
which can be used to generate dependent samples from the posterior
distribution of the parameters
</p>
<p>An object of class <code>jags</code> is a list of functions that share a
common environment. This environment encapsulates the state of the
model, and the functions can be used to query or modify the model
state.
</p>
<table>
<tr><td><code>ptr()</code></td>
<td>
<p>Returns an external pointer to an object created by
the JAGS library</p>
</td></tr>
<tr><td><code>data()</code></td>
<td>
<p>Returns a list containing the data that define
the observed nodes in the model</p>
</td></tr>
<tr><td><code>model()</code></td>
<td>
<p>Returns a character vector containing the BUGS-language
representation of the model</p>
</td></tr>
<tr><td><code>state(internal=FALSE)</code></td>
<td>
<p>Returns a list of length equal to the
number of parallel chains in the model. Each element of the list is
itself a list containing the current parameter values in that chain.
if <code>internal=TRUE</code> then the returned lists also include the RNG
names (<code>.RNG.name</code>) and states (<code>.RNG.state</code>).  This is
not the user-level interface: use the <code><a href="#topic+coef.jags">coef.jags</a></code> method
instead.</p>
</td></tr>
<tr><td><code>update(n.iter)</code></td>
<td>
<p>Updates the model by <code>n.iter</code> iterations.
This is not the user-level interface: use the
<code><a href="#topic+update.jags">update.jags</a></code> method instead.</p>
</td></tr>
</table>


<h3>Initialization</h3>

<p>There are various ways to specify initial values for a JAGS model.
If no initial values are supplied, then they will be generated
automatically by JAGS. See the JAGS User Manual for
details. Otherwise, the options are as follows:
</p>

<ol>
<li><p> A list of numeric values. Initial values for a single chain
may supplied as a named list of numeric values. If there are multiple
parallel chains then the same list is re-used for each chain.
</p>
</li>
<li><p> A list of lists. Distinct initial values for each chain may be
given as a list of lists. In this case, the list should have the same
length as the number of chains in the model.
</p>
</li>
<li><p> A function.  A function may be supplied that returns a list of
initial values.  The function is called repeatedly to generate initial
values for each chain. Normally this function should call some random
number generating functions so that it returns different values every
time it is called. The function should either have no arguments, or
have a single argument named <code>chain</code>. In the latter case, the
supplied function is called with the chain number as argument. In this
way, initial values may be generated that depend systematically on
the chain number.
</p>
</li></ol>



<h3>Random number generators</h3>

<p>Each chain in a model has its own random number generator (RNG).  RNGs
and their initial seed values are assigned automatically when the
model is created. The automatic seeds are calculated from the current
time.
</p>
<p>If you wish to make the output from the model reproducible, you may
specify the RNGs to be used for each chain, and their starting seeds
as part of the <code>inits</code> argument (see <code>Initialization</code>
above). This is done by supplementing the list of initial parameter
values for a given chain with two additional elements named
&ldquo;.RNG.name&rdquo;, and &ldquo;.RNG.seed&rdquo;:
</p>

<dl>
<dt><code>.RNG.name</code></dt><dd><p>a character vector of length 1. The names of
the RNGs supplied in the base module are:
</p>

<ul>
<li> <p>&ldquo;base::Wichmann-Hill&rdquo;
</p>
</li>
<li> <p>&ldquo;base::Marsaglia-Multicarry&rdquo;
</p>
</li>
<li> <p>&ldquo;base::Super-Duper&rdquo;
</p>
</li>
<li> <p>&ldquo;base::Mersenne-Twister&rdquo;
</p>
</li></ul>

<p>If the lecuyer module is loaded, it provides &ldquo;lecuyer::RngStream&rdquo;
</p>
</dd>
<dt><code>.RNG.seed</code></dt><dd><p>a numeric vector of length 1 containing an
integer value.</p>
</dd>
</dl>

<p>Note that it is also possible to specify &ldquo;.RNG.state&rdquo; rather than 
&ldquo;.RNG.seed&rdquo; - see for example the output of <code><a href="#topic+parallel.seeds">parallel.seeds</a></code>
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>

<hr>
<h2 id='jags.module'>Dynamically load JAGS modules</h2><span id='topic+load.module'></span><span id='topic+unload.module'></span><span id='topic+list.modules'></span>

<h3>Description</h3>

<p>A JAGS module is a dynamically loaded library that extends the
functionality of JAGS. These functions load and unload JAGS modules
and show the names of the currently loaded modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.module(name, path, quiet=FALSE)
unload.module(name, quiet=FALSE)
list.modules()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jags.module_+3A_name">name</code></td>
<td>
<p>name of the load module to be loaded</p>
</td></tr>
<tr><td><code id="jags.module_+3A_path">path</code></td>
<td>
<p>file path to the location of the DLL. If omitted,
the option <code>jags.moddir</code> is used to locate the modules</p>
</td></tr>
<tr><td><code id="jags.module_+3A_quiet">quiet</code></td>
<td>
<p>a logical. If <code>TRUE</code>, no message will be printed
about loading the package</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.modules()
load.module("glm")
list.modules()
unload.module("glm")
list.modules()
</code></pre>

<hr>
<h2 id='jags.object'>Functions for manipulating jags model objects</h2><span id='topic+variable.names.jags'></span><span id='topic+coef.jags'></span><span id='topic+list.samplers'></span>

<h3>Description</h3>

<p>A <code>jags</code> object represents a Bayesian graphical model
described using the BUGS language. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jags'
coef(object, chain=1, ...)
## S3 method for class 'jags'
variable.names(object, ...)
list.samplers(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jags.object_+3A_object">object</code></td>
<td>
<p>a <code>jags</code> model object</p>
</td></tr>
<tr><td><code id="jags.object_+3A_chain">chain</code></td>
<td>
<p>chain number to query</p>
</td></tr>
<tr><td><code id="jags.object_+3A_...">...</code></td>
<td>
<p>additional arguments to the call (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>coef</code> function returns a list with an entry for each Node
array that contains an unobserved Node. Elements corresponding to
observed Nodes or deterministic Nodes are given missing values.
</p>
<p>The <code>variable.names</code> function returns a character vector of
names of node arrays used in the model.
</p>
<p>The <code>list.samplers</code> function returns a named list with an entry
for each Sampler used by the model.  Each list element is a character
vector containing the names of stochastic Nodes that are updated
together in a block. The names of the list elements indicate the
sampling methods that are used to update each block.  Stochastic nodes
that are updated by forward sampling from the prior are not listed.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(LINE)
  LINE$recompile()
  coef(LINE)
  variable.names(LINE)
  list.samplers(LINE)
</code></pre>

<hr>
<h2 id='jags.samples'>Generate posterior samples</h2><span id='topic+jags.samples'></span>

<h3>Description</h3>

<p>Function to extract random samples from the posterior distribution
of the parameters of a <code>jags</code> model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags.samples(model, variable.names, n.iter, thin = 1,
             type="trace", force.list=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jags.samples_+3A_model">model</code></td>
<td>
<p>a jags model object</p>
</td></tr>
<tr><td><code id="jags.samples_+3A_variable.names">variable.names</code></td>
<td>
<p>a character vector giving the names of variables
to be monitored</p>
</td></tr>
<tr><td><code id="jags.samples_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations to monitor</p>
</td></tr>
<tr><td><code id="jags.samples_+3A_thin">thin</code></td>
<td>
<p>thinning interval for monitors</p>
</td></tr>
<tr><td><code id="jags.samples_+3A_type">type</code></td>
<td>
<p>type of monitor (can be vectorised)</p>
</td></tr>
<tr><td><code id="jags.samples_+3A_force.list">force.list</code></td>
<td>
<p>option to consistently return a named list of monitor
types even if a single monitor type is requested</p>
</td></tr>
<tr><td><code id="jags.samples_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the update method for jags
model objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>jags.samples</code> function creates monitors for the given
variables, runs the model for <code>n.iter</code> iterations and returns
the monitored samples.
</p>


<h3>Value</h3>

<p>A list of <code>mcarray</code> objects, with one element for each 
element of the <code>variable.names</code> argument.  If more than 
one type of monitor is requested (or if force.list is TRUE)
then the return value will be a (named) list of lists of 
<code>mcarray</code> objects, with one element for each monitor type.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+jags.model">jags.model</a></code>, <code><a href="#topic+coda.samples">coda.samples</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(LINE)
  LINE$recompile()
  LINE.samples &lt;- jags.samples(LINE, c("alpha","beta","sigma"),
  n.iter=1000)
  LINE.samples
  LINE.samples &lt;- jags.samples(LINE, c("alpha","beta","sigma"),
  force.list=TRUE, n.iter=1000)
  LINE.samples
  LINE.samples &lt;- jags.samples(LINE, c("alpha","alpha"),
  n.iter=1000, type=c("trace","mean"))
  LINE.samples$trace
  LINE.samples$mean
</code></pre>

<hr>
<h2 id='jags.version'>JAGS version</h2><span id='topic+jags.version'></span><span id='topic+JAGS.version'></span>

<h3>Description</h3>

<p>Get the version of the JAGS library which is currently linked to this R session
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags.version()
</code></pre>


<h3>Value</h3>

<p>The version of JAGS formatted as a package version string (see <code><a href="base.html#topic+package_version">package_version</a></code>)
</p>

<hr>
<h2 id='line'>Linear regression example</h2><span id='topic+LINE'></span>

<h3>Description</h3>

<p>The LINE model is a trivial linear regression model with only 5 observations.
It's main use is to allow automated checks of the <span class="pkg">rjags</span> package.
</p>


<h3>Format</h3>

<p>A <code>jags.model</code> object, which must be recompiled before
use.
</p>

<hr>
<h2 id='mcarray.object'>Objects for representing MCMC output</h2><span id='topic+mcarray.object'></span><span id='topic+print.mcarray'></span><span id='topic+summary.mcarray'></span><span id='topic+as.mcmc.list.mcarray'></span>

<h3>Description</h3>

<p>An <code>mcarray</code> object is used by the <code>jags.samples</code> function
to represent MCMC output from a JAGS model. It is an array with named
dimensions, for which the dimensions &quot;iteration&quot; and &quot;chain&quot; have a
special status
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcarray'
summary(object, FUN, ...)
## S3 method for class 'mcarray'
print(x, ...)
## S3 method for class 'mcarray'
as.mcmc.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcarray.object_+3A_object">object</code>, <code id="mcarray.object_+3A_x">x</code></td>
<td>
<p>an <code>mcarray</code> object</p>
</td></tr>
<tr><td><code id="mcarray.object_+3A_fun">FUN</code></td>
<td>
<p>a function to be used to generate summary statistics</p>
</td></tr>
<tr><td><code id="mcarray.object_+3A_...">...</code></td>
<td>
<p>additional arguments to the call</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>coda</code> package defines <code>mcmc</code> objects for representing
output from an MCMC sampler, and <code>mcmc.list</code> for representing
output from multiple parallel chains.  These objects emphasize the
time-series aspect of the MCMC output, but lose the original array
structure of the variables they represent.  The <code>mcarray</code> class
attempts to rectify this by preserving the dimensions of the original
node array defined in the JAGS model.
</p>


<h3>Value</h3>

<p>The <code>summary</code> method for <code>mcarray</code> objects applies the
given function to the array, marginalizing the &quot;chain&quot; and &quot;iteration&quot;
dimensions.
</p>
<p>The <code>print</code> method applies the summary function with
<code>FUN=mean</code>.
</p>
<p>The <code>as.mcmc.list</code> method coerces an <code>mcarray</code> to an
<code>mcmc.list</code> object so that the diagnostics provided by the
<code>coda</code> package can be applied to the MCMC output it represents.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>

<hr>
<h2 id='parallel'>Get initial values for parallel RNGs</h2><span id='topic+parallel.seeds'></span>

<h3>Description</h3>

<p>On a multi-processor system, you may wish to run parallel chains using
multiple <code>jags.model</code> objects, each running a single chain on a
separate processor.  This function returns a list of values that may
be used to initialize the random number generator of each chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel.seeds(factory, nchain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel_+3A_factory">factory</code></td>
<td>
<p>Name of the RNG factory to use.</p>
</td></tr>
<tr><td><code id="parallel_+3A_nchain">nchain</code></td>
<td>
<p>Number of chains for which to initialize RNGs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parallel.seeds</code> returns a list of RNG states. Each element
is a list of length 2 with the following elements:
</p>
<table>
<tr><td><code>.RNG.name</code></td>
<td>
<p>The name of the RNG</p>
</td></tr>
<tr><td><code>.RNG.state</code></td>
<td>
<p>An integer vector giving the state of the RNG.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is not yet possible to make the results of <code>parallel.seeds</code>
reproducible.  This will be fixed in a future version of JAGS.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+jags.model">jags.model</a></code>, section &ldquo;Random number generators&rdquo;,
for further details on RNG initialization;
<code><a href="#topic+list.factories">list.factories</a></code> to find the names of available RNG
factories.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##The BaseRNG factory generates up to four distinct types of RNG. If
##more than 4 chains are requested, it will recycle the RNG types, but
##use different initial values
parallel.seeds("base::BaseRNG", 3)

## The lecuyer module provides the RngStream factory, which allows large
## numbers of independent parallel RNGs to be generated. 
load.module("lecuyer")
list.factories(type="rng")
parallel.seeds("lecuyer::RngStream", 5);
</code></pre>

<hr>
<h2 id='read.jagsdata'>Read data files for jags models</h2><span id='topic+read.jagsdata'></span><span id='topic+read.bugsdata'></span>

<h3>Description</h3>

<p>Read data for a JAGS model from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.jagsdata(file)
read.bugsdata(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.jagsdata_+3A_file">file</code></td>
<td>
<p>name of a file containing a text repesentation of the
data for a jags model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command line interface for JAGS reads data and initial values from
a text file.  The data format used for jags data files is the same as the R
<code>dump</code> function. Thus the data values can be read into an
R session using the <code>source</code> function, but this will create
objects in the global environment. The <code>read.jagsdata</code> function
is a simple wrapper that reads the data into a list instead.
</p>
<p>OpenBUGS also reads data and initial values from a text file. The
format of these files is described as &quot;S-PLUS&quot; format by the OpenBUGS
authors. It superficially resembles the format used by the <code>dput</code>
function (and in fact can be parsed by the <code>dget</code>
function). However, in BUGS &quot;S-PLUS&quot; format, arrays are stored in
row-major order instead of the column-major order used by R.  The
<code>read.bugsdata</code> function reads OpenBUGS &quot;S-PLUS&quot; format files and
permutes the elements of arrays so that they appear in the correct
order.
</p>
<p>Either function returns a list which can be used as the
<code>data</code> or <code>inits</code> argument of <code>jags.model</code>.
</p>


<h3>Value</h3>

<p>A named list of numeric vectors or arrays. 
</p>


<h3>Note</h3>

<p>Earlier versions of the rjags package had a <code>read.data</code> function
which read data in either format, but the function name was ambiguous
(There are many data file format in R) so this is now deprecated.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>

<hr>
<h2 id='rjags-deprecated'>Deprecated Functions in the rjags package</h2><span id='topic+rjags-deprecated'></span><span id='topic+read.data'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
the rjags package and will soon be defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.data(file, format=c("jags","bugs"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rjags-deprecated_+3A_file">file</code></td>
<td>
<p>name of a file containing a text repesentation of the
data for a jags model</p>
</td></tr>
<tr><td><code id="rjags-deprecated_+3A_format">format</code></td>
<td>
<p>format of the data</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.data</code> with <code>format="jags"</code> is a deprecated synonym for
<code><a href="#topic+read.jagsdata">read.jagsdata</a></code> and with
<code>format="bugs"</code> is a deprecated synonym for
<code><a href="#topic+read.bugsdata">read.bugsdata</a></code>.
</p>

<hr>
<h2 id='rjags-package'>
Bayesian graphical models using MCMC
</h2><span id='topic+rjags-package'></span><span id='topic+rjags'></span>

<h3>Description</h3>

<p>The rjags package provides an interface from R to the JAGS library for
Bayesian data analysis.  JAGS uses Markov Chain Monte Carlo (MCMC) to
generate a sequence of dependent samples from the posterior
distribution of the parameters.
</p>


<h3>Details</h3>

<p>JAGS is a clone of BUGS (Bayesian analysis Using Gibbs Sampling).  See
Lunn et al (2009) for a history of the BUGS project.  Note that the
rjags package does not include a copy of the JAGS library: you must
install this separately. For instructions on downloading JAGS, see the
home page at <a href="https://mcmc-jags.sourceforge.io">https://mcmc-jags.sourceforge.io</a>.
</p>
<p>To fully understand how JAGS works, you need to read the
<a href="https://sourceforge.net/projects/mcmc-jags/files/Manuals/4.x/jags_user_manual.pdf/download">JAGS
User Manual</a>.  The manual explains the basics of modelling with JAGS
and shows the functions and distributions available in the dialect of
the BUGS language used by JAGS. It also describes the command line
interface.  The <span class="pkg">rjags</span> package does not use the command line
interface but provides equivalent functionality using R functions.
</p>
<p>Analysis using the <span class="pkg">rjags</span> package proceeds in steps:
</p>

<ol>
<li><p> Define the model using the BUGS language in a separate file.
</p>
</li>
<li><p> Read in the model file using the <code>jags.model</code> function.
This creates an object of class &ldquo;jags&rdquo;.
</p>
</li>
<li><p> Update the model using the <code>update</code> method for
&ldquo;jags&rdquo; objects.  This constitutes a &lsquo;burn-in&rsquo; period.
</p>
</li>
<li><p> Extract samples from the model object using the
<code>coda.samples</code> function. This creates an object of class
&ldquo;mcmc.list&rdquo; which can be used to summarize the posterior
distribution. The <span class="pkg">coda</span> package also provides convergence
diagnostics to check that the output is valid for analysis (see
Plummer et al 2006).
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Martyn Plummer
</p>


<h3>References</h3>

<p>Lunn D, Spiegelhalter D, Thomas A, Best N. (2009) The BUGS project:
Evolution, critique and future directions.  <em>Statistics in Medicine</em>, 
<b>28</b>:3049-67.
</p>
<p>Plummer M, Best N, Cowles K, Vines K (2006). CODA: Convergence Diagnosis
and Output Analysis for MCMC, <em>R News</em>, <b>6</b>:7-11.
</p>

<hr>
<h2 id='update'>Update jags models</h2><span id='topic+update.jags'></span>

<h3>Description</h3>

<p>Update the Markov chain associated with the model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jags'
update(object, n.iter=1, by, progress.bar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>a <code>jags</code> model object</p>
</td></tr>
<tr><td><code id="update_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations of the Markov chain to run</p>
</td></tr>
<tr><td><code id="update_+3A_by">by</code></td>
<td>
<p>refresh frequency for progress bar.  See Details</p>
</td></tr>
<tr><td><code id="update_+3A_progress.bar">progress.bar</code></td>
<td>
<p>type of progress bar. Possible values are
<code>"text"</code>, <code>"gui"</code>, and <code>"none"</code>. See Details.</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>additional arguments to the update method (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since MCMC calculations are typically long, a progress bar is
displayed during the call to <code>update</code>.  The type of progress bar
is determined by the <code>progress.bar</code> argument.  Type <code>"text"</code>
is displayed on the R console. Type <code>"gui"</code> is a graphical
progress bar in a new window.  The progress bar is suppressed if
<code>progress.bar</code> is <code>"none"</code> or <code>NULL</code>, if the update is
less than 100 iterations, or if R is not running interactively.
</p>
<p>The default progress bar type is taken from the option <code>jags.pb</code>.
</p>
<p>The progress bar is refreshed every <code>by</code> iterations. The
update can only be interrupted when the progress bar is refreshed.
Therefore it is advisable not to set <code>by</code> to a very large
value. By default <code>by</code> is either <code>n.iter/50</code> or <code>100</code>,
whichever is smaller.
</p>


<h3>Value</h3>

<p>The <code>update</code> method for <code>jags</code> model objects modifies the
original object and returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
