<!DOCTYPE html><html><head><title>Help for package SNSchart</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SNSchart}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calibrateControlLimit'><p>Calibration of the control limit for the selected chart</p></a></li>
<li><a href='#dataAlignment'><p>Alignment of the data</p></a></li>
<li><a href='#example49'><p>Data from Example 4.9 Qiu (2014).</p></a></li>
<li><a href='#example65'><p>Data from Example 6.5 on page 246 Qiu (2014).</p></a></li>
<li><a href='#example71'><p>Data from Example 7.1 Qiu (2014).</p></a></li>
<li><a href='#example74a'><p>Data from Example 7.4(a) Qiu (2014).</p></a></li>
<li><a href='#example74b'><p>Data from Example 7.4(b) Qiu (2014).</p></a></li>
<li><a href='#example74c'><p>Data from Example 7.4(c) Qiu (2014).</p></a></li>
<li><a href='#example81'><p>Data from Example 8.1 on page 319 Qiu (2014).</p></a></li>
<li><a href='#example82'><p>Data from Example 8.2 Qiu (2014).</p></a></li>
<li><a href='#example83'><p>Data from Example 8.3 on page 326 Qiu (2014).</p></a></li>
<li><a href='#example84'><p>Data from Example 8.4 Qiu (2014).</p></a></li>
<li><a href='#example85'><p>Data from Example 8.5 Qiu (2014).</p></a></li>
<li><a href='#example87'><p>Data from Example 8.7 on page 339 Qiu (2014).</p></a></li>
<li><a href='#example91'><p>Data from Example 9.1 on page 369 Qiu (2014).</p></a></li>
<li><a href='#example93'><p>Data from Example 9.3 Qiu (2014).</p></a></li>
<li><a href='#getARL'><p>Average Run Length (ARL)</p></a></li>
<li><a href='#getDist'><p>Random Observations Generator</p></a></li>
<li><a href='#getQuantile'><p>Obtain Quantile from Distribution Function</p></a></li>
<li><a href='#getRL'><p>Run Length</p></a></li>
<li><a href='#mcalibrateControlLimit'><p>Calibration of the control limit for the selected chart</p></a></li>
<li><a href='#mgetARL'><p>Multivariate Average Run Length (ARL)</p></a></li>
<li><a href='#mgetDist'><p>Multivariate Random Observations Generetor</p></a></li>
<li><a href='#mgetRL'><p>Multivariate Run Length</p></a></li>
<li><a href='#MNS'><p>Multivariate Normal Scores</p></a></li>
<li><a href='#MSNS'><p>Multivariate Sequential Normal Scores</p></a></li>
<li><a href='#NS'><p>Normal Scores</p></a></li>
<li><a href='#SNS'><p>Sequential Normal Scores</p></a></li>
<li><a href='#srank'><p>Sequential Rank</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sequential Normal Scores in Statistical Process Management</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Victor Tercero [aut],
  Luis Benavides [aut, cre],
  Jorge Merlo [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luis Benavides &lt;luisbv@tec.mx&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The methods discussed in this package are new non-parametric methods
    based on sequential normal scores 'SNS' (Conover et al (2017)
    &lt;<a href="https://doi.org/10.1080%2F07474946.2017.1360091">doi:10.1080/07474946.2017.1360091</a>&gt;), designed for sequences of observations,
    usually time series data, which may occur singly or in batches,
    and may be univariate or multivariate. These methods are designed
    to detect changes in the process, which may occur as changes in location
    (mean or median), changes in scale (standard deviation, or variance), or
    other changes of interest in the distribution of the observations,
    over the time observed. They usually apply to large data sets,
    so computations need to be simple enough to be done in a reasonable
    time on a computer, and easily updated as each new observation
    (or batch of observations) becomes available. Some examples and more detail
    in 'SNS' is presented in the work by Conover et al (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1901.04443">doi:10.48550/arXiv.1901.04443</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, stats, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-05 18:22:03 UTC; L03099908</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-07 08:40:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='calibrateControlLimit'>Calibration of the control limit for the selected chart</h2><span id='topic+calibrateControlLimit'></span>

<h3>Description</h3>

<p>The methodology used to calibrate the control limit
for the SNS chart depending on the selected chart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateControlLimit(
  targetARL = NULL,
  targetMRL = NULL,
  n,
  m,
  theta = NULL,
  Ftheta = NULL,
  scoring = "Z",
  Chi2corrector = "None",
  dist,
  mu,
  sigma,
  dist.par = c(0, 1, 1),
  chart,
  chart.par,
  replicates = 50000,
  isParallel = TRUE,
  maxIter = 20,
  progress = TRUE,
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE,
  isFixed = FALSE,
  rounding.factor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrateControlLimit_+3A_targetarl">targetARL</code></td>
<td>
<p>scalar. is the target ARL to calibrate. By default is set to NULL</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_targetmrl">targetMRL</code></td>
<td>
<p>scalar. is the target ARL to calibrate. By default is set to NULL</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_n">n</code></td>
<td>
<p>scalar. Subroup size</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_m">m</code></td>
<td>
<p>scalar. Reference sample size</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_theta">theta</code></td>
<td>
<p>scalar. Value corresponig with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_ftheta">Ftheta</code></td>
<td>
<p>scalar. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_scoring">scoring</code></td>
<td>
<p>character string. If &quot;Z&quot; (normal scores) (default). If &quot;Z-SQ&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_chi2corrector">Chi2corrector</code></td>
<td>
<p>character string. Only when scoring is Z-SQ. Select from
</p>

<ul>
<li><p>&quot;approx: Z^2*(m + 1 + 1.3)/(m+1).
</p>
</li>
<li><p>&quot;exact&quot;: Z^2/mean(Z).
</p>
</li>
<li><p>&quot;none&quot;: Z^2.
</p>
</li></ul>

<p>If &quot;approx&quot; () (default). If &quot;exact&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_dist">dist</code></td>
<td>
<p>character string. Select from:
</p>

<ul>
<li><p>&quot;Uniform: Continuous Uniform distribution .
</p>
</li>
<li><p>&quot;Normal&quot;: Normal distribution (default).
</p>
</li>
<li><p>&quot;Normal2&quot;: Squared Normal distribution (also known as Chi-squared).
</p>
</li>
<li><p>&quot;DoubleExp&quot;: Double exponential distribution (also known as Laplace distribution).
</p>
</li>
<li><p>&quot;DoubleExp2&quot;: Double exponential squared distribution from a <code>DoubleExp(0,1)</code>.
</p>
</li>
<li><p>&quot;LogNormal&quot;: Lognormal distribution.
</p>
</li>
<li><p>&quot;Gamma&quot;: Gamma distribution.
</p>
</li>
<li><p>&quot;Weibull&quot;: Weibull distribution.
</p>
</li>
<li><p>&quot;t&quot;: Student-t distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_mu">mu</code></td>
<td>
<p>vector. Two elements, the first one is the mean of the reference sample and the second one is the mean of the monitoring sample.</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_sigma">sigma</code></td>
<td>
<p>vector. Two elements, the first one is the sd of the reference sample and the second one is the sd of the monitoring sample.</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_dist.par">dist.par</code></td>
<td>
<p>vector. Distribution parameters. <code>c(par.a, par.b)</code>. Default <code>c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_chart">chart</code></td>
<td>
<p>character string. Selected type of chart. Three options are available: Shewhart, CUSUM, EWMA</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_chart.par">chart.par</code></td>
<td>
<p>vector. The size depends on the selected chart:
</p>

<dl>
<dt>Shewhart scheme: </dt><dd><p>is <code>c(k)</code>, where <code>k</code> comes from <code class="reqn">UCL = mu + k\sigma, LCL = mu - k\sigma.</code></p>
</dd>
<dt>CUSUM scheme: </dt><dd><p>is <code>c(k, h, t)</code> where <code>k</code> is the reference value and <code>h</code> is the control limit,
and <code>t</code> is the type of the chart (1:positive, 2:negative, 3:two sides)</p>
</dd>
<dt>EWMA scheme: </dt><dd><p>is <code>c(lambda, L)</code>, where <code>lambda</code> is the smoothing constant
and <code>L</code> multiplies standard deviation to get the control limit</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_replicates">replicates</code></td>
<td>
<p>scalar. Number of replicates to get the ARL</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_isparallel">isParallel</code></td>
<td>
<p>logical. If <code>TRUE</code> the code runs in parallel according to the
number of cores in the computer,otherwise the code runs sequentially. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_maxiter">maxIter</code></td>
<td>
<p>scalar. is a numeric. The maximum number of iteration to take the calibration before stops</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_progress">progress</code></td>
<td>
<p>logical. If <code>TRUE</code> it shows the progress in the console.</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_isfixed">isFixed</code></td>
<td>
<p>logical. If <code>TRUE</code> the reference sample does not update, otherwise the reference sample is updated whenever the batch is in control.</p>
</td></tr>
<tr><td><code id="calibrateControlLimit_+3A_rounding.factor">rounding.factor</code></td>
<td>
<p>scalar. positive value that determine the range between two consecutive rounded values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>objective.function</code>: scalar. The best solution obtained, in terms of the target ARL or MRL
</p>
</li>
<li> <p><code>par.value</code>: scalar. Which parameter of the chart reach this best solution
</p>
</li>
<li> <p><code>iter</code>: scalar. In which iteration is found the objective function.
</p>
</li>
<li> <p><code>found</code>: boolean. Is TRUE if in the <code>maxIter</code> is reached the desired +-5
</p>
</li></ul>



<h3>Note</h3>

<p>The argument <code>chart.par</code> in this function correspond to the initial parameters to start the calibration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2 # subgroup size
m &lt;- 30 # reference-sample size
dist &lt;- "Normal" # distribution
mu &lt;- c(0, 0) # c(reference sample mean, monitoring sample mean)
sigma &lt;- c(1, 1) # c(reference sample sd, monitoring sample sd)

#### Distribution parameters
dist.par &lt;- c(0, 1) # c(location, scale)

#### Other Parameters
replicates &lt;- 2
targetARL &lt;- 370
isParallel = FALSE

#### Control chart parameters
chart &lt;- "Shewhart"
chart.par &lt;- c(3)
shewhart &lt;- calibrateControlLimit(
  targetARL = targetARL, targetMRL = NULL, n = n, m = m, theta = NULL,
  Ftheta = NULL, dist = dist, mu = mu, sigma = sigma, dist.par = dist.par, chart.par = chart.par,
  replicates = replicates, chart = chart, isParallel = isParallel
)

chart &lt;- "CUSUM"
chart.par &lt;- c(0.5, 2.5, 3)
cusum &lt;- calibrateControlLimit(
  targetARL = targetARL, targetMRL = NULL, n = n, m = m, theta = NULL,
  Ftheta = NULL, dist = dist, mu = mu, sigma = sigma, dist.par = dist.par, chart.par = chart.par,
  replicates = replicates, chart = chart, isParallel = isParallel
)

chart &lt;- "EWMA"
chart.par &lt;- c(0.2, 2.962)
ewma &lt;- calibrateControlLimit(
  targetARL = targetARL, targetMRL = NULL, n = n, m = m, theta = NULL,
  Ftheta = NULL, dist = dist, mu = mu, sigma = sigma, dist.par = dist.par, chart.par = chart.par,
  replicates = replicates, chart = chart, isParallel = isParallel
)
</code></pre>

<hr>
<h2 id='dataAlignment'>Alignment of the data</h2><span id='topic+dataAlignment'></span>

<h3>Description</h3>

<p>Align the monitoring sample <code>X</code> and the reference sample <code>Y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataAlignment(
  X,
  Y,
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataAlignment_+3A_x">X</code></td>
<td>
<p>vector. Monitoring sample.</p>
</td></tr>
<tr><td><code id="dataAlignment_+3A_y">Y</code></td>
<td>
<p>vector. Reference sample.</p>
</td></tr>
<tr><td><code id="dataAlignment_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dataAlignment_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dataAlignment_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>X</code>: vector. Monitor sample with the alignment selected.
</p>
</li>
<li> <p><code>Y</code>: vector. Reference sample with the alignment selected.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>X = c(30, 45, 50)
Y = c(20, 22, 25, 30, 70)
dataAlignment(X,Y)

</code></pre>

<hr>
<h2 id='example49'>Data from Example 4.9 Qiu (2014).</h2><span id='topic+example49'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 4.9 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example49
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 6 columns:
</p>

<dl>
<dt>Y1</dt><dd><p>Reference sample of the first data set. 10 batches are N(0,1)</p>
</dd>
<dt>X1</dt><dd><p>Monitoring sample of the first data set. 10 batches are N(1,1).</p>
</dd>
<dt>Y2</dt><dd><p>Reference sample of the second data set. 10 batches are N(0,1)</p>
</dd>
<dt>X2</dt><dd><p>Monitoring sample of the second data set. 10 batches are N(0,2^2).</p>
</dd>
<dt>X.id</dt><dd><p>id of each observation of the batch for the second data set.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example49.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example49.dat</a>
</p>

<hr>
<h2 id='example65'>Data from Example 6.5 on page 246 Qiu (2014).</h2><span id='topic+example65'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 6.5 on page 246 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example65
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 5 columns:
</p>

<dl>
<dt>x</dt><dd><p>first 9 observations are the reference sample. Batch size equals to 1.</p>
</dd>
<dt>Wn</dt><dd><p>Wn</p>
</dd>
<dt>Sn2</dt><dd><p>Sn2</p>
</dd>
<dt>Bmax</dt><dd><p>Bmax</p>
</dd>
<dt>hn</dt><dd><p>hn</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example65.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example65.dat</a>
</p>

<hr>
<h2 id='example71'>Data from Example 7.1 Qiu (2014).</h2><span id='topic+example71'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 7.1 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example71
</code></pre>


<h3>Format</h3>

<p>The data (X1,X2,X3) consist of 30 observations each variable.
</p>

<dl>
<dt>X</dt><dd><p>1st batch.</p>
</dd>
<dt>X.1</dt><dd><p>2nd batch.</p>
</dd>
<dt>X.2</dt><dd><p>3rd batch.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example71.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example71.dat</a>
</p>

<hr>
<h2 id='example74a'>Data from Example 7.4(a) Qiu (2014).</h2><span id='topic+example74a'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 7.4(a) of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example74a
</code></pre>


<h3>Format</h3>

<p>The data (X1,X2,X3) consist of 30 observations each variable.
</p>

<dl>
<dt>X</dt><dd><p>1st batch.</p>
</dd>
<dt>X.1</dt><dd><p>2nd batch.</p>
</dd>
<dt>X.2</dt><dd><p>3rd batch.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example74a.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example74a.dat</a>
</p>

<hr>
<h2 id='example74b'>Data from Example 7.4(b) Qiu (2014).</h2><span id='topic+example74b'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 7.4(b) of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example74b
</code></pre>


<h3>Format</h3>

<p>The data (X1,X2,X3) consist of 30 observations each variable.
</p>

<dl>
<dt>X</dt><dd><p>1st batch.</p>
</dd>
<dt>X.1</dt><dd><p>2nd batch.</p>
</dd>
<dt>X.2</dt><dd><p>3rd batch.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example74b.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example74b.dat</a>
</p>

<hr>
<h2 id='example74c'>Data from Example 7.4(c) Qiu (2014).</h2><span id='topic+example74c'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 7.4(c) of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example74c
</code></pre>


<h3>Format</h3>

<p>The data (X1,X2,X3) consist of 30 observations each variable.
</p>

<dl>
<dt>X</dt><dd><p>1st batch.</p>
</dd>
<dt>X.1</dt><dd><p>2nd batch.</p>
</dd>
<dt>X.2</dt><dd><p>3rd batch.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example74c.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example74c.dat</a>
</p>

<hr>
<h2 id='example81'>Data from Example 8.1 on page 319 Qiu (2014).</h2><span id='topic+example81'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 8.1 on page 319 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example81
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows (30 batches of size equals to 10)
</p>

<dl>
<dt>X</dt><dd><p>observations of all batches</p>
</dd>
<dt>X.id</dt><dd><p>id of each observation of the batch</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example81.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example81.dat</a>
</p>

<hr>
<h2 id='example82'>Data from Example 8.2 Qiu (2014).</h2><span id='topic+example82'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 8.2 on page 323 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example82
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows (30 batches of size equals to 5)
</p>

<dl>
<dt>X</dt><dd><p>observations of all batches</p>
</dd>
<dt>X.id</dt><dd><p>id of each observation of the batch</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example82.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example82.dat</a>
</p>

<hr>
<h2 id='example83'>Data from Example 8.3 on page 326 Qiu (2014).</h2><span id='topic+example83'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 8.3 on page 326 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example83
</code></pre>


<h3>Format</h3>

<p>A data frame with 180 rows (30 batches of size equals to 6)
</p>

<dl>
<dt>X</dt><dd><p>observations of all batches</p>
</dd>
<dt>X.id</dt><dd><p>id of each observation of the batch</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example81.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example81.dat</a>
</p>

<hr>
<h2 id='example84'>Data from Example 8.4 Qiu (2014).</h2><span id='topic+example84'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 8.4 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example84
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows (30 batches of size equals to 5)
</p>

<dl>
<dt>X</dt><dd><p>observations of all batches</p>
</dd>
<dt>X.id</dt><dd><p>id of each observation of the batch</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example84.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example84.dat</a>
</p>

<hr>
<h2 id='example85'>Data from Example 8.5 Qiu (2014).</h2><span id='topic+example85'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 8.5 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example85
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows (30 batches of size equals to 10)
</p>

<dl>
<dt>X</dt><dd><p>observations of all batches</p>
</dd>
<dt>X.id</dt><dd><p>id of each observation of the batch</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example85.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example85.dat</a>
</p>

<hr>
<h2 id='example87'>Data from Example 8.7 on page 339 Qiu (2014).</h2><span id='topic+example87'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 8.7 on page 339 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example87
</code></pre>


<h3>Format</h3>

<p>A data frame with 86 rows (86 batches of size equals to 1)
</p>

<dl>
<dt>X</dt><dd><p>observations of all batches</p>
</dd>
<dt>X.id</dt><dd><p>id of each observation of the batch</p>
</dd>
<dt>Y</dt><dd><p>reference sample of size equals to 14</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example87.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example87.dat</a>
</p>

<hr>
<h2 id='example91'>Data from Example 9.1 on page 369 Qiu (2014).</h2><span id='topic+example91'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 9.1 on page 369 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example91
</code></pre>


<h3>Format</h3>

<p>The data (X,Y) consist of 20 batches with 50 observations in each batch.
</p>

<dl>
<dt>V1</dt><dd><p>1st batch.</p>
</dd>
<dt>V2</dt><dd><p>2nd batch.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example91.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example91.dat</a>
</p>

<hr>
<h2 id='example93'>Data from Example 9.3 Qiu (2014).</h2><span id='topic+example93'></span>

<h3>Description</h3>

<p>A dataset containing the data set used in Example 9.3 of Qiu (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example93
</code></pre>


<h3>Format</h3>

<p>The data (X,Y) consist of 20 batches with 10 observations in each batch.
</p>

<dl>
<dt>X</dt><dd><p>1st batch.</p>
</dd>
<dt>X.1</dt><dd><p>2nd batch.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example93.dat">https://users.phhp.ufl.edu/pqiu/research/book/spc/data/example93.dat</a>
</p>

<hr>
<h2 id='getARL'>Average Run Length (ARL)</h2><span id='topic+getARL'></span>

<h3>Description</h3>

<p>Get the ARL <code><a href="#topic+getRL">getRL</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getARL(
  n,
  m,
  theta = NULL,
  Ftheta = NULL,
  dist,
  mu,
  sigma,
  dist.par = c(0, 1, 1),
  chart,
  chart.par,
  scoring = "Z",
  Chi2corrector = "None",
  replicates = 10000,
  isParallel = TRUE,
  print.RL = FALSE,
  progress = FALSE,
  calibrate = FALSE,
  arl0 = 370,
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE,
  isFixed = FALSE,
  rounding.factor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getARL_+3A_n">n</code></td>
<td>
<p>scalar. Subroup size</p>
</td></tr>
<tr><td><code id="getARL_+3A_m">m</code></td>
<td>
<p>scalar. Reference sample size</p>
</td></tr>
<tr><td><code id="getARL_+3A_theta">theta</code></td>
<td>
<p>scalar. Value corresponig with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="getARL_+3A_ftheta">Ftheta</code></td>
<td>
<p>scalar. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="getARL_+3A_dist">dist</code></td>
<td>
<p>character string. Select from:
</p>

<ul>
<li><p>&quot;Uniform: Continuous Uniform distribution .
</p>
</li>
<li><p>&quot;Normal&quot;: Normal distribution (default).
</p>
</li>
<li><p>&quot;Normal2&quot;: Squared Normal distribution (also known as Chi-squared).
</p>
</li>
<li><p>&quot;DoubleExp&quot;: Double exponential distribution (also known as Laplace distribution).
</p>
</li>
<li><p>&quot;DoubleExp2&quot;: Double exponential squared distribution from a <code>DoubleExp(0,1)</code>.
</p>
</li>
<li><p>&quot;LogNormal&quot;: Lognormal distribution.
</p>
</li>
<li><p>&quot;Gamma&quot;: Gamma distribution.
</p>
</li>
<li><p>&quot;Weibull&quot;: Weibull distribution.
</p>
</li>
<li><p>&quot;t&quot;: Student-t distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getARL_+3A_mu">mu</code></td>
<td>
<p>vector. Two elements, the first one is the mean of the reference sample and the second one is the mean of the monitoring sample.</p>
</td></tr>
<tr><td><code id="getARL_+3A_sigma">sigma</code></td>
<td>
<p>vector. Two elements, the first one is the sd of the reference sample and the second one is the sd of the monitoring sample.</p>
</td></tr>
<tr><td><code id="getARL_+3A_dist.par">dist.par</code></td>
<td>
<p>vector. Distribution parameters. <code>c(par.a, par.b)</code>. Default <code>c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="getARL_+3A_chart">chart</code></td>
<td>
<p>character string. Selected type of chart. Three options are available: Shewhart, CUSUM, EWMA</p>
</td></tr>
<tr><td><code id="getARL_+3A_chart.par">chart.par</code></td>
<td>
<p>vector. The size depends on the selected chart:
</p>

<dl>
<dt>Shewhart scheme: </dt><dd><p>is <code>c(k)</code>, where <code>k</code> comes from <code class="reqn">UCL = mu + k\sigma, LCL = mu - k\sigma.</code></p>
</dd>
<dt>CUSUM scheme: </dt><dd><p>is <code>c(k, h, t)</code> where <code>k</code> is the reference value and <code>h</code> is the control limit,
and <code>t</code> is the type of the chart (1:positive, 2:negative, 3:two sides)</p>
</dd>
<dt>EWMA scheme: </dt><dd><p>is <code>c(lambda, L)</code>, where <code>lambda</code> is the smoothing constant
and <code>L</code> multiplies standard deviation to get the control limit</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getARL_+3A_scoring">scoring</code></td>
<td>
<p>character string. If &quot;Z&quot; (normal scores) (default). If &quot;Z-SQ&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="getARL_+3A_chi2corrector">Chi2corrector</code></td>
<td>
<p>character string. Only when scoring is Z-SQ. Select from
</p>

<ul>
<li><p>&quot;approx: Z^2*(m + 1 + 1.3)/(m+1).
</p>
</li>
<li><p>&quot;exact&quot;: Z^2/mean(Z).
</p>
</li>
<li><p>&quot;none&quot;: Z^2.
</p>
</li></ul>

<p>If &quot;approx&quot; () (default). If &quot;exact&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="getARL_+3A_replicates">replicates</code></td>
<td>
<p>scalar. Number of replicates to get the ARL</p>
</td></tr>
<tr><td><code id="getARL_+3A_isparallel">isParallel</code></td>
<td>
<p>logical. If <code>TRUE</code> the code runs in parallel according to the
number of cores in the computer,otherwise the code runs sequentially. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getARL_+3A_print.rl">print.RL</code></td>
<td>
<p>logical. If <code>TRUE</code> return the vectors of RL for each iteration.</p>
</td></tr>
<tr><td><code id="getARL_+3A_progress">progress</code></td>
<td>
<p>logical. If <code>TRUE</code> it shows the progress in the console.</p>
</td></tr>
<tr><td><code id="getARL_+3A_calibrate">calibrate</code></td>
<td>
<p>logical. If <code>TRUE</code> the RL is limit to 10 times the target ARL.</p>
</td></tr>
<tr><td><code id="getARL_+3A_arl0">arl0</code></td>
<td>
<p>scalar. Expected value of the RL. Default <code>370</code>.</p>
</td></tr>
<tr><td><code id="getARL_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getARL_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getARL_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="getARL_+3A_isfixed">isFixed</code></td>
<td>
<p>logical. If <code>TRUE</code> the reference sample does not update, otherwise the reference sample is updated whenever the batch is in control.</p>
</td></tr>
<tr><td><code id="getARL_+3A_rounding.factor">rounding.factor</code></td>
<td>
<p>scalar. positive value that determine the range between two consecutive rounded values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>ARL</code>: scalar. Average Run Length for the <code>RL</code>s of all the <code>replicates</code>.
</p>
</li>
<li> <p><code>SDRL</code>: scalar. Standard Deviation Run Length for the <code>RL</code> in all the <code>replicates</code>.
</p>
</li>
<li> <p><code>MRL</code>: bolean. Median Run Length for the <code>RL</code>s of all the <code>replicates</code>.
</p>
</li>
<li> <p><code>QRL</code>: vector. It retrieve the quantiles (0.05, 0.1, 0.2, 0.25, 0.5, 0.75, 0.8, 0.9, 0.95) for all the <code>RL</code>s.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5 # subgroup size
m &lt;- 100 # reference-sample size
dist &lt;- "Normal"
mu &lt;- c(0, 0) # c(reference sample mean, monitoring sample mean)
sigma &lt;- c(1, 1) # c(reference sample sd, monitoring sample sd)

#### Normal distribution parameters
dist.par &lt;- c(0, 1) # c(location, scale)

#### Other Parameters
replicates &lt;- 2
print.RL &lt;- TRUE
isParallel &lt;- FALSE
calibrate &lt;- FALSE
progress &lt;- TRUE
arl0 &lt;- 370

#### Control chart parameters
chart &lt;- "Shewhart"
chart.par &lt;- c(3)
shewhart &lt;- getARL(n, m,
  theta = NULL, Ftheta = NULL, dist, mu, sigma, dist.par = dist.par,
  chart = chart, chart.par = chart.par, print.RL = print.RL,
  replicates = replicates, isParallel = isParallel,
  calibrate = calibrate, arl0 = arl0
)

chart &lt;- "CUSUM"
chart.par &lt;- c(0.25, 4.4181, 3)
cusum &lt;- getARL(n, m,
  theta = NULL, Ftheta = NULL, dist, mu, sigma, dist.par = dist.par,
  chart = chart, chart.par = chart.par, print.RL = print.RL,
  replicates = replicates, isParallel = isParallel,
  calibrate = calibrate, arl0 = arl0
)

chart &lt;- "EWMA"
chart.par &lt;- c(0.2, 2.962)
shewhart &lt;- getARL(n, m,
  theta = NULL, Ftheta = NULL, dist, mu, sigma, dist.par = dist.par,
  chart = chart, chart.par = chart.par, print.RL = print.RL,
  replicates = replicates, isParallel = isParallel,
  calibrate = calibrate, arl0 = arl0
)
</code></pre>

<hr>
<h2 id='getDist'>Random Observations Generator</h2><span id='topic+getDist'></span>

<h3>Description</h3>

<p>Random observations generator selected from several distributions with user defined mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDist(
  n,
  dist,
  mu,
  sigma,
  par.location = 0,
  par.scale = 1,
  par.shape = 1,
  dist.par = NULL,
  rounding.factor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDist_+3A_n">n</code></td>
<td>
<p>scalar. Number of observations to be generated.</p>
</td></tr>
<tr><td><code id="getDist_+3A_dist">dist</code></td>
<td>
<p>character string. Select from:
</p>

<ul>
<li><p>&quot;Uniform: Continuous Uniform distribution .
</p>
</li>
<li><p>&quot;Normal&quot;: Normal distribution (default).
</p>
</li>
<li><p>&quot;Normal2&quot;: Squared Normal distribution (also known as Chi-squared).
</p>
</li>
<li><p>&quot;DoubleExp&quot;: Double exponential distribution (also known as Laplace distribution).
</p>
</li>
<li><p>&quot;DoubleExp2&quot;: Double exponential squared distribution from a <code>DoubleExp(0,1)</code>.
</p>
</li>
<li><p>&quot;LogNormal&quot;: Lognormal distribution.
</p>
</li>
<li><p>&quot;Gamma&quot;: Gamma distribution.
</p>
</li>
<li><p>&quot;Weibull&quot;: Weibull distribution.
</p>
</li>
<li><p>&quot;t&quot;: Student-t distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getDist_+3A_mu">mu</code></td>
<td>
<p>scalar. Expected value of the desired distribution.</p>
</td></tr>
<tr><td><code id="getDist_+3A_sigma">sigma</code></td>
<td>
<p>scalar. Standard deviation of the desired distribution.</p>
</td></tr>
<tr><td><code id="getDist_+3A_par.location">par.location</code></td>
<td>
<p>scalar. Location parameter of the desired distribution. Default 0**.</p>
</td></tr>
<tr><td><code id="getDist_+3A_par.scale">par.scale</code></td>
<td>
<p>scalar. Scale parameter of the desired distribution. Default 1**.</p>
</td></tr>
<tr><td><code id="getDist_+3A_par.shape">par.shape</code></td>
<td>
<p>scalar. Shape parameter of the desired distribution, Default 1.</p>
</td></tr>
<tr><td><code id="getDist_+3A_dist.par">dist.par</code></td>
<td>
<p>vector. Overwrite <code>par.location</code>, <code>par.scale</code>, <code>par.shape</code>. Depends on the distribution (default <code>NULL</code>):
</p>

<ul>
<li><p>&quot;Uniform: no matter how is defined always gives numbers between 0 and 1.
</p>
</li>
<li><p>&quot;Normal&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;Normal2&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;DoubleExp&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;DoubleExp2&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;LogNormal&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;Gamma&quot;: c(scale, shape).
</p>
</li>
<li><p>&quot;Weibull&quot;: c(shape, scale).
</p>
</li>
<li><p>&quot;t&quot;: c(degrees of freedom).
</p>
</li></ul>
</td></tr>
<tr><td><code id="getDist_+3A_rounding.factor">rounding.factor</code></td>
<td>
<p>scalar. positive value that determine the range between two consecutive rounded values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector <code>x</code> with <code>n</code> observations generated following the selected distribution with its parameters.
</p>


<h3>**Note</h3>


<ul>
<li><p>For &quot;Lognormal&quot;, <code>par.location</code> and <code>par.scale</code> correspond to the location and scale parameters of the normal
distribution that generales the lognormal. Hence, in this case they are the logmean and
the logsigma parameters
</p>
</li>
<li><p>For &quot;Normal2&quot; and &quot;DoubleExp2&quot;, <code>par.location</code> and <code>par.scale</code> correspond
correspond to the location and scale parameters of the normal and double exponential
that are used to generates their squared forms.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>getDist(1, "Normal", 0, 1)
</code></pre>

<hr>
<h2 id='getQuantile'>Obtain Quantile from Distribution Function</h2><span id='topic+getQuantile'></span>

<h3>Description</h3>

<p>Get the quantile <code>theta</code> from several distributions with user defined mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQuantile(
  Ftheta,
  mu,
  sigma,
  dist,
  par.location = 0,
  par.scale = 1,
  par.shape = 1,
  dist.par = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQuantile_+3A_ftheta">Ftheta</code></td>
<td>
<p>scalar. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_mu">mu</code></td>
<td>
<p>scalar. Expected value of the desired distribution.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_sigma">sigma</code></td>
<td>
<p>scalar. Standard deviation of the desired distribution.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_dist">dist</code></td>
<td>
<p>character string. Select from:
</p>

<ul>
<li><p>&quot;Uniform: Continuous Uniform distribution .
</p>
</li>
<li><p>&quot;Normal&quot;: Normal distribution (default).
</p>
</li>
<li><p>&quot;Normal2&quot;: Squared Normal distribution (also known as Chi-squared).
</p>
</li>
<li><p>&quot;DoubleExp&quot;: Double exponential distribution (also known as Laplace distribution).
</p>
</li>
<li><p>&quot;DoubleExp2&quot;: Double exponential squared distribution from a <code>DoubleExp(0,1)</code>.
</p>
</li>
<li><p>&quot;LogNormal&quot;: Lognormal distribution.
</p>
</li>
<li><p>&quot;Gamma&quot;: Gamma distribution.
</p>
</li>
<li><p>&quot;Weibull&quot;: Weibull distribution.
</p>
</li>
<li><p>&quot;t&quot;: Student-t distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getQuantile_+3A_par.location">par.location</code></td>
<td>
<p>scalar. Location parameter of the desired distribution. Default 0**.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_par.scale">par.scale</code></td>
<td>
<p>scalar. Scale parameter of the desired distribution. Default 1**.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_par.shape">par.shape</code></td>
<td>
<p>scalar. Shape parameter of the desired distribution, Default 1.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_dist.par">dist.par</code></td>
<td>
<p>vector. Overwrite <code>par.location</code>, <code>par.scale</code>, <code>par.shape</code>. Depends on the distribution (default <code>NULL</code>):
</p>

<ul>
<li><p>&quot;Uniform: no matter how is defined always gives numbers between 0 and 1.
</p>
</li>
<li><p>&quot;Normal&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;Normal2&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;DoubleExp&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;DoubleExp2&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;LogNormal&quot;: c(location, scale).
</p>
</li>
<li><p>&quot;Gamma&quot;: c(scale, shape).
</p>
</li>
<li><p>&quot;Weibull&quot;: c(shape, scale).
</p>
</li>
<li><p>&quot;t&quot;: c(degrees of freedom).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A quantile <code>theta</code> of the selected <code>Ftheta</code> distribution with its parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getQuantile(0.5, 0, 1, "Normal")
</code></pre>

<hr>
<h2 id='getRL'>Run Length</h2><span id='topic+getRL'></span>

<h3>Description</h3>

<p>Get the run length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRL(
  replica = 1,
  n,
  m,
  theta = NULL,
  Ftheta = NULL,
  dist,
  mu,
  sigma,
  dist.par = c(0, 1, 1),
  scoring = "Z",
  chart,
  chart.par,
  calibrate = FALSE,
  arl0 = 370,
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE,
  isFixed = FALSE,
  Chi2corrector = "None",
  rounding.factor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRL_+3A_replica">replica</code></td>
<td>
<p>scalar. It is used for the parallel version of the function (<code>parallel=TRUE</code>). Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="getRL_+3A_n">n</code></td>
<td>
<p>scalar. Subroup size</p>
</td></tr>
<tr><td><code id="getRL_+3A_m">m</code></td>
<td>
<p>scalar. Reference sample size</p>
</td></tr>
<tr><td><code id="getRL_+3A_theta">theta</code></td>
<td>
<p>scalar. Value corresponig with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="getRL_+3A_ftheta">Ftheta</code></td>
<td>
<p>scalar. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="getRL_+3A_dist">dist</code></td>
<td>
<p>character string. Select from:
</p>

<ul>
<li><p>&quot;Uniform: Continuous Uniform distribution .
</p>
</li>
<li><p>&quot;Normal&quot;: Normal distribution (default).
</p>
</li>
<li><p>&quot;Normal2&quot;: Squared Normal distribution (also known as Chi-squared).
</p>
</li>
<li><p>&quot;DoubleExp&quot;: Double exponential distribution (also known as Laplace distribution).
</p>
</li>
<li><p>&quot;DoubleExp2&quot;: Double exponential squared distribution from a <code>DoubleExp(0,1)</code>.
</p>
</li>
<li><p>&quot;LogNormal&quot;: Lognormal distribution.
</p>
</li>
<li><p>&quot;Gamma&quot;: Gamma distribution.
</p>
</li>
<li><p>&quot;Weibull&quot;: Weibull distribution.
</p>
</li>
<li><p>&quot;t&quot;: Student-t distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getRL_+3A_mu">mu</code></td>
<td>
<p>vector. Two elements, the first one is the mean of the reference sample and the second one is the mean of the monitoring sample.</p>
</td></tr>
<tr><td><code id="getRL_+3A_sigma">sigma</code></td>
<td>
<p>vector. Two elements, the first one is the sd of the reference sample and the second one is the sd of the monitoring sample.</p>
</td></tr>
<tr><td><code id="getRL_+3A_dist.par">dist.par</code></td>
<td>
<p>vector. Distribution parameters. <code>c(par.a, par.b)</code>. Default <code>c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="getRL_+3A_scoring">scoring</code></td>
<td>
<p>character string. If &quot;Z&quot; (normal scores) (default). If &quot;Z-SQ&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="getRL_+3A_chart">chart</code></td>
<td>
<p>character string. Selected type of chart. Three options are available: Shewhart, CUSUM, EWMA</p>
</td></tr>
<tr><td><code id="getRL_+3A_chart.par">chart.par</code></td>
<td>
<p>vector. The size depends on the selected chart:
</p>

<dl>
<dt>Shewhart scheme: </dt><dd><p>is <code>c(k)</code>, where <code>k</code> comes from <code class="reqn">UCL = mu + k\sigma, LCL = mu - k\sigma.</code></p>
</dd>
<dt>CUSUM scheme: </dt><dd><p>is <code>c(k, h, t)</code> where <code>k</code> is the reference value and <code>h</code> is the control limit,
and <code>t</code> is the type of the chart (1:positive, 2:negative, 3:two sides)</p>
</dd>
<dt>EWMA scheme: </dt><dd><p>is <code>c(lambda, L)</code>, where <code>lambda</code> is the smoothing constant
and <code>L</code> multiplies standard deviation to get the control limit</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getRL_+3A_calibrate">calibrate</code></td>
<td>
<p>logical. If <code>TRUE</code> the RL is limit to 10 times the target ARL.</p>
</td></tr>
<tr><td><code id="getRL_+3A_arl0">arl0</code></td>
<td>
<p>scalar. Expected value of the RL. Default <code>370</code>.</p>
</td></tr>
<tr><td><code id="getRL_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getRL_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getRL_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="getRL_+3A_isfixed">isFixed</code></td>
<td>
<p>logical. If <code>TRUE</code> the reference sample does not update, otherwise the reference sample is updated whenever the batch is in control.</p>
</td></tr>
<tr><td><code id="getRL_+3A_chi2corrector">Chi2corrector</code></td>
<td>
<p>character string. Only when scoring is Z-SQ. Select from
</p>

<ul>
<li><p>&quot;approx: Z^2*(m + 1 + 1.3)/(m+1).
</p>
</li>
<li><p>&quot;exact&quot;: Z^2/mean(Z).
</p>
</li>
<li><p>&quot;none&quot;: Z^2.
</p>
</li></ul>

<p>If &quot;approx&quot; () (default). If &quot;exact&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="getRL_+3A_rounding.factor">rounding.factor</code></td>
<td>
<p>scalar. positive value that determine the range between two consecutive rounded values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RL</code> vector. The run length of the chart for the parameter setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5 # subgroup size
m &lt;- 100 # reference-sample size
dist &lt;- "Normal"
mu &lt;- c(0, 0) # c(reference sample mean, monitoring sample mean)
sigma &lt;- c(1, 1) # c(reference sample sd, monitoring sample sd)

#### Distribution parameters
dist.par &lt;- c(0, 1, 1) # c(location, scale, shape)

#### Other Parameters
replicates &lt;- 2
print.RL &lt;- TRUE
calibrate &lt;- FALSE
progress &lt;- TRUE
arl0 &lt;- 370

#### Control chart parameters
chart &lt;- "Shewhart"
chart.par &lt;- c(3)
shewhart &lt;- getRL(1, n, m,
  theta = NULL, Ftheta = NULL,dist, mu, sigma, dist.par = dist.par,
  chart = chart, chart.par = chart.par, calibrate = calibrate, arl0 = arl0
)

chart &lt;- "CUSUM"
chart.par &lt;- c(0.25, 4.4181, 3)
cusum &lt;- getRL(1, n, m,
  theta = NULL, Ftheta = NULL, dist, mu, sigma, dist.par = dist.par,
  chart = chart, chart.par = chart.par, calibrate = calibrate, arl0 = arl0
)

chart &lt;- "EWMA"
chart.par &lt;- c(0.2, 2.962)
shewhart &lt;- getRL(1, n, m,
  theta = NULL, Ftheta = NULL,dist, mu, sigma, dist.par = dist.par,
  chart = chart, chart.par = chart.par, calibrate = calibrate, arl0 = arl0
)
</code></pre>

<hr>
<h2 id='mcalibrateControlLimit'>Calibration of the control limit for the selected chart</h2><span id='topic+mcalibrateControlLimit'></span>

<h3>Description</h3>

<p>The methodology used to calibrate the control limit
for the SNS chart depending on the selected chart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcalibrateControlLimit(
  targetARL = NULL,
  targetMRL = NULL,
  n,
  m,
  nv,
  theta = NULL,
  Ftheta = NULL,
  dists = c("Normal", "Normal"),
  mu = c(0, 0),
  sigma = NULL,
  dists.par = matrix(c(0, 1, 1, 0, 1, 1), ncol = 2),
  correlation = 0,
  chart = "T2",
  chart.par = c(10),
  replicates = 50000,
  isParallel = FALSE,
  maxIter = 20,
  progress = TRUE,
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcalibrateControlLimit_+3A_targetarl">targetARL</code></td>
<td>
<p>scalar. is the target ARL to calibrate. By default is set to NULL</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_targetmrl">targetMRL</code></td>
<td>
<p>scalar. is the target ARL to calibrate. By default is set to NULL</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_n">n</code></td>
<td>
<p>scalar. Subroup size</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_m">m</code></td>
<td>
<p>scalar. Reference sample size</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_nv">nv</code></td>
<td>
<p>scalar. Number of variables to be generated.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_theta">theta</code></td>
<td>
<p>vector. Value corresponding with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_ftheta">Ftheta</code></td>
<td>
<p>vector. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_dists">dists</code></td>
<td>
<p>list.  Select the</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_mu">mu</code></td>
<td>
<p>vector. Two elements of the vector the first one is the mean of the reference sample and the second one is the mean of the monitoring sample.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_sigma">sigma</code></td>
<td>
<p>scalar. Standard deviation of the desired distribution.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_dists.par">dists.par</code></td>
<td>
<p>matrix  For each variable (column), specify
</p>

<ul>
<li><p><code>par.location</code>: Location parameter of the desired distribution. Default 0.
</p>
</li>
<li><p><code>par.scale</code>: Scale parameter of the desired distribution. Default 1.
</p>
</li>
<li><p><code>par.shape</code>: Shape parameter of the desired distribution, Default 1.
</p>
</li></ul>

<p>The number of columns must be the same as the number of variables.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_correlation">correlation</code></td>
<td>
<p>scalar. Corralation between variables.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_chart">chart</code></td>
<td>
<p>character string. Selected type of chart. One option available: <code>"T2"</code>.
</p>

<dl>
<dt>T2 scheme: </dt><dd><p>is <code>c(k)</code>, where <code>k</code> comes from <code class="reqn">UCL = mu + k\sigma, LCL = mu - k\sigma.</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_chart.par">chart.par</code></td>
<td>
<p>vector. Control limit and other parameters of the selected chart.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_replicates">replicates</code></td>
<td>
<p>scalar. Number of replicates to get the ARL</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_isparallel">isParallel</code></td>
<td>
<p>logical. If <code>TRUE</code> the code runs in parallel according to the
number of cores in the computer,otherwise the code runs sequentially. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_maxiter">maxIter</code></td>
<td>
<p>scalar. is a numeric. The maximum number of iteration to take the calibration before stops</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_progress">progress</code></td>
<td>
<p>logical. If <code>TRUE</code> it shows the progress in the console.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mcalibrateControlLimit_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>objective.function</code>: scalar. The best solution obtained, in terms of the target ARL or MRL
</p>
</li>
<li> <p><code>par.value</code>: scalar. Which parameter of the chart reach this best solution
</p>
</li>
<li> <p><code>found</code>: boolean. Is TRUE if in the <code>maxIter</code> is reached the desired +-5
</p>
</li></ul>



<h3>Note</h3>

<p>The argument <code>chart.par</code> in this function correspond to the initial parameters to start the calibration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5 # subgroup size
m &lt;- 10 # reference-sample size
dists &lt;- c("Normal", "Normal") # distribution
mu &lt;- c(0, 0) # c(reference sample mean, monitoring sample mean)
nv &lt;- 2 # number of variables
#### Other Parameters
replicates &lt;- 2
targetARL &lt;- 200
isParallel = FALSE
maxIter &lt;- 2
#### Control chart parameters
chart &lt;- "T2"
chart.par &lt;- c(0.005)
t2 &lt;- mcalibrateControlLimit(targetARL = targetARL,n = n, m = m, nv = nv, theta = NULL,
  Ftheta = NULL, dists = dists, mu = mu, chart.par = chart.par,
  replicates = replicates, chart = chart, isParallel = isParallel,
  maxIter = maxIter
)

</code></pre>

<hr>
<h2 id='mgetARL'>Multivariate Average Run Length (ARL)</h2><span id='topic+mgetARL'></span>

<h3>Description</h3>

<p>Get the ARL <code><a href="#topic+getRL">getRL</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgetARL(
  n,
  m,
  nv,
  theta = NULL,
  Ftheta = NULL,
  dists,
  dists.par = NULL,
  mu,
  sigma = NULL,
  chart = "T2",
  chart.par = c(0.005),
  correlation = 0,
  s = NULL,
  replicates = 10000,
  isParallel = TRUE,
  print.RL = FALSE,
  progress = FALSE,
  calibrate = FALSE,
  arl0 = 370,
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgetARL_+3A_n">n</code></td>
<td>
<p>scalar. Subroup size</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_m">m</code></td>
<td>
<p>scalar. Reference sample size</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_nv">nv</code></td>
<td>
<p>scalar. Number of variables to be generated.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_theta">theta</code></td>
<td>
<p>vector. Value corresponding with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_ftheta">Ftheta</code></td>
<td>
<p>vector. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_dists">dists</code></td>
<td>
<p>list.  Select the</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_dists.par">dists.par</code></td>
<td>
<p>matrix  For each variable (column), specify
</p>

<ul>
<li><p><code>par.location</code>: Location parameter of the desired distribution. Default 0.
</p>
</li>
<li><p><code>par.scale</code>: Scale parameter of the desired distribution. Default 1.
</p>
</li>
<li><p><code>par.shape</code>: Shape parameter of the desired distribution, Default 1.
</p>
</li></ul>

<p>The number of columns must be the same as the number of variables.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_mu">mu</code></td>
<td>
<p>vector. Two elements of the vector the first one is the mean of the reference sample and the second one is the mean of the monitoring sample.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_sigma">sigma</code></td>
<td>
<p>scalar. Standard deviation of the desired distribution.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_chart">chart</code></td>
<td>
<p>character string. Selected type of chart. One option available: <code>"T2"</code>.
</p>

<dl>
<dt>T2 scheme: </dt><dd><p>is <code>c(k)</code>, where <code>k</code> comes from <code class="reqn">UCL = mu + k\sigma, LCL = mu - k\sigma.</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgetARL_+3A_chart.par">chart.par</code></td>
<td>
<p>vector. Control limit and other parameters of the selected chart.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_correlation">correlation</code></td>
<td>
<p>scalar. Corralation between variables.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_s">s</code></td>
<td>
<p>matrix. Correlation matrix of the variables</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_replicates">replicates</code></td>
<td>
<p>scalar. Number of replicates to get the ARL</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_isparallel">isParallel</code></td>
<td>
<p>logical. If <code>TRUE</code> the code runs in parallel according to the
number of cores in the computer,otherwise the code runs sequentially. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_print.rl">print.RL</code></td>
<td>
<p>logical. If <code>TRUE</code> return the vectors of RL for each iteration.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_progress">progress</code></td>
<td>
<p>logical. If <code>TRUE</code> it shows the progress in the console.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_calibrate">calibrate</code></td>
<td>
<p>logical. If <code>TRUE</code> the RL is limit to 10 times the target ARL.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_arl0">arl0</code></td>
<td>
<p>scalar. Expected value of the RL. It is only used for stop the RL if exceeds 10 times its value. Default <code>370</code>.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mgetARL_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mgetARL_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>ARL</code>: scalar. Average Run Length for the <code>RL</code>s of all the <code>replicates</code>.
</p>
</li>
<li> <p><code>SDRL</code>: scalar. Standard Deviation Run Length for the <code>RL</code> in all the <code>replicates</code>.
</p>
</li>
<li> <p><code>MRL</code>: bolean. Median Run Length for the <code>RL</code>s of all the <code>replicates</code>.
</p>
</li>
<li> <p><code>QRL</code>: vector. It retrieve the quantiles (0.05, 0.1, 0.2, 0.25, 0.5, 0.75, 0.8, 0.9, 0.95) for all the <code>RL</code>s.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mgetARL(replicates=5,n=5,m=100,nv=2,mu=c(0,0),
dists = c("Normal", "Normal"), dists.par = matrix(c(0,1,1,0,1,1), ncol=2),
isParallel=FALSE)
</code></pre>

<hr>
<h2 id='mgetDist'>Multivariate Random Observations Generetor</h2><span id='topic+mgetDist'></span>

<h3>Description</h3>

<p>Multivariate Random observations generator selected from several distributions with user defined mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgetDist(
  n,
  nv,
  mu = 0,
  sigma = NULL,
  correlation = 0,
  s = NULL,
  dists = NULL,
  dists.par = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgetDist_+3A_n">n</code></td>
<td>
<p>scalar. Number of observations to be generated.</p>
</td></tr>
<tr><td><code id="mgetDist_+3A_nv">nv</code></td>
<td>
<p>scalar. Number of variables to be generated.</p>
</td></tr>
<tr><td><code id="mgetDist_+3A_mu">mu</code></td>
<td>
<p>scalar. Expected value of the desired distribution.</p>
</td></tr>
<tr><td><code id="mgetDist_+3A_sigma">sigma</code></td>
<td>
<p>scalar. Standard deviation of the desired distribution.</p>
</td></tr>
<tr><td><code id="mgetDist_+3A_correlation">correlation</code></td>
<td>
<p>scalar. Corralation between variables.</p>
</td></tr>
<tr><td><code id="mgetDist_+3A_s">s</code></td>
<td>
<p>matrix. Correlation matrix of the variables</p>
</td></tr>
<tr><td><code id="mgetDist_+3A_dists">dists</code></td>
<td>
<p>list.  Select the</p>
</td></tr>
<tr><td><code id="mgetDist_+3A_dists.par">dists.par</code></td>
<td>
<p>matrix  For each variable (column), specify
</p>

<ul>
<li><p><code>par.location</code>: Location parameter of the desired distribution. Default 0.
</p>
</li>
<li><p><code>par.scale</code>: Scale parameter of the desired distribution. Default 1.
</p>
</li>
<li><p><code>par.shape</code>: Shape parameter of the desired distribution, Default 1.
</p>
</li></ul>

<p>The number of columns must be the same as the number of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>x</code> with <code>n</code> observations generated following the selected distribution with its parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mgetDist(n=5, nv=2, dists=c("Normal", "Normal"),dists.par= matrix(c(0,1,1,0,1,1), ncol=2))
</code></pre>

<hr>
<h2 id='mgetRL'>Multivariate Run Length</h2><span id='topic+mgetRL'></span>

<h3>Description</h3>

<p>Get the run length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgetRL(
  replica = 1,
  n,
  m,
  nv,
  theta = NULL,
  Ftheta = NULL,
  dists,
  mu,
  sigma = NULL,
  dists.par = NULL,
  correlation = 0,
  s = NULL,
  chart = "T2",
  chart.par = c(0.005),
  null.dist = "Chi",
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE,
  calibrate = FALSE,
  arl0 = 370
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgetRL_+3A_replica">replica</code></td>
<td>
<p>scalar. It is used for the parallel version of the function (<code>parallel=TRUE</code>). Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_n">n</code></td>
<td>
<p>scalar. Subroup size</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_m">m</code></td>
<td>
<p>scalar. Reference sample size</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_nv">nv</code></td>
<td>
<p>scalar. Number of variables to be generated.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_theta">theta</code></td>
<td>
<p>vector. Value corresponding with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_ftheta">Ftheta</code></td>
<td>
<p>vector. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_dists">dists</code></td>
<td>
<p>list.  Select the</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_mu">mu</code></td>
<td>
<p>vector. Two elements of the vector the first one is the mean of the reference sample and the second one is the mean of the monitoring sample.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_sigma">sigma</code></td>
<td>
<p>scalar. Standard deviation of the desired distribution.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_dists.par">dists.par</code></td>
<td>
<p>matrix  For each variable (column), specify
</p>

<ul>
<li><p><code>par.location</code>: Location parameter of the desired distribution. Default 0.
</p>
</li>
<li><p><code>par.scale</code>: Scale parameter of the desired distribution. Default 1.
</p>
</li>
<li><p><code>par.shape</code>: Shape parameter of the desired distribution, Default 1.
</p>
</li></ul>

<p>The number of columns must be the same as the number of variables.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_correlation">correlation</code></td>
<td>
<p>scalar. Corralation between variables.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_s">s</code></td>
<td>
<p>matrix. Correlation matrix of the variables</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_chart">chart</code></td>
<td>
<p>character string. Selected type of chart. One option available: <code>"T2"</code>.
</p>

<dl>
<dt>T2 scheme: </dt><dd><p>is <code>c(k)</code>, where <code>k</code> comes from <code class="reqn">UCL = mu + k\sigma, LCL = mu - k\sigma.</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgetRL_+3A_chart.par">chart.par</code></td>
<td>
<p>vector. Control limit and other parameters of the selected chart.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_null.dist">null.dist</code></td>
<td>
<p>character string. It is the null distribution choose from <code>"Chi"</code> or <code>"F"</code>.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mgetRL_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_calibrate">calibrate</code></td>
<td>
<p>logical. If <code>TRUE</code> the RL is limit to 10 times the target ARL.</p>
</td></tr>
<tr><td><code id="mgetRL_+3A_arl0">arl0</code></td>
<td>
<p>scalar. Expected value of the RL. It is only used for stop the RL if exceeds 10 times its value. Default <code>370</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RL</code> vector. The run length of the chart for the parameter setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mgetRL(n=5, m=10, nv=2, mu=c(0,0), dists = c("Normal", "Normal"),
dists.par = matrix(c(0,1,1,0,1,1), ncol=2))
</code></pre>

<hr>
<h2 id='MNS'>Multivariate Normal Scores</h2><span id='topic+MNS'></span>

<h3>Description</h3>

<p>Get conditional or unconditional multivariate normal score (NS) of observations (<code>X</code>)
relative to previous observations (<code>Y</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MNS(
  X,
  Y = NULL,
  theta = NULL,
  Ftheta = NULL,
  scoring = "Z",
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MNS_+3A_x">X</code></td>
<td>
<p>matrix or data.frame. New observations to obtain the normal scores.</p>
</td></tr>
<tr><td><code id="MNS_+3A_y">Y</code></td>
<td>
<p>matrix or data.frame. If <code>Y</code> is not defined (no previous observation available, <code>NULL</code>), NS is relative to <code>X</code>. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="MNS_+3A_theta">theta</code></td>
<td>
<p>vector. Value corresponding with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="MNS_+3A_ftheta">Ftheta</code></td>
<td>
<p>vector. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="MNS_+3A_scoring">scoring</code></td>
<td>
<p>character string. If &quot;Z&quot; (normal scores) (default). If &quot;Z-SQ&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="MNS_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MNS_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="MNS_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>R</code>: matrix. Multivariate Ranks for the <code>X</code> observations. If ties occurs, average ranks are used.
</p>
</li>
<li> <p><code>P</code>: matrix. Multivariate Probability of the ranks for the <code>X</code> observations. Instead of Van Der Waerden normal scores where <code class="reqn">P = R/(n+1)</code>, <code class="reqn">P = (R-0.5)/n</code>,
where <code class="reqn">R</code> stands for rank and <code class="reqn">P</code> for the input evaluated in the inverse of a Standard Normal Distribution.
</p>
</li>
<li> <p><code>Z</code>: matrix. Multivariate Normal scores for the <code>X</code> observations. <code class="reqn">Z</code> if <code>scoring</code> is &quot;Z&quot; and <code class="reqn">Z^2</code> if <code>scoring</code> is &quot;Z-SQ&quot;.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
Y = matrix(Y, ncol=2)
X &lt;- c(30, 35, 45, 30, 35, 45)
X = matrix(X, ncol=2)
theta &lt;- c(40, 40)
Ftheta &lt;- c(0.5, 0.5)
# EXAMPLE CONDITIONAL
MNS(X = X, Y = Y, theta = theta, Ftheta = Ftheta)
</code></pre>

<hr>
<h2 id='MSNS'>Multivariate Sequential Normal Scores</h2><span id='topic+MSNS'></span>

<h3>Description</h3>

<p>Transform a matrix <code>X</code> into SNS using initial observations <code>Y</code> if available
SNS follow the order of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSNS(
  X,
  X.id,
  Y = NULL,
  theta = NULL,
  Ftheta = NULL,
  scoring = "Z",
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE,
  chart = "T2",
  chart.par = c(0.005),
  null.dist = "Chi",
  isFixed = FALSE,
  omit.id = NULL,
  auto.omit.alarm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSNS_+3A_x">X</code></td>
<td>
<p>matrix or data.frame. New observations to obtain the normal scores.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_x.id">X.id</code></td>
<td>
<p>vector. The id of each column (variable) of the matrix <code>X</code>.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_y">Y</code></td>
<td>
<p>matrix or data.frame. If <code>Y</code> is not defined (no previous observation available, <code>NULL</code>), NS is relative to <code>X</code>. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_theta">theta</code></td>
<td>
<p>vector. Value corresponding with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_ftheta">Ftheta</code></td>
<td>
<p>vector. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="MSNS_+3A_scoring">scoring</code></td>
<td>
<p>character string. If &quot;Z&quot; (normal scores) (default). If &quot;Z-SQ&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="MSNS_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MSNS_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="MSNS_+3A_chart">chart</code></td>
<td>
<p>character string. Selected type of chart. One option available: <code>"T2"</code>.
</p>

<dl>
<dt>T2 scheme: </dt><dd><p>is <code>c(k)</code>, where <code>k</code> comes from <code class="reqn">UCL = mu + k\sigma, LCL = mu - k\sigma.</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="MSNS_+3A_chart.par">chart.par</code></td>
<td>
<p>vector. Control limit and other parameters of the selected chart.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_null.dist">null.dist</code></td>
<td>
<p>character string. It is the null distribution choose from <code>"Chi"</code> or <code>"F"</code>.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_isfixed">isFixed</code></td>
<td>
<p>logical. If <code>TRUE</code> the reference sample does not update, otherwise the reference sample is updated when the batch is in control.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_omit.id">omit.id</code></td>
<td>
<p>vector. Elements of the vector are the id which are omitted in the analysis.</p>
</td></tr>
<tr><td><code id="MSNS_+3A_auto.omit.alarm">auto.omit.alarm</code></td>
<td>
<p>logical. Determine if OC signals are added (or not) to reference sample. By default is set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>coefficients</code>: list. Two elements: <code>n</code> the number of observation per group in <code>X</code> and <code>chart</code> the selected chart to perform the analysis.
</p>
</li>
<li> <p><code>X</code>: vector. New observations (Monitoring sample) to obtain the SNS.
</p>
</li>
<li> <p><code>Z</code>: vector. SNS of the <code>X</code> monitoring sample.
</p>
</li>
<li> <p><code>T2</code>: vector. T2 statistic for each of the groups in <code>X</code>.
</p>
</li>
<li> <p><code>X.id</code>: vector. The id of each column (variable) of the matrix <code>X</code>.
</p>
</li>
<li> <p><code>UCL</code>: vector. Upper control limit for each group in <code>X</code>.
</p>
</li></ul>



<h3>Comments</h3>

<p>If ties, average ranks are used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MNS">MNS</a></code> for multivariate normal scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = cbind(example91$X1, example91$X2)
X.id = example91$X.id
msns = MSNS(X, X.id)
</code></pre>

<hr>
<h2 id='NS'>Normal Scores</h2><span id='topic+NS'></span>

<h3>Description</h3>

<p>Get conditional or unconditional normal score (NS) of observations (<code>X</code>)
relative to previous observations (<code>Y</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NS(
  X,
  Y = NULL,
  theta = NULL,
  Ftheta = NULL,
  scoring = "Z",
  Chi2corrector = "None",
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NS_+3A_x">X</code></td>
<td>
<p>vector. New observations to obtain the Nnormal scores.</p>
</td></tr>
<tr><td><code id="NS_+3A_y">Y</code></td>
<td>
<p>vector. If <code>Y</code> is not defined (no previous observation available, <code>NULL</code>), NS is relative to <code>X</code>. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="NS_+3A_theta">theta</code></td>
<td>
<p>scalar. Value corresponig with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="NS_+3A_ftheta">Ftheta</code></td>
<td>
<p>scalar. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="NS_+3A_scoring">scoring</code></td>
<td>
<p>character string. If &quot;Z&quot; (normal scores) (default). If &quot;Z-SQ&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="NS_+3A_chi2corrector">Chi2corrector</code></td>
<td>
<p>character string. Only when scoring is Z-SQ. Select from
</p>

<ul>
<li><p>&quot;approx: Z^2*(m + 1 + 1.3)/(m+1).
</p>
</li>
<li><p>&quot;exact&quot;: Z^2/mean(Z).
</p>
</li>
<li><p>&quot;none&quot;: Z^2.
</p>
</li></ul>

<p>If &quot;approx&quot; () (default). If &quot;exact&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="NS_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="NS_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="NS_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>R</code>: vector. Ranks for the <code>X</code> observations. If ties occurs, average ranks are used.
</p>
</li>
<li> <p><code>P</code>: vector. Probability of the ranks for the <code>X</code> observations. Instead of Van Der Waerden normal scores where <code class="reqn">P = R/(n+1)</code>, <code class="reqn">P = (R-0.5)/n</code>,
where <code class="reqn">R</code> stands for rank and <code class="reqn">P</code> for the input evaluated in the inverse of a Standard Normal Distribution.
</p>
</li>
<li> <p><code>Z</code>: vector. Normal scores for the <code>X</code> observations. <code class="reqn">Z</code> if <code>scoring</code> is &quot;Z&quot; and <code class="reqn">Z^2</code> if <code>scoring</code> is &quot;Z-SQ&quot;.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
X &lt;- c(30, 35, 45)
theta &lt;- 40
Ftheta &lt;- 0.5
# EXAMPLE CONDITIONAL
NS(X = X, Y = Y, theta = theta, Ftheta = Ftheta)

# EXAMPLE UNCONDITIONAL
theta &lt;- NULL
Ftheta &lt;- NULL
NS(X = X, Y = Y, theta = theta, Ftheta = Ftheta)
</code></pre>

<hr>
<h2 id='SNS'>Sequential Normal Scores</h2><span id='topic+SNS'></span>

<h3>Description</h3>

<p>Transform a vector <code>X</code> into SNS using initial observations <code>Y</code> if available
SNS follow the order of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SNS(
  X,
  X.id,
  Y = NULL,
  theta = NULL,
  Ftheta = NULL,
  scoring = "Z",
  Chi2corrector = "None",
  alignment = "unadjusted",
  constant = NULL,
  absolute = FALSE,
  chart = "Shewhart",
  chart.par = c(3),
  snsRaw = FALSE,
  isFixed = FALSE,
  omit.id = NULL,
  auto.omit.alarm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNS_+3A_x">X</code></td>
<td>
<p>vector. New observations to obtain the Nnormal scores.</p>
</td></tr>
<tr><td><code id="SNS_+3A_x.id">X.id</code></td>
<td>
<p>vector. The id of the vector <code>X</code>.</p>
</td></tr>
<tr><td><code id="SNS_+3A_y">Y</code></td>
<td>
<p>vector. If <code>Y</code> is not defined (no previous observation available, <code>NULL</code>), NS is relative to <code>X</code>. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SNS_+3A_theta">theta</code></td>
<td>
<p>scalar. Value corresponig with the <code>Ftheta</code> quantile.</p>
</td></tr>
<tr><td><code id="SNS_+3A_ftheta">Ftheta</code></td>
<td>
<p>scalar. Quantile of the data distribution. The values that take are between (0,1).</p>
</td></tr>
<tr><td><code id="SNS_+3A_scoring">scoring</code></td>
<td>
<p>character string. If &quot;Z&quot; (normal scores) (default). If &quot;Z-SQ&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="SNS_+3A_chi2corrector">Chi2corrector</code></td>
<td>
<p>character string. Only when scoring is Z-SQ. Select from
</p>

<ul>
<li><p>&quot;approx: Z^2*(m + 1 + 1.3)/(m+1).
</p>
</li>
<li><p>&quot;exact&quot;: Z^2/mean(Z).
</p>
</li>
<li><p>&quot;none&quot;: Z^2.
</p>
</li></ul>

<p>If &quot;approx&quot; () (default). If &quot;exact&quot; (normal scores squared).</p>
</td></tr>
<tr><td><code id="SNS_+3A_alignment">alignment</code></td>
<td>
<p>character string. Aligment of the data <code>X</code> and <code>Y</code>. Select from
</p>

<ul>
<li><p> &quot;unadjusted&quot;: nothing is sustracte from <code>X</code> and <code>Y</code> (default).
</p>
</li>
<li><p> &quot;overallmean&quot;: overall mean is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;overallmedian&quot;: overall median is sustracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;samplemean&quot;: mean from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;samplemedian&quot;: median from corresponding group (<code>X</code> and <code>Y</code>) is sustracted from its corresponing vector.
</p>
</li>
<li><p> &quot;referencemean&quot;: mean from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;referencemedian&quot;: median from <code>Y</code> is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li>
<li><p> &quot;constantvalue&quot;: a constant value is subtracted from <code>X</code> and <code>Y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SNS_+3A_constant">constant</code></td>
<td>
<p>scalar. Only used when the <code>alignment</code> is selected &quot;constantvalue&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SNS_+3A_absolute">absolute</code></td>
<td>
<p>logical. If <code>TRUE</code>, the absolute aligned values are obtained. (Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="SNS_+3A_chart">chart</code></td>
<td>
<p>character string. Selected type of chart. Three options are available: Shewhart, CUSUM, EWMA</p>
</td></tr>
<tr><td><code id="SNS_+3A_chart.par">chart.par</code></td>
<td>
<p>vector. The size depends on the selected chart:
</p>

<dl>
<dt>Shewhart scheme: </dt><dd><p>is <code>c(k)</code>, where <code>k</code> comes from <code class="reqn">UCL = mu + k\sigma, LCL = mu - k\sigma.</code></p>
</dd>
<dt>CUSUM scheme: </dt><dd><p>is <code>c(k, h, t)</code> where <code>k</code> is the reference value and <code>h</code> is the control limit,
and <code>t</code> is the type of the chart (1:positive, 2:negative, 3:two sides)</p>
</dd>
<dt>EWMA scheme: </dt><dd><p>is <code>c(lambda, L)</code>, where <code>lambda</code> is the smoothing constant
and <code>L</code> multiplies standard deviation to get the control limit</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="SNS_+3A_snsraw">snsRaw</code></td>
<td>
<p>logical. If <code>TRUE</code> return also the sns for each observation in vector <code>X</code>.</p>
</td></tr>
<tr><td><code id="SNS_+3A_isfixed">isFixed</code></td>
<td>
<p>logical. If <code>TRUE</code> the reference sample does not update, otherwise the reference sample is updated whenever the batch is in control.</p>
</td></tr>
<tr><td><code id="SNS_+3A_omit.id">omit.id</code></td>
<td>
<p>vector. Elements of the vector are the id which are omitted in the analysis.</p>
</td></tr>
<tr><td><code id="SNS_+3A_auto.omit.alarm">auto.omit.alarm</code></td>
<td>
<p>logical. Determine if OC signals are added (or not) to reference sample. By default is set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple output. Select by <code>output$</code>
</p>

<ul>
<li> <p><code>coefficients</code>: list. Three elements: <code>n</code> the number of observation per group in <code>X</code>, <code>chart</code> the selected chart to perform the analysis, and <code>chart.par</code> the parameters of the selected chart.
</p>
</li>
<li> <p><code>R</code>: vector. Ranks for the new observations (Monitoring sample).
</p>
</li>
<li> <p><code>X</code>: vector. New observations (Monitoring sample) to obtain the SNS.
</p>
</li>
<li> <p><code>Z</code>: vector. SNS of the <code>X</code> monitoring sample.
</p>
</li>
<li> <p><code>X.id</code>: vector. The id of each column (variable) of the matrix <code>X</code>.
</p>
</li>
<li> <p><code>UCL</code>: vector. Upper control limit for each group in <code>X</code>.
</p>
</li>
<li> <p><code>LCL</code>: vector. Lower control limit for each group in <code>X</code>.
</p>
</li>
<li> <p><code>scoring</code>: string. Selected score to evaluate SNS.
</p>
</li></ul>



<h3>Comments</h3>

<p>If ties occur, average ranks are used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NS">NS</a></code> for normal scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE CONDITIONAL WITH REFERENCE SAMPLE
Y &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
X &lt;- c(30, 35, 45)
theta &lt;- 40
Ftheta &lt;- 0.5
sample.id &lt;- c("a", "b", "c")
SNS(X = X, X.id = sample.id, Y = Y, theta = theta, Ftheta = Ftheta)

# EXAMPLE CONDITIONAL WITH REFERENCE SAMPLE
Y &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
X &lt;- c(30, 35, 45)
theta &lt;- 40
Ftheta &lt;- 0.5
sample.id &lt;- c("a", "b", "c")
SNS(X = X, X.id = sample.id, Y = Y, theta = theta, Ftheta = Ftheta)

# EXAMPLE UNCONDITIONAL WITH REFERENCE SAMPLE
Y &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
X &lt;- c(30, 35, 45)
theta &lt;- NULL
Ftheta &lt;- NULL
sample.id &lt;- c("a", "b", "c")
SNS(X = X, X.id = sample.id, Y = Y, theta = theta, Ftheta = Ftheta)

# EXAMPLE CONDITIONAL WITHOUT REFERENCE SAMPLE
Y &lt;- NULL # c(10,20,30,40,50,60,70,80,90,100)
X &lt;- c(30, 35, 45)
theta &lt;- 40
Ftheta &lt;- 0.5
sample.id &lt;- c("a", "b", "c")
SNS(X = X, X.id = sample.id, Y = Y, theta = theta, Ftheta = Ftheta)

# EXAMPLE UNCONDITIONAL WITHOUT REFERENCE SAMPLE
Y &lt;- NULL
X &lt;- c(30, 35, 45)
theta &lt;- NULL
Ftheta &lt;- NULL
sample.id &lt;- c("a", "b", "c")
SNS(X = X, X.id = sample.id, Y = Y, theta = theta, Ftheta = Ftheta)
</code></pre>

<hr>
<h2 id='srank'>Sequential Rank</h2><span id='topic+srank'></span>

<h3>Description</h3>

<p>Get the sequential rank of observations (<code>X</code>)
relative to previous observations (<code>Y</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srank(X, Y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srank_+3A_x">X</code></td>
<td>
<p>vector. New observations to obtain the Nnormal scores.</p>
</td></tr>
<tr><td><code id="srank_+3A_y">Y</code></td>
<td>
<p>vector. If <code>Y</code> is not defined (no previous observation available, <code>NULL</code>), NS is relative to <code>X</code>. Default <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector. Sequentil Ranks for the <code>X</code> observations. If ties occurs, average of the ranks are used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(30, 35, 45)
srank(X)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
