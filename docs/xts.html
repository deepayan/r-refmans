<!DOCTYPE html><html><head><title>Help for package xts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#xts-package'>
<p>xts: extensible time-series</p></a></li>
<li><a href='#.parseISO8601'>
<p>Internal ISO 8601:2004(e) Time Parser</p></a></li>
<li><a href='#+5B.xts'>
<p>Extract Subsets of xts Objects</p></a></li>
<li><a href='#addEventLines'><p>Add vertical lines to an existing xts plot</p></a></li>
<li><a href='#addLegend'><p>Add Legend</p></a></li>
<li><a href='#addPanel'><p>Add a panel to an existing xts plot</p></a></li>
<li><a href='#addPolygon'><p>Add a polygon to an existing xts plot</p></a></li>
<li><a href='#addSeries'><p>Add a time series to an existing xts plot</p></a></li>
<li><a href='#align.time'>
<p>Align seconds, minutes, and hours to beginning of next period.</p></a></li>
<li><a href='#apply.monthly'><p> Apply Function over Calendar Periods</p></a></li>
<li><a href='#as.environment.xts'><p> Coerce an &lsquo;xts&rsquo; Object to an Environment by Column</p></a></li>
<li><a href='#as.xts'><p> Convert Object To And From Class xts</p></a></li>
<li><a href='#as.xts.methods'><p> Convert Object To And From Class xts</p></a></li>
<li><a href='#axTicksByTime'><p> Compute x-Axis Tickmark Locations by Time</p></a></li>
<li><a href='#CLASS'><p> Extract and Set .CLASS Attribute</p></a></li>
<li><a href='#coredata.xts'><p> Extract/Replace Core Data of an xts Object</p></a></li>
<li><a href='#diff.xts'><p> Lags and Differences of xts Objects</p></a></li>
<li><a href='#dimnames.xts'><p> Dimnames of an xts Object</p></a></li>
<li><a href='#endpoints'><p> Locate Endpoints by Time</p></a></li>
<li><a href='#first'><p> Return First or Last n Elements of A Data Object</p></a></li>
<li><a href='#firstof'><p> Create a POSIXct Object</p></a></li>
<li><a href='#index.xts'><p> Get and Replace the Class of an xts Index</p></a></li>
<li><a href='#isOrdered'><p> Check If A Vector Is Ordered</p></a></li>
<li><a href='#make.index.unique'>
<p>Force Time Values To Be Unique</p></a></li>
<li><a href='#merge.xts'><p> Merge xts Objects</p></a></li>
<li><a href='#na.locf.xts'>
<p>Last Observation Carried Forward</p></a></li>
<li><a href='#ndays'><p> Number of Periods in Data</p></a></li>
<li><a href='#period.apply'><p> Apply Function Over Specified Interval</p></a></li>
<li><a href='#period.max'><p> Calculate Max By Period</p></a></li>
<li><a href='#period.min'><p> Calculate Min By Period</p></a></li>
<li><a href='#period.prod'><p> Calculate Product By Period</p></a></li>
<li><a href='#period.sum'><p> Calculate Sum By Period</p></a></li>
<li><a href='#periodicity'><p> Approximate Series Periodicity</p></a></li>
<li><a href='#plot.xts'><p>Plotting xts Objects</p></a></li>
<li><a href='#print.xts'><p> Print An xts Time-Series Object</p></a></li>
<li><a href='#rbind.xts'><p> Concatenate Two or More xts Objects by Row</p></a></li>
<li><a href='#sample_matrix'><p> Sample Data Matrix For xts Example and Unit Testing</p></a></li>
<li><a href='#split.xts'>
<p>Divide into Groups by Time</p></a></li>
<li><a href='#tclass'><p> Get or Replace the Class of an xts Object's Index</p></a></li>
<li><a href='#tformat'><p> Get or Replace the Format of an xts Object's Index</p></a></li>
<li><a href='#timeBased'><p> Check if Class is Time-Based</p></a></li>
<li><a href='#timeBasedSeq'><p> Create a Sequence or Range of Times</p></a></li>
<li><a href='#to.period'><p> Convert time series data to an OHLC series</p></a></li>
<li><a href='#tzone'><p> Get or Replace the Timezone of an xts Object's Index</p></a></li>
<li><a href='#window.xts'><p>Extract time windows from an <code>xts</code> series</p></a></li>
<li><a href='#xts'><p> Create Or Test For An xts Time-Series Object</p></a></li>
<li><a href='#xtsAPI'><p> xts C API Documentation</p></a></li>
<li><a href='#xtsAttributes'><p> Extract and Replace xts Attributes</p></a></li>
<li><a href='#xtsInternals'><p> Internal Documentation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>eXtensible Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.13.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), zoo (&ge; 1.7-12)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>timeSeries, timeDate, tseries, chron, tinytest</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide for uniform handling of R's different time-based data classes by extending zoo, maximizing native format information preservation and allowing for user level customization and extension, while simplifying cross-class interoperability.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://joshuaulrich.github.io/xts/">https://joshuaulrich.github.io/xts/</a>,
<a href="https://github.com/joshuaulrich/xts">https://github.com/joshuaulrich/xts</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/joshuaulrich/xts/issues">https://github.com/joshuaulrich/xts/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-19 19:31:01 UTC; josh</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey A. Ryan [aut, cph],
  Joshua M. Ulrich [cre, aut],
  Ross Bennett [ctb],
  Corwin Joy [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua M. Ulrich &lt;josh.m.ulrich@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='xts-package'>
xts: extensible time-series
</h2><span id='topic+xts-package'></span>

<h3>Description</h3>

<p>Extensible time series class and methods, extending and behaving
like zoo.
</p>


<h3>Details</h3>

<p>Easily convert one of <span class="rlang"><b>R</b></span>'s many time-series (and non-time-series)
classes to a true time-based object which inherits all of zoo's
methods, while allowing for new time-based tools where appropriate.
</p>
<p>Additionally, one may use <span class="pkg">xts</span> to create new objects which
can contain arbitrary attributes named during creation as name=value
pairs.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan and Joshua M. Ulrich
</p>
<p>Maintainer: Joshua M. Ulrich &lt;josh.m.ulrich@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xts">xts</a></code>
<code><a href="#topic+as.xts">as.xts</a></code>
<code><a href="#topic+reclass">reclass</a></code>
<code><a href="zoo.html#topic+zoo">zoo</a></code>
</p>

<hr>
<h2 id='.parseISO8601'>
Internal ISO 8601:2004(e) Time Parser
</h2><span id='topic+ISO8601'></span><span id='topic+parseISO8601'></span><span id='topic+makeISO8601'></span><span id='topic+.parseISO8601'></span><span id='topic+.makeISO8601'></span>

<h3>Description</h3>

<p>This function is used internally in the subsetting
mechanism of xts.  The function is unexported, though
documented for use with xts subsetting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parseISO8601(x, start, end, tz="")

.makeISO8601(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".parseISO8601_+3A_x">x</code></td>
<td>

<p>For .parseISO8601(x), a character string conforming 
to the ISO 8601:2004(e) rules. For .makeISO8601(x), <code>x</code>
should be a time-like object with
<code>start</code> and <code>end</code> methods.
</p>
</td></tr>
<tr><td><code id=".parseISO8601_+3A_start">start</code></td>
<td>

<p>lower constraint on range
</p>
</td></tr>
<tr><td><code id=".parseISO8601_+3A_end">end</code></td>
<td>

<p>upper constraint of range
</p>
</td></tr>
<tr><td><code id=".parseISO8601_+3A_tz">tz</code></td>
<td>

<p>timezone (tzone) to use internally
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replicates most of the ISO 
standard for expressing time and time-based
ranges in a universally accepted way.
</p>
<p>The best documentation is now the official
ISO page as well as the Wikipedia entry for
ISO 8601:2004.
</p>
<p>The basic idea is to create
the endpoints of a range, given a string
representation. These endpoints are aligned
in POSIXct time to the zero second of the day
at the beginning, and the 59.9999th second of the 59th
minute of the 23rd hour of the final day.
</p>
<p>For dates prior to the epoch (1970-01-01) the
ending time is aligned to the 59.0000 second. This
is due to a bug/feature in the <span class="rlang"><b>R</b></span> implementation of
asPOSIXct and mktime0 at the C-source level. This limits
the precision of ranges prior to 1970 to 1 minute
granularity with the current <span class="pkg">xts</span> workaround.
</p>
<p>Recurring times over multiple days may be specified
using the T notation. See the examples for details.
</p>


<h3>Value</h3>

<p>A list of length two, with an entry
named &lsquo;first.time&rsquo; and one
names &lsquo;last.time&rsquo;.
</p>
<p>For .makeISO8601, a character vector of length
one describing the ISO-style format for a given
time-based object.
</p>


<h3>Note</h3>

<p>There is no checking done to test for a properly constructed
ISO format string.  This must be correctly entered by the user, lest
bad things may happen.
</p>
<p>When using durations, it is important to note that the
time of the duration specified is not necessarily the
same as the realized periods that may be returned when
applied to an irregular time series.  This is not a bug,
rather it is a standards and implementation gotcha.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/ISO_8601">https://en.wikipedia.org/wiki/ISO_8601</a><br />
<a href="https://www.iso.org/iso-8601-date-and-time-format.html">https://www.iso.org/iso-8601-date-and-time-format.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the start and end of 2000
.parseISO8601('2000')

# the start of 2000 and end of 2001
.parseISO8601('2000/2001')

# May 1, 2000 to Dec 31, 2001
.parseISO8601('2000-05/2001')

# May 1, 2000 to end of Feb 2001
.parseISO8601('2000-05/2001-02')

# Jan 1, 2000 to Feb 29, 2000; note the truncated time on the LHS
.parseISO8601('2000-01/02')

# 8:30 to 15:00 (used in xts subsetting to extract recurring times)
.parseISO8601('T08:30/T15:00')
</code></pre>

<hr>
<h2 id='+5B.xts'>
Extract Subsets of xts Objects
</h2><span id='topic++5B.xts'></span><span id='topic+subset.xts'></span><span id='topic+.subset.xts'></span><span id='topic+.subset_xts'></span>

<h3>Description</h3>

<p>Details on efficient subsetting of <code>xts</code> objects
for maximum performance and compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
x[i, j, drop = FALSE, which.i=FALSE, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.xts_+3A_x">x</code></td>
<td>

<p>xts object
</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_i">i</code></td>
<td>

<p>the rows to extract. Numeric, timeBased or ISO-8601 style (see details)
</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_j">j</code></td>
<td>

<p>the columns to extract, numeric or by name
</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_drop">drop</code></td>
<td>

<p>should dimension be dropped, if possible. See NOTE.
</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_which.i">which.i</code></td>
<td>

<p>return the &lsquo;i&rsquo; values used for subsetting. No
subset will be performed.
</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_...">...</code></td>
<td>

<p>additional arguments (unused)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the primary motivations, and key points of differentiation
of the time series class xts, is the ability to subset rows
by specifying ISO-8601 compatible range strings.  This allows
for natural range-based time queries without requiring prior
knowledge of the underlying time object used in construction.
</p>
<p>When a raw character vector is used for the <code>i</code>
subset argument, it is processed as if it was ISO-8601
compliant.  This means that it is parsed from left to
right, according to the following specification:
</p>
<p>CCYYMMDD HH:MM:SS.ss+
</p>
<p>A full description will be expanded from a left-specified
truncated one.
</p>
<p>Additionally, one may specify range-based queries
by simply supplying two time descriptions seperated
by a forward slash:
</p>
<p>CCYYMMDD HH:MM:SS.ss+/CCYYMMDD HH:MM:SS.ss
</p>
<p>The algorithm to parse the above is <code>.parseISO8601</code> from
the <span class="pkg">xts</span> package.
</p>
<p>ISO-style subsetting, given a range type query, makes use
of a custom binary search mechanism that allows for
very fast subsetting as no linear search though the index
is required.  ISO-style character vectors may be longer than
length one, allowing for multiple non-contiguous ranges
to be selected in one subsetting call.
</p>
<p>If a character <em>vector</em> representing time is used in place of 
numeric values, ISO-style queries, or timeBased
objects, the above parsing will be carried out on
each element of the i-vector.  This overhead can
be very costly. If the character approach is used when
no ISO range querying is needed, it is
recommended to wrap the &lsquo;i&rsquo; character vector with the <code>I()</code>
function call, to allow for more efficient internal processing.
Alternately converting character vectors to POSIXct objects will
provide the most performance efficiency.
</p>
<p>As <code>xts</code> uses POSIXct time representations
of all user-level index classes internally, the fastest
timeBased subsetting will always be from POSIXct objects,
regardless of the <code>tclass</code> of the original
object.  All non-POSIXct time classes
are converted to character first to preserve
consistent TZ behavior.
</p>


<h3>Value</h3>

<p>An extraction of the original xts object.  If <code>which.i</code>
is TRUE, the corresponding integer &lsquo;i&rsquo; values used to
subset will be returned.
</p>


<h3>Note</h3>

<p>By design, drop=FALSE in the default case.  This preserves the basic
underlying type of <code>matrix</code> and the <code>dim()</code> to be non-NULL.
This is different from both matrix and <code>zoo</code> behavior as <span class="rlang"><b>R</b></span>
uses <code>drop=TRUE</code>.  Explicitly passing <code>drop=TRUE</code> may
be required when performing certain matrix operations.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p>ISO 8601: Date elements and interchange formats -
Information interchange - Representation of dates and time
<a href="https://www.iso.org">https://www.iso.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xts">xts</a></code>,
<code><a href="#topic+.parseISO8601">.parseISO8601</a></code>,
<code><a href="#topic+.index">.index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xts(1:3, Sys.Date()+1:3)
xx &lt;- cbind(x,x)

# drop=FALSE for xts, differs from zoo and matrix
z &lt;- as.zoo(xx)
z/z[,1]

m &lt;- as.matrix(xx)
m/m[,1]

# this will fail with non-conformable arrays (both retain dim)
tryCatch(
  xx/x[,1], 
  error=function(e) print("need to set drop=TRUE")
)

# correct way
xx/xx[,1,drop=TRUE]

# or less efficiently
xx/drop(xx[,1])
# likewise
xx/coredata(xx)[,1]


x &lt;- xts(1:1000, as.Date("2000-01-01")+1:1000)
y &lt;- xts(1:1000, as.POSIXct(format(as.Date("2000-01-01")+1:1000)))

x.subset &lt;- index(x)[1:20]
x[x.subset] # by original index type
system.time(x[x.subset]) 
x[as.character(x.subset)] # by character string. Beware!
system.time(x[as.character(x.subset)]) # slow!
system.time(x[I(as.character(x.subset))]) # wrapped with I(), faster!

x['200001'] # January 2000
x['1999/2000'] # All of 2000 (note there is no need to use the exact start)
x['1999/200001'] # January 2000 

x['2000/200005'] # 2000-01 to 2000-05
x['2000/2000-04-01'] # through April 01, 2000
y['2000/2000-04-01'] # through April 01, 2000 (using POSIXct series)


### Time of day subsetting 

i &lt;- 0:60000
focal_date &lt;- as.numeric(as.POSIXct("2018-02-01", tz = "UTC"))
x &lt;- .xts(i, c(focal_date + i * 15), tz = "UTC", dimnames = list(NULL, "value"))

# Select all observations between 9am and 15:59:59.99999:
w1 &lt;- x["T09/T15"] # or x["T9/T15"]
head(w1)

# timestring is of the form THH:MM:SS.ss/THH:MM:SS.ss

# Select all observations between 13:00:00 and 13:59:59.9999 in two ways:
y1 &lt;- x["T13/T13"]
head(y1)

x[.indexhour(x) == 13]

# Select all observations between 9:30am and 30 seconds, and 4.10pm:
x["T09:30:30/T16:10"]

# It is possible to subset time of day overnight.
# e.g. This is useful for subsetting FX time series which trade 24 hours on week days

# Select all observations between 23:50 and 00:15 the following day, in the xts time zone
z &lt;- x["T23:50/T00:14"]
z["2018-02-10 12:00/"] # check the last day


# Select all observations between 7pm and 8.30am the following day:
z2 &lt;- x["T19:00/T08:29:59"]
head(z2); tail(z2)


</code></pre>

<hr>
<h2 id='addEventLines'>Add vertical lines to an existing xts plot</h2><span id='topic+addEventLines'></span>

<h3>Description</h3>

<p>Add vertical lines and labels to an existing xts plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEventLines(events, main = "", on = 0, lty = 1, lwd = 1, col = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addEventLines_+3A_events">events</code></td>
<td>
<p>xts object of events and their associated labels. It is assumed
that the first column of <code>events</code> is the event description/label.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_main">main</code></td>
<td>
<p>main title for a new panel if drawn.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_on">on</code></td>
<td>
<p>panel number to draw on. A new panel will be drawn if <code>on=NA</code>.
The default, <code>on=0</code>, will add to the active panel. The active panel is 
defined as the panel on which the most recent action was performed. Note that
only the first element of <code>on</code> is checked for the default behavior to
add to the last active panel.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_lty">lty</code></td>
<td>
<p>set the line type, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_lwd">lwd</code></td>
<td>
<p>set the line width, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_col">col</code></td>
<td>
<p>color palette to use, set by default to rational choices.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_...">...</code></td>
<td>
<p>any other passthrough parameters to <code><a href="graphics.html#topic+text">text</a></code> to
control how the event labels are drawn</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(xts)
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix)
events &lt;- xts(letters[1:3], 
              as.Date(c("2007-01-12", "2007-04-22", "2007-06-13")))
plot(sample.xts[,4])
addEventLines(events, srt=90, pos=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='addLegend'>Add Legend</h2><span id='topic+addLegend'></span>

<h3>Description</h3>

<p>Add Legend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLegend(legend.loc = "topright", legend.names = NULL, col = NULL,
  ncol = 1, on = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLegend_+3A_legend.loc">legend.loc</code></td>
<td>
<p>legend.loc places a legend into one of nine locations on
the chart: bottomright, bottom, bottomleft, left, topleft, top, topright,
right, or center.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_legend.names">legend.names</code></td>
<td>
<p>character vector of names for the legend. If <code>NULL</code>,
the column names of the current plot object are used.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_col">col</code></td>
<td>
<p>fill colors for the legend. If <code>NULL</code>,
the colorset of the current plot object data is used.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_ncol">ncol</code></td>
<td>
<p>number of columns for the legend</p>
</td></tr>
<tr><td><code id="addLegend_+3A_on">on</code></td>
<td>
<p>panel number to draw on. A new panel will be drawn if <code>on=NA</code>.
The default, <code>on=0</code>, will add to the active panel. The active panel is 
defined as the panel on which the most recent action was performed. Note that
only the first element of <code>on</code> is checked for the default behavior to
add to the last active panel.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_...">...</code></td>
<td>
<p>any other passthrough parameters to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='addPanel'>Add a panel to an existing xts plot</h2><span id='topic+addPanel'></span>

<h3>Description</h3>

<p>Apply a function to the data of an existing xts plot object and plot
the result. <code>FUN</code> should have arguments <code>x</code> or <code>R</code> for the  
data of the existing xts plot object to be passed to. All other additional
arguments for <code>FUN</code> are passed through ....
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPanel(FUN, main = "", on = NA, type = "l", col = NULL, lty = 1,
  lwd = 1, pch = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPanel_+3A_fun">FUN</code></td>
<td>
<p>an xts object to plot.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_main">main</code></td>
<td>
<p>main title for a new panel if drawn.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_on">on</code></td>
<td>
<p>panel number to draw on. A new panel will be drawn if <code>on=NA</code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_type">type</code></td>
<td>
<p>the type of plot to be drawn, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_col">col</code></td>
<td>
<p>color palette to use, set by default to rational choices.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_lty">lty</code></td>
<td>
<p>set the line type, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_lwd">lwd</code></td>
<td>
<p>set the line width, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_pch">pch</code></td>
<td>
<p>the type of plot to be drawn, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_...">...</code></td>
<td>
<p>additional named arguments passed through to <code>FUN</code> and 
any other graphical passthrough parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xts)
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix)

calcReturns &lt;- function(price, method = c("discrete", "log")){
  px &lt;- try.xts(price)
  method &lt;- match.arg(method)[1L]
  returns &lt;- switch(method,
    simple = ,
    discrete = px / lag(px) - 1,
    compound = ,
    log = diff(log(px)))
  reclass(returns, px)
}

# plot the Close
plot(sample.xts[,"Close"])
# calculate returns 
addPanel(calcReturns, method="discrete", type="h")
# Add simple moving average to panel 1
addPanel(rollmean, k=20, on=1)
addPanel(rollmean, k=40, col="blue", on=1)
</code></pre>

<hr>
<h2 id='addPolygon'>Add a polygon to an existing xts plot</h2><span id='topic+addPolygon'></span>

<h3>Description</h3>

<p>Draw a polygon on an existing xts plot by specifying a time series of y 
coordinates. The xts index is used for the x coordinates and the first two 
columns are the upper and lower y coordinates, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPolygon(x, y = NULL, main = "", on = NA, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPolygon_+3A_x">x</code></td>
<td>

<p>an xts object to plot. Must contain 2 columns for the upper and lower y
coordinates for the polygon. The first column is interpreted as the upper y
coordinates and the second column as the lower y coordinates.
</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_y">y</code></td>
<td>
<p>NULL, not used</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_main">main</code></td>
<td>
<p>main title for a new panel if drawn.</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_on">on</code></td>
<td>
<p>panel number to draw on. A new panel will be drawn if <code>on=NA</code>.</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_col">col</code></td>
<td>
<p>color palette to use, set by default to rational choices.</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_...">...</code></td>
<td>
<p>passthru parameters to <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett</p>


<h3>References</h3>

<p>Based on code by Dirk Eddelbuettel from <a href="http://dirk.eddelbuettel.com/blog/2011/01/16/">http://dirk.eddelbuettel.com/blog/2011/01/16/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(xts)
data(sample_matrix)
x &lt;- as.xts(sample_matrix)[,1]
ix &lt;- index(x["2007-02"])
shade &lt;- xts(matrix(rep(range(x), each = length(ix)), ncol = 2), ix)

plot(x)

# set on = -1 to draw the shaded region *behind* the main series
addPolygon(shade, on = -1, col = "lightgrey")

## End(Not run)
</code></pre>

<hr>
<h2 id='addSeries'>Add a time series to an existing xts plot</h2><span id='topic+addSeries'></span>

<h3>Description</h3>

<p>Add a time series to an existing xts plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSeries(x, main = "", on = NA, type = "l", col = NULL, lty = 1,
  lwd = 1, pch = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSeries_+3A_x">x</code></td>
<td>
<p>an xts object to plot.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_main">main</code></td>
<td>
<p>main title for a new panel if drawn.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_on">on</code></td>
<td>
<p>panel number to draw on. A new panel will be drawn if <code>on=NA</code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_type">type</code></td>
<td>
<p>the type of plot to be drawn, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_col">col</code></td>
<td>
<p>color palette to use, set by default to rational choices.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_lty">lty</code></td>
<td>
<p>set the line type, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_lwd">lwd</code></td>
<td>
<p>set the line width, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_pch">pch</code></td>
<td>
<p>the type of plot to be drawn, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_...">...</code></td>
<td>
<p>any other passthrough graphical parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='align.time'>
Align seconds, minutes, and hours to beginning of next period.
</h2><span id='topic+align.time'></span><span id='topic+align.time.xts'></span><span id='topic+adj.time'></span><span id='topic+shift.time'></span>

<h3>Description</h3>

<p>Change timestamps to the start of the next period, specified
in multiples of seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align.time(x, ...)

## S3 method for class 'xts'
align.time(x, n=60, ...)

shift.time(x, n=60, ...)

adj.time(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align.time_+3A_x">x</code></td>
<td>

<p>object to align
</p>
</td></tr>
<tr><td><code id="align.time_+3A_n">n</code></td>
<td>

<p>number of seconds to adjust by
</p>
</td></tr>
<tr><td><code id="align.time_+3A_...">...</code></td>
<td>

<p>additional arguments. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 generic. 
The result is to round up to the next
period determined by <code>n modulo x</code>.
</p>


<h3>Value</h3>

<p>A new object of class(x)
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan with input from Brian Peterson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+to.period">to.period</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Sys.time() + 1:1000

# every 10 seconds
align.time(x, 10)

# align to next whole minute
align.time(x, 60)

# align to next whole 10 min interval
align.time(x, 10 * 60)
</code></pre>

<hr>
<h2 id='apply.monthly'> Apply Function over Calendar Periods </h2><span id='topic+apply.daily'></span><span id='topic+apply.weekly'></span><span id='topic+apply.monthly'></span><span id='topic+apply.quarterly'></span><span id='topic+apply.yearly'></span>

<h3>Description</h3>

<p>Apply a specified function to each distinct period in a given
time series object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.daily(x, FUN, ...)
apply.weekly(x, FUN, ...)
apply.monthly(x, FUN, ...)
apply.quarterly(x, FUN, ...)
apply.yearly(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply.monthly_+3A_x">x</code></td>
<td>
<p> an time-series object coercible to xts </p>
</td></tr>
<tr><td><code id="apply.monthly_+3A_fun">FUN</code></td>
<td>
<p> an <span class="rlang"><b>R</b></span> function </p>
</td></tr>
<tr><td><code id="apply.monthly_+3A_...">...</code></td>
<td>
<p> additional arguments to FUN </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple mechanism to apply a function to non-overlapping
time periods, e.g. weekly, monthly, etc. Different from rolling
functions in that this will subset the data based on the specified
time period (implicit in the call), and return a vector of values
for each period in the original data.
</p>
<p>Essentially a wrapper to the <span class="pkg">xts</span> functions
<code>endpoints</code> and <code>period.apply</code>, mainly as
a convenience.
</p>


<h3>Value</h3>

<p>A vector of results produced by <code>FUN</code>, corresponding
to the appropriate periods.
</p>


<h3>Note</h3>

<p>When <code>FUN = mean</code> the results will contain one column for every column
in the input, which is different from other math functions (e.g. <code>median</code>,
<code>sum</code>, <code>prod</code>, <code>sd</code>, etc.).
</p>
<p><code>FUN = mean</code> works by column because the default method <code>stats::mean</code>
used to work by column for matrices and data.frames. R Core changed the
behavior of <code>mean</code> to always return one column in order to be consistent
with the other math functions. This broke some <span class="pkg">xts</span> dependencies and
<code>mean.xts</code> was created to maintain the original behavior.
</p>
<p>Using <code>FUN = mean</code> will print a message that describes this inconsistency.
To avoid the message and confusion, use <code>FUN = colMeans</code> to calculate
means by column and use <code>FUN = function(x) mean</code> to calculate one mean
for all the data. Set <code>options(xts.message.period.apply.mean = FALSE)</code>
to suppress this message.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+endpoints">endpoints</a></code>, <code><a href="#topic+period.apply">period.apply</a></code>,
<code><a href="#topic+to.monthly">to.monthly</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>xts.ts &lt;- xts(rnorm(231),as.Date(13514:13744,origin="1970-01-01"))

start(xts.ts)
end(xts.ts)

apply.monthly(xts.ts,colMeans)
apply.monthly(xts.ts,function(x) var(x))
</code></pre>

<hr>
<h2 id='as.environment.xts'> Coerce an &lsquo;xts&rsquo; Object to an Environment by Column </h2><span id='topic+as.environment.xts'></span>

<h3>Description</h3>

<p>Method to automatically convert an &lsquo;xts&rsquo; object to an environment
containing vectors representing each column of the original xts object. Each
objects will be named according to the column name it is exracted by.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
as.environment(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.environment.xts_+3A_x">x</code></td>
<td>
<p> an <code>xts</code> object </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An experimental tool to convert <code>xts</code> objects into environments
for simplifying use withing the standard R formula/data paradigm.
</p>


<h3>Value</h3>

<p>An <code>environment</code> containing <code>ncol(x)</code> vectors
extracted by column from <code>x</code>.  Note that environments
do not preserve (or have knowledge) of column position, a.k.a order.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xts(1:10, Sys.Date()+1:10)
colnames(x) &lt;- "X"
y &lt;- xts(1:10, Sys.Date()+1:10)
colnames(x) &lt;- "Y"
xy &lt;- cbind(x,y)
colnames(xy)
e &lt;- as.environment(xy)    # currently using xts-style positive k 
ls(xy)
ls.str(xy)
</code></pre>

<hr>
<h2 id='as.xts'> Convert Object To And From Class xts </h2><span id='topic+as.xts'></span><span id='topic+xtsible'></span><span id='topic+use.xts'></span><span id='topic+try.xts'></span><span id='topic+use.reclass'></span><span id='topic+Reclass'></span><span id='topic+reclass'></span>

<h3>Description</h3>

<p>Conversion functions to coerce data objects of
arbitrary classes to class <code>xts</code> and back, without
losing any attributes of the original format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.xts(x, ...)
xtsible(x)

Reclass(x)

try.xts(x, ..., error = TRUE)
reclass(x, match.to, error = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.xts_+3A_x">x</code></td>
<td>
<p> data object to convert. See details for supported types </p>
</td></tr>
<tr><td><code id="as.xts_+3A_match.to">match.to</code></td>
<td>
 <p><code>xts</code> object whose attributes will be passed to <code>x</code></p>
</td></tr>
<tr><td><code id="as.xts_+3A_error">error</code></td>
<td>
<p> error handling option. See Details. </p>
</td></tr>
<tr><td><code id="as.xts_+3A_...">...</code></td>
<td>
<p> additional parameters or attributes </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple and reliable way to convert many different
objects into a uniform format for use within <span class="rlang"><b>R</b></span>.
</p>
<p>It is possible with a call to <code>as.xts</code> to
convert objects of class <code>timeSeries</code>, <code>ts</code>, <code>irts</code>,
<code>matrix</code>, <code>data.frame</code>, and <code>zoo</code>.
</p>
<p><code>xtsible</code> safely checks whether an object can be converted to
an <code>xts</code> object; returning TRUE on success and FALSE
otherwise.
</p>
<p>The help file <code>as.xts.methods</code> lists all available
xts methods and arguments specific to each coercible type.
</p>
<p>Additional name=value pairs may be passed to the function
to be added to the new object. A special print.xts method
will assure that the attributes are hidden from view, but will
be available via <span class="rlang"><b>R</b></span>'s standard <code>attr</code> function, as well
as the <code>xtsAttributes</code> function.
</p>
<p>The returned object will preserve all relevant attribute/slot
data within itself, allowing for temporary conversion to use
zoo and xts compatible methods. A call to <code>reclass</code>
returns the object to its original class, with all original
attributes intact - unless otherwise changed.
</p>
<p>It should be obvious, but any attributes added via the ...
argument will not be carried back to the original data object,
as there would be no available storage slot/attribute.
</p>
<p><code>Reclass</code> is designed for top-level use, where it is
desirable to have the object returned from an arbitrary
function in the same class as the object passed in.  Most
functions within <span class="rlang"><b>R</b></span> are not designed to return objects
matching the original object's class.  While this tool is
highly experimental at present, it attempts to handle
conversion and reconversion transparently.  The caveats are
that the original object must be coercible to <code>xts</code>,
the returned object must be of the same row length as the
original object, and that the object to reconvert to is
the first argument to the function being wrapped.
</p>
<p><code>try.xts</code> and <code>reclass</code> are functions that enable
external developers access to the reclassing tools within
<span class="pkg">xts</span> to help speed development of time-aware functions,
as well as provide a more robust and seemless end-user experience,
regardless of the end-user's choice of data-classes.
</p>
<p>The <code>error</code> argument to try.xts accepts a logical value,
indicating where an error should be thrown, a character string
allowing for custom error messages to be displayed, or
a function of the form <code>f(x, ...)</code>, to be called
upon construction error.
</p>
<p>See the accompanying vignette for more details on the above usage
and the package in general.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>xts</code>.
</p>
<p>In the case of <code>Reclass</code> and <code>reclass</code>, the object
returned will be of the original class as identified by <code>CLASS</code>.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+xts">xts</a></code>,<code><a href="#topic+as.xts.methods">as.xts.methods</a></code> </p>

<hr>
<h2 id='as.xts.methods'> Convert Object To And From Class xts </h2><span id='topic+as.xts.methods'></span><span id='topic+as.xts.timeSeries'></span><span id='topic+as.timeSeries.xts'></span><span id='topic+as.xts.xts'></span><span id='topic+as.xts.zoo'></span><span id='topic+as.xts.ts'></span><span id='topic+as.xts.data.frame'></span><span id='topic+as.xts.matrix'></span>

<h3>Description</h3>

<p>Conversion S3 methods to coerce data objects of
arbitrary classes to class <code>xts</code> and back, without
losing any attributes of the original format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
as.xts(x,...,.RECLASS=FALSE)


## S3 method for class 'timeSeries'
as.xts(x, dateFormat="POSIXct", FinCenter, recordIDs,
    title, documentation, ..., .RECLASS=FALSE)

## S3 method for class 'zoo'
as.xts(x, order.by=index(x), frequency=NULL, ..., .RECLASS=FALSE)

## S3 method for class 'ts'
as.xts(x, dateFormat,...,.RECLASS=FALSE)

## S3 method for class 'data.frame'
as.xts(x, order.by, dateFormat="POSIXct",
    frequency=NULL, ...,.RECLASS=FALSE) 

## S3 method for class 'matrix'
as.xts(x, order.by, dateFormat="POSIXct",
    frequency=NULL, ..., .RECLASS=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.xts.methods_+3A_x">x</code></td>
<td>
<p> data object to convert. See details for supported types </p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_dateformat">dateFormat</code></td>
<td>
<p>what format should the dates be converted to</p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_fincenter">FinCenter</code></td>
<td>
<p>see timeSeries help</p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_recordids">recordIDs</code></td>
<td>
<p>see timeSeries help</p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_title">title</code></td>
<td>
<p>see timeSeries help</p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_documentation">documentation</code></td>
<td>
<p>see timeSeries help</p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_order.by">order.by</code></td>
<td>
<p>see <a href="zoo.html#topic+zoo">zoo</a> help </p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_frequency">frequency</code></td>
<td>
<p>see <a href="zoo.html#topic+zoo">zoo</a> help </p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_...">...</code></td>
<td>
<p> additional parameters or attributes </p>
</td></tr>
<tr><td><code id="as.xts.methods_+3A_.reclass">.RECLASS</code></td>
<td>
<p> should conversion be reversible? </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple and reliable way to convert many different
objects into a uniform format for use within <span class="rlang"><b>R</b></span>.
</p>
<p>It is possible with a call to <code>as.xts</code> to
convert objects of class <code>timeSeries</code>, <code>ts</code>,
<code>matrix</code>, <code>data.frame</code>, and <code>zoo</code>.
</p>
<p>Additional name=value pairs may be passed to the function
to be added to the new object. A special print.xts method
will assure that the attributes are hidden from view, but will
be available via <span class="rlang"><b>R</b></span>'s standard <code>attr</code> function.
</p>
<p>If <code>.RECLASS=TRUE</code>, the returned object will preserve all relevant attribute/slot
data within itself, allowing for temporary conversion to use
zoo and xts compatible methods. A call to <code>reclass</code>
returns the object to its original class, with all original
attributes intact - unless otherwise changed.  This is the default
behavior when <code>try.xts</code> is used for conversion, and should
not be altered by the user; i.e. don't touch it unless you are
aware of the consequences.
</p>
<p>It should be obvious, but any attributes added via the ...
argument will not be carried back to the original data object,
as there would be no available storage slot/attribute.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>xts</code>.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+xts">xts</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  # timeSeries
  library(timeSeries)
  x &lt;- timeSeries(1:10, 1:10)

  str( as.xts(x) )
  str( reclass(as.xts(x)) )
  str( try.xts(x) )
  str( reclass(try.xts(x)) )
  
## End(Not run)
</code></pre>

<hr>
<h2 id='axTicksByTime'> Compute x-Axis Tickmark Locations by Time </h2><span id='topic+axTicksByTime'></span>

<h3>Description</h3>

<p>Compute x-axis tickmarks like <code>axTicks</code> in base
but with respect to time.  Additionally the first
argument is the object indexed by time which you
are looking to derive tickmark locations for.
</p>
<p>It is possible to specify the detail you are seeking,
or by passing 'auto' to the <code>ticks.on</code> argument,
to get a best heuristic fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axTicksByTime(x, ticks.on='auto', k = 1,
              labels=TRUE, format.labels=TRUE, ends=TRUE,
              gt = 2, lt = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axTicksByTime_+3A_x">x</code></td>
<td>
<p> the object indexed by time, or a vector of times/dates </p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_ticks.on">ticks.on</code></td>
<td>
<p> what to break on </p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_k">k</code></td>
<td>
<p> frequency of breaks </p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_labels">labels</code></td>
<td>
<p> should a labeled vector be returned </p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_format.labels">format.labels</code></td>
<td>
<p> format labels - may be format to use </p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_ends">ends</code></td>
<td>
<p> should the ends be adjusted </p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_gt">gt</code></td>
<td>
<p> lower bound on number of breaks </p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_lt">lt</code></td>
<td>
<p> upper bound on number of breaks </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is written for internal use, and documented
for those wishing to use outside of the internal function
uses. In general it is most unlikely that the end user will
call this function directly.
</p>
<p>The <code>format.labels</code> argument allows for standard formatting like
that used in <code>format</code>, <code>strptime</code>, and <code>strftime</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of index element locations where tick marks should be drawn.
These are <em>locations</em> (e.g. 1, 2, 3, ...), <em>not</em> the index
timestamps.
</p>
<p>If possible, the result will be named using formatted values from the index
timestamps. The names will be used for the tick mark labels.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+endpoints">endpoints</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample_matrix)
axTicksByTime(as.xts(sample_matrix),'auto')
axTicksByTime(as.xts(sample_matrix),'weeks')
axTicksByTime(as.xts(sample_matrix),'months',7)
</code></pre>

<hr>
<h2 id='CLASS'> Extract and Set .CLASS Attribute </h2><span id='topic+CLASS'></span><span id='topic+CLASS+3C-'></span>

<h3>Description</h3>

<p>Simple extraction and replacement function
to access <code>xts</code> .CLASS attribute.  The .CLASS
attribute is used by <code>reclass</code> to transform
an <code>xts</code> object back to its original class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CLASS(x)

CLASS(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CLASS_+3A_x">x</code></td>
<td>
<p> an xts object </p>
</td></tr>
<tr><td><code id="CLASS_+3A_value">value</code></td>
<td>
<p> the new .CLASS value to assign </p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is not recommended that CLASS be called in
daily use.  While it may be possible to coerce objects
to other classes than originally derived from, there is
little, if any, chance that the <code>reclass</code> function
will perform as expected.
</p>
<p>It is best to use the traditional <code>as</code> methods.
</p>


<h3>Value</h3>

<p>Called for its side-effect of changing the .CLASS attribute
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.xts">as.xts</a></code>,<code><a href="#topic+reclass">reclass</a></code> </p>

<hr>
<h2 id='coredata.xts'> Extract/Replace Core Data of an xts Object </h2><span id='topic+coredata.xts'></span><span id='topic+xcoredata'></span><span id='topic+xcoredata+3C-'></span>

<h3>Description</h3>

<p>Mechanism to extract and replace the core data of an
<code>xts</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
coredata(x, fmt=FALSE, ...)

xcoredata(x,...)
xcoredata(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coredata.xts_+3A_x">x</code></td>
<td>
<p> an <code>xts</code> object </p>
</td></tr>
<tr><td><code id="coredata.xts_+3A_fmt">fmt</code></td>
<td>
<p> should the rownames be formated in a non-standard way </p>
</td></tr>
<tr><td><code id="coredata.xts_+3A_value">value</code></td>
<td>
<p> non-core attributes to assign </p>
</td></tr>
<tr><td><code id="coredata.xts_+3A_...">...</code></td>
<td>
<p> further arguments [unused] </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract coredata of an <code>xts</code> object - removing 
all attributes except <code>dim</code> and <code>dimnames</code> and
returning a matrix object with rownames converted from
the index of the <code>xts</code> object.
</p>
<p>The <code>fmt</code> argument, if TRUE, allows the internal
index formatting specified by the user to be used. Alternatively,
it may be a valid formatting string to be passed to <code>format</code>.
Setting to FALSE will return the row names by simply
coercing the index class to a character string in the default
manner.
</p>
<p><code>xcoredata</code> is the functional complement to
<code>coredata</code>, returning all of the attributes
normally removed by <code>coredata</code>.  Its purpose,
along with the replacement function <code>xcoredata&lt;-</code>
is primarily for use by developers using <span class="pkg">xts</span>
to allow for internal replacement of values
removed during use of non xts-aware functions.
</p>


<h3>Value</h3>

<p>Returns either a matrix object for coredata, or
a list of named attributes.
</p>
<p>The replacement functions are called for their side-effects.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="zoo.html#topic+zoo">coredata</a></code>, <code><a href="#topic+xtsAttributes">xtsAttributes</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample_matrix)
x &lt;- as.xts(sample_matrix, myattr=100)
coredata(x)
xcoredata(x)
</code></pre>

<hr>
<h2 id='diff.xts'> Lags and Differences of xts Objects </h2><span id='topic+diff.xts'></span><span id='topic+lag.xts'></span><span id='topic+lagts.xts'></span>

<h3>Description</h3>

<p>Methods for computing lags and differences on <code>xts</code> objects.  This
matches most of the functionality of <span class="pkg">zoo</span> methods, with some default
argument changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
lag(x, k = 1, na.pad = TRUE, ...)

## S3 method for class 'xts'
diff(x, lag = 1, differences = 1, arithmetic = TRUE, log = FALSE, na.pad = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff.xts_+3A_x">x</code></td>
<td>
<p> an <code>xts</code> object </p>
</td></tr>
<tr><td><code id="diff.xts_+3A_k">k</code></td>
<td>
<p> period to lag over </p>
</td></tr>
<tr><td><code id="diff.xts_+3A_lag">lag</code></td>
<td>
<p> period to difference over </p>
</td></tr>
<tr><td><code id="diff.xts_+3A_differences">differences</code></td>
<td>
<p> order of differencing </p>
</td></tr>
<tr><td><code id="diff.xts_+3A_arithmetic">arithmetic</code></td>
<td>
<p> should arithmetic or geometric differencing be used </p>
</td></tr>
<tr><td><code id="diff.xts_+3A_log">log</code></td>
<td>
<p> should (geometric) log differences be returned </p>
</td></tr>
<tr><td><code id="diff.xts_+3A_na.pad">na.pad</code></td>
<td>
<p> pad vector back to original size </p>
</td></tr>
<tr><td><code id="diff.xts_+3A_...">...</code></td>
<td>
<p> additional arguments </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary motivation for having methods specific to <code>xts</code>
was to make use of faster C-level code within xts.  Additionally,
it was decided that <code>lag</code>'s default behavior should
match the common time-series interpretation of that operator &mdash; specifically
that a value at time &lsquo;t&rsquo; should be the value at time &lsquo;t-1&rsquo;
for a positive lag. This is different than <code>lag.zoo</code> as well
as <code>lag.ts</code>.
</p>
<p>Another notable difference is that <code>na.pad</code> is set to
TRUE by default, to better reflect the transformation visually
and within functions requiring positional matching of data.
</p>
<p>Backwards compatability with zoo can be achieved by setting
<code>options(xts.compat.zoo.lag=TRUE)</code>. This will change the
defaults of lag.xts to k=-1 and na.pad=FALSE.
</p>


<h3>Value</h3>

<p>An <code>xts</code> object reflected the desired lag and/or differencing.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>References</h3>

 <p><a href="https://en.wikipedia.org/wiki/Lag">https://en.wikipedia.org/wiki/Lag</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xts(1:10, Sys.Date()+1:10)
lag(x)    # currently using xts-style positive k 

lag(x, k=2)

lag(x, k=-1, na.pad=FALSE) # matches lag.zoo(x, k=1)

diff(x)
diff(x, lag=1)
diff(x, diff=2)
diff(diff(x))
</code></pre>

<hr>
<h2 id='dimnames.xts'> Dimnames of an xts Object </h2><span id='topic+dimnames.xts'></span><span id='topic+dimnames+3C-.xts'></span>

<h3>Description</h3>

<p>Get or set dimnames of an xts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
dimnames(x)

## S3 replacement method for class 'xts'
dimnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimnames.xts_+3A_x">x</code></td>
<td>
<p> an xts object </p>
</td></tr>
<tr><td><code id="dimnames.xts_+3A_value">value</code></td>
<td>
<p> a list object of length two. See Details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>dimnames.xts</code> and <code>dimnames&lt;-.xts</code> are
methods for the base functions <code>dimnames</code> and <code>dimnames&lt;-</code>.
</p>
<p><code>xts</code> objects by design are intended for lightweight management
of time-indexed data. 
</p>
<p>Rownames are redundant in this design, as well
as quite burdensome with respect to memory consumption and
internal copying costs.
</p>
<p><code>rownames</code> and <code>colnames</code> in <span class="rlang"><b>R</b></span> make use of <code>dimnames</code> method
dispatch internally, and thus require only modifications
to dimnames to enforce the <code>xts</code> no rownames requirement.
</p>
<p>To prevent accidental setting of rownames, <code>dimnames&lt;-</code>
for <code>xts</code> will simply set the rownames to <code>NULL</code>
when invoked, regardless of attempts to set otherwise.
</p>
<p>This is done for internal compatibility reasons, as well as
to provide consistency in performance regardless of object use.
</p>
<p>User level interaction with either dimnames or rownames will
produce a character vector of the index, formatted based
on the current specification of <code>indexFormat</code>. This
occurs within the call by converting the results
of calling <code>index(x)</code> to a character string, which itself
first creates the object type specified internally from the
underlying numeric time representation.
</p>


<h3>Value</h3>

<p>A list or character string containing coerced row names
and/or actual column names.
</p>
<p>Attempts to set rownames on xts objects via rownames or dimnames
will silently fail.  This is your warning.
</p>


<h3>Note</h3>

 
<p>All <code>xts</code> objects have dimension.  There are
no <code>xts</code> objects representable as named or unnamed
vectors.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+xts">xts</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xts(1:10, Sys.Date()+1:10)
dimnames(x)
rownames(x)
rownames(x) &lt;- 1:10
rownames(x)
str(x)
</code></pre>

<hr>
<h2 id='endpoints'> Locate Endpoints by Time </h2><span id='topic+endpoints'></span>

<h3>Description</h3>

<p>Extract index locations for an <code>xts</code> object that correspond to the
<em>last</em> observation in each period specified by <code>on</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endpoints(x, on="months", k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endpoints_+3A_x">x</code></td>
<td>
<p> an xts object </p>
</td></tr>
<tr><td><code id="endpoints_+3A_on">on</code></td>
<td>
<p> the periods endpoints to find as a character string </p>
</td></tr>
<tr><td><code id="endpoints_+3A_k">k</code></td>
<td>
<p> along every k-th element - see notes </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>endpoints</code> returns a numeric vector corresponding to the <em>last</em>
observation in each period. The vector always begins with zero and ends with
the last observation in <code>x</code>.
</p>
<p>Periods are always based on the distance from the UNIX epoch (midnight
1970-01-01 UTC), <em>not the first observation in <code>x</code></em>. The examples
illustrate this behavior.
</p>
<p>Valid values for the argument <code>on</code> include: &ldquo;us&rdquo; (microseconds),
&ldquo;microseconds&rdquo;, &ldquo;ms&rdquo; (milliseconds), &ldquo;milliseconds&rdquo;,
&ldquo;secs&rdquo; (seconds), &ldquo;seconds&rdquo;, &ldquo;mins&rdquo; (minutes),
&ldquo;minutes&rdquo;, &ldquo;hours&rdquo;, &ldquo;days&rdquo;, &ldquo;weeks&rdquo;,
&ldquo;months&rdquo;, &ldquo;quarters&rdquo;, and &ldquo;years&rdquo;.
</p>


<h3>Value</h3>

<p>A numeric vector of beginning with 0 and ending with the value equal to the
number of observations in the <code>x</code> argument.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample_matrix)

endpoints(sample_matrix)
endpoints(sample_matrix, "weeks")

### example of how periods are based on the UNIX epoch,
### *not* the first observation of the data series
x &lt;- xts(1:38, yearmon(seq(2018 - 1/12, 2021, 1/12)))
# endpoints for the end of every other year
ep &lt;- endpoints(x, "years", k = 2)
# Dec-2017 is the end of the *first* year in the data. But when you start from
# Jan-1970 and use every second year end as your endpoints, the endpoints are
# always December of every odd year.
x[ep, ]

</code></pre>

<hr>
<h2 id='first'> Return First or Last n Elements of A Data Object </h2><span id='topic+first'></span><span id='topic+first.default'></span><span id='topic+first.xts'></span><span id='topic+last'></span><span id='topic+last.default'></span><span id='topic+last.xts'></span>

<h3>Description</h3>

<p>A generic function to return the first or last
elements or rows of a vector or two-dimensional
data object.
</p>
<p>A more advanced subsetting is available for
zoo objects with indexes inheriting from POSIXt
or Date classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first(x,...)
last(x,...)

## Default S3 method:
first(x,n=1,keep=FALSE,...)

## Default S3 method:
last(x,n=1,keep=FALSE,...)

## S3 method for class 'xts'
first(x,n=1,keep=FALSE,...)

## S3 method for class 'xts'
last(x,n=1,keep=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_+3A_x">x</code></td>
<td>
<p> 1 or 2 dimensional data object </p>
</td></tr>
<tr><td><code id="first_+3A_n">n</code></td>
<td>
<p> number of periods to return </p>
</td></tr>
<tr><td><code id="first_+3A_keep">keep</code></td>
<td>
<p> should removed values be kept? </p>
</td></tr>
<tr><td><code id="first_+3A_...">...</code></td>
<td>
<p> additional args - unused </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides the ability to identify the first or last
<code>n</code> rows or observations of a data set.  The generic
method behaves much like <code>head</code> and <code>tail</code> from
<span class="pkg">base</span>, except by default only the <em>first</em> or
<em>last</em> observation will be returned.
</p>
<p>The more useful method for the xts class allows for
time based subsetting, given an xtsible object.
</p>
<p><code>n</code> may be either a numeric value, indicating the number of
observations to return - forward from <code>first</code>, or backwards from <code>last</code>,
or it may be a character string describing the number and type of periods to
return.
</p>
<p><code>n</code> may be positive or negative, in either numeric or character
contexts. When positive it will return the result expected - e.g.
<code>last(X,'1 month')</code> will return the last month's data. If negative,
all data will be returned <em>except</em> for the last month. It is important
to note that this is not the same as calling <code>first(X,'1 month')</code> or
<code>first(X,'-1 month')</code>. All 4 variations return different subsets of
data and have distinct purposes.
</p>
<p>If <code>n</code> is a character string, it must be of the form &lsquo;n period.type&rsquo;
or &lsquo;period.type&rsquo;,
where <code>n</code> is a numeric value (defaults to 1 if not provided)
describing the number of <code>period.types</code>
to move forward (first) or back (last).
</p>
<p>For example, to return the last 3 weeks of a time oriented zoo object, one
could call <code>last(X,'3 weeks')</code>. Valid period.types are: secs, seconds,
mins, minutes, hours, days, weeks, months, quarters, and years.
</p>
<p>It is possible to use any frequency specification (secs, mins, days, ...)
for the period.type portion of the string, even if the original data is in
a higher frequency. This makes it possible to return the last &lsquo;2 months&rsquo;
of data from an oject that has a daily periodicity.
</p>
<p>It should be noted that it is only possible to extract data with methods
equal to or less than the frequency of the original data set. Attempting otherwise
will result in error.
</p>
<p>Requesting more data than is in the original data object will produce a warning
advising as such, and the object returned will simply be the original data.
</p>


<h3>Value</h3>

<p>A subset of elements/rows of the original data. 
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>Examples</h3>

<pre><code class='language-R'>first(1:100)
last(1:100)

data(LakeHuron)
first(LakeHuron,10)
last(LakeHuron)

x &lt;- xts(1:100, Sys.Date()+1:100)
first(x, 10)
first(x, '1 day')
first(x, '4 days')
first(x, 'month')
last(x, '2 months')
last(x, '6 weeks')
</code></pre>

<hr>
<h2 id='firstof'> Create a POSIXct Object </h2><span id='topic+firstof'></span><span id='topic+lastof'></span>

<h3>Description</h3>

<p>Enable fast creation of time stamps corresponding
to the first or last observation in a specified
time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstof(year = 1970, month = 1, day = 1, hour = 0, min = 0, sec = 0, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstof_+3A_year">year</code>, <code id="firstof_+3A_month">month</code>, <code id="firstof_+3A_day">day</code></td>
<td>
<p> numerical values to specify a day </p>
</td></tr>
<tr><td><code id="firstof_+3A_hour">hour</code>, <code id="firstof_+3A_min">min</code>, <code id="firstof_+3A_sec">sec</code></td>
<td>
<p> numerical vaues to specify time within a day </p>
</td></tr>
<tr><td><code id="firstof_+3A_tz">tz</code></td>
<td>
<p> timezone used for conversion </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper to the <span class="rlang"><b>R</b></span> function ISOdatetime with
defaults corresponding to the first or last
possible time in a given period.
</p>


<h3>Value</h3>

<p>An object of class POSIXct.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+ISOdatetime">ISOdatetime</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>firstof(2000)
firstof(2005,01,01)

lastof(2007)
lastof(2007,10)
</code></pre>

<hr>
<h2 id='index.xts'> Get and Replace the Class of an xts Index </h2><span id='topic+index.xts'></span><span id='topic+index+3C-.xts'></span><span id='topic+.index'></span><span id='topic+.index+3C-'></span><span id='topic+.indexhour'></span><span id='topic+.indexsec'></span><span id='topic+.indexmin'></span><span id='topic+.indexyear'></span><span id='topic+.indexymon'></span><span id='topic+.indexyday'></span><span id='topic+.indexday'></span><span id='topic+.indexDate'></span><span id='topic+.indexmday'></span><span id='topic+.indexwday'></span><span id='topic+.indexweek'></span><span id='topic+.indexmon'></span><span id='topic+.indexisdst'></span><span id='topic+convertIndex'></span>

<h3>Description</h3>

<p>Functions to get and replace an xts object's index values and it's components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
index(x, ...)
## S3 replacement method for class 'xts'
index(x) &lt;- value

.index(x, ...)
.index(x) &lt;- value

convertIndex(x, value)

# date/time component extraction
.indexsec(x)
.indexmin(x)
.indexhour(x)

.indexDate(x)
.indexday(x)
.indexwday(x)
.indexmday(x)

.indexweek(x)
.indexmon(x)
.indexyear(x)
.indexyday(x)

.indexisdst(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index.xts_+3A_x">x</code></td>
<td>
<p> an <code>xts</code> object </p>
</td></tr>
<tr><td><code id="index.xts_+3A_value">value</code></td>
<td>
<p> new index value </p>
</td></tr>
<tr><td><code id="index.xts_+3A_...">...</code></td>
<td>
<p> arguments passed to other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, an xts object's index is a <em>numeric</em> value corresponding to
seconds since the epoch in the UTC timezone. The <code>.index</code> and
<code>.index&lt;-</code> functions get and replace the internal <em>numeric</em> value of
the index, respectively.  These functions are primarily for internal use, but
are exported because they may be useful for users.
</p>
<p>The <code>index</code> and <code>index&lt;-</code> methods get and replace the xts object's
index, respectively. The replacement method also updates the <code><a href="#topic+tclass">tclass</a></code>
and <code><a href="#topic+tzone">tzone</a></code> of the index to match the class and timezone of the new
index, respectively. The <code>index</code> method converts the index to the class
specified by the <code><a href="#topic+tclass">tclass</a></code> attribute and with the timezone specified by
the <code><a href="#topic+tzone">tzone</a></code> attribute before returning the index values to the user.
</p>
<p>The <code>.indexXXX</code> functions extract time components (similar to
<code><a href="base.html#topic+POSIXlt">POSIXlt</a></code> components) from the internal time index:
</p>

<dl>
<dt><code>.indexsec</code></dt><dd><p>0 - 61: seconds of the minute (local time)</p>
</dd>
<dt><code>.indexmin</code></dt><dd><p>0 - 59: minutes of the hour (local time)</p>
</dd>
<dt><code>.indexhour</code></dt><dd><p>0 - 23: hours of the day (local time)</p>
</dd>
<dt><code>.indexDate</code></dt><dd><p>date as seconds since the epoch (UTC <em>not local time</em></p>
</dd>
<dt><code>.indexday</code></dt><dd><p>date as seconds since the epoch (UTC <em>not local time</em></p>
</dd>
<dt><code>.indexwday</code></dt><dd><p>0 - 6: day of the week (Sunday - Saturday, local time)</p>
</dd>
<dt><code>.indexmday</code></dt><dd><p>1 - 31: day of the month (local time)</p>
</dd>
<dt><code>.indexweek</code></dt><dd><p>weeks since the epoch (UTC <em>not local time</em></p>
</dd>
<dt><code>.indexmon</code></dt><dd><p>0 - 11: month of the year (local time)</p>
</dd>
<dt><code>.indexyear</code></dt><dd><p>years since 1900 (local time)</p>
</dd>
<dt><code>.indexyday</code></dt><dd><p>0 - 365: day of the year (local time, 365 only in leap years)</p>
</dd>
<dt><code>.indexisdst</code></dt><dd><p>1, 0, -1: Daylight Saving Time flag. Positive if Daylight
Saving Time is in effect, zero if not, negative if unknown.</p>
</dd>
</dl>

<p>Changes in timezone, index class, and index format internal structure,
by <span class="pkg">xts</span> version:
</p>

<dl>
<dt>Version 0.12.0:</dt><dd><p>The <code>.indexTZ</code>, <code>.indexCLASS</code> and
<code>.indexFORMAT</code> attributes are no longer stored on xts objects, only
on the index itself.
</p>
<p>The <code>indexTZ</code>, <code>indexClass</code>, and <code>indexFormat</code> functions
(and their respective replacement methods) are deprecated in favor of their
respective <code>tzone</code>, <code>tclass</code>, and <code>tformat</code> versions. The
previous versions will throw a warning that they're deprecated, but they
will continue to work.  There are no plans to remove them or have them
throw an error. Ever.
</p>
<p>The latter versions are careful to look for the old attributes on the xts
object, in case they're ever called on an xts object that was created prior
to the attributes being added to the index itself.
</p>
<p>There are options to throw a warning if there is no <code>tzone</code> or
<code>tclass</code> attribute on the index, even if there may be one on the xts
object. This gives the user a way to know if an xts object should be
updated to use the new structure.
</p>
<p>You can enable the warnings via:
<code>options(xts.warn.index.missing.tzone = TRUE, xts.warn.index.missing.tclass = TRUE)</code>
You can identify xts objects with the old structure by printing them. Then
you can update them to the new structure using <code>x &lt;- as.xts(x)</code>.
</p>
</dd>
<dt>Version 0.9.8:</dt><dd><p>The index timezone is now set to &quot;UTC&quot; for time classes
that do not have any intra-day component (e.g. days, months, quarters).
Previously the timezone was blank, which meant &quot;local time&quot; as determined
by R and the OS.
</p>
</dd>
<dt>Version 0.9.2:</dt><dd><p>There are new get/set methods for the timezone, index
class, and index format attributes: <code>tzone</code> and, <code>tzone&lt;-</code>,
<code>tclass</code> and <code>tclass&lt;-</code>, and <code>tformat</code> and <code>tformat&lt;-</code>.
</p>
<p>These new functions are aliases to their <code>indexTZ</code>, <code>indexClass</code>,
and <code>indexFormat</code> counterparts.
</p>
</dd>
<dt>Version 0.7.5:</dt><dd><p>The timezone, index class, and index format were added
as attributes to the index itself, as <code>tzone</code>, <code>tclass</code>, and
<code>tformat</code>, respectively. This is in order to remove those three
attributes from the xts object, so they're only on the index itself.
</p>
<p>The <code>indexTZ</code>, <code>indexClass</code>, and <code>indexFormat</code> functions
(and their respective replacement methods) will continue to work as in
prior <span class="pkg">xts</span> versions. The attributes on the index take priority over
their respective counterparts that may be on the xts object.
</p>
</dd>
<dt>Versions 0.6.4 and prior:</dt><dd><p>Objects track their timezone and index class
in their <code>.indexTZ</code> and <code>.indexCLASS</code> attributes, respectively.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

<p><code><a href="#topic+tformat">tformat</a></code> describes how the index values are formatted when printed,
<code><a href="#topic+tclass">tclass</a></code> provides details how <span class="pkg">xts</span> handles the class of the index,
and <code><a href="#topic+tzone">tzone</a></code> has more information about the index timezone settings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- timeBasedSeq('2010-01-01/2010-01-01 12:00/H')
x &lt;- xts(seq_along(x), x)

# the index values, converted to 'tclass' (POSIXct in this case)
index(x)
class(index(x))  # POSIXct
tclass(x)        # POSIXct

# the internal numeric index
.index(x)
# add 1 hour (3600 seconds) to the numeric index
.index(x) &lt;- index(x) + 3600
index(x)

y &lt;- timeBasedSeq('2010-01-01/2010-01-02 12:00')
y &lt;- xts(seq_along(y), y)

# Select all observations in the first 6 and last 3 minutes of the
# 8th and 15th hours on each day
y[.indexhour(y) %in% c(8, 15) &amp; .indexmin(y) %in% c(0:5, 57:59)]

i &lt;- 0:60000
focal_date &lt;- as.numeric(as.POSIXct("2018-02-01", tz = "UTC"))
y &lt;- .xts(i, c(focal_date + i * 15), tz = "UTC", dimnames = list(NULL, "value"))

# Select all observations for the first minute of each hour
y[.indexmin(y) == 0]

# Select all observations on Monday
mon &lt;- y[.indexwday(y) == 1]
head(mon)
tail(mon)
unique(weekdays(index(mon))) # check

# Disjoint time of day selections

# Select all observations between 08:30 and 08:59:59.9999  or between 12:00 and 12:14:59.99999:
y[.indexhour(y) == 8 &amp; .indexmin(y) &gt;= 30 | .indexhour(y) == 12 &amp; .indexmin(x) %in% 0:14]

### Compound selections

# Select all observations for Wednesdays or Fridays between 9am and 4pm (exclusive of 4pm):
y[.indexwday(y) %in% c(3, 5) &amp; (.indexhour(y) %in%  c(9:15))]

# Select all observations on Monday between 8:59:45 and 09:04:30:

y[.indexwday(y) == 1 &amp; (.indexhour(y) == 8 &amp; .indexmin(y) == 59 &amp; .indexsec(y) &gt;= 45 |
                        .indexhour(y) == 9 &amp;
                        (.indexmin(y) &lt;  4 | .indexmin(y) ==  4 &amp; .indexsec(y) &lt;= 30))]

i &lt;- 0:30000
u &lt;- .xts(i, c(focal_date + i * 1800), tz = "UTC", dimnames = list(NULL, "value"))

# Select all observations for January or February:
u[.indexmon(u) %in% c(0, 1)]

# Select all data for the 28th to 31st of each month, excluding any Fridays:
u[.indexmday(u) %in% 28:31 &amp; .indexwday(u) != 5]

# Subset by week since origin
unique(.indexweek(u))
origin &lt;- xts(1, as.POSIXct("1970-01-01"))
unique(.indexweek(origin))

# Select all observations in weeks 2515 to 2517.
u2 &lt;- u[.indexweek(u) %in% 2515:2517]
head(u2); tail(u2)

# Select all observations after 12pm for day 50 and 51 in each year
u[.indexyday(u) %in% 50:51 &amp; .indexhour(u) &gt;= 12]
</code></pre>

<hr>
<h2 id='isOrdered'> Check If A Vector Is Ordered </h2><span id='topic+isOrdered'></span>

<h3>Description</h3>

<p>Performs check to determine if a vector is strictly increasing,
strictly decreasing, not decreasing, or not increasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isOrdered(x, increasing = TRUE, strictly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isOrdered_+3A_x">x</code></td>
<td>
<p> a numeric vector </p>
</td></tr>
<tr><td><code id="isOrdered_+3A_increasing">increasing</code></td>
<td>
<p> test for increasing/decreasing values </p>
</td></tr>
<tr><td><code id="isOrdered_+3A_strictly">strictly</code></td>
<td>
<p> are duplicates OK </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designed for internal use with <span class="pkg">xts</span>, this provides
highly optimized tests for ordering.
</p>


<h3>Value</h3>

<p>Logical
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+is.unsorted">is.unsorted</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># strictly increasing
isOrdered(1:10, increasing=TRUE)
isOrdered(1:10, increasing=FALSE)
isOrdered(c(1,1:10), increasing=TRUE)
isOrdered(c(1,1:10), increasing=TRUE, strictly=FALSE)

# decreasing
isOrdered(10:1, increasing=TRUE)
isOrdered(10:1, increasing=FALSE)

</code></pre>

<hr>
<h2 id='make.index.unique'>
Force Time Values To Be Unique
</h2><span id='topic+make.index.unique'></span><span id='topic+make.time.unique'></span><span id='topic+is.index.unique'></span><span id='topic+is.time.unique'></span>

<h3>Description</h3>

<p>A generic function to force sorted time vectors to be
unique. Useful for high-frequency time-series where original
time-stamps may have identical values. For the case
of xts objects, the default <code>eps</code> is set to ten
microseconds. In practice this advances each subsequent
identical time by <code>eps</code> over the previous (possibly also
advanced) value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.index.unique(x, eps = 1e-06, drop=FALSE, fromLast=FALSE, ...)

make.time.unique(x, eps = 1e-06, drop=FALSE, fromLast=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.index.unique_+3A_x">x</code></td>
<td>

<p>An xts object, or POSIXct vector.
</p>
</td></tr>
<tr><td><code id="make.index.unique_+3A_eps">eps</code></td>
<td>

<p>value to add to force uniqueness.
</p>
</td></tr>
<tr><td><code id="make.index.unique_+3A_drop">drop</code></td>
<td>

<p>drop duplicates instead of adjusting by <code>eps</code>
</p>
</td></tr>
<tr><td><code id="make.index.unique_+3A_fromlast">fromLast</code></td>
<td>

<p>if drop=TRUE, fromLast controls which duplicated times
are dropped. If fromLast=FALSE, the earliest observation
with an identical timestamp is kept with subsequent observations
dropped.
</p>
</td></tr>
<tr><td><code id="make.index.unique_+3A_...">...</code></td>
<td>

<p>unused
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned time-series object will have new time-stamps
so that <code>isOrdered( .index(x) )</code> evaluates to TRUE.
</p>


<h3>Value</h3>

<p>A modified version of x.
</p>


<h3>Note</h3>

<p>Incoming values must be pre-sorted, and no check is done to
make sure that this is the case.  If the index values are
of storage.mode &lsquo;integer&rsquo;, they will be coerced
to &lsquo;double&rsquo; if drop=FALSE.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+align.time">align.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ds &lt;- options(digits.secs=6) # so we can see the change

x &lt;- xts(1:10, as.POSIXct("2011-01-21") + c(1,1,1,2:8)/1e3)
x
make.index.unique(x)

options(ds)
</code></pre>

<hr>
<h2 id='merge.xts'> Merge xts Objects </h2><span id='topic+merge.xts'></span><span id='topic+cbind.xts'></span>

<h3>Description</h3>

<p>Used to perform merge operation on <code>xts</code> objects
by <em>time</em> (index).  Given the
inherent ordered nature of <code>xts</code> time-series, a
merge-join style merge allows for optimally efficient
joins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
merge(...,
      all = TRUE,
      fill = NA,
      suffixes = NULL,
      join = "outer",
      retside = TRUE,
      retclass = "xts",
      tzone = NULL,
      drop=NULL,
      check.names=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.xts_+3A_...">...</code></td>
<td>
<p> one or more xts objects, or objects coercible to class xts </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_all">all</code></td>
<td>
<p> a logical vector indicating merge type </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_fill">fill</code></td>
<td>
<p> values to be used for missing elements </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_suffixes">suffixes</code></td>
<td>
<p> to be added to merged column names </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_join">join</code></td>
<td>
<p> type of database join </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_retside">retside</code></td>
<td>
<p> which side of the merged object should be returned (2-case only) </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_retclass">retclass</code></td>
<td>
<p> object to return </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_tzone">tzone</code></td>
<td>
<p> time zone of merged object </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_drop">drop</code></td>
<td>
<p> not currently used </p>
</td></tr>
<tr><td><code id="merge.xts_+3A_check.names">check.names</code></td>
<td>
<p> not currently used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an xts method compatible with merge.zoo, as xts extends zoo.
That documentation should also be referenced.
Difference are noted where applicable.
</p>
<p>Implemented almost entirely in custom C-level code,
it is possible using either the <code>all</code> argument or
the <code>join</code> argument to implement all common
database join operations along the to-be-merged objects 
time-index: &lsquo;outer&rsquo; (full outer - all rows), 
&lsquo;inner&rsquo; (only rows with common indexes),
&lsquo;left&rsquo; (all rows in the left object, and those that match in the right),
and &lsquo;right&rsquo; (all rows in the right object, and those that match in the left).
</p>
<p>The above join types can also be expressed as a vector of
logical values passed to <code>all</code>.  c(TRUE,TRUE) or TRUE for &lsquo;join=&quot;outer&quot;&rsquo;,
c(FALSE,FALSE) or FALSE for &lsquo;join=&quot;inner&quot;&rsquo;, c(TRUE, FALSE) for &lsquo;join=&quot;left&quot;&rsquo;,
and c(FALSE,TRUE) for &lsquo;join=&quot;right&quot;&rsquo;.
</p>
<p>Note that the <code>all</code> and <code>join</code> arguments imply a two case scenario.  For merging
more than two objects, they will simply fall back to a full outer or full inner join,
depending on the first position of all, as
left and right can be ambiguous with respect to sides.
</p>
<p>To do something along the lines of merge.zoo's method of joining based on
an all argument of the same length of the arguments to join, see the example.  
</p>
<p>The resultant object will have the timezone of the leftmost
argument if available. Use <code>tzone</code> to override. 
</p>
<p>If <code>retclass</code> is <code>NULL</code>, the joined objects will be split
and reassigned silently back to the original environment they are called
from.  This is for backward compatibility with zoo, though unused
by xts.
</p>
<p>If <code>retclass</code> is <code>FALSE</code> the object will be stripped of
its class attribute.  This is for internal use.
</p>


<h3>Value</h3>

<p>A new <code>xts</code> object containing the appropriate
elements of the objects passed in to be merged.
</p>


<h3>Note</h3>

<p>This is a highly optimized merge, specifically designed for ordered data. The
only supported merging is based on the underlying time index.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>References</h3>

<p> Merge Join Discussion: <a href="https://blogs.msdn.microsoft.com/craigfr/2006/08/03/merge-join/">https://blogs.msdn.microsoft.com/craigfr/2006/08/03/merge-join/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- xts(4:10, Sys.Date()+4:10))
(y &lt;- xts(1:6, Sys.Date()+1:6))

merge(x,y)
merge(x,y, join='inner')
merge(x,y, join='left')
merge(x,y, join='right')

merge.zoo(zoo(x),zoo(y),zoo(x), all=c(TRUE, FALSE, TRUE))
merge(merge(x,x),y,join='left')[,c(1,3,2)]

# zero-width objects (only index values) can be used
xi &lt;- xts( , index(x))
merge(y, xi)
</code></pre>

<hr>
<h2 id='na.locf.xts'>
Last Observation Carried Forward
</h2><span id='topic+na.locf.xts'></span>

<h3>Description</h3>

<p><span class="pkg">xts</span> method replace &lsquo;NA&rsquo; with most recent non-&lsquo;NA&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
na.locf(object, na.rm = FALSE, fromLast = FALSE, maxgap=Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.locf.xts_+3A_object">object</code></td>
<td>

<p>an xts object
</p>
</td></tr>
<tr><td><code id="na.locf.xts_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. Should leading/trailing &lsquo;NA&rsquo;'s be removed?
The default for xts <code>FALSE</code> is different than the
default S3 method in the <span class="pkg">zoo</span> package.
</p>
</td></tr>
<tr><td><code id="na.locf.xts_+3A_fromlast">fromLast</code></td>
<td>

<p>logical. Cause observations to be carried backward rather
than forward. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="na.locf.xts_+3A_maxgap">maxgap</code></td>
<td>

<p>runs of more than &lsquo;maxgap&rsquo; will retain &lsquo;NA&rsquo;s after the
maximum gap specified. See <code>na.locf</code> in the zoo package.
</p>
</td></tr>
<tr><td><code id="na.locf.xts_+3A_...">...</code></td>
<td>

<p>unused
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <span class="pkg">xts</span> method for the S3 generic <code>na.locf</code>.
The primary difference to note is that after the &lsquo;NA&rsquo;
fill action is carried out, the default it to leave
trailing or leading &lsquo;NA&rsquo;'s in place. This is different
than <span class="pkg">zoo</span> behavior.
</p>


<h3>Value</h3>

<p>See the documentation in zoo.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p>&lsquo;zoo&rsquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xts(1:10, Sys.Date()+1:10)
x[c(1,2,5,9,10)] &lt;- NA

x
na.locf(x)
na.locf(x, fromLast=TRUE)
na.locf(x, na.rm=TRUE, fromLast=TRUE)
</code></pre>

<hr>
<h2 id='ndays'> Number of Periods in Data </h2><span id='topic+nseconds'></span><span id='topic+nminutes'></span><span id='topic+nhours'></span><span id='topic+ndays'></span><span id='topic+nweeks'></span><span id='topic+nmonths'></span><span id='topic+nquarters'></span><span id='topic+nyears'></span>

<h3>Description</h3>

<p>Calculate the number of specified periods in a given
time series like data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nseconds(x)
nminutes(x)
nhours(x)
ndays(x)
nweeks(x)
nmonths(x)
nquarters(x)
nyears(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndays_+3A_x">x</code></td>
<td>
<p> A time-based object </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially a wrapper to <code>endpoints</code> with the appropriate
period specified; the resulting value derived from counting the
endpoints
</p>
<p>As a compromise between simplicity and accuracy, the results will always
round up to the nearest complete period. So n**** - 1 will return
the completed periods.
</p>
<p>For finer grain detail one should call
a higher frequency n**** function.
</p>
<p>An alternative summary can be found with <code>periodicity</code>
and <code>unclass(periodicity(x))</code>.
</p>


<h3>Value</h3>

<p>The number of observations for the period type specified
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+endpoints">endpoints</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getSymbols("QQQQ")

ndays(QQQQ)
nweeks(QQQQ)

## End(Not run)
</code></pre>

<hr>
<h2 id='period.apply'> Apply Function Over Specified Interval </h2><span id='topic+period.apply'></span>

<h3>Description</h3>

<p>Apply a specified function to data over intervals specified by <code>INDEX</code>.
The intervals are defined as the observations from <code>INDEX[k]+1</code> to
<code>INDEX[k+1]</code>, for <code>k = 1:(length(INDEX)-1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period.apply(x, INDEX, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period.apply_+3A_x">x</code></td>
<td>
<p> The data that FUN will be applied to. </p>
</td></tr>
<tr><td><code id="period.apply_+3A_index">INDEX</code></td>
<td>
<p> A numeric vector of index breakpoint locations. The vector
should begin with 0 and end with <code>NROW(x)</code>. </p>
</td></tr>
<tr><td><code id="period.apply_+3A_fun">FUN</code></td>
<td>
<p> A <code>function</code> to apply to each interval in <code>x</code>. </p>
</td></tr>
<tr><td><code id="period.apply_+3A_...">...</code></td>
<td>
<p> Additional arguments for <code>FUN</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to the rest of the apply family, <code>period.apply()</code> calculates the
specified function's value over a subset of data. The primary difference is
that <code>period.apply()</code> applies the function to non-overlapping intervals
of a vector or matrix.
</p>
<p>Useful for applying functions over an entire data object by any non-overlapping
intervals. For example, when <code>INDEX</code> is the result of a call to
<code>endpoints()</code>.
</p>
<p><code>period.apply()</code> checks that <code>INDEX</code> is sorted, unique, starts with
0, and ends with <code>NROW(x)</code>. All those conditions are true of vectors
returned by <code>endpoints()</code>.
</p>


<h3>Value</h3>

<p>An object with <code>length(INDEX) - 1</code> observations (assuming <code>INDEX</code>
starts with 0 and ends with <code>NROW(x)</code>).
</p>


<h3>Note</h3>

<p>When <code>FUN = mean</code> the results will contain one column for every column
in the input, which is different from other math functions (e.g. <code>median</code>,
<code>sum</code>, <code>prod</code>, <code>sd</code>, etc.).
</p>
<p><code>FUN = mean</code> works by column because the default method <code>stats::mean</code>
used to work by column for matrices and data.frames. R Core changed the
behavior of <code>mean</code> to always return one column in order to be consistent
with the other math functions. This broke some <span class="pkg">xts</span> dependencies and
<code>mean.xts</code> was created to maintain the original behavior.
</p>
<p>Using <code>FUN = mean</code> will print a message that describes this inconsistency.
To avoid the message and confusion, use <code>FUN = colMeans</code> to calculate
means by column and use <code>FUN = function(x) mean</code> to calculate one mean
for all the data. Set <code>options(xts.message.period.apply.mean = FALSE)</code>
to suppress this message.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan, Joshua M. Ulrich </p>


<h3>See Also</h3>

 <p><code><a href="#topic+endpoints">endpoints</a></code> <code><a href="#topic+apply.monthly">apply.monthly</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>zoo.data &lt;- zoo(rnorm(31)+10,as.Date(13514:13744,origin="1970-01-01"))
ep &lt;- endpoints(zoo.data,'weeks')
period.apply(zoo.data, INDEX=ep, FUN=function(x) colMeans(x))
period.apply(zoo.data, INDEX=ep, FUN=colMeans)                  #same

period.apply(letters,c(0,5,7,26), paste0)
</code></pre>

<hr>
<h2 id='period.max'> Calculate Max By Period </h2><span id='topic+period.max'></span>

<h3>Description</h3>

<p>Calculate a maximum for each period of INDEX. Essentially a rolling
application of maximum over a series of non-overlapping sections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period.max(x, INDEX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period.max_+3A_x">x</code></td>
<td>
<p> a univariate data object </p>
</td></tr>
<tr><td><code id="period.max_+3A_index">INDEX</code></td>
<td>
<p> a numeric vector of endpoints to calculate maximum on </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to calculate a maximum per period given an arbitrary
index of sections to be calculated over. This is an optimized function
for maximum.  There are additional optimized versions for min, sum, and
prod. 
</p>
<p>For xts-coercible objects, an appropriate INDEX can be derived
from a call to 'endpoints'.
</p>


<h3>Value</h3>

<p>An xts or zoo object of maximums, indexed by the period endpoints.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+endpoints">endpoints</a></code>, <code><a href="#topic+period.sum">period.sum</a></code>,
<code><a href="#topic+period.min">period.min</a></code>, <code><a href="#topic+period.prod">period.prod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>period.max(c(1,1,4,2,2,6,7,8,-1,20),c(0,3,5,8,10))

data(sample_matrix)
period.max(sample_matrix[,1],endpoints(sample_matrix))
period.max(as.xts(sample_matrix)[,1],endpoints(sample_matrix))
</code></pre>

<hr>
<h2 id='period.min'> Calculate Min By Period </h2><span id='topic+period.min'></span>

<h3>Description</h3>

<p>Calculate a minimum for each period of INDEX. Essentially a rolling
application of minimum over a series of non-overlapping sections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period.min(x, INDEX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period.min_+3A_x">x</code></td>
<td>
<p> a univariate data object </p>
</td></tr>
<tr><td><code id="period.min_+3A_index">INDEX</code></td>
<td>
<p> a numeric vector of endpoints to calculate maximum on </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to calculate a minimum per period given an arbitrary
index of sections to be calculated over. This is an optimized function
for minimum. There are additional optimized versions for max, sum, and
prod. 
</p>
<p>For xts-coercible objects, an appropriate INDEX
can be derived from a call to <code>endpoints</code>.
</p>


<h3>Value</h3>

<p>An xts or zoo object of minimums, indexed by the period endpoints.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+endpoints">endpoints</a></code>, <code><a href="#topic+period.sum">period.sum</a></code>,
<code><a href="#topic+period.max">period.max</a></code>, <code><a href="#topic+period.prod">period.prod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>period.min(c(1,1,4,2,2,6,7,8,-1,20),c(0,3,5,8,10))

data(sample_matrix)
period.min(sample_matrix[,1],endpoints(sample_matrix))
period.min(as.xts(sample_matrix)[,1],endpoints(sample_matrix))
</code></pre>

<hr>
<h2 id='period.prod'> Calculate Product By Period </h2><span id='topic+period.prod'></span>

<h3>Description</h3>

<p>Calculate a product for each period of INDEX. Essentially a rolling
application of prod over a series of non-overlapping sections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period.prod(x, INDEX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period.prod_+3A_x">x</code></td>
<td>
<p> a univariate data object </p>
</td></tr>
<tr><td><code id="period.prod_+3A_index">INDEX</code></td>
<td>
<p> a vector of breakpoints to calculate product on </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to calculate a product per period given an arbitrary
index of sections to be calculated over. This is an optimized function
for product.  There are additionally optimized versions for min, max, and
sum. 
</p>
<p>For xts-coercible objects, an appropriate INDEX can be
derived from a call to <code>endpoints</code>.
</p>


<h3>Value</h3>

<p>An <code>xts</code> or <code>zoo</code> object of products,
indexed by the period endpoints.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+endpoints">endpoints</a></code>, <code><a href="#topic+period.sum">period.sum</a></code>, 
<code><a href="#topic+period.min">period.min</a></code>, <code><a href="#topic+period.max">period.max</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>period.prod(c(1,1,4,2,2,6,7,8,-1,20),c(0,3,5,8,10))

data(sample_matrix)
period.prod(sample_matrix[,1],endpoints(sample_matrix))
period.prod(as.xts(sample_matrix)[,1],endpoints(sample_matrix))
</code></pre>

<hr>
<h2 id='period.sum'> Calculate Sum By Period </h2><span id='topic+period.sum'></span>

<h3>Description</h3>

<p>Calculate a sum for each period of INDEX. Essentially a rolling
application of sum over a series of non-overlapping sections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period.sum(x, INDEX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period.sum_+3A_x">x</code></td>
<td>
<p> a univariate data object </p>
</td></tr>
<tr><td><code id="period.sum_+3A_index">INDEX</code></td>
<td>
<p> a numeric vector of endpoints to calculate sum on </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to calculate a sum per period given an arbitrary
index of sections to be calculated over. This is an optimized function
for sum.  There are additionally optimized versions for min, max, and
prod. 
</p>
<p>For xts-coercible objects, an appropriate INDEX can be derived
from a call to <code>endpoints</code>.
</p>


<h3>Value</h3>

<p>An <code>xts</code> or <code>zoo</code> object of sums,
indexed by the period endpoints.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+endpoints">endpoints</a></code>, <code><a href="#topic+period.max">period.max</a></code>,
<code><a href="#topic+period.min">period.min</a></code>, <code><a href="#topic+period.prod">period.prod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>period.sum(c(1,1,4,2,2,6,7,8,-1,20),c(0,3,5,8,10))

data(sample_matrix)
period.sum(sample_matrix[,1],endpoints(sample_matrix))
period.sum(as.xts(sample_matrix)[,1],endpoints(sample_matrix))
</code></pre>

<hr>
<h2 id='periodicity'> Approximate Series Periodicity </h2><span id='topic+periodicity'></span>

<h3>Description</h3>

<p>Estimate the periodicity of a time-series-like
object by calculating the median time between
observations in days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodicity(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodicity_+3A_x">x</code></td>
<td>
<p> time-series-like object </p>
</td></tr>
<tr><td><code id="periodicity_+3A_...">...</code></td>
<td>
<p> unused </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple wrapper to quickly estimate the periodicity
of a given data. Returning an object of type <code>periodicity</code>.
</p>
<p>This calculates the
median number of days between observations
as a difftime object, the numerical difference,
the units of measurement,
and the derived scale of the data as a string. 
</p>
<p>The time index currently must be of either <code>Date</code>
or <code>POSIX</code> class, or coercible to such. 
</p>
<p>The only list item of note is the <code>scale</code>.
This is an estimate of the periodicity of the data
in common terms - e.g. 7 day daily data is best
described as &lsquo;weekly&rsquo;, and would be returned as
such.
</p>
<p>Possible <code>scale</code> values are:
</p>
<p>&lsquo;minute&rsquo;,&lsquo;hourly&rsquo;,
&lsquo;daily&rsquo;,&lsquo;weekly&rsquo;,
&lsquo;monthly&rsquo;,&lsquo;quarterly&rsquo;,
and &lsquo;yearly&rsquo;.
</p>


<h3>Value</h3>

<p>An object containing a list containing the <code>difftime</code> object,
frequency, units, and suitable scale.
</p>


<h3>Note</h3>

<p>This function is only a <em>good estimate</em> for
the underlying periodicity.  If the series is too
short, or has <em>no</em> real periodicity, the return
values will obviously be wrong. That said, it is quite
robust and used internally within <span class="pkg">xts</span>.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+difftime">difftime</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>zoo.ts &lt;- zoo(rnorm(231),as.Date(13514:13744,origin="1970-01-01"))
periodicity(zoo.ts)
</code></pre>

<hr>
<h2 id='plot.xts'>Plotting xts Objects</h2><span id='topic+plot.xts'></span><span id='topic+lines.xts'></span><span id='topic+points.xts'></span>

<h3>Description</h3>

<p>Plotting for xts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
plot(x, y = NULL, ..., subset = "",
  panels = NULL, multi.panel = FALSE, col = 1:8, up.col = NULL,
  dn.col = NULL, bg = "#FFFFFF", type = "l", lty = 1, lwd = 2, lend = 1,
  main = deparse(substitute(x)), main.timespan = TRUE, observation.based = FALSE,
  log = FALSE, ylim = NULL, yaxis.same = TRUE, yaxis.left = TRUE, yaxis.right = TRUE,
  yaxis.ticks = 5, major.ticks = "auto", minor.ticks = NULL,
  grid.ticks.on = "auto", grid.ticks.lwd = 1, grid.ticks.lty = 1,
  grid.col = "darkgray", labels.col = "#333333", format.labels = TRUE,
  grid2 = "#F5F5F5", legend.loc = NULL, extend.xaxis = FALSE)
## S3 method for class 'xts'
lines(x, ..., main = "", on = 0, col = NULL, type = "l",
  lty = 1, lwd = 1, pch = 1)
## S3 method for class 'xts'
points(x, ..., main = "", on = 0, col = NULL, pch = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.xts_+3A_x">x</code></td>
<td>
<p>xts object</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_y">y</code></td>
<td>
<p>NULL, not used</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_...">...</code></td>
<td>
<p>any passthrough graphical arguments for <code>lines</code> and <code>points</code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_subset">subset</code></td>
<td>
<p>character vector of length one of the subset range using subsetting as in <code><a href="#topic+xts">xts</a></code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_panels">panels</code></td>
<td>
<p>character vector of expressions to plot as panels</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_multi.panel">multi.panel</code></td>
<td>
<p>TRUE/FALSE or an integer less than or equal to the number
of columns in the data set. If TRUE, each column of the data is plotted in a
separate panel. For example, if <code>multi.panel = 2</code>, then the data
will be plotted in groups of 2 columns and each group is plotted in a
separate panel.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_col">col</code></td>
<td>
<p>color palette to use, set by default to rational choices</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_up.col">up.col</code></td>
<td>
<p>color for positive bars if <code>type="h"</code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_dn.col">dn.col</code></td>
<td>
<p>color for negative bars if <code>type="h"</code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_bg">bg</code></td>
<td>
<p>background color of plotting area, same as in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_type">type</code></td>
<td>
<p>the type of plot to be drawn, same as in <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_lty">lty</code></td>
<td>
<p>set the line type, same as in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_lwd">lwd</code></td>
<td>
<p>set the line width, same as in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_lend">lend</code></td>
<td>
<p>set the line end style, same as in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_main.timespan">main.timespan</code></td>
<td>
<p>include the timespan of the series on the plot? (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_observation.based">observation.based</code></td>
<td>
<p>TRUE/FALSE (default FALSE). If <code>TRUE</code>, the x-axis is drawn based on observations in the data. If <code>FALSE</code>, the x-axis is drawn based on the time index of the data.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_log">log</code></td>
<td>
<p>TRUE/FALSE (default FALSE). If <code>TRUE</code>, the y-axis is drawn in log-scale</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_ylim">ylim</code></td>
<td>
<p>the range of the y axis</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_yaxis.same">yaxis.same</code></td>
<td>
<p>TRUE/FALSE. If TRUE, the y axis is drawn with the same ylim for multiple panels</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_yaxis.left">yaxis.left</code></td>
<td>
<p>if TRUE, draws the y axis on the left</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_yaxis.right">yaxis.right</code></td>
<td>
<p>if TRUE, draws the y axis on the right</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_yaxis.ticks">yaxis.ticks</code></td>
<td>
<p>desired number of y axis grid lines. The actual number
of grid lines is determined by the <code>n</code> argument to <code><a href="base.html#topic+pretty">pretty</a></code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_major.ticks">major.ticks</code></td>
<td>
<p>period that specifies where tick marks and labels will be
drawn on the x-axis. See Details for possible values.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_minor.ticks">minor.ticks</code></td>
<td>
<p>period that specifies where minor ticks on will be drawn on
the x-axis. If <code>NULL</code>, minor ticks are not drawn. See Details for
possible values.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid.ticks.on">grid.ticks.on</code></td>
<td>
<p>period that specifies where vertical grid lines will be
drawn. See Details for possible values.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid.ticks.lwd">grid.ticks.lwd</code></td>
<td>
<p>line width of the grid</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid.ticks.lty">grid.ticks.lty</code></td>
<td>
<p>line type of the grid</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid.col">grid.col</code></td>
<td>
<p>color of the grid</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_labels.col">labels.col</code></td>
<td>
<p>color of the axis labels</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_format.labels">format.labels</code></td>
<td>
<p>label format to draw lower frequency x-axis ticks and labels passed to <code><a href="#topic+axTicksByTime">axTicksByTime</a></code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid2">grid2</code></td>
<td>
<p>color for secondary x axis grid</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_legend.loc">legend.loc</code></td>
<td>
<p>places a legend into one of nine locations on the chart:
bottomright, bottom, bottomleft, left, topleft, top, topright, right, or
center. Default NULL does not draw a legend.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_pch">pch</code></td>
<td>
<p>the plotting character to use, same as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_on">on</code></td>
<td>
<p>panel number to draw on. A new panel will be drawn if <code>on=NA</code>.
The default, <code>on=0</code>, will add to the active panel. The active panel is 
defined as the panel on which the most recent action was performed. Note that
only the first element of <code>on</code> is checked for the default behavior to
add to the last active panel.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_extend.xaxis">extend.xaxis</code></td>
<td>
<p>TRUE/FALSE (default FALSE). If TRUE, extend the x-axis
before and/or after the plot's existing time index range, so all of of the
time index values of the new series are included in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for arguments <code>major.ticks</code>, <code>minor.ticks</code>,
and <code>grid.ticks.on</code> include &lsquo;auto&rsquo;, &lsquo;minute&rsquo;,
&lsquo;hours&rsquo;, &lsquo;days&rsquo;, &lsquo;weeks&rsquo;, &lsquo;months&rsquo;,
&lsquo;quarters&rsquo;, and &lsquo;years&rsquo;. The default is &lsquo;auto&rsquo;, which
attempts to determine sensible locations from the periodicity and locations
of observations. The other values are based on the possible values for the
<code>ticks.on</code> argument of <code><a href="#topic+axTicksByTime">axTicksByTime</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>References</h3>

<p>based on <code>chart_Series</code> in the <code>quantmod</code> package by Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addSeries">addSeries</a></code>, <code><a href="#topic+addPanel">addPanel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix)

# plot the Close
plot(sample.xts[,"Close"])

# plot a subset of the data
plot(sample.xts[,"Close"], subset="2007-04-01/2007-06-31")

# function to compute simple returns
simple.ret &lt;- function(x, col.name){
  x[,col.name] / lag(x[,col.name]) - 1
}

# plot the close and add a panel with the simple returns
plot(sample.xts[,"Close"])
R &lt;- simple.ret(sample.xts, "Close")
lines(R, type="h", on=NA)

# add the 50 period simple moving average to panel 1 of the plot
library(TTR)
lines(SMA(sample.xts[,"Close"], n = 50), on=1, col="blue")

# add month end points to the chart
points(sample.xts[endpoints(sample.xts[,"Close"], on = "months"), "Close"], 
       col="red", pch=17, on=1)

# add legend to panel 1
addLegend("topright", on=1, 
          legend.names = c("Close", "SMA(50)"), 
          lty=c(1, 1), lwd=c(2, 1),
          col=c("black", "blue", "red"))

## End(Not run)
</code></pre>

<hr>
<h2 id='print.xts'> Print An xts Time-Series Object </h2><span id='topic+print.xts'></span>

<h3>Description</h3>

<p>Method for printing an extensible time-series object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
print(x, fmt, ..., show.rows = 10, max.rows = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.xts_+3A_x">x</code></td>
<td>
<p> An xts object </p>
</td></tr>
<tr><td><code id="print.xts_+3A_fmt">fmt</code></td>
<td>
<p> Passed to <code><a href="zoo.html#topic+coredata">coredata</a></code> to format the time index </p>
</td></tr>
<tr><td><code id="print.xts_+3A_...">...</code></td>
<td>
<p> Arguments passed to other methods </p>
</td></tr>
<tr><td><code id="print.xts_+3A_show.rows">show.rows</code></td>
<td>
<p> The number of first and last rows to print if the number of
rows is truncated (default 10, or <code>getOption("xts.print.show.rows")</code>) </p>
</td></tr>
<tr><td><code id="print.xts_+3A_max.rows">max.rows</code></td>
<td>
<p> The output will contain at most <code>max.rows</code> rows before
being truncated (default 100, or <code>getOption("xts.print.max.rows")</code>) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>Author(s)</h3>

<p> Joshua M. Ulrich </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix)

# output is truncated and shows first and last 10 observations
print(sample.xts)

# show the first and last 5 observations
print(sample.xts, show.rows = 5)
</code></pre>

<hr>
<h2 id='rbind.xts'> Concatenate Two or More xts Objects by Row </h2><span id='topic+rbind.xts'></span><span id='topic+c.xts'></span>

<h3>Description</h3>

<p>Concatenate or bind by row two or more xts objects
along a time-based index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
c(...)

## S3 method for class 'xts'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.xts_+3A_...">...</code></td>
<td>
<p> objects to bind </p>
</td></tr>
<tr><td><code id="rbind.xts_+3A_deparse.level">deparse.level</code></td>
<td>
<p> not implemented </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented in C, these functions bind <code>xts</code> objects
by row, resulting in another <code>xts</code> object
</p>
<p>There may be non-unique index
values in either the original series, or
the resultant series. 
</p>
<p>Identical indexed series are bound in the order
or the arguments passed to rbind. See examples.
</p>
<p>All objects must have the same number of
columns, as well as be <code>xts</code> objects
or coercible to such.
</p>
<p><code>rbind</code> and <code>c</code> are aliases.
</p>
<p>For traditional merge operations, see <code>merge.xts</code> and
<code>cbind.xts</code>.
</p>


<h3>Value</h3>

<p>An <code>xts</code> object with one row per row
for each object concatenated.
</p>


<h3>Note</h3>

 
<p>This differs from rbind.zoo in that non-unique index values are allowed,
in addition to the completely different algorithms used internally.
</p>
<p>All operations may not behave as expected on objects with non-unique
indices.  You have been warned.
</p>
<p><code>rbind</code> is a .Primitive function in <span class="rlang"><b>R</b></span>. As such
method dispatch occurs at the C-level, and may not be
consistent with expectations.  See the details section
of the base function, and if needed call rbind.xts directly
to avoid dispatch ambiguity.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="#topic+merge.xts">merge.xts</a></code>
<code><a href="base.html#topic+rbind">rbind</a></code>   </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xts(1:10, Sys.Date()+1:10)
str(x)

merge(x,x)
rbind(x,x)
rbind(x[1:5],x[6:10])

c(x,x)

# this also works on non-unique index values
x &lt;- xts(rep(1,5), Sys.Date()+c(1,2,2,2,3))
y &lt;- xts(rep(2,3), Sys.Date()+c(1,2,3))

# overlapping indexes are appended
rbind(x,y)
rbind(y,x)

</code></pre>

<hr>
<h2 id='sample_matrix'> Sample Data Matrix For xts Example and Unit Testing </h2><span id='topic+sample_matrix'></span>

<h3>Description</h3>

<p>Simulated 180 observations on 4 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample_matrix)</code></pre>


<h3>Format</h3>

<pre>
  The format is:
 num [1:180, 1:4] 50.0 50.2 50.4 50.4 50.2 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:180] "2007-01-02" "2007-01-03" "2007-01-04" "2007-01-05" ...
  ..$ : chr [1:4] "Open" "High" "Low" "Close"
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(.sample.matrix)
</code></pre>

<hr>
<h2 id='split.xts'>
Divide into Groups by Time
</h2><span id='topic+split.xts'></span>

<h3>Description</h3>

<p>Creates a list of xts objects split along
time periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
split(x, f = "months", drop=FALSE, k = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.xts_+3A_x">x</code></td>
<td>

<p>an xts object
</p>
</td></tr>
<tr><td><code id="split.xts_+3A_f">f</code></td>
<td>

<p>a 'character' vector describing the period to split by
</p>
</td></tr>
<tr><td><code id="split.xts_+3A_drop">drop</code></td>
<td>

<p>ignored by split.xts
</p>
</td></tr>
<tr><td><code id="split.xts_+3A_k">k</code></td>
<td>

<p>number of periods to aggregate into each split. See Details.
</p>
</td></tr>
<tr><td><code id="split.xts_+3A_...">...</code></td>
<td>

<p>further args to non-xts method
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A quick way to break up a large xts
object by standard time periods; e.g. 'months', 'quarters', etc.
</p>
<p><code>endpoints</code> is used to find the start and end of
each period (or k-periods).  See that function for valid
arguments.
</p>
<p>If <code>f</code> is not a character vector, the NextMethod is
called, which would in turn dispatch to the split.zoo method.
</p>


<h3>Value</h3>

<p>A list of xts objects.
</p>


<h3>Note</h3>

<p><code>aggregate.zoo</code> would be more flexible, though not as fast
for xts objects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endpoints">endpoints</a></code>, 
<code><a href="zoo.html#topic+split.zoo">split.zoo</a></code>, 
<code><a href="zoo.html#topic+aggregate.zoo">aggregate.zoo</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample_matrix)
x &lt;- as.xts(sample_matrix)


split(x)
split(x, f="weeks")
split(x, f="weeks", k=4)
</code></pre>

<hr>
<h2 id='tclass'> Get or Replace the Class of an xts Object's Index </h2><span id='topic+tclass'></span><span id='topic+tclass+3C-'></span><span id='topic+tclass.xts'></span><span id='topic+tclass+3C-.xts'></span><span id='topic+indexClass'></span><span id='topic+indexClass+3C-'></span>

<h3>Description</h3>

<p>Generic functions to get or replace the class of an xts object's index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclass(x, ...)
tclass(x) &lt;- value

## S3 method for class 'xts'
tclass(x, ...)
## S3 replacement method for class 'xts'
tclass(x) &lt;- value

##### The functions below are DEPRECATED #####
indexClass(x)
indexClass(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tclass_+3A_x">x</code></td>
<td>
<p> an <code>xts</code> object </p>
</td></tr>
<tr><td><code id="tclass_+3A_value">value</code></td>
<td>
<p> new index class (see Details for valid values) </p>
</td></tr>
<tr><td><code id="tclass_+3A_...">...</code></td>
<td>
<p> arguments passed to other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, an xts object's index is a <em>numeric</em> value corresponding to
seconds since the epoch in the UTC timezone. The index class is stored as the
<code>tclass</code> attribute on the internal index. This is used to convert the
internal index values to the desired class when the <code>index</code> function is
called.
</p>
<p>The <code>tclass</code> function retrieves the class of the internal index, and the
<code>tclass&lt;-</code> function sets it. The specified value for <code>tclass&lt;-</code> must
be one of the following character strings: <code>"Date"</code>, <code>"POSIXct"</code>,
<code>"chron"</code>, <code>"yearmon"</code>, <code>"yearqtr"</code>, or <code>"timeDate"</code>.
</p>


<h3>Value</h3>

<p>A vector containing the class of the object's index.
</p>


<h3>Note</h3>

<p>Both <code>indexClass</code> and <code>indexClass&lt;-</code> are deprecated in favor of
<code>tclass</code> and <code>tclass&lt;-</code>, respectively.
</p>
<p>Replacing the <code>tclass</code> <em>does not</em> change the values of the internal
index. See the examples.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+index">index</a></code> has more information on the xts index, <code><a href="#topic+tformat">tformat</a></code>
details how the index values are formatted when printed, <code><a href="#topic+tzone">tzone</a></code>
has more information about the index timezone settings.
</p>
<p>The following help pages describe the characteristics of the valid index
classes: <code><a href="base.html#topic+POSIXct">POSIXct</a></code>, <code><a href="base.html#topic+Date">Date</a></code>, <code><a href="chron.html#topic+chron">chron</a></code>,
<code><a href="zoo.html#topic+yearmon">yearmon</a></code>, <code><a href="zoo.html#topic+yearqtr">yearqtr</a></code>,
<code><a href="timeDate.html#topic+timeDate">timeDate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- timeBasedSeq('2010-01-01/2010-01-02 12:00')
x &lt;- xts(seq_along(x), x)


y &lt;- timeBasedSeq('2010-01-01/2010-01-03 12:00/H')
y &lt;- xts(seq_along(y), y, tzone = "America/New_York")

# Changing the tclass does not change the internal index values, but it
# does change how the index is printed!
head(y)    # the index has times
.index(y)
tclass(y) &lt;- "Date"
head(y)    # the index prints without times, but
.index(y)  # the internal index is not changed!
</code></pre>

<hr>
<h2 id='tformat'> Get or Replace the Format of an xts Object's Index </h2><span id='topic+tformat'></span><span id='topic+tformat+3C-'></span><span id='topic+tformat.xts'></span><span id='topic+tformat+3C-.xts'></span><span id='topic+indexFormat'></span><span id='topic+indexFormat+3C-'></span>

<h3>Description</h3>

<p>Generic functions to get or replace the format that determines how an xts
object's index is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tformat(x, ...)
tformat(x) &lt;- value

## S3 method for class 'xts'
tformat(x, ...)
## S3 replacement method for class 'xts'
tformat(x) &lt;- value

##### The functions below are DEPRECATED #####
indexFormat(x)
indexFormat(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tformat_+3A_x">x</code></td>
<td>
<p> an <code>xts</code> object </p>
</td></tr>
<tr><td><code id="tformat_+3A_value">value</code></td>
<td>
<p> new index format string (see Details for valid values) </p>
</td></tr>
<tr><td><code id="tformat_+3A_...">...</code></td>
<td>
<p> arguments passed to other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid values for the <code>value</code> argument are the same as specified in the
<em>Details</em> section of <code><a href="base.html#topic+strptime">strptime</a></code>.
</p>
<p>An xts object's <code>tformat</code> is <code>NULL</code> by default, so the index will be
formatted according to its <code><a href="#topic+tclass">tclass</a></code> (e.g. <code>Date</code>,
<code>POSIXct</code>, <code>timeDate</code>, <code>yearmon</code>, etc.).
</p>
<p><code>tformat</code> only changes how the index is <em>printed</em> and how the row
names are formatted when xts objects are converted to other classes (e.g.
<code>matrix</code> or <code>data.frame</code>. It does not affect the internal index
in any way.
</p>


<h3>Value</h3>

<p>A vector containing the format for the object's index.
</p>


<h3>Note</h3>

<p>Both <code>indexFormat</code> and <code>indexFormat&lt;-</code> are deprecated in favor of
<code>tformat</code> and <code>tformat&lt;-</code>, respectively.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+index">index</a></code> has more information on the xts index, <code><a href="#topic+tclass">tclass</a></code>
details how <span class="pkg">xts</span> handles the class of the index, <code><a href="#topic+tzone">tzone</a></code> has
more information about the index timezone settings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- timeBasedSeq('2010-01-01/2010-01-02 12:00')
  x &lt;- xts(seq_along(x), x)

  # set a custom index format
  head(x)
  tformat(x) &lt;- "%Y-%b-%d %H:%M:%OS3"
  head(x)
</code></pre>

<hr>
<h2 id='timeBased'> Check if Class is Time-Based </h2><span id='topic+timeBased'></span><span id='topic+is.timeBased'></span>

<h3>Description</h3>

<p>Used to verify that the object is one of the
known time-based classes in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.timeBased(x)
timeBased(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeBased_+3A_x">x</code></td>
<td>
<p> object to test </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current time-based objects supported are
<code>Date</code>, <code>POSIXct</code>, <code>chron</code>,
<code>yearmon</code>, <code>yearqtr</code>, and <code>timeDate</code>.
</p>


<h3>Value</h3>

<p>Logical
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>Examples</h3>

<pre><code class='language-R'>timeBased(Sys.time())
timeBased(Sys.Date())

timeBased(200701)
</code></pre>

<hr>
<h2 id='timeBasedSeq'> Create a Sequence or Range of Times </h2><span id='topic+timeBasedSeq'></span><span id='topic+timeBasedRange'></span>

<h3>Description</h3>

<p>A function to create a vector of time-based objects
suitable for indexing an <em>xts</em> object,
given a string conforming to the ISO 8601 time
and date standard for range-based specification. The
resultant series can be of any class supported by
<em>xts</em>, including POSIXct, Date, chron, timeDate,
yearmon, and yearqtr.
</p>
<p><code>timeBasedRange</code> creates a vector of length 1 or 2
as seconds since the epoch (1970-01-01) for use
internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeBasedSeq(x, retclass = NULL, length.out = NULL)

timeBasedRange(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeBasedSeq_+3A_x">x</code></td>
<td>
<p> a string representing the time-date range desired </p>
</td></tr>
<tr><td><code id="timeBasedSeq_+3A_retclass">retclass</code></td>
<td>
<p> the return class desired </p>
</td></tr>
<tr><td><code id="timeBasedSeq_+3A_length.out">length.out</code></td>
<td>
<p> passed to <code>seq</code> internally </p>
</td></tr>
<tr><td><code id="timeBasedSeq_+3A_...">...</code></td>
<td>
<p> unused </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designed to provide uniform creation of valid
time-based objects for use within <em>xts</em>, the
interface conforms (mostly) to the ISO recommended
format for specifying ranges.
</p>
<p>In general, the format is a string specifying
a time and/or date <em>from</em>, <em>to</em>, and
optionally <em>by</em> delineated by
either &lsquo;&quot;/&quot;&rsquo; or &lsquo;&quot;::&quot;&rsquo;.
</p>
<p>The first argument need not be quoted, as it is
converted internally if need be.
</p>
<p>The general form is <em>from/to/by</em> or
<em>from::to::by</em>, where <em>to</em> and <em>by</em>
are optional if the length.out arg is specified.
</p>
<p>The <code>from</code> and <code>to</code> elements of the string
must be left-specified with respect to the standard
<em>CCYYMMDD HHMMSS</em> form.  All dates-times
specified will be set to either the earliest point (from)
or the latest (to), given the level of specificity.
</p>
<p>For example &lsquo;1999&rsquo; in the <em>from</em> field
would set the start to the beginning of 1999. The opposite
occurs in the <em>to</em> field.
</p>
<p>The level of detail in the request is interpretted as the
level of detail in the result.  The maximum detail of either
<em>from</em> or <em>to</em> is the basis of the sequence, unless
the optional <em>by</em> element is specified, which will be covered later.
</p>
<p>To request a yearly series, it is only necessary to
use &lsquo;&quot;1999/2008&quot;&rsquo;.  Alternately, one could
request a monthly series (returned by default as
class <code>yearmon</code>) with &lsquo;&quot;199901/2008&quot;&rsquo; or
&lsquo;&quot;1999-01/2008&quot;&rsquo;, or even &lsquo;&quot;1999/2008-01&quot;&rsquo;.
As the level of granularity increases, so does the
resultant sequence granularity - as does its length.
</p>
<p>Using the optional third <em>by</em> field (the third
delimited element to the string), will override the
granularity intepretation and return the requested
periodicity.  The acceptable arguments include
<code>Y</code> for years, <code>m</code> for months, <code>d</code> for
days, <code>H</code> for hours, <code>M</code> for minutes and <code>S</code> for
seconds.
</p>


<h3>Value</h3>

<p>A sequence or range of time-based objects.
</p>
<p>If <code>retclass</code> is <code>NULL</code>, the result is a named
list of from, to, by and length.out.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>References</h3>

<p> International Organization for Standardization: ISO 8601
<a href="https://www.iso.org">https://www.iso.org</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+timeBased">timeBased</a></code>, <code><a href="#topic+xts">xts</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>timeBasedSeq('1999/2008')
timeBasedSeq('199901/2008')
timeBasedSeq('199901/2008/d')
timeBasedSeq('20080101 0830',length=100) # 100 minutes
timeBasedSeq('20080101 083000',length=100) # 100 seconds
</code></pre>

<hr>
<h2 id='to.period'> Convert time series data to an OHLC series </h2><span id='topic+to.period'></span><span id='topic+to_period'></span><span id='topic+to.minutes'></span><span id='topic+to.minutes3'></span><span id='topic+to.minutes5'></span><span id='topic+to.minutes10'></span><span id='topic+to.minutes15'></span><span id='topic+to.minutes30'></span><span id='topic+to.hourly'></span><span id='topic+to.daily'></span><span id='topic+to.weekly'></span><span id='topic+to.monthly'></span><span id='topic+to.quarterly'></span><span id='topic+to.yearly'></span><span id='topic+OHLC'></span>

<h3>Description</h3>

<p>Convert an OHLC or univariate object to a specified periodicity lower
than the given data object. For example, convert a daily
series to a monthly series, or a monthly series to a yearly one,
or a one minute series to an hourly series.
</p>
<p>The result will contain the open and close for the
given period, as well as the maximum and minimum over the
new period, reflected in the new high and low, respectively.
</p>
<p>If volume for a period was available, the new volume will also be
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.minutes(x,k,name,...)
to.minutes3(x,name,...)
to.minutes5(x,name,...)
to.minutes10(x,name,...)
to.minutes15(x,name,...)
to.minutes30(x,name,...)
to.hourly(x,name,...)
to.daily(x,drop.time=TRUE,name,...)

to.weekly(x,drop.time=TRUE,name,...)
to.monthly(x,indexAt='yearmon',drop.time=TRUE,name,...)
to.quarterly(x,indexAt='yearqtr',drop.time=TRUE,name,...)
to.yearly(x,drop.time=TRUE,name,...)

to.period(x,
          period = 'months', 
          k = 1, 
          indexAt, 
          name=NULL,
          OHLC = TRUE,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.period_+3A_x">x</code></td>
<td>
<p> a univariate or OHLC type time-series object </p>
</td></tr> 
<tr><td><code id="to.period_+3A_period">period</code></td>
<td>
<p> period to convert to. See details. </p>
</td></tr>
<tr><td><code id="to.period_+3A_indexat">indexAt</code></td>
<td>
<p> convert final index to new class or date. See details </p>
</td></tr>
<tr><td><code id="to.period_+3A_drop.time">drop.time</code></td>
<td>
<p> remove time component of POSIX datestamp (if any) </p>
</td></tr>
<tr><td><code id="to.period_+3A_k">k</code></td>
<td>
<p> number of sub periods to aggregate on (only for minutes and seconds) </p>
</td></tr>
<tr><td><code id="to.period_+3A_name">name</code></td>
<td>
<p> override column names </p>
</td></tr>
<tr><td><code id="to.period_+3A_ohlc">OHLC</code></td>
<td>
<p> should an OHLC object be returned? (only <code>OHLC=TRUE</code> currently supported) </p>
</td></tr>
<tr><td><code id="to.period_+3A_...">...</code></td>
<td>
<p> additional arguments </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially an easy and reliable way to convert one periodicity of data
into any new periodicity. It is important to note
that all dates will be aligned to the <em>end</em> of each period
by default - with the exception of <code>to.monthly</code> and <code>to.quarterly</code>,
which index by &lsquo;yearmon&rsquo; and &lsquo;yearqtr&rsquo; from the <span class="pkg">zoo</span>
package, respectively.
</p>
<p>Valid period character strings include: <code>"seconds"</code>, 
<code>"minutes"</code>, <code>"hours"</code>, <code>"days"</code>, <code>"weeks"</code>,
<code>"months"</code>, <code>"quarters"</code>, and <code>"years"</code>. These are
calculated internally via <code>endpoints</code>. See that function's help
page for further details.
</p>
<p>To adjust the final indexing style, it is possible to set
<code>indexAt</code> to one of the following: &lsquo;yearmon&rsquo;,
&lsquo;yearqtr&rsquo;, &lsquo;firstof&rsquo;, &lsquo;lastof&rsquo;,
&lsquo;startof&rsquo;, or &lsquo;endof&rsquo;.  The final index will
then be <code>yearmon</code>, <code>yearqtr</code>, the first time of the period,
the last time of the period, the starting time in the data for that
period, or the ending time in the data for that period, respectively.
</p>
<p>It is also possible to pass a single time series, such as
a univariate exchange rate, and return an OHLC object of
lower frequency - e.g. the weekly OHLC of the daily series.
</p>
<p>Setting <code>drop.time</code> to <code>TRUE</code> (the default)
will convert a series that includes a time
component into one with just a date index, as the time index
is often of little value in lower frequency series.
</p>
<p>It is not possible to convert a series from a lower periodicity
to a higher periodicity - e.g. weekly to daily or
daily to 5 minute bars, as that would
require magic.
</p>


<h3>Value</h3>

<p>An object of the original type, with new periodicity.
</p>


<h3>Note</h3>

<p>In order for this function to  work properly on OHLC data, it is necessary
that the Open, High, Low and Close columns be names as such; including
the first letter capitalized and the full spelling found.  Internally
a call is made to reorder the data into the correct column order,
and then a verification step to make sure that this ordering and naming
has succeeded. All other data formats must be aggregated with functions
such as <code>aggregate</code> and <code>period.apply</code>.
</p>
<p>This method should work on almost all time-series-like
objects. Including &lsquo;timeSeries&rsquo;, &lsquo;zoo&rsquo;,
&lsquo;ts&rsquo;, and &lsquo;irts&rsquo;. It is even likely
to work well for other data structures - including &lsquo;data.frames&rsquo;
and &lsquo;matrix&rsquo; objects.
</p>
<p>Internally a call to <code>as.xts</code> converts the original <code>x</code>
into the universal <code>xts</code> format, and then re-converts back
to the original type.
</p>
<p>A special note with respect to &lsquo;ts&rsquo; objects. As these are
strictly regular they may include <code>NA</code> values.  These are
stripped for aggregation purposes, though replaced before returning.
This inevitably leads to many, many additional &lsquo;NA&rsquo; values
in the data. It is more beneficial to consider using an &lsquo;xts&rsquo;
object originally, or converting to one in the function call by means
of <code>as.xts</code>.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample_matrix)

samplexts &lt;- as.xts(sample_matrix)

to.monthly(samplexts)
to.monthly(sample_matrix)

str(to.monthly(samplexts))
str(to.monthly(sample_matrix))
</code></pre>

<hr>
<h2 id='tzone'> Get or Replace the Timezone of an xts Object's Index </h2><span id='topic+tzone'></span><span id='topic+tzone+3C-'></span><span id='topic+tzone.xts'></span><span id='topic+tzone+3C-.xts'></span><span id='topic+indexTZ'></span><span id='topic+indexTZ+3C-'></span><span id='topic+TimeZone'></span>

<h3>Description</h3>

<p>Generic functions to get or replace the timezone of an xts object's index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tzone(x, ...)
tzone(x) &lt;- value

## S3 method for class 'xts'
tzone(x, ...)
## S3 replacement method for class 'xts'
tzone(x) &lt;- value

##### The functions below are DEPRECATED #####
indexTZ(x, ...)
indexTZ(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tzone_+3A_x">x</code></td>
<td>
<p> an <code>xts</code> object </p>
</td></tr>
<tr><td><code id="tzone_+3A_value">value</code></td>
<td>
<p> a valid timezone value (see <code>OlsonNames()</code>) </p>
</td></tr>
<tr><td><code id="tzone_+3A_...">...</code></td>
<td>
<p> arguments passed to other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, an xts object's index is a <em>numeric</em> value corresponding to
seconds since the epoch in the UTC timezone. When an xts object is created, all
time index values are converted internally to <code><a href="base.html#topic+POSIXct">POSIXct</a></code> (which is
also in seconds since the UNIX epoch), using the underlying OS conventions and
the <span class="env">TZ</span> environment variable. The <code>xts()</code> function manages timezone
information as transparently as possible.
</p>
<p>The <code>tzone&lt;-</code> function <em>does not</em> change the internal index values
(i.e. the index will remain the same time in the UTC timezone).
</p>


<h3>Value</h3>

<p>A one element named vector containing the timezone of the object's index.
</p>


<h3>Note</h3>

<p>Both <code>indexTZ</code> and <code>indexTZ&lt;-</code> are deprecated in favor of
<code>tzone</code> and <code>tzone&lt;-</code>, respectively.
</p>
<p>Problems may arise when an object that had been created under one timezone are
used in a session using another timezone. This isn't usually a issue, but when
it is a warning is given upon printing or subsetting. This warning may be
suppressed by setting <code>options(xts_check_TZ = FALSE)</code>.
</p>


<h3>Note</h3>

<p>Both <code>indexTZ</code> and <code>indexTZ&lt;-</code> are deprecated in favor of
<code>tzone</code> and <code>tzone&lt;-</code>, respectively.
</p>
<p>Timezones are a difficult issue to manage. It's best to set the system <span class="env">TZ</span>
environment variable to &quot;GMT&quot; or &quot;UTC&quot; (via <code>Sys.setenv(TZ = "UTC")</code> at
the beginning of your scripts if you do not need intra-daily resolution.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+POSIXt">POSIXt</a></code>
<code><a href="zoo.html#topic+index">index</a></code> has more information on the xts index,
<code><a href="#topic+tformat">tformat</a></code> describes how the index values are formatted when printed,
and <code><a href="#topic+tclass">tclass</a></code> provides details how <span class="pkg">xts</span> handles the class of
the index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Date indexes always have a "UTC" timezone
x &lt;- xts(1, Sys.Date())
tzone(x)
str(x)
print(x)

# The default 'tzone' is blank -- your machine's local timezone,
# determined by the 'TZ' environment variable.
x &lt;- xts(1, Sys.time())
tzone(x)
str(x)

# now set 'tzone' to different values
tzone(x) &lt;- "UTC"
str(x)

tzone(x) &lt;- "America/Chicago"
str(x)

y &lt;- timeBasedSeq('2010-01-01/2010-01-03 12:00/H')
y &lt;- xts(seq_along(y), y, tzone = "America/New_York")

# Changing the tzone does not change the internal index values, but it
# does change how the index is printed!
head(y)
head(.index(y))
tzone(y) &lt;- "Europe/London"
head(y)          # the index prints with hours, but
head(.index(y))  # the internal index is not changed!
</code></pre>

<hr>
<h2 id='window.xts'>Extract time windows from an <code>xts</code> series</h2><span id='topic+window.xts'></span>

<h3>Description</h3>

<p>Method for extracting time windows from <code>xts</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
window(x, index. = NULL, start = NULL, end = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window.xts_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="window.xts_+3A_index.">index.</code></td>
<td>
<p>a user defined time index. This defaults to the <code>xts</code>
index for the series via <code>.index(x)</code>. When supplied, this is typically
a subset of the dates in the full series.<br />
The <code>index.</code> must be a set of dates that are convertible to
<code>POSIXct</code>. If you want fast lookups, then <code>index.</code> should be
sorted and of class <code>POSIXct</code>.<br />
If an unsorted <code>index.</code> is passed in, <code>window</code> will sort it.</p>
</td></tr>
<tr><td><code id="window.xts_+3A_start">start</code></td>
<td>
<p>a start time. Extract <code>xts</code> rows where <code>index. &gt;=
    start</code>. <code>start</code> may be any class that is convertible to
<code>POSIXct</code> such as a character variable in the format
&lsquo;YYYY-MM-DD&rsquo;.<br />
If <code>start</code> is <code>NULL</code> then all <code>index.</code> dates are matched.</p>
</td></tr>
<tr><td><code id="window.xts_+3A_end">end</code></td>
<td>
<p>an end time. Extract <code>xts</code> rows where <code>index. &lt;= end</code>.
<code>end</code> must be convertible to <code>POSIXct</code>. If <code>end</code> is
<code>NULL</code> then all <code>index.</code> dates are matched.</p>
</td></tr>
<tr><td><code id="window.xts_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The point of having <code>window</code> in addition to the regular subset function
is to have a fast way of extracting time ranges from an <code>xts</code> series. In
particular, this method will convert <code>start</code> and <code>end</code> to
<code>POSIXct</code> then do a binary lookup on the internal <code>xts</code> index to
quickly return a range of matching dates. With a user supplied <code>index.</code>,
a similarly fast invocation of <code>findInterval</code> is used so that large sets
of sorted dates can be retrieved quickly.
</p>


<h3>Value</h3>

<p>The matching time window is extracted.
</p>


<h3>Author(s)</h3>

<p> Corwin Joy </p>


<h3>See Also</h3>

<p><code><a href="#topic+subset.xts">subset.xts</a></code>,
<code><a href="base.html#topic+findInterval">findInterval</a></code>,
<code><a href="#topic+xts">xts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## xts example
x.date &lt;- as.Date(paste(2003, rep(1:4, 4:1), seq(1,19,2), sep = "-"))
x &lt;- xts(matrix(rnorm(20), ncol = 2), x.date)
x

window(x, start = "2003-02-01", end = "2003-03-01")
window(x, start = as.Date("2003-02-01"), end = as.Date("2003-03-01"))
window(x, index = x.date[1:6], start = as.Date("2003-02-01"))
window(x, index = x.date[c(4, 8, 10)])

## Assign to subset
window(x, index = x.date[c(4, 8, 10)]) &lt;- matrix(1:6, ncol = 2)
x
</code></pre>

<hr>
<h2 id='xts'> Create Or Test For An xts Time-Series Object </h2><span id='topic+xts'></span><span id='topic+.xts'></span><span id='topic+is.xts'></span>

<h3>Description</h3>

<p>Constructor function for creating an extensible time-series object.
</p>
<p><code>xts</code> is used to create an <code>xts</code> object from raw data inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xts(x = NULL,
    order.by = index(x),
    frequency = NULL,
    unique = TRUE,
    tzone = Sys.getenv("TZ"),
    ...)

.xts(x = NULL,
     index,
     tclass = c("POSIXct", "POSIXt"),
     tzone = Sys.getenv("TZ"),
     check = TRUE,
     unique = FALSE,
     ...)

is.xts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xts_+3A_x">x</code></td>
<td>
<p> an object containing the time series data </p>
</td></tr>
<tr><td><code id="xts_+3A_order.by">order.by</code></td>
<td>
<p> a corresponding vector of dates/times of a known time-based
class. See Details. </p>
</td></tr>
<tr><td><code id="xts_+3A_index">index</code></td>
<td>
<p> a corresponding <em>numeric</em> vector specified as seconds
since the UNIX epoch (1970-01-01 00:00:00.000) </p>
</td></tr>
<tr><td><code id="xts_+3A_frequency">frequency</code></td>
<td>
<p> numeric indicating frequency of <code>order.by</code>. See Details. </p>
</td></tr>
<tr><td><code id="xts_+3A_unique">unique</code></td>
<td>
<p> check the index for unique timestamps? </p>
</td></tr>
<tr><td><code id="xts_+3A_check">check</code></td>
<td>
<p> check that the index is ordered? </p>
</td></tr>
<tr><td><code id="xts_+3A_tclass">tclass</code></td>
<td>
<p> time class to use for the index. See <code><a href="#topic+tclass">tclass</a></code>. </p>
</td></tr>
<tr><td><code id="xts_+3A_tzone">tzone</code></td>
<td>
<p> time zone of the index (ignored indices without a time
component, e.g. Date, yearmon, yearqtr). See <code><a href="#topic+tzone">tzone</a></code>. </p>
</td></tr>
<tr><td><code id="xts_+3A_...">...</code></td>
<td>
<p> additional attributes to be added. See Details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>xts</code> object extends the S3 class <code>zoo</code> from the package of the
same name.
</p>
<p>The <code>xts()</code> constructor is the preferred way to create xts objects. It
performs several checks to ensure it returns a well-formed xts object. The
<code>.xts()</code> constructor is mainly for internal use. It is more efficient than
the regular <code>xts()</code> constructor because it doesn't perform as many
validity checks. Use it with caution.
</p>
<p>Similar to zoo objects, xts objects must have an ordered index.  While zoo
indexes cannot contain duplicate values, xts objects have optionally supported
duplicate index elements since version 0.5-0.  The <code>xts</code> class has one
additional requirement, the index must be a time-based class.  Currently
supported classes include: &lsquo;Date&rsquo;, &lsquo;POSIXct&rsquo;, &lsquo;timeDate&rsquo;,
as well as &lsquo;yearmon&rsquo; and &lsquo;yearqtr&rsquo; where the index values
remain unique.
</p>
<p>The uniqueness requirement was relaxed in version 0.5-0, but is still enforced
by default.  Setting <code>unique = FALSE</code> skips the uniqueness check and only
ensures that the index is ordered via the <code>isOrdered</code> function.
</p>
<p>As of version 0.10-0, xts no longer allows missing values in the index.  This
is because many xts functions expect all index values to be finite.  The most
important of these is <code>merge.xts</code>, which is used ubiquitously.  Missing
values in the index are usually the result of a date-time conversion error (e.g.
incorrect format, non-existent time due to daylight saving time, etc).  Because
of how non-finite numbers are represented, a missing timestamp will always be
at the end of the index (except if it is <code>-Inf</code>, which will be first).
</p>
<p>Another difference from <span class="pkg">zoo</span> is that xts object may carry additional
attributes that may be desired in individual time-series handling.
This includes the ability to augment the objects data with
meta-data otherwise not cleanly attachable to a standard zoo object.
</p>
<p>Examples of usage from finance may include the addition of data
for keeping track of sources, last-update times, financial
instrument descriptions or details, etc.
</p>
<p>The idea behind <code>xts</code> is to offer the user the ability to utilize
a standard zoo object, while providing an mechanism to customize
the object's meta-data, as well as create custom methods to handle
the object in a manner required by the user.
</p>
<p>Many xts-specific methods have been written to better handle the
unique aspects of xts.  These include, &lsquo;&quot;[&quot;&rsquo;, merge, cbind,
rbind, c, Ops, lag, diff, coredata, head and tail.  Additionally
there are xts specific methods for converting to/from R's different
time-series classes. 
</p>
<p>Subsetting via &quot;[&quot; methods offers the ability to specify dates by
range, if they are enclosed in quotes.  The style borrows from
python by creating ranges with a double colon &ldquo;&quot;::&quot;&rdquo; or &ldquo;&quot;/&quot;&rdquo; operator.  Each side of
the operator may be left blank, which would then default to the beginning
and end of the data, respectively.  To specify a subset of times,
it is only required that the time specified be in standard ISO format, with
some form of separation between the elements. The time must be &lsquo;left-filled&rsquo;,
that is to specify a full year one needs only to provide the year, a month would require
the full year and the integer of the month requested - e.g. '1999-01'.
This format would extend all the way down to seconds - e.g. '1999-01-01 08:35:23'.
Leading zeros are not necessary.  See the examples for more detail.
</p>
<p>Users may also extend the <code>xts</code> class to new classes to
allow for method overloading.
</p>
<p>Additional benefits derive from the use of <code><a href="#topic+as.xts">as.xts</a></code> and
<code><a href="#topic+reclass">reclass</a></code>, which allow for lossless two-way conversion
between common R time-series classes and the <code>xts</code> object
structure. See those functions for more detail. 
</p>


<h3>Value</h3>

<p>An S3 object of class <code>xts</code>. As it inherits and extends
the zoo class, all zoo methods remain valid.  Additional
attributes may be assigned and extracted via
<code>xtsAttributes</code>.
</p>


<h3>Note</h3>

 
<p>Most users will benefit the most by using the
<code>as.xts</code> and <code>reclass</code> functions to
automagically handle <em>all</em> data objects
as one would handle a <code>zoo</code> object.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan and Joshua M. Ulrich </p>


<h3>References</h3>

 <p><span class="pkg">zoo</span>: </p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.xts">as.xts</a></code>, <code><a href="zoo.html#topic+index">index</a></code>, <code><a href="#topic+tclass">tclass</a></code>,
<code><a href="#topic+tformat">tformat</a></code>, <code><a href="#topic+tzone">tzone</a></code>, <code><a href="#topic+xtsAttributes">xtsAttributes</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix, descr='my new xts object')

class(sample.xts)
str(sample.xts)

head(sample.xts)  # attribute 'descr' hidden from view
attr(sample.xts,'descr')

sample.xts['2007']  # all of 2007
sample.xts['2007-03/']  # March 2007 to the end of the data set
sample.xts['2007-03/2007']  # March 2007 to the end of 2007
sample.xts['/'] # the whole data set
sample.xts['/2007'] # the beginning of the data through 2007
sample.xts['2007-01-03'] # just the 3rd of January 2007
</code></pre>

<hr>
<h2 id='xtsAPI'> xts C API Documentation </h2><span id='topic+xtsAPI'></span>

<h3>Description</h3>

<p>This help file is to help in development of xts, as well
as provide some clarity and insight into its purpose and implementation.
</p>
<p>By Jeffrey A. Ryan, Dirk Eddelbuettel, and Joshua M. Ulrich
Last modified: 2018-05-02
Version: 0.10-3 and above
</p>
<p>At present the <span class="pkg">xts</span> API has publicly available
interfaces to the following functions (as defined in <code>xtsAPI.h</code>):
</p>
<pre>
Callable from other R packages:
  SEXP xtsIsOrdered(SEXP x, SEXP increasing, SEXP strictly)
  SEXP xtsNaCheck(SEXP x, SEXP check)
  SEXP xtsTry(SEXP x)
  SEXP xtsRbind(SEXP x, SEXP y, SEXP dup)
  SEXP xtsCoredata(SEXP x)
  SEXP xtsLag(SEXP x, SEXP k, SEXP pad)

Internal use functions:
  SEXP isXts(SEXP x)
  void copy_xtsAttributes(SEXP x, SEXP y)
  void copy_xtsCoreAttributes(SEXP x, SEXP y)

Internal use macros:
  xts_ATTRIB(x)
  xts_COREATTRIB(x)
  GET_xtsIndex(x)
  SET_xtsIndex(x,value)
  GET_xtsIndexFormat(x)
  SET_xtsIndexFormat(x,value)
  GET_xtsCLASS(x)
  SET_xtsCLASS(x,value)

Internal use SYMBOLS:
  xts_IndexSymbol
  xts_ClassSymbol
  xts_IndexFormatSymbol

Callable from R:
  SEXP mergeXts(SEXP args)
  SEXP rbindXts(SEXP args)
  SEXP tryXts(SEXP x)
</pre>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# some example code to look at

file.show(system.file('api_example/README', package="xts"))
file.show(system.file('api_example/src/checkOrder.c', package="xts"))

## End(Not run)
</code></pre>

<hr>
<h2 id='xtsAttributes'> Extract and Replace xts Attributes </h2><span id='topic+xtsAttributes'></span><span id='topic+xtsAttributes+3C-'></span>

<h3>Description</h3>

<p>Extract and replace non-core <code>xts</code> attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtsAttributes(x, user=NULL)

xtsAttributes(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtsAttributes_+3A_x">x</code></td>
<td>
<p> an xts object </p>
</td></tr>
<tr><td><code id="xtsAttributes_+3A_user">user</code></td>
<td>
<p> logical; should user-defined attributes be returned?
The default of <code>NULL</code> returns all <code>xts</code> attributes. </p>
</td></tr>
<tr><td><code id="xtsAttributes_+3A_value">value</code></td>
<td>
<p> a list of new name=value attributes </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since <code>xts</code> objects are S3 objects with special
attributes, a method is necessary to properly assign
and view the user-added attributes.
</p>
<p>A call to <code>attributes</code> from the <span class="pkg">base</span> package
will return all attributes, including those specific
to the <code>xts</code> class.
</p>


<h3>Value</h3>

<p>A named list of user settable attributes.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+attributes">attributes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xts(matrix(1:(9*6),nc=6),
         order.by=as.Date(13000,origin="1970-01-01")+1:9,
         a1='my attribute')

xtsAttributes(x)
xtsAttributes(x) &lt;- list(a2=2020)

xtsAttributes(x)
xtsAttributes(x) &lt;- list(a1=NULL)
xtsAttributes(x)
</code></pre>

<hr>
<h2 id='xtsInternals'> Internal Documentation </h2><span id='topic+.dimnames.xts'></span><span id='topic+dimnames.xts+3C-'></span>

<h3>Description</h3>

<p>This help file is to help in development of xts, as well
as provide some clarity and insight into its purpose and implementation.
</p>
<p>Last modified: 2008-08-06 by Jeffrey A. Ryan
Version: 0.5-0 and above
</p>
<p>The <span class="pkg">xts</span> package xts designed as a drop-in replacement
for the very popular <span class="pkg">zoo</span> package.  Most all functionality
of zoo has been extended or carries into the xts package.
</p>
<p>Notable changes in direction include the use of time-based
indexing, at first explicitely, now implicitely.
</p>
<p>An <code>xts</code> object consists of data in the form of a matrix,
an index - ordered and increasing, either numeric or integer, and additional
attributes for use internally, or for end-user purposes.
</p>
<p>The current implementation enforces two major rules on
the object.  One is that the index must be coercible to numeric, by
way of <code>as.POSIXct</code>.  There are defined types that meet this criteria.
See <code>timeBased</code> for details.
</p>
<p>The second requirement is that the object cannot have rownames.
The motivation from this comes in part from the work
Matthew Doyle has done in his data.table class, in the package of the
same name.  Rownames in <span class="rlang"><b>R</b></span> must be character vectors, and as such
are inefficient in both storage and conversion.  By eliminating
the rownames, and providing a numeric index of <span class="rlang"><b>R</b></span> internal type <code>REAL</code>
or <code>INTEGER</code>, it is possible to maintain a connection
to standard <span class="rlang"><b>R</b></span> date and time classes via the POSIXct functions, while at
at the same time maximizing efficiencies in data handling.
</p>
<p>User level functions <code>index</code>, as well as conversion to
other classes proceeds as if there were rownames.  The code
for <code>index</code> automatically converts time to numeric in both extraction
and replacement functionality. This provides a level of
abstraction to facilitate internal, and external package use and inter-operability.
</p>
<p>There is also new work on providing a C-level API to some of the
xts functionality to facilitate external package developers to
utilize the fast utility routines such as subsetting and merges, without
having to call only from <span class="rlang"><b>R</b></span>.  Obviously this places far
more burden on the developer to not only understand the
internal xts implementation, but also to understand all of
what is documented for R-internals (and much that isn't). At present the functions
and macros
available can be found in the &lsquo;xts.h&rsquo; file in the src directory.
</p>
<p>There is no current documentation for this API.  The adventure
starts here.  Future documentation is planned, not implemented.
</p>


<h3>Author(s)</h3>

<p> Jeffrey A. Ryan </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
