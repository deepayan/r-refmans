<!DOCTYPE html><html><head><title>Help for package xts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#xts-package'><p>xts: extensible time-series</p></a></li>
<li><a href='#.parseISO8601'><p>Internal ISO 8601:2004(e) Time Parser</p></a></li>
<li><a href='#+5B.xts'><p>Extract Subsets of xts Objects</p></a></li>
<li><a href='#addEventLines'><p>Add vertical lines to an existing xts plot</p></a></li>
<li><a href='#addLegend'><p>Add Legend</p></a></li>
<li><a href='#addPanel'><p>Add a panel to an existing xts plot</p></a></li>
<li><a href='#addPolygon'><p>Add a polygon to an existing xts plot</p></a></li>
<li><a href='#addSeries'><p>Add a time series to an existing xts plot</p></a></li>
<li><a href='#adj.time'><p>Align seconds, minutes, and hours to beginning of next period.</p></a></li>
<li><a href='#apply.daily'><p>Apply Function over Calendar Periods</p></a></li>
<li><a href='#as.environment.xts'><p>Coerce an xts Object to an Environment by Column</p></a></li>
<li><a href='#as.xts.Date'><p>Convert Objects To and From xts</p></a></li>
<li><a href='#axTicksByTime'><p>Compute x-Axis Tickmark Locations by Time</p></a></li>
<li><a href='#c.xts'><p>Concatenate Two or More xts Objects by Row</p></a></li>
<li><a href='#CLASS'><p>Extract and Set .CLASS Attribute</p></a></li>
<li><a href='#coredata.xts'><p>Extract/Replace Core Data of an xts Object</p></a></li>
<li><a href='#dimnames.xts'><p>Dimnames of an xts Object</p></a></li>
<li><a href='#endpoints'><p>Locate Endpoints by Time</p></a></li>
<li><a href='#first'><p>Return First or Last n Elements of A Data Object</p></a></li>
<li><a href='#firstof'><p>Create a POSIXct Object</p></a></li>
<li><a href='#index.xts'><p>Get and Replace the Class of an xts Index</p></a></li>
<li><a href='#indexTZ'><p>Get or Replace the Timezone of an xts Object's Index</p></a></li>
<li><a href='#is.index.unique'><p>Force Time Values To Be Unique</p></a></li>
<li><a href='#is.timeBased'><p>Check if Class is Time-Based</p></a></li>
<li><a href='#isOrdered'><p>Check If A Vector Is Ordered</p></a></li>
<li><a href='#lag.xts'><p>Lags and Differences of xts Objects</p></a></li>
<li><a href='#merge.xts'><p>Merge xts Objects</p></a></li>
<li><a href='#na.locf.xts'><p>Last Observation Carried Forward</p></a></li>
<li><a href='#nseconds'><p>Number of Periods in Data</p></a></li>
<li><a href='#period.apply'><p>Apply Function Over Specified Interval</p></a></li>
<li><a href='#period.sum'><p>Optimized Calculations By Period</p></a></li>
<li><a href='#periodicity'><p>Approximate Series Periodicity</p></a></li>
<li><a href='#plot.xts'><p>Plotting xts Objects</p></a></li>
<li><a href='#print.xts'><p>Print An xts Time-Series Object</p></a></li>
<li><a href='#sample_matrix'><p>Sample Data Matrix For xts Example and Unit Testing</p></a></li>
<li><a href='#split.xts'><p>Divide into Groups by Time</p></a></li>
<li><a href='#tclass'><p>Get or Replace the Class of an xts Object's Index</p></a></li>
<li><a href='#tformat'><p>Get or Replace the Format of an xts Object's Index</p></a></li>
<li><a href='#timeBasedRange'><p>Create a Sequence or Range of Times</p></a></li>
<li><a href='#to.period'><p>Convert time series data to an OHLC series</p></a></li>
<li><a href='#try.xts'><p>Convert Objects to xts and Back to Original Class</p></a></li>
<li><a href='#window.xts'><p>Extract Time Windows from xts Objects</p></a></li>
<li><a href='#xts'><p>Create or Test For An xts Time-Series Object</p></a></li>
<li><a href='#xts-internals'><p>Internal Documentation</p></a></li>
<li><a href='#xtsAPI'><p>xts C API Documentation</p></a></li>
<li><a href='#xtsAttributes'><p>Extract and Replace xts Attributes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>eXtensible Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.14.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), zoo (&ge; 1.7-12)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>timeSeries, timeDate, tseries, chron, tinytest</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide for uniform handling of R's different time-based data classes by extending zoo, maximizing native format information preservation and allowing for user level customization and extension, while simplifying cross-class interoperability.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://joshuaulrich.github.io/xts/">https://joshuaulrich.github.io/xts/</a>,
<a href="https://github.com/joshuaulrich/xts">https://github.com/joshuaulrich/xts</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/joshuaulrich/xts/issues">https://github.com/joshuaulrich/xts/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-05 18:39:54 UTC; josh</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey A. Ryan [aut, cph],
  Joshua M. Ulrich [cre, aut],
  Ross Bennett [ctb],
  Corwin Joy [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua M. Ulrich &lt;josh.m.ulrich@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-05 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='xts-package'>xts: extensible time-series</h2><span id='topic+xts-package'></span>

<h3>Description</h3>

<p>Extensible time series class and methods, extending and behaving like zoo.
</p>


<h3>Details</h3>

<p>Easily convert one of <span class="rlang"><b>R</b></span>'s many time-series (and non-time-series) classes to a
true time-based object which inherits all of zoo's methods, while allowing
for new time-based tools where appropriate.
</p>
<p>Additionally, one may use <span class="pkg">xts</span> to create new objects which can contain
arbitrary attributes named during creation as name=value pairs.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan and Joshua M. Ulrich
</p>
<p>Maintainer: Joshua M. Ulrich <a href="mailto:josh.m.ulrich@gmail.com">josh.m.ulrich@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xts">xts()</a></code>, <code><a href="#topic+as.xts">as.xts()</a></code>, <code><a href="#topic+reclass">reclass()</a></code>, <code><a href="zoo.html#topic+zoo">zoo()</a></code>
</p>

<hr>
<h2 id='.parseISO8601'>Internal ISO 8601:2004(e) Time Parser</h2><span id='topic+.parseISO8601'></span><span id='topic+ISO8601'></span><span id='topic+parseISO8601'></span>

<h3>Description</h3>

<p>This function replicates most of the ISO standard for parsing times and
time-based ranges in a universally accepted way. The best documentation is
the official ISO page as well as the Wikipedia entry for ISO 8601:2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parseISO8601(x, start, end, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".parseISO8601_+3A_x">x</code></td>
<td>
<p>A character string conforming to the ISO 8601:2004(e) rules.</p>
</td></tr>
<tr><td><code id=".parseISO8601_+3A_start">start</code></td>
<td>
<p>Lower constraint on range.</p>
</td></tr>
<tr><td><code id=".parseISO8601_+3A_end">end</code></td>
<td>
<p>Upper constraint of range</p>
</td></tr>
<tr><td><code id=".parseISO8601_+3A_tz">tz</code></td>
<td>
<p>Timezone (tzone) to use internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea is to create the endpoints of a range, given a string
representation. These endpoints are aligned in POSIXct time to the zero
second of the day at the beginning, and the 59.9999th second of the 59th
minute of the 23rd hour of the final day.
</p>
<p>For dates prior to the epoch (1970-01-01) the ending time is aligned to the
59.0000 second. This is due to a bug/feature in the <span class="rlang"><b>R</b></span> implementation of
<code>as.POSIXct()</code> and <code>mktime0()</code> at the C-source level. This limits the
precision of ranges prior to 1970 to 1 minute granularity with the current
<span class="pkg">xts</span> workaround.
</p>
<p>Recurring times over multiple days may be specified using the &quot;T&quot; notation.
See the examples for details.
</p>


<h3>Value</h3>

<p>A two element list with an entry named &lsquo;first.time&rsquo; and
one named &lsquo;last.time&rsquo;.
</p>


<h3>Note</h3>

<p>There is no checking done to test for a properly constructed ISO
format string. This must be correctly entered by the user.
</p>
<p>When using durations, it is important to note that the time of the duration
specified is not necessarily the same as the realized periods that may be
returned when applied to an irregular time series. This is not a bug, it is
a standards and implementation gotcha.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/ISO_8601">https://en.wikipedia.org/wiki/ISO_8601</a><br />
<a href="https://www.iso.org/iso-8601-date-and-time-format.html">https://www.iso.org/iso-8601-date-and-time-format.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the start and end of 2000
.parseISO8601('2000')

# the start of 2000 and end of 2001
.parseISO8601('2000/2001')

# May 1, 2000 to Dec 31, 2001
.parseISO8601('2000-05/2001')

# May 1, 2000 to end of Feb 2001
.parseISO8601('2000-05/2001-02')

# Jan 1, 2000 to Feb 29, 2000; note the truncated time on the LHS
.parseISO8601('2000-01/02')

# 8:30 to 15:00 (used in xts subsetting to extract recurring times)
.parseISO8601('T08:30/T15:00')

</code></pre>

<hr>
<h2 id='+5B.xts'>Extract Subsets of xts Objects</h2><span id='topic++5B.xts'></span><span id='topic+subset.xts'></span><span id='topic+.subset.xts'></span><span id='topic+.subset_xts'></span>

<h3>Description</h3>

<p>Details on efficient subsetting of xts objects for maximum performance
and compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
x[i, j, drop = FALSE, which.i = FALSE, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_i">i</code></td>
<td>
<p>The rows to extract. Can be a numeric vector, time-based vector, or
an ISO-8601 style range string (see details).</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_j">j</code></td>
<td>
<p>The columns to extract, either a numeric vector of column locations
or a character vector of column names.</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_drop">drop</code></td>
<td>
<p>Should dimension be dropped, if possible? See notes section.</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_which.i">which.i</code></td>
<td>
<p>Logical value that determines whether a subset xts object is
returned (the default), or the locations of the matching rows (when
<code>which.i = TRUE</code>).</p>
</td></tr>
<tr><td><code id="+2B5B.xts_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the primary motivations and key points of differentiation of xts is
the ability to subset rows by specifying ISO-8601 compatible range strings.
This allows for natural range-based time queries without requiring prior
knowledge of the underlying class used for the time index.
</p>
<p>When <code>i</code> is a character string, it is processed as an ISO-8601 formatted
datetime or time range using <code><a href="#topic+.parseISO8601">.parseISO8601()</a></code>. A single datetime is
parsed from left to to right, according to the following specification:
</p>
<p>CCYYMMDD HH:MM:SS.ss+
</p>
<p>A time range can be specified by two datetimes separated by a forward slash
or double-colon. For example:
</p>
<p>CCYYMMDD HH:MM:SS.ss+/CCYYMMDD HH:MM:SS.ss
</p>
<p>The ISO8601 time range subsetting uses a custom binary search algorithm to
efficiently find the beginning and end of the time range. <code>i</code> can also be a
vector of ISO8601 time ranges, which enables subsetting by multiple
non-contiguous time ranges in one subset call.
</p>
<p>The above parsing, both for single datetimes and time ranges, will be done
on each element when <code>i</code> is a character <em>vector</em>. This is very inefficient,
especially for long vectors. In this case, it's recommened to use <code>I(i)</code> so
the xts subset function can process the vector more efficiently. Another
alternative is to convert <code>i</code> to POSIXct before passing it to the subset
function. See the examples for an illustration of using <code>I(i)</code>.
</p>
<p>The xts index is stored as POSIXct internally, regardless of the value of
its <code>tclass</code> attribute. So the fastest time-based subsetting is always when
<code>i</code> is a POSIXct vector.
</p>


<h3>Value</h3>

<p>An xts object containing the subset of <code>x</code>. When <code>which.i = TRUE</code>,
the corresponding integer locations of the matching rows is returned.
</p>


<h3>Note</h3>

<p>By design, xts objects always have two dimensions. They cannot be
vectors like zoo objects. Therefore <code>drop = FALSE</code> by default in order to
preserve the xts object's dimensions. This is different from both matrix and
zoo, which use <code>drop = TRUE</code> by default. Explicitly setting <code>drop = TRUE</code>
may be needed when performing certain matrix operations.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p>ISO 8601: Date elements and interchange formats - Information
interchange - Representation of dates and time <a href="https://www.iso.org">https://www.iso.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xts">xts()</a></code>, <code><a href="#topic+.parseISO8601">.parseISO8601()</a></code>, <code><a href="#topic+.index">.index()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- xts(1:3, Sys.Date()+1:3)
xx &lt;- cbind(x,x)

# drop = FALSE for xts, differs from zoo and matrix
z &lt;- as.zoo(xx)
z/z[,1]

m &lt;- as.matrix(xx)
m/m[,1]

# this will fail with non-conformable arrays (both retain dim)
tryCatch(
  xx/x[,1], 
  error = function(e) print("need to set drop = TRUE")
)

# correct way
xx/xx[,1,drop = TRUE]

# or less efficiently
xx/drop(xx[,1])
# likewise
xx/coredata(xx)[,1]


x &lt;- xts(1:1000, as.Date("2000-01-01")+1:1000)
y &lt;- xts(1:1000, as.POSIXct(format(as.Date("2000-01-01")+1:1000)))

x.subset &lt;- index(x)[1:20]
x[x.subset] # by original index type
system.time(x[x.subset]) 
x[as.character(x.subset)] # by character string. Beware!
system.time(x[as.character(x.subset)]) # slow!
system.time(x[I(as.character(x.subset))]) # wrapped with I(), faster!

x['200001'] # January 2000
x['1999/2000'] # All of 2000 (note there is no need to use the exact start)
x['1999/200001'] # January 2000 

x['2000/200005'] # 2000-01 to 2000-05
x['2000/2000-04-01'] # through April 01, 2000
y['2000/2000-04-01'] # through April 01, 2000 (using POSIXct series)


### Time of day subsetting 

i &lt;- 0:60000
focal_date &lt;- as.numeric(as.POSIXct("2018-02-01", tz = "UTC"))
x &lt;- .xts(i, c(focal_date + i * 15), tz = "UTC", dimnames = list(NULL, "value"))

# Select all observations between 9am and 15:59:59.99999:
w1 &lt;- x["T09/T15"] # or x["T9/T15"]
head(w1)

# timestring is of the form THH:MM:SS.ss/THH:MM:SS.ss

# Select all observations between 13:00:00 and 13:59:59.9999 in two ways:
y1 &lt;- x["T13/T13"]
head(y1)

x[.indexhour(x) == 13]

# Select all observations between 9:30am and 30 seconds, and 4.10pm:
x["T09:30:30/T16:10"]

# It is possible to subset time of day overnight.
# e.g. This is useful for subsetting FX time series which trade 24 hours on week days

# Select all observations between 23:50 and 00:15 the following day, in the xts time zone
z &lt;- x["T23:50/T00:14"]
z["2018-02-10 12:00/"] # check the last day


# Select all observations between 7pm and 8.30am the following day:
z2 &lt;- x["T19:00/T08:29:59"]
head(z2); tail(z2)

</code></pre>

<hr>
<h2 id='addEventLines'>Add vertical lines to an existing xts plot</h2><span id='topic+addEventLines'></span>

<h3>Description</h3>

<p>Add vertical lines and labels to an existing xts plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEventLines(events, main = "", on = 0, lty = 1, lwd = 1, col = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addEventLines_+3A_events">events</code></td>
<td>
<p>An xts object of events and their associated labels. It is
ensured that the first column of <code>events</code> is the event description/label.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_main">main</code></td>
<td>
<p>Main title for a new panel, if drawn.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_on">on</code></td>
<td>
<p>Panel number to draw on. A new panel will be drawn if <code>on = NA</code>.
The default, <code>on = 0</code>, will add to the active panel. The active panel is
defined as the panel on which the most recent action was performed. Note
that only the first element of <code>on</code> is checked for the default behavior to
add to the last active panel.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_lty">lty</code></td>
<td>
<p>Set the line type, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_lwd">lwd</code></td>
<td>
<p>Set the line width, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_col">col</code></td>
<td>
<p>Color palette to use, set by default to rational choices.</p>
</td></tr>
<tr><td><code id="addEventLines_+3A_...">...</code></td>
<td>
<p>Any other passthrough parameters to <code><a href="graphics.html#topic+text">text()</a></code> to control how
the event labels are drawn.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(xts)
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix)
events &lt;- xts(letters[1:3], 
              as.Date(c("2007-01-12", "2007-04-22", "2007-06-13")))
plot(sample.xts[,4])
addEventLines(events, srt = 90, pos = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='addLegend'>Add Legend</h2><span id='topic+addLegend'></span>

<h3>Description</h3>

<p>Add a legend to an existing panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLegend(
  legend.loc = "topright",
  legend.names = NULL,
  col = NULL,
  ncol = 1,
  on = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLegend_+3A_legend.loc">legend.loc</code></td>
<td>
<p>One of nine locations: bottomright, bottom, bottomleft,
left, topleft, top, topright, right, or center.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_legend.names">legend.names</code></td>
<td>
<p>Character vector of names for the legend. When <code>NULL</code>,
the column names of the current plot object are used.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_col">col</code></td>
<td>
<p>Fill colors for the legend. When <code>NULL</code>, the colorset of the
current plot object data is used.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns for the legend.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_on">on</code></td>
<td>
<p>Panel number to draw on. A new panel will be drawn if <code>on = NA</code>.
The default, <code>on = 0</code>, will add to the active panel. The active panel is
defined as the panel on which the most recent action was performed. Note
that only the first element of <code>on</code> is checked for the default behavior to
add to the last active panel.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_...">...</code></td>
<td>
<p>Any other passthrough parameters to <code><a href="graphics.html#topic+legend">legend()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='addPanel'>Add a panel to an existing xts plot</h2><span id='topic+addPanel'></span>

<h3>Description</h3>

<p>Apply a function to the data of an existing xts plot object and plot the
result on an existing or new panel. <code>FUN</code> should have arguments <code>x</code> or <code>R</code>
for the data of the existing xts plot object to be passed to. All other
additional arguments for <code>FUN</code> are passed through ....
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPanel(
  FUN,
  main = "",
  on = NA,
  type = "l",
  col = NULL,
  lty = 1,
  lwd = 1,
  pch = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPanel_+3A_fun">FUN</code></td>
<td>
<p>An xts object to plot.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_main">main</code></td>
<td>
<p>Main title for a new panel if drawn.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_on">on</code></td>
<td>
<p>Panel number to draw on. A new panel will be drawn if <code>on = NA</code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_type">type</code></td>
<td>
<p>The type of plot to be drawn, same as in <code><a href="base.html#topic+plot">plot()</a></code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_col">col</code></td>
<td>
<p>Color palette to use, set by default to rational choices.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_lty">lty</code></td>
<td>
<p>Set the line type, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_lwd">lwd</code></td>
<td>
<p>Set the line width, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_pch">pch</code></td>
<td>
<p>The type of plot to be drawn, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="addPanel_+3A_...">...</code></td>
<td>
<p>Additional named arguments passed through to <code>FUN</code> and any
other graphical passthrough parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.xts">plot.xts()</a></code>, <code><a href="#topic+addSeries">addSeries()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(xts)
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix)

calcReturns &lt;- function(price, method = c("discrete", "log")){
  px &lt;- try.xts(price)
  method &lt;- match.arg(method)[1L]
  returns &lt;- switch(method,
    simple = ,
    discrete = px / lag(px) - 1,
    compound = ,
    log = diff(log(px)))
  reclass(returns, px)
}

# plot the Close
plot(sample.xts[,"Close"])
# calculate returns 
addPanel(calcReturns, method = "discrete", type = "h")
# Add simple moving average to panel 1
addPanel(rollmean, k = 20, on = 1)
addPanel(rollmean, k = 40, col = "blue", on = 1)

</code></pre>

<hr>
<h2 id='addPolygon'>Add a polygon to an existing xts plot</h2><span id='topic+addPolygon'></span>

<h3>Description</h3>

<p>Draw a polygon on an existing xts plot by specifying a time series of y
coordinates. The xts index is used for the x coordinates and the first two
columns are the upper and lower y coordinates, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPolygon(x, y = NULL, main = "", on = NA, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPolygon_+3A_x">x</code></td>
<td>
<p>An xts object to plot. Must contain 2 columns for the upper and
the lower y coordinates for the polygon. The first column is interpreted
as upper y coordinates and the second column as the lower y coordinates.</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_y">y</code></td>
<td>
<p><code>NULL</code>, not used.</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_main">main</code></td>
<td>
<p>Main title for a new panel, if drawn.</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_on">on</code></td>
<td>
<p>Panel number to draw on. A new panel will be drawn if <code>on = NA</code>.</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_col">col</code></td>
<td>
<p>Color palette to use, set by default to rational choices.</p>
</td></tr>
<tr><td><code id="addPolygon_+3A_...">...</code></td>
<td>
<p>Any other passthrough parameters to <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>References</h3>

<p>Based on code by Dirk Eddelbuettel from
<a href="http://dirk.eddelbuettel.com/blog/2011/01/16/">http://dirk.eddelbuettel.com/blog/2011/01/16/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(xts)
data(sample_matrix)
x &lt;- as.xts(sample_matrix)[,1]
ix &lt;- index(x["2007-02"])
shade &lt;- xts(matrix(rep(range(x), each = length(ix)), ncol = 2), ix)

plot(x)

# set on = -1 to draw the shaded region *behind* the main series
addPolygon(shade, on = -1, col = "lightgrey")

## End(Not run)

</code></pre>

<hr>
<h2 id='addSeries'>Add a time series to an existing xts plot</h2><span id='topic+addSeries'></span>

<h3>Description</h3>

<p>Add a time series to an existing xts plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSeries(
  x,
  main = "",
  on = NA,
  type = "l",
  col = NULL,
  lty = 1,
  lwd = 1,
  pch = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSeries_+3A_x">x</code></td>
<td>
<p>An xts object to add to the plot.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_main">main</code></td>
<td>
<p>Main title for a new panel if drawn.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_on">on</code></td>
<td>
<p>Panel number to draw on. A new panel will be drawn if <code>on = NA</code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_type">type</code></td>
<td>
<p>The type of plot to be drawn, same as in <code><a href="base.html#topic+plot">plot()</a></code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_col">col</code></td>
<td>
<p>Color palette to use, set by default to rational choices.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_lty">lty</code></td>
<td>
<p>Set the line type, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_lwd">lwd</code></td>
<td>
<p>Set the line width, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_pch">pch</code></td>
<td>
<p>The type of plot to be drawn, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="addSeries_+3A_...">...</code></td>
<td>
<p>Any other passthrough graphical parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='adj.time'>Align seconds, minutes, and hours to beginning of next period.</h2><span id='topic+adj.time'></span><span id='topic+align.time'></span><span id='topic+align.time.xts'></span><span id='topic+shift.time'></span>

<h3>Description</h3>

<p>Change timestamps to the start of the next period, specified in multiples of
seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj.time(x, ...)

align.time(x, ...)

## S3 method for class 'xts'
align.time(x, n = 60, ...)

shift.time(x, n = 60, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj.time_+3A_x">x</code></td>
<td>
<p>Object containing timestamps to align.</p>
</td></tr>
<tr><td><code id="adj.time_+3A_...">...</code></td>
<td>
<p>Additional arguments. See details.</p>
</td></tr>
<tr><td><code id="adj.time_+3A_n">n</code></td>
<td>
<p>Number of seconds to adjust by.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 generic. The result is to round up to the next period
determined by 'n modulo x'.
</p>


<h3>Value</h3>

<p>A new object with the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan with input from Brian Peterson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+to.period">to.period()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- Sys.time() + 1:1000

# every 10 seconds
align.time(x, 10)

# align to next whole minute
align.time(x, 60)

# align to next whole 10 min interval
align.time(x, 10 * 60)

</code></pre>

<hr>
<h2 id='apply.daily'>Apply Function over Calendar Periods</h2><span id='topic+apply.daily'></span><span id='topic+apply.weekly'></span><span id='topic+apply.monthly'></span><span id='topic+apply.quarterly'></span><span id='topic+apply.yearly'></span>

<h3>Description</h3>

<p>Apply a specified function to each distinct period in a given time series
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.daily(x, FUN, ...)

apply.weekly(x, FUN, ...)

apply.monthly(x, FUN, ...)

apply.quarterly(x, FUN, ...)

apply.yearly(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply.daily_+3A_x">x</code></td>
<td>
<p>A time-series object coercible to xts.</p>
</td></tr>
<tr><td><code id="apply.daily_+3A_fun">FUN</code></td>
<td>
<p>A function to apply to each period.</p>
</td></tr>
<tr><td><code id="apply.daily_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple mechanism to apply a function to non-overlapping time periods, e.g.
weekly, monthly, etc. Different from rolling functions in that this will
subset the data based on the specified time period (implicit in the call),
and return a vector of values for each period in the original data.
</p>
<p>Essentially a wrapper to the <span class="pkg">xts</span> functions <code>endpoints()</code> and
<code>period.apply()</code>, mainly as a convenience.
</p>


<h3>Value</h3>

<p>A vector of results produced by <code>FUN</code>, corresponding to the
appropriate periods.
</p>


<h3>Note</h3>

<p>When <code>FUN = mean</code> the results will contain one column for every
column in the input, which is different from other math functions (e.g.
<code>median</code>, <code>sum</code>, <code>prod</code>, <code>sd</code>, etc.).
</p>
<p><code>FUN = mean</code> works by column because the default method <code>stats::mean</code>
previously worked by column for matrices and data.frames. R Core changed the
behavior of <code>mean</code> to always return one column in order to be consistent
with the other math functions. This broke some <span class="pkg">xts</span> dependencies and
<code>mean.xts()</code> was created to maintain the original behavior.
</p>
<p>Using <code>FUN = mean</code> will print a message that describes this inconsistency.
To avoid the message and confusion, use <code>FUN = colMeans</code> to calculate means
by column and use <code>FUN = function(x) mean</code> to calculate one mean for all the
data. Set <code>options(xts.message.period.apply.mean = FALSE)</code> to suppress this
message.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endpoints">endpoints()</a></code>, <code><a href="#topic+period.apply">period.apply()</a></code>, <code><a href="#topic+to.monthly">to.monthly()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xts.ts &lt;- xts(rnorm(231),as.Date(13514:13744,origin="1970-01-01"))

start(xts.ts)
end(xts.ts)

apply.monthly(xts.ts,colMeans)
apply.monthly(xts.ts,function(x) var(x))

</code></pre>

<hr>
<h2 id='as.environment.xts'>Coerce an xts Object to an Environment by Column</h2><span id='topic+as.environment.xts'></span>

<h3>Description</h3>

<p>Method to automatically convert an xts object to an environment containing
vectors representing each column of the original xts object. The name of
each object in the resulting environment corresponds to the name of the
column of the xts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
as.environment(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.environment.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment containing <code>ncol(x)</code> vectors extracted by
column from <code>x</code>.
</p>


<h3>Note</h3>

<p>Environments do not preserve (or have knowledge) of column order and
cannot be subset by an integer index.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- xts(1:10, Sys.Date()+1:10)
colnames(x) &lt;- "X"
y &lt;- xts(1:10, Sys.Date()+1:10)
colnames(x) &lt;- "Y"
xy &lt;- cbind(x,y)
colnames(xy)
e &lt;- as.environment(xy)    # currently using xts-style positive k 
ls(xy)
ls.str(xy)

</code></pre>

<hr>
<h2 id='as.xts.Date'>Convert Objects To and From xts</h2><span id='topic+as.xts.Date'></span><span id='topic+as.xts.POSIXt'></span><span id='topic+as.xts.data.frame'></span><span id='topic+as.xts.irts'></span><span id='topic+as.xts.matrix'></span><span id='topic+as.xts.timeDate'></span><span id='topic+as.xts.timeSeries'></span><span id='topic+as.xts.ts'></span><span id='topic+as.xts'></span><span id='topic+xtsible'></span><span id='topic+as.xts.yearmon'></span><span id='topic+as.xts.yearqtr'></span><span id='topic+as.xts.zoo'></span>

<h3>Description</h3>

<p>Conversion S3 methods to coerce data objects of arbitrary classes to xts
and back, without losing any attributes of the original format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Date'
as.xts(x, ...)

## S3 method for class 'POSIXt'
as.xts(x, ...)

## S3 method for class 'data.frame'
as.xts(
  x,
  order.by,
  dateFormat = "POSIXct",
  frequency = NULL,
  ...,
  .RECLASS = FALSE
)

## S3 method for class 'irts'
as.xts(x, order.by, frequency = NULL, ..., .RECLASS = FALSE)

## S3 method for class 'matrix'
as.xts(
  x,
  order.by,
  dateFormat = "POSIXct",
  frequency = NULL,
  ...,
  .RECLASS = FALSE
)

## S3 method for class 'timeDate'
as.xts(x, ...)

## S3 method for class 'timeSeries'
as.xts(
  x,
  dateFormat = "POSIXct",
  FinCenter,
  recordIDs,
  title,
  documentation,
  ...,
  .RECLASS = FALSE
)

## S3 method for class 'ts'
as.xts(x, dateFormat, ..., .RECLASS = FALSE)

as.xts(x, ...)

xtsible(x)

## S3 method for class 'yearmon'
as.xts(x, ...)

## S3 method for class 'yearqtr'
as.xts(x, ...)

## S3 method for class 'zoo'
as.xts(x, order.by = index(x), frequency = NULL, ..., .RECLASS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.xts.Date_+3A_x">x</code></td>
<td>
<p>Data object to convert. See details for supported types.</p>
</td></tr>
<tr><td><code id="as.xts.Date_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
<tr><td><code id="as.xts.Date_+3A_order.by">order.by</code>, <code id="as.xts.Date_+3A_frequency">frequency</code></td>
<td>
<p>See <a href="zoo.html#topic+zoo">zoo</a> help.</p>
</td></tr>
<tr><td><code id="as.xts.Date_+3A_dateformat">dateFormat</code></td>
<td>
<p>What class should the dates be converted to?</p>
</td></tr>
<tr><td><code id="as.xts.Date_+3A_.reclass">.RECLASS</code></td>
<td>
<p>Should the conversion be reversible via <code><a href="#topic+reclass">reclass()</a></code>?</p>
</td></tr>
<tr><td><code id="as.xts.Date_+3A_fincenter">FinCenter</code>, <code id="as.xts.Date_+3A_recordids">recordIDs</code>, <code id="as.xts.Date_+3A_title">title</code>, <code id="as.xts.Date_+3A_documentation">documentation</code></td>
<td>
<p>See <a href="timeSeries.html#topic+timeSeries">timeSeries</a> help.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple and reliable way to convert many different objects into a uniform
format for use within <span class="rlang"><b>R</b></span>.
</p>
<p><code>as.xts()</code> can convert objects of the following classes into an xts object:
object: <a href="timeSeries.html#topic+timeSeries">timeSeries</a>, <a href="stats.html#topic+ts">ts</a>, <a href="base.html#topic+matrix">matrix</a>, <a href="base.html#topic+data.frame">data.frame</a>,
and <a href="zoo.html#topic+zoo">zoo</a>. <code>xtsible()</code> safely checks whether an object can be converted to
an xts object.
</p>
<p>Additional <code>name = value</code> pairs may be passed to the function to be added to
the new object. A special <code><a href="#topic+print.xts">print.xts()</a></code> method ensures the attributes are
hidden from view, but will be available via <span class="rlang"><b>R</b></span>'s standard <code>attr()</code> function,
as well as the <code><a href="#topic+xtsAttributes">xtsAttributes()</a></code> function.
</p>
<p>When <code>.RECLASS = TRUE</code>, the returned xts object internally preserves all
relevant attribute/slot data from the input <code>x</code>. This allows for temporary
conversion to xts in order to use zoo and xts compatible methods. See
<code><a href="#topic+reclass">reclass()</a></code> for details.
</p>


<h3>Value</h3>

<p>An S3 object of class xts.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xts">xts()</a></code>, <code><a href="#topic+reclass">reclass()</a></code>, <code><a href="zoo.html#topic+zoo">zoo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# timeSeries
library(timeSeries)
x &lt;- timeSeries(1:10, 1:10)

str(as.xts(x))
str(reclass(as.xts(x)))
str(try.xts(x))
str(reclass(try.xts(x)))

## End(Not run)

</code></pre>

<hr>
<h2 id='axTicksByTime'>Compute x-Axis Tickmark Locations by Time</h2><span id='topic+axTicksByTime'></span>

<h3>Description</h3>

<p>Compute x-axis tickmarks like <code><a href="graphics.html#topic+axTicks">axTicks()</a></code> in base but with respect to
time. This function is written for internal use, and documented for those
wishing to use it for customized plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axTicksByTime(
  x,
  ticks.on = "auto",
  k = 1,
  labels = TRUE,
  format.labels = TRUE,
  ends = TRUE,
  gt = 2,
  lt = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axTicksByTime_+3A_x">x</code></td>
<td>
<p>An object indexed by time or a vector of times/dates.</p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_ticks.on">ticks.on</code></td>
<td>
<p>Time unit for tick locations.</p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_k">k</code></td>
<td>
<p>Frequency of tick locations.</p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_labels">labels</code></td>
<td>
<p>Should a labeled vector be returned?</p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_format.labels">format.labels</code></td>
<td>
<p>Either a logical value specifying whether labels should
be formatted, or a character string specifying the format to use.</p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_ends">ends</code></td>
<td>
<p>Should the ends be adjusted?</p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_gt">gt</code></td>
<td>
<p>Lower bound on number of tick locations.</p>
</td></tr>
<tr><td><code id="axTicksByTime_+3A_lt">lt</code></td>
<td>
<p>Upper bound on number of tick locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>ticks.on = "auto"</code> uses heuristics to compute sensible tick
locations. Use a combination of <code>ticks.on</code> and <code>k</code> to create tick locations
at specific intervals. For example, <code>ticks.on = "days"</code> and <code>k = 7</code> will
create tick marks every 7 days.
</p>
<p>When <code>format.labels</code> is a character string the possible values are the same
as those listed in the Details section of <code><a href="base.html#topic+strptime">strptime()</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of index element locations where tick marks should
be drawn. These are <em>locations</em> (e.g. 1, 2, 3, ...), <em>not</em> the
index timestamps.
</p>
<p>If possible, the result will be named using formatted values from the index
timestamps. The names will be used for the tick mark labels.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endpoints">endpoints()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sample_matrix)
axTicksByTime(as.xts(sample_matrix),'auto')
axTicksByTime(as.xts(sample_matrix),'weeks')
axTicksByTime(as.xts(sample_matrix),'months',7)

</code></pre>

<hr>
<h2 id='c.xts'>Concatenate Two or More xts Objects by Row</h2><span id='topic+c.xts'></span><span id='topic+rbind.xts'></span>

<h3>Description</h3>

<p>Concatenate or bind by row two or more xts objects along a time-based index.
All objects must have the same number of columns and be xts objects or
coercible to xts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
c(...)

## S3 method for class 'xts'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.xts_+3A_...">...</code></td>
<td>
<p>Objects to bind by row.</p>
</td></tr>
<tr><td><code id="c.xts_+3A_deparse.level">deparse.level</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Duplicate index values are supported. When one or more input has the same
index value, the duplicated index values in the result are in the same order
the objects are passed to <code>rbind()</code>. See examples.
</p>
<p><code>c()</code> is an alias for <code>rbind()</code> for xts objects.
</p>
<p>See <code><a href="#topic+merge.xts">merge.xts()</a></code> for traditional merge operations.
</p>


<h3>Value</h3>

<p>An xts object with one row per row for each object concatenated.
</p>


<h3>Note</h3>

<p><code>rbind()</code> is a '.Primitive' function in <span class="rlang"><b>R</b></span>, which means method dispatch
occurs at the C-level, and may not be consistent with normal S3 method
dispatch (see <code><a href="base.html#topic+rbind">rbind()</a></code> for details). Call <code>rbind.xts()</code> directly to
avoid potential dispatch ambiguity.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge.xts">merge.xts()</a></code> <code><a href="base.html#topic+rbind">rbind()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- xts(1:10, Sys.Date()+1:10)
str(x)

merge(x,x)
rbind(x,x)
rbind(x[1:5],x[6:10])

c(x,x)

# this also works on non-unique index values
x &lt;- xts(rep(1,5), Sys.Date()+c(1,2,2,2,3))
y &lt;- xts(rep(2,3), Sys.Date()+c(1,2,3))

# overlapping indexes are appended
rbind(x,y)
rbind(y,x)

</code></pre>

<hr>
<h2 id='CLASS'>Extract and Set .CLASS Attribute</h2><span id='topic+CLASS'></span><span id='topic+CLASS+3C-'></span>

<h3>Description</h3>

<p>Extraction and replacement functions to access the xts '.CLASS' attribute.
The '.CLASS' attribute is used by <code>reclass()</code> to transform an xts object
back to its original class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CLASS(x)

CLASS(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CLASS_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="CLASS_+3A_value">value</code></td>
<td>
<p>The new value to assign to the '.CLASS' attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is meant for use in conjunction with <code>try.xts()</code> and <code>reclass()</code> and is
is not intended for daily use. While it's possible to interactively coerce
objects to other classes than originally derived from, it's likely to cause
unexpected behavior. It is best to use the usual <code>as.xts()</code> and other
classes' <code>as</code> methods.
</p>


<h3>Value</h3>

<p>Called for its side-effect of changing the '.CLASS' attribute.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.xts">as.xts()</a></code>, <code><a href="#topic+reclass">reclass()</a></code>
</p>

<hr>
<h2 id='coredata.xts'>Extract/Replace Core Data of an xts Object</h2><span id='topic+coredata.xts'></span><span id='topic+xcoredata'></span><span id='topic+xcoredata+3C-'></span>

<h3>Description</h3>

<p>Mechanism to extract and replace the core data of an xts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
coredata(x, fmt = FALSE, ...)

xcoredata(x, ...)

xcoredata(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coredata.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="coredata.xts_+3A_fmt">fmt</code></td>
<td>
<p>Should the rownames be formated using <code>tformat()</code>? Alternatively
a date/time string to be passed to <code>format()</code>. See details.</p>
</td></tr>
<tr><td><code id="coredata.xts_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="coredata.xts_+3A_value">value</code></td>
<td>
<p>Non-core attributes to assign.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract coredata of an xts object - removing all attributes except
<code>dim</code> and <code>dimnames</code> and returning a matrix object with rownames
converted from the index of the xts object.
</p>
<p>The rownames of the result use the format specified by <code>tformat(x)</code> when
<code>fmt = TRUE</code>. When <code>fmt</code> is a character string to be passed to <code>format()</code>.
See <code><a href="base.html#topic+strptime">strptime()</a></code> for valid format strings. Setting <code>fmt = FALSE</code> will
return the row names by simply coercing the index class to a character
string in the default manner.
</p>
<p><code>xcoredata()</code> is the complement to <code>coredata()</code>. It returns all of the
attributes normally removed by <code>coredata()</code>.  Its purpose, along with the
the replacement function <code style="white-space: pre;">&#8288;xcoredata&lt;-&#8288;</code> is primarily for developers using
<span class="pkg">xts</span>' <code><a href="#topic+try.xts">try.xts()</a></code> and <code><a href="#topic+reclass">reclass()</a></code> functionality inside functions
so the functions can take any time series class as an input and return the
same time series class.
</p>


<h3>Value</h3>

<p>Returns either a matrix object for coredata, or a list of named
attributes.
</p>
<p>The replacement functions are called for their side-effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">coredata()</a></code>, <code><a href="#topic+xtsAttributes">xtsAttributes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sample_matrix)
x &lt;- as.xts(sample_matrix, myattr=100)
coredata(x)
xcoredata(x)

</code></pre>

<hr>
<h2 id='dimnames.xts'>Dimnames of an xts Object</h2><span id='topic+dimnames.xts'></span><span id='topic+dimnames+3C-.xts'></span>

<h3>Description</h3>

<p>Get or set dimnames of an xts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
dimnames(x)

## S3 replacement method for class 'xts'
dimnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimnames.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="dimnames.xts_+3A_value">value</code></td>
<td>
<p>A two element list. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For efficienty, xts objects do not have rownames (unlike zoo objects).
Attempts to set rownames on an xts object will silently set them to <code>NULL</code>.
This is done for internal compatibility reasons, as well as to provide
consistency in performance regardless of object use.
</p>


<h3>Value</h3>

<p>A list or character string containing coerced row names and/or
actual column names.
</p>
<p>Attempts to set rownames on xts objects via rownames or dimnames will
silently fail.
</p>


<h3>Note</h3>

<p>Unlike zoo, all xts objects have dimensions. xts objects cannot be
plain vectors.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xts">xts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- xts(1:10, Sys.Date()+1:10)
dimnames(x)
rownames(x)
rownames(x) &lt;- 1:10
rownames(x)
str(x)

</code></pre>

<hr>
<h2 id='endpoints'>Locate Endpoints by Time</h2><span id='topic+endpoints'></span>

<h3>Description</h3>

<p>Extract index locations for an xts object that correspond to the <em>last</em>
observation in each period specified by <code>on</code> and <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endpoints(x, on = "months", k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endpoints_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="endpoints_+3A_on">on</code></td>
<td>
<p>A character string specifying the period.</p>
</td></tr>
<tr><td><code id="endpoints_+3A_k">k</code></td>
<td>
<p>The number of periods each endpoint should cover.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>endpoints()</code> returns a numeric vector that always begins with zero and ends
with the number of observations in <code>x</code>.
</p>
<p>Periods are always based on the distance from the UNIX epoch (midnight
1970-01-01 UTC), <em>not the first observation in <code>x</code></em>. See the examples.
</p>
<p>Valid values for the <code>on</code> argument are: &ldquo;us&rdquo; (microseconds),
&ldquo;microseconds&rdquo;, &ldquo;ms&rdquo; (milliseconds), &ldquo;milliseconds&rdquo;,
&ldquo;secs&rdquo; (seconds), &ldquo;seconds&rdquo;, &ldquo;mins&rdquo; (minutes),
&ldquo;minutes&rdquo;, &ldquo;hours&rdquo;, &ldquo;days&rdquo;, &ldquo;weeks&rdquo;,
&ldquo;months&rdquo;, &ldquo;quarters&rdquo;, and &ldquo;years&rdquo;.
</p>


<h3>Value</h3>

<p>A numeric vector of beginning with 0 and ending with the number of
of observations in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sample_matrix)

endpoints(sample_matrix)
endpoints(sample_matrix, "weeks")

### example of how periods are based on the UNIX epoch,
### *not* the first observation of the data series
x &lt;- xts(1:38, yearmon(seq(2018 - 1/12, 2021, 1/12)))
# endpoints for the end of every other year
ep &lt;- endpoints(x, "years", k = 2)
# Dec-2017 is the end of the *first* year in the data. But when you start from
# Jan-1970 and use every second year end as your endpoints, the endpoints are
# always December of every odd year.
x[ep, ]

</code></pre>

<hr>
<h2 id='first'>Return First or Last n Elements of A Data Object</h2><span id='topic+first'></span><span id='topic+first.default'></span><span id='topic+first.xts'></span><span id='topic+last'></span><span id='topic+last.default'></span><span id='topic+last.xts'></span>

<h3>Description</h3>

<p>Generic functions to return the first or last elements or rows of a vector
or two-dimensional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first(x, ...)

## Default S3 method:
first(x, n = 1, keep = FALSE, ...)

## S3 method for class 'xts'
first(x, n = 1, keep = FALSE, ...)

last(x, ...)

## Default S3 method:
last(x, n = 1, keep = FALSE, ...)

## S3 method for class 'xts'
last(x, n = 1, keep = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="first_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="first_+3A_n">n</code></td>
<td>
<p>Number of observations to return.</p>
</td></tr>
<tr><td><code id="first_+3A_keep">keep</code></td>
<td>
<p>Should removed values be kept as an attribute on the result?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A more advanced subsetting is available for zoo objects with indexes
inheriting from POSIXt or Date classes.
</p>
<p>Quickly and easily extract the first or last <code>n</code> observations of an object.
When <code>n</code> is a number, these functions are similar to <code><a href="utils.html#topic+head">head()</a></code> and
<code><a href="utils.html#topic+tail">tail()</a></code>, but only return the <em>first</em> or <em>last</em> observation by default.
</p>
<p><code>n</code> can be a character string if <code>x</code> is an xts object or coerceable to xts.
It must be of the form &lsquo;n period&rsquo;, where 'n' is a numeric value
(1 if not provided) describing the number of periods to return. Valid
periods are: secs, seconds, mins, minutes, hours, days, weeks, months,
quarters, and years.
</p>
<p>The 'period' portion can be any frequency greater than or equal to the
frequency of the object's time index. For example, <code>first(x, "2 months")</code>
will return the first 2 months of data even if <code>x</code> is hourly frequency.
Attempts to set 'period' to a frequency less than the object's frequency
will throw an error.
</p>
<p><code>n</code> may be positive or negative, whether it's a number or character string.
When <code>n</code> is positive, the functions return the obvious result. For example,
<code>first(x, "1 month")</code> returns the first month's data. When <code>n</code> is negative,
all data <em>except</em> first month's is returned.
</p>
<p>Requesting more data than is in <code>x</code> will throw a warning and simply return
<code>x</code>.
</p>


<h3>Value</h3>

<p>A subset of elements/rows of the original data.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
first(1:100)
last(1:100)

data(LakeHuron)
first(LakeHuron,10)
last(LakeHuron)

x &lt;- xts(1:100, Sys.Date()+1:100)
first(x, 10)
first(x, '1 day')
first(x, '4 days')
first(x, 'month')
last(x, '2 months')
last(x, '6 weeks')

</code></pre>

<hr>
<h2 id='firstof'>Create a POSIXct Object</h2><span id='topic+firstof'></span><span id='topic+lastof'></span>

<h3>Description</h3>

<p>Easily create of time stamps corresponding to the first or last observation
in a specified time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstof(year = 1970, month = 1, day = 1, hour = 0, min = 0, sec = 0, tz = "")

lastof(
  year = 1970,
  month = 12,
  day = 31,
  hour = 23,
  min = 59,
  sec = 59,
  subsec = 0.99999,
  tz = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstof_+3A_year">year</code>, <code id="firstof_+3A_month">month</code>, <code id="firstof_+3A_day">day</code></td>
<td>
<p>Numeric values to specify a day.</p>
</td></tr>
<tr><td><code id="firstof_+3A_hour">hour</code>, <code id="firstof_+3A_min">min</code>, <code id="firstof_+3A_sec">sec</code></td>
<td>
<p>Numeric vaues to specify time within a day.</p>
</td></tr>
<tr><td><code id="firstof_+3A_tz">tz</code></td>
<td>
<p>Timezone used for conversion.</p>
</td></tr>
<tr><td><code id="firstof_+3A_subsec">subsec</code></td>
<td>
<p>Number of sub-seconds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper to <code><a href="base.html#topic+ISOdatetime">ISOdatetime()</a></code> with defaults corresponding to the
first or last possible time in a given period.
</p>


<h3>Value</h3>

<p>An POSIXct object.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ISOdatetime">ISOdatetime()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
firstof(2000)
firstof(2005,01,01)

lastof(2007)
lastof(2007,10)

</code></pre>

<hr>
<h2 id='index.xts'>Get and Replace the Class of an xts Index</h2><span id='topic+index.xts'></span><span id='topic+index+3C-.xts'></span><span id='topic+time+3C-.xts'></span><span id='topic+time.xts'></span><span id='topic+.index'></span><span id='topic+.index+3C-'></span><span id='topic+.indexsec'></span><span id='topic+.indexmin'></span><span id='topic+.indexhour'></span><span id='topic+.indexmday'></span><span id='topic+.indexmon'></span><span id='topic+.indexyear'></span><span id='topic+.indexwday'></span><span id='topic+.indexbday'></span><span id='topic+.indexyday'></span><span id='topic+.indexisdst'></span><span id='topic+.indexDate'></span><span id='topic+.indexday'></span><span id='topic+.indexweek'></span><span id='topic+.indexyweek'></span><span id='topic+convertIndex'></span>

<h3>Description</h3>

<p>Functions to get and replace an xts object's index values and it's
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
index(x, ...)

## S3 replacement method for class 'xts'
index(x) &lt;- value

## S3 replacement method for class 'xts'
time(x) &lt;- value

## S3 method for class 'xts'
time(x, ...)

.index(x, ...)

.index(x) &lt;- value

.indexsec(x)

.indexmin(x)

.indexhour(x)

.indexmday(x)

.indexmon(x)

.indexyear(x)

.indexwday(x)

.indexbday(x)

.indexyday(x)

.indexisdst(x)

.indexDate(x)

.indexday(x)

.indexweek(x)

.indexyweek(x)

convertIndex(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="index.xts_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="index.xts_+3A_value">value</code></td>
<td>
<p>A new time index value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An xts object's index is stored internally as the number of seconds since
UNIX epoch in the UTC timezone. The <code>.index()</code> and <code style="white-space: pre;">&#8288;.index&lt;-&#8288;</code> functions get
and replace the internal numeric value of the index, respectively. These
functions are primarily for internal use, but are exported because they may
be useful for users.
</p>
<p>The replacement method also updates the <code><a href="#topic+tclass">tclass()</a></code> and <code><a href="#topic+tzone">tzone()</a></code> of the
index to match the class and timezone of the new index, respectively. The
<code>index()</code> method converts the internal numeric index to the class specified
by the 'tclass' attribute and with the timezone specified by the 'tzone'
attribute before returning the index values to the user.
</p>
<p>The <code>.indexXXX()</code> functions below extract time components from the internal
time index. They return values like the values of <a href="base.html#topic+POSIXlt">POSIXlt</a> components.
</p>

<dl>
<dt><code>.indexsec</code></dt><dd><p>0 - 61: seconds of the minute (local time)</p>
</dd>
<dt><code>.indexmin</code></dt><dd><p>0 - 59: minutes of the hour (local time)</p>
</dd>
<dt><code>.indexhour</code></dt><dd><p>0 - 23: hours of the day (local time)</p>
</dd>
<dt><code>.indexDate</code></dt><dd><p>date as seconds since the epoch (UTC <em>not local time</em></p>
</dd>
<dt><code>.indexday</code></dt><dd><p>date as seconds since the epoch (UTC <em>not local time</em></p>
</dd>
<dt><code>.indexwday</code></dt><dd><p>0 - 6: day of the week (Sunday - Saturday, local time)</p>
</dd>
<dt><code>.indexmday</code></dt><dd><p>1 - 31: day of the month (local time)</p>
</dd>
<dt><code>.indexweek</code></dt><dd><p>weeks since the epoch (UTC <em>not local time</em></p>
</dd>
<dt><code>.indexmon</code></dt><dd><p>0 - 11: month of the year (local time)</p>
</dd>
<dt><code>.indexyear</code></dt><dd><p>years since 1900 (local time)</p>
</dd>
<dt><code>.indexyday</code></dt><dd><p>0 - 365: day of the year (local time, 365 only in leap years)</p>
</dd>
<dt><code>.indexisdst</code></dt><dd><p>1, 0, -1: Daylight Saving Time flag. Positive if
Daylight Saving Time is in effect, zero if not, negative if unknown.</p>
</dd>
</dl>

<p>Changes in timezone, index class, and index format internal structure, by
<span class="pkg">xts</span> version:
</p>

<dl>
<dt>Version 0.12.0:</dt><dd><p>The <code>.indexTZ</code>, <code>.indexCLASS</code> and <code>.indexFORMAT</code>
attributes are no longer stored on xts objects, only on the index itself.
<br /><br />
The <code>indexTZ()</code>, <code>indexClass()</code>, and <code>indexFormat()</code> functions (and
their respective replacement methods) are deprecated in favor of their
respective <code>tzone()</code>, <code>tclass()</code>, and <code>tformat()</code> versions. The previous
versions throw a warning that they're deprecated, but they will continue
to work. They will never be removed or throw an error. Ever.
<br /><br />
The new versions are careful to look for the old attributes on the xts
object, in case they're ever called on an xts object that was created prior
to the attributes being added to the index itself.
<br /><br />
You can set <code>options(xts.warn.index.missing.tzone = TRUE)</code> and
<code>options(xts.warn.index.missing.tclass = TRUE)</code> to identify xts objects
that do not have a 'tzone' or 'tclass' attribute on the index, even if
there is a 'tzone' or 'tclass' attribute on the xts object itself. The
warnings will be thrown when the object is printed.
Use <code>x &lt;- as.xts(x)</code> to update these objects to the new structure.</p>
</dd>
<dt>Version 0.9.8:</dt><dd><p>The index timezone is now set to &quot;UTC&quot; for time classes
that do not have any intra-day component (e.g. days, months, quarters).
Previously the timezone was blank, which meant &quot;local time&quot; as determined by
<span class="rlang"><b>R</b></span> and the OS.</p>
</dd>
<dt>Version 0.9.2:</dt><dd><p>There are new get/set methods for the timezone, index
class, and index format attributes: <code>tzone()</code> and, <code style="white-space: pre;">&#8288;tzone&lt;-&#8288;</code>, <code>tclass()</code>
and <code style="white-space: pre;">&#8288;tclass&lt;-&#8288;</code>, and <code>tformat()</code> and <code style="white-space: pre;">&#8288;tformat&lt;-&#8288;</code>. These new functions are
aliases to their <code>indexTZ()</code>, <code>indexClass()</code>, and <code>indexFormat()</code>
counterparts.</p>
</dd>
<dt>Version 0.7.5:</dt><dd><p>The timezone, index class, and index format were added
as attributes to the index itself, as 'tzone', 'tclass', and 'tformat',
respectively. This is in order to remove those three attributes from the xts
object, so they're only on the index itself.
<br /><br />
The <code>indexTZ()</code>, <code>indexClass()</code>, and <code>indexFormat()</code> functions (and their
respective replacement methods) will continue to work as in prior <span class="pkg">xts</span>
versions. The attributes on the index take priority over their respective
counterparts that may be on the xts object.</p>
</dd>
<dt>Versions 0.6.4 and prior:</dt><dd><p>Objects track their timezone and index class
in their '.indexTZ' and '.indexCLASS' attributes, respectively.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tformat">tformat()</a></code> describes how the index values are formatted when
printed, <code><a href="#topic+tclass">tclass()</a></code> documents how <span class="pkg">xts</span> handles the index class, and
<code><a href="#topic+tzone">tzone()</a></code> has more information about index timezone settings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- timeBasedSeq('2010-01-01/2010-01-01 12:00/H')
x &lt;- xts(seq_along(x), x)

# the index values, converted to 'tclass' (POSIXct in this case)
index(x)
class(index(x))  # POSIXct
tclass(x)        # POSIXct

# the internal numeric index
.index(x)
# add 1 hour (3600 seconds) to the numeric index
.index(x) &lt;- index(x) + 3600
index(x)

y &lt;- timeBasedSeq('2010-01-01/2010-01-02 12:00')
y &lt;- xts(seq_along(y), y)

# Select all observations in the first 6 and last 3 minutes of the
# 8th and 15th hours on each day
y[.indexhour(y) %in% c(8, 15) &amp; .indexmin(y) %in% c(0:5, 57:59)]

i &lt;- 0:60000
focal_date &lt;- as.numeric(as.POSIXct("2018-02-01", tz = "UTC"))
y &lt;- .xts(i, c(focal_date + i * 15), tz = "UTC", dimnames = list(NULL, "value"))

# Select all observations for the first minute of each hour
y[.indexmin(y) == 0]

# Select all observations on Monday
mon &lt;- y[.indexwday(y) == 1]
head(mon)
tail(mon)
unique(weekdays(index(mon))) # check

# Disjoint time of day selections

# Select all observations between 08:30 and 08:59:59.9999  or between 12:00 and 12:14:59.99999:
y[.indexhour(y) == 8 &amp; .indexmin(y) &gt;= 30 | .indexhour(y) == 12 &amp; .indexmin(x) %in% 0:14]

### Compound selections

# Select all observations for Wednesdays or Fridays between 9am and 4pm (exclusive of 4pm):
y[.indexwday(y) %in% c(3, 5) &amp; (.indexhour(y) %in%  c(9:15))]

# Select all observations on Monday between 8:59:45 and 09:04:30:

y[.indexwday(y) == 1 &amp; (.indexhour(y) == 8 &amp; .indexmin(y) == 59 &amp; .indexsec(y) &gt;= 45 |
                        .indexhour(y) == 9 &amp;
                        (.indexmin(y) &lt;  4 | .indexmin(y) ==  4 &amp; .indexsec(y) &lt;= 30))]

i &lt;- 0:30000
u &lt;- .xts(i, c(focal_date + i * 1800), tz = "UTC", dimnames = list(NULL, "value"))

# Select all observations for January or February:
u[.indexmon(u) %in% c(0, 1)]

# Select all data for the 28th to 31st of each month, excluding any Fridays:
u[.indexmday(u) %in% 28:31 &amp; .indexwday(u) != 5]

# Subset by week since origin
unique(.indexweek(u))
origin &lt;- xts(1, as.POSIXct("1970-01-01"))
unique(.indexweek(origin))

# Select all observations in weeks 2515 to 2517.
u2 &lt;- u[.indexweek(u) %in% 2515:2517]
head(u2); tail(u2)

# Select all observations after 12pm for day 50 and 51 in each year
u[.indexyday(u) %in% 50:51 &amp; .indexhour(u) &gt;= 12]

</code></pre>

<hr>
<h2 id='indexTZ'>Get or Replace the Timezone of an xts Object's Index</h2><span id='topic+indexTZ'></span><span id='topic+tzone'></span><span id='topic+indexTZ+3C-'></span><span id='topic+tzone+3C-'></span>

<h3>Description</h3>

<p>Generic functions to get or replace the timezone of an xts object's index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexTZ(x, ...)

tzone(x, ...)

indexTZ(x) &lt;- value

tzone(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexTZ_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="indexTZ_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="indexTZ_+3A_value">value</code></td>
<td>
<p>A valid timezone value (see <code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, an xts object's index is a <em>numeric</em> value corresponding to
seconds since the epoch in the UTC timezone. When an xts object is created,
all time index values are converted internally to <code><a href="base.html#topic+POSIXct">POSIXct()</a></code>
(which is also in seconds since the UNIX epoch), using the underlying OS
conventions and the <span class="env">TZ</span> environment variable. The <code>xts()</code> function
manages timezone information as transparently as possible.
</p>
<p>The <code style="white-space: pre;">&#8288;tzone&lt;-&#8288;</code> function <em>does not</em> change the internal index values
(i.e. the index will remain the same time in the UTC timezone).
</p>


<h3>Value</h3>

<p>A one element named vector containing the timezone of the object's
index.
</p>


<h3>Note</h3>

<p>Both <code>indexTZ()</code> and <code style="white-space: pre;">&#8288;indexTZ&lt;-&#8288;</code> are deprecated in favor of
<code>tzone()</code> and <code style="white-space: pre;">&#8288;tzone&lt;-&#8288;</code>, respectively.
</p>
<p>Problems may arise when an object that had been created under one timezone
are used in a session using another timezone. This isn't usually a issue,
but when it is a warning is given upon printing or subsetting. This warning
may be suppressed by setting <code>options(xts_check_TZ = FALSE)</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+index">index()</a></code> has more information on the xts index, <code><a href="#topic+tformat">tformat()</a></code>
describes how the index values are formatted when printed, and <code><a href="#topic+tclass">tclass()</a></code>
provides details how <span class="pkg">xts</span> handles the class of the index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Date indexes always have a "UTC" timezone
x &lt;- xts(1, Sys.Date())
tzone(x)
str(x)
print(x)

# The default 'tzone' is blank -- your machine's local timezone,
# determined by the 'TZ' environment variable.
x &lt;- xts(1, Sys.time())
tzone(x)
str(x)

# now set 'tzone' to different values
tzone(x) &lt;- "UTC"
str(x)

tzone(x) &lt;- "America/Chicago"
str(x)

y &lt;- timeBasedSeq('2010-01-01/2010-01-03 12:00/H')
y &lt;- xts(seq_along(y), y, tzone = "America/New_York")

# Changing the tzone does not change the internal index values, but it
# does change how the index is printed!
head(y)
head(.index(y))
tzone(y) &lt;- "Europe/London"
head(y)          # the index prints with hours, but
head(.index(y))  # the internal index is not changed!

</code></pre>

<hr>
<h2 id='is.index.unique'>Force Time Values To Be Unique</h2><span id='topic+is.index.unique'></span><span id='topic+is.time.unique'></span><span id='topic+make.index.unique'></span><span id='topic+make.time.unique'></span>

<h3>Description</h3>

<p>A generic function to force sorted time vectors to be unique. Useful for
high-frequency time-series where original time-stamps may have identical
values. For the case of xts objects, the default <code>eps</code> is set to ten
microseconds. In practice this advances each subsequent identical time by
<code>eps</code> over the previous (possibly also advanced) value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.index.unique(x)

is.time.unique(x)

make.index.unique(x, eps = 1e-06, drop = FALSE, fromLast = FALSE, ...)

make.time.unique(x, eps = 1e-06, drop = FALSE, fromLast = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.index.unique_+3A_x">x</code></td>
<td>
<p>An xts object, or POSIXct vector.</p>
</td></tr>
<tr><td><code id="is.index.unique_+3A_eps">eps</code></td>
<td>
<p>A value to add to force uniqueness.</p>
</td></tr>
<tr><td><code id="is.index.unique_+3A_drop">drop</code></td>
<td>
<p>Should duplicates be dropped instead of adjusted by <code>eps</code>?</p>
</td></tr>
<tr><td><code id="is.index.unique_+3A_fromlast">fromLast</code></td>
<td>
<p>When <code>drop = TRUE</code>, <code>fromLast</code> controls which duplicated
times are dropped. When <code>fromLast = FALSE</code>, the earliest observation with
an identical timestamp is kept and subsequent observations are dropped.</p>
</td></tr>
<tr><td><code id="is.index.unique_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned time-series object will have new time-stamps so that
<code>isOrdered(.index(x))</code> evaluates to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A modified version of <code>x</code> with unique timestamps.
</p>


<h3>Note</h3>

<p>Incoming values must be pre-sorted, and no check is done to make sure
that this is the case.  &lsquo;integer&rsquo; index value will be coerced to
&lsquo;double&rsquo; when <code>drop = FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+align.time">align.time()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ds &lt;- options(digits.secs=6) # so we can see the change

x &lt;- xts(1:10, as.POSIXct("2011-01-21") + c(1,1,1,2:8)/1e3)
x
make.index.unique(x)

options(ds)

</code></pre>

<hr>
<h2 id='is.timeBased'>Check if Class is Time-Based</h2><span id='topic+is.timeBased'></span><span id='topic+timeBased'></span>

<h3>Description</h3>

<p>Used to verify that the object is one of the known time-based classes in R.
Current time-based objects supported are <code>Date</code>, <code>POSIXct</code>, <code>chron</code>,
<code>yearmon</code>, <code>yearqtr</code>, and <code>timeDate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.timeBased(x)

timeBased(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.timeBased_+3A_x">x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
timeBased(Sys.time())
timeBased(Sys.Date())

timeBased(200701)

</code></pre>

<hr>
<h2 id='isOrdered'>Check If A Vector Is Ordered</h2><span id='topic+isOrdered'></span>

<h3>Description</h3>

<p>Check if a vector is strictly increasing, strictly decreasing, not
decreasing, or not increasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isOrdered(x, increasing = TRUE, strictly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isOrdered_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="isOrdered_+3A_increasing">increasing</code></td>
<td>
<p>Test for increasing (<code>TRUE</code>) or decreasing (<code>FALSE</code>) values?</p>
</td></tr>
<tr><td><code id="isOrdered_+3A_strictly">strictly</code></td>
<td>
<p>When <code>TRUE</code>, vectors with duplicate values are <em>not</em>
considered ordered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designed for internal use with <span class="pkg">xts</span>, this provides highly optimized
tests for ordering.
</p>


<h3>Value</h3>

<p>A logical scalar indicating whether or not <code>x</code> is ordered.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.unsorted">is.unsorted()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# strictly increasing
isOrdered(1:10, increasing=TRUE)
isOrdered(1:10, increasing=FALSE)
isOrdered(c(1,1:10), increasing=TRUE)
isOrdered(c(1,1:10), increasing=TRUE, strictly=FALSE)

# decreasing
isOrdered(10:1, increasing=TRUE)
isOrdered(10:1, increasing=FALSE)

</code></pre>

<hr>
<h2 id='lag.xts'>Lags and Differences of xts Objects</h2><span id='topic+lag.xts'></span><span id='topic+diff.xts'></span>

<h3>Description</h3>

<p>Methods for computing lags and differences on xts objects. This provides
similar functionality as the <span class="pkg">zoo</span> counterparts, but with some different
defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
lag(x, k = 1, na.pad = TRUE, ...)

## S3 method for class 'xts'
diff(
  x,
  lag = 1,
  differences = 1,
  arithmetic = TRUE,
  log = FALSE,
  na.pad = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="lag.xts_+3A_k">k</code></td>
<td>
<p>Number of periods to shift.</p>
</td></tr>
<tr><td><code id="lag.xts_+3A_na.pad">na.pad</code></td>
<td>
<p>Should <code>NA</code> be added so the result has the same number of
observations as <code>x</code>?</p>
</td></tr>
<tr><td><code id="lag.xts_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="lag.xts_+3A_lag">lag</code></td>
<td>
<p>Period to difference over.</p>
</td></tr>
<tr><td><code id="lag.xts_+3A_differences">differences</code></td>
<td>
<p>Order of differencing.</p>
</td></tr>
<tr><td><code id="lag.xts_+3A_arithmetic">arithmetic</code></td>
<td>
<p>Should arithmetic or geometric differencing be used?</p>
</td></tr>
<tr><td><code id="lag.xts_+3A_log">log</code></td>
<td>
<p>Should (geometric) log differences be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary motivation for these methods was to take advantage of a faster
C-level implementation. Another motivation was to make <code>lag()</code> behave using
standard sign for <code>k</code>. Both <code><a href="zoo.html#topic+lag.zoo">lag.zoo()</a></code> and <code><a href="stats.html#topic+lag.default">lag.default()</a></code> require a
<em>negative</em> value for <code>k</code> in order to shift a series backward. So <code>k = 1</code>,
shifts the series <em>forward</em> one observation. This is especially confusing
because <code>k = 1</code> is the default for those functions. When <code>x</code> is an xts
object, <code>lag(x, 1)</code> returns an object where the value at time 't' is the
value at time 't-1' in the original object.
</p>
<p>Another difference is that <code>na.pad = TRUE</code> by default, to better reflect the
transformation visually and for functions the require positional alignment
of data.
</p>
<p>Set <code>options(xts.compat.zoo.lag = TRUE)</code> to use make <code>lag.xts()</code> consistent
with <code>lag.zoo()</code> by reversing the sign of <code>k</code> and setting <code>na.pad = FALSE</code>.
</p>


<h3>Value</h3>

<p>An xts object with the desired lag and/or differencing.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Lag">https://en.wikipedia.org/wiki/Lag</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- xts(1:10, Sys.Date()+1:10)
lag(x)    # currently using xts-style positive k 

lag(x, k=2)

lag(x, k=-1, na.pad=FALSE) # matches lag.zoo(x, k=1)

diff(x)
diff(x, lag=1)
diff(x, diff=2)
diff(diff(x))

</code></pre>

<hr>
<h2 id='merge.xts'>Merge xts Objects</h2><span id='topic+merge.xts'></span><span id='topic+cbind.xts'></span>

<h3>Description</h3>

<p>Perform merge operations on xts objects by time index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
merge(
  ...,
  all = TRUE,
  fill = NA,
  suffixes = NULL,
  join = "outer",
  retside = TRUE,
  retclass = "xts",
  tzone = NULL,
  drop = NULL,
  check.names = NULL
)

## S3 method for class 'xts'
cbind(..., all = TRUE, fill = NA, suffixes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.xts_+3A_...">...</code></td>
<td>
<p>One or more xts objects, or objects coercible to class xts.</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_all">all</code></td>
<td>
<p>A logical vector indicating merge type.</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_fill">fill</code></td>
<td>
<p>Values to be used for missing elements.</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_suffixes">suffixes</code></td>
<td>
<p>Suffix to be added to merged column names.</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_join">join</code></td>
<td>
<p>Type of database join. One of 'outer', 'inner', 'left', or 'right'.</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_retside">retside</code></td>
<td>
<p>Which side of the merged object should be returned (2-case only)?</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_retclass">retclass</code></td>
<td>
<p>Either a logical value indicating whether the result should
have a 'class' attribute, or the name of the desired class for the result.</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_tzone">tzone</code></td>
<td>
<p>Time zone to use for the merged result.</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_drop">drop</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="merge.xts_+3A_check.names">check.names</code></td>
<td>
<p>Use <code><a href="base.html#topic+make.names">make.names()</a></code> to ensure column names are vaild <span class="rlang"><b>R</b></span>
object names?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This xts method is compatible with <code><a href="zoo.html#topic+merge.zoo">merge.zoo()</a></code> but implemented almost
entirely in C-level code for efficiency.
</p>
<p>The function can perform all common database join operations along the time
index by setting 'join' to one of the values below. Note that 'left' and
'right' are only implemented for two objects.
</p>

<ul>
<li><p> outer: full outer (all rows in all objects)
</p>
</li>
<li><p> inner: only rows with common indexes in all objects
</p>
</li>
<li><p> left: all rows in the first object, and rows from the second object that
have the same index as the first object
</p>
</li>
<li><p> right: all rows in the second object, and rows from the first object that
have the same index as the second object
</p>
</li></ul>

<p>The above join types can also be accomplished by setting 'all' to one of the
values below.
</p>

<ul>
<li><p> outer: <code>all = TRUE</code> or <code>all = c(TRUE, TRUE)</code>
</p>
</li>
<li><p> inner: <code>all = FALSE</code> or <code>all = c(FALSE, FALSE)</code>
</p>
</li>
<li><p> left: <code>all = c(TRUE, FALSE)</code>
</p>
</li>
<li><p> right: <code>all = c(FALSE, TRUE)</code>
</p>
</li></ul>

<p>The result will have the timezone of the leftmost argument if available. Use
the 'tzone' argument to override the default behavior.
</p>
<p>When <code>retclass = NULL</code> the joined objects will be split and reassigned
silently back to the original environment they are called from. This is for
backward compatibility with zoo, but unused by xts. When <code>retclass = FALSE</code>
the object will be stripped of its class attribute. This is for internal use.
</p>
<p>See the examples in order to join using an 'all' argument that is the same
arguments to join, like you can do with <code>merge.zoo()</code>.
</p>


<h3>Value</h3>

<p>A new xts object containing the appropriate elements of the
objects passed in to be merged.
</p>


<h3>Note</h3>

<p>This is a highly optimized merge, specifically designed for ordered
data. The only supported merging is based on the underlying time index.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p>Merge Join Discussion:
<a href="https://blogs.msdn.microsoft.com/craigfr/2006/08/03/merge-join/">https://blogs.msdn.microsoft.com/craigfr/2006/08/03/merge-join/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- xts(4:10, Sys.Date()+4:10))
(y &lt;- xts(1:6, Sys.Date()+1:6))

merge(x,y)
merge(x,y, join='inner')
merge(x,y, join='left')
merge(x,y, join='right')

merge.zoo(zoo(x),zoo(y),zoo(x), all=c(TRUE, FALSE, TRUE))
merge(merge(x,x),y,join='left')[,c(1,3,2)]

# zero-width objects (only index values) can be used
xi &lt;- xts( , index(x))
merge(y, xi)

</code></pre>

<hr>
<h2 id='na.locf.xts'>Last Observation Carried Forward</h2><span id='topic+na.locf.xts'></span>

<h3>Description</h3>

<p><span class="pkg">xts</span> method replace <code>NA</code> with most recent non-NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
na.locf(object, na.rm = FALSE, fromLast = FALSE, maxgap = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.locf.xts_+3A_object">object</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="na.locf.xts_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether leading/trailing <code>NA</code> should be
removed. The default is <code>FALSE</code> unlike the zoo method.</p>
</td></tr>
<tr><td><code id="na.locf.xts_+3A_fromlast">fromLast</code></td>
<td>
<p>Logical indicating whether observations should be carried
backward rather than forward. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="na.locf.xts_+3A_maxgap">maxgap</code></td>
<td>
<p>Consecutive runs of observations more than 'maxgap' will
remain <code>NA</code>. See <code><a href="zoo.html#topic+zoo">na.locf()</a></code> for details.</p>
</td></tr>
<tr><td><code id="na.locf.xts_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <span class="pkg">xts</span> method for the S3 generic <code>na.locf()</code>. The primary
difference to note is that after the <code>NA</code> fill action is carried out, the
default it to leave trailing or leading <code>NA</code>'s in place. This is different
than <span class="pkg">zoo</span> behavior.
</p>


<h3>Value</h3>

<p>An object where each <code>NA</code> in <code>object</code> is replaced by the most recent
non-NA prior to it. See <code><a href="zoo.html#topic+zoo">na.locf()</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">na.locf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- xts(1:10, Sys.Date()+1:10)
x[c(1,2,5,9,10)] &lt;- NA

x
na.locf(x)
na.locf(x, fromLast=TRUE)
na.locf(x, na.rm=TRUE, fromLast=TRUE)

</code></pre>

<hr>
<h2 id='nseconds'>Number of Periods in Data</h2><span id='topic+nseconds'></span><span id='topic+nminutes'></span><span id='topic+nhours'></span><span id='topic+ndays'></span><span id='topic+nweeks'></span><span id='topic+nmonths'></span><span id='topic+nquarters'></span><span id='topic+nyears'></span>

<h3>Description</h3>

<p>Calculate the number of specified periods in a given time series like data
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nseconds(x)

nminutes(x)

nhours(x)

ndays(x)

nweeks(x)

nmonths(x)

nquarters(x)

nyears(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nseconds_+3A_x">x</code></td>
<td>
<p>A time-based object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially a wrapper to <code>endpoints()</code> with the appropriate period
specified. The result is the number of endpoints found.
</p>
<p>As a compromise between simplicity and accuracy, the results will always
round up to the nearest complete period. Subtract 1 from the result to
get the completed periods.
</p>
<p>For finer grain detail one should call the higher frequency functions.
</p>
<p>An alternative summary can be found with <code>periodicity(x)</code> and
<code>unclass(periodicity(x))</code>.
</p>


<h3>Value</h3>

<p>The number of respective periods in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endpoints">endpoints()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
getSymbols("QQQQ")

ndays(QQQQ)
nweeks(QQQQ)

## End(Not run)

</code></pre>

<hr>
<h2 id='period.apply'>Apply Function Over Specified Interval</h2><span id='topic+period.apply'></span>

<h3>Description</h3>

<p>Apply a specified function to data over intervals specified by <code>INDEX</code>. The
intervals are defined as the observations from <code>INDEX[k]+1</code> to <code>INDEX[k+1]</code>,
for <code>k = 1:(length(INDEX)-1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period.apply(x, INDEX, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period.apply_+3A_x">x</code></td>
<td>
<p>The data that <code>FUN</code> will be applied to.</p>
</td></tr>
<tr><td><code id="period.apply_+3A_index">INDEX</code></td>
<td>
<p>A numeric vector of index breakpoint locations. The vector
should begin with 0 and end with <code>nrow(x)</code>.</p>
</td></tr>
<tr><td><code id="period.apply_+3A_fun">FUN</code></td>
<td>
<p>A function to apply to each interval in <code>x</code>.</p>
</td></tr>
<tr><td><code id="period.apply_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to the rest of the apply family, <code>period.apply()</code> calculates the
specified function's value over a subset of data. The primary difference is
that <code>period.apply()</code> applies the function to non-overlapping intervals of a
vector or matrix.
</p>
<p>Useful for applying functions over an entire data object by any
non-overlapping intervals. For example, when <code>INDEX</code> is the result of a
call to <code>endpoints()</code>.
</p>
<p><code>period.apply()</code> checks that <code>INDEX</code> is sorted, unique, starts with 0, and
ends with <code>nrow(x)</code>. All those conditions are true of vectors returned by
<code>endpoints()</code>.
</p>


<h3>Value</h3>

<p>An object with <code>length(INDEX) - 1</code> observations, assuming <code>INDEX</code>
starts with 0 and ends with <code>nrow(x)</code>.
</p>


<h3>Note</h3>

<p>When <code>FUN = mean</code> the results will contain one column for every
column in the input, which is different from other math functions (e.g.
<code>median</code>, <code>sum</code>, <code>prod</code>, <code>sd</code>, etc.).
</p>
<p><code>FUN = mean</code> works by column because the default method <code>stats::mean</code>
previously worked by column for matrices and data.frames. R Core changed the
behavior of <code>mean</code> to always return one column in order to be consistent
with the other math functions. This broke some <span class="pkg">xts</span> dependencies and
<code>mean.xts()</code> was created to maintain the original behavior.
</p>
<p>Using <code>FUN = mean</code> will print a message that describes this inconsistency.
To avoid the message and confusion, use <code>FUN = colMeans</code> to calculate means
by column and use <code>FUN = function(x) mean</code> to calculate one mean for all the
data. Set <code>options(xts.message.period.apply.mean = FALSE)</code> to suppress this
message.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan, Joshua M. Ulrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endpoints">endpoints()</a></code> <code><a href="#topic+apply.monthly">apply.monthly()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zoo.data &lt;- zoo(rnorm(31)+10,as.Date(13514:13744,origin="1970-01-01"))
ep &lt;- endpoints(zoo.data,'weeks')
period.apply(zoo.data, INDEX=ep, FUN=function(x) colMeans(x))
period.apply(zoo.data, INDEX=ep, FUN=colMeans)                  #same

period.apply(letters,c(0,5,7,26), paste0)

</code></pre>

<hr>
<h2 id='period.sum'>Optimized Calculations By Period</h2><span id='topic+period.sum'></span><span id='topic+period.prod'></span><span id='topic+period.max'></span><span id='topic+period.min'></span>

<h3>Description</h3>

<p>Calculate a sum, product, minimum, or maximum for each non-overlapping
period specified by <code>INDEX</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period.sum(x, INDEX)

period.prod(x, INDEX)

period.max(x, INDEX)

period.min(x, INDEX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period.sum_+3A_x">x</code></td>
<td>
<p>A univariate data object.</p>
</td></tr>
<tr><td><code id="period.sum_+3A_index">INDEX</code></td>
<td>
<p>A numeric vector of endpoints for each period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are similar to calling <code>period.apply()</code> with the same
endpoints and function. There may be slight differences in the results due
to numerical accuracy.
</p>
<p>For xts-coercible objects, an appropriate <code>INDEX</code> can be created by a call
to <code>endpoints()</code>.
</p>


<h3>Value</h3>

<p>An xts or zoo object containing the sum, product, minimum, or
maximum for each endpoint in <code>INDEX</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endpoints">endpoints()</a></code>, <code><a href="#topic+period.apply">period.apply()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 1, 4, 2, 2, 6, 7, 8, -1, 20)
i &lt;- c(0, 3, 5, 8, 10)

period.sum(x, i)
period.prod(x, i)
period.min(x, i)
period.max(x, i)

data(sample_matrix)
y &lt;- sample_matrix[, 1]
ep &lt;- endpoints(sample_matrix)

period.sum(y, ep)
period.sum(as.xts(y), ep)

period.prod(y, ep)
period.prod(as.xts(y), ep)

period.min(y, ep)
period.min(as.xts(y), ep)

period.max(y, ep)
period.max(as.xts(y), ep)

</code></pre>

<hr>
<h2 id='periodicity'>Approximate Series Periodicity</h2><span id='topic+periodicity'></span>

<h3>Description</h3>

<p>Estimate the periodicity of a time-series-like object by calculating the
median time between observations in days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodicity(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodicity_+3A_x">x</code></td>
<td>
<p>A time-series-like object.</p>
</td></tr>
<tr><td><code id="periodicity_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple wrapper to quickly estimate the periodicity of a given data.
Returning an object of type <code>periodicity</code>.
</p>
<p>This calculates the median time difference between observations as a
difftime object, the numerical difference, the units of measurement, and the
derived scale of the data as a string.
</p>
<p>The time index currently must be of either a 'Date' or 'POSIXct' class, or
or coercible to one of them.
</p>
<p>The 'scale' component of the result is an estimate of the periodicity of the
data in common terms - e.g. 7 day daily data is best described as 'weekly',
and would be returned as such.
</p>


<h3>Value</h3>

<p>A 'periodicity' object with the following elements:
</p>

<ul>
<li><p> the <code>difftime</code> object,
</p>
</li>
<li><p> frequency: the median time difference between observations
</p>
</li>
<li><p> start: the first observation
</p>
</li>
<li><p> end: the last observation
</p>
</li>
<li><p> units: one of secs, mins, hours, or days
</p>
</li>
<li><p> scale: one of seconds, minute, hourly, daily, weekly, monthly, quarterly, or yearly
</p>
</li>
<li><p> label: one of second, minute, hour, day, week, month, quarter, year
</p>
</li></ul>

<p>Possible <code>scale</code> values are: &lsquo;minute&rsquo;, &lsquo;hourly&rsquo;, &lsquo;daily&rsquo;,
&lsquo;weekly&rsquo;, &lsquo;monthly&rsquo;, &lsquo;quarterly&rsquo;, and &lsquo;yearly&rsquo;.
</p>


<h3>Note</h3>

<p>This function only attempts to be a <em>good estimate</em> for the underlying
periodicity. If the series is too short, or has highly irregular periodicity,
the return values will not be accurate. That said, it is quite robust and
used internally within <span class="pkg">xts</span>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+difftime">difftime()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zoo.ts &lt;- zoo(rnorm(231),as.Date(13514:13744,origin="1970-01-01"))
periodicity(zoo.ts)

</code></pre>

<hr>
<h2 id='plot.xts'>Plotting xts Objects</h2><span id='topic+plot.xts'></span><span id='topic+lines.xts'></span><span id='topic+points.xts'></span>

<h3>Description</h3>

<p>Plotting for xts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
plot(
  x,
  y = NULL,
  ...,
  subset = "",
  panels = NULL,
  multi.panel = FALSE,
  col = 1:8,
  up.col = NULL,
  dn.col = NULL,
  bg = "#FFFFFF",
  type = "l",
  lty = 1,
  lwd = 2,
  lend = 1,
  main = deparse(substitute(x)),
  main.timespan = TRUE,
  observation.based = FALSE,
  log = FALSE,
  ylim = NULL,
  yaxis.same = TRUE,
  yaxis.left = TRUE,
  yaxis.right = TRUE,
  yaxis.ticks = 5,
  major.ticks = "auto",
  minor.ticks = NULL,
  grid.ticks.on = "auto",
  grid.ticks.lwd = 1,
  grid.ticks.lty = 1,
  grid.col = "darkgray",
  labels.col = "#333333",
  format.labels = TRUE,
  grid2 = "#F5F5F5",
  legend.loc = NULL,
  extend.xaxis = FALSE
)

## S3 method for class 'xts'
lines(
  x,
  ...,
  main = "",
  on = 0,
  col = NULL,
  type = "l",
  lty = 1,
  lwd = 1,
  pch = 1
)

## S3 method for class 'xts'
points(x, ..., main = "", on = 0, col = NULL, pch = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.xts_+3A_x">x</code></td>
<td>
<p>A xts object.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_y">y</code></td>
<td>
<p>Not used, always <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_...">...</code></td>
<td>
<p>Any passthrough arguments for <code>lines()</code> and <code>points()</code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_subset">subset</code></td>
<td>
<p>An ISO8601-style subset string.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_panels">panels</code></td>
<td>
<p>Character vector of expressions to plot as panels.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_multi.panel">multi.panel</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code>, or an integer less than or equal
to the number of columns in the data set. When <code>TRUE</code>, each column of the
data is plotted in a separate panel. When an integer 'n', the data will be
plotted in groups of 'n' columns per panel and each group will be plotted
in a separate panel.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_col">col</code></td>
<td>
<p>Color palette to use.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_up.col">up.col</code></td>
<td>
<p>Color for positive bars when <code>type = "h"</code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_dn.col">dn.col</code></td>
<td>
<p>Color for negative bars when <code>type = "h"</code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_bg">bg</code></td>
<td>
<p>Background color of plotting area, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_type">type</code></td>
<td>
<p>The type of plot to be drawn, same as in <code><a href="base.html#topic+plot">plot()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_lty">lty</code></td>
<td>
<p>Set the line type, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_lwd">lwd</code></td>
<td>
<p>Set the line width, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_lend">lend</code></td>
<td>
<p>Set the line end style, same as in <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_main">main</code></td>
<td>
<p>Main plot title.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_main.timespan">main.timespan</code></td>
<td>
<p>Should the timespan of the series be shown in the top
right corner of the plot?</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_observation.based">observation.based</code></td>
<td>
<p>When <code>TRUE</code>, all the observations are equally spaced
along the x-axis. When <code>FALSE</code> (the default) the observations on the x-axis
are spaced based on the time index of the data.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_log">log</code></td>
<td>
<p>Should the y-axis be in log scale? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_ylim">ylim</code></td>
<td>
<p>The range of the y axis.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_yaxis.same">yaxis.same</code></td>
<td>
<p>Should 'ylim' be the same for every panel? Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_yaxis.left">yaxis.left</code></td>
<td>
<p>Add y-axis labels to the left side of the plot?</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_yaxis.right">yaxis.right</code></td>
<td>
<p>Add y-axis labels to the right side of the plot?</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_yaxis.ticks">yaxis.ticks</code></td>
<td>
<p>Desired number of y-axis grid lines. The actual number of
grid lines is determined by the <code>n</code> argument to <code><a href="base.html#topic+pretty">pretty()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_major.ticks">major.ticks</code></td>
<td>
<p>Period specifying locations for major tick marks and labels
on the x-axis. See Details for possible values.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_minor.ticks">minor.ticks</code></td>
<td>
<p>Period specifying locations for minor tick marks on the
x-axis. When <code>NULL</code>, minor ticks are not drawn. See details for possible
values.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid.ticks.on">grid.ticks.on</code></td>
<td>
<p>Period specifying locations for vertical grid lines.
See details for possible values.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid.ticks.lwd">grid.ticks.lwd</code></td>
<td>
<p>Line width of the grid.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid.ticks.lty">grid.ticks.lty</code></td>
<td>
<p>Line type of the grid.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid.col">grid.col</code></td>
<td>
<p>Color of the grid.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_labels.col">labels.col</code></td>
<td>
<p>Color of the axis labels.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_format.labels">format.labels</code></td>
<td>
<p>Label format to draw lower frequency x-axis ticks and
labels passed to <code><a href="#topic+axTicksByTime">axTicksByTime()</a></code></p>
</td></tr>
<tr><td><code id="plot.xts_+3A_grid2">grid2</code></td>
<td>
<p>Color for secondary x-axis grid.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_legend.loc">legend.loc</code></td>
<td>
<p>Places a legend into one of nine locations on the chart:
bottomright, bottom, bottomleft, left, topleft, top, topright, right, or
center. Default <code>NULL</code> does not draw a legend.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_extend.xaxis">extend.xaxis</code></td>
<td>
<p>When <code>TRUE</code>, extend the x-axis before and/or after the
plot's existing time index range, so all of of the time index values of
the new series are included in the plot. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_on">on</code></td>
<td>
<p>Panel number to draw on. A new panel will be drawn if <code>on = NA</code>.
The default, <code>on = 0</code>, will add to the active panel. The active panel is
defined as the panel on which the most recent action was performed. Note
that only the first element of <code>on</code> is checked for the default behavior to
add to the last active panel.</p>
</td></tr>
<tr><td><code id="plot.xts_+3A_pch">pch</code></td>
<td>
<p>the plotting character to use, same as in 'par'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for arguments <code>major.ticks</code>, <code>minor.ticks</code>, and
<code>grid.ticks.on</code> include &lsquo;auto&rsquo;, &lsquo;minute&rsquo;, &lsquo;hours&rsquo;,
&lsquo;days&rsquo;, &lsquo;weeks&rsquo;, &lsquo;months&rsquo;, &lsquo;quarters&rsquo;, and
&lsquo;years&rsquo;. The default is &lsquo;auto&rsquo;, which attempts to determine
sensible locations from the periodicity and locations of observations. The
other values are based on the possible values for the <code>ticks.on</code>
argument of <code><a href="#topic+axTicksByTime">axTicksByTime()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>References</h3>

<p>based on <code><a href="quantmod.html#topic+quantmod-package">chart_Series()</a></code> in <span class="pkg">quantmod</span>
written by Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addSeries">addSeries()</a></code>, <code><a href="#topic+addPanel">addPanel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix)

# plot the Close
plot(sample.xts[,"Close"])

# plot a subset of the data
plot(sample.xts[,"Close"], subset = "2007-04-01/2007-06-31")

# function to compute simple returns
simple.ret &lt;- function(x, col.name){
  x[,col.name] / lag(x[,col.name]) - 1
}

# plot the close and add a panel with the simple returns
plot(sample.xts[,"Close"])
R &lt;- simple.ret(sample.xts, "Close")
lines(R, type = "h", on = NA)

# add the 50 period simple moving average to panel 1 of the plot
library(TTR)
lines(SMA(sample.xts[,"Close"], n = 50), on = 1, col = "blue")

# add month end points to the chart
points(sample.xts[endpoints(sample.xts[,"Close"], on = "months"), "Close"], 
       col = "red", pch = 17, on = 1)

# add legend to panel 1
addLegend("topright", on = 1, 
          legend.names = c("Close", "SMA(50)"), 
          lty = c(1, 1), lwd = c(2, 1),
          col = c("black", "blue", "red"))

## End(Not run)

</code></pre>

<hr>
<h2 id='print.xts'>Print An xts Time-Series Object</h2><span id='topic+print.xts'></span>

<h3>Description</h3>

<p>Method for printing an extensible time-series object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
print(x, fmt, ..., show.rows = 10, max.rows = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="print.xts_+3A_fmt">fmt</code></td>
<td>
<p>Passed to <code><a href="zoo.html#topic+coredata">coredata()</a></code> to format the time index.</p>
</td></tr>
<tr><td><code id="print.xts_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="print.xts_+3A_show.rows">show.rows</code></td>
<td>
<p>The number of first and last rows to print if the number of
rows is truncated (default 10, or <code>getOption("xts.print.show.rows")</code>).</p>
</td></tr>
<tr><td><code id="print.xts_+3A_max.rows">max.rows</code></td>
<td>
<p>The output will contain at most <code>max.rows</code> rows before being
truncated (default 100, or <code>getOption("xts.print.max.rows")</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Joshua M. Ulrich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix)

# output is truncated and shows first and last 10 observations
print(sample.xts)

# show the first and last 5 observations
print(sample.xts, show.rows = 5)

</code></pre>

<hr>
<h2 id='sample_matrix'>Sample Data Matrix For xts Example and Unit Testing</h2><span id='topic+sample_matrix'></span>

<h3>Description</h3>

<p>Simulated 180 observations on 4 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample_matrix)
</code></pre>


<h3>Format</h3>

<pre>The format is:
  num [1:180, 1:4] 50.0 50.2 50.4 50.4 50.2 ...
  - attr(*, "dimnames")=List of 2
    ..$ : chr [1:180] "2007-01-02" "2007-01-03" "2007-01-04" "2007-01-05" ...
    ..$ : chr [1:4] "Open" "High" "Low" "Close" </pre>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sample_matrix)

</code></pre>

<hr>
<h2 id='split.xts'>Divide into Groups by Time</h2><span id='topic+split.xts'></span>

<h3>Description</h3>

<p>Creates a list of xts objects split along time periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
split(x, f = "months", drop = FALSE, k = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="split.xts_+3A_f">f</code></td>
<td>
<p>A character vector describing the period to split by.</p>
</td></tr>
<tr><td><code id="split.xts_+3A_drop">drop</code></td>
<td>
<p>Ignored by <code>split.xts()</code>.</p>
</td></tr>
<tr><td><code id="split.xts_+3A_k">k</code></td>
<td>
<p>Number of periods to aggregate into each split. See details.</p>
</td></tr>
<tr><td><code id="split.xts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A quick way to break up a large xts object by standard time periods; e.g.
'months', 'quarters', etc.
</p>
<p><code><a href="#topic+endpoints">endpoints()</a></code> is used to find the start and end of each period (or
k-periods). See that function for valid arguments.
</p>
<p>The inputs are passed to <code><a href="zoo.html#topic+split.zoo">split.zoo()</a></code> when <code>f</code> is not a character vector.
</p>


<h3>Value</h3>

<p>A list of xts objects.
</p>


<h3>Note</h3>

<p><code><a href="zoo.html#topic+aggregate.zoo">aggregate.zoo()</a></code> is more flexible, though not as fast for xts
objects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endpoints">endpoints()</a></code>, <code><a href="zoo.html#topic+zoo">split.zoo()</a></code>, <code><a href="zoo.html#topic+zoo">aggregate.zoo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sample_matrix)
x &lt;- as.xts(sample_matrix)


split(x)
split(x, f="weeks")
split(x, f="weeks", k=4)

</code></pre>

<hr>
<h2 id='tclass'>Get or Replace the Class of an xts Object's Index</h2><span id='topic+tclass'></span><span id='topic+tclass.default'></span><span id='topic+tclass.xts'></span><span id='topic+tclass+3C-'></span><span id='topic+tclass+3C-.default'></span><span id='topic+indexClass'></span><span id='topic+indexClass+3C-'></span><span id='topic+tclass+3C-.xts'></span>

<h3>Description</h3>

<p>Generic functions to get or replace the class of an xts object's index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclass(x, ...)

## Default S3 method:
tclass(x, ...)

## S3 method for class 'xts'
tclass(x, ...)

tclass(x) &lt;- value

## Default S3 replacement method:
tclass(x) &lt;- value

indexClass(x)

indexClass(x) &lt;- value

## S3 replacement method for class 'xts'
tclass(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tclass_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="tclass_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="tclass_+3A_value">value</code></td>
<td>
<p>The new index class (see Details for valid values).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, an xts object's index is a <em>numeric</em> value corresponding to
seconds since the epoch in the UTC timezone. The index class is stored as
the <code>tclass</code> attribute on the internal index. This is used to convert
the internal index values to the desired class when the <code>index</code>
function is called.
</p>
<p>The <code>tclass</code> function retrieves the class of the internal index, and
the <code style="white-space: pre;">&#8288;tclass&lt;-&#8288;</code> function sets it. The specified value for
<code style="white-space: pre;">&#8288;tclass&lt;-&#8288;</code> must be one of the following character strings:
<code>"Date"</code>, <code>"POSIXct"</code>, <code>"chron"</code>, <code>"yearmon"</code>,
<code>"yearqtr"</code>, or <code>"timeDate"</code>.
</p>


<h3>Value</h3>

<p>A vector containing the class of the object's index.
</p>


<h3>Note</h3>

<p>Both <code>indexClass</code> and <code style="white-space: pre;">&#8288;indexClass&lt;-&#8288;</code> are deprecated in favor
of <code>tclass</code> and <code style="white-space: pre;">&#8288;tclass&lt;-&#8288;</code>, respectively.
</p>
<p>Replacing the <code>tclass</code> can <em>potentially change</em> the values of the internal
index. For example, changing the 'tclass' from POSIXct to Date will
truncate the POSIXct value and convert the timezone to UTC (since the Date
class doesn't have a timezone). See the examples.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+index">index()</a></code> has more information on the xts index, <code><a href="#topic+tformat">tformat()</a></code>
details how the index values are formatted when printed, and <code><a href="#topic+tzone">tzone()</a></code>
has more information about the index timezone settings.
</p>
<p>The following help pages describe the characteristics of the valid index
classes: <code><a href="base.html#topic+POSIXct">POSIXct()</a></code>, <code><a href="base.html#topic+Date">Date()</a></code>, <a href="chron.html#topic+chron">chron()</a>,
<code><a href="zoo.html#topic+zoo">yearmon()</a></code>, <code><a href="zoo.html#topic+zoo">yearqtr()</a></code>,
<code><a href="timeDate.html#topic+timeDate">timeDate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- timeBasedSeq('2010-01-01/2010-01-02 12:00')
x &lt;- xts(seq_along(x), x)

y &lt;- timeBasedSeq('2010-01-01/2010-01-03 12:00/H')
y &lt;- xts(seq_along(y), y, tzone = "America/New_York")

# Changing the tclass *changes* the internal index values
head(y)          # the index has times
head(.index(y))
tclass(y) &lt;- "Date"
head(y)          # the index prints as a Date
head(.index(y))  # the internal index is truncated

</code></pre>

<hr>
<h2 id='tformat'>Get or Replace the Format of an xts Object's Index</h2><span id='topic+tformat'></span><span id='topic+tformat+3C-'></span><span id='topic+indexFormat'></span><span id='topic+indexFormat+3C-'></span>

<h3>Description</h3>

<p>Generic functions to get or replace the format that determines how an xts
object's index is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tformat(x, ...)

tformat(x) &lt;- value

indexFormat(x)

indexFormat(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tformat_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="tformat_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="tformat_+3A_value">value</code></td>
<td>
<p>New index format string (see <code><a href="base.html#topic+strptime">strptime()</a></code> details for valid
values).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid values for the <code>value</code> argument are the same as specified in the
<em>Details</em> section of <code><a href="base.html#topic+strptime">strptime()</a></code>.
</p>
<p>An xts object's <code>tformat</code> is <code>NULL</code> by default, so the index will be
be formatted according to its <code><a href="#topic+tclass">tclass()</a></code> (e.g. Date, POSIXct, timeDate,
yearmon, etc.).
</p>
<p>The <code>tformat</code> only changes how the index is <em>printed</em> and how the row names
are formatted when xts objects are converted to other classes (e.g. matrix
or data.frame). It does not affect the internal index in any way.
</p>


<h3>Value</h3>

<p>A vector containing the format for the object's index.
</p>


<h3>Note</h3>

<p>Both <code>indexFormat()</code> and <code style="white-space: pre;">&#8288;indexFormat&lt;-&#8288;</code> are deprecated in
favor of <code>tformat()</code> and <code style="white-space: pre;">&#8288;tformat&lt;-&#8288;</code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+index">index()</a></code> has more information on the xts index, <code><a href="#topic+tclass">tclass()</a></code>
details how <span class="pkg">xts</span> handles the class of the index, <code><a href="#topic+tzone">tzone()</a></code> has more
information about the index timezone settings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- timeBasedSeq('2010-01-01/2010-01-02 12:00')
x &lt;- xts(seq_along(x), x)

# set a custom index format
head(x)
tformat(x) &lt;- "%Y-%b-%d %H:%M:%OS3"
head(x)

</code></pre>

<hr>
<h2 id='timeBasedRange'>Create a Sequence or Range of Times</h2><span id='topic+timeBasedRange'></span><span id='topic+timeBasedSeq'></span>

<h3>Description</h3>

<p>A function to create a vector of time-based objects suitable for indexing an
xts object, given a string conforming to the ISO-8601 time and date standard
for range-based specification. The resulting series can be of any class
supported by xts, including POSIXct, Date, chron, timeDate, yearmon, and
yearqtr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeBasedRange(x, ...)

timeBasedSeq(x, retclass = NULL, length.out = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeBasedRange_+3A_x">x</code></td>
<td>
<p>An ISO-8601 time-date range string.</p>
</td></tr>
<tr><td><code id="timeBasedRange_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="timeBasedRange_+3A_retclass">retclass</code></td>
<td>
<p>The return class desired.</p>
</td></tr>
<tr><td><code id="timeBasedRange_+3A_length.out">length.out</code></td>
<td>
<p>Passed to <code>seq()</code> internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>timeBasedRange()</code> creates a one or two element numeric vector representing
the start and end number of seconds since epoch (1970-01-01). For internal
use.
</p>
<p><code>timeBasedSeq()</code> creates sequences of time-based observations using strings
formatted according to the ISO-8601 specification. The general format is
<em>from/to/by</em> or <em>from::to::by</em>, where <em>to</em> and <em>by</em> are optional when the
'length.out' argument is specified.
</p>
<p>The <em>from</em> and <em>to</em> elements of the string must be left-specified with
respect to the standard <em>CCYYMMDD HHMMSS</em> form. All dates/times specified
will be set to either the earliest point (from) or the latest (to), to the
given the level of specificity. For example, &lsquo;1999&rsquo; in the <em>from</em>
field would set the start to the beginning of 1999. &lsquo;1999&rsquo; in the
<em>to</em> field would set the end to the end of 1999.
</p>
<p>The amount of resolution in the result is determined by the resolution of
the <em>from</em> and <em>to</em> component, unless the optional <em>by</em> component is
specified.
</p>
<p>For example, <code>timeBasedSeq("1999/2008")</code> returns a vector of Dates for
January 1st of each year. <code>timeBasedSeq("199501/1996")</code> returns a yearmon
vector of 24 months in 1995 and 1996. And <code>timeBasedSeq("19950101/1996")</code>
creates a Date vector for all the days in those two years.
</p>
<p>The optional <em>by</em> field (the third delimited element to the string), will
the resolution heuristic described above and will use the specified <em>by</em>
resolution. The possible values for <em>by</em> are: 'Y' (years), 'm' (months),
'd' (days), 'H' (hours), 'M' (minutes), 'S' (seconds). Sub-second
resolutions are not supported.
</p>


<h3>Value</h3>

<p><code>timeBasedSeq()</code> returns a vector of time-based observations.
<code>timeBasedRange()</code> returns a one or two element numeric vector representing
the start and end number of seconds since epoch (1970-01-01).
</p>
<p>When <code>retclass = NULL</code>, the result of <code>timeBasedSeq()</code> is a named list
containing elements &quot;from&quot;, &quot;to&quot;, &quot;by&quot; and &quot;length.out&quot;.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p>International Organization for Standardization: ISO 8601
<a href="https://www.iso.org">https://www.iso.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timeBased">timeBased()</a></code>, <code><a href="#topic+xts">xts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
timeBasedSeq('1999/2008')
timeBasedSeq('199901/2008')
timeBasedSeq('199901/2008/d')
timeBasedSeq('20080101 0830',length=100) # 100 minutes
timeBasedSeq('20080101 083000',length=100) # 100 seconds

</code></pre>

<hr>
<h2 id='to.period'>Convert time series data to an OHLC series</h2><span id='topic+to.period'></span><span id='topic+to_period'></span><span id='topic+to.minutes'></span><span id='topic+to.minutes3'></span><span id='topic+to.minutes5'></span><span id='topic+to.minutes10'></span><span id='topic+to.minutes15'></span><span id='topic+to.minutes30'></span><span id='topic+to.hourly'></span><span id='topic+to.daily'></span><span id='topic+to.weekly'></span><span id='topic+to.monthly'></span><span id='topic+to.quarterly'></span><span id='topic+to.yearly'></span>

<h3>Description</h3>

<p>Convert an OHLC or univariate object to a specified periodicity lower than
the given data object. For example, convert a daily series to a monthly
series, or a monthly series to a yearly one, or a one minute series to an
hourly series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.period(
  x,
  period = "months",
  k = 1,
  indexAt = NULL,
  name = NULL,
  OHLC = TRUE,
  ...
)

to.minutes(x, k, name, ...)

to.minutes3(x, name, ...)

to.minutes5(x, name, ...)

to.minutes10(x, name, ...)

to.minutes15(x, name, ...)

to.minutes30(x, name, ...)

to.hourly(x, name, ...)

to.daily(x, drop.time = TRUE, name, ...)

to.weekly(x, drop.time = TRUE, name, ...)

to.monthly(x, indexAt = "yearmon", drop.time = TRUE, name, ...)

to.quarterly(x, indexAt = "yearqtr", drop.time = TRUE, name, ...)

to.yearly(x, drop.time = TRUE, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.period_+3A_x">x</code></td>
<td>
<p>A univariate or OHLC type time-series object.</p>
</td></tr>
<tr><td><code id="to.period_+3A_period">period</code></td>
<td>
<p>Period to convert to. See details.</p>
</td></tr>
<tr><td><code id="to.period_+3A_k">k</code></td>
<td>
<p>Number of sub periods to aggregate on (only for minutes and
seconds).</p>
</td></tr>
<tr><td><code id="to.period_+3A_indexat">indexAt</code></td>
<td>
<p>Convert final index to new class or date. See details.</p>
</td></tr>
<tr><td><code id="to.period_+3A_name">name</code></td>
<td>
<p>Override column names?</p>
</td></tr>
<tr><td><code id="to.period_+3A_ohlc">OHLC</code></td>
<td>
<p>Should an OHLC object be returned? (only <code>OHLC = TRUE</code>
currently supported)</p>
</td></tr>
<tr><td><code id="to.period_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="to.period_+3A_drop.time">drop.time</code></td>
<td>
<p>Remove time component of POSIX datestamp (if any)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result will contain the open and close for the given period, as well as
the maximum and minimum over the new period, reflected in the new high and
low, respectively. Aggregate volume will also be calculated if applicable.
</p>
<p>An easy and reliable way to convert one periodicity of data into any new
periodicity. It is important to note that all dates will be aligned to the
<em>end</em> of each period by default - with the exception of <code>to.monthly()</code> and
<code>to.quarterly()</code>, which use the <span class="pkg">zoo</span> package's <a href="zoo.html#topic+zoo">yearmon</a> and
<a href="zoo.html#topic+zoo">yearqtr</a> classes, respectively.
</p>
<p>Valid period character strings include: <code>"seconds"</code>, <code>"minutes"</code>, <code>"hours"</code>,
<code>"days"</code>, <code>"weeks"</code>, <code>"months"</code>, <code>"quarters"</code>, and <code>"years"</code>. These are
calculated internally via <code><a href="#topic+endpoints">endpoints()</a></code>. See that function's help page for
further details.
</p>
<p>To adjust the final indexing style, it is possible to set <code>indexAt</code> to one
of the following: &lsquo;yearmon&rsquo;, &lsquo;yearqtr&rsquo;, &lsquo;firstof&rsquo;,
&lsquo;lastof&rsquo;, &lsquo;startof&rsquo;, or &lsquo;endof&rsquo;. The final index will
then be <code>yearmon</code>, <code>yearqtr</code>, the first time of the period, the last time
of the period, the starting time in the data for that period, or the ending
time in the data for that period, respectively.
</p>
<p>It is also possible to pass a single time series, such as a univariate
exchange rate, and return an OHLC object of lower frequency - e.g. the
weekly OHLC of the daily series.
</p>
<p>Setting <code>drop.time = TRUE</code> (the default) will convert a series that includes
a time component into one with just a date index, since the time component
is often of little value in lower frequency series.
</p>


<h3>Value</h3>

<p>An object of the original type, with new periodicity.
</p>


<h3>Note</h3>

<p>In order for this function to work properly on OHLC data, it is
necessary that the Open, High, Low and Close columns be names as such;
including the first letter capitalized and the full spelling found.
Internally a call is made to reorder the data into the correct column order,
and then a verification step to make sure that this ordering and naming has
succeeded. All other data formats must be aggregated with functions such as
<code>aggregate()</code> and <code>period.apply()</code>.
</p>
<p>This method should work on almost all time-series-like objects. Including
&lsquo;timeSeries&rsquo;, &lsquo;zoo&rsquo;, &lsquo;ts&rsquo;, and &lsquo;irts&rsquo;. It is
even likely to work well for other data structures - including
&lsquo;data.frames&rsquo; and &lsquo;matrix&rsquo; objects.
</p>
<p>Internally a call to <code>as.xts()</code> converts the original <code>x</code> into the
universal xts format, and then re-converts back to the original type.
</p>
<p>A special note with respect to &lsquo;ts&rsquo; objects. As these are strictly
regular they may include <code>NA</code> values. These are removed before aggregation,
though replaced before returning the result. This inevitably leads to many
additional <code>NA</code> values in the result. Consider using an xts object or
converting to xts using <code>as.xts()</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sample_matrix)

samplexts &lt;- as.xts(sample_matrix)

to.monthly(samplexts)
to.monthly(sample_matrix)

str(to.monthly(samplexts))
str(to.monthly(sample_matrix))

</code></pre>

<hr>
<h2 id='try.xts'>Convert Objects to xts and Back to Original Class</h2><span id='topic+try.xts'></span><span id='topic+use.xts'></span><span id='topic+reclass'></span><span id='topic+Reclass'></span><span id='topic+use.reclass'></span>

<h3>Description</h3>

<p>Functions to convert objects of arbitrary classes to xts and then back to
the original class, without losing any attributes of the original class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try.xts(x, ..., error = TRUE)

reclass(x, match.to, error = FALSE, ...)

Reclass(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try.xts_+3A_x">x</code></td>
<td>
<p>Data object to convert. See details for supported types.</p>
</td></tr>
<tr><td><code id="try.xts_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
<tr><td><code id="try.xts_+3A_error">error</code></td>
<td>
<p>Error handling option. See Details.</p>
</td></tr>
<tr><td><code id="try.xts_+3A_match.to">match.to</code></td>
<td>
<p>An xts object whose attributes will be copied to the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple and reliable way to convert many different objects into a uniform
format for use within <span class="rlang"><b>R</b></span>.
</p>
<p><code>try.xts()</code> and <code>reclass()</code> are functions that enable external developers
access to the reclassing tools within <span class="pkg">xts</span> to help speed development of
time-aware functions, as well as provide a more robust and seemless end-user
experience, regardless of the end-user's choice of data-classes.
</p>
<p><code>try.xts()</code> calls <code>as.xts()</code> internally. See <code><a href="#topic+as.xts">as.xts()</a></code> for available xts
methods and arguments for each coercible class. Since it calls <code>as.xts()</code>,
you can add custom attributes as <code>name = value</code> pairs in the same way. But
these custom attributes will not be copied back to the original object when
<code>reclass()</code> is called.
</p>
<p>The <code>error</code> argument can be a logical value indicating whether an error
should be thrown (or fail silently), a character string allowing for custom
error error messages, or a function of the form <code>f(x, ...)</code> that will be
called if the conversion fails.
</p>
<p><code>reclass()</code> converts an object created by <code>try.xts()</code> back to its original
class with all the original attributes intact (unless they were changed
after the object was converted to xts). The <code>match.to</code> argument allows you
copy the index attributes (<code><a href="#topic+tclass">tclass</a></code>, <code><a href="#topic+tformat">tformat</a></code>, and <code><a href="#topic+tzone">tzone</a></code>) and
<code><a href="#topic+xtsAttributes">xtsAttributes()</a></code> from another xts object to the result. <code>match.to</code> must
be an xts object with an index value for every observation in <code>x</code>.
</p>
<p><code>Reclass()</code> is designed for top-level use, where it is desirable to have
the object returned from an arbitrary function in the same class as the
object passed in. Most functions in <span class="rlang"><b>R</b></span> are not designed to return objects
matching the original object's class. It attempts to handle conversion and
reconversion transparently but it requires the original object must be
coercible to xts, the result of the function must have the same number of
rows as the input, and the object to be converted/reclassed must be the
first argument to the function being wrapped. Note that this function
hasn't been tested for robustness.
</p>
<p>See the accompanying vignette for more details on the above usage.
</p>


<h3>Value</h3>

<p><code>try.xts()</code> returns an xts object when conversion is successful.
The <code>error</code> argument controls the function's behavior when conversion fails.
</p>
<p><code>Reclass()</code> and <code>reclass()</code> return the object as its original class, as
specified by the 'CLASS' attribute.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.xts">as.xts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- 1:10

# fails silently, the result is still an integer vector
try.xts(a, error = FALSE)

# control the result with a function
try.xts(a, error = function(x, ...) { "I'm afraid I can't do that." })

z &lt;- zoo(1:10, timeBasedSeq("2020-01-01/2020-01-10"))
x &lt;- try.xts(z)  # zoo to xts
str(x)
str(reclass(x))  # reclass back to zoo

</code></pre>

<hr>
<h2 id='window.xts'>Extract Time Windows from xts Objects</h2><span id='topic+window.xts'></span>

<h3>Description</h3>

<p>Method for extracting time windows from xts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
window(x, index. = NULL, start = NULL, end = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window.xts_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="window.xts_+3A_index.">index.</code></td>
<td>
<p>A user defined time index (default <code>.index(x)</code>).</p>
</td></tr>
<tr><td><code id="window.xts_+3A_start">start</code></td>
<td>
<p>A start time coercible to POSIXct.</p>
</td></tr>
<tr><td><code id="window.xts_+3A_end">end</code></td>
<td>
<p>An end time coercible to POSIXct.</p>
</td></tr>
<tr><td><code id="window.xts_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The xts <code>window()</code> method provides an efficient way to subset an xts object
between a start and end date using a binary search algorithm. Specifically,
it converts <code>start</code> and <code>end</code> to POSIXct and then does a binary search of
the index to quickly return a subset of <code>x</code> between <code>start</code> and <code>end</code>.
</p>
<p>Both <code>start</code> and <code>end</code> may be any class that is convertible to POSIXct, such
as a character string in the format &lsquo;yyyy-mm-dd&rsquo;. When <code>start = NULL</code>
the returned subset will begin at the first value of <code>index.</code>. When
<code>end = NULL</code> the returned subset will end with the last value of <code>index.</code>.
Otherwise the subset will contain all timestamps where <code>index.</code> is between
<code>start</code> and <code>end</code>, inclusive.
</p>
<p>When <code>index.</code> is specified, <code><a href="base.html#topic+findInterval">findInterval()</a></code> is used to quickly retrieve
large sets of sorted timestamps. For the best performance, <code>index.</code> must be
a <em>sorted</em> POSIXct vector or a numeric vector of seconds since the epoch.
<code>index.</code> is typically a subset of the timestamps in <code>x</code>.
</p>


<h3>Value</h3>

<p>The subset of <code>x</code> that matches the time window.
</p>


<h3>Author(s)</h3>

<p>Corwin Joy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset.xts">subset.xts()</a></code>, <code><a href="base.html#topic+findInterval">findInterval()</a></code>, <code><a href="#topic+xts">xts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## xts example
x.date &lt;- as.Date(paste(2003, rep(1:4, 4:1), seq(1,19,2), sep = "-"))
x &lt;- xts(matrix(rnorm(20), ncol = 2), x.date)
x

window(x, start = "2003-02-01", end = "2003-03-01")
window(x, start = as.Date("2003-02-01"), end = as.Date("2003-03-01"))
window(x, index. = x.date[1:6], start = as.Date("2003-02-01"))
window(x, index. = x.date[c(4, 8, 10)])

## Assign to subset
window(x, index. = x.date[c(4, 8, 10)]) &lt;- matrix(1:6, ncol = 2)
x

</code></pre>

<hr>
<h2 id='xts'>Create or Test For An xts Time-Series Object</h2><span id='topic+xts'></span><span id='topic+.xts'></span><span id='topic+is.xts'></span>

<h3>Description</h3>

<p>Constructor function for creating an extensible time-series object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xts(
  x = NULL,
  order.by = index(x),
  frequency = NULL,
  unique = TRUE,
  tzone = Sys.getenv("TZ"),
  ...
)

.xts(
  x = NULL,
  index,
  tclass = c("POSIXct", "POSIXt"),
  tzone = Sys.getenv("TZ"),
  check = TRUE,
  unique = FALSE,
  ...
)

is.xts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xts_+3A_x">x</code></td>
<td>
<p>An object containing the underlying data.</p>
</td></tr>
<tr><td><code id="xts_+3A_order.by">order.by</code></td>
<td>
<p>A corresponding vector of dates/times of a known time-based
class. See Details.</p>
</td></tr>
<tr><td><code id="xts_+3A_frequency">frequency</code></td>
<td>
<p>Numeric value indicating the frequency of <code>order.by</code>. See
details.</p>
</td></tr>
<tr><td><code id="xts_+3A_unique">unique</code></td>
<td>
<p>Can the index only include unique timestamps? Ignored when
<code>check = FALSE</code>.</p>
</td></tr>
<tr><td><code id="xts_+3A_tzone">tzone</code></td>
<td>
<p>Time zone of the index (ignored for indices without a time
component, e.g. Date, yearmon, yearqtr). See <code><a href="#topic+tzone">tzone()</a></code>.</p>
</td></tr>
<tr><td><code id="xts_+3A_...">...</code></td>
<td>
<p>Additional attributes to be added. See details.</p>
</td></tr>
<tr><td><code id="xts_+3A_index">index</code></td>
<td>
<p>A corresponding <em>numeric</em> vector specified as seconds since
the UNIX epoch (1970-01-01 00:00:00.000).</p>
</td></tr>
<tr><td><code id="xts_+3A_tclass">tclass</code></td>
<td>
<p>Time class to use for the index. See <code><a href="#topic+tclass">tclass()</a></code>.</p>
</td></tr>
<tr><td><code id="xts_+3A_check">check</code></td>
<td>
<p>Must the index be ordered? The index cannot contain duplicates
when <code>check = TRUE</code> and <code>unique = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xts()</code> is used to create an xts object from raw data inputs. The xts class
inherits from and extends the zoo class, which means most zoo functions can
be used on xts objects.
</p>
<p>The <code>xts()</code> constructor is the preferred way to create xts objects. It
performs several checks to ensure it returns a well-formed xts object. The
<code>.xts()</code> constructor is mainly for internal use. It is more efficient then
the regular <code>xts()</code> constructor because it doesn't perform as many validity
checks. Use it with caution.
</p>
<p>Similar to zoo objects, xts objects must have an ordered index. While zoo
indexes cannot contain duplicate values, xts objects have optionally
supported duplicate index elements since version 0.5-0. The xts class has
one additional requirement: the index must be a time-based class. Currently
supported classes include: &lsquo;Date&rsquo;, &lsquo;POSIXct&rsquo;, &lsquo;timeDate&rsquo;,
as well as &lsquo;yearmon&rsquo; and &lsquo;yearqtr&rsquo; where the index values
remain unique.
</p>
<p>The uniqueness requirement was relaxed in version 0.5-0, but is still
enforced by default. Setting <code>unique = FALSE</code> skips the uniqueness check and
only ensures that the index is ordered via the <code>isOrdered()</code> function.
</p>
<p>As of version 0.10-0, xts no longer allows missing values in the index. This
is because many xts functions expect all index values to be finite. The most
important of these is <code>merge.xts()</code>, which is used ubiquitously. Missing
values in the index are usually the result of a date-time conversion error
(e.g. incorrect format, non-existent time due to daylight saving time, etc.).
Because of how non-finite numbers are represented, a missing timestamp will
always be at the end of the index (except if it is <code>-Inf</code>, which will be
first).
</p>
<p>Another difference from <span class="pkg">zoo</span> is that xts object may carry additional
attributes that may be desired in individual time-series handling. This
includes the ability to augment the objects data with meta-data otherwise
not cleanly attachable to a standard zoo object. These attributes may be
assigned and extracted via <code><a href="#topic+xtsAttributes">xtsAttributes()</a></code> and <code><a href="#topic+xtsAttributes+3C-">xtsAttributes&lt;-</a></code>,
respectively.
</p>
<p>Examples of usage from finance may include the addition of data for keeping
track of sources, last-update times, financial instrument descriptions or
details, etc.
</p>
<p>The idea behind <span class="pkg">xts</span> is to offer the user the ability to utilize a
standard zoo object, while providing an mechanism to customize the object's
meta-data, as well as create custom methods to handle the object in a manner
required by the user.
</p>
<p>Many xts-specific methods have been written to better handle the unique
aspects of xts. These include, subsetting (<code>[</code>), <code>merge()</code>, <code>cbind()</code>,
<code>rbind()</code>, <code>c()</code>, math and logical operations, <code>lag()</code>, <code>diff()</code>,
<code>coredata()</code>, <code>head()</code>, and <code>tail()</code>. There are also xts-specific methods
for converting to/from R's different time-series classes.
</p>
<p>Subsetting via <code>[</code> methods offers the ability to specify dates by range, if
they are enclosed in quotes. The style borrows from python by creating
ranges separated by a double colon &ldquo;&quot;::&quot;&rdquo; or &ldquo;&quot;/&quot;&rdquo;. Each side
of the range may be left blank, which would then default to the start and
end of the data, respectively. To specify a subset of times, it is only
required that the time specified be in standard ISO format, with some form
of separation between the elements. The time must be <em>left-filled</em>, that is
to specify a full year one needs only to provide the year, a month requires
the full year and the integer of the month requested - e.g. '1999-01'. This
format would extend all the way down to seconds - e.g. '1999-01-01 08:35:23'.
Leading zeros are not necessary. See the examples for more detail.
</p>
<p>Users may also extend the xts class to new classes to allow for method
overloading.
</p>
<p>Additional benefits derive from the use of <code><a href="#topic+as.xts">as.xts()</a></code> and <code><a href="#topic+reclass">reclass()</a></code>,
which allow for lossless two-way conversion between common R time-series
classes and the xts object structure. See those functions for more detail.
</p>


<h3>Value</h3>

<p>An S3 object of class xts.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan and Joshua M. Ulrich
</p>


<h3>References</h3>

<p><span class="pkg">zoo</span>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.xts">as.xts()</a></code>, <code><a href="zoo.html#topic+index">index()</a></code>, <code><a href="#topic+tclass">tclass()</a></code>, <code><a href="#topic+tformat">tformat()</a></code>, <code><a href="#topic+tzone">tzone()</a></code>,
<code><a href="#topic+xtsAttributes">xtsAttributes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix, descr='my new xts object')

class(sample.xts)
str(sample.xts)

head(sample.xts)  # attribute 'descr' hidden from view
attr(sample.xts,'descr')

sample.xts['2007']  # all of 2007
sample.xts['2007-03/']  # March 2007 to the end of the data set
sample.xts['2007-03/2007']  # March 2007 to the end of 2007
sample.xts['/'] # the whole data set
sample.xts['/2007'] # the beginning of the data through 2007
sample.xts['2007-01-03'] # just the 3rd of January 2007

</code></pre>

<hr>
<h2 id='xts-internals'>Internal Documentation</h2><span id='topic+xts-internals'></span>

<h3>Description</h3>

<p>This help file is to help in development of xts, as well as provide some
clarity and insight into its purpose and implementation.
</p>


<h3>Details</h3>

<p>Last modified: 2008-08-06 by Jeffrey A. Ryan Version: 0.5-0 and above
</p>
<p>The <span class="pkg">xts</span> package xts designed as a drop-in replacement for the very
popular <span class="pkg">zoo</span> package.  Most all functionality of zoo has been extended
or carries into the xts package.
</p>
<p>Notable changes in direction include the use of time-based indexing, at
first explicitely, now implicitely.
</p>
<p>An xts object consists of data in the form of a matrix, an index -
ordered and increasing, either numeric or integer, and additional attributes
for use internally, or for end-user purposes.
</p>
<p>The current implementation enforces two major rules on the object.  One is
that the index must be coercible to numeric, by way of <code>as.POSIXct</code>.
There are defined types that meet this criteria. See <code>timeBased</code> for
details.
</p>
<p>The second requirement is that the object cannot have rownames. The
motivation from this comes in part from the work Matthew Doyle has done in
his data.table class, in the package of the same name.  Rownames in must be
character vectors, and as such are inefficient in both storage and
conversion.  By eliminating the rownames, and providing a numeric index of
internal type <code>REAL</code> or <code>INTEGER</code>, it is possible to maintain a
connection to standard date and time classes via the POSIXct functions,
while at at the same time maximizing efficiencies in data handling.
</p>
<p>User level functions <code>index</code>, as well as conversion to other classes
proceeds as if there were rownames.  The code for <code>index</code> automatically
converts time to numeric in both extraction and replacement functionality.
This provides a level of abstraction to facilitate internal, and external
package use and inter-operability.
</p>
<p>There is also new work on providing a C-level API to some of the xts
functionality to facilitate external package developers to utilize the fast
utility routines such as subsetting and merges, without having to call only
from .  Obviously this places far more burden on the developer to not only
understand the internal xts implementation, but also to understand all of
what is documented for R-internals (and much that isn't). At present the
functions and macros available can be found in the &lsquo;xts.h&rsquo; file in
the src directory.
</p>
<p>There is no current documentation for this API.  The adventure starts here.
Future documentation is planned, not implemented.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>

<hr>
<h2 id='xtsAPI'>xts C API Documentation</h2><span id='topic+xtsAPI'></span>

<h3>Description</h3>

<p>This help file is to help in development of xts, as well as provide some
clarity and insight into its purpose and implementation.
</p>


<h3>Details</h3>

<p>By Jeffrey A. Ryan, Dirk Eddelbuettel, and Joshua M. Ulrich Last modified:
2018-05-02 Version: 0.10-3 and above
</p>
<p>At present the <span class="pkg">xts</span> API has publicly available interfaces to the
following functions (as defined in <code>xtsAPI.h</code>):
</p>
<pre>Callable from other R packages:
  SEXP xtsIsOrdered(SEXP x, SEXP increasing, SEXP strictly)
  SEXP xtsNaCheck(SEXP x, SEXP check)
  SEXP xtsTry(SEXP x)
  SEXP xtsRbind(SEXP x, SEXP y, SEXP dup)
  SEXP xtsCoredata(SEXP x)
  SEXP xtsLag(SEXP x, SEXP k, SEXP pad)

Internal use functions:
  SEXP isXts(SEXP x)
  void copy_xtsAttributes(SEXP x, SEXP y)
  void copy_xtsCoreAttributes(SEXP x, SEXP y)

Internal use macros:
  xts_ATTRIB(x)
  xts_COREATTRIB(x)
  GET_xtsIndex(x)
  SET_xtsIndex(x,value)
  GET_xtsIndexFormat(x)
  SET_xtsIndexFormat(x,value)
  GET_xtsCLASS(x)
  SET_xtsCLASS(x,value)

Internal use SYMBOLS:
  xts_IndexSymbol
  xts_ClassSymbol
  xts_IndexFormatSymbol

Callable from R:
  SEXP mergeXts(SEXP args)
  SEXP rbindXts(SEXP args)
  SEXP tryXts(SEXP x)
</pre>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# some example code to look at

file.show(system.file('api_example/README', package="xts"))
file.show(system.file('api_example/src/checkOrder.c', package="xts"))

## End(Not run)

</code></pre>

<hr>
<h2 id='xtsAttributes'>Extract and Replace xts Attributes</h2><span id='topic+xtsAttributes'></span><span id='topic+xtsAttributes+3C-'></span>

<h3>Description</h3>

<p>Extract and replace non-core xts attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtsAttributes(x, user = NULL)

xtsAttributes(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtsAttributes_+3A_x">x</code></td>
<td>
<p>An xts object.</p>
</td></tr>
<tr><td><code id="xtsAttributes_+3A_user">user</code></td>
<td>
<p>Should user-defined attributes be returned? The default of
<code>NULL</code> returns all xts attributes.</p>
</td></tr>
<tr><td><code id="xtsAttributes_+3A_value">value</code></td>
<td>
<p>A list of new <code>name = value</code> attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows users to assign custom attributes to the xts objects,
without altering core xts attributes (i.e. tclass, tzone, and tformat).
</p>
<p><code><a href="base.html#topic+attributes">attributes()</a></code> returns all attributes, including core attributes of the
xts class.
</p>


<h3>Value</h3>

<p>A named list of user-defined attributes.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+attributes">attributes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- xts(matrix(1:(9*6),nc=6),
         order.by=as.Date(13000,origin="1970-01-01")+1:9,
         a1='my attribute')

xtsAttributes(x)
xtsAttributes(x) &lt;- list(a2=2020)

xtsAttributes(x)
xtsAttributes(x) &lt;- list(a1=NULL)
xtsAttributes(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
