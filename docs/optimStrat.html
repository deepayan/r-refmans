<!DOCTYPE html><html><head><title>Help for package optimStrat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optimStrat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#optimStrat-package'><p>optimStrat</p></a></li>
<li><a href='#covp'><p>Covariance</p></a></li>
<li><a href='#desvar'><p>Design variance</p></a></li>
<li><a href='#expgreg'><p>Expected variance of the general regression estimator</p></a></li>
<li><a href='#expvar'><p>Expected variance</p></a></li>
<li><a href='#optiallo'><p>Optimal allocation in stratified simple random sampling</p></a></li>
<li><a href='#optimApp'><p>Interactive Web-based Application of optimStrat</p></a></li>
<li><a href='#pinc'>
<p>Inclusion probabilities in a PIps design</p></a></li>
<li><a href='#simulatey'><p>Simulate the Study Variable</p></a></li>
<li><a href='#skewness'><p>Sample Skewness</p></a></li>
<li><a href='#stratify'><p>Stratification of an Auxiliary Variable</p></a></li>
<li><a href='#vargreg'>
<p>Design variance of the general regression estimator.</p></a></li>
<li><a href='#varp'><p>Variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Choosing the Sample Strategy</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Edgar Bueno &lt;edgar.bueno@stat.su.se&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edgar Bueno &lt;edgar.bueno@stat.su.se&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>shiny, mvtnorm, cubature</td>
</tr>
<tr>
<td>Description:</td>
<td>Intended to assist in the choice of the sampling strategy to implement in a survey.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 05:12:21 UTC; edgar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='optimStrat-package'>optimStrat</h2><span id='topic+optimStrat-package'></span><span id='topic+optimStrat'></span>

<h3>Description</h3>

<p>OptimStrat is a package intended to assist in the choice of the sample strategy to implement in a survey. It allows for calculating the variance and the expected variance of several sampling strategies.</p>


<h3>Details</h3>

<p>The package includes a function to calculate the design variance of several sampling strategies. It also includes a function to calculate the expected variance under a superpopuation model and a web-based application where the user can compare five sampling strategies in order to determine which one to implement in a survey.
</p>


<h3>Author(s)</h3>

<p>Edgar Bueno
</p>


<h3>References</h3>

<p>Bueno, E. (2018). <em>A Comparison of Stratified Simple Random Sampling and Probability Proporional-to-size Sampling.</em> Research Report, Department of Statistics, Stockholm University 2018:6. <a href="http://gauss.stat.su.se/rr/RR2018_6.pdf">http://gauss.stat.su.se/rr/RR2018_6.pdf</a>.
</p>

<hr>
<h2 id='covp'>Covariance</h2><span id='topic+covp'></span>

<h3>Description</h3>

<p>Compute the covariance between <code>x</code> and <code>y</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>covp(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covp_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="covp_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the covariance between <code>x</code> and <code>y</code> using <code class="reqn">n</code> (instead of <code class="reqn">n-1</code> as in <code><a href="stats.html#topic+cov">cov</a></code>) in the denominator.
</p>
<p>If the length of <code>x</code> and <code>y</code> are different, the elements of the shortest one will be recycled as necessary.
</p>


<h3>Value</h3>

<p>An object with the covariance between <code>x</code> and <code>y</code>.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov">cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;- rnorm(100)
y&lt;- rnorm(100)
covp(x, y)
cov(x, y)
</code></pre>

<hr>
<h2 id='desvar'>Design variance</h2><span id='topic+desvar'></span>

<h3>Description</h3>

<p>Compute the design variance of six sampling strategies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>desvar(y, x, n, H, d2, d4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desvar_+3A_y">y</code></td>
<td>
<p>a numeric vector giving the values of the study variable.</p>
</td></tr>
<tr><td><code id="desvar_+3A_x">x</code></td>
<td>
<p>a positive numeric vector giving the values of the auxiliary variable.</p>
</td></tr>
<tr><td><code id="desvar_+3A_n">n</code></td>
<td>
<p>a positive integer indicating the desired sample size.</p>
</td></tr>
<tr><td><code id="desvar_+3A_h">H</code></td>
<td>
<p>a positive integer giving the desired number of strata/poststrata.</p>
</td></tr>
<tr><td><code id="desvar_+3A_d2">d2</code></td>
<td>
<p>a number giving the <em>assumed</em> shape of the trend term in the superpopulation model.</p>
</td></tr>
<tr><td><code id="desvar_+3A_d4">d4</code></td>
<td>
<p>a number giving the <em>assumed</em> shape of the spread term in the superpopulation model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The design variance of a sample of size <code>n</code> is computed for six sampling strategies (stsi&ndash;HT, <code class="reqn">\pi</code>ps&ndash;HT, stsi&ndash;pos, <code class="reqn">\pi</code>ps&ndash;pos, stsi&ndash;reg and <code class="reqn">\pi</code>ps&ndash;pos). The strategies are defined assuming that there is an underlying superpopulation model of the form
</p>
<p style="text-align: center;"><code class="reqn">Y_{k}=\delta_{0}+\delta_{1}x_{k}^{\delta_{2}}+\epsilon_{k}</code>
</p>

<p>with <code class="reqn">E\epsilon_{k}=0</code>, <code class="reqn">V\epsilon_{k}=\delta_{3}^{2}x_{k}^{2\delta_{4}}</code> and <code class="reqn">Cov(\epsilon_{k},\epsilon_{l})=0</code>.
</p>
<p>The number of strata/poststrata is given by <code>H</code>.
</p>


<h3>Value</h3>

<p>A vector of length six with the variance of the six sampling strategies.</p>


<h3>References</h3>

<p>Bueno, E. (2018). <em>A Comparison of Stratified Simple Random Sampling and Probability Proporional-to-size Sampling.</em> Research Report, Department of Statistics, Stockholm University 2018:6. <a href="http://gauss.stat.su.se/rr/RR2018_6.pdf">http://gauss.stat.su.se/rr/RR2018_6.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expvar">expvar</a></code> for the expected variance of five sampling strategies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f&lt;- function(x,b0,b1,b2,...) {b0+b1*x^b2}
g&lt;- function(x,b3,...) {x^b3}
x&lt;- 1 + sort( rgamma(5000, shape=4/9, scale=108) )
y&lt;- simulatey(x,f,g,dist="gamma",b0=10,b1=1,b2=1.25,b3=0.5,rho=0.90)

desvar(y,x,n=500,H=6,d2=1.25,d4=0.50)
desvar(y,x,n=500,H=6,d2=1.00,d4=1.00)
</code></pre>

<hr>
<h2 id='expgreg'>Expected variance of the general regression estimator</h2><span id='topic+expgreg'></span>

<h3>Description</h3>

<p>Compute the expected design variance of the general regression estimator of the total of a study variable under different sampling designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expgreg(x, b11, b12, b21, b22, d12, Rfy, n, design = NULL, 
        stratum = NULL, x_des = NULL, inc.p = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expgreg_+3A_x">x</code></td>
<td>
<p>design matrix with the variables to be used into the GREG estimator.</p>
</td></tr>
<tr><td><code id="expgreg_+3A_b11">b11</code></td>
<td>
<p>a numeric vector of length equal to the number of variables in <code>x</code> giving the coefficients of the trend term in the <em>true</em> superpopulation model (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expgreg_+3A_b12">b12</code></td>
<td>
<p>a numeric vector of length equal to the number of variables in <code>x</code> giving the exponents of the trend term in the <em>true</em> superpopulation model (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expgreg_+3A_b21">b21</code></td>
<td>
<p>a numeric vector of length equal to the number of variables in <code>x</code> giving the coefficients of the spread term in the <em>true</em> superpopulation model (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expgreg_+3A_b22">b22</code></td>
<td>
<p>a numeric vector of length equal to the number of variables in <code>x</code> giving the exponents of the spread term in the <em>true</em> superpopulation model (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expgreg_+3A_d12">d12</code></td>
<td>
<p>a numeric vector of length equal to the number of variables in <code>x</code> giving the exponents of the trend term in the <em>assumed</em> superpopulation model (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expgreg_+3A_rfy">Rfy</code></td>
<td>
<p>a number giving the square root of the coefficient of determination between the auxiliary variables and the study varible.</p>
</td></tr>
<tr><td><code id="expgreg_+3A_n">n</code></td>
<td>
<p>either a positive number indicating the (expected) sample size (when <code>design</code> is one of 'srs', 'poi', 'pips' or <code>NULL</code>) or a numeric vector indicating the sample size of the strata to which each element belongs (when <code>design</code> is 'stsi') (see &lsquo;Examples&rsquo;).</p>
</td></tr>
<tr><td><code id="expgreg_+3A_design">design</code></td>
<td>
<p>a character string giving the sampling design. It must be one of 'srs' (simple random sampling without replacement),  'poi' (Poisson sampling), 'stsi' (stratified simple random sampling), 'pips' (Pareto <code class="reqn">\pi</code>ps sampling) or <code>NULL</code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expgreg_+3A_stratum">stratum</code></td>
<td>
<p>a vector indicating the stratum to which every unit belongs. Only used if <code>design</code> is 'stsi'.</p>
</td></tr>
<tr><td><code id="expgreg_+3A_x_des">x_des</code></td>
<td>
<p>a positive numeric vector giving the values of the auxiliary variable that is used for defining the inclusion probabilities. Only used if <code>design</code> is 'poi' or 'pips'.</p>
</td></tr>
<tr><td><code id="expgreg_+3A_inc.p">inc.p</code></td>
<td>
<p>a matrix giving the first and second order inclusion probabilities. Only used if <code>design</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="expgreg_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="stats.html#topic+lm">lm</a></code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected variance of the general regression estimator under different sampling designs is computed.
</p>
<p>It is assumed that the underlying superpopulation model is of the form
</p>
<p style="text-align: center;"><code class="reqn">Y_{k} = f(x_{k}|\delta_{1}) + \epsilon_{k}</code>
</p>

<p>with <code class="reqn">E\epsilon_{k}=0</code>, <code class="reqn">V\epsilon_{k}= \sigma_{0}^{2}g^{2}(x_{k}|\delta_{2})</code> and <code class="reqn">Cov(\epsilon_{k},\epsilon_{l})=0</code>.
</p>
<p>But the true generating model is in fact of the form
</p>
<p style="text-align: center;"><code class="reqn">Y_{k} = f(x_{k}|\beta_{1}) + \epsilon_{k}</code>
</p>

<p>with <code class="reqn">E\epsilon_{k}=0</code>, <code class="reqn">V\epsilon_{k}= \sigma^{2}g^{2}(x_{k}|\beta_{2})</code> and <code class="reqn">Cov(\epsilon_{k},\epsilon_{l})=0</code>.
</p>
<p>Where
</p>
<p style="text-align: center;"><code class="reqn">f(x_{k}|\delta_{1}) = \sum_{j=1}^{J}\delta_{1,j}x_{jk}^{\delta_{1,J+j}},</code>
</p>

<p style="text-align: center;"><code class="reqn">g(x_{k}|\delta_{2}) = \sum_{j=1}^{J}\delta_{2,j}x_{jk}^{\delta_{2,J+j}},</code>
</p>

<p style="text-align: center;"><code class="reqn">f(x_{k}|\beta_{1}) = \sum_{j=1}^{J}\beta_{1,j}x_{jk}^{\beta_{1,J+j}},</code>
</p>

<p style="text-align: center;"><code class="reqn">g(x_{k}|\beta_{2}) = \sum_{j=1}^{J}\beta_{2,j}x_{jk}^{\beta_{2,J+j}}.</code>
</p>


<ul>
<li><p> the coefficients <code class="reqn">\beta_{1,j}</code> (<code class="reqn">j=1,\cdots,J</code>) are given by <code>b11</code>;
</p>
</li>
<li><p> the exponents <code class="reqn">\beta_{1,j}</code> (<code class="reqn">j=J+1,\cdots,2J</code>) are given by <code>b12</code>;
</p>
</li>
<li><p> the coefficients <code class="reqn">\beta_{2,j}</code> (<code class="reqn">j=1,\cdots,J</code>) are given by <code>b21</code>;
</p>
</li>
<li><p> the exponents <code class="reqn">\beta_{2,j}</code> (<code class="reqn">j=J+1,\cdots,2J</code>) are given by <code>b22</code>;
</p>
</li>
<li><p> the exponents <code class="reqn">\delta_{1,j}</code> (<code class="reqn">j=J+1,\cdots,2J</code>) are given by <code>d12</code>.
</p>
</li></ul>

<p>The expected variance of the GREG estimator is approximated by
</p>
<p style="text-align: center;"><code class="reqn">E\left(V\left(\hat{t}\right)\right) = V\left(\hat{t}_{z}\right) + \hat{\sigma}^{2}\sum_{k=1}^{N}\left(\frac{1}{\pi_{k}}-1\right)g^{2}(x_{k}|\beta_{2})</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">V\left(\hat{t}_{z}\right) = \sum_{k=1}^{N}\sum_{l=1}^{N}\pi_{kl}\frac{z_{k}}{\pi_{k}}\frac{z_{l}}{\pi_{l}} - \left(\sum_{k=1}^{N}z_{k}\right)^{2}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\hat{\sigma}^{2} = \frac{S^{2}_{f}}{\bar{g^{2}}}\left(\frac{1}{R^{2}_{fy}}-1\right),</code>
</p>

<p style="text-align: center;"><code class="reqn">z_{k} = \left(x_{k}^{\beta}-x_{k}^{\delta}A\right)\beta_{1}^{**},</code>
</p>

<p style="text-align: center;"><code class="reqn">S^{2}_{f} = \sum_{k=1}^{N}(f(x_{k}|\beta_{1})-\bar{f})^{2}/N,</code>
</p>

<p style="text-align: center;"><code class="reqn">\bar{g^{2}} = \sum_{k=1}^{N}g(x_{k}|\beta_{2})^{2}/N,</code>
</p>

<p style="text-align: center;"><code class="reqn">x_{k}^{\beta} = \left(x_{1k}^{\beta_{1,J+1}},\cdots,x_{Jk}^{\beta_{1,2J}}\right),</code>
</p>

<p style="text-align: center;"><code class="reqn">x_{k}^{\delta} = \left(x_{1k}^{\delta_{1,J+1}},\cdots,x_{Jk}^{\delta_{1,2J}}\right),</code>
</p>

<p style="text-align: center;"><code class="reqn">\beta_{1}^{**} = (\beta_{1,1},\cdots,\beta_{1,J})',</code>
</p>

<p style="text-align: center;"><code class="reqn">A = \left(\sum_{k=1}^{N}w_{k}x_{k}^{\delta'}x_{k}^{\delta}\right)^{-1}\sum_{k=1}^{N}w_{k}x_{k}^{\delta'}x_{k}^{\beta}.</code>
</p>
 
<p><code class="reqn">N</code> is the population size and <code class="reqn">\pi_{k}</code> and <code class="reqn">\pi_{kl}</code> are, respectively, the first and second order inclusion probabilities. <code class="reqn">w_{k}</code> is a weight associated to each element and it represents the inverse of the conditional variance (up to a scalar) of the underlying superpopulation model (see &lsquo;Examples&rsquo;).
</p>
<p>If <code>design=NULL</code>, the matrix of inclusion probabilities is obtained proportional to the matrix <code>p.inc</code>. If <code>design</code> is other than <code>NULL</code>, the formula for the variance is simplified in such a way that the inclusion probabilities matrix is no longer necessary. In particular:
</p>

<ul>
<li><p> if <code>design='srs'</code>, only the sample size <code>n</code> is required;
</p>
</li>
<li><p> if <code>design='stsi'</code>, both the stratum ID <code>stratum</code> and the sample size per stratum <code>n</code>, are required;
</p>
</li>
<li><p> if <code>design</code> is either <code>'pips'</code> or <code>'poi'</code>, the inclusion probabilities are obtained proportional to the values of <code>x_des</code>, corrected if necessary.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric value giving the expected variance of the general regression estimator for the desired design under the working and true models.</p>


<h3>References</h3>

<p>Bueno, E. (2018). <em>A Comparison of Stratified Simple Random Sampling and Probability Proportional-to-size Sampling.</em> Research Report, Department of Statistics, Stockholm University 2018:6. <a href="http://gauss.stat.su.se/rr/RR2018_6.pdf">http://gauss.stat.su.se/rr/RR2018_6.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expvar">expvar</a></code> for the simultaneous calculation of the expected variance of five sampling strategies under a superpopulation model; <code><a href="#topic+vargreg">vargreg</a></code> for the variance of the GREG estimator; <code><a href="#topic+desvar">desvar</a></code> for the simultaneous calculation of the variance of six sampling strategies; <code><a href="#topic+optimApp">optimApp</a></code> for an interactive application of <code>expgreg</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;- 1 + sort( rgamma(5000, shape=4/9, scale=108) )
x2&lt;- 1 + sort( rgamma(5000, shape=4/9, scale=108) )
x3&lt;- 1 + sort( rgamma(5000, shape=4/9, scale=108) )
x&lt;- cbind(x1,x2,x3)
expgreg(x,b11=c(1,-1,0),b12=c(1,1,0),b21=c(0,0,1),b22=c(0,0,0.5),
        d12=c(1,1,0),Rfy=0.8,n=150,"pips",x_des=x3)
expgreg(x,b11=c(1,-1,0),b12=c(1,1,0),b21=c(0,0,1),b22=c(0,0,0.5),
        d12=c(1,1,0),Rfy=0.8,n=150,"pips",x_des=x2)
expgreg(x,b11=c(1,-1,0),b12=c(1,1,0),b21=c(0,0,1),b22=c(0,0,0.5),
        d12=c(1,1,0),Rfy=0.8,n=150,"pips",x_des=x2,weights=1/x1)

st1&lt;- optiallo(n=150,x=x3,H=6)
expgreg(x,b11=c(1,-1,0),b12=c(1,1,0),b21=c(0,0,1),b22=c(0,0,0.5),
        d12=c(1,1,0),Rfy=0.8,n=st1$nh,"stsi",stratum=st1$stratum)
expgreg(x,b11=c(1,-1,0),b12=c(1,1,0),b21=c(0,0,1),b22=c(0,0,0.5),
        d12=c(1,0,1),Rfy=0.8,n=st1$nh,"stsi",stratum=st1$stratum)
expgreg(x,b11=c(1,-1,0),b12=c(1,1,0),b21=c(0,0,1),b22=c(0,0,0.5),
        d12=c(1,0,1),Rfy=0.8,n=st1$nh,"stsi",stratum=st1$stratum,weights=1/x1)
</code></pre>

<hr>
<h2 id='expvar'>Expected variance</h2><span id='topic+expvar'></span>

<h3>Description</h3>

<p>Compute the expected variance of five sampling strategies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>expvar(b, d, x, n, H, Rxy, stratum1 = NULL, stratum2 = NULL, st = 1:5,
   short = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expvar_+3A_b">b</code></td>
<td>
<p>a numeric vector of length two giving the <em>true</em> shapes of the 
trend and spread terms.</p>
</td></tr>
<tr><td><code id="expvar_+3A_d">d</code></td>
<td>
<p>a numeric vector of length two giving the <em>assumed</em> shapes of the 
trend and spread terms.</p>
</td></tr>
<tr><td><code id="expvar_+3A_x">x</code></td>
<td>
<p>a positive numeric vector giving the values of the auxiliary variable.</p>
</td></tr>
<tr><td><code id="expvar_+3A_n">n</code></td>
<td>
<p>a positive integer indicating the desired sample size.</p>
</td></tr>
<tr><td><code id="expvar_+3A_h">H</code></td>
<td>
<p>a positive integer giving the 
desired number of strata/poststrata. Ignored if <code>stratum1</code> and <code>stratum2</code> 
are given.</p>
</td></tr>
<tr><td><code id="expvar_+3A_rxy">Rxy</code></td>
<td>
<p>a number giving the correlation between the auxiliary variable and 
the study variable.</p>
</td></tr>
<tr><td><code id="expvar_+3A_stratum1">stratum1</code></td>
<td>
<p>a list giving stratum and sample sizes per stratum 
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expvar_+3A_stratum2">stratum2</code></td>
<td>
<p>a list giving stratum and sample sizes per stratum (see 
&lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expvar_+3A_st">st</code></td>
<td>
<p>a numeric vector indicating the strategies for which the expected variance is to be calculated (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="expvar_+3A_short">short</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default) a vector of length five is 
returned. If <code>TRUE</code> only the strategies given by <code>st</code> are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected variance of a sample of size <code>n</code> is computed for 
five sampling strategies (<code class="reqn">\pi</code>ps&ndash;reg, STSI&ndash;reg, STSI&ndash;HT, <code class="reqn">\pi</code>ps&ndash;pos and STSI&ndash;pos).
</p>
<p>The strategies are defined assuming that the underlying superpopulation model is of the form
</p>
<p style="text-align: center;"><code class="reqn">Y_{k}=\delta_{0}+\delta_{1}x_{k}^{\delta_{2}}+\epsilon_{k}</code>
</p>

<p>with <code class="reqn">E\epsilon_{k}=0</code>, <code class="reqn">V\epsilon_{k}=\delta_{3}^{2}x_{k}^{2\delta_{4}}</code> and <code class="reqn">Cov(\epsilon_{k} , \epsilon_{l}) = 0</code>. But the true generating model is of the form
</p>
<p style="text-align: center;"><code class="reqn">Y_{k}=\beta_{0}+\beta_{1}x_{k}^{\beta_{2}}+\epsilon_{k}</code>
</p>

<p>with <code class="reqn">E\epsilon_{k}=0</code>, <code class="reqn">V\epsilon_{k} = \beta_{3}^{2}x_{k}^{2\beta_{4}}</code> and <code class="reqn">Cov(\epsilon_{k},\epsilon_{l})=0</code>.
</p>
<p>The parameters <code class="reqn">\beta_2</code> and <code class="reqn">\beta_4</code> are given by <code>b</code>. The parameters <code class="reqn">\delta_2</code> and <code class="reqn">\delta_4</code> are given by <code>d</code>.
</p>
<p><code>stratum1</code> and <code>stratum2</code> are lists with two components (each with length <code>length(x)</code>): <code>stratum</code> indicates the stratum to which each element belongs and <code>nh</code> indicates the sample sizes to be selected in each stratum. They can be created via <code><a href="#topic+optiallo">optiallo</a></code>. <code>stratum1</code> gives the stratification for STSI&ndash;HT and the poststrata for <code class="reqn">\pi</code>ps&ndash;pos and STSI&ndash;pos; whereas <code>stratum2</code> gives the stratification for STSI&ndash;reg and STSI&ndash;pos. If <code>NULL</code>, <code><a href="#topic+optiallo">optiallo</a></code> is used for defining <code>H</code> strata/poststrata.
</p>
<p><code>st</code> indicates which variances to be calculated. If <code>1 in st</code>, the expected variance of <code class="reqn">\pi</code>ps&ndash;reg is calculated. If <code>2 in st</code>, the expected variance of STSI&ndash;reg is calculated, and so on.
</p>


<h3>Value</h3>

<p>If <code>short=FALSE</code> a vector of length five is returned giving the expected variance of the strategies given in <code>st</code>. <code>NA</code> is returned for those strategies not given in <code>st</code>. If <code>short=TRUE</code>, the <code>NA</code>s are omitted.</p>


<h3>References</h3>

<p>Bueno, E. (2018). <em>A Comparison of Stratified Simple Random Sampling and Probability Proportional-to-size Sampling.</em> Research Report, Department of Statistics, Stockholm University 2018:6. <a href="http://gauss.stat.su.se/rr/RR2018_6.pdf">http://gauss.stat.su.se/rr/RR2018_6.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optiallo">optiallo</a></code> for how to stratify an auxiliary variable and allocate the sample size; <code><a href="#topic+desvar">desvar</a></code> for calculating the variance of the five strategies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;- 1 + sort( rgamma(5000, shape=4/9, scale=108) )
expvar(b=c(1,1),d=c(1,1),x,n=500,H=6,Rxy=0.9)
expvar(b=c(1,1),d=c(1,1),x,n=500,H=6,Rxy=0.9,st=1:3)
expvar(b=c(1,1),d=c(1,1),x,n=500,H=6,Rxy=0.9,st=1:3,short=TRUE)

st1&lt;- optiallo(n=500,x,H=6)
post1&lt;- optiallo(n=500,x^1.5,H=10)
expvar(b=c(1,1),d=c(1,1),x,n=500,H=6,Rxy=0.9,
   stratum1=post1,stratum2=st1)
</code></pre>

<hr>
<h2 id='optiallo'>Optimal allocation in stratified simple random sampling</h2><span id='topic+optiallo'></span>

<h3>Description</h3>

<p>Allocates a sample of size <code>n</code> using Neyman optimal allocation in Stratified Simple Random Sampling.</p>


<h3>Usage</h3>

<pre><code class='language-R'>optiallo(n, x, stratum = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optiallo_+3A_n">n</code></td>
<td>
<p>a positive integer indicating the desired sample size.</p>
</td></tr>
<tr><td><code id="optiallo_+3A_x">x</code></td>
<td>
<p>a positive numeric vector giving the values of the auxiliary variable.</p>
</td></tr>
<tr><td><code id="optiallo_+3A_stratum">stratum</code></td>
<td>
<p>a vector indicating the stratum to which every unit belongs (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="optiallo_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+stratify">stratify</a></code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allocates a sample of size <code>n</code> using Neyman optimal allocation in Stratified Simple Random Sampling.
</p>
<p>If <code>stratum==NULL</code>, the stratification is generated via <code><a href="#topic+stratify">stratify</a></code>. Then at least the number of strata should be passed to <code><a href="#topic+stratify">stratify</a></code> using the argument <code>H</code>.
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>stratum</code></td>
<td>
<p>a vector indicating the stratum to which each element belongs.</p>
</td></tr>
<tr><td><code>nh</code></td>
<td>
<p>a vector indicating the sample size of the strata to which each element belongs.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+stratify">stratify</a></code> for defining the stratification using the cum-sqrt-rule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;- 1 + sort( rgamma(100, shape=4/9, scale=108) )
st1&lt;- stratify(x,H=6)
optiallo(n=30,x,stratum=st1)

optiallo(n=30,x,H=6)
</code></pre>

<hr>
<h2 id='optimApp'>Interactive Web-based Application of optimStrat</h2><span id='topic+optimApp'></span>

<h3>Description</h3>

<p>Call Shiny to run a web-based application of <code>optimStrat</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimApp()
</code></pre>


<h3>Author(s)</h3>

<p>Edgar Bueno, <a href="mailto:edgar.bueno@stat.su.se">edgar.bueno@stat.su.se</a></p>

<hr>
<h2 id='pinc'>
Inclusion probabilities in a PIps design
</h2><span id='topic+pinc'></span>

<h3>Description</h3>

<p>Compute the inclusion probabilities to be used in a PIps design with sample size equal to <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinc(n, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pinc_+3A_n">n</code></td>
<td>
<p>a positive integer indicating the desired sample size.</p>
</td></tr>
<tr><td><code id="pinc_+3A_x">x</code></td>
<td>
<p>a positive numeric vector giving the values of the auxiliary variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inclusion probabilities are calculated as <code class="reqn">n\times x_{k}/t_{x}</code> and corrected, if necessary, to ensure that they are smaller or equal than one.
</p>


<h3>Value</h3>

<p>A numeric vector giving the inclusion probability of each element.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;- 1 + sort( rgamma(100, shape=4/9, scale=108) )
pinc(n=30,x)
</code></pre>

<hr>
<h2 id='simulatey'>Simulate the Study Variable</h2><span id='topic+simulatey'></span>

<h3>Description</h3>

<p>Simulate values for the study variable based on the auxiliary variable <code>x</code> and an assumed superpopulation model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatey(x, f, g, dist = "normal", rho = NULL, Sigma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulatey_+3A_x">x</code></td>
<td>
<p>a numeric vector giving the values of the auxiliary variable.</p>
</td></tr>
<tr><td><code id="simulatey_+3A_f">f</code></td>
<td>
<p>the name of the function defining the desired trend (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="simulatey_+3A_g">g</code></td>
<td>
<p>the name of the function defining the desired spread (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="simulatey_+3A_dist">dist</code></td>
<td>
<p>the desired distribution of the study variable conditioned on the auxiliary variable. Either 'normal' or 'gamma' (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="simulatey_+3A_rho">rho</code></td>
<td>
<p>a number giving the absolute value of the desired correlation between <code>x</code> and the vector to be simulated.</p>
</td></tr>
<tr><td><code id="simulatey_+3A_sigma">Sigma</code></td>
<td>
<p>a nonnegative number giving the scale of the spread term in the superpopulation model. Ignored if <code>rho</code> is given (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="simulatey_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>f</code> and <code>g</code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of the study variable <code>y</code> are simulated using a superpopulation model defined as:
</p>
<p style="text-align: center;"><code class="reqn">Y_{k}=f(x_{k})+\epsilon_{k}</code>
</p>

<p>with <code class="reqn">E(\epsilon_{k}) = 0</code>, <code class="reqn">V(\epsilon_{k}) = \sigma^{2}g^{2}(x_{k})</code> and <code class="reqn">Cov(\epsilon_{k},\epsilon_{l}) = 0</code> if <code class="reqn">k\ne l</code>. Also <code class="reqn">Y_{k}|f(x_{k})</code> is distributed according to <code>dist</code>.
</p>
<p><code>f</code> and <code>g</code> should return a vector of the same length of <code>x</code>. Their first argument should be <code>x</code> and they should not share the name of any other argument. Both <code>f</code> and <code>g</code> should have the ... argument (see &lsquo;Examples&rsquo;).
</p>
<p>Note that <code>Sigma</code> defines the degree of association between <code>x</code> and <code>y</code>: the larger <code>Sigma</code>, the smaller the correlation, <code>rho</code>, and vice versa. For this reason only one of them should be defined. If both are defined, <code>Sigma</code> will be ignored.
</p>
<p>Depending on the trend function <code>f</code>, some correlations cannot be reached. In those cases, <code>Sigma</code> will automatically be set to zero, <code>dist</code> will automatically be set to 'normal' and <code>rho</code> will be ignored (see &lsquo;Examples&rsquo;).
</p>
<p>If the trend term takes negative values, <code>dist</code> will be automatically set to 'normal'.
</p>


<h3>Value</h3>

<p>A numeric vector giving the simulated value of <code>y</code> associated to each value in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f&lt;- function(x,b0,b1,b2,...) {b0+b1*x^b2}
g&lt;- function(x,b3,...) {x^b3}

x&lt;- 1 + sort( rgamma(5000, shape=4/9, scale=108) )

#Linear trend and homocedasticity
y1&lt;- simulatey(x,f,g,dist="normal",b0=0,b1=1,b2=1,b3=0,rho=0.90)
y2&lt;- simulatey(x,f,g,dist="gamma",b0=0,b1=1,b2=1,b3=0,rho=0.90)

#Linear trend and heterocedasticity
y3&lt;- simulatey(x,f,g,dist="normal",b0=0,b1=1,b2=1,b3=1,rho=0.90)
y4&lt;- simulatey(x,f,g,dist="gamma",b0=0,b1=1,b2=1,b3=1,rho=0.90)

#Quadratic trend and homocedasticity
y5&lt;- simulatey(x,f,g,dist="gamma",b0=0,b1=1,b2=2,b3=0,rho=0.80)

#Correlation of minus one
y6&lt;- simulatey(x,f,g,dist="normal",b0=0,b1=-1,b2=1,b3=0,rho=1)

#Desired correlation cannot be attained
y7&lt;- simulatey(x,f,g,dist="normal",b0=0,b1=1,b2=3,b3=0,rho=0.99)

#Negative expectation not possible under gamma distribution
y8&lt;- simulatey(x,f,g,dist="gamma",b0=0,b1=-1,b2=1,b3=0,rho=1) 

#Conditional variance of zero not possible under gamma distribution
y9&lt;- simulatey(x,f,g,dist="gamma",b0=0,b1=1,b2=3,b3=0,rho=0.99)
</code></pre>

<hr>
<h2 id='skewness'>Sample Skewness</h2><span id='topic+skewness'></span>

<h3>Description</h3>

<p>Calculate the sample skewness.</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewness_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="skewness_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the sample skewness of <code>x</code> as
</p>
<p style="text-align: center;"><code class="reqn">\frac{\frac{1}{N}\sum_{i=1}^{N}\left(x_{i}-\bar{x}\right)^{3}}{\left[\frac{1}{N-1}\sum_{i=1}^{N}\left(x_{i}-\bar{x}\right)^{2}\right]^{3/2}}</code>
</p>



<h3>Value</h3>

<p>A vector of length one giving the sample skewness of <code>x</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;- rnorm(1000)
skewness(x)
</code></pre>

<hr>
<h2 id='stratify'>Stratification of an Auxiliary Variable</h2><span id='topic+stratify'></span>

<h3>Description</h3>

<p>Stratify the auxiliary variable <code>x</code> into <code>H</code> strata using the cum-sqrt-rule.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratify(x, H, forced = FALSE, J = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratify_+3A_x">x</code></td>
<td>
<p>a positive numeric vector giving the values of the auxiliary variable.</p>
</td></tr>
<tr><td><code id="stratify_+3A_h">H</code></td>
<td>
<p>a positive integer smaller or equal than <code>length(x)</code> giving the desired number of strata.</p>
</td></tr>
<tr><td><code id="stratify_+3A_forced">forced</code></td>
<td>
<p>a logical value indicating if the number of strata <em>must</em> be exactly equal to <code>H</code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="stratify_+3A_j">J</code></td>
<td>
<p>a positive integer indicating the number of bins used for the cum-sqrt-rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cum-sqrt-rule is used in order to define <code>H</code> strata from the auxiliary vector <code>x</code>.
</p>
<p>Depending on some characteristics of <code>x</code>, e.g. high skewness, few observations or too many ties, the resulting stratification may have a number of strata other than <code>H</code>. Using <code>forced = TRUE</code> tries its best to obtain exactly <code>H</code> strata.
</p>
<p>Note that if <code>length(x) &lt; H</code> then <code>forced</code> will be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A numeric vector giving the stratum to which each observation in <code>x</code> belongs.</p>


<h3>References</h3>

<p>Sarndal, C.E., Swensson, B. and Wretman, J. (1992). <em>Model Assisted Survey Sampling</em>. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optiallo">optiallo</a></code> for allocating the sample into the strata using Neyman optimal allocation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;- 1 + sort( rgamma(100, shape=4/9, scale=108) )
stratify(x, H=3)
</code></pre>

<hr>
<h2 id='vargreg'>
Design variance of the general regression estimator.
</h2><span id='topic+vargreg'></span>

<h3>Description</h3>

<p>Compute the (approximated) design variance of the general regression estimator of the total of a study variable under different sampling designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vargreg(formula, design = NULL, n, stratum = NULL, 
        x_des = NULL, inc.p = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vargreg_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code>: a symbolic description of the model to be fitted. The details of model specification are given under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="vargreg_+3A_design">design</code></td>
<td>
<p>a character string giving the sampling design. It must be one of 'srs' (simple random sampling without replacement),  'poi' (Poisson sampling), 'stsi' (stratified simple random sampling), 'pips' (Pareto <code class="reqn">\pi</code>ps sampling) or <code>NULL</code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="vargreg_+3A_n">n</code></td>
<td>
<p>either a positive number indicating the (expected) sample size (when <code>design</code> is one of 'srs', 'poi', 'pips' or <code>NULL</code>) or a numeric vector indicating the sample size of the strata to which each element belongs (when <code>design</code> is 'stsi') (see &lsquo;Examples&rsquo;).</p>
</td></tr>
<tr><td><code id="vargreg_+3A_stratum">stratum</code></td>
<td>
<p>a vector indicating the stratum to which every unit belongs. Only used if <code>design</code> is 'stsi'.</p>
</td></tr>
<tr><td><code id="vargreg_+3A_x_des">x_des</code></td>
<td>
<p>a positive numeric vector giving the values of the auxiliary variable that is used for defining the inclusion probabilities. Only used if <code>design</code> is 'poi' or 'pips'.</p>
</td></tr>
<tr><td><code id="vargreg_+3A_inc.p">inc.p</code></td>
<td>
<p>a matrix giving the first and second order inclusion probabilities. Only used if <code>design</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vargreg_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="stats.html#topic+lm">lm</a></code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code> should be of the form <code>y~x</code>, where <code>y</code> is the study variable and <code>x</code> are the auxiliary variables used by the general regression (GREG) estimator, <code class="reqn">\hat{t}</code>,. See <code><a href="stats.html#topic+formula">formula</a></code> for more details and &lsquo;Examples&rsquo; for typical expressions for some well-known estimators (e.g. the Horvitz-Thompson, ratio, regression and poststratification estimators).
</p>
<p>The variance of the GREG estimator is approximated by
</p>
<p style="text-align: center;"><code class="reqn">AV\left(\hat{t}\right) = \sum_{k=1}^{N}\sum_{l=1}^{N}\pi_{kl}\frac{E_{k}}{\pi_{k}}\frac{E_{l}}{\pi_{l}} - \left(\sum_{k=1}^{N}E_{k}\right)^{2}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">E_{k} = y_{k}-\hat{y}_{k} \textrm{ and } \hat{y}_{k} = x_{k}B \textrm{ with } B = \left(\sum_{k=1}^{N}w_{k}x_{k}^{'}x_{k}\right)\sum_{k=1}^{N}w_{k}x_{k}^{'}y_{k}</code>
</p>

<p><code class="reqn">N</code> is the population size and <code class="reqn">\pi_{k}</code> and <code class="reqn">\pi_{kl}</code> are, respectively, the first and second order inclusion probabilities. <code class="reqn">w_{k}</code> is a weight associated to each element and it represents the inverse of the conditional variance (up to a scalar) of the underlying superpopulation model (see &lsquo;Examples&rsquo;).
</p>
<p>If <code>design=NULL</code>, the matrix of inclusion probabilities is obtained proportional to the matrix <code>p.inc</code>. If <code>design</code> is other than <code>NULL</code>, the formula for the variance is simplified in such a way that the inclusion probabilities matrix is no longer necessary. In particular:
</p>

<ul>
<li><p> if <code>design='srs'</code>, only the sample size <code>n</code> is required;
</p>
</li>
<li><p> if <code>design='stsi'</code>, both the stratum ID <code>stratum</code> and the sample size per stratum <code>n</code>, are required;
</p>
</li>
<li><p> if <code>design</code> is either <code>'pips'</code> or <code>'poi'</code>, the inclusion probabilities are obtained proportional to the values of <code>x_des</code>, corrected if necessary.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric value giving the variance of the general regression estimator under the desired design.</p>


<h3>References</h3>

<p>Sarndal, C.E., Swensson, B. and Wretman, J. (1992). <em>Model Assisted Survey Sampling</em>. Springer.
</p>
<p>Rosen, B. (1997). <em>On Sampling with Probability Proportional to Size.</em> Journal of Statistical Planning and Inference <strong>62</strong>, 159-191.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+desvar">desvar</a></code> for the simultaneous calculation of the variance of six sampling strategies; <code><a href="#topic+expgreg">expgreg</a></code> for the expected variance of the GREG estimator under a superpopulation model; <code><a href="#topic+expvar">expvar</a></code> for the simultaneous calculation of the expected variance of five sampling strategies under a superpopulation model; <code><a href="#topic+optimApp">optimApp</a></code> for an interactive application of <code>expgreg</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f&lt;- function(x,b0,b1,b2,...) {b0+b1*x^b2}
g&lt;- function(x,b3,...) {x^b3}
x&lt;- 1 + sort( rgamma(5000, shape=4/9, scale=108) )
y&lt;- simulatey(x,f,g,dist="gamma",b0=10,b1=1,b2=1,b3=1,rho=0.95)

st1&lt;- optiallo(n=100,x=x,H=6)
vargreg("y~0",design="srs",n=100)                         #SRS-HT
vargreg("y~0",design="poi",n=100,x_des=x)                 #Poi-HT
vargreg("y~0",design="stsi",n=st1$nh,stratum=st1$stratum) #STSI-HT
vargreg("y~0",design="pips",n=100,x_des=x)                #PIPS-HT

vargreg("y~x-1",design="srs",n=100,weights=1/x)          #SRS-ratio
vargreg("y~x-1",design="poi",n=100,x_des=x,weights=1/x)  #Poi-ratio
vargreg("y~x-1",design="stsi",n=st1$nh,
        stratum=st1$stratum,weights=1/x)                 #STSI-ratio
vargreg("y~x-1",design="pips",n=100,x_des=x,weights=1/x) #PIPS-ratio

vargreg("y~x",design="srs",n=100)                         #SRS-reg
vargreg("y~x",design="poi",n=100,x_des=x)                 #Poi-reg
vargreg("y~x",design="stsi",n=st1$nh,stratum=st1$stratum) #STSI-reg
vargreg("y~x",design="pips",n=100,x_des=x)                #PIPS-reg

x2&lt;- as.factor(st1$stratum)
vargreg("y~x2",design="srs",n=100)                          #SRS-pos
vargreg("y~x2",design="poi",n=100,x_des=x)                  #Poi-pos
vargreg("y~x2",design="stsi",n=st1$nh,stratum=st1$stratum)  #STSI-pos
vargreg("y~x2",design="pips",n=100,x_des=x)                 #PIPS-pos

y2&lt;- c(16,21,18)
x2&lt;- y2
inc.probs&lt;- matrix(c(8,5,4,5,7,3,4,3,6),3,3)
vargreg("y2~0",n=2.1,inc.p=inc.probs)                 #HT
vargreg("y2~x2-1",n=2.1,inc.p=inc.probs,weights=1/x2) #Ratio
vargreg("y2~x2",n=2.1,inc.p=inc.probs)                #Regression
x3&lt;- as.factor(c(1,2,2))
vargreg("y2~x3",n=2.1,inc.p=inc.probs)                #Post.
</code></pre>

<hr>
<h2 id='varp'>Variance</h2><span id='topic+varp'></span>

<h3>Description</h3>

<p>Compute the variance of <code>x</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>varp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varp_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the variance of <code>x</code> using <code class="reqn">n</code> (instead of <code class="reqn">n-1</code> as in <code><a href="stats.html#topic+var">var</a></code>) in the denominator.
</p>


<h3>Value</h3>

<p>An object with the variance of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+var">var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;- rnorm(100)
varp(x)
var(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
