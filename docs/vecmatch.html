<!DOCTYPE html><html lang="en-US"><head><title>Help for package vecmatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vecmatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vecmatch-package'><p>vecmatch: Generalized Propensity Score Estimation and Matching for Multiple Groups</p></a></li>
<li><a href='#balqual'><p>Evaluate Matching Quality</p></a></li>
<li><a href='#cancer'><p>Patients with Colorectal Cancer and Adenoma metadata</p></a></li>
<li><a href='#csregion'><p>Filter the data based on common support region</p></a></li>
<li><a href='#estimate_gps'><p>Calculate treatment allocation probabilities</p></a></li>
<li><a href='#hspine'><p>Fixing bug in productplots::prodcalc</p></a></li>
<li><a href='#match_gps'><p>Match the data based on generalized propensity score</p></a></li>
<li><a href='#mosaic'><p>Plot the distribution of categorical covariates</p></a></li>
<li><a href='#raincloud'><p>Examine the imbalance of continuous covariates</p></a></li>
<li><a href='#vecmatch'><p>vecmatch</p></a></li>
<li><a href='#vspine'><p>Fixing bug in productplots::prodcalc</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generalized Propensity Score Estimation and Matching for
Multiple Groups</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Vector Matching algorithm to match multiple
    treatment groups based on previously estimated generalized propensity
    scores. The package includes tools for visualizing initial confounder
    imbalances, estimating treatment assignment probabilities using various
    methods, defining the common support region, performing matching across
    multiple groups, and evaluating matching quality. For more details, see 
    Lopez and Gutman (2017) &lt;<a href="https://doi.org/10.1214%2F17-STS612">doi:10.1214/17-STS612</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Polymerase3/vecmatch">https://github.com/Polymerase3/vecmatch</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Polymerase3/vecmatch/issues">https://github.com/Polymerase3/vecmatch/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brglm2, chk, cli, ggplot2, ggpp, ggpubr, grDevices, MASS,
Matching, mclogit, nnet, optmatch, productplots, rlang,
rstatix, stats, utils, VGAM, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-05 10:02:29 UTC; polymerase</td>
</tr>
<tr>
<td>Author:</td>
<td>Mateusz Kolek <a href="https://orcid.org/0000-0001-6470-4830"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mateusz Kolek &lt;mati.kolek13@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-07 11:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='vecmatch-package'>vecmatch: Generalized Propensity Score Estimation and Matching for Multiple Groups</h2><span id='topic+vecmatch-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Implements the Vector Matching algorithm to match multiple treatment groups based on previously estimated generalized propensity scores. The package includes tools for visualizing initial confounder imbalances, estimating treatment assignment probabilities using various methods, defining the common support region, performing matching across multiple groups, and evaluating matching quality. For more details, see Lopez and Gutman (2017) <a href="https://doi.org/10.1214/17-STS612">doi:10.1214/17-STS612</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mateusz Kolek <a href="mailto:mati.kolek13@gmail.com">mati.kolek13@gmail.com</a> (<a href="https://orcid.org/0000-0001-6470-4830">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Polymerase3/vecmatch">https://github.com/Polymerase3/vecmatch</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Polymerase3/vecmatch/issues">https://github.com/Polymerase3/vecmatch/issues</a>
</p>
</li></ul>


<hr>
<h2 id='balqual'>Evaluate Matching Quality</h2><span id='topic+balqual'></span>

<h3>Description</h3>

<p>The <code>balqual()</code> function evaluates the balance quality of a
dataset after matching, comparing it to the original unbalanced dataset. It
computes various summary statistics and provides an easy interpretation
using user-specified cutoff values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balqual(
  matched_data = NULL,
  formula = NULL,
  type = c("smd", "r", "var_ratio"),
  statistic = c("mean", "max"),
  cutoffs = NULL,
  round = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balqual_+3A_matched_data">matched_data</code></td>
<td>
<p>An object of class <code>matched</code>, generated by the
<code><a href="#topic+match_gps">match_gps()</a></code> function. This object is essential for the <code>balqual()</code>
function as it contains the final data.frame and attributes required to
compute the quality coefficients.</p>
</td></tr>
<tr><td><code id="balqual_+3A_formula">formula</code></td>
<td>
<p>A valid R formula used to compute generalized propensity
scores during the first step of the vector matching algorithm in
<code><a href="#topic+estimate_gps">estimate_gps()</a></code>. This formula must match the one used in <code>estimate_gps()</code>.</p>
</td></tr>
<tr><td><code id="balqual_+3A_type">type</code></td>
<td>
<p>A character vector specifying the quality metrics to calculate.
Can maximally contain 3 values in a vector created by the <code>c()</code>. Possible
values include:
</p>

<ul>
<li> <p><code>smd</code> - Calculates standardized mean differences (SMD) between groups,
defined as the difference in means divided by the standard deviation of the
treatment group (Rubin, 2001).
</p>
</li>
<li> <p><code>r</code> - Computes Pearson's r coefficient using the Z statistic from the
U-Mann-Whitney test.
</p>
</li>
<li> <p><code>var_ratio</code> - Measures the dispersion differences between groups,
calculated as the ratio of the larger variance to the smaller one.
</p>
</li></ul>
</td></tr>
<tr><td><code id="balqual_+3A_statistic">statistic</code></td>
<td>
<p>A character vector specifying the type of statistics used to
summarize the quality metrics. Since quality metrics are calculated for all
pairwise comparisons between treatment levels, they need to be aggregated
for the entire dataset.
</p>

<ul>
<li> <p><code>max</code>: Returns the maximum values of the statistics defined in the <code>type</code>
argument (as suggested by Lopez and Gutman, 2017).
</p>
</li>
<li> <p><code>mean</code>: Returns the corresponding averages.
</p>
</li></ul>

<p>To compute both, provide both names using the <code>c()</code> function.</p>
</td></tr>
<tr><td><code id="balqual_+3A_cutoffs">cutoffs</code></td>
<td>
<p>A numeric vector with the same length as the number of
coefficients specified in the <code>type</code> argument. Defines the cutoffs for each
corresponding metric, below which the dataset is considered balanced. If
<code>NULL</code>, the default cutoffs are used: 0.1 for <code>smd</code> and <code>r</code>, and 2 for
<code>var_ratio</code>.</p>
</td></tr>
<tr><td><code id="balqual_+3A_round">round</code></td>
<td>
<p>An integer specifying the number of decimal places to round the
output to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If assigned to a name, returns a list of summary statistics of class
<code>quality</code> containing:
</p>

<ul>
<li> <p><code>quality_mean</code> - A data frame with the mean values of the statistics
specified in the <code>type</code> argument for all balancing variables used in
<code>formula</code>.
</p>
</li>
<li> <p><code>quality_max</code> - A data frame with the maximal values of the statistics
specified in the <code>type</code> argument for all balancing variables used in
<code>formula</code>.
</p>
</li>
<li> <p><code>perc_matched</code> - A single numeric value indicating the percentage of
observations in the original dataset that were matched.
</p>
</li>
<li> <p><code>statistic</code> - A single string defining which statistic will be displayed
in the console.
</p>
</li>
<li> <p><code>summary_head</code> - A summary of the matching process. If <code>max</code> is included
in the <code>statistic</code>, it contains the maximal observed values for each
variable; otherwise, it includes the mean values.
</p>
</li>
<li> <p><code>n_before</code> - The number of observations in the dataset before matching.
</p>
</li>
<li> <p><code>n_after</code> - The number of observations in the dataset after matching.
</p>
</li>
<li> <p><code>count_table</code> - A contingency table showing the distribution of the
treatment variable before and after matching.
</p>
</li></ul>

<p>The <code>balqual()</code> function also prints a well-formatted table with the
defined summary statistics for each variable in the <code>formula</code> to the
console.
</p>


<h3>References</h3>

<p>Rubin, D.B. Using Propensity Scores to Help Design Observational
Studies: Application to the Tobacco Litigation. Health Services &amp; Outcomes
Research Methodology 2, 169–188 (2001).
https://doi.org/10.1023/A:1020363010465
</p>
<p>Michael J. Lopez, Roee Gutman &quot;Estimation of Causal Effects with Multiple
Treatments: A Review and New Ideas,&quot; Statistical Science, Statist. Sci.
32(3), 432-454, (August 2017)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_gps">match_gps()</a></code> for matching the generalized propensity scores;
<code><a href="#topic+estimate_gps">estimate_gps()</a></code> for the documentation of the <code>formula</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We try to balance the treatment variable in the cancer dataset based on age
# and sex covariates
data(cancer)

# Firstly, we define the formula
formula_cancer &lt;- formula(status ~ age * sex)

# Then we can estimate the generalized propensity scores
gps_cancer &lt;- estimate_gps(formula_cancer,
  cancer,
  method = "multinom",
  reference = "control",
  verbose_output = TRUE
)

# ... and drop observations based on the common support region...
csr_cancer &lt;- csregion(gps_cancer)

# ... to match the samples using `match_gps()`
matched_cancer &lt;- match_gps(csr_cancer,
  reference = "control",
  caliper = 1,
  kmeans_cluster = 5,
  kmeans_args = list(n.iter = 100),
  verbose_output = TRUE
)

# At the end we can assess the quality of matching using `balqual()`
balqual(
  matched_data = matched_cancer,
  formula = formula_cancer,
  type = "smd",
  statistic = "max",
  round = 3,
  cutoffs = 0.2
)

</code></pre>

<hr>
<h2 id='cancer'>Patients with Colorectal Cancer and Adenoma metadata</h2><span id='topic+cancer'></span>

<h3>Description</h3>

<p>This is a synthetically generated dataset containing metadata for healthy
individuals and patients diagnosed with colorectal cancer or adenomas. The
primary purpose of this dataset in the context of matching is to balance the
<code>status</code> groups across various covariates and achieve optimal matching
quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cancer)
</code></pre>


<h3>Format</h3>

<p>A data frame (<code>cancer</code>) with 1,224 rows and 5 columns:
</p>

<dl>
<dt>status</dt><dd><p>Patient's health status, which can be one of the following:
<code>healthy</code>, <code>adenoma</code>, <code>crc_benign</code>
(benign colorectal carcinoma), or <code>crc_malignant</code>
(malignant colorectal carcinoma).</p>
</dd>
<dt>sex</dt><dd><p>Patient's biological sex, recorded as either <code>M</code> (male) or
<code>F</code> (female).</p>
</dd>
<dt>age</dt><dd><p>Patient's age, represented as a continuous numeric variable.</p>
</dd>
<dt>bmi</dt><dd><p>Patient's Body Mass Index (BMI), represented as a continuous
numeric variable.</p>
</dd>
<dt>smoker</dt><dd><p>Smoking status of the patient,
recorded as <code>yes</code> or <code>no</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data generated artificially
</p>

<hr>
<h2 id='csregion'>Filter the data based on common support region</h2><span id='topic+csregion'></span>

<h3>Description</h3>

<p>The <code>csregion()</code> function estimates the boundaries of the
rectangular common support region, as defined by Lopez and Gutman (2017),
and filters the matrix of generalized propensity scores based on these
boundaries. The function returns a matrix of observations whose generalized
propensity scores lie within the treatment group-specific boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csregion(gps_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csregion_+3A_gps_matrix">gps_matrix</code></td>
<td>
<p>An object of classes <code>gps</code> and <code>data.frame</code> (e.g., created
by the <code>estimate_gps()</code> function). The first column corresponds to the
treatment or grouping variable, while the other columns represent the
treatment assignment probabilities calculated separately for each
hypotetical treatment group. The number of columns should therefore be
equal to the number of unique levels of the treatment variable plus one
(for the treatment variable itself). The number of rows should correspond
to the number of subjects for which generalized propensity scores were
estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix similar to the one returned by <code>estimate_gps()</code>,
but with the number of rows reduced to exclude those observations that do
not fit within the common support region (CSR) boundaries. The returned
object also possesses additional attributes that summarize the calculation
process of the CSR boundaries:
</p>

<ul>
<li> <p><code>filter_matrix</code> - A logical matrix with the same dimensions as the
gps-part of <code>gps_matrix</code>, indicating which treatment assignment
probabilities fall within the CSR boundaries,
</p>
</li>
<li> <p><code>filter_vector</code> - A vector indicating whether each observation was kept
(<code>TRUE</code>) or removed (<code>FALSE</code>), essentially a row-wise
sum of <code>filter_matrix</code>,
</p>
</li>
<li> <p><code>csr_summary</code> - A summary of the CSR calculation process, including
details of the boundaries and the number of observations filtered.
</p>
</li>
<li> <p><code>csr_data</code> - The original dataset used for the estimation of generalized
propensity scores (<code>original_data</code> attribute of the <code>gps</code> object) filtered
by the <code>filter_vector</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We could estimate simples generalized propensity scores for the `iris`
# dataset
gps &lt;- estimate_gps(Species ~ Sepal.Length, data = iris)

# And then define the common support region boundaries using `csregion()`
gps_csr &lt;- csregion(gps)

# The additional information of the CSR-calculation process are
# accessible through the attributes described in the `*Value*` section
attr(gps_csr, "filter_matrix")
attr(gps_csr, "csr_summary")
attr(gps_csr, "csr_data")

</code></pre>

<hr>
<h2 id='estimate_gps'>Calculate treatment allocation probabilities</h2><span id='topic+estimate_gps'></span>

<h3>Description</h3>

<p><code>estimate_gps()</code> computes generalized propensity scores for
treatment groups by applying a user-defined formula and method. It returns
a matrix of GPS probabilities for each subject and treatment group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_gps(
  formula,
  data = NULL,
  method = "multinom",
  link = NULL,
  reference = NULL,
  by = NULL,
  subset = NULL,
  ordinal_treat = NULL,
  fit_object = FALSE,
  verbose_output = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_gps_+3A_formula">formula</code></td>
<td>
<p>a valid R formula, which describes the model used to
calculating the probabilities of receiving a treatment. The variable to be
balanced is on the left side, while the covariates used to predict the
treatment variable are on the right side. To define the interactions
between covariates, use <code>*</code>. For more details, refer to <code><a href="stats.html#topic+formula">stats::formula()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_data">data</code></td>
<td>
<p>a data frame with columns specified in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_method">method</code></td>
<td>
<p>a single string describing the model used for the calculation
of generalized propensity scores. The default value is set to <code>multinom</code>.
For available methods refer to the Details section below.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_link">link</code></td>
<td>
<p>a single string; determines an alternative model for a method
used for estimation. For available links, see Details.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_reference">reference</code></td>
<td>
<p>a single string describing one class from the treatment
variable, referred to as the baseline category in the calculation of
generalized propensity scores.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_by">by</code></td>
<td>
<p>a single string with the name of a column, contained in the <code>data</code>
argument. The dataset will be divided by the groups created by the grouping
<code>by</code> variable and the calculation of the propensity scores will be carried
out separately for each group. The results will then be merged and
presented to the user as a single GPS matrix.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_subset">subset</code></td>
<td>
<p>a logical atomic vector of length equal to the number of rows
in the <code>data</code> arguments. Allows to filter out observations from the further
analysis, for which the value of the vector is equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_ordinal_treat">ordinal_treat</code></td>
<td>
<p>an atomic vector of the length equal to the length of
unique levels of the treatment variable. Confirms, that the treatment
variable is an ordinal variable and adjusts its levels, to the order of
levels specified in the argument. Is a call to the function <code style="white-space: pre;">&#8288;factor(treat, levels = ordinal_treat, ordered = TRUE&#8288;</code>.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_fit_object">fit_object</code></td>
<td>
<p>a logical flag. If <code>TRUE</code>, the the fitted object is
returned instead of the GPS matrix.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_verbose_output">verbose_output</code></td>
<td>
<p>a logical flag. If <code>TRUE</code> a more verbose version of the
function is run and the output is printed out to the console.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_...">...</code></td>
<td>
<p>additional arguments, that can be passed to the fitting function
and are not controlled by the above arguments. For more details and
examples refer to the Details section and documentations of corresponding
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main goal of the <code>estimate_gps()</code> function is to calculate the
generalized propensity scores aka. treatment allocation probabilities. It
is the first step in the workflow of the vector matching algorithm and is
essential for the further analysis. The returned matrix of class <code>gps</code> can
then be passed to the <code>csregion()</code> function to calculate the rectangular
common support region boundaries and drop samples not eligible for the
further analysis. The list of available methods operated by the
<code>estimate_gps()</code> is provided below with a short description and function
used for the calculations:
</p>

<ul>
<li> <p><code>multinom</code> - multinomial logistic regression model <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code>
</p>
</li>
<li> <p><code>vglm</code> - vector generalized linear model for multinomial data
<code><a href="VGAM.html#topic+vglm">VGAM::vglm()</a></code>,
</p>
</li>
<li> <p><code>brglm2</code> - bias reduction model for multinomial responses using the
Poisson trick <code><a href="brglm2.html#topic+brmultinom">brglm2::brmultinom()</a></code>,
</p>
</li>
<li> <p><code>mblogit</code> - baseline-category logit models <code><a href="mclogit.html#topic+mblogit">mclogit::mblogit()</a></code>.
</p>
</li>
<li> <p><code>polr</code> - ordered logistic or probit regression only for ordered factor
variables from <code><a href="MASS.html#topic+polr">MASS::polr()</a></code>. The <code>method</code> argument of the underlying
<code>MASS::polr()</code> package function can be controlled with the <code>link</code> argument.
Available options: <code>link = c("logistic", "probit", "loglog", "cloglog",   "cauchit")</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric matrix of class <code>gps</code> with the number of columns equal to
the number of unique treatment variable levels plus one (for the treatment
variable itself) and the number of row equal to the number of subjects in
the initial dataset. The original dataset used for estimation can be
accessed as <code>original_data</code> attribute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csregion">csregion()</a></code> for the calculation of common support region,
<code><a href="#topic+match_gps">match_gps()</a></code> for the matching of generalized propensity scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("brglm2")

# Conducting covariate balancing on the `airquality` dataset. Our goal was to
# compare ozone levels by month, but we discovered that ozone levels are
# strongly correlated with wind intensity (measured in mph), and the average
# wind intensity varies across months. Therefore, we need to balance the
# months by wind values to ensure a valid comparison of ozone levels.

# Initial imbalance of means
tapply(airquality$Wind, airquality$Month, mean)

# Formula definition
formula_air &lt;- formula(Month ~ Wind)

# Estimating the generalized propensity scores using brglm2 method using
# maximum penalized likelihood estimators with powers of the Jeffreys
gp_scores &lt;- estimate_gps(formula_air,
  data = airquality, method = "brglm2",
  reference = "5", verbose_output = TRUE,
  control = brglmControl(type = "MPL_Jeffreys")
)

# Filtering the observations outside the csr region
gps_csr &lt;- csregion(gp_scores)

# Calculating imbalance after csr
filter_which &lt;- attr(gps_csr, "filter_vector")
filtered_air &lt;- airquality[filter_which, ]

tapply(filtered_air$Wind, filtered_air$Month, mean)

# We can also investigate the imbalance using the raincloud function
raincloud(filtered_air,
  y = Wind,
  group = Month,
  significance = "t_test"
)
</code></pre>

<hr>
<h2 id='hspine'>Fixing bug in productplots::prodcalc</h2><span id='topic+hspine'></span>

<h3>Description</h3>

<p>Fixing bug in productplots::prodcalc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hspine(...)
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='match_gps'>Match the data based on generalized propensity score</h2><span id='topic+match_gps'></span>

<h3>Description</h3>

<p>The <code>match_gps()</code> function performs sample matching based on
generalized propensity scores (GPS). It utilizes the k-means clustering
algorithm to partition the data into clusters and subsequently matches all
treatment groups within these clusters. This approach ensures efficient and
structured comparisons across treatment levels while accounting for the
propensity score distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_gps(
  csmatrix = NULL,
  method = "nnm",
  caliper = 0.2,
  reference = NULL,
  ratio = NULL,
  replace = NULL,
  order = NULL,
  ties = NULL,
  min_controls = NULL,
  max_controls = NULL,
  kmeans_args = NULL,
  kmeans_cluster = 5,
  verbose_output = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_gps_+3A_csmatrix">csmatrix</code></td>
<td>
<p>An object of class <code>gps</code> and/or <code>csr</code> representing a data
frame of generalized propensity scores. The first column must be the
treatment variable, with additional attributes describing the calculation
of the common support region and the estimation of generalized propensity
scores. It is crucial that the common support region was calculated using
the <code>csregion()</code> function to ensure compatibility.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_method">method</code></td>
<td>
<p>A single string specifying the matching method to use. The
default is <code>"nnm"</code>, which applies the k-nearest neighbors matching
algorithm. See the Details section for a full list of available methods.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_caliper">caliper</code></td>
<td>
<p>A numeric value specifying the caliper width, which defines
the allowable range within which observations can be matched. It is
expressed as a percentage of the standard deviation of the
logit-transformed generalized propensity scores. To perform matching
without a caliper, set this parameter to a very large value. For exact
matching, set <code>caliper = 0</code> and enable the <code>exact</code> option by setting it to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_reference">reference</code></td>
<td>
<p>A single string specifying the exact level of the treatment
variable to be used as the reference in the matching process. All other
treatment levels will be matched to this reference level. Ideally, this
should be the control level. If no natural control is present, avoid
selecting a level with extremely low or high covariate or propensity score
values. Instead, choose a level with covariate or propensity score
distributions that are centrally positioned among all treatment groups to
maximize the number of matches.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_ratio">ratio</code></td>
<td>
<p>A scalar for the number of matches which should be found for
each control observation. The default is one-to-one matching. Only
available for the methods <code>"nnm"</code> and <code>"pairopt"</code>.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_replace">replace</code></td>
<td>
<p>Logical value indicating whether matching should be done with
replacement. If <code>FALSE</code>, the order of matches generally matters. Matches
are found in the same order as the data is sorted. Specifically, the
matches for the first observation will be found first, followed by those
for the second observation, and so on. Matching without replacement is
generally not recommended as it tends to increase bias. However, in cases
where the dataset is large and there are many potential matches, setting
<code>replace = FALSE</code> often results in a substantial speedup with negligible or
no bias. Only available for the method <code>"nnm"</code></p>
</td></tr>
<tr><td><code id="match_gps_+3A_order">order</code></td>
<td>
<p>A string specifying the order in which logit-transformed GPS
values are sorted before matching. The available options are:
</p>

<ul>
<li> <p><code>"desc"</code> – sorts GPS values from highest to lowest (default).
</p>
</li>
<li> <p><code>"asc"</code> – sorts GPS values from lowest to highest.
</p>
</li>
<li> <p><code>"original"</code> – preserves the original order of GPS values.
</p>
</li>
<li> <p><code>"random"</code> – randomly shuffles GPS values. To generate different random
orders, set a seed using <code><a href="base.html#topic+set.seed">set.seed()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="match_gps_+3A_ties">ties</code></td>
<td>
<p>A logical flag indicating how tied matches should be handled.
Available only for the <code>"nnm"</code> method, with a default value of <code>FALSE</code> (all
tied matches are included in the final dataset, but only unique
observations are retained). For more details, see the <code>ties</code> argument in
<code><a href="Matching.html#topic+Matchby">Matching::Matchby()</a></code>.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_min_controls">min_controls</code></td>
<td>
<p>The minimum number of treatment observations that should
be matched to each control observation. Available only for the <code>"fullopt"</code>
method. For more details, see the <code>min.controls</code> argument in
<code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_max_controls">max_controls</code></td>
<td>
<p>The maximum number of treatment observations that can be
matched to each control observation. Available only for the <code>"fullopt"</code>
method. For more details, see the <code>max.controls</code> argument in
<code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_kmeans_args">kmeans_args</code></td>
<td>
<p>A list of arguments to pass to <a href="stats.html#topic+kmeans">stats::kmeans</a>. These
arguments must be provided inside a <code>list()</code> in the paired <code>name = value</code>
format.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_kmeans_cluster">kmeans_cluster</code></td>
<td>
<p>An integer specifying the number of clusters to pass to
<a href="stats.html#topic+kmeans">stats::kmeans</a>.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_verbose_output">verbose_output</code></td>
<td>
<p>a logical flag. If <code>TRUE</code> a more verbose version of the
function is run and the output is printed out to the console.</p>
</td></tr>
<tr><td><code id="match_gps_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the matching
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Propensity score matching can be performed using various matching
algorithms. Lopez and Gutman (2017) do not explicitly specify the matching
algorithm used, but it is assumed they applied the commonly used k-nearest
neighbors matching algorithm, implemented as <code>method = "nnm"</code>. However,
this algorithm can sometimes be challenging to use, especially when
treatment and control groups have unequal sizes. When <code>replace = FALSE</code>,
the number of matches is strictly limited by the smaller group, and even
with <code>replace = TRUE</code>, the results may not always be satisfactory. To
address these limitations, we have implemented an additional matching
algorithm to maximize the number of matched observations within a dataset.
</p>
<p>The available matching methods are:
</p>

<ul>
<li> <p><code>"nnm"</code> – classic k-nearest neighbors matching, implemented using
<code><a href="Matching.html#topic+Matchby">Matching::Matchby()</a></code>. The tunable parameters in <code>match_gps()</code> are
<code>caliper</code>, <code>ratio</code>, <code>replace</code>, <code>order</code>, and <code>ties</code>. Additional arguments
can be passed to <code><a href="Matching.html#topic+Matchby">Matching::Matchby()</a></code> via the <code>...</code> argument.
</p>
</li>
<li> <p><code>"fullopt"</code> – optimal full matching algorithm, implemented with
<code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>. This method calculates a discrepancy matrix to
identify all possible matches, often optimizing the percentage of matched
observations. The available tuning parameters are <code>caliper</code>,
<code>min_controls</code>, and <code>max_controls</code>.
</p>
</li>
<li> <p><code>"pairmatch"</code> – optimal 1:1 and 1:k matching algorithm, implemented using
<code><a href="optmatch.html#topic+pairmatch">optmatch::pairmatch()</a></code>, which is actually a wrapper around
<code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>. Like <code>"fullopt"</code>, this method calculates a
discrepancy matrix and finds matches that minimize its sum. The available
tuning parameters are <code>caliper</code> and <code>ratio</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> similar to the one provided as the <code>data</code> argument in
the <code><a href="#topic+estimate_gps">estimate_gps()</a></code> function, containing the same columns but only the
observations for which a match was found. The returned object includes two
attributes, accessible with the <code>attr()</code> function:
</p>

<ul>
<li> <p><code>original_data</code>: A <code>data.frame</code> with the original data returned by the
<code><a href="#topic+csregion">csregion()</a></code> or <code><a href="#topic+estimate_gps">estimate_gps()</a></code> function, after the estimation of the csr
and filtering out observations not within the csr.
</p>
</li>
<li> <p><code>matching_filter</code>: A logical vector indicating which rows from
<code>original_data</code> were included in the final matched dataset.
</p>
</li></ul>



<h3>References</h3>

<p>Michael J. Lopez, Roee Gutman &quot;Estimation of Causal Effects with
Multiple Treatments: A Review and New Ideas,&quot; Statistical Science, Statist.
Sci. 32(3), 432-454, (August 2017)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_gps">estimate_gps()</a></code> for the calculation of generalized propensity
scores; <code><a href="MatchIt.html#topic+matchit">MatchIt::matchit()</a></code>, <code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code> and
<code><a href="optmatch.html#topic+pairmatch">optmatch::pairmatch()</a></code> for the documentation of the matching functions;
<code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> for the documentation of the k-Means algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining the formula used for gps estimation
formula_cancer &lt;- formula(status ~ age + sex)

# Step 1.) Estimation of the generalized propensity scores
gp_scores &lt;- estimate_gps(formula_cancer,
  data = cancer,
  method = "multinom",
  reference = "control",
  verbose_output = TRUE
)

# Step 2.) Defining the common support region
gps_csr &lt;- csregion(gp_scores)

# Step 3.) Matching the gps
matched_cancer &lt;- match_gps(gps_csr,
  caliper = 0.25,
  reference = "control",
  method = "fullopt",
  kmeans_cluster = 2,
  kmeans_args = list(
    iter.max = 200,
    algorithm = "Forgy"
  ),
  verbose_output = TRUE
)

</code></pre>

<hr>
<h2 id='mosaic'>Plot the distribution of categorical covariates</h2><span id='topic+mosaic'></span>

<h3>Description</h3>

<p>The <code>mosaic()</code> function generates imbalance plots for
contingency tables with up to three variables. Frequencies in the
contingency table are represented as tiles (rectangles), with each tile's
size proportional to the frequency of the corresponding group within the
entire dataset. The x-axis scale remains fixed across mosaic plots,
enabling straightforward comparisons of imbalance across treatment groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic(
  data = NULL,
  y = NULL,
  group = NULL,
  facet = NULL,
  ncol = 1,
  group_counts = FALSE,
  group_counts_size = 4,
  significance = FALSE,
  plot_name = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosaic_+3A_data">data</code></td>
<td>
<p>A non-empty <code>data.frame</code> containing at least one numeric column,
as specified by the <code>y</code> argument. This argument must be provided and does
not have a default value.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_y">y</code></td>
<td>
<p>A single string or unquoted symbol representing the name of a
numeric column in the <code>data</code>. In the vector matching workflow, it is
typically a numeric covariate that requires balancing.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_group">group</code></td>
<td>
<p>A single string or unquoted symbol representing the name of a
factor or character column in <code>data</code>. In <code>raincloud()</code> plots, the groups
specified by <code>group</code> argument will be distinguished by separate <code>fill</code> and
<code>color</code> aesthetics. For clarity, it is recommended to plot fewer than 10
groups, though there is no formal limit.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_facet">facet</code></td>
<td>
<p>A single string or unquoted symbol representing the name of a
variable in <code>data</code> to facet by. This argument is used in a call to
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>, creating separate distribution plots for each
unique group in the <code>facet</code> variable.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_ncol">ncol</code></td>
<td>
<p>A single integer. The value should be less than or equal to the
number of unique categories in the <code>facet</code> variable. This argument is used
only when <code>facet</code> is not NULL, specifying the number of columns in the
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> call. The distribution plots will be arranged into
the number of columns defined by <code>ncol</code>.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_group_counts">group_counts</code></td>
<td>
<p>A logical flag. If <code>TRUE</code>, the sizes of the groups will
be displayed inside the rectangles in the plot created by the <code>mosaic()</code>
function. If <code>FALSE</code> (default), the group sizes will not be shown.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_group_counts_size">group_counts_size</code></td>
<td>
<p>A single numeric value that specifies the size of
the group count labels in millimeters ('mm'). This value is passed to the
<code>size</code> argument of <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code>.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_significance">significance</code></td>
<td>
<p>A logical flag; defaults to <code>FALSE</code>. When <code>TRUE</code>, a
Chi-squared test of independence is performed on the contingency table
of <code>y</code> and <code>group</code>. Note that <code>group</code> must be specified for the test to be
calculated. If <code>facet</code> is provided, the significance is assessed separately
for each <code>facet</code> subgroup. Additionally, the function calculates
standardized Pearson residuals (differences between observed and expected
counts) and fills mosaic plot cells based on the level of partial
significance for each cell.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_plot_name">plot_name</code></td>
<td>
<p>A string specifying a valid file name or path for the plot.
If set to <code>NULL</code>, the plot is displayed to the current graphical device but
not saved locally. If a valid name with <code>.png</code> or <code>.pdf</code> extension is
provided, the plot is saved locally. Users can also include a subdirectory
in <code>plot_name</code>. Ensure the file path follows the correct syntax for your
operating system.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical flag (default <code>FALSE</code>) that is evaluated only if
the <code>save.name</code> argument is provided. If <code>TRUE</code>, the function checks
whether a plot with the same name already exists. If it does, the existing
plot will be overwritten. If <code>FALSE</code> and a plot with the same name exists,
an error is thrown. If no such plot exists, the plot is saved normally.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>rstatix::chisq_test</code> when
<code>significance = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object representing the contingency table of <code>y</code> and
<code>group</code> as a mosaic plot, optionally grouped by <code>facet</code> if specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example: Creating a Mosaic Plot of the Titanic Dataset
## This plot visualizes survival rates by gender across different passenger
## classes. By setting `significance = TRUE`, you can highlight statistically
## significant differences within each rectangle of the mosaic plot.
library(ggplot2)

# Load Titanic dataset and convert to data frame
titanic_df &lt;- as.data.frame(Titanic)

# Expand the dataset by repeating rows according to 'Freq'
titanic_long &lt;- titanic_df[rep(
  seq_len(nrow(titanic_df)),
  titanic_df$Freq
), ]

# Remove the 'Freq' column as it is no longer needed
titanic_long$Freq &lt;- NULL

# Plot the data using mosaic() and modify the result using additional ggplot2
# functions
p &lt;- vecmatch::mosaic(
  data = titanic_long,
  y = Survived,
  group = Sex,
  facet = Class,
  ncol = 2,
  significance = TRUE
)

p &lt;- p +
  theme_minimal()

p

</code></pre>

<hr>
<h2 id='raincloud'>Examine the imbalance of continuous covariates</h2><span id='topic+raincloud'></span>

<h3>Description</h3>

<p>The <code>raincloud()</code> function allows to generate distribution plots
for continuous data in an easy and uncomplicated way. The function is based
on the <code>ggplot2</code> package, which must already be preinstalled Raincloud
plots consist of three main elements:
</p>

<ul>
<li><p> Distribution plots, specifically  violin plots with the mean values and
standard deviations of respective groups,
</p>
</li>
<li><p> Jittered point plots depicting the underlying distribution of the data in
the rawest form,
</p>
</li>
<li><p> Boxplots, summarizing the most important statistics of the underlying
distribution.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>raincloud(
  data = NULL,
  y = NULL,
  group = NULL,
  facet = NULL,
  ncol = 1,
  significance = NULL,
  sig_label_size = 2L,
  sig_label_color = FALSE,
  smd_type = "mean",
  limits = NULL,
  jitter = 0.1,
  alpha = 0.4,
  plot_name = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raincloud_+3A_data">data</code></td>
<td>
<p>A non-empty <code>data.frame</code> containing at least one numeric column,
as specified by the <code>y</code> argument. This argument must be provided and does
not have a default value.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_y">y</code></td>
<td>
<p>A single string or unquoted symbol representing the name of a
numeric column in the <code>data</code>. In the vector matching workflow, it is
typically a numeric covariate that requires balancing.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_group">group</code></td>
<td>
<p>A single string or unquoted symbol representing the name of a
factor or character column in <code>data</code>. In <code>raincloud()</code> plots, the groups
specified by <code>group</code> argument will be distinguished by separate <code>fill</code> and
<code>color</code> aesthetics. For clarity, it is recommended to plot fewer than 10
groups, though there is no formal limit.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_facet">facet</code></td>
<td>
<p>A single string or unquoted symbol representing the name of a
variable in <code>data</code> to facet by. This argument is used in a call to
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>, creating separate distribution plots for each
unique group in the <code>facet</code> variable.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_ncol">ncol</code></td>
<td>
<p>A single integer. The value should be less than or equal to the
number of unique categories in the <code>facet</code> variable. This argument is used
only when <code>facet</code> is not NULL, specifying the number of columns in the
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> call. The distribution plots will be arranged into
the number of columns defined by <code>ncol</code>.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_significance">significance</code></td>
<td>
<p>A single string specifying the method for calculating
p-values in multiple comparisons between groups defined by the <code>group</code>
argument. Significant comparisons are represented by bars connecting the
compared groups on the left side of the boxplots. Note that if there are
many significant tests, the plot size may adjust accordingly. For available
methods refer to the <em>Details</em> section. If the <code>significance</code> argument is
not <code>NULL</code>, standardized mean differences (SMDs) are also calculated and
displayed on the right side of the jittered point plots.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_sig_label_size">sig_label_size</code></td>
<td>
<p>An integer specifying the size of the significance and
SMD (standardized mean difference) labels displayed on the bars on the
right side of the plot.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_sig_label_color">sig_label_color</code></td>
<td>
<p>Logical flag. If <code>FALSE</code> (default), significance and
SMD bars and text are displayed in the default color (black). If <code>TRUE</code>,
colors are applied dynamically based on value: nonsignificant tests and SMD
values below 0.10 are displayed in green, while significant tests and SMD
values of 0.10 or higher are displayed in red.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_smd_type">smd_type</code></td>
<td>
<p>A single string indicating the type of effect size to
calculate and display on the left side of the jittered point plots:
</p>

<ul>
<li> <p><code>mean</code> - Cohen's d is calculated,
</p>
</li>
<li> <p><code>median</code> - the Wilcoxon effect size (r) is calculated based on the Z
statistic extracted from the Wilcoxon test.
</p>
</li></ul>
</td></tr>
<tr><td><code id="raincloud_+3A_limits">limits</code></td>
<td>
<p>A numeric atomic vector of length two, specifying the <code>y</code> axis
limits in the distribution plots. The first element sets the minimum value,
and the second sets the maximum. This vector is passed to the
<code><a href="ggplot2.html#topic+lims">ggplot2::xlim()</a></code> function to adjust the axis scale.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_jitter">jitter</code></td>
<td>
<p>A single numeric value between 0 and 1 that controls the amount
of jitter applied to points in the <code><a href="ggplot2.html#topic+geom_jitter">ggplot2::geom_jitter()</a></code> plots. Higher
values of the <code>jitter</code> argument produce more jittered plot. It's
recommended to keep this value low, as higher jitter can make the plot
difficult to interpret.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_alpha">alpha</code></td>
<td>
<p>A single numeric value between 0 and 1 that controls the
transparency of the density plots, boxplots, and jittered point plots.
Lower values result in higher transparency. It is recommended to keep this
value relatively high to maintain the interpretability of the plots when
using the <code>group</code> argument, as excessive transparency may cause overlap
between groups, making it difficult to distinguish them visually.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_plot_name">plot_name</code></td>
<td>
<p>A string specifying a valid file name or path for the plot.
If set to <code>NULL</code>, the plot is displayed to the current graphical device but
not saved locally. If a valid name with <code>.png</code> or <code>.pdf</code> extension is
provided, the plot is saved locally. Users can also include a subdirectory
in <code>plot_name</code>. Ensure the file path follows the correct syntax for your
operating system.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical flag (default <code>FALSE</code>) that is evaluated only if
the <code>save.name</code> argument is provided. If <code>TRUE</code>, the function checks
whether a plot with the same name already exists. If it does, the existing
plot will be overwritten. If <code>FALSE</code> and a plot with the same name exists,
an error is thrown. If no such plot exists, the plot is saved normally.</p>
</td></tr>
<tr><td><code id="raincloud_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function for calculating
p-values when the <code>significance</code> argument is specified. For available
functions associated with different <code>significance</code> methods, please refer to
the <em>Details</em> section and consult the documentation for the relevant
functions in the <code>rstatix</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available methods for the argument <code>significance</code> are:
</p>

<ul>
<li> <p><code>"t_test"</code> - Performs a pairwise comparison using the two-sample t-test,
with the default Holm adjustment for multiple comparisons. This test assumes
normally distributed data and equal variances. The adjustment can be
modified via the <code>p.adjust.method</code> argument. The test is implemented via
<code><a href="rstatix.html#topic+t_test">rstatix::pairwise_t_test()</a></code>
</p>
</li>
<li> <p><code>"dunn_test"</code> - Executes Dunn's test for pairwise comparisons following a
Kruskal-Wallis test. It is a non-parametric alternative to the t-test when
assumptions of normality or homogeneity of variances are violated.
Implemented via <code><a href="rstatix.html#topic+dunn_test">rstatix::dunn_test()</a></code>.
</p>
</li>
<li> <p><code>"tukeyHSD_test"</code> - Uses Tukey's Honest Significant Difference (HSD) test
for pairwise comparisons between group means. Suitable for comparing all
pairs when the overall ANOVA is significant. The method assumes equal
variance between groups and is implemented via <code><a href="rstatix.html#topic+tukey_hsd">rstatix::tukey_hsd()</a></code>.
</p>
</li>
<li> <p><code>"games_howell_test"</code> - A post-hoc test used after ANOVA, which does not
assume equal variances or equal sample sizes. It’s particularly robust for
data that violate homogeneity of variance assumptions. Implemented via
<code><a href="rstatix.html#topic+games_howell_test">rstatix::games_howell_test()</a></code>.
</p>
</li>
<li> <p><code>"wilcoxon_test"</code> - Performs the Wilcoxon rank-sum test (also known as the
Mann-Whitney U test) for non-parametric pairwise comparisons. Useful when
data are not normally distributed. Implemented via
<code><a href="rstatix.html#topic+wilcox_test">rstatix::pairwise_wilcox_test()</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>ggplot</code> object representing the distribution of the <code>y</code> variable
across the levels of the <code>group</code> and <code>facet</code> variables in <code>data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mosaic">mosaic()</a></code> which summarizes the distribution of discrete data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example: Creating a raincloud plot for the ToothGrowth dataset.
## This plot visualizes the distribution of the `len` variable by
## `dose` (using different colors) and facets by `supp`. Group
## differences by `dose` are calculated using a `t_test`, and standardized
## mean differences (SMDs) are displayed through jittered points.
library(ggplot2)
library(ggpubr)

p &lt;- raincloud(ToothGrowth, len, dose, supp,
  significance = "t_test",
  jitter = 0.15, alpha = 0.4
)

## As `p` is a valid `ggplot` object, we can manipulate its
## characteristics usingthe `ggplot2` or `ggpubr` packages
## to create publication grade plot:
p &lt;- p +
  theme_classic2() +
  theme(
    axis.line.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  guides(fill = guide_legend("Dose [mg]")) +
  ylab("Length [cm]")

p

</code></pre>

<hr>
<h2 id='vecmatch'>vecmatch</h2><span id='topic+vecmatch'></span>

<h3>Description</h3>

<p>vecmatch
</p>

<hr>
<h2 id='vspine'>Fixing bug in productplots::prodcalc</h2><span id='topic+vspine'></span>

<h3>Description</h3>

<p>Fixing bug in productplots::prodcalc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vspine(...)
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
