<!DOCTYPE html><html lang="en"><head><title>Help for package glmmfields</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glmmfields}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#glmmfields-package'><p>The 'glmmfields' package.</p></a></li>
<li><a href='#format_data'><p>Format data for fitting a glmmfields model</p></a></li>
<li><a href='#glmmfields'><p>Fit a spatiotemporal random fields GLMM</p></a></li>
<li><a href='#lognormal'><p>Lognormal family</p></a></li>
<li><a href='#loo.glmmfields'><p>Return LOO information criteria</p></a></li>
<li><a href='#nbinom2'><p>Negative binomial family</p></a></li>
<li><a href='#plot.glmmfields'><p>Plot predictions from an glmmfields model</p></a></li>
<li><a href='#predict'><p>Predict from a glmmfields model</p></a></li>
<li><a href='#sim_glmmfields'><p>Simulate a random field with a MVT distribution</p></a></li>
<li><a href='#stan_pars'><p>Return a vector of parameters</p></a></li>
<li><a href='#student_t'><p>Student-t and half-t priors</p></a></li>
<li><a href='#tidy'><p>Tidy model output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Linear Mixed Models with Robust Random Fields for
Spatiotemporal Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Bayesian spatial and spatiotemporal
    models that optionally allow for extreme spatial deviations through
    time. 'glmmfields' uses a predictive process approach with random
    fields implemented through a multivariate-t distribution instead of
    the usual multivariate normal.  Sampling is conducted with 'Stan'.
    References: Anderson and Ward (2019) &lt;<a href="https://doi.org/10.1002%2Fecy.2403">doi:10.1002/ecy.2403</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/seananderson/glmmfields">https://github.com/seananderson/glmmfields</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/seananderson/glmmfields/issues">https://github.com/seananderson/glmmfields/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.4.0), Rcpp (&ge; 0.12.18)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, broom, broom.mixed, cluster, dplyr (&ge; 0.8.0),
forcats, ggplot2 (&ge; 2.2.0), loo (&ge; 2.0.0), mvtnorm, nlme,
RcppParallel (&ge; 5.0.1), reshape2, rstan (&ge; 2.26.0),
rstantools (&ge; 2.1.1), tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bayesplot, coda, knitr, parallel, rmarkdown, testthat,
viridis</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.8), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-20 17:26:44 UTC; seananderson</td>
</tr>
<tr>
<td>Author:</td>
<td>Sean C. Anderson [aut, cre],
  Eric J. Ward [aut],
  Trustees of Columbia University [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sean C. Anderson &lt;sean@seananderson.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='glmmfields-package'>The 'glmmfields' package.</h2><span id='topic+glmmfields-package'></span>

<h3>Description</h3>

<p>Implements Bayesian spatial and spatiotemporal models that
optionally allow for extreme spatial deviations through time. 'glmmfields'
uses a predictive process approach with random fields implemented through a
multivariate-t distribution instead of the usual multivariate normal.
Sampling is conducted with 'Stan'.
</p>


<h3>References</h3>

<p>Stan Development Team (2018). RStan: the R interface to Stan. R package
version 2.18.2. http://mc-stan.org
</p>

<hr>
<h2 id='format_data'>Format data for fitting a glmmfields model</h2><span id='topic+format_data'></span>

<h3>Description</h3>

<p>Format data for fitting a glmmfields model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_data(
  data,
  y,
  X,
  time,
  lon = "lon",
  lat = "lat",
  station = NULL,
  nknots = 25L,
  covariance = c("squared-exponential", "exponential", "matern"),
  fixed_intercept = FALSE,
  cluster = c("pam", "kmeans")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_data_+3A_data">data</code></td>
<td>
<p>A data frame to be formatted</p>
</td></tr>
<tr><td><code id="format_data_+3A_y">y</code></td>
<td>
<p>A numeric vector of the response</p>
</td></tr>
<tr><td><code id="format_data_+3A_x">X</code></td>
<td>
<p>A matrix of the predictors</p>
</td></tr>
<tr><td><code id="format_data_+3A_time">time</code></td>
<td>
<p>A character object giving the name of the time column</p>
</td></tr>
<tr><td><code id="format_data_+3A_lon">lon</code></td>
<td>
<p>A character object giving the name of the longitude column</p>
</td></tr>
<tr><td><code id="format_data_+3A_lat">lat</code></td>
<td>
<p>A character object giving the name of the latitude column</p>
</td></tr>
<tr><td><code id="format_data_+3A_station">station</code></td>
<td>
<p>A numeric vector giving the integer ID of the station</p>
</td></tr>
<tr><td><code id="format_data_+3A_nknots">nknots</code></td>
<td>
<p>The number of knots</p>
</td></tr>
<tr><td><code id="format_data_+3A_covariance">covariance</code></td>
<td>
<p>The type of covariance function</p>
</td></tr>
<tr><td><code id="format_data_+3A_fixed_intercept">fixed_intercept</code></td>
<td>
<p>Should the intercept be fixed?</p>
</td></tr>
<tr><td><code id="format_data_+3A_cluster">cluster</code></td>
<td>
<p>The type of clustering algorithm used to determine the not locations.
<code>"pam"</code> = <code><a href="cluster.html#topic+pam">pam</a></code>. <code>kmeans</code> is faster for large datasets.</p>
</td></tr>
</table>

<hr>
<h2 id='glmmfields'>Fit a spatiotemporal random fields GLMM</h2><span id='topic+glmmfields'></span>

<h3>Description</h3>

<p>Fit a spatiotemporal random fields model that optionally uses the MVT
distribution instead of a MVN distribution to allow for spatial extremes
through time. It is also possible to fit a spatial random fields model
without a time component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmmfields(
  formula,
  data,
  lon,
  lat,
  time = NULL,
  nknots = 15L,
  prior_gp_theta = half_t(3, 0, 5),
  prior_gp_sigma = half_t(3, 0, 5),
  prior_sigma = half_t(3, 0, 5),
  prior_rw_sigma = half_t(3, 0, 5),
  prior_intercept = student_t(3, 0, 10),
  prior_beta = student_t(3, 0, 3),
  prior_phi = student_t(1000, 0, 0.5),
  fixed_df_value = 1000,
  fixed_phi_value = 0,
  estimate_df = FALSE,
  estimate_ar = FALSE,
  family = gaussian(link = "identity"),
  binomial_N = NULL,
  covariance = c("squared-exponential", "exponential", "matern"),
  matern_kappa = 0.5,
  algorithm = c("sampling", "meanfield"),
  year_re = FALSE,
  nb_lower_truncation = 0,
  control = list(adapt_delta = 0.9),
  save_log_lik = FALSE,
  df_lower_bound = 2,
  cluster = c("pam", "kmeans"),
  offset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmmfields_+3A_formula">formula</code></td>
<td>
<p>The model formula.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_lon">lon</code></td>
<td>
<p>A character object giving the name of the longitude column.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_lat">lat</code></td>
<td>
<p>A character object giving the name of the latitude column.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_time">time</code></td>
<td>
<p>A character object giving the name of the time column. Leave
as <code>NULL</code> to fit a spatial GLMM without a time element.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_nknots">nknots</code></td>
<td>
<p>The number of knots to use in the predictive process model.
Smaller values will be faster but may not adequately represent the shape
of the spatial pattern.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_prior_gp_theta">prior_gp_theta</code></td>
<td>
<p>The prior on the Gaussian Process scale parameter. Must
be declared with <code><a href="#topic+half_t">half_t()</a></code>. Here, and throughout, priors that
are normal or half-normal can be implemented by setting the first
parameter in the half-t or student-t distribution to a large value.
E.g. something greater than 100.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_prior_gp_sigma">prior_gp_sigma</code></td>
<td>
<p>The prior on the Gaussian Process eta parameter. Must
be declared with <code><a href="#topic+half_t">half_t()</a></code>.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>The prior on the observation process scale parameter. Must
be declared with <code><a href="#topic+half_t">half_t()</a></code>. This acts as a substitute for the
scale parameter in whatever observation distribution is being used. E.g.
the CV for the Gamma or the dispersion parameter for the negative
binomial.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_prior_rw_sigma">prior_rw_sigma</code></td>
<td>
<p>The prior on the standard deviation parameter of the
random walk process (if specified). Must be declared with
<code><a href="#topic+half_t">half_t()</a></code>.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_prior_intercept">prior_intercept</code></td>
<td>
<p>The prior on the intercept parameter. Must be declared
with <code><a href="#topic+student_t">student_t()</a></code>.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_prior_beta">prior_beta</code></td>
<td>
<p>The prior on the slope parameters (if any). Must be
declared with <code><a href="#topic+student_t">student_t()</a></code>.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_prior_phi">prior_phi</code></td>
<td>
<p>The prior on the AR parameter. Must be
declared with <code><a href="#topic+student_t">student_t()</a></code>.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_fixed_df_value">fixed_df_value</code></td>
<td>
<p>The fixed value for the student-t degrees of freedom
parameter if the degrees of freedom parameter is fixed in the MVT. If the
degrees of freedom parameter is estimated then this argument is ignored.
Must be 1 or greater. Very large values (e.g. the default value)
approximate the normal distribution. If the value is &gt;=1000 then a true
MVN distribution will be fit.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_fixed_phi_value">fixed_phi_value</code></td>
<td>
<p>The fixed value for temporal autoregressive parameter,
between random fields at time(t) and time(t-1). If the phi parameter
is estimated then this argument is ignored.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_estimate_df">estimate_df</code></td>
<td>
<p>Logical: should the degrees of freedom parameter be
estimated?</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_estimate_ar">estimate_ar</code></td>
<td>
<p>Logical: should the AR (autoregressive) parameter be
estimated? Here, this refers to a autoregressive process in the evolution
of the spatial field through time.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_family">family</code></td>
<td>
<p>Family object describing the observation model. Note that only
one link is implemented for each distribution. Gamma, negative binomial
(specified via <code><a href="#topic+nbinom2">nbinom2()</a></code> as <code>nbinom2(link = "log")</code>, and Poisson must
have a log link. Binomial must have a logit link. Also implemented is the
lognormal (specified via <code><a href="#topic+lognormal">lognormal()</a></code> as <code>lognormal(link = "log")</code>.
Besides the negative binomial and lognormal, other families are specified
as shown in <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_binomial_n">binomial_N</code></td>
<td>
<p>A character object giving the optional name of the column containing
Binomial sample size. Leave as <code>NULL</code> to fit a spatial GLMM with sample sizes (N) = 1,
equivalent to bernoulli model.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_covariance">covariance</code></td>
<td>
<p>The covariance function of the Gaussian Process.
One of &quot;squared-exponential&quot;, &quot;exponential&quot;, or &quot;matern&quot;.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_matern_kappa">matern_kappa</code></td>
<td>
<p>Optional parameter for the Matern covariance function.
Optional values are 1.5 or 2.5. Values of 0.5 are equivalent to exponential.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_algorithm">algorithm</code></td>
<td>
<p>Character object describing whether the model should be fit
with full NUTS MCMC or via the variational inference mean-field approach.
See <code><a href="rstan.html#topic+stanmodel-method-vb">rstan::vb()</a></code>. Note that the variational inference approach
should not be trusted for final inference and is much more likely to give
incorrect inference than MCMC.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_year_re">year_re</code></td>
<td>
<p>Logical: estimate a random walk for the time variable? If
<code>TRUE</code>, then no fixed effects (B coefficients) will be estimated.
In this case, <code>prior_intercept</code> will be used as the prior for
the initial value in time.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_nb_lower_truncation">nb_lower_truncation</code></td>
<td>
<p>For NB2 only: lower truncation value. E.g. 0 for
no truncation, 1 for 1 and all values above. Note that estimation is
likely to be considerably slower with lower truncation because the
sampling is not vectorized. Also note that the log likelihood values
returned for estimating quantities like LOOIC will not be correct if
lower truncation is implemented.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_control">control</code></td>
<td>
<p>List to pass to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>. For example,
increase <code>adapt_delta</code> if there are warnings about divergent
transitions: <code>control = list(adapt_delta = 0.99)</code>. By default,
<span class="pkg">glmmfields</span> sets <code>adapt_delta = 0.9</code>.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_save_log_lik">save_log_lik</code></td>
<td>
<p>Logical: should the log likelihood for each data point be
saved so that information criteria such as LOOIC or WAIC can be calculated?
Defaults to <code>FALSE</code> so that the size of model objects is smaller.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_df_lower_bound">df_lower_bound</code></td>
<td>
<p>The lower bound on the degrees of freedom parameter.
Values that are too low, e.g. below 2 or 3, it might affect chain
convergence. Defaults to 2.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_cluster">cluster</code></td>
<td>
<p>The type of clustering algorithm used to determine the knot
locations. <code>"pam"</code> = <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>. The <code>"kmeans"</code>
algorithm will be faster on larger datasets.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_offset">offset</code></td>
<td>
<p>An optional offset vector.</p>
</td></tr>
<tr><td><code id="glmmfields_+3A_...">...</code></td>
<td>
<p>Any other arguments to pass to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that there is no guarantee that the default priors are reasonable for
your data. Also, there is no guarantee the default priors will remain the
same in future versions. Therefore it is important that you specify any
priors that are used in your model, even if they replicate the defaults in
the package. It is particularly important that you consider that prior on
<code>gp_theta</code> since it depends on the distance between your location points. You
may need to scale your coordinate units so they are on a ballpark range of
1-10 by, say, dividing the coordinates (say in UTMs) by several order of
magnitude.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Spatiotemporal example:
set.seed(1)
s &lt;- sim_glmmfields(n_draws = 12, n_knots = 12, gp_theta = 1.5,
gp_sigma = 0.2, sd_obs = 0.2)
print(s$plot)
# options(mc.cores = parallel::detectCores()) # for parallel processing
# should use 4 or more chains for real model fits
m &lt;- glmmfields(y ~ 0, time = "time",
 lat = "lat", lon = "lon", data = s$dat,
 nknots = 12, iter = 1000, chains = 2, seed = 1)

# Spatial example (with covariates) from the vignette and customizing
# some priors:
set.seed(1)
N &lt;- 100 # number of data points
temperature &lt;- rnorm(N, 0, 1) # simulated temperature data
X &lt;- cbind(1, temperature) # design matrix
s &lt;- sim_glmmfields(n_draws = 1, gp_theta = 1.2, n_data_points = N,
  gp_sigma = 0.3, sd_obs = 0.1, n_knots = 12, obs_error = "gamma",
  covariance = "squared-exponential", X = X,
  B = c(0.5, 0.2)) # B represents our intercept and slope
d &lt;- s$dat
d$temperature &lt;- temperature
library(ggplot2)
ggplot(s$dat, aes(lon, lat, colour = y)) +
  viridis::scale_colour_viridis() +
  geom_point(size = 3)
m_spatial &lt;- glmmfields(y ~ temperature, data = d, family = Gamma(link = "log"),
  lat = "lat", lon = "lon", nknots = 12, iter = 2000, chains = 2,
  prior_beta = student_t(100, 0, 1), prior_intercept = student_t(100, 0, 5),
  control = list(adapt_delta = 0.95))

</code></pre>

<hr>
<h2 id='lognormal'>Lognormal family</h2><span id='topic+lognormal'></span>

<h3>Description</h3>

<p>Lognormal family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lognormal(link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lognormal_+3A_link">link</code></td>
<td>
<p>The link (must be log)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>lognormal()
</code></pre>

<hr>
<h2 id='loo.glmmfields'>Return LOO information criteria</h2><span id='topic+loo.glmmfields'></span><span id='topic+loo'></span>

<h3>Description</h3>

<p>Extract the LOOIC (leave-one-out information criterion) using
<code><a href="loo.html#topic+loo">loo::loo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmfields'
loo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo.glmmfields_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+glmmfields">glmmfields()</a></code>.
Must be fit with <code>save_log_lik = TRUE</code>, which is <em>not</em> the default.</p>
</td></tr>
<tr><td><code id="loo.glmmfields_+3A_...">...</code></td>
<td>
<p>Arguments for <code><a href="loo.html#topic+relative_eff">loo::relative_eff()</a></code> and <code><a href="loo.html#topic+loo">loo::loo.array()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
s &lt;- sim_glmmfields(n_draws = 12, n_knots = 12, gp_theta = 1.5,
gp_sigma = 0.2, sd_obs = 0.2)
# options(mc.cores = parallel::detectCores()) # for parallel processing

# save_log_lik defaults to FALSE to save space but is needed for loo():
m &lt;- glmmfields(y ~ 0, time = "time",
 lat = "lat", lon = "lon", data = s$dat,
 nknots = 12, iter = 1000, chains = 4, seed = 1,
 save_log_lik = TRUE)
loo(m)

</code></pre>

<hr>
<h2 id='nbinom2'>Negative binomial family</h2><span id='topic+nbinom2'></span>

<h3>Description</h3>

<p>This is the NB2 parameterization where the variance scales quadratically
with the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbinom2(link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nbinom2_+3A_link">link</code></td>
<td>
<p>The link (must be log)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>nbinom2()
</code></pre>

<hr>
<h2 id='plot.glmmfields'>Plot predictions from an glmmfields model</h2><span id='topic+plot.glmmfields'></span>

<h3>Description</h3>

<p>Plot predictions from an glmmfields model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmfields'
plot(
  x,
  type = c("prediction", "spatial-residual", "residual-vs-fitted"),
  link = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.glmmfields_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+glmmfields">glmmfields</a></code></p>
</td></tr>
<tr><td><code id="plot.glmmfields_+3A_type">type</code></td>
<td>
<p>Type of plot</p>
</td></tr>
<tr><td><code id="plot.glmmfields_+3A_link">link</code></td>
<td>
<p>Logical: should the plots be made on the link scale
or on the natural scale?</p>
</td></tr>
<tr><td><code id="plot.glmmfields_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+predict.glmmfields">predict.glmmfields</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Spatiotemporal example:
set.seed(1)
s &lt;- sim_glmmfields(n_draws = 12, n_knots = 12, gp_theta = 1.5,
gp_sigma = 0.2, sd_obs = 0.1)
# options(mc.cores = parallel::detectCores()) # for parallel processing
m &lt;- glmmfields(y ~ 0, time = "time",
 lat = "lat", lon = "lon", data = s$dat,
 nknots = 12, iter = 600, chains = 1)
x &lt;- plot(m, type = "prediction")
x
x + ggplot2::scale_color_gradient2()
plot(m, type = "spatial-residual")
plot(m, type = "residual-vs-fitted")

</code></pre>

<hr>
<h2 id='predict'>Predict from a glmmfields model</h2><span id='topic+predict'></span><span id='topic+predictive_interval'></span><span id='topic+posterior_linpred'></span><span id='topic+posterior_predict'></span><span id='topic+predictive_interval.glmmfields'></span><span id='topic+posterior_linpred.glmmfields'></span><span id='topic+posterior_predict.glmmfields'></span><span id='topic+predict.glmmfields'></span>

<h3>Description</h3>

<p>These functions extract posterior draws or credible intervals. The helper
functions are named to match those in the <span class="pkg">rstanarm</span> package and call the
function <code>predict()</code> with appropriate argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmfields'
predictive_interval(object, ...)

## S3 method for class 'glmmfields'
posterior_linpred(object, ...)

## S3 method for class 'glmmfields'
posterior_predict(object, ...)

## S3 method for class 'glmmfields'
predict(
  object,
  newdata = NULL,
  estimate_method = c("median", "mean"),
  conf_level = 0.95,
  interval = c("confidence", "prediction"),
  type = c("link", "response"),
  return_mcmc = FALSE,
  offset = NULL,
  iter = "all",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+glmmfields">glmmfields()</a></code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Ignored currently</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, a data frame to predict on</p>
</td></tr>
<tr><td><code id="predict_+3A_estimate_method">estimate_method</code></td>
<td>
<p>Method for computing point estimate (&quot;mean&quot; or
&quot;median&quot;)</p>
</td></tr>
<tr><td><code id="predict_+3A_conf_level">conf_level</code></td>
<td>
<p>Probability level for the credible intervals.</p>
</td></tr>
<tr><td><code id="predict_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation. Same as for
<code><a href="stats.html#topic+predict.lm">stats::predict.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_type">type</code></td>
<td>
<p>Whether the predictions are returned on &quot;link&quot; scale or
&quot;response&quot; scale (Same as for <code><a href="stats.html#topic+predict.glm">stats::predict.glm()</a></code>).</p>
</td></tr>
<tr><td><code id="predict_+3A_return_mcmc">return_mcmc</code></td>
<td>
<p>Logical. Should the full MCMC draws be returned for the
predictions?</p>
</td></tr>
<tr><td><code id="predict_+3A_offset">offset</code></td>
<td>
<p>Optional offset vector to be used in prediction.</p>
</td></tr>
<tr><td><code id="predict_+3A_iter">iter</code></td>
<td>
<p>Number of MCMC iterations to draw. Defaults to all.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

# simulate:
set.seed(1)
s &lt;- sim_glmmfields(
  n_draws = 12, n_knots = 12, gp_theta = 2.5,
  gp_sigma = 0.2, sd_obs = 0.1
)

# fit:
# options(mc.cores = parallel::detectCores()) # for parallel processing
m &lt;- glmmfields(y ~ 0,
  data = s$dat, time = "time",
  lat = "lat", lon = "lon",
  nknots = 12, iter = 800, chains = 1
)

# Predictions:
# Link scale credible intervals:
p &lt;- predict(m, type = "link", interval = "confidence")
head(p)

# Prediction intervals on new observations (include observation error):
p &lt;- predictive_interval(m)
head(p)

# Posterior prediction draws:
p &lt;- posterior_predict(m, iter = 100)
dim(p) # rows are iterations and columns are data elements

# Draws from the linear predictor (not in link space):
p &lt;- posterior_linpred(m, iter = 100)
dim(p) # rows are iterations and columns are data elements

# Use the `tidy` method to extract parameter estimates as a data frame:
head(tidy(m, conf.int = TRUE, conf.method = "HPDinterval"))

# Make predictions on a fine-scale spatial grid:
pred_grid &lt;- expand.grid(
  lat = seq(min(s$dat$lat), max(s$dat$lat), length.out = 25),
  lon = seq(min(s$dat$lon), max(s$dat$lon), length.out = 25),
  time = unique(s$dat$time)
)
pred_grid$prediction &lt;- predict(m,
  newdata = pred_grid, type = "response", iter = 100,
  estimate_method = "median", offset = rep(0, nrow(pred_grid))
)$estimate

ggplot(pred_grid, aes(lon, lat, fill = prediction)) +
  facet_wrap(~time) +
  geom_raster() +
  scale_fill_gradient2()

</code></pre>

<hr>
<h2 id='sim_glmmfields'>Simulate a random field with a MVT distribution</h2><span id='topic+sim_glmmfields'></span>

<h3>Description</h3>

<p>Simulate a random field with a MVT distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_glmmfields(
  n_knots = 15,
  n_draws = 10,
  gp_theta = 0.5,
  gp_sigma = 0.2,
  mvt = TRUE,
  df = 1e+06,
  seed = NULL,
  n_data_points = 100,
  sd_obs = 0.1,
  covariance = c("squared-exponential", "exponential", "matern"),
  matern_kappa = 0.5,
  obs_error = c("normal", "gamma", "poisson", "nb2", "binomial", "lognormal"),
  B = c(0),
  phi = 0,
  X = rep(1, n_draws * n_data_points),
  g = data.frame(lon = runif(n_data_points, 0, 10), lat = runif(n_data_points, 0, 10))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_glmmfields_+3A_n_knots">n_knots</code></td>
<td>
<p>The number of knots</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_n_draws">n_draws</code></td>
<td>
<p>The number of draws (for example, the number of years)</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_gp_theta">gp_theta</code></td>
<td>
<p>The Gaussian Process scale parameter</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_gp_sigma">gp_sigma</code></td>
<td>
<p>The Gaussian Process variance parameter</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_mvt">mvt</code></td>
<td>
<p>Logical: MVT? (vs. MVN)</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_df">df</code></td>
<td>
<p>The degrees of freedom parameter for the MVT distribution</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_seed">seed</code></td>
<td>
<p>The random seed value</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_n_data_points">n_data_points</code></td>
<td>
<p>The number of data points per draw</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_sd_obs">sd_obs</code></td>
<td>
<p>The observation process scale parameter</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_covariance">covariance</code></td>
<td>
<p>The covariance function of the Gaussian process
(&quot;squared-exponential&quot;, &quot;exponential&quot;, &quot;matern&quot;)</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_matern_kappa">matern_kappa</code></td>
<td>
<p>The optional matern parameter. Can be 1.5 or 2.5. Values
of 0.5 equivalent to exponential model.</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_obs_error">obs_error</code></td>
<td>
<p>The observation error distribution</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_b">B</code></td>
<td>
<p>A vector of parameters. The first element is the intercept</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_phi">phi</code></td>
<td>
<p>The auto regressive parameter on the mean of the random field knots</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_x">X</code></td>
<td>
<p>The model matrix</p>
</td></tr>
<tr><td><code id="sim_glmmfields_+3A_g">g</code></td>
<td>
<p>Grid of points</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- sim_glmmfields(n_draws = 12, n_knots = 12, gp_theta = 1.5,
  gp_sigma = 0.2, sd_obs = 0.2)
names(s)
</code></pre>

<hr>
<h2 id='stan_pars'>Return a vector of parameters</h2><span id='topic+stan_pars'></span>

<h3>Description</h3>

<p>Return a vector of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_pars(
  obs_error,
  estimate_df = TRUE,
  est_temporalRE = FALSE,
  estimate_ar = FALSE,
  fixed_intercept = FALSE,
  save_log_lik = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_pars_+3A_obs_error">obs_error</code></td>
<td>
<p>The observation error distribution</p>
</td></tr>
<tr><td><code id="stan_pars_+3A_estimate_df">estimate_df</code></td>
<td>
<p>Logical indicating whether the degrees of freedom
parameter should be estimated</p>
</td></tr>
<tr><td><code id="stan_pars_+3A_est_temporalre">est_temporalRE</code></td>
<td>
<p>Logical: estimate a random walk for the time variable?</p>
</td></tr>
<tr><td><code id="stan_pars_+3A_estimate_ar">estimate_ar</code></td>
<td>
<p>Logical indicating whether the ar
parameter should be estimated</p>
</td></tr>
<tr><td><code id="stan_pars_+3A_fixed_intercept">fixed_intercept</code></td>
<td>
<p>Should the intercept be fixed?</p>
</td></tr>
<tr><td><code id="stan_pars_+3A_save_log_lik">save_log_lik</code></td>
<td>
<p>Logical: should the log likelihood for each data point be
saved so that information criteria such as LOOIC or WAIC can be calculated?
Defaults to <code>FALSE</code> so that the size of model objects is smaller.</p>
</td></tr>
</table>

<hr>
<h2 id='student_t'>Student-t and half-t priors</h2><span id='topic+student_t'></span><span id='topic+half_t'></span>

<h3>Description</h3>

<p>Student-t and half-t priors. Note that this can be used to represent an
effectively normal distribution prior by setting the first argument (the
degrees of freedom parameter) to a large value (roughly 50 or above).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>student_t(df = 3, location = 0, scale = 1)

half_t(df = 3, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="student_t_+3A_df">df</code></td>
<td>
<p>Degrees of freedom parameter</p>
</td></tr>
<tr><td><code id="student_t_+3A_location">location</code></td>
<td>
<p>Location parameter</p>
</td></tr>
<tr><td><code id="student_t_+3A_scale">scale</code></td>
<td>
<p>Scale parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>student_t(3, 0, 1)
half_t(3, 0, 1)
</code></pre>

<hr>
<h2 id='tidy'>Tidy model output</h2><span id='topic+tidy'></span><span id='topic+tidy.glmmfields'></span>

<h3>Description</h3>

<p>Tidy model output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy(x, ...)

## S3 method for class 'glmmfields'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+glmmfields">glmmfields()</a></code></p>
</td></tr>
<tr><td><code id="tidy_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
