<!DOCTYPE html><html><head><title>Help for package modeltime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modeltime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.prepare_transform'><p>Prepare Recursive Transformations</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#adam_fit_impl'><p>Low-Level ADAM function for translating modeltime to forecast</p></a></li>
<li><a href='#adam_params'><p>Tuning Parameters for ADAM Models</p></a></li>
<li><a href='#Adam_predict_impl'><p>Bridge prediction function for ADAM models</p></a></li>
<li><a href='#adam_reg'><p>General Interface for ADAM Regression Models</p></a></li>
<li><a href='#add_modeltime_model'><p>Add a Model into a Modeltime Table</p></a></li>
<li><a href='#arima_boost'><p>General Interface for &quot;Boosted&quot; ARIMA Regression Models</p></a></li>
<li><a href='#Arima_fit_impl'><p>Low-Level ARIMA function for translating modeltime to forecast</p></a></li>
<li><a href='#arima_params'><p>Tuning Parameters for ARIMA Models</p></a></li>
<li><a href='#Arima_predict_impl'><p>Bridge prediction function for ARIMA models</p></a></li>
<li><a href='#arima_reg'><p>General Interface for ARIMA Regression Models</p></a></li>
<li><a href='#arima_xgboost_fit_impl'><p>Bridge ARIMA-XGBoost Modeling function</p></a></li>
<li><a href='#arima_xgboost_predict_impl'><p>Bridge prediction Function for ARIMA-XGBoost Models</p></a></li>
<li><a href='#auto_adam_fit_impl'><p>Low-Level ADAM function for translating modeltime to forecast</p></a></li>
<li><a href='#Auto_adam_predict_impl'><p>Bridge prediction function for AUTO ADAM models</p></a></li>
<li><a href='#auto_arima_fit_impl'><p>Low-Level ARIMA function for translating modeltime to forecast</p></a></li>
<li><a href='#auto_arima_xgboost_fit_impl'><p>Bridge ARIMA-XGBoost Modeling function</p></a></li>
<li><a href='#combine_modeltime_tables'><p>Combine multiple Modeltime Tables into a single Modeltime Table</p></a></li>
<li><a href='#control_modeltime'><p>Control aspects of the training process</p></a></li>
<li><a href='#create_model_grid'><p>Helper to make <code>parsnip</code> model specs from a <code>dials</code> parameter grid</p></a></li>
<li><a href='#create_xreg_recipe'><p>Developer Tools for preparing XREGS (Regressors)</p></a></li>
<li><a href='#croston_fit_impl'><p>Low-Level Exponential Smoothing function for translating modeltime to forecast</p></a></li>
<li><a href='#croston_predict_impl'><p>Bridge prediction function for CROSTON models</p></a></li>
<li><a href='#drop_modeltime_model'><p>Drop a Model from a Modeltime Table</p></a></li>
<li><a href='#ets_fit_impl'><p>Low-Level Exponential Smoothing function for translating modeltime to forecast</p></a></li>
<li><a href='#ets_predict_impl'><p>Bridge prediction function for Exponential Smoothing models</p></a></li>
<li><a href='#exp_smoothing'><p>General Interface for Exponential Smoothing State Space Models</p></a></li>
<li><a href='#exp_smoothing_params'><p>Tuning Parameters for Exponential Smoothing Models</p></a></li>
<li><a href='#get_arima_description'><p>Get model descriptions for Arima objects</p></a></li>
<li><a href='#get_model_description'><p>Get model descriptions for parsnip, workflows &amp; modeltime objects</p></a></li>
<li><a href='#get_tbats_description'><p>Get model descriptions for TBATS objects</p></a></li>
<li><a href='#is_calibrated'><p>Test if a Modeltime Table has been calibrated</p></a></li>
<li><a href='#is_modeltime_model'><p>Test if object contains a fitted modeltime model</p></a></li>
<li><a href='#is_modeltime_table'><p>Test if object is a Modeltime Table</p></a></li>
<li><a href='#is_residuals'><p>Test if a table contains residuals.</p></a></li>
<li><a href='#load_namespace'><p>These are not intended for use by the general public.</p></a></li>
<li><a href='#log_extractors'><p>Log Extractor Functions for Modeltime Nested Tables</p></a></li>
<li><a href='#m750'><p>The 750th Monthly Time Series used in the M4 Competition</p></a></li>
<li><a href='#m750_models'><p>Three (3) Models trained on the M750 Data (Training Set)</p></a></li>
<li><a href='#m750_splits'><p>The results of train/test splitting the M750 Data</p></a></li>
<li><a href='#m750_training_resamples'><p>The Time Series Cross Validation Resamples the M750 Data (Training Set)</p></a></li>
<li><a href='#maape'><p>Mean Arctangent Absolute Percentage Error</p></a></li>
<li><a href='#maape_vec'><p>Mean Arctangent Absolute Percentage Error</p></a></li>
<li><a href='#make_ts_splits'><p>Generate a Time Series Train/Test Split Indicies</p></a></li>
<li><a href='#mdl_time_forecast'><p>Modeltime Forecast Helpers</p></a></li>
<li><a href='#mdl_time_refit'><p>Modeltime Refit Helpers</p></a></li>
<li><a href='#metric_sets'><p>Forecast Accuracy Metrics Sets</p></a></li>
<li><a href='#modeltime_accuracy'><p>Calculate Accuracy Metrics</p></a></li>
<li><a href='#modeltime_calibrate'><p>Preparation for forecasting</p></a></li>
<li><a href='#modeltime_fit_workflowset'><p>Fit a <code>workflowset</code> object to one or multiple time series</p></a></li>
<li><a href='#modeltime_forecast'><p>Forecast future data</p></a></li>
<li><a href='#modeltime_nested_fit'><p>Fit Tidymodels Workflows to Nested Time Series</p></a></li>
<li><a href='#modeltime_nested_forecast'><p>Modeltime Nested Forecast</p></a></li>
<li><a href='#modeltime_nested_refit'><p>Refits a Nested Modeltime Table</p></a></li>
<li><a href='#modeltime_nested_select_best'><p>Select the Best Models from Nested Modeltime Table</p></a></li>
<li><a href='#modeltime_refit'><p>Refit one or more trained models to new data</p></a></li>
<li><a href='#modeltime_residuals'><p>Extract Residuals Information</p></a></li>
<li><a href='#modeltime_residuals_test'><p>Apply Statistical Tests to Residuals</p></a></li>
<li><a href='#modeltime_table'><p>Scale forecast analysis with a Modeltime Table</p></a></li>
<li><a href='#naive_fit_impl'><p>Low-Level NAIVE Forecast</p></a></li>
<li><a href='#naive_predict_impl'><p>Bridge prediction function for NAIVE Models</p></a></li>
<li><a href='#naive_reg'><p>General Interface for NAIVE Forecast Models</p></a></li>
<li><a href='#new_modeltime_bridge'><p>Constructor for creating modeltime models</p></a></li>
<li><a href='#nnetar_fit_impl'><p>Low-Level NNETAR function for translating modeltime to forecast</p></a></li>
<li><a href='#nnetar_params'><p>Tuning Parameters for NNETAR Models</p></a></li>
<li><a href='#nnetar_predict_impl'><p>Bridge prediction function for ARIMA models</p></a></li>
<li><a href='#nnetar_reg'><p>General Interface for NNETAR Regression Models</p></a></li>
<li><a href='#panel_tail'><p>Filter the last N rows (Tail) for multiple time series</p></a></li>
<li><a href='#parallel_start'><p>Start parallel clusters using <code>parallel</code> package</p></a></li>
<li><a href='#parse_index'><p>Developer Tools for parsing date and date-time information</p></a></li>
<li><a href='#plot_modeltime_forecast'><p>Interactive Forecast Visualization</p></a></li>
<li><a href='#plot_modeltime_residuals'><p>Interactive Residuals Visualization</p></a></li>
<li><a href='#pluck_modeltime_model'><p>Extract model by model id in a Modeltime Table</p></a></li>
<li><a href='#prep_nested'><p>Prepared Nested Modeltime Data</p></a></li>
<li><a href='#prophet_boost'><p>General Interface for Boosted PROPHET Time Series Models</p></a></li>
<li><a href='#prophet_fit_impl'><p>Low-Level PROPHET function for translating modeltime to PROPHET</p></a></li>
<li><a href='#prophet_params'><p>Tuning Parameters for Prophet Models</p></a></li>
<li><a href='#prophet_predict_impl'><p>Bridge prediction function for PROPHET models</p></a></li>
<li><a href='#prophet_reg'><p>General Interface for PROPHET Time Series Models</p></a></li>
<li><a href='#prophet_xgboost_fit_impl'><p>Low-Level PROPHET function for translating modeltime to Boosted PROPHET</p></a></li>
<li><a href='#prophet_xgboost_predict_impl'><p>Bridge prediction function for Boosted PROPHET models</p></a></li>
<li><a href='#pull_modeltime_residuals'><p>Extracts modeltime residuals data from a Modeltime Model</p></a></li>
<li><a href='#pull_parsnip_preprocessor'><p>Pulls the Formula from a Fitted Parsnip Model Object</p></a></li>
<li><a href='#recipe_helpers'><p>Developer Tools for processing XREGS (Regressors)</p></a></li>
<li><a href='#recursive'><p>Create a Recursive Time Series Model from a Parsnip or Workflow Regression Model</p></a></li>
<li><a href='#seasonal_reg'><p>General Interface for Multiple Seasonality Regression Models (TBATS, STLM)</p></a></li>
<li><a href='#smooth_fit_impl'><p>Low-Level Exponential Smoothing function for translating modeltime to forecast</p></a></li>
<li><a href='#smooth_predict_impl'><p>Bridge prediction function for Exponential Smoothing models</p></a></li>
<li><a href='#snaive_fit_impl'><p>Low-Level SNAIVE Forecast</p></a></li>
<li><a href='#snaive_predict_impl'><p>Bridge prediction function for SNAIVE Models</p></a></li>
<li><a href='#stlm_arima_fit_impl'><p>Low-Level stlm function for translating modeltime to forecast</p></a></li>
<li><a href='#stlm_arima_predict_impl'><p>Bridge prediction function for ARIMA models</p></a></li>
<li><a href='#stlm_ets_fit_impl'><p>Low-Level stlm function for translating modeltime to forecast</p></a></li>
<li><a href='#stlm_ets_predict_impl'><p>Bridge prediction function for ARIMA models</p></a></li>
<li><a href='#summarize_accuracy_metrics'><p>Summarize Accuracy Metrics</p></a></li>
<li><a href='#table_modeltime_accuracy'><p>Interactive Accuracy Tables</p></a></li>
<li><a href='#tbats_fit_impl'><p>Low-Level tbats function for translating modeltime to forecast</p></a></li>
<li><a href='#tbats_predict_impl'><p>Bridge prediction function for ARIMA models</p></a></li>
<li><a href='#temporal_hier_fit_impl'><p>Low-Level Temporaral Hierarchical function for translating modeltime to forecast</p></a></li>
<li><a href='#temporal_hier_predict_impl'><p>Bridge prediction function for TEMPORAL HIERARCHICAL models</p></a></li>
<li><a href='#temporal_hierarchy'><p>General Interface for Temporal Hierarchical Forecasting (THIEF) Models</p></a></li>
<li><a href='#temporal_hierarchy_params'><p>Tuning Parameters for TEMPORAL HIERARCHICAL Models</p></a></li>
<li><a href='#theta_fit_impl'><p>Low-Level Exponential Smoothing function for translating modeltime to forecast</p></a></li>
<li><a href='#theta_predict_impl'><p>Bridge prediction function for THETA models</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#time_series_params'><p>Tuning Parameters for Time Series (ts-class) Models</p></a></li>
<li><a href='#type_sum.mdl_time_tbl'><p>Succinct summary of Modeltime Tables</p></a></li>
<li><a href='#update_model_description'><p>Update the model description by model id in a Modeltime Table</p></a></li>
<li><a href='#update_modeltime_model'><p>Update the model by model id in a Modeltime Table</p></a></li>
<li><a href='#window_function_fit_impl'><p>Low-Level Window Forecast</p></a></li>
<li><a href='#window_function_predict_impl'><p>Bridge prediction function for window Models</p></a></li>
<li><a href='#window_reg'><p>General Interface for Window Forecast Models</p></a></li>
<li><a href='#xgboost_impl'><p>Wrapper for parsnip::xgb_train</p></a></li>
<li><a href='#xgboost_predict'><p>Wrapper for xgboost::predict</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The Tidymodels Extension for Time Series Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.8</td>
</tr>
<tr>
<td>Description:</td>
<td>
    The time series forecasting framework for use with the 'tidymodels' ecosystem. 
    Models include ARIMA, Exponential Smoothing, and additional time series models
    from the 'forecast' and 'prophet' packages. Refer to "Forecasting Principles &amp; Practice, Second edition" 
    (<a href="https://otexts.com/fpp2/">https://otexts.com/fpp2/</a>).
    Refer to "Prophet: forecasting at scale" 
    (<a href="https://research.facebook.com/blog/2017/02/prophet-forecasting-at-scale/">https://research.facebook.com/blog/2017/02/prophet-forecasting-at-scale/</a>.).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/business-science/modeltime">https://github.com/business-science/modeltime</a>,
<a href="https://business-science.github.io/modeltime/">https://business-science.github.io/modeltime/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/business-science/modeltime/issues">https://github.com/business-science/modeltime/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>StanHeaders, timetk (&ge; 2.8.1), parsnip (&ge; 0.2.1), dials,
yardstick (&ge; 0.0.8), workflows (&ge; 1.0.0), hardhat (&ge; 1.0.0),
rlang (&ge; 0.1.2), glue, plotly, reactable, gt, ggplot2, tibble,
tidyr, dplyr, purrr, stringr, forcats, scales, janitor,
parallel, parallelly, doParallel, foreach, magrittr, forecast,
xgboost (&ge; 1.2.0.1), prophet, methods, cli, tidyverse,
tidymodels</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rstan, slider, sparklyr, workflowsets, recipes, rsample, tune
(&ge; 0.2.0), lubridate, progress, testthat, roxygen2, kernlab,
glmnet, thief, smooth, greybox, earth, randomForest,
trelliscopejs, knitr, rmarkdown (&ge; 2.9), webshot, qpdf, covr,
TSrepr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-02 14:32:11 UTC; mdanc</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Dancho [aut, cre],
  Business Science [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Dancho &lt;mdancho@business-science.io&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-02 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.prepare_transform'>Prepare Recursive Transformations</h2><span id='topic+.prepare_transform'></span><span id='topic+.prepare_panel_transform'></span>

<h3>Description</h3>

<p>Prepare Recursive Transformations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prepare_transform(.transform)

.prepare_panel_transform(.transform)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prepare_transform_+3A_.transform">.transform</code></td>
<td>
<p>A transformation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that applies a recursive transformation
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='adam_fit_impl'>Low-Level ADAM function for translating modeltime to forecast</h2><span id='topic+adam_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level ADAM function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adam_fit_impl(
  x,
  y,
  period = "auto",
  p = 0,
  d = 0,
  q = 0,
  P = 0,
  D = 0,
  Q = 0,
  model = "ZXZ",
  constant = FALSE,
  regressors = c("use", "select", "adapt"),
  outliers = c("ignore", "use", "select"),
  level = 0.99,
  occurrence = c("none", "auto", "fixed", "general", "odds-ratio", "inverse-odds-ratio",
    "direct"),
  distribution = c("default", "dnorm", "dlaplace", "ds", "dgnorm", "dlnorm", "dinvgauss",
    "dgamma"),
  loss = c("likelihood", "MSE", "MAE", "HAM", "LASSO", "RIDGE", "MSEh", "TMSE", "GTMSE",
    "MSCE"),
  ic = c("AICc", "AIC", "BIC", "BICc"),
  select_order = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adam_fit_impl_+3A_x">x</code></td>
<td>
<p>A data.frame of predictors</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_y">y</code></td>
<td>
<p>A vector with outcome</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_p">p</code></td>
<td>
<p>The order of the non-seasonal auto-regressive (AR) terms. Often denoted &quot;p&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_d">d</code></td>
<td>
<p>The order of integration for non-seasonal differencing. Often denoted &quot;d&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_q">q</code></td>
<td>
<p>The order of the non-seasonal moving average (MA) terms. Often denoted &quot;q&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_p">P</code></td>
<td>
<p>The order of the seasonal auto-regressive (SAR) terms. Often denoted &quot;P&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_d">D</code></td>
<td>
<p>The order of integration for seasonal differencing. Often denoted &quot;D&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_q">Q</code></td>
<td>
<p>The order of the seasonal moving average (SMA) terms. Often denoted &quot;Q&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_model">model</code></td>
<td>
<p>The type of ETS model.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_constant">constant</code></td>
<td>
<p>Logical, determining, whether the constant is needed in the model or not.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided explanatory variables.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_outliers">outliers</code></td>
<td>
<p>Defines what to do with outliers.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_level">level</code></td>
<td>
<p>What confidence level to use for detection of outliers.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_occurrence">occurrence</code></td>
<td>
<p>The type of model used in probability estimation.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_distribution">distribution</code></td>
<td>
<p>what density function to assume for the error term.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_ic">ic</code></td>
<td>
<p>The information criterion to use in the model selection / combination procedure.</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_select_order">select_order</code></td>
<td>
<p>If TRUE, then the function will select the most appropriate order using a
mechanism similar to auto.msarima(), but implemented in auto.adam(). The values list(ar=...,i=...,ma=...)
specify the maximum orders to check in this case</p>
</td></tr>
<tr><td><code id="adam_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>smooth::adam</code></p>
</td></tr>
</table>

<hr>
<h2 id='adam_params'>Tuning Parameters for ADAM Models</h2><span id='topic+adam_params'></span><span id='topic+use_constant'></span><span id='topic+regressors_treatment'></span><span id='topic+outliers_treatment'></span><span id='topic+probability_model'></span><span id='topic+distribution'></span><span id='topic+information_criteria'></span><span id='topic+select_order'></span>

<h3>Description</h3>

<p>Tuning Parameters for ADAM Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_constant(values = c(FALSE, TRUE))

regressors_treatment(values = c("use", "select", "adapt"))

outliers_treatment(values = c("ignore", "use", "select"))

probability_model(
  values = c("none", "auto", "fixed", "general", "odds-ratio", "inverse-odds-ratio",
    "direct")
)

distribution(
  values = c("default", "dnorm", "dlaplace", "ds", "dgnorm", "dlnorm", "dinvgauss",
    "dgamma")
)

information_criteria(values = c("AICc", "AIC", "BICc", "BIC"))

select_order(values = c(FALSE, TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adam_params_+3A_values">values</code></td>
<td>
<p>A character string of possible values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main parameters for ADAM models are:
</p>

<ul>
<li> <p><code>non_seasonal_ar</code>: The order of the non-seasonal auto-regressive (AR) terms.
</p>
</li>
<li> <p><code>non_seasonal_differences</code>: The order of integration for non-seasonal differencing.
</p>
</li>
<li> <p><code>non_seasonal_ma</code>: The order of the non-seasonal moving average (MA) terms.
</p>
</li>
<li> <p><code>seasonal_ar</code>: The order of the seasonal auto-regressive (SAR) terms.
</p>
</li>
<li> <p><code>seasonal_differences</code>: The order of integration for seasonal differencing.
</p>
</li>
<li> <p><code>seasonal_ma</code>: The order of the seasonal moving average (SMA) terms.
</p>
</li>
<li> <p><code>use_constant</code>: Logical, determining, whether the constant is needed in the model or not.
</p>
</li>
<li> <p><code>regressors_treatment</code>: The variable defines what to do with the provided explanatory variables.
</p>
</li>
<li> <p><code>outliers_treatment</code>: Defines what to do with outliers.
</p>
</li>
<li> <p><code>probability_model</code>: The type of model used in probability estimation.
</p>
</li>
<li> <p><code>distribution</code>: What density function to assume for the error term.
</p>
</li>
<li> <p><code>information_criteria</code>: The information criterion to use in the model selection / combination procedure.
</p>
</li>
<li> <p><code>select_order</code>: If TRUE, then the function will select the most appropriate order.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>dials</code> parameter
</p>
<p>A parameter
</p>
<p>A parameter
</p>
<p>A parameter
</p>
<p>A parameter
</p>
<p>A parameter
</p>
<p>A parameter
</p>
<p>A parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use_constant()

regressors_treatment()

distribution()


</code></pre>

<hr>
<h2 id='Adam_predict_impl'>Bridge prediction function for ADAM models</h2><span id='topic+Adam_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for ADAM models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Adam_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Adam_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="Adam_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="Adam_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>smooth::adam()</code></p>
</td></tr>
</table>

<hr>
<h2 id='adam_reg'>General Interface for ADAM Regression Models</h2><span id='topic+adam_reg'></span>

<h3>Description</h3>

<p><code>adam_reg()</code> is a way to generate a <em>specification</em> of an ADAM model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>smooth</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adam_reg(
  mode = "regression",
  ets_model = NULL,
  non_seasonal_ar = NULL,
  non_seasonal_differences = NULL,
  non_seasonal_ma = NULL,
  seasonal_ar = NULL,
  seasonal_differences = NULL,
  seasonal_ma = NULL,
  use_constant = NULL,
  regressors_treatment = NULL,
  outliers_treatment = NULL,
  outliers_ci = NULL,
  probability_model = NULL,
  distribution = NULL,
  loss = NULL,
  information_criteria = NULL,
  seasonal_period = NULL,
  select_order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adam_reg_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_ets_model">ets_model</code></td>
<td>
<p>The type of ETS model. The first letter stands for the type of the error term (&quot;A&quot; or &quot;M&quot;),
the second (and sometimes the third as well) is for the trend (&quot;N&quot;, &quot;A&quot;, &quot;Ad&quot;, &quot;M&quot; or &quot;Md&quot;), and the last one is
for the type of seasonality (&quot;N&quot;, &quot;A&quot; or &quot;M&quot;).</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_non_seasonal_ar">non_seasonal_ar</code></td>
<td>
<p>The order of the non-seasonal auto-regressive (AR) terms. Often denoted &quot;p&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_non_seasonal_differences">non_seasonal_differences</code></td>
<td>
<p>The order of integration for non-seasonal differencing. Often denoted &quot;d&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_non_seasonal_ma">non_seasonal_ma</code></td>
<td>
<p>The order of the non-seasonal moving average (MA) terms. Often denoted &quot;q&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_seasonal_ar">seasonal_ar</code></td>
<td>
<p>The order of the seasonal auto-regressive (SAR) terms. Often denoted &quot;P&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_seasonal_differences">seasonal_differences</code></td>
<td>
<p>The order of integration for seasonal differencing. Often denoted &quot;D&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_seasonal_ma">seasonal_ma</code></td>
<td>
<p>The order of the seasonal moving average (SMA) terms. Often denoted &quot;Q&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_use_constant">use_constant</code></td>
<td>
<p>Logical, determining, whether the constant is needed in the model or not. This is mainly needed for
ARIMA part of the model, but can be used for ETS as well.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_regressors_treatment">regressors_treatment</code></td>
<td>
<p>The variable defines what to do with the provided explanatory variables: &quot;use&quot; means that all
of the data should be used, while &quot;select&quot; means that a selection using ic should be done, &quot;adapt&quot; will trigger the
mechanism of time varying parameters for the explanatory variables.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_outliers_treatment">outliers_treatment</code></td>
<td>
<p>Defines what to do with outliers: &quot;ignore&quot;, so just returning the model, &quot;detect&quot; outliers based
on specified level and include dummies for them in the model, or detect and &quot;select&quot; those of them that reduce ic value.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_outliers_ci">outliers_ci</code></td>
<td>
<p>What confidence level to use for detection of outliers. Default is 99%.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_probability_model">probability_model</code></td>
<td>
<p>The type of model used in probability estimation. Can be &quot;none&quot; - none, &quot;fixed&quot; - constant
probability, &quot;general&quot; - the general Beta model with two parameters, &quot;odds-ratio&quot; - the Odds-ratio model with b=1 in
Beta distribution, &quot;inverse-odds-ratio&quot; - the model with a=1 in Beta distribution, &quot;direct&quot; - the TSB-like
(Teunter et al., 2011) probability update mechanism a+b=1, &quot;auto&quot; - the automatically selected type of occurrence model.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_distribution">distribution</code></td>
<td>
<p>what density function to assume for the error term. The full name of the distribution should be
provided, starting with the letter &quot;d&quot; - &quot;density&quot;.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_information_criteria">information_criteria</code></td>
<td>
<p>The information criterion to use in the model selection / combination procedure.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
<tr><td><code id="adam_reg_+3A_select_order">select_order</code></td>
<td>
<p>If TRUE, then the function will select the most appropriate order. The values list(ar=...,i=...,ma=...)
specify the maximum orders to check in this case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>adam_reg()</code>, the
mode will always be &quot;regression&quot;.
</p>
<p>The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li><p> &quot;auto_adam&quot; (default) - Connects to <code><a href="smooth.html#topic+adam">smooth::auto.adam()</a></code>
</p>
</li>
<li><p> &quot;adam&quot; - Connects to <code><a href="smooth.html#topic+adam">smooth::adam()</a></code>
</p>
</li></ul>

<p><strong>Main Arguments</strong>
</p>
<p>The main arguments (tuning parameters) for the model are:
</p>

<ul>
<li> <p><code>seasonal_period</code>: The periodic nature of the seasonality. Uses &quot;auto&quot; by default.
</p>
</li>
<li> <p><code>non_seasonal_ar</code>: The order of the non-seasonal auto-regressive (AR) terms.
</p>
</li>
<li> <p><code>non_seasonal_differences</code>: The order of integration for non-seasonal differencing.
</p>
</li>
<li> <p><code>non_seasonal_ma</code>: The order of the non-seasonal moving average (MA) terms.
</p>
</li>
<li> <p><code>seasonal_ar</code>: The order of the seasonal auto-regressive (SAR) terms.
</p>
</li>
<li> <p><code>seasonal_differences</code>: The order of integration for seasonal differencing.
</p>
</li>
<li> <p><code>seasonal_ma</code>: The order of the seasonal moving average (SMA) terms.
</p>
</li>
<li> <p><code>ets_model</code>: The type of ETS model.
</p>
</li>
<li> <p><code>use_constant</code>: Logical, determining, whether the constant is needed in the model or not.
</p>
</li>
<li> <p><code>regressors_treatment</code>: The variable defines what to do with the provided explanatory variables.
</p>
</li>
<li> <p><code>outliers_treatment</code>: Defines what to do with outliers.
</p>
</li>
<li> <p><code>probability_model</code>: The type of model used in probability estimation.
</p>
</li>
<li> <p><code>distribution</code>: what density function to assume for the error term.
</p>
</li>
<li> <p><code>loss</code>: The type of Loss Function used in optimization.
</p>
</li>
<li> <p><code>information_criteria</code>: The information criterion to use in the model selection / combination procedure.
</p>
</li></ul>

<p>These arguments are converted to their specific names at the
time that the model is fit.
</p>
<p>Other options and argument can be
set using <code>set_engine()</code> (See Engine Details below).
</p>
<p>If parameters need to be modified, <code>update()</code> can be used
in lieu of recreating the object from scratch.
</p>
<p><strong>auto_adam (default engine)</strong>
</p>
<p>The engine uses <code><a href="smooth.html#topic+adam">smooth::auto.adam()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; Registered S3 method overwritten by 'greybox':
#&gt;   method     from
#&gt;   print.pcor lava
#&gt; function (data, model = "ZXZ", lags = c(frequency(data)), orders = list(ar = c(0), 
#&gt;     i = c(0), ma = c(0), select = FALSE), formula = NULL, regressors = c("use", 
#&gt;     "select", "adapt"), occurrence = c("none", "auto", "fixed", "general", 
#&gt;     "odds-ratio", "inverse-odds-ratio", "direct"), distribution = c("dnorm", 
#&gt;     "dlaplace", "ds", "dgnorm", "dlnorm", "dinvgauss", "dgamma"), outliers = c("ignore", 
#&gt;     "use", "select"), level = 0.99, h = 0, holdout = FALSE, persistence = NULL, 
#&gt;     phi = NULL, initial = c("optimal", "backcasting"), arma = NULL, ic = c("AICc", 
#&gt;         "AIC", "BIC", "BICc"), bounds = c("usual", "admissible", "none"), 
#&gt;     silent = TRUE, parallel = FALSE, ...)
</pre></div>
<p>The <em>MAXIMUM</em> nonseasonal ARIMA terms (<code>max.p</code>, <code>max.d</code>, <code>max.q</code>) and
seasonal ARIMA terms (<code>max.P</code>, <code>max.D</code>, <code>max.Q</code>) are provided to
<code><a href="forecast.html#topic+auto.arima">forecast::auto.arima()</a></code> via <code>arima_reg()</code> parameters.
Other options and argument can be set using <code>set_engine()</code>.
</p>
<p>Parameter Notes:
</p>

<ul>
<li><p> All values of nonseasonal pdq and seasonal PDQ are maximums.
The <code>smooth::auto.adam()</code> model will select a value using these as an upper limit.
</p>
</li>
<li> <p><code>xreg</code> - This is supplied via the parsnip / modeltime <code>fit()</code> interface
(so don't provide this manually). See Fit Details (below).
</p>
</li></ul>

<p><strong>adam</strong>
</p>
<p>The engine uses <code><a href="smooth.html#topic+adam">smooth::adam()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (data, model = "ZXZ", lags = c(frequency(data)), orders = list(ar = c(0), 
#&gt;     i = c(0), ma = c(0), select = FALSE), constant = FALSE, formula = NULL, 
#&gt;     regressors = c("use", "select", "adapt"), occurrence = c("none", "auto", 
#&gt;         "fixed", "general", "odds-ratio", "inverse-odds-ratio", "direct"), 
#&gt;     distribution = c("default", "dnorm", "dlaplace", "ds", "dgnorm", "dlnorm", 
#&gt;         "dinvgauss", "dgamma"), loss = c("likelihood", "MSE", "MAE", "HAM", 
#&gt;         "LASSO", "RIDGE", "MSEh", "TMSE", "GTMSE", "MSCE"), outliers = c("ignore", 
#&gt;         "use", "select"), level = 0.99, h = 0, holdout = FALSE, persistence = NULL, 
#&gt;     phi = NULL, initial = c("optimal", "backcasting"), arma = NULL, ic = c("AICc", 
#&gt;         "AIC", "BIC", "BICc"), bounds = c("usual", "admissible", "none"), 
#&gt;     silent = TRUE, ...)
</pre></div>
<p>The nonseasonal ARIMA terms (<code>orders</code>) and seasonal ARIMA terms (<code>orders</code>)
are provided to <code><a href="smooth.html#topic+adam">smooth::adam()</a></code> via <code>adam_reg()</code> parameters.
Other options and argument can be set using <code>set_engine()</code>.
</p>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>xreg</code> - This is supplied via the parsnip / modeltime <code>fit()</code> interface
(so don't provide this manually). See Fit Details (below).
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><em>Seasonal Period Specification</em>
</p>
<p>The period can be non-seasonal (<code style="white-space: pre;">&#8288;seasonal_period = 1 or "none"&#8288;</code>) or
yearly seasonal (e.g. For monthly time stamps, <code>seasonal_period = 12</code>, <code>seasonal_period = "12 months"</code>, or <code>seasonal_period = "yearly"</code>).
There are 3 ways to specify:
</p>

<ol>
<li> <p><code>seasonal_period = "auto"</code>: A seasonal period is selected based on the periodicity of the data (e.g. 12 if monthly)
</p>
</li>
<li> <p><code>seasonal_period = 12</code>: A numeric frequency. For example, 12 is common for monthly data
</p>
</li>
<li> <p><code>seasonal_period = "1 year"</code>: A time-based phrase. For example, &quot;1 year&quot; would convert to 12 for monthly data.
</p>
</li></ol>

<p><strong>Univariate (No xregs, Exogenous Regressors):</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (xregs, Exogenous Regressors)</strong>
</p>
<p>The <code>xreg</code> parameter is populated using the <code>fit()</code> function:
</p>

<ul>
<li><p> Only <code>factor</code>, <code style="white-space: pre;">&#8288;ordered factor&#8288;</code>, and <code>numeric</code> data will be used as xregs.
</p>
</li>
<li><p> Date and Date-time variables are not used as xregs
</p>
</li>
<li> <p><code>character</code> data should be converted to factor.
</p>
</li></ul>

<p><em>Xreg Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>month.lbl</code> (labeled month as a ordered factor).
</p>
</li></ol>

<p>The <code>month.lbl</code> is an exogenous regressor that can be passed to the <code>arima_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>fit(y ~ date + month.lbl)</code> will pass <code>month.lbl</code> on as an exogenous regressor.
</p>
</li></ul>

<p>Note that date or date-time class values are excluded from <code>xreg</code>.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)
library(smooth)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- AUTO ADAM ----

# Model Spec
model_spec &lt;- adam_reg() %&gt;%
    set_engine("auto_adam")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit


# ---- STANDARD ADAM ----

# Model Spec
model_spec &lt;- adam_reg(
        seasonal_period          = 12,
        non_seasonal_ar          = 3,
        non_seasonal_differences = 1,
        non_seasonal_ma          = 3,
        seasonal_ar              = 1,
        seasonal_differences     = 0,
        seasonal_ma              = 1
    ) %&gt;%
    set_engine("adam")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit


</code></pre>

<hr>
<h2 id='add_modeltime_model'>Add a Model into a Modeltime Table</h2><span id='topic+add_modeltime_model'></span>

<h3>Description</h3>

<p>Add a Model into a Modeltime Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_modeltime_model(object, model, location = "bottom")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_modeltime_model_+3A_object">object</code></td>
<td>
<p>Multiple Modeltime Tables (class <code>mdl_time_tbl</code>)</p>
</td></tr>
<tr><td><code id="add_modeltime_model_+3A_model">model</code></td>
<td>
<p>A model of class <code>model_fit</code> or a fitted <code>workflow</code> object</p>
</td></tr>
<tr><td><code id="add_modeltime_model_+3A_location">location</code></td>
<td>
<p>Where to add the model. Either &quot;top&quot; or &quot;bottom&quot;. Default: &quot;bottom&quot;.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+combine_modeltime_tables">combine_modeltime_tables()</a></code>: Combine 2 or more Modeltime Tables together
</p>
</li>
<li> <p><code><a href="#topic+add_modeltime_model">add_modeltime_model()</a></code>: Adds a new row with a new model to a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+drop_modeltime_model">drop_modeltime_model()</a></code>: Drop one or more models from a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_description">update_modeltime_description()</a></code>: Updates a description for a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_model">update_modeltime_model()</a></code>: Updates a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+pull_modeltime_model">pull_modeltime_model()</a></code>: Extracts a model from a Modeltime Table
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tidymodels)

model_fit_ets &lt;- exp_smoothing() %&gt;%
    set_engine("ets") %&gt;%
    fit(value ~ date, training(m750_splits))

m750_models %&gt;%
    add_modeltime_model(model_fit_ets)


</code></pre>

<hr>
<h2 id='arima_boost'>General Interface for &quot;Boosted&quot; ARIMA Regression Models</h2><span id='topic+arima_boost'></span>

<h3>Description</h3>

<p><code>arima_boost()</code> is a way to generate a <em>specification</em> of a time series model
that uses boosting to improve modeling errors (residuals) on Exogenous Regressors.
It works with both &quot;automated&quot; ARIMA (<code>auto.arima</code>) and standard ARIMA (<code>arima</code>).
The main algorithms are:
</p>

<ul>
<li><p> Auto ARIMA + XGBoost Errors (engine = <code>auto_arima_xgboost</code>, default)
</p>
</li>
<li><p> ARIMA + XGBoost Errors (engine = <code>arima_xgboost</code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>arima_boost(
  mode = "regression",
  seasonal_period = NULL,
  non_seasonal_ar = NULL,
  non_seasonal_differences = NULL,
  non_seasonal_ma = NULL,
  seasonal_ar = NULL,
  seasonal_differences = NULL,
  seasonal_ma = NULL,
  mtry = NULL,
  trees = NULL,
  min_n = NULL,
  tree_depth = NULL,
  learn_rate = NULL,
  loss_reduction = NULL,
  sample_size = NULL,
  stop_iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arima_boost_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_non_seasonal_ar">non_seasonal_ar</code></td>
<td>
<p>The order of the non-seasonal auto-regressive (AR) terms. Often denoted &quot;p&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_non_seasonal_differences">non_seasonal_differences</code></td>
<td>
<p>The order of integration for non-seasonal differencing. Often denoted &quot;d&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_non_seasonal_ma">non_seasonal_ma</code></td>
<td>
<p>The order of the non-seasonal moving average (MA) terms. Often denoted &quot;q&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_seasonal_ar">seasonal_ar</code></td>
<td>
<p>The order of the seasonal auto-regressive (SAR) terms. Often denoted &quot;P&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_seasonal_differences">seasonal_differences</code></td>
<td>
<p>The order of integration for seasonal differencing. Often denoted &quot;D&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_seasonal_ma">seasonal_ma</code></td>
<td>
<p>The order of the seasonal moving average (SMA) terms. Often denoted &quot;Q&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_mtry">mtry</code></td>
<td>
<p>A number for the number (or proportion) of predictors that will
be randomly sampled at each split when creating the tree models
(specific engines only)</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_trees">trees</code></td>
<td>
<p>An integer for the number of trees contained in
the ensemble.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_min_n">min_n</code></td>
<td>
<p>An integer for the minimum number of data points
in a node that is required for the node to be split further.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_tree_depth">tree_depth</code></td>
<td>
<p>An integer for the maximum depth of the tree (i.e. number
of splits) (specific engines only).</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_learn_rate">learn_rate</code></td>
<td>
<p>A number for the rate at which the boosting algorithm adapts
from iteration-to-iteration (specific engines only). This is sometimes referred to
as the shrinkage parameter.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_loss_reduction">loss_reduction</code></td>
<td>
<p>A number for the reduction in the loss function required
to split further (specific engines only).</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_sample_size">sample_size</code></td>
<td>
<p>number for the number (or proportion) of data that is exposed to the fitting routine.</p>
</td></tr>
<tr><td><code id="arima_boost_+3A_stop_iter">stop_iter</code></td>
<td>
<p>The number of iterations without improvement before
stopping  (<code>xgboost</code> only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>arima_boost()</code>, the
mode will always be &quot;regression&quot;.
</p>
<p>The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li><p> &quot;auto_arima_xgboost&quot; (default) - Connects to <code><a href="forecast.html#topic+auto.arima">forecast::auto.arima()</a></code> and
<a href="xgboost.html#topic+xgb.train">xgboost::xgb.train</a>
</p>
</li>
<li><p> &quot;arima_xgboost&quot; - Connects to <code><a href="forecast.html#topic+Arima">forecast::Arima()</a></code> and
<a href="xgboost.html#topic+xgb.train">xgboost::xgb.train</a>
</p>
</li></ul>

<p><strong>Main Arguments</strong>
</p>
<p>The main arguments (tuning parameters) for the <strong>ARIMA model</strong> are:
</p>

<ul>
<li> <p><code>seasonal_period</code>: The periodic nature of the seasonality. Uses &quot;auto&quot; by default.
</p>
</li>
<li> <p><code>non_seasonal_ar</code>: The order of the non-seasonal auto-regressive (AR) terms.
</p>
</li>
<li> <p><code>non_seasonal_differences</code>: The order of integration for non-seasonal differencing.
</p>
</li>
<li> <p><code>non_seasonal_ma</code>: The order of the non-seasonal moving average (MA) terms.
</p>
</li>
<li> <p><code>seasonal_ar</code>: The order of the seasonal auto-regressive (SAR) terms.
</p>
</li>
<li> <p><code>seasonal_differences</code>: The order of integration for seasonal differencing.
</p>
</li>
<li> <p><code>seasonal_ma</code>: The order of the seasonal moving average (SMA) terms.
</p>
</li></ul>

<p>The main arguments (tuning parameters) for the model <strong>XGBoost model</strong> are:
</p>

<ul>
<li> <p><code>mtry</code>: The number of predictors that will be
randomly sampled at each split when creating the tree models.
</p>
</li>
<li> <p><code>trees</code>: The number of trees contained in the ensemble.
</p>
</li>
<li> <p><code>min_n</code>: The minimum number of data points in a node
that are required for the node to be split further.
</p>
</li>
<li> <p><code>tree_depth</code>: The maximum depth of the tree (i.e. number of
splits).
</p>
</li>
<li> <p><code>learn_rate</code>: The rate at which the boosting algorithm adapts
from iteration-to-iteration.
</p>
</li>
<li> <p><code>loss_reduction</code>: The reduction in the loss function required
to split further.
</p>
</li>
<li> <p><code>sample_size</code>: The amount of data exposed to the fitting routine.
</p>
</li>
<li> <p><code>stop_iter</code>: The number of iterations without improvement before
stopping.
</p>
</li></ul>

<p>These arguments are converted to their specific names at the
time that the model is fit.
</p>
<p>Other options and argument can be
set using <code>set_engine()</code> (See Engine Details below).
</p>
<p>If parameters need to be modified, <code>update()</code> can be used
in lieu of recreating the object from scratch.
</p>


<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:
</p>
<p>Model 1: ARIMA:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> forecast::auto.arima </td><td style="text-align: left;"> forecast::Arima </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonal_period </td><td style="text-align: left;"> ts(frequency) </td><td style="text-align: left;"> ts(frequency) </td>
</tr>
<tr>
 <td style="text-align: left;">
   non_seasonal_ar, non_seasonal_differences, non_seasonal_ma </td><td style="text-align: left;"> max.p(5), max.d(2), max.q(5) </td><td style="text-align: left;"> order = c(p(0), d(0), q(0)) </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonal_ar, seasonal_differences, seasonal_ma </td><td style="text-align: left;"> max.P(2), max.D(1), max.Q(2) </td><td style="text-align: left;"> seasonal = c(P(0), D(0), Q(0)) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Model 2: XGBoost:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> xgboost::xgb.train </td>
</tr>
<tr>
 <td style="text-align: left;">
   tree_depth </td><td style="text-align: left;"> max_depth (6) </td>
</tr>
<tr>
 <td style="text-align: left;">
   trees </td><td style="text-align: left;"> nrounds (15) </td>
</tr>
<tr>
 <td style="text-align: left;">
   learn_rate </td><td style="text-align: left;"> eta (0.3) </td>
</tr>
<tr>
 <td style="text-align: left;">
   mtry </td><td style="text-align: left;"> colsample_bynode (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
   min_n </td><td style="text-align: left;"> min_child_weight (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
   loss_reduction </td><td style="text-align: left;"> gamma (0) </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_size </td><td style="text-align: left;"> subsample (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
   stop_iter </td><td style="text-align: left;"> early_stop </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other options can be set using <code>set_engine()</code>.
</p>
<p><strong>auto_arima_xgboost (default engine)</strong>
</p>
<p>Model 1: Auto ARIMA (<code>forecast::auto.arima</code>):
</p>
<div class="sourceCode"><pre>#&gt; function (y, d = NA, D = NA, max.p = 5, max.q = 5, max.P = 2, max.Q = 2, 
#&gt;     max.order = 5, max.d = 2, max.D = 1, start.p = 2, start.q = 2, start.P = 1, 
#&gt;     start.Q = 1, stationary = FALSE, seasonal = TRUE, ic = c("aicc", "aic", 
#&gt;         "bic"), stepwise = TRUE, nmodels = 94, trace = FALSE, approximation = (length(x) &gt; 
#&gt;         150 | frequency(x) &gt; 12), method = NULL, truncate = NULL, xreg = NULL, 
#&gt;     test = c("kpss", "adf", "pp"), test.args = list(), seasonal.test = c("seas", 
#&gt;         "ocsb", "hegy", "ch"), seasonal.test.args = list(), allowdrift = TRUE, 
#&gt;     allowmean = TRUE, lambda = NULL, biasadj = FALSE, parallel = FALSE, 
#&gt;     num.cores = 2, x = y, ...)
</pre></div>
<p>Parameter Notes:
</p>

<ul>
<li><p> All values of nonseasonal pdq and seasonal PDQ are maximums.
The <code>auto.arima</code> will select a value using these as an upper limit.
</p>
</li>
<li> <p><code>xreg</code> - This should not be used since XGBoost will be doing the regression
</p>
</li></ul>

<p>Model 2: XGBoost (<code>xgboost::xgb.train</code>):
</p>
<div class="sourceCode"><pre>#&gt; function (params = list(), data, nrounds, watchlist = list(), obj = NULL, 
#&gt;     feval = NULL, verbose = 1, print_every_n = 1L, early_stopping_rounds = NULL, 
#&gt;     maximize = NULL, save_period = NULL, save_name = "xgboost.model", xgb_model = NULL, 
#&gt;     callbacks = list(), ...)
</pre></div>
<p>Parameter Notes:
</p>

<ul>
<li><p> XGBoost uses a <code>params = list()</code> to capture.
Parsnip / Modeltime automatically sends any args provided as <code>...</code> inside of <code>set_engine()</code> to
the <code>params = list(...)</code>.
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><em>Seasonal Period Specification</em>
</p>
<p>The period can be non-seasonal (<code>seasonal_period = 1</code>) or seasonal (e.g. <code>seasonal_period = 12</code> or <code>seasonal_period = "12 months"</code>).
There are 3 ways to specify:
</p>

<ol>
<li> <p><code>seasonal_period = "auto"</code>: A period is selected based on the periodicity of the data (e.g. 12 if monthly)
</p>
</li>
<li> <p><code>seasonal_period = 12</code>: A numeric frequency. For example, 12 is common for monthly data
</p>
</li>
<li> <p><code>seasonal_period = "1 year"</code>: A time-based phrase. For example, &quot;1 year&quot; would convert to 12 for monthly data.
</p>
</li></ol>

<p><strong>Univariate (No xregs, Exogenous Regressors):</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li><p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (xregs, Exogenous Regressors)</strong>
</p>
<p>The <code>xreg</code> parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>

<ul>
<li><p> Only <code>factor</code>, <code style="white-space: pre;">&#8288;ordered factor&#8288;</code>, and <code>numeric</code> data will be used as xregs.
</p>
</li>
<li><p> Date and Date-time variables are not used as xregs
</p>
</li>
<li> <p><code>character</code> data should be converted to factor.
</p>
</li></ul>

<p><em>Xreg Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>month.lbl</code> (labeled month as a ordered factor).
</p>
</li></ol>

<p>The <code>month.lbl</code> is an exogenous regressor that can be passed to the <code>arima_boost()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>fit(y ~ date + month.lbl)</code> will pass <code>month.lbl</code> on as an exogenous regressor.
</p>
</li>
<li> <p><code>fit_xy(data[,c("date", "month.lbl")], y = data$y)</code> will pass x, where x is a data frame containing <code>month.lbl</code>
and the <code>date</code> feature. Only <code>month.lbl</code> will be used as an exogenous regressor.
</p>
</li></ul>

<p>Note that date or date-time class values are excluded from <code>xreg</code>.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)


# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# MODEL SPEC ----

# Set engine and boosting parameters
model_spec &lt;- arima_boost(

    # ARIMA args
    seasonal_period = 12,
    non_seasonal_ar = 0,
    non_seasonal_differences = 1,
    non_seasonal_ma = 1,
    seasonal_ar     = 0,
    seasonal_differences = 1,
    seasonal_ma     = 1,

    # XGBoost Args
    tree_depth = 6,
    learn_rate = 0.1
) %&gt;%
    set_engine(engine = "arima_xgboost")

# FIT ----


# Boosting - Happens by adding numeric date and month features
model_fit_boosted &lt;- model_spec %&gt;%
    fit(value ~ date + as.numeric(date) + month(date, label = TRUE),
        data = training(splits))

model_fit_boosted



</code></pre>

<hr>
<h2 id='Arima_fit_impl'>Low-Level ARIMA function for translating modeltime to forecast</h2><span id='topic+Arima_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level ARIMA function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Arima_fit_impl(
  x,
  y,
  period = "auto",
  p = 0,
  d = 0,
  q = 0,
  P = 0,
  D = 0,
  Q = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arima_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_p">p</code></td>
<td>
<p>The order of the non-seasonal auto-regressive (AR) terms. Often denoted &quot;p&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_d">d</code></td>
<td>
<p>The order of integration for non-seasonal differencing. Often denoted &quot;d&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_q">q</code></td>
<td>
<p>The order of the non-seasonal moving average (MA) terms. Often denoted &quot;q&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_p">P</code></td>
<td>
<p>The order of the seasonal auto-regressive (SAR) terms. Often denoted &quot;P&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_d">D</code></td>
<td>
<p>The order of integration for seasonal differencing. Often denoted &quot;D&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_q">Q</code></td>
<td>
<p>The order of the seasonal moving average (SMA) terms. Often denoted &quot;Q&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="Arima_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::Arima</code></p>
</td></tr>
</table>

<hr>
<h2 id='arima_params'>Tuning Parameters for ARIMA Models</h2><span id='topic+arima_params'></span><span id='topic+non_seasonal_ar'></span><span id='topic+non_seasonal_differences'></span><span id='topic+non_seasonal_ma'></span><span id='topic+seasonal_ar'></span><span id='topic+seasonal_differences'></span><span id='topic+seasonal_ma'></span>

<h3>Description</h3>

<p>Tuning Parameters for ARIMA Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>non_seasonal_ar(range = c(0L, 5L), trans = NULL)

non_seasonal_differences(range = c(0L, 2L), trans = NULL)

non_seasonal_ma(range = c(0L, 5L), trans = NULL)

seasonal_ar(range = c(0L, 2L), trans = NULL)

seasonal_differences(range = c(0L, 1L), trans = NULL)

seasonal_ma(range = c(0L, 2L), trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arima_params_+3A_range">range</code></td>
<td>
<p>A two-element vector holding the <em>defaults</em> for the smallest and
largest possible values, respectively. If a transformation is specified,
these values should be in the <em>transformed units</em>.</p>
</td></tr>
<tr><td><code id="arima_params_+3A_trans">trans</code></td>
<td>
<p>A <code>trans</code> object from the <code>scales</code> package, such as
<code>scales::log10_trans()</code> or <code>scales::reciprocal_trans()</code>. If not provided,
the default is used which matches the units used in <code>range</code>. If no
transformation, <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main parameters for ARIMA models are:
</p>

<ul>
<li> <p><code>non_seasonal_ar</code>: The order of the non-seasonal auto-regressive (AR) terms.
</p>
</li>
<li> <p><code>non_seasonal_differences</code>: The order of integration for non-seasonal differencing.
</p>
</li>
<li> <p><code>non_seasonal_ma</code>: The order of the non-seasonal moving average (MA) terms.
</p>
</li>
<li> <p><code>seasonal_ar</code>: The order of the seasonal auto-regressive (SAR) terms.
</p>
</li>
<li> <p><code>seasonal_differences</code>: The order of integration for seasonal differencing.
</p>
</li>
<li> <p><code>seasonal_ma</code>: The order of the seasonal moving average (SMA) terms.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>non_seasonal_ar()

non_seasonal_differences()

non_seasonal_ma()


</code></pre>

<hr>
<h2 id='Arima_predict_impl'>Bridge prediction function for ARIMA models</h2><span id='topic+Arima_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for ARIMA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Arima_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arima_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="Arima_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="Arima_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::Arima()</code></p>
</td></tr>
</table>

<hr>
<h2 id='arima_reg'>General Interface for ARIMA Regression Models</h2><span id='topic+arima_reg'></span>

<h3>Description</h3>

<p><code>arima_reg()</code> is a way to generate a <em>specification</em> of an ARIMA model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>forecast</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arima_reg(
  mode = "regression",
  seasonal_period = NULL,
  non_seasonal_ar = NULL,
  non_seasonal_differences = NULL,
  non_seasonal_ma = NULL,
  seasonal_ar = NULL,
  seasonal_differences = NULL,
  seasonal_ma = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arima_reg_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="arima_reg_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
<tr><td><code id="arima_reg_+3A_non_seasonal_ar">non_seasonal_ar</code></td>
<td>
<p>The order of the non-seasonal auto-regressive (AR) terms. Often denoted &quot;p&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="arima_reg_+3A_non_seasonal_differences">non_seasonal_differences</code></td>
<td>
<p>The order of integration for non-seasonal differencing. Often denoted &quot;d&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="arima_reg_+3A_non_seasonal_ma">non_seasonal_ma</code></td>
<td>
<p>The order of the non-seasonal moving average (MA) terms. Often denoted &quot;q&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="arima_reg_+3A_seasonal_ar">seasonal_ar</code></td>
<td>
<p>The order of the seasonal auto-regressive (SAR) terms. Often denoted &quot;P&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="arima_reg_+3A_seasonal_differences">seasonal_differences</code></td>
<td>
<p>The order of integration for seasonal differencing. Often denoted &quot;D&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="arima_reg_+3A_seasonal_ma">seasonal_ma</code></td>
<td>
<p>The order of the seasonal moving average (SMA) terms. Often denoted &quot;Q&quot; in PDQ-notation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>arima_reg()</code>, the
mode will always be &quot;regression&quot;.
</p>
<p>The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li><p> &quot;auto_arima&quot; (default) - Connects to <code><a href="forecast.html#topic+auto.arima">forecast::auto.arima()</a></code>
</p>
</li>
<li><p> &quot;arima&quot; - Connects to <code><a href="forecast.html#topic+Arima">forecast::Arima()</a></code>
</p>
</li></ul>

<p><strong>Main Arguments</strong>
</p>
<p>The main arguments (tuning parameters) for the model are:
</p>

<ul>
<li> <p><code>seasonal_period</code>: The periodic nature of the seasonality. Uses &quot;auto&quot; by default.
</p>
</li>
<li> <p><code>non_seasonal_ar</code>: The order of the non-seasonal auto-regressive (AR) terms.
</p>
</li>
<li> <p><code>non_seasonal_differences</code>: The order of integration for non-seasonal differencing.
</p>
</li>
<li> <p><code>non_seasonal_ma</code>: The order of the non-seasonal moving average (MA) terms.
</p>
</li>
<li> <p><code>seasonal_ar</code>: The order of the seasonal auto-regressive (SAR) terms.
</p>
</li>
<li> <p><code>seasonal_differences</code>: The order of integration for seasonal differencing.
</p>
</li>
<li> <p><code>seasonal_ma</code>: The order of the seasonal moving average (SMA) terms.
</p>
</li></ul>

<p>These arguments are converted to their specific names at the
time that the model is fit.
</p>
<p>Other options and argument can be
set using <code>set_engine()</code> (See Engine Details below).
</p>
<p>If parameters need to be modified, <code>update()</code> can be used
in lieu of recreating the object from scratch.
</p>


<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> forecast::auto.arima </td><td style="text-align: left;"> forecast::Arima </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonal_period </td><td style="text-align: left;"> ts(frequency) </td><td style="text-align: left;"> ts(frequency) </td>
</tr>
<tr>
 <td style="text-align: left;">
   non_seasonal_ar, non_seasonal_differences, non_seasonal_ma </td><td style="text-align: left;"> max.p(5), max.d(2), max.q(5) </td><td style="text-align: left;"> order = c(p(0), d(0), q(0)) </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonal_ar, seasonal_differences, seasonal_ma </td><td style="text-align: left;"> max.P(2), max.D(1), max.Q(2) </td><td style="text-align: left;"> seasonal = c(P(0), D(0), Q(0)) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other options can be set using <code>set_engine()</code>.
</p>
<p><strong>auto_arima (default engine)</strong>
</p>
<p>The engine uses <code><a href="forecast.html#topic+auto.arima">forecast::auto.arima()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, d = NA, D = NA, max.p = 5, max.q = 5, max.P = 2, max.Q = 2, 
#&gt;     max.order = 5, max.d = 2, max.D = 1, start.p = 2, start.q = 2, start.P = 1, 
#&gt;     start.Q = 1, stationary = FALSE, seasonal = TRUE, ic = c("aicc", "aic", 
#&gt;         "bic"), stepwise = TRUE, nmodels = 94, trace = FALSE, approximation = (length(x) &gt; 
#&gt;         150 | frequency(x) &gt; 12), method = NULL, truncate = NULL, xreg = NULL, 
#&gt;     test = c("kpss", "adf", "pp"), test.args = list(), seasonal.test = c("seas", 
#&gt;         "ocsb", "hegy", "ch"), seasonal.test.args = list(), allowdrift = TRUE, 
#&gt;     allowmean = TRUE, lambda = NULL, biasadj = FALSE, parallel = FALSE, 
#&gt;     num.cores = 2, x = y, ...)
</pre></div>
<p>The <em>MAXIMUM</em> nonseasonal ARIMA terms (<code>max.p</code>, <code>max.d</code>, <code>max.q</code>) and
seasonal ARIMA terms (<code>max.P</code>, <code>max.D</code>, <code>max.Q</code>) are provided to
<code><a href="forecast.html#topic+auto.arima">forecast::auto.arima()</a></code> via <code>arima_reg()</code> parameters.
Other options and argument can be set using <code>set_engine()</code>.
</p>
<p>Parameter Notes:
</p>

<ul>
<li><p> All values of nonseasonal pdq and seasonal PDQ are maximums.
The <code>forecast::auto.arima()</code> model will select a value using these as an upper limit.
</p>
</li>
<li> <p><code>xreg</code> - This is supplied via the parsnip / modeltime <code>fit()</code> interface
(so don't provide this manually). See Fit Details (below).
</p>
</li></ul>

<p><strong>arima</strong>
</p>
<p>The engine uses <code><a href="forecast.html#topic+Arima">forecast::Arima()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, order = c(0, 0, 0), seasonal = c(0, 0, 0), xreg = NULL, include.mean = TRUE, 
#&gt;     include.drift = FALSE, include.constant, lambda = model$lambda, biasadj = FALSE, 
#&gt;     method = c("CSS-ML", "ML", "CSS"), model = NULL, x = y, ...)
</pre></div>
<p>The nonseasonal ARIMA terms (<code>order</code>) and seasonal ARIMA terms (<code>seasonal</code>)
are provided to <code><a href="forecast.html#topic+Arima">forecast::Arima()</a></code> via <code>arima_reg()</code> parameters.
Other options and argument can be set using <code>set_engine()</code>.
</p>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>xreg</code> - This is supplied via the parsnip / modeltime <code>fit()</code> interface
(so don't provide this manually). See Fit Details (below).
</p>
</li>
<li> <p><code>method</code> - The default is set to &quot;ML&quot; (Maximum Likelihood).
This method is more robust at the expense of speed and possible
selections may fail unit root inversion testing. Alternatively, you can add <code>method = "CSS-ML"</code> to
evaluate Conditional Sum of Squares for starting values, then Maximium Likelihood.
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><em>Seasonal Period Specification</em>
</p>
<p>The period can be non-seasonal (<code style="white-space: pre;">&#8288;seasonal_period = 1 or "none"&#8288;</code>) or
yearly seasonal (e.g. For monthly time stamps, <code>seasonal_period = 12</code>, <code>seasonal_period = "12 months"</code>, or <code>seasonal_period = "yearly"</code>).
There are 3 ways to specify:
</p>

<ol>
<li> <p><code>seasonal_period = "auto"</code>: A seasonal period is selected based on the periodicity of the data (e.g. 12 if monthly)
</p>
</li>
<li> <p><code>seasonal_period = 12</code>: A numeric frequency. For example, 12 is common for monthly data
</p>
</li>
<li> <p><code>seasonal_period = "1 year"</code>: A time-based phrase. For example, &quot;1 year&quot; would convert to 12 for monthly data.
</p>
</li></ol>

<p><strong>Univariate (No xregs, Exogenous Regressors):</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li><p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (xregs, Exogenous Regressors)</strong>
</p>
<p>The <code>xreg</code> parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>

<ul>
<li><p> Only <code>factor</code>, <code style="white-space: pre;">&#8288;ordered factor&#8288;</code>, and <code>numeric</code> data will be used as xregs.
</p>
</li>
<li><p> Date and Date-time variables are not used as xregs
</p>
</li>
<li> <p><code>character</code> data should be converted to factor.
</p>
</li></ul>

<p><em>Xreg Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>month.lbl</code> (labeled month as a ordered factor).
</p>
</li></ol>

<p>The <code>month.lbl</code> is an exogenous regressor that can be passed to the <code>arima_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>fit(y ~ date + month.lbl)</code> will pass <code>month.lbl</code> on as an exogenous regressor.
</p>
</li>
<li> <p><code>fit_xy(data[,c("date", "month.lbl")], y = data$y)</code> will pass x, where x is a data frame containing <code>month.lbl</code>
and the <code>date</code> feature. Only <code>month.lbl</code> will be used as an exogenous regressor.
</p>
</li></ul>

<p>Note that date or date-time class values are excluded from <code>xreg</code>.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- AUTO ARIMA ----

# Model Spec
model_spec &lt;- arima_reg() %&gt;%
    set_engine("auto_arima")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit


# ---- STANDARD ARIMA ----

# Model Spec
model_spec &lt;- arima_reg(
        seasonal_period          = 12,
        non_seasonal_ar          = 3,
        non_seasonal_differences = 1,
        non_seasonal_ma          = 3,
        seasonal_ar              = 1,
        seasonal_differences     = 0,
        seasonal_ma              = 1
    ) %&gt;%
    set_engine("arima")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit

</code></pre>

<hr>
<h2 id='arima_xgboost_fit_impl'>Bridge ARIMA-XGBoost Modeling function</h2><span id='topic+arima_xgboost_fit_impl'></span>

<h3>Description</h3>

<p>Bridge ARIMA-XGBoost Modeling function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arima_xgboost_fit_impl(
  x,
  y,
  period = "auto",
  p = 0,
  d = 0,
  q = 0,
  P = 0,
  D = 0,
  Q = 0,
  include.mean = TRUE,
  include.drift = FALSE,
  include.constant,
  lambda = model$lambda,
  biasadj = FALSE,
  method = c("CSS-ML", "ML", "CSS"),
  model = NULL,
  max_depth = 6,
  nrounds = 15,
  eta = 0.3,
  colsample_bytree = NULL,
  colsample_bynode = NULL,
  min_child_weight = 1,
  gamma = 0,
  subsample = 1,
  validation = 0,
  early_stop = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arima_xgboost_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_p">p</code></td>
<td>
<p>The order of the non-seasonal auto-regressive (AR) terms.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_d">d</code></td>
<td>
<p>The order of integration for non-seasonal differencing.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_q">q</code></td>
<td>
<p>The order of the non-seasonal moving average (MA) terms.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_p">P</code></td>
<td>
<p>The order of the seasonal auto-regressive (SAR) terms.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_d">D</code></td>
<td>
<p>The order of integration for seasonal differencing.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_q">Q</code></td>
<td>
<p>The order of the seasonal moving average (SMA) terms.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_include.mean">include.mean</code></td>
<td>
<p>Should the ARIMA model include a mean term? The default
is <code>TRUE</code> for undifferenced series, <code>FALSE</code> for differenced ones
(where a mean would not affect the fit nor predictions).</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_include.drift">include.drift</code></td>
<td>
<p>Should the ARIMA model include a linear drift term?
(i.e., a linear regression with ARIMA errors is fitted.)  The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_include.constant">include.constant</code></td>
<td>
<p>If <code>TRUE</code>, then <code>include.mean</code> is set to
be <code>TRUE</code> for undifferenced series and <code>include.drift</code> is set to
be <code>TRUE</code> for differenced series. Note that if there is more than one
difference taken, no constant is included regardless of the value of this
argument. This is deliberate as otherwise quadratic and higher order
polynomial trends would be induced.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_method">method</code></td>
<td>
<p>Fitting method: maximum likelihood or minimize conditional
sum-of-squares. The default (unless there are missing values) is to use
conditional-sum-of-squares to find starting values, then maximum likelihood.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_model">model</code></td>
<td>
<p>Output from a previous call to <code>Arima</code>. If model is
passed, this same model is fitted to <code>y</code> without re-estimating any
parameters.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_max_depth">max_depth</code></td>
<td>
<p>An integer for the maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_nrounds">nrounds</code></td>
<td>
<p>An integer for the number of boosting iterations.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_eta">eta</code></td>
<td>
<p>A numeric value between zero and one to control the learning rate.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsampling proportion of columns.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_colsample_bynode">colsample_bynode</code></td>
<td>
<p>Subsampling proportion of columns for each node
within each tree. See the <code>counts</code> argument below. The default uses all
columns.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_min_child_weight">min_child_weight</code></td>
<td>
<p>A numeric value for the minimum sum of instance
weights needed in a child to continue to split.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_gamma">gamma</code></td>
<td>
<p>A number for the minimum loss reduction required to make a
further partition on a leaf node of the tree</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_subsample">subsample</code></td>
<td>
<p>Subsampling proportion of rows.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_validation">validation</code></td>
<td>
<p>A positive number. If on <code style="white-space: pre;">&#8288;[0, 1)&#8288;</code> the value, <code>validation</code>
is a random proportion of data in <code>x</code> and <code>y</code> that are used for performance
assessment and potential early stopping. If 1 or greater, it is the <em>number</em>
of training set samples use for these purposes.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_early_stop">early_stop</code></td>
<td>
<p>An integer or <code>NULL</code>. If not <code>NULL</code>, it is the number of
training iterations without improvement before stopping. If <code>validation</code> is
used, performance is base on the validation set; otherwise the training set
is used.</p>
</td></tr>
<tr><td><code id="arima_xgboost_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>xgboost::xgb.train</code></p>
</td></tr>
</table>

<hr>
<h2 id='arima_xgboost_predict_impl'>Bridge prediction Function for ARIMA-XGBoost Models</h2><span id='topic+arima_xgboost_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction Function for ARIMA-XGBoost Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arima_xgboost_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arima_xgboost_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="arima_xgboost_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="arima_xgboost_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>predict.xgb.Booster()</code></p>
</td></tr>
</table>

<hr>
<h2 id='auto_adam_fit_impl'>Low-Level ADAM function for translating modeltime to forecast</h2><span id='topic+auto_adam_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level ADAM function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_adam_fit_impl(
  x,
  y,
  period = "auto",
  p = 0,
  d = 0,
  q = 0,
  P = 0,
  D = 0,
  Q = 0,
  model = "ZXZ",
  constant = FALSE,
  regressors = c("use", "select", "adapt"),
  outliers = c("ignore", "use", "select"),
  level = 0.99,
  occurrence = c("none", "auto", "fixed", "general", "odds-ratio", "inverse-odds-ratio",
    "direct"),
  distribution = c("default", "dnorm", "dlaplace", "ds", "dgnorm", "dlnorm", "dinvgauss",
    "dgamma"),
  loss = c("likelihood", "MSE", "MAE", "HAM", "LASSO", "RIDGE", "MSEh", "TMSE", "GTMSE",
    "MSCE"),
  ic = c("AICc", "AIC", "BIC", "BICc"),
  select_order = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_adam_fit_impl_+3A_x">x</code></td>
<td>
<p>A data.frame of predictors</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_y">y</code></td>
<td>
<p>A vector with outcome</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_p">p</code></td>
<td>
<p>The order of the non-seasonal auto-regressive (AR) terms. Often denoted &quot;p&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_d">d</code></td>
<td>
<p>The order of integration for non-seasonal differencing. Often denoted &quot;d&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_q">q</code></td>
<td>
<p>The order of the non-seasonal moving average (MA) terms. Often denoted &quot;q&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_p">P</code></td>
<td>
<p>The order of the seasonal auto-regressive (SAR) terms. Often denoted &quot;P&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_d">D</code></td>
<td>
<p>The order of integration for seasonal differencing. Often denoted &quot;D&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_q">Q</code></td>
<td>
<p>The order of the seasonal moving average (SMA) terms. Often denoted &quot;Q&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_model">model</code></td>
<td>
<p>The type of ETS model.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_constant">constant</code></td>
<td>
<p>Logical, determining, whether the constant is needed in the model or not.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided explanatory variables.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_outliers">outliers</code></td>
<td>
<p>Defines what to do with outliers.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_level">level</code></td>
<td>
<p>What confidence level to use for detection of outliers.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_occurrence">occurrence</code></td>
<td>
<p>The type of model used in probability estimation.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_distribution">distribution</code></td>
<td>
<p>what density function to assume for the error term.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_ic">ic</code></td>
<td>
<p>The information criterion to use in the model selection / combination procedure.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_select_order">select_order</code></td>
<td>
<p>If TRUE, then the function will select the most appropriate order using
a mechanism similar to auto.msarima(), but implemented in auto.adam(). The values list(ar=...,i=...,ma=...)
specify the maximum orders to check in this case.</p>
</td></tr>
<tr><td><code id="auto_adam_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>smooth::auto.adam</code></p>
</td></tr>
</table>

<hr>
<h2 id='Auto_adam_predict_impl'>Bridge prediction function for AUTO ADAM models</h2><span id='topic+Auto_adam_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for AUTO ADAM models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Auto_adam_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Auto_adam_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="Auto_adam_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="Auto_adam_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>smooth::auto.adam()</code></p>
</td></tr>
</table>

<hr>
<h2 id='auto_arima_fit_impl'>Low-Level ARIMA function for translating modeltime to forecast</h2><span id='topic+auto_arima_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level ARIMA function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_arima_fit_impl(
  x,
  y,
  period = "auto",
  max.p = 5,
  max.d = 2,
  max.q = 5,
  max.P = 2,
  max.D = 1,
  max.Q = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_arima_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_max.p">max.p</code></td>
<td>
<p>The maximum order of the non-seasonal auto-regressive (AR) terms.</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_max.d">max.d</code></td>
<td>
<p>The maximum order of integration for non-seasonal differencing.</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_max.q">max.q</code></td>
<td>
<p>The maximum order of the non-seasonal moving average (MA) terms.</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_max.p">max.P</code></td>
<td>
<p>The maximum order of the seasonal auto-regressive (SAR) terms.</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_max.d">max.D</code></td>
<td>
<p>The maximum order of integration for seasonal differencing.</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_max.q">max.Q</code></td>
<td>
<p>The maximum order of the seasonal moving average (SMA) terms.</p>
</td></tr>
<tr><td><code id="auto_arima_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::auto.arima</code></p>
</td></tr>
</table>

<hr>
<h2 id='auto_arima_xgboost_fit_impl'>Bridge ARIMA-XGBoost Modeling function</h2><span id='topic+auto_arima_xgboost_fit_impl'></span>

<h3>Description</h3>

<p>Bridge ARIMA-XGBoost Modeling function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_arima_xgboost_fit_impl(
  x,
  y,
  period = "auto",
  max.p = 5,
  max.d = 2,
  max.q = 5,
  max.P = 2,
  max.D = 1,
  max.Q = 2,
  max.order = 5,
  d = NA,
  D = NA,
  start.p = 2,
  start.q = 2,
  start.P = 1,
  start.Q = 1,
  stationary = FALSE,
  seasonal = TRUE,
  ic = c("aicc", "aic", "bic"),
  stepwise = TRUE,
  nmodels = 94,
  trace = FALSE,
  approximation = (length(x) &gt; 150 | frequency(x) &gt; 12),
  method = NULL,
  truncate = NULL,
  test = c("kpss", "adf", "pp"),
  test.args = list(),
  seasonal.test = c("seas", "ocsb", "hegy", "ch"),
  seasonal.test.args = list(),
  allowdrift = TRUE,
  allowmean = TRUE,
  lambda = NULL,
  biasadj = FALSE,
  max_depth = 6,
  nrounds = 15,
  eta = 0.3,
  colsample_bytree = NULL,
  colsample_bynode = NULL,
  min_child_weight = 1,
  gamma = 0,
  subsample = 1,
  validation = 0,
  early_stop = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_max.p">max.p</code></td>
<td>
<p>The maximum order of the non-seasonal auto-regressive (AR) terms.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_max.d">max.d</code></td>
<td>
<p>The maximum order of integration for non-seasonal differencing.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_max.q">max.q</code></td>
<td>
<p>The maximum order of the non-seasonal moving average (MA) terms.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_max.p">max.P</code></td>
<td>
<p>The maximum order of the seasonal auto-regressive (SAR) terms.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_max.d">max.D</code></td>
<td>
<p>The maximum order of integration for seasonal differencing.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_max.q">max.Q</code></td>
<td>
<p>The maximum order of the seasonal moving average (SMA) terms.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_max.order">max.order</code></td>
<td>
<p>Maximum value of p+q+P+Q if model selection is not
stepwise.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_d">d</code></td>
<td>
<p>Order of first-differencing. If missing, will choose a value based
on <code>test</code>.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_d">D</code></td>
<td>
<p>Order of seasonal-differencing. If missing, will choose a value
based on <code>season.test</code>.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_start.p">start.p</code></td>
<td>
<p>Starting value of p in stepwise procedure.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_start.q">start.q</code></td>
<td>
<p>Starting value of q in stepwise procedure.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_start.p">start.P</code></td>
<td>
<p>Starting value of P in stepwise procedure.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_start.q">start.Q</code></td>
<td>
<p>Starting value of Q in stepwise procedure.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_stationary">stationary</code></td>
<td>
<p>If <code>TRUE</code>, restricts search to stationary models.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_seasonal">seasonal</code></td>
<td>
<p>If <code>FALSE</code>, restricts search to non-seasonal models.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_ic">ic</code></td>
<td>
<p>Information criterion to be used in model selection.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_stepwise">stepwise</code></td>
<td>
<p>If <code>TRUE</code>, will do stepwise selection (faster).
Otherwise, it searches over all models. Non-stepwise selection can be very
slow, especially for seasonal models.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_nmodels">nmodels</code></td>
<td>
<p>Maximum number of models considered in the stepwise search.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, the list of ARIMA models considered will be
reported.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_approximation">approximation</code></td>
<td>
<p>If <code>TRUE</code>, estimation is via conditional sums of
squares and the information criteria used for model selection are
approximated. The final model is still computed using maximum likelihood
estimation. Approximation should be used for long time series or a high
seasonal period to avoid excessive computation times.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_method">method</code></td>
<td>
<p>fitting method: maximum likelihood or minimize
conditional sum-of-squares.  The default (unless there are missing
values) is to use conditional-sum-of-squares to find starting
values, then maximum likelihood.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_truncate">truncate</code></td>
<td>
<p>An integer value indicating how many observations to use in
model selection. The last <code>truncate</code> values of the series are used to
select a model when <code>truncate</code> is not <code>NULL</code> and
<code>approximation=TRUE</code>. All observations are used if either
<code>truncate=NULL</code> or <code>approximation=FALSE</code>.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_test">test</code></td>
<td>
<p>Type of unit root test to use. See <code><a href="forecast.html#topic+ndiffs">ndiffs</a></code> for
details.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_test.args">test.args</code></td>
<td>
<p>Additional arguments to be passed to the unit root test.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_seasonal.test">seasonal.test</code></td>
<td>
<p>This determines which method is used to select the number of seasonal differences.
The default method is to use a measure of seasonal strength computed from an STL decomposition.
Other possibilities involve seasonal unit root tests.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_seasonal.test.args">seasonal.test.args</code></td>
<td>
<p>Additional arguments to be passed to the seasonal
unit root test.
See <code><a href="forecast.html#topic+nsdiffs">nsdiffs</a></code> for details.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_allowdrift">allowdrift</code></td>
<td>
<p>If <code>TRUE</code>, models with drift terms are considered.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_allowmean">allowmean</code></td>
<td>
<p>If <code>TRUE</code>, models with a non-zero mean are considered.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_max_depth">max_depth</code></td>
<td>
<p>An integer for the maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_nrounds">nrounds</code></td>
<td>
<p>An integer for the number of boosting iterations.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_eta">eta</code></td>
<td>
<p>A numeric value between zero and one to control the learning rate.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsampling proportion of columns.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_colsample_bynode">colsample_bynode</code></td>
<td>
<p>Subsampling proportion of columns for each node
within each tree. See the <code>counts</code> argument below. The default uses all
columns.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_min_child_weight">min_child_weight</code></td>
<td>
<p>A numeric value for the minimum sum of instance
weights needed in a child to continue to split.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_gamma">gamma</code></td>
<td>
<p>A number for the minimum loss reduction required to make a
further partition on a leaf node of the tree</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_subsample">subsample</code></td>
<td>
<p>Subsampling proportion of rows.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_validation">validation</code></td>
<td>
<p>A positive number. If on <code style="white-space: pre;">&#8288;[0, 1)&#8288;</code> the value, <code>validation</code>
is a random proportion of data in <code>x</code> and <code>y</code> that are used for performance
assessment and potential early stopping. If 1 or greater, it is the <em>number</em>
of training set samples use for these purposes.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_early_stop">early_stop</code></td>
<td>
<p>An integer or <code>NULL</code>. If not <code>NULL</code>, it is the number of
training iterations without improvement before stopping. If <code>validation</code> is
used, performance is base on the validation set; otherwise the training set
is used.</p>
</td></tr>
<tr><td><code id="auto_arima_xgboost_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>xgboost::xgb.train</code></p>
</td></tr>
</table>

<hr>
<h2 id='combine_modeltime_tables'>Combine multiple Modeltime Tables into a single Modeltime Table</h2><span id='topic+combine_modeltime_tables'></span>

<h3>Description</h3>

<p>Combine multiple Modeltime Tables into a single Modeltime Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_modeltime_tables(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_modeltime_tables_+3A_...">...</code></td>
<td>
<p>Multiple Modeltime Tables (class <code>mdl_time_tbl</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines multiple Modeltime Tables.
</p>

<ul>
<li><p> The <code>.model_id</code> will automatically be renumbered to ensure
each model has a unique ID.
</p>
</li>
<li><p> Only the <code>.model_id</code>, <code>.model</code>, and <code>.model_desc</code> columns will be returned.
</p>
</li></ul>

<p><strong>Re-Training Models on the Same Datasets</strong>
</p>
<p>One issue can arise if your models are trained on different datasets.
If your models have been trained on different datasets, you can run
<code><a href="#topic+modeltime_refit">modeltime_refit()</a></code> to train all models on the same data.
</p>
<p><strong>Re-Calibrating Models</strong>
</p>
<p>If your data has been calibrated using <code><a href="#topic+modeltime_calibrate">modeltime_calibrate()</a></code>,
the <code>.test</code> and <code>.calibration_data</code> columns will be removed.
To re-calibrate, simply run <code><a href="#topic+modeltime_calibrate">modeltime_calibrate()</a></code> on the newly
combined Modeltime Table.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+combine_modeltime_tables">combine_modeltime_tables()</a></code>: Combine 2 or more Modeltime Tables together
</p>
</li>
<li> <p><code><a href="#topic+add_modeltime_model">add_modeltime_model()</a></code>: Adds a new row with a new model to a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+drop_modeltime_model">drop_modeltime_model()</a></code>: Drop one or more models from a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_description">update_modeltime_description()</a></code>: Updates a description for a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_model">update_modeltime_model()</a></code>: Updates a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+pull_modeltime_model">pull_modeltime_model()</a></code>: Extracts a model from a Modeltime Table
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(modeltime)
library(tidymodels)
library(tidyverse)
library(timetk)
library(lubridate)

# Setup
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

splits &lt;- time_series_split(m750, assess = "3 years", cumulative = TRUE)

model_fit_arima &lt;- arima_reg() %&gt;%
    set_engine("auto_arima") %&gt;%
    fit(value ~ date, training(splits))

model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine("prophet") %&gt;%
    fit(value ~ date, training(splits))

# Multiple Modeltime Tables
model_tbl_1 &lt;- modeltime_table(model_fit_arima)
model_tbl_2 &lt;- modeltime_table(model_fit_prophet)

# Combine
combine_modeltime_tables(model_tbl_1, model_tbl_2)

</code></pre>

<hr>
<h2 id='control_modeltime'>Control aspects of the training process</h2><span id='topic+control_modeltime'></span><span id='topic+control_refit'></span><span id='topic+control_fit_workflowset'></span><span id='topic+control_nested_fit'></span><span id='topic+control_nested_refit'></span><span id='topic+control_nested_forecast'></span>

<h3>Description</h3>

<p>These functions are matched to the associated
training functions:
</p>

<ul>
<li> <p><code>control_refit()</code>: Used with <code><a href="#topic+modeltime_refit">modeltime_refit()</a></code>
</p>
</li>
<li> <p><code>control_fit_workflowset()</code>: Used with <code><a href="#topic+modeltime_fit_workflowset">modeltime_fit_workflowset()</a></code>
</p>
</li>
<li> <p><code>control_nested_fit()</code>: Used with <code><a href="#topic+modeltime_nested_fit">modeltime_nested_fit()</a></code>
</p>
</li>
<li> <p><code>control_nested_refit()</code>: Used with <code><a href="#topic+modeltime_nested_refit">modeltime_nested_refit()</a></code>
</p>
</li>
<li> <p><code>control_nested_forecast()</code>: Used with <code><a href="#topic+modeltime_nested_forecast">modeltime_nested_forecast()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>control_refit(verbose = FALSE, allow_par = FALSE, cores = 1, packages = NULL)

control_fit_workflowset(
  verbose = FALSE,
  allow_par = FALSE,
  cores = 1,
  packages = NULL
)

control_nested_fit(
  verbose = FALSE,
  allow_par = FALSE,
  cores = 1,
  packages = NULL
)

control_nested_refit(
  verbose = FALSE,
  allow_par = FALSE,
  cores = 1,
  packages = NULL
)

control_nested_forecast(
  verbose = FALSE,
  allow_par = FALSE,
  cores = 1,
  packages = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_modeltime_+3A_verbose">verbose</code></td>
<td>
<p>Logical to control printing.</p>
</td></tr>
<tr><td><code id="control_modeltime_+3A_allow_par">allow_par</code></td>
<td>
<p>Logical to allow parallel computation. Default: <code>FALSE</code> (single threaded).</p>
</td></tr>
<tr><td><code id="control_modeltime_+3A_cores">cores</code></td>
<td>
<p>Number of cores for computation. If -1, uses all available physical cores.
Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="control_modeltime_+3A_packages">packages</code></td>
<td>
<p>An optional character string of additional R package names that should be loaded
during parallel processing.
</p>

<ul>
<li><p> Packages in your namespace are loaded by default
</p>
</li>
<li><p> Key Packages are loaded by default: <code>tidymodels</code>, <code>parsnip</code>, <code>modeltime</code>, <code>dplyr</code>, <code>stats</code>, <code>lubridate</code> and <code>timetk</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A List with the control settings.
</p>


<h3>See Also</h3>


<ul>
<li><p> Setting Up Parallel Processing: <code><a href="#topic+parallel_start">parallel_start()</a></code>, [parallel_stop())]
</p>
</li>
<li><p> Training Functions: [modeltime_refit()], [modeltime_fit_workflowset()], [modeltime_nested_fit()], [modeltime_nested_refit()]
</p>
</li></ul>

<p>[parallel_stop())]: R:parallel_stop())
[modeltime_refit()]: R:modeltime_refit()
[modeltime_fit_workflowset()]: R:modeltime_fit_workflowset()
[modeltime_nested_fit()]: R:modeltime_nested_fit()
[modeltime_nested_refit()]: R:modeltime_nested_refit()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# No parallel processing by default
control_refit()

# Allow parallel processing and use all cores
control_refit(allow_par = TRUE, cores = -1)

# Set verbosity to show additional training information
control_refit(verbose = TRUE)

# Add additional packages used during modeling in parallel processing
# - This is useful if your namespace does not load all needed packages
#   to run models.
# - An example is if I use `temporal_hierarchy()`, which depends on the `thief` package
control_refit(allow_par = TRUE, packages = "thief")

</code></pre>

<hr>
<h2 id='create_model_grid'>Helper to make <code>parsnip</code> model specs from a <code>dials</code> parameter grid</h2><span id='topic+create_model_grid'></span>

<h3>Description</h3>

<p>Helper to make <code>parsnip</code> model specs from a <code>dials</code> parameter grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model_grid(grid, f_model_spec, engine_name, ..., engine_params = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model_grid_+3A_grid">grid</code></td>
<td>
<p>A tibble that forms a grid of parameters to adjust</p>
</td></tr>
<tr><td><code id="create_model_grid_+3A_f_model_spec">f_model_spec</code></td>
<td>
<p>A function name (quoted or unquoted) that
specifies a <code>parsnip</code> model specification function</p>
</td></tr>
<tr><td><code id="create_model_grid_+3A_engine_name">engine_name</code></td>
<td>
<p>A name of an engine to use. Gets passed to <code>parsnip::set_engine()</code>.</p>
</td></tr>
<tr><td><code id="create_model_grid_+3A_...">...</code></td>
<td>
<p>Static parameters that get passed to the f_model_spec</p>
</td></tr>
<tr><td><code id="create_model_grid_+3A_engine_params">engine_params</code></td>
<td>
<p>A <code>list</code> of additional parameters that can be passed to the
engine via <code>parsnip::set_engine(...)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function that combines <code>dials</code> grids with
<code>parsnip</code> model specifications. The intent is to make it easier
to generate <code>workflowset</code> objects for forecast evaluations
with <code>modeltime_fit_workflowset()</code>.
</p>
<p>The process follows:
</p>

<ol>
<li><p> Generate a grid (hyperparemeter combination)
</p>
</li>
<li><p> Use <code>create_model_grid()</code> to apply the parameter combinations to
a parsnip model spec and engine.
</p>
</li></ol>

<p>The output contains &quot;.model&quot; column that can be used as a list
of models inside the <code>workflow_set()</code> function.
</p>


<h3>Value</h3>

<p>Tibble with a new colum named <code>.models</code>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="dials.html#topic+grid_regular">dials::grid_regular()</a></code>: For making parameter grids.
</p>
</li>
<li> <p><code><a href="workflowsets.html#topic+workflow_set">workflowsets::workflow_set()</a></code>: For creating a <code>workflowset</code> from the <code>.models</code> list stored in the &quot;.models&quot; column.
</p>
</li>
<li> <p><code><a href="#topic+modeltime_fit_workflowset">modeltime_fit_workflowset()</a></code>: For fitting a <code>workflowset</code> to forecast data.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tidymodels)
library(modeltime)

# Parameters that get optimized
grid_tbl &lt;- grid_regular(
    learn_rate(),
    levels = 3
)

# Generate model specs
grid_tbl %&gt;%
    create_model_grid(
        f_model_spec = boost_tree,
        engine_name  = "xgboost",
        # Static boost_tree() args
        mode = "regression",
        # Static set_engine() args
        engine_params = list(
            max_depth = 5
        )
    )

</code></pre>

<hr>
<h2 id='create_xreg_recipe'>Developer Tools for preparing XREGS (Regressors)</h2><span id='topic+create_xreg_recipe'></span>

<h3>Description</h3>

<p>These functions are designed to assist developers in extending the <code>modeltime</code>
package. <code>create_xregs_recipe()</code> makes it simple to automate conversion
of raw un-encoded features to machine-learning ready features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_xreg_recipe(
  data,
  prepare = TRUE,
  clean_names = TRUE,
  dummy_encode = TRUE,
  one_hot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_xreg_recipe_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="create_xreg_recipe_+3A_prepare">prepare</code></td>
<td>
<p>Whether or not to run <code>recipes::prep()</code> on the final recipe.
Default is to prepare. User can set this to FALSE to return an un prepared recipe.</p>
</td></tr>
<tr><td><code id="create_xreg_recipe_+3A_clean_names">clean_names</code></td>
<td>
<p>Uses <code>janitor::clean_names()</code> to process the names and improve robustness
to failure during dummy (one-hot) encoding step.</p>
</td></tr>
<tr><td><code id="create_xreg_recipe_+3A_dummy_encode">dummy_encode</code></td>
<td>
<p>Should <code>factors</code> (categorical data) be</p>
</td></tr>
<tr><td><code id="create_xreg_recipe_+3A_one_hot">one_hot</code></td>
<td>
<p>If <code>dummy_encode = TRUE</code>, should the encoding return
one column for each feature or one less column than each feature. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default recipe contains steps to:
</p>

<ol>
<li><p> Remove date features
</p>
</li>
<li><p> Clean the column names removing spaces and bad characters
</p>
</li>
<li><p> Convert ordered factors to regular factors
</p>
</li>
<li><p> Convert factors to dummy variables
</p>
</li>
<li><p> Remove any variables that have zero variance
</p>
</li></ol>



<h3>Value</h3>

<p>A <code>recipe</code> in either prepared or un-prepared format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timetk)
library(recipes)
library(lubridate)

predictors &lt;- m4_monthly %&gt;%
    filter(id == "M750") %&gt;%
    select(-value) %&gt;%
    mutate(month = month(date, label = TRUE))
predictors

# Create default recipe
xreg_recipe_spec &lt;- create_xreg_recipe(predictors, prepare = TRUE)

# Extracts the preprocessed training data from the recipe (used in your fit function)
juice_xreg_recipe(xreg_recipe_spec)

# Applies the prepared recipe to new data (used in your predict function)
bake_xreg_recipe(xreg_recipe_spec, new_data = predictors)

</code></pre>

<hr>
<h2 id='croston_fit_impl'>Low-Level Exponential Smoothing function for translating modeltime to forecast</h2><span id='topic+croston_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level Exponential Smoothing function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>croston_fit_impl(x, y, alpha = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="croston_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="croston_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="croston_fit_impl_+3A_alpha">alpha</code></td>
<td>
<p>Value of alpha. Default value is 0.1.</p>
</td></tr>
<tr><td><code id="croston_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::ets</code></p>
</td></tr>
</table>

<hr>
<h2 id='croston_predict_impl'>Bridge prediction function for CROSTON models</h2><span id='topic+croston_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for CROSTON models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>croston_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="croston_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="croston_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="croston_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::predict()</code></p>
</td></tr>
</table>

<hr>
<h2 id='drop_modeltime_model'>Drop a Model from a Modeltime Table</h2><span id='topic+drop_modeltime_model'></span>

<h3>Description</h3>

<p>Drop a Model from a Modeltime Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_modeltime_model(object, .model_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_modeltime_model_+3A_object">object</code></td>
<td>
<p>A Modeltime Table (class <code>mdl_time_tbl</code>)</p>
</td></tr>
<tr><td><code id="drop_modeltime_model_+3A_.model_id">.model_id</code></td>
<td>
<p>A numeric value matching the .model_id that you want to drop</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+combine_modeltime_tables">combine_modeltime_tables()</a></code>: Combine 2 or more Modeltime Tables together
</p>
</li>
<li> <p><code><a href="#topic+add_modeltime_model">add_modeltime_model()</a></code>: Adds a new row with a new model to a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+drop_modeltime_model">drop_modeltime_model()</a></code>: Drop one or more models from a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_description">update_modeltime_description()</a></code>: Updates a description for a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_model">update_modeltime_model()</a></code>: Updates a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+pull_modeltime_model">pull_modeltime_model()</a></code>: Extracts a model from a Modeltime Table
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tidymodels)


m750_models %&gt;%
    drop_modeltime_model(.model_id = c(2,3))


</code></pre>

<hr>
<h2 id='ets_fit_impl'>Low-Level Exponential Smoothing function for translating modeltime to forecast</h2><span id='topic+ets_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level Exponential Smoothing function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ets_fit_impl(
  x,
  y,
  period = "auto",
  error = "auto",
  trend = "auto",
  season = "auto",
  damping = "auto",
  alpha = NULL,
  beta = NULL,
  gamma = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ets_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_error">error</code></td>
<td>
<p>The form of the error term: &quot;auto&quot;, &quot;additive&quot;, or &quot;multiplicative&quot;.
If the error is multiplicative, the data must be non-negative.</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_trend">trend</code></td>
<td>
<p>The form of the trend term: &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_season">season</code></td>
<td>
<p>The form of the seasonal term: &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_damping">damping</code></td>
<td>
<p>Apply damping to a trend: &quot;auto&quot;, &quot;damped&quot;, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_alpha">alpha</code></td>
<td>
<p>Value of alpha. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_beta">beta</code></td>
<td>
<p>Value of beta. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_gamma">gamma</code></td>
<td>
<p>Value of gamma. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="ets_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::ets</code></p>
</td></tr>
</table>

<hr>
<h2 id='ets_predict_impl'>Bridge prediction function for Exponential Smoothing models</h2><span id='topic+ets_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for Exponential Smoothing models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ets_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ets_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="ets_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="ets_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::ets()</code></p>
</td></tr>
</table>

<hr>
<h2 id='exp_smoothing'>General Interface for Exponential Smoothing State Space Models</h2><span id='topic+exp_smoothing'></span>

<h3>Description</h3>

<p><code>exp_smoothing()</code> is a way to generate a <em>specification</em> of an Exponential Smoothing model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>forecast</code>. Several algorithms are implemented:
</p>

<ul>
<li><p> ETS - Automated Exponential Smoothing
</p>
</li>
<li><p> CROSTON - Croston's forecast is a special case
of Exponential Smoothing for intermittent demand
</p>
</li>
<li><p> Theta - A special case of Exponential Smoothing with Drift that
performed well in the M3 Competition
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>exp_smoothing(
  mode = "regression",
  seasonal_period = NULL,
  error = NULL,
  trend = NULL,
  season = NULL,
  damping = NULL,
  smooth_level = NULL,
  smooth_trend = NULL,
  smooth_seasonal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_smoothing_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="exp_smoothing_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
<tr><td><code id="exp_smoothing_+3A_error">error</code></td>
<td>
<p>The form of the error term: &quot;auto&quot;, &quot;additive&quot;, or &quot;multiplicative&quot;.
If the error is multiplicative, the data must be non-negative.</p>
</td></tr>
<tr><td><code id="exp_smoothing_+3A_trend">trend</code></td>
<td>
<p>The form of the trend term: &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="exp_smoothing_+3A_season">season</code></td>
<td>
<p>The form of the seasonal term: &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="exp_smoothing_+3A_damping">damping</code></td>
<td>
<p>Apply damping to a trend: &quot;auto&quot;, &quot;damped&quot;, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="exp_smoothing_+3A_smooth_level">smooth_level</code></td>
<td>
<p>This is often called the &quot;alpha&quot; parameter used as the base level smoothing
factor for exponential smoothing models.</p>
</td></tr>
<tr><td><code id="exp_smoothing_+3A_smooth_trend">smooth_trend</code></td>
<td>
<p>This is often called the &quot;beta&quot; parameter used as the trend smoothing
factor for exponential smoothing models.</p>
</td></tr>
<tr><td><code id="exp_smoothing_+3A_smooth_seasonal">smooth_seasonal</code></td>
<td>
<p>This is often called the &quot;gamma&quot; parameter used as the seasonal smoothing
factor for exponential smoothing models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models can be created using the following <em>engines</em>:
</p>

<ul>
<li><p> &quot;ets&quot; (default) - Connects to <code><a href="forecast.html#topic+ets">forecast::ets()</a></code>
</p>
</li>
<li><p> &quot;croston&quot; - Connects to <code><a href="forecast.html#topic+croston">forecast::croston()</a></code>
</p>
</li>
<li><p> &quot;theta&quot; - Connects to <code><a href="forecast.html#topic+thetaf">forecast::thetaf()</a></code>
</p>
</li>
<li><p> &quot;smooth_es&quot; - Connects to <code><a href="smooth.html#topic+es">smooth::es()</a></code>
</p>
</li></ul>



<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> forecast::ets </td><td style="text-align: left;"> forecast::croston() </td><td style="text-align: left;"> forecast::thetaf() </td><td style="text-align: left;"> smooth::es() </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonal_period() </td><td style="text-align: left;"> ts(frequency) </td><td style="text-align: left;"> ts(frequency) </td><td style="text-align: left;"> ts(frequency) </td><td style="text-align: left;"> ts(frequency) </td>
</tr>
<tr>
 <td style="text-align: left;">
   error(), trend(), season() </td><td style="text-align: left;"> model ('ZZZ') </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> model('ZZZ') </td>
</tr>
<tr>
 <td style="text-align: left;">
   damping() </td><td style="text-align: left;"> damped (NULL) </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> phi </td>
</tr>
<tr>
 <td style="text-align: left;">
   smooth_level() </td><td style="text-align: left;"> alpha (NULL) </td><td style="text-align: left;"> alpha (0.1) </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> persistence(alpha) </td>
</tr>
<tr>
 <td style="text-align: left;">
   smooth_trend() </td><td style="text-align: left;"> beta (NULL) </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> persistence(beta) </td>
</tr>
<tr>
 <td style="text-align: left;">
   smooth_seasonal() </td><td style="text-align: left;"> gamma (NULL) </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> persistence(gamma) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other options can be set using <code>set_engine()</code>.
</p>
<p><strong>ets (default engine)</strong>
</p>
<p>The engine uses <code><a href="forecast.html#topic+ets">forecast::ets()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, model = "ZZZ", damped = NULL, alpha = NULL, beta = NULL, gamma = NULL, 
#&gt;     phi = NULL, additive.only = FALSE, lambda = NULL, biasadj = FALSE, 
#&gt;     lower = c(rep(1e-04, 3), 0.8), upper = c(rep(0.9999, 3), 0.98), opt.crit = c("lik", 
#&gt;         "amse", "mse", "sigma", "mae"), nmse = 3, bounds = c("both", "usual", 
#&gt;         "admissible"), ic = c("aicc", "aic", "bic"), restrict = TRUE, allow.multiplicative.trend = FALSE, 
#&gt;     use.initial.values = FALSE, na.action = c("na.contiguous", "na.interp", 
#&gt;         "na.fail"), ...)
</pre></div>
<p>The main arguments are <code>model</code> and <code>damped</code> are defined using:
</p>

<ul>
<li> <p><code>error()</code> = &quot;auto&quot;, &quot;additive&quot;, and &quot;multiplicative&quot; are converted to  &quot;Z&quot;, &quot;A&quot;, and &quot;M&quot;
</p>
</li>
<li> <p><code>trend()</code> = &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot;, and &quot;none&quot; are converted to &quot;Z&quot;,&quot;A&quot;,&quot;M&quot; and &quot;N&quot;
</p>
</li>
<li> <p><code>season()</code> = &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot;, and &quot;none&quot; are converted to &quot;Z&quot;,&quot;A&quot;,&quot;M&quot; and &quot;N&quot;
</p>
</li>
<li> <p><code>damping()</code> - &quot;auto&quot;, &quot;damped&quot;, &quot;none&quot; are converted to NULL, TRUE, FALSE
</p>
</li>
<li> <p><code>smooth_level()</code>, <code>smooth_trend()</code>, and <code>smooth_seasonal()</code> are
automatically determined if not provided. They are mapped to &quot;alpha&quot;, &quot;beta&quot; and &quot;gamma&quot;, respectively.
</p>
</li></ul>

<p>By default, all arguments are set to &quot;auto&quot; to perform automated Exponential Smoothing using
<em>in-sample data</em> following the underlying <code>forecast::ets()</code> automation routine.
</p>
<p>Other options and argument can be set using <code>set_engine()</code>.
</p>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>xreg</code> - This model is not set up to use exogenous regressors. Only univariate
models will be fit.
</p>
</li></ul>

<p><strong>croston</strong>
</p>
<p>The engine uses <code><a href="forecast.html#topic+croston">forecast::croston()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, h = 10, alpha = 0.1, x = y)
</pre></div>
<p>The main arguments are defined using:
</p>

<ul>
<li> <p><code>smooth_level()</code>: The &quot;alpha&quot; parameter
</p>
</li></ul>

<p>Parameter Notes:
</p>

<ul>
<li> <p><code>xreg</code> - This model is not set up to use exogenous regressors. Only univariate
models will be fit.
</p>
</li></ul>

<p><strong>theta</strong>
</p>
<p>The engine uses <code><a href="forecast.html#topic+thetaf">forecast::thetaf()</a></code>
</p>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>xreg</code> - This model is not set up to use exogenous regressors. Only univariate
models will be fit.
</p>
</li></ul>

<p><strong>smooth_es</strong>
</p>
<p>The engine uses <code><a href="smooth.html#topic+es">smooth::es()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, model = "ZZZ", persistence = NULL, phi = NULL, initial = c("optimal", 
#&gt;     "backcasting"), initialSeason = NULL, ic = c("AICc", "AIC", "BIC", 
#&gt;     "BICc"), loss = c("likelihood", "MSE", "MAE", "HAM", "MSEh", "TMSE", 
#&gt;     "GTMSE", "MSCE"), h = 10, holdout = FALSE, cumulative = FALSE, interval = c("none", 
#&gt;     "parametric", "likelihood", "semiparametric", "nonparametric"), level = 0.95, 
#&gt;     bounds = c("usual", "admissible", "none"), silent = c("all", "graph", 
#&gt;         "legend", "output", "none"), xreg = NULL, xregDo = c("use", "select"), 
#&gt;     initialX = NULL, ...)
</pre></div>
<p>The main arguments <code>model</code> and <code>phi</code> are defined using:
</p>

<ul>
<li> <p><code>error()</code> = &quot;auto&quot;, &quot;additive&quot; and &quot;multiplicative&quot; are converted to &quot;Z&quot;, &quot;A&quot; and &quot;M&quot;
</p>
</li>
<li> <p><code>trend()</code> = &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot;, &quot;additive_damped&quot;, &quot;multiplicative_damped&quot; and &quot;none&quot; are converted to &quot;Z&quot;, &quot;A&quot;, &quot;M&quot;, &quot;Ad&quot;, &quot;Md&quot; and &quot;N&quot;.
</p>
</li>
<li> <p><code>season()</code> = &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot;, and &quot;none&quot; are converted &quot;Z&quot;, &quot;A&quot;,&quot;M&quot; and &quot;N&quot;
</p>
</li>
<li> <p><code>damping()</code> - Value of damping parameter. If NULL, then it is estimated.
</p>
</li>
<li> <p><code>smooth_level()</code>, <code>smooth_trend()</code>, and <code>smooth_seasonal()</code> are
automatically determined if not provided. They are mapped to &quot;persistence&quot;(&quot;alpha&quot;, &quot;beta&quot; and &quot;gamma&quot;, respectively).
</p>
</li></ul>

<p>By default, all arguments are set to &quot;auto&quot; to perform automated Exponential Smoothing using
<em>in-sample data</em> following the underlying <code>smooth::es()</code> automation routine.
</p>
<p>Other options and argument can be set using <code>set_engine()</code>.
</p>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>xreg</code> - This is supplied via the parsnip / modeltime <code>fit()</code> interface
(so don't provide this manually). See Fit Details (below).
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><em>Seasonal Period Specification</em>
</p>
<p>The period can be non-seasonal (<code>seasonal_period = 1</code> or <code>"none"</code>) or seasonal (e.g. <code>seasonal_period = 12</code> or <code>seasonal_period = "12 months"</code>).
There are 3 ways to specify:
</p>

<ol>
<li> <p><code>seasonal_period = "auto"</code>: A period is selected based on the periodicity of the data (e.g. 12 if monthly)
</p>
</li>
<li> <p><code>seasonal_period = 12</code>: A numeric frequency. For example, 12 is common for monthly data
</p>
</li>
<li> <p><code>seasonal_period = "1 year"</code>: A time-based phrase. For example, &quot;1 year&quot; would convert to 12 for monthly data.
</p>
</li></ol>

<p><strong>Univariate:</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li><p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (xregs, Exogenous Regressors)</strong>
</p>
<p>Just for <code>smooth</code> engine.
</p>
<p>The <code>xreg</code> parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>

<ul>
<li><p> Only <code>factor</code>, <code style="white-space: pre;">&#8288;ordered factor&#8288;</code>, and <code>numeric</code> data will be used as xregs.
</p>
</li>
<li><p> Date and Date-time variables are not used as xregs
</p>
</li>
<li> <p><code>character</code> data should be converted to factor.
</p>
</li></ul>

<p><em>Xreg Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>month.lbl</code> (labeled month as a ordered factor).
</p>
</li></ol>

<p>The <code>month.lbl</code> is an exogenous regressor that can be passed to the <code>arima_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>fit(y ~ date + month.lbl)</code> will pass <code>month.lbl</code> on as an exogenous regressor.
</p>
</li>
<li> <p><code>fit_xy(data[,c("date", "month.lbl")], y = data$y)</code> will pass x, where x is a data frame containing <code>month.lbl</code>
and the <code>date</code> feature. Only <code>month.lbl</code> will be used as an exogenous regressor.
</p>
</li></ul>

<p>Note that date or date-time class values are excluded from <code>xreg</code>.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)
library(smooth)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- AUTO ETS ----

# Model Spec - The default parameters are all set
# to "auto" if none are provided
model_spec &lt;- exp_smoothing() %&gt;%
    set_engine("ets")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit


# ---- STANDARD ETS ----

# Model Spec
model_spec &lt;- exp_smoothing(
        seasonal_period  = 12,
        error            = "multiplicative",
        trend            = "additive",
        season           = "multiplicative"
    ) %&gt;%
    set_engine("ets")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit


# ---- CROSTON ----

# Model Spec
model_spec &lt;- exp_smoothing(
        smooth_level = 0.2
    ) %&gt;%
    set_engine("croston")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit




# ---- THETA ----

#' # Model Spec
model_spec &lt;- exp_smoothing() %&gt;%
    set_engine("theta")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit





#' # ---- SMOOTH ----

#' # Model Spec
model_spec &lt;- exp_smoothing(
               seasonal_period  = 12,
               error            = "multiplicative",
               trend            = "additive_damped",
               season           = "additive"
         ) %&gt;%
    set_engine("smooth_es")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(value ~ date, data = training(splits))
model_fit


</code></pre>

<hr>
<h2 id='exp_smoothing_params'>Tuning Parameters for Exponential Smoothing Models</h2><span id='topic+exp_smoothing_params'></span><span id='topic+error'></span><span id='topic+trend'></span><span id='topic+trend_smooth'></span><span id='topic+season'></span><span id='topic+damping'></span><span id='topic+damping_smooth'></span><span id='topic+smooth_level'></span><span id='topic+smooth_trend'></span><span id='topic+smooth_seasonal'></span>

<h3>Description</h3>

<p>Tuning Parameters for Exponential Smoothing Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error(values = c("additive", "multiplicative"))

trend(values = c("additive", "multiplicative", "none"))

trend_smooth(
  values = c("additive", "multiplicative", "none", "additive_damped",
    "multiplicative_damped")
)

season(values = c("additive", "multiplicative", "none"))

damping(values = c("damped", "none"))

damping_smooth(range = c(0, 2), trans = NULL)

smooth_level(range = c(0, 1), trans = NULL)

smooth_trend(range = c(0, 1), trans = NULL)

smooth_seasonal(range = c(0, 1), trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_smoothing_params_+3A_values">values</code></td>
<td>
<p>A character string of possible values.</p>
</td></tr>
<tr><td><code id="exp_smoothing_params_+3A_range">range</code></td>
<td>
<p>A two-element vector holding the <em>defaults</em> for the smallest and
largest possible values, respectively. If a transformation is specified,
these values should be in the <em>transformed units</em>.</p>
</td></tr>
<tr><td><code id="exp_smoothing_params_+3A_trans">trans</code></td>
<td>
<p>A <code>trans</code> object from the <code>scales</code> package, such as
<code>scales::log10_trans()</code> or <code>scales::reciprocal_trans()</code>. If not provided,
the default is used which matches the units used in <code>range</code>. If no
transformation, <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main parameters for Exponential Smoothing models are:
</p>

<ul>
<li> <p><code>error</code>: The form of the error term: additive&quot;, or &quot;multiplicative&quot;.
If the error is multiplicative, the data must be non-negative.
</p>
</li>
<li> <p><code>trend</code>: The form of the trend term: &quot;additive&quot;, &quot;multiplicative&quot; or &quot;none&quot;.
</p>
</li>
<li> <p><code>season</code>: The form of the seasonal term: &quot;additive&quot;, &quot;multiplicative&quot; or &quot;none&quot;..
</p>
</li>
<li> <p><code>damping</code>: Apply damping to a trend: &quot;damped&quot;, or &quot;none&quot;.
</p>
</li>
<li> <p><code>smooth_level</code>: This is often called the &quot;alpha&quot; parameter used as the base level smoothing factor for exponential smoothing models.
</p>
</li>
<li> <p><code>smooth_trend</code>: This is often called the &quot;beta&quot; parameter used as the trend smoothing factor for exponential smoothing models.
</p>
</li>
<li> <p><code>smooth_seasonal</code>: This is often called the &quot;gamma&quot; parameter used as the seasonal smoothing factor for exponential smoothing models.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
error()

trend()

season()

</code></pre>

<hr>
<h2 id='get_arima_description'>Get model descriptions for Arima objects</h2><span id='topic+get_arima_description'></span>

<h3>Description</h3>

<p>Get model descriptions for Arima objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_arima_description(object, padding = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_arima_description_+3A_object">object</code></td>
<td>
<p>Objects of class <code>Arima</code></p>
</td></tr>
<tr><td><code id="get_arima_description_+3A_padding">padding</code></td>
<td>
<p>Whether or not to include padding</p>
</td></tr>
</table>


<h3>Source</h3>


<ul>
<li><p> Forecast R Package, <code>forecast:::arima.string()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(forecast)

arima_fit &lt;- forecast::Arima(1:10)

get_arima_description(arima_fit)


</code></pre>

<hr>
<h2 id='get_model_description'>Get model descriptions for parsnip, workflows &amp; modeltime objects</h2><span id='topic+get_model_description'></span>

<h3>Description</h3>

<p>Get model descriptions for parsnip, workflows &amp; modeltime objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_model_description(object, indicate_training = FALSE, upper_case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_model_description_+3A_object">object</code></td>
<td>
<p>Parsnip or workflow objects</p>
</td></tr>
<tr><td><code id="get_model_description_+3A_indicate_training">indicate_training</code></td>
<td>
<p>Whether or not to indicate if the model has been trained</p>
</td></tr>
<tr><td><code id="get_model_description_+3A_upper_case">upper_case</code></td>
<td>
<p>Whether to return upper or lower case model descriptions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timetk)
library(parsnip)
library(modeltime)

# Model Specification ----

arima_spec &lt;- arima_reg() %&gt;%
    set_engine("auto_arima")

get_model_description(arima_spec, indicate_training = TRUE)

# Fitted Model ----

m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

arima_fit &lt;- arima_spec %&gt;%
    fit(value ~ date, data = m750)

get_model_description(arima_fit, indicate_training = TRUE)


</code></pre>

<hr>
<h2 id='get_tbats_description'>Get model descriptions for TBATS objects</h2><span id='topic+get_tbats_description'></span>

<h3>Description</h3>

<p>Get model descriptions for TBATS objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tbats_description(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tbats_description_+3A_object">object</code></td>
<td>
<p>Objects of class <code>tbats</code></p>
</td></tr>
</table>


<h3>Source</h3>


<ul>
<li><p> Forecast R Package, <code>forecast:::as.character.tbats()</code>
</p>
</li></ul>


<hr>
<h2 id='is_calibrated'>Test if a Modeltime Table has been calibrated</h2><span id='topic+is_calibrated'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> for objects that contains columns
&quot;.type&quot; and &quot;.calibration_data&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_calibrated(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_calibrated_+3A_object">object</code></td>
<td>
<p>An object to detect if is a Calibrated Modeltime Table</p>
</td></tr>
</table>

<hr>
<h2 id='is_modeltime_model'>Test if object contains a fitted modeltime model</h2><span id='topic+is_modeltime_model'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> for trained workflows and parsnip objects
that contain modeltime models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_modeltime_model(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_modeltime_model_+3A_object">object</code></td>
<td>
<p>An object to detect if contains a fitted modeltime model</p>
</td></tr>
</table>

<hr>
<h2 id='is_modeltime_table'>Test if object is a Modeltime Table</h2><span id='topic+is_modeltime_table'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> for objects that contain class <code>mdl_time_tbl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_modeltime_table(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_modeltime_table_+3A_object">object</code></td>
<td>
<p>An object to detect if is a Modeltime Table</p>
</td></tr>
</table>

<hr>
<h2 id='is_residuals'>Test if a table contains residuals.</h2><span id='topic+is_residuals'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> for objects that contains the column name '.residuals'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_residuals(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_residuals_+3A_object">object</code></td>
<td>
<p>An object to detect if it provides from modeltime::modeltime_residuals().</p>
</td></tr>
</table>

<hr>
<h2 id='load_namespace'>These are not intended for use by the general public.</h2><span id='topic+load_namespace'></span>

<h3>Description</h3>

<p>These are not intended for use by the general public.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_namespace(x, full_load)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_namespace_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="load_namespace_+3A_full_load">full_load</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Control information
</p>

<hr>
<h2 id='log_extractors'>Log Extractor Functions for Modeltime Nested Tables</h2><span id='topic+log_extractors'></span><span id='topic+extract_nested_test_accuracy'></span><span id='topic+extract_nested_test_forecast'></span><span id='topic+extract_nested_error_report'></span><span id='topic+extract_nested_best_model_report'></span><span id='topic+extract_nested_future_forecast'></span><span id='topic+extract_nested_modeltime_table'></span><span id='topic+extract_nested_train_split'></span><span id='topic+extract_nested_test_split'></span>

<h3>Description</h3>

<p>Extract logged information calculated during the <code>modeltime_nested_fit()</code>,
<code>modeltime_nested_select_best()</code>, and <code>modeltime_nested_refit()</code> processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_nested_test_accuracy(object)

extract_nested_test_forecast(object, .include_actual = TRUE, .id_subset = NULL)

extract_nested_error_report(object)

extract_nested_best_model_report(object)

extract_nested_future_forecast(
  object,
  .include_actual = TRUE,
  .id_subset = NULL
)

extract_nested_modeltime_table(object, .row_id = 1)

extract_nested_train_split(object, .row_id = 1)

extract_nested_test_split(object, .row_id = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_extractors_+3A_object">object</code></td>
<td>
<p>A nested modeltime table</p>
</td></tr>
<tr><td><code id="log_extractors_+3A_.include_actual">.include_actual</code></td>
<td>
<p>Whether or not to include the actual data in the extracted forecast.
Default: TRUE.</p>
</td></tr>
<tr><td><code id="log_extractors_+3A_.id_subset">.id_subset</code></td>
<td>
<p>Can supply a vector of id's to extract forcasts for one or more id's,
rather than extracting all forecasts. If <code>NULL</code>, extracts forecasts for all id's.</p>
</td></tr>
<tr><td><code id="log_extractors_+3A_.row_id">.row_id</code></td>
<td>
<p>The row number to extract from the nested data.</p>
</td></tr>
</table>

<hr>
<h2 id='m750'>The 750th Monthly Time Series used in the M4 Competition</h2><span id='topic+m750'></span>

<h3>Description</h3>

<p>The 750th Monthly Time Series used in the M4 Competition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m750
</code></pre>


<h3>Format</h3>

<p>A <code>tibble</code> with 306 rows and 3 variables:
</p>

<ul>
<li> <p><code>id</code> Factor. Unique series identifier
</p>
</li>
<li> <p><code>date</code> Date. Timestamp information. Monthly format.
</p>
</li>
<li> <p><code>value</code> Numeric. Value at the corresponding timestamp.
</p>
</li></ul>



<h3>Source</h3>


<ul>
<li> <p><a href="https://mofc.unic.ac.cy/m4/">M4 Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m750

</code></pre>

<hr>
<h2 id='m750_models'>Three (3) Models trained on the M750 Data (Training Set)</h2><span id='topic+m750_models'></span>

<h3>Description</h3>

<p>Three (3) Models trained on the M750 Data (Training Set)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m750_models
</code></pre>


<h3>Format</h3>

<p>An <code>time_series_cv</code> object with 6 slices of Time Series Cross Validation
resamples made on the <code>training(m750_splits)</code>
</p>


<h3>Details</h3>

<div class="sourceCode r"><pre>library(modeltime)
m750_models &lt;- modeltime_table(
    wflw_fit_arima,
    wflw_fit_prophet,
    wflw_fit_glmnet
)
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>library(modeltime)

m750_models



</code></pre>

<hr>
<h2 id='m750_splits'>The results of train/test splitting the M750 Data</h2><span id='topic+m750_splits'></span>

<h3>Description</h3>

<p>The results of train/test splitting the M750 Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m750_splits
</code></pre>


<h3>Format</h3>

<p>An <code>rsplit</code> object split into approximately 23.5-years of training data
and 2-years of testing data
</p>


<h3>Details</h3>

<div class="sourceCode r"><pre>library(timetk)
m750_splits &lt;- time_series_split(m750, assess = "2 years", cumulative = TRUE)
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsample)

m750_splits

training(m750_splits)

</code></pre>

<hr>
<h2 id='m750_training_resamples'>The Time Series Cross Validation Resamples the M750 Data (Training Set)</h2><span id='topic+m750_training_resamples'></span>

<h3>Description</h3>

<p>The Time Series Cross Validation Resamples the M750 Data (Training Set)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m750_training_resamples
</code></pre>


<h3>Format</h3>

<p>An <code>time_series_cv</code> object with 6 slices of Time Series Cross Validation
resamples made on the <code>training(m750_splits)</code>
</p>


<h3>Details</h3>

<div class="sourceCode r"><pre>library(timetk)
m750_training_resamples &lt;- time_series_cv(
    data        = training(m750_splits),
    assess      = "2 years",
    skip        = "2 years",
    cumulative  = TRUE,
    slice_limit = 6
)
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsample)

m750_training_resamples



</code></pre>

<hr>
<h2 id='maape'>Mean Arctangent Absolute Percentage Error</h2><span id='topic+maape'></span>

<h3>Description</h3>

<p>Useful when MAPE returns Inf typically due to intermittent data containing zeros.
This is a wrapper to the function of <code>TSrepr::maape()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maape(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maape_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the truth and estimate columns.</p>
</td></tr>
<tr><td><code id="maape_+3A_...">...</code></td>
<td>
<p>Not currently in use.</p>
</td></tr>
</table>

<hr>
<h2 id='maape_vec'>Mean Arctangent Absolute Percentage Error</h2><span id='topic+maape_vec'></span>

<h3>Description</h3>

<p>This is basically a wrapper to the function of <code>TSrepr::maape()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maape_vec(truth, estimate, na_rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maape_vec_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results (that is numeric).</p>
</td></tr>
<tr><td><code id="maape_vec_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted results (that is also numeric).</p>
</td></tr>
<tr><td><code id="maape_vec_+3A_na_rm">na_rm</code></td>
<td>
<p>Not in use...NA values managed by TSrepr::maape</p>
</td></tr>
<tr><td><code id="maape_vec_+3A_...">...</code></td>
<td>
<p>Not currently in use</p>
</td></tr>
</table>

<hr>
<h2 id='make_ts_splits'>Generate a Time Series Train/Test Split Indicies</h2><span id='topic+make_ts_splits'></span>

<h3>Description</h3>

<p>Makes fast train/test split indicies for time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ts_splits(.data, .length_test, .length_train = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ts_splits_+3A_.data">.data</code></td>
<td>
<p>A data frame containing ordered time seried data (ascending)</p>
</td></tr>
<tr><td><code id="make_ts_splits_+3A_.length_test">.length_test</code></td>
<td>
<p>The number of rows to include in the test set</p>
</td></tr>
<tr><td><code id="make_ts_splits_+3A_.length_train">.length_train</code></td>
<td>
<p>Optional. The number of rows to include in the training set.
If NULL, returns all remaining row indicies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing train_idx and test_idx
</p>

<hr>
<h2 id='mdl_time_forecast'>Modeltime Forecast Helpers</h2><span id='topic+mdl_time_forecast'></span>

<h3>Description</h3>

<p>Used for low-level forecasting of modeltime, parnsip and workflow models.
These functions are not intended for user use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdl_time_forecast(
  object,
  calibration_data,
  new_data = NULL,
  h = NULL,
  actual_data = NULL,
  bind_actual = TRUE,
  keep_data = FALSE,
  arrange_index = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdl_time_forecast_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="mdl_time_forecast_+3A_calibration_data">calibration_data</code></td>
<td>
<p>Data that has been calibrated from a testing set</p>
</td></tr>
<tr><td><code id="mdl_time_forecast_+3A_new_data">new_data</code></td>
<td>
<p>A <code>tibble</code> containing future information to forecast.
If <code>NULL</code>, forecasts the calibration data.</p>
</td></tr>
<tr><td><code id="mdl_time_forecast_+3A_h">h</code></td>
<td>
<p>The forecast horizon (can be used instead of <code>new_data</code> for
time series with no exogenous regressors).
Extends the calibration data <code>h</code> periods into the future.</p>
</td></tr>
<tr><td><code id="mdl_time_forecast_+3A_actual_data">actual_data</code></td>
<td>
<p>Reference data that is combined with the output tibble and given a <code>.key = "actual"</code></p>
</td></tr>
<tr><td><code id="mdl_time_forecast_+3A_bind_actual">bind_actual</code></td>
<td>
<p>Logical. Whether or not to skip rowwise binding of 'actual_data&ldquo;</p>
</td></tr>
<tr><td><code id="mdl_time_forecast_+3A_keep_data">keep_data</code></td>
<td>
<p>Whether or not to keep the <code>new_data</code> and <code>actual_data</code> as extra columns in the results.
This can be useful if there is an important feature in the <code>new_data</code> and <code>actual_data</code> needed
when forecasting.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mdl_time_forecast_+3A_arrange_index">arrange_index</code></td>
<td>
<p>Whether or not to sort the index in rowwise chronological order (oldest to newest) or to
keep the original order of the data.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mdl_time_forecast_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with forecast features
</p>

<hr>
<h2 id='mdl_time_refit'>Modeltime Refit Helpers</h2><span id='topic+mdl_time_refit'></span>

<h3>Description</h3>

<p>Used for low-level refitting of modeltime, parnsip and workflow models
These functions are not intended for user use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdl_time_refit(object, data, ..., control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdl_time_refit_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="mdl_time_refit_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> that contains data to retrain the model(s) using.</p>
</td></tr>
<tr><td><code id="mdl_time_refit_+3A_...">...</code></td>
<td>
<p>Additional arguments to control refitting.
</p>
<p><strong>Ensemble Model Spec (<code>modeltime.ensemble</code>):</strong>
</p>
<p>When making a meta-learner with <code>modeltime.ensemble::ensemble_model_spec()</code>,
used to pass <code>resamples</code> argument containing results
from <code>modeltime.resample::modeltime_fit_resamples()</code>.</p>
</td></tr>
<tr><td><code id="mdl_time_refit_+3A_control">control</code></td>
<td>
<p>Used to control verbosity and parallel processing.
See <code><a href="#topic+control_refit">control_refit()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with forecast features
</p>

<hr>
<h2 id='metric_sets'>Forecast Accuracy Metrics Sets</h2><span id='topic+metric_sets'></span><span id='topic+default_forecast_accuracy_metric_set'></span><span id='topic+extended_forecast_accuracy_metric_set'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>metric_set()</code> with several common forecast / regression
accuracy metrics included. These are the default time series accuracy
metrics used with <code><a href="#topic+modeltime_accuracy">modeltime_accuracy()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_forecast_accuracy_metric_set(...)

extended_forecast_accuracy_metric_set(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric_sets_+3A_...">...</code></td>
<td>
<p>Add additional <code>yardstick</code> metrics</p>
</td></tr>
</table>


<h3>Default Forecast Accuracy Metric Set</h3>

<p>The primary purpose is to use the default accuracy metrics to calculate the following
forecast accuracy metrics using <code><a href="#topic+modeltime_accuracy">modeltime_accuracy()</a></code>:
</p>

<ul>
<li><p> MAE   - Mean absolute error, <code><a href="ModelMetrics.html#topic+mae">mae()</a></code>
</p>
</li>
<li><p> MAPE  - Mean absolute percentage error, <code><a href="modelr.html#topic+mape">mape()</a></code>
</p>
</li>
<li><p> MASE  - Mean absolute scaled error, <code>mase()</code>
</p>
</li>
<li><p> SMAPE - Symmetric mean absolute percentage error, <code>smape()</code>
</p>
</li>
<li><p> RMSE  - Root mean squared error, <code><a href="ModelMetrics.html#topic+rmse">rmse()</a></code>
</p>
</li>
<li><p> RSQ   - R-squared, <code><a href="lava.html#topic+rsq">rsq()</a></code>
</p>
</li></ul>

<p>Adding additional metrics is possible via <code>...</code>.
</p>


<h3>Extended Forecast Accuracy Metric Set</h3>

<p>Extends the default metric set by adding:
</p>

<ul>
<li><p> MAAPE - Mean Arctangent Absolute Percentage Error, <code><a href="#topic+maape">maape()</a></code>.
MAAPE is designed for intermittent data where MAPE returns <code>Inf</code>.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="yardstick.html#topic+metric_tweak">yardstick::metric_tweak()</a></code> - For modifying <code>yardstick</code> metrics
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)
library(timetk)
library(yardstick)

fake_data &lt;- tibble(
    y    = c(1:12, 2*1:12),
    yhat = c(1 + 1:12, 2*1:12 - 1)
)

# ---- HOW IT WORKS ----

# Default Forecast Accuracy Metric Specification
default_forecast_accuracy_metric_set()

# Create a metric summarizer function from the metric set
calc_default_metrics &lt;- default_forecast_accuracy_metric_set()

# Apply the metric summarizer to new data
calc_default_metrics(fake_data, y, yhat)

# ---- ADD MORE PARAMETERS ----

# Can create a version of mase() with seasonality = 12 (monthly)
mase12 &lt;- metric_tweak(.name = "mase12", .fn = mase, m = 12)

# Add it to the default metric set
my_metric_set &lt;- default_forecast_accuracy_metric_set(mase12)
my_metric_set

# Apply the newly created metric set
my_metric_set(fake_data, y, yhat)


</code></pre>

<hr>
<h2 id='modeltime_accuracy'>Calculate Accuracy Metrics</h2><span id='topic+modeltime_accuracy'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>yardstick</code> that simplifies time series regression accuracy metric
calculations from a fitted <code>workflow</code> (trained workflow) or <code>model_fit</code> (trained parsnip model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_accuracy(
  object,
  new_data = NULL,
  metric_set = default_forecast_accuracy_metric_set(),
  acc_by_id = FALSE,
  quiet = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_accuracy_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="modeltime_accuracy_+3A_new_data">new_data</code></td>
<td>
<p>A <code>tibble</code> to predict and calculate residuals on.
If provided, overrides any calibration data.</p>
</td></tr>
<tr><td><code id="modeltime_accuracy_+3A_metric_set">metric_set</code></td>
<td>
<p>A <code>yardstick::metric_set()</code> that is used to summarize one or more
forecast accuracy (regression) metrics.</p>
</td></tr>
<tr><td><code id="modeltime_accuracy_+3A_acc_by_id">acc_by_id</code></td>
<td>
<p>Should a global or local model accuracy be produced? (Default: FALSE)
</p>

<ul>
<li><p> When <code>FALSE</code>, a global model accuracy is provided.
</p>
</li>
<li><p> If <code>TRUE</code>, a local accuracy is provided group-wise for each time series ID.
To enable local accuracy, an <code>id</code> must be provided during <code>modeltime_calibrate()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="modeltime_accuracy_+3A_quiet">quiet</code></td>
<td>
<p>Hide errors (<code>TRUE</code>, the default), or display them as they occur?</p>
</td></tr>
<tr><td><code id="modeltime_accuracy_+3A_...">...</code></td>
<td>
<p>If <code>new_data</code> is provided, these parameters are passed to <code>modeltime_calibrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following accuracy metrics are included by default via <code><a href="#topic+default_forecast_accuracy_metric_set">default_forecast_accuracy_metric_set()</a></code>:
</p>

<ul>
<li><p> MAE - Mean absolute error, <code><a href="ModelMetrics.html#topic+mae">mae()</a></code>
</p>
</li>
<li><p> MAPE - Mean absolute percentage error, <code><a href="modelr.html#topic+mape">mape()</a></code>
</p>
</li>
<li><p> MASE  - Mean absolute scaled error, <code>mase()</code>
</p>
</li>
<li><p> SMAPE - Symmetric mean absolute percentage error, <code>smape()</code>
</p>
</li>
<li><p> RMSE  - Root mean squared error, <code><a href="ModelMetrics.html#topic+rmse">rmse()</a></code>
</p>
</li>
<li><p> RSQ   - R-squared, <code><a href="lava.html#topic+rsq">rsq()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with accuracy estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidymodels)
library(tidyverse)
library(lubridate)
library(timetk)
library(modeltime)


# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- ACCURACY ----

models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits)) %&gt;%
    modeltime_accuracy(
        metric_set = metric_set(mae, rmse, rsq)
    )


</code></pre>

<hr>
<h2 id='modeltime_calibrate'>Preparation for forecasting</h2><span id='topic+modeltime_calibrate'></span>

<h3>Description</h3>

<p>Calibration sets the stage for accuracy and forecast confidence
by computing predictions and residuals from out of sample data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_calibrate(object, new_data, id = NULL, quiet = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_calibrate_+3A_object">object</code></td>
<td>
<p>A fitted model object that is either:
</p>

<ol>
<li><p> A modeltime table that has been created using <code><a href="#topic+modeltime_table">modeltime_table()</a></code>
</p>
</li>
<li><p> A workflow that has been fit by <code>fit.workflow()</code> or
</p>
</li>
<li><p> A parsnip model that has been fit using <code>fit.model_spec()</code>
</p>
</li></ol>
</td></tr>
<tr><td><code id="modeltime_calibrate_+3A_new_data">new_data</code></td>
<td>
<p>A test data set <code>tibble</code> containing future information (timestamps and actual values).</p>
</td></tr>
<tr><td><code id="modeltime_calibrate_+3A_id">id</code></td>
<td>
<p>A quoted column name containing an identifier column identifying time series that are grouped.</p>
</td></tr>
<tr><td><code id="modeltime_calibrate_+3A_quiet">quiet</code></td>
<td>
<p>Hide errors (<code>TRUE</code>, the default), or display them as they occur?</p>
</td></tr>
<tr><td><code id="modeltime_calibrate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+modeltime_forecast">modeltime_forecast()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of calibration are used for:
</p>

<ul>
<li> <p><strong>Forecast Confidence Interval Estimation</strong>: The out of sample residual data is used to calculate the
confidence interval. Refer to <code><a href="#topic+modeltime_forecast">modeltime_forecast()</a></code>.
</p>
</li>
<li> <p><strong>Accuracy Calculations:</strong> The out of sample actual and prediction values are used to calculate
performance metrics. Refer to <code><a href="#topic+modeltime_accuracy">modeltime_accuracy()</a></code>
</p>
</li></ul>

<p>The calibration steps include:
</p>

<ol>
<li><p> If not a Modeltime Table, objects are converted to Modeltime Tables internally
</p>
</li>
<li><p> Two Columns are added:
</p>
</li></ol>


<ul>
<li> <p><code>.type</code>: Indicates the sample type. This is:
</p>

<ul>
<li><p> &quot;Test&quot; if predicted, or
</p>
</li>
<li><p> &quot;Fitted&quot; if residuals were stored during modeling.
</p>
</li></ul>

</li>
<li> <p><code>.calibration_data</code>:
</p>

<ul>
<li><p> Contains a tibble with Timestamps, Actual Values, Predictions and Residuals
calculated from <code>new_data</code> (Test Data)
</p>
</li>
<li><p> If <code>id</code> is provided, will contain a 5th column that is the identifier variable.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A Modeltime Table (<code>mdl_time_tbl</code>) with nested <code>.calibration_data</code> added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- CALIBRATE ----

calibration_tbl &lt;- models_tbl %&gt;%
    modeltime_calibrate(
        new_data = testing(splits)
    )

# ---- ACCURACY ----

calibration_tbl %&gt;%
    modeltime_accuracy()

# ---- FORECAST ----

calibration_tbl %&gt;%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = m750
    )


</code></pre>

<hr>
<h2 id='modeltime_fit_workflowset'>Fit a <code>workflowset</code> object to one or multiple time series</h2><span id='topic+modeltime_fit_workflowset'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>fit()</code> that takes a
<code>workflowset</code> object and fits each model on one or multiple
time series either sequentially or in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_fit_workflowset(
  object,
  data,
  ...,
  control = control_fit_workflowset()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_fit_workflowset_+3A_object">object</code></td>
<td>
<p>A workflow_set object, generated with the workflowsets::workflow_set function.</p>
</td></tr>
<tr><td><code id="modeltime_fit_workflowset_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> that contains data to fit the models.</p>
</td></tr>
<tr><td><code id="modeltime_fit_workflowset_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="modeltime_fit_workflowset_+3A_control">control</code></td>
<td>
<p>An object used to modify the fitting process. See <code><a href="#topic+control_fit_workflowset">control_fit_workflowset()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Modeltime Table containing one or more fitted models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control_fit_workflowset">control_fit_workflowset()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidymodels)
library(modeltime)
library(workflowsets)
library(tidyverse)
library(lubridate)
library(timetk)

data_set &lt;- m4_monthly

# SETUP WORKFLOWSETS

rec1 &lt;- recipe(value ~ date + id, data_set) %&gt;%
    step_mutate(date_num = as.numeric(date)) %&gt;%
    step_mutate(month_lbl = lubridate::month(date, label = TRUE)) %&gt;%
    step_dummy(all_nominal(), one_hot = TRUE)

mod1 &lt;- linear_reg() %&gt;% set_engine("lm")

mod2 &lt;- prophet_reg() %&gt;% set_engine("prophet")

wfsets &lt;- workflowsets::workflow_set(
    preproc = list(rec1 = rec1),
    models  = list(
        mod1 = mod1,
        mod2 = mod2
    ),
    cross   = TRUE
)

# FIT WORKFLOWSETS
# - Returns a Modeltime Table with fitted workflowsets

wfsets %&gt;% modeltime_fit_workflowset(data_set)

</code></pre>

<hr>
<h2 id='modeltime_forecast'>Forecast future data</h2><span id='topic+modeltime_forecast'></span>

<h3>Description</h3>

<p>The goal of <code>modeltime_forecast()</code> is to simplify the process of
forecasting future data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_forecast(
  object,
  new_data = NULL,
  h = NULL,
  actual_data = NULL,
  conf_interval = 0.95,
  conf_by_id = FALSE,
  conf_method = "conformal_default",
  keep_data = FALSE,
  arrange_index = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_forecast_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_new_data">new_data</code></td>
<td>
<p>A <code>tibble</code> containing future information to forecast.
If <code>NULL</code>, forecasts the calibration data.</p>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_h">h</code></td>
<td>
<p>The forecast horizon (can be used instead of <code>new_data</code> for
time series with no exogenous regressors).
Extends the calibration data <code>h</code> periods into the future.</p>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_actual_data">actual_data</code></td>
<td>
<p>Reference data that is combined with the output tibble and given a <code>.key = "actual"</code></p>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_conf_interval">conf_interval</code></td>
<td>
<p>An estimated confidence interval based on the calibration data.
This is designed to estimate future confidence from <em>out-of-sample prediction error</em>.</p>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_conf_by_id">conf_by_id</code></td>
<td>
<p>Whether or not to produce confidence interval estimates by an ID feature.
</p>

<ul>
<li><p> When <code>FALSE</code>, a global model confidence interval is provided.
</p>
</li>
<li><p> If <code>TRUE</code>, a local confidence interval is provided group-wise for each time series ID.
To enable local confidence interval, an <code>id</code> must be provided during <code>modeltime_calibrate()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_conf_method">conf_method</code></td>
<td>
<p>Algorithm used to produce confidence intervals. All CI's are Conformal Predictions. Choose one of:
</p>

<ul>
<li> <p><code>conformal_default</code>: Uses <code>qnorm()</code> to compute quantiles from out-of-sample (test set) residuals.
</p>
</li>
<li> <p><code>conformal_split</code>: Uses the split method split conformal inference method described by Lei <em>et al</em> (2018)
</p>
</li></ul>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_keep_data">keep_data</code></td>
<td>
<p>Whether or not to keep the <code>new_data</code> and <code>actual_data</code> as extra columns in the results.
This can be useful if there is an important feature in the <code>new_data</code> and <code>actual_data</code> needed
when forecasting.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_arrange_index">arrange_index</code></td>
<td>
<p>Whether or not to sort the index in rowwise chronological order (oldest to newest) or to
keep the original order of the data.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modeltime_forecast_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>modeltime_forecast()</code> function prepares a forecast for visualization with
with <code><a href="#topic+plot_modeltime_forecast">plot_modeltime_forecast()</a></code>. The forecast is controlled by <code>new_data</code> or <code>h</code>,
which can be combined with existing data (controlled by <code>actual_data</code>).
Confidence intervals are included if the incoming Modeltime Table has been
calibrated using <code><a href="#topic+modeltime_calibrate">modeltime_calibrate()</a></code>.
Otherwise confidence intervals are not estimated.
</p>
<p><strong>New Data</strong>
</p>
<p>When forecasting you can specify future data using <code>new_data</code>.
This is a future tibble with date column and columns for xregs
extending the trained dates and exogonous regressors (xregs) if used.
</p>

<ul>
<li> <p><strong>Forecasting Evaluation Data</strong>: By default, the <code>new_data</code> will use the <code>.calibration_data</code>
if <code>new_data</code> is not provided.
This is the equivalent of using <code>rsample::testing()</code> for getting test data sets.
</p>
</li>
<li> <p><strong>Forecasting Future Data</strong>: See <code>timetk::future_frame()</code> for creating future tibbles.
</p>
</li>
<li> <p><strong>Xregs</strong>: Can be used with this method
</p>
</li></ul>

<p><strong>H (Horizon)</strong>
</p>
<p>When forecasting, you can specify <code>h</code>. This is a phrase like &quot;1 year&quot;,
which extends the <code>.calibration_data</code> (1st priority) or the <code>actual_data</code> (2nd priority)
into the future.
</p>

<ul>
<li> <p><strong>Forecasting Future Data</strong>: All forecasts using <code>h</code> are
<em><strong>extended after the calibration data or actual_data</strong></em>.
</p>
</li>
<li><p> Extending <code>.calibration_data</code> - Calibration data is given 1st priority, which is
desirable <em>after refitting</em> with <code><a href="#topic+modeltime_refit">modeltime_refit()</a></code>.
Internally, a call is made to <code>timetk::future_frame()</code> to
expedite creating new data using the date feature.
</p>
</li>
<li><p> Extending <code>actual_data</code> - If <code>h</code> is provided, and the modeltime table has not been
calibrated, the &quot;actual_data&quot; will be extended into the future. This is useful
in situations where you want to go directly from <code>modeltime_table()</code> to <code>modeltime_forecast()</code>
without calibrating or refitting.
</p>
</li>
<li> <p><strong>Xregs</strong>: Cannot be used because future data must include new xregs.
If xregs are desired, build a future data frame and use <code>new_data</code>.
</p>
</li></ul>

<p><strong>Actual Data</strong>
</p>
<p>This is reference data that contains the true values of the time-stamp data.
It helps in visualizing the performance of the forecast vs the actual data.
</p>
<p>When <code>h</code> is used and the Modeltime Table has <em>not been calibrated</em>, then the
actual data is extended into the future periods that are defined by <code>h</code>.
</p>
<p><strong>Confidence Interval Estimation</strong>
</p>
<p>Confidence intervals (<code>.conf_lo</code>, <code>.conf_hi</code>) are estimated based on the normal estimation of
the testing errors (out of sample) from <code><a href="#topic+modeltime_calibrate">modeltime_calibrate()</a></code>.
The out-of-sample error estimates are then carried through and
applied to applied to any future forecasts.
</p>
<p>The confidence interval can be adjusted with the <code>conf_interval</code> parameter. The algorithm used
to produce confidence intervals can be changed with the <code>conf_method</code> parameter.
</p>
<p><em>Conformal Default Method:</em>
</p>
<p>When <code>conf_method = "conformal_default"</code> (default), this method uses <code>qnorm()</code>
to produce a 95% confidence interval by default. It estimates a normal (Gaussian distribution)
based on the out-of-sample errors (residuals).
</p>
<p>The confidence interval is <em>mean-adjusted</em>, meaning that if the mean of the residuals
is non-zero, the confidence interval is adjusted to widen the interval to capture
the difference in means.
</p>
<p><em>Conformal Split Method:</em>
</p>
<p>When <code style="white-space: pre;">&#8288;conf_method = "conformal_split&#8288;</code>, this method uses the split conformal inference method
described by Lei <em>et al</em> (2018). This is also implemented in the <code>probably</code> R package's
<code>int_conformal_split()</code> function.
</p>
<p><em>What happens to the confidence interval after refitting models?</em>
</p>
<p>Refitting has no affect on the confidence interval since this is calculated independently of
the refitted model. New observations typically improve
future accuracy, which in most cases makes the out-of-sample confidence intervals conservative.
</p>
<p><strong>Keep Data</strong>
</p>
<p>Include the new data (and actual data) as extra columns with the results of the model forecasts.
This can be helpful when the new data includes information useful to the forecasts.
An example is when forecasting <em>Panel Data</em> and the new data contains
ID features related to the time series group that the forecast belongs to.
</p>
<p><strong>Arrange Index</strong>
</p>
<p>By default, <code>modeltime_forecast()</code> keeps the original order of the data.
If desired, the user can sort the output by <code>.key</code>, <code>.model_id</code> and <code>.index</code>.
</p>


<h3>Value</h3>

<p>A tibble with predictions and time-stamp data. For ease of plotting and calculations,
the column names are transformed to:
</p>

<ul>
<li> <p><code>.key</code>: Values labeled either &quot;prediction&quot; or &quot;actual&quot;
</p>
</li>
<li> <p><code>.index</code>: The timestamp index.
</p>
</li>
<li> <p><code>.value</code>: The value being forecasted.
</p>
</li></ul>

<p>Additionally, if the Modeltime Table has been previously calibrated using <code><a href="#topic+modeltime_calibrate">modeltime_calibrate()</a></code>,
you will gain confidence intervals.
</p>

<ul>
<li> <p><code>.conf_lo</code>: The lower limit of the confidence interval.
</p>
</li>
<li> <p><code>.conf_hi</code>: The upper limit of the confidence interval.
</p>
</li></ul>

<p>Additional descriptive columns are included:
</p>

<ul>
<li> <p><code>.model_id</code>: Model ID from the Modeltime Table
</p>
</li>
<li> <p><code>.model_desc</code>: Model Description from the Modeltime Table
</p>
</li></ul>

<p>Unnecessary columns are <em>dropped</em> to save space:
</p>

<ul>
<li> <p><code>.model</code>
</p>
</li>
<li> <p><code>.calibration_data</code>
</p>
</li></ul>



<h3>References</h3>

<p>Lei, Jing, et al. &quot;Distribution-free predictive inference for regression.&quot;
<em>Journal of the American Statistical Association</em> 113.523 (2018): 1094-1111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- CALIBRATE ----

calibration_tbl &lt;- models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits))

# ---- ACCURACY ----

calibration_tbl %&gt;%
    modeltime_accuracy()

# ---- FUTURE FORECAST ----

calibration_tbl %&gt;%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = m750
    )

# ---- ALTERNATIVE: FORECAST WITHOUT CONFIDENCE INTERVALS ----
# Skips Calibration Step, No Confidence Intervals

models_tbl %&gt;%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = m750
    )

# ---- KEEP NEW DATA WITH FORECAST ----
# Keeps the new data. Useful if new data has information
#  like ID features that should be kept with the forecast data

calibration_tbl %&gt;%
    modeltime_forecast(
        new_data      = testing(splits),
        keep_data     = TRUE
    )

</code></pre>

<hr>
<h2 id='modeltime_nested_fit'>Fit Tidymodels Workflows to Nested Time Series</h2><span id='topic+modeltime_nested_fit'></span>

<h3>Description</h3>

<p>Fits one or more <code>tidymodels</code> workflow objects to nested time series data using the following process:
</p>

<ol>
<li><p> Models are iteratively fit to training splits.
</p>
</li>
<li><p> Accuracy is calculated on testing splits and is logged.
Accuracy results can be retrieved with <code><a href="#topic+extract_nested_test_accuracy">extract_nested_test_accuracy()</a></code>
</p>
</li>
<li><p> Any model that returns an error is logged.
Error logs can be retrieved with <code><a href="#topic+extract_nested_error_report">extract_nested_error_report()</a></code>
</p>
</li>
<li><p> Forecast is predicted on testing splits and is logged.
Forecast results can be retrieved with <code><a href="#topic+extract_nested_test_forecast">extract_nested_test_forecast()</a></code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>modeltime_nested_fit(
  nested_data,
  ...,
  model_list = NULL,
  metric_set = default_forecast_accuracy_metric_set(),
  conf_interval = 0.95,
  control = control_nested_fit()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_nested_fit_+3A_nested_data">nested_data</code></td>
<td>
<p>Nested time series data</p>
</td></tr>
<tr><td><code id="modeltime_nested_fit_+3A_...">...</code></td>
<td>
<p>Tidymodels <code>workflow</code> objects that will be fit to the nested time series data.</p>
</td></tr>
<tr><td><code id="modeltime_nested_fit_+3A_model_list">model_list</code></td>
<td>
<p>Optionally, a <code>list()</code> of Tidymodels <code>workflow</code> objects can be provided</p>
</td></tr>
<tr><td><code id="modeltime_nested_fit_+3A_metric_set">metric_set</code></td>
<td>
<p>A <code>yardstick::metric_set()</code> that is used to summarize one or more
forecast accuracy (regression) metrics.</p>
</td></tr>
<tr><td><code id="modeltime_nested_fit_+3A_conf_interval">conf_interval</code></td>
<td>
<p>An estimated confidence interval based on the calibration data.
This is designed to estimate future confidence from <em>out-of-sample prediction error</em>.</p>
</td></tr>
<tr><td><code id="modeltime_nested_fit_+3A_control">control</code></td>
<td>
<p>Used to control verbosity and parallel processing. See <code><a href="#topic+control_nested_fit">control_nested_fit()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Preparing Data for Nested Forecasting</h4>

<p>Use <code><a href="#topic+extend_timeseries">extend_timeseries()</a></code>, <code><a href="#topic+nest_timeseries">nest_timeseries()</a></code>, and <code><a href="#topic+split_nested_timeseries">split_nested_timeseries()</a></code> for preparing
data for Nested Forecasting. The structure must be a nested data frame, which is suppplied in
<code>modeltime_nested_fit(nested_data)</code>.
</p>



<h4>Fitting Models</h4>

<p>Models must be in the form of <code style="white-space: pre;">&#8288;tidymodels workflow&#8288;</code> objects. The models can be provided in two ways:
</p>

<ol>
<li><p> Using <code>...</code> (dots): The workflow objects can be provided as dots.
</p>
</li>
<li><p> Using <code>model_list</code> parameter: You can supply one or more workflow objects that are wrapped in a <code>list()</code>.
</p>
</li></ol>




<h4>Controlling the fitting process</h4>

<p>A <code>control</code> object can be provided during fitting to adjust the verbosity and parallel processing.
See <code><a href="#topic+control_nested_fit">control_nested_fit()</a></code>.
</p>


<hr>
<h2 id='modeltime_nested_forecast'>Modeltime Nested Forecast</h2><span id='topic+modeltime_nested_forecast'></span>

<h3>Description</h3>

<p>Make a new forecast from a Nested Modeltime Table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_nested_forecast(
  object,
  h = NULL,
  include_actual = TRUE,
  conf_interval = 0.95,
  id_subset = NULL,
  control = control_nested_forecast()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_nested_forecast_+3A_object">object</code></td>
<td>
<p>A Nested Modeltime Table</p>
</td></tr>
<tr><td><code id="modeltime_nested_forecast_+3A_h">h</code></td>
<td>
<p>The forecast horizon. Extends the &quot;trained on&quot; data &quot;h&quot; periods
into the future.</p>
</td></tr>
<tr><td><code id="modeltime_nested_forecast_+3A_include_actual">include_actual</code></td>
<td>
<p>Whether or not to include the &quot;.actual_data&quot; as part of the forecast.
If FALSE, just returns the forecast predictions.</p>
</td></tr>
<tr><td><code id="modeltime_nested_forecast_+3A_conf_interval">conf_interval</code></td>
<td>
<p>An estimated confidence interval based on the calibration data.
This is designed to estimate future confidence from <em>out-of-sample prediction error</em>.</p>
</td></tr>
<tr><td><code id="modeltime_nested_forecast_+3A_id_subset">id_subset</code></td>
<td>
<p>A sequence of ID's from the modeltime table to subset the forecasting process.
This can speed forecasts up.</p>
</td></tr>
<tr><td><code id="modeltime_nested_forecast_+3A_control">control</code></td>
<td>
<p>Used to control verbosity and parallel processing. See <code><a href="#topic+control_nested_forecast">control_nested_forecast()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to help users that want to make new forecasts other than those
that are created during the logging process as part of the Nested Modeltime Workflow.
</p>


<h4>Logged Forecasts</h4>

<p>The logged forecasts can be extracted using:
</p>

<ul>
<li> <p><code><a href="#topic+extract_nested_future_forecast">extract_nested_future_forecast()</a></code>: Extracts the future forecast created after refitting with <code>modeltime_nested_refit()</code>.
</p>
</li>
<li> <p><code><a href="#topic+extract_nested_test_forecast">extract_nested_test_forecast()</a></code>: Extracts the test forecast created after initial fitting with <code>modeltime_nested_fit()</code>.
</p>
</li></ul>

<p>The problem is that these forecasts are static. The user would need to redo the fitting, model selection,
and refitting process to obtain new forecasts. This is why <code>modeltime_nested_forecast()</code> exists. So you can create
a new forecast without retraining any models.
</p>



<h4>Nested Forecasts</h4>

<p>The main arguments is
<code>h</code>, which is a horizon that specifies how far into the future to make the new forecast.
</p>

<ul>
<li><p> If <code>h = NULL</code>, a logged forecast will be returned
</p>
</li>
<li><p> If <code>h = 12</code>, a new forecast will be generated that extends each series 12-periods into the future.
</p>
</li>
<li><p> If <code>h = "2 years"</code>, a new forecast will be generated that extends each series 2-years into the future.
</p>
</li></ul>

<p>Use the <code>id_subset</code> to filter the Nested Modeltime Table <code>object</code> to just the time series of interest.
</p>
<p>Use the <code>conf_interval</code> to override the logged confidence interval.
Note that this will have no effect if <code>h = NULL</code> as logged forecasts are returned.
So be sure to provide <code>h</code> if you want to update the confidence interval.
</p>
<p>Use the <code>control</code> argument to apply verbosity during the forecasting process and to run forecasts in parallel.
Generally, parallel is better if many forecasts are being generated.
</p>


<hr>
<h2 id='modeltime_nested_refit'>Refits a Nested Modeltime Table</h2><span id='topic+modeltime_nested_refit'></span>

<h3>Description</h3>

<p>Refits a Nested Modeltime Table to actual data using the following process:
</p>

<ol>
<li><p> Models are iteratively refit to .actual_data.
</p>
</li>
<li><p> Any model that returns an error is logged.
Errors can be retrieved with <code><a href="#topic+extract_nested_error_report">extract_nested_error_report()</a></code>
</p>
</li>
<li><p> Forecast is predicted on future_data and is logged.
Forecast can be retrieved with <code><a href="#topic+extract_nested_future_forecast">extract_nested_future_forecast()</a></code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>modeltime_nested_refit(object, control = control_nested_refit())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_nested_refit_+3A_object">object</code></td>
<td>
<p>A Nested Modeltime Table</p>
</td></tr>
<tr><td><code id="modeltime_nested_refit_+3A_control">control</code></td>
<td>
<p>Used to control verbosity and parallel processing. See <code><a href="#topic+control_nested_refit">control_nested_refit()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='modeltime_nested_select_best'>Select the Best Models from Nested Modeltime Table</h2><span id='topic+modeltime_nested_select_best'></span>

<h3>Description</h3>

<p>Finds the best models for each time series group in a Nested Modeltime Table using
a <code>metric</code> that the user specifies.
</p>

<ul>
<li><p> Logs the best results, which can be accessed with <code><a href="#topic+extract_nested_best_model_report">extract_nested_best_model_report()</a></code>
</p>
</li>
<li><p> If <code>filter_test_forecasts = TRUE</code>, updates the test forecast log, which can be accessed
<code><a href="#topic+extract_nested_test_forecast">extract_nested_test_forecast()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>modeltime_nested_select_best(
  object,
  metric = "rmse",
  minimize = TRUE,
  filter_test_forecasts = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_nested_select_best_+3A_object">object</code></td>
<td>
<p>A Nested Modeltime Table</p>
</td></tr>
<tr><td><code id="modeltime_nested_select_best_+3A_metric">metric</code></td>
<td>
<p>A metric to minimize or maximize. By default available metrics are:
</p>

<ul>
<li><p> &quot;rmse&quot; (default)
</p>
</li>
<li><p> &quot;mae&quot;
</p>
</li>
<li><p> &quot;mape&quot;
</p>
</li>
<li><p> &quot;mase&quot;
</p>
</li>
<li><p> &quot;smape&quot;
</p>
</li>
<li><p> &quot;rsq&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="modeltime_nested_select_best_+3A_minimize">minimize</code></td>
<td>
<p>Whether to minimize or maximize. Default: TRUE (minimize).</p>
</td></tr>
<tr><td><code id="modeltime_nested_select_best_+3A_filter_test_forecasts">filter_test_forecasts</code></td>
<td>
<p>Whether or not to update the test forecast log to
filter only the best forecasts. Default: TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='modeltime_refit'>Refit one or more trained models to new data</h2><span id='topic+modeltime_refit'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>fit()</code> that takes a
Modeltime Table and retrains each model on <em>new data</em> re-using the parameters
and preprocessing steps used during the training process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_refit(object, data, ..., control = control_refit())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_refit_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="modeltime_refit_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> that contains data to retrain the model(s) using.</p>
</td></tr>
<tr><td><code id="modeltime_refit_+3A_...">...</code></td>
<td>
<p>Additional arguments to control refitting.
</p>
<p><strong>Ensemble Model Spec (<code>modeltime.ensemble</code>):</strong>
</p>
<p>When making a meta-learner with <code>modeltime.ensemble::ensemble_model_spec()</code>,
used to pass <code>resamples</code> argument containing results
from <code>modeltime.resample::modeltime_fit_resamples()</code>.</p>
</td></tr>
<tr><td><code id="modeltime_refit_+3A_control">control</code></td>
<td>
<p>Used to control verbosity and parallel processing.
See <code><a href="#topic+control_refit">control_refit()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refitting is an important step prior to forecasting time series models.
The <code>modeltime_refit()</code> function makes it easy to recycle models,
retraining on new data.
</p>
<p><strong>Recycling Parameters</strong>
</p>
<p>Parameters are recycled during retraining using the following criteria:
</p>

<ul>
<li> <p><strong>Automated models</strong> (e.g. &quot;auto arima&quot;) will have parameters recalculated.
</p>
</li>
<li> <p><strong>Non-automated models</strong> (e.g. &quot;arima&quot;) will have parameters preserved.
</p>
</li>
<li><p> All preprocessing steps will be reused on the data
</p>
</li></ul>

<p><strong>Refit</strong>
</p>
<p>The <code>modeltime_refit()</code> function is used to retrain models trained with <code>fit()</code>.
</p>
<p><strong>Refit XY</strong>
</p>
<p>The XY format is not supported at this time.
</p>


<h3>Value</h3>

<p>A Modeltime Table containing one or more re-trained models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control_refit">control_refit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- CALIBRATE ----
# - Calibrate on training data set

calibration_tbl &lt;- models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits))


# ---- REFIT ----
# - Refit on full data set

refit_tbl &lt;- calibration_tbl %&gt;%
    modeltime_refit(m750)


</code></pre>

<hr>
<h2 id='modeltime_residuals'>Extract Residuals Information</h2><span id='topic+modeltime_residuals'></span>

<h3>Description</h3>

<p>This is a convenience function to unnest model residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_residuals(object, new_data = NULL, quiet = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_residuals_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="modeltime_residuals_+3A_new_data">new_data</code></td>
<td>
<p>A <code>tibble</code> to predict and calculate residuals on.
If provided, overrides any calibration data.</p>
</td></tr>
<tr><td><code id="modeltime_residuals_+3A_quiet">quiet</code></td>
<td>
<p>Hide errors (<code>TRUE</code>, the default), or display them as they occur?</p>
</td></tr>
<tr><td><code id="modeltime_residuals_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- RESIDUALS ----

# In-Sample
models_tbl %&gt;%
    modeltime_calibrate(new_data = training(splits)) %&gt;%
    modeltime_residuals() %&gt;%
    plot_modeltime_residuals(.interactive = FALSE)

# Out-of-Sample
models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits)) %&gt;%
    modeltime_residuals() %&gt;%
    plot_modeltime_residuals(.interactive = FALSE)


</code></pre>

<hr>
<h2 id='modeltime_residuals_test'>Apply Statistical Tests to Residuals</h2><span id='topic+modeltime_residuals_test'></span>

<h3>Description</h3>

<p>This is a convenience function to calculate some statistical tests on the residuals models. Currently, the
following statistics are calculated: the shapiro.test to check the normality of the residuals, the box-pierce
and ljung-box tests and the durbin watson test to check the autocorrelation of the residuals. In all cases
the p-values are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_residuals_test(object, new_data = NULL, lag = 1, fitdf = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_residuals_test_+3A_object">object</code></td>
<td>
<p>A <code>tibble</code> extracted from modeltime::modeltime_residuals().</p>
</td></tr>
<tr><td><code id="modeltime_residuals_test_+3A_new_data">new_data</code></td>
<td>
<p>A <code>tibble</code> to predict and calculate residuals on.
If provided, overrides any calibration data.</p>
</td></tr>
<tr><td><code id="modeltime_residuals_test_+3A_lag">lag</code></td>
<td>
<p>The statistic will be based on lag autocorrelation coefficients. Default: 1
(Applies to Box-Pierce, Ljung-Box, and Durbin-Watson Tests)</p>
</td></tr>
<tr><td><code id="modeltime_residuals_test_+3A_fitdf">fitdf</code></td>
<td>
<p>Number of degrees of freedom to be subtracted. Default: 0
(Applies Box-Pierce and Ljung-Box Tests)</p>
</td></tr>
<tr><td><code id="modeltime_residuals_test_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Shapiro-Wilk Test</strong>
</p>
<p>The Shapiro-Wilk tests the Normality of the residuals.
The Null Hypothesis is that the residuals are normally distributed.
A low P-Value below a given significance level indicates the values are NOT Normally Distributed.
</p>
<p>If the <strong>p-value &gt; 0.05 (good)</strong>, this implies that the distribution
of the data are not significantly different from normal distribution.
In other words, we can assume the normality.
</p>
<p><strong>Box-Pierce and Ljung-Box Tests Tests</strong>
</p>
<p>The Ljung-Box and Box-Pierce tests are methods that test for the absense
of autocorrelation in residuals. A low p-value below a given significance level
indicates the values are autocorrelated.
</p>
<p>If the <strong>p-value &gt; 0.05 (good)</strong>, this implies that the residuals
of the data are are independent.
In other words, we can assume the residuals are not autocorrelated.
</p>
<p>For more information about the parameters associated with the Box Pierce and Ljung Box tests check
?Box.Test
</p>
<p><strong>Durbin-Watson Test</strong>
</p>
<p>The Durbin-Watson test is a method that tests for the absense of autocorrelation in residuals.
The Durbin Watson test reports a test statistic, with a value from 0 to 4, where:
</p>

<ul>
<li> <p><strong>2 is no autocorrelation (good)</strong>
</p>
</li>
<li><p> From 0 to &lt;2 is positive autocorrelation (common in time series data)
</p>
</li>
<li><p> From &gt;2 to 4 is negative autocorrelation (less common in time series data)
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with with the p-values of the calculated statistical tests.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+shapiro.test">stats::shapiro.test()</a></code>, <code><a href="stats.html#topic+box.test">stats::Box.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- RESIDUALS ----

# In-Sample
models_tbl %&gt;%
    modeltime_calibrate(new_data = training(splits)) %&gt;%
    modeltime_residuals() %&gt;%
    modeltime_residuals_test()

# Out-of-Sample
models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits)) %&gt;%
    modeltime_residuals() %&gt;%
    modeltime_residuals_test()


</code></pre>

<hr>
<h2 id='modeltime_table'>Scale forecast analysis with a Modeltime Table</h2><span id='topic+modeltime_table'></span><span id='topic+as_modeltime_table'></span>

<h3>Description</h3>

<p>Designed to perform forecasts at scale using models created with
<code>modeltime</code>, <code>parsnip</code>, <code>workflows</code>, and regression modeling extensions
in the <code>tidymodels</code> ecosystem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltime_table(...)

as_modeltime_table(.l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltime_table_+3A_...">...</code></td>
<td>
<p>Fitted <code>parsnip</code> model or <code>workflow</code> objects</p>
</td></tr>
<tr><td><code id="modeltime_table_+3A_.l">.l</code></td>
<td>
<p>A list containing fitted <code>parsnip</code> model or <code>workflow</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modeltime_table()</code>:
</p>

<ol>
<li><p> Creates a table of models
</p>
</li>
<li><p> Validates that all objects are models (parsnip or workflows objects) and
all models have been fitted (trained)
</p>
</li>
<li><p> Provides an ID and Description of the models
</p>
</li></ol>

<p><code>as_modeltime_table()</code>:
</p>
<p>Converts a <code>list</code> of models to a modeltime table. Useful if programatically creating
Modeltime Tables from models stored in a <code>list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

# Make a Modeltime Table
models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# Can also convert a list of models
list(model_fit_prophet) %&gt;%
    as_modeltime_table()

# ---- CALIBRATE ----

calibration_tbl &lt;- models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits))

# ---- ACCURACY ----

calibration_tbl %&gt;%
    modeltime_accuracy()

# ---- FORECAST ----

calibration_tbl %&gt;%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = m750
    )

</code></pre>

<hr>
<h2 id='naive_fit_impl'>Low-Level NAIVE Forecast</h2><span id='topic+naive_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level NAIVE Forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naive_fit_impl(x, y, id = NULL, seasonal_period = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naive_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="naive_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="naive_fit_impl_+3A_id">id</code></td>
<td>
<p>An optional ID feature to identify different time series. Should be a quoted name.</p>
</td></tr>
<tr><td><code id="naive_fit_impl_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>Not used for NAIVE forecast but here for consistency with SNAIVE</p>
</td></tr>
<tr><td><code id="naive_fit_impl_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>

<hr>
<h2 id='naive_predict_impl'>Bridge prediction function for NAIVE Models</h2><span id='topic+naive_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for NAIVE Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naive_predict_impl(object, new_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naive_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="naive_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
</table>

<hr>
<h2 id='naive_reg'>General Interface for NAIVE Forecast Models</h2><span id='topic+naive_reg'></span>

<h3>Description</h3>

<p><code>naive_reg()</code> is a way to generate a <em>specification</em> of an NAIVE or SNAIVE model
before fitting and allows the model to be created using
different packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naive_reg(mode = "regression", id = NULL, seasonal_period = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naive_reg_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="naive_reg_+3A_id">id</code></td>
<td>
<p>An optional quoted column name (e.g. &quot;id&quot;) for
identifying multiple time series (i.e. panel data).</p>
</td></tr>
<tr><td><code id="naive_reg_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>SNAIVE only. A seasonal frequency. Uses &quot;auto&quot; by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>naive_reg()</code>, the
mode will always be &quot;regression&quot;.
</p>
<p>The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li><p> &quot;naive&quot; (default) - Performs a NAIVE forecast
</p>
</li>
<li><p> &quot;snaive&quot; - Performs a Seasonal NAIVE forecast
</p>
</li></ul>



<h3>Engine Details</h3>

<p><strong>naive (default engine)</strong>
</p>

<ul>
<li><p> The engine uses <code><a href="#topic+naive_fit_impl">naive_fit_impl()</a></code>
</p>
</li>
<li><p> The NAIVE implementation uses the last observation and forecasts this value forward.
</p>
</li>
<li><p> The <code>id</code> can be used to distinguish multiple time series contained in
the data
</p>
</li>
<li><p> The <code>seasonal_period</code> is not used but provided for consistency with the SNAIVE
implementation
</p>
</li></ul>

<p><strong>snaive (default engine)</strong>
</p>

<ul>
<li><p> The engine uses <code><a href="#topic+snaive_fit_impl">snaive_fit_impl()</a></code>
</p>
</li>
<li><p> The SNAIVE implementation uses the last seasonal series in the data
and forecasts this sequence of observations forward
</p>
</li>
<li><p> The <code>id</code> can be used to distinguish multiple time series contained in
the data
</p>
</li>
<li><p> The <code>seasonal_period</code> is used to determine how far back to define the repeated
series. This can be a numeric value (e.g. 28) or a period (e.g. &quot;1 month&quot;)
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><strong>ID features (Multiple Time Series, Panel Data)</strong>
</p>
<p>The <code>id</code> parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>
<p><em>ID Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>series_id</code> (a unique identifer that identifies each time series in your data).
</p>
</li></ol>

<p>The <code>series_id</code> can be passed to the <code>naive_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>naive_reg(id = "series_id")</code> specifes that the <code>series_id</code> column should be used
to identify each time series.
</p>
</li>
<li> <p><code>fit(y ~ date + series_id)</code> will pass <code>series_id</code> on to the underlying
naive or snaive functions.
</p>
</li></ul>

<p><strong>Seasonal Period Specification (snaive)</strong>
</p>
<p>The period can be non-seasonal (<code style="white-space: pre;">&#8288;seasonal_period = 1 or "none"&#8288;</code>) or
yearly seasonal (e.g. For monthly time stamps, <code>seasonal_period = 12</code>, <code>seasonal_period = "12 months"</code>, or <code>seasonal_period = "yearly"</code>).
There are 3 ways to specify:
</p>

<ol>
<li> <p><code>seasonal_period = "auto"</code>: A seasonal period is selected based on the periodicity of the data (e.g. 12 if monthly)
</p>
</li>
<li> <p><code>seasonal_period = 12</code>: A numeric frequency. For example, 12 is common for monthly data
</p>
</li>
<li> <p><code>seasonal_period = "1 year"</code>: A time-based phrase. For example, &quot;1 year&quot; would convert to 12 for monthly data.
</p>
</li></ol>

<p><strong>External Regressors (Xregs)</strong>
</p>
<p>These models are univariate. No xregs are used in the modeling process.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- NAIVE ----

# Model Spec
model_spec &lt;- naive_reg() %&gt;%
    set_engine("naive")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit


# ---- SEASONAL NAIVE ----

# Model Spec
model_spec &lt;- naive_reg(
        id = "id",
        seasonal_period = 12
    ) %&gt;%
    set_engine("snaive")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date + id, data = training(splits))
model_fit

</code></pre>

<hr>
<h2 id='new_modeltime_bridge'>Constructor for creating modeltime models</h2><span id='topic+new_modeltime_bridge'></span>

<h3>Description</h3>

<p>These functions are used to construct new <code>modeltime</code> bridge functions that
connect the <code>tidymodels</code> infrastructure to time-series models containing date or date-time features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_modeltime_bridge(class, models, data, extras = NULL, desc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_modeltime_bridge_+3A_class">class</code></td>
<td>
<p>A class name that is used for creating custom printing messages</p>
</td></tr>
<tr><td><code id="new_modeltime_bridge_+3A_models">models</code></td>
<td>
<p>A list containing one or more models</p>
</td></tr>
<tr><td><code id="new_modeltime_bridge_+3A_data">data</code></td>
<td>
<p>A data frame (or tibble) containing 4 columns:
(date column with name that matches input data), .actual, .fitted, and .residuals.</p>
</td></tr>
<tr><td><code id="new_modeltime_bridge_+3A_extras">extras</code></td>
<td>
<p>An optional list that is typically used for transferring preprocessing recipes
to the predict method.</p>
</td></tr>
<tr><td><code id="new_modeltime_bridge_+3A_desc">desc</code></td>
<td>
<p>An optional model description to appear when printing your modeltime objects</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(stats)
library(tidyverse)
library(lubridate)
library(timetk)

lm_model &lt;- lm(value ~ as.numeric(date) + hour(date) + wday(date, label = TRUE),
               data = taylor_30_min)

data = tibble(
    date        = taylor_30_min$date, # Important - The column name must match the modeled data
    # These are standardized names: .actual, .fitted, .residuals
    .actual     = taylor_30_min$value,
    .fitted     = lm_model$fitted.values %&gt;% as.numeric(),
    .residuals  = lm_model$residuals %&gt;% as.numeric()
)

new_modeltime_bridge(
    class  = "lm_time_series_impl",
    models = list(model_1 = lm_model),
    data   = data,
    extras = NULL
)


</code></pre>

<hr>
<h2 id='nnetar_fit_impl'>Low-Level NNETAR function for translating modeltime to forecast</h2><span id='topic+nnetar_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level NNETAR function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnetar_fit_impl(
  x,
  y,
  period = "auto",
  p = 1,
  P = 1,
  size = 10,
  repeats = 20,
  decay = 0,
  maxit = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnetar_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_p">p</code></td>
<td>
<p>Embedding dimension for non-seasonal time series. Number of
non-seasonal lags used as inputs. For non-seasonal time series, the default
is the optimal number of lags (according to the AIC) for a linear AR(p)
model. For seasonal time series, the same method is used but applied to
seasonally adjusted data (from an stl decomposition).</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_p">P</code></td>
<td>
<p>Number of seasonal lags used as inputs.</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_size">size</code></td>
<td>
<p>Number of nodes in the hidden layer. Default is half of the
number of input nodes (including external regressors, if given) plus 1.</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_repeats">repeats</code></td>
<td>
<p>Number of networks to fit with different random starting
weights. These are then averaged when producing forecasts.</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_decay">decay</code></td>
<td>
<p>Parameter for weight decay. Default 0.</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations. Default 100.</p>
</td></tr>
<tr><td><code id="nnetar_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::nnetar</code></p>
</td></tr>
</table>

<hr>
<h2 id='nnetar_params'>Tuning Parameters for NNETAR Models</h2><span id='topic+nnetar_params'></span><span id='topic+num_networks'></span>

<h3>Description</h3>

<p>Tuning Parameters for NNETAR Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_networks(range = c(1L, 100L), trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnetar_params_+3A_range">range</code></td>
<td>
<p>A two-element vector holding the <em>defaults</em> for the smallest and
largest possible values, respectively. If a transformation is specified,
these values should be in the <em>transformed units</em>.</p>
</td></tr>
<tr><td><code id="nnetar_params_+3A_trans">trans</code></td>
<td>
<p>A <code>trans</code> object from the <code>scales</code> package, such as
<code>scales::log10_trans()</code> or <code>scales::reciprocal_trans()</code>. If not provided,
the default is used which matches the units used in <code>range</code>. If no
transformation, <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main parameters for NNETAR models are:
</p>

<ul>
<li> <p><code>non_seasonal_ar</code>: Number of non-seasonal auto-regressive (AR) lags. Often denoted &quot;p&quot; in pdq-notation.
</p>
</li>
<li> <p><code>seasonal_ar</code>: Number of seasonal auto-regressive (SAR) lags. Often denoted &quot;P&quot; in PDQ-notation.
</p>
</li>
<li> <p><code>hidden_units</code>: An integer for the number of units in the hidden model.
</p>
</li>
<li> <p><code>num_networks</code>: Number of networks to fit with different random starting weights. These are then averaged when producing forecasts.
</p>
</li>
<li> <p><code>penalty</code>: A non-negative numeric value for the amount of weight decay.
</p>
</li>
<li> <p><code>epochs</code>: An integer for the number of training iterations.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+non_seasonal_ar">non_seasonal_ar()</a></code>, <code><a href="#topic+seasonal_ar">seasonal_ar()</a></code>, <code><a href="dials.html#topic+dropout">dials::hidden_units()</a></code>, <code><a href="dials.html#topic+penalty">dials::penalty()</a></code>, <code><a href="dials.html#topic+dropout">dials::epochs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
num_networks()

</code></pre>

<hr>
<h2 id='nnetar_predict_impl'>Bridge prediction function for ARIMA models</h2><span id='topic+nnetar_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for ARIMA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnetar_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnetar_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="nnetar_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="nnetar_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::forecast()</code></p>
</td></tr>
</table>

<hr>
<h2 id='nnetar_reg'>General Interface for NNETAR Regression Models</h2><span id='topic+nnetar_reg'></span>

<h3>Description</h3>

<p><code>nnetar_reg()</code> is a way to generate a <em>specification</em> of an NNETAR model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>forecast</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnetar_reg(
  mode = "regression",
  seasonal_period = NULL,
  non_seasonal_ar = NULL,
  seasonal_ar = NULL,
  hidden_units = NULL,
  num_networks = NULL,
  penalty = NULL,
  epochs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnetar_reg_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="nnetar_reg_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
<tr><td><code id="nnetar_reg_+3A_non_seasonal_ar">non_seasonal_ar</code></td>
<td>
<p>The order of the non-seasonal auto-regressive (AR) terms. Often denoted &quot;p&quot; in pdq-notation.</p>
</td></tr>
<tr><td><code id="nnetar_reg_+3A_seasonal_ar">seasonal_ar</code></td>
<td>
<p>The order of the seasonal auto-regressive (SAR) terms. Often denoted &quot;P&quot; in PDQ-notation.</p>
</td></tr>
<tr><td><code id="nnetar_reg_+3A_hidden_units">hidden_units</code></td>
<td>
<p>An integer for the number of units in the hidden model.</p>
</td></tr>
<tr><td><code id="nnetar_reg_+3A_num_networks">num_networks</code></td>
<td>
<p>Number of networks to fit with different random starting weights.
These are then averaged when producing forecasts.</p>
</td></tr>
<tr><td><code id="nnetar_reg_+3A_penalty">penalty</code></td>
<td>
<p>A non-negative numeric value for the amount of weight
decay.</p>
</td></tr>
<tr><td><code id="nnetar_reg_+3A_epochs">epochs</code></td>
<td>
<p>An integer for the number of training iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>nnetar_reg()</code>, the
mode will always be &quot;regression&quot;.
</p>
<p>The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li><p> &quot;nnetar&quot; (default) - Connects to <code><a href="forecast.html#topic+nnetar">forecast::nnetar()</a></code>
</p>
</li></ul>

<p><strong>Main Arguments</strong>
</p>
<p>The main arguments (tuning parameters) for the model are the parameters in
<code>nnetar_reg()</code> function. These arguments are converted to their specific names at the
time that the model is fit.
</p>
<p>Other options and argument can be
set using <code>set_engine()</code> (See Engine Details below).
</p>
<p>If parameters need to be modified, <code>update()</code> can be used
in lieu of recreating the object from scratch.
</p>


<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> forecast::nnetar </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonal_period </td><td style="text-align: left;"> ts(frequency) </td>
</tr>
<tr>
 <td style="text-align: left;">
   non_seasonal_ar </td><td style="text-align: left;"> p (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonal_ar </td><td style="text-align: left;"> P (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
   hidden_units </td><td style="text-align: left;"> size (10) </td>
</tr>
<tr>
 <td style="text-align: left;">
   num_networks </td><td style="text-align: left;"> repeats (20) </td>
</tr>
<tr>
 <td style="text-align: left;">
   epochs </td><td style="text-align: left;"> maxit (100) </td>
</tr>
<tr>
 <td style="text-align: left;">
   penalty </td><td style="text-align: left;"> decay (0) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other options can be set using <code>set_engine()</code>.
</p>
<p><strong>nnetar</strong>
</p>
<p>The engine uses <code><a href="forecast.html#topic+nnetar">forecast::nnetar()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, p, P = 1, size, repeats = 20, xreg = NULL, lambda = NULL, 
#&gt;     model = NULL, subset = NULL, scale.inputs = TRUE, x = y, ...)
</pre></div>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>xreg</code> - This is supplied via the parsnip / modeltime <code>fit()</code> interface
(so don't provide this manually). See Fit Details (below).
</p>
</li>
<li> <p><code>size</code> - Is set to 10 by default. This differs from the <code>forecast</code> implementation
</p>
</li>
<li> <p><code>p</code> and <code>P</code> - Are set to 1 by default.
</p>
</li>
<li> <p><code>maxit</code> and <code>decay</code> are <code>nnet::nnet</code> parameters that are exposed in the <code>nnetar_reg()</code> interface.
These are key tuning parameters.
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><em>Seasonal Period Specification</em>
</p>
<p>The period can be non-seasonal (<code style="white-space: pre;">&#8288;seasonal_period = 1 or "none"&#8288;</code>) or
yearly seasonal (e.g. For monthly time stamps, <code>seasonal_period = 12</code>, <code>seasonal_period = "12 months"</code>, or <code>seasonal_period = "yearly"</code>).
There are 3 ways to specify:
</p>

<ol>
<li> <p><code>seasonal_period = "auto"</code>: A seasonal period is selected based on the periodicity of the data (e.g. 12 if monthly)
</p>
</li>
<li> <p><code>seasonal_period = 12</code>: A numeric frequency. For example, 12 is common for monthly data
</p>
</li>
<li> <p><code>seasonal_period = "1 year"</code>: A time-based phrase. For example, &quot;1 year&quot; would convert to 12 for monthly data.
</p>
</li></ol>

<p><strong>Univariate (No xregs, Exogenous Regressors):</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li><p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (xregs, Exogenous Regressors)</strong>
</p>
<p>The <code>xreg</code> parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>

<ul>
<li><p> Only <code>factor</code>, <code style="white-space: pre;">&#8288;ordered factor&#8288;</code>, and <code>numeric</code> data will be used as xregs.
</p>
</li>
<li><p> Date and Date-time variables are not used as xregs
</p>
</li>
<li> <p><code>character</code> data should be converted to factor.
</p>
</li></ul>

<p><em>Xreg Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>month.lbl</code> (labeled month as a ordered factor).
</p>
</li></ol>

<p>The <code>month.lbl</code> is an exogenous regressor that can be passed to the <code>nnetar_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>fit(y ~ date + month.lbl)</code> will pass <code>month.lbl</code> on as an exogenous regressor.
</p>
</li>
<li> <p><code>fit_xy(data[,c("date", "month.lbl")], y = data$y)</code> will pass x, where x is a data frame containing <code>month.lbl</code>
and the <code>date</code> feature. Only <code>month.lbl</code> will be used as an exogenous regressor.
</p>
</li></ul>

<p>Note that date or date-time class values are excluded from <code>xreg</code>.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- NNETAR ----

# Model Spec
model_spec &lt;- nnetar_reg() %&gt;%
    set_engine("nnetar")

# Fit Spec
set.seed(123)
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit



</code></pre>

<hr>
<h2 id='panel_tail'>Filter the last N rows (Tail) for multiple time series</h2><span id='topic+panel_tail'></span>

<h3>Description</h3>

<p>Filter the last N rows (Tail) for multiple time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel_tail(data, id, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel_tail_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="panel_tail_+3A_id">id</code></td>
<td>
<p>An &quot;id&quot; feature indicating which column differentiates the time series panels</p>
</td></tr>
<tr><td><code id="panel_tail_+3A_n">n</code></td>
<td>
<p>The number of rows to filter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+recursive">recursive()</a></code> - used to generate recursive autoregressive models
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(timetk)

# Get the last 6 observations from each group
m4_monthly %&gt;%
    panel_tail(id = id, n = 6)

</code></pre>

<hr>
<h2 id='parallel_start'>Start parallel clusters using <code>parallel</code> package</h2><span id='topic+parallel_start'></span><span id='topic+parallel_stop'></span>

<h3>Description</h3>

<p>Start parallel clusters using <code>parallel</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel_start(..., .method = c("parallel", "spark"))

parallel_stop()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel_start_+3A_...">...</code></td>
<td>
<p>Parameters passed to underlying functions (See Details Section)</p>
</td></tr>
<tr><td><code id="parallel_start_+3A_.method">.method</code></td>
<td>
<p>The method to create the parallel backend. Supports:
</p>

<ul>
<li><p> &quot;parallel&quot; - Uses the <code>parallel</code> and <code>doParallel</code> packages
</p>
</li>
<li><p> &quot;spark&quot; - Uses the <code>sparklyr</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Parallel (<code>.method = "parallel"</code>)</h3>

<p>Performs 3 Steps:
</p>

<ol>
<li><p> Makes clusters using <code>parallel::makeCluster(...)</code>. The <code>parallel_start(...)</code>
are passed to <code>parallel::makeCluster(...)</code>.
</p>
</li>
<li><p> Registers clusters using <code>doParallel::registerDoParallel()</code>.
</p>
</li>
<li><p> Adds <code>.libPaths()</code> using <code>parallel::clusterCall()</code>.
</p>
</li></ol>



<h3>Spark (<code>.method = "spark"</code>)</h3>


<ul>
<li><p> Important, make sure to create a spark connection using <code>sparklyr::spark_connect()</code>.
</p>
</li>
<li><p> Pass the connection object as the first argument.
For example, <code>parallel_start(sc, .method = "spark")</code>.
</p>
</li>
<li><p> The <code>parallel_start(...)</code> are passed to <code>sparklyr::registerDoSpark(...)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Starts 2 clusters
parallel_start(2)

# Returns to sequential processing
parallel_stop()



</code></pre>

<hr>
<h2 id='parse_index'>Developer Tools for parsing date and date-time information</h2><span id='topic+parse_index'></span><span id='topic+parse_index_from_data'></span><span id='topic+parse_period_from_index'></span>

<h3>Description</h3>

<p>These functions are designed to assist developers in extending the <code>modeltime</code>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_index_from_data(data)

parse_period_from_index(data, period)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_index_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="parse_index_+3A_period">period</code></td>
<td>
<p>A period to calculate from the time index. Numeric values are returned as-is.
&quot;auto&quot; guesses a numeric value from the index. A time-based phrase (e.g. &quot;7 days&quot;) calculates
the number of timestamps that typically occur within the time-based phrase.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> parse_index_from_data(): Returns a tibble containing the date or date-time column.
</p>
</li>
<li><p> parse_period_from_index(): Returns the numeric period from a tibble containing the index.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timetk)

predictors &lt;- m4_monthly %&gt;%
    filter(id == "M750") %&gt;%
    select(-value)

index_tbl &lt;- parse_index_from_data(predictors)
index_tbl

period &lt;- parse_period_from_index(index_tbl, period = "1 year")
period

</code></pre>

<hr>
<h2 id='plot_modeltime_forecast'>Interactive Forecast Visualization</h2><span id='topic+plot_modeltime_forecast'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>plot_time_series()</code> that generates an interactive (<code>plotly</code>) or static
(<code>ggplot2</code>) plot with the forecasted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_modeltime_forecast(
  .data,
  .conf_interval_show = TRUE,
  .conf_interval_fill = "grey20",
  .conf_interval_alpha = 0.2,
  .smooth = FALSE,
  .legend_show = TRUE,
  .legend_max_width = 40,
  .facet_ncol = 1,
  .facet_nrow = 1,
  .facet_scales = "free_y",
  .title = "Forecast Plot",
  .x_lab = "",
  .y_lab = "",
  .color_lab = "Legend",
  .interactive = TRUE,
  .plotly_slider = FALSE,
  .trelliscope = FALSE,
  .trelliscope_params = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_modeltime_forecast_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> that is the output of <code><a href="#topic+modeltime_forecast">modeltime_forecast()</a></code></p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.conf_interval_show">.conf_interval_show</code></td>
<td>
<p>Logical. Whether or not to include the confidence interval as a ribbon.</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.conf_interval_fill">.conf_interval_fill</code></td>
<td>
<p>Fill color for the confidence interval</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.conf_interval_alpha">.conf_interval_alpha</code></td>
<td>
<p>Fill opacity for the confidence interval. Range (0, 1).</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.smooth">.smooth</code></td>
<td>
<p>Logical - Whether or not to include a trendline smoother.
Uses See <code><a href="timetk.html#topic+smooth_vec">smooth_vec()</a></code> to apply a LOESS smoother.</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.legend_show">.legend_show</code></td>
<td>
<p>Logical. Whether or not to show the legend.
Can save space with long model descriptions.</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.legend_max_width">.legend_max_width</code></td>
<td>
<p>Numeric. The width of truncation to apply to the legend text.</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.facet_ncol">.facet_ncol</code></td>
<td>
<p>Number of facet columns.</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.facet_nrow">.facet_nrow</code></td>
<td>
<p>Number of facet rows (only used for <code>.trelliscope = TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.facet_scales">.facet_scales</code></td>
<td>
<p>Control facet x &amp; y-axis ranges.
Options include &quot;fixed&quot;, &quot;free&quot;, &quot;free_y&quot;, &quot;free_x&quot;</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.title">.title</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.x_lab">.x_lab</code></td>
<td>
<p>X-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Y-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.color_lab">.color_lab</code></td>
<td>
<p>Legend label if a <code>color_var</code> is used.</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.interactive">.interactive</code></td>
<td>
<p>Returns either a static (<code>ggplot2</code>) visualization or an interactive (<code>plotly</code>) visualization</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.plotly_slider">.plotly_slider</code></td>
<td>
<p>If <code>TRUE</code>, returns a plotly date range slider.</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.trelliscope">.trelliscope</code></td>
<td>
<p>Returns either a normal plot or a trelliscopejs plot (great for many time series)
Must have <code>trelliscopejs</code> installed.</p>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_.trelliscope_params">.trelliscope_params</code></td>
<td>
<p>Pass parameters to the <code>trelliscopejs::facet_trelliscope()</code> function as a <code>list()</code>.
The only parameters that cannot be passed are:
</p>

<ul>
<li> <p><code>ncol</code>: use <code>.facet_ncol</code>
</p>
</li>
<li> <p><code>nrow</code>: use <code>.facet_nrow</code>
</p>
</li>
<li> <p><code>scales</code>: use <code>facet_scales</code>
</p>
</li>
<li> <p><code>as_plotly</code>: use <code>.interactive</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_modeltime_forecast_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="timetk.html#topic+plot_time_series">timetk::plot_time_series()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A static <code>ggplot2</code> plot or an interactive <code>plotly</code> plot containing a forecast
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- FORECAST ----

models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits)) %&gt;%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = m750
    ) %&gt;%
    plot_modeltime_forecast(.interactive = FALSE)

</code></pre>

<hr>
<h2 id='plot_modeltime_residuals'>Interactive Residuals Visualization</h2><span id='topic+plot_modeltime_residuals'></span>

<h3>Description</h3>

<p>This is a wrapper for examining residuals using:
</p>

<ul>
<li><p> Time Plot: <code>plot_time_series()</code>
</p>
</li>
<li><p> ACF Plot: <code>plot_acf_diagnostics()</code>
</p>
</li>
<li><p> Seasonality Plot: <code>plot_seasonal_diagnostics()</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plot_modeltime_residuals(
  .data,
  .type = c("timeplot", "acf", "seasonality"),
  .smooth = FALSE,
  .legend_show = TRUE,
  .legend_max_width = 40,
  .title = "Residuals Plot",
  .x_lab = "",
  .y_lab = "",
  .color_lab = "Legend",
  .interactive = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_modeltime_residuals_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> that is the output of <code><a href="#topic+modeltime_residuals">modeltime_residuals()</a></code></p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.type">.type</code></td>
<td>
<p>One of &quot;timeplot&quot;, &quot;acf&quot;, or &quot;seasonality&quot;. The default is &quot;timeplot&quot;.</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.smooth">.smooth</code></td>
<td>
<p>Logical - Whether or not to include a trendline smoother.
Uses See <code><a href="timetk.html#topic+smooth_vec">smooth_vec()</a></code> to apply a LOESS smoother.</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.legend_show">.legend_show</code></td>
<td>
<p>Logical. Whether or not to show the legend.
Can save space with long model descriptions.</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.legend_max_width">.legend_max_width</code></td>
<td>
<p>Numeric. The width of truncation to apply to the legend text.</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.title">.title</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.x_lab">.x_lab</code></td>
<td>
<p>X-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Y-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.color_lab">.color_lab</code></td>
<td>
<p>Legend label if a <code>color_var</code> is used.</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_.interactive">.interactive</code></td>
<td>
<p>Returns either a static (<code>ggplot2</code>) visualization or an interactive (<code>plotly</code>) visualization</p>
</td></tr>
<tr><td><code id="plot_modeltime_residuals_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to:
</p>

<ul>
<li><p> Time Plot: <code>plot_time_series()</code>
</p>
</li>
<li><p> ACF Plot: <code>plot_acf_diagnostics()</code>
</p>
</li>
<li><p> Seasonality Plot: <code>plot_seasonal_diagnostics()</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A static <code>ggplot2</code> plot or an interactive <code>plotly</code> plot containing residuals vs time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- RESIDUALS ----

residuals_tbl &lt;- models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits)) %&gt;%
    modeltime_residuals()

residuals_tbl %&gt;%
    plot_modeltime_residuals(
        .type = "timeplot",
        .interactive = FALSE
    )

</code></pre>

<hr>
<h2 id='pluck_modeltime_model'>Extract model by model id in a Modeltime Table</h2><span id='topic+pluck_modeltime_model'></span><span id='topic+pluck_modeltime_model.mdl_time_tbl'></span><span id='topic+pull_modeltime_model'></span>

<h3>Description</h3>

<p>The <code>pull_modeltime_model()</code> and <code>pluck_modeltime_model()</code> functions are synonymns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pluck_modeltime_model(object, .model_id)

## S3 method for class 'mdl_time_tbl'
pluck_modeltime_model(object, .model_id)

pull_modeltime_model(object, .model_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pluck_modeltime_model_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="pluck_modeltime_model_+3A_.model_id">.model_id</code></td>
<td>
<p>A numeric value matching the .model_id that you want to update</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+combine_modeltime_tables">combine_modeltime_tables()</a></code>: Combine 2 or more Modeltime Tables together
</p>
</li>
<li> <p><code><a href="#topic+add_modeltime_model">add_modeltime_model()</a></code>: Adds a new row with a new model to a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+drop_modeltime_model">drop_modeltime_model()</a></code>: Drop one or more models from a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_description">update_modeltime_description()</a></code>: Updates a description for a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_model">update_modeltime_model()</a></code>: Updates a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+pull_modeltime_model">pull_modeltime_model()</a></code>: Extracts a model from a Modeltime Table
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
m750_models %&gt;%
    pluck_modeltime_model(2)

</code></pre>

<hr>
<h2 id='prep_nested'>Prepared Nested Modeltime Data</h2><span id='topic+prep_nested'></span><span id='topic+extend_timeseries'></span><span id='topic+nest_timeseries'></span><span id='topic+split_nested_timeseries'></span>

<h3>Description</h3>

<p>A set of functions to simplify preparation of nested data for
iterative (nested) forecasting with Nested Modeltime Tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_timeseries(.data, .id_var, .date_var, .length_future, ...)

nest_timeseries(.data, .id_var, .length_future, .length_actual = NULL)

split_nested_timeseries(.data, .length_test, .length_train = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_nested_+3A_.data">.data</code></td>
<td>
<p>A data frame or tibble containing time series data. The data should have:
</p>

<ul>
<li><p> identifier (.id_var): Identifying one or more time series groups
</p>
</li>
<li><p> date variable (.date_var): A date or date time column
</p>
</li>
<li><p> target variable (.value): A column containing numeric values that is to be forecasted
</p>
</li></ul>
</td></tr>
<tr><td><code id="prep_nested_+3A_.id_var">.id_var</code></td>
<td>
<p>An id column</p>
</td></tr>
<tr><td><code id="prep_nested_+3A_.date_var">.date_var</code></td>
<td>
<p>A date or datetime column</p>
</td></tr>
<tr><td><code id="prep_nested_+3A_.length_future">.length_future</code></td>
<td>
<p>Varies based on the function:
</p>

<ul>
<li> <p><code>extend_timeseries()</code>: Defines how far into the future to extend the
time series by each time series group.
</p>
</li>
<li> <p><code>nest_timeseries()</code>: Defines which observations should be split into the <code>.future_data</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="prep_nested_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the helper function. See details.</p>
</td></tr>
<tr><td><code id="prep_nested_+3A_.length_actual">.length_actual</code></td>
<td>
<p>Can be used to slice the <code>.actual_data</code> to a most recent number of observations.</p>
</td></tr>
<tr><td><code id="prep_nested_+3A_.length_test">.length_test</code></td>
<td>
<p>Defines the length of the test split for evaluation.</p>
</td></tr>
<tr><td><code id="prep_nested_+3A_.length_train">.length_train</code></td>
<td>
<p>Defines the length of the training split for evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preparation of nested time series follows a 3-Step Process:
</p>


<h4>Step 1: Extend the Time Series</h4>

<p><code>extend_timeseries()</code>: A wrapper for <code><a href="timetk.html#topic+future_frame">timetk::future_frame()</a></code> that extends a time series
group-wise into the future.
</p>

<ul>
<li><p> The group column is specified by <code>.id_var</code>.
</p>
</li>
<li><p> The date column is specified by <code>.date_var</code>.
</p>
</li>
<li><p> The length into the future is specified with <code>.length_future</code>.
</p>
</li>
<li><p> The <code>...</code> are additional parameters that can be passed to <code><a href="timetk.html#topic+future_frame">timetk::future_frame()</a></code>
</p>
</li></ul>




<h4>Step 2: Nest the Time Series</h4>

<p><code>nest_timeseries()</code>: A helper for nesting your data into <code>.actual_data</code> and <code>.future_data</code>.
</p>

<ul>
<li><p> The group column is specified by <code>.id_var</code>
</p>
</li>
<li><p> The <code>.length_future</code> defines the length of the <code>.future_data</code>.
</p>
</li>
<li><p> The remaining data is converted to the <code>.actual_data</code>.
</p>
</li>
<li><p> The <code>.length_actual</code> can be used to slice the <code>.actual_data</code> to a most recent number of observations.
</p>
</li></ul>

<p>The result is a &quot;nested data frame&quot;.
</p>



<h4>Step 3: Split the Actual Data into Train/Test Splits</h4>

<p><code>split_nested_timeseries()</code>: A wrapper for <code><a href="timetk.html#topic+time_series_split">timetk::time_series_split()</a></code> that generates
training/testing splits from the <code>.actual_data</code> column.
</p>

<ul>
<li><p> The <code>.length_test</code> is the primary argument that identifies the size of the
testing sample. This is typically the same size as the <code>.future_data</code>.
</p>
</li>
<li><p> The <code>.length_train</code> is an optional size of the training data.
</p>
</li>
<li><p> The <code>...</code> (dots) are additional arguments that can be passed to <code><a href="timetk.html#topic+time_series_split">timetk::time_series_split()</a></code>.
</p>
</li></ul>




<h4>Helpers</h4>

<p><code><a href="#topic+extract_nested_train_split">extract_nested_train_split()</a></code> and <code><a href="#topic+extract_nested_test_split">extract_nested_test_split()</a></code> are used to simplify extracting
the training and testing data from the actual data. This can be helpful when making
preprocessing recipes using the <code>recipes</code> package.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(timetk)
library(modeltime)


nested_data_tbl &lt;- walmart_sales_weekly %&gt;%
    select(id, Date, Weekly_Sales) %&gt;%
    set_names(c("id", "date", "value")) %&gt;%

    # Step 1: Extends the time series by id
    extend_timeseries(
        .id_var     = id,
        .date_var   = date,
        .length_future = 52
    ) %&gt;%

    # Step 2: Nests the time series into .actual_data and .future_data
    nest_timeseries(
        .id_var     = id,
        .length_future = 52
    ) %&gt;%

    # Step 3: Adds a column .splits that contains training/testing indicies
    split_nested_timeseries(
        .length_test = 52
    )

nested_data_tbl

# Helpers: Getting the Train/Test Sets
extract_nested_train_split(nested_data_tbl, .row_id = 1)

</code></pre>

<hr>
<h2 id='prophet_boost'>General Interface for Boosted PROPHET Time Series Models</h2><span id='topic+prophet_boost'></span>

<h3>Description</h3>

<p><code>prophet_boost()</code> is a way to generate a <em>specification</em> of a Boosted PROPHET model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>prophet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_boost(
  mode = "regression",
  growth = NULL,
  changepoint_num = NULL,
  changepoint_range = NULL,
  seasonality_yearly = NULL,
  seasonality_weekly = NULL,
  seasonality_daily = NULL,
  season = NULL,
  prior_scale_changepoints = NULL,
  prior_scale_seasonality = NULL,
  prior_scale_holidays = NULL,
  logistic_cap = NULL,
  logistic_floor = NULL,
  mtry = NULL,
  trees = NULL,
  min_n = NULL,
  tree_depth = NULL,
  learn_rate = NULL,
  loss_reduction = NULL,
  sample_size = NULL,
  stop_iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_boost_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_growth">growth</code></td>
<td>
<p>String 'linear' or 'logistic' to specify a linear or logistic trend.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_changepoint_num">changepoint_num</code></td>
<td>
<p>Number of potential changepoints to include for modeling trend.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_changepoint_range">changepoint_range</code></td>
<td>
<p>Adjusts the flexibility of the trend component by limiting to a percentage of data
before the end of the time series. 0.80 means that a changepoint cannot exist after the first 80% of the data.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_seasonality_yearly">seasonality_yearly</code></td>
<td>
<p>One of &quot;auto&quot;, TRUE or FALSE. Toggles on/off a seasonal component that
models year-over-year seasonality.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_seasonality_weekly">seasonality_weekly</code></td>
<td>
<p>One of &quot;auto&quot;, TRUE or FALSE. Toggles on/off a seasonal component that
models week-over-week seasonality.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_seasonality_daily">seasonality_daily</code></td>
<td>
<p>One of &quot;auto&quot;, TRUE or FALSE. Toggles on/off a seasonal componet that
models day-over-day seasonality.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_season">season</code></td>
<td>
<p>'additive' (default) or 'multiplicative'.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_prior_scale_changepoints">prior_scale_changepoints</code></td>
<td>
<p>Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_prior_scale_seasonality">prior_scale_seasonality</code></td>
<td>
<p>Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_prior_scale_holidays">prior_scale_holidays</code></td>
<td>
<p>Parameter modulating the strength of the holiday components model,
unless overridden in the holidays input.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_logistic_cap">logistic_cap</code></td>
<td>
<p>When growth is logistic, the upper-bound for &quot;saturation&quot;.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_logistic_floor">logistic_floor</code></td>
<td>
<p>When growth is logistic, the lower-bound for &quot;saturation&quot;.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_mtry">mtry</code></td>
<td>
<p>A number for the number (or proportion) of predictors that will
be randomly sampled at each split when creating the tree models
(specific engines only)</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_trees">trees</code></td>
<td>
<p>An integer for the number of trees contained in
the ensemble.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_min_n">min_n</code></td>
<td>
<p>An integer for the minimum number of data points
in a node that is required for the node to be split further.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_tree_depth">tree_depth</code></td>
<td>
<p>An integer for the maximum depth of the tree (i.e. number
of splits) (specific engines only).</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_learn_rate">learn_rate</code></td>
<td>
<p>A number for the rate at which the boosting algorithm adapts
from iteration-to-iteration (specific engines only). This is sometimes referred to
as the shrinkage parameter.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_loss_reduction">loss_reduction</code></td>
<td>
<p>A number for the reduction in the loss function required
to split further (specific engines only).</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_sample_size">sample_size</code></td>
<td>
<p>number for the number (or proportion) of data that is exposed to the fitting routine.</p>
</td></tr>
<tr><td><code id="prophet_boost_+3A_stop_iter">stop_iter</code></td>
<td>
<p>The number of iterations without improvement before
stopping  (<code>xgboost</code> only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>prophet_boost()</code>, the
mode will always be &quot;regression&quot;.
</p>
<p>The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li><p> &quot;prophet_xgboost&quot; (default) - Connects to <code><a href="prophet.html#topic+prophet">prophet::prophet()</a></code> and <code><a href="xgboost.html#topic+xgb.train">xgboost::xgb.train()</a></code>
</p>
</li></ul>

<p><strong>Main Arguments</strong>
</p>
<p>The main arguments (tuning parameters) for the <strong>PROPHET</strong> model are:
</p>

<ul>
<li> <p><code>growth</code>: String 'linear' or 'logistic' to specify a linear or logistic trend.
</p>
</li>
<li> <p><code>changepoint_num</code>: Number of potential changepoints to include for modeling trend.
</p>
</li>
<li> <p><code>changepoint_range</code>: Range changepoints that adjusts how close to the end
the last changepoint can be located.
</p>
</li>
<li> <p><code>season</code>: 'additive' (default) or 'multiplicative'.
</p>
</li>
<li> <p><code>prior_scale_changepoints</code>: Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.
</p>
</li>
<li> <p><code>prior_scale_seasonality</code>: Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality.
</p>
</li>
<li> <p><code>prior_scale_holidays</code>: Parameter modulating the strength of the holiday components model,
unless overridden in the holidays input.
</p>
</li>
<li> <p><code>logistic_cap</code>: When growth is logistic, the upper-bound for &quot;saturation&quot;.
</p>
</li>
<li> <p><code>logistic_floor</code>: When growth is logistic, the lower-bound for &quot;saturation&quot;.
</p>
</li></ul>

<p>The main arguments (tuning parameters) for the model <strong>XGBoost model</strong> are:
</p>

<ul>
<li> <p><code>mtry</code>: The number of predictors that will be
randomly sampled at each split when creating the tree models.
</p>
</li>
<li> <p><code>trees</code>: The number of trees contained in the ensemble.
</p>
</li>
<li> <p><code>min_n</code>: The minimum number of data points in a node
that are required for the node to be split further.
</p>
</li>
<li> <p><code>tree_depth</code>: The maximum depth of the tree (i.e. number of
splits).
</p>
</li>
<li> <p><code>learn_rate</code>: The rate at which the boosting algorithm adapts
from iteration-to-iteration.
</p>
</li>
<li> <p><code>loss_reduction</code>: The reduction in the loss function required
to split further.
</p>
</li>
<li> <p><code>sample_size</code>: The amount of data exposed to the fitting routine.
</p>
</li>
<li> <p><code>stop_iter</code>: The number of iterations without improvement before
stopping.
</p>
</li></ul>

<p>These arguments are converted to their specific names at the
time that the model is fit.
</p>
<p>Other options and argument can be
set using <code>set_engine()</code> (See Engine Details below).
</p>
<p>If parameters need to be modified, <code>update()</code> can be used
in lieu of recreating the object from scratch.
</p>


<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:
</p>
<p>Model 1: PROPHET:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> prophet </td>
</tr>
<tr>
 <td style="text-align: left;">
   growth </td><td style="text-align: left;"> growth ('linear') </td>
</tr>
<tr>
 <td style="text-align: left;">
   changepoint_num </td><td style="text-align: left;"> n.changepoints (25) </td>
</tr>
<tr>
 <td style="text-align: left;">
   changepoint_range </td><td style="text-align: left;"> changepoints.range (0.8) </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonality_yearly </td><td style="text-align: left;"> yearly.seasonality ('auto') </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonality_weekly </td><td style="text-align: left;"> weekly.seasonality ('auto') </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonality_daily </td><td style="text-align: left;"> daily.seasonality ('auto') </td>
</tr>
<tr>
 <td style="text-align: left;">
   season </td><td style="text-align: left;"> seasonality.mode ('additive') </td>
</tr>
<tr>
 <td style="text-align: left;">
   prior_scale_changepoints </td><td style="text-align: left;"> changepoint.prior.scale (0.05) </td>
</tr>
<tr>
 <td style="text-align: left;">
   prior_scale_seasonality </td><td style="text-align: left;"> seasonality.prior.scale (10) </td>
</tr>
<tr>
 <td style="text-align: left;">
   prior_scale_holidays </td><td style="text-align: left;"> holidays.prior.scale (10) </td>
</tr>
<tr>
 <td style="text-align: left;">
   logistic_cap </td><td style="text-align: left;"> df$cap (NULL) </td>
</tr>
<tr>
 <td style="text-align: left;">
   logistic_floor </td><td style="text-align: left;"> df$floor (NULL) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Model 2: XGBoost:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> xgboost::xgb.train </td>
</tr>
<tr>
 <td style="text-align: left;">
   tree_depth </td><td style="text-align: left;"> max_depth (6) </td>
</tr>
<tr>
 <td style="text-align: left;">
   trees </td><td style="text-align: left;"> nrounds (15) </td>
</tr>
<tr>
 <td style="text-align: left;">
   learn_rate </td><td style="text-align: left;"> eta (0.3) </td>
</tr>
<tr>
 <td style="text-align: left;">
   mtry </td><td style="text-align: left;"> colsample_bynode (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
   min_n </td><td style="text-align: left;"> min_child_weight (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
   loss_reduction </td><td style="text-align: left;"> gamma (0) </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_size </td><td style="text-align: left;"> subsample (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
   stop_iter </td><td style="text-align: left;"> early_stop </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other options can be set using <code>set_engine()</code>.
</p>
<p><strong>prophet_xgboost</strong>
</p>
<p>Model 1: PROPHET (<code>prophet::prophet</code>):
</p>
<div class="sourceCode"><pre>#&gt; function (df = NULL, growth = "linear", changepoints = NULL, n.changepoints = 25, 
#&gt;     changepoint.range = 0.8, yearly.seasonality = "auto", weekly.seasonality = "auto", 
#&gt;     daily.seasonality = "auto", holidays = NULL, seasonality.mode = "additive", 
#&gt;     seasonality.prior.scale = 10, holidays.prior.scale = 10, changepoint.prior.scale = 0.05, 
#&gt;     mcmc.samples = 0, interval.width = 0.8, uncertainty.samples = 1000, 
#&gt;     fit = TRUE, ...)
</pre></div>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>df</code>: This is supplied via the parsnip / modeltime <code>fit()</code> interface
(so don't provide this manually). See Fit Details (below).
</p>
</li>
<li> <p><code>holidays</code>: A data.frame of holidays can be supplied via <code>set_engine()</code>
</p>
</li>
<li> <p><code>uncertainty.samples</code>: The default is set to 0 because the prophet
uncertainty intervals are not used as part of the Modeltime Workflow.
You can override this setting if you plan to use prophet's uncertainty tools.
</p>
</li></ul>

<p>Logistic Growth and Saturation Levels:
</p>

<ul>
<li><p> For <code>growth = "logistic"</code>, simply add numeric values for <code>logistic_cap</code> and / or
<code>logistic_floor</code>. There is <em>no need</em> to add additional columns
for &quot;cap&quot; and &quot;floor&quot; to your data frame.
</p>
</li></ul>

<p>Limitations:
</p>

<ul>
<li> <p><code>prophet::add_seasonality()</code> is not currently implemented. It's used to
specify non-standard seasonalities using fourier series. An alternative is to use
<code>step_fourier()</code> and supply custom seasonalities as Extra Regressors.
</p>
</li></ul>

<p>Model 2: XGBoost (<code>xgboost::xgb.train</code>):
</p>
<div class="sourceCode"><pre>#&gt; function (params = list(), data, nrounds, watchlist = list(), obj = NULL, 
#&gt;     feval = NULL, verbose = 1, print_every_n = 1L, early_stopping_rounds = NULL, 
#&gt;     maximize = NULL, save_period = NULL, save_name = "xgboost.model", xgb_model = NULL, 
#&gt;     callbacks = list(), ...)
</pre></div>
<p>Parameter Notes:
</p>

<ul>
<li><p> XGBoost uses a <code>params = list()</code> to capture.
Parsnip / Modeltime automatically sends any args provided as <code>...</code> inside of <code>set_engine()</code> to
the <code>params = list(...)</code>.
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><strong>Univariate (No Extra Regressors):</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li><p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (Extra Regressors)</strong>
</p>
<p>Extra Regressors parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>

<ul>
<li><p> Only <code>factor</code>, <code style="white-space: pre;">&#8288;ordered factor&#8288;</code>, and <code>numeric</code> data will be used as xregs.
</p>
</li>
<li><p> Date and Date-time variables are not used as xregs
</p>
</li>
<li> <p><code>character</code> data should be converted to factor.
</p>
</li></ul>

<p><em>Xreg Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>month.lbl</code> (labeled month as a ordered factor).
</p>
</li></ol>

<p>The <code>month.lbl</code> is an exogenous regressor that can be passed to the <code>arima_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>fit(y ~ date + month.lbl)</code> will pass <code>month.lbl</code> on as an exogenous regressor.
</p>
</li>
<li> <p><code>fit_xy(data[,c("date", "month.lbl")], y = data$y)</code> will pass x, where x is a data frame containing <code>month.lbl</code>
and the <code>date</code> feature. Only <code>month.lbl</code> will be used as an exogenous regressor.
</p>
</li></ul>

<p>Note that date or date-time class values are excluded from <code>xreg</code>.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lubridate)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- PROPHET ----

# Model Spec
model_spec &lt;- prophet_boost(
    learn_rate = 0.1
) %&gt;%
    set_engine("prophet_xgboost")

# Fit Spec

model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date + as.numeric(date) + month(date, label = TRUE),
        data = training(splits))
model_fit




</code></pre>

<hr>
<h2 id='prophet_fit_impl'>Low-Level PROPHET function for translating modeltime to PROPHET</h2><span id='topic+prophet_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level PROPHET function for translating modeltime to PROPHET
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_fit_impl(
  x,
  y,
  growth = "linear",
  n.changepoints = 25,
  changepoint.range = 0.8,
  yearly.seasonality = "auto",
  weekly.seasonality = "auto",
  daily.seasonality = "auto",
  seasonality.mode = "additive",
  changepoint.prior.scale = 0.05,
  seasonality.prior.scale = 10,
  holidays.prior.scale = 10,
  regressors.prior.scale = 10000,
  regressors.standardize = "auto",
  regressors.mode = NULL,
  logistic_cap = NULL,
  logistic_floor = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_growth">growth</code></td>
<td>
<p>String 'linear', 'logistic', or 'flat' to specify a linear, logistic
or flat trend.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_n.changepoints">n.changepoints</code></td>
<td>
<p>Number of potential changepoints to include. Not used
if input 'changepoints' is supplied. If 'changepoints' is not supplied,
then n.changepoints potential changepoints are selected uniformly from the
first 'changepoint.range' proportion of df$ds.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_changepoint.range">changepoint.range</code></td>
<td>
<p>Proportion of history in which trend changepoints
will be estimated. Defaults to 0.8 for the first 80
'changepoints' is specified.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_yearly.seasonality">yearly.seasonality</code></td>
<td>
<p>Fit yearly seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_weekly.seasonality">weekly.seasonality</code></td>
<td>
<p>Fit weekly seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_daily.seasonality">daily.seasonality</code></td>
<td>
<p>Fit daily seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_seasonality.mode">seasonality.mode</code></td>
<td>
<p>'additive' (default) or 'multiplicative'.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_changepoint.prior.scale">changepoint.prior.scale</code></td>
<td>
<p>Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_seasonality.prior.scale">seasonality.prior.scale</code></td>
<td>
<p>Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality. Can be specified for
individual seasonalities using add_seasonality.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_holidays.prior.scale">holidays.prior.scale</code></td>
<td>
<p>Parameter modulating the strength of the holiday
components model, unless overridden in the holidays input.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_regressors.prior.scale">regressors.prior.scale</code></td>
<td>
<p>Float scale for the normal prior.
Default is 10,000.
Gets passed to <code>prophet::add_regressor(prior.scale)</code></p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_regressors.standardize">regressors.standardize</code></td>
<td>
<p>Bool, specify whether this regressor will be
standardized prior to fitting.
Can be 'auto' (standardize if not binary), True, or False.
Gets passed to <code>prophet::add_regressor(standardize)</code>.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_regressors.mode">regressors.mode</code></td>
<td>
<p>Optional, 'additive' or 'multiplicative'.
Defaults to <code>seasonality.mode</code>.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_logistic_cap">logistic_cap</code></td>
<td>
<p>When growth is logistic, the upper-bound for &quot;saturation&quot;.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_logistic_floor">logistic_floor</code></td>
<td>
<p>When growth is logistic, the lower-bound for &quot;saturation&quot;.</p>
</td></tr>
<tr><td><code id="prophet_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>prophet::prophet</code></p>
</td></tr>
</table>

<hr>
<h2 id='prophet_params'>Tuning Parameters for Prophet Models</h2><span id='topic+prophet_params'></span><span id='topic+growth'></span><span id='topic+changepoint_num'></span><span id='topic+changepoint_range'></span><span id='topic+seasonality_yearly'></span><span id='topic+seasonality_weekly'></span><span id='topic+seasonality_daily'></span><span id='topic+prior_scale_changepoints'></span><span id='topic+prior_scale_seasonality'></span><span id='topic+prior_scale_holidays'></span>

<h3>Description</h3>

<p>Tuning Parameters for Prophet Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth(values = c("linear", "logistic"))

changepoint_num(range = c(0L, 50L), trans = NULL)

changepoint_range(range = c(0.6, 0.9), trans = NULL)

seasonality_yearly(values = c(TRUE, FALSE))

seasonality_weekly(values = c(TRUE, FALSE))

seasonality_daily(values = c(TRUE, FALSE))

prior_scale_changepoints(range = c(-3, 2), trans = log10_trans())

prior_scale_seasonality(range = c(-3, 2), trans = log10_trans())

prior_scale_holidays(range = c(-3, 2), trans = log10_trans())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_params_+3A_values">values</code></td>
<td>
<p>A character string of possible values.</p>
</td></tr>
<tr><td><code id="prophet_params_+3A_range">range</code></td>
<td>
<p>A two-element vector holding the <em>defaults</em> for the smallest and
largest possible values, respectively. If a transformation is specified,
these values should be in the <em>transformed units</em>.</p>
</td></tr>
<tr><td><code id="prophet_params_+3A_trans">trans</code></td>
<td>
<p>A <code>trans</code> object from the <code>scales</code> package, such as
<code>scales::log10_trans()</code> or <code>scales::reciprocal_trans()</code>. If not provided,
the default is used which matches the units used in <code>range</code>. If no
transformation, <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main parameters for Prophet models are:
</p>

<ul>
<li> <p><code>growth</code>: The form of the trend: &quot;linear&quot;, or &quot;logistic&quot;.
</p>
</li>
<li> <p><code>changepoint_num</code>: The maximum number of trend changepoints allowed when modeling the trend
</p>
</li>
<li> <p><code>changepoint_range</code>: The range affects how close the changepoints can go to the end of the time series.
The larger the value, the more flexible the trend.
</p>
</li>
<li><p> Yearly, Weekly, and Daily Seasonality:
</p>

<ul>
<li> <p><em>Yearly</em>: <code>seasonality_yearly</code> - Useful when seasonal patterns appear year-over-year
</p>
</li>
<li> <p><em>Weekly</em>: <code>seasonality_weekly</code> - Useful when seasonal patterns appear week-over-week (e.g. daily data)
</p>
</li>
<li> <p><em>Daily</em>: <code>seasonality_daily</code> - Useful when seasonal patterns appear day-over-day (e.g. hourly data)
</p>
</li></ul>

</li>
<li> <p><code>season</code>:
</p>

<ul>
<li><p> The form of the seasonal term: &quot;additive&quot; or &quot;multiplicative&quot;.
</p>
</li>
<li><p> See <code><a href="#topic+season">season()</a></code>.
</p>
</li></ul>

</li>
<li><p> &quot;Prior Scale&quot;: Controls flexibility of
</p>

<ul>
<li> <p><em>Changepoints:</em> <code>prior_scale_changepoints</code>
</p>
</li>
<li> <p><em>Seasonality:</em> <code>prior_scale_seasonality</code>
</p>
</li>
<li> <p><em>Holidays:</em> <code>prior_scale_holidays</code>
</p>
</li>
<li><p> The <code>log10_trans()</code> converts priors to a scale from 0.001 to 100,
which effectively weights lower values more heavily than larger values.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
growth()

changepoint_num()

season()

prior_scale_changepoints()

</code></pre>

<hr>
<h2 id='prophet_predict_impl'>Bridge prediction function for PROPHET models</h2><span id='topic+prophet_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for PROPHET models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="prophet_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="prophet_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>prophet::predict()</code></p>
</td></tr>
</table>

<hr>
<h2 id='prophet_reg'>General Interface for PROPHET Time Series Models</h2><span id='topic+prophet_reg'></span>

<h3>Description</h3>

<p><code>prophet_reg()</code> is a way to generate a <em>specification</em> of a PROPHET model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>prophet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_reg(
  mode = "regression",
  growth = NULL,
  changepoint_num = NULL,
  changepoint_range = NULL,
  seasonality_yearly = NULL,
  seasonality_weekly = NULL,
  seasonality_daily = NULL,
  season = NULL,
  prior_scale_changepoints = NULL,
  prior_scale_seasonality = NULL,
  prior_scale_holidays = NULL,
  logistic_cap = NULL,
  logistic_floor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_reg_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_growth">growth</code></td>
<td>
<p>String 'linear' or 'logistic' to specify a linear or logistic trend.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_changepoint_num">changepoint_num</code></td>
<td>
<p>Number of potential changepoints to include for modeling trend.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_changepoint_range">changepoint_range</code></td>
<td>
<p>Adjusts the flexibility of the trend component by limiting to a percentage of data
before the end of the time series. 0.80 means that a changepoint cannot exist after the first 80% of the data.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_seasonality_yearly">seasonality_yearly</code></td>
<td>
<p>One of &quot;auto&quot;, TRUE or FALSE. Toggles on/off a seasonal component that
models year-over-year seasonality.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_seasonality_weekly">seasonality_weekly</code></td>
<td>
<p>One of &quot;auto&quot;, TRUE or FALSE. Toggles on/off a seasonal component that
models week-over-week seasonality.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_seasonality_daily">seasonality_daily</code></td>
<td>
<p>One of &quot;auto&quot;, TRUE or FALSE. Toggles on/off a seasonal componet that
models day-over-day seasonality.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_season">season</code></td>
<td>
<p>'additive' (default) or 'multiplicative'.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_prior_scale_changepoints">prior_scale_changepoints</code></td>
<td>
<p>Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_prior_scale_seasonality">prior_scale_seasonality</code></td>
<td>
<p>Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_prior_scale_holidays">prior_scale_holidays</code></td>
<td>
<p>Parameter modulating the strength of the holiday components model,
unless overridden in the holidays input.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_logistic_cap">logistic_cap</code></td>
<td>
<p>When growth is logistic, the upper-bound for &quot;saturation&quot;.</p>
</td></tr>
<tr><td><code id="prophet_reg_+3A_logistic_floor">logistic_floor</code></td>
<td>
<p>When growth is logistic, the lower-bound for &quot;saturation&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>prophet_reg()</code>, the
mode will always be &quot;regression&quot;.
</p>
<p>The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li><p> &quot;prophet&quot; (default) - Connects to <code><a href="prophet.html#topic+prophet">prophet::prophet()</a></code>
</p>
</li></ul>

<p><strong>Main Arguments</strong>
</p>
<p>The main arguments (tuning parameters) for the model are:
</p>

<ul>
<li> <p><code>growth</code>: String 'linear' or 'logistic' to specify a linear or logistic trend.
</p>
</li>
<li> <p><code>changepoint_num</code>: Number of potential changepoints to include for modeling trend.
</p>
</li>
<li> <p><code>changepoint_range</code>: Range changepoints that adjusts how close to the end
the last changepoint can be located.
</p>
</li>
<li> <p><code>season</code>: 'additive' (default) or 'multiplicative'.
</p>
</li>
<li> <p><code>prior_scale_changepoints</code>: Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.
</p>
</li>
<li> <p><code>prior_scale_seasonality</code>: Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality.
</p>
</li>
<li> <p><code>prior_scale_holidays</code>: Parameter modulating the strength of the holiday components model,
unless overridden in the holidays input.
</p>
</li>
<li> <p><code>logistic_cap</code>: When growth is logistic, the upper-bound for &quot;saturation&quot;.
</p>
</li>
<li> <p><code>logistic_floor</code>: When growth is logistic, the lower-bound for &quot;saturation&quot;.
</p>
</li></ul>

<p>These arguments are converted to their specific names at the
time that the model is fit.
</p>
<p>Other options and argument can be
set using <code>set_engine()</code> (See Engine Details below).
</p>
<p>If parameters need to be modified, <code>update()</code> can be used
in lieu of recreating the object from scratch.
</p>


<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> prophet </td>
</tr>
<tr>
 <td style="text-align: left;">
   growth </td><td style="text-align: left;"> growth ('linear') </td>
</tr>
<tr>
 <td style="text-align: left;">
   changepoint_num </td><td style="text-align: left;"> n.changepoints (25) </td>
</tr>
<tr>
 <td style="text-align: left;">
   changepoint_range </td><td style="text-align: left;"> changepoints.range (0.8) </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonality_yearly </td><td style="text-align: left;"> yearly.seasonality ('auto') </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonality_weekly </td><td style="text-align: left;"> weekly.seasonality ('auto') </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonality_daily </td><td style="text-align: left;"> daily.seasonality ('auto') </td>
</tr>
<tr>
 <td style="text-align: left;">
   season </td><td style="text-align: left;"> seasonality.mode ('additive') </td>
</tr>
<tr>
 <td style="text-align: left;">
   prior_scale_changepoints </td><td style="text-align: left;"> changepoint.prior.scale (0.05) </td>
</tr>
<tr>
 <td style="text-align: left;">
   prior_scale_seasonality </td><td style="text-align: left;"> seasonality.prior.scale (10) </td>
</tr>
<tr>
 <td style="text-align: left;">
   prior_scale_holidays </td><td style="text-align: left;"> holidays.prior.scale (10) </td>
</tr>
<tr>
 <td style="text-align: left;">
   logistic_cap </td><td style="text-align: left;"> df$cap (NULL) </td>
</tr>
<tr>
 <td style="text-align: left;">
   logistic_floor </td><td style="text-align: left;"> df$floor (NULL) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other options can be set using <code>set_engine()</code>.
</p>
<p><strong>prophet</strong>
</p>
<p>The engine uses <code><a href="prophet.html#topic+prophet">prophet::prophet()</a></code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (df = NULL, growth = "linear", changepoints = NULL, n.changepoints = 25, 
#&gt;     changepoint.range = 0.8, yearly.seasonality = "auto", weekly.seasonality = "auto", 
#&gt;     daily.seasonality = "auto", holidays = NULL, seasonality.mode = "additive", 
#&gt;     seasonality.prior.scale = 10, holidays.prior.scale = 10, changepoint.prior.scale = 0.05, 
#&gt;     mcmc.samples = 0, interval.width = 0.8, uncertainty.samples = 1000, 
#&gt;     fit = TRUE, ...)
</pre></div>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>df</code>: This is supplied via the parsnip / modeltime <code>fit()</code> interface
(so don't provide this manually). See Fit Details (below).
</p>
</li>
<li> <p><code>holidays</code>: A data.frame of holidays can be supplied via <code>set_engine()</code>
</p>
</li>
<li> <p><code>uncertainty.samples</code>: The default is set to 0 because the prophet
uncertainty intervals are not used as part of the Modeltime Workflow.
You can override this setting if you plan to use prophet's uncertainty tools.
</p>
</li></ul>

<p>Regressors:
</p>

<ul>
<li><p> Regressors are provided via the <code>fit()</code> or <code>recipes</code> interface, which passes
regressors to <code>prophet::add_regressor()</code>
</p>
</li>
<li><p> Parameters can be controlled in <code>set_engine()</code> via: <code>regressors.prior.scale</code>, <code>regressors.standardize</code>,
and <code>regressors.mode</code>
</p>
</li>
<li><p> The regressor prior scale implementation default is <code>regressors.prior.scale = 1e4</code>, which deviates from
the <code>prophet</code> implementation (defaults to holidays.prior.scale)
</p>
</li></ul>

<p>Logistic Growth and Saturation Levels:
</p>

<ul>
<li><p> For <code>growth = "logistic"</code>, simply add numeric values for <code>logistic_cap</code> and / or
<code>logistic_floor</code>. There is <em>no need</em> to add additional columns
for &quot;cap&quot; and &quot;floor&quot; to your data frame.
</p>
</li></ul>

<p>Limitations:
</p>

<ul>
<li> <p><code>prophet::add_seasonality()</code> is not currently implemented. It's used to
specify non-standard seasonalities using fourier series. An alternative is to use
<code>step_fourier()</code> and supply custom seasonalities as Extra Regressors.
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><strong>Univariate (No Extra Regressors):</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li><p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (Extra Regressors)</strong>
</p>
<p>Extra Regressors parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>

<ul>
<li><p> Only <code>factor</code>, <code style="white-space: pre;">&#8288;ordered factor&#8288;</code>, and <code>numeric</code> data will be used as xregs.
</p>
</li>
<li><p> Date and Date-time variables are not used as xregs
</p>
</li>
<li> <p><code>character</code> data should be converted to factor.
</p>
</li></ul>

<p><em>Xreg Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>month.lbl</code> (labeled month as a ordered factor).
</p>
</li></ol>

<p>The <code>month.lbl</code> is an exogenous regressor that can be passed to the <code>arima_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>fit(y ~ date + month.lbl)</code> will pass <code>month.lbl</code> on as an exogenous regressor.
</p>
</li>
<li> <p><code>fit_xy(data[,c("date", "month.lbl")], y = data$y)</code> will pass x, where x is a data frame containing <code>month.lbl</code>
and the <code>date</code> feature. Only <code>month.lbl</code> will be used as an exogenous regressor.
</p>
</li></ul>

<p>Note that date or date-time class values are excluded from <code>xreg</code>.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- PROPHET ----

# Model Spec
model_spec &lt;- prophet_reg() %&gt;%
    set_engine("prophet")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit


</code></pre>

<hr>
<h2 id='prophet_xgboost_fit_impl'>Low-Level PROPHET function for translating modeltime to Boosted PROPHET</h2><span id='topic+prophet_xgboost_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level PROPHET function for translating modeltime to Boosted PROPHET
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_xgboost_fit_impl(
  x,
  y,
  df = NULL,
  growth = "linear",
  changepoints = NULL,
  n.changepoints = 25,
  changepoint.range = 0.8,
  yearly.seasonality = "auto",
  weekly.seasonality = "auto",
  daily.seasonality = "auto",
  holidays = NULL,
  seasonality.mode = "additive",
  seasonality.prior.scale = 10,
  holidays.prior.scale = 10,
  changepoint.prior.scale = 0.05,
  logistic_cap = NULL,
  logistic_floor = NULL,
  mcmc.samples = 0,
  interval.width = 0.8,
  uncertainty.samples = 1000,
  fit = TRUE,
  max_depth = 6,
  nrounds = 15,
  eta = 0.3,
  colsample_bytree = NULL,
  colsample_bynode = NULL,
  min_child_weight = 1,
  gamma = 0,
  subsample = 1,
  validation = 0,
  early_stop = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_df">df</code></td>
<td>
<p>(optional) Dataframe containing the history. Must have columns ds
(date type) and y, the time series. If growth is logistic, then df must
also have a column cap that specifies the capacity at each ds. If not
provided, then the model object will be instantiated but not fit; use
fit.prophet(m, df) to fit the model.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_growth">growth</code></td>
<td>
<p>String 'linear', 'logistic', or 'flat' to specify a linear, logistic
or flat trend.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_changepoints">changepoints</code></td>
<td>
<p>Vector of dates at which to include potential
changepoints. If not specified, potential changepoints are selected
automatically.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_n.changepoints">n.changepoints</code></td>
<td>
<p>Number of potential changepoints to include. Not used
if input 'changepoints' is supplied. If 'changepoints' is not supplied,
then n.changepoints potential changepoints are selected uniformly from the
first 'changepoint.range' proportion of df$ds.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_changepoint.range">changepoint.range</code></td>
<td>
<p>Proportion of history in which trend changepoints
will be estimated. Defaults to 0.8 for the first 80
'changepoints' is specified.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_yearly.seasonality">yearly.seasonality</code></td>
<td>
<p>Fit yearly seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_weekly.seasonality">weekly.seasonality</code></td>
<td>
<p>Fit weekly seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_daily.seasonality">daily.seasonality</code></td>
<td>
<p>Fit daily seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_holidays">holidays</code></td>
<td>
<p>data frame with columns holiday (character) and ds (date
type)and optionally columns lower_window and upper_window which specify a
range of days around the date to be included as holidays. lower_window=-2
will include 2 days prior to the date as holidays. Also optionally can have
a column prior_scale specifying the prior scale for each holiday.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_seasonality.mode">seasonality.mode</code></td>
<td>
<p>'additive' (default) or 'multiplicative'.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_seasonality.prior.scale">seasonality.prior.scale</code></td>
<td>
<p>Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality. Can be specified for
individual seasonalities using add_seasonality.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_holidays.prior.scale">holidays.prior.scale</code></td>
<td>
<p>Parameter modulating the strength of the holiday
components model, unless overridden in the holidays input.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_changepoint.prior.scale">changepoint.prior.scale</code></td>
<td>
<p>Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_logistic_cap">logistic_cap</code></td>
<td>
<p>When growth is logistic, the upper-bound for &quot;saturation&quot;.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_logistic_floor">logistic_floor</code></td>
<td>
<p>When growth is logistic, the lower-bound for &quot;saturation&quot;.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_mcmc.samples">mcmc.samples</code></td>
<td>
<p>Integer, if greater than 0, will do full Bayesian
inference with the specified number of MCMC samples. If 0, will do MAP
estimation.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_interval.width">interval.width</code></td>
<td>
<p>Numeric, width of the uncertainty intervals provided
for the forecast. If mcmc.samples=0, this will be only the uncertainty
in the trend using the MAP estimate of the extrapolated generative model.
If mcmc.samples&gt;0, this will be integrated over all model parameters,
which will include uncertainty in seasonality.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_uncertainty.samples">uncertainty.samples</code></td>
<td>
<p>Number of simulated draws used to estimate
uncertainty intervals. Settings this value to 0 or False will disable
uncertainty estimation and speed up the calculation.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_fit">fit</code></td>
<td>
<p>Boolean, if FALSE the model is initialized but not fit.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_max_depth">max_depth</code></td>
<td>
<p>An integer for the maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_nrounds">nrounds</code></td>
<td>
<p>An integer for the number of boosting iterations.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_eta">eta</code></td>
<td>
<p>A numeric value between zero and one to control the learning rate.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsampling proportion of columns.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_colsample_bynode">colsample_bynode</code></td>
<td>
<p>Subsampling proportion of columns for each node
within each tree. See the <code>counts</code> argument below. The default uses all
columns.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_min_child_weight">min_child_weight</code></td>
<td>
<p>A numeric value for the minimum sum of instance
weights needed in a child to continue to split.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_gamma">gamma</code></td>
<td>
<p>A number for the minimum loss reduction required to make a
further partition on a leaf node of the tree</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_subsample">subsample</code></td>
<td>
<p>Subsampling proportion of rows.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_validation">validation</code></td>
<td>
<p>A positive number. If on <code style="white-space: pre;">&#8288;[0, 1)&#8288;</code> the value, <code>validation</code>
is a random proportion of data in <code>x</code> and <code>y</code> that are used for performance
assessment and potential early stopping. If 1 or greater, it is the <em>number</em>
of training set samples use for these purposes.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_early_stop">early_stop</code></td>
<td>
<p>An integer or <code>NULL</code>. If not <code>NULL</code>, it is the number of
training iterations without improvement before stopping. If <code>validation</code> is
used, performance is base on the validation set; otherwise the training set
is used.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>xgboost::xgb.train</code></p>
</td></tr>
</table>

<hr>
<h2 id='prophet_xgboost_predict_impl'>Bridge prediction function for Boosted PROPHET models</h2><span id='topic+prophet_xgboost_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for Boosted PROPHET models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_xgboost_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_xgboost_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="prophet_xgboost_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>prophet::predict()</code></p>
</td></tr>
</table>

<hr>
<h2 id='pull_modeltime_residuals'>Extracts modeltime residuals data from a Modeltime Model</h2><span id='topic+pull_modeltime_residuals'></span>

<h3>Description</h3>

<p>If a modeltime model contains <code>data</code> with residuals information,
this function will extract the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_modeltime_residuals(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_modeltime_residuals_+3A_object">object</code></td>
<td>
<p>A fitted <code>parsnip</code> / <code>modeltime</code> model or <code>workflow</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> containing the model timestamp, actual, fitted, and residuals data
</p>

<hr>
<h2 id='pull_parsnip_preprocessor'>Pulls the Formula from a Fitted Parsnip Model Object</h2><span id='topic+pull_parsnip_preprocessor'></span>

<h3>Description</h3>

<p>Pulls the Formula from a Fitted Parsnip Model Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_parsnip_preprocessor(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_parsnip_preprocessor_+3A_object">object</code></td>
<td>
<p>A fitted parsnip model <code>model_fit</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula using <code>stats::formula()</code>
</p>

<hr>
<h2 id='recipe_helpers'>Developer Tools for processing XREGS (Regressors)</h2><span id='topic+recipe_helpers'></span><span id='topic+juice_xreg_recipe'></span><span id='topic+bake_xreg_recipe'></span>

<h3>Description</h3>

<p>Wrappers for using <code>recipes::bake</code> and <code>recipes::juice</code> to process data
returning data in either <code style="white-space: pre;">&#8288;data frame&#8288;</code> or <code>matrix</code> format (Common formats needed
for machine learning algorithms).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juice_xreg_recipe(recipe, format = c("tbl", "matrix"))

bake_xreg_recipe(recipe, new_data, format = c("tbl", "matrix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recipe_helpers_+3A_recipe">recipe</code></td>
<td>
<p>A prepared recipe</p>
</td></tr>
<tr><td><code id="recipe_helpers_+3A_format">format</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>tbl</code>: Returns a tibble (data.frame)
</p>
</li>
<li> <p><code>matrix</code>: Returns a matrix
</p>
</li></ul>
</td></tr>
<tr><td><code id="recipe_helpers_+3A_new_data">new_data</code></td>
<td>
<p>Data to be processed by a recipe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data in either the <code>tbl</code> (data.frame) or <code>matrix</code> formats
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(timetk)
library(recipes)
library(lubridate)

predictors &lt;- m4_monthly %&gt;%
    filter(id == "M750") %&gt;%
    select(-value) %&gt;%
    mutate(month = month(date, label = TRUE))
predictors

# Create default recipe
xreg_recipe_spec &lt;- create_xreg_recipe(predictors, prepare = TRUE)

# Extracts the preprocessed training data from the recipe (used in your fit function)
juice_xreg_recipe(xreg_recipe_spec)

# Applies the prepared recipe to new data (used in your predict function)
bake_xreg_recipe(xreg_recipe_spec, new_data = predictors)


</code></pre>

<hr>
<h2 id='recursive'>Create a Recursive Time Series Model from a Parsnip or Workflow Regression Model</h2><span id='topic+recursive'></span>

<h3>Description</h3>

<p>Create a Recursive Time Series Model from a Parsnip or Workflow Regression Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recursive(object, transform, train_tail, id = NULL, chunk_size = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recursive_+3A_object">object</code></td>
<td>
<p>An object of <code>model_fit</code> or a fitted <code>workflow</code> class</p>
</td></tr>
<tr><td><code id="recursive_+3A_transform">transform</code></td>
<td>
<p>A transformation performed on <code>new_data</code> after
each step of recursive algorithm.
</p>

<ul>
<li> <p><strong>Transformation Function:</strong> Must have one argument <code>data</code> (see examples)
</p>
</li></ul>
</td></tr>
<tr><td><code id="recursive_+3A_train_tail">train_tail</code></td>
<td>
<p>A tibble with tail of training data set.
In most cases it'll be required to create some variables
based on dependent variable.</p>
</td></tr>
<tr><td><code id="recursive_+3A_id">id</code></td>
<td>
<p>(Optional) An identifier that can be provided to perform a panel forecast.
A single quoted column name (e.g. <code>id = "id"</code>).</p>
</td></tr>
<tr><td><code id="recursive_+3A_chunk_size">chunk_size</code></td>
<td>
<p>The size of the smallest lag used in <code>transform</code>. If the
smallest lag necessary is n, the forecasts can be computed in chunks of n,
which can dramatically improve performance. Defaults to 1. Non-integers are
coerced to integer, e.g. <code>chunk_size = 3.5</code> will be coerced to integer via
<code>as.integer()</code>.</p>
</td></tr>
<tr><td><code id="recursive_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>What is a Recursive Model?</strong>
</p>
<p>A <em>recursive model</em> uses predictions to generate
new values for independent features. These features are typically
lags used in autoregressive models. It's important to understand that
a recursive model is only needed when the <strong>Lag Size &lt; Forecast Horizon.</strong>
</p>
<p><strong>Why is Recursive needed for Autoregressive Models with Lag Size &lt; Forecast Horizon?</strong>
</p>
<p>When the lag length is less than the forecast horizon,
a problem exists were missing values (<code>NA</code>) are
generated in the future data. A solution that <code>recursive()</code> implements
is to iteratively fill these missing values in with values generated
from predictions.
</p>
<p><strong>Recursive Process</strong>
</p>
<p>When producing forecast, the following steps are performed:
</p>

<ol>
<li><p> Computing forecast for first row of new data.
The first row cannot contain NA in any required column.
</p>
</li>
<li><p> Filling i-th place of the dependent variable column with
already computed forecast.
</p>
</li>
<li><p> Computing missing features for next step, based on
already calculated prediction. These features are computed
with on a tibble object made from binded <code>train_tail</code> (i.e. tail of
training data set) and <code>new_data</code> (which is an argument of predict function).
</p>
</li>
<li><p> Jumping into point 2., and repeating rest of steps till the for-loop is ended.
</p>
</li></ol>

<p><strong>Recursion for Panel Data</strong>
</p>
<p>Panel data is time series data with multiple groups identified by an ID column.
The <code>recursive()</code> function can be used for Panel Data with the following modifications:
</p>

<ol>
<li><p> Supply an <code>id</code> column as a quoted column name
</p>
</li>
<li><p> Replace <code><a href="utils.html#topic+tail">tail()</a></code> with <code><a href="#topic+panel_tail">panel_tail()</a></code> to use tails for each time series group.
</p>
</li></ol>



<h3>Value</h3>

<p>An object with added <code>recursive</code> class
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+panel_tail">panel_tail()</a></code> - Used to generate tails for multiple time series groups.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# Libraries &amp; Setup ----
library(modeltime)
library(tidymodels)
library(tidyverse)
library(lubridate)
library(timetk)
library(slider)

# ---- SINGLE TIME SERIES (NON-PANEL) -----

m750

FORECAST_HORIZON &lt;- 24

m750_extended &lt;- m750 %&gt;%
    group_by(id) %&gt;%
    future_frame(
        .length_out = FORECAST_HORIZON,
        .bind_data  = TRUE
    ) %&gt;%
    ungroup()

# TRANSFORM FUNCTION ----
# - Function runs recursively that updates the forecasted dataset
lag_roll_transformer &lt;- function(data){
    data %&gt;%
        # Lags
        tk_augment_lags(value, .lags = 1:12) %&gt;%
        # Rolling Features
        mutate(rolling_mean_12 = lag(slide_dbl(
            value, .f = mean, .before = 12, .complete = FALSE
        ), 1))
}

# Data Preparation
m750_rolling &lt;- m750_extended %&gt;%
    lag_roll_transformer() %&gt;%
    select(-id)

train_data &lt;- m750_rolling %&gt;%
    drop_na()

future_data &lt;- m750_rolling %&gt;%
    filter(is.na(value))

# Modeling

# Straight-Line Forecast
model_fit_lm &lt;- linear_reg() %&gt;%
    set_engine("lm") %&gt;%
    # Use only date feature as regressor
    fit(value ~ date, data = train_data)

# Autoregressive Forecast
model_fit_lm_recursive &lt;- linear_reg() %&gt;%
    set_engine("lm") %&gt;%
    # Use date plus all lagged features
    fit(value ~ ., data = train_data) %&gt;%
    # Add recursive() w/ transformer and train_tail
    recursive(
        transform  = lag_roll_transformer,
        train_tail = tail(train_data, FORECAST_HORIZON)
    )

model_fit_lm_recursive

# Forecasting
modeltime_table(
    model_fit_lm,
    model_fit_lm_recursive
) %&gt;%
    update_model_description(2, "LM - Lag Roll") %&gt;%
    modeltime_forecast(
        new_data    = future_data,
        actual_data = m750
    ) %&gt;%
    plot_modeltime_forecast(
        .interactive        = FALSE,
        .conf_interval_show = FALSE
    )

# MULTIPLE TIME SERIES (PANEL DATA) -----

m4_monthly

FORECAST_HORIZON &lt;- 24

m4_extended &lt;- m4_monthly %&gt;%
    group_by(id) %&gt;%
    future_frame(
        .length_out = FORECAST_HORIZON,
        .bind_data  = TRUE
    ) %&gt;%
    ungroup()

# TRANSFORM FUNCTION ----
# - NOTE - We create lags by group
lag_transformer_grouped &lt;- function(data){
    data %&gt;%
        group_by(id) %&gt;%
        tk_augment_lags(value, .lags = 1:FORECAST_HORIZON) %&gt;%
        ungroup()
}

m4_lags &lt;- m4_extended %&gt;%
    lag_transformer_grouped()

train_data &lt;- m4_lags %&gt;%
    drop_na()

future_data &lt;- m4_lags %&gt;%
    filter(is.na(value))

# Modeling Autoregressive Panel Data
model_fit_lm_recursive &lt;- linear_reg() %&gt;%
    set_engine("lm") %&gt;%
    fit(value ~ ., data = train_data) %&gt;%
    recursive(
        id         = "id", # We add an id = "id" to specify the groups
        transform  = lag_transformer_grouped,
        # We use panel_tail() to grab tail by groups
        train_tail = panel_tail(train_data, id, FORECAST_HORIZON)
    )

modeltime_table(
    model_fit_lm_recursive
) %&gt;%
    modeltime_forecast(
        new_data    = future_data,
        actual_data = m4_monthly,
        keep_data   = TRUE
    ) %&gt;%
    group_by(id) %&gt;%
    plot_modeltime_forecast(
        .interactive = FALSE,
        .conf_interval_show = FALSE
    )



</code></pre>

<hr>
<h2 id='seasonal_reg'>General Interface for Multiple Seasonality Regression Models (TBATS, STLM)</h2><span id='topic+seasonal_reg'></span>

<h3>Description</h3>

<p><code>seasonal_reg()</code> is a way to generate a <em>specification</em> of an
Seasonal Decomposition model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>forecast</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonal_reg(
  mode = "regression",
  seasonal_period_1 = NULL,
  seasonal_period_2 = NULL,
  seasonal_period_3 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonal_reg_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="seasonal_reg_+3A_seasonal_period_1">seasonal_period_1</code></td>
<td>
<p>(required) The primary seasonal frequency.
Uses <code>"auto"</code> by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
<tr><td><code id="seasonal_reg_+3A_seasonal_period_2">seasonal_period_2</code></td>
<td>
<p>(optional) A second seasonal frequency.
Is <code>NULL</code> by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
<tr><td><code id="seasonal_reg_+3A_seasonal_period_3">seasonal_period_3</code></td>
<td>
<p>(optional) A third seasonal frequency.
Is <code>NULL</code> by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>seasonal_reg()</code>, the
mode will always be &quot;regression&quot;.
</p>
<p>The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li><p> &quot;tbats&quot; - Connects to <code>forecast::tbats()</code>
</p>
</li>
<li><p> &quot;stlm_ets&quot; - Connects to <code>forecast::stlm()</code>, <code>method = "ets"</code>
</p>
</li>
<li><p> &quot;stlm_arima&quot; - Connects to <code>forecast::stlm()</code>, <code>method = "arima"</code>
</p>
</li></ul>



<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> forecast::stlm </td><td style="text-align: left;"> forecast::tbats </td>
</tr>
<tr>
 <td style="text-align: left;">
   seasonal_period_1, seasonal_period_2, seasonal_period_3 </td><td style="text-align: left;"> msts(seasonal.periods) </td><td style="text-align: left;"> msts(seasonal.periods) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other options can be set using <code>set_engine()</code>.
</p>
<p>The engines use <code>forecast::stlm()</code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, s.window = 7 + 4 * seq(6), robust = FALSE, method = c("ets", 
#&gt;     "arima"), modelfunction = NULL, model = NULL, etsmodel = "ZZN", lambda = NULL, 
#&gt;     biasadj = FALSE, xreg = NULL, allow.multiplicative.trend = FALSE, x = y, 
#&gt;     ...)
</pre></div>
<p><strong>tbats</strong>
</p>

<ul>
<li> <p><strong>Method:</strong> Uses <code>method = "tbats"</code>, which by default is auto-TBATS.
</p>
</li>
<li> <p><strong>Xregs:</strong> Univariate. Cannot accept Exogenous Regressors (xregs). Xregs are ignored.
</p>
</li></ul>

<p><strong>stlm_ets</strong>
</p>

<ul>
<li> <p><strong>Method:</strong> Uses <code>method = "stlm_ets"</code>, which by default is auto-ETS.
</p>
</li>
<li> <p><strong>Xregs:</strong> Univariate. Cannot accept Exogenous Regressors (xregs). Xregs are ignored.
</p>
</li></ul>

<p><strong>stlm_arima</strong>
</p>

<ul>
<li> <p><strong>Method:</strong> Uses <code>method = "stlm_arima"</code>, which by default is auto-ARIMA.
</p>
</li>
<li> <p><strong>Xregs:</strong> Multivariate. Can accept Exogenous Regressors (xregs).
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><em>Seasonal Period Specification</em>
</p>
<p>The period can be non-seasonal (<code style="white-space: pre;">&#8288;seasonal_period = 1 or "none"&#8288;</code>) or
yearly seasonal (e.g. For monthly time stamps, <code>seasonal_period = 12</code>, <code>seasonal_period = "12 months"</code>, or <code>seasonal_period = "yearly"</code>).
There are 3 ways to specify:
</p>

<ol>
<li> <p><code>seasonal_period = "auto"</code>: A seasonal period is selected based on the periodicity of the data (e.g. 12 if monthly)
</p>
</li>
<li> <p><code>seasonal_period = 12</code>: A numeric frequency. For example, 12 is common for monthly data
</p>
</li>
<li> <p><code>seasonal_period = "1 year"</code>: A time-based phrase. For example, &quot;1 year&quot; would convert to 12 for monthly data.
</p>
</li></ol>

<p><strong>Univariate (No xregs, Exogenous Regressors):</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li><p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (xregs, Exogenous Regressors)</strong>
</p>

<ul>
<li><p> The <code>tbats</code> engine <em>cannot</em> accept Xregs.
</p>
</li>
<li><p> The <code>stlm_ets</code> engine <em>cannot</em> accept Xregs.
</p>
</li>
<li><p> The <code>stlm_arima</code> engine <em>can</em> accept Xregs
</p>
</li></ul>

<p>The <code>xreg</code> parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>

<ul>
<li><p> Only <code>factor</code>, <code style="white-space: pre;">&#8288;ordered factor&#8288;</code>, and <code>numeric</code> data will be used as xregs.
</p>
</li>
<li><p> Date and Date-time variables are not used as xregs
</p>
</li>
<li> <p><code>character</code> data should be converted to factor.
</p>
</li></ul>

<p><em>Xreg Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>month.lbl</code> (labeled month as a ordered factor).
</p>
</li></ol>

<p>The <code>month.lbl</code> is an exogenous regressor that can be passed to the <code>seasonal_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>fit(y ~ date + month.lbl)</code> will pass <code>month.lbl</code> on as an exogenous regressor.
</p>
</li>
<li> <p><code>fit_xy(data[,c("date", "month.lbl")], y = data$y)</code> will pass x, where x is a data frame containing <code>month.lbl</code>
and the <code>date</code> feature. Only <code>month.lbl</code> will be used as an exogenous regressor.
</p>
</li></ul>

<p>Note that date or date-time class values are excluded from <code>xreg</code>.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)

# Data
taylor_30_min

# Split Data 80/20
splits &lt;- initial_time_split(taylor_30_min, prop = 0.8)

# ---- STLM ETS ----

# Model Spec
model_spec &lt;- seasonal_reg() %&gt;%
    set_engine("stlm_ets")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit


# ---- STLM ARIMA ----

# Model Spec
model_spec &lt;- seasonal_reg() %&gt;%
    set_engine("stlm_arima")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit

</code></pre>

<hr>
<h2 id='smooth_fit_impl'>Low-Level Exponential Smoothing function for translating modeltime to forecast</h2><span id='topic+smooth_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level Exponential Smoothing function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_fit_impl(
  x,
  y,
  period = "auto",
  error = "auto",
  trend = "auto",
  season = "auto",
  damping = NULL,
  alpha = NULL,
  beta = NULL,
  gamma = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_error">error</code></td>
<td>
<p>The form of the error term: &quot;auto&quot;, &quot;additive&quot;, or &quot;multiplicative&quot;.
If the error is multiplicative, the data must be non-negative.</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_trend">trend</code></td>
<td>
<p>The form of the trend term: &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_season">season</code></td>
<td>
<p>The form of the seasonal term: &quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_damping">damping</code></td>
<td>
<p>Apply damping to a trend: &quot;auto&quot;, &quot;damped&quot;, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_alpha">alpha</code></td>
<td>
<p>Value of alpha. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_beta">beta</code></td>
<td>
<p>Value of beta. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_gamma">gamma</code></td>
<td>
<p>Value of gamma. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="smooth_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>smooth::es</code></p>
</td></tr>
</table>

<hr>
<h2 id='smooth_predict_impl'>Bridge prediction function for Exponential Smoothing models</h2><span id='topic+smooth_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for Exponential Smoothing models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="smooth_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="smooth_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>smooth::es()</code></p>
</td></tr>
</table>

<hr>
<h2 id='snaive_fit_impl'>Low-Level SNAIVE Forecast</h2><span id='topic+snaive_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level SNAIVE Forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snaive_fit_impl(x, y, id = NULL, seasonal_period = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snaive_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="snaive_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="snaive_fit_impl_+3A_id">id</code></td>
<td>
<p>An optional ID feature to identify different time series. Should be a quoted name.</p>
</td></tr>
<tr><td><code id="snaive_fit_impl_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>The seasonal period to forecast into the future</p>
</td></tr>
<tr><td><code id="snaive_fit_impl_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>

<hr>
<h2 id='snaive_predict_impl'>Bridge prediction function for SNAIVE Models</h2><span id='topic+snaive_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for SNAIVE Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snaive_predict_impl(object, new_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snaive_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="snaive_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
</table>

<hr>
<h2 id='stlm_arima_fit_impl'>Low-Level stlm function for translating modeltime to forecast</h2><span id='topic+stlm_arima_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level stlm function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stlm_arima_fit_impl(
  x,
  y,
  period_1 = "auto",
  period_2 = NULL,
  period_3 = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stlm_arima_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="stlm_arima_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="stlm_arima_fit_impl_+3A_period_1">period_1</code></td>
<td>
<p>(required) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="stlm_arima_fit_impl_+3A_period_2">period_2</code></td>
<td>
<p>(optional) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="stlm_arima_fit_impl_+3A_period_3">period_3</code></td>
<td>
<p>(optional) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="stlm_arima_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::stlm()</code></p>
</td></tr>
</table>

<hr>
<h2 id='stlm_arima_predict_impl'>Bridge prediction function for ARIMA models</h2><span id='topic+stlm_arima_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for ARIMA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stlm_arima_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stlm_arima_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="stlm_arima_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="stlm_arima_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::forecast()</code></p>
</td></tr>
</table>

<hr>
<h2 id='stlm_ets_fit_impl'>Low-Level stlm function for translating modeltime to forecast</h2><span id='topic+stlm_ets_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level stlm function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stlm_ets_fit_impl(
  x,
  y,
  period_1 = "auto",
  period_2 = NULL,
  period_3 = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stlm_ets_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="stlm_ets_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="stlm_ets_fit_impl_+3A_period_1">period_1</code></td>
<td>
<p>(required) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="stlm_ets_fit_impl_+3A_period_2">period_2</code></td>
<td>
<p>(optional) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="stlm_ets_fit_impl_+3A_period_3">period_3</code></td>
<td>
<p>(optional) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="stlm_ets_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::stlm()</code></p>
</td></tr>
</table>

<hr>
<h2 id='stlm_ets_predict_impl'>Bridge prediction function for ARIMA models</h2><span id='topic+stlm_ets_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for ARIMA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stlm_ets_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stlm_ets_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="stlm_ets_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="stlm_ets_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::forecast()</code></p>
</td></tr>
</table>

<hr>
<h2 id='summarize_accuracy_metrics'>Summarize Accuracy Metrics</h2><span id='topic+summarize_accuracy_metrics'></span>

<h3>Description</h3>

<p>This is an internal function used by <code>modeltime_accuracy()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_accuracy_metrics(data, truth, estimate, metric_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_accuracy_metrics_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the truth and estimate columns.</p>
</td></tr>
<tr><td><code id="summarize_accuracy_metrics_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results (that is numeric).</p>
</td></tr>
<tr><td><code id="summarize_accuracy_metrics_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted results (that is also numeric).</p>
</td></tr>
<tr><td><code id="summarize_accuracy_metrics_+3A_metric_set">metric_set</code></td>
<td>
<p>A <code>yardstick::metric_set()</code> that is used to summarize one or more
forecast accuracy (regression) metrics.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)

predictions_tbl &lt;- tibble(
    group = c("model 1", "model 1", "model 1",
              "model 2", "model 2", "model 2"),
    truth = c(1, 2, 3,
              1, 2, 3),
    estimate = c(1.2, 2.0, 2.5,
                 0.9, 1.9, 3.3)
)

predictions_tbl %&gt;%
    group_by(group) %&gt;%
    summarize_accuracy_metrics(
        truth, estimate,
        metric_set = default_forecast_accuracy_metric_set()
    )

</code></pre>

<hr>
<h2 id='table_modeltime_accuracy'>Interactive Accuracy Tables</h2><span id='topic+table_modeltime_accuracy'></span>

<h3>Description</h3>

<p>Converts results from <code><a href="#topic+modeltime_accuracy">modeltime_accuracy()</a></code> into
either interactive (<code>reactable</code>) or static (<code>gt</code>) tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_modeltime_accuracy(
  .data,
  .round_digits = 2,
  .sortable = TRUE,
  .show_sortable = TRUE,
  .searchable = TRUE,
  .filterable = FALSE,
  .expand_groups = TRUE,
  .title = "Accuracy Table",
  .interactive = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_modeltime_accuracy_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> that is the output of <code><a href="#topic+modeltime_accuracy">modeltime_accuracy()</a></code></p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_.round_digits">.round_digits</code></td>
<td>
<p>Rounds accuracy metrics to a specified number of digits.
If <code>NULL</code>, rounding is not performed.</p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_.sortable">.sortable</code></td>
<td>
<p>Allows sorting by columns.
Only applied to <code>reactable</code> tables.
Passed to <code>reactable(sortable)</code>.</p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_.show_sortable">.show_sortable</code></td>
<td>
<p>Shows sorting.
Only applied to <code>reactable</code> tables.
Passed to <code>reactable(showSortable)</code>.</p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_.searchable">.searchable</code></td>
<td>
<p>Adds search input.
Only applied to <code>reactable</code> tables.
Passed to <code>reactable(searchable)</code>.</p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_.filterable">.filterable</code></td>
<td>
<p>Adds filters to table columns.
Only applied to <code>reactable</code> tables.
Passed to <code>reactable(filterable)</code>.</p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_.expand_groups">.expand_groups</code></td>
<td>
<p>Expands groups dropdowns.
Only applied to <code>reactable</code> tables.
Passed to <code>reactable(defaultExpanded)</code>.</p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_.title">.title</code></td>
<td>
<p>A title for static (<code>gt</code>) tables.</p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_.interactive">.interactive</code></td>
<td>
<p>Return interactive or static tables. If <code>TRUE</code>,
returns <code>reactable</code> table. If <code>FALSE</code>, returns static <code>gt</code> table.</p>
</td></tr>
<tr><td><code id="table_modeltime_accuracy_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="reactable.html#topic+reactable">reactable::reactable()</a></code>
or <code><a href="gt.html#topic+gt">gt::gt()</a></code> (depending on <code>.interactive</code> selection).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Groups</strong>
</p>
<p>The function respects <code>dplyr::group_by()</code> groups and thus scales with multiple groups.
</p>
<p><strong>Reactable Output</strong>
</p>
<p>A <code>reactable()</code> table is an interactive format that enables live searching and sorting.
When <code>.interactive = TRUE</code>, a call is made to  <code><a href="reactable.html#topic+reactable">reactable::reactable()</a></code>.
</p>
<p><code>table_modeltime_accuracy()</code> includes several common options like toggles for sorting and searching.
Additional arguments can be passed to <code><a href="reactable.html#topic+reactable">reactable::reactable()</a></code> via <code>...</code>.
</p>
<p><strong>GT Output</strong>
</p>
<p>A <code>gt</code> table is an HTML-based table that is &quot;static&quot; (e.g. non-searchable, non-sortable). It's
commonly used in PDF and Word documents that does not support interactive content.
</p>
<p>When <code>.interactive = FALSE</code>, a call is made to <code><a href="gt.html#topic+gt">gt::gt()</a></code>. Arguments can be passed via <code>...</code>.
</p>
<p>Table customization is implemented using a piping workflow (<code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>).
For more information, refer to the <a href="https://gt.rstudio.com/index.html">GT Documentation</a>.
</p>


<h3>Value</h3>

<p>A static <code>gt</code> table or an interactive <code>reactable</code> table containing
the accuracy information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: prophet ----
model_fit_prophet &lt;- prophet_reg() %&gt;%
    set_engine(engine = "prophet") %&gt;%
    fit(value ~ date, data = training(splits))


# ---- MODELTIME TABLE ----

models_tbl &lt;- modeltime_table(
    model_fit_prophet
)

# ---- ACCURACY ----

models_tbl %&gt;%
    modeltime_calibrate(new_data = testing(splits)) %&gt;%
    modeltime_accuracy() %&gt;%
    table_modeltime_accuracy()


</code></pre>

<hr>
<h2 id='tbats_fit_impl'>Low-Level tbats function for translating modeltime to forecast</h2><span id='topic+tbats_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level tbats function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbats_fit_impl(
  x,
  y,
  period_1 = "auto",
  period_2 = NULL,
  period_3 = NULL,
  use.parallel = length(y) &gt; 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbats_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="tbats_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="tbats_fit_impl_+3A_period_1">period_1</code></td>
<td>
<p>(required) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="tbats_fit_impl_+3A_period_2">period_2</code></td>
<td>
<p>(optional) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="tbats_fit_impl_+3A_period_3">period_3</code></td>
<td>
<p>(optional) First seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="tbats_fit_impl_+3A_use.parallel">use.parallel</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether or not to use parallel processing.</p>
</td></tr>
<tr><td><code id="tbats_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::tbats()</code></p>
</td></tr>
</table>

<hr>
<h2 id='tbats_predict_impl'>Bridge prediction function for ARIMA models</h2><span id='topic+tbats_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for ARIMA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbats_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbats_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="tbats_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="tbats_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::forecast()</code></p>
</td></tr>
</table>

<hr>
<h2 id='temporal_hier_fit_impl'>Low-Level Temporaral Hierarchical function for translating modeltime to forecast</h2><span id='topic+temporal_hier_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level Temporaral Hierarchical function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporal_hier_fit_impl(
  x,
  y,
  period = "auto",
  comb = c("struc", "mse", "ols", "bu", "shr", "sam"),
  usemodel = c("ets", "arima", "theta", "naive", "snaive"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporal_hier_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="temporal_hier_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="temporal_hier_fit_impl_+3A_period">period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default. A character phrase
of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot; can be used if a date or date-time variable is provided.</p>
</td></tr>
<tr><td><code id="temporal_hier_fit_impl_+3A_comb">comb</code></td>
<td>
<p>Combination method of temporal hierarchies</p>
</td></tr>
<tr><td><code id="temporal_hier_fit_impl_+3A_usemodel">usemodel</code></td>
<td>
<p>Model used for forecasting each aggregation level</p>
</td></tr>
<tr><td><code id="temporal_hier_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::ets</code></p>
</td></tr>
</table>

<hr>
<h2 id='temporal_hier_predict_impl'>Bridge prediction function for TEMPORAL HIERARCHICAL models</h2><span id='topic+temporal_hier_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for TEMPORAL HIERARCHICAL models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporal_hier_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporal_hier_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="temporal_hier_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="temporal_hier_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::predict()</code></p>
</td></tr>
</table>

<hr>
<h2 id='temporal_hierarchy'>General Interface for Temporal Hierarchical Forecasting (THIEF) Models</h2><span id='topic+temporal_hierarchy'></span>

<h3>Description</h3>

<p><code>temporal_hierarchy()</code> is a way to generate a <em>specification</em> of an Temporal Hierarchical Forecasting model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>thief</code>. Note this
function requires the <code>thief</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporal_hierarchy(
  mode = "regression",
  seasonal_period = NULL,
  combination_method = NULL,
  use_model = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporal_hierarchy_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="temporal_hierarchy_+3A_seasonal_period">seasonal_period</code></td>
<td>
<p>A seasonal frequency. Uses &quot;auto&quot; by default.
A character phrase of &quot;auto&quot; or time-based phrase of &quot;2 weeks&quot;
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td></tr>
<tr><td><code id="temporal_hierarchy_+3A_combination_method">combination_method</code></td>
<td>
<p>Combination method of temporal hierarchies, taking one of the following values:
</p>

<ul>
<li><p> &quot;struc&quot; - Structural scaling: weights from temporal hierarchy
</p>
</li>
<li><p> &quot;mse&quot; - Variance scaling: weights from in-sample MSE
</p>
</li>
<li><p> &quot;ols&quot; - Unscaled OLS combination weights
</p>
</li>
<li><p> &quot;bu&quot; - Bottom-up combination – i.e., all aggregate forecasts are ignored.
</p>
</li>
<li><p> &quot;shr&quot; - GLS using a shrinkage (to block diagonal) estimate of residuals
</p>
</li>
<li><p> &quot;sam&quot; - GLS using sample covariance matrix of residuals
</p>
</li></ul>
</td></tr>
<tr><td><code id="temporal_hierarchy_+3A_use_model">use_model</code></td>
<td>
<p>Model used for forecasting each aggregation level:
</p>

<ul>
<li><p> &quot;ets&quot; - exponential smoothing
</p>
</li>
<li><p> &quot;arima&quot; - arima
</p>
</li>
<li><p> &quot;theta&quot; - theta
</p>
</li>
<li><p> &quot;naive&quot; - random walk forecasts
</p>
</li>
<li><p> &quot;snaive&quot; - seasonal naive forecasts, based on the last year of observed data
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Models can be created using the following <em>engines</em>:
</p>

<ul>
<li><p> &quot;thief&quot; (default) - Connects to <code>thief::thief()</code>
</p>
</li></ul>



<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:</p>

<table>
<tr>
 <td style="text-align: left;">
   modeltime </td><td style="text-align: left;"> thief::thief() </td>
</tr>
<tr>
 <td style="text-align: left;">
   combination_method </td><td style="text-align: left;"> comb </td>
</tr>
<tr>
 <td style="text-align: left;">
   use_model </td><td style="text-align: left;"> usemodel </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other options can be set using <code>set_engine()</code>.
</p>
<p><strong>thief (default engine)</strong>
</p>
<p>The engine uses <code>thief::thief()</code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, m = frequency(y), h = m * 2, comb = c("struc", "mse", "ols", 
#&gt;     "bu", "shr", "sam"), usemodel = c("ets", "arima", "theta", "naive", 
#&gt;     "snaive"), forecastfunction = NULL, aggregatelist = NULL, ...)
</pre></div>
<p>Other options and argument can be set using <code>set_engine()</code>.
</p>
<p>Parameter Notes:
</p>

<ul>
<li> <p><code>xreg</code> - This model is not set up to use exogenous regressors. Only univariate
models will be fit.
</p>
</li></ul>



<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><strong>Univariate:</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li><p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li><p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li></ul>

<p><strong>Multivariate (xregs, Exogenous Regressors)</strong>
</p>
<p>This model is not set up for use with exogenous regressors.
</p>


<h3>References</h3>


<ul>
<li><p>For forecasting with temporal hierarchies see: Athanasopoulos G., Hyndman R.J., Kourentzes N., Petropoulos F. (2017) Forecasting with Temporal Hierarchies. <em>European Journal of Operational research</em>, <b>262</b>(<b>1</b>), 60-74.
</p>
</li>
<li><p>For combination operators see: Kourentzes N., Barrow B.K., Crone S.F. (2014) Neural network ensemble operators for time series forecasting. <em>Expert Systems with Applications</em>, <b>41</b>(<b>9</b>), 4235-4244.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)
library(thief)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- HIERARCHICAL ----

# Model Spec - The default parameters are all set
# to "auto" if none are provided
model_spec &lt;- temporal_hierarchy() %&gt;%
    set_engine("thief")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit




</code></pre>

<hr>
<h2 id='temporal_hierarchy_params'>Tuning Parameters for TEMPORAL HIERARCHICAL Models</h2><span id='topic+temporal_hierarchy_params'></span><span id='topic+combination_method'></span><span id='topic+use_model'></span>

<h3>Description</h3>

<p>Tuning Parameters for TEMPORAL HIERARCHICAL Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combination_method()

use_model()
</code></pre>


<h3>Details</h3>

<p>The main parameters for Temporal Hierarchical models are:
</p>

<ul>
<li> <p><code>combination_method</code>: Combination method of temporal hierarchies.
</p>
</li>
<li> <p><code>use_model</code>: Model used for forecasting each aggregation level.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>combination_method()

use_model()

</code></pre>

<hr>
<h2 id='theta_fit_impl'>Low-Level Exponential Smoothing function for translating modeltime to forecast</h2><span id='topic+theta_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level Exponential Smoothing function for translating modeltime to forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_fit_impl(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="theta_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="theta_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>forecast::ets</code></p>
</td></tr>
</table>

<hr>
<h2 id='theta_predict_impl'>Bridge prediction function for THETA models</h2><span id='topic+theta_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for THETA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_predict_impl(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="theta_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="theta_predict_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::predict()</code></p>
</td></tr>
</table>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+expr'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+.data'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="rlang.html#topic+sym">sym</a>()</code> creates a symbol from a string and
<code><a href="rlang.html#topic+sym">syms</a>()</code> creates a list of symbols from a
character vector.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">enquo</a>()</code> and
<code><a href="rlang.html#topic+nse-defuse">enquos</a>()</code> delay the execution of one or
several function arguments. <code>enquo()</code> returns a single quoted
expression, which is like a blueprint for the delayed computation.
<code>enquos()</code> returns a list of such quoted expressions.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">expr</a>()</code> quotes a new expression <em>locally</em>. It
is mostly useful to build new expressions around arguments
captured with <code><a href="#topic+enquo">enquo()</a></code> or <code><a href="#topic+enquos">enquos()</a></code>:
<code>expr(mean(!!enquo(arg), na.rm = TRUE))</code>.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+as_name">as_name</a>()</code> transforms a quoted variable name
into a string. Supplying something else than a quoted variable
name is an error.
</p>
<p>That's unlike <code><a href="rlang.html#topic+as_label">as_label</a>()</code> which also returns
a single string but supports any kind of R object as input,
including quoted function calls and vectors. Its purpose is to
summarise that object into a single label. That label is often
suitable as a default name.
</p>
<p>If you don't know what a quoted expression contains (for instance
expressions captured with <code>enquo()</code> could be a variable
name, a call to a function, or an unquoted constant), then use
<code>as_label()</code>. If you know you have quoted a simple variable
name, or would like to enforce this, use <code>as_name()</code>.
</p>
</li></ul>

<p>To learn more about tidy eval and how to use these tools, visit the
<a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming
section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a>.
</p>

<hr>
<h2 id='time_series_params'>Tuning Parameters for Time Series (ts-class) Models</h2><span id='topic+time_series_params'></span><span id='topic+seasonal_period'></span>

<h3>Description</h3>

<p>Tuning Parameters for Time Series (ts-class) Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonal_period(values = c("none", "daily", "weekly", "yearly"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_series_params_+3A_values">values</code></td>
<td>
<p>A time-based phrase</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time series models (e.g. <code>Arima()</code> and <code>ets()</code>) use <code><a href="stats.html#topic+ts">stats::ts()</a></code> or <code><a href="forecast.html#topic+msts">forecast::msts()</a></code>
to apply seasonality. We can do the same process using the following
general time series parameter:
</p>

<ul>
<li> <p><code>period</code>: The periodic nature of the seasonality.
</p>
</li></ul>

<p>It's usually best practice to <em>not</em> tune this parameter, but rather set
to obvious values based on the seasonality of the data:
</p>

<ul>
<li> <p><strong>Daily Seasonality:</strong> Often used with <strong>hourly data</strong> (e.g. 24 hourly timestamps per day)
</p>
</li>
<li> <p><strong>Weekly Seasonality:</strong> Often used with <strong>daily data</strong> (e.g. 7 daily timestamps per week)
</p>
</li>
<li> <p><strong>Yearly Seasonalty:</strong> Often used with <strong>weekly, monthly, and quarterly data</strong>
(e.g. 12 monthly observations per year).
</p>
</li></ul>

<p>However, in the event that users want to experiment with period tuning, you
can do so with <code>seasonal_period()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seasonal_period()



</code></pre>

<hr>
<h2 id='type_sum.mdl_time_tbl'>Succinct summary of Modeltime Tables</h2><span id='topic+type_sum.mdl_time_tbl'></span>

<h3>Description</h3>

<p><code>type_sum</code> controls how objects are shown when inside tibble
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdl_time_tbl'
type_sum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_sum.mdl_time_tbl_+3A_x">x</code></td>
<td>
<p>A <code>mdl_time_tbl</code> object to summarise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character value.
</p>

<hr>
<h2 id='update_model_description'>Update the model description by model id in a Modeltime Table</h2><span id='topic+update_model_description'></span><span id='topic+update_modeltime_description'></span>

<h3>Description</h3>

<p>The <code>update_model_description()</code> and <code>update_modeltime_description()</code> functions
are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_model_description(object, .model_id, .new_model_desc)

update_modeltime_description(object, .model_id, .new_model_desc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_model_description_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="update_model_description_+3A_.model_id">.model_id</code></td>
<td>
<p>A numeric value matching the .model_id that you want to update</p>
</td></tr>
<tr><td><code id="update_model_description_+3A_.new_model_desc">.new_model_desc</code></td>
<td>
<p>Text describing the new model description</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+combine_modeltime_tables">combine_modeltime_tables()</a></code>: Combine 2 or more Modeltime Tables together
</p>
</li>
<li> <p><code><a href="#topic+add_modeltime_model">add_modeltime_model()</a></code>: Adds a new row with a new model to a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+drop_modeltime_model">drop_modeltime_model()</a></code>: Drop one or more models from a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_description">update_modeltime_description()</a></code>: Updates a description for a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_model">update_modeltime_model()</a></code>: Updates a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+pull_modeltime_model">pull_modeltime_model()</a></code>: Extracts a model from a Modeltime Table
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
m750_models %&gt;%
    update_modeltime_description(2, "PROPHET - No Regressors")

</code></pre>

<hr>
<h2 id='update_modeltime_model'>Update the model by model id in a Modeltime Table</h2><span id='topic+update_modeltime_model'></span>

<h3>Description</h3>

<p>Update the model by model id in a Modeltime Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_modeltime_model(object, .model_id, .new_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_modeltime_model_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="update_modeltime_model_+3A_.model_id">.model_id</code></td>
<td>
<p>A numeric value matching the .model_id that you want to update</p>
</td></tr>
<tr><td><code id="update_modeltime_model_+3A_.new_model">.new_model</code></td>
<td>
<p>A fitted workflow, model_fit, or mdl_time_ensmble object</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+combine_modeltime_tables">combine_modeltime_tables()</a></code>: Combine 2 or more Modeltime Tables together
</p>
</li>
<li> <p><code><a href="#topic+add_modeltime_model">add_modeltime_model()</a></code>: Adds a new row with a new model to a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+drop_modeltime_model">drop_modeltime_model()</a></code>: Drop one or more models from a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_description">update_modeltime_description()</a></code>: Updates a description for a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+update_modeltime_model">update_modeltime_model()</a></code>: Updates a model inside a Modeltime Table
</p>
</li>
<li> <p><code><a href="#topic+pull_modeltime_model">pull_modeltime_model()</a></code>: Extracts a model from a Modeltime Table
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tidymodels)

model_fit_ets &lt;- exp_smoothing() %&gt;%
    set_engine("ets") %&gt;%
    fit(value ~ date, training(m750_splits))

m750_models %&gt;%
    update_modeltime_model(1, model_fit_ets)


</code></pre>

<hr>
<h2 id='window_function_fit_impl'>Low-Level Window Forecast</h2><span id='topic+window_function_fit_impl'></span>

<h3>Description</h3>

<p>Low-Level Window Forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_function_fit_impl(
  x,
  y,
  id = NULL,
  window_size = "all",
  window_function = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_function_fit_impl_+3A_x">x</code></td>
<td>
<p>A dataframe of xreg (exogenous regressors)</p>
</td></tr>
<tr><td><code id="window_function_fit_impl_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to fit</p>
</td></tr>
<tr><td><code id="window_function_fit_impl_+3A_id">id</code></td>
<td>
<p>An optional ID feature to identify different time series. Should be a quoted name.</p>
</td></tr>
<tr><td><code id="window_function_fit_impl_+3A_window_size">window_size</code></td>
<td>
<p>The period to apply the window function to</p>
</td></tr>
<tr><td><code id="window_function_fit_impl_+3A_window_function">window_function</code></td>
<td>
<p>A function to apply to the window. The default is <code>mean()</code>.</p>
</td></tr>
<tr><td><code id="window_function_fit_impl_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <code>window_function</code>. For example, it's
common to pass <code>na.rm = TRUE</code> for the mean forecast.</p>
</td></tr>
</table>

<hr>
<h2 id='window_function_predict_impl'>Bridge prediction function for window Models</h2><span id='topic+window_function_predict_impl'></span>

<h3>Description</h3>

<p>Bridge prediction function for window Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_function_predict_impl(object, new_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_function_predict_impl_+3A_object">object</code></td>
<td>
<p>An object of class <code>model_fit</code>.</p>
</td></tr>
<tr><td><code id="window_function_predict_impl_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
</table>

<hr>
<h2 id='window_reg'>General Interface for Window Forecast Models</h2><span id='topic+window_reg'></span>

<h3>Description</h3>

<p><code>window_reg()</code> is a way to generate a <em>specification</em> of a window model
before fitting and allows the model to be created using
different backends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_reg(mode = "regression", id = NULL, window_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_reg_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="window_reg_+3A_id">id</code></td>
<td>
<p>An optional quoted column name (e.g. &quot;id&quot;) for
identifying multiple time series (i.e. panel data).</p>
</td></tr>
<tr><td><code id="window_reg_+3A_window_size">window_size</code></td>
<td>
<p>A window to apply the window function. By default,
the window uses the full data set, which is rarely the best choice.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A time series window regression is derived using <code>window_reg()</code>.
The model can be created using the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li> <p><strong>&quot;window_function&quot; (default)</strong> - Performs a Window Forecast
applying a <code>window_function</code> (engine parameter)
to a window of size defined by <code>window_size</code>
</p>
</li></ul>



<h3>Engine Details</h3>

<p><strong>function (default engine)</strong>
</p>
<p>The engine uses <code><a href="#topic+window_function_fit_impl">window_function_fit_impl()</a></code>. A time series window function
applies a <code>window_function</code> to a window of the data (last N observations).
</p>

<ul>
<li><p> The function can return a scalar (single value) or multiple values
that are repeated for each window
</p>
</li>
<li><p> Common use cases:
</p>

<ul>
<li> <p><strong>Moving Average Forecasts:</strong> Forecast forward a 20-day average
</p>
</li>
<li> <p><strong>Weighted Average Forecasts:</strong> Exponentially weighting the most recent observations
</p>
</li>
<li> <p><strong>Median Forecasts:</strong> Forecasting forward a 20-day median
</p>
</li>
<li> <p><strong>Repeating Forecasts:</strong> Simulating a Seasonal Naive Forecast by
broadcasting the last 12 observations of a monthly dataset into the future
</p>
</li></ul>

</li></ul>

<p>The key engine parameter is the <code>window_function</code>. A function / formula:
</p>

<ul>
<li><p> If a function, e.g. <code>mean</code>, the function is used with
any additional arguments, <code>...</code> in <code>set_engine()</code>.
</p>
</li>
<li><p> If a formula, e.g. <code>~ mean(., na.rm = TRUE)</code>, it is converted to a function.
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>


<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul>
<li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>

<p><strong>ID features (Multiple Time Series, Panel Data)</strong>
</p>
<p>The <code>id</code> parameter is populated using the <code>fit()</code> or <code>fit_xy()</code> function:
</p>
<p><em>ID Example:</em> Suppose you have 3 features:
</p>

<ol>
<li> <p><code>y</code> (target)
</p>
</li>
<li> <p><code>date</code> (time stamp),
</p>
</li>
<li> <p><code>series_id</code> (a unique identifer that identifies each time series in your data).
</p>
</li></ol>

<p>The <code>series_id</code> can be passed to the <code>window_reg()</code> using
<code>fit()</code>:
</p>

<ul>
<li> <p><code>window_reg(id = "series_id")</code> specifes that the <code>series_id</code> column should be used
to identify each time series.
</p>
</li>
<li> <p><code>fit(y ~ date + series_id)</code> will pass <code>series_id</code> on to the underlying functions.
</p>
</li></ul>

<p><strong>Window Function Specification (window_function)</strong>
</p>
<p>You can specify a function / formula using <code>purrr</code> syntax.
</p>

<ul>
<li><p> If a function, e.g. <code>mean</code>, the function is used with
any additional arguments, <code>...</code> in <code>set_engine()</code>.
</p>
</li>
<li><p> If a formula, e.g. <code>~ mean(., na.rm = TRUE)</code>, it is converted to a function.
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p><strong>Window Size Specification (window_size)</strong>
</p>
<p>The period can be non-seasonal (<code style="white-space: pre;">&#8288;window_size = 1 or "none"&#8288;</code>) or
yearly seasonal (e.g. For monthly time stamps, <code>window_size = 12</code>, <code>window_size = "12 months"</code>, or <code>window_size = "yearly"</code>).
There are 3 ways to specify:
</p>

<ol>
<li> <p><code>window_size = "all"</code>: A seasonal period is selected based on the periodicity of the data (e.g. 12 if monthly)
</p>
</li>
<li> <p><code>window_size = 12</code>: A numeric frequency. For example, 12 is common for monthly data
</p>
</li>
<li> <p><code>window_size = "1 year"</code>: A time-based phrase. For example, &quot;1 year&quot; would convert to 12 for monthly data.
</p>
</li></ol>

<p><strong>External Regressors (Xregs)</strong>
</p>
<p>These models are univariate. No xregs are used in the modeling process.
</p>


<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- WINDOW FUNCTION -----

# Used to make:
# - Mean/Median forecasts
# - Simple repeating forecasts

# Median Forecast ----

# Model Spec
model_spec &lt;- window_reg(
        window_size     = 12
    ) %&gt;%
    # Extra parameters passed as: set_engine(...)
    set_engine(
        engine          = "window_function",
        window_function = median,
        na.rm           = TRUE
    )

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit

# Predict
# - The 12-month median repeats going forward
predict(model_fit, testing(splits))


# ---- PANEL FORECAST - WINDOW FUNCTION ----

# Weighted Average Forecast
model_spec &lt;- window_reg(
        # Specify the ID column for Panel Data
        id          = "id",
        window_size = 12
    ) %&gt;%
    set_engine(
        engine = "window_function",
        # Create a Weighted Average
        window_function = ~ sum(tail(.x, 3) * c(0.1, 0.3, 0.6)),
    )

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date + id, data = training(splits))
model_fit

# Predict: The weighted average (scalar) repeats going forward
predict(model_fit, testing(splits))

# ---- BROADCASTING PANELS (REPEATING) ----

# Simulating a Seasonal Naive Forecast by
# broadcasted model the last 12 observations into the future
model_spec &lt;- window_reg(
        id          = "id",
        window_size = Inf
    ) %&gt;%
    set_engine(
        engine          = "window_function",
        window_function = ~ tail(.x, 12),
    )

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date + id, data = training(splits))
model_fit

# Predict: The sequence is broadcasted (repeated) during prediction
predict(model_fit, testing(splits))

</code></pre>

<hr>
<h2 id='xgboost_impl'>Wrapper for parsnip::xgb_train</h2><span id='topic+xgboost_impl'></span>

<h3>Description</h3>

<p>Wrapper for parsnip::xgb_train
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgboost_impl(
  x,
  y,
  max_depth = 6,
  nrounds = 15,
  eta = 0.3,
  colsample_bynode = NULL,
  colsample_bytree = NULL,
  min_child_weight = 1,
  gamma = 0,
  subsample = 1,
  validation = 0,
  early_stop = NULL,
  objective = NULL,
  counts = TRUE,
  event_level = c("first", "second"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgboost_impl_+3A_x">x</code></td>
<td>
<p>A data frame or matrix of predictors</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_y">y</code></td>
<td>
<p>A vector (factor or numeric) or matrix (numeric) of outcome data.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_max_depth">max_depth</code></td>
<td>
<p>An integer for the maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_nrounds">nrounds</code></td>
<td>
<p>An integer for the number of boosting iterations.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_eta">eta</code></td>
<td>
<p>A numeric value between zero and one to control the learning rate.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_colsample_bynode">colsample_bynode</code></td>
<td>
<p>Subsampling proportion of columns for each node
within each tree. See the <code>counts</code> argument below. The default uses all
columns.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsampling proportion of columns for each tree.
See the <code>counts</code> argument below. The default uses all columns.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_min_child_weight">min_child_weight</code></td>
<td>
<p>A numeric value for the minimum sum of instance
weights needed in a child to continue to split.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_gamma">gamma</code></td>
<td>
<p>A number for the minimum loss reduction required to make a
further partition on a leaf node of the tree</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_subsample">subsample</code></td>
<td>
<p>Subsampling proportion of rows. By default, all of the
training data are used.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_validation">validation</code></td>
<td>
<p>A positive number. If on <code style="white-space: pre;">&#8288;[0, 1)&#8288;</code> the value, <code>validation</code>
is a random proportion of data in <code>x</code> and <code>y</code> that are used for performance
assessment and potential early stopping. If 1 or greater, it is the <em>number</em>
of training set samples use for these purposes.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_early_stop">early_stop</code></td>
<td>
<p>An integer or <code>NULL</code>. If not <code>NULL</code>, it is the number of
training iterations without improvement before stopping. If <code>validation</code> is
used, performance is base on the validation set; otherwise the training set
is used.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_counts">counts</code></td>
<td>
<p>A logical. If <code>FALSE</code>, <code>colsample_bynode</code> and
<code>colsample_bytree</code> are both assumed to be <em>proportions</em> of the proportion of
columns affects (instead of counts).</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_event_level">event_level</code></td>
<td>
<p>For binary classification, this is a single string of either
<code>"first"</code> or <code>"second"</code> to pass along describing which level of the outcome
should be considered the &quot;event&quot;.</p>
</td></tr>
<tr><td><code id="xgboost_impl_+3A_...">...</code></td>
<td>
<p>Other options to pass to <code>xgb.train()</code> or xgboost's method for <code>predict()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='xgboost_predict'>Wrapper for xgboost::predict</h2><span id='topic+xgboost_predict'></span>

<h3>Description</h3>

<p>Wrapper for xgboost::predict
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgboost_predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgboost_predict_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="xgboost_predict_+3A_newdata">newdata</code></td>
<td>
<p>New data to be predicted</p>
</td></tr>
<tr><td><code id="xgboost_predict_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
