<!DOCTYPE html><html><head><title>Help for package reader</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reader}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cat.path'><p>Simple and robust way to create full-path file names.</p></a></li>
<li><a href='#classify.ext'><p>Classify file types readable by standard R I/O functions.</p></a></li>
<li><a href='#column.salvage'><p>Change column name in different form to desired form.</p></a></li>
<li><a href='#conv.fixed.width'><p>Convert a matrix or dataframe to fixed-width for nice file output</p></a></li>
<li><a href='#file.ncol'><p>Find the number of columns (lines) in a file.</p></a></li>
<li><a href='#file.nrow'><p>Find the number of rows (lines) in a file.</p></a></li>
<li><a href='#find.file'><p>Search for a directory to add to the path so that a file exists.</p></a></li>
<li><a href='#find.id.col'><p>Find which column in a dataframe contains a specified set of values.</p></a></li>
<li><a href='#force.frame'><p>returns a dataframe if 'unknown.data' can in anyway relate to such:</p></a></li>
<li><a href='#force.vec'><p>returns a vector if 'unknown.data' can in anyway relate to such:</p></a></li>
<li><a href='#get.delim'><p>Determine the delimiter for a text data file.</p></a></li>
<li><a href='#get.ext'><p>Get the file extension from a file-name.</p></a></li>
<li><a href='#is.file'><p>Test whether a file exists in a target directory, or alternative</p>
list of directories.</a></li>
<li><a href='#n.readLines'><p>Read 'n' lines (ignoring comments and header) from a file.</p></a></li>
<li><a href='#parse.args'><p>Function to collect arguments when running R from the command line</p></a></li>
<li><a href='#reader'><p>Flexibly load from a text or binary file, accepts multiple file formats.</p></a></li>
<li><a href='#reader-internal'><p>Internal reader Functions</p></a></li>
<li><a href='#reader-package'>
<p>Suite of Functions to Flexibly Read Data from Files</p></a></li>
<li><a href='#rmv.ext'><p>Remove the file extension from a file-name.</p></a></li>
<li><a href='#shift.rownames'><p>Shift the first column of a dataframe to rownames() if appropriate.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Suite of Functions to Flexibly Read Data from Files</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-12-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Cooper</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas Cooper &lt;njcooper@gmx.co.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), utils, NCmisc (&ge; 1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions to simplify reading data from files. The main function, reader(), should read most common R datafile types without needing any parameters except the filename. Other functions provide simple ways of handling file paths and extensions, and automatically detecting file format and structure.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>'reader.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-02 18:53:27 UTC; ncooper</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-03 07:41:03</td>
</tr>
</table>
<hr>
<h2 id='cat.path'>Simple and robust way to create full-path file names.</h2><span id='topic+cat.path'></span>

<h3>Description</h3>

<p>Create a path with a file name, plus optional directory, prefix,
suffix, and file extension. dir/ext are robust, so that if they
already exist, the path produced will still make sense. Prefix is
applied after the directory, and suffix before the file extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat.path(dir = "", fn, pref = "", suf = "", ext = "",
  must.exist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat.path_+3A_dir">dir</code></td>
<td>
<p>directory for the full path, if 'fn' already has a dir,
then dir will be overridden. Auto add file separator if not present</p>
</td></tr>
<tr><td><code id="cat.path_+3A_fn">fn</code></td>
<td>
<p>compulsory vector of file names/paths</p>
</td></tr>
<tr><td><code id="cat.path_+3A_pref">pref</code></td>
<td>
<p>prefix to add in front of the file name</p>
</td></tr>
<tr><td><code id="cat.path_+3A_suf">suf</code></td>
<td>
<p>suffix to add after the file name, before the extension</p>
</td></tr>
<tr><td><code id="cat.path_+3A_ext">ext</code></td>
<td>
<p>file extension, will override an existing extension</p>
</td></tr>
<tr><td><code id="cat.path_+3A_must.exist">must.exist</code></td>
<td>
<p>the specified file must already exist, else error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns vector of file names with the full paths
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydir &lt;- "/Documents"
cat.path(mydir,"temp.doc")
# dir not added if one already present
cat.path(mydir,"/Downloads/me/temp.doc")
# using prefix and suffix
cat.path(mydir,"temp.doc","NEW",suf=5)
# changing the extension from .docx to .doc
cat.path(mydir,"temp.docx",ext="doc")
</code></pre>

<hr>
<h2 id='classify.ext'>Classify file types readable by standard R I/O functions.</h2><span id='topic+classify.ext'></span>

<h3>Description</h3>

<p>Look for known file extensions and classify as binary, comma-separated,
text format, or OTH=other; other files are assumed to be unreadable.
To read other files, need to specify more types manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify.ext(ext = NULL, more.txt = NULL, more.bin = NULL,
  more.csv = NULL, print.all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify.ext_+3A_ext">ext</code></td>
<td>
<p>filenames or extensions to classify</p>
</td></tr>
<tr><td><code id="classify.ext_+3A_more.txt">more.txt</code></td>
<td>
<p>more extensions that should be treated as txt</p>
</td></tr>
<tr><td><code id="classify.ext_+3A_more.bin">more.bin</code></td>
<td>
<p>more extensions that should be treated as binary</p>
</td></tr>
<tr><td><code id="classify.ext_+3A_more.csv">more.csv</code></td>
<td>
<p>more extensions that should be treated as csv</p>
</td></tr>
<tr><td><code id="classify.ext_+3A_print.all">print.all</code></td>
<td>
<p>setting to T, simply prints the list of supported ext</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the 4 way classification for each file/extension
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.delim">get.delim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>classify.ext(c("test.txt","*.csv","tot","other","rda","test.RDatA"))
</code></pre>

<hr>
<h2 id='column.salvage'>Change column name in different form to desired form.</h2><span id='topic+column.salvage'></span>

<h3>Description</h3>

<p>Searches for possible equivalents for a desired column in a dataframe
and replaces first name match with desired name. Useful when parsing
different annotation files which may have standard columns with slightly
different names, e.g, Gender=SEX=sex=M/F, or ID=id=ids=samples=subjectID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>column.salvage(frame, desired, testfor, ignore.case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="column.salvage_+3A_frame">frame</code></td>
<td>
<p>a dataframe or matrix with column names</p>
</td></tr>
<tr><td><code id="column.salvage_+3A_desired">desired</code></td>
<td>
<p>the column name wanted</p>
</td></tr>
<tr><td><code id="column.salvage_+3A_testfor">testfor</code></td>
<td>
<p>possible alternate forms of the desired column name</p>
</td></tr>
<tr><td><code id="column.salvage_+3A_ignore.case">ignore.case</code></td>
<td>
<p>whether to ignore the upper/lower case of the column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the original dataframe with the target column renamed
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(Sex=c("M","F","F"),time=c(9,12,3),ID=c("ID3121","ID3122","ID2124"))
# standard example
new.df &lt;- column.salvage(df,"sex",c("gender","sex","M/F")); df; new.df
# exact column already present so no change
new.df &lt;- column.salvage(df,"ID",c("ID","id","ids","samples","subjectID")); df; new.df
# ignore case==TRUE potentially results in not finding desired column:
new.df &lt;- column.salvage(df,"sex",c("gender","sex","M/F"),ignore.case=FALSE); df; new.df
</code></pre>

<hr>
<h2 id='conv.fixed.width'>Convert a matrix or dataframe to fixed-width for nice file output</h2><span id='topic+conv.fixed.width'></span>

<h3>Description</h3>

<p>Pads each column to a common size so write.table() produces a
fixed width format that looks nice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv.fixed.width(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv.fixed.width_+3A_dat">dat</code></td>
<td>
<p>data.frame or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns dat with space padding as character
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a> #' @author Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
df &lt;- data.frame(ID=paste("ID",99:108,sep=""),
  scores=sample(150,10,TRUE)+30,age=sample(16,10,TRUE))
dff &lt;- conv.fixed.width(df)
write.table(df,file="notFW.txt",row.names=FALSE,col.names=FALSE,quote=FALSE)
write.table(dff,file="isFW.txt",row.names=FALSE,col.names=FALSE,quote=FALSE)
cat("Fixed-width:\n",paste(readLines("isFW.txt"),"\n"),sep="")
cat("standard-format:\n",paste(readLines("notFW.txt"),"\n"),sep="")
unlink(c("isFW.txt","notFW.txt"))
setwd(orig.dir) # reset working dir to original
</code></pre>

<hr>
<h2 id='file.ncol'>Find the number of columns (lines) in a file.</h2><span id='topic+file.ncol'></span>

<h3>Description</h3>

<p>Returns the number of columns in a datafile. File equivalent of ncol()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file.ncol(fn, reader = FALSE, del = NULL, comment = "#", skip = 0,
  force = FALSE, excl.rn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file.ncol_+3A_fn">fn</code></td>
<td>
<p>name of the file(s) to get the length of</p>
</td></tr>
<tr><td><code id="file.ncol_+3A_reader">reader</code></td>
<td>
<p>try to read the entire file to get a result, else
looks at the top few lines (ignoring comments)</p>
</td></tr>
<tr><td><code id="file.ncol_+3A_del">del</code></td>
<td>
<p>specify a delimiter (else this will be auto-detected)</p>
</td></tr>
<tr><td><code id="file.ncol_+3A_comment">comment</code></td>
<td>
<p>a comment symbol to ignore lines in files</p>
</td></tr>
<tr><td><code id="file.ncol_+3A_skip">skip</code></td>
<td>
<p>number of lines to skip at top of file before processing</p>
</td></tr>
<tr><td><code id="file.ncol_+3A_force">force</code></td>
<td>
<p>try to read the file regardless of whether it looks
like an invalid file type. Only use when you know the files are valid</p>
</td></tr>
<tr><td><code id="file.ncol_+3A_excl.rn">excl.rn</code></td>
<td>
<p>exclude rownames from column count (essentially subtract 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns number of columns in file(s). If no delimiter, then =1
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+file.nrow">file.nrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
write.table(matrix(rnorm(100),nrow=10),"temp.txt",col.names=FALSE,row.names=FALSE)
file.ncol("temp.txt",excl.rn=TRUE)
unlink("temp.txt")
# find ncol for all files in current directory:
# [NB: use with caution, will be slow if dir contains large files]
# not run # lf &lt;- list.files(); if(length(lf)==0) { print("no files in dir") }
# lf &lt;- lf[classify.ext(lf)=="TXT"]
# not run (only works if length(lf)&gt;0) # file.ncol(lf) 
setwd(orig.dir) # reset working directory to original
</code></pre>

<hr>
<h2 id='file.nrow'>Find the number of rows (lines) in a file.</h2><span id='topic+file.nrow'></span>

<h3>Description</h3>

<p>Returns the number of lines in a file, which in the case of a datafile
will often correspond to the number of rows, or rows+1. Can also
do this for all files in the directory. File equivalent of nrow()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file.nrow(fn = "", dir = "", all.in.dir = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file.nrow_+3A_fn">fn</code></td>
<td>
<p>name of the file(s) to get the length of</p>
</td></tr>
<tr><td><code id="file.nrow_+3A_dir">dir</code></td>
<td>
<p>optional path for fn location, or specify all files in dir</p>
</td></tr>
<tr><td><code id="file.nrow_+3A_all.in.dir">all.in.dir</code></td>
<td>
<p>select whether to extract length for all files in dir</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns length of file (or all files)
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+file.ncol">file.ncol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
write.table(matrix(rnorm(100),nrow=10),"temp.txt",col.names=FALSE)
file.nrow("temp.txt")
# use with caution, will be slow if dir contains large files
# not run # file.nrow(all.in.dir=TRUE) 
unlink("temp.txt")
setwd(orig.dir) # reset working directory to original
</code></pre>

<hr>
<h2 id='find.file'>Search for a directory to add to the path so that a file exists.</h2><span id='topic+find.file'></span>

<h3>Description</h3>

<p>Looks for a file named 'fn' in 'dir', and if not found there, 
broadens the search to the list or vector of directorys, 'dirs'.
Returns the full path of the first match that exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.file(fn, dir = "", dirs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.file_+3A_fn">fn</code></td>
<td>
<p>name of the file to search for</p>
</td></tr>
<tr><td><code id="find.file_+3A_dir">dir</code></td>
<td>
<p>the first directory to look in (expected location)</p>
</td></tr>
<tr><td><code id="find.file_+3A_dirs">dirs</code></td>
<td>
<p>vector/list, a set of directories to look in should
the file not be found in 'dir'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if the file is found, returns the full path of the file,
else returns an empty string &quot;&quot;
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.file">is.file</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
l.fn &lt;- "temp.txt"
writeLines("test",con=l.fn)
find.file(l.fn)
find.file(l.fn,dir=getwd())
unlink(l.fn)
# not run # common.places &lt;- ## &lt;&lt;add local folder here&gt;&gt; ##
# not run # d.fn &lt;- cat.path(common.places[1],l.fn)
# write this example file to the first of the folders #
# not run # if(!file.exists(d.fn)) {  writeLines("test2",con=d.fn) }
# search the local folders for a
# a file named 'temp.txt'
# not run # find.file(l.fn,dir=getwd(),dirs=common.places)
# unlink(d.fn) # run only if test file produced
setwd(orig.dir) # reset working dir to original
</code></pre>

<hr>
<h2 id='find.id.col'>Find which column in a dataframe contains a specified set of values.</h2><span id='topic+find.id.col'></span>

<h3>Description</h3>

<p>Starting with a list of ids, each column is searched. The column with
the highest non-zero percentage matching is assumed to correspond
to the id list. The search terminates early if a perfect match is 
found. Useful for assembling annotation from multiple sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.id.col(frame, ids, ret = c("col", "maxpc", "index", "result"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.id.col_+3A_frame">frame</code></td>
<td>
<p>a data.frame, or similarly 2 dimensional object which 
might contain ids</p>
</td></tr>
<tr><td><code id="find.id.col_+3A_ids">ids</code></td>
<td>
<p>a vector of IDs/value that might be found in at least 
1 column of frame</p>
</td></tr>
<tr><td><code id="find.id.col_+3A_ret">ret</code></td>
<td>
<p>specify what should be returned, see values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ret can specify a list returning, 'col': the column number 
(col=0 for rownames) with the best match; 'maxpc': the percentage
of ids found in the best matching column; 'index': the matching vector
that maps the frame rows onto ids; 'results': the (sub)set of ids
found in frame. NAs given for ids not found
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new.frame &lt;- data.frame(day=c("M","T","W"),time=c(9,12,3),staff=c("Mary","Jane","John"))
staff.ids &lt;- c("Mark","Jane","John","Andrew","Sally","Mary")
new.frame; staff.ids; find.id.col(new.frame,staff.ids)
</code></pre>

<hr>
<h2 id='force.frame'>returns a dataframe if 'unknown.data' can in anyway relate to such:</h2><span id='topic+force.frame'></span>

<h3>Description</h3>

<p>it can be:
- dataframe, matrix, big.matrix, sub.big.matrix, big.matrix.descriptor,
a bigmatrix description file, an RData file containing one of these 
objects, the name of a text or RData file, a named vector (names 
become rownames), or a list containing a matrix or dataframe. 
Using this within functions allows flexibility in 
specification of a datasource
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force.frame(unknown.data, too.big = 10^7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="force.frame_+3A_unknown.data">unknown.data</code></td>
<td>
<p>something that is or can refer to a 2d dataset</p>
</td></tr>
<tr><td><code id="force.frame_+3A_too.big">too.big</code></td>
<td>
<p>max size in GB, to prevent unintended conversion to 
matrix of a very large big.matrix object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data.frame regardless of the original object type
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+force.vec">force.vec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a matrix, binary file, text file, big.matrix.descriptor
orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
test.files &lt;- c("temp.rda","temp.txt")
mymat &lt;- matrix(rnorm(100),nrow=10)
# not run yet # require(bigmemory)
save(mymat,file=test.files[1])
write.table(mymat,file=test.files[2],col.names=FALSE,row.names=FALSE)
test.frames &lt;- list(mymat = mymat,
 myrda = test.files[1], mytxt = test.files[2] )
 # not run yet #: ,mybig = describe(as.big.matrix(mymat)) )
sapply(sapply(test.frames,is),"[",1)
# run the function on each, reporting specs of the object returned
for (cc in 1:length(test.frames)) {
  the.frame &lt;- force.frame(test.frames[[cc]])
  cat(names(test.frames)[cc],": dim() =&gt; ",
      paste(dim(the.frame),collapse=","),
      "; is() =&gt; ",is(the.frame)[1],"\n",sep="")
}
unlink(test.files)
setwd(orig.dir) # reset working dir to original
</code></pre>

<hr>
<h2 id='force.vec'>returns a vector if 'unknown.data' can in anyway relate to such:</h2><span id='topic+force.vec'></span>

<h3>Description</h3>

<p>if the name of a file with a vector or vector, then reads the file,
if a matrix or dataframe, then preferentially return rownames, 
otherwise return first column - designed to search for IDs.
Using this within functions allows flexibility in 
the specification of a datasource for vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force.vec(unknown.data, most.unique = TRUE, dir = NULL, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="force.vec_+3A_unknown.data">unknown.data</code></td>
<td>
<p>something that is or can refer to a 2d dataset</p>
</td></tr>
<tr><td><code id="force.vec_+3A_most.unique">most.unique</code></td>
<td>
<p>if TRUE, select most unique column if a unknown.data
is a matrix, else select the first column</p>
</td></tr>
<tr><td><code id="force.vec_+3A_dir">dir</code></td>
<td>
<p>if unknown.data is a file name, specifies directory(s) to
look for the file</p>
</td></tr>
<tr><td><code id="force.vec_+3A_warn">warn</code></td>
<td>
<p>whether to display a warning if unknown.data is a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector regardless of the original object type
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+force.frame">force.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a matrix, binary file, and simple vector
my.ids &lt;- paste("ID",1:4,sep="")
my.dat &lt;- sample(2,4,replace=TRUE)
test.files &lt;- c("temp.rda")
mymat &lt;- cbind(my.ids,my.dat)
save(mymat,file=test.files[1])
test.vecs &lt;- list(myvec = my.ids,
 myrda = test.files[1],mymat=mymat)
# show dimensions of each test object
sapply(test.vecs,function(x) {  if(is.null(dim(x))){ length(x)} else {dim(x)}})
# run the function on each, reporting specs of the object returned
for (cc in 1:3) {
  the.vec &lt;- force.vec(test.vecs[[cc]])
  cat(names(test.vecs)[cc],": length() =&gt; ",
      length(the.vec),"; is() =&gt; ",is(the.vec)[1],"\n",sep="")
}
unlink(test.files)
</code></pre>

<hr>
<h2 id='get.delim'>Determine the delimiter for a text data file.</h2><span id='topic+get.delim'></span>

<h3>Description</h3>

<p>Reads the first few lines of data in a text file and attempts to
infer what delimiter is in use, based on the 'delims' argument
that would result in the most consistent number of columns in the
first 'n' lines of data. Searches preferentially for delimiters
implying between 2 and 'large' columns, then for &gt;large, and lastly
for 1 column if nothing else gives a match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.delim(fn, n = 10, comment = "#", skip = 0, delims = c("\t",
  "\t| +", " ", ";", ","), large = 10, one.byte = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.delim_+3A_fn">fn</code></td>
<td>
<p>name of the file to parse</p>
</td></tr>
<tr><td><code id="get.delim_+3A_n">n</code></td>
<td>
<p>the number of lines to read to make the inference</p>
</td></tr>
<tr><td><code id="get.delim_+3A_comment">comment</code></td>
<td>
<p>a comment symbol to ignore lines in files</p>
</td></tr>
<tr><td><code id="get.delim_+3A_skip">skip</code></td>
<td>
<p>number of lines to skip at top of file before processing</p>
</td></tr>
<tr><td><code id="get.delim_+3A_delims">delims</code></td>
<td>
<p>the set of delimiters to test for</p>
</td></tr>
<tr><td><code id="get.delim_+3A_large">large</code></td>
<td>
<p>search initially for delimiters that imply more than 1, 
and less than this 'large' columns; if none in this range, look next
at &gt;large.</p>
</td></tr>
<tr><td><code id="get.delim_+3A_one.byte">one.byte</code></td>
<td>
<p>only check for one-byte delimiters, [e.g, whitespace regular expr is &gt;1 byte]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns character of the most likely delimiter
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reader">reader</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
df &lt;- data.frame(ID=paste("ID",101:110,sep=""),
  scores=sample(70,10,TRUE)+30,age=sample(7,10,TRUE)+11)
# save data to various file formats
test.files &lt;- c("temp.txt","temp2.txt","temp3.csv")
write.table(df,file=test.files[1],col.names=FALSE,row.names=FALSE,sep="|",quote=TRUE)
write.table(df,file=test.files[2],col.names=TRUE,row.names=TRUE,sep="\t",quote=FALSE)
write.csv(df,file=test.files[3])
# report the delimiters
for (cc in 1:length(test.files)) { 
  cat("\n",test.files[cc],": ")
  print(get.delim(test.files[cc])) }
unlink(test.files)
setwd(orig.dir) # reset working dir to original
</code></pre>

<hr>
<h2 id='get.ext'>Get the file extension from a file-name.</h2><span id='topic+get.ext'></span>

<h3>Description</h3>

<p>Get the file extension from a file-name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.ext(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.ext_+3A_fn">fn</code></td>
<td>
<p>filename(s) (with full path is ok too)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the (usually) 3 character file extension of a filename
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmv.ext">rmv.ext</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.ext("/documents/nick/mydoc.xlsx")
get.ext(c("temp.cnv","temp.txt"))
</code></pre>

<hr>
<h2 id='is.file'>Test whether a file exists in a target directory, or alternative
list of directories.</h2><span id='topic+is.file'></span>

<h3>Description</h3>

<p>Looks for a file named 'fn' in 'dir', and if not found there, 
broadens the search to the list or vector of directorys, 'dirs'.
Returns TRUE or FALSE as to whether the file exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.file(fn, dir = "", dirs = NULL, combine = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.file_+3A_fn">fn</code></td>
<td>
<p>name of the file to search for</p>
</td></tr>
<tr><td><code id="is.file_+3A_dir">dir</code></td>
<td>
<p>the first directory to look in (expected location)</p>
</td></tr>
<tr><td><code id="is.file_+3A_dirs">dirs</code></td>
<td>
<p>vector/list, a set of directories to look in should
the file not be found in 'dir'.</p>
</td></tr>
<tr><td><code id="is.file_+3A_combine">combine</code></td>
<td>
<p>if a list is given, test whether ALL files valid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector of whether each file was found,  or  if
combine is true, then a single value whether ALL valid or not.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find.file">find.file</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
l.fn &lt;- "temp.txt"
writeLines("test",con=l.fn)
some.local.files &lt;- narm(list.files()[1:10])
print(some.local.files)
is.file(l.fn)
is.file(l.fn,dir=getwd())
is.file(some.local.files)
# add a non-valid file to the list to see what happens
is.file(c(some.local.files,"fakefile.unreal"))
is.file(c(some.local.files,"fakefile.unreal"),combine=FALSE)
unlink(l.fn)
setwd(orig.dir) # reset working dir to original
</code></pre>

<hr>
<h2 id='n.readLines'>Read 'n' lines (ignoring comments and header) from a file.</h2><span id='topic+n.readLines'></span>

<h3>Description</h3>

<p>Useful when you don't know the length/structure of a file
and want a useful sample to look at. Can skip ahead in the file too.
Copes well when there are less than 'n' lines in the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.readLines(fn, n, comment = "#", skip = 0, header = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.readLines_+3A_fn">fn</code></td>
<td>
<p>name of the file(s) to get the length of</p>
</td></tr>
<tr><td><code id="n.readLines_+3A_n">n</code></td>
<td>
<p>number of valid lines to attempt to read
looks at the top few lines (ignoring comments)</p>
</td></tr>
<tr><td><code id="n.readLines_+3A_comment">comment</code></td>
<td>
<p>a comment symbol to ignore lines in files</p>
</td></tr>
<tr><td><code id="n.readLines_+3A_skip">skip</code></td>
<td>
<p>number of lines to skip at top of file before processing</p>
</td></tr>
<tr><td><code id="n.readLines_+3A_header">header</code></td>
<td>
<p>whether to allow for, and skip, a header row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the first n lines of the file meeting the criteria,
or if 'skip' implies lines beyond the length of the file, the 
result,will be truncated - although in this case, the last 
line will always be read.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
dat &lt;- matrix(sample(100),nrow=10)
write.table(dat,"temp.txt",col.names=FALSE,row.names=FALSE)
n.readLines("temp.txt",n=2,skip=2,header=FALSE)
dat[3:4,]
unlink("temp.txt")
setwd(orig.dir) # reset working directory to original
</code></pre>

<hr>
<h2 id='parse.args'>Function to collect arguments when running R from the command line</h2><span id='topic+parse.args'></span>

<h3>Description</h3>

<p>Allows parameter specification by A=..., B=... in the command line
e.g, R &lt; myScript.R M=1 NAME=John X=10.5, using commandArgs()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.args(arg.list = NULL, coms = c("X"), def = 0, list.out = F,
  verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.args_+3A_arg.list">arg.list</code></td>
<td>
<p>the result of a commandArgs() call, or else NULL to
initiate this call within the function</p>
</td></tr>
<tr><td><code id="parse.args_+3A_coms">coms</code></td>
<td>
<p>list of valid commands to look for, not case sensitive</p>
</td></tr>
<tr><td><code id="parse.args_+3A_def">def</code></td>
<td>
<p>list of default values for each parameter (in same order)</p>
</td></tr>
<tr><td><code id="parse.args_+3A_list.out">list.out</code></td>
<td>
<p>logical, whether to return output as a list or data.frame</p>
</td></tr>
<tr><td><code id="parse.args_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to print to the console which assignments are made and warning messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns dataframe showing the resulting values [column 1, &quot;value&quot;] for each 'coms' (rownames); or, if
list.out=TRUE, then returns a list with names corresponding to 'coms' and values equivalent to 'value' column of 
the data.frame that would be returned if list.out=FALSE
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse.args(c("M=1","NAME=John","X=10.5"),coms=c("M","X","NAME"))
parse.args(c("N=1")) # invalid command entered, ignored with warning
temp.fn &lt;- "tempScript1234.R"
# make a temporary R Script file to call using the command line
# not run # writeLines(c("require(reader)","parse.args(coms=c('M','X','NAME'))"),con=temp.fn)
bash.cmd &lt;- "R --no-save &lt; tempScript1234.R M=1 NAME=John X=10.5"
# run above command in the terminal, or using 'system' below:
# not run # arg &lt;- system(bash.cmd)
# not run # unlink(temp.fn) # delete temporary file
</code></pre>

<hr>
<h2 id='reader'>Flexibly load from a text or binary file, accepts multiple file formats.</h2><span id='topic+reader'></span>

<h3>Description</h3>

<p>Uses file extension to distinguish between binary, csv or other 
text formats. Then tries to automatically determine other parameters
necessary to read the file. Will attempt to detect the delimiter,
and detect whether there is a heading/column names, and whether 
the first column should be rownames, or left as a data column.
Internal calls to standard file reading functions use 
'stringsAsFactors=FALSE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reader(fn, dir = "", want.type = NULL, def = "\t", force.read = TRUE,
  header = NA, h.test.p = 0.05, quiet = TRUE, treatas = NULL,
  override = FALSE, more.types = NULL, auto.vec = TRUE, one.byte = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reader_+3A_fn">fn</code></td>
<td>
<p>filename (with or without path if dir is specified)</p>
</td></tr>
<tr><td><code id="reader_+3A_dir">dir</code></td>
<td>
<p>optional directory if separate path/filename is preferred</p>
</td></tr>
<tr><td><code id="reader_+3A_want.type">want.type</code></td>
<td>
<p>if loading a binary file with multiple objects, specify
here the is() type of object you are trying to load</p>
</td></tr>
<tr><td><code id="reader_+3A_def">def</code></td>
<td>
<p>the default delimiter to try first</p>
</td></tr>
<tr><td><code id="reader_+3A_force.read">force.read</code></td>
<td>
<p>attempt to read the file even if the file type looks unsupported</p>
</td></tr>
<tr><td><code id="reader_+3A_header">header</code></td>
<td>
<p>presence of a header should be autodetected, but can specify header status 
if you don't trust the autodetection</p>
</td></tr>
<tr><td><code id="reader_+3A_h.test.p">h.test.p</code></td>
<td>
<p>p value to discriminate between number of characters in a column name versus
a column value (sensitivity parameter for automatic header detection)</p>
</td></tr>
<tr><td><code id="reader_+3A_quiet">quiet</code></td>
<td>
<p>run without messages and warnings</p>
</td></tr>
<tr><td><code id="reader_+3A_treatas">treatas</code></td>
<td>
<p>a standard file extension, e.g, 'txt', to treat file as</p>
</td></tr>
<tr><td><code id="reader_+3A_override">override</code></td>
<td>
<p>assume first col is rownames, regardless of heuristic</p>
</td></tr>
<tr><td><code id="reader_+3A_more.types">more.types</code></td>
<td>
<p>optionally add more file types which are read as text</p>
</td></tr>
<tr><td><code id="reader_+3A_auto.vec">auto.vec</code></td>
<td>
<p>if the file seems to only have a single column, automatically
return the result as a vector rather than a dataframe with 1 column</p>
</td></tr>
<tr><td><code id="reader_+3A_one.byte">one.byte</code></td>
<td>
<p>logical parameter, passed to 'get.delim', whether to look for only 1-byte
delimiters, to also search for 'whitespace' which is a multibyte (wildcard) delimiter type. 
Use one.byte = FALSE, to read fixed width files, e.g, many plink files.</p>
</td></tr>
<tr><td><code id="reader_+3A_...">...</code></td>
<td>
<p>further arguments to the function used by 'reader' to parse the file,
e.g, depending on file.type, can be read.table(), read.delim(), read.csv().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the most appropriate object depending on the file type,
which is usually a data.frame except for binary files
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
# create some datasets
df &lt;- data.frame(ID=paste("ID",101:110,sep=""),
  scores=sample(70,10,TRUE)+30,age=sample(7,10,TRUE)+11)
DNA &lt;- apply(matrix(c("A","C","G","T")[sample(4,100,TRUE)],nrow=10),
                                                1,paste,collapse="")
fix.wid &lt;- c("    MyVal    Results        Check",
  "    0.234      42344          yes",
  "    0.334        351          yes","    0.224         46           no",
  "    0.214     445391          yes")
# save data to various file formats
test.files &lt;- c("temp.txt","temp2.txt","temp3.csv",
                              "temp4.rda","temp5.fasta","temp6.txt")
write.table(df,file=test.files[1],col.names=FALSE,row.names=FALSE,sep="|",quote=TRUE)
write.table(df,file=test.files[2],col.names=TRUE,row.names=TRUE,sep="\t",quote=FALSE)
write.csv(df,file=test.files[3])
save(df,file=test.files[4])
writeLines(DNA,con=test.files[5])
writeLines(fix.wid,con=test.files[6])
# use the same reader() function call to read in each file
for(cc in 1:length(test.files)) {
  cat(test.files[cc],"\n")
  myobj &lt;- reader(test.files[cc])  # add 'quiet=FALSE' to see some working
  print(myobj); cat("\n\n")
}
# inspect files before deleting if desired
unlink(test.files) 
# myobj &lt;- reader(file.choose()); myobj # run this to attempt opening a file
setwd(orig.dir) # reset working directory to original
</code></pre>

<hr>
<h2 id='reader-internal'>Internal reader Functions</h2><span id='topic+add.dir.if.not'></span><span id='topic+vec.extract.mat'></span><span id='topic+assess.dat.type'></span><span id='topic+is.ch'></span><span id='topic+wc.windows'></span><span id='topic+dir.force.slash'></span><span id='topic+as.df'></span>

<h3>Description</h3>

<p>Internal reader functions
</p>


<h3>Details</h3>

<p>These are not recommended/needed to be called by the user 
</p>

<hr>
<h2 id='reader-package'>
Suite of Functions to Flexibly Read Data from Files
</h2><span id='topic+reader-package'></span><span id='topic+reader-package'></span>

<h3>Description</h3>

<p>A set of functions to simplify reading data from files. The main function, reader(), should read most common R datafile 
types without needing any parameters except the filename. Other functions provide simple ways of handling file paths and 
extensions, and automatically detecting file format and structure.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> reader</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-12-29</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The reader() function, for which the package is named,
should be able to read most of the common types of datafiles used in R
without needing any arguments other than the filename. 
The structure, header, file-format and delimiter are determined automatically. 
Usually no extra parameters are needed. Other functions provide similarly flexibility
to run contigent on data type and file format, or can look for an input file in
multiple directory locations. The function cat.path() provides a simple interface to
construct file paths using directories, suffixes, prefixes and file extension.
Functions in this package can be nested inside new functions, providing flexible parameter format,
without having to use multiple if-statements to cope with contigencies. 
Supported types included delimited text files, R binary files,
big.matrix files, text list files, and unstructured text. Note that the file type
that will be attempted to read in is initially determine by the file extension,
using the function: 'classify.ext()'.
</p>
<p>List of key functions:
</p>

<ul>
<li><p><em>cat.path</em>  Simple and foolproof way to create full-path file names.
</p>
</li>
<li><p><em>classify.ext</em>  Classify file types readable by standard R I/O functions.
</p>
</li>
<li><p><em>column.salvage</em>  Change column name in different form to desired form.
</p>
</li>
<li><p><em>file.ncol</em>  Find the number of columns (lines) in a file.
</p>
</li>
<li><p><em>file.nrow</em>  Find the number of rows (lines) in a file.
</p>
</li>
<li><p><em>find.id.col</em>  Find which column in a dataframe contains a specified set of values.
</p>
</li>
<li><p><em>shift.rownames</em>  Shift the first column of a dataframe to rownames()
</p>
</li>
<li><p><em>force.frame</em>  returns a dataframe if 'unknown.data' can in anyway relate to such
</p>
</li>
<li><p><em>force.vec</em>  returns a vector if 'unknown.data' can in anyway relate to such
</p>
</li>
<li><p><em>get.delim</em>  Determine the delimiter for a text data file.
</p>
</li>
<li><p><em>get.ext</em>  Get the file extension from a file-name.
</p>
</li>
<li><p><em>is.file</em>  Test whether a file exists in a target directory.
</p>
</li>
<li><p><em>make.fixed.width</em>  Convert a matrix or dataframe to fixed-width.
</p>
</li>
<li><p><em>n.readLines</em>  Read 'n' lines (ignoring comments and header) from a file.
</p>
</li>
<li><p><em>parse.args</em>  Function to collect arguments when running R from the command line.
</p>
</li>
<li><p><em>reader</em>  Flexibly load from a text or binary file, accepts multiple file formats.
</p>
</li>
<li><p><em>rmv.ext</em>  Remove the file extension from a file-name.
</p>
</li>
<li><p><em>find.file</em>  Construct a path to a file, where multiple directories can be searched to find an existing file.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>
<p>Maintainer: 
Nicholas Cooper &lt;njcooper@gmx.co.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="NCmisc.html#topic+NCmisc-package">NCmisc</a></code> ~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydir &lt;- "/Documents"
cat.path(mydir,"temp.doc","NEW",suf=5)
## example for the reader() function ##
df &lt;- data.frame(ID=paste("ID",101:110,sep=""),
                 scores=sample(70,10,TRUE)+30,age=sample(7,10,TRUE)+11)
test.files &lt;- c("temp.txt","temp2.csv","temp3.rda")
write.table(df,file=test.files[1],col.names=TRUE,row.names=TRUE,sep="\t",quote=FALSE)
# file.nrow and file.ncol examples
file.nrow(test.files[1])
file.ncol(test.files[1])
write.csv(df,file=test.files[2])
save(df,file=test.files[3])
# use the same simple reader() function call to read in each file type
for(cc in 1:length(test.files)) {
    cat(test.files[cc],"\n")
    myobj &lt;- reader(test.files[cc])  # add 'quiet=F' to see some working
    print(myobj); cat("\n\n")
}
# inspect files before deleting if desired:
#  unlink(test.files)
#
# find id column in data frame
new.frame &lt;- data.frame(day=c("M","T","W"),time=c(9,12,3),staff=c("Mary","Jane","John"))
staff.ids &lt;- c("Mark","Jane","John","Andrew","Sally","Mary")
new.frame; find.id.col(new.frame,staff.ids)
</code></pre>

<hr>
<h2 id='rmv.ext'>Remove the file extension from a file-name.</h2><span id='topic+rmv.ext'></span>

<h3>Description</h3>

<p>Default is to only remove from a known list of file types,
this is to protect files with '.' which may not have an extension
This option can be changed, and more types can be specified too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmv.ext(fn = NULL, only.known = TRUE, more.known = NULL,
  print.known = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmv.ext_+3A_fn">fn</code></td>
<td>
<p>filename(s) (with full path is ok too)</p>
</td></tr>
<tr><td><code id="rmv.ext_+3A_only.known">only.known</code></td>
<td>
<p>logical, only remove extension if in the 'known' list</p>
</td></tr>
<tr><td><code id="rmv.ext_+3A_more.known">more.known</code></td>
<td>
<p>character vector, add to the list of known extensions</p>
</td></tr>
<tr><td><code id="rmv.ext_+3A_print.known">print.known</code></td>
<td>
<p>return the list of 'known' file extensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the file name/path without the file extension
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.ext">get.ext</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmv.ext(print.known=TRUE)
rmv.ext("/documents/nick/mydoc.xlsx")
rmv.ext(c("temp.cnv","temp.txt","temp.epi"))
# remove anything that looks like an extension
rmv.ext(c("temp.cnv","temp.txt","temp.epi"),only.known=FALSE) 
# add to list of known extensions
rmv.ext(c("temp.cnv","temp.txt","temp.epi"),more.known="epi") 
</code></pre>

<hr>
<h2 id='shift.rownames'>Shift the first column of a dataframe to rownames() if appropriate.</h2><span id='topic+shift.rownames'></span>

<h3>Description</h3>

<p>Checks whether the first column looks like IDs, and if so will.
remove the column, and move these values to rownames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.rownames(dataf, override = FALSE, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.rownames_+3A_dataf">dataf</code></td>
<td>
<p>data.frame to run the conversion on</p>
</td></tr>
<tr><td><code id="shift.rownames_+3A_override">override</code></td>
<td>
<p>assume col 1 is rownames, regardless of numeric() test</p>
</td></tr>
<tr><td><code id="shift.rownames_+3A_warn">warn</code></td>
<td>
<p>whether to display warnings if assumptions aren't met</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns vectors of strings of char, lengths X
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:nick.cooper@cimr.cam.ac.uk">nick.cooper@cimr.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reader">reader</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(ID=paste("ID",101:110,sep=""),
                   scores=sample(70,10,TRUE)+30,age=sample(7,10,TRUE)+11)
shift.rownames(df1)
df2 &lt;- data.frame(ID=paste(101:110),
                   scores=sample(70,10,TRUE)+30,age=sample(7,10,TRUE)+11)
shift.rownames(df2) # first col are all numbers, so no convert
shift.rownames(df2,override=TRUE) # override forces conversion
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
