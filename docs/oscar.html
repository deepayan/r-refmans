<!DOCTYPE html><html lang="en"><head><title>Help for package oscar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {oscar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#oscar-package'><p>oscar: Optimal Subset Cardinality Regression</p></a></li>
<li><a href='#coef+2Coscar-method'><p>Extract coefficients of oscar-objects</p></a></li>
<li><a href='#cost'><p>Return total cost of model fit based on provided kit/variable costs vector</p></a></li>
<li><a href='#Example+20data'><p>Example data from TYKS / HUSLAB</p></a></li>
<li><a href='#feat'><p>Return named vector of feature indices with a given k that are non-zero</p></a></li>
<li><a href='#kits'><p>Return named vector of indices for kits with a given k that are non-zero</p></a></li>
<li><a href='#oscar'><p>Main OSCAR fitting function</p></a></li>
<li><a href='#oscar-class'><p>S4-class for oscar</p></a></li>
<li><a href='#oscar.binarize'><p>Binary logical indicator matrix representation of an oscar object's coefficients (zero vs. non-zero, i.e. feature inclusion)</p></a></li>
<li><a href='#oscar.binplot'><p>Visualize binary indicator matrix optionally coupled with cross-validation performance for oscar models</p></a></li>
<li><a href='#oscar.bs'><p>Bootstrapping for oscar-fitted model objects</p></a></li>
<li><a href='#oscar.bs.boxplot'><p>Bootstrap visualization with boxplot, percentage of new additions</p></a></li>
<li><a href='#oscar.bs.k'><p>Reformatting bootstrap output for cardinality k rows</p></a></li>
<li><a href='#oscar.bs.plot'><p>Bootstrap heatmap plot for oscar models</p></a></li>
<li><a href='#oscar.bs.visu'><p>Visualize bootstrapping of a fit oscar object</p></a></li>
<li><a href='#oscar.control'><p>Control OSCAR optimizer parameters</p></a></li>
<li><a href='#oscar.cost.after'><p>Return total cost of model fits if the cost is not included in the oscar object</p></a></li>
<li><a href='#oscar.cv'><p>Cross-validation for oscar-fitted model objects over k-range</p></a></li>
<li><a href='#oscar.cv.visu'><p>Visualize cross-validation as a function of k</p></a></li>
<li><a href='#oscar.pareto'><p>Retrieve a set of pareto-optimal points for an oscar-model based on model goodness-of-fit or cross-validation</p></a></li>
<li><a href='#oscar.pareto.visu'><p>Visualize oscar model pareto front</p></a></li>
<li><a href='#oscar.sparsify'><p>Create a sparse matrix representation of betas as a function of k</p></a></li>
<li><a href='#oscar.visu'><p>Target function value and total kit cost as a function of number of kits included</p></a></li>
<li><a href='#show+2Coscar-method'><p>Showing oscar-objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Subset Cardinality Regression (OSCAR) Models Using the
L0-Pseudonorm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimal Subset Cardinality Regression (OSCAR) models offer
    regularized linear regression using the L0-pseudonorm, conventionally
    known as the number of non-zero coefficients. The package estimates an
    optimal subset of features using the L0-penalization via
    cross-validation, bootstrapping and visual diagnostics. Effective
    Fortran implementations are offered along the package for finding
    optima for the DC-decomposition, which is used for transforming the
    discrete L0-regularized optimization problem into a continuous
    non-convex optimization task. These optimization modules include DBDC
    ('Double Bundle method for nonsmooth DC optimization' as described in
    Joki et al. (2018) &lt;<a href="https://doi.org/10.1137%2F16M1115733">doi:10.1137/16M1115733</a>&gt;) and LMBM ('Limited
    Memory Bundle Method for large-scale nonsmooth optimization' as
    in Haarala et al. (2004) &lt;<a href="https://doi.org/10.1080%2F10556780410001689225">doi:10.1080/10556780410001689225</a>&gt;). The
    OSCAR models are comprehensively exemplified in Halkola et al. (2023) 
    &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1010333">doi:10.1371/journal.pcbi.1010333</a>&gt;). Multiple regression model families
    are supported: Cox, logistic, and Gaussian.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Syksy/oscar">https://github.com/Syksy/oscar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Syksy/oscar/issues">https://github.com/Syksy/oscar/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, hamlet, Matrix, methods, stats, survival,
utils, pROC</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ePCR, glmnet, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-02 00:04:47 UTC; teemu</td>
</tr>
<tr>
<td>Author:</td>
<td>Teemu Daniel Laajala
    <a href="https://orcid.org/0000-0002-7016-7354"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Kaisa Joki [aut],
  Anni Halkola [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 13:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='oscar-package'>oscar: Optimal Subset Cardinality Regression</h2><span id='topic+oscar-package'></span>

<h3>Description</h3>

<p>OSCAR models utilize the L0-pseudonorm to select an optimal subset of features that generalizes linear regression models to a variety of families. Currently supported models include conventional Gaussian regression (family=&quot;mse&quot; or family=&quot;gaussian&quot;), Binomial/Logistic regression (family=&quot;logistic&quot;), and Cox proportional hazards modeling (family=&quot;cox&quot;).
</p>


<h3>References</h3>

<p>Halkola AS, Joki K, Mirtti T, Mäkelä MM, Aittokallio T, Laajala TD (2023) OSCAR: Optimal subset cardinality regression using the L0-pseudonorm with applications to prognostic modelling of prostate cancer. PLoS Comput Biol 19(3): e1010333. <a href="https://doi.org/10.1371/journal.pcbi.1010333">doi:10.1371/journal.pcbi.1010333</a>
</p>

<hr>
<h2 id='coef+2Coscar-method'>Extract coefficients of oscar-objects</h2><span id='topic+coef+2Coscar-method'></span><span id='topic+predict+2Coscar-method'></span><span id='topic+plot+2Coscar-method'></span>

<h3>Description</h3>

<p>Extract coefficients of oscar-objects
</p>
<p>Prediction based on oscar-objects
</p>
<p>Plot oscar-coefficients as a function of k and override default plot generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'oscar'
coef(object, k)

## S4 method for signature 'oscar'
predict(
  object,
  k,
  type = c("response", "link", "nonzero", "coefficients", "label"),
  newdata = object@x
)

## S4 method for signature 'oscar'
plot(x, y, k = 1:x@kmax, add = FALSE, intercept = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef+2B2Coscar-method_+3A_object">object</code></td>
<td>
<p>Fit oscar S4-object</p>
</td></tr>
<tr><td><code id="coef+2B2Coscar-method_+3A_k">k</code></td>
<td>
<p>Vector of cardinality 'k' values</p>
</td></tr>
<tr><td><code id="coef+2B2Coscar-method_+3A_type">type</code></td>
<td>
<p>Type of prediction; valid values are 'response', 'link', 'nonzero', 'coefficients', or 'label'</p>
</td></tr>
<tr><td><code id="coef+2B2Coscar-method_+3A_newdata">newdata</code></td>
<td>
<p>Data to predict on; if no alternate is supplied, the function uses the original 'x' data matrix used to fit object</p>
</td></tr>
<tr><td><code id="coef+2B2Coscar-method_+3A_x">x</code></td>
<td>
<p>Values on x-axis</p>
</td></tr>
<tr><td><code id="coef+2B2Coscar-method_+3A_y">y</code></td>
<td>
<p>Values on y-axis</p>
</td></tr>
<tr><td><code id="coef+2B2Coscar-method_+3A_add">add</code></td>
<td>
<p>Should the plot be added on top of an existing plot (if FALSE, create a new graphics device), Default: FALSE</p>
</td></tr>
<tr><td><code id="coef+2B2Coscar-method_+3A_intercept">intercept</code></td>
<td>
<p>Should model intercept be plotted, Default: FALSE</p>
</td></tr>
<tr><td><code id="coef+2B2Coscar-method_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the points-function drawing lines as a function of cardinality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model coefficient values at given cardinality 'k'
</p>
<p>A vector of coefficient predictions at the specificied cardinality 'k' with a format depending on the supplied 'type' parameter
</p>
<p>Override default plot function with no return but instead tailor suitable graphics plotting
</p>

<hr>
<h2 id='cost'>Return total cost of model fit based on provided kit/variable costs vector</h2><span id='topic+cost'></span><span id='topic+cost+2Coscar-methods'></span><span id='topic+cost+2Coscar-method'></span>

<h3>Description</h3>

<p>Return total cost of model fit based on provided kit/variable costs vector
</p>
<p>Return total cost of model fit based on provided kit/variable costs vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost(object, k)

## S4 method for signature 'oscar'
cost(object, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_+3A_object">object</code></td>
<td>
<p>Fit oscar S4-object</p>
</td></tr>
<tr><td><code id="cost_+3A_k">k</code></td>
<td>
<p>Cardinality 'k' to compute total feature cost at</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of total feature/kit cost at cardinality 'k'
</p>
<p>Numeric value of total feature/kit cost at cardinality 'k'
</p>

<hr>
<h2 id='Example+20data'>Example data from TYKS / HUSLAB</h2><span id='topic+ex_X'></span><span id='topic+ex_Y'></span><span id='topic+ex_K'></span><span id='topic+ex_c'></span>

<h3>Description</h3>

<p>An example data set from mCRPC patients in TYKS, along with cost vector / kit structure from HUSLAB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(ex)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>	data(ex)
</code></pre>

<hr>
<h2 id='feat'>Return named vector of feature indices with a given k that are non-zero</h2><span id='topic+feat'></span><span id='topic+feat+2Coscar-methods'></span><span id='topic+feat+2Coscar-method'></span>

<h3>Description</h3>

<p>Return named vector of feature indices with a given k that are non-zero
</p>
<p>Return named vector of feature indices with a given k that are non-zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat(object, k)

## S4 method for signature 'oscar'
feat(object, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feat_+3A_object">object</code></td>
<td>
<p>Fit oscar S4-object</p>
</td></tr>
<tr><td><code id="feat_+3A_k">k</code></td>
<td>
<p>Cardinality 'k' to extract non-zero features at</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of feature indices at cardinality 'k'
</p>
<p>Vector of feature indices at cardinality 'k'
</p>

<hr>
<h2 id='kits'>Return named vector of indices for kits with a given k that are non-zero</h2><span id='topic+kits'></span><span id='topic+kits+2Coscar-methods'></span><span id='topic+kits+2Coscar-method'></span>

<h3>Description</h3>

<p>Return named vector of indices for kits with a given k that are non-zero
</p>
<p>Return named vector of indices for kits with a given k that are non-zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kits(object, k)

## S4 method for signature 'oscar'
kits(object, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kits_+3A_object">object</code></td>
<td>
<p>Fit oscar S4-object</p>
</td></tr>
<tr><td><code id="kits_+3A_k">k</code></td>
<td>
<p>Cardinality 'k' to extract kit indices at</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of kit indices at cardinality 'k'
</p>
<p>Vector of kit indices at cardinality 'k'
</p>

<hr>
<h2 id='oscar'>Main OSCAR fitting function</h2><span id='topic+oscar'></span>

<h3>Description</h3>

<p>This function fits an OSCAR model object to the provided training data with the desired model family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar(
  x,
  y,
  k,
  w,
  family = "cox",
  metric,
  solver = 1,
  verb = 1,
  print = 3,
  kmax,
  sanitize = TRUE,
  percentage = 1,
  in_selection = 1,
  storeX = TRUE,
  storeY = TRUE,
  control,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar_+3A_x">x</code></td>
<td>
<p>Data matrix 'x'</p>
</td></tr>
<tr><td><code id="oscar_+3A_y">y</code></td>
<td>
<p>Response vector/two-column matrix 'y' (see: family); number of rows equal to nrow(x)</p>
</td></tr>
<tr><td><code id="oscar_+3A_k">k</code></td>
<td>
<p>Integer (0/1) kit indicator matrix; number of columns equal to ncol(x), Default: Unit diagonal indicator matrix</p>
</td></tr>
<tr><td><code id="oscar_+3A_w">w</code></td>
<td>
<p>Kit cost weight vector w of length nrow(k), Default: Equal cost for all variables</p>
</td></tr>
<tr><td><code id="oscar_+3A_family">family</code></td>
<td>
<p>Model family, should be one of: 'cox', 'mse'/'gaussian', or 'logistic, Default: 'cox'</p>
</td></tr>
<tr><td><code id="oscar_+3A_metric">metric</code></td>
<td>
<p>Goodness metric, Default(s): Concordance index for Cox, MSE for Gaussian, and AUC for logistic regression</p>
</td></tr>
<tr><td><code id="oscar_+3A_solver">solver</code></td>
<td>
<p>Solver used in the optimization, should be  1/'DBDC' or 2/'LMBM', Default: 1.</p>
</td></tr>
<tr><td><code id="oscar_+3A_verb">verb</code></td>
<td>
<p>Level of verbosity in R, Default: 1</p>
</td></tr>
<tr><td><code id="oscar_+3A_print">print</code></td>
<td>
<p>Level of verbosity in Fortran (may not be visible on all terminals); should be an integer between range, range, Default: 3</p>
</td></tr>
<tr><td><code id="oscar_+3A_kmax">kmax</code></td>
<td>
<p>Maximum k step tested, by default all k are tested from k to maximum dimensionality, Default: ncol(x)</p>
</td></tr>
<tr><td><code id="oscar_+3A_sanitize">sanitize</code></td>
<td>
<p>Whether input column names should be cleaned of potentially problematic symbols, Default: TRUE</p>
</td></tr>
<tr><td><code id="oscar_+3A_percentage">percentage</code></td>
<td>
<p>Percentage of possible starting points used within range [0,1], Default: 1</p>
</td></tr>
<tr><td><code id="oscar_+3A_in_selection">in_selection</code></td>
<td>
<p>Which starting point selection strategy is used (1, 2 or 3), Default: 1</p>
</td></tr>
<tr><td><code id="oscar_+3A_storex">storeX</code></td>
<td>
<p>If data matrix X should be saved in the model object; turning this off might would help with memory, Default: TRUE</p>
</td></tr>
<tr><td><code id="oscar_+3A_storey">storeY</code></td>
<td>
<p>If data response Y should be saved in the model object; turning this off might would help with memory, Default: TRUE</p>
</td></tr>
<tr><td><code id="oscar_+3A_control">control</code></td>
<td>
<p>Tuning parameters for the optimizers, see function oscar.control(), Default: see ?oscar.control</p>
</td></tr>
<tr><td><code id="oscar_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OSCAR utilizes the L0-pseudonorm, also known as the best subset selection, and makes use of a DC-formulation of the discrete feature selection task into a continuous one. Then an appropriate optimization algorithm is utilized to find optima at different cardinalities (k). The S4 model objects 'oscar' can then be passed on to various down-stream functions, such as oscar.pareto, oscar.cv, and oscar.bs, along with their supporting visualization functions.
</p>


<h3>Value</h3>

<p>Fitted oscar-object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscar.cv">oscar.cv</a></code> <code><a href="#topic+oscar.bs">oscar.bs</a></code> <code><a href="#topic+oscar.pareto">oscar.pareto</a></code> <code><a href="#topic+oscar.visu">oscar.visu</a></code> <code><a href="#topic+oscar.cv.visu">oscar.cv.visu</a></code> <code><a href="#topic+oscar.bs.visu">oscar.bs.visu</a></code> <code><a href="#topic+oscar.pareto.visu">oscar.pareto.visu</a></code> <code><a href="#topic+oscar.binplot">oscar.binplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit
}
</code></pre>

<hr>
<h2 id='oscar-class'>S4-class for oscar</h2><span id='topic+oscar-class'></span>

<h3>Description</h3>

<p>S4-class for oscar
</p>

<hr>
<h2 id='oscar.binarize'>Binary logical indicator matrix representation of an oscar object's coefficients (zero vs. non-zero, i.e. feature inclusion)</h2><span id='topic+oscar.binarize'></span>

<h3>Description</h3>

<p>Create a sparse matrix with binary indicator 1 indicating that a coefficient was non-zero, and value 0 (or . in sparse matrix) indicating that a coefficient was zero (i.e. feature not included)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.binarize(fit, kmax = fit@kmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.binarize_+3A_fit">fit</code></td>
<td>
<p>Fit oscar-model object</p>
</td></tr>
<tr><td><code id="oscar.binarize_+3A_kmax">kmax</code></td>
<td>
<p>Create matrix until kmax-value; by default same as for fit object, but for high dimensional tasks one may wish to reduce this</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix consists of TRUE/FALSE values, and is very similar to the oscar.sparsify, where the function provides estimate values in a sparse matrix format.
</p>


<h3>Value</h3>

<p>A binary logical indicator matrix of variables (rows) as a function of cardinality k (columns), where elements are binary indicators for 1 as non-zero and 0 as zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  oscar.binarize(fit, kmax=5)
}

</code></pre>

<hr>
<h2 id='oscar.binplot'>Visualize binary indicator matrix optionally coupled with cross-validation performance for oscar models</h2><span id='topic+oscar.binplot'></span>

<h3>Description</h3>

<p>This visualization function makes use of the sparsified beta-coefficient matrix form as a function of cardinality. Optionally, user may showcase cross-validation performance alongside at the same cardinality values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.binplot(
  fit,
  cv,
  kmax,
  collines = TRUE,
  rowlines = TRUE,
  cex.axis = 0.6,
  heights = c(0.2, 0.8),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.binplot_+3A_fit">fit</code></td>
<td>
<p>Fitted oscar S4-class object</p>
</td></tr>
<tr><td><code id="oscar.binplot_+3A_cv">cv</code></td>
<td>
<p>Matrix produced by oscar.cv; rows are cv-folds, cols are k-values</p>
</td></tr>
<tr><td><code id="oscar.binplot_+3A_kmax">kmax</code></td>
<td>
<p>Maximum cardinality 'k'</p>
</td></tr>
<tr><td><code id="oscar.binplot_+3A_collines">collines</code></td>
<td>
<p>Should vertical lines be drawn to bottom part</p>
</td></tr>
<tr><td><code id="oscar.binplot_+3A_rowlines">rowlines</code></td>
<td>
<p>Should horizontal lines be drawn to highlight variables</p>
</td></tr>
<tr><td><code id="oscar.binplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis magnification</p>
</td></tr>
<tr><td><code id="oscar.binplot_+3A_heights">heights</code></td>
<td>
<p>Paneling proportions as a numeric vector of length 2</p>
</td></tr>
<tr><td><code id="oscar.binplot_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to hamlet::hmap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is a plotting function that does not return anything, but instead draws on a new graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_cv &lt;- oscar.cv(fit, fold = 10, seed = 123)
  oscar.binplot(fit=fit, cv=fit_cv)
}
</code></pre>

<hr>
<h2 id='oscar.bs'>Bootstrapping for oscar-fitted model objects</h2><span id='topic+oscar.bs'></span>

<h3>Description</h3>

<p>This model bootstraps the fitting of a given oscar object (re-fits the model for data that is equal in size but sampled with replacement). The output objects give insight into robustness of the oscar-coefficient path, as well as relative importance of model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.bs(fit, bootstrap = 100, seed = NULL, verb = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.bs_+3A_fit">fit</code></td>
<td>
<p>oscar-model object</p>
</td></tr>
<tr><td><code id="oscar.bs_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Number of bootstrapped datasets, Default: 100</p>
</td></tr>
<tr><td><code id="oscar.bs_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility with NULL indicating that it is not set, Default: NULL</p>
</td></tr>
<tr><td><code id="oscar.bs_+3A_verb">verb</code></td>
<td>
<p>Level of verbosity with higher integer giving more information, Default: 0</p>
</td></tr>
<tr><td><code id="oscar.bs_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to oscar-function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides a fail-safe try-catch in an event of non-convergence of the model fitting procedure. This may occur for example if a bootstrapped data matrix has a column consist of a single value only over all observations.
</p>


<h3>Value</h3>

<p>3-dimensional array with dimensions corresponding to k-steps, beta coefficients, and bootstrap runs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_bs &lt;- oscar.cv(fit, bootstrap = 20, seed = 123)
  fit_bs
}
</code></pre>

<hr>
<h2 id='oscar.bs.boxplot'>Bootstrap visualization with boxplot, percentage of new additions</h2><span id='topic+oscar.bs.boxplot'></span>

<h3>Description</h3>

<p>This function plots as barplots as a function of k-cardinality in what proporties certain coefficients were chosen as non-zero over the bootstrap runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.bs.boxplot(bs, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.bs.boxplot_+3A_bs">bs</code></td>
<td>
<p>Bootstrapped 3-dimensional array for an oscar object as produced by oscar.bs</p>
</td></tr>
<tr><td><code id="oscar.bs.boxplot_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to barplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is a plotting function that does not return anything, but instead draws on a new graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_bs &lt;- oscar.bs(fit, bootstrap = 20, seed = 123)
  oscar.bs.boxplot(fit_bs)
}
</code></pre>

<hr>
<h2 id='oscar.bs.k'>Reformatting bootstrap output for cardinality k rows</h2><span id='topic+oscar.bs.k'></span>

<h3>Description</h3>

<p>The function reformats bootstrapped runs to a single long data.frame, where all bootstrapped runs are covered along with the choices for the variables at each cardinality 'k'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.bs.k(bs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.bs.k_+3A_bs">bs</code></td>
<td>
<p>Bootstrapped list from oscar.bs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reformatted data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_bs &lt;- oscar.bs(fit, bootstrap = 20, seed = 123)
  ll &lt;- oscar.bs.k(fit_bs)
  head(ll)
  tail(ll)
}
</code></pre>

<hr>
<h2 id='oscar.bs.plot'>Bootstrap heatmap plot for oscar models</h2><span id='topic+oscar.bs.plot'></span>

<h3>Description</h3>

<p>This function neatly plots a colourized proportion of variables chosen as a function of cardinalities over a multitude of bootstrap runs. This helps model diagnostics in assesssing variable importance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.bs.plot(
  fit,
  bs,
  kmax,
  cex.axis = 0.6,
  palet = colorRampPalette(c("orange", "red", "black", "blue", "cyan"))(dim(bs)[3]),
  nbins = dim(bs)[3],
  Colv = NA,
  Rowv = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.bs.plot_+3A_fit">fit</code></td>
<td>
<p>Fitted oscar S4-class object</p>
</td></tr>
<tr><td><code id="oscar.bs.plot_+3A_bs">bs</code></td>
<td>
<p>Bootstrapped 3-dimensional array for an oscar object as produced by oscar.bs</p>
</td></tr>
<tr><td><code id="oscar.bs.plot_+3A_kmax">kmax</code></td>
<td>
<p>Maximum cardinality 'k'</p>
</td></tr>
<tr><td><code id="oscar.bs.plot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis magnification</p>
</td></tr>
<tr><td><code id="oscar.bs.plot_+3A_palet">palet</code></td>
<td>
<p>Colour palette</p>
</td></tr>
<tr><td><code id="oscar.bs.plot_+3A_nbins">nbins</code></td>
<td>
<p>Number of bins (typically ought to be same as number of colours in the palette)</p>
</td></tr>
<tr><td><code id="oscar.bs.plot_+3A_colv">Colv</code></td>
<td>
<p>Column re-ordering indices or a readily built dendrogram</p>
</td></tr>
<tr><td><code id="oscar.bs.plot_+3A_rowv">Rowv</code></td>
<td>
<p>Row re-ordering indices or a readily built dendrogram</p>
</td></tr>
<tr><td><code id="oscar.bs.plot_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the hamlet::hmap function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further heatmap parameters available from ?hmap
</p>


<h3>Value</h3>

<p>This is a plotting function that does not return anything, but instead draws on a new graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_bs &lt;- oscar.bs(fit, bootstrap = 20, seed = 123)
  oscar.bs.plot(fit, fit_bs)
}
</code></pre>

<hr>
<h2 id='oscar.bs.visu'>Visualize bootstrapping of a fit oscar object</h2><span id='topic+oscar.bs.visu'></span>

<h3>Description</h3>

<p>This function visualizes bootstrapped model coefficients over multiple bootstrap runs as lines in a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.bs.visu(bs, intercept = FALSE, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.bs.visu_+3A_bs">bs</code></td>
<td>
<p>Bootstrapped 3-dimensional array for an oscar object as produced by oscar.bs</p>
</td></tr>
<tr><td><code id="oscar.bs.visu_+3A_intercept">intercept</code></td>
<td>
<p>Whether model intercept should be plotted also as a coefficient, Default: FALSE</p>
</td></tr>
<tr><td><code id="oscar.bs.visu_+3A_add">add</code></td>
<td>
<p>Should plot be added on top of an existing plot device</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is a plotting function that does not return anything, but instead draws on an existing or a new graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_bs &lt;- oscar.bs(fit, bootstrap = 20, seed = 123)
  oscar.bs.visu(fit_bs)
}
</code></pre>

<hr>
<h2 id='oscar.control'>Control OSCAR optimizer parameters</h2><span id='topic+oscar.control'></span>

<h3>Description</h3>

<p>Fine-tuning the parameters available for the DBDC and LMBM optimizers. See oscar documentation for the optimization algorithms for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.control(
  x,
  family,
  start = 2,
  in_mrounds = 5000,
  in_mit = 5000,
  in_mrounds_esc = 5000,
  in_b1,
  in_b2 = 3,
  in_b,
  in_m = 0.01,
  in_m_clarke = 0.01,
  in_c = 0.1,
  in_r_dec,
  in_r_inc = 10^5,
  in_eps1 = 5 * 10^(-5),
  in_eps,
  in_crit_tol = 10^(-5),
  na = 4,
  mcu = 7,
  mcinit = 7,
  tolf = 10^(-5),
  tolf2 = 10^4,
  tolg = 10^(-5),
  tolg2 = tolg,
  eta = 0.5,
  epsL = 0.125
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.control_+3A_x">x</code></td>
<td>
<p>Input data matrix 'x'; will be used for calculating various control parameter defaults.</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_family">family</code></td>
<td>
<p>Model family; should be one of 'cox', 'logistic', or 'gaussian'/'mse'</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_start">start</code></td>
<td>
<p>Starting point generation method, see vignettes for details; should be an integer between range,range, Default: 2</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_mrounds">in_mrounds</code></td>
<td>
<p>DBDC: The maximum number of rounds in one main iteration, Default: 5000</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_mit">in_mit</code></td>
<td>
<p>DBDC: The maximum number of main iterations, Default: 5000</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_mrounds_esc">in_mrounds_esc</code></td>
<td>
<p>DBDC: The maximum number of rounds in escape procedure, Default: 5000</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_b1">in_b1</code></td>
<td>
<p>DBDC: The size of bundle B1, Default: min(n_feat+5,1000)</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_b2">in_b2</code></td>
<td>
<p>DBDC: The size of bundle B2, Default: 3</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_b">in_b</code></td>
<td>
<p>DBDC: Bundle B in escape procedure, Default: 2*n_feat</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_m">in_m</code></td>
<td>
<p>DBDC: The descent parameter in main iteration, Default: 0.01</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_m_clarke">in_m_clarke</code></td>
<td>
<p>DBDC: The descent parameter in escape procedure, Default: 0.01</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_c">in_c</code></td>
<td>
<p>DBDC: The extra decrease parameter in main iteration, Default: 0.1</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_r_dec">in_r_dec</code></td>
<td>
<p>DBDC: The decrease parameter in main iteration, Default: 0.75, 0.99, or larger depending on n_obs (thresholds 10, 300, and above)</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_r_inc">in_r_inc</code></td>
<td>
<p>DBDC: The increase parameter in main iteration, Default: 10^5</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_eps1">in_eps1</code></td>
<td>
<p>DBDC: The enlargement parameter, Default: 5*10^(-5)</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_eps">in_eps</code></td>
<td>
<p>DBDC: The stopping tolerance (proximity measure), Default: 10^(-6) if number of features is &lt;= 50, otherwise 10^(-5)</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_in_crit_tol">in_crit_tol</code></td>
<td>
<p>DBDC: The stopping tolerance (criticality tolerance), Default: 10^(-5)</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_na">na</code></td>
<td>
<p>LMBM: Size of the bundle, Default: 4</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_mcu">mcu</code></td>
<td>
<p>LMBM: Upper limit for maximum number of stored corrections, Default: 7</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_mcinit">mcinit</code></td>
<td>
<p>LMBM: Initial maximum number of stored corrections, Default: 7</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_tolf">tolf</code></td>
<td>
<p>LMBM: Tolerance for change of function values, Default: 10^(-5)</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_tolf2">tolf2</code></td>
<td>
<p>LMBM: Second tolerance for change of function values, Default: 10^4</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_tolg">tolg</code></td>
<td>
<p>LMBM: Tolerance for the first termination criterion, Default: 10^(-5)</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_tolg2">tolg2</code></td>
<td>
<p>LMBM: Tolerance for the second termination criterion, Default: same as 'tolg'</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_eta">eta</code></td>
<td>
<p>LMBM: Distance measure parameter (&gt;0), Default: 0.5</p>
</td></tr>
<tr><td><code id="oscar.control_+3A_epsl">epsL</code></td>
<td>
<p>LMBM: Line search parameter (0 &lt; epsL &lt; 0.25), Default: 0.125</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sanity checks and provides reasonable DBDC ('Double Bundle method for nonsmooth DC optimization' as described in Joki et al. (2018) &lt;doi:10.1137/16M1115733&gt;) and LMBM ('Limited Memory Bundle Method for large-scale nonsmooth optimization' as presented in Haarala et al. (2004) &lt;doi:10.1080/10556780410001689225&gt;) optimization tuning parameters. User may override custom values, though sanity checks will prevent unreasonable values and replace them. The returned list of parameters can be provided for the 'control' parameter when fitting oscar-objects.
</p>


<h3>Value</h3>

<p>A list of sanity checked parameter values for the OSCAR optimizers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  oscar.control() # Return a list of default parameters
}
</code></pre>

<hr>
<h2 id='oscar.cost.after'>Return total cost of model fits if the cost is not included in the oscar object</h2><span id='topic+oscar.cost.after'></span>

<h3>Description</h3>

<p>If at least one measurement from a kit is included in the model, the kit cost is added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.cost.after(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.cost.after_+3A_object">object</code></td>
<td>
<p>Fit oscar S4-object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector for numeric values of total kit costs at different cardinalities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  oscar.cost.after(fit)
}

</code></pre>

<hr>
<h2 id='oscar.cv'>Cross-validation for oscar-fitted model objects over k-range</h2><span id='topic+oscar.cv'></span>

<h3>Description</h3>

<p>Create a cross-validation matrix with the chosen goodness metric with n-folds. Based on the goodness metric, one ought to pick optimal cardinality (parameter 'k').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.cv(
  fit,
  fold = 10,
  seed = NULL,
  strata = rep(1, times = nrow(fit@x)),
  verb = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.cv_+3A_fit">fit</code></td>
<td>
<p>oscar-model object</p>
</td></tr>
<tr><td><code id="oscar.cv_+3A_fold">fold</code></td>
<td>
<p>Number of cross-validation folds, Default: 10</p>
</td></tr>
<tr><td><code id="oscar.cv_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility with NULL indicating that it is not set, Default: NULL</p>
</td></tr>
<tr><td><code id="oscar.cv_+3A_strata">strata</code></td>
<td>
<p>Should stratified cross-validation be used; separate values indicate balanced strata. Default: Unit vector, which will treat all observations equally.</p>
</td></tr>
<tr><td><code id="oscar.cv_+3A_verb">verb</code></td>
<td>
<p>Level of verbosity with higher integer giving more information, Default: 0</p>
</td></tr>
<tr><td><code id="oscar.cv_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to oscar-function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A k-fold cross-validation is run by mimicking the parameters contained in the original oscar S4-object. This requires the original data at slots @x and @y.
</p>


<h3>Value</h3>

<p>A matrix with goodness of fit over folds and k-values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_cv &lt;- oscar.cv(fit, fold=10, seed=123)
  fit_cv
}
</code></pre>

<hr>
<h2 id='oscar.cv.visu'>Visualize cross-validation as a function of k</h2><span id='topic+oscar.cv.visu'></span>

<h3>Description</h3>

<p>This function plots the model performance as a function of cardinality for k-fold cross-validation. Performance metric depends on user choice and model family (i.e. lower MSE is good, higher C-index is good).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.cv.visu(
  cv,
  add = FALSE,
  main = "OSCAR cross-validation",
  xlab = "Cardinality 'k'",
  ylab = "CV performance",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.cv.visu_+3A_cv">cv</code></td>
<td>
<p>Matrix produced by oscar.cv; rows are cv-folds, cols are k-values</p>
</td></tr>
<tr><td><code id="oscar.cv.visu_+3A_add">add</code></td>
<td>
<p>Should plot be added on top of an existing plot device</p>
</td></tr>
<tr><td><code id="oscar.cv.visu_+3A_main">main</code></td>
<td>
<p>Main title</p>
</td></tr>
<tr><td><code id="oscar.cv.visu_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="oscar.cv.visu_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="oscar.cv.visu_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on top the CV points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is a plotting function that does not return anything, but instead draws on an existing or a new graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_cv &lt;- oscar.cv(fit, fold = 10, seed = 123)
  oscar.cv.visu(fit_cv)
}
</code></pre>

<hr>
<h2 id='oscar.pareto'>Retrieve a set of pareto-optimal points for an oscar-model based on model goodness-of-fit or cross-validation</h2><span id='topic+oscar.pareto'></span>

<h3>Description</h3>

<p>This function retrieves the set of pareto optimal points for an oscar model fit in n-proportional time as cardinality axis is readily sorted. It is advisable to optimize model generalization (via cross-validation) rather than mere goodness-of-fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.pareto(fit, cv, xval = "cost", weak = FALSE, summarize = mean)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.pareto_+3A_fit">fit</code></td>
<td>
<p>Fit oscar S4-object</p>
</td></tr>
<tr><td><code id="oscar.pareto_+3A_cv">cv</code></td>
<td>
<p>A cross-validation matrix as produced by oscar.cv; if CV is not provided, then goodness-of-fit from fit object itself is used rather than cross-validation generalization metric</p>
</td></tr>
<tr><td><code id="oscar.pareto_+3A_xval">xval</code></td>
<td>
<p>The x-axis to construct pareto front based on; by default 'cost' vector for features/kits, can also be 'cardinality'/'k'</p>
</td></tr>
<tr><td><code id="oscar.pareto_+3A_weak">weak</code></td>
<td>
<p>If weak pareto-optimality is allowed; by default FALSE.</p>
</td></tr>
<tr><td><code id="oscar.pareto_+3A_summarize">summarize</code></td>
<td>
<p>Function that summarizes over cross-validation folds; by default, this is the mean over the k-folds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing points and indices at which pareto optimal points exist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_cv &lt;- oscar.cv(fit, fold=10)
  oscar.pareto(fit, cv=fit_cv)
}

</code></pre>

<hr>
<h2 id='oscar.pareto.visu'>Visualize oscar model pareto front</h2><span id='topic+oscar.pareto.visu'></span>

<h3>Description</h3>

<p>Visualization function for showing the pareto front for cardinality 'k' and model goodness metric, either from goodness-of-fit or from cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.pareto.visu(
  fit,
  cv,
  xval = "cost",
  weak = FALSE,
  summarize = mean,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.pareto.visu_+3A_fit">fit</code></td>
<td>
<p>Fit oscar S4-object</p>
</td></tr>
<tr><td><code id="oscar.pareto.visu_+3A_cv">cv</code></td>
<td>
<p>A cross-validation matrix as produced by oscar.cv; if CV is not provided, then goodness-of-fit from fit object itself is used rather than cross-validation generalization metric</p>
</td></tr>
<tr><td><code id="oscar.pareto.visu_+3A_xval">xval</code></td>
<td>
<p>The x-axis to construct pareto front based on; by default 'cost' vector for features/kits, can also be 'cardinality'/'k'</p>
</td></tr>
<tr><td><code id="oscar.pareto.visu_+3A_weak">weak</code></td>
<td>
<p>If weak pareto-optimality is allowed; by default FALSE.</p>
</td></tr>
<tr><td><code id="oscar.pareto.visu_+3A_summarize">summarize</code></td>
<td>
<p>Function that summarizes over cross-validation folds; by default, this is the mean over the k-folds.</p>
</td></tr>
<tr><td><code id="oscar.pareto.visu_+3A_add">add</code></td>
<td>
<p>If the fit should be added on top of an existing plot; in that case leaving out labels etc. By default new plot is called.</p>
</td></tr>
<tr><td><code id="oscar.pareto.visu_+3A_...">...</code></td>
<td>
<p>Additional parameters provided for the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is a plotting function that does not return anything, but instead draws on an existing or a new graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  fit_cv &lt;- oscar.cv(fit, fold = 10, seed = 123)
  opar &lt;- par(mfrow=c(1,2))
  oscar.pareto.visu(fit=fit) # Model goodness-of-fit
  oscar.pareto.visu(fit=fit, cv=fit_cv) # Model cross-validation performance
  par(opar)
}
</code></pre>

<hr>
<h2 id='oscar.sparsify'>Create a sparse matrix representation of betas as a function of k</h2><span id='topic+oscar.sparsify'></span>

<h3>Description</h3>

<p>Variable estimates (rows) as a function of cardinality (k, columns). Since a model can drop out variables in favor of two better ones as k increases, this sparse representation helps visualize which variables are included at what cardinality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.sparsify(fit, kmax = fit@kmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.sparsify_+3A_fit">fit</code></td>
<td>
<p>oscar-model object</p>
</td></tr>
<tr><td><code id="oscar.sparsify_+3A_kmax">kmax</code></td>
<td>
<p>Create matrix until kmax-value; by default same as for fit object, but for high dimensional tasks one may wish to reduce this</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses sparseMatrix-class from Matrix-package
</p>


<h3>Value</h3>

<p>A sparse matrix of variables (rows) as a function of cardinality k (columns), where elements are the beta estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  oscar.sparsify(fit, kmax=5)
}

</code></pre>

<hr>
<h2 id='oscar.visu'>Target function value and total kit cost as a function of number of kits included</h2><span id='topic+oscar.visu'></span>

<h3>Description</h3>

<p>Plot oscar S4-object goodness-of-fit, kit costs, and similar performance metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscar.visu(
  fit,
  y = c("target", "cost", "goodness", "cv", "AIC"),
  cols = c("red", "blue"),
  legend = "top",
  mtexts = TRUE,
  add = FALSE,
  main = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscar.visu_+3A_fit">fit</code></td>
<td>
<p>Fitted oscar S4-class object</p>
</td></tr>
<tr><td><code id="oscar.visu_+3A_y">y</code></td>
<td>
<p>Plotted y-axes supporting two simultaneous axes with different scales, Default: c(&quot;target&quot;, &quot;cost&quot;, &quot;goodness&quot;, &quot;cv&quot;)</p>
</td></tr>
<tr><td><code id="oscar.visu_+3A_cols">cols</code></td>
<td>
<p>Colours for drawn lines, Default: c(&quot;red&quot;, &quot;blue&quot;)</p>
</td></tr>
<tr><td><code id="oscar.visu_+3A_legend">legend</code></td>
<td>
<p>Location of legend or omission of legend with NA, Default: 'top'</p>
</td></tr>
<tr><td><code id="oscar.visu_+3A_mtexts">mtexts</code></td>
<td>
<p>Outer margin texts</p>
</td></tr>
<tr><td><code id="oscar.visu_+3A_add">add</code></td>
<td>
<p>Should plot be added into an existing frame / plot</p>
</td></tr>
<tr><td><code id="oscar.visu_+3A_main">main</code></td>
<td>
<p>Main title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is a plotting function that does not return anything, but instead draws on an existing or a new graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(ex)
  fit &lt;- oscar(x=ex_X, y=ex_Y, k=ex_K, w=ex_c, family='cox')
  oscar.visu(fit, y=c("target", "cost"))
}
</code></pre>

<hr>
<h2 id='show+2Coscar-method'>Showing oscar-objects</h2><span id='topic+show+2Coscar-method'></span>

<h3>Description</h3>

<p>Showing oscar-objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'oscar'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Coscar-method_+3A_object">object</code></td>
<td>
<p>Fit oscar S4-object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs raw text describing key characteristics of the oscar-object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
