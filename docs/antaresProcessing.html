<!DOCTYPE html><html><head><title>Help for package antaresProcessing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {antaresProcessing}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addCongestionLink'><p>Add the congestion frequency and the number of congested hours for a given link</p></a></li>
<li><a href='#addDownwardMargin'><p>Add downward margins of areas</p></a></li>
<li><a href='#addExportAndImport'><p>Export and import of areas or districts</p></a></li>
<li><a href='#addLoadFactorLink'><p>Load factors of link</p></a></li>
<li><a href='#addNetLoad'><p>Net load of areas</p></a></li>
<li><a href='#addProcessingH5'><p>Add process results of antaresProcessing to an ANTARES .h5 files</p></a></li>
<li><a href='#addUpwardMargin'><p>Add upward margin of areas</p></a></li>
<li><a href='#compare'><p>Compare two simulations or two antaresData</p></a></li>
<li><a href='#externalDependency'><p>External Dependencies in imports and exports</p></a></li>
<li><a href='#getValues'><p>Get values of a variable</p></a></li>
<li><a href='#loadFactor'><p>Load factors of clusters</p></a></li>
<li><a href='#mergeAllAntaresData'><p>Merge all antaresDataSets</p></a></li>
<li><a href='#modulation'><p>Compute the modulation of cluster units</p></a></li>
<li><a href='#netLoadRamp'><p>Ramp of an area</p></a></li>
<li><a href='#surplus'><p>Compute economic surplus</p></a></li>
<li><a href='#surplusClusters'><p>Compute the surplus of clusters</p></a></li>
<li><a href='#surplusSectors'><p>Compute the surplus of sectors</p></a></li>
<li><a href='#synthesize'><p>Synthesize Monte-Carlo scenarios</p></a></li>
<li><a href='#thermalGroupCapacities'><p>compute thermal capacities from study</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'Antares' Results Processing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.18.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Process results generated by 'Antares', a powerful open source software developed by
    RTE (Réseau de Transport d’Électricité) to simulate and study electric power systems (more information about
    'Antares' here: <a href="https://github.com/AntaresSimulatorTeam/Antares_Simulator">https://github.com/AntaresSimulatorTeam/Antares_Simulator</a>).
    This package provides functions to create new columns like net load, load factors, upward and
    downward margins or to compute aggregated statistics like economic surpluses
    of consumers, producers and sectors.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rte-antares-rpackage/antaresProcessing">https://github.com/rte-antares-rpackage/antaresProcessing</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rte-antares-rpackage/antaresProcessing/issues">https://github.com/rte-antares-rpackage/antaresProcessing/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Depends:</td>
<td>antaresRead (&ge; 1.1.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rhdf5 (&ge; 2.24.0), parallel, testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Infrastructure, DataImport</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-05 10:12:41 UTC; BenoitThieurmel</td>
</tr>
<tr>
<td>Author:</td>
<td>Veronique Bachelier [aut, cre],
  Jalal-Edine ZAWAM [aut],
  Francois Guillem [aut],
  Benoit Thieurmel [aut],
  Titouan Robert [aut],
  RTE [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Veronique Bachelier &lt;veronique.bachelier@rte-france.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-07 00:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='addCongestionLink'>Add the congestion frequency and the number of congested hours for a given link</h2><span id='topic+addCongestionLink'></span>

<h3>Description</h3>

<p>This function computes 4 congestion variables of link (congestion frequency and congestion hours in direct and indirect direction) and adds them to an
<code>antaresData</code> object. The input object must be at an hourly timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCongestionLink(x, timeStep = c("daily", "weekly", "monthly", "annual"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCongestionLink_+3A_x">x</code></td>
<td>
<p>Object of class <code>antaresData</code> created with function
<code><a href="antaresRead.html#topic+readAntares">readAntares</a></code>. It must contain the columns
<code>CONG. PROB +</code> and <code>CONG. PROB -</code> and be at an hourly timestep.</p>
</td></tr>
<tr><td><code id="addCongestionLink_+3A_timestep">timeStep</code></td>
<td>
<p><code>character</code> Desired time step for the result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>addCongestionLink</code> modifies its input by adding four columns:
</p>
<table>
<tr><td><code>congestionFrequencyDirect</code></td>
<td>

<p>This is the congestion frequency on the direct direction of the link at the specified time resolution.
</p>
<pre>congestionFrequencyDirect = round(sum((`CONG. PROB +` != 0)/.N), 2)</pre>
</td></tr>
<tr><td><code>congestionFrequencyIndirect</code></td>
<td>

<p>This is the congestion frequency on the indirect direction of the link at the specified time resolution.
</p>
<pre>congestionFrequencyIndirect  = round(sum((`CONG. PROB -` != 0)/.N), 2)</pre>
</td></tr>
<tr><td><code>congestionHoursDirect</code></td>
<td>

<p>This is the number of congestion hours on the direct direction of the link at the specified time resolution.
</p>
<pre>congestionHoursDirect  = sum(`CONG. PROB +` != 0)</pre>
</td></tr>
<tr><td><code>congestionHoursIndirect</code></td>
<td>

<p>This is the number of congestion hours on the direct direction of the link at the specified time resolution.
</p>
<pre>congestionHoursIndirect =  sum(`CONG. PROB -` != 0)</pre>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Data required by the function

mydata &lt;- readAntares(links = "all")
mydata &lt;- addCongestionLink(mydata, timeStep = "daily")
names(mydata)

mydata &lt;- addCongestionLink(mydata, timeStep = c('daily'))

## End(Not run)

</code></pre>

<hr>
<h2 id='addDownwardMargin'>Add downward margins of areas</h2><span id='topic+addDownwardMargin'></span>

<h3>Description</h3>

<p>This function computes isolated and interconnected downward margins of areas and
add them to an antaresData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDownwardMargin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addDownwardMargin_+3A_x">x</code></td>
<td>
<p>An object of class <code>antaresData</code> created with
<code><a href="antaresRead.html#topic+readAntares">readAntares</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given area, downward margin is equal to the thermal minimum production
(due must run production and minimum stable power of production units) plus
the fatal productions minus the load and the pumping capacity. More formally
it is equal to:
</p>
<p><code>isolatedDownwardMargin = thermalPMin + `H. ROR` + WIND + SOLAR + `MISC. NDG`
                               - LOAD - pumpingCapacity</code>
</p>
<p>The variable <code>pumpingCapacity</code> is automatically created when pumped
storage areas are removed with function
<code><a href="antaresRead.html#topic+removeVirtualAreas">removeVirtualAreas</a></code>. If there is not any such area,
<code>pumpingCapacity</code> is assumed to be equal to 0.
</p>
<p>Interconnected downward margin is the isolated downward margin plus the exports
minus the imports:
</p>
<p><code>interconnectedDownwardMargin = isolatedDownwardMargin + BALANCE - `ROW BAL.`</code>
</p>


<h3>Value</h3>

<p>The function modifies its input by adding to it two new columns
<code>isolatedDownwardMargin</code> and <code>interconnectedDownwardMargin</code>. For
convenience it invisibly returns <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# data required by the function
showAliases("downwardMargin")

mydata &lt;- readAntares(select = "downwardMargin")
mydata &lt;- removeVirtualAreas(mydata, getAreas(c("pump", "stor")))

addDownwardMargin(mydata)
names(mydata$areas)

## End(Not run)
</code></pre>

<hr>
<h2 id='addExportAndImport'>Export and import of areas or districts</h2><span id='topic+addExportAndImport'></span>

<h3>Description</h3>

<p>This function computes the export and import of areas or districts and add it to an
<code>antaresData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addExportAndImport(x, addCapacities = FALSE, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addExportAndImport_+3A_x">x</code></td>
<td>
<p>an object of class &quot;antaresDataList&quot; created with the function
<code>readAntares</code>. It has to contain some areas and all the links that are
connected to these areas. Moreover the function <code><a href="antaresRead.html#topic+removeVirtualAreas">removeVirtualAreas</a></code> must be call before.</p>
</td></tr>
<tr><td><code id="addExportAndImport_+3A_addcapacities">addCapacities</code></td>
<td>
<p>If <code>TRUE</code>, export and import capacities are added.</p>
</td></tr>
<tr><td><code id="addExportAndImport_+3A_opts">opts</code></td>
<td>
<p>opts</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>addExportAndImport</code> modifies its input by adding to it columns:
</p>
<table>
<tr><td><code>export</code></td>
<td>
<p>export for an area or district</p>
</td></tr>
<tr><td><code>import</code></td>
<td>
<p>import for an area or district</p>
</td></tr>
<tr><td><code>capExport</code></td>
<td>
<p>capacity of export for an area or district, if <code>addCapacities</code> is set to TRUE</p>
</td></tr>
<tr><td><code>capImport</code></td>
<td>
<p>capacity of import for an area or district, if <code>addCapacities</code> is set to TRUE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Data required by the function
showAliases("exportsImports")

mydata &lt;- readAntares(select = "exportsImports")
addExportAndImport(mydata)
names(mydata$areas)


## End(Not run)
</code></pre>

<hr>
<h2 id='addLoadFactorLink'>Load factors of link</h2><span id='topic+addLoadFactorLink'></span>

<h3>Description</h3>

<p>This function computes the load factor of link and add it to an
<code>antaresData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLoadFactorLink(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLoadFactorLink_+3A_x">x</code></td>
<td>
<p>Object of class <code>antaresData</code> created with function
<code><a href="antaresRead.html#topic+readAntares">readAntares</a></code>. It must contain the columns
<code>transCapacityDirect</code> and <code>transCapacityIndirect</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>addLoadFactorLink</code> modifies its input by adding to it two columns:
</p>
<table>
<tr><td><code>loadFactor</code></td>
<td>
<p>Proportion of the installed capacity of a link that
is effectively used:
</p>
<pre>loadFactor = `FLOW LIN` / transCapacity</pre>
<p>Notice that <code>loadFactor</code> can be positive or negative according to the
direction of the flow.
</p>
</td></tr>
<tr><td><code>congestion</code></td>
<td>
<p>1 if the link is saturated (<code>loadFactor = +/-1)</code>,
0 otherwise.
</p>
</td></tr>
</table>
<p>For convenience, the function invisibly returns the modified input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Data required by the function
showAliases("loadFactorLink")

mydata &lt;- readAntares(select = "loadFactorLink")
addLoadFactorLink(mydata)
names(mydata)

## End(Not run)

</code></pre>

<hr>
<h2 id='addNetLoad'>Net load of areas</h2><span id='topic+addNetLoad'></span>

<h3>Description</h3>

<p>This function computes the net load of areas or districts and add it to an
<code>antaresData</code> object. Net load is the load of an area minus productions
that are not controlled: wind, solar, hydraulic run of river, etc. the
production of clusters in must run mode is also subtracted by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNetLoad(x, ignoreMustRun = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNetLoad_+3A_x">x</code></td>
<td>
<p>An <code>antaresData</code> object created with readAntares. Unless
<code>ignoreMustRun</code> is true, it must
have a column  <code>mustRunTotal</code>.</p>
</td></tr>
<tr><td><code id="addNetLoad_+3A_ignoremustrun">ignoreMustRun</code></td>
<td>
<p>If <code>TRUE</code>, the production in must run mode is not substracted to the
net load.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>addNetLoad</code> modifies its input by adding to it a column &quot;netLoad&quot;. For
convenience, it invisibly returns the modified input.
formula = LOAD - 'ROW BAL.' - PSP - 'MISC. NDG' - 'H. ROR' - WIND - SOLAR - mustRunTotal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Data required by the function
showAliases("netLoad")

mydata &lt;- readAntares(select = "netLoad")
addNetLoad(mydata)
names(mydata)


## End(Not run)

</code></pre>

<hr>
<h2 id='addProcessingH5'>Add process results of antaresProcessing to an ANTARES .h5 files</h2><span id='topic+addProcessingH5'></span>

<h3>Description</h3>

<p>In this version only hourly data can be enriched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addProcessingH5(
  opts = simOptions(),
  mcY = c("mcInd", "mcAll"),
  timeStep = "hourly",
  addNetLoad = FALSE,
  addDownwardMargin = FALSE,
  addUpwardMargin = FALSE,
  addExportAndImport = FALSE,
  addLoadFactorLink = FALSE,
  externalDependency = FALSE,
  loadFactor = FALSE,
  modulation = FALSE,
  netLoadRamp = FALSE,
  surplus = FALSE,
  surplusClusters = FALSE,
  thermalAvailabilities = FALSE,
  linkCapacity = FALSE,
  mustRun = FALSE,
  allProcess = FALSE,
  evalAreas = list(),
  evalLinks = list(),
  evalClusters = list(),
  evalDistricts = list(),
  nThreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addProcessingH5_+3A_opts">opts</code></td>
<td>
<p><code>simOptions</code> obtain which <a href="antaresRead.html#topic+setSimulationPath">setSimulationPath</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_mcy">mcY</code></td>
<td>
<p><code>character</code>, &quot;mcInd&quot; or &quot;mcAll&quot;.</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_timestep">timeStep</code></td>
<td>
<p><code>character</code>, timeStep</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_addnetload">addNetLoad</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+addNetLoad">addNetLoad</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_adddownwardmargin">addDownwardMargin</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+addDownwardMargin">addDownwardMargin</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_addupwardmargin">addUpwardMargin</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+addUpwardMargin">addUpwardMargin</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_addexportandimport">addExportAndImport</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+addExportAndImport">addExportAndImport</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_addloadfactorlink">addLoadFactorLink</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+addLoadFactorLink">addLoadFactorLink</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_externaldependency">externalDependency</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+externalDependency">externalDependency</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_loadfactor">loadFactor</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+loadFactor">loadFactor</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_modulation">modulation</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+modulation">modulation</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_netloadramp">netLoadRamp</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+netLoadRamp">netLoadRamp</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_surplus">surplus</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+surplus">surplus</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_surplusclusters">surplusClusters</code></td>
<td>
<p><code>boolean</code> refer to <a href="#topic+surplusClusters">surplusClusters</a></p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_thermalavailabilities">thermalAvailabilities</code></td>
<td>
<p><code>boolean</code> Should the surplus of the last unit of a cluster be computed by <a href="#topic+surplusClusters">surplusClusters</a>.
Should loadFactorAvailable be added to the result of <a href="#topic+loadFactor">loadFactor</a>.</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_linkcapacity">linkCapacity</code></td>
<td>
<p><code>boolean</code> should export and import capacities be computed by <a href="#topic+addExportAndImport">addExportAndImport</a>.</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_mustrun">mustRun</code></td>
<td>
<p><code>boolean</code> should the production in must run mode subtracted to the net load <a href="#topic+addNetLoad">addNetLoad</a>.
Should the must run production be ignored in the computation of the netLoadRamp see <a href="#topic+netLoadRamp">netLoadRamp</a>.</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_allprocess">allProcess</code></td>
<td>
<p><code>boolean</code> All process in one argument.</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_evalareas">evalAreas</code></td>
<td>
<p><code>list</code>, list of operation to evaluate in areas data</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_evallinks">evalLinks</code></td>
<td>
<p><code>list</code>, list of operation to evaluate in links data</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_evalclusters">evalClusters</code></td>
<td>
<p><code>list</code>, list of operation to evaluate in clusters data</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_evaldistricts">evalDistricts</code></td>
<td>
<p><code>list</code>, list of operation to evaluate in districts data</p>
</td></tr>
<tr><td><code id="addProcessingH5_+3A_nthreads">nThreads</code></td>
<td>
<p><code>numeric</code>, nThreads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When you add a straitment, an alias is created. They can be used for request h5 file. See examples.
</p>
<p>Available alias are :
</p>

<ul>
<li><p> &quot;Out_addDownwardMargin&quot;
</p>
</li>
<li><p> &quot;Out_addUpwardMargin&quot;
</p>
</li>
<li><p> &quot;Out_addExportAndImport&quot;
</p>
</li>
<li><p> &quot;Out_addLoadFactorLink&quot;
</p>
</li>
<li><p> &quot;Out_externalDependency&quot;
</p>
</li>
<li><p> &quot;Out_loadFactor&quot;
</p>
</li>
<li><p> &quot;Out_modulation&quot;
</p>
</li>
<li><p> &quot;Out_netLoadRamp&quot;
</p>
</li>
<li><p> &quot;Out_surplus&quot;
</p>
</li>
<li><p> &quot;Out_surplusClusters&quot;
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
addProcessingH5(opts = opts,  mcY = "mcInd",
               addDownwardMargin = TRUE,
               addUpwardMargin = TRUE,
               addExportAndImport = TRUE,
               addLoadFactorLink = TRUE,
               externalDependency = TRUE,
               loadFactor = TRUE,
               modulation = TRUE,
               netLoadRamp = TRUE,
               surplus = TRUE,
               surplusClusters = TRUE,
               evalAreas = list(Tota = "`H. STOR` + `MISC. DTG`",
                                Tota2 = "`NODU` + `NP COST` + 1"),
               evalLinks = list(),
               evalClusters = list(),
               evalDistricts = list()
               )

#After write of new columns, new aliases are avialable in antaresRead.You can use
#showAliases() to see them. Prifix Out_ is used to distinguish them.
showAliases("Out_surplusClusters")
readAntares(opts = opts, select = "Out_surplusClusters")


## End(Not run)

</code></pre>

<hr>
<h2 id='addUpwardMargin'>Add upward margin of areas</h2><span id='topic+addUpwardMargin'></span>

<h3>Description</h3>

<p>This function computes isolated and interconnected upward margins of areas and
add them to an antaresData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addUpwardMargin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addUpwardMargin_+3A_x">x</code></td>
<td>
<p>An object of class <code>antaresData</code> created with
<code><a href="antaresRead.html#topic+readAntares">readAntares</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given area and time step, isolated upward margin is the difference
between the available production capacity plus the fatal productions and the
load. More formally it is equal to:
</p>
<p><code>isolatedUpwardMargin = (`AVL DTG` + generatingMaxPower + storageCapacity) +
                             (`H. ROR` + WIND + SOLAR + `MISC. NDG`) - LOAD</code>
</p>
<p>NB: in Antares v6 (and earlier versions) <code>generatingMaxPower</code> is replaced
by <code>hstorPMaxAvg</code>.
</p>
<p>The variable <code>storageCapacity</code> is automatically created when pumped
storage areas are removed with function
<code><a href="antaresRead.html#topic+removeVirtualAreas">removeVirtualAreas</a></code>. If there is not any such area,
<code>storageCapacity</code> is assumed to be equal to 0.
</p>
<p>Interconnected upward margin is the isolated upward margin plus the imports and
minus the exports:
</p>
<p><code>interconnectedUpwardMargin = isolatedUpwardMargin - BALANCE + `ROW BAL.`</code>
</p>


<h3>Value</h3>

<p>The function modifies its input by adding to it two new columns
<code>isolatedUpwardMargin</code> and <code>interconnectedUpwardMargin</code>. For
convenience it invisibly returns <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Data required by the function
showAliases("upwardMargin")

mydata &lt;- readAntares(select = "upwardMargin")
mydata &lt;- removeVirtualAreas(mydata, getAreas(c("pump", "stor")))

addUpwardMargin(mydata)

## End(Not run)
</code></pre>

<hr>
<h2 id='compare'>Compare two simulations or two antaresData</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p><code>compare</code> has been designed to compare two surpluses created with function
<code><a href="#topic+surplus">surplus</a></code> but it can be used to compare the values of two tables of
class <code>antaresData</code> that contain the same type of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(x, y, method = c("diff", "ratio", "rate"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_x">x</code></td>
<td>
<p>Table of class <code>antaresData</code>. x can be an antaresDataTable or antaresDataList.</p>
</td></tr>
<tr><td><code id="compare_+3A_y">y</code></td>
<td>
<p>Table of class <code>antaresData</code>. x can be an antaresDataTable or antaresDataList.
It must contain the same type of data than 'x': if 'x' contains areas,
it must contain areas, ... Moreover it has to have same time step and
contain either synthetic or detailed results like 'x'.</p>
</td></tr>
<tr><td><code id="compare_+3A_method">method</code></td>
<td>
<p>Method used two compare the two tables. <code>"diff"</code> compute the difference
between 'y' and 'x'. <code>"ratio"</code> computes the ratio between 'y' and 'x'.
Finally, <code>"rate"</code> computes the rate of change between 'y' and 'x' (
it is equal to the ratio between 'y' and 'x' minus one).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table of class <code>antaresDataTable</code>. It contains all shared rows and
columns between 'x' and 'y'. The columns contain the statistic chosen:
difference, ratio or rate of change.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First simulation
studyPath &lt;- "path/to/study/"

setSimulationPath(studyPath, 1)
mydata1 &lt;- readAntares("all", "all", synthesis = FALSE)
surplus1 &lt;- surplus(mydata1, groupByDistrict = TRUE)

# Second simulation
setSimulationPath(studyPath, 2)
mydata2 &lt;- readAntares("all", "all", synthesis = FALSE)
surplus2 &lt;- surplus(mydata2, groupByDistrict = TRUE)

compare(surplus1, surplus2)

opts1 &lt;- setSimulationPath(studyPath,-1)
mydata1&lt;-readAntares(areas = "all",
links = "all",
select = c("allAreas", "allLinks"),
mcYears = c(1),
linkCapacity = TRUE)

opts2 &lt;- setSimulationPath(studyPath,-2)
mydata2 &lt;- readAntares(areas = "all",
links = "all",
select = c("allAreas", "allLinks"),
mcYears = c(1),
linkCapacity = TRUE)

opts3 &lt;- setSimulationPath(studyPath,-3)
mydata3 &lt;- readAntares(areas = "all",
links = "all",
select = c("allAreas", "allLinks"),
mcYears = c(1),
linkCapacity = TRUE)

opts4 &lt;- setSimulationPath(studyPath, -4)
mydata4 &lt;- readAntares(areas = "all",
links = "all",
select=c("allAreas", "allLinks"),
mcYears = c(1),
linkCapacity = TRUE)

opts5 &lt;- setSimulationPath(studyPath, -5)
mydata5 &lt;- readAntares(areas = "all",
links = "all",
select=c("allAreas", "allLinks"),
mcYears = c(1),
linkCapacity = TRUE)

resCompare1 &lt;- compare(mydata2, mydata1, method = "diff")
resCompare2 &lt;- compare(mydata3, mydata1, method = "diff")
resCompare3 &lt;- compare(mydata4, mydata1, method = "diff")
resCompare4 &lt;- compare(mydata5, mydata1, method = "diff")

listCompare &lt;- list(resCompare1, resCompare2, resCompare3, resCompare4)

for (i in 1:length(listCompare)){
listCompare[[i]] &lt;- removeVirtualAreas(listCompare[[i]],
                                       storageFlexibility =
                                       getAreas(select = c("z_dsr", "y_mul", "pum", "tur")))
}

ml &lt;- readRDS("path/to/mapLayout.rds")
plotMap(listCompare, ml)

## End(Not run)

</code></pre>

<hr>
<h2 id='externalDependency'>External Dependencies in imports and exports</h2><span id='topic+externalDependency'></span>

<h3>Description</h3>

<p>This function computes the dependency in imports and export for each area or districts at a
given time step. Dependency in imports represents moments where imports are required
to have no loss of load. Dependency in exports represents moments where exports are required to
have no spilled energy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>externalDependency(x, timeStep = "annual", synthesis = FALSE, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="externalDependency_+3A_x">x</code></td>
<td>
<p>An object created with function <code><a href="antaresRead.html#topic+readAntares">readAntares</a></code>. It
must contain data for areas and/or districts. More specifically this
function requires the columns <code>generatingMaxPower</code>
(or <code>hstorPMaxAvg</code> for Antares v6 and earlier), and <code>netLoad</code>. To
get these columns, one has to invoke <code><a href="antaresRead.html#topic+readAntares">readAntares</a></code>
with the parameter <code>hydroStorageMaxPower = TRUE</code> and
<code><a href="#topic+addNetLoad">addNetLoad</a></code> (see examples).
</p>
<p>Moreover it needs to have a hourly time step.
</p>
<p>This object must also contain linkCapacity if there was virtual areas
remove by <code><a href="antaresRead.html#topic+removeVirtualAreas">removeVirtualAreas</a></code> to be able to
calculate pumping and storage capacities.</p>
</td></tr>
<tr><td><code id="externalDependency_+3A_timestep">timeStep</code></td>
<td>
<p>Desired time step for the result.</p>
</td></tr>
<tr><td><code id="externalDependency_+3A_synthesis">synthesis</code></td>
<td>
<p>If TRUE, average external dependencies are returned. Else the function
returns external dependencies per Monte-Carlo scenario.</p>
</td></tr>
<tr><td><code id="externalDependency_+3A_opts">opts</code></td>
<td>
<p>opts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table of class <code>antaresDataTable</code> with the following columns:
</p>
<table>
<tr><td><code>area</code></td>
<td>
<p>Area name.</p>
</td></tr>
<tr><td><code>timeId</code></td>
<td>
<p>Time id and other time columns.</p>
</td></tr>
<tr><td><code>pumping</code></td>
<td>
<p>capacity of pumping</p>
</td></tr>
<tr><td><code>storage</code></td>
<td>
<p>capacity of storage</p>
</td></tr>
<tr><td><code>exportsLevel</code></td>
<td>
<p>netLoad + pumping</p>
</td></tr>
<tr><td><code>importsLevel</code></td>
<td>
<p>netLoad - 'AVL DTG' - hydroStorageMaxPower - storage &gt; 0</p>
</td></tr>
<tr><td><code>exportsFrequency</code></td>
<td>
<p>number of time step where this criteria is satisfied
</p>
<p>criteria : netLoad + pumping &lt; 0
</p>
</td></tr>
<tr><td><code>importsFrequency</code></td>
<td>
<p>number of time step where this criteria is satisfied
</p>
<p>criteria : netLoad - 'AVL DTG' - hydroStorageMaxPower - storage &gt; 0
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Data required by the function
showAliases("externalDependency")

mydata &lt;- readAntares(select = "externalDependency")
addNetLoad(mydata)
externalDependency(mydata)

# if there are some virtual pumping/storage areas, remove them with
# removeVirtualAreas
mydata &lt;- removeVirtualAreas(mydata, c("pumping", "storage"))
externalDependency(mydata, ignoreMustRun = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='getValues'>Get values of a variable</h2><span id='topic+getValues'></span>

<h3>Description</h3>

<p>Get all the values of a variable for some years Monte Carlo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getValues(data = NULL, variable = NULL, mcyear = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues_+3A_data">data</code></td>
<td>
<p>an object of class &quot;antaresData&quot; created with the function
<code>readAntares</code>.</p>
</td></tr>
<tr><td><code id="getValues_+3A_variable">variable</code></td>
<td>
<p>a variable of data</p>
</td></tr>
<tr><td><code id="getValues_+3A_mcyear">mcyear</code></td>
<td>
<p>set of mcYear</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

mydata &lt;- readAntares(areas="all",clusters="all", select="LOAD")
getValues(mydata$areas, variable="LOAD")
getValues(myData$clusters, variable = "production")


## End(Not run)
</code></pre>

<hr>
<h2 id='loadFactor'>Load factors of clusters</h2><span id='topic+loadFactor'></span>

<h3>Description</h3>

<p>This function computes the load factor and other related statistics
for cluster of a study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadFactor(
  x,
  timeStep = "annual",
  synthesis = FALSE,
  clusterDesc = NULL,
  loadFactorAvailable = FALSE,
  opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadFactor_+3A_x">x</code></td>
<td>
<p>Object of class <code>antaresData</code> created with function
<code><a href="antaresRead.html#topic+readAntares">readAntares</a></code>. It must contain hourly detailed
results for clusters and has to contain the columns
<code>minGenModulation</code>.</p>
</td></tr>
<tr><td><code id="loadFactor_+3A_timestep">timeStep</code></td>
<td>
<p>Desired time step for the result.</p>
</td></tr>
<tr><td><code id="loadFactor_+3A_synthesis">synthesis</code></td>
<td>
<p>If TRUE, average surpluses are returned. Else the function returns surpluses
per Monte-Carlo scenario.</p>
</td></tr>
<tr><td><code id="loadFactor_+3A_clusterdesc">clusterDesc</code></td>
<td>
<p>A table created with the function <code><a href="antaresRead.html#topic+readClusterDesc">readClusterDesc</a></code>.
If is this parameter is set to <code>NULL</code> (the default), then the function
attempts to read the needed data in the same study as <code>x</code>.</p>
</td></tr>
<tr><td><code id="loadFactor_+3A_loadfactoravailable">loadFactorAvailable</code></td>
<td>
<p>Should loadFactorAvailable be added to the result?</p>
</td></tr>
<tr><td><code id="loadFactor_+3A_opts">opts</code></td>
<td>
<p>opts where clusterDesc will be read if null based on data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table of class <code>antaresDataTable</code>containing the following
columns:
</p>
<table>
<tr><td><code>area</code></td>
<td>
<p>Area name</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Cluster name</p>
</td></tr>
<tr><td><code>mcYear</code></td>
<td>
<p>Only if <code>synthesis=FALSE</code>. Id of the Monte-carlo scenario</p>
</td></tr>
<tr><td><code>timeId</code></td>
<td>
<p>Time id and other time variables</p>
</td></tr>
<tr><td><code>loadFactor</code></td>
<td>

<p>Load factor of the cluster. It represent the proportion of
the installed capacity of a cluster that is effectively generate
</p>
<p>Formula: production / (unitcount * nominalcapacity)
</p>
</td></tr>
</table>
<p>#' </p>
<table>
<tr><td><code>loadFactorAvailable</code></td>
<td>

<p>Load factor of the cluster. It represent the proportion of
the capacity available of a cluster that is effectively generate
</p>
<p>Formula: production / thermalAvailability
</p>
</td></tr>
<tr><td><code>propHoursMinGen</code></td>
<td>

<p>Proportion of hours when production is positive and
all units of a cluster are either off, either producing at their minimum. This
situation occurs when units are kept producing above the optimal level to avoid
future startup costs or to satisfy the constraints generated by parameters
&quot;Min. up Time&quot; or &quot;Min gen. modulation&quot;.
</p>
<p>Formula: mean(1 if production &gt; 0 and production = max(min.stable.power * unitcount,
minGenModulation * nominalcapacity * unitcount) else 0)
</p>
</td></tr>
<tr><td><code>propHoursMaxGen</code></td>
<td>

<p>Proportion of hours when all units started produce at
their maximal capacity.
</p>
<p>Formula: mean(1 if production &gt; 0 and production = NODU * nominalcapacity *
(1 - spinning / 100))
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# data required by the function
showAliases("loadfactor")

mydata &lt;- readAntares(select = "loadfactor")
loadFactor(mydata, synthesis = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='mergeAllAntaresData'>Merge all antaresDataSets</h2><span id='topic+mergeAllAntaresData'></span>

<h3>Description</h3>

<p>Merge all antaresDataSets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeAllAntaresData(dta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeAllAntaresData_+3A_dta">dta</code></td>
<td>
<p>antaresData</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setSimulationPath("Mystud", 1)
dta &lt;- readAntares(areas = "all", links = "all", clusters = "all", districts = "all")
dta &lt;- mergeAllAntaresData(dta)

## End(Not run)

</code></pre>

<hr>
<h2 id='modulation'>Compute the modulation of cluster units</h2><span id='topic+modulation'></span>

<h3>Description</h3>

<p>This function computes the modulation of cluster units or of sectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modulation(
  x,
  timeStep = "annual",
  synthesis = FALSE,
  by = c("cluster", "sector"),
  clusterDesc = NULL,
  opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modulation_+3A_x">x</code></td>
<td>
<p>An <code>antaresData</code> object created with <code>readAntares</code>. It must
contain the hourly detailed results for clusters if <code>by = "cluster"</code>
or for areas and/or districts if <code>by = "sector"</code></p>
</td></tr>
<tr><td><code id="modulation_+3A_timestep">timeStep</code></td>
<td>
<p>Desired time step for the result.</p>
</td></tr>
<tr><td><code id="modulation_+3A_synthesis">synthesis</code></td>
<td>
<p>If TRUE, average surpluses are returned. Else the function returns surpluses
per Monte-Carlo scenario.</p>
</td></tr>
<tr><td><code id="modulation_+3A_by">by</code></td>
<td>
<p>Should modulations computed by cluster or by sector? Possible values are
&quot;sector&quot; and &quot;cluster&quot;.</p>
</td></tr>
<tr><td><code id="modulation_+3A_clusterdesc">clusterDesc</code></td>
<td>
<p>A table created with the function <code><a href="antaresRead.html#topic+readClusterDesc">readClusterDesc</a></code>.
If is this parameter is set to <code>NULL</code> (the default), then the function
attempts to read the needed data in the same study as <code>x</code>.</p>
</td></tr>
<tr><td><code id="modulation_+3A_opts">opts</code></td>
<td>
<p>opts where clusterDesc will be read if null based on data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table of class <code>antaresDataTable</code> or a list of such tables with
the following columns:
</p>
<table>
<tr><td><code>area</code></td>
<td>

<p>Area name. If <code>byDistrict=TRUE</code>, this column is replaced by column
<code>district</code>.
</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>

<p>Cluster name. If <code>by="sector"</code>, this column is replaced by column
<code>sector</code>.
</p>
</td></tr>
<tr><td><code>timeId</code></td>
<td>

<p>Time id and other time columns.
</p>
</td></tr>
<tr><td><code>upwardModulation</code></td>
<td>

<p>Maximal absolute modulation of a cluster unit or of the sector, if <code>timeStep</code> is hourly.
</p>
</td></tr>
<tr><td><code>downwardModulation</code></td>
<td>

<p>Maximal absolute modulation of a cluster unit or of the sector, if <code>timeStep</code> is hourly.
</p>
</td></tr>
<tr><td><code>absoluteModulation</code></td>
<td>

<p>Maximal absolute modulation of a cluster unit or of the sector, if <code>timeStep</code> is hourly.
</p>
</td></tr>
<tr><td><code>avg_upwardModulation</code></td>
<td>

<p>Average upward modulation of a cluster unit or of the sector, if <code>timeStep</code> is not hourly.
</p>
</td></tr>
<tr><td><code>avg_downwardModulation</code></td>
<td>

<p>Average downward modulation of a cluster unit or of the sector, if <code>timeStep</code> is not hourly.
</p>
</td></tr>
<tr><td><code>avg_absoluteModulation</code></td>
<td>

<p>Average absolute modulation of a cluster unit or of the sector, if <code>timeStep</code> is not hourly.
</p>
</td></tr>
<tr><td><code>max_upwardModulation</code></td>
<td>

<p>Maximal upward modulation of a cluster unit or of the sector, if <code>timeStep</code> is not hourly.
</p>
</td></tr>
<tr><td><code>max_downwardModulation</code></td>
<td>

<p>Maximal downward modulation of a cluster unit or of the sector, if <code>timeStep</code> is not hourly.
</p>
</td></tr>
<tr><td><code>max_absoluteModulation</code></td>
<td>

<p>Maximal absolute modulation of a cluster unit or of the sector, if <code>timeStep</code> is not hourly.
</p>
</td></tr>
</table>
<p>Notice that if <code>by="cluster"</code>, the function computes the modulation per
unit, i.e. the modulation of a cluster divided by the number of units of the
cluster. On the opposite, if <code>by="sector"</code>, the function returns the
modulation of the global production of the sector. Moreover, if parameter
<code>x</code> contains area and district data, the function returns a list with
components <code>areas</code> and  <code>districts</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# data required by the function
showAliases("modulation")

mydata &lt;- readAntares(select="modulation")

# Modulation of cluster units
modulation(mydata)

# Aggregate Monte-Carlo scenarios
modulation(mydata, synthesis = TRUE)

# Modulation of sectors
modulation(mydata, by = "sector")

# Modulation of sectors per district
modulation(mydata, by = "sector")

## End(Not run)

</code></pre>

<hr>
<h2 id='netLoadRamp'>Ramp of an area</h2><span id='topic+netLoadRamp'></span>

<h3>Description</h3>

<p>This function computes the ramp of the consumption and the balance of areas
and/or districts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netLoadRamp(
  x,
  timeStep = "hourly",
  synthesis = FALSE,
  ignoreMustRun = FALSE,
  opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netLoadRamp_+3A_x">x</code></td>
<td>
<p>Object of class <code>antaresData</code> containing data for areas and/or
districts. It must contain the column <code>BALANCE</code>  and either the column
&quot;netLoad&quot; or the columns needed to compute the net load  see <a href="#topic+addNetLoad">addNetLoad</a>.</p>
</td></tr>
<tr><td><code id="netLoadRamp_+3A_timestep">timeStep</code></td>
<td>
<p>Desired time step for the result.</p>
</td></tr>
<tr><td><code id="netLoadRamp_+3A_synthesis">synthesis</code></td>
<td>
<p>If TRUE, average surpluses are returned. Else the function returns surpluses
per Monte-Carlo scenario.</p>
</td></tr>
<tr><td><code id="netLoadRamp_+3A_ignoremustrun">ignoreMustRun</code></td>
<td>
<p>Should the must run production be ignored in the computation of the net
load?</p>
</td></tr>
<tr><td><code id="netLoadRamp_+3A_opts">opts</code></td>
<td>
<p>opts where clusterDesc will be read if null based on data</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>netLoadRamp</code> returns a data.table or a list of data.tables with the
following columns:
</p>
<table>
<tr><td><code>netLoadRamp</code></td>
<td>

<p>Ramp of the net load of an area. If <code>timeStep</code> is not hourly, then these
columns contain the average value for the given time step.
Formula = netLoad - shift(netLoad, fill = 0)
</p>
</td></tr>
<tr><td><code>balanceRamp</code></td>
<td>

<p>Ramp of the balance of an area. If <code>timeStep</code> is not hourly, then
these columns contain the average value for the given time step.
</p>
<p>formula = BALANCE - shift(BALANCE, fill = 0)
</p>
</td></tr>
<tr><td><code>areaRamp</code></td>
<td>

<p>Sum of the two previous columns. If <code>timeStep</code> is not hourly, then
these columns contain the average value for the given time step.
</p>
<p>formula = netLoadRamp + balanceRamp
</p>
</td></tr>
<tr><td><code>minNetLoadRamp</code></td>
<td>
<p>Minimum ramp of the net load of an area, if <code>timeStep</code> is not hourly.</p>
</td></tr>
<tr><td><code>minBalanceRamp</code></td>
<td>
<p>Minimum ramp of the balance of an area, if <code>timeStep</code> is not hourly.</p>
</td></tr>
<tr><td><code>minAreaRamp</code></td>
<td>
<p>Minimum ramp sum of the sum of balance and net load, if <code>timeStep</code> is not hourly.</p>
</td></tr>
<tr><td><code>maxNetLoadRamp</code></td>
<td>
<p>Maximum ramp of the net load of an area, if <code>timeStep</code> is not hourly.</p>
</td></tr>
<tr><td><code>maxBalanceRamp</code></td>
<td>
<p>Maximum ramp of the balance of an area, if <code>timeStep</code> is not hourly.</p>
</td></tr>
<tr><td><code>maxAreaRamp</code></td>
<td>
<p>Maximum ramp of the sum of balance and net load, if <code>timeStep</code> is not hourly.</p>
</td></tr>
</table>
<p>For convenience the function invisibly returns the modified input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# data required by the function
showAliases("netLoadRamp")

mydata &lt;- readAntares(select="netLoadRamp")
netLoadRamp(mydata, timeStep = "annual")

## End(Not run)

</code></pre>

<hr>
<h2 id='surplus'>Compute economic surplus</h2><span id='topic+surplus'></span>

<h3>Description</h3>

<p>This function computes the economic surplus for the consumers, the producers
and the global surplus of an area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surplus(
  x,
  timeStep = "annual",
  synthesis = FALSE,
  groupByDistrict = FALSE,
  hurdleCost = TRUE,
  opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surplus_+3A_x">x</code></td>
<td>
<p>an object of class &quot;antaresDataList&quot; created with the function
<code>readAntares</code>. It has to contain some areas and all the links that are
connected to these areas. Moreover it needs to have a hourly time step and detailed results.</p>
</td></tr>
<tr><td><code id="surplus_+3A_timestep">timeStep</code></td>
<td>
<p>Desired time step for the result.</p>
</td></tr>
<tr><td><code id="surplus_+3A_synthesis">synthesis</code></td>
<td>
<p>If TRUE, average surpluses are returned. Else the function returns surpluses
per Monte-Carlo scenario.</p>
</td></tr>
<tr><td><code id="surplus_+3A_groupbydistrict">groupByDistrict</code></td>
<td>
<p>If TRUE, results are grouped by district.</p>
</td></tr>
<tr><td><code id="surplus_+3A_hurdlecost">hurdleCost</code></td>
<td>
<p>If TRUE, HURDLE COST will be removed from congestionFees.</p>
</td></tr>
<tr><td><code id="surplus_+3A_opts">opts</code></td>
<td>
<p>opts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the following columns:
</p>
<table>
<tr><td><code>area</code></td>
<td>
<p>Name of the area.</p>
</td></tr>
<tr><td><code>timeId</code></td>
<td>
<p>timeId and other time columns.</p>
</td></tr>
<tr><td><code>consumerSurplus</code></td>
<td>
<p>The surplus of the consumers of some area.
</p>
<p>formula = (unsuppliedCost[area] - 'MRG. PRICE') * LOAD</p>
</td></tr>
<tr><td><code>producerSurplus</code></td>
<td>

<p>The surplus of the producers of some area.
</p>
<p>formula = 'MRG. PRICE' * production - 'OP. COST'
</p>
<p>Production includes &quot;NUCLEAR&quot;, &quot;LIGNITE&quot;, &quot;COAL&quot;, &quot;GAS&quot;, &quot;OIL&quot;, &quot;MIX. FUEL&quot;,
&quot;MISC. DTG&quot;, &quot;H. STOR&quot;, &quot;H. ROR&quot;, &quot;WIND&quot;, &quot;SOLAR&quot; and &quot;MISC. NDG&quot;
</p>
</td></tr>
<tr><td><code>rowBalanceSurplus</code></td>
<td>

<p>Surplus of the ROW balance.
</p>
<p>Formula: 'MRG. PRICE' * 'ROW BAL.'
</p>
</td></tr>
<tr><td><code>storageSurplus</code></td>
<td>

<p>Surplus created by storage/flexibility areas.
</p>
<p>formula = storage * x$areas$'MRG. PRICE'
</p>
</td></tr>
<tr><td><code>congestionFees</code></td>
<td>

<p>The congestion fees of a given area. It equals to half
the congestion fees of the links connected to that area.
</p>
<p>formula = (congestionFees-hurdleCost) / 2
</p>
</td></tr>
<tr><td><code>globalSurplus</code></td>
<td>

<p>Sum of the consumer surplus, the producer surplus and the congestion fees.
</p>
<p>formula = consumerSurplus + producerSurplus + storageSurplus + congestionFees + rowBalanceSurplus</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
showAliases("surplus")

mydata &lt;- readAntares(select="surplus")
surplus(mydata)

surplus(mydata, synthesis = TRUE)
surplus(mydata, synthesis = TRUE, groupByDistrict = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='surplusClusters'>Compute the surplus of clusters</h2><span id='topic+surplusClusters'></span>

<h3>Description</h3>

<p>This function computes the surplus of clusters of interest. The surplus of a
cluster is equal to its production times the marginal cost of the area it
belongs to minus variable, fixed and startup costs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surplusClusters(
  x,
  timeStep = "annual",
  synthesis = FALSE,
  surplusLastUnit = FALSE,
  clusterDesc = NULL,
  opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surplusClusters_+3A_x">x</code></td>
<td>
<p>An <code>antaresData</code> object created with <code>readAntares</code>. It must
contain an element <code>clusters</code> and an element <code>areas</code> with at
least the column <code>MRG. PRICE</code>.</p>
</td></tr>
<tr><td><code id="surplusClusters_+3A_timestep">timeStep</code></td>
<td>
<p>Desired time step for the result.</p>
</td></tr>
<tr><td><code id="surplusClusters_+3A_synthesis">synthesis</code></td>
<td>
<p>If TRUE, average surpluses are returned. Else the function returns surpluses
per Monte-Carlo scenario.</p>
</td></tr>
<tr><td><code id="surplusClusters_+3A_surpluslastunit">surplusLastUnit</code></td>
<td>
<p>Should the surplus of the last unit of a cluster be computed ? If
<code>TRUE</code>, then <code>x</code> must have been created with the option
<code>thermalAvailabilities=TRUE</code> in order to contain the required column
&quot;available units&quot;</p>
</td></tr>
<tr><td><code id="surplusClusters_+3A_clusterdesc">clusterDesc</code></td>
<td>
<p>A table created with the function <code><a href="antaresRead.html#topic+readClusterDesc">readClusterDesc</a></code>.
If is this parameter is set to <code>NULL</code> (the default), then the function
attempts to read the needed data in the same study as <code>x</code>.</p>
</td></tr>
<tr><td><code id="surplusClusters_+3A_opts">opts</code></td>
<td>
<p>opts where clusterDesc will be read if null based on data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table of class <code>antaresDataTable</code> with the following columns:
</p>
<table>
<tr><td><code>area</code></td>
<td>
<p>Area name.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Cluster name.</p>
</td></tr>
<tr><td><code>timeId</code></td>
<td>
<p>Time id and other time columns.</p>
</td></tr>
<tr><td><code>variableCost</code></td>
<td>

<p>Proportional costs of production of the cluster
</p>
<p>Formula = marginal cost * production
</p>
</td></tr>
<tr><td><code>fixedCost</code></td>
<td>

<p>Fixed costs of production of the cluster
</p>
<p>Formula = NODU * fixed cost
</p>
</td></tr>
<tr><td><code>startupCost</code></td>
<td>

<p>Start up costs of the cluster.
</p>
</td></tr>
<tr><td><code>surplusPerUnit</code></td>
<td>

<p>Average surplus per unit of the cluster.
</p>
<p>formula = ('MRG. PRICE' * production - opCost - startupCost) / unitcount
</p>
</td></tr>
<tr><td><code>surplusLastUnit</code></td>
<td>

<p>Surplus of the last unit of the cluster.
</p>
<p>formula = ('MRG. PRICE' * prodLastUnit - opCost / pmax(1, NODU) - startup.cost)
</p>
</td></tr>
<tr><td><code>totalSurplus</code></td>
<td>

<p>Surplus of all units of the cluster.
</p>
<p>formula = 'MRG. PRICE' * production - opCost - startupCost
</p>
</td></tr>
<tr><td><code>economicGradient</code></td>
<td>

<p>Economic gradient of a cluster. It is equal to
the surplus per unit divided by the capacity of a unit.
</p>
<p>formula = surplusPerUnit / nominalcapacity
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Data required by the function:
showAliases("surplusClusters")

mydata &lt;- readAntares(select = "surplusClusters")
surplusClusters(mydata)

# Computing the surplus of the last unit of a cluster requires the additional
# column "availableUnits". To add this column, one has to use parameter
# "thermalAvailabilities = TRUE" in readAntares.

mydata &lt;- readAntares(select = c("surplusClusters", "thermalAvailabilities"))
surplusClusters(mydata, surplusLastUnit = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='surplusSectors'>Compute the surplus of sectors</h2><span id='topic+surplusSectors'></span>

<h3>Description</h3>

<p>This function computes the surplus of sectors for each area and time step.
For sectors wind, solar, hydraulic storage and run of river, production costs
are assumed to be equal to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surplusSectors(
  x,
  sectors = c("thermal", "renewable"),
  timeStep = "annual",
  synthesis = FALSE,
  groupByDistrict = FALSE,
  clusterDesc = NULL,
  opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surplusSectors_+3A_x">x</code></td>
<td>
<p>Object of class <code>antaresData</code> created with <code>readAntares</code>. It needs
to contain hourly detailed results of a simulation. Moreover, it must contain
area data and if thermal sectors are required, cluster data.</p>
</td></tr>
<tr><td><code id="surplusSectors_+3A_sectors">sectors</code></td>
<td>
<p>vector containing the name of the sectors for which surplus needs to be
computed. Possible values are &quot;thermal&quot; for thermal sectors(nuclear, coal,..),
&quot;ren&quot; for renewable energy and any column name that can be considered as
a production (for instance production of virtual areas). It is assumed that
the cost of these productions is equal to 0 as for renewable energies.
If the parameter contains the value &quot;thermal&quot;, then the parameter
<code>x</code> has to contain cluster data.</p>
</td></tr>
<tr><td><code id="surplusSectors_+3A_timestep">timeStep</code></td>
<td>
<p>Desired time step for the result.</p>
</td></tr>
<tr><td><code id="surplusSectors_+3A_synthesis">synthesis</code></td>
<td>
<p>If TRUE, average surpluses are returned. Else the function returns surpluses
per Monte-Carlo scenario.</p>
</td></tr>
<tr><td><code id="surplusSectors_+3A_groupbydistrict">groupByDistrict</code></td>
<td>
<p>If TRUE, results are grouped by district.</p>
</td></tr>
<tr><td><code id="surplusSectors_+3A_clusterdesc">clusterDesc</code></td>
<td>
<p>A table created with the function <code><a href="antaresRead.html#topic+readClusterDesc">readClusterDesc</a></code>.
If is this parameter is set to <code>NULL</code> (the default), then the function
attempts to read the needed data in the same study as <code>x</code>.</p>
</td></tr>
<tr><td><code id="surplusSectors_+3A_opts">opts</code></td>
<td>
<p>opts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table of class &quot;antaresData&quot;. It contains one column per sector
containing the surplus of that sector for a given area and timeId.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Data required by the function:
showAliases("surplusSectors")

mydata &lt;- readAntares(select = "surplusSectors")
surplusSectors(mydata)

# Note that if the parameter "sectors" is modified, the function can require
# more or less data. For instance, if one only wants surplus for thermal
# sectors:
mydata &lt;- readAntares(areas = "all", clusters = "all", synthesis = FALSE,
                      select = "MRG. PRICE")
surplusSectors(mydata, sectors = "thermal")


## End(Not run)

</code></pre>

<hr>
<h2 id='synthesize'>Synthesize Monte-Carlo scenarios</h2><span id='topic+synthesize'></span>

<h3>Description</h3>

<p>This function takes as input an object of class <code>antaresData</code> containing
detailed results of a simulation and creates a synthesis of the results.
The synthesis contains the average value of each variable over Monte-Carlo
scenarios and eventually other aggregated statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthesize(x, ..., prefixForMeans = "", useTime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synthesize_+3A_x">x</code></td>
<td>
<p>an object of class <code>antaresData</code> created with
<code><a href="antaresRead.html#topic+readAntares">readAntares</a></code> and containing detailed results of
an Antares simulation.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_...">...</code></td>
<td>
<p>Additional parameters indicating which additional statistics to produce.
See details to see how to specify them.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_prefixformeans">prefixForMeans</code></td>
<td>
<p>Prefix to add to the columns containing average values. If it is different
than &quot;&quot;, a &quot;_&quot; is automatically added.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_usetime">useTime</code></td>
<td>
<p>use times columns for synthesize.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional statistics can be asked in three different ways:
</p>

<ol>
<li><p> A character string in &quot;min&quot;, &quot;max&quot;, &quot;std&quot;, &quot;median&quot; or &quot;qXXX&quot; where
&quot;XXX&quot; is a real number between 0 and 100. It will add
for each column respectively the minimum or maximum value, the standard
deviation, the median or a quantile.
</p>
</li>
<li><p> A named argument whose value is a function or one of the previous
aliases. For instance <code>med = median</code> will calculate the median of
each variable. The name of the resulting column will be prefixed by
&quot;med_&quot;. Similarly, <code>l = "q5"</code> will compute the 5
each variable and put the result in a column with name prefixed by &quot;l_&quot;
</p>
</li>
<li><p> A named argument whose value is a list. It has to contain an element
<code>fun</code> equal to a function or an alias and optionally an element
<code>only</code> containing the names of the columns to which to apply the function.
For instance <code>med = list(fun = median, only = c("LOAD", "MRG. PRICE"))</code>
will compute the median of variables &quot;LOAD&quot; and &quot;MRG. PRICE&quot;. The result
will be stored in columns &quot;med_LOAD&quot; and &quot;med_MRG. PRICE&quot;.
</p>
</li></ol>

<p>The computation of custom statistics can take some time, especially with hourly
data. To improve performance, prefer the third form and compute custom
statistics only on a few variables.
</p>


<h3>Value</h3>

<p>Synthetic version of the input data. It has the same structure as <code>x</code>
except that column <code>mcYear</code> has been removed. All variables are
averaged across Monte-Carlo scenarios and eventually some additional columns
have been added corresponding to the requested custom statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mydata &lt;- readAntares("all", timeStep = "annual")

synthesize(mydata)

# Add minimum and maximum for all variables
synthesize(mydata, "min", "max")

# Compute a custom statistic for all columns
synthesize(mydata, log = function(x) mean(log(1 + x)))

# Same but only for column "LOAD"
synthesize(mydata,
           log = list(fun = function(x) mean(log(1 + x)),
                      only = "LOAD"))

# Compute the proportion of time balance is positive

synthesize(mydata, propPos = list(fun = function(x) mean(x &gt; 0),
                                  only = "BALANCE"))

# Compute 95% confidence interval for the marginal price
synthesize(mydata,
           l = list(fun = "q2.5", only = "MRG. PRICE"),
           u = list(fun = "q97.5", only = "MRG. PRICE"))

## End(Not run)

</code></pre>

<hr>
<h2 id='thermalGroupCapacities'>compute thermal capacities from study</h2><span id='topic+thermalGroupCapacities'></span>

<h3>Description</h3>

<p>compute thermal capacities from study
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thermalGroupCapacities(opts = simOptions())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thermalGroupCapacities_+3A_opts">opts</code></td>
<td>
<p><code>simOptions</code> obtain which <a href="antaresRead.html#topic+setSimulationPath">setSimulationPath</a></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
