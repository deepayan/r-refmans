<!DOCTYPE html><html><head><title>Help for package SGB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SGB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arc'>
<p>arc dataset</p></a></li>
<li><a href='#B2i'><p>Balances to isometric log-ratio</p></a></li>
<li><a href='#carseg'>
<p>carseg dataset</p></a></li>
<li><a href='#covest.SGB'>
<p>Classical and robust asymptotic covariance matrix</p></a></li>
<li><a href='#EqualityConstr'>
<p>Equality constraints for overall shape and/or regression parameters and jacobian</p></a></li>
<li><a href='#EZ.SGB'>
<p>Expectations of Z under the SGB distribution</p></a></li>
<li><a href='#GenGammaDistrib'><p>Generalized Gamma distribution</p></a></li>
<li><a href='#GoodnessFit'>
<p>Goodness of fit tests on the marginal distributions of each part in a SGB model</p></a></li>
<li><a href='#Imputation'>
<p>Imputation of missing parts in compositions from a SGB model</p></a></li>
<li><a href='#InequalityConstr'>
<p>Inequality constraints and jacobian</p></a></li>
<li><a href='#InitialParameters'>
<p>Initial parameters estimates and comparison</p></a></li>
<li><a href='#MarginPlots'>
<p>Histograms, quantile and probability plots for the z(u)-transforms of parts</p></a></li>
<li><a href='#ocar'>
<p>ocar data set</p></a></li>
<li><a href='#oilr'>
<p>oilr data set</p></a></li>
<li><a href='#regSGB'>
<p>Regression for compositions following a SGB distribution</p></a></li>
<li><a href='#SGB-package'>
<p>Package SGB</p></a></li>
<li><a href='#SGBdistrib'>
<p>Density and random generator for the SGB distribution</p></a></li>
<li><a href='#SGBLik'>
<p>SGB log-likelihood and gradient</p></a></li>
<li><a href='#SGButil'>
<p>Computation of scales and z-vectors</p></a></li>
<li><a href='#stepSGB'>
<p>Stepwise backward elimination for SGB regression</p></a></li>
<li><a href='#summaryA.SGB'>
<p>Aitchison expectation and mode under the SGB distribution</p></a></li>
<li><a href='#Tabulation'>
<p>Tabulation of overall SGB regression results with AIC and matrix view of regression coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simplicial Generalized Beta Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Monique Graf </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Monique Graf &lt;monique.p.n.graf@bluewin.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Main properties and regression procedures using a generalization of the Dirichlet distribution called Simplicial Generalized Beta distribution. It is a new distribution on the simplex (i.e. on the space of compositions or positive vectors with sum of components equal to 1). The Dirichlet distribution can be constructed from a random vector of independent Gamma variables divided by their sum. The SGB follows the same construction with generalized Gamma instead of Gamma variables. The Dirichlet exponents are supplemented by an overall shape parameter and a vector of scales. The scale vector is itself a composition and can be modeled with auxiliary variables through a log-ratio transformation. Graf, M. (2017, ISBN: 978-84-947240-0-8). See also the vignette enclosed in the package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>Formula</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS, numDeriv, alabama</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, goftest</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 09:04:24 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 09:37:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='arc'>
arc dataset
</h2><span id='topic+arc'></span>

<h3>Description</h3>

<p>39 (sand,silt,clay) compositions in an Arctic lake in function of depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("arc")</code></pre>


<h3>Format</h3>

<p>A data frame with 39 observations on the following 4 variables.
</p>

<dl>
<dt>sand</dt><dd><p>	sand part
</p>
</dd>
<dt>silt</dt><dd><p>	silt part
</p>
</dd>
<dt>clay</dt><dd><p>	clay part
</p>
</dd>
<dt>depth</dt><dd><p>	depth (m)
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Aitchison, J. (1986). <em>The Statistical Analysis of Compositional Data.</em>.  Monographs on Statistics
and Applied Probability. Chapman and Hall Ltd (reprinted 2003 with additional material by
the Blackburn Press, London (UK).</p>


<h3>References</h3>

<p>Coakley, J.P. and Rust, B.R. (1968). Sedimentation in an Arctic lake. <em>J. Sed. Petrology</em>, <b>38</b>, 1290-1300.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arc)
str(arc) 
</code></pre>

<hr>
<h2 id='B2i'>Balances to isometric log-ratio
</h2><span id='topic+B2i'></span>

<h3>Description</h3>

<p>Coefficients of log of parts in a balance matrix,  
(+1) for numerator  and (-1) for denominator, are transformed
into the corresponding isometric log-ratio (ilr) coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B2i(bal, balnames=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B2i_+3A_bal">bal</code></td>
<td>
<p> a (<code class="reqn">D-1</code> x <code class="reqn">D</code>) balance matrix with cells +1, 0 or -1.  
</p>
</td></tr>
<tr><td><code id="B2i_+3A_balnames">balnames</code></td>
<td>
<p> logical, if TRUE, balance names are attributed to ilr transforms; if FALSE (default) ilr transforms are numbered <code class="reqn">ilr1</code> to <code class="reqn">ilrD1</code>, where <code class="reqn">D1=D-1</code> and <code class="reqn">D</code> is the number of parts.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two scalars multiplying positive and negative cells respectively are defined for each row of the matrix <code class="reqn">bal</code> in such a way that the resulting matrix defines the ilr transformation to apply to the log of a compositional vector. The output transformation matrix is transposed for application to a compositional dataset where the compositions are the rows.
</p>


<h3>Value</h3>

<p> a  <code class="reqn">D \times (D-1)</code> matrix giving the coefficients of the ilr transforms 
</p>


<h3>References</h3>

<p>Pawlowsky-Glahn, V., J. J. Egozcue, and R. Tolosana-Delgado (2007). Lecture Notes on Compositional Data Analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bal &lt;- matrix(c(1,-1,0,1,1,-1),nrow=2, byrow=TRUE)
colnames(bal) &lt;- paste("l.P",1:3,sep="") 
bal
B2i(bal)

rownames(bal) &lt;- paste("B",1:2,sep="") 
bal
B2i(bal,balnames=TRUE)
B2i(bal)

</code></pre>

<hr>
<h2 id='carseg'>
carseg dataset
</h2><span id='topic+carseg'></span>

<h3>Description</h3>

<p>Segment shares of car sales in five categories according to the size of the car chassis, with explanatory variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("carseg")</code></pre>


<h3>Format</h3>

<p>A data frame with 152 observations on the following 13 variables.
</p>

<dl>
<dt>SA</dt><dd><p>		Segment share in category A
</p>
</dd>
<dt>SB</dt><dd><p>		Segment share in category B
</p>
</dd>
<dt>SC</dt><dd><p>		Segment share in category C
</p>
</dd>
<dt>SD</dt><dd><p>		Segment share in category D
</p>
</dd>
<dt>SE</dt><dd><p>		Segment share in category E
</p>
</dd>
<dt>expend</dt><dd><p>	quarterly household expenditures
</p>
</dd>
<dt>sent</dt><dd><p>	monthly confidence indicator made up of several branches
</p>
</dd>
<dt>FBCF</dt><dd><p>	monthly households investment
</p>
</dd>
<dt>PAC</dt><dd><p>		binary vector indicating the incentive period
</p>
</dd>
<dt>PIB</dt><dd><p>		Gross domestic product
</p>
</dd>
<dt>price</dt><dd><p>	gas oil price
</p>
</dd>
<dt>rates</dt><dd><p>	monthly short term interest rates
</p>
</dd>
<dt>month</dt><dd><p>	sequential month number (1 to 150)
</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset consists of simulated monthly segment market shares (SA to SE) corresponding to the 5 segments of a certain brand during 150 consecutive months (01/2003 to 08/2015). The set of explanatory variables was selected by Morais and Thomas-Agnan (2019) as being the most meaningful to explain the segment shares. Names have been simplified.
</p>


<h3>References</h3>

<p>Morais, J. and Thomas-Agnan, C. (2019), Impact of economic context on automobile market segment shares: a compositional approach, <em>Case Studies in Business, Industry and Government Statistics</em>, in press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carseg)
summary(carseg[,(6:12)])
</code></pre>

<hr>
<h2 id='covest.SGB'>
Classical and robust asymptotic covariance matrix
</h2><span id='topic+covest.SGB'></span>

<h3>Description</h3>

<p>Computation of two covariance matrices of the estimators of parameters in a SGB regression. The first is based on the Hessian and the second is the sandwich estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covest.SGB(x, d, u, V, weight=rep(1,dim(d)[1]), x0 = NULL, hessian = NULL, ind = NULL, 
    shape1 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covest.SGB_+3A_x">x</code></td>
<td>

<p>vector of parameters (shape1,coefi,shape2) where
shape1 is the overall shape, coefi is the vector of regression coefficients (see <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>) and shape2 the vector of the <code class="reqn">D</code> Dirichlet shape parameters; <code class="reqn">D</code>: number of parts.
shape1 and shape2 must be positive.
</p>
</td></tr>
<tr><td><code id="covest.SGB_+3A_d">d</code></td>
<td>

<p>data matrix of explanatory variables (with constant vector if required in the model) <code class="reqn">(n \times m)</code>; <code class="reqn">n</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables.
</p>
</td></tr>
<tr><td><code id="covest.SGB_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (variables to be explained) <code class="reqn">n \times D</code>.
</p>
</td></tr>
<tr><td><code id="covest.SGB_+3A_v">V</code></td>
<td>

<p>full rank transformation of log(parts) into log-ratios, matrix <code class="reqn">D \times (D-1)</code>.
</p>
</td></tr>
<tr><td><code id="covest.SGB_+3A_weight">weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>;  positive observation weights, default <code>rep(1,n)</code>. Should be scaled to sum to <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="covest.SGB_+3A_x0">x0</code></td>
<td>

<p>specification of the initial parameter vector of length <code class="reqn">npar</code> (optional), default: NULL, no specification.
</p>
</td></tr>
<tr><td><code id="covest.SGB_+3A_hessian">hessian</code></td>
<td>

<p>Hessian matrix (optional), see <code><a href="#topic+regSGB">regSGB</a></code>, default: NULL, no specification. In this case the Hessian is computed numerically.
</p>
</td></tr>
<tr><td><code id="covest.SGB_+3A_ind">ind</code></td>
<td>

<p>vector of length equal to the number of fixed parameters; specifies the indices of the fixed components in the vector of parameters <code class="reqn">x</code> (possible for <code>shape1</code> and <code>coefi</code> (regression coefficients) only).
</p>
</td></tr>
<tr><td><code id="covest.SGB_+3A_shape1">shape1</code></td>
<td>

<p>fixed value of the overall shape parameter, if <code>heq = heqa.SGB</code> or 
<code>heq = heqab.SGB</code>. Default is 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by regSGB. In this case the Hessian is the output of <code><a href="alabama.html#topic+auglag">auglag</a></code> and is numerically computed. <br />
A design based covariance matrix of the parameters can be obtained by linearization as the covariance matrix of the <code>scores</code>.
</p>


<h3>Value</h3>

<p>a list with
</p>
<table>
<tr><td><code>summary</code></td>
<td>
<p>Data frame with <br />
<code>Initial = x0</code> (if specified), <br />
<code>Estimate = x</code>, <br />
<code>StdErr1</code> = ordinary asymptotic standard error of parameters, <br />
<code>StdErr</code> = robust asymptotic standard error, <br />
<code>p.value</code> = asymptotic normal p-value based on <code>StdErr</code>. For <code>shape1</code>, <code class="reqn">H_0</code> is &quot;shape1=shape1&quot;, or &quot;shape1=1&quot; if <code>shape1=NULL</code>. The other parameters are tested against 0. <br />
<code>signif</code> = significance code based on p.value.
</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>matrix <code class="reqn">n \times npar</code>. Each row contains the (unweighted) derivatives of the log-density at a data point w.r.t the parameters.</p>
</td></tr>
<tr><td><code>vcov1</code></td>
<td>
<p>ordinary asymptotic covariance matrix, inverse of minus the Hessian.</p>
</td></tr>
<tr><td><code>StdErr1</code></td>
<td>
<p>vector of ordinary asymptotic standard error of parameters.</p>
</td></tr>
<tr><td><code>varest2</code></td>
<td>
<p>robust asymptotic covariance matrix.</p>
</td></tr>
<tr><td><code>StdErr</code></td>
<td>
<p>vector of robust asymptotic standard error of parameters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Huber, P. J. (1967). The behavior of maximum likelihood estimates under nonstandard conditions. In <em>Proceedings of the Fifth Berkeley Symposium on Mathematical Statistics and Probability</em>, Volume 1, pp. 221-233.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regSGB">regSGB</a></code> for creating <code>oilr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arc)
data(oilr)

## compositions
da &lt;- as.matrix(log(arc[["depth"]]),ncol=1)
ua &lt;- as.matrix(arc[,1:3])

## ilr transforms
 c1 &lt;- 1/sqrt(2)
 c2 &lt;- 1/sqrt(6)
 Vilr &lt;- matrix(c(-c1,c1,0,-c2,-c2,2*c2),nrow=3)
 colnames(Vilr) &lt;- c("ilr1","ilr2")
 Vilr
 
 covs &lt;- covest.SGB(oilr[["par"]], da, ua, Vilr)

## Compare the ordinary and robust correlation matrices of parameters estimates.

## (Ordinary) covariance based on inverse Hessian
vcov1 &lt;- covs[["vcov1"]] 
StdErr1 &lt;- covs[["StdErr1"]]
## Estimated correlation matrix
vcor1 &lt;- diag(1/StdErr1) %*% vcov1 %*% diag(1/StdErr1)
round(vcor1,2)

## Robust (Huber's sandwich estimator):
StdErr &lt;- covs[["StdErr"]]
vcov &lt;- covs[["vcov"]]

## Estimated correlation matrix
round(diag(1/StdErr) %*% vcov %*% diag(1/StdErr),2)

</code></pre>

<hr>
<h2 id='EqualityConstr'>
Equality constraints for overall shape and/or regression parameters and jacobian
</h2><span id='topic+EqualityConstr'></span><span id='topic+heqa.SGB'></span><span id='topic+heqa.SGB.jac'></span><span id='topic+heqb.SGB'></span><span id='topic+heqb.SGB.jac'></span><span id='topic+heqab.SGB'></span><span id='topic+heqab.SGB.jac'></span>

<h3>Description</h3>

<p>Setting of equality constraints on parameters. <br />
<code>heqa.SGB</code> sets the overall shape parameter to <code>shape1</code>. <br />
<code>heqb.SGB</code> sets specified regression parameters to 0.  <br />
<code>heqab.SGB</code> is a combination of both.  <br />
<code>heqa.SGB.jac</code>, <code>heqb.SGB.jac</code>, <code>heqab.SGB.jac</code> compute the corresponding Jacobians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heqa.SGB(x, d, u, bound, shape1, ...)
heqa.SGB.jac(x, ...)
heqb.SGB(x, d, u, bound, shape1, index, ...)
heqb.SGB.jac(x, d, u, bound, shape1, index, ...)
heqab.SGB(x, d, u, bound, shape1, index, ...)
heqab.SGB.jac(x, d, u, bound, shape1, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EqualityConstr_+3A_x">x</code></td>
<td>

<p>current vector of parameters (<code>shape1</code>, <code>coefi</code>, <code>shape2</code>) where
<code>shape1</code> is the overall shape, <code>coefi</code> is the vector of regression coefficients (see <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>) and <code>shape2</code> the vector of <code class="reqn">D</code> Dirichlet shape parameters.
</p>
</td></tr>
<tr><td><code id="EqualityConstr_+3A_d">d</code></td>
<td>

<p>data matrix of explanatory variables (without constant vector) <code class="reqn">(N \times m)</code>; <code class="reqn">N</code>: sample size, <code class="reqn">m</code>: number of explanatory variables.
</p>
</td></tr>
<tr><td><code id="EqualityConstr_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(N \times D)</code>; <code class="reqn">D</code>: number of parts.
</p>
</td></tr>
<tr><td><code id="EqualityConstr_+3A_bound">bound</code></td>
<td>

<p>not used.
</p>
</td></tr>
<tr><td><code id="EqualityConstr_+3A_shape1">shape1</code></td>
<td>

<p>chosen fixed value of the overall shape parameter. <br /> 
Default <code>shape1</code> = 1 for <code>heqa.SGB</code> and <code>heqab.SGB</code>. <br />
<code>shape1</code> is not fixed in <code>heqb.SGB</code>.
</p>
</td></tr>
<tr><td><code id="EqualityConstr_+3A_index">index</code></td>
<td>

<p>vector of length equal to the number of fixed parameters; specifies the indices of the fixed components in the vector of parameters <code>x</code>, such that for <br /> 
<code>heqa.SGB, heqa.SGB.jac</code>: <code>index</code>=1. The fixed value of the overall shape parameter is <code>shape1</code> (by default 1). <br /> 
<code>heqb.SGB, heqb.SGB.jac</code>: <code>index</code>= c(...) with ... the indices of regression parameters to be set to 0. <br /> 
<code>heqab.SGB, heqab.SGB.jac</code>: <code>index</code>=c(1,...); <code>shape1</code> is the fixed value of the overall shape parameter, and ... the indices of the regression parameters to be set to 0. 
</p>
</td></tr>
<tr><td><code id="EqualityConstr_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are invoked by <code><a href="#topic+regSGB">regSGB</a></code> through the specification of the function name, <code>shape1</code> and/or <code>index</code>.
</p>


<h3>Value</h3>

<p><code>heqa.SGB</code>, <code>heqb.SGB</code>, <code>heqab.SGB</code>: vector of the same length as <code>index</code> specifying the current value of <code>x[index]</code> or <code>x[1]-shape1</code>, where <code>x</code> is the current vector of parameters. It should be near zero at convergence of the regression algorithm. <br />
<code>heqa.SGB.jac</code>, <code> heqb.SGB.jac</code>, <code> heqab.SGB.jac</code>: the corresponding jacobian matrices of dimensions <code class="reqn">length(index) \times length(x)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regSGB">regSGB</a></code>, <code><a href="#topic+summary.regSGB">summary.regSGB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## parameter vector for a 3 parts composition with one explanatory variable (+ intercept):
x &lt;- c(1,3.2,0.04,0.05,6,7:9)

## shape1 fixed to 1.5:
heqa.SGB(x,d,u,bound,1.5)
heqa.SGB.jac(x)

## Parameters 3 (first slope) and 4 (second intercept) fixed to 0:
heqb.SGB(x,d,u,bound,shape1,c(3,4))
heqb.SGB.jac(x,d,u,bound,shape1,c(3,4))

## Parameters 1, 3, 4 fixed to 1.5, 0, 0 respectively:
heqab.SGB(x,d,u,bound,1.5,c(1,3,4))
heqab.SGB.jac(x,d,u,bound,1.5,c(1,3,4))
</code></pre>

<hr>
<h2 id='EZ.SGB'>
Expectations of Z under the SGB distribution
</h2><span id='topic+EZ.SGB'></span>

<h3>Description</h3>

<p>Expectations under Lebesgue and Aitchison measures for the transformed composition <code class="reqn">Z= C((U/scale)^{shape1})</code> and <code class="reqn">C(Z^{1/shape1})</code>, where <code class="reqn">C(.)</code> is the closure operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EZ.SGB(D, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EZ.SGB_+3A_x">x</code></td>
<td>

<p>vector of parameters (<code>shape1</code>,<code>coefi</code>,<code>shape2</code>) where
<code>shape1</code> is the overall shape, <code>coefi</code> is the vector of regression coefficients (see <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>) and <code>shape2</code> the vector of <code class="reqn">D</code> Dirichlet shape parameters
</p>
</td></tr>
<tr><td><code id="EZ.SGB_+3A_d">D</code></td>
<td>

<p>number of parts
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 4 rows and D columns giving on each row the expectation of parts
</p>
<table>
<tr><td><code>EZ</code></td>
<td>

<p><code class="reqn">E(Z)</code>, expectation under the (ordinary) Lebesgue measure,
</p>
</td></tr>
<tr><td><code>EAZ</code></td>
<td>

<p><code class="reqn">E_A(Z)</code>, expectation under the Aitchison measure,
</p>
</td></tr>
<tr><td><code>EZa</code></td>
<td>

<p><code class="reqn">E(Z^{1/shape1})</code>, expectation under the (ordinary) Lebesgue measure,
</p>
</td></tr>
<tr><td><code>EAZa</code></td>
<td>

<p><code class="reqn">E_A(Z^{1/shape1})</code>, expectation under the Aitchison measure.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+zval">zval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
x &lt;- c(2,rnorm(4,0,1),1.8,3.1,4.0) 
D &lt;- 3
EZ.SGB(D,x)

</code></pre>

<hr>
<h2 id='GenGammaDistrib'>Generalized Gamma distribution
</h2><span id='topic+GenGammaDistrib'></span><span id='topic+dggamma'></span><span id='topic+rggamma'></span>

<h3>Description</h3>

<p>Density and random generation of the generalized gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dggamma(x, shape1, scale, shape2)
rggamma(n, shape1, scale, shape2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenGammaDistrib_+3A_x">x</code></td>
<td>

<p>vector of positive values
</p>
</td></tr>
<tr><td><code id="GenGammaDistrib_+3A_n">n</code></td>
<td>

<p>number of simulated vectors
</p>
</td></tr>
<tr><td><code id="GenGammaDistrib_+3A_shape1">shape1</code></td>
<td>

<p>overall shape parameter
</p>
</td></tr>
<tr><td><code id="GenGammaDistrib_+3A_scale">scale</code></td>
<td>

<p>vector of scales. Should be of the same length as <code>x</code>
</p>
</td></tr>
<tr><td><code id="GenGammaDistrib_+3A_shape2">shape2</code></td>
<td>

<p>vector of Dirichlet parameters. Should be of the same length as <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>log density at <code class="reqn">x &gt;0</code>: <br />
<code class="reqn">log(shape1/scale) - lgamma(shape2) + (shape1*shape2-1)*log(x/scale) - (x/scale)^{shape1}</code>
</p>


<h3>Value</h3>

<p>dggamma: Generalized gamma density evaluated at  x 
</p>
<p>rggamma: Generalized gamma random deviates
</p>


<h3>References</h3>

<p>Stacy, E.W. (1962). &quot;A Generalization of the Gamma Distribution.&quot; <em>Annals of Mathematical Statistics</em> <strong>33</strong>(3): 1187-1192.<br /> <br />
Johnson, N.L.; Kotz, S; Balakrishnan, N. (1994) <em>Continuous Univariate Distributions</em>, Volume 1, 2nd Edition. Wiley. ISBN 0-471-58495-9 (Section 17.8.7)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
u1 &lt;- rggamma(10,2,1,1.4) # 10 random deviates with scale 1
set.seed(12345)
u &lt;- rggamma(10,2,1:10,1.4) # 10 random deviates with scale 1:10, repectively
u
u/u1
dggamma(u,2,1:10,1.4)
</code></pre>

<hr>
<h2 id='GoodnessFit'>
Goodness of fit tests on the marginal distributions of each part in a SGB model
</h2><span id='topic+GoodnessFit'></span><span id='topic+ks.SGB'></span><span id='topic+cvm.SGB'></span><span id='topic+print.testSGB'></span>

<h3>Description</h3>

<p>Kolmogorov-Smirnov goodness of fit tests <br />
Cramer-von-Mises goodness of fit tests. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks.SGB(u,shape1,shape2,scale,alpha=0.05)
cvm.SGB(u,shape1,shape2,scale,alpha=0.05)

## S3 method for class 'testSGB'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GoodnessFit_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(N \times D)</code>; <code class="reqn">D</code>: number of parts
</p>
</td></tr>
<tr><td><code id="GoodnessFit_+3A_shape1">shape1</code></td>
<td>

<p>positive number, overall shape parameter of the SGB distribution. See <code><a href="#topic+SGBdistrib">SGBdistrib</a></code>.
</p>
</td></tr>
<tr><td><code id="GoodnessFit_+3A_shape2">shape2</code></td>
<td>

<p>vector of length <code class="reqn"> D</code>, Dirichlet shape parameters of the SGB distribution. See <code><a href="#topic+SGBdistrib">SGBdistrib</a></code>.
</p>
</td></tr>
<tr><td><code id="GoodnessFit_+3A_scale">scale</code></td>
<td>

<p>matrix of the same dimensions as <code>u</code>, containing the shape compositions, or positive number if the scales of all parts are identical. See <code><a href="#topic+SGBdistrib">SGBdistrib</a></code>.
</p>
</td></tr>
<tr><td><code id="GoodnessFit_+3A_alpha">alpha</code></td>
<td>

<p>overall level of the test, default 0.05.
</p>
</td></tr>
<tr><td><code id="GoodnessFit_+3A_x">x</code></td>
<td>

<p>an object of class &quot;testSGB&quot;.
</p>
</td></tr>
<tr><td><code id="GoodnessFit_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ks.SGB</code> calls <code><a href="stats.html#topic+ks.test">ks.test</a></code> and <code>cvm.SGB</code> calls <code><a href="goftest.html#topic+cvm.test">cvm.test</a></code>. <br />  
Consider <code class="reqn">z=C[(u/scale)^{shape1}]</code>, where <code class="reqn">C[.]</code> is the closure operation. The scale compositions <code class="reqn">scale</code> may be modelled with auxiliary variables. Under the SGB hypothesis, the components of  <code class="reqn"> z</code> should be marginally beta-distributed. The functions provide <code class="reqn"> D</code> tests, one for each part. <br />
Theoretically, the parameters should be known and not estimated on the data. Thus the test using estimated parameters is conservative. <br />
The cutoff value is based on the false discovery rate for multiple comparisons  (Benjamini and Hochberg, 1995), which is simply <code>alpha*i/D</code> for the i-th ordered p-value, i=1,...,D (number of tests). Reject the null hypothesis if at least one p-value is smaller than the cutoff. The overall level is then <code>alpha</code>. The proof of the result does not use an independence assumption between the tests.
</p>


<h3>Value</h3>

<p>A list of class 'testSGB' with the following components:<br />
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>either &quot;One-sample Kolmogorov-Smirnov test&quot; or &quot;Cramer-von Mises test of goodness-of-fit&quot;
</p>
</td></tr>
<tr><td><code>Compositions</code></td>
<td>
<p>name of the dataset <code>u</code>
</p>
</td></tr>
<tr><td><code>tests</code></td>
<td>
<p>data frame with <code class="reqn">D</code> rows and 3 columns: test statistics for each part against the beta distribution and corresponding p-values and cutoff. Any  p-value smaller than the cutoff means that the assumption of the beta distribution for all the margins is rejected.
</p>
</td></tr>
</table>
<p>A print method exists for the class &quot;testSGB&quot;.
</p>


<h3>References</h3>

<p>Benjamini, Y. and Y. Hochberg (1995). Controlling the false discovery rate: A practical and powerful approach to multiple testing. <em>Journal of the Royal Statistical Society.</em> Series B (Methodological) 57 (1), 289-300. <br /> <br />
Birnbaum, Z. W.  and Fred H. Tingey (1951), One-sided confidence contours for probability distribution functions. <em>The Annals of Mathematical Statistics</em>, <strong>22</strong>/4, 592-596. <br /> <br />
Conover, William J.  (1971), <em>Practical Nonparametric Statistics.</em> New York: John Wiley &amp; Sons. Pages 295-301 (one-sample Kolmogorov test), 309-314 (two-sample Smirnov test). <br /> <br />
Csorgo, S. and Faraway, J.J. (1996) The exact and asymptotic distributions of Cramer-von Mises statistics. <em>Journal of the Royal Statistical Society</em>, Series B <strong>58</strong>, 221-234. <br /> <br />
Durbin, J. (1973), <em>Distribution theory for tests based on the sample distribution function.</em> SIAM. <br /> <br />
Marsaglia, G., Wai Wan Tsang and Jingbo Wang (2003), Evaluating Kolmogorov's distribution. <em>Journal of Statistical Software</em>, <strong>8</strong>/18.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SGBdistrib">SGBdistrib</a></code> for the theoretical distribution,  <code><a href="#topic+oilr">oilr</a></code> for the regression results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate 1000 random variates according to SGB(shape1,rep(1/3,3),shape2)
shape1 &lt;- 0.6
shape2 &lt;- c(10,20, 30)
rnum &lt;- rSGB(1000,shape1,rep(1,3)/3,shape2)
ks.SGB(rnum,shape1=shape1, shape2=shape2,scale=1)
## same result as
ks.SGB(rnum,shape1=shape1,scale= matrix(rep(1/3,3000),ncol=3), shape2=shape2)
library(goftest)
cvm.SGB(rnum,shape1=shape1,scale= matrix(rep(1/3,3000),ncol=3), shape2=shape2)

## Arctic lake data

# oilr is a SGB regression object, see \code{\link{oilr}}.
data(oilr)       # regSGB object
data(arc)
ua &lt;- arc[1:3]   # compositions

## Kolmogorov-Smirnov goodness of fit test
ks.SGB(ua,shape1=oilr[["par"]][1],shape2=oilr[["par"]][4:6],scale=oilr[["scale"]])
## Rounding shape1 affects the results less than rounding shape2.
ks.SGB(ua,shape1=round(oilr[["par"]][1],3),shape2=round(oilr[["par"]][4:6],1),
	 scale=oilr[["scale"]])
ks.SGB(ua,shape1=round(oilr[["par"]][1],1),shape2=round(oilr[["par"]][4:6],3),
	 scale=oilr[["scale"]])

## Cramer-von-Mises goodness of fit test
library(goftest)
cvm.SGB(ua,shape1=oilr[["par"]][1],shape2=oilr[["par"]][4:6],scale=oilr[["scale"]])

</code></pre>

<hr>
<h2 id='Imputation'>
Imputation of missing parts in compositions from a SGB model
</h2><span id='topic+Imputation'></span><span id='topic+impute.regSGB'></span>

<h3>Description</h3>

<p>Applied to a completely missing composition, the function returns the Aitchison expectation. <br />
Applied to a partially missing composition, it returns the conditional Aitchison expectation, given the observed sub-composition. <br />
Applied to a complete case, it returns the complete case. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.regSGB(obj, dsup, usup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Imputation_+3A_obj">obj</code></td>
<td>

<p>list, output of regSGB.
</p>
</td></tr>
<tr><td><code id="Imputation_+3A_dsup">dsup</code></td>
<td>

<p>data frame with explanatory variables for the incomplete compositions. Missing values not allowed.
</p>
</td></tr>
<tr><td><code id="Imputation_+3A_usup">usup</code></td>
<td>

<p>compositions corresponding to <code>dsup</code>. On each row, the non-missing parts sum to 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with imputed compositions instead of missing or partially missing compositions. Complete cases are also returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Arctic lake
data(arc)
arcmis &lt;- arc
arc[11:13,]

## Introduce NA alues

arcmis[11,2] &lt;- NA      # "core" observation
arcmis[12,3] &lt;- NA      # outlying clay value
arcmis[13,1:3] &lt;- NA    # totally missing observation
umis &lt;- arcmis[,1:3]
umis &lt;- umis/rowSums(umis,na.rm=TRUE)
umis[11:13,]

d &lt;- data.frame(depth=arc[["depth"]])

## original compositions
arc[11:13,1:3]

## unconditional predicted value                            
MeanA.SGB(oilr[["par"]][1],oilr[["scale"]],oilr[["par"]][4:6] )[11:13,]

## predicted value given the sub-composition (sand,clay) for 11, (sand,silt) for 12        
impute.regSGB(oilr,arcmis,umis)[11:13, ]

impute.regSGB(oilr,arcmis[11:13, ],umis[11:13, ])  # same result. 
</code></pre>

<hr>
<h2 id='InequalityConstr'>
Inequality constraints and jacobian
</h2><span id='topic+InequalityConstr'></span><span id='topic+hin.SGB'></span><span id='topic+hin.SGB.jac'></span>

<h3>Description</h3>

<p>Setting of inequality constraints on shape parameters. <br />
<code>hin.SGB</code> sets inequality constraints on the shape parameters in a SGB regression.<br />
<code>hin.SGB.jac</code> defines the corresponding Jacobian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hin.SGB(x, d, u, bound, ...)
hin.SGB.jac(x, d, u, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InequalityConstr_+3A_x">x</code></td>
<td>

<p>vector of parameters (<code>shape1</code>, <code>coefi</code>, <code>shape2</code>) where
<code>shape1</code> is the overall shape, <code>coefi</code> is the vector of regression coefficients (see <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>) and <code>shape2</code> the vector of <code class="reqn">D</code> Dirichlet shape parameters.
</p>
</td></tr>
<tr><td><code id="InequalityConstr_+3A_d">d</code></td>
<td>

<p>data matrix of explanatory variables (without constant vector) <code class="reqn">(N 	\times m)</code>; <code class="reqn">N</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables.
</p>
</td></tr>
<tr><td><code id="InequalityConstr_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(N \times D)</code>; <code class="reqn">D</code>: number of parts.
</p>
</td></tr>
<tr><td><code id="InequalityConstr_+3A_bound">bound</code></td>
<td>

<p>the estimates of shapes are constrained by <code>shape1*shape2[i] &gt; bound, i=1,...,D.</code> By default <code>bound = 2.1</code>. 
</p>
</td></tr>
<tr><td><code id="InequalityConstr_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are invoked internally by <code>regSGB</code> with <code>bound</code> specified by the user. <br />
<code>shape1</code> is constrained to be larger than 0.1, in order to avoid numerical problems and <code>shape2</code> must be positive. <br />
Moments of ratios of parts only exist up to <code>bound</code>. Thus <code>bound = 2.1</code> guarantees the existence of variances of ratios of parts.
</p>


<h3>Value</h3>

<p><code>hin.SGB</code> : vector of length <code class="reqn">D+1</code> with the current value of <code>c(shape1-0.1,shape1*shape2-bound)</code>. It should be non-negative at convergence of the regression algorithm. <br />
<code>hin.SGB.jac</code> : corresponding jacobian matrix of dimensions <code class="reqn">(D+1) \times</code>  <code>length(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Parameter vector for a 3 parts composition with one explanatory variable (+ intercept):
x &lt;- c(1,3.2,0.04,0.05,6,7:9)
bound &lt;- 2.1
u &lt;- t(c(0.1,0.5,0.4))  # only used to compute the number of parts.
hin.SGB(x, d, u, bound)
# = c(shape1-0.1, shape1*shape2-bound,shape2)
# all must be positive.
</code></pre>

<hr>
<h2 id='InitialParameters'>
Initial parameters estimates and comparison
</h2><span id='topic+InitialParameters'></span><span id='topic+initpar.SGB'></span><span id='topic+compushape2'></span><span id='topic+condshape2'></span>

<h3>Description</h3>

<p><code>initpar.SGB</code> computes an initial vector of parameters. <br />
<code>condshape2</code> computes the <code>shape2</code> parameters by the same method as <code>initpar.SGB</code>, but from an arbitrary set of parameters (<code>shape1</code>,<code>coefi</code>)  (e.g. the result of a SGB regression fit). These approximations are compared with the <code>shape2</code> estimates. <br />
<code>compushape2</code> is internally called by <code>initpar.SGB</code> and <code>condshape2</code>. It computes <code>shape2</code> parameters in function of <code>shape1</code> and given regression parameters <code>coefi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initpar.SGB(d, u, V, weight = rep(1, dim(u)[1]), shape1 = 1, Mean2 = TRUE) 
condshape2(x,d,u,V)
compushape2(shape1, coefi, d, u, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InitialParameters_+3A_d">d</code></td>
<td>

<p>data matrix of explanatory variables (without constant vector) <code class="reqn">(n \times m)</code>;  <code class="reqn">n</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables
</p>
</td></tr>
<tr><td><code id="InitialParameters_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(n \times D)</code>; <code class="reqn">D</code>: number of parts
</p>
</td></tr>
<tr><td><code id="InitialParameters_+3A_v">V</code></td>
<td>

<p>full rank transformation of log(parts) into log-ratios, matrix <code class="reqn">D \times (D-1)</code>
</p>
</td></tr>
<tr><td><code id="InitialParameters_+3A_weight">weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>;  positive observation weights, default <code>rep(1,n)</code>. Should be scaled to sum to <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="InitialParameters_+3A_shape1">shape1</code></td>
<td>

<p>positive number, overall shape parameter
</p>
</td></tr>
<tr><td><code id="InitialParameters_+3A_mean2">Mean2</code></td>
<td>

<p>logical, if TRUE (default), the computed <code>shape2</code> parameters are each replaced by their average.
</p>
</td></tr>
<tr><td><code id="InitialParameters_+3A_coefi">coefi</code></td>
<td>

<p>vector of regression coefficients of length <code class="reqn">(m+1)*(D-1)</code>, resp.  <code class="reqn">D-1</code> constants, then <code class="reqn">D-1</code> coef. of the 1st expl. variable,..., <code class="reqn">D-1</code> coef. of the <code class="reqn">m</code>-th expl. variable
</p>
</td></tr>
<tr><td><code id="InitialParameters_+3A_x">x</code></td>
<td>

<p>fitted SGB regression parameters, see <code><a href="#topic+regSGB">regSGB</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main function here is <code>initpar.SGB</code>. The initial value of <code>shape1</code> must be specified by the user; by default, it takes the value 1.
In the initial regression model, each column of 
<code>log(u) % * % V</code>  
is regressed by OLS on the columns of <code>d</code>. <code>coefi</code> is the vector of regression parameters, first the <code class="reqn">D-1</code> terms associated with the first explanatory variable in <code>d</code>, and so on similarily for each explanatory variable. The initial scale compositions are computed by back-transforming the predicted values to the simplex and used to compute the vector <code class="reqn"> z=C[(u/scale)^{shape1}]</code>, where <code class="reqn">C[.]</code> is the closure operation. Wicker et al. (2008), see also Ng et al. (2011) p.74-75, describe a procedure to find initial values for the shape parameters in a Dirichlet distribution. Their method is used on the (approximate) Dirichlet vector <code class="reqn"> z</code>. <br />
</p>


<h3>Value</h3>

<p><code>initpar.SGB</code>:  <br />
vector of length <code class="reqn">(1+ (D-1)*(m+1) + D)</code> containing initial  values for (<code>shape1</code>,<code>coefi</code>,<code>shape2</code>). <br />
<code>condshape2</code>: <br />
list with two components: 1. title and 2. data-frame with 2 columns: fitted <code>shape2</code> and Wicker's  approximation.
</p>


<h3>References</h3>

<p>Wicker, N., J. Muller, R. K. R. Kalathur, and O. Poch (2008). A maximum likelihood approximation method for Dirichlet's parameter estimation. <em>Computational Statistics &amp; Data Analysis</em> <b>52</b> (3), 1315-1322.
</p>
<p>Kai Wang Ng, Guo-Liang Tian, Man-Lai Tang (2011). <em>Dirichlet and Related Distributions: Theory, Methods and Applications</em>. Wiley Series in Probability and Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Explanatory variable
da &lt;- data.frame(l.depth=log(arc[["depth"]]))  
damat &lt;- as.matrix(da)
## Compositions
ua &lt;- arc[,1:3]

## alr transforms
Va &lt;- matrix(c(1,0,-1,0,1,-1),nrow=3)   
colnames(Va) &lt;- c("alr1","alr2")
Va

## Initial values
initpar.SGB(damat,ua,Va)
initpar.SGB(damat,ua,Va,Mean2=FALSE)

## Conditional shape2 values; same as parameters computed with initpar
condshape2(initpar.SGB(damat,ua,Va,Mean2=FALSE),damat,ua,Va)

## Comparison with fitted parameters
oa &lt;- regSGB(damat, as.matrix(ua), Va)
condshape2(oa[["par"]],damat,ua,Va)

</code></pre>

<hr>
<h2 id='MarginPlots'> 
Histograms, quantile and probability plots for the z(u)-transforms of parts
</h2><span id='topic+MarginPlots'></span><span id='topic+hzbeta'></span><span id='topic+qzbeta'></span><span id='topic+pzbeta'></span>

<h3>Description</h3>

<p>These functions draw a plot for each part in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hzbeta(u, obj, weight = rep(1,dim(u)[1]) )
qzbeta(u, obj, weight = rep(1,dim(u)[1]) )
pzbeta(u, obj, weight = rep(1,dim(u)[1]) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MarginPlots_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(N \times D)</code>; <code class="reqn">D</code>: number of parts
</p>
</td></tr>
<tr><td><code id="MarginPlots_+3A_obj">obj</code></td>
<td>

<p>list, result of regSGB. See <code><a href="#topic+regSGB">regSGB</a></code>.
</p>
</td></tr>
<tr><td><code id="MarginPlots_+3A_weight">weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>;  positive observation weights, default rep(1,n). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">U</code> follow a <code class="reqn">SGB(shape1,scale,shape2)</code> distribution. Then the composition 
</p>
<p style="text-align: center;"><code class="reqn">Z=C[(U/scale)^{shape1}]</code>
</p>
 
<p>is called the <code class="reqn">z(u)</code>-transform of <code class="reqn">U</code>.<br />
<code class="reqn">Z</code> follows a <code class="reqn">Dirichlet(shape2)</code> distribution and each part <code class="reqn">Z_i, i=1,...,D</code> is Beta-distributed with parameters <code>(shape2[i],sum(shape2)-shape2[i])</code>.
<br />
Goodness of fit plots are produced for the parts of the <code class="reqn">z(u)</code>-transforms against the Beta distribution. Each function creates <code class="reqn">D</code> plots, where <code class="reqn">D</code> is the number of parts. <br />
<code>hzbeta</code>: histograms and the corresponding Beta-densities,<br /> 
<code>qzbeta</code>: marginal quantile plots, <br /> 
<code>pzbeta</code>: marginal probability plots.<br />
If <code>weight</code>  is specified, weighted histgrams, quantile and probability plots are drawn. 
</p>


<h3>Value</h3>

<p><code class="reqn">D</code> plots are produced comparing the marginal distribution of the parts of the <code class="reqn">z(u)</code> compositions with the theoretical Beta distribution. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Arctic lake data
data(arc)
# Compositions
ua &lt;- arc[,1:3]

# SGB regression
data(oilr)

# plot
par(mfrow=c(3,3))
hzbeta(ua,oilr)
qzbeta(ua,oilr)
pzbeta(ua,oilr)
</code></pre>

<hr>
<h2 id='ocar'>
ocar data set
</h2><span id='topic+ocar'></span>

<h3>Description</h3>

<p>Car segment shares SGB regression with formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ocar")</code></pre>


<h3>Format</h3>

<p>List of 25 items, see <code><a href="#topic+regSGB">regSGB</a></code>.
</p>


<h3>Details</h3>

<p><code>ocar</code> is the same regression as <code>object3</code> in <code><a href="#topic+regSGB">regSGB</a></code>, Example 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ocar)
ocar
summary(ocar)   # regSGB summary
ocar[["kkt1"]]  # first KKT condition
ocar[["V"]]     # matrix of log-ratio transformation

#######################################################
## ocar has been created by the following commands:
## Car segment shares
 data(carseg)
 
## Extract the compositions
uc &lt;- as.matrix(carseg[,(1:5)])

## Define the log-ratio transformation matrix
Vc &lt;- matrix(c( 1, 0, 0, 0,
               -1, 1, 0, 0,
                0,-1, 1, 0,
                0, 0,-1, 1,
                0, 0, 0,-1),ncol=4,byrow=TRUE)
colnames(Vc) &lt;- c("AB","BC","CD","DE")
rownames(Vc) &lt;- colnames(uc)
Vc

## Formula
Form &lt;- Formula(AB | BC | CD | DE ~  log(expend) + I(PAC*log(expend)) + log(sent) + log(FBCF) + 
                 log(price) + rates)
ocar &lt;- regSGB(Form, data = list(carseg, uc, Vc),shape10=4.4)
##########################################################

</code></pre>

<hr>
<h2 id='oilr'>
oilr data set
</h2><span id='topic+oilr'></span>

<h3>Description</h3>

<p>Arctic lake SGB regression based on isometric log-ratio transforms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("oilr")</code></pre>


<h3>Format</h3>

<p>List of 25 items, see <code><a href="#topic+regSGB">regSGB</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oilr)
oilr
summary(oilr)   # regSGB summary
oilr[["kkt1"]]  # first KKT condition
oilr[["V"]]     # matrix of log-ratio transformation

## oilr has been created by the following commands:
## Arctic lake data
 data(arc)
# Compositions
 ua &lt;- arc[,1:3]

## ilr transforms
 c1 &lt;- 1/sqrt(2)
 c2 &lt;- 1/sqrt(6)
 Vilr &lt;- matrix(c(-c1,c1,0,-c2,-c2,2*c2),nrow=3)
 colnames(Vilr) &lt;- c("ilr1","ilr2")
 Vilr

## Formula
 F1 &lt;- Formula(ilr1 | ilr2 ~ -1 + log(depth) )
# SGB regression object
 oilr &lt;- regSGB(F1, data= list(arc, ua, Vilr), shape10=0.5, bound=2.1)
##########################################################

</code></pre>

<hr>
<h2 id='regSGB'>
Regression for compositions following a SGB distribution
</h2><span id='topic+regSGB'></span><span id='topic+regSGB.default'></span><span id='topic+regSGB.formula'></span><span id='topic+summary.regSGB'></span><span id='topic+print.regSGB'></span>

<h3>Description</h3>

<p>Explanatory variables may influence the scale vector through a linear model applied to a log-ratio transform of the compositions. The shape parameters do not depend on explanatory variables. The overall shape parameter <code>shape1</code> is common to all parts, whereas the Dirichlet shape parameters vector <code>shape2</code> are specific to each part, i.e. <code>shape2[j]</code> is the Dirichlet parameter for <code>u[i,j]</code>, <code>i=1,...,n</code>, (<code>n</code>=number of compositions in the dataset <code>u</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regSGB(d, ...)

## Default S3 method:
regSGB(d, u, V, weight=rep(1,dim(d)[1]), 
    shape10 = 1, bound = 2.1, ind = NULL, shape1 = NULL, Mean2 = TRUE, 
    control.optim = list(trace=0,fnscale=-1),
    control.outer = list(itmax=1000,ilack.max=200,trace=TRUE, kkt2.check =TRUE,
    method = "BFGS"),...)
       
## S3 method for class 'formula'
regSGB(Formula, data= list(), weight=rep(1,dim(d)[1]), 
    shape10 = 1, bound = 2.1, ind = NULL, shape1 = 1,  Mean2=TRUE,
    control.optim = list(trace=0,fnscale=-1),
    control.outer = list(itmax=1000,ilack.max=200,trace=TRUE,kkt2.check =TRUE, 
    method = "BFGS"),...)
         
## S3 method for class 'regSGB'
print(x, ...)

## S3 method for class 'regSGB'
summary(object, digits=3,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regSGB_+3A_formula">Formula</code></td>
<td>

<p>formula of class Formula, see <code><a href="Formula.html#topic+Formula">Formula</a></code>.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_d">d</code></td>
<td>

<p>data matrix of explanatory variables (without constant vector) <code class="reqn">(n \times m)</code>; <code class="reqn">n</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(n \times D)</code>; <code class="reqn">D</code>: number of parts.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_v">V</code></td>
<td>

<p>log-ratio transformation matrix <code class="reqn">(D \times (D-1))</code>.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_data">data</code></td>
<td>
<p> a list with 3 components <code>d</code>, <code>u</code> and <code>V</code>. 
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_weight">weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>;  positive observation weights, default rep(1,n). Should be scaled to sum to <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_shape10">shape10</code></td>
<td>

<p>positive number, initial value of the overall shape parameter, default 1.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_bound">bound</code></td>
<td>

<p>inequality constraints on the estimates of shapes:<br />
<code>shape1*shape2[i] &gt; bound, i=1,...,D.</code> <br />
By default <code>bound = 2.1</code>, see <code><a href="#topic+InequalityConstr">InequalityConstr</a></code>. 
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_ind">ind</code></td>
<td>

<p>vector of length equal to the number of fixed parameters; see <code>index</code> in <code><a href="#topic+EqualityConstr">EqualityConstr</a></code>. 
Default <code>ind</code> = NULL (no fixed parameters).
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_shape1">shape1</code></td>
<td>

<p>fixed value of the overall shape parameter if <code>min(ind)=1</code>. Default is 1.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_mean2">Mean2</code></td>
<td>

<p>logical, if TRUE (default), the computed <code>shape2</code> parameters are each replaced by their average. See <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_control.optim">control.optim</code></td>
<td>

<p>list of control parameters for optim, see <code><a href="stats.html#topic+optim">optim</a></code>. Default is from <code><a href="alabama.html#topic+auglag">auglag</a></code>, except <code>list(fnscale = -1)</code>. Always specify <code>fnscale = -1</code>.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_control.outer">control.outer</code></td>
<td>

<p>list of control parameters to be used by the outer loop in <code>constrOptim.nl</code>, see <code><a href="alabama.html#topic+auglag">auglag</a></code>. 
Default is from <code><a href="alabama.html#topic+auglag">auglag</a></code>, except <br />
<code>list(itmax = 1000, ilack.max = 200</code>.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_object">object</code></td>
<td>

<p>an object of class &quot;regSGB&quot;.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_digits">digits</code></td>
<td>

<p>number of decimal places for print, default 3.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_x">x</code></td>
<td>

<p>an object of class &quot;regSGB&quot;.
</p>
</td></tr>
<tr><td><code id="regSGB_+3A_...">...</code></td>
<td>
<p> not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is advisable to use the formula to specify the model for easy comparison between models. 
Without formula, the <code>d</code> matrix of explanatory variables must contain exactly the variables used in the model, 
whereas with formula other variables can be included as well. 
Variable transformations can be utilized within the formula, see Example 4 below with the indicator <code>I</code> and the log. <br /> 
Constraints on parameters can be introduced, see example 5 and  <code><a href="#topic+EqualityConstr">EqualityConstr</a></code> for more details. <br />
Use <code> weight</code> for pseudo-likelihood estimation. <code> weight</code> is scaled to <code class="reqn">n</code>, the sample size. <br />
A design based covariance matrix of the parameters can be obtained by linearization as the covariance matrix of the <code>scores</code>.
</p>


<h3>Value</h3>

<p>A list of class 'regSGB' with the following components:<br />
The first 13 form the output from <code><a href="alabama.html#topic+auglag">auglag</a></code>.
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of length <code class="reqn">npar</code>. Parameters that optimize the nonlinear objective function, satisfying constraints, if convergence is successful.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the objective function at termination.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>A vector of length 2 denoting the number of times the objective and its gradient were evaluated, respectively.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>An integer code indicating the type of convergence. 0 indicates successful convergence. 
Positive integer codes indicate failure to converge.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A character string giving any additional information on convergence returned by <code><a href="stats.html#topic+optim">optim</a></code>, or NULL.</p>
</td></tr>
<tr><td><code>outer.iteration</code></td>
<td>
<p>Number of outer iterations.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Values of the Lagrangian parameter. This is a vector of the same length as the total number of inequalities and equalities. It must be zero for inactive inequalities; non-negative for active inequalities; and can have any sign for equalities.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Value of augmented penalty parameter for the quadratic term.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>Gradient of the augmented Lagrangian function at convergence. It should be small.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Hessian of the augmented Lagrangian function at convergence. It should be negative definite for maximization.</p>
</td></tr>
<tr><td><code>ineq</code></td>
<td>
<p>Values of inequality constraints at convergence. All of them must be non-negative.</p>
</td></tr>
<tr><td><code>equal</code></td>
<td>
<p>Values of equality constraints at convergence. All of them must be close to zero.</p>
</td></tr>
<tr><td><code>kkt1</code></td>
<td>
<p>A logical variable indicating whether or not the first-order KKT conditions were satisfied (printed 1 if conditions satisfied and 0 otherwise).</p>
</td></tr>
<tr><td><code>kkt2</code></td>
<td>
<p>A logical variable indicating whether or not the second-order KKT conditions were satisfied (printed 1 if conditions satisfied and 0 otherwise).</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p><code class="reqn">n 	\times D</code> matrix, the estimated scale compositions, see <code><a href="#topic+bval">bval</a></code>.</p>
</td></tr>
<tr><td><code>meanA</code></td>
<td>
<p>Aitchison expectation at estimated parameters.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p><code class="reqn">(n 	\times (D-1))</code> matrix, estimated log-ratio transforms.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Observed minus estimated log-ratio transforms.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>matrix <code class="reqn">n \times npar</code>. Each row contains the (unweighted) derivatives of the log-density at a data point w.r.t the parameters.</p>
</td></tr>
<tr><td><code>Rsquare</code></td>
<td>
<p>ratio of total variation of <code>meanA</code> and total variation of compositions <code>u</code>.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>The robust covariance matrix of parameters estimates, see <code><a href="#topic+covest.SGB">covest.SGB</a></code>.</p>
</td></tr>
<tr><td><code>StdErr1</code></td>
<td>
<p>Ordinary asymptotic standard errors of parameters.</p>
</td></tr>
<tr><td><code>StdErr</code></td>
<td>
<p>Robust asymptotic standard errors of parameters.</p>
</td></tr>
<tr><td><code>fixed.par</code></td>
<td>
<p>Indices of the fixed parameters.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>The summary from <code><a href="#topic+covest.SGB">covest.SGB</a></code>.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC criterion.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>log-ratio transformation matrix (same as corresponding input parameter <code>V</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> Arguments for calling <code>regSGB</code>.</p>
</td></tr>
<tr><td><code>Formula</code></td>
<td>
<p>Expression for formula.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Graf, M. (2017). A distribution on the simplex of the Generalized Beta type. <em>In J. A. Martin-Fernandez (Ed.), Proceedings CoDaWork 2017</em>, University of Girona (Spain), 71-90.
</p>
<p>Hijazi, R. H. and R. W. Jernigan (2009). Modelling compositional data using Dirichlet regression models.
<em>Journal of Applied Probability and Statistics</em>, <strong>4</strong> (1), 77-91.
</p>
<p>Kotz, S., N. Balakrishnan, and N. L. Johnson (2000). <em>Continuous Multivariate Distributions</em>, Volume 1, Models and Applications. John Wiley &amp; Sons.
</p>
<p>Madsen, K., H. Nielsen, and O. Tingleff (2004). Optimization With Constraints. <em>Informatics and Mathematical Modelling</em>, Technical University of Denmark.
</p>
<p>Monti, G. S., G. Mateu-Figueras, and V. Pawlowsky-Glahn (2011). Notes on the scaled Dirichlet distribution. In <em>V. Pawlowsky-Glahn and A. Buccianti (Eds.), Compositional data analysis. Theory and applications.</em> Wiley.
</p>
<p>Varadhan, R. (2015). alabama: Constrained Nonlinear Optimization. R package version 2015.3-1.
</p>
<p>Wicker, N., J. Muller, R. K. R. Kalathur, and O. Poch (2008). A maximum likelihood approximation
method for Dirichlet parameter estimation. Computational Statistics &amp; Data Analysis 52 (3), 1315-1322.
</p>
<p>Zeileis, A. and Y. Croissant (2010). Extended model formulas in R: Multiple parts and multiple responses. <em>Journal of Statistical Software</em> <strong>34</strong> (1), 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepSGB">stepSGB</a></code>, for an experimental stepwise descending regression, <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>, for the computation of initial parameters.
This function uses <code><a href="Formula.html#topic+Formula">Formula</a></code>, <code><a href="alabama.html#topic+auglag">auglag</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regression for car segment shares
## ---------------------------------
data(carseg)
## Extract the compositions
uc &lt;- as.matrix(carseg[,(1:5)])

## Extract the explanatory variables
attach(carseg)

## Example 1: without formula
## --------------------------
## Change some variables
dc &lt;- data.frame(l.exp1=log(expend)*PAC,l.exp0=log(expend)*(1-PAC), l.sent=log(sent),
l.FBCF=log(FBCF), l.price=log(price), rates)

## Define the log-ratio transformation matrix
Vc &lt;- matrix(c( 1,0,0,0,
               -1,1,0,0,
               0,-1,1,0,
               0,0,-1,1,
               0,0,0,-1),ncol=4,byrow=TRUE)
colnames(Vc) &lt;- c("AB","BC","CD","DE")
rownames(Vc) &lt;- colnames(uc)
Vc

# 2 next rows  only necessary when calling regSGB without a formula.
dc1 &lt;- cbind("(Intercept)"= 1 , dc)
dc1 &lt;- as.matrix(dc1)   

object10 &lt;- regSGB(dc1,uc, Vc,shape10=4.4)
summary(object10)

## Example 2: same with formula
## ----------------------------
## Define the formula
Form &lt;- Formula(AB | BC | CD | DE ~  l.exp1 + l.exp0 + l.sent + l.FBCF + l.price +  rates)

## Regression with formula
object1 &lt;- regSGB(Form, data= list(dc, uc, Vc),shape10=4.4)

summary(object1)

## Example 3: Usage of I()
## -----------------------
Form2 &lt;- Formula(AB | BC | CD | DE ~  I(l.exp1 + l.exp0) + l.exp1 +l.sent + 
                 l.FBCF + l.price + rates )
object2 &lt;- regSGB(Form2,data= list(dc, uc, Vc),shape10=4.4)
object2

## Example 4: Usage of variable transformations on the original file
## -----------------------------------------------------------------
Form3 &lt;- Formula(AB | BC | CD | DE ~  log(expend) + I(PAC*log(expend)) + log(sent) + log(FBCF) + 
                 log(price) + rates)
object3 &lt;- regSGB(Form3, data=list(carseg, uc, Vc),shape10=4.4)
object3
object2[["par"]]-object3[["par"]]    # same results

## Example 5: Fixing parameter values
## ----------------------------------
## 1. In the following regression we condition on shape1 = 2.36.
object4 &lt;- regSGB(Form3,data=list(carseg, uc, Vc), 
                  shape10 = 4.4,  bound = 2.0, ind = 1, shape1 = 2.36)
summary(object4)

## 2. In the following regression we condition on shape1 = 2.36 and the  coefficient of 
## log(FBCF).BC = 0.  Notice that it is the 19th parameter.
object5 &lt;- regSGB(Form3,data=list(carseg, uc, Vc),
                  shape10 = 4.4, bound = 2.0, ind = c(1,19) , shape1 = 2.36)
summary(object5)

object3[["AIC"]]
object4[["AIC"]]  # largest AIC
object5[["AIC"]]
</code></pre>

<hr>
<h2 id='SGB-package'>
Package SGB
</h2><span id='topic+SGB-package'></span><span id='topic+SGB'></span>

<h3>Description</h3>

<p>Package SGB contains a generalization of the Dirichlet distribution, called the Simplicial Generalized Beta (SGB). It is a new distribution on the simplex (i.e. on the space of compositions or positive vectors with sum of components equal to 1). The Dirichlet distribution can be constructed from a random vector of independent Gamma variables divided by their sum. The SGB follows the same construction with generalized Gamma instead of Gamma variables. The Dirichlet exponents are supplemented by an overall shape parameter and a vector of scales. The scale vector is itself a composition and can be modeled with auxiliary variables through a log-ratio transformation. 
</p>


<h3>Details</h3>


<p>Index of help topics:
</p>
<pre>
B2i                     Balances to isometric log-ratio
EZ.SGB                  Expectations of Z under the SGB distribution
EqualityConstr          Equality constraints for overall shape and/or
                        regression parameters and jacobian
GenGammaDistrib         Generalized Gamma distribution
GoodnessFit             Goodness of fit tests on the marginal
                        distributions of each part in a SGB model
Imputation              Imputation of missing parts in compositions
                        from a SGB model
InequalityConstr        Inequality constraints and jacobian
InitialParameters       Initial parameters estimates and comparison
MarginPlots             Histograms, quantile and probability plots for
                        the z(u)-transforms of parts
SGB-package             Package SGB
SGBLik                  SGB log-likelihood and gradient
SGBdistrib              Density and random generator for the SGB
                        distribution
SGButil                 Computation of scales and z-vectors
Tabulation              Tabulation of overall SGB regression results
                        with AIC and matrix view of regression
                        coefficients
arc                     arc dataset
carseg                  carseg dataset
covest.SGB              Classical and robust asymptotic covariance
                        matrix
ocar                    ocar data set
oilr                    oilr data set
regSGB                  Regression for compositions following a SGB
                        distribution
stepSGB                 Stepwise backward elimination for SGB
                        regression
summaryA.SGB            Aitchison expectation and mode under the SGB
                        distribution
</pre>

<p>Further information is available in the following vignettes:<br /><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>vignette</code> </td><td style="text-align: left;"> SGB multivariate regression (source, pdf)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Monique Graf
</p>
<p>Maintainer: Monique Graf &lt;monique.p.n.graf@bluewin.ch&gt;
</p>


<h3>References</h3>

<p>Graf, M. (2017). A distribution on the simplex of the Generalized Beta type. <em>In J. A. Martin-Fernandez (Ed.), Proceedings CoDaWork 2017</em>, University of Girona (Spain), 71-90.
</p>
<p>Graf, M. (2019). The Simplicial Generalized Beta distribution - R-package SGB and applications. <em>Proceedings of the 8th International Workshop on Compositional Data Analysis (CoDaWork2019): Terrassa, 3-8 June, 2019. J.J. Egozcue, J. Graffelman and M.I. Ortego (Editors). Universitat Politecnica de Catalunya-BarcelonaTECH, 2019. 202 p. ISBN 978-84-947240-2-2. </em>.
</p>
<p>Graf, M. (2020). Regression for compositions based on a generalization of the Dirichlet distribution. <em>Statistical Methods &amp; Applications</em>, (), 1-24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Result of a regression object:
summary(oilr)
</code></pre>

<hr>
<h2 id='SGBdistrib'>
Density and random generator for the SGB distribution
</h2><span id='topic+SGBdistrib'></span><span id='topic+dSGB'></span><span id='topic+rSGB'></span>

<h3>Description</h3>

<p><code>dSGB</code> computes the density for a given argument <code>u</code> (a composition) and given parameters. <br />
<code>rSGB</code> generates <code class="reqn">n</code> compositions for given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dSGB(u, shape1, scale, shape2) 
rSGB(n, shape1, scale, shape2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SGBdistrib_+3A_u">u</code></td>
<td>

<p>vector of length <code class="reqn">D</code> containing the composition
</p>
</td></tr>
<tr><td><code id="SGBdistrib_+3A_shape1">shape1</code></td>
<td>

<p>overall shape parameter. 
shape1 = 1 for a Dirichlet composition.
</p>
</td></tr>
<tr><td><code id="SGBdistrib_+3A_scale">scale</code></td>
<td>

<p>vector of the same length as u containing the scales of parts. 
If missing, scales are set to 1.
</p>
</td></tr>
<tr><td><code id="SGBdistrib_+3A_shape2">shape2</code></td>
<td>

<p>vector of length <code class="reqn">D</code> containing the (Dirichlet) shapes for each part.
</p>
</td></tr>
<tr><td><code id="SGBdistrib_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of columns in <code>u</code> and the number of components in <code>shape2</code> must match. 
</p>


<h3>Value</h3>

<p>dSGB gives the density, rSGB generates a (<code class="reqn">n \times D</code> - matrix with random compositions on each row. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bval">bval</a>, <a href="#topic+zval">zval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   u1 &lt;- c(0.2,0.3,0.5)
   scale1 &lt;- c(0.25,0.33,0.32)
   shape1 &lt;- 1
   shape2 &lt;- c(0.8,3,0.9)
   dSGB(u1,shape1,scale1,shape2)
   rSGB(10,shape1,scale1,shape2)
   

## with equal scales
   dSGB(u1,shape1,shape2=shape2)
   rSGB(10,shape1,shape2=shape2)
 
</code></pre>

<hr>
<h2 id='SGBLik'>
SGB log-likelihood and gradient
</h2><span id='topic+SGBLik'></span><span id='topic+fn.SGB'></span><span id='topic+gr.SGB'></span>

<h3>Description</h3>

<p><code>fn.SGB</code> gives the log-likelihood and <code>gr.SGB</code> the gradient vector of the log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn.SGB(x, d, u, V,  weight, ...)
gr.SGB(x, d, u, V, weight, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SGBLik_+3A_x">x</code></td>
<td>

<p>vector of parameters (<code>shape1</code>, <code>coefi</code>, <code>shape2</code>) where
<code>shape1</code> is the overall shape, <code>coefi</code> is the vector of regression coefficients (see <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>) and <code>shape2</code> the vector of <code class="reqn">D</code> Dirichlet shape parameters.
</p>
</td></tr>
<tr><td><code id="SGBLik_+3A_d">d</code></td>
<td>

<p>data matrix of explanatory variables (without constant vector) <code class="reqn">(n x m)</code>; <code class="reqn">n</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables
</p>
</td></tr>
<tr><td><code id="SGBLik_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(n x D)</code>; <code class="reqn">D</code>: number of parts
</p>
</td></tr>
<tr><td><code id="SGBLik_+3A_v">V</code></td>
<td>

<p>full rank transformation of log(parts) into log-ratios, matrix <code class="reqn">(D x (D-1))</code>
</p>
</td></tr>
<tr><td><code id="SGBLik_+3A_weight">weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>;  positive observation weights, default rep(1,n). Should be scaled to sum to <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="SGBLik_+3A_...">...</code></td>
<td>

<p>others parameters that might be introduced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analytical expression for <code>fn.SGB</code> is found in the vignette &quot;SGB regression&quot;, Section 3.2. More details in Graf(2017).
</p>


<h3>Value</h3>

<p>fn.SGB: value of the log-likelihood at parameter <code>x</code> <br />
gr.SGB: gradient vector at parameter <code>x</code>.
</p>


<h3>References</h3>

<p>Graf, M. (2017). A distribution on the simplex of the Generalized Beta type. <em>In J. A. Martin-Fernandez (Ed.), Proceedings CoDaWork 2017</em>, University of Girona (Spain), 71-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regSGB">regSGB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Explanatory variable
da &lt;- data.frame(l.depth=log(arc[["depth"]]))  
damat &lt;- as.matrix(da)

## Compositions
ua &lt;- as.matrix(arc[,1:3])

## alr transforms
Va &lt;- matrix(c(1,0,-1,0,1,-1),nrow=3)   
colnames(Va) &lt;- c("alr1","alr2")
Va

## Initial values
x &lt;- initpar.SGB(damat,ua,Va)
fn.SGB(x, damat, ua, Va,weight=rep(1,dim(da)[1]))
gr.SGB(x, damat, ua, Va,weight=rep(1,dim(da)[1]))

</code></pre>

<hr>
<h2 id='SGButil'>
Computation of scales and z-vectors
</h2><span id='topic+SGButil'></span><span id='topic+bval'></span><span id='topic+zval'></span>

<h3>Description</h3>

<p>bval computes the scale for each observed composition from the parameters and auxiliary variables for that observation. <br />
zval computes the z-vector for each observed composition, i.e. the transform that is Dirichlet distributed under the  SGB model for the observed composition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bval(D, x, d, V)
zval(u, x, d, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SGButil_+3A_d">D</code></td>
<td>
 
<p>number of parts
</p>
</td></tr>
<tr><td><code id="SGButil_+3A_x">x</code></td>
<td>

<p>vector of parameters (<code>shape1</code>,<code>coefi</code>,<code>shape2</code>) where
<code>shape1</code> is the overall shape, <code>coefi</code> is the vector of regression coefficients (see <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>) and <code>shape2</code> the vector of <code class="reqn">D</code> Dirichlet shape parameters
</p>
</td></tr>
<tr><td><code id="SGButil_+3A_d">d</code></td>
<td>
 
<p><code class="reqn">(n \times m)</code> - data matrix of explanatory variables (variables corresponding to <code>coefi</code>); <code class="reqn">n</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables
</p>
</td></tr>
<tr><td><code id="SGButil_+3A_u">u</code></td>
<td>

<p><code class="reqn">(n \times D)</code> - data matrix of compositions (independent variables); <code class="reqn">D</code>: number of parts
</p>
</td></tr>
<tr><td><code id="SGButil_+3A_v">V</code></td>
<td>
 
<p><code class="reqn">D \times (D-1)</code> - matrix specifying the full rank transformation of log(parts) into log-ratios
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Graf (2017), Equation (8), or the vignette &quot;SGB regression&quot;, Equation (1).
</p>


<h3>Value</h3>

<p> transformed composition of length <code class="reqn">D</code>.
</p>


<h3>References</h3>

<p>Graf, M. (2017). A distribution on the simplex of the Generalized Beta type. <em>In J. A. Martin-Fernandez (Ed.), Proceedings CoDaWork 2017</em>, University of Girona (Spain), 71-90.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example with 2 compositions
u &lt;- matrix(c(0.2,0.4,0.5,0.5,0.3,0.2),nrow=2,byrow=TRUE)
u
D &lt;- NCOL(u)  # number of parts

## auxiliary variable
d &lt;- matrix(c(3.2,4.6),ncol=1)

## log-ratio transformation
V &lt;- matrix(c(c(1,-1,0)/sqrt(2),c(1,1,-2)/sqrt(6)),ncol=2)

## vector of parameters:
shape1 &lt;- 2.00
coefi &lt;- c(-0.78,  0.06,  0.96, -0.11)
shape2 &lt;- c(1.80,  3.10,  4.00) 
x &lt;-c(shape1, coefi, shape2)
bval(D,x,d,V)
zval(u,x,d,V)
</code></pre>

<hr>
<h2 id='stepSGB'>
Stepwise backward elimination for SGB regression
</h2><span id='topic+stepSGB'></span><span id='topic+stepSGB.default'></span>

<h3>Description</h3>

<p>Stepwise elimination of the non significant regression parameters. Possibility to assign a fixed value   <code> shape1</code> to the overall shape parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepSGB(obj0, d, u,  weight = rep(1, dim(d)[1]), shape10 = obj0[["par"]][1],
  bound = 2.1, shape1 = NULL, Mean2 = TRUE, maxiter = 10, 
  control.optim = list(fnscale = -1), 
  control.outer = list(itmax = 1000, ilack.max = 200, trace = TRUE,
   kkt2.check = TRUE, method = "BFGS") )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepSGB_+3A_obj0">obj0</code></td>
<td>

<p>object of class regSGB, see <code><a href="#topic+regSGB">regSGB</a></code>.
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_d">d</code></td>
<td>

<p>data matrix of explanatory variables (without constant vector) <code class="reqn">(n \times m)</code>; <code class="reqn">n</code>: sample size, 
<code class="reqn">m</code>: number of auxiliary variables.
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_u">u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(n \times D)</code>; <code class="reqn">D</code>: number of parts.
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_weight">weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>; positive observation weights, default <code>rep(1,n)</code>. Should be scaled to sum to  <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_shape10">shape10</code></td>
<td>

<p>positive number, initial value of the overall shape parameter, 
default obj0[[&quot;par&quot;]][1].
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_bound">bound</code></td>
<td>

<p>inequality constraints on the estimates of shapes:<br />
<code>shape1*shape2[i] &gt; bound, i=1,...,D.</code> <br />
By default <code>bound = 2.1</code>, see <code><a href="#topic+InequalityConstr">InequalityConstr</a></code>. 
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_shape1">shape1</code></td>
<td>

<p>fixed value of the overall shape parameter. Default is NULL (no fixed value).
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_mean2">Mean2</code></td>
<td>

<p>logical, if TRUE (default), the initial shape2 parameters are each replaced by their average. See <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>.
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_maxiter">maxiter</code></td>
<td>

<p>maximum number of iterations, i.e. attempts to set a parameter to 0.
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_control.optim">control.optim</code></td>
<td>

<p>list of control parameters for optim, see <code><a href="stats.html#topic+optim">optim</a></code>. Default is from <code>auglag</code>, except <code>list(fnscale = -1)</code>. Always specify <code>fnscale = -1</code>.
</p>
</td></tr>
<tr><td><code id="stepSGB_+3A_control.outer">control.outer</code></td>
<td>

<p>list of control parameters to be used by the outer loop in constrOptim.nl, see <code><a href="alabama.html#topic+auglag">auglag</a></code>. 
Default is from <code>auglag</code>, except <code>list(itmax = 1000, ilack.max = 200)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an experimental procedure for searching a set of non-significant parameters that will be set to zero. The shape parameters are excluded from the elimination procedure. The algorithm starts with <code>obj0</code>, output of regSGB.  The p-values for the regression parameters in <code>summary(obj0)</code> are taken in decreasing order. The parameter with the largest p-value is set to zero and <code>regSGB</code> computes the regression with this constraint. If the AIC value is smaller than the AIC in <code>obj0</code>, the parameter with the next largest p-value in <code>obj0</code> is set to zero and the regression with the two constraints is computed. The process iterates until either a larger AIC is found or <code>maxiter</code> is attained.<br />
The initial value of the overall shape parameter is set to the estimated value in the full model <code>obj0</code>. The other initial values are computed as in <code><a href="#topic+regSGB">regSGB</a></code>. <br />
There is the possibility to fix the value of the overvall shape parameter, if <code>shape1</code> is given a positive number <code class="reqn">a_0</code> (default NULL, no fixed value). <br />
If <code>regSGB</code> was called without <code>Formula</code>, the data-frame with auxiliary variables for <code>stepSGB</code> follows the same rules as for the initial regSGB object, see Example 1 in <code><a href="#topic+regSGB">regSGB</a></code>.
</p>


<h3>Value</h3>

<p>A list of class 'stepSGB' with the following 5 components:<br />
</p>
<table>
<tr><td><code>reg</code></td>
<td>
<p>A list with the following components: <br />
<code>full</code> Object of class regSGB, same as <code>obj0</code>, see <code><a href="#topic+regSGB">regSGB</a></code>. <br />
<code>iter1</code> Object of class regSGB obtained at iteration 1. <br />
... <br />
<code>iterk</code> Object of class regSGB obtained at iteration k.
</p>
</td></tr> </table>
<p><br />
</p>
<table>
<tr><td><code>Formula</code></td>
<td>
<p>The original formula, or NULL</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Value of k, the last iteration.</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>Data frame with <code>k+1</code> columns, overall results and <code>k</code>  iterations. The rows are <br />
<code>value</code> Log-likelihood <br />
<code>n.par</code> Total number of parameters (including the shape2 param.) <br />
<code>n.par.fixed</code> Number of fixed parameters. <br />
<code>AIC</code> Value of the AIC criterion. <br />
<code>convergence</code> 0 if converged. <br />
<code>kkt1</code> 1 if first Karush-Kuhn-Tucker criterion fulfilled, zero otherwise. <br />
<code>kkt2</code> 1 if second Karush-Kuhn-Tucker criterion fulfilled, zero otherwise. <br /> 
<code>counts.function</code> Number of times the objective function (the log-likelihood) was evaluated. <br />
<code>counts.gradient</code> Number of times  the gradient was evaluated. \
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Arguments for calling <code>stepSGB</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="../doc/vignette.pdf"><code>vignette("SGB regression", package = "SGB")</code></a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regSGB">regSGB</a></code>, <code><a href="#topic+initpar.SGB">initpar.SGB</a></code>, <code><a href="alabama.html#topic+auglag">auglag</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carseg)
## Extract the compositions
uc &lt;- as.matrix(carseg[,(1:5)])
## Initial regression
data(ocar)

step_ocar &lt;- stepSGB(ocar, carseg, uc, bound=2.1, control.outer=list(trace=FALSE))

summary(step_ocar[["reg"]][["full"]])
summary(step_ocar[["reg"]][["iter4"]])
step_ocar[["tab"]]

</code></pre>

<hr>
<h2 id='summaryA.SGB'>
Aitchison expectation and mode under the SGB distribution
</h2><span id='topic+summaryA.SGB'></span><span id='topic+MeanA.SGB'></span><span id='topic+ModeA.SGB'></span><span id='topic+MeanAobj.SGB'></span><span id='topic+ModeAobj.SGB'></span>

<h3>Description</h3>

<p>The expectation and mode in the log-ratio space, transformed back to the simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanA.SGB(shape1, scale, shape2)
ModeA.SGB(shape1, scale, shape2)
MeanAobj.SGB(obj)
ModeAobj.SGB(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryA.SGB_+3A_shape1">shape1</code></td>
<td>

<p>overall shape parameter. <code>shape1</code> = 1 for a Dirichlet composition.
</p>
</td></tr>
<tr><td><code id="summaryA.SGB_+3A_scale">scale</code></td>
<td>

<p>vector of length <code class="reqn">D</code> or matrix with <code class="reqn">D</code> columns containing the scales of parts. 
</p>
</td></tr>
<tr><td><code id="summaryA.SGB_+3A_shape2">shape2</code></td>
<td>

<p>vector of length <code class="reqn">D</code> containing the (Dirichlet) shapes for each part.
</p>
</td></tr>
<tr><td><code id="summaryA.SGB_+3A_obj">obj</code></td>
<td>

<p>list, result of regSGB. See <code><a href="#topic+regSGB">regSGB</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MeanA</code>, <code>ModeA</code> compute Aitchison expectation and mode in function of the SGB distribution parameters, whereas <code>MeanAobj</code>, <code>ModeAobj</code> compute Aitchison expectation and mode in function of the model variables in an SGB regression object.
</p>


<h3>Value</h3>

<p>A matrix or vector of  dimensions <code class="reqn">(n \times D)</code>. 
Each row gives the Aitchison expectation for compositions having the corresponding set of auxiliary variables.
</p>


<h3>References</h3>

<p>Aitchison, J. (1986). <em>The Statistical Analysis of Compositional Data</em>. Monographs on Statistics and Applied Probability. Chapman and Hall Ltd (reprinted 2003 with additional material by the Blackburn Press, London (UK).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oilr">oilr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   set.seed(1234)
   x &lt;- c(2,rnorm(4,0,1),1.8,3.1,4.0)
   d &lt;- c(3.2,4.6)
   V &lt;- t(matrix(c(1/sqrt(2),-1/sqrt(2),0,
                 1/sqrt(6),1/sqrt(6),-2/sqrt(6)),
                 nrow=2,byrow=TRUE))
   D &lt;- 3
   shape1 &lt;- x[1]
   scale &lt;- bval(D,x,d,V)
   shape2 &lt;- x[(length(x)-D+1):length(x)]
# Expectation
   MeanA.SGB(shape1,scale,shape2)
# Mode
   ModeA.SGB(shape1, scale, shape2)

## Arctic lake data
# oilr is a SGB regression object
data(oilr) 
MeanAobj.SGB(oilr)   # is the same as oilr[["meanA"]]
ModeAobj.SGB(oilr)
</code></pre>

<hr>
<h2 id='Tabulation'>
Tabulation of overall SGB regression results with AIC and matrix view of regression coefficients
</h2><span id='topic+Tabulation'></span><span id='topic+table.regSGB'></span><span id='topic+coefmat'></span>

<h3>Description</h3>

<p>table.regSGB: Value of the log-likelihood, number of parameters, AIC criterion, optimality tests and iterations counts. <br />
coefmat: regression coefficients in matrix form with significance level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.regSGB(object)
coefmat(object,digits=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tabulation_+3A_object">object</code></td>
<td>

<p>an object of class regSGB
</p>
</td></tr>
<tr><td><code id="Tabulation_+3A_digits">digits</code></td>
<td>

<p>number of decimal places for the coefficients
</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p><code>table.regSGB</code>: Data frame with one column, with the overall statistics results. <br />
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>the maximum log-likelihood</p>
</td></tr>
<tr><td><code>n.par</code></td>
<td>
<p>the number of parameters</p>
</td></tr>
<tr><td><code>n.par.fixed</code></td>
<td>
<p>the number of fixed parameters</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the AIC criterion</p>
</td></tr>
<tr><td><code>Rsquare</code></td>
<td>
<p>total variance of estimated over total variance of observed compositions</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>the convergence code (0: converged, others, see <code><a href="alabama.html#topic+auglag">auglag</a></code>).</p>
</td></tr>
<tr><td><code>kkt1</code></td>
<td>
<p>the first Karush-Kuhn-Tucker conditions (1=TRUE, 0=FALSE), see <code><a href="alabama.html#topic+auglag">auglag</a></code>.</p>
</td></tr>
<tr><td><code>kkt2</code></td>
<td>
<p>the second Karush-Kuhn-Tucker conditions (1=TRUE, 0=FALSE), see <code><a href="alabama.html#topic+auglag">auglag</a></code>.</p>
</td></tr>
<tr><td><code>counts.function</code></td>
<td>
<p>number of times the log-likelihood was evaluated.</p>
</td></tr>
<tr><td><code>counts.gradient</code></td>
<td>
<p>number of times the gradient was evaluated.</p>
</td></tr> </table>
<p><br />
</p>
<p><code>coefmat</code>: character matrix with the regression coefficients arranged in columns, one for each log-ratio transform. Each ceofficient is followed by the significance level. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regSGB">regSGB</a></code>, <code><a href="#topic+oilr">oilr</a></code>, <code><a href="alabama.html#topic+auglag">auglag</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overall model statistics
table.regSGB(oilr)
## 
print(coefmat(oilr),quote=FALSE)
## it is a subset of
summary(oilr)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
