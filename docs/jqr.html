<!DOCTYPE html><html><head><title>Help for package jqr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jqr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jqr'><p>jqr</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#at'><p>Format strings and escaping</p></a></li>
<li><a href='#build'><p>Build arrays and objects</p></a></li>
<li><a href='#combine'><p>Combine json pieces</p></a></li>
<li><a href='#commits'><p>GitHub Commits Data</p></a></li>
<li><a href='#dot'><p>dot and related functions</p></a></li>
<li><a href='#funs'><p>Define and use functions</p></a></li>
<li><a href='#index'><p>index and related functions</p></a></li>
<li><a href='#jq'><p>Execute a query with jq</p></a></li>
<li><a href='#jq_flags'><p>Flags for use with jq</p></a></li>
<li><a href='#jqr_new'><p>JQ Streaming API</p></a></li>
<li><a href='#keys'><p>Operations on keys, or by keys</p></a></li>
<li><a href='#logicaltests'><p>Logical tests</p></a></li>
<li><a href='#manip'><p>Manipulation operations</p></a></li>
<li><a href='#maths'><p>Math operations</p></a></li>
<li><a href='#paths'><p>Outputs paths to all the elements in its input</p></a></li>
<li><a href='#peek'><p>Peek at a query</p></a></li>
<li><a href='#rangej'><p>Produce range of numbers</p></a></li>
<li><a href='#recurse'><p>Search through a recursive structure - extract data from all levels</p></a></li>
<li><a href='#select'><p>Select - filtering</p></a></li>
<li><a href='#sortj'><p>Sort and related</p></a></li>
<li><a href='#string'><p>Give back a character string</p></a></li>
<li><a href='#types'><p>Types and related functions</p></a></li>
<li><a href='#vars'><p>Variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Client for 'jq', a 'JSON' Processor</td>
</tr>
<tr>
<td>Description:</td>
<td>Client for 'jq', a 'JSON' processor (<a href="https://jqlang.github.io/jq/">https://jqlang.github.io/jq/</a>), 
    written in C. 'jq' allows the following with 'JSON' data: index into, parse, 
    do calculations, cut up and filter, change key names and values, perform 
    conditionals and comparisons, and more.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/jqr/">https://docs.ropensci.org/jqr/</a> (docs),
<a href="https://github.com/ropensci/jqr">https://github.com/ropensci/jqr</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/jqr/issues">https://github.com/ropensci/jqr/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libjq: jq-devel (rpm) or libjq-dev (deb)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, lazyeval</td>
</tr>
<tr>
<td>Suggests:</td>
<td>jsonlite, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 12:28:20 UTC; jeroen</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut],
  Jeroen Ooms [aut, cre],
  Scott Chamberlain [aut],
  Stefan Milton Bache [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeroen Ooms &lt;jeroen@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='jqr'>jqr</h2><span id='topic+jqr'></span><span id='topic+jqr-package'></span>

<h3>Description</h3>

<p>An R client for the C library jq
</p>


<h3>Low-level</h3>

<p>Low level interface, in which you can execute 'jq' code just as you
would on the command line. Available via <code><a href="#topic+jq">jq</a></code>
</p>


<h3>High-level DSL</h3>

<p>High-level, uses a suite of functions to construct queries. Queries
are constucted, then excuted internally with <code><a href="#topic+jq">jq</a></code>
</p>


<h3>Pipes</h3>

<p>The high level DSL supports piping, though you don't have to use
pipes.
</p>


<h3>NSE and SE</h3>

<p>Most DSL functions have NSE (non-standard evaluation) and SE
(standard evaluation) versions, which make <code>jqr</code> easy to use
for interactive use as well as programming.
</p>


<h3>jq version</h3>

<p>We link to <code>jq</code> through the installed version on your system,
so the version can vary. Run <code>jq --version</code> to get your jq version
</p>


<h3>indexing</h3>

<p>note that <code>jq</code> indexing starts at <code>0</code>, whereas R indexing
starts at <code>1</code>. So when you want the first thing in an array using
<code>jq</code>, for example, you want <code>0</code>, not <code>1</code>
</p>


<h3>output data format</h3>

<p>Note that with both the low level interface and the high level DSL, we
print the output to look like a valid JSON object to make it easier to
look at. However, it's important to know that the output is really just a
simple character string or vector of strings - it's just the print function
that pretty prints it and makes it look like a single JSON object. What jq
is giving you often is a stream of valid JSON objects, each one of which is
valid, but altogether are not valid. However, a trick you can do is to
wrap your jq program in brackets like <code>[.[]]</code> instead of <code>.[]</code>
to give a single JSON object
</p>
<p>Related to above, you can use the function provided <code><a href="#topic+string">string</a></code>
with the high level DSL to get back a character string instead of
pretty printed version
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='at'>Format strings and escaping</h2><span id='topic+at'></span><span id='topic+at_'></span>

<h3>Description</h3>

<p>Format strings and escaping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at(.data, ...)

at_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="at_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="at_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="at_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{"user":"jqlang","titles":["JQ Primer", "More JQ"]}'
x %&gt;% at(base64) %&gt;% peek
x %&gt;% at(base64)
x %&gt;% index() %&gt;% at(base64)

y &lt;- '["fo", "foo", "barfoo", "foobar", "barfoob"]'
y %&gt;% index() %&gt;% at(base64)

## prepare for shell use
y %&gt;% index() %&gt;% at(sh)

## rendered as csv with double quotes
z &lt;- '[1, 2, 3, "a"]'
z %&gt;% at(csv)

## rendered as csv with double quotes
z %&gt;% index()
z %&gt;% index() %&gt;% at(text)

## % encode for URI's
#### DOESNT WORK --------------------------

## html escape
#### DOESNT WORK --------------------------

## serialize to json
#### DOESNT WORK --------------------------
</code></pre>

<hr>
<h2 id='build'>Build arrays and objects</h2><span id='topic+build'></span><span id='topic+build_array'></span><span id='topic+build_array_'></span><span id='topic+build_object'></span><span id='topic+build_object_'></span>

<h3>Description</h3>

<p>Build arrays and objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_array(.data, ...)

build_array_(.data, ..., .dots)

build_object(.data, ...)

build_object_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="build_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="build_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="build_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## BUILD ARRAYS
x &lt;- '{"user":"jqlang", "projects": ["jq", "wikiflow"]}' 
jq(x, "[.user, .projects[]]")
x %&gt;% build_array(.user, .projects[])

jq('[1, 2, 3]', '[ .[] | . * 2]')
'[1, 2, 3]' %&gt;% build_array(.[] | . * 2)


## BUILD OBJECTS
'{"foo": 5, "bar": 7}' %&gt;% build_object(a = .foo) %&gt;% peek
'{"foo": 5, "bar": 7}' %&gt;% build_object(a = .foo)

# using json dataset, just first element
x &lt;- commits %&gt;% index(0)
x %&gt;%
   build_object(message = .commit.message, name = .commit.committer.name)
x %&gt;% build_object(sha = .commit.tree.sha, author = .author.login)

# using json dataset, all elements
x &lt;- index(commits)
x %&gt;% build_object(message = .commit.message, name = .commit.committer.name)
x %&gt;% build_object(sha = .sha, name = .commit.committer.name)

# many JSON inputs
'{"foo": 5, "bar": 7} {"foo": 50, "bar": 7} {"foo": 500, "bar": 7}' %&gt;%
  build_object(hello = .foo)
</code></pre>

<hr>
<h2 id='combine'>Combine json pieces</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>Combine json pieces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_x">x</code></td>
<td>
<p>Input, of class json</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{"foo": 5, "bar": 7}' %&gt;% select(a = .foo)
combine(x)

(x &lt;- commits %&gt;% index() %&gt;%
 select(sha = .sha, name = .commit.committer.name))
combine(x)
</code></pre>

<hr>
<h2 id='commits'>GitHub Commits Data</h2><span id='topic+commits'></span>

<h3>Description</h3>

<p>GitHub Commits Data
</p>


<h3>Format</h3>

<p>A character string of json github commits data for the jq repo.
</p>

<hr>
<h2 id='dot'>dot and related functions</h2><span id='topic+dot'></span><span id='topic+dot_'></span><span id='topic+dotstr'></span><span id='topic+dotstr_'></span>

<h3>Description</h3>

<p>dot and related functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dot(.data)

dot_(.data, dots = ".")

dotstr(.data, ...)

dotstr_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dot_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="dot_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
<tr><td><code id="dot_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="dot_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>str &lt;- '[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]'
str %&gt;% dot
str %&gt;% index %&gt;% dotstr(name)
'{"foo": 5, "bar": 8}' %&gt;% dot
'{"foo": 5, "bar": 8}' %&gt;% dotstr(foo)
'{"foo": {"bar": 8}}' %&gt;% dotstr(foo.bar)
</code></pre>

<hr>
<h2 id='funs'>Define and use functions</h2><span id='topic+funs'></span>

<h3>Description</h3>

<p>Define and use functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funs(.data, fxn, action)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs_+3A_.data">.data</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="funs_+3A_fxn">fxn</code></td>
<td>
<p>A function definition, without <code>def</code> (added internally)</p>
</td></tr>
<tr><td><code id="funs_+3A_action">action</code></td>
<td>
<p>What to do with the function on the data</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>jq("[1,2,10,20]", 'def increment: . + 1; map(increment)')
"[1,2,10,20]" %&gt;% funs('increment: . + 1', 'map(increment)')
"[1,2,10,20]" %&gt;% funs('increment: . / 100', 'map(increment)')
"[1,2,10,20]" %&gt;% funs('increment: . / 100', 'map(increment)')
'[[1,2],[10,20]]' %&gt;% funs('addvalue(f): f as $x | map(. + $x)', 'addvalue(.[0])')
"[1,2]" %&gt;% funs('f(a;b;c;d;e;f): [a+1,b,c,d,e,f]', 'f(.[0];.[1];.[0];.[0];.[0];.[0])')
"[1,2,3,4]" %&gt;% funs('fac: if . == 1 then 1 else . * (. - 1 | fac) end', '[.[] | fac]')
</code></pre>

<hr>
<h2 id='index'>index and related functions</h2><span id='topic+index'></span><span id='topic+index_'></span><span id='topic+indexif'></span><span id='topic+indexif_'></span><span id='topic+dotindex'></span><span id='topic+dotindex_'></span>

<h3>Description</h3>

<p>index and related functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index(.data, ...)

index_(.data, ..., .dots)

indexif(.data, ...)

indexif_(.data, ..., .dots)

dotindex(.data, ...)

dotindex_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="index_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="index_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="index_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>index</code>/<code>index_</code> - queries like: <code>.[]</code>, <code>.[0]</code>,
<code>.[1:5]</code>,
<code>.["foo"]</code>
</p>
</li>
<li> <p><code>indexif</code>/<code>indexif_</code> - queries like: <code>.["foo"]?</code>
</p>
</li>
<li> <p><code>dotindex</code>/<code>dotindex_</code> - queries like: <code>.[].foo</code>,
<code>.[].foo.bar</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>str &lt;- '[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]'
str %&gt;% index
'{"name":"JSON", "good":true}' %&gt;% indexif(name)
'{"name":"JSON", "good":true}' %&gt;% indexif(good)
'{"name":"JSON", "good":true}' %&gt;% indexif(that)
'{"a": 1, "b": 1}' %&gt;% index
'[]' %&gt;% index
'[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]' %&gt;% index(0)
'["a","b","c","d","e"]' %&gt;% index(2)
'["a","b","c","d","e"]' %&gt;% index('2:4')
'["a","b","c","d","e"]' %&gt;% index('2:5')
'["a","b","c","d","e"]' %&gt;% index(':3')
'["a","b","c","d","e"]' %&gt;% index('-2:')

str %&gt;% index %&gt;% select(bad = .name)

'[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]' %&gt;%
  dotindex(name)
'[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]' %&gt;%
  dotindex(good)
'[{"name":"JSON", "good":{"foo":5}}, {"name":"XML", "good":{"foo":6}}]' %&gt;%
  dotindex(good)
'[{"name":"JSON", "good":{"foo":5}}, {"name":"XML", "good":{"foo":6}}]' %&gt;%
  dotindex(good.foo)
</code></pre>

<hr>
<h2 id='jq'>Execute a query with jq</h2><span id='topic+jq'></span><span id='topic+jq.jqr'></span><span id='topic+jq.character'></span><span id='topic+jq.json'></span><span id='topic+jq.connection'></span>

<h3>Description</h3>

<p><code>jq</code> is meant to work with the high level interface in this package.
<code>jq</code> also provides access to the low level interface in which you can
use jq query strings just as you would on the command line. Output gets
class of json, and pretty prints to the console for easier viewing.
<code>jqr</code> doesn't do pretty printing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jq(x, ...)

## S3 method for class 'jqr'
jq(x, ...)

## S3 method for class 'character'
jq(x, ..., flags = jq_flags())

## S3 method for class 'json'
jq(x, ..., flags = jq_flags())

## S3 method for class 'connection'
jq(x, ..., flags = jq_flags(), out = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jq_+3A_x">x</code></td>
<td>
<p><code>json</code> object or character string with json data. this can
be one or more valid json objects</p>
</td></tr>
<tr><td><code id="jq_+3A_...">...</code></td>
<td>
<p>character specification of jq query. Each element in <code>...</code>
will be combined with &quot; | &quot;, which is convenient for long queries.</p>
</td></tr>
<tr><td><code id="jq_+3A_flags">flags</code></td>
<td>
<p>See <code><a href="#topic+jq_flags">jq_flags</a></code></p>
</td></tr>
<tr><td><code id="jq_+3A_out">out</code></td>
<td>
<p>a filename, callback function, connection object to stream output.
Set to 'NULL' to buffer all output and return a character vector.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+peek">peek</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>'{"a": 7}' %&gt;%  do(.a + 1)
'[8,3,null,6]' %&gt;% sortj

x &lt;- '[{"message": "hello", "name": "jenn"},
  {"message": "world", "name": "beth"}]'
jq(index(x))

jq('{"a": 7, "b": 4}', 'keys')
jq('[8,3,null,6]', 'sort')

# many json inputs
jq(c("[123, 456]", "[77, 88, 99]", "[41]"), ".[]")
# Stream from connection
tmp &lt;- tempfile()
writeLines(c("[123, 456]", "[77, 88, 99]", "[41]"), tmp)
jq(file(tmp), ".[]")

## Not run: 
# from a url
x &lt;- 'http://jeroen.github.io/data/diamonds.json'
jq(url(x), ".[]")

# from a file
file &lt;- file.path(tempdir(), "diamonds_nd.json")
download.file(x, destfile = file)
jq(file(file), ".carat")
jq(file(file), "select(.carat &gt; 1.5)")
jq(file(file), 'select(.carat &gt; 4 and .cut == "Fair")')

## End(Not run)
</code></pre>

<hr>
<h2 id='jq_flags'>Flags for use with jq</h2><span id='topic+jq_flags'></span><span id='topic+flags'></span>

<h3>Description</h3>

<p>The <code>flags</code> function is provided for the high-level DSL
approach, whereas the <code>jq_flags</code> function is used to provide
the low-level <code>jq</code> with the appropriate flags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jq_flags(
  pretty = FALSE,
  ascii = FALSE,
  color = FALSE,
  sorted = FALSE,
  stream = FALSE,
  seq = FALSE
)

flags(
  .data,
  pretty = FALSE,
  ascii = FALSE,
  color = FALSE,
  sorted = FALSE,
  stream = FALSE,
  seq = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jq_flags_+3A_pretty">pretty</code></td>
<td>
<p>Pretty print the json (different to jsonlite's
pretty printing).</p>
</td></tr>
<tr><td><code id="jq_flags_+3A_ascii">ascii</code></td>
<td>
<p>Force jq to produce pure ASCII output with non-ASCII
characters replaced by equivalent escape sequences.</p>
</td></tr>
<tr><td><code id="jq_flags_+3A_color">color</code></td>
<td>
<p>Add ANSI escape sequences for coloured output</p>
</td></tr>
<tr><td><code id="jq_flags_+3A_sorted">sorted</code></td>
<td>
<p>Output fields of each object with keys in sorted order</p>
</td></tr>
<tr><td><code id="jq_flags_+3A_stream">stream</code></td>
<td>
<p>Parse the input in streaming fashion, outputing arrays
of path and leaf values like <code>jq --stream</code> command line.</p>
</td></tr>
<tr><td><code id="jq_flags_+3A_seq">seq</code></td>
<td>
<p>Use the application/json-seq MIME type scheme for separating
JSON like the <code>jq --seq</code> command line.</p>
</td></tr>
<tr><td><code id="jq_flags_+3A_.data">.data</code></td>
<td>
<p>A <code>jqr</code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>'{"a": 7, "z":0, "b": 4}' %&gt;% flags(sorted = TRUE)
'{"a": 7, "z":0, "b": 4}' %&gt;% dot %&gt;% flags(sorted = TRUE)
jq('{"a": 7, "z":0, "b": 4}', ".") %&gt;% flags(sorted = TRUE)
jq('{"a": 7, "z":0, "b": 4}', ".", flags = jq_flags(sorted = TRUE))
</code></pre>

<hr>
<h2 id='jqr_new'>JQ Streaming API</h2><span id='topic+jqr_new'></span><span id='topic+jqr_feed'></span>

<h3>Description</h3>

<p>Low level JQ API. First create a program using a 'query' and 'flags' and then
feed pieces of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jqr_new(query, flags = jq_flags())

jqr_feed(jqr_program, json, unlist = TRUE, finalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jqr_new_+3A_query">query</code></td>
<td>
<p>string with a valid jq program</p>
</td></tr>
<tr><td><code id="jqr_new_+3A_flags">flags</code></td>
<td>
<p>See <code><a href="#topic+jq_flags">jq_flags</a></code></p>
</td></tr>
<tr><td><code id="jqr_new_+3A_jqr_program">jqr_program</code></td>
<td>
<p>object returned by [jqr_new]</p>
</td></tr>
<tr><td><code id="jqr_new_+3A_json">json</code></td>
<td>
<p>character vector with json data. If the JSON object is incomplete, you
must set 'finalize' to 'FALSE' otherwise you get an error.</p>
</td></tr>
<tr><td><code id="jqr_new_+3A_unlist">unlist</code></td>
<td>
<p>if 'TRUE' returns a single character vector with all output for each
each string in 'json' input</p>
</td></tr>
<tr><td><code id="jqr_new_+3A_finalize">finalize</code></td>
<td>
<p>completes the parsing and verifies that the JSON string is valid. Set
this to 'TRUE' when feeding the final piece of data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>program &lt;- jqr_new(".[]")
jqr_feed(program, c("[123, 456]", "[77, 88, 99]"))
jqr_feed(program, c("[41, 234]"))
jqr_feed(program, "", finalize = TRUE)
</code></pre>

<hr>
<h2 id='keys'>Operations on keys, or by keys</h2><span id='topic+keys'></span><span id='topic+del'></span><span id='topic+del_'></span><span id='topic+haskey'></span><span id='topic+haskey_'></span>

<h3>Description</h3>

<p><code>keys</code> takes no input, and retrieves keys. <code>del</code> deletes
provided keys. <code>haskey</code> checks if a json string has a key, or the
input array has an element at the given index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keys(.data)

del(.data, ...)

del_(.data, ..., .dots)

haskey(.data, ...)

haskey_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keys_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="keys_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="keys_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="keys_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># get keys
str &lt;- '{"foo": 5, "bar": 7}'
jq(str, "keys")
str %&gt;% keys()

# delete by key name
jq(str, "del(.bar)")
str %&gt;% del(bar)

# check for key existence
str3 &lt;- '[[0,1], ["a","b","c"]]'
jq(str3, "map(has(2))")
str3 %&gt;% haskey(2)
jq(str3, "map(has(1,2))")
str3 %&gt;% haskey(1,2)

## many JSON inputs
'{"foo": 5, "bar": 7} {"hello": 5, "world": 7}' %&gt;% keys
'{"foo": 5, "bar": 7} {"hello": 5, "bar": 7}' %&gt;% del(bar)
</code></pre>

<hr>
<h2 id='logicaltests'>Logical tests</h2><span id='topic+logicaltests'></span><span id='topic+allj'></span><span id='topic+anyj'></span>

<h3>Description</h3>

<p>Logical tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allj(.data)

anyj(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logicaltests_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># any
'[true, false]' %&gt;% anyj
'[false, false]' %&gt;% anyj
'[]' %&gt;% anyj

# all
'[true, false]' %&gt;% allj
'[true, true]' %&gt;% allj
'[]' %&gt;% allj

## many JSON inputs
'[true, false] [true, true] [false, false]' %&gt;% anyj
'[true, false] [true, true] [false, false]' %&gt;% allj
</code></pre>

<hr>
<h2 id='manip'>Manipulation operations</h2><span id='topic+manip'></span><span id='topic+join'></span><span id='topic+join_'></span><span id='topic+splitj'></span><span id='topic+splitj_'></span><span id='topic+ltrimstr'></span><span id='topic+ltrimstr_'></span><span id='topic+rtrimstr'></span><span id='topic+rtrimstr_'></span><span id='topic+startswith'></span><span id='topic+startswith_'></span><span id='topic+endswith'></span><span id='topic+endswith_'></span><span id='topic+index_loc'></span><span id='topic+index_loc_'></span><span id='topic+rindex_loc'></span><span id='topic+rindex_loc_'></span><span id='topic+indices'></span><span id='topic+indices_'></span><span id='topic+tojson'></span><span id='topic+fromjson'></span><span id='topic+tostring'></span><span id='topic+tonumber'></span><span id='topic+contains'></span><span id='topic+contains_'></span><span id='topic+uniquej'></span><span id='topic+uniquej_'></span><span id='topic+group'></span><span id='topic+group_'></span>

<h3>Description</h3>

<p>Manipulation operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(.data, ...)

join_(.data, ..., .dots)

splitj(.data, ...)

splitj_(.data, ..., .dots)

ltrimstr(.data, ...)

ltrimstr_(.data, ..., .dots)

rtrimstr(.data, ...)

rtrimstr_(.data, ..., .dots)

startswith(.data, ...)

startswith_(.data, ..., .dots)

endswith(.data, ...)

endswith_(.data, ..., .dots)

index_loc(.data, ...)

index_loc_(.data, ..., .dots)

rindex_loc(.data, ...)

rindex_loc_(.data, ..., .dots)

indices(.data, ...)

indices_(.data, ..., .dots)

tojson(.data)

fromjson(.data)

tostring(.data)

tonumber(.data)

contains(.data, ...)

contains_(.data, ..., .dots)

uniquej(.data, ...)

uniquej_(.data, ..., .dots)

group(.data, ...)

group_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manip_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="manip_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="manip_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="manip_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="magrittr.html#topic+add">add</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># join
str &lt;- '["a","b,c,d","e"]'
jq(str, 'join(", ")')
str %&gt;% join
str %&gt;% join(`;`)
str %&gt;% join(`yep`)
## many JSON inputs
'["a","b,c,d","e"] ["a","f,e,f"]' %&gt;% join(`---`)

# split
jq('"a, b,c,d, e"', 'split(", ")')

# ltrimstr
jq('["fo", "foo", "barfoo", "foobar", "afoo"]', '[.[]|ltrimstr("foo")]')
'["fo", "foo", "barfoo", "foobar", "afoo"]' %&gt;% index() %&gt;% ltrimstr(foo)

# rtrimstr
jq('["fo", "foo", "barfoo", "foobar", "foob"]', '[.[]|rtrimstr("foo")]')
'["fo", "foo", "barfoo", "foobar", "foob"]' %&gt;% index() %&gt;% rtrimstr(foo)

# startswith
str &lt;- '["fo", "foo", "barfoo", "foobar", "barfoob"]'
jq(str, '[.[]|startswith("foo")]')
str %&gt;% index %&gt;% startswith(foo)
## many JSON inputs
'["fo", "foo"] ["barfoo", "foobar", "barfoob"]' %&gt;% index %&gt;% startswith(foo)

# endswith
jq(str, '[.[]|endswith("foo")]')
str %&gt;% index %&gt;% endswith(foo)
str %&gt;% index %&gt;% endswith_("foo")
str %&gt;% index %&gt;% endswith(bar)
str %&gt;% index %&gt;% endswith_("bar")
## many JSON inputs
'["fo", "foo"] ["barfoo", "foobar", "barfoob"]' %&gt;% index %&gt;% endswith(foo)

# get index (location) of a character
## input has to be quoted
str &lt;- '"a,b, cd, efg, hijk"'
str %&gt;% index_loc(", ")
str %&gt;% index_loc(",")
str %&gt;% index_loc("j")
str %&gt;% rindex_loc(", ")
str %&gt;% indices(", ")

# tojson, fromjson, tostring, tonumber
'[1, "foo", ["foo"]]' %&gt;% index %&gt;% tostring
'[1, "1"]' %&gt;% index %&gt;% tonumber
'[1, "foo", ["foo"]]' %&gt;% index %&gt;% tojson
'[1, "foo", ["foo"]]' %&gt;% index %&gt;% tojson %&gt;% fromjson

# contains
'"foobar"' %&gt;% contains("bar")
'["foobar", "foobaz", "blarp"]' %&gt;% contains(`["baz", "bar"]`)
'["foobar", "foobaz", "blarp"]' %&gt;% contains(`["bazzzzz", "bar"]`)
str &lt;- '{"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]}'
str %&gt;% contains(`{foo: 12, bar: [{barp: 12}]}`)
str %&gt;% contains(`{foo: 12, bar: [{barp: 15}]}`)

# unique
'[1,2,5,3,5,3,1,3]' %&gt;% uniquej
str &lt;- '[{"foo": 1, "bar": 2}, {"foo": 1, "bar": 3}, {"foo": 4, "bar": 5}]'
str %&gt;% uniquej(foo)
str %&gt;% uniquej_("foo")
'["chunky", "bacon", "kitten", "cicada", "asparagus"]' %&gt;% uniquej(length)

# group
x &lt;- '[{"foo":1, "bar":10}, {"foo":3, "bar":100}, {"foo":1, "bar":1}]'
x %&gt;% group(foo)
x %&gt;% group_("foo")
</code></pre>

<hr>
<h2 id='maths'>Math operations</h2><span id='topic+maths'></span><span id='topic+do'></span><span id='topic+do_'></span><span id='topic+lengthj'></span><span id='topic+sqrtj'></span><span id='topic+floorj'></span><span id='topic+minj'></span><span id='topic+minj_'></span><span id='topic+maxj'></span><span id='topic+maxj_'></span><span id='topic+ad'></span><span id='topic+map'></span><span id='topic+map_'></span>

<h3>Description</h3>

<p>Math operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do(.data, ...)

do_(.data, ..., .dots)

lengthj(.data)

sqrtj(.data)

floorj(.data)

minj(.data, ...)

minj_(.data, ..., .dots)

maxj(.data, ...)

maxj_(.data, ..., .dots)

ad(.data)

map(.data, ...)

map_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maths_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="maths_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="maths_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="maths_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># do math
jq('{"a": 7}', '.a + 1')
# adding null gives back same result
jq('{"a": 7}', '.a + null')
jq('{"a": 7}', '.a += 1')
'{"a": 7}' %&gt;%  do(.a + 1)
# '{"a": 7}' %&gt;%  do(.a += 1) # this doesn't work quite yet
'{"a": [1,2], "b": [3,4]}' %&gt;%  do(.a + .b)
'{"a": [1,2], "b": [3,4]}' %&gt;%  do(.a - .b)
'{"a": 3}' %&gt;%  do(4 - .a)
'["xml", "yaml", "json"]' %&gt;%  do('. - ["xml", "yaml"]')
'5' %&gt;%  do(10 / . * 3)
## many JSON inputs
'{"a": [1,2], "b": [3,4]} {"a": [1,5], "b": [3,10]}' %&gt;%  do(.a + .b)

# comparisons
'[5,4,2,7]' %&gt;% index() %&gt;% do(. &lt; 4)
'[5,4,2,7]' %&gt;% index() %&gt;% do(. &gt; 4)
'[5,4,2,7]' %&gt;% index() %&gt;% do(. &lt;= 4)
'[5,4,2,7]' %&gt;% index() %&gt;% do(. &gt;= 4)
'[5,4,2,7]' %&gt;% index() %&gt;% do(. == 4)
'[5,4,2,7]' %&gt;% index() %&gt;% do(. != 4)
## many JSON inputs
'[5,4,2,7] [4,3,200,0.1]' %&gt;% index() %&gt;% do(. &lt; 4)

# length
'[[1,2], "string", {"a":2}, null]' %&gt;% index %&gt;% lengthj

# sqrt
'9' %&gt;% sqrtj
## many JSON inputs
'9 4 5' %&gt;% sqrtj

# floor
'3.14159' %&gt;% floorj
## many JSON inputs
'3.14159 30.14 45.9' %&gt;% floorj

# find minimum
'[5,4,2,7]' %&gt;% minj
'[{"foo":1, "bar":14}, {"foo":2, "bar":3}]' %&gt;% minj
'[{"foo":1, "bar":14}, {"foo":2, "bar":3}]' %&gt;% minj(foo)
'[{"foo":1, "bar":14}, {"foo":2, "bar":3}]' %&gt;% minj(bar)
## many JSON inputs
'[{"foo":1}, {"foo":14}] [{"foo":2}, {"foo":3}]' %&gt;% minj(foo)

# find maximum
'[5,4,2,7]' %&gt;% maxj
'[{"foo":1, "bar":14}, {"foo":2, "bar":3}]' %&gt;% maxj
'[{"foo":1, "bar":14}, {"foo":2, "bar":3}]' %&gt;% maxj(foo)
'[{"foo":1, "bar":14}, {"foo":2, "bar":3}]' %&gt;% maxj(bar)
## many JSON inputs
'[{"foo":1}, {"foo":14}] [{"foo":2}, {"foo":3}]' %&gt;% maxj(foo)

# increment values
## requires special % operators, they get escaped internally
'{"foo": 1}' %&gt;% do(.foo %+=% 1)
'{"foo": 1}' %&gt;% do(.foo %-=% 1)
'{"foo": 1}' %&gt;% do(.foo %*=% 4)
'{"foo": 1}' %&gt;% do(.foo %/=% 10)
'{"foo": 1}' %&gt;% do(.foo %//=% 10)
### fix me - %= doesn't work
# '{"foo": 1}' %&gt;% do(.foo %%=% 10)
## many JSON inputs
'{"foo": 1} {"foo": 2} {"foo": 3}' %&gt;% do(.foo %+=% 1)

# add
'["a","b","c"]' %&gt;% ad
'[1, 2, 3]' %&gt;% ad
'[]' %&gt;% ad
## many JSON inputs
'["a","b","c"] ["d","e","f"]' %&gt;% ad

# map
## as far as I know, this only works with numbers, thus it's
## in the maths section
'[1, 2, 3]' %&gt;% map(.+1)
'[1, 2, 3]' %&gt;% map(./1)
'[1, 2, 3]' %&gt;% map(.*4)
# many JSON inputs
'[1, 2, 3] [100, 200, 300] [1000, 2000, 30000]' %&gt;% map(.+1)
</code></pre>

<hr>
<h2 id='paths'>Outputs paths to all the elements in its input</h2><span id='topic+paths'></span>

<h3>Description</h3>

<p>Outputs paths to all the elements in its input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paths_+3A_.data">.data</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>'[1,[[],{"a":2}]]' %&gt;% paths
'[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]' %&gt;% paths
</code></pre>

<hr>
<h2 id='peek'>Peek at a query</h2><span id='topic+peek'></span>

<h3>Description</h3>

<p>Prints the query resulting from <code>jq</code> all in one character string just
as you would execute it on the command line. Output gets class of json,
and pretty prints to the console for easier viewing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peek_+3A_.data">.data</code></td>
<td>
<p>(list) input, using higher level interface</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jq">jq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>'{"a": 7}' %&gt;% do(.a + 1) %&gt;% peek
'[8,3,null,6]' %&gt;% sortj %&gt;% peek
</code></pre>

<hr>
<h2 id='rangej'>Produce range of numbers</h2><span id='topic+rangej'></span>

<h3>Description</h3>

<p>Produce range of numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rangej(x, array = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rangej_+3A_x">x</code></td>
<td>
<p>Input, single number or number range.</p>
</td></tr>
<tr><td><code id="rangej_+3A_array">array</code></td>
<td>
<p>(logical) Create array. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>2:4 %&gt;% rangej
2:1000 %&gt;% rangej
1 %&gt;% rangej
4 %&gt;% rangej
</code></pre>

<hr>
<h2 id='recurse'>Search through a recursive structure - extract data from all levels</h2><span id='topic+recurse'></span><span id='topic+recurse_'></span>

<h3>Description</h3>

<p>Search through a recursive structure - extract data from all levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recurse(.data, ...)

recurse_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recurse_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="recurse_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="recurse_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="recurse_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{"name": "/", "children": [
  {"name": "/bin", "children": [
    {"name": "/bin/ls", "children": []},
    {"name": "/bin/sh", "children": []}]},
  {"name": "/home", "children": [
    {"name": "/home/stephen", "children": [
      {"name": "/home/stephen/jq", "children": []}]}]}]}'
x %&gt;% recurse(.children[]) %&gt;% build_object(name)
x %&gt;% recurse(.children[]) %&gt;% build_object(name) %&gt;% string
</code></pre>

<hr>
<h2 id='select'>Select - filtering</h2><span id='topic+select'></span><span id='topic+select_'></span>

<h3>Description</h3>

<p>The function <code>select(foo)</code> produces its input unchanged if 
<code>foo</code> returns TRUE for that input, and produces no output otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(.data, ...)

select_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="select_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="select_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this function has changed what it does dramatically. we were 
using this function for object construction, which is now done with 
<code><a href="#topic+build_object">build_object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jq('[1,5,3,0,7]', 'map(select(. &gt;= 2))')
'[1,5,3,0,7]' %&gt;% map(select(. &gt;= 2)) 


'{"foo": 4, "bar": 7}' %&gt;% select(.foo == 4)
'{"foo": 5, "bar": 7} {"foo": 4, "bar": 7}' %&gt;% select(.foo == 4)
'[{"foo": 5, "bar": 7}, {"foo": 4, "bar": 7}]' %&gt;% index() %&gt;% 
  select(.foo == 4)
'{"foo": 4, "bar": 7} {"foo": 5, "bar": 7} {"foo": 8, "bar": 7}' %&gt;% 
  select(.foo &lt; 6)

x &lt;- '{"foo": 4, "bar": 2} {"foo": 5, "bar": 4} {"foo": 8, "bar": 12}'
jq(x, 'select((.foo &lt; 6) and (.bar &gt; 3))')
jq(x, 'select((.foo &lt; 6) or (.bar &gt; 3))')
x %&gt;% select((.foo &lt; 6) &amp;&amp; (.bar &gt; 3))
x %&gt;% select((.foo &lt; 6) || (.bar &gt; 3))

x &lt;- '[{"foo": 5, "bar": 7}, {"foo": 4, "bar": 7}, {"foo": 4, "bar": 9}]'
jq(x, '.[] | select(.foo == 4) | {user: .bar}')
x %&gt;% index() %&gt;% select(.foo == 4) %&gt;% build_object(user = .bar)
</code></pre>

<hr>
<h2 id='sortj'>Sort and related</h2><span id='topic+sortj'></span><span id='topic+sortj_'></span><span id='topic+reverse'></span>

<h3>Description</h3>

<p>Sort and related
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortj(.data, ...)

sortj_(.data, ..., .dots)

reverse(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortj_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="sortj_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="sortj_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="sortj_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># sort
'[8,3,null,6]' %&gt;% sortj
'[{"foo":4, "bar":10}, {"foo":3, "bar":100}, {"foo":2, "bar":1}]' %&gt;%
  sortj(foo)

# reverse order
'[1,2,3,4]' %&gt;% reverse

# many JSON inputs
'[{"foo":7}, {"foo":4}] [{"foo":300}, {"foo":1}] [{"foo":2}, {"foo":1}]' %&gt;%
  sortj(foo)

'[1,2,3,4] [10,20,30,40] [100,200,300,4000]' %&gt;%
  reverse
</code></pre>

<hr>
<h2 id='string'>Give back a character string</h2><span id='topic+string'></span>

<h3>Description</h3>

<p>Give back a character string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_+3A_.data">.data</code></td>
<td>
<p>(list) input, using higher level interface</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+peek">peek</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>'{"a": 7}' %&gt;% do(.a + 1) %&gt;% string
'[8,3,null,6]' %&gt;% sortj %&gt;% string
</code></pre>

<hr>
<h2 id='types'>Types and related functions</h2><span id='topic+types'></span><span id='topic+type'></span><span id='topic+type_'></span>

<h3>Description</h3>

<p>Types and related functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types(.data)

type(.data, ...)

type_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="types_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="types_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="types_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># get type information for each element
jq('[0, false, [], {}, null, "hello"]', 'map(type)')
'[0, false, [], {}, null, "hello"]' %&gt;% types
'[0, false, [], {}, null, "hello", true, [1,2,3]]' %&gt;% types

# select elements by type
jq('[0, false, [], {}, null, "hello"]', '.[] | numbers,booleans')
'[0, false, [], {}, null, "hello"]' %&gt;% index() %&gt;% type(booleans)
</code></pre>

<hr>
<h2 id='vars'>Variables</h2><span id='topic+vars'></span><span id='topic+vars_'></span>

<h3>Description</h3>

<p>Variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars(.data, ...)

vars_(.data, ..., .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_+3A_.data">.data</code></td>
<td>
<p>input. This can be JSON input, or an object of class
<code>jqr</code> that has JSON and query params combined, which is passed
from function to function when using the jqr DSL.</p>
</td></tr>
<tr><td><code id="vars_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names</p>
</td></tr>
<tr><td><code id="vars_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation</p>
</td></tr>
<tr><td><code id="vars_+3A_dots">dots</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{
 "posts": [
   {"title": "Frist psot", "author": "anon"},
   {"title": "A well-written article", "author": "person1"}
 ],
 "realnames": {
   "anon": "Anonymous Coward",
   "person1": "Person McPherson"
 }
}'

x %&gt;% dotstr(posts[])
x %&gt;% dotstr(posts[]) %&gt;% string
x %&gt;% vars(realnames = names) %&gt;% dotstr(posts[]) %&gt;%
   build_object(title, author = "$names[.author]")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
