<!DOCTYPE html><html lang="en"><head><title>Help for package blocklength</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {blocklength}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hhj'><p>Hall, Horowitz, and Jing (1995) &quot;HHJ&quot; Algorithm to Select the Optimal Block-Length</p></a></li>
<li><a href='#nppi'><p>Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In &quot;NPPI&quot; Rule to Select the Optimal Block-Length</p></a></li>
<li><a href='#plot.hhj'><p>Plot MSE Function for HHJ Algorithm</p></a></li>
<li><a href='#plot.nppi'><p>Plot Stability of JAB Point Estimates</p></a></li>
<li><a href='#plot.pwsd'><p>Plot Correlogram for Politis and White Auto<code class="reqn">-</code>Correlation Implied Hypothesis Test</p></a></li>
<li><a href='#pwsd'><p>Politis and White (2004) Spectral Density &quot;PWSD&quot; Automatic Block-Length Selection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Select an Optimal Block-Length to Bootstrap Dependent Data
(Block Bootstrap)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alec Stashevsky &lt;alec@alecstashevsky.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions to select the optimal block-length for a 
    dependent bootstrap (block-bootstrap). Includes the Hall, Horowitz, and Jing
    (1995) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F82.3.561">doi:10.1093/biomet/82.3.561</a>&gt; subsampling-based cross-validation method, the 
    Politis and White (2004) &lt;<a href="https://doi.org/10.1081%2FETC-120028836">doi:10.1081/ETC-120028836</a>&gt; Spectral Density 
    Plug-in method, including the Patton, Politis, and White (2009)
    &lt;<a href="https://doi.org/10.1080%2F07474930802459016">doi:10.1080/07474930802459016</a>&gt; correction, and the Lahiri, Furukawa, and Lee
    (2007) &lt;<a href="https://doi.org/10.1016%2Fj.stamet.2006.08.002">doi:10.1016/j.stamet.2006.08.002</a>&gt; nonparametric plug-in method, with 
    a corresponding set of S3 plot methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, parallel, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>tseries, stats</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://alecstashevsky.com/r/blocklength">https://alecstashevsky.com/r/blocklength</a>,
<a href="https://github.com/Alec-Stashevsky/blocklength">https://github.com/Alec-Stashevsky/blocklength</a>,
<a href="https://alec-stashevsky.github.io/blocklength/">https://alec-stashevsky.github.io/blocklength/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Alec-Stashevsky/blocklength/issues">https://github.com/Alec-Stashevsky/blocklength/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-08</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-08 20:58:22 UTC; alec</td>
</tr>
<tr>
<td>Author:</td>
<td>Alec Stashevsky <a href="https://orcid.org/0000-0003-2538-4947"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sergio Armella [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-08 21:50:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='hhj'>Hall, Horowitz, and Jing (1995) &quot;HHJ&quot; Algorithm to Select the Optimal Block-Length</h2><span id='topic+hhj'></span>

<h3>Description</h3>

<p>Perform the Hall, Horowitz, and Jing (1995) &quot;HHJ&quot; cross-validation algorithm
to select the optimal block-length for a bootstrap on dependent data
(block-bootstrap). Dependent data such as stationary time series are suitable
for usage with the HHJ algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhj(
  series,
  nb = 100L,
  n_iter = 10L,
  pilot_block_length = NULL,
  sub_sample = NULL,
  k = "two-sided",
  bofb = 1L,
  search_grid = NULL,
  grid_step = c(1L, 1L),
  cl = NULL,
  verbose = TRUE,
  plots = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hhj_+3A_series">series</code></td>
<td>
<p>a numeric vector or time series giving the original data for
which to find the optimal block-length for.</p>
</td></tr>
<tr><td><code id="hhj_+3A_nb">nb</code></td>
<td>
<p>an integer value, number of bootstrapped series to compute.</p>
</td></tr>
<tr><td><code id="hhj_+3A_n_iter">n_iter</code></td>
<td>
<p>an integer value, maximum number of iterations for the HHJ
algorithm to compute.</p>
</td></tr>
<tr><td><code id="hhj_+3A_pilot_block_length">pilot_block_length</code></td>
<td>
<p>a numeric value, the block-length (<code class="reqn">l*</code> in
<em>HHJ</em>) for which to perform initial block bootstraps.</p>
</td></tr>
<tr><td><code id="hhj_+3A_sub_sample">sub_sample</code></td>
<td>
<p>a numeric value, the length of each overlapping
subsample, <code class="reqn">m</code> in <em>HHJ</em>.</p>
</td></tr>
<tr><td><code id="hhj_+3A_k">k</code></td>
<td>
<p>a character string, either <code>"bias/variance"</code>,
<code>"one-sided"</code>, or <code>"two-sided"</code> depending on the desired object of
estimation. If the desired bootstrap statistic is bias or variance then
select <code>"bias/variance"</code> which sets <code class="reqn">k = 3</code> per HHJ. If the object
of estimation is the one-sided or two-sided distribution function, then set
<code>k = "one-sided"</code> or <code>k = "two-sided"</code> which sets <code class="reqn">k = 4</code> and
<code class="reqn">k = 5</code>, respectively. For the purpose of generating symmetric confidence
intervals around an unknown parameter, <code>k = "two-sided"</code> (the default)
should be used.</p>
</td></tr>
<tr><td><code id="hhj_+3A_bofb">bofb</code></td>
<td>
<p>a numeric value, length of the basic blocks in the
<em>block-of-blocks</em> bootstrap, <em>see</em> <code>m = </code> for
<code><a href="tseries.html#topic+tsbootstrap">tsbootstrap</a></code> and Kunsch (1989).</p>
</td></tr>
<tr><td><code id="hhj_+3A_search_grid">search_grid</code></td>
<td>
<p>a numeric value, the range of solutions around <code class="reqn">l*</code> to
evaluate within the <code class="reqn">MSE</code> function <em>after</em> the first iteration. The
first iteration will search through all the possible block-lengths unless
specified in <code>grid_step = </code>.</p>
</td></tr>
<tr><td><code id="hhj_+3A_grid_step">grid_step</code></td>
<td>
<p>a numeric value or vector of at most length 2, the number of
steps to increment over the subsample block-lengths when evaluating the
<code class="reqn">MSE</code> function. If <code>grid_step = 1</code> then each block-length will be
evaluated in the <code class="reqn">MSE</code> function. If <code>grid_step &gt; 1</code>, the <code class="reqn">MSE</code>
function will search over the sequence of block-lengths from <code>1</code> to
<code>m</code> by <code>grid_step</code>. If <code>grid_step</code> is a vector of length 2,
the first iteration will step by the first element of <code>grid_step</code> and
subsequent iterations will step by the second element.</p>
</td></tr>
<tr><td><code id="hhj_+3A_cl">cl</code></td>
<td>
<p>a cluster object, created by package <span class="pkg">parallel</span>,
<span class="pkg">doParallel</span>, or <span class="pkg">snow</span>. If <code>NULL</code>, no parallelization will be
used.</p>
</td></tr>
<tr><td><code id="hhj_+3A_verbose">verbose</code></td>
<td>
<p>a logical value, if set to <code>FALSE</code> then no interim
messages are output to the console. Error messages will still be output.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hhj_+3A_plots">plots</code></td>
<td>
<p>a logical value, if set to <code>FALSE</code> then no interim plots
are output to the console. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The HHJ algorithm is computationally intensive as it relies on a
cross-validation process using a type of subsampling to estimate the mean
squared error (<code class="reqn">MSE</code>) incurred by the bootstrap at various block-lengths.
</p>
<p>Under-the-hood, <code>hhj()</code> makes use of <code><a href="tseries.html#topic+tsbootstrap">tsbootstrap</a></code>,
<em>see</em> Trapletti and Hornik (2020), to perform the moving block-bootstrap
(or the <em>block-of-blocks</em> bootstrap by setting <code>bofb &gt; 1</code>) according
to Kunsch (1989).
</p>


<h3>Value</h3>

<p>an object of class 'hhj'
</p>


<h3>References</h3>

<p>Adrian Trapletti and Kurt Hornik (2020). tseries: Time Series Analysis and
Computational Finance. R package version 0.10-48.
</p>
<p>Kunsch, H. (1989) The Jackknife and the Bootstrap for General Stationary
Observations. The Annals of Statistics, 17(3), 1217-1241. Retrieved
February 16, 2021, from <a href="https://doi.org/10.1214/aos/1176347265">doi:10.1214/aos/1176347265</a>
</p>
<p>Peter Hall, Joel L. Horowitz, Bing-Yi Jing, On blocking rules for the
bootstrap with dependent data, Biometrika, Volume 82, Issue 3,
September 1995, Pages 561-574, DOI: <a href="https://doi.org/10.1093/biomet/82.3.561">doi:10.1093/biomet/82.3.561</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate AR(1) time series
sim &lt;- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),
                        n = 500, innov = rnorm(500))

# Calculate optimal block length for series
hhj(sim, sub_sample = 10)


# Use parallel computing
library(parallel)

# Make cluster object with 2 cores
cl &lt;- makeCluster(2)

# Calculate optimal block length for series
hhj(sim, cl = cl)


</code></pre>

<hr>
<h2 id='nppi'>Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In &quot;NPPI&quot; Rule to Select the Optimal Block-Length</h2><span id='topic+nppi'></span>

<h3>Description</h3>

<p>This function implements the Nonparametric Plug-In (NPPI) algorithm,
as proposed by Lahiri, Furukawa, and Lee (2007), to select the optimal block
length for block bootstrap procedures.
The NPPI method estimates the optimal block length by balancing bias and
variance in block bootstrap estimators, particularly for time series and
other dependent data structures. The function also leverages the Moving
Block Bootstrap (MBB) method of (Kunsch, 1989) and the Moving Blocks
Jackknifte (MBJ) of Liu and Singh (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nppi(
  data,
  stat_function = mean,
  r = 1,
  a = 1,
  l = NULL,
  m = NULL,
  num_bootstrap = 1000,
  c_1 = 1L,
  epsilon = 1e-08,
  plots = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nppi_+3A_data">data</code></td>
<td>
<p>A numeric vector, ts, or single-column data.frame representing
the time series or dependent data.</p>
</td></tr>
<tr><td><code id="nppi_+3A_stat_function">stat_function</code></td>
<td>
<p>A function to compute the statistic of interest
(*e.g.*, mean, variance). The function should accept a numeric vector as input
and return a scalar value (default is <code>mean</code>).</p>
</td></tr>
<tr><td><code id="nppi_+3A_r">r</code></td>
<td>
<p>The rate parameter for the MSE expansion (default is 1). This
parameter controls the convergence rate in the bias-variance trade-off.</p>
</td></tr>
<tr><td><code id="nppi_+3A_a">a</code></td>
<td>
<p>The bias exponent (default is 1). Adjust this based on the
theoretical properties of the statistic being bootstrapped.</p>
</td></tr>
<tr><td><code id="nppi_+3A_l">l</code></td>
<td>
<p>Optional. The initial block size for bias estimation.
If not provided, it is set to <code>max(2, round(c_1 * n^{1 / (r + 4)}))</code>,
where <code>n</code> is the sample size.</p>
</td></tr>
<tr><td><code id="nppi_+3A_m">m</code></td>
<td>
<p>Optional. The number of blocks to delete in the
Jackknife-After-Bootstrap (JAB) variance estimation. If not provided,
it defaults to <code>floor(c_2 * n^{1/3} * l^{2/3})</code>.</p>
</td></tr>
<tr><td><code id="nppi_+3A_num_bootstrap">num_bootstrap</code></td>
<td>
<p>The number of bootstrap replications for bias estimation
(default is 1000).</p>
</td></tr>
<tr><td><code id="nppi_+3A_c_1">c_1</code></td>
<td>
<p>A tuning constant for initial block size calculation (default is 1).</p>
</td></tr>
<tr><td><code id="nppi_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the variance to prevent division by
zero (default is <code>1e-8</code>).</p>
</td></tr>
<tr><td><code id="nppi_+3A_plots">plots</code></td>
<td>
<p>A logical value indicating whether to plot the JAB diagnostic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Jackknife-After-Bootstrap (JAB) variance estimation (Lahiri, 2002).
</p>


<h3>Value</h3>

<p>A object of class <code>nppi</code> with the following components:
</p>

<dl>
<dt>optimal_block_length</dt><dd><p>The estimated optimal block length for the
block bootstrap procedure.</p>
</dd>
<dt>bias</dt><dd><p>The estimated bias of the block bootstrap estimator.</p>
</dd>
<dt>variance</dt><dd><p>The estimated variance of the block bootstrap estimator
using the JAB method.</p>
</dd>
<dt>jab_point_values</dt><dd><p>The point estimates of the statistic for each
deletion block in the JAB variance estimation. Used for diagnostic plots</p>
</dd>
<dt>jab_pseudo_values</dt><dd><p>The pseudo-values of each JAB point value.</p>
</dd>
<dt>l</dt><dd><p>The initial block size used for bias estimation.</p>
</dd>
<dt>m</dt><dd><p>The number of blocks to delete in the JAB variance estimation.</p>
</dd>
</dl>



<h3>References</h3>

<p>Efron, B. (1992), 'Jackknife-after-bootstrap standard errors and influence
functions (with discussion)', Journal of Royal Statistical Society,
Series B 54, 83-111.
</p>
<p>Kunsch, H. (1989) The Jackknife and the Bootstrap for General Stationary
Observations. The Annals of Statistics, 17(3), 1217-1241. Retrieved
February 16, 2021, from <a href="https://doi.org/10.1214/aos/1176347265">doi:10.1214/aos/1176347265</a>
</p>
<p>Lahiri, S. N., Furukawa, K., &amp; Lee, Y.-D. (2007). A nonparametric plug-in
rule for selecting optimal block lengths for Block Bootstrap Methods.
Statistical Methodology, 4(3), 292-321. DOI:
<a href="https://doi.org/10.1016/j.stamet.2006.08.002">doi:10.1016/j.stamet.2006.08.002</a>
</p>
<p>Lahiri, S. N. (2003). 7.4 A Nonparametric Plug-in Method. In Resampling
methods for dependent data (pp. 186-197). Springer.
</p>
<p>Liu, R. Y. and Singh, K. (1992), Moving blocks jackknife and bootstrap
capture weak dependence, in R. Lepage and L. Billard, eds, 'Exploring
the Limits of the Bootstrap', Wiley, New York, pp. 225-248.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate AR(1) time series
set.seed(32)
sim &lt;- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),
                        n = 500, innov = rnorm(500))

# Estimate the optimal block length for the sample mean
result &lt;- nppi(data = sim, stat_function = mean, num_bootstrap = 500, m = 2)

print(result$optimal_block_length)

# Use S3 method to plot JAB diagnostic
plot(result)

</code></pre>

<hr>
<h2 id='plot.hhj'>Plot MSE Function for HHJ Algorithm</h2><span id='topic+plot.hhj'></span>

<h3>Description</h3>

<p>S3 Method for objects of class 'hhj'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hhj'
plot(x, iter = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hhj_+3A_x">x</code></td>
<td>
<p>an object of class 'hhj'</p>
</td></tr>
<tr><td><code id="plot.hhj_+3A_iter">iter</code></td>
<td>
<p>a vector of <code>hhj()</code> iterations to plot. <code>NULL</code>. All
iterations are plotted by default.</p>
</td></tr>
<tr><td><code id="plot.hhj_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+plot">base::plot</a></code>
</p>

<dl>
<dt><code>y</code></dt><dd><p>the y coordinates of points in the plot, <em>optional</em>
if <code>x</code> is an appropriate structure.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Generate AR(1) time series
sim &lt;- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),
                        n = 500, innov = rnorm(500))

# Generate 'hhj' class object of optimal block length for series
hhj &lt;- hhj(sim, sub_sample = 10)

## S3 method for class 'hhj'
plot(hhj)


</code></pre>

<hr>
<h2 id='plot.nppi'>Plot Stability of JAB Point Estimates</h2><span id='topic+plot.nppi'></span>

<h3>Description</h3>

<p>S3 Method for objects of class 'nppi'
This function visualizes the JAB point estimates across deletion blocks
indices used to estimate variance of the NPPI algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nppi'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.nppi_+3A_x">x</code></td>
<td>
<p>An object of class <code>nppi</code>, containing JAB point values.</p>
</td></tr>
<tr><td><code id="plot.nppi_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+plot">base::plot</a></code>
</p>

<dl>
<dt><code>y</code></dt><dd><p>the y coordinates of points in the plot, <em>optional</em>
if <code>x</code> is an appropriate structure.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate AR(1) time series
set.seed(32)
sim &lt;- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),
                        n = 500, innov = rnorm(500))

# Estimate the optimal block length for the sample mean
result &lt;- nppi(data = sim, stat_function = mean, num_bootstrap = 500, m = 2)

# Use s3 method
plot(result)

</code></pre>

<hr>
<h2 id='plot.pwsd'>Plot Correlogram for Politis and White Auto<code class="reqn">-</code>Correlation Implied Hypothesis Test</h2><span id='topic+plot.pwsd'></span>

<h3>Description</h3>

<p>S3 Method for objects of class 'pwsd'
<em>See</em> <code>?plot.acf</code> of the <span class="pkg">stats</span> package for more customization
options on the correlogram, from which <code>plot.pwsd</code> is based
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pwsd'
plot(x, c = NULL, main = NULL, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pwsd_+3A_x">x</code></td>
<td>
<p>an of object of class 'pwsd' or 'acf'</p>
</td></tr>
<tr><td><code id="plot.pwsd_+3A_c">c</code></td>
<td>
<p>a numeric value, the constant which acts as the significance level
for the implied hypothesis test. Defaults to <code>qnorm(0.975)</code> for a
two-tailed 95% confidence level. Politis and  White (2004) suggest
<code>c = 2</code>.</p>
</td></tr>
<tr><td><code id="plot.pwsd_+3A_main">main</code></td>
<td>
<p>an overall title for the plot, if no string is supplied a default
title  will be populated. <em>See</em> <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="plot.pwsd_+3A_ylim">ylim</code></td>
<td>
<p>a numeric of length 2 giving the y-axis limits for the plot</p>
</td></tr>
<tr><td><code id="plot.pwsd_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+plot">base::plot</a></code>
</p>

<dl>
<dt><code>y</code></dt><dd><p>the y coordinates of points in the plot, <em>optional</em>
if <code>x</code> is an appropriate structure.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use S3 Method

# Generate AR(1) time series
sim &lt;- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),
                        n = 500, innov = rnorm(500))

b &lt;- pwsd(sim, round = TRUE, correlogram = FALSE)
plot(b)

</code></pre>

<hr>
<h2 id='pwsd'>Politis and White (2004) Spectral Density &quot;PWSD&quot; Automatic Block-Length Selection</h2><span id='topic+pwsd'></span>

<h3>Description</h3>

<p>Run the Automatic Block-Length selection method proposed by Politis and White
(2004) and corrected in Patton, Politis, and White (2009). The method is
based on spectral density estimation via flat-top lag windows of Politis and
Romano (1995). This code was adapted from <code><a href="np.html#topic+b.star">b.star</a></code> to add
functionality and include correlogram support including an S3 method,
<em>see</em> Hayfield and Racine (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwsd(
  data,
  K_N = NULL,
  M_max = NULL,
  m_hat = NULL,
  b_max = NULL,
  c = NULL,
  round = FALSE,
  correlogram = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwsd_+3A_data">data</code></td>
<td>
<p>an <code class="reqn">n x k</code> data.frame, matrix, or vector (if <code class="reqn">k = 1</code>)
where the optimal block-length will be computed for each of the <code class="reqn">k</code>
columns.</p>
</td></tr>
<tr><td><code id="pwsd_+3A_k_n">K_N</code></td>
<td>
<p>an integer value, the maximum lags for the auto-correlation,
<code class="reqn">rho_k</code>, which to apply the <em>implied hypothesis</em> test. Defaults to
<code>max(5, log(N))</code>. <em>See</em> Politis and White (2004) footnote c.</p>
</td></tr>
<tr><td><code id="pwsd_+3A_m_max">M_max</code></td>
<td>
<p>an integer value, the upper-bound for the optimal number of lags,
<code class="reqn">M</code>, to compute the auto-covariance for. <em>See</em> Theorem 3.3 (ii) of
Politis and White (2004).</p>
</td></tr>
<tr><td><code id="pwsd_+3A_m_hat">m_hat</code></td>
<td>
<p>an integer value, if set to <code>NULL</code> (the default), then
<code>m_hat</code> is estimated as the smallest integer after which the correlogram
appears negligible for <code>K_N</code> lags. In problematic cases, setting
<code>m_hat</code> to an integer value can be used to override the estimation
procedure.</p>
</td></tr>
<tr><td><code id="pwsd_+3A_b_max">b_max</code></td>
<td>
<p>a numeric value, the upper-bound for the optimal block-length.
Defaults to <code>ceiling(min(3 * sqrt(n), n / 3))</code> per Politis and White
(2004).</p>
</td></tr>
<tr><td><code id="pwsd_+3A_c">c</code></td>
<td>
<p>a numeric value, the constant which acts as the significance level
for the implied hypothesis test. Defaults to <code>qnorm(0.975)</code> for a
two-tailed 95% confidence level. Politis and  White (2004) suggest
<code>c = 2</code>.</p>
</td></tr>
<tr><td><code id="pwsd_+3A_round">round</code></td>
<td>
<p>a logical value, if set to <code>FALSE</code> then the final
block-length output will not be rounded, the default. If set to <code>TRUE</code>
the final estimates for the optimal block-length will be rounded to whole
numbers.</p>
</td></tr>
<tr><td><code id="pwsd_+3A_correlogram">correlogram</code></td>
<td>
<p>a logical value, if set to <code>TRUE</code> a plot of the
correlogram (<em>i.e.</em> a plot of <code class="reqn">R(k)</code> vs. <code class="reqn">k</code>) will be output to
the console. If set to <code>FALSE</code>, no interim plots will be output to the
console, but may be plotted later using the corresponding S3 method,
<a href="#topic+plot.pwsd">plot.pwsd</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'pwsd'
</p>


<h3>References</h3>

<p>Andrew Patton, Dimitris N. Politis &amp; Halbert White (2009) Correction to
&quot;Automatic Block-Length Selection for the Dependent Bootstrap&quot; by D.
Politis and H. White, Econometric Review, 28:4, 372-375, DOI:
<a href="https://doi.org/10.1080/07474930802459016">doi:10.1080/07474930802459016</a>
</p>
<p>Dimitris N. Politis &amp; Halbert White (2004) Automatic Block-Length Selection
for the Dependent Bootstrap, Econometric Reviews, 23:1, 53-70, DOI:
<a href="https://doi.org/10.1081/ETC-120028836">doi:10.1081/ETC-120028836</a>
</p>
<p>Politis, D.N. and Romano, J.P. (1995), Bias-Corrected Nonparametric Spectral
Estimation. Journal of Time Series Analysis, 16: 67-103, DOI:
<a href="https://doi.org/10.1111/j.1467-9892.1995.tb00223.x">doi:10.1111/j.1467-9892.1995.tb00223.x</a>
</p>
<p>Tristen Hayfield and Jeffrey S. Racine (2008). Nonparametric Econometrics:
The np Package. Journal of Statistical Software 27(5). DOI:
<a href="https://doi.org/10.18637/jss.v027.i05">doi:10.18637/jss.v027.i05</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate AR(1) time series
sim &lt;- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),
                        n = 500, innov = rnorm(500))

# Calculate optimal block length for series
pwsd(sim, round = TRUE)


# Use S3 Method
b &lt;- pwsd(sim, round = TRUE, correlogram = FALSE)
plot(b)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
