<!DOCTYPE html><html lang="en"><head><title>Help for package dlm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dlm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arms'><p>Function to perform Adaptive Rejection Metropolis Sampling</p></a></li>
<li><a href='#ARtransPars'><p>Function to parametrize a stationary AR process</p></a></li>
<li><a href='#bdiag'><p>Build a block diagonal matrix</p></a></li>
<li><a href='#convex.bounds'><p>Find the boundaries of a convex set</p></a></li>
<li><a href='#dlm'><p>dlm objects</p></a></li>
<li><a href='#dlmBSample'><p>Draw from the posterior distribution of the state vectors</p></a></li>
<li><a href='#dlmFilter'><p>DLM filtering</p></a></li>
<li><a href='#dlmForecast'><p>Prediction and simulation of future observations</p></a></li>
<li><a href='#dlmGibbsDIG'><p>Gibbs sampling for d-inverse-gamma model</p></a></li>
<li><a href='#dlmLL'><p>Log likelihood evaluation for a state space model</p></a></li>
<li><a href='#dlmMLE'><p>Parameter estimation by maximum likelihood</p></a></li>
<li><a href='#dlmModARMA'><p>Create a DLM representation of an ARMA process</p></a></li>
<li><a href='#dlmModPoly'><p>Create an n-th order polynomial DLM</p></a></li>
<li><a href='#dlmModReg'><p>Create a DLM representation of a regression model</p></a></li>
<li><a href='#dlmModSeas'><p>Create a DLM for seasonal factors</p></a></li>
<li><a href='#dlmModTrig'><p>Create Fourier representation of a periodic DLM component</p></a></li>
<li><a href='#dlmRandom'><p>Random DLM</p></a></li>
<li><a href='#dlmSmooth'><p>DLM smoothing</p></a></li>
<li><a href='#dlmSum'><p>Outer sum of Dynamic Linear Models</p></a></li>
<li><a href='#dlmSvd2var'><p>Compute a nonnegative definite matrix from its</p>
Singular Value Decomposition</a></li>
<li><a href='#dropFirst'><p>Drop the first element of a vector or matrix</p></a></li>
<li><a href='#FF'><p>Components of a dlm object</p></a></li>
<li><a href='#mcmc'><p>Utility functions for MCMC output analysis</p></a></li>
<li><a href='#NelPlo'><p>Nelson-Plosser macroeconomic time series</p></a></li>
<li><a href='#residuals.dlmFiltered'><p>One-step forecast errors</p></a></li>
<li><a href='#rwishart'><p>Random Wishart matrix</p></a></li>
<li><a href='#USecon'><p>US macroeconomic time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian and Likelihood Analysis of Dynamic Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-12</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods, grDevices, graphics</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanni Petris &lt;GPetris@uark.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides routines for Maximum likelihood,
    Kalman filtering and smoothing, and Bayesian
    analysis of Normal linear State Space models, also known as 
    Dynamic Linear Models. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-21 08:09:52 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanni Petris [aut, cre],
  Wally Gilks [ctb] (Author of original C code for ARMS)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-21 08:15:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='arms'>Function to perform Adaptive Rejection Metropolis Sampling</h2><span id='topic+arms'></span>

<h3>Description</h3>

<p>Generates a sequence of random variables using ARMS. For multivariate densities, 
ARMS is used along randomly selected straight lines through the current point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arms(y.start, myldens, indFunc, n.sample, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arms_+3A_y.start">y.start</code></td>
<td>
<p>initial point</p>
</td></tr>
<tr><td><code id="arms_+3A_myldens">myldens</code></td>
<td>
<p>univariate or multivariate log target density</p>
</td></tr>
<tr><td><code id="arms_+3A_indfunc">indFunc</code></td>
<td>
<p>indicator function of the convex support of the target density</p>
</td></tr>
<tr><td><code id="arms_+3A_n.sample">n.sample</code></td>
<td>
<p>desired sample size</p>
</td></tr>
<tr><td><code id="arms_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>myldens</code> and <code>indFunc</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strictly speaking, the support of the target density must be a bounded convex set. 
When this is not the case, the following tricks usually work.
If the support is not bounded, restrict it to a bounded set having probability 
practically one. 
A workaround, if the support is not convex, is to consider the convex set 
generated by the support 
and define <code>myldens</code> to return <code>log(.Machine$double.xmin)</code> outside
the true support (see the last example.)
</p>
<p>The next point is generated along a randomly selected line through the current
point using arms.
</p>
<p>Make sure the value returned by <code>myldens</code> is never smaller than
<code>log(.Machine$double.xmin)</code>, to avoid divisions by zero.
</p>


<h3>Value</h3>

<p>An <code>n.sample</code> by <code>length(y.start)</code> matrix, whose rows are the 
sampled points.
</p>


<h3>Note</h3>

<p>The function is based on original C code by W. Gilks for the 
univariate case.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Gilks, W.R., Best, N.G. and Tan, K.K.C. (1995)
Adaptive rejection Metropolis sampling within Gibbs sampling
(Corr: 97V46 p541-542 with Neal, R.M.), <em>Applied Statistics</em>
<b>44</b>:455&ndash;472.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### ==&gt; Warning: running the examples may take a few minutes! &lt;== ####    

set.seed(4521222)
### Univariate densities
## Unif(-r,r) 
y &lt;- arms(runif(1,-1,1), function(x,r) 1, function(x,r) (x&gt;-r)*(x&lt;r), 5000, r=2)
summary(y); hist(y,prob=TRUE,main="Unif(-r,r); r=2")
## Normal(mean,1)
norldens &lt;- function(x,mean) -(x-mean)^2/2 
y &lt;- arms(runif(1,3,17), norldens, function(x,mean) ((x-mean)&gt;-7)*((x-mean)&lt;7),
          5000, mean=10)
summary(y); hist(y,prob=TRUE,main="Gaussian(m,1); m=10")
curve(dnorm(x,mean=10),3,17,add=TRUE)
## Exponential(1)
y &lt;- arms(5, function(x) -x, function(x) (x&gt;0)*(x&lt;70), 5000)
summary(y); hist(y,prob=TRUE,main="Exponential(1)")
curve(exp(-x),0,8,add=TRUE)
## Gamma(4.5,1) 
y &lt;- arms(runif(1,1e-4,20), function(x) 3.5*log(x)-x,
          function(x) (x&gt;1e-4)*(x&lt;20), 5000)
summary(y); hist(y,prob=TRUE,main="Gamma(4.5,1)")
curve(dgamma(x,shape=4.5,scale=1),1e-4,20,add=TRUE)
## Gamma(0.5,1) (this one is not log-concave)
y &lt;- arms(runif(1,1e-8,10), function(x) -0.5*log(x)-x,
          function(x) (x&gt;1e-8)*(x&lt;10), 5000)
summary(y); hist(y,prob=TRUE,main="Gamma(0.5,1)")
curve(dgamma(x,shape=0.5,scale=1),1e-8,10,add=TRUE)
## Beta(.2,.2) (this one neither)
y &lt;- arms(runif(1), function(x) (0.2-1)*log(x)+(0.2-1)*log(1-x),
          function(x) (x&gt;1e-5)*(x&lt;1-1e-5), 5000)
summary(y); hist(y,prob=TRUE,main="Beta(0.2,0.2)")
curve(dbeta(x,0.2,0.2),1e-5,1-1e-5,add=TRUE)
## Triangular
y &lt;- arms(runif(1,-1,1), function(x) log(1-abs(x)), function(x) abs(x)&lt;1, 5000)     
summary(y); hist(y,prob=TRUE,ylim=c(0,1),main="Triangular")
curve(1-abs(x),-1,1,add=TRUE)
## Multimodal examples (Mixture of normals)
lmixnorm &lt;- function(x,weights,means,sds) {
    log(crossprod(weights, exp(-0.5*((x-means)/sds)^2 - log(sds))))
}
y &lt;- arms(0, lmixnorm, function(x,...) (x&gt;(-100))*(x&lt;100), 5000, weights=c(1,3,2),
          means=c(-10,0,10), sds=c(1.5,3,1.5))
summary(y); hist(y,prob=TRUE,main="Mixture of Normals")
curve(colSums(c(1,3,2)/6*dnorm(matrix(x,3,length(x),byrow=TRUE),c(-10,0,10),c(1.5,3,1.5))),
      par("usr")[1], par("usr")[2], add=TRUE)

### Bivariate densities 
## Bivariate standard normal
y &lt;- arms(c(0,2), function(x) -crossprod(x)/2,
          function(x) (min(x)&gt;-5)*(max(x)&lt;5), 500)
plot(y, main="Bivariate standard normal", asp=1)
## Uniform in the unit square
y &lt;- arms(c(0.2,.6), function(x) 1,
          function(x) (min(x)&gt;0)*(max(x)&lt;1), 500)
plot(y, main="Uniform in the unit square", asp=1)
polygon(c(0,1,1,0),c(0,0,1,1))
## Uniform in the circle of radius r
y &lt;- arms(c(0.2,0), function(x,...) 1,
          function(x,r2) sum(x^2)&lt;r2, 500, r2=2^2)
plot(y, main="Uniform in the circle of radius r; r=2", asp=1)
curve(-sqrt(4-x^2), -2, 2, add=TRUE)
curve(sqrt(4-x^2), -2, 2, add=TRUE)
## Uniform on the simplex
simp &lt;- function(x) if ( any(x&lt;0) || (sum(x)&gt;1) ) 0 else 1
y &lt;- arms(c(0.2,0.2), function(x) 1, simp, 500)
plot(y, xlim=c(0,1), ylim=c(0,1), main="Uniform in the simplex", asp=1)
polygon(c(0,1,0), c(0,0,1))
## A bimodal distribution (mixture of normals)
bimodal &lt;- function(x) { log(prod(dnorm(x,mean=3))+prod(dnorm(x,mean=-3))) }
y &lt;- arms(c(-2,2), bimodal, function(x) all(x&gt;(-10))*all(x&lt;(10)), 500)
plot(y, main="Mixture of bivariate Normals", asp=1)

## A bivariate distribution with non-convex support
support &lt;- function(x) {
    return(as.numeric( -1 &lt; x[2] &amp;&amp; x[2] &lt; 1 &amp;&amp;
                      -2 &lt; x[1] &amp;&amp;
                      ( x[1] &lt; 1 || crossprod(x-c(1,0)) &lt; 1 ) ) )
}
Min.log &lt;- log(.Machine$double.xmin) + 10
logf &lt;- function(x) {
    if ( x[1] &lt; 0 ) return(log(1/4))
    else
        if (crossprod(x-c(1,0)) &lt; 1 ) return(log(1/pi))
    return(Min.log)
}
x &lt;- as.matrix(expand.grid(seq(-2.2,2.2,length=40),seq(-1.1,1.1,length=40)))
y &lt;- sapply(1:nrow(x), function(i) support(x[i,]))
plot(x,type='n',asp=1)
points(x[y==1,],pch=1,cex=1,col='green')
z &lt;- arms(c(0,0), logf, support, 1000)
points(z,pch=20,cex=0.5,col='blue')
polygon(c(-2,0,0,-2),c(-1,-1,1,1))
curve(-sqrt(1-(x-1)^2),0,2,add=TRUE)
curve(sqrt(1-(x-1)^2),0,2,add=TRUE)
sum( z[,1] &lt; 0 ) # sampled points in the square
sum( apply(t(z)-c(1,0),2,crossprod) &lt; 1 ) # sampled points in the circle

</code></pre>

<hr>
<h2 id='ARtransPars'>Function to parametrize a stationary AR process</h2><span id='topic+ARtransPars'></span>

<h3>Description</h3>


<p>The function maps a vector of length p to the vector of autoregressive
coefficients of a stationary AR(p) process. It can be used to
parametrize a stationary AR(p) process 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARtransPars(raw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARtransPars_+3A_raw">raw</code></td>
<td>
<p>a vector of length p</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first maps each element of <code>raw</code> to (0,1) using
tanh. The numbers obtained are treated as the first partial
autocorrelations of a stationary AR(p) process and the vector of the
corresponding autoregressive coefficients is computed and returned.
</p>


<h3>Value</h3>

<p>The vector of autoregressive coefficients of a stationary AR(p) process
corresponding to the parameters in <code>raw</code>. 
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris, <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Jones, 1987. Randomly choosing parameters from the
stationarity and invertibility region of autoregressive-moving average
models. <em>Applied Statistics</em>, 36.</p>


<h3>Examples</h3>

<pre><code class='language-R'>(ar &lt;- ARtransPars(rnorm(5)))
all( Mod(polyroot(c(1,-ar))) &gt; 1 ) # TRUE
</code></pre>

<hr>
<h2 id='bdiag'>Build a block diagonal matrix</h2><span id='topic+bdiag'></span>

<h3>Description</h3>

<p>The function builds a block diagonal matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiag(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bdiag_+3A_...">...</code></td>
<td>
<p>individual matrices, or a list of matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix obtained by combining the arguments.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>bdiag(matrix(1:4,2,2),diag(3))
bdiag(matrix(1:6,3,2),matrix(11:16,2,3))
</code></pre>

<hr>
<h2 id='convex.bounds'>Find the boundaries of a convex set</h2><span id='topic+convex.bounds'></span>

<h3>Description</h3>

<p>Finds the boundaries of a bounded convex set along a specified 
straight line, using a bisection approach. It is mainly intended for 
use within <code><a href="#topic+arms">arms</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convex.bounds(x, dir, indFunc, ..., tol=1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convex.bounds_+3A_x">x</code></td>
<td>
<p>a point within the set</p>
</td></tr>
<tr><td><code id="convex.bounds_+3A_dir">dir</code></td>
<td>
<p>a vector specifying a direction</p>
</td></tr>
<tr><td><code id="convex.bounds_+3A_indfunc">indFunc</code></td>
<td>
<p>indicator function of the set</p>
</td></tr>
<tr><td><code id="convex.bounds_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>indFunc</code></p>
</td></tr>
<tr><td><code id="convex.bounds_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a bisection algorithm along a line having parametric representation
<code>x + t * dir</code>.
</p>


<h3>Value</h3>

<p>A vector <code>ans</code> of length two. The boundaries of the set are
<code>x + ans[1] * dir</code> and <code>x + ans[2] * dir</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## boundaries of a unit circle
convex.bounds(c(0,0), c(1,1), indFunc=function(x) crossprod(x)&lt;1)
</code></pre>

<hr>
<h2 id='dlm'>dlm objects</h2><span id='topic+dlm'></span><span id='topic+as.dlm'></span><span id='topic+is.dlm'></span>

<h3>Description</h3>

<p>The function <code>dlm</code> is used to create Dynamic Linear Model objects.
<code>as.dlm</code> and <code>is.dlm</code> coerce an object to a Dynamic Linear
Model object and test whether an object is a Dynamic Linear Model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlm(...)
as.dlm(obj)
is.dlm(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlm_+3A_...">...</code></td>
<td>
<p>list with named elements <code>m0</code>,
<code>C0</code>, <code>FF</code>, <code>V</code>, <code>GG</code>, <code>W</code> and,
optionally, 
<code>JFF</code>, <code>JV</code>, <code>JGG</code>, <code>JW</code>, and
<code>X</code>. The first six are the usual vector and matrices that define
a time-invariant DLM. The remaining elements are used for time-varying
DLM. <code>X</code>, if present, should be a matrix. If <code>JFF</code> is not
<code>NULL</code>, then it must be a matrix of the 
same dimension of <code>FF</code>, with the <code class="reqn">(i,j)</code> element being zero if
<code>FF[i,j]</code> is time-invariant, and a positive integer <code class="reqn">k</code>
otherwise. In this case the <code class="reqn">(i,j)</code> element of <code>FF</code> at time
<code class="reqn">t</code> will be <code>X[t,k]</code>. A similar interpretation holds for
<code>JV</code>, <code>JGG</code>, and <code>JW</code>. <code>...</code> may have additional
components, that are not used by <code>dlm</code>. The named components
may also be passed to the function as individual arguments.</p>
</td></tr>     
<tr><td><code id="dlm_+3A_obj">obj</code></td>
<td>
<p>an arbitrary <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>dlm</code> is used to create Dynamic Linear Model
objects. These are lists with the named elements described above and
with class of <code>"dlm"</code>. 
</p>
<p>Class <code>"dlm"</code> has a number of methods. In particular, consistent
DLM can be added together to produce another DLM.
</p>


<h3>Value</h3>

<p>For <code>dlm</code>, an object of class <code>"dlm"</code>.</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).<br />
West and Harrison, Bayesian forecasting and
dynamic models (2nd ed.), Springer (1997).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmModReg">dlmModReg</a></code>, <code><a href="#topic+dlmModPoly">dlmModPoly</a></code>,
<code><a href="#topic+dlmModARMA">dlmModARMA</a></code>, <code><a href="#topic+dlmModSeas">dlmModSeas</a></code>, to create
particular objects of class <code>"dlm"</code>.   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Linear regression as a DLM
x &lt;- matrix(rnorm(10),nc=2)
mod &lt;- dlmModReg(x)
is.dlm(mod)

## Adding dlm's
dlmModPoly() + dlmModSeas(4) # linear trend plus quarterly seasonal component
</code></pre>

<hr>
<h2 id='dlmBSample'>Draw from the posterior distribution of the state vectors</h2><span id='topic+dlmBSample'></span>

<h3>Description</h3>

<p>The function simulates one draw from the posterior distribution
of the state vectors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmBSample(modFilt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmBSample_+3A_modfilt">modFilt</code></td>
<td>

<p>a list, typically the ouptut from <code>dlmFilter</code>, with elements
<code>m</code>, <code>U.C</code>, <code>D.C</code>, <code>a</code>, <code>U.R</code>, <code>D.R</code> (see
the value returned by <code>dlmFilter</code>), and <code>mod</code> The latter is an
object of class <code>"dlm"</code> or a list with elements <code>GG</code>, <code>W</code>
and, optionally, <code>JGG</code>, <code>JW</code>, and <code>X</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculations are based on singular value decomposition.
</p>


<h3>Value</h3>

<p>The function returns a draw from the posterior distribution 
of the state vectors. If <code>m</code> is a time series then the returned 
value is a time series with the same <code>tsp</code>, otherwise it is 
a matrix or vector.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).<br />
West and Harrison, Bayesian forecasting and
dynamic models (2nd ed.), Springer (1997).
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+dlmFilter">dlmFilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nileMod &lt;- dlmModPoly(1, dV = 15099.8, dW = 1468.4)
nileFilt &lt;- dlmFilter(Nile, nileMod)
nileSmooth &lt;- dlmSmooth(nileFilt) # estimated "true" level
plot(cbind(Nile, nileSmooth$s[-1]), plot.type = "s",
     col = c("black", "red"), ylab = "Level",
     main = "Nile river", lwd = c(2, 2)) 
for (i in 1:10) # 10 simulated "true" levels 
    lines(dlmBSample(nileFilt[-1]), lty=2) 
</code></pre>

<hr>
<h2 id='dlmFilter'>DLM filtering</h2><span id='topic+dlmFilter'></span>

<h3>Description</h3>

<p>The functions applies Kalman filter to compute filtered
values of the state vectors, together with their
variance/covariance matrices. By default the function returns an object 
of class <code>"dlmFiltered"</code>. Methods for <code>residuals</code> and <code>tsdiag</code> 
for objects of class <code>"dlmFiltered"</code> exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmFilter(y, mod, debug = FALSE, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmFilter_+3A_y">y</code></td>
<td>
<p>the data. <code>y</code> can be a vector, a matrix, a univariate or
multivariate time series.</p>
</td></tr>
<tr><td><code id="dlmFilter_+3A_mod">mod</code></td>
<td>
<p>an object of class <code>dlm</code>, or a list with components
<code>m0</code>, <code>C0</code>, 
<code>FF</code>, <code>V</code>, <code>GG</code>, <code>W</code>, and optionally <code>JFF</code>,
<code>JV</code>, <code>JGG</code>, <code>JW</code>, and <code>X</code>, defining the model
and the parameters of the prior distribution.</p>
</td></tr>
<tr><td><code id="dlmFilter_+3A_debug">debug</code></td>
<td>
<p>if <code>FALSE</code>, faster C code will be used, otherwise
all the computations will be performed in R.</p>
</td></tr>
<tr><td><code id="dlmFilter_+3A_simplify">simplify</code></td>
<td>
<p>should the data be included in the output?</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The calculations are based on the singular value decomposition (SVD)
of the relevant matrices. Variance matrices are returned in terms of
their SVD.
</p>
<p>Missing values are allowed in <code>y</code>.
</p>


<h3>Value</h3>


<p>A list with the components described below. If <code>simplify</code> is 
<code>FALSE</code>, the returned list has class <code>"dlmFiltered"</code>. 
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>The input data, coerced to a matrix. This is present only if 
<code>simplify</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p>The argument <code>mod</code> (possibly simplified).</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Time series (or matrix) of filtered values of the state vectors.
The series starts one time unit before the first observation.</p>
</td></tr>
<tr><td><code>U.C</code></td>
<td>
<p>See below.</p>
</td></tr>
<tr><td><code>D.C</code></td>
<td>
<p>Together with <code>U.C</code>, it gives the SVD
of the variances of the estimation errors.
The variance of <code class="reqn">m[t,]-theta[t,]</code> is given by
<code>U.C[[t]] %*% diag(D.C[t,]^2) %*% t(U.C[[t]])</code>.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>Time series (or matrix) of predicted values of the state vectors
given the observations up and including the previous time unit.</p>
</td></tr>
<tr><td><code>U.R</code></td>
<td>
<p>See below.</p>
</td></tr>
<tr><td><code>D.R</code></td>
<td>
<p>Together with <code>U.R</code>, it gives the SVD
of the variances of the prediction errors.
The variance of <code class="reqn">a[t,]-theta[t,]</code> is given by
<code>U.R[[t]] %*% diag(D.R[t,]^2) %*% t(U.R[[t]])</code>.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Time series (or matrix) of one-step-ahead forecast of the
observations.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The observation variance <code>V</code> in <code>mod</code> must be nonsingular.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Zhang, Y. and Li, X.R., Fixed-interval smoothing algorithm
based on singular value decomposition, <em>Proceedings of the 1996
IEEE International Conference on Control Applications</em>.<br />
Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with R,
Springer (2009).   
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+dlm">dlm</a></code> for a description of dlm objects,
<code><a href="#topic+dlmSvd2var">dlmSvd2var</a></code> to obtain a variance matrix from its SVD,
<code><a href="#topic+dlmMLE">dlmMLE</a></code> for maximum likelihood estimation, 
<code><a href="#topic+dlmSmooth">dlmSmooth</a></code> for Kalman smoothing, and
<code><a href="#topic+dlmBSample">dlmBSample</a></code> for drawing from the posterior distribution
of the state vectors.</p>


<h3>Examples</h3>

<pre><code class='language-R'>nileBuild &lt;- function(par) {
  dlmModPoly(1, dV = exp(par[1]), dW = exp(par[2]))
}
nileMLE &lt;- dlmMLE(Nile, rep(0,2), nileBuild); nileMLE$conv
nileMod &lt;- nileBuild(nileMLE$par)
V(nileMod)
W(nileMod)
nileFilt &lt;- dlmFilter(Nile, nileMod)
nileSmooth &lt;- dlmSmooth(nileFilt)
plot(cbind(Nile, nileFilt$m[-1], nileSmooth$s[-1]), plot.type='s',
     col=c("black","red","blue"), ylab="Level", main="Nile river", lwd=c(1,2,2))
</code></pre>

<hr>
<h2 id='dlmForecast'>Prediction and simulation of future observations</h2><span id='topic+dlmForecast'></span>

<h3>Description</h3>

<p>The function evaluates the expected value and variance of future
observations and system states. It can also generate a sample from the
distribution of future observations and system states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dlmForecast(mod, nAhead = 1, method = c("plain", "svd"), sampleNew = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmForecast_+3A_mod">mod</code></td>
<td>
<p>an object of class <code>"dlm"</code>, or a list with components
<code>m0</code>, <code>C0</code>,
<code>FF</code>, <code>V</code>, <code>GG</code>, and <code>W</code>, defining the model
and the parameters of the prior distribution. <code>mod</code> can also be
an object of class <code>"dlmFiltered"</code>, such as the output from
<code>dlmFilter</code>.</p>
</td></tr>
<tr><td><code id="dlmForecast_+3A_nahead">nAhead</code></td>
<td>
<p>number of steps ahead for which a forecast is
requested.</p>
</td></tr>
<tr><td><code id="dlmForecast_+3A_method">method</code></td>
<td>
<p><code>method="svd"</code> uses singular value decomposition
for the calculations. Currently, only <code>method="plain"</code>
is implemented.</p>
</td></tr>
<tr><td><code id="dlmForecast_+3A_samplenew">sampleNew</code></td>
<td>
<p>if <code>sampleNew=n</code> for an integer <code>n</code>, them a
sample of size <code>n</code> from the forecast distribution of states and
observables will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>a</code></td><td style="text-align: left;"> matrix of expected values of future states</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>R</code></td><td style="text-align: left;"> list of variances of future states</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>f</code></td><td style="text-align: left;"> matrix of expected values of future observations</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Q</code></td><td style="text-align: left;"> list of variances of future observations</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>newStates</code></td><td style="text-align: left;"> list of matrices containing the simulated
    future values</td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> of the states. Each component of the list corresponds</td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> to one simulation.</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>newObs</code></td><td style="text-align: left;"> same as <code>newStates</code>, but for the observations.
  </td>
</tr>

</table>

<p>The last two components are not present if <code>sampleNew=FALSE</code>.
</p>


<h3>Note</h3>

<p>The function is currently entirely written in <span class="rlang"><b>R</b></span> and is not
particularly fast. Currently, only constant models are allowed. 
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Comparing theoretical prediction intervals with sample quantiles
set.seed(353)
n &lt;- 20; m &lt;- 1; p &lt;- 5
mod &lt;- dlmModPoly() + dlmModSeas(4, dV=0)
W(mod) &lt;- rwishart(2*p,p) * 1e-1
m0(mod) &lt;- rnorm(p, sd=5)
C0(mod) &lt;- diag(p) * 1e-1
new &lt;- 100
fore &lt;- dlmForecast(mod, nAhead=n, sampleNew=new)
ciTheory &lt;- (outer(sapply(fore$Q, FUN=function(x) sqrt(diag(x))), qnorm(c(0.1,0.9))) +
             as.vector(t(fore$f)))
ciSample &lt;- t(apply(array(unlist(fore$newObs), dim=c(n,m,new))[,1,], 1,
                    FUN=function(x) quantile(x, c(0.1,0.9))))
plot.ts(cbind(ciTheory,fore$f[,1]),plot.type="s", col=c("red","red","green"),ylab="y")
for (j in 1:2) lines(ciSample[,j], col="blue")
legend(2,-40,legend=c("forecast mean", "theoretical bounds", "Monte Carlo bounds"),
       col=c("green","red","blue"), lty=1, bty="n")
</code></pre>

<hr>
<h2 id='dlmGibbsDIG'>Gibbs sampling for d-inverse-gamma model</h2><span id='topic+dlmGibbsDIG'></span>

<h3>Description</h3>

<p>The function implements a Gibbs sampler for a univariate DLM
having one or more unknown variances in its specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmGibbsDIG(y, mod, a.y, b.y, a.theta, b.theta, shape.y, rate.y,
            shape.theta, rate.theta, n.sample = 1,
            thin = 0, ind, save.states = TRUE,
            progressBar = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmGibbsDIG_+3A_y">y</code></td>
<td>
<p>data vector or univariate time series</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_mod">mod</code></td>
<td>
<p>a dlm for univariate observations</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_a.y">a.y</code></td>
<td>
<p>prior mean of observation precision</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_b.y">b.y</code></td>
<td>
<p>prior variance of observation precision</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_a.theta">a.theta</code></td>
<td>
<p>prior mean of system precisions (recycled, if needed)</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_b.theta">b.theta</code></td>
<td>
<p>prior variance of system precisions (recycled, if needed)</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_shape.y">shape.y</code></td>
<td>
<p>shape parameter of the prior of observation precision</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_rate.y">rate.y</code></td>
<td>
<p>rate parameter of the prior of observation precision</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_shape.theta">shape.theta</code></td>
<td>
<p>shape parameter of the prior of system precisions (recycled, if needed)</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_rate.theta">rate.theta</code></td>
<td>
<p>rate parameter of the prior of system precisions (recycled, if needed)</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_n.sample">n.sample</code></td>
<td>
<p>requested number of Gibbs iterations</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_thin">thin</code></td>
<td>
<p>discard <code>thin</code> iterations for every saved iteration</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_ind">ind</code></td>
<td>
<p>indicator of the system variances that need to be estimated</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_save.states">save.states</code></td>
<td>
<p>should the simulated states be included in the output?</p>
</td></tr>
<tr><td><code id="dlmGibbsDIG_+3A_progressbar">progressBar</code></td>
<td>
<p>should a text progress bar be displayed during execution?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>d-inverse-gamma</em> model is a constant univariate DLM with unknown
observation variance, diagonal system variance with unknown diagonal
entries.  Some of these entries may be known, in which case they are
typically zero.  Independent inverse gamma priors are assumed for the
unknown variances.  These can be specified be mean and variance or,
alternatively, by shape and rate.  Recycling is applied for the prior
parameters of unknown system variances.  The argument <code>ind</code> can
be used to specify the index of the unknown system variances, in case
some of the diagonal elements of <code>W</code> are known.  The unobservable
states are generated in the Gibbs sampler and are returned if
<code>save.states = TRUE</code>.  For more details on the model and usage
examples, see the package vignette. 
</p>


<h3>Value</h3>

<p>The function returns a list of simulated values.
</p>
<table role = "presentation">
<tr><td><code>dV</code></td>
<td>
<p>simulated values of the observation variance.</p>
</td></tr>
<tr><td><code>dW</code></td>
<td>
<p>simulated values of the unknown diagonal elements of the
system variance.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>simulated values of the state vectors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the package vignette for an example
</code></pre>

<hr>
<h2 id='dlmLL'>Log likelihood evaluation for a state space model</h2><span id='topic+dlmLL'></span>

<h3>Description</h3>

<p>Function that computes the log likelihood of a state space model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmLL(y, mod, debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmLL_+3A_y">y</code></td>
<td>
<p>a vector, matrix, or time series of data.</p>
</td></tr>
<tr><td><code id="dlmLL_+3A_mod">mod</code></td>
<td>
<p>an object of class <code>"dlm"</code>, or a list with components
<code>m0</code>, <code>C0</code>, 
<code>FF</code>, <code>V</code>, <code>GG</code>, <code>W</code> defining the model
and the parameters of the prior distribution.</p>
</td></tr> 
<tr><td><code id="dlmLL_+3A_debug">debug</code></td>
<td>
<p>if <code>debug=TRUE</code>, the function uses R code, otherwise
it uses faster C code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculations are based on singular value decomposition.
Missing values are allowed in <code>y</code>.
</p>


<h3>Value</h3>

<p>The function returns the negative of the loglikelihood.
</p>


<h3>Warning</h3>

<p>The observation variance <code>V</code> in <code>mod</code> must be nonsingular.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Durbin and Koopman, Time series analysis by state space
methods, Oxford University Press, 2001.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmMLE">dlmMLE</a></code>, <code><a href="#topic+dlmFilter">dlmFilter</a></code> for the definition of 
the equations of the model.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- See the examples for dlmMLE ----
</code></pre>

<hr>
<h2 id='dlmMLE'>Parameter estimation by maximum likelihood</h2><span id='topic+dlmMLE'></span>

<h3>Description</h3>

<p>The function returns the MLE of unknown parameters in the specification of 
a state space model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmMLE(y, parm, build, method = "L-BFGS-B", ..., debug = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmMLE_+3A_y">y</code></td>
<td>
<p>a vector, matrix, or time series of data.</p>
</td></tr>
<tr><td><code id="dlmMLE_+3A_parm">parm</code></td>
<td>
<p>vector of initial values - for the optimization routine -
of the unknown parameters.</p>
</td></tr> 
<tr><td><code id="dlmMLE_+3A_build">build</code></td>
<td>
<p>a function that takes a vector of the same length as
<code>parm</code> and returns an object of class dlm, or a list that may
be interpreted as such.</p>
</td></tr>
<tr><td><code id="dlmMLE_+3A_method">method</code></td>
<td>
<p>passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="dlmMLE_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>optim</code> and
<code>build</code>.</p>
</td></tr>
<tr><td><code id="dlmMLE_+3A_debug">debug</code></td>
<td>
<p>if <code>debug=TRUE</code>, the likelihood calculations are done
entirely in R, otherwise C functions are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The evaluation of the loglikelihood is done by <code>dlmLL</code>. 
For the optimization, <code>optim</code> is called. It is possible for the
model to depend on additional parameters, other than those in
<code>parm</code>, passed to <code>build</code> via the <code>...</code> argument.
</p>


<h3>Value</h3>

<p>The function <code>dlmMLE</code> returns the value returned by <code>optim</code>.
</p>


<h3>Warning</h3>

<p>The <code>build</code> argument must return a dlm with nonsingular
observation variance <code>V</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmLL">dlmLL</a></code>, <code><a href="#topic+dlm">dlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NelPlo)
### multivariate local level -- seemingly unrelated time series
buildSu &lt;- function(x) {
  Vsd &lt;- exp(x[1:2])
  Vcorr &lt;- tanh(x[3])
  V &lt;- Vsd %o% Vsd
  V[1,2] &lt;- V[2,1] &lt;- V[1,2] * Vcorr
  Wsd &lt;- exp(x[4:5])
  Wcorr &lt;- tanh(x[6])
  W &lt;- Wsd %o% Wsd
  W[1,2] &lt;- W[2,1] &lt;- W[1,2] * Wcorr
  return(list(
              m0 = rep(0,2),
              C0 = 1e7 * diag(2),
              FF = diag(2),
              GG = diag(2),
              V = V,
              W = W))
}

suMLE &lt;- dlmMLE(NelPlo, rep(0,6), buildSu); suMLE
buildSu(suMLE$par)[c("V","W")]
StructTS(NelPlo[,1], type="level") ## compare with W[1,1] and V[1,1]
StructTS(NelPlo[,2], type="level") ## compare with W[2,2] and V[2,2]

## multivariate local level model with homogeneity restriction
buildHo &lt;- function(x) {
  Vsd &lt;- exp(x[1:2])
  Vcorr &lt;- tanh(x[3])
  V &lt;- Vsd %o% Vsd
  V[1,2] &lt;- V[2,1] &lt;- V[1,2] * Vcorr
  return(list(
              m0 = rep(0,2),
              C0 = 1e7 * diag(2),
              FF = diag(2),
              GG = diag(2),
              V = V,
              W = x[4]^2 * V))
}

hoMLE &lt;- dlmMLE(NelPlo, rep(0,4), buildHo); hoMLE
buildHo(hoMLE$par)[c("V","W")]
</code></pre>

<hr>
<h2 id='dlmModARMA'>Create a DLM representation of an ARMA process</h2><span id='topic+dlmModARMA'></span>

<h3>Description</h3>

<p>The function creates an object of class dlm representing a specified
univariate or multivariate ARMA process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmModARMA(ar = NULL, ma = NULL, sigma2 = 1, dV, m0, C0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmModARMA_+3A_ar">ar</code></td>
<td>
<p>a vector or a list of matrices (in the multivariate case)
containing the autoregressive coefficients.</p>
</td></tr>
<tr><td><code id="dlmModARMA_+3A_ma">ma</code></td>
<td>
<p>a vector or a list of matrices (in the multivariate case)
containing the moving average coefficients.</p>
</td></tr>
<tr><td><code id="dlmModARMA_+3A_sigma2">sigma2</code></td>
<td>
<p>the variance (or variance matrix) of the innovations.</p>
</td></tr>
<tr><td><code id="dlmModARMA_+3A_dv">dV</code></td>
<td>
<p>the variance, or the diagonal elements of the variance
matrix in the multivariate case, of the observation noise. <code>V</code>
is assumed to be diagonal and it defaults to zero.</p>
</td></tr>
<tr><td><code id="dlmModARMA_+3A_m0">m0</code></td>
<td>
<p><code class="reqn">m_0</code>, the expected value of the pre-sample state vector.</p>
</td></tr>
<tr><td><code id="dlmModARMA_+3A_c0">C0</code></td>
<td>
<p><code class="reqn">C_0</code>, the variance matrix of the pre-sample state vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned DLM only gives one of the many possible representations
of an ARMA process. 
</p>


<h3>Value</h3>

<p>The function returns an object of class dlm representing the ARMA
model specified by <code>ar</code>, <code>ma</code>, and <code>sigma2</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).<br />
Durbin and Koopman, Time series analysis by state space 
methods, Oxford University Press, 2001.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmModPoly">dlmModPoly</a></code>, <code><a href="#topic+dlmModSeas">dlmModSeas</a></code>,
<code><a href="#topic+dlmModReg">dlmModReg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## ARMA(2,3)
dlmModARMA(ar = c(.5,.1), ma = c(.4,2,.3), sigma2=1)
## Bivariate ARMA(2,1)
dlmModARMA(ar = list(matrix(1:4,2,2), matrix(101:104,2,2)),
           ma = list(matrix(-4:-1,2,2)), sigma2 = diag(2))
</code></pre>

<hr>
<h2 id='dlmModPoly'>Create an n-th order polynomial DLM</h2><span id='topic+dlmModPoly'></span>

<h3>Description</h3>

<p>The function creates an <code class="reqn">n</code>th order polynomial DLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmModPoly(order = 2, dV = 1, dW = c(rep(0, order - 1), 1),
           m0 = rep(0, order), C0 = 1e+07 * diag(nrow = order)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmModPoly_+3A_order">order</code></td>
<td>
<p>order of the polynomial model. The default
corresponds to a stochastic linear trend.</p>
</td></tr>
<tr><td><code id="dlmModPoly_+3A_dv">dV</code></td>
<td>
<p>variance of the observation noise.</p>
</td></tr>
<tr><td><code id="dlmModPoly_+3A_dw">dW</code></td>
<td>
<p>diagonal elements of the variance matrix of the system noise.</p>
</td></tr>
<tr><td><code id="dlmModPoly_+3A_m0">m0</code></td>
<td>
<p><code class="reqn">m_0</code>, the expected value of the pre-sample state vector.</p>
</td></tr>
<tr><td><code id="dlmModPoly_+3A_c0">C0</code></td>
<td>
<p><code class="reqn">C_0</code>, the variance matrix of the pre-sample state vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class dlm representing the required n-th order
polynomial model.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).<br />
West and Harrison, Bayesian forecasting and dynamic models
(2nd ed.), Springer, 1997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmModARMA">dlmModARMA</a></code>, <code><a href="#topic+dlmModReg">dlmModReg</a></code>,
<code><a href="#topic+dlmModSeas">dlmModSeas</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## the default
dlmModPoly()
## random walk plus noise
dlmModPoly(1, dV = .3, dW = .01)
</code></pre>

<hr>
<h2 id='dlmModReg'>Create a DLM representation of a regression model</h2><span id='topic+dlmModReg'></span>

<h3>Description</h3>

<p>The function creates a dlm representation of a linear regression
model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmModReg(X, addInt = TRUE, dV = 1, dW = rep(0, NCOL(X) + addInt),
          m0 = rep(0, length(dW)),
          C0 = 1e+07 * diag(nrow = length(dW)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmModReg_+3A_x">X</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="dlmModReg_+3A_addint">addInt</code></td>
<td>
<p>logical: should an intercept be added?</p>
</td></tr>
<tr><td><code id="dlmModReg_+3A_dv">dV</code></td>
<td>
<p>variance of the observation noise.</p>
</td></tr>
<tr><td><code id="dlmModReg_+3A_dw">dW</code></td>
<td>
<p>diagonal elements of the variance matrix of the system noise.</p>
</td></tr>
<tr><td><code id="dlmModReg_+3A_m0">m0</code></td>
<td>
<p><code class="reqn">m_0</code>, the expected value of the pre-sample state vector.</p>
</td></tr>
<tr><td><code id="dlmModReg_+3A_c0">C0</code></td>
<td>
<p><code class="reqn">C_0</code>, the variance matrix of the pre-sample state vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By setting <code>dW</code> equal to a nonzero vector one obtains a DLM
representation of a dynamic regression model. The default value zero
of <code>dW</code> corresponds to standard linear regression. Only
univariate regression is currently covered. 
</p>


<h3>Value</h3>

<p>An object of class dlm representing the specified regression model.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).<br />
West and Harrison, Bayesian forecasting and dynamic models
(2nd ed.), Springer, 1997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmModARMA">dlmModARMA</a></code>, <code><a href="#topic+dlmModPoly">dlmModPoly</a></code>,
<code><a href="#topic+dlmModSeas">dlmModSeas</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(6,4,10), nc = 2); x
dlmModReg(x)
dlmModReg(x, addInt = FALSE)
</code></pre>

<hr>
<h2 id='dlmModSeas'>Create a DLM for seasonal factors</h2><span id='topic+dlmModSeas'></span>

<h3>Description</h3>

<p>The function creates a DLM representation of seasonal component. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmModSeas(frequency, dV = 1, dW = c(1, rep(0, frequency - 2)),
           m0 = rep(0, frequency - 1),
           C0 = 1e+07 * diag(nrow = frequency - 1)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmModSeas_+3A_frequency">frequency</code></td>
<td>
<p>how many seasons?</p>
</td></tr>
<tr><td><code id="dlmModSeas_+3A_dv">dV</code></td>
<td>
<p>variance of the observation noise.</p>
</td></tr>
<tr><td><code id="dlmModSeas_+3A_dw">dW</code></td>
<td>
<p>diagonal elements of the variance matrix of the system noise.</p>
</td></tr>
<tr><td><code id="dlmModSeas_+3A_m0">m0</code></td>
<td>
<p><code class="reqn">m_0</code>, the expected value of the pre-sample state vector.</p>
</td></tr>
<tr><td><code id="dlmModSeas_+3A_c0">C0</code></td>
<td>
<p><code class="reqn">C_0</code>, the variance matrix of the pre-sample state vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class dlm representing a seasonal factor for a process
with <code>frequency</code> seasons.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).<br />
Harvey, Forecasting, structural time series models and the
Kalman filter, Cambridge University Press, 1989.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmModARMA">dlmModARMA</a></code>, <code><a href="#topic+dlmModPoly">dlmModPoly</a></code>,
<code><a href="#topic+dlmModReg">dlmModReg</a></code>, and <code><a href="#topic+dlmModTrig">dlmModTrig</a></code> for the Fourier
representation of a seasonal component.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## seasonal component for quarterly data
dlmModSeas(4, dV = 3.2)
</code></pre>

<hr>
<h2 id='dlmModTrig'>Create Fourier representation of a periodic DLM component</h2><span id='topic+dlmModTrig'></span>

<h3>Description</h3>

<p>The function creates a dlm representing a specified periodic
component. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmModTrig(s, q, om, tau, dV = 1, dW = 0, m0, C0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmModTrig_+3A_s">s</code></td>
<td>
<p>the period, if integer.</p>
</td></tr>
<tr><td><code id="dlmModTrig_+3A_q">q</code></td>
<td>
<p>number of harmonics in the DLM.</p>
</td></tr>
<tr><td><code id="dlmModTrig_+3A_om">om</code></td>
<td>
<p>the frequency.</p>
</td></tr>
<tr><td><code id="dlmModTrig_+3A_tau">tau</code></td>
<td>
<p>the period, if not an integer.</p>
</td></tr>
<tr><td><code id="dlmModTrig_+3A_dv">dV</code></td>
<td>
<p>variance of the observation noise.</p>
</td></tr>
<tr><td><code id="dlmModTrig_+3A_dw">dW</code></td>
<td>
<p>a single number expressing the variance of the system noise.</p>
</td></tr>
<tr><td><code id="dlmModTrig_+3A_m0">m0</code></td>
<td>
<p><code class="reqn">m_0</code>, the expected value of the pre-sample state vector.</p>
</td></tr>
<tr><td><code id="dlmModTrig_+3A_c0">C0</code></td>
<td>
<p><code class="reqn">C_0</code>, the variance matrix of the pre-sample state vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The periodic component is specified by one and only one of <code>s</code>,
<code>om</code>, and <code>tau</code>. When <code>s</code> is given, the function
assumes that the period is an integer, while a period specified by
<code>tau</code> is assumed to be noninteger. Instead of <code>tau</code>,
the frequency <code>om</code> can be specified. The argument <code>q</code>
specifies the number of harmonics to include in the model. When
<code>tau</code> or <code>omega</code> is given, then <code>q</code> is required as
well, since in this case the implied Fourier representation has
infinitely many harmonics. On the other hand, if <code>s</code> is given,
<code>q</code> defaults to all the harmonics in the Fourier representation,
that is <code>floor(s/2)</code>.
</p>
<p>The system variance of the resulting dlm is <code>dW</code> times the identity
matrix of the appropriate dimension. 
</p>


<h3>Value</h3>

<p>An object of class dlm, representing a periodic component.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).<br />
West and Harrison, Bayesian forecasting and
dynamic models (2nd ed.), Springer (1997).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmModSeas">dlmModSeas</a></code>, <code><a href="#topic+dlmModARMA">dlmModARMA</a></code>,
<code><a href="#topic+dlmModPoly">dlmModPoly</a></code>, <code><a href="#topic+dlmModReg">dlmModReg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dlmModTrig(s = 3)
dlmModTrig(tau = 3, q = 1) # same thing
dlmModTrig(s = 4) # for quarterly data
dlmModTrig(s = 4, q = 1)
dlmModTrig(tau = 4, q = 2) # a bad idea!
m1 &lt;- dlmModTrig(tau = 6.3, q = 2); m1
m2 &lt;- dlmModTrig(om = 2 * pi / 6.3, q = 2)
all.equal(unlist(m1), unlist(m2))
</code></pre>

<hr>
<h2 id='dlmRandom'>Random DLM</h2><span id='topic+dlmRandom'></span>

<h3>Description</h3>

<p>Generate a random (constant or time-varying) object of class
<code>"dlm"</code>, along with states and observations from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmRandom(m, p, nobs = 0, JFF, JV, JGG, JW)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmRandom_+3A_m">m</code></td>
<td>
<p>dimension of the observation vector.</p>
</td></tr>
<tr><td><code id="dlmRandom_+3A_p">p</code></td>
<td>
<p>dimension of the state vector.</p>
</td></tr>
<tr><td><code id="dlmRandom_+3A_nobs">nobs</code></td>
<td>
<p>number of states and observations to simulate from the model.</p>
</td></tr>
<tr><td><code id="dlmRandom_+3A_jff">JFF</code></td>
<td>
<p>should the model have a time-varying <code>FF</code> component?</p>
</td></tr>
<tr><td><code id="dlmRandom_+3A_jv">JV</code></td>
<td>
<p>should the model have a time-varying <code>V</code> component?</p>
</td></tr>
<tr><td><code id="dlmRandom_+3A_jgg">JGG</code></td>
<td>
<p>should the model have a time-varying <code>GG</code> component?</p>
</td></tr>
<tr><td><code id="dlmRandom_+3A_jw">JW</code></td>
<td>
<p>should the model have a time-varying <code>W</code> component?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates randomly the system and observation matrices and
the variances of a DLM having the specified state and observation
dimension. The system matrix <code>GG</code> is guaranteed to have
eigenvalues strictly less than one, which implies that a constant DLM is
asymptotically stationary. The default behavior is to generate a
constant DLM. If <code>JFF</code> is <code>TRUE</code> then a model for
<code>nobs</code> observations in which all
the elements of <code>FF</code> are time-varying is generated. Similarly
with <code>JV</code>, <code>JGG</code>, and <code>JW</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following components.
</p>
<table role = "presentation">
<tr><td><code>mod</code></td>
<td>
<p>An object of class <code>"dlm"</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Matrix of simulated state vectors from the model.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Matrix of simulated observations from the model.</p>
</td></tr>
</table>
<p>If <code>nobs</code> is zero, only the <code>mod</code> component is returned.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Anderson and Moore, Optimal filtering, Prentice-Hall (1979)</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlm">dlm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dlmRandom(1, 3, 5)
</code></pre>

<hr>
<h2 id='dlmSmooth'>DLM smoothing</h2><span id='topic+dlmSmooth'></span><span id='topic+dlmSmooth.dlmFiltered'></span><span id='topic+dlmSmooth.default'></span>

<h3>Description</h3>

<p>The function apply Kalman smoother to compute 
smoothed values of the state vectors, together with their
variance/covariance matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmSmooth(y, ...)
## Default S3 method:
dlmSmooth(y, mod, ...)
## S3 method for class 'dlmFiltered'
dlmSmooth(y, ..., debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmSmooth_+3A_y">y</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="dlmSmooth_+3A_...">...</code></td>
<td>
<p>futher arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="dlmSmooth_+3A_mod">mod</code></td>
<td>
<p>an object of class <code>"dlm"</code>.</p>
</td></tr>
<tr><td><code id="dlmSmooth_+3A_debug">debug</code></td>
<td>
<p>if <code>debug=FALSE</code>, faster C code will be used, otherwise
all the computations will be performed in R.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The default method returns means and variances of the smoothing
distribution for a data vector (or matrix) <code>y</code> and a model
<code>mod</code>.
</p>
<p><code>dlmSmooth.dlmFiltered</code> produces the same output based on a
<code>dlmFiltered</code> object, typically one produced by a call to
<code>dlmFilter</code>. 
</p>
<p>The calculations are based on the singular value decomposition (SVD)
of the relevant matrices. Variance matrices are returned in terms of
their SVD.
</p>


<h3>Value</h3>


<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>s</code></td>
<td>
<p>Time series (or matrix) of smoothed values of the state
vectors. The series starts one time unit before the first observation.</p>
</td></tr> 
<tr><td><code>U.S</code></td>
<td>
<p>See below.</p>
</td></tr>
<tr><td><code>D.S</code></td>
<td>
<p>Together with <code>U.S</code>, it gives the SVD of the variances
of the smoothing errors.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The observation variance <code>V</code> in <code>mod</code> must be nonsingular.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Zhang, Y. and Li, X.R., Fixed-interval smoothing algorithm
based on singular value decomposition, <em>Proceedings of the 1996
IEEE International Conference on Control Applications</em>.<br />
Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+dlm">dlm</a></code> for a description of dlm objects,
<code><a href="#topic+dlmSvd2var">dlmSvd2var</a></code> to obtain a variance matrix from its SVD,
<code><a href="#topic+dlmFilter">dlmFilter</a></code> for Kalman filtering, 
<code><a href="#topic+dlmMLE">dlmMLE</a></code> for maximum likelihood estimation, and
<code><a href="#topic+dlmBSample">dlmBSample</a></code> for drawing from the posterior distribution
of the state vectors.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s &lt;- dlmSmooth(Nile, dlmModPoly(1, dV = 15100, dW = 1470))
plot(Nile, type ='o')
lines(dropFirst(s$s), col = "red")

## Multivariate
set.seed(2)
tmp &lt;- dlmRandom(3, 5, 20)
obs &lt;- tmp$y
m &lt;- tmp$mod
rm(tmp)

f &lt;- dlmFilter(obs, m)
s &lt;- dlmSmooth(f)
all.equal(s, dlmSmooth(obs, m))
</code></pre>

<hr>
<h2 id='dlmSum'>Outer sum of Dynamic Linear Models</h2><span id='topic+dlmSum'></span><span id='topic++25+2B+25'></span>

<h3>Description</h3>

<p><code>dlmSum</code> creates a unique DLM out of two or more
independent DLMs. <code>%+%</code> is an alias for <code>dlmSum</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmSum(...)
x %+% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmSum_+3A_...">...</code></td>
<td>
<p>any number of objects of class <code>dlm</code>, or a list of
such objects.</p>
</td></tr>
<tr><td><code id="dlmSum_+3A_x">x</code>, <code id="dlmSum_+3A_y">y</code></td>
<td>
<p>objects of class <code>dlm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dlm</code>, representing the outer sum of the
arguments.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- dlmModPoly(2)
m2 &lt;- dlmModPoly(1)
dlmSum(m1, m2)
m1 %+% m2 # same thing
</code></pre>

<hr>
<h2 id='dlmSvd2var'>Compute a nonnegative definite matrix from its
Singular Value Decomposition</h2><span id='topic+dlmSvd2var'></span>

<h3>Description</h3>

<p>The function computes a nonnegative definite matrix from its Singular
Value Decomposition. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmSvd2var(u, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlmSvd2var_+3A_u">u</code></td>
<td>
<p>a square matrix, or a list of square matrices for a
vectorized usage.</p>
</td></tr>
<tr><td><code id="dlmSvd2var_+3A_d">d</code></td>
<td>
<p>a vector, or a matrix for a vectorized usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SVD of a nonnegative definite <code class="reqn">n</code> by <code class="reqn">n</code> square matrix
<code class="reqn">x</code> can be written as <code class="reqn">u d^2 u'</code>, where <code class="reqn">u</code> is an <code class="reqn">n</code>
by <code class="reqn">n</code> orthogonal matrix and <code class="reqn">d</code> is a diagonal matrix. For a
single matrix, the function returns just <code class="reqn">u d^2 u'</code>. Note that the
argument <code>d</code> is a vector containing the diagonal elements of
<code class="reqn">d</code>. For a vectorized usage, <code>u</code> is a list of square
matrices, and <code>d</code> is a matrix. The returned value in this case is
a list of matrices, with the element <code class="reqn">i</code> being <code>u[[i]] %*%
    diag(d[i,]^2) %*% t(u[[i]])</code>. 
</p>


<h3>Value</h3>

<p>The function returns a nonnegative definite matrix, reconstructed from
its SVD, or a list of such matrices (see details above).
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Horn and Johnson, Matrix analysis, Cambridge University
Press (1985)</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(16),4,4)
x &lt;- crossprod(x)
tmp &lt;- La.svd(x)
all.equal(dlmSvd2var(tmp$u, sqrt(tmp$d)), x)
## Vectorized usage
x &lt;- dlmFilter(Nile, dlmModPoly(1, dV=15099, dW=1469))
x$se &lt;- sqrt(unlist(dlmSvd2var(x$U.C, x$D.C)))
## Level with 50% probability interval
plot(Nile, lty=2)
lines(dropFirst(x$m), col="blue")
lines(dropFirst(x$m - .67*x$se), lty=3, col="blue")
lines(dropFirst(x$m + .67*x$se), lty=3, col="blue")
</code></pre>

<hr>
<h2 id='dropFirst'>Drop the first element of a vector or matrix</h2><span id='topic+dropFirst'></span>

<h3>Description</h3>

<p>A utility function, <code>dropFirst</code> drops the first element of a
vector or matrix, retaining the correct time series attributes, in
case the argument is a time series object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropFirst(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropFirst_+3A_x">x</code></td>
<td>
<p>a vector or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>x[-1]</code> or <code>x[-1,]</code>, if the argument is
a matrix. For an argument of class <code>ts</code> the class is preserved,
together with the correct <code>tsp</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>(pres &lt;- dropFirst(presidents))
start(presidents)
start(pres)
</code></pre>

<hr>
<h2 id='FF'>Components of a dlm object</h2><span id='topic+FF'></span><span id='topic+FF+3C-'></span><span id='topic+V'></span><span id='topic+V+3C-'></span><span id='topic+GG'></span><span id='topic+GG+3C-'></span><span id='topic+W'></span><span id='topic+W+3C-'></span><span id='topic+m0'></span><span id='topic+m0+3C-'></span><span id='topic+C0'></span><span id='topic+C0+3C-'></span><span id='topic+FF.dlm'></span><span id='topic+FF+3C-.dlm'></span><span id='topic+V.dlm'></span><span id='topic+V+3C-.dlm'></span><span id='topic+GG.dlm'></span><span id='topic+GG+3C-.dlm'></span><span id='topic+W.dlm'></span><span id='topic+W+3C-.dlm'></span><span id='topic+m0.dlm'></span><span id='topic+m0+3C-.dlm'></span><span id='topic+C0.dlm'></span><span id='topic+C0+3C-.dlm'></span><span id='topic+JFF'></span><span id='topic+JFF+3C-'></span><span id='topic+JV'></span><span id='topic+JV+3C-'></span><span id='topic+JGG'></span><span id='topic+JGG+3C-'></span><span id='topic+JW'></span><span id='topic+JW+3C-'></span><span id='topic+X'></span><span id='topic+X+3C-'></span><span id='topic+JFF.dlm'></span><span id='topic+JFF+3C-.dlm'></span><span id='topic+JV.dlm'></span><span id='topic+JV+3C-.dlm'></span><span id='topic+JGG.dlm'></span><span id='topic+JGG+3C-.dlm'></span><span id='topic+JW.dlm'></span><span id='topic+JW+3C-.dlm'></span><span id='topic+X.dlm'></span><span id='topic+X+3C-.dlm'></span>

<h3>Description</h3>

<p>Functions to get or set specific components of an object of class <code>dlm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm'
FF(x)
## S3 replacement method for class 'dlm'
FF(x) &lt;- value
## S3 method for class 'dlm'
V(x)
## S3 replacement method for class 'dlm'
V(x) &lt;- value
## S3 method for class 'dlm'
GG(x)
## S3 replacement method for class 'dlm'
GG(x) &lt;- value
## S3 method for class 'dlm'
W(x)
## S3 replacement method for class 'dlm'
W(x) &lt;- value
## S3 method for class 'dlm'
m0(x)
## S3 replacement method for class 'dlm'
m0(x) &lt;- value
## S3 method for class 'dlm'
C0(x)
## S3 replacement method for class 'dlm'
C0(x) &lt;- value
## S3 method for class 'dlm'
JFF(x)
## S3 replacement method for class 'dlm'
JFF(x) &lt;- value
## S3 method for class 'dlm'
JV(x)
## S3 replacement method for class 'dlm'
JV(x) &lt;- value
## S3 method for class 'dlm'
JGG(x)
## S3 replacement method for class 'dlm'
JGG(x) &lt;- value
## S3 method for class 'dlm'
JW(x)
## S3 replacement method for class 'dlm'
JW(x) &lt;- value
## S3 method for class 'dlm'
X(x)
## S3 replacement method for class 'dlm'
X(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FF_+3A_x">x</code></td>
<td>
<p>an object of class <code>dlm</code>.</p>
</td></tr>
<tr><td><code id="FF_+3A_value">value</code></td>
<td>
<p>a numeric matrix (or vector for <code>m0</code>).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Missing or infinite values are not allowed in <code>value</code>. The dimension of
<code>value</code> must match the dimension of the current value of the
specific component in <code>x</code>
</p>


<h3>Value</h3>

<p>For the assignment forms, the updated <code>dlm</code> object.
</p>
<p>For the other forms, the specific component of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dlm">dlm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(222)
mod &lt;- dlmRandom(5, 6)
all.equal( FF(mod), mod$FF )
all.equal( V(mod), mod$V )
all.equal( GG(mod), mod$GG )
all.equal( W(mod), mod$W )
all.equal( m0(mod), mod$m0 )
all.equal( C0(mod), mod$C0)
m0(mod)
m0(mod) &lt;- rnorm(6)
C0(mod)
C0(mod) &lt;- rwishart(10, 6)
### A time-varying model
mod &lt;- dlmModReg(matrix(rnorm(10), 5, 2))
JFF(mod)
X(mod)
</code></pre>

<hr>
<h2 id='mcmc'>Utility functions for MCMC output analysis</h2><span id='topic+mcmcMean'></span><span id='topic+mcmcMeans'></span><span id='topic+mcmcSD'></span><span id='topic+ergMean'></span>

<h3>Description</h3>

<p>Returns the mean, the standard deviation of the mean, and a sequence
of partial means of the input vector or matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcMean(x, sd = TRUE)
mcmcMeans(x, sd = TRUE)
mcmcSD(x)
ergMean(x, m = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc_+3A_x">x</code></td>
<td>
<p>vector or matrix containing the output of a Markov chain
Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_sd">sd</code></td>
<td>
<p>logical: should an estimate of the Monte Carlo standard
deviation be reported?</p>
</td></tr> 
<tr><td><code id="mcmc_+3A_m">m</code></td>
<td>
<p>ergodic means are computed for <code>i</code> in <code>m:NROW(x)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> is typically the output from a simulation. If a
matrix, rows are considered consecutive simulations of a target
vector. In this case means, standard deviations, and ergodic means
are returned for each column. The standard deviation of the mean is
estimated using Sokal's method (see the reference). <code>mcmcMeans</code>
is an alias for <code>mcmcMean</code>.
</p>


<h3>Value</h3>

<p><code>mcmcMean</code> returns the sample mean of a vector containing the output
of an MCMC sampler, together with an estimated standard error. If the input
is a matrix, means and standard errors are computed for each column.<br />
<code>mcmcSD</code> returns an estimate of the standard deviation of the mean for
the output of an MCMC sampler.<br />
<code>ergMean</code> returns a vector of running ergodic means.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>P. Green (2001). A Primer on Markov Chain Monte Carlo. In
<em>Complex Stochastic Systems</em>, (Barndorff-Nielsen, Cox and
Kl\&quot;uppelberg, eds.). Chapman and Hall/CRC. </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rexp(1000), nc=4)
dimnames(x) &lt;- list(NULL, LETTERS[1:NCOL(x)])
mcmcSD(x)
mcmcMean(x)
em &lt;- ergMean(x, m = 51)
plot(ts(em, start=51), xlab="Iteration", main="Ergodic means")
</code></pre>

<hr>
<h2 id='NelPlo'>Nelson-Plosser macroeconomic time series</h2><span id='topic+NelPlo'></span>

<h3>Description</h3>

<p>A subset of Nelson-Plosser data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NelPlo)</code></pre>


<h3>Format</h3>

<p>The format is:
mts [1:43, 1:2] -4.39  3.12  1.08 -1.50  3.91 ...
- attr(*, &quot;tsp&quot;)= num [1:3] 1946 1988    1
- attr(*, &quot;class&quot;)= chr [1:2] &quot;mts&quot; &quot;ts&quot;
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : NULL
..$ : chr [1:2] &quot;ip&quot; &quot;stock.prices&quot;
</p>


<h3>Details</h3>

<p>The series are <code>100*diff(log())</code> of 
industrial production and stock prices (S&amp;P500) from 1946 to 1988.
</p>


<h3>Source</h3>

<p>The complete data set is available in package <code>tseries</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NelPlo)
plot(NelPlo)
</code></pre>

<hr>
<h2 id='residuals.dlmFiltered'>One-step forecast errors</h2><span id='topic+residuals.dlmFiltered'></span>

<h3>Description</h3>

<p>The function computes one-step forecast errors for a filtered dynamic
linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlmFiltered'
residuals(object, ..., type = c("standardized", "raw"), sd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.dlmFiltered_+3A_object">object</code></td>
<td>
<p>an object of class <code>"dlmFiltered"</code>, such as the
output from <code>dlmFilter</code></p>
</td></tr>
<tr><td><code id="residuals.dlmFiltered_+3A_...">...</code></td>
<td>
<p>unused additional arguments.</p>
</td></tr>
<tr><td><code id="residuals.dlmFiltered_+3A_type">type</code></td>
<td>
<p>should standardized or raw forecast errors be produced?</p>
</td></tr>
<tr><td><code id="residuals.dlmFiltered_+3A_sd">sd</code></td>
<td>
<p>when <code>sd = TRUE</code>, standard deviations are returned as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix (in the multivariate case) of one-step forecast
errors, standardized if <code>type = "standardized"</code>. Time series
attributes of the original observation vector (matrix) are retained by
the one-step forecast errors.
</p>
<p>If <code>sd = TRUE</code> then the returned value is a list with the
one-step forecast errors in component <code>res</code> and the corresponding
standard deviations in component <code>sd</code>. 
</p>


<h3>Note</h3>

<p>The <code>object</code> argument must include a component <code>y</code>
containing the data. This component will not be present if
<code>object</code> was obtained by calling <code>dlmFilter</code> with
<code>simplify = TRUE</code>.</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Giovanni Petris (2010), An R Package for Dynamic Linear
Models. Journal of Statistical Software, 36(12), 1-16.
<a href="https://www.jstatsoft.org/v36/i12/">https://www.jstatsoft.org/v36/i12/</a>.<br />
Petris, Petrone, and Campagnoli, Dynamic Linear Models with
R, Springer (2009).<br />
West and Harrison, Bayesian forecasting and
dynamic models (2nd ed.), Springer (1997).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlmFilter">dlmFilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## diagnostic plots 
nileMod &lt;- dlmModPoly(1, dV = 15100, dW = 1468)
nileFilt &lt;- dlmFilter(Nile, nileMod)
res &lt;- residuals(nileFilt, sd=FALSE)
qqnorm(res)
tsdiag(nileFilt)
</code></pre>

<hr>
<h2 id='rwishart'>Random Wishart matrix</h2><span id='topic+rwishart'></span>

<h3>Description</h3>

<p>Generate a draw from a Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwishart(df, p = nrow(SqrtSigma), Sigma, SqrtSigma = diag(p))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rwishart_+3A_df">df</code></td>
<td>
<p>degrees of freedom. It has to be integer.</p>
</td></tr>
<tr><td><code id="rwishart_+3A_p">p</code></td>
<td>
<p>dimension of the matrix to simulate.</p>
</td></tr>
<tr><td><code id="rwishart_+3A_sigma">Sigma</code></td>
<td>
<p>the matrix parameter Sigma of the Wishart distribution.</p>
</td></tr>
<tr><td><code id="rwishart_+3A_sqrtsigma">SqrtSigma</code></td>
<td>
<p>a <em>square root</em> of the matrix parameter Sigma of the 
Wishart distribution. Sigma must be equal to <code>crossprod(SqrtSigma)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wishart is a distribution on the set of nonnegative definite
symmetric matrices. Its density is
</p>
<p style="text-align: center;"><code class="reqn">p(W) = \frac{c |W|^{(n-p-1)/2}}{|\Sigma|^{n/2}}
    \exp\left\{-\frac{1}{2}\mathrm{tr}(\Sigma^{-1}W)\right\}</code>
</p>

<p>where <code class="reqn">n</code> is the degrees of freedom parameter <code>df</code> and
<code class="reqn">c</code> is a normalizing constant.
The mean of the Wishart distribution is <code class="reqn">n\Sigma</code> and the
variance of an entry is
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Var}(W_{ij}) = n (\Sigma_{ij}^2 +
    \Sigma_{ii}\Sigma_{jj})</code>
</p>

<p>The matrix parameter, which should be a positive definite symmetric
matrix, can be specified via either the argument Sigma or
SqrtSigma. If Sigma is specified, then SqrtSigma is ignored. No checks
are made for symmetry and positive definiteness of Sigma.
</p>


<h3>Value</h3>

<p>The function returns one draw from the Wishart distribution with 
<code>df</code> degrees of freedom and matrix parameter <code>Sigma</code> or
<code>crossprod(SqrtSigma)</code>	
</p>


<h3>Warning</h3>

<p>The function only works for an integer number 
of degrees of freedom.</p>


<h3>Note</h3>

<p>From a suggestion by B.Venables, posted on S-news</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Press (1982). Applied multivariate analysis.</p>


<h3>Examples</h3>

<pre><code class='language-R'>rwishart(25, p = 3)
a &lt;- matrix(rnorm(9), 3)
rwishart(30, SqrtSigma = a)
b &lt;- crossprod(a)
rwishart(30, Sigma = b)
</code></pre>

<hr>
<h2 id='USecon'>US macroeconomic time series</h2><span id='topic+USecon'></span>

<h3>Description</h3>

<p>US macroeconomic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USecon)</code></pre>


<h3>Format</h3>

<p>The format is:
mts [1:40, 1:2]  0.1364  0.0778 -0.3117 -0.5478 -1.2636 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : NULL
..$ : chr [1:2] &quot;M1&quot; &quot;GNP&quot;
- attr(*, &quot;tsp&quot;)= num [1:3] 1978 1988    4
- attr(*, &quot;class&quot;)= chr [1:2] &quot;mts&quot; &quot;ts&quot;
</p>


<h3>Details</h3>

<p>The series are <code>100*diff(log())</code> of seasonally adjusted real 
U.S. money 'M1' and GNP from 1978 to 1987.
</p>


<h3>Source</h3>

<p>The complete data set is available in package <code>tseries</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USecon)
plot(USecon)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
