<!DOCTYPE html><html><head><title>Help for package SFtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SFtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Infinity'><p>Simulated dataset</p></a></li>
<li><a href='#SFtools-package'><p>SFtools: Space Filling Based Tools for Data Mining</p></a></li>
<li><a href='#UfsCov'><p>UfsCov algorithm for unsupervised feature selection</p></a></li>
<li><a href='#UfsCov_ff'><p>UfsCov for unsupervised features selection</p></a></li>
<li><a href='#UfsCov_par'><p>UfsCov algorithm for unsupervised feature selection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Space Filling Based Tools for Data Mining</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohamed Laib and Mikhail Kanevski</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mohamed Laib &lt;laib.med@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains space filling based tools for
    machine learning and data mining. Some functions offer
    several computational techniques and deal with the out of
    memory for large big data by using the ff package.</td>
</tr>
<tr>
<td>Imports:</td>
<td>wordspace, doParallel, ff, parallel, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sites.google.com/site/mohamedlaibwebpage/">https://sites.google.com/site/mohamedlaibwebpage/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlaib/SFtools/issues">https://github.com/mlaib/SFtools/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Note:</td>
<td>The GPU computing version can be found soon, on following url
https://sites.google.com/site/mohamedlaibwebpage/Software.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-06-28 15:23:59 UTC; mlaib</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-06-28 15:53:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='Infinity'>Simulated dataset</h2><span id='topic+Infinity'></span>

<h3>Description</h3>

<p>Generates a simulated dataset (the Infinity dataset)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Infinity(n=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Infinity_+3A_n">n</code></td>
<td>
<p>Number of generated data points (by default: <code>n=1000</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of simulated dataset, with <code class="reqn">7</code> features
(<code class="reqn">4</code> of them are redundants)
</p>


<h3>Author(s)</h3>

<p>Mohamed Laib <a href="mailto:Mohamed.Laib@unil.ch">Mohamed.Laib@unil.ch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infinity&lt;-Infinity(n=1000)
plot(infinity$x1,infinity$x2)

## Not run: 

#### Visualisation of the infinity dataset (3D) ####
require(rgl)
require(colorRamps)

c &lt;- cut(infinity$z,breaks=100)
cols &lt;- matlab.like(100)[as.numeric(c)]
plot3d(infinity$x1,infinity$x2,infinity$z,radius=0.01, col=cols,
type="s",xlab="x1",ylab="x2",zlab="z",box=F)
grid3d(c("x","y","z"),col="black",lwd=1)


## End(Not run)
</code></pre>

<hr>
<h2 id='SFtools-package'>SFtools: Space Filling Based Tools for Data Mining</h2><span id='topic+SFtools'></span><span id='topic+SFtools-package'></span>

<h3>Description</h3>

<p>Contains space filling based tools for
machine learning and data mining. Some functions offer
several computational techniques and deal with the out of
memory for large big data by using the ff package.
</p>


<h3>Author(s)</h3>

<p>Mohamed Laib <a href="mailto:Mohamed.Laib@unil.ch">Mohamed.Laib@unil.ch</a>  and
</p>
<p>Mikhail Kanevski <a href="mailto:Mikhail.Kanevski@unil.ch">Mikhail.Kanevski@unil.ch</a>,
</p>
<p>Maintainer: Mohamed Laib <a href="mailto:laib.med@gmail.com">laib.med@gmail.com</a>
</p>


<h3>References</h3>

<p>M. Laib and M. Kanevski (2017). Unsupervised Feature Selection Based on Space
Filling Concept, <a href="https://arxiv.org/abs/1706.08894">arXiv:1706.08894</a>.
</p>
<p>J. A. Royle, D. Nychka, An algorithm for the construction of spatial
coverage designs with implementation in Splus, Computers and Geosciences
24 (1997) p. 479–488.
</p>
<p>J. Franco, Planification d’expériences numériques en phase exploratoire
pour la simulation des phénomènes complexes, Thesis (2008) 282.
</p>
<p>D. Dupuy, C. Helbert, J. Franco (2015). DiceDesign
and DiceEval: Two R Packages for Design and Analysis of Computer
Experiments. Journal of Statistical Software, 65(11), 1-38.
<a href="http://www.jstatsoft.org/v65/i11/">Jstatsoft</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sites.google.com/site/mohamedlaibwebpage/">https://sites.google.com/site/mohamedlaibwebpage/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlaib/SFtools/issues">https://github.com/mlaib/SFtools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='UfsCov'>UfsCov algorithm for unsupervised feature selection</h2><span id='topic+UfsCov'></span>

<h3>Description</h3>

<p>Applies the UfsCov algorithm based on the space filling concept,
by using a sequatial forward search (SFS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UfsCov(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UfsCov_+3A_data">data</code></td>
<td>
<p>Data of class: <code>matrix</code> or <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the algorithm is based on pairwise distances, and
according to the computing power of your machine, large number of
data points can take much time and needs more memory.
See <code><a href="#topic+UfsCov_par">UfsCov_par</a></code> for parellel computing, or
<code><a href="#topic+UfsCov_ff">UfsCov_ff</a></code> for memory efficient storage of large data
on disk and fast access (by using the <code>ff</code> and the <code>ffbase</code> packages).
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><code>CovD</code> a vector containing the coverage measure of
each step of the SFS.
</p>
</li>
<li> <p><code>IdR</code> a vector containing the added variables during
the selection procedure.
</p>
</li></ul>



<h3>Note</h3>

<p>The algorithm does not deal with missing values and constant
features. Please make sure to remove them.
</p>


<h3>Author(s)</h3>

<p>Mohamed Laib <a href="mailto:Mohamed.Laib@unil.ch">Mohamed.Laib@unil.ch</a>
</p>


<h3>References</h3>

<p>M. Laib and M. Kanevski (2017). Unsupervised Feature Selection Based on Space
Filling Concept, <a href="https://arxiv.org/abs/1706.08894">arXiv:1706.08894</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infinity&lt;-Infinity(n=800)
Results&lt;- UfsCov(infinity)

cou&lt;-colnames(infinity)
nom&lt;-cou[Results[[2]]]
par(mfrow=c(1,1), mar=c(5,5,2,2))
names(Results[[1]])&lt;-cou[Results[[2]]]
plot(Results[[1]] ,pch=16,cex=1,col="blue", axes = FALSE,
xlab = "Added Features", ylab = "Coverage measure")
lines(Results[[1]] ,cex=2,col="blue")
grid(lwd=1.5,col="gray" )
box()
axis(2)
axis(1,1:length(nom),nom)
which.min(Results[[1]])

## Not run: 

#### UfsCov on the Butterfly dataset ####
require(IDmining)

N &lt;- 1000
raw_dat &lt;- Butterfly(N)
dat&lt;-raw_dat[,-9]

Results&lt;- UfsCov(dat)
cou&lt;-colnames(dat)
nom&lt;-cou[Results[[2]]]
par(mfrow=c(1,1), mar=c(5,5,2,2))
names(Results[[1]])&lt;-cou[Results[[2]]]

plot(Results[[1]] ,pch=16,cex=1,col="blue", axes = FALSE,
xlab = "Added Features", ylab = "Coverage measure")
lines(Results[[1]] ,cex=2,col="blue")
grid(lwd=1.5,col="gray" )
box()
axis(2)
axis(1,1:length(nom),nom)
which.min(Results[[1]])


## End(Not run)
</code></pre>

<hr>
<h2 id='UfsCov_ff'>UfsCov for unsupervised features selection</h2><span id='topic+UfsCov_ff'></span>

<h3>Description</h3>

<p>Applies the UfsCov algorithm based on the space filling concept,
by using a sequatial forward search (for memory efficient storage
of large data on disk and fast access).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UfsCov_ff(data, blocks=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UfsCov_ff_+3A_data">data</code></td>
<td>
<p>Data of class: <code>matrix</code> or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="UfsCov_ff_+3A_blocks">blocks</code></td>
<td>
<p>Number of splits to facilitate the computation of the
distance matrix (by default: blocks=2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><code>CovD</code> a vector containing the coverage measure of
each step of the SFS.
</p>
</li>
<li> <p><code>IdR</code> a vector containing the added variables during
the selection procedure.
</p>
</li></ul>



<h3>Note</h3>

<p>This function is still under developement.
</p>


<h3>Author(s)</h3>

<p>Mohamed Laib <a href="mailto:Mohamed.Laib@unil.ch">Mohamed.Laib@unil.ch</a>
</p>


<h3>References</h3>

<p>M. Laib and M. Kanevski (2017). Unsupervised Feature Selection Based on Space
Filling Concept, <a href="https://arxiv.org/abs/1706.08894">arXiv:1706.08894</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#### Infinity dataset ####
N &lt;- 1000
dat&lt;-Infinity(N)
Results&lt;- UfsCov_ff(dat)

cou&lt;-colnames(dat)
nom&lt;-cou[Results[[2]]]
par(mfrow=c(1,1), mar=c(5,5,2,2))
names(Results[[1]])&lt;-cou[Results[[2]]]
plot(Results[[1]] ,pch=16,cex=1,col="blue", axes = FALSE,
xlab = "Added Features", ylab = "Coverage measure")
lines(Results[[1]] ,cex=2,col="blue")
grid(lwd=1.5,col="gray" )
box()
axis(2)
axis(1,1:length(nom),nom)
which.min(Results[[1]])

#### Butterfly dataset ####

require(IDmining)
N &lt;- 1000
raw_dat &lt;- Butterfly(N)
dat&lt;-raw_dat[,-9]

Results&lt;- UfsCov_ff(dat)


## End(Not run)
</code></pre>

<hr>
<h2 id='UfsCov_par'>UfsCov algorithm for unsupervised feature selection</h2><span id='topic+UfsCov_par'></span>

<h3>Description</h3>

<p>Applies the UfsCov algorithm based on the space filling concept,
by using a sequatial forward search (SFS).This function
offers a parellel computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UfsCov_par(data, ncores=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UfsCov_par_+3A_data">data</code></td>
<td>
<p>Data of class: <code>matrix</code> or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="UfsCov_par_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use (by default: <code>ncores=2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the algorithm is based on pairwise distances, and
according to the computing power of your machine, large number of
data points needs more memory. See <code><a href="#topic+UfsCov_ff">UfsCov_ff</a></code> for memory
efficient storage of large data on disk and fast access (by using the
<code>ff</code> and the <code>ffbase</code> packages).
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><code>CovD</code> a vector containing the coverage measure of
each step of the SFS.
</p>
</li>
<li> <p><code>IdR</code> a vector containing the added variables during
the selection procedure.
</p>
</li></ul>



<h3>Note</h3>

<p>The algorithm does not deal with missing values and constant
features. Please make sure to remove them. Note that it is not recommanded to
use this function with small data, it takes more time than using the
standard <code><a href="#topic+UfsCov">UfsCov</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Mohamed Laib <a href="mailto:Mohamed.Laib@unil.ch">Mohamed.Laib@unil.ch</a>
</p>


<h3>References</h3>

<p>M. Laib and M. Kanevski (2017). Unsupervised Feature Selection Based on Space
Filling Concept, <a href="https://arxiv.org/abs/1706.08894">arXiv:1706.08894</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UfsCov">UfsCov</a></code>, <code><a href="#topic+UfsCov_ff">UfsCov_ff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 800
dat&lt;-Infinity(N)
Results&lt;- UfsCov_par(dat,ncores=2)

cou&lt;-colnames(dat)
nom&lt;-cou[Results[[2]]]
par(mfrow=c(1,1), mar=c(5,5,2,2))
names(Results[[1]])&lt;-cou[Results[[2]]]
plot(Results[[1]] ,pch=16,cex=1,col="blue", axes = FALSE,
xlab = "Added Features", ylab = "Coverage measure")
lines(Results[[1]] ,cex=2,col="blue")
grid(lwd=1.5,col="gray" )
box()
axis(2)
axis(1,1:length(nom),nom)
which.min(Results[[1]])

## Not run: 

N&lt;-5000
dat&lt;-Infinity(N)

## Little comparison:
system.time(Uf&lt;-UfsCov(dat))
system.time(Uf.p&lt;-UfsCov_par(dat, ncores = 4))


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
