<!DOCTYPE html><html><head><title>Help for package spBayesSurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spBayesSurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anovaDDP'><p>Bayesian Nonparametric Survival Model</p></a></li>
<li><a href='#baseline'><p>Stratification effects on baseline functions</p></a></li>
<li><a href='#bspline'><p>Generate a Cubic B-Spline Basis Matrix</p></a></li>
<li><a href='#cox.snell.survregbayes'><p>Cox-Snell Diagnostic Plot</p></a></li>
<li><a href='#frailtyGAFT'><p>Generalized Accelerated Failure Time Frailty Model</p></a></li>
<li><a href='#frailtyprior'><p>Frailty prior specification</p></a></li>
<li><a href='#GetCurves'><p>Density, Survival, and Hazard Estimates</p></a></li>
<li><a href='#indeptCoxph'><p>Bayesian Proportional Hazards Model</p></a></li>
<li><a href='#LeukSurv'><p>The Leukemia Survival Data</p></a></li>
<li><a href='#predict.bspline'><p>Evaluate a Cubic Spline Basis</p></a></li>
<li><a href='#SpatDensReg'><p>Bayesian Nonparametric Spatially Smoothed Density Estimation</p></a></li>
<li><a href='#spCopulaCoxph'><p>Marginal Bayesian Proportional Hazards Model via Spatial Copula</p></a></li>
<li><a href='#spCopulaDDP'><p>Marginal Bayesian Nonparametric Survival Model via Spatial Copula</p></a></li>
<li><a href='#SuperSurvRegBayes'><p>Bayesian Semiparametric Super Survival Model</p></a></li>
<li><a href='#survregbayes'><p>Bayesian Semiparametric Survival Models</p></a></li>
<li><a href='#survregbayes2'><p>Bayesian Semiparametric Survival Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Modeling and Analysis of Spatially Correlated Survival
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-23</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides several Bayesian survival models for spatial/non-spatial survival data: proportional hazards (PH), accelerated failure time (AFT), proportional odds (PO), and accelerated hazards (AH), a super model that includes PH, AFT, PO and AH as special cases, Bayesian nonparametric nonproportional hazards (LDDPM), generalized accelerated failure time (GAFT), and spatially smoothed Polya tree density estimation. The spatial dependence is modeled via frailties under PH, AFT, PO, AH and GAFT, and via copulas under LDDPM and PH. Model choice is carried out via the logarithm of the pseudo marginal likelihood (LPML), the deviance information criterion (DIC), and the Watanabe-Akaike information criterion (WAIC). See Zhou, Hanson and Zhang (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v092.i09">doi:10.18637/jss.v092.i09</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.16), survival, coda, methods, MASS, fields,
splines</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.8.500.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Haiming Zhou [aut, cre, cph],
  Timothy Hanson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haiming Zhou &lt;haiming2019@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 13:58:09 UTC; hzhou</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anovaDDP'>Bayesian Nonparametric Survival Model</h2><span id='topic+anovaDDP'></span>

<h3>Description</h3>

<p>This function fits a Bayesian Nonparametric model (De Iorio et al., 2009) for non-spatial right censored time-to-event data. Note that the notations are different with those presented in the original paper; see Zhou, Hanson and Zhang (2018) for new examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovaDDP(formula, data, na.action, prediction=NULL,
         mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500),
         prior=NULL, state=NULL, scale.designX=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anovaDDP_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It currently only supports right-censoring.</p>
</td></tr>
<tr><td><code id="anovaDDP_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="anovaDDP_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="anovaDDP_+3A_prediction">prediction</code></td>
<td>
<p>a list giving the information used to obtain conditional inferences. The list includes the following element: <code>xpred</code> giving the npred by p covariates matrix, used for prediction. If <code>prediction=NULL</code>, <code>xpred</code> will be set to be the design matrix used in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="anovaDDP_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="anovaDDP_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. See Zhou, Hanson and Zhang (2018) for more detailed hyperprior specifications.</p>
</td></tr>
<tr><td><code id="anovaDDP_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis.</p>
</td></tr>  
<tr><td><code id="anovaDDP_+3A_scale.designx">scale.designX</code></td>
<td>
<p>flag to indicate wheter the design matrix X will be centered by column means and scaled by column standard deviations, where <code>TRUE</code> indicates yes. The default is <code>TRUE</code> for improving numerical stability. All returned posterior samples fit from scaled covariates. Note if we want to specify informative priors for regression coefficients, these priors should correspond to scaled predictors when <code>scale.designX=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Bayesian Nonparametric model (De Iorio et al., 2009) for non-spatial right censored time-to-event data. Note that the notations are different with those presented in the original paper; see Zhou, Hanson and Zhang (2018) for new examples. 
</p>


<h3>Value</h3>

<p>The <code>anovaDDP</code> object is a list containing at least the following components:
</p>
<table>
<tr><td><code>n</code></td>
<td>

<p>the number of row observations used in fitting the model
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>the number of columns in the model matrix
</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used 
</p>
</td></tr>
<tr><td><code>X.scaled</code></td>
<td>

<p>the n by p scaled design matrix
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>the n by p orginal design matrix
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>the p+1 by N by nsave array of posterior samples for the coefficients
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>the N by nsave matrix of posterior samples for sigma2 involved in the DDP.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>the N by nsave matrix of posterior samples for weights involved in the DDP. 
</p>
</td></tr>
<tr><td><code>Tpred</code></td>
<td>

<p>the npred by nsave predicted survival times for covariates specified in the argument <code>prediction</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H., Hanson, T., and Zhang, J. (2020). spBayesSurv: Fitting Bayesian Spatial Survival Models Using R. <em>Journal of Statistical Software</em>, 92(9): 1-33.
</p>
<p>Zhou, H., Hanson, T., and Knapp, R. (2015). Marginal Bayesian nonparametric model for time to disease arrival of threatened amphibian populations. <em>Biometrics</em>, 71(4): 1101-1110. 
</p>
<p>De Iorio, M., Johnson, W. O., Mueller, P., and Rosner, G. L. (2009). Bayesian nonparametric nonproportional hazards survival modeling. <em>Biometrics</em>, 65(3): 762-771. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spCopulaDDP">spCopulaDDP</a>, <a href="#topic+GetCurves">GetCurves</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############################################################
# A simulated data: mixture of two normals
###############################################################
rm(list=ls())
library(survival)
library(spBayesSurv)
library(coda)
## True parameters 
betaT = cbind(c(3.5, 0.5), c(2.5, -1)); 
wT = c(0.4, 0.6); 
sig2T = c(1^2, 0.5^2);
n=100; 
## The Survival function for log survival times:
fiofy = function(y, xi, w=wT){
  nw = length(w);
  ny = length(y);
  res = matrix(0, ny, nw);
  Xi = c(1,xi);
  for (k in 1:nw){
    res[,k] = w[k]*dnorm(y, sum(Xi*betaT[,k]), sqrt(sig2T[k]) )
  }
  apply(res, 1, sum)
}
fioft = function(t, xi, w=wT) fiofy(log(t), xi, w)/t;
Fiofy = function(y, xi, w=wT){
  nw = length(w);
  ny = length(y);
  res = matrix(0, ny, nw);
  Xi = c(1,xi);
  for (k in 1:nw){
    res[,k] = w[k]*pnorm(y, sum(Xi*betaT[,k]), sqrt(sig2T[k]) )
  }
  apply(res, 1, sum)
}
Fioft = function(t, xi, w=wT) Fiofy(log(t), xi, w);
## The inverse for Fioft
Finv = function(u, x) uniroot(function (y) Fiofy(y,x)-u, lower=-250, 
                              upper=250, extendInt ="yes", tol=1e-6)$root

## generate x 
x1 = runif(n,-1.5,1.5); X = cbind(x1);
## generate survival times
u = runif(n);
tT = rep(0, n);
for (i in 1:n){
  tT[i] = exp(Finv(u[i], X[i,]));
}

### ----------- right-censored -------------###
t_obs=tT 
Centime = runif(n, 20, 200);
delta = (tT&lt;=Centime) +0 ; 
length(which(delta==0))/n; # censoring rate
rcen = which(delta==0);
t_obs[rcen] = Centime[rcen]; ## observed time 
## make a data frame
d = data.frame(tobs=t_obs, x1=x1, delta=delta, tT=tT); 
table(d$delta)/n;

###############################################################
# Independent DDP: Bayesian Nonparametric Survival Model
###############################################################
# MCMC parameters
nburn=500; nsave=500; nskip=0;
# Note larger nburn, nsave and nskip should be used in practice.
mcmc=list(nburn=nburn, nsave=nsave, nskip=nskip, ndisplay=1000);
prior = list(N=10, a0=2, b0=2);
# Fit the Cox PH model
res1 = anovaDDP(formula = Surv(tobs, delta)~x1, data=d, 
                prior=prior, mcmc=mcmc);
## LPML
LPML = sum(log(res1$cpo)); LPML;
## Number of non-negligible components
quantile(colSums(res1$w&gt;0.05))

############################################
## Curves
############################################
ygrid = seq(0,6.0,length=100); tgrid = exp(ygrid);
xpred = data.frame(x1=c(-1, 1))
plot(res1, xnewdata=xpred, tgrid=tgrid);

</code></pre>

<hr>
<h2 id='baseline'>Stratification effects on baseline functions</h2><span id='topic+baseline'></span>

<h3>Description</h3>

<p>This function allows one to add a simple baseline stratification term to the generalized AFT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_+3A_...">...</code></td>
<td>
<p>stratification variables to be entered; see the example in <code><a href="#topic+frailtyGAFT">frailtyGAFT</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H., Hanson, T., and Zhang, J. (2020). spBayesSurv: Fitting Bayesian Spatial Survival Models Using R. <em>Journal of Statistical Software</em>, 92(9): 1-33.
</p>
<p>Zhou, H., Hanson, T., and Zhang, J. (2017). Generalized accelerated failure time spatial frailty model for arbitrarily censored data. <em>Lifetime Data Analysis</em>, 23(3): 495-515..
</p>

<hr>
<h2 id='bspline'>Generate a Cubic B-Spline Basis Matrix</h2><span id='topic+bspline'></span><span id='topic+makepredictcall.bspline'></span>

<h3>Description</h3>

<p>Generate the B-spline basis matrix for a cubic spline with the first and last columns dropped. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bspline(x, df=NULL, knots=NULL, Boundary.knots = range(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bspline_+3A_x">x</code></td>
<td>
<p>the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="bspline_+3A_df">df</code></td>
<td>
<p>degrees of freedom; one can specify <code>df</code> rather than <code>knots</code>; the function chooses <code>df-2</code> inner knots at suitable quantile of <code>x</code> (which will ignore missing values). The default, <code>NULL</code>, corresponds to one inner knots, i.e. <code>df=3</code>.</p>
</td></tr>
<tr><td><code id="bspline_+3A_knots">knots</code></td>
<td>
<p>the internal breakpoints that define the spline. The default is <code>NULL</code>, which corresponds the median for one knot, quantiles for more knots.</p>
</td></tr>
<tr><td><code id="bspline_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to anchor the B-spline basis (default the range of the non-NA data).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) Generalized additive models. Chapter 7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bspline">predict.bspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
basis &lt;- bspline(women$height, df = 5)
newX &lt;- seq(58, 72, length.out = 51)
# evaluate the basis at the new data
predict(basis, newX)
</code></pre>

<hr>
<h2 id='cox.snell.survregbayes'>Cox-Snell Diagnostic Plot</h2><span id='topic+cox.snell.survregbayes'></span>

<h3>Description</h3>

<p>This function provides the Cox-Snell diagnostic plot (Zhou and Hanson, 2018) for fitting  for Bayesian semiparametric survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.snell.survregbayes(x, ncurves = 10, PLOT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox.snell.survregbayes_+3A_x">x</code></td>
<td>
<p>an object obtained from the function <code><a href="#topic+survregbayes">survregbayes</a></code>.</p>
</td></tr>
<tr><td><code id="cox.snell.survregbayes_+3A_ncurves">ncurves</code></td>
<td>
<p>the number of posterior draws.</p>
</td></tr>
<tr><td><code id="cox.snell.survregbayes_+3A_plot">PLOT</code></td>
<td>
<p>a logical value indicating whether the estimated survival curves will be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the plot (if <code>PLOT = TRUE</code>) and a list with the following components:
</p>
<table>
<tr><td><code>resid</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object using the everaged residuals
</p>
</td></tr>
<tr><td><code>resid*</code></td>
<td>

<p>the <code>*</code> goes from 1 to <code>ncurves</code>, and each is the <code><a href="survival.html#topic+Surv">Surv</a></code> object using the residuals obtained from each posterior draw. 
</p>
</td></tr>
<tr><td><code>St1</code></td>
<td>

<p>the <code>n</code> by <code>ncurves</code> matrix of survival functions evaluated at left endpoints of the time interval.
</p>
</td></tr>
<tr><td><code>St2</code></td>
<td>

<p>the <code>n</code> by <code>ncurves</code> matrix of survival functions evaluated at right endpoints of the time interval.
</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>

<p>The status indicator: 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H. and Hanson, T. (2018). A unified framework for fitting Bayesian semiparametric models to arbitrarily censored survival data, including spatially-referenced data. <em>Journal of the American Statistical Association</em>, 113(522): 571-581.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survregbayes">survregbayes</a></code> 
</p>

<hr>
<h2 id='frailtyGAFT'>Generalized Accelerated Failure Time Frailty Model</h2><span id='topic+frailtyGAFT'></span><span id='topic+print.frailtyGAFT'></span><span id='topic+summary.frailtyGAFT'></span><span id='topic+print.summary.frailtyGAFT'></span>

<h3>Description</h3>

<p>This function fits a generalized accelerated failure time frailty model (Zhou, et al., 2017) for clustered and/or areal-level time-to-event data. Note that the function arguments are slightly different with those presented in the original paper; see Zhou, Hanson and Zhang (2018) for new examples. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frailtyGAFT(formula, data, na.action, 
            mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500), 
            prior=NULL, state=NULL, Proximity=NULL, Coordinates=NULL,
            DIST=NULL, scale.designX=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frailtyGAFT_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It supports right-censoring, left-censoring, interval-censoring, and mixtures of them. To include CAR frailties, add <code>frailtyprior("car",ID)</code> to the formula, where <code>ID</code> is an n dimensional vector of cluster ID numbers. Furthermore, use <code>frailtyprior("iid",ID)</code> for Gaussian exchangeable frailties, use <code>frailtyprior("grf",ID)</code> for Gaussian random fields (GRF) frailties, and exclude the term <code>frailtyprior()</code> for non-frailty models. Note: the data need to be sorted by ID. </p>
</td></tr>
<tr><td><code id="frailtyGAFT_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="frailtyGAFT_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="frailtyGAFT_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="frailtyGAFT_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. See Zhou, Hanson and Zhang (2018) for more detailed hyperprior specifications.</p>
</td></tr>
<tr><td><code id="frailtyGAFT_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis.</p>
</td></tr> 
<tr><td><code id="frailtyGAFT_+3A_proximity">Proximity</code></td>
<td>
<p>an m by m symetric adjacency matrix, where m is the number of clusters/regions. If CAR frailty model is specified in the formula, <code>Proximity</code> is required; otherwise it is ignored. Note: this matrix should be specified according to the data that have been sorted by ID. </p>
</td></tr>
<tr><td><code id="frailtyGAFT_+3A_coordinates">Coordinates</code></td>
<td>
<p>an m by d coordinates matrix, where m is the number of clusters/regions, d is the dimension of coordiantes. If GRF frailty model is specified in the formula, <code>Coordinates</code> is required; otherwise it is ignored. Note: this matrix should be specified according to the data that have been sorted by ID.</p>
</td></tr>
<tr><td><code id="frailtyGAFT_+3A_dist">DIST</code></td>
<td>
<p>This is a function argument, used to calculate the distance. The default is Euclidean distance (<code>fields::rdist</code>). This function should have two arguments (X1,X2), where X1 and X2 are matrices with coordinates as the rows. The returned value of this function should be the pairwise distance matrix. If nrow(X1)=m and nrow(X2)=n then the function should return an m by n matrix of all distances between these two sets of points.</p>
</td></tr>
<tr><td><code id="frailtyGAFT_+3A_scale.designx">scale.designX</code></td>
<td>
<p>flag to indicate whether the design matrix X and Xtf will be centered by column means and scaled by column standard deviations, where <code>TRUE</code> indicates yes. The default is <code>TRUE</code> for improving numerical stability. Even when it is scaled, the reported regression coefficients are in original scales. Note if we want to specify informative priors for regression coefficients, these priors should correspond to scaled predictors when <code>scale.designX=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a a generalized accelerated failure time frailty model (Zhou, et al., 2017) for clustered and/or areal-level time-to-event data. Note that the function arguments are slightly different with those presented in the original paper of Zhou, et al. (2017); see Zhou, Hanson and Zhang (2018) for new examples. 
</p>


<h3>Value</h3>

<p>The <code>frailtyGAFT</code> object is a list containing at least the following components:
</p>
<table>
<tr><td><code>modelname</code></td>
<td>

<p>the name of the fitted model
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>a named vector of coefficients. The last two elements are the estimates of scale parameter sigma and precision parameter alpha involved in the LDTFP prior. 
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>the list of hyperparameters used in all priors. 
</p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>

<p>the list of MCMC parameters used 
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>the number of row observations used in fitting the model
</p>
</td></tr>
<tr><td><code>pce</code></td>
<td>

<p>the number of columns in the model matrix including the intercept
</p>
</td></tr>
<tr><td><code>ptf</code></td>
<td>

<p>the number of columns in the model matrix used in the LDTFP baseline including the intercept
</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used 
</p>
</td></tr>
<tr><td><code>X.scaled</code></td>
<td>

<p>the n by pce-1 scaled design matrix
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>the n by pce-1 orginal design matrix
</p>
</td></tr>
<tr><td><code>Xtf.scaled</code></td>
<td>

<p>the n by ptf-1 scaled design matrix used in the LDTFP baseline
</p>
</td></tr>
<tr><td><code>Xtf</code></td>
<td>

<p>the n by ptf-1 orginal design matrix used in the LDTFP baseline
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>the vector of posterior samples for the variance parameter used in the LDTFP prior. 
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>the pce by nsave matrix of posterior samples for the coefficients in the <code>linear.predictors</code> which includes the intercept
</p>
</td></tr>
<tr><td><code>beta.scaled</code></td>
<td>

<p>the pce by nsave matrix of posterior samples for the coefficients in the <code>linear.predictors</code>. Note that these posterior samples are based scaled design matrix.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>the vector of posterior samples for the precision parameter alpha in the LDTFP prior. 
</p>
</td></tr>
<tr><td><code>maxL</code></td>
<td>

<p>the truncation level used in the LDTFP prior. 
</p>
</td></tr>
<tr><td><code>logt</code></td>
<td>

<p>the n by nsave matrix of posterior samples for log survival times. 
</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>

<p>the length n vector of the stabilized estiamte of CPO; used for calculating LPML
</p>
</td></tr>
<tr><td><code>accept_beta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of beta coefficient vector
</p>
</td></tr>
<tr><td><code>frail.prior</code></td>
<td>

<p>the frailty prior used in <code><a href="#topic+frailtyprior">frailtyprior</a></code> 
</p>
</td></tr>
<tr><td><code>BF</code></td>
<td>

<p>the Bayes factors for testing necessariness of each stratification covariate.  
</p>
</td></tr>
</table>
<p>The object will also have the following components when frailty models are fit:
</p>
<table>
<tr><td><code>v</code></td>
<td>

<p>the nID by nsave matrix of posterior samples for frailties, where nID is the number of clusters considered.
</p>
</td></tr>
<tr><td><code>tau2</code></td>
<td>

<p>the vector of posterior samples for tau2 involved in the IID, GRF or CAR frailty prior. 
</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>

<p>the cluster ID used in <code><a href="#topic+frailtyprior">frailtyprior</a></code> 
</p>
</td></tr>
</table>
<p>If GRF frailties are used, the object will also have:
</p>
<table>
<tr><td><code>Coordinates</code></td>
<td>

<p>the <code>Coordinates</code> matrix used in <code><a href="#topic+survregbayes">survregbayes</a></code> 
</p>
</td></tr>
<tr><td><code>ratephi</code></td>
<td>

<p>the acceptance rates in the posterior sampling of phi involved in the GRF prior 
</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>

<p>the vector of posterior samples for phi involved in the GRF prior 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H., Hanson, T., and Zhang, J. (2020). spBayesSurv: Fitting Bayesian Spatial Survival Models Using R. <em>Journal of Statistical Software</em>, 92(9): 1-33.
</p>
<p>Zhou, H., Hanson, T., and Zhang, J. (2017). Generalized accelerated failure time spatial frailty model for arbitrarily censored data. <em>Lifetime Data Analysis</em>, 23(3): 495-515.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+baseline">baseline</a></code>, <code><a href="#topic+frailtyprior">frailtyprior</a></code>, <code><a href="#topic+survregbayes">survregbayes</a></code>, <code>rdist</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############################################################
# A simulated data: GAFT spatial frailty model
###############################################################
rm(list=ls())
library(survival)
library(spBayesSurv)
library(coda)
library(MASS)

## True densities
set.seed(1)
Finvsingle = function(u, F) {
  res = uniroot(function (x) F(x)-u, lower=-1000, upper=1000, 
                tol=.Machine$double.eps^0.5);
  res$root
}
Finv = function(u, F) {sapply(u, Finvsingle, F)};
f0 = function(x) dnorm(x, 0, 0.8);
F0 = function(x) pnorm(x, 0, 0.8);
shift=1
f1 = function(x) 0.5*dnorm(x, -shift, 0.5) + 0.5*dnorm(x, shift, 0.5)
F1 = function(x) 0.5*pnorm(x, -shift, 0.5) + 0.5*pnorm(x, shift, 0.5);
ff = function(x, xtf=0) {
  if(xtf==0) {res=f0(x)} else res=f1(x)
  res
}
FF = function(x, xtf=0){
  if(xtf==0) {res=F0(x)} else res=F1(x)
  res
}

# Simulation settings;
betaT = c(-1, 1, -0.5);
tau2T = 0.1;
m = 50; # blocks
mi = 2;
mis = rep(mi, m);
id = rep(1:m,mis);
n = length(id); # Total number of subjects
# Generate symmetric adjaceny matrix, W 
wi = rep(0, m)
while(any(wi==0)){
  W = matrix(0,m,m)
  W[upper.tri(W,diag=FALSE)]&lt;-rbinom(m*(m-1)/2,1,.1)
  W = W+t(W) 
  wi = apply(W,1,sum)  # No. neighbors
}
# Spatial effects, v
Wstar = matrix(0, m-1, m-1);
Dstar = diag(wi[-m]);
for(i in 1:(m-1)){
  for(j in 1:(m-1)){
    Wstar[i,j] = W[j,i]-W[j,m]-W[m,i]-wi[m]
  }
}
Qstar = Dstar-Wstar;
covT = tau2T*solve(Qstar);
v0 = mvrnorm(1, mu=rep(0,m-1), Sigma=covT);
v = c(v0,-sum(v0));
vn = rep(v, mis);

# responses
x1 = rnorm(n, 0, 1);
x2 = rbinom(n, 1, 0.5);
xtf = x2; ptf = 2;
X = cbind(1,x1,x2); pce = ncol(X);
u = runif(n, 0, 1)
y = rep(0, n);
for(i in 1:n) {
  if(x2[i]==1) {
    y[i] = sum(betaT*X[i,]) + vn[i] + Finv(u[i], F1)
  }else{
    y[i] = sum(betaT*X[i,]) + vn[i] + Finv(u[i], F0)
  } 
}

# generate responses
Cen = runif(n, 0.5, 1)
delta = (exp(y)&lt;=Cen)+0;
sum(delta)/n
tTrue = exp(y);
tobs = cbind(tTrue, tTrue);
tobs[which(delta==0),] = cbind(Cen[which(delta==0)], NA);
dtotal = data.frame(tleft=tobs[,1], tright=tobs[,2], x1=x1, 
                    x2=x2, xtf=x2, ID=id, tTrue=tTrue, censor=delta);
## sort the data by ID
d = dtotal[order(dtotal$ID),];

# Prior information and MCMC
fit0 &lt;- survival::survreg(Surv(tleft, censor)~x1+x2, dist="lognormal", data=d);
prior = list(maxL = 4, a0 = 5, b0 = 1);
mcmc=list(nburn=200, nsave=200, nskip=0, ndisplay=100)
# Note larger nburn, nsave and nskip should be used in practice.

# Fit the model
ptm&lt;-proc.time()
res = frailtyGAFT(Surv(tleft, tright, type="interval2")~x1+x2+baseline(x1, x2)+
                    frailtyprior(prior="car", ID),  data=d, mcmc=mcmc, prior=prior, 
                  Proximity=W);
summary(res);
systime1=proc.time()-ptm; systime1;

### trace plots
par(mfrow = c(3,1))
traceplot(mcmc(res$beta[1,]), main="beta1");
traceplot(mcmc(res$beta[2,]), main="beta2");
traceplot(mcmc(res$beta[3,]), main="beta3");

####################################################################
## Get curves
####################################################################
par(mfrow = c(1,1))
xpred = data.frame(x1=c(1,1.5), x2=c(0,1))
xtfpred = xpred;
plot(res, xnewdata=xpred, xtfnewdata=xtfpred, CI=0.9);
</code></pre>

<hr>
<h2 id='frailtyprior'>Frailty prior specification</h2><span id='topic+frailtyprior'></span>

<h3>Description</h3>

<p>This function allows one to add a frailty term to the linear predictor of semiparametric PH, PO and AFT models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frailtyprior(prior="car", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frailtyprior_+3A_prior">prior</code></td>
<td>
<p>a name string to be entered, e.g, <code>"car"</code>, <code>"iid"</code>, or <code>"grf"</code>; see the example in <code><a href="#topic+frailtyGAFT">frailtyGAFT</a></code> and <code><a href="#topic+survregbayes2">survregbayes2</a></code>.</p>
</td></tr>
<tr><td><code id="frailtyprior_+3A_...">...</code></td>
<td>
<p>Cluster ID to be entered for clustered data or locations for point-referenced data; see the example in <code><a href="#topic+frailtyGAFT">frailtyGAFT</a></code> and <code><a href="#topic+survregbayes2">survregbayes2</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>

<hr>
<h2 id='GetCurves'>Density, Survival, and Hazard Estimates</h2><span id='topic+GetCurves'></span><span id='topic+plot.survregbayes'></span><span id='topic+plot.frailtyGAFT'></span><span id='topic+plot.SuperSurvRegBayes'></span><span id='topic+plot.indeptCoxph'></span><span id='topic+plot.anovaDDP'></span><span id='topic+plot.spCopulaCoxph'></span><span id='topic+plot.spCopulaDDP'></span><span id='topic+plot.SpatDensReg'></span>

<h3>Description</h3>

<p>This function estimates density, survival, and hazard functions given covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCurves(x, xnewdata, xtfnewdata, tgrid = NULL, ygrid = NULL, 
          frail = NULL, CI = 0.95, PLOT = TRUE, ...)
## S3 method for class 'survregbayes'
plot(x, xnewdata, tgrid = NULL, 
     frail = NULL, CI = 0.95, PLOT = TRUE, ...)
## S3 method for class 'frailtyGAFT'
plot(x, xnewdata, xtfnewdata, tgrid = NULL, 
     frail = NULL, CI = 0.95, PLOT = TRUE, ...)
## S3 method for class 'SuperSurvRegBayes'
plot(x, xnewdata, tgrid = NULL, CI = 0.95, PLOT = TRUE, ...)
## S3 method for class 'indeptCoxph'
plot(x, xnewdata, tgrid = NULL, CI = 0.95, PLOT = TRUE, ...)
## S3 method for class 'anovaDDP'
plot(x, xnewdata, tgrid = NULL, CI = 0.95, PLOT = TRUE, ...)
## S3 method for class 'spCopulaCoxph'
plot(x, xnewdata, tgrid = NULL, CI = 0.95, PLOT = TRUE, ...)
## S3 method for class 'spCopulaDDP'
plot(x, xnewdata, tgrid = NULL, CI = 0.95, PLOT = TRUE, ...)
## S3 method for class 'SpatDensReg'
plot(x, xnewdata, ygrid = NULL, CI = 0.95, PLOT = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCurves_+3A_x">x</code></td>
<td>
<p> an object obtained from the functions <code><a href="#topic+survregbayes">survregbayes</a></code>, <code><a href="#topic+frailtyGAFT">frailtyGAFT</a></code>, <code><a href="#topic+SuperSurvRegBayes">SuperSurvRegBayes</a></code>, <code><a href="#topic+indeptCoxph">indeptCoxph</a></code>, <code><a href="#topic+anovaDDP">anovaDDP</a></code>, <code><a href="#topic+spCopulaCoxph">spCopulaCoxph</a></code>, <code><a href="#topic+spCopulaDDP">spCopulaDDP</a></code> and <code><a href="#topic+SpatDensReg">SpatDensReg</a></code>.</p>
</td></tr>
<tr><td><code id="GetCurves_+3A_xnewdata">xnewdata</code></td>
<td>
<p>A data frame in which to look for variables with which to obtain estimated curves.</p>
</td></tr>
<tr><td><code id="GetCurves_+3A_xtfnewdata">xtfnewdata</code></td>
<td>
<p>A data frame in which to look for variables with which to obtain estimated curves, used only for <code><a href="#topic+frailtyGAFT">frailtyGAFT</a></code>.</p>
</td></tr>
<tr><td><code id="GetCurves_+3A_tgrid">tgrid</code></td>
<td>
<p>a vector of grid points indicating where the curves will be estimated.</p>
</td></tr> 
<tr><td><code id="GetCurves_+3A_ygrid">ygrid</code></td>
<td>
<p>a vector of grid points indicating where the curves will be estimated, used only for <code><a href="#topic+SpatDensReg">SpatDensReg</a></code>.</p>
</td></tr> 
<tr><td><code id="GetCurves_+3A_frail">frail</code></td>
<td>
<p>an optional matrix of posterior frailty values for <code><a href="#topic+survregbayes">survregbayes</a></code> and <code><a href="#topic+frailtyGAFT">frailtyGAFT</a></code>, where the rows refer to clusters/regions and the number of columns is the length of thined MCMC chain. The default is to set frailties to be zero.</p>
</td></tr> 
<tr><td><code id="GetCurves_+3A_ci">CI</code></td>
<td>
<p>a numeric value indicating the level of credible interval.</p>
</td></tr>
<tr><td><code id="GetCurves_+3A_plot">PLOT</code></td>
<td>
<p>a logical value indicating whether the estimated survival curves will be plotted.</p>
</td></tr>
<tr><td><code id="GetCurves_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates density, survival, and hazard functions given covariates.
</p>


<h3>Value</h3>

<p>Use <code>names</code> to find out what they are, where <code>fhat</code> represents density, <code>Shat</code> represents survival, <code>hhat</code> represents hazard. The credible bands are also provided, e.g., <code>Shatlow</code> represents the lower band and <code>Shatup</code> represents the upper band.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survregbayes">survregbayes</a></code>, <code><a href="#topic+frailtyGAFT">frailtyGAFT</a></code>, <code><a href="#topic+SuperSurvRegBayes">SuperSurvRegBayes</a></code>, <code><a href="#topic+indeptCoxph">indeptCoxph</a></code>, <code><a href="#topic+anovaDDP">anovaDDP</a></code>, <code><a href="#topic+spCopulaCoxph">spCopulaCoxph</a></code>, <code><a href="#topic+spCopulaDDP">spCopulaDDP</a></code> and <code><a href="#topic+SpatDensReg">SpatDensReg</a></code>
</p>

<hr>
<h2 id='indeptCoxph'>Bayesian Proportional Hazards Model</h2><span id='topic+indeptCoxph'></span><span id='topic+print.indeptCoxph'></span><span id='topic+summary.indeptCoxph'></span><span id='topic+print.summary.indeptCoxph'></span>

<h3>Description</h3>

<p>This function fits a Bayesian proportional hazards model (Zhou, Hanson and Zhang, 2018) for non-spatial right censored time-to-event data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indeptCoxph(formula, data, na.action, prediction=NULL, 
            mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500), 
            prior=NULL, state=NULL, scale.designX=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indeptCoxph_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It currently only supports right-censoring.</p>
</td></tr>
<tr><td><code id="indeptCoxph_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="indeptCoxph_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="indeptCoxph_+3A_prediction">prediction</code></td>
<td>
<p>a list giving the information used to obtain conditional inferences. The list includes the following element: <code>xpred</code> giving the npred by p covariates matrix, used for prediction. If <code>prediction=NULL</code>, <code>xpred</code> will be set to be the design matrix used in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="indeptCoxph_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="indeptCoxph_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. See Zhou, Hanson and Zhang (2018) for more detailed hyperprior specifications.</p>
</td></tr>
<tr><td><code id="indeptCoxph_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis.</p>
</td></tr>  
<tr><td><code id="indeptCoxph_+3A_scale.designx">scale.designX</code></td>
<td>
<p>flag to indicate wheter the design matrix X will be centered by column means and scaled by column standard deviations, where <code>TRUE</code> indicates yes. The default is <code>TRUE</code> for improving numerical stability. Even when it is scaled, the reported regression coefficients are in original scales. Note if we want to specify informative priors for regression coefficients, these priors should correspond to scaled predictors when <code>scale.designX=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Bayesian proportional hazards model (Zhou, Hanson and Zhang, 2018) for non-spatial right censored time-to-event data.
</p>


<h3>Value</h3>

<p>The <code>indeptCoxph</code> object is a list containing at least the following components:
</p>
<table>
<tr><td><code>modelname</code></td>
<td>

<p>the name of the fitted model
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>a named vector of coefficients.  
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>the list of hyperparameters used in all priors. 
</p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>

<p>the list of MCMC parameters used 
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>the number of row observations used in fitting the model
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>the number of columns in the model matrix 
</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used 
</p>
</td></tr>
<tr><td><code>X.scaled</code></td>
<td>

<p>the n by p scaled design matrix
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>the n by p orginal design matrix
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>the p by nsave matrix of posterior samples for the coefficients in the <code>linear.predictors</code> 
</p>
</td></tr>
<tr><td><code>beta.scaled</code></td>
<td>

<p>the p by nsave matrix of posterior samples for the coefficients in the <code>linear.predictors</code>. Note that these posterior samples are based scaled design matrix.
</p>
</td></tr>
<tr><td><code>ratebeta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of beta coefficient vector
</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>

<p>the length n vector of the stabilized estiamte of CPO; used for calculating LPML
</p>
</td></tr>
<tr><td><code>Tpred</code></td>
<td>

<p>the npred by nsave predicted survival times for covariates specified in the argument <code>prediction</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H., Hanson, T., and Zhang, J. (2020). spBayesSurv: Fitting Bayesian Spatial Survival Models Using R. <em>Journal of Statistical Software</em>, 92(9): 1-33.
</p>
<p>Zhou, H., Hanson, T., and Knapp, R. (2015). Marginal Bayesian nonparametric model for time to disease arrival of threatened amphibian populations. <em>Biometrics</em>, 71(4): 1101-1110. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spCopulaCoxph">spCopulaCoxph</a>, <a href="#topic+GetCurves">GetCurves</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############################################################
# A simulated data: Cox PH
###############################################################
rm(list=ls())
library(survival)
library(spBayesSurv)
library(coda)
## True parameters 
betaT = c(1,1); 
n=100; 
## Baseline Survival
f0oft = function(t) 0.5*dlnorm(t, -1, 0.5)+0.5*dlnorm(t,1,0.5);
S0oft = function(t) (0.5*plnorm(t, -1, 0.5, lower.tail=FALSE)+
                       0.5*plnorm(t, 1, 0.5, lower.tail=FALSE))
## The Survival function:
Sioft = function(t,x)  exp( log(S0oft(t))*exp(sum(x*betaT)) ) ;
fioft = function(t,x) exp(sum(x*betaT))*f0oft(t)/S0oft(t)*Sioft(t,x);
Fioft = function(t,x) 1-Sioft(t,x);
## The inverse for Fioft
Finv = function(u, x) uniroot(function (t) Fioft(t,x)-u, lower=1e-100, 
                              upper=1e100, extendInt ="yes", tol=1e-6)$root

## generate x 
x1 = rbinom(n, 1, 0.5); x2 = rnorm(n, 0, 1); X = cbind(x1, x2);
## generate survival times
u = runif(n);
tT = rep(0, n);
for (i in 1:n){
  tT[i] = Finv(u[i], X[i,]);
}

### ----------- right-censored -------------###
t_obs=tT 
Centime = runif(n, 2, 6);
delta = (tT&lt;=Centime) +0 ; 
length(which(delta==0))/n; # censoring rate
rcen = which(delta==0);
t_obs[rcen] = Centime[rcen]; ## observed time 
## make a data frame
d = data.frame(tobs=t_obs, x1=x1, x2=x2, delta=delta, tT=tT); 
table(d$delta)/n;

###############################################################
# Independent Cox PH
###############################################################
# MCMC parameters
nburn=500; nsave=300; nskip=0;
# Note larger nburn, nsave and nskip should be used in practice.
mcmc=list(nburn=nburn, nsave=nsave, nskip=nskip, ndisplay=1000);
prior = list(M=10, r0=1);
# Fit the Cox PH model
res1 = indeptCoxph(formula = Surv(tobs, delta)~x1+x2, data=d, 
                   prior=prior, mcmc=mcmc);
sfit1=summary(res1); sfit1;
## traceplot
par(mfrow = c(2,2))
traceplot(mcmc(res1$beta[1,]), main="beta1")
traceplot(mcmc(res1$beta[2,]), main="beta2")
traceplot(mcmc(res1$h.scaled[2,]), main="h")
traceplot(mcmc(res1$h.scaled[3,]), main="h")

############################################
## Curves
############################################
par(mfrow = c(1,1))
tgrid = seq(1e-10,4,0.1);
xpred = data.frame(x1=c(0,0), x2=c(0,1)); 
plot(res1, xnewdata=xpred, tgrid=tgrid);
</code></pre>

<hr>
<h2 id='LeukSurv'>The Leukemia Survival Data</h2><span id='topic+LeukSurv'></span>

<h3>Description</h3>

<p>A dataset on the survival of acute myeloid leukemia in 1,043 pateietns, first analyzed by Henderson et al. (2002). It is of interest to investigate possible spatial variation in survival after accounting for known subject-specific prognostic factors, which include age, sex, white blood cell count (wbc) at diagnosis, and the Townsend score (tpi) for which higher values indicates less affluent areas. Both exact residential locations of all patients and their administrative districts (24 districts that make up the whole region) are available. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LeukSurv)</code></pre>


<h3>Format</h3>


<table>
<tr>
 <td style="text-align: left;">
    time:</td><td style="text-align: left;"> survival time in days</td>
</tr>
<tr>
 <td style="text-align: left;">
    cens:</td><td style="text-align: left;"> right censoring status 0=censored, 1=dead</td>
</tr>
<tr>
 <td style="text-align: left;">
    xcoord: </td><td style="text-align: left;"> coordinates in x-axis of residence </td>
</tr>
<tr>
 <td style="text-align: left;">
    ycoord: </td><td style="text-align: left;"> coordinates in y-axis of residence </td>
</tr>
<tr>
 <td style="text-align: left;">
    age:</td><td style="text-align: left;"> age in years</td>
</tr>
<tr>
 <td style="text-align: left;">
    sex:</td><td style="text-align: left;">  male=1 female=0</td>
</tr>
<tr>
 <td style="text-align: left;">
    wbc:</td><td style="text-align: left;"> white blood cell count at diagnosis, truncated at 500 </td>
</tr>
<tr>
 <td style="text-align: left;">
    tpi:</td><td style="text-align: left;"> the Townsend score for which higher values indicates less affluent areas</td>
</tr>
<tr>
 <td style="text-align: left;">
    district:</td><td style="text-align: left;"> administrative district of residence </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Henderson, R., Shimakura, S., and Gorst, D. (2002), Modeling spatial variation in leukemia survival data, <em>Journal of the American Statistical Association</em>, 97(460), 965-972.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LeukSurv)
head(LeukSurv)
</code></pre>

<hr>
<h2 id='predict.bspline'>Evaluate a Cubic Spline Basis</h2><span id='topic+predict.bspline'></span>

<h3>Description</h3>

<p>Evaluate a predefined spline basis at given values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bspline'
predict(object, newx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bspline_+3A_object">object</code></td>
<td>
<p>the result of a call to <code><a href="#topic+bspline">bspline</a></code> having attributes describing knots, df, etc..</p>
</td></tr>
<tr><td><code id="predict.bspline_+3A_newx">newx</code></td>
<td>
<p>the <code>x</code> values at which evaluations are required.</p>
</td></tr>
<tr><td><code id="predict.bspline_+3A_...">...</code></td>
<td>
<p>Optional additional arguments. At present no additional arguments are used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspline">bspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
basis &lt;- bspline(women$height, df = 5)
newX &lt;- seq(58, 72, length.out = 51)
# evaluate the basis at the new data
predict(basis, newX)
</code></pre>

<hr>
<h2 id='SpatDensReg'>Bayesian Nonparametric Spatially Smoothed Density Estimation</h2><span id='topic+SpatDensReg'></span><span id='topic+BF.SpatDensReg'></span><span id='topic+print.SpatDensReg'></span><span id='topic+summary.SpatDensReg'></span><span id='topic+print.summary.SpatDensReg'></span>

<h3>Description</h3>

<p>This function provides a Bayesian nonparametric density estimator that changes smoothly in space. The estimator is built from the predictive rule for a marginalized Polya tree (PT), modified so that observations are spatially weighted by their distance from the location of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatDensReg(formula, data, na.action, prior=NULL, state=NULL,
            mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500),
            permutation=TRUE, fix.theta=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatDensReg_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It supports right-censoring, left-censoring, interval-censoring, and mixtures of them. Note: for survival data, the input response should be log survival times.</p>
</td></tr>
<tr><td><code id="SpatDensReg_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="SpatDensReg_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="SpatDensReg_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. The list includes the following parameter: <code>maxL</code> an integer giving the maximum level of Polya trees, (<code>a0</code>, <code>b0</code>) parameters of the gamma prior for the precision parameter alpha, (<code>theta0</code>, <code>V0</code>) mean and variance of the normal prior for the centering distribution parameter vector theta, <code>phiq0</code> the prior probability of phi=0, <code>phib0</code> the rate parameter of the exponential prior of phi. The function itself provides all default priors. See Hanson, Zhou, and de Carvalho (2018).</p>
</td></tr>
<tr><td><code id="SpatDensReg_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. If <code>NULL</code>, all values are provided based on the centering parametric model.</p>
</td></tr> 
<tr><td><code id="SpatDensReg_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="SpatDensReg_+3A_permutation">permutation</code></td>
<td>
<p>flag to indicate whether a random data permutation will be implemented in the beginning of each iterate; default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="SpatDensReg_+3A_fix.theta">fix.theta</code></td>
<td>
<p>flag to indicate whether the centering distribution parameters theta=(location, log(scale)) are fixed; default is <code>TRUE</code> indicating fixed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>SpatDensReg</code> object is a list containing at least the following components:
</p>
<table>
<tr><td><code>modelname</code></td>
<td>

<p>the name of the fitted model
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>the list of hyperparameters used in all priors. 
</p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>

<p>the list of MCMC parameters used 
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>the number of row observations used in fitting the model
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>the number of columns in the model matrix
</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used 
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>the n by p design matrix
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>the 2 by nsave matrix of posterior samples for location and log(scale) involved in the centering distribution of Polya tree prior. 
</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>

<p>the vector of posterior samples for the phi parameter in the marginal PT definition. 
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>the vector of posterior samples for the precision parameter alpha in the PT prior. 
</p>
</td></tr>
<tr><td><code>maxL</code></td>
<td>

<p>the truncation level used in the PT prior. 
</p>
</td></tr>
<tr><td><code>Surv.cox.snell</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used for Cox-Snell residual plot. This is not recommended for frailty models, for which please use the function <code><a href="#topic+cox.snell.survregbayes">cox.snell.survregbayes</a></code>. 
</p>
</td></tr>
<tr><td><code>ratetheta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of theta vector involved in the centering distribution
</p>
</td></tr>
<tr><td><code>ratec</code></td>
<td>

<p>the acceptance rate in the posterior sampling of precision parameter alpha involved in the PT prior
</p>
</td></tr>
<tr><td><code>ratephi</code></td>
<td>

<p>the acceptance rate in the posterior sampling of phi parameter 
</p>
</td></tr>
<tr><td><code>initial.values</code></td>
<td>

<p>the list of initial values used for the parameters 
</p>
</td></tr>
<tr><td><code>BF</code></td>
<td>

<p>the Bayes factor for comparing the spatial model vs. the exchangeable model
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Hanson, T., Zhou, H., and de Carvalho, V. (2018). Bayesian nonparametric spatially smoothed density estimation. In <em>New Frontiers of Biostatistics and Bioinformatics</em> (pp 87-105). Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data
rm(list=ls())
library(survival)
library(spBayesSurv)
library(coda)

## True conditional density
fiofy_x = function(y, x){
  0.5*dnorm(y, -x, 1)+0.5*dnorm(y, x, 1);
}

## Generate data
n = 200;
x = runif(n, 0, 3)
y = rep(0, n);
uu = runif(n);
for(i in 1:n){
  if(uu[i]&lt;0.5){
    y[i] = rnorm(1, -x[i], 1);
  }else{
    y[i] = rnorm(1, x[i], 1);
  }
}

## right censored 
y1=y;y2=y;
Centime = runif(n, 2, 4); 
delta = (y&lt;=Centime) +0 ; 
length(which(delta==0))/n; ## censoring rate
rcen = which(delta==0);
y1[rcen] = Centime[rcen];
y2[rcen] = NA;
## make a data frame
## Method 1: in the interval-censoring notation: 
## y1 is the left endpoint and y2 is the right endpoint.
## This way we could use Surv(y1, y2, type="interval2")
## Method 2: Because we have right-censored data, 
## we could use y1 as the observed survival times and delta as the indicator. 
## This way we could use Surv(y1, delta). This is the same as above. 
d = data.frame(y1=y1, y2=y2, x=x, delta=delta); 

##-------------fit the model-------------------##
# MCMC parameters
nburn=50; nsave=50; nskip=0;
# Note larger nburn, nsave and nskip should be used in practice.
mcmc=list(nburn=nburn, nsave=nsave, nskip=nskip, ndisplay=50);
prior = list(maxL=4, phiq0=0);
# Note please set 0&lt;phiq0&lt;1 for a valid Bayes factor of testing 
# spatial model vs. exchangeable model.
# If the Bayes factor is not needed, setting phiq0=0 will speed up 
# the computing time about seven times. 
state = list(alpha=1);
ptm&lt;-proc.time()
res1 = SpatDensReg(formula = Surv(y1, delta)~x, data=d, 
                   prior=prior, state=state, mcmc=mcmc, permutation = TRUE, 
                   fix.theta=FALSE);
## Or equivalently formula = Surv(y1, y2, type="interval2") can also be used.
sfit=summary(res1); sfit
systime1=proc.time()-ptm; systime1;
traceplot(mcmc(res1$theta[1,]))
traceplot(mcmc(res1$theta[2,]))
traceplot(mcmc(res1$alpha))
traceplot(mcmc(res1$phi))

## plots
ygrid = seq(-6, 6,length.out=100);
xpred = data.frame(x=c(0,1,2,3)); 
plot(res1, xnewdata=xpred, ygrid=ygrid);
</code></pre>

<hr>
<h2 id='spCopulaCoxph'>Marginal Bayesian Proportional Hazards Model via Spatial Copula</h2><span id='topic+spCopulaCoxph'></span><span id='topic+print.spCopulaCoxph'></span><span id='topic+summary.spCopulaCoxph'></span><span id='topic+print.summary.spCopulaCoxph'></span>

<h3>Description</h3>

<p>This function fits a marginal Bayesian proportional hazards model (Zhou, Hanson and Zhang, 2018) for point-referenced right censored time-to-event data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spCopulaCoxph(formula, data, na.action, prediction=NULL, 
              mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500), 
              prior=NULL, state=NULL, scale.designX=TRUE,
              Coordinates, DIST=NULL, Knots=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spCopulaCoxph_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It currently only supports right-censoring.</p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_prediction">prediction</code></td>
<td>
<p>a list giving the information used to obtain conditional inferences. The list includes the following elements: <code>spred</code> and <code>xpred</code> giving the n by 2 new locations and corresponding npred by p covariates matrix, respectively, used for prediction. If <code>prediction=NULL</code>, <code>xpred</code> will be set to be the design matrix used in <code>formula</code>, and <code>spred</code> will be set to be in <code>Coordinates</code>.</p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. See Zhou, Hanson and Zhang (2018) for more detailed hyperprior specifications.</p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis.</p>
</td></tr>  
<tr><td><code id="spCopulaCoxph_+3A_scale.designx">scale.designX</code></td>
<td>
<p>flag to indicate wheter the design matrix X will be centered by column means and scaled by column standard deviations, where <code>TRUE</code> indicates yes. The default is <code>TRUE</code> for improving numerical stability. Even when it is scaled, the reported regression coefficients are in original scales. Note if we want to specify informative priors for regression coefficients, these priors should correspond to scaled predictors when <code>scale.designX=TRUE</code>.</p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_coordinates">Coordinates</code></td>
<td>
<p>an n by 2 coordinates matrix, where n is the sample size, 2 is the dimension of coordiantes. Note all cocordinates should be distinct. </p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_dist">DIST</code></td>
<td>
<p>This is a function argument, used to calculate the distance. The default is Euclidean distance (<code>fields::rdist</code>). This function should have two arguments (X1,X2), where X1 and X2 are matrices with coordinates as the rows. The returned value of this function should be the pairwise distance matrix. If nrow(X1)=m and nrow(X2)=n then the function should return an m by n matrix of all distances between these two sets of points.</p>
</td></tr>
<tr><td><code id="spCopulaCoxph_+3A_knots">Knots</code></td>
<td>
<p>an nknots by 2 matrix, where nknots is the number of selected knots for FSA, and 2 is the dimension of each location. If <code>Knots</code> is not specified, the space-filling algorithm will be used to find the knots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a marginal Bayesian proportional hazards model (Zhou, Hanson and Zhang, 2018) for point-referenced right censored time-to-event data.
</p>


<h3>Value</h3>

<p>The <code>spCopulaCoxph</code> object is a list containing at least the following components:
</p>
<table>
<tr><td><code>modelname</code></td>
<td>

<p>the name of the fitted model
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>a named vector of coefficients.  
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>the list of hyperparameters used in all priors. 
</p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>

<p>the list of MCMC parameters used 
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>the number of row observations used in fitting the model
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>the number of columns in the model matrix 
</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used 
</p>
</td></tr>
<tr><td><code>X.scaled</code></td>
<td>

<p>the n by p scaled design matrix
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>the n by p orginal design matrix
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>the p by nsave matrix of posterior samples for the coefficients in the <code>linear.predictors</code> 
</p>
</td></tr>
<tr><td><code>beta.scaled</code></td>
<td>

<p>the p by nsave matrix of posterior samples for the coefficients in the <code>linear.predictors</code>. Note that these posterior samples are based scaled design matrix.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>the 2 by nsave matrix of posterior samples for sill and range parameters 
</p>
</td></tr>
<tr><td><code>ratebeta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of beta coefficient vector
</p>
</td></tr>
<tr><td><code>ratetheta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of theta 
</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>

<p>the length n vector of the stabilized estiamte of CPO; used for calculating LPML
</p>
</td></tr>
<tr><td><code>Coordinates</code></td>
<td>

<p>the <code>Coordinates</code> matrix used in <code><a href="#topic+survregbayes">survregbayes</a></code> 
</p>
</td></tr>
<tr><td><code>Tpred</code></td>
<td>

<p>the npred by nsave predicted survival times for covariates specified in the argument <code>prediction</code>.
</p>
</td></tr>
<tr><td><code>Zpred</code></td>
<td>

<p>the npred by nsave predicted z values for covariates specified in the argument <code>prediction</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H., Hanson, T., and Zhang, J. (2020). spBayesSurv: Fitting Bayesian Spatial Survival Models Using R. <em>Journal of Statistical Software</em>, 92(9): 1-33.
</p>
<p>Zhou, H., Hanson, T., and Knapp, R. (2015). Marginal Bayesian nonparametric model for time to disease arrival of threatened amphibian populations. <em>Biometrics</em>, 71(4): 1101-1110. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spCopulaDDP">spCopulaDDP</a>, <a href="#topic+GetCurves">GetCurves</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############################################################
# A simulated data: spatial Copula Cox PH
###############################################################
rm(list=ls())
library(survival)
library(spBayesSurv)
library(coda)
## True parameters 
betaT = c(1,1); 
theta1 = 0.98; theta2 = 0.1;
n=50; npred=3; ntot = n+npred;
## Baseline Survival
f0oft = function(t) 0.5*dlnorm(t, -1, 0.5)+0.5*dlnorm(t,1,0.5);
S0oft = function(t) (0.5*plnorm(t, -1, 0.5, lower.tail=FALSE)+
                       0.5*plnorm(t, 1, 0.5, lower.tail=FALSE))
## The Survival function:
Sioft = function(t,x)  exp( log(S0oft(t))*exp(sum(x*betaT)) ) ;
fioft = function(t,x) exp(sum(x*betaT))*f0oft(t)/S0oft(t)*Sioft(t,x);
Fioft = function(t,x) 1-Sioft(t,x);
## The inverse for Fioft
Finv = function(u, x) uniroot(function (t) Fioft(t,x)-u, lower=1e-100, 
                              upper=1e100, extendInt ="yes", tol=1e-6)$root

## generate coordinates: 
## npred is the # of locations for prediction
ldist = 100; wdist = 40;
s1 = runif(ntot, 0, wdist); s2 = runif(ntot, 0, ldist);
s = cbind(s1,s2); #plot(s[,1], s[,2]);
## Covariance matrix
corT = matrix(1, ntot, ntot);
for (i in 1:(ntot-1)){
  for (j in (i+1):ntot){
    dij = sqrt(sum( (s[i,]-s[j,])^2 ));
    corT[i,j] = theta1*exp(-theta2*dij);
    corT[j,i] = theta1*exp(-theta2*dij);
  }
}

## generate x 
x1 = rbinom(ntot, 1, 0.5); x2 = rnorm(ntot, 0, 1); X = cbind(x1, x2);
## generate transformed log of survival times
z = MASS::mvrnorm(1, rep(0, ntot), corT);
## generate survival times
u = pnorm(z);
tT = rep(0, ntot);
for (i in 1:ntot){
  tT[i] = Finv(u[i], X[i,]);
}

### ----------- right-censored -------------###
t_obs=tT 
Centime = runif(ntot, 2, 6);
delta = (tT&lt;=Centime) +0 ; 
length(which(delta==0))/ntot; # censoring rate
rcen = which(delta==0);
t_obs[rcen] = Centime[rcen]; ## observed time 
## make a data frame
dtot = data.frame(tobs=t_obs, x1=x1, x2=x2, delta=delta, tT=tT,
                  s1=s1, s2=s2); 
## Hold out npred for prediction purpose
predindex = sample(1:ntot, npred);
dpred = dtot[predindex,];
d = dtot[-predindex,];
# Prediction settings 
prediction = list(xpred=cbind(dpred$x1, dpred$x2), 
                  spred=cbind(dpred$s1, dpred$s2));

###############################################################
# Independent Cox PH
###############################################################
# MCMC parameters
nburn=500; nsave=500; nskip=0;
# Note larger nburn, nsave and nskip should be used in practice.
mcmc=list(nburn=nburn, nsave=nsave, nskip=nskip, ndisplay=1000);
prior = list(M=10, r0=1, nknots=10, nblock=n);
# here nknots=10&lt;n, so FSA will be used with nblock=n.
# As nknots is getting larger, the FSA is more accurate but slower
# As nblock is getting smaller, the FSA is more accurate but slower. 
# In most applications, setting nblock=n works fine, which is the
# setting by not specifying nblock. 
# If nknots is not specified or nknots=n, the exact covariance is used. 
# Fit the Cox PH model
res1 = spCopulaCoxph(formula = Surv(tobs, delta)~x1+x2, data=d, 
                     prior=prior, mcmc=mcmc, prediction=prediction,
                     Coordinates=cbind(d$s1,d$s2), Knots=NULL);
# here if prediction=NULL, prediction$xpred will be set as the design matrix
# in formula, and prediction$spred will be set as the Coordinates argument. 
# Knots=NULL is the defualt setting, for which the knots will be generated 
# using fields::cover.design() with number of knots equal to prior$nknots. 
sfit1=summary(res1); sfit1;
## MSPE
mean((dpred$tT-apply(res1$Tpred, 1, median))^2); 

## traceplot
par(mfrow = c(2,2))
traceplot(mcmc(res1$beta[1,]), main="beta1")
traceplot(mcmc(res1$beta[2,]), main="beta2")
traceplot(mcmc(res1$theta[1,]), main="sill")
traceplot(mcmc(res1$theta[2,]), main="range")

############################################
## Curves
############################################
par(mfrow = c(1,1))
tgrid = seq(1e-10,4,0.1);
xpred = data.frame(x1=c(0,0), x2=c(0,1)); 
plot(res1, xnewdata=xpred, tgrid=tgrid);
</code></pre>

<hr>
<h2 id='spCopulaDDP'>Marginal Bayesian Nonparametric Survival Model via Spatial Copula</h2><span id='topic+spCopulaDDP'></span>

<h3>Description</h3>

<p>This function fits a marginal Bayesian Nonparametric model (Zhou, Hanson and Knapp, 2015) for point-referenced right censored time-to-event data. Note that the function arguments are slightly different with those presented in the original paper; see Zhou, Hanson and Zhang (2018) for new examples. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spCopulaDDP(formula, data, na.action, prediction=NULL,
            mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500), 
            prior=NULL, state=NULL, scale.designX=TRUE,
            Coordinates, DIST=NULL, Knots=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spCopulaDDP_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It currently only supports right-censoring.</p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_prediction">prediction</code></td>
<td>
<p>a list giving the information used to obtain conditional inferences. The list includes the following elements: <code>spred</code> and <code>xpred</code> giving the n by 2 new locations and corresponding npred by p covariates matrix, respectively, used for prediction. If <code>prediction=NULL</code>, <code>xpred</code> will be set to be the design matrix used in <code>formula</code>, and <code>spred</code> will be set to be in <code>Coordinates</code>.</p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. See Zhou, Hanson and Zhang (2018) for more detailed hyperprior specifications.</p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis.</p>
</td></tr>  
<tr><td><code id="spCopulaDDP_+3A_scale.designx">scale.designX</code></td>
<td>
<p>flag to indicate wheter the design matrix X will be centered by column means and scaled by column standard deviations, where <code>TRUE</code> indicates yes. The default is <code>TRUE</code> for improving numerical stability. Even when it is scaled, the reported regression coefficients are in original scales. Note if we want to specify informative priors for regression coefficients, these priors should correspond to scaled predictors when <code>scale.designX=TRUE</code>.</p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_coordinates">Coordinates</code></td>
<td>
<p>an n by 2 coordinates matrix, where n is the sample size, 2 is the dimension of coordiantes. Note all cocordinates should be distinct. </p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_dist">DIST</code></td>
<td>
<p>This is a function argument, used to calculate the distance. The default is Euclidean distance (<code>fields::rdist</code>). This function should have two arguments (X1,X2), where X1 and X2 are matrices with coordinates as the rows. The returned value of this function should be the pairwise distance matrix. If nrow(X1)=m and nrow(X2)=n then the function should return an m by n matrix of all distances between these two sets of points.</p>
</td></tr>
<tr><td><code id="spCopulaDDP_+3A_knots">Knots</code></td>
<td>
<p>an nknots by 2 matrix, where nknots is the number of selected knots for FSA, and 2 is the dimension of each location. If <code>Knots</code> is not specified, the space-filling algorithm will be used to find the knots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a marginal Bayesian Nonparametric model (Zhou, Hanson and Knapp, 2015) for point-referenced right censored time-to-event data. Note that the function arguments are slightly different with those presented in the original paper; see Zhou, Hanson and Zhang (2018) for new examples. 
</p>


<h3>Value</h3>

<p>The <code>spCopulaDDP</code> object is a list containing at least the following components:
</p>
<table>
<tr><td><code>n</code></td>
<td>

<p>the number of row observations used in fitting the model
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>the number of columns in the model matrix
</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used 
</p>
</td></tr>
<tr><td><code>X.scaled</code></td>
<td>

<p>the n by p scaled design matrix
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>the n by p orginal design matrix
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>the p+1 by N by nsave array of posterior samples for the coefficients
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>the N by nsave matrix of posterior samples for sigma2 involved in the DDP.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>the N by nsave matrix of posterior samples for weights involved in the DDP. 
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>the 2 by nsave matrix of posterior samples for partial sill and range involved in the Gaussian copula.
</p>
</td></tr>
<tr><td><code>Tpred</code></td>
<td>

<p>the npred by nsave predicted survival times for covariates specified in the argument <code>prediction</code>.
</p>
</td></tr>
<tr><td><code>Zpred</code></td>
<td>

<p>the npred by nsave predicted z values for covariates specified in the argument <code>prediction</code>.
</p>
</td></tr>
<tr><td><code>ratey</code></td>
<td>

<p>the n-vector of acceptance rates for sampling censored survival times.
</p>
</td></tr>
<tr><td><code>ratebeta</code></td>
<td>

<p>the N-vector of acceptance rates for sampling beta coefficients.
</p>
</td></tr>
<tr><td><code>ratesigma</code></td>
<td>

<p>the N-vector of acceptance rates for sampling sigma2.
</p>
</td></tr>
<tr><td><code>ratetheta</code></td>
<td>

<p>the acceptance rate for sampling theta. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H., Hanson, T., and Zhang, J. (2020). spBayesSurv: Fitting Bayesian Spatial Survival Models Using R. <em>Journal of Statistical Software</em>, 92(9): 1-33.
</p>
<p>Zhou, H., Hanson, T., and Knapp, R. (2015). Marginal Bayesian nonparametric model for time to disease arrival of threatened amphibian populations. <em>Biometrics</em>, 71(4): 1101-1110. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anovaDDP">anovaDDP</a>, <a href="#topic+GetCurves">GetCurves</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############################################################
# A simulated data: mixture of two normals with spatial dependence
###############################################################
rm(list=ls())
library(survival)
library(spBayesSurv)
library(coda)
## True parameters 
betaT = cbind(c(3.5, 0.5), c(2.5, -1)); 
wT = c(0.4, 0.6); 
sig2T = c(1^2, 0.5^2);
theta1 = 0.98; theta2 = 0.1;
n=30; npred=3; ntot = n+npred;
## The Survival function for log survival times:
fiofy = function(y, xi, w=wT){
  nw = length(w);
  ny = length(y);
  res = matrix(0, ny, nw);
  Xi = c(1,xi);
  for (k in 1:nw){
    res[,k] = w[k]*dnorm(y, sum(Xi*betaT[,k]), sqrt(sig2T[k]) )
  }
  apply(res, 1, sum)
}
fioft = function(t, xi, w=wT) fiofy(log(t), xi, w)/t;
Fiofy = function(y, xi, w=wT){
  nw = length(w);
  ny = length(y);
  res = matrix(0, ny, nw);
  Xi = c(1,xi);
  for (k in 1:nw){
    res[,k] = w[k]*pnorm(y, sum(Xi*betaT[,k]), sqrt(sig2T[k]) )
  }
  apply(res, 1, sum)
}
Fioft = function(t, xi, w=wT) Fiofy(log(t), xi, w);
## The inverse for Fioft
Finv = function(u, x) uniroot(function (y) Fiofy(y,x)-u, lower=-250, 
                              upper=250, extendInt ="yes", tol=1e-6)$root

## generate coordinates: 
## npred is the # of locations for prediction
ldist = 100; wdist = 40;
s1 = runif(ntot, 0, wdist); s2 = runif(ntot, 0, ldist);
s = cbind(s1,s2); #plot(s[,1], s[,2]);
## Covariance matrix
corT = matrix(1, ntot, ntot);
for (i in 1:(ntot-1)){
  for (j in (i+1):ntot){
    dij = sqrt(sum( (s[i,]-s[j,])^2 ));
    corT[i,j] = theta1*exp(-theta2*dij);
    corT[j,i] = theta1*exp(-theta2*dij);
  }
}

## generate x 
x1 = runif(ntot,-1.5,1.5); X = cbind(x1);
## generate transformed log of survival times
z = MASS::mvrnorm(1, rep(0, ntot), corT);
## generate survival times
u = pnorm(z);
tT = rep(0, ntot);
for (i in 1:ntot){
  tT[i] = exp(Finv(u[i], X[i,]));
}

### ----------- right-censored -------------###
t_obs=tT 
Centime = runif(ntot, 200, 500);
delta = (tT&lt;=Centime) +0 ; 
length(which(delta==0))/ntot; # censoring rate
rcen = which(delta==0);
t_obs[rcen] = Centime[rcen]; ## observed time 
## make a data frame
dtot = data.frame(tobs=t_obs, x1=x1, delta=delta, tT=tT,
                  s1=s1, s2=s2); 
## Hold out npred for prediction purpose
predindex = sample(1:ntot, npred);
dpred = dtot[predindex,];
d = dtot[-predindex,];
# Prediction settings 
prediction = list(xpred=cbind(dpred$x1), 
                  spred=cbind(dpred$s1, dpred$s2));

###############################################################
# Independent DDP: Bayesian Nonparametric Survival Model
###############################################################
# MCMC parameters
nburn=100; nsave=100; nskip=0;
# Note larger nburn, nsave and nskip should be used in practice.
mcmc=list(nburn=nburn, nsave=nsave, nskip=nskip, ndisplay=1000);
prior = list(N=10, a0=2, b0=2, nknots=n, nblock=round(n/2));
# here nknots=n, so FSA is not used.
# If nknots&lt;n, FSA will be used with nblock=round(n/2).
# As nknots is getting larger, the FSA is more accurate but slower
# As nblock is getting smaller, the FSA is more accurate but slower. 
# In most applications, setting nblock=n works fine, which is the
# setting by not specifying nblock. 
# If nknots is not specified or nknots=n, the exact covariance is used. 
# Fit the Cox PH model
res1 = spCopulaDDP(formula = Surv(tobs, delta)~x1, data=d, 
                     prior=prior, mcmc=mcmc, prediction=prediction,
                     Coordinates=cbind(d$s1,d$s2), Knots=NULL);
# here if prediction=NULL, prediction$xpred will be set as the design matrix
# in formula, and prediction$spred will be set as the Coordinates argument. 
# Knots=NULL is the defualt setting, for which the knots will be generated 
# using fields::cover.design() with number of knots equal to prior$nknots. 
## LPML
LPML = sum(log(res1$cpo)); LPML;
## Number of non-negligible components
quantile(colSums(res1$w&gt;0.05))
## MSPE
mean((log(dpred$tT)-apply(log(res1$Tpred), 1, median))^2); 

## traceplot
par(mfrow = c(1,2))
traceplot(mcmc(res1$theta[1,]), main="sill")
traceplot(mcmc(res1$theta[2,]), main="range")

############################################
## Curves
############################################
ygrid = seq(0,6.0,length=100); tgrid = exp(ygrid);
ngrid = length(tgrid);
xpred = data.frame(x1=c(-1, 1)); 
plot(res1, xnewdata=xpred, tgrid=tgrid);
</code></pre>

<hr>
<h2 id='SuperSurvRegBayes'>Bayesian Semiparametric Super Survival Model</h2><span id='topic+SuperSurvRegBayes'></span><span id='topic+print.SuperSurvRegBayes'></span><span id='topic+summary.SuperSurvRegBayes'></span><span id='topic+print.summary.SuperSurvRegBayes'></span>

<h3>Description</h3>

<p>This function fits a super survival model (Zhang, Hanson and Zhou, 2018). It can fit both Case I and Case II interval censored data, as well as standard right-censored, uncensored, and mixtures of these. The Bernstein Polynomial Prior is used for fitting the baseline survival function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuperSurvRegBayes(formula, data, na.action, dist="lognormal", 
                  mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500),
                  prior=NULL, state=NULL, truncation_time=NULL, subject.num=NULL, 
                  InitParamMCMC=FALSE, scale.designX=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuperSurvRegBayes_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It supports right-censoring, left-censoring, interval-censoring, and mixtures of them.</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_dist">dist</code></td>
<td>
<p>centering distribution for MPT. Choices include <code>"loglogistic"</code>, <code>"lognormal"</code>, and <code>"weibull"</code>.</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. The list includes: <code>maxL</code> an integer giving the maximum level of MPT, <code>a0</code> and <code>b0</code> gamma prior of the precision parameter of MPT, <code>Shat</code> the initial covariance matrix of adaptive M-H for each of the beta_h, beta_o and beta_q, <code>Vhat</code> the initial covariance matrix of adaptive M-H for theta, <code>beta0</code> and <code>S0</code> the prior for each of the beta_h, beta_o and beta_q, for which the default is the g-prior, <code>theta0</code> and <code>V0</code> the prior for theta.</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis.</p>
</td></tr> 
<tr><td><code id="SuperSurvRegBayes_+3A_truncation_time">truncation_time</code></td>
<td>
<p>a vector of left-trucation times with length n.</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_subject.num">subject.num</code></td>
<td>
<p>a vector of suject id numbers when time dependent covariates are considered. For example, for subject 1 time dependent covariates are recorded over [0,1), [1,3), and for subject 2 covariates are recorded over [0,2), [2,3), [3,4). Suppose we only have two subjects, i.e. n=2. In this case, we save the data in the long format, set truncation_time=c(0,1,0,2,3) and subject.num=c(1,1,2,2,2).</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_initparammcmc">InitParamMCMC</code></td>
<td>
<p>flag to indicate wheter an initial MCMC will be run based on the centering parametric model, where <code>TRUE</code> indicates yes.</p>
</td></tr>
<tr><td><code id="SuperSurvRegBayes_+3A_scale.designx">scale.designX</code></td>
<td>
<p>flag to indicate wheter the design matrix X will be centered by column means and scaled by column standard deviations, where <code>TRUE</code> indicates yes. The default is <code>TRUE</code> for improving numerical stability. Even when it is scaled, the reported regression coefficients are in original scales. Note if we want to specify informative priors for regression coefficients, these priors should correspond to scaled predictors when <code>scale.designX=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>SuperSurvRegBayes</code> object is a list containing at least the following components:
</p>
<table>
<tr><td><code>modelname</code></td>
<td>

<p>the name of the fitted model
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used
</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>

<p>the centering distribution used in the TBP prior on baseline survival function
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>a named vector of coefficients. The last two elements are the estimates of theta1 and theta2 involved in the centering baseline survival function. 
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>the list of hyperparameters used in all priors. 
</p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>

<p>the list of MCMC parameters used 
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>the number of row observations used in fitting the model
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>the number of columns in the model matrix
</p>
</td></tr>
<tr><td><code>nsubject</code></td>
<td>

<p>the number of subjects/individuals, which is equal to n in the absence of time-dependent covariates
</p>
</td></tr>
<tr><td><code>subject.num</code></td>
<td>

<p>the vector of subject id numbers when time dependent covariates are considered
</p>
</td></tr>
<tr><td><code>truncation_time</code></td>
<td>

<p>the vector of left-trucation times
</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used 
</p>
</td></tr>
<tr><td><code>X.scaled</code></td>
<td>

<p>the n by p scaled design matrix
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>the n by p orginal design matrix
</p>
</td></tr>
<tr><td><code>theta.scaled</code></td>
<td>

<p>the 2 by nsave matrix of posterior samples for theta1 and theta2 involved in the centering baseline survival function. Note that these posterior samples are based scaled design matrix.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>the vector of posterior samples for the precision parameter alpha in the TBP prior. 
</p>
</td></tr>
<tr><td><code>maxL</code></td>
<td>

<p>the truncation level used in the TBP prior. 
</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>

<p>the maxL by nsave matrix of posterior samples for the weights in the TBP prior. 
</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>

<p>the length n vector of the stabilized estiamte of CPO; used for calculating LPML
</p>
</td></tr>
<tr><td><code>pD</code></td>
<td>

<p>the effective number of parameters involved in DIC
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>the deviance information criterion (DIC)
</p>
</td></tr>
<tr><td><code>ratetheta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of theta vector involved in the centering baseline survival function
</p>
</td></tr>
<tr><td><code>ratebeta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of beta coefficient vector
</p>
</td></tr>
<tr><td><code>rateYs</code></td>
<td>

<p>the acceptance rate in the posterior sampling of weight vector involved in the TBP prior
</p>
</td></tr>
<tr><td><code>ratec</code></td>
<td>

<p>the acceptance rate in the posterior sampling of precision parameter alpha involved in the TBP prior
</p>
</td></tr>
<tr><td><code>BF</code></td>
<td>

<p>the Bayes factors for testing AFT, PH, PO, AH, EH and YP models. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou
</p>


<h3>References</h3>

<p>Zhang, J., Hanson, T., and Zhou, H. (2019). Bayes factors for choosing among six common survival models. <em>Lifetime Data Analysis</em>, 25(2): 361-379.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survregbayes">survregbayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################################
# A simulated data based on PH_PO_AFT super model
#################################################################
rm(list=ls())
library(coda)
library(survival)
library(spBayesSurv)

## True coeffs
betaT_h = c(1, 1);
betaT_o = c(0, 0);
betaT_q = c(1, 1);
## Baseline Survival
f0oft = function(t) 0.5*dlnorm(t, -1, 0.5)+0.5*dlnorm(t,1,0.5);
S0oft = function(t) {
  0.5*plnorm(t, -1, 0.5, lower.tail=FALSE)+
    0.5*plnorm(t, 1, 0.5, lower.tail=FALSE)
}
h0oft = function(t) f0oft(t)/S0oft(t);
## The Survival function:
Sioft = function(t,x){
  xibeta_h = sum(x*betaT_h);
  xibeta_o = sum(x*betaT_o);
  xibeta_q = sum(x*betaT_q);
  (1+exp(xibeta_o-xibeta_h+xibeta_q)*
     (1/S0oft(exp(xibeta_q)*t)-1))^(-exp(xibeta_h-xibeta_q));
}
Fioft = function(t,x) 1-Sioft(t,x);
## The inverse for Fioft
Finv = function(u, x) uniroot(function (t) Fioft(t,x)-u, lower=1e-100, 
                              upper=1e100, extendInt ="yes", tol=1e-6)$root
### true plots
tt=seq(1e-10, 4, 0.02);
xpred1 = c(0,0);
xpred2 = c(0,1);
plot(tt, Sioft(tt, xpred1), "l", ylim=c(0,1));
lines(tt, Sioft(tt, xpred2), "l");

##-------------Generate data-------------------##
## generate x 
n = 80; 
x1 = rbinom(n, 1, 0.5); x2 = rnorm(n, 0, 1); X = cbind(x1, x2);
## generate survival times
u = runif(n);
tT = rep(0, n);
for (i in 1:n){
  tT[i] = Finv(u[i], X[i,]);
}

### ----------- right censored -------------###
t1=tT;t2=tT;
Centime = runif(n, 2, 6);
delta = (tT&lt;=Centime) +0 ; length(which(delta==0))/n;
rcen = which(delta==0);
t1[rcen] = Centime[rcen];
t2[rcen] = NA;
## make a data frame
d = data.frame(t1=t1, t2=t2, x1=x1, x2=x2, delta=delta, tT=tT); table(d$delta)/n;

##-------------Fit the model-------------------##
# MCMC parameters
nburn=200; nsave=500; nskip=0; niter = nburn+nsave
mcmc=list(nburn=nburn, nsave=nsave, nskip=nskip, ndisplay=1000);
prior = list(maxL=15, a0=1, b0=1, M=10, q=.9);
ptm&lt;-proc.time()
res1 = SuperSurvRegBayes(formula = Surv(t1, t2, type="interval2")~x1+x2, data=d, 
                          prior=prior, mcmc=mcmc, dist="lognormal");
sfit=summary(res1); sfit;
systime1=proc.time()-ptm; systime1;
par(mfrow = c(3,2))
traceplot(mcmc(res1$beta_h[1,]), main="beta_h for x1");
traceplot(mcmc(res1$beta_h[2,]), main="beta_h for x2");
traceplot(mcmc(res1$beta_o[1,]), main="beta_o for x1");
traceplot(mcmc(res1$beta_o[2,]), main="beta_o for x2");
traceplot(mcmc(res1$beta_q[1,]), main="beta_q for x1");
traceplot(mcmc(res1$beta_q[2,]), main="beta_q for x2");

####################################################################
## Get curves
####################################################################
par(mfrow = c(1,1))
tgrid = seq(1e-10,4,0.2);
xpred = data.frame(x1=c(0,0), x2=c(0,1)); 
plot(res1, xnewdata=xpred, tgrid=tgrid);
</code></pre>

<hr>
<h2 id='survregbayes'>Bayesian Semiparametric Survival Models</h2><span id='topic+survregbayes'></span><span id='topic+print.survregbayes'></span><span id='topic+summary.survregbayes'></span><span id='topic+print.summary.survregbayes'></span>

<h3>Description</h3>

<p>This function fits semiparametric proportional hazards (PH), proportional odds (PO), accelerated failture time (AFT) and accelerated hazards (AH) models. Both georeferenced (location observed exactly) and areally observed (location known up to a geographic unit such as a county) spatial locations can be handled. Georeferenced data are modeled with Gaussian random field (GRF) frailties whereas areal data are modeled with a conditional autoregressive (CAR) prior on frailties. For non-spatial clustered data, an IID Gaussian frailties are assumed. Variable selection is also incorporated. The function can fit both Case I and Case II interval censored data, as well as standard right-censored, uncensored, and mixtures of these. The transformed Bernstein Polynomial (TBP) prior is used for fitting the baseline survival function. The full scale approximation (FSA) (Sang and Huang, 2012) could be used to inverse the spatial correlation matrix for georeferenced data. The function also fits all these models without frailties. The logarithm of the pseudo marginal likelihood (LPML), the deviance information criterion (DIC), and the Watanabe-Akaike information criterion (WAIC) are provided for model comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survregbayes(formula, data, na.action, survmodel="PH", dist="loglogistic", 
             mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500), 
             prior=NULL, state=NULL, selection=FALSE, Proximity=NULL, 
             truncation_time=NULL, subject.num=NULL, Knots=NULL,
             Coordinates=NULL, DIST=NULL, InitParamMCMC=TRUE, 
             scale.designX=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survregbayes_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It supports right-censoring, left-censoring, interval-censoring, and mixtures of them. To include CAR frailties, add <code>frailtyprior("car",ID)</code> to the formula, where <code>ID</code> is an n dimensional vector of cluster ID numbers. Furthermore, use <code>frailtyprior("iid",ID)</code> for Gaussian exchangeable frailties, use <code>frailtyprior("grf",ID)</code> for Gaussian random fields (GRF) frailties, and exclude the term <code>frailtyprior()</code> for non-frailty models. Note: the data need to be sorted by ID.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_survmodel">survmodel</code></td>
<td>
<p>a character string for the assumed survival model. The options include <code>"PH"</code> for proportional hazards, <code>"PO"</code> for proportional odds, and <code>"AFT"</code> for accelerated failture time.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_dist">dist</code></td>
<td>
<p>centering distribution for TBP. Choices include <code>"loglogistic"</code>, <code>"lognormal"</code>, and <code>"weibull"</code>.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. The function itself provides all default priors. Note if FSA is used, the number of knots <code>knots</code> and the number of blocks <code>nblock</code> are specified here; see examples below. See Zhou, Hanson and Zhang (2018) for more detailed hyperprior specifications.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis.</p>
</td></tr> 
<tr><td><code id="survregbayes_+3A_selection">selection</code></td>
<td>
<p>flag to indicate whether variable selection is performed, where <code>FALSE</code> indicates that no variable selection will be performed.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_proximity">Proximity</code></td>
<td>
<p>an m by m symetric adjacency matrix, where m is the number of clusters/regions. If CAR frailty model is specified in the formula, <code>Proximity</code> is required; otherwise it is ignored. Note: this matrix should be specified according to the data that have been sorted by ID.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_truncation_time">truncation_time</code></td>
<td>
<p>a vector of left-trucation times with length n.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_subject.num">subject.num</code></td>
<td>
<p>a vector of subject id numbers when time dependent covariates are considered. For example, for subject 1 time dependent covariates are recorded over [0,1), [1,3), and for subject 2 covariates are recorded over [0,2), [2,3), [3,4). Suppose we only have two subjects, i.e. n=2. In this case, we save the data in the long format, set truncation_time=c(0,1,0,2,3) and subject.num=c(1,1,2,2,2).</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_knots">Knots</code></td>
<td>
<p>an nknots by d matrix, where nknots is the number of selected knots for FSA, and d is the dimension of each location. If <code>Knots</code> is not specified, the space-filling algorithm will be used to find the knots.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_coordinates">Coordinates</code></td>
<td>
<p>an m by d coordinates matrix, where m is the number of clusters/regions, d is the dimension of coordiantes. If GRF frailty model is specified in the formula, <code>Coordinates</code> is required; otherwise it is ignored. Note: this matrix should be specified according to the data that have been sorted by ID.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_dist">DIST</code></td>
<td>
<p>This is a function argument, used to calculate the distance. The default is Euclidean distance (<code>fields::rdist</code>). This function should have two arguments (X1,X2), where X1 and X2 are matrices with coordinates as the rows. The returned value of this function should be the pairwise distance matrix. If nrow(X1)=m and nrow(X2)=n then the function should return an m by n matrix of all distances between these two sets of points.</p>
</td></tr>
<tr><td><code id="survregbayes_+3A_initparammcmc">InitParamMCMC</code></td>
<td>
<p>flag to indicate whether an initial MCMC will be run based on the centering parametric model, where <code>TRUE</code> indicates yes. </p>
</td></tr>
<tr><td><code id="survregbayes_+3A_scale.designx">scale.designX</code></td>
<td>
<p>flag to indicate whether the design matrix X will be centered by column means and scaled by column standard deviations, where <code>TRUE</code> indicates yes. The default is <code>TRUE</code> for improving numerical stability. Even when it is scaled, the reported regression coefficients are in original scales. Note if we want to specify informative priors for regression coefficients, these priors should correspond to scaled predictors when <code>scale.designX=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This class of objects is returned by the <code>survregbayes</code> function to represent a fitted Bayesian semiparametric survival model. Objects of this class have methods for the functions <code>print</code>, <code>summary</code> and <code>plot</code>.
</p>
<p>The <code>survregbayes</code> object is a list containing at least the following components:
</p>
<table>
<tr><td><code>modelname</code></td>
<td>

<p>the name of the fitted model
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used
</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>

<p>the centering distribution used in the TBP prior on baseline survival function
</p>
</td></tr>
<tr><td><code>survmodel</code></td>
<td>

<p>the model fitted 
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>a named vector of coefficients. The last two elements are the estimates of theta1 and theta2 involved in the centering baseline survival function. 
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>the list of hyperparameters used in all priors. 
</p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>

<p>the list of MCMC parameters used 
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>the number of row observations used in fitting the model
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>the number of columns in the model matrix
</p>
</td></tr>
<tr><td><code>nsubject</code></td>
<td>

<p>the number of subjects/individuals, which is equal to n in the absence of time-dependent covariates
</p>
</td></tr>
<tr><td><code>subject.num</code></td>
<td>

<p>the vector of subject id numbers when time dependent covariates are considered
</p>
</td></tr>
<tr><td><code>truncation_time</code></td>
<td>

<p>the vector of left-trucation times
</p>
</td></tr>
<tr><td><code>Surv</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used 
</p>
</td></tr>
<tr><td><code>X.scaled</code></td>
<td>

<p>the n by p scaled design matrix
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>the n by p orginal design matrix
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>the p by nsave matrix of posterior samples for the coefficients in the <code>linear.predictors</code>
</p>
</td></tr>
<tr><td><code>theta.scaled</code></td>
<td>

<p>the 2 by nsave matrix of posterior samples for theta1 and theta2 involved in the centering baseline survival function. Note that these posterior samples are based scaled design matrix.
</p>
</td></tr>
<tr><td><code>beta.scaled</code></td>
<td>

<p>the p by nsave matrix of posterior samples for the coefficients in the <code>linear.predictors</code>. Note that these posterior samples are based scaled design matrix.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>the vector of posterior samples for the precision parameter alpha in the TBP prior. 
</p>
</td></tr>
<tr><td><code>maxL</code></td>
<td>

<p>the truncation level used in the TBP prior. 
</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>

<p>the maxL by nsave matrix of posterior samples for the weights in the TBP prior. 
</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>

<p>the length n vector of the stabilized estiamte of CPO; used for calculating LPML
</p>
</td></tr>
<tr><td><code>pD</code></td>
<td>

<p>the effective number of parameters involved in DIC
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>the deviance information criterion (DIC)
</p>
</td></tr>
<tr><td><code>pW</code></td>
<td>

<p>the effective number of parameters involved in WAIC
</p>
</td></tr>
<tr><td><code>WAIC</code></td>
<td>

<p>the Watanabe-Akaike information criterion (WAIC)
</p>
</td></tr>
<tr><td><code>Surv.cox.snell</code></td>
<td>

<p>the <code><a href="survival.html#topic+Surv">Surv</a></code> object used for Cox-Snell residual plot. This is not recommended for frailty models, for which please use the function <code><a href="#topic+cox.snell.survregbayes">cox.snell.survregbayes</a></code>. 
</p>
</td></tr>
<tr><td><code>ratetheta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of theta vector involved in the centering baseline survival function
</p>
</td></tr>
<tr><td><code>ratebeta</code></td>
<td>

<p>the acceptance rate in the posterior sampling of beta coefficient vector
</p>
</td></tr>
<tr><td><code>rateYs</code></td>
<td>

<p>the acceptance rate in the posterior sampling of weight vector involved in the TBP prior
</p>
</td></tr>
<tr><td><code>ratec</code></td>
<td>

<p>the acceptance rate in the posterior sampling of precision parameter alpha involved in the TBP prior
</p>
</td></tr>
<tr><td><code>frail.prior</code></td>
<td>

<p>the frailty prior used in <code><a href="#topic+frailtyprior">frailtyprior</a></code> 
</p>
</td></tr>
<tr><td><code>selection</code></td>
<td>

<p>whether the variable selection was performed 
</p>
</td></tr>
<tr><td><code>initial.values</code></td>
<td>

<p>the list of initial values used for the parameters 
</p>
</td></tr>
<tr><td><code>BF.baseline</code></td>
<td>

<p>the Bayes factor for comparing the parametric baseline vs. the TBP baseline 
</p>
</td></tr>
<tr><td><code>BF.bs</code></td>
<td>

<p>Bayes factors for testing linearity when <code><a href="#topic+bspline">bspline</a></code> is added to the <code>linear.predictors</code>
</p>
</td></tr>
</table>
<p>The object will also have the following components when frailty models are fit:
</p>
<table>
<tr><td><code>v</code></td>
<td>

<p>the nID by nsave matrix of posterior samples for frailties, where nID is the number of clusters considered.
</p>
</td></tr>
<tr><td><code>ratev</code></td>
<td>

<p>the vector of acceptance rates in the posterior sampling of frailties 
</p>
</td></tr>
<tr><td><code>tau2</code></td>
<td>

<p>the vector of posterior samples for tau2 involved in the IID, GRF or CAR frailty prior. 
</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>

<p>the cluster ID used in <code><a href="#topic+frailtyprior">frailtyprior</a></code> 
</p>
</td></tr>
</table>
<p>If GRF frailties are used, the object will also have:
</p>
<table>
<tr><td><code>Coordinates</code></td>
<td>

<p>the <code>Coordinates</code> matrix used in <code><a href="#topic+survregbayes">survregbayes</a></code> 
</p>
</td></tr>
<tr><td><code>ratephi</code></td>
<td>

<p>the acceptance rates in the posterior sampling of phi involved in the GRF prior 
</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>

<p>the vector of posterior samples for phi involved in the GRF prior 
</p>
</td></tr>
<tr><td><code>Knots</code></td>
<td>

<p>the <code>Knots</code> matrix used in <code><a href="#topic+survregbayes">survregbayes</a></code> 
</p>
</td></tr>
</table>
<p>If the variable selection is performed, the object will also include:
</p>
<table>
<tr><td><code>gamma</code></td>
<td>

<p>the p by nsave matrix of posterior samples for gamma involved in the variable selection
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H., Hanson, T., and Zhang, J. (2020). spBayesSurv: Fitting Bayesian Spatial Survival Models Using R. <em>Journal of Statistical Software</em>, 92(9): 1-33.
</p>
<p>Zhou, H. and Hanson, T. (2018). A unified framework for fitting Bayesian semiparametric models to arbitrarily censored survival data, including spatially-referenced data. <em>Journal of the American Statistical Association</em>, 113(522): 571-581.
</p>
<p>Sang, H. and Huang, J. Z. (2012). A full scale approximation of covariance functions for large spatial data sets. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 74(1), 111-132.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyprior">frailtyprior</a></code>, <code><a href="#topic+cox.snell.survregbayes">cox.snell.survregbayes</a></code>, <code>rdist</code>, <code>rdist.earth</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rm(list=ls())
library(survival)
library(spBayesSurv)
library(coda)
library(MASS)
library(fields)

## True coeffs
betaT = c(1,1); 
## Baseline Survival
f0oft = function(t) 0.5*dlnorm(t, -1, 0.5)+0.5*dlnorm(t,1,0.5);
S0oft = function(t) (0.5*plnorm(t, -1, 0.5, lower.tail=FALSE)+
                       0.5*plnorm(t, 1, 0.5, lower.tail=FALSE))
## The Survival function:
Sioft = function(t,x,v=0)  exp( log(S0oft(t))*exp(sum(x*betaT)+v) ) ;
Fioft = function(t,x,v=0) 1-Sioft(t,x,v);
## The inverse for Fioft
Finv = function(u, x,v=0) uniroot(function (t) Fioft(t,x,v)-u, lower=1e-100, 
                                  upper=1e100, extendInt ="yes", tol=1e-6)$root
## correlation function
rho_Exp = function(dis, phi) exp(-(dis*phi));

###############################################################################
########################### Start to simulation ###############################
###############################################################################
phiT=1; sill=0.9999; ## phiT is the range parameter phi. 
tau2T = 1; ## true frailty variance; 
m = 50; mi=2
id=rep(1:m, each=mi)
mseq = rep(mi, m);
n = sum(mseq);
s1 = runif(m, 0, 10); s2 = runif(m, 0, 10);
locs = cbind(s1, s2); 
ss = cbind(rep(locs[,1],each=mi), rep(locs[,2],each=mi)); ### the locations. 
Dmm = .Call("DistMat", t(locs), t(locs), PACKAGE = "spBayesSurv");
Rmm = sill*rho_Exp(Dmm, phiT)+diag(1-sill, m, m);
v = mvrnorm(1, mu=rep(0,m), Sigma=tau2T*Rmm); 
vn = rep(v, each=mi)
## generate x 
x1 = rbinom(n, 1, 0.5); x2 = rnorm(n, 0, 1); X = cbind(x1, x2);
## generate survival times
u = runif(n);
tT = rep(0, n);
for (i in 1:n){
  tT[i] = Finv(u[i], X[i,], vn[i]);
}

### ----------- right censored -------------###
t1=tT;t2=tT;
## right censored
Centime = runif(n, 2,6);
delta = (tT&lt;=Centime) +0 ; length(which(delta==0))/n;
rcen = which(delta==0);
t1[rcen] = Centime[rcen];
t2[rcen] = NA;
## make a data frame
## Method 1: in the interval-censoring notation: 
## t1 is the left endpoint and t2 is the right endpoint.
## This way we could use Surv(t1, t2, type="interval2")
## Method 2: Because we have right-censored data, 
## we could use t1 as the observed survival times and delta as the indicator. 
## This way we could use Surv(t1, delta). This is the same as above. 
## (s1, s2) are the locations. 
d = data.frame(t1=t1, t2=t2, x1=x1, x2=x2, delta=delta, 
               s1=ss[,1], s2=ss[,2], id=id); 
table(d$delta)/n;

##-------------spBayesSurv-------------------##
# MCMC parameters
nburn=200; nsave=200; nskip=0;
# Note larger nburn, nsave and nskip should be used in practice.
mcmc=list(nburn=nburn, nsave=nsave, nskip=nskip, ndisplay=1000);
prior = list(maxL=15, a0=1, b0=1, nknots=m, nblock=m, nu=1);
# here if nknots&lt;m, FSA will be used with nblock=m.
cor.dist = function(x1, x2) rdist(x1,x2)
ptm&lt;-proc.time()
res1 = survregbayes(formula = Surv(t1, delta)~x1+x2+
                       frailtyprior("grf", id), data=d, InitParamMCMC=FALSE,
                     survmodel="PH", prior=prior, mcmc=mcmc, DIST=cor.dist,
                     dist="loglogistic", Coordinates = locs);
## Or equivalently formula = Surv(t1, t2, type="interval2") can also be used.
## Note InitParamMCMC=FALSE is used for speeding,
## InitParamMCMC=TRUE is recommended in general. 
sfit=summary(res1); sfit
systime1=proc.time()-ptm; systime1;

############################################
## Results
############################################
## acceptance rate of frailties
res1$ratev[1]
## traceplots;
par(mfrow=c(2,3));
traceplot(mcmc(res1$beta[1,]), main="beta1");
traceplot(mcmc(res1$beta[2,]), main="beta2");
traceplot(mcmc(res1$v[1,]), main="frailty");
traceplot(mcmc(res1$v[2,]), main="frailty");
traceplot(mcmc(res1$v[3,]), main="frailty");
#traceplot(mcmc(res1$v[4,]), main="frailty");
traceplot(mcmc(res1$phi), main="phi");

############################################
## Curves
############################################
par(mfrow=c(1,1));
wide=0.2;
tgrid = seq(1e-10,4,wide);
ngrid = length(tgrid);
p = length(betaT); # number of covariates
newdata = data.frame(x1=c(0,0), x2=c(0,1))
plot(res1, xnewdata=newdata, tgrid=tgrid, PLOT=TRUE);

## Cox-Snell plot
set.seed(1)
cox.snell.survregbayes(res1, ncurves=2, PLOT=TRUE);
</code></pre>

<hr>
<h2 id='survregbayes2'>Bayesian Semiparametric Survival Models</h2><span id='topic+survregbayes2'></span><span id='topic+print.survregbayes2'></span><span id='topic+plot.survregbayes2'></span><span id='topic+summary.survregbayes2'></span><span id='topic+print.summary.survregbayes2'></span>

<h3>Description</h3>

<p>This function fits mixtures of Polya trees (MPT) proportional hazards, proportional odds, and accelerated failture time models. It also allows to include exchangeable and CAR frailties for fitting clusterd survival data. The function can fit both Case I and Case II interval censored data, as well as standard right-censored, uncensored, and mixtures of these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survregbayes2(formula, data, na.action, survmodel="PH", dist="loglogistic", 
              mcmc=list(nburn=3000, nsave=2000, nskip=0, ndisplay=500), 
              prior=NULL, state=NULL, selection=FALSE, Proximity=NULL,
              truncation_time=NULL, subject.num=NULL, InitParamMCMC=TRUE, 
              scale.designX=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survregbayes2_+3A_formula">formula</code></td>
<td>
<p>a formula expression with the response returned by the <code>Surv</code> function in the <code>survival</code> package. It supports right-censoring, left-censoring, interval-censoring, and mixtures of them. To include CAR frailties, add <code>frailtyprior("car",ID)</code> to the formula, where <code>ID</code> is an n dimensional vector of cluster ID numbers. Furthermore, use <code>frailtyprior("iid",ID)</code> for Gaussian IID frailties, and exclude the term <code>frailtyprior()</code> for non-frailty models. Note: the data need to be sorted by ID.</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied to the <code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_survmodel">survmodel</code></td>
<td>
<p>a character string for the assumed survival model. The options include <code>"PH"</code> for proportional hazards, <code>"PO"</code> for proportional odds, and <code>"AFT"</code> for accelerated failture time.</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_dist">dist</code></td>
<td>
<p>centering distribution for MPT. Choices include <code>"loglogistic"</code>, <code>"lognormal"</code>, and <code>"weibull"</code>.</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. The list must include the following elements: <code>nburn</code> an integer giving the number of burn-in scans, <code>nskip</code> an integer giving the thinning interval, <code>nsave</code> an integer giving the total number of scans to be saved, <code>ndisplay</code> an integer giving the number of saved scans to be displayed on screen (the function reports on the screen when every <code>ndisplay</code> iterations have been carried out).</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. The list includes the following parameter: <code>maxL</code> an integer giving the maximum number of mixtures of beta distributions. The function itself provides all default priors. </p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis.</p>
</td></tr> 
<tr><td><code id="survregbayes2_+3A_selection">selection</code></td>
<td>
<p>flag to indicate whether variable selection is performed, where <code>FALSE</code> indicates that no variable selection will be performed.</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_proximity">Proximity</code></td>
<td>
<p>an m by m symetric adjacency matrix, where m is the number of clusters/regions. If CAR frailty model is specified in the formula, <code>Proximity</code> is required; otherwise it is ignored. Note: this matrix should be specified according to the data that have been sorted by ID.</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_truncation_time">truncation_time</code></td>
<td>
<p>a vector of left-trucation times with length n.</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_subject.num">subject.num</code></td>
<td>
<p>a vector of suject id numbers when time dependent covariates are considered. For example, for subject 1 time dependent covariates are recorded over [0,1), [1,3), and for subject 2 covariates are recorded over [0,2), [2,3), [3,4). Suppose we only have two subjects, i.e. n=2. In this case, we save the data in the long format, set truncation_time=c(0,1,0,2,3) and subject.num=c(1,1,2,2,2).</p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_initparammcmc">InitParamMCMC</code></td>
<td>
<p>flag to indicate wheter an initial MCMC will be run based on the centering parametric model, where <code>TRUE</code> indicates yes. </p>
</td></tr>
<tr><td><code id="survregbayes2_+3A_scale.designx">scale.designX</code></td>
<td>
<p>flag to indicate wheter the design matrix X will be centered by column means and scaled by column standard deviations, where <code>TRUE</code> indicates yes. The default is <code>TRUE</code> for improving numerical stability. Even when it is scaled, the reported regression coefficients are in original scales. Note if we want to specify informative priors for regression coefficients, these priors should correspond to scaled predictors when <code>scale.designX=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results include the MCMC chains for the parameters; use <code>names</code> to find out what they are.
</p>


<h3>Author(s)</h3>

<p>Haiming Zhou and Timothy Hanson
</p>


<h3>References</h3>

<p>Zhou, H. and Hanson, T. (2015). Bayesian spatial survival models. In Nonparametric Bayesian Inference in Biostatistics (pp 215-246). Springer International Publishing.
</p>
<p>Zhao, L. and Hanson, T. (2011). Spatially dependent Polya tree modeling for survival data. <em>Biometrics</em>, 67(2), 391-403.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyprior">frailtyprior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rm(list=ls())
library(coda)
library(survival)
library(spBayesSurv)

## True coeffs
betaT = c(1,1); 
## Baseline Survival
f0oft = function(t) 0.5*dlnorm(t, -1, 0.5)+0.5*dlnorm(t,1,0.5);
S0oft = function(t) (0.5*plnorm(t, -1, 0.5, lower.tail=FALSE)+
                       0.5*plnorm(t, 1, 0.5, lower.tail=FALSE));
## The Survival function:
Sioft = function(t,x,v=0)  exp( log(S0oft(t))*exp(sum(x*betaT)+v) ) ;
Fioft = function(t,x,v=0) 1-Sioft(t,x,v);
## The inverse for Fioft
Finv = function(u, x,v=0) uniroot(function (t) Fioft(t,x,v)-u, 
                                  lower=1e-100, upper=1e100,
                                  extendInt ="yes")$root

##-------------Generate data-------------------##
## generate x 
n = 100; 
x1 = rbinom(n, 1, 0.5); x2 = rnorm(n, 0, 1); X = cbind(x1, x2);
## generate survival times
u = runif(n);
tT = rep(0, n);
for (i in 1:n){
  tT[i] = Finv(u[i], X[i,]);
}

### ----------- partly interval-censored -------------###
t1=rep(NA, n);t2=rep(NA, n); delta=rep(NA, n); 
n1 = floor(0.5*n); ## right-censored part
n2 = n-n1; ## interval-censored part
# right-censored part
rcen = sample(1:n, n1);
t1_r=tT[rcen];t2_r=tT[rcen];
Centime = runif(n1, 2, 6);
delta_r = (tT[rcen]&lt;=Centime) +0 ; length(which(delta_r==0))/n1;
t1_r[which(delta_r==0)] = Centime[which(delta_r==0)];
t2_r[which(delta_r==0)] = NA;
t1[rcen]=t1_r; t2[rcen]=t2_r; delta[rcen] = delta_r;
# interval-censored part
intcen = (1:n)[-rcen];
t1_int=rep(NA, n2);t2_int=rep(NA, n2); delta_int=rep(NA, n2);
npois = rpois(n2, 2)+1;
for(i in 1:n2){
  gaptime = cumsum(rexp(npois[i], 1)); 
  pp = Fioft(gaptime, X[intcen[i],]);
  ind = sum(u[intcen[i]]&gt;pp); 
  if (ind==0){
    delta_int[i] = 2;
    t2_int[i] = gaptime[1];
  }else if (ind==npois[i]){
    delta_int[i] = 0;
    t1_int[i] = gaptime[ind];
  }else{
    delta_int[i] = 3;
    t1_int[i] = gaptime[ind];
    t2_int[i] = gaptime[ind+1];
  }
}
t1[intcen]=t1_int; t2[intcen]=t2_int; delta[intcen] = delta_int;
## make a data frame
d = data.frame(t1=t1, t2=t2, x1=x1, x2=x2, delta=delta, tT=tT);
table(d$delta)/n;

##-------------spBayesSurv-------------------##
fit0=survreg(formula = Surv(t1, t2, type="interval2")~x1+x2, 
             data=d, dist="loglogistic");
# MCMC parameters
nburn=500; nsave=500; nskip=0; niter = nburn+nsave
# Note larger nburn, nsave and nskip should be used in practice.
mcmc=list(nburn=nburn, nsave=nsave, nskip=nskip, ndisplay=500);
prior = list(maxL=4, a0=1, b0=1);
ptm&lt;-proc.time()
res = survregbayes2(formula = Surv(t1, t2, type="interval2")~x1+x2, data=d, 
                     survmodel="PH", prior=prior, mcmc=mcmc, 
                    dist="loglogistic", InitParamMCMC=FALSE);
## Note InitParamMCMC=FALSE is used only speeding,
## InitParamMCMC=TRUE is recommended in general. 
sfit=summary(res); sfit;
systime=proc.time()-ptm; 

### trace plots
par(mfrow = c(2,2));
traceplot(mcmc(res$beta[1,]), main="beta1");
traceplot(mcmc(res$beta[2,]), main="beta2");

####################################################################
## Get curves
####################################################################
par(mfrow = c(1,1));
wide=0.01;
tgrid = seq(0.001,4,wide);
ngrid = length(tgrid);
xnew = c(0,1)
xpred = cbind(c(0,0), xnew); 
nxpred = nrow(xpred);
estimates=plot(res, xpred, tgrid);
## plots
## survival function when x=(0,0)
i=2
par(cex=1.5,mar=c(4.1,4.1,1,1),cex.lab=1.4,cex.axis=1.1)
plot(tgrid, Sioft(tgrid, c(0,xnew[i])), "l", lwd=3, 
     xlim=c(0,3), xlab="time", ylab="survival");
polygon(x=c(rev(tgrid),tgrid),
        y=c(rev(estimates$Shatlow[,i]),estimates$Shatup[,i]),
        border=NA,col="lightgray");
lines(tgrid, Sioft(tgrid, c(0,xnew[i])), "l", lwd=3);
lines(tgrid, estimates$Shat[,i], lty=3, lwd=3, col=1);
## survival function when x=(0,0)
i=1
par(cex=1.5,mar=c(4.1,4.1,1,1),cex.lab=1.4,cex.axis=1.1)
lines(tgrid, Sioft(tgrid, c(0,xnew[i])), "l", lwd=3, 
     xlim=c(0,3), xlab="time", ylab="survival");
polygon(x=c(rev(tgrid),tgrid),
        y=c(rev(estimates$Shatlow[,i]),estimates$Shatup[,i]),
        border=NA,col="lightgray");
lines(tgrid, Sioft(tgrid, c(0,xnew[i])), "l", lwd=3);
lines(tgrid, estimates$Shat[,i], lty=3, lwd=3, col=1);
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
