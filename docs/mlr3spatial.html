<!DOCTYPE html><html><head><title>Help for package mlr3spatial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlr3spatial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mlr3spatial-package'><p>mlr3spatial: Support for Spatial Objects Within the 'mlr3' Ecosystem</p></a></li>
<li><a href='#as_data_backend.stars'><p>Coerce to spatial DataBackend</p></a></li>
<li><a href='#as_task_classif_st'><p>Convert to a Spatiotemporal Classification Task</p></a></li>
<li><a href='#as_task_regr_st'><p>Convert to a Spatiotemporal Regression Task</p></a></li>
<li><a href='#block_size'><p>Split Raster Into Chunks</p></a></li>
<li><a href='#DataBackendRaster'><p>DataBackend for Raster Objects</p></a></li>
<li><a href='#DataBackendVector'><p>DataBackend for Vector Objects</p></a></li>
<li><a href='#factor_layer'><p>Factor Layer Generator</p></a></li>
<li><a href='#generate_stack'><p>Generate Raster Stack</p></a></li>
<li><a href='#leipzig'><p>Leipzig Land Cover Task</p></a></li>
<li><a href='#mask_stack'><p>Sample Points in Raster Stack</p></a></li>
<li><a href='#numeric_layer'><p>Numeric Layer Generator</p></a></li>
<li><a href='#predict_spatial'><p>Predict on Spatial Objects with mlr3 Learners</p></a></li>
<li><a href='#sample_stack'><p>Sample Points in Raster Stack</p></a></li>
<li><a href='#TaskClassifST'><p>Spatiotemporal Classification Task</p></a></li>
<li><a href='#TaskRegrST'><p>Spatiotemporal Regression Task</p></a></li>
<li><a href='#write_raster'><p>Write a Raster in Chunks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Support for Spatial Objects Within the 'mlr3' Ecosystem</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends the 'mlr3' ML framework with methods for spatial
    objects. Data storage and prediction are supported for packages
    'terra', 'raster' and 'stars'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlr3spatial.mlr-org.com">https://mlr3spatial.mlr-org.com</a>,
<a href="https://github.com/mlr-org/mlr3spatial">https://github.com/mlr-org/mlr3spatial</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/mlr3spatial/issues">https://github.com/mlr-org/mlr3spatial/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mlr3 (&ge; 0.14.0), R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.0.0), data.table (&ge; 1.14.0), lgr (&ge; 0.4.2),
methods, mlr3misc (&ge; 0.11.0), R6 (&ge; 2.5.0), sf, terra (&ge;
1.6-3), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, future, future.callr, knitr, mlr3learners (&ge; 0.4.5),
paradox, ranger, raster, rmarkdown, rpart, stars (&ge; 0.5-5),
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'DataBackendRaster.R' 'DataBackendVector.R'
'LearnerClassifSpatial.R' 'LearnerRegrSpatial.R' 'TaskRegrST.R'
'TaskClassifST.R' 'TaskClassif_leipzig.R'
'as_task_classif_st.R' 'as_task_regr_st.R'
'as_task_unsupervised.R' 'data.R' 'helper.R'
'predict_spatial.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-09 12:22:52 UTC; marc</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Becker <a href="https://orcid.org/0000-0002-8115-0400"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Patrick Schratz <a href="https://orcid.org/0000-0003-0748-6624"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Becker &lt;marcbecker@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-09 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mlr3spatial-package'>mlr3spatial: Support for Spatial Objects Within the 'mlr3' Ecosystem</h2><span id='topic+mlr3spatial'></span><span id='topic+mlr3spatial-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Extends the 'mlr3' ML framework with methods for spatial objects. Data storage and prediction are supported for packages 'terra', 'raster' and 'stars'.
</p>


<h3>Learn mlr3</h3>


<ul>
<li><p> Book on mlr3: <a href="https://mlr3book.mlr-org.com">https://mlr3book.mlr-org.com</a>
</p>
</li>
<li><p> Use cases and examples gallery: <a href="https://mlr3gallery.mlr-org.com">https://mlr3gallery.mlr-org.com</a>
</p>
</li>
<li><p> Cheat Sheets: <a href="https://github.com/mlr-org/mlr3cheatsheets">https://github.com/mlr-org/mlr3cheatsheets</a>
</p>
</li></ul>



<h3>mlr3 extensions</h3>


<ul>
<li><p> Preprocessing and machine learning pipelines: <a href="https://CRAN.R-project.org/package=mlr3pipelines"><span class="pkg">mlr3pipelines</span></a>
</p>
</li>
<li><p> Analysis of benchmark experiments: <a href="https://CRAN.R-project.org/package=mlr3benchmark"><span class="pkg">mlr3benchmark</span></a>
</p>
</li>
<li><p> More classification and regression tasks: <a href="https://CRAN.R-project.org/package=mlr3data"><span class="pkg">mlr3data</span></a>
</p>
</li>
<li><p> Connector to <a href="https://www.openml.org">OpenML</a>: <a href="https://CRAN.R-project.org/package=mlr3oml"><span class="pkg">mlr3oml</span></a>
</p>
</li>
<li><p> Solid selection of good classification and regression learners: <a href="https://CRAN.R-project.org/package=mlr3learners"><span class="pkg">mlr3learners</span></a>
</p>
</li>
<li><p> Even more learners: <a href="https://github.com/mlr-org/mlr3extralearners">https://github.com/mlr-org/mlr3extralearners</a>
</p>
</li>
<li><p> Tuning of hyperparameters: <a href="https://CRAN.R-project.org/package=mlr3tuning"><span class="pkg">mlr3tuning</span></a>
</p>
</li>
<li><p> Hyperband tuner: <a href="https://CRAN.R-project.org/package=mlr3hyperband"><span class="pkg">mlr3hyperband</span></a>
</p>
</li>
<li><p> Visualizations for many <span class="pkg">mlr3</span> objects: <a href="https://CRAN.R-project.org/package=mlr3viz"><span class="pkg">mlr3viz</span></a>
</p>
</li>
<li><p> Survival analysis and probabilistic regression: <a href="https://CRAN.R-project.org/package=mlr3proba"><span class="pkg">mlr3proba</span></a>
</p>
</li>
<li><p> Cluster analysis: <a href="https://CRAN.R-project.org/package=mlr3cluster"><span class="pkg">mlr3cluster</span></a>
</p>
</li>
<li><p> Feature selection filters: <a href="https://CRAN.R-project.org/package=mlr3filters"><span class="pkg">mlr3filters</span></a>
</p>
</li>
<li><p> Feature selection wrappers: <a href="https://CRAN.R-project.org/package=mlr3fselect"><span class="pkg">mlr3fselect</span></a>
</p>
</li>
<li><p> Interface to real (out-of-memory) data bases: <a href="https://CRAN.R-project.org/package=mlr3db"><span class="pkg">mlr3db</span></a>
</p>
</li>
<li><p> Performance measures as plain functions: <a href="https://CRAN.R-project.org/package=mlr3measures"><span class="pkg">mlr3measures</span></a>
</p>
</li></ul>



<h3>Suggested packages</h3>


<ul>
<li><p> Parallelization framework: <a href="https://CRAN.R-project.org/package=future"><span class="pkg">future</span></a>
</p>
</li>
<li><p> Progress bars: <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
</p>
</li>
<li><p> Encapsulated evaluation: <a href="https://CRAN.R-project.org/package=evaluate"><span class="pkg">evaluate</span></a>, <a href="https://CRAN.R-project.org/package=callr"><span class="pkg">callr</span></a> (external process)
</p>
</li></ul>



<h3>Package Options</h3>


<ul>
<li> <p><code>"mlr3.debug"</code>: If set to <code>TRUE</code>, parallelization via <a href="https://CRAN.R-project.org/package=future"><span class="pkg">future</span></a> is
disabled to simplify debugging and provide more concise tracebacks. Note that
results computed with debug mode enabled use a different seeding mechanism
and are not reproducible.
</p>
</li>
<li> <p><code>"mlr3.allow_utf8_names"</code>: If set to <code>TRUE</code>, checks on the feature names
are relaxed, allowing non-ascii characters in column names. This is an
experimental and temporal option to pave the way for text analysis, and will
likely be removed in a future version of the package. analysis.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marc Becker <a href="mailto:marcbecker@posteo.de">marcbecker@posteo.de</a> (<a href="https://orcid.org/0000-0002-8115-0400">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Patrick Schratz <a href="mailto:patrick.schratz@gmail.com">patrick.schratz@gmail.com</a> (<a href="https://orcid.org/0000-0003-0748-6624">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>Becker M, Schratz P (2024).
<em>mlr3spatial: Support for Spatial Objects Within the 'mlr3' Ecosystem</em>.
https://mlr3spatial.mlr-org.com,
https://github.com/mlr-org/mlr3spatial.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mlr3spatial.mlr-org.com">https://mlr3spatial.mlr-org.com</a>
</p>
</li>
<li> <p><a href="https://github.com/mlr-org/mlr3spatial">https://github.com/mlr-org/mlr3spatial</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/mlr3spatial/issues">https://github.com/mlr-org/mlr3spatial/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_data_backend.stars'>Coerce to spatial DataBackend</h2><span id='topic+as_data_backend.stars'></span><span id='topic+as_data_backend.SpatRaster'></span><span id='topic+as_data_backend.RasterBrick'></span><span id='topic+as_data_backend.RasterStack'></span><span id='topic+as_data_backend.sf'></span>

<h3>Description</h3>

<p>Wraps a <a href="mlr3.html#topic+DataBackend">DataBackend</a> around spatial objects.
Currently these S3 methods are only alternative ways for writing <code>DataBackendRaster$new()</code>.
They do not support coercing from other backends yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
as_data_backend(data, primary_key = NULL, ...)

## S3 method for class 'SpatRaster'
as_data_backend(data, primary_key = NULL, ...)

## S3 method for class 'RasterBrick'
as_data_backend(data, primary_key = NULL, ...)

## S3 method for class 'RasterStack'
as_data_backend(data, primary_key = NULL, ...)

## S3 method for class 'sf'
as_data_backend(data, primary_key = NULL, keep_rownames = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_data_backend.stars_+3A_data">data</code></td>
<td>
<p>(<a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>)<br />
The input <a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>.</p>
</td></tr>
<tr><td><code id="as_data_backend.stars_+3A_primary_key">primary_key</code></td>
<td>
<p>(<code>character(1)</code> | <code>integer()</code>)<br />
Name of the primary key column, or integer vector of row ids.</p>
</td></tr>
<tr><td><code id="as_data_backend.stars_+3A_...">...</code></td>
<td>
<p>(<code>any</code>)<br />
Not used.</p>
</td></tr>
<tr><td><code id="as_data_backend.stars_+3A_keep_rownames">keep_rownames</code></td>
<td>
<p>(<code>logical(1)</code> | <code>character(1)</code>)<br />
If <code>TRUE</code> or a single string, keeps the row names of <code>data</code> as a new column.
The column is named like the provided string, defaulting to <code>"..rownames"</code> for <code>keep_rownames == TRUE</code>.
Note that the created column will be used as a regular feature by the task unless you manually change the column role.
Also see <code><a href="data.table.html#topic+as.data.table">data.table::as.data.table()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="mlr3.html#topic+DataBackend">DataBackend</a>.
</p>

<hr>
<h2 id='as_task_classif_st'>Convert to a Spatiotemporal Classification Task</h2><span id='topic+as_task_classif_st'></span><span id='topic+as_task_classif_st.TaskClassifST'></span><span id='topic+as_task_classif_st.data.frame'></span><span id='topic+as_task_classif_st.DataBackend'></span><span id='topic+as_task_classif_st.sf'></span><span id='topic+as_task_classif_st.TaskRegrST'></span>

<h3>Description</h3>

<p>Convert object to a <a href="#topic+TaskClassifST">TaskClassifST</a>.
This is a S3 generic, specialized for at least the following objects:
</p>

<ol>
<li> <p><a href="#topic+TaskClassifST">TaskClassifST</a>: Ensure the identity.
</p>
</li>
<li> <p><code><a href="base.html#topic+data.frame">data.frame()</a></code> and <a href="mlr3.html#topic+DataBackend">DataBackend</a>: Provides an alternative to the constructor of <a href="#topic+TaskClassifST">TaskClassifST</a>.
</p>
</li>
<li> <p><a href="sf.html#topic+sf">sf::sf</a>: Extracts spatial meta data before construction.
</p>
</li>
<li> <p><a href="mlr3.html#topic+TaskRegr">TaskRegr</a>: Calls <code><a href="mlr3.html#topic+convert_task">convert_task()</a></code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>as_task_classif_st(x, ...)

## S3 method for class 'TaskClassifST'
as_task_classif_st(x, clone = FALSE, ...)

## S3 method for class 'data.frame'
as_task_classif_st(
  x,
  target,
  id = deparse(substitute(x)),
  positive = NULL,
  coordinate_names,
  crs = NA_character_,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'DataBackend'
as_task_classif_st(
  x,
  target,
  id = deparse(substitute(x)),
  positive = NULL,
  coordinate_names,
  crs,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'sf'
as_task_classif_st(
  x,
  target = NULL,
  id = deparse(substitute(x)),
  positive = NULL,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'TaskRegrST'
as_task_classif_st(
  x,
  target = NULL,
  drop_original_target = FALSE,
  drop_levels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_task_classif_st_+3A_x">x</code></td>
<td>
<p>(any)<br />
Object to convert.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_...">...</code></td>
<td>
<p>(any)<br />
Additional arguments.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_clone">clone</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, ensures that the returned object is not the same as the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_target">target</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Name of the target column.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Id for the new task.
Defaults to the (deparsed and substituted) name of the data argument.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_positive">positive</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Level of the positive class. See <a href="mlr3.html#topic+TaskClassif">TaskClassif</a>.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_coordinate_names">coordinate_names</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The column names of the coordinates in the data.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_crs">crs</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Coordinate reference system.
WKT2 or EPSG string.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_coords_as_features">coords_as_features</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_label">label</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Label for the new instance.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_drop_original_target">drop_original_target</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>FALSE</code> (default), the original target is added as a feature.
Otherwise the original target is dropped.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_drop_levels">drop_levels</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code> (default), unused levels of the new target variable are dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+TaskClassifST">TaskClassifST</a>
</p>

<hr>
<h2 id='as_task_regr_st'>Convert to a Spatiotemporal Regression Task</h2><span id='topic+as_task_regr_st'></span><span id='topic+as_task_regr_st.TaskRegrST'></span><span id='topic+as_task_regr_st.data.frame'></span><span id='topic+as_task_regr_st.DataBackend'></span><span id='topic+as_task_regr_st.sf'></span><span id='topic+as_task_regr_st.TaskClassifST'></span>

<h3>Description</h3>

<p>Convert object to a <a href="#topic+TaskRegrST">TaskRegrST</a>.
This is a S3 generic, specialized for at least the following objects:
</p>

<ol>
<li> <p><a href="#topic+TaskRegrST">TaskRegrST</a>: Ensure the identity.
</p>
</li>
<li> <p><code><a href="base.html#topic+data.frame">data.frame()</a></code> and <a href="mlr3.html#topic+DataBackend">DataBackend</a>: Provides an alternative to the constructor of <a href="#topic+TaskRegrST">TaskRegrST</a>.
</p>
</li>
<li> <p><a href="sf.html#topic+sf">sf::sf</a>: Extracts spatial meta data before construction.
</p>
</li>
<li> <p><a href="mlr3.html#topic+TaskClassif">TaskClassif</a>: Calls <code><a href="mlr3.html#topic+convert_task">convert_task()</a></code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>as_task_regr_st(x, ...)

## S3 method for class 'TaskRegrST'
as_task_regr_st(x, clone = FALSE, ...)

## S3 method for class 'data.frame'
as_task_regr_st(
  x,
  target,
  id = deparse(substitute(x)),
  coordinate_names,
  crs = NA_character_,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'DataBackend'
as_task_regr_st(
  x,
  target,
  id = deparse(substitute(x)),
  coordinate_names,
  crs,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'sf'
as_task_regr_st(
  x,
  target = NULL,
  id = deparse(substitute(x)),
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'TaskClassifST'
as_task_regr_st(
  x,
  target = NULL,
  drop_original_target = FALSE,
  drop_levels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_task_regr_st_+3A_x">x</code></td>
<td>
<p>(any)<br />
Object to convert.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_...">...</code></td>
<td>
<p>(any)<br />
Additional arguments.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_clone">clone</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, ensures that the returned object is not the same as the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_target">target</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Name of the target column.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Id for the new task.
Defaults to the (deparsed and substituted) name of the data argument.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_coordinate_names">coordinate_names</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The column names of the coordinates in the data.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_crs">crs</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Coordinate reference system.
WKT2 or EPSG string.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_coords_as_features">coords_as_features</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_label">label</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Label for the new instance.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_drop_original_target">drop_original_target</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>FALSE</code> (default), the original target is added as a feature.
Otherwise the original target is dropped.</p>
</td></tr>
<tr><td><code id="as_task_regr_st_+3A_drop_levels">drop_levels</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code> (default), unused levels of the new target variable are dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+TaskRegrST">TaskRegrST</a>
</p>

<hr>
<h2 id='block_size'>Split Raster Into Chunks</h2><span id='topic+block_size'></span>

<h3>Description</h3>

<p>Splits raster into chunks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_size(raster, chunksize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_size_+3A_raster">raster</code></td>
<td>
<p>(<a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>)<br />
Raster to be split into chunks.</p>
</td></tr>
<tr><td><code id="block_size_+3A_chunksize">chunksize</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
The chunksize determines in how many subparts the prediction task will be
split into. The value can be roughly thought of as megabyte of a raster file
on disk. For example, if a prediction on a 1 GB file would be carried out
with <code>chunksize = 100L</code>, the prediction would happen in 10 chunks.
</p>
<p>The default of <code>chunksize = 1000L</code> might be a good compromise between speed
and memory usage. If you find yourself running out of memory, reduce this
value.</p>
</td></tr>
</table>

<hr>
<h2 id='DataBackendRaster'>DataBackend for Raster Objects</h2><span id='topic+DataBackendRaster'></span>

<h3>Description</h3>

<p><a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a> for <a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a> raster objects.
</p>


<h3>Read mode</h3>

<p>There are two different ways the reading of values is performed internally:
</p>

<ul>
<li><p> &quot;Block mode&quot; reads complete rows of the raster file and subsets the requested cells.
This mode is faster than &quot;cell mode&quot; if the complete raster file is iterated over.
</p>
</li>
<li><p> &quot;Cell mode&quot; reads individual cells.
This is faster than &quot;block mode&quot; if only a few cells are sampled.
</p>
</li></ul>

<p>&quot;Block mode&quot; is activated if <code style="white-space: pre;">&#8288;$data(rows)&#8288;</code> is used with a increasing integer sequence e.g. <code>200:300</code>.
If only a single cell is requested, &quot;cell mode&quot; is used.
</p>


<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a></code> -&gt; <code>DataBackendRaster</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>rownames</code></dt><dd><p>(<code>integer()</code>)<br />
Returns vector of all distinct row identifiers, i.e. the contents of the primary key column.</p>
</dd>
<dt><code>colnames</code></dt><dd><p>(<code>character()</code>)<br />
Returns vector of all column names.</p>
</dd>
<dt><code>nrow</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of rows (observations).</p>
</dd>
<dt><code>ncol</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of columns (variables).</p>
</dd>
<dt><code>stack</code></dt><dd><p>(<code>SpatRaster</code>)<br />
Raster stack.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataBackendRaster-new"><code>DataBackendRaster$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendRaster-data"><code>DataBackendRaster$data()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendRaster-head"><code>DataBackendRaster$head()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendRaster-distinct"><code>DataBackendRaster$distinct()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendRaster-missings"><code>DataBackendRaster$missings()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendRaster-coordinates"><code>DataBackendRaster$coordinates()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="format"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-format'><code>mlr3::DataBackend$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="print"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-print'><code>mlr3::DataBackend$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DataBackendRaster-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendRaster$new(data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>(<a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>)<br />
The input <a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataBackendRaster-data"></a>



<h4>Method <code>data()</code></h4>

<p>Returns a slice of the raster in the specified format.
Currently, the only supported formats is <code>"data.table"</code>.
</p>
<p>The rows must be addressed as vector of cells indices, columns must be
referred to via layer names. Queries for rows with no matching row id and
queries for columns with no matching column name are silently ignored.
</p>
<p>Rows are guaranteed to be returned in the same order as <code>rows</code>, columns
may be returned in an arbitrary order. Duplicated row ids result in
duplicated rows, duplicated column names lead to an exception.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendRaster$data(rows, cols, data_format = "data.table")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices. Row indices start with 1 in the upper left corner in the
raster, increase from left to right and then from top to bottom. The last
cell is in the bottom right corner and the row index equals the number of
cells in the raster.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character(1)</code>)<br />
Desired data format. Currently only <code>"data.table"</code> supported.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataBackendRaster-head"></a>



<h4>Method <code>head()</code></h4>

<p>Retrieve the first <code>n</code> rows.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendRaster$head(n = 6L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of rows.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of the first <code>n</code> rows.
</p>


<hr>
<a id="method-DataBackendRaster-distinct"></a>



<h4>Method <code>distinct()</code></h4>

<p>Returns a named list of vectors of distinct values for each column
specified. If <code>na_rm</code> is <code>TRUE</code>, missing values are removed from the
returned vectors of distinct values. Non-existing rows and columns are
silently ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendRaster$distinct(rows, cols, na_rm = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices. Row indices start with 1 in the upper left corner in the
raster, increase from left to right and then from top to bottom. The last
cell is in the bottom right corner and the row index equals the number of
cells in the raster.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p><code>logical(1)</code><br />
Whether to remove NAs or not.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Named <code>list()</code> of distinct values.
</p>


<hr>
<a id="method-DataBackendRaster-missings"></a>



<h4>Method <code>missings()</code></h4>

<p>Returns the number of missing values per column in the specified slice
of data. Non-existing rows and columns are silently ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendRaster$missings(rows, cols)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices. Row indices start with 1 in the upper left corner in the
raster, increase from left to right and then from top to bottom. The last
cell is in the bottom right corner and the row index equals the number of
cells in the raster.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Total of missing values per column (named <code>numeric()</code>).
</p>


<hr>
<a id="method-DataBackendRaster-coordinates"></a>



<h4>Method <code>coordinates()</code></h4>

<p>Returns the coordinates of <code>rows</code>.
If <code>rows</code> is missing, all coordinates are returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendRaster$coordinates(rows)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices. Row indices start with 1 in the upper left corner in the
raster, increase from left to right and then from top to bottom. The last
cell is in the bottom right corner and the row index equals the number of
cells in the raster.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of coordinates of <code>rows</code>.
</p>



<hr>
<h2 id='DataBackendVector'>DataBackend for Vector Objects</h2><span id='topic+DataBackendVector'></span>

<h3>Description</h3>

<p><a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a> for <a href="sf.html#topic+sf">sf::sf</a> vector objects.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a></code> -&gt; <code><a href="mlr3.html#topic+DataBackendDataTable">mlr3::DataBackendDataTable</a></code> -&gt; <code>DataBackendVector</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>sfc</code></dt><dd><p>(<a href="sf.html#topic+sfc">sf::sfc</a>)<br />
Returns the sfc object.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataBackendVector-new"><code>DataBackendVector$new()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="format"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-format'><code>mlr3::DataBackend$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="print"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-print'><code>mlr3::DataBackend$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackendDataTable" data-id="data"><a href='../../mlr3/html/DataBackendDataTable.html#method-DataBackendDataTable-data'><code>mlr3::DataBackendDataTable$data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackendDataTable" data-id="distinct"><a href='../../mlr3/html/DataBackendDataTable.html#method-DataBackendDataTable-distinct'><code>mlr3::DataBackendDataTable$distinct()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackendDataTable" data-id="head"><a href='../../mlr3/html/DataBackendDataTable.html#method-DataBackendDataTable-head'><code>mlr3::DataBackendDataTable$head()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackendDataTable" data-id="missings"><a href='../../mlr3/html/DataBackendDataTable.html#method-DataBackendDataTable-missings'><code>mlr3::DataBackendDataTable$missings()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DataBackendVector-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendVector$new(data, primary_key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>(<code>sf</code>)<br />
A raster object.</p>
</dd>
<dt><code>primary_key</code></dt><dd><p>(<code>character(1)</code> | <code>integer()</code>)<br />
Name of the primary key column, or integer vector of row ids.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='factor_layer'>Factor Layer Generator</h2><span id='topic+factor_layer'></span>

<h3>Description</h3>

<p>Generates a factor layer when passed to <code><a href="#topic+generate_stack">generate_stack()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_layer(id, levels, in_memory = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor_layer_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Layer id.</p>
</td></tr>
<tr><td><code id="factor_layer_+3A_levels">levels</code></td>
<td>
<p>(<code>character()</code>)<br />
Factor levels.</p>
</td></tr>
<tr><td><code id="factor_layer_+3A_in_memory">in_memory</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>FALSE</code> (default), layer is written to disk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named <code>list()</code>
</p>

<hr>
<h2 id='generate_stack'>Generate Raster Stack</h2><span id='topic+generate_stack'></span>

<h3>Description</h3>

<p>Generates a raster stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_stack(
  layers,
  layer_size = NULL,
  dimension = NULL,
  multi_layer_file = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_stack_+3A_layers">layers</code></td>
<td>
<p>(List of <code><a href="#topic+numeric_layer">numeric_layer()</a></code> and <code><a href="#topic+factor_layer">factor_layer()</a></code>)<br />
List of layers.</p>
</td></tr>
<tr><td><code id="generate_stack_+3A_layer_size">layer_size</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Size of a single layer in megabytes.</p>
</td></tr>
<tr><td><code id="generate_stack_+3A_dimension">dimension</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Dimension of the squared layers.</p>
</td></tr>
<tr><td><code id="generate_stack_+3A_multi_layer_file">multi_layer_file</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, raster is written to disk as a single multi-layer file.
Overwrites <code>ìn_memory</code> argument of <code>numeric_layer()</code> and <code>factor_layer()</code>.
</p>
<p><code>layer_size</code> and <code>dimension</code> are mutually exclusive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>
</p>

<hr>
<h2 id='leipzig'>Leipzig Land Cover Task</h2><span id='topic+leipzig'></span><span id='topic+mlr_tasks_leipzig'></span>

<h3>Description</h3>

<p>Point survey of land cover in Leipzig.
Includes Sentinel-2 spectral bands and NDVI.
</p>


<h3>Source</h3>

<p>Copernicus Sentinel Data (2021). Retrieved from Copernicus Open Access Hub and processed by European Space Agency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("sf")) {
  library(sf)
  data("leipzig", package = "mlr3spatial")
  print(leipzig)
}
</code></pre>

<hr>
<h2 id='mask_stack'>Sample Points in Raster Stack</h2><span id='topic+mask_stack'></span>

<h3>Description</h3>

<p>Masks stack to a circular area of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_stack(stack)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_stack_+3A_stack">stack</code></td>
<td>
<p>(<a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>)<br />
Raster stack.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>
</p>

<hr>
<h2 id='numeric_layer'>Numeric Layer Generator</h2><span id='topic+numeric_layer'></span>

<h3>Description</h3>

<p>Generates a numeric layer when passed to <code><a href="#topic+generate_stack">generate_stack()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numeric_layer(id, in_memory = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numeric_layer_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Layer id.</p>
</td></tr>
<tr><td><code id="numeric_layer_+3A_in_memory">in_memory</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>FALSE</code> (default), layer is written to disk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named <code>list()</code>
</p>

<hr>
<h2 id='predict_spatial'>Predict on Spatial Objects with mlr3 Learners</h2><span id='topic+predict_spatial'></span>

<h3>Description</h3>

<p>This function allows to directly predict mlr3 learners on various spatial objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_spatial(
  newdata,
  learner,
  chunksize = 200L,
  format = "terra",
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_spatial_+3A_newdata">newdata</code></td>
<td>
<p>(<a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a> | <code>stars::stars</code> | <a href="sf.html#topic+sf">sf::sf</a> | <code>raster::RasterStack</code> | <code>raster::RasterBrick</code>).
New data to predict on. All spatial data formats convertible by <code>as_data_backend()</code> are supported e.g. <a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a> or <a href="sf.html#topic+sf">sf::sf</a>.</p>
</td></tr>
<tr><td><code id="predict_spatial_+3A_learner">learner</code></td>
<td>
<p>(<a href="mlr3.html#topic+Learner">Learner</a>).
Learner with trained model.</p>
</td></tr>
<tr><td><code id="predict_spatial_+3A_chunksize">chunksize</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
The chunksize determines in how many subparts the prediction task will be
split into. The value can be roughly thought of as megabyte of a raster file
on disk. For example, if a prediction on a 1 GB file would be carried out
with <code>chunksize = 100L</code>, the prediction would happen in 10 chunks.
</p>
<p>The default of <code>chunksize = 1000L</code> might be a good compromise between speed
and memory usage. If you find yourself running out of memory, reduce this
value.</p>
</td></tr>
<tr><td><code id="predict_spatial_+3A_format">format</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Output class of the resulting object.
Accepted values are <code>"raster"</code>, <code>"stars"</code> and <code>"terra"</code> if the input is a raster.
Note that when choosing something else than <code>"terra"</code>, the spatial object is converted into the respective format which might cause overhead both in runtime and memory allocation.
For vector data only <code>"sf"</code> is supported.</p>
</td></tr>
<tr><td><code id="predict_spatial_+3A_filename">filename</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Path where the spatial object should be written to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object of class given in argument <code>format</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra, exclude = "resample")

# fit rpart on training points
task_train = tsk("leipzig")
learner = lrn("classif.rpart")
learner$train(task_train)

# load raster
stack = rast(system.file("extdata", "leipzig_raster.tif", package = "mlr3spatial"))

# predict land cover classes
pred = predict_spatial(stack, learner, chunksize = 1L)
</code></pre>

<hr>
<h2 id='sample_stack'>Sample Points in Raster Stack</h2><span id='topic+sample_stack'></span>

<h3>Description</h3>

<p>Samples <code>n</code> points of a raster stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_stack(stack, n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_stack_+3A_stack">stack</code></td>
<td>
<p>(<a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a>)<br />
Raster stack.</p>
</td></tr>
<tr><td><code id="sample_stack_+3A_n">n</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="sf.html#topic+sf">sf::sf</a>
</p>

<hr>
<h2 id='TaskClassifST'>Spatiotemporal Classification Task</h2><span id='topic+TaskClassifST'></span>

<h3>Description</h3>

<p>This task specializes <a href="mlr3.html#topic+TaskClassif">TaskClassif</a> for spatiotemporal classification problems.
</p>
<p>A spatial example task is available via <code>tsk("ecuador")</code>.
</p>
<p>The coordinate reference system passed during initialization must match the one which was used during data creation, otherwise offsets of multiple meters may occur.
By default, coordinates are not used as features.
This can be changed by setting <code>coords_as_features = TRUE</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3.html#topic+Task">mlr3::Task</a></code> -&gt; <code><a href="mlr3.html#topic+TaskSupervised">mlr3::TaskSupervised</a></code> -&gt; <code><a href="mlr3.html#topic+TaskClassif">mlr3::TaskClassif</a></code> -&gt; <code>TaskClassifST</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>crs</code></dt><dd><p>(<code>character(1)</code>)<br />
Returns coordinate reference system of task.</p>
</dd>
<dt><code>coordinate_names</code></dt><dd><p>(<code>character()</code>)<br />
Returns coordinate names.</p>
</dd>
<dt><code>coords_as_features</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TaskClassifST-new"><code>TaskClassifST$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskClassifST-coordinates"><code>TaskClassifST$coordinates()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskClassifST-print"><code>TaskClassifST$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskClassifST-clone"><code>TaskClassifST$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="add_strata"><a href='../../mlr3/html/Task.html#method-Task-add_strata'><code>mlr3::Task$add_strata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="cbind"><a href='../../mlr3/html/Task.html#method-Task-cbind'><code>mlr3::Task$cbind()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="data"><a href='../../mlr3/html/Task.html#method-Task-data'><code>mlr3::Task$data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="filter"><a href='../../mlr3/html/Task.html#method-Task-filter'><code>mlr3::Task$filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="format"><a href='../../mlr3/html/Task.html#method-Task-format'><code>mlr3::Task$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="formula"><a href='../../mlr3/html/Task.html#method-Task-formula'><code>mlr3::Task$formula()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="head"><a href='../../mlr3/html/Task.html#method-Task-head'><code>mlr3::Task$head()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="help"><a href='../../mlr3/html/Task.html#method-Task-help'><code>mlr3::Task$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="levels"><a href='../../mlr3/html/Task.html#method-Task-levels'><code>mlr3::Task$levels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="missings"><a href='../../mlr3/html/Task.html#method-Task-missings'><code>mlr3::Task$missings()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="rbind"><a href='../../mlr3/html/Task.html#method-Task-rbind'><code>mlr3::Task$rbind()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="rename"><a href='../../mlr3/html/Task.html#method-Task-rename'><code>mlr3::Task$rename()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="select"><a href='../../mlr3/html/Task.html#method-Task-select'><code>mlr3::Task$select()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_col_roles"><a href='../../mlr3/html/Task.html#method-Task-set_col_roles'><code>mlr3::Task$set_col_roles()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_levels"><a href='../../mlr3/html/Task.html#method-Task-set_levels'><code>mlr3::Task$set_levels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_row_roles"><a href='../../mlr3/html/Task.html#method-Task-set_row_roles'><code>mlr3::Task$set_row_roles()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="TaskClassif" data-id="droplevels"><a href='../../mlr3/html/TaskClassif.html#method-TaskClassif-droplevels'><code>mlr3::TaskClassif$droplevels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="TaskClassif" data-id="truth"><a href='../../mlr3/html/TaskClassif.html#method-TaskClassif-truth'><code>mlr3::TaskClassif$truth()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TaskClassifST-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
The function <code><a href="#topic+as_task_classif_st">as_task_classif_st()</a></code> provides an alternative way to construct classification tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskClassifST$new(
  id,
  backend,
  target,
  positive = NULL,
  label = NA_character_,
  coordinate_names,
  crs = NA_character_,
  coords_as_features = FALSE,
  extra_args = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>backend</code></dt><dd><p>(<a href="mlr3.html#topic+DataBackend">DataBackend</a>)<br />
Either a <a href="mlr3.html#topic+DataBackend">DataBackend</a>, or any object which is convertible to a <a href="mlr3.html#topic+DataBackend">DataBackend</a> with <code>as_data_backend()</code>.
E.g., am <code>sf</code> will be converted to a <a href="mlr3.html#topic+DataBackendDataTable">DataBackendDataTable</a>.</p>
</dd>
<dt><code>target</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the target column.</p>
</dd>
<dt><code>positive</code></dt><dd><p>(<code>character(1)</code>)<br />
Only for binary classification: Name of the positive class.
The levels of the target columns are reordered accordingly, so that the first element of <code style="white-space: pre;">&#8288;$class_names&#8288;</code> is the positive class, and the second element is the negative class.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for the new instance.</p>
</dd>
<dt><code>coordinate_names</code></dt><dd><p>(<code>character(1)</code>)<br />
The column names of the coordinates in the data.</p>
</dd>
<dt><code>crs</code></dt><dd><p>(<code>character(1)</code>)<br />
Coordinate reference system.
WKT2 or EPSG string.</p>
</dd>
<dt><code>coords_as_features</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.</p>
</dd>
<dt><code>extra_args</code></dt><dd><p>(named <code>list()</code>)<br />
Named list of constructor arguments, required for converting task types via <code><a href="mlr3.html#topic+convert_task">convert_task()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TaskClassifST-coordinates"></a>



<h4>Method <code>coordinates()</code></h4>

<p>Returns coordinates of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskClassifST$coordinates(row_ids = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>row_ids</code></dt><dd><p>(<code>integer()</code>)<br />
Vector of rows indices as subset of <code>task$row_ids</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-TaskClassifST-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the task.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskClassifST$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments passed to the <code style="white-space: pre;">&#8288;$print()&#8288;</code> method of the superclass.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TaskClassifST-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskClassifST$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='TaskRegrST'>Spatiotemporal Regression Task</h2><span id='topic+TaskRegrST'></span>

<h3>Description</h3>

<p>This task specializes <a href="mlr3.html#topic+TaskRegr">TaskRegr</a> for spatiotemporal regression problems.
</p>
<p>A spatial example task is available via <code>tsk("cookfarm_mlr3")</code>.
</p>
<p>The coordinate reference system passed during initialization must match the one which was used during data creation, otherwise offsets of multiple meters may occur.
By default, coordinates are not used as features.
This can be changed by setting <code>coords_as_features = TRUE</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3.html#topic+Task">mlr3::Task</a></code> -&gt; <code><a href="mlr3.html#topic+TaskSupervised">mlr3::TaskSupervised</a></code> -&gt; <code><a href="mlr3.html#topic+TaskRegr">mlr3::TaskRegr</a></code> -&gt; <code>TaskRegrST</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>crs</code></dt><dd><p>(<code>character(1)</code>)<br />
Returns coordinate reference system of the task.</p>
</dd>
<dt><code>coordinate_names</code></dt><dd><p>(<code>character()</code>)<br />
Returns coordinate names.</p>
</dd>
<dt><code>coords_as_features</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TaskRegrST-new"><code>TaskRegrST$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskRegrST-coordinates"><code>TaskRegrST$coordinates()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskRegrST-print"><code>TaskRegrST$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskRegrST-clone"><code>TaskRegrST$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="add_strata"><a href='../../mlr3/html/Task.html#method-Task-add_strata'><code>mlr3::Task$add_strata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="cbind"><a href='../../mlr3/html/Task.html#method-Task-cbind'><code>mlr3::Task$cbind()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="data"><a href='../../mlr3/html/Task.html#method-Task-data'><code>mlr3::Task$data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="droplevels"><a href='../../mlr3/html/Task.html#method-Task-droplevels'><code>mlr3::Task$droplevels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="filter"><a href='../../mlr3/html/Task.html#method-Task-filter'><code>mlr3::Task$filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="format"><a href='../../mlr3/html/Task.html#method-Task-format'><code>mlr3::Task$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="formula"><a href='../../mlr3/html/Task.html#method-Task-formula'><code>mlr3::Task$formula()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="head"><a href='../../mlr3/html/Task.html#method-Task-head'><code>mlr3::Task$head()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="help"><a href='../../mlr3/html/Task.html#method-Task-help'><code>mlr3::Task$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="levels"><a href='../../mlr3/html/Task.html#method-Task-levels'><code>mlr3::Task$levels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="missings"><a href='../../mlr3/html/Task.html#method-Task-missings'><code>mlr3::Task$missings()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="rbind"><a href='../../mlr3/html/Task.html#method-Task-rbind'><code>mlr3::Task$rbind()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="rename"><a href='../../mlr3/html/Task.html#method-Task-rename'><code>mlr3::Task$rename()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="select"><a href='../../mlr3/html/Task.html#method-Task-select'><code>mlr3::Task$select()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_col_roles"><a href='../../mlr3/html/Task.html#method-Task-set_col_roles'><code>mlr3::Task$set_col_roles()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_levels"><a href='../../mlr3/html/Task.html#method-Task-set_levels'><code>mlr3::Task$set_levels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_row_roles"><a href='../../mlr3/html/Task.html#method-Task-set_row_roles'><code>mlr3::Task$set_row_roles()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="TaskRegr" data-id="truth"><a href='../../mlr3/html/TaskRegr.html#method-TaskRegr-truth'><code>mlr3::TaskRegr$truth()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TaskRegrST-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
The function <code><a href="#topic+as_task_regr_st">as_task_regr_st()</a></code> provides an alternative way to construct classification tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskRegrST$new(
  id,
  backend,
  target,
  label = NA_character_,
  coordinate_names,
  crs = NA_character_,
  coords_as_features = FALSE,
  extra_args = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>backend</code></dt><dd><p>(<a href="mlr3.html#topic+DataBackend">DataBackend</a>)<br />
Either a <a href="mlr3.html#topic+DataBackend">DataBackend</a>, or any object which is convertible to a <a href="mlr3.html#topic+DataBackend">DataBackend</a> with <code>as_data_backend()</code>.
E.g., am <code>sf</code> will be converted to a <a href="mlr3.html#topic+DataBackendDataTable">DataBackendDataTable</a>.</p>
</dd>
<dt><code>target</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the target column.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for the new instance.</p>
</dd>
<dt><code>coordinate_names</code></dt><dd><p>(<code>character(1)</code>)<br />
The column names of the coordinates in the data.</p>
</dd>
<dt><code>crs</code></dt><dd><p>(<code>character(1)</code>)<br />
Coordinate reference system.
WKT2 or EPSG string.</p>
</dd>
<dt><code>coords_as_features</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.</p>
</dd>
<dt><code>extra_args</code></dt><dd><p>(named <code>list()</code>)<br />
Named list of constructor arguments, required for converting task types via <code><a href="mlr3.html#topic+convert_task">convert_task()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TaskRegrST-coordinates"></a>



<h4>Method <code>coordinates()</code></h4>

<p>Returns coordinates of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskRegrST$coordinates(row_ids = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>row_ids</code></dt><dd><p>(<code>integer()</code>)<br />
Vector of rows indices as subset of <code>task$row_ids</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-TaskRegrST-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the task.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskRegrST$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments passed to the <code style="white-space: pre;">&#8288;$print()&#8288;</code> method of the superclass.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TaskRegrST-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskRegrST$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='write_raster'>Write a Raster in Chunks</h2><span id='topic+write_raster'></span>

<h3>Description</h3>

<p>Writes square raster to disk in chunks.
Internal helper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_raster(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_raster_+3A_data">data</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[SpatRaster]&#8288;</code><br />
<code>SpatRaster</code> object.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
