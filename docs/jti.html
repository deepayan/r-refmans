<!DOCTYPE html><html lang="en"><head><title>Help for package jti</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jti}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jti-package'><p>jti: Junction Tree Inference</p></a></li>
<li><a href='#asia'><p>Asia</p></a></li>
<li><a href='#asia2'><p>Asia2</p></a></li>
<li><a href='#bnfit_to_cpts'><p>bnfit to cpts</p></a></li>
<li><a href='#compile'><p>Compile information</p></a></li>
<li><a href='#cpt_list'><p>Conditional probability list</p></a></li>
<li><a href='#dim_names'><p>Various getters</p></a></li>
<li><a href='#get_cliques'><p>Return the cliques of a junction tree</p></a></li>
<li><a href='#get_graph'><p>Get graph</p></a></li>
<li><a href='#get_triang_graph'><p>Get triangulated graph</p></a></li>
<li><a href='#initialize'><p>Initialize</p></a></li>
<li><a href='#jt'><p>Junction Tree</p></a></li>
<li><a href='#jt_leaves'><p>Query Parents or Leaves in a Junction Tree</p></a></li>
<li><a href='#jt_nbinary_ops'><p>Number of Binary Operations</p></a></li>
<li><a href='#mpd'><p>Maximal Prime Decomposition</p></a></li>
<li><a href='#mpe'><p>Most Probable Explanation</p></a></li>
<li><a href='#plot.charge'><p>A plot method for junction trees</p></a></li>
<li><a href='#plot.jt'><p>A plot method for junction trees</p></a></li>
<li><a href='#pot_list'><p>A check and extraction of clique potentials from a Markov random field</p>
to be used in the junction tree algorithm</a></li>
<li><a href='#print.charge'><p>A print method for compiled objects</p></a></li>
<li><a href='#print.cpt_list'><p>A print method for cpt lists</p></a></li>
<li><a href='#print.jt'><p>A print method for junction trees</p></a></li>
<li><a href='#propagate'><p>Propagation of junction trees</p></a></li>
<li><a href='#query_belief'><p>Query probabilities</p></a></li>
<li><a href='#query_evidence'><p>Query Evidence</p></a></li>
<li><a href='#send_messages'><p>Send Messages in a Junction Tree</p></a></li>
<li><a href='#set_evidence'><p>Enter Evidence</p></a></li>
<li><a href='#sim_data_from_bn'><p>Simulate data from a Bayesian network</p></a></li>
<li><a href='#sim_data_from_dmrf'><p>Simulate data from a decomposable discrete markov random field</p></a></li>
<li><a href='#triangulate'><p>Triangulate a Bayesian network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Junction Tree Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-22</td>
</tr>
<tr>
<td>Description:</td>
<td>Minimal and memory efficient implementation of the junction tree
	     algorithm using the Lauritzen-Spiegelhalter scheme;
	     S. L. Lauritzen and D. J. Spiegelhalter (1988) 
	     <a href="https://www.jstor.org/stable/2345762?seq=1">https://www.jstor.org/stable/2345762?seq=1</a>. The jti package is
	     part of the paper &lt;<a href="https://doi.org/10.18637%2Fjss.v111.i02">doi:10.18637/jss.v111.i02</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlindsk/jti">https://github.com/mlindsk/jti</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, igraph, sparta</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, tinytest, ess</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-22 12:22:48 UTC; mlindsk</td>
</tr>
<tr>
<td>Author:</td>
<td>Mads Lindskou [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mads Lindskou &lt;madslindskou@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-23 15:30:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='jti-package'>jti: Junction Tree Inference</h2><span id='topic+jti'></span><span id='topic+jti-package'></span>

<h3>Description</h3>

<p>Minimal and memory efficient implementation of the junction tree
algorithm using the Lauritzen-Spiegelhalter scheme.
</p>


<h3>Details</h3>

<p>The main functions are <code>cpt_list</code>, <code>compile</code>,<code>jt</code>
and <code>query_belief</code> which together is sufficient to make
inference using the junction tree algorithm.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mads Lindskou <a href="mailto:madslindskou@gmail.com">madslindskou@gmail.com</a>
</p>


<h3>References</h3>

<p>Local Computations with Probabilities on Graphical Structures
and Their Application to Expert Systems by S. L. Lauritzen
and D. J. Spiegelhalter (1988). Journal of the Royal Statistical
Society: Series B (Methodological) volume 50, issue 2.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mlindsk/jti">https://github.com/mlindsk/jti</a>
</p>
</li></ul>


<hr>
<h2 id='asia'>Asia</h2><span id='topic+asia'></span>

<h3>Description</h3>

<p>Small synthetic data set from Lauritzen and Spiegelhalter (1988) about lung
diseases (tuberculosis, lung cancer or bronchitis) and visits to Asia. This
copy of the data was taken from the R package &quot;bnlearn&quot; where all values
&quot;yes&quot; have been converted to &quot;y&quot; and all values &quot;no&quot; have been converted
to &quot;n&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asia
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 5000 rows and 8 columns.
</p>


<h3>Details</h3>


<dl>
<dt><code>D</code> (dysponea)</dt><dd></dd>
<dt><code>T</code> (tuberculosis)</dt><dd></dd>
<dt><code>L</code> (lung cancer)</dt><dd></dd>
<dt><code>B</code> (bronchitis)</dt><dd></dd>
<dt><code>A</code> (visit to Asia)</dt><dd></dd>
<dt><code>S</code> (smoking)</dt><dd></dd>
<dt><code>X</code> (chest C-ray)</dt><dd></dd>
<dt><code>E</code> (tuberculosis vs cancer/bronchitis)</dt><dd></dd>
</dl>



<h3>References</h3>

<p><a href="https://www.bnlearn.com/documentation/man/asia.html">bnlearn-asia</a>
</p>

<hr>
<h2 id='asia2'>Asia2</h2><span id='topic+asia2'></span>

<h3>Description</h3>

<p>See the <code>asia</code> data for information. This version, has class <code>bn.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asia2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>


<h3>References</h3>

<p><a href="https://www.bnlearn.com/bnrepository/discrete-small.html#asia">bnlearn-asia</a>
</p>

<hr>
<h2 id='bnfit_to_cpts'>bnfit to cpts</h2><span id='topic+bnfit_to_cpts'></span>

<h3>Description</h3>

<p>Convert a <code>bn.fit</code> object (a list of cpts from the bnlearn package)
into a list of ordinary array-like cpts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bnfit_to_cpts(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bnfit_to_cpts_+3A_x">x</code></td>
<td>
<p>A <code>bn.fit</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='compile'>Compile information</h2><span id='topic+compile'></span><span id='topic+compile.cpt_list'></span>

<h3>Description</h3>

<p>Compiled objects are used as building blocks for junction tree inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile(
  x,
  evidence = NULL,
  root_node = "",
  joint_vars = NULL,
  tri = "min_fill",
  pmf_evidence = NULL,
  alpha = NULL,
  initialize_cpts = TRUE
)

## S3 method for class 'cpt_list'
compile(
  x,
  evidence = NULL,
  root_node = "",
  joint_vars = NULL,
  tri = "min_fill",
  pmf_evidence = NULL,
  alpha = NULL,
  initialize_cpts = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compile_+3A_x">x</code></td>
<td>
<p>An object returned from <code>cpt_list</code> (baeysian network) or
<code>pot_list</code> (decomposable markov random field)</p>
</td></tr>
<tr><td><code id="compile_+3A_evidence">evidence</code></td>
<td>
<p>A named vector. The names are the variabes and the elements
are the evidence.</p>
</td></tr>
<tr><td><code id="compile_+3A_root_node">root_node</code></td>
<td>
<p>A node for which we require it to live in the root
clique (the first clique).</p>
</td></tr>
<tr><td><code id="compile_+3A_joint_vars">joint_vars</code></td>
<td>
<p>A vector of variables for which we require them
to be in the same clique. Edges between all these variables are added
to the moralized graph.</p>
</td></tr>
<tr><td><code id="compile_+3A_tri">tri</code></td>
<td>
<p>The optimization strategy used for triangulation if x originates
from a Baeysian network. One of
</p>

<ul>
<li><p> 'min_fill'
</p>
</li>
<li><p> 'min_rfill'
</p>
</li>
<li><p> 'min_sp'
</p>
</li>
<li><p> 'min_ssp'
</p>
</li>
<li><p> 'min_lsp'
</p>
</li>
<li><p> 'min_lssp'
</p>
</li>
<li><p> 'min_elsp'
</p>
</li>
<li><p> 'min_elssp'
</p>
</li>
<li><p> 'min_nei'
</p>
</li>
<li><p> 'minimal'
</p>
</li>
<li><p> 'alpha'
</p>
</li></ul>
</td></tr>
<tr><td><code id="compile_+3A_pmf_evidence">pmf_evidence</code></td>
<td>
<p>A named vector of frequencies of the expected
missingness of a variable. Variables with frequencies of 1 can be
neglected; these are inferrred. A value of 0.25 means, that the
given variable is expected to be missing (it is not a evidence node)
in one fourth of the future cases. Relevant for <code>tri</code> methods
'min_elsp' and 'min_elssp'.</p>
</td></tr>
<tr><td><code id="compile_+3A_alpha">alpha</code></td>
<td>
<p>Character vector. A permutation of the nodes
in the graph. It specifies a user-supplied eliminination ordering for
triangulation of the moral graph.</p>
</td></tr>
<tr><td><code id="compile_+3A_initialize_cpts">initialize_cpts</code></td>
<td>
<p><code>TRUE</code> if the CPTs should be initialized,
i.e. multiplied together to form the clique potentials. If FALSE,
the <code>compile</code>d object will save the triangulation and other
information that needs only bee computed once. Herafter, it is
possible to enter evidence into the CPTs, using <code>set_evidence</code>,
saving a lot of computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Junction Tree Algorithm performs both a forward and inward
message pass (collect and distribute). However, when the forward
phase is finished, the root clique potential is guaranteed to be the
joint pmf over the variables involved in the root clique. Thus, if
it is known in advance that a specific variable is of interest, the
algortihm can be terminated after the forward phase. Use the <code>root_node</code>
to specify such a variable and specify <code>propagate = "collect"</code> in
the juntion tree algortihm function <code>jt</code>.
</p>
<p>Moreover, if interest is in some joint pmf for variables that end up
being in different cliques these variables must be specified in advance
using the <code>joint_vars</code> argument. The compilation step then
adds edges between all of these variables to ensure that at least one
clique contains all of them.
</p>
<p>Evidence can be entered either at compile stage
or after compilation. Hence, one can also combine
evidence from before compilation with evidence
after compilation. Before refers to entering
evidence in the 'compile' function and after
refers to entering evidence in the 'jt' function.
</p>
<p>Finally, one can either use a Bayesian network or a decomposable
Markov random field (use the <code>ess</code> package to fit these). Bayesian
networks must be constructed with <code>cpt_list</code> and decomposable MRFs
can be constructed with both <code>pot_list</code> and <code>cpt_list</code>. However,
<code>pot_list</code> is just an alias for <code>cpt_list</code> which handles both
cases internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cptl &lt;- cpt_list(asia2)
cp1  &lt;- compile(cptl, evidence = c(bronc = "yes"), joint_vars = c("bronc", "tub"))
print(cp1)
names(cp1)
dim_names(cp1)
plot(get_graph(cp1))
</code></pre>

<hr>
<h2 id='cpt_list'>Conditional probability list</h2><span id='topic+cpt_list'></span><span id='topic+cpt_list.list'></span><span id='topic+cpt_list.data.frame'></span>

<h3>Description</h3>

<p>A check and conversion of cpts to be used in the junction tree algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt_list(x, g = NULL)

## S3 method for class 'list'
cpt_list(x, g = NULL)

## S3 method for class 'data.frame'
cpt_list(x, g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpt_list_+3A_x">x</code></td>
<td>
<p>Either a named list with cpts in form of array-like object(s)
where names must be the child node or a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="cpt_list_+3A_g">g</code></td>
<td>
<p>Either a directed acyclic graph (DAG) as an igraph object or a
decomposable graph as an igraph object. If <code>x</code> is a list,
<code>g</code> must be <code>NULL</code>. The procedure then deduce the graph
from the conditional probability tables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
el &lt;- matrix(c(
"A", "T",
"T", "E",
"S", "L",
"S", "B",
"L", "E",
"E", "X",
"E", "D",
"B", "D"),
 nc = 2,
 byrow = TRUE
)

g &lt;- igraph::graph_from_edgelist(el) 
cl &lt;- cpt_list(asia, g)

print(cl)
dim_names(cl)
names(cl)
plot(get_graph(cl))
</code></pre>

<hr>
<h2 id='dim_names'>Various getters</h2><span id='topic+dim_names'></span><span id='topic+has_inconsistencies'></span><span id='topic+dim_names.cpt_list'></span><span id='topic+names.cpt_list'></span><span id='topic+dim_names.charge'></span><span id='topic+names.charge'></span><span id='topic+has_inconsistencies.charge'></span><span id='topic+dim_names.jt'></span><span id='topic+names.jt'></span><span id='topic+has_inconsistencies.jt'></span>

<h3>Description</h3>

<p>Getter methods for <code>cpt_list</code>, <code>pot_list</code>, <code>charge</code>
and <code>jt</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim_names(x)

has_inconsistencies(x)

## S3 method for class 'cpt_list'
dim_names(x)

## S3 method for class 'cpt_list'
names(x)

## S3 method for class 'charge'
dim_names(x)

## S3 method for class 'charge'
names(x)

## S3 method for class 'charge'
has_inconsistencies(x)

## S3 method for class 'jt'
dim_names(x)

## S3 method for class 'jt'
names(x)

## S3 method for class 'jt'
has_inconsistencies(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim_names_+3A_x">x</code></td>
<td>
<p><code>cpt_list</code>, <code>pot_list</code>, <code>charge</code> or <code>jt</code></p>
</td></tr>
</table>

<hr>
<h2 id='get_cliques'>Return the cliques of a junction tree</h2><span id='topic+get_cliques'></span><span id='topic+get_cliques.jt'></span><span id='topic+get_cliques.charge'></span><span id='topic+get_cliques.pot_list'></span><span id='topic+get_clique_root_idx'></span><span id='topic+get_clique_root_idx.jt'></span><span id='topic+get_clique_root'></span><span id='topic+get_clique_root.jt'></span>

<h3>Description</h3>

<p>Return the cliques of a junction tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cliques(x)

## S3 method for class 'jt'
get_cliques(x)

## S3 method for class 'charge'
get_cliques(x)

## S3 method for class 'pot_list'
get_cliques(x)

get_clique_root_idx(x)

## S3 method for class 'jt'
get_clique_root_idx(x)

get_clique_root(x)

## S3 method for class 'jt'
get_clique_root(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cliques_+3A_x">x</code></td>
<td>
<p>A junction tree object, <code>jt</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See Example 5  and 6 of the 'jt' function 

</code></pre>

<hr>
<h2 id='get_graph'>Get graph</h2><span id='topic+get_graph'></span><span id='topic+get_graph.charge'></span><span id='topic+get_graph.cpt_list'></span>

<h3>Description</h3>

<p>Retrieve the graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_graph(x)

## S3 method for class 'charge'
get_graph(x)

## S3 method for class 'cpt_list'
get_graph(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_graph_+3A_x">x</code></td>
<td>
<p><code>cpt_list</code> or a compiled object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph as an <code>igraph</code> object
</p>

<hr>
<h2 id='get_triang_graph'>Get triangulated graph</h2><span id='topic+get_triang_graph'></span>

<h3>Description</h3>

<p>Retrieve the triangulated graph from
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_triang_graph(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_triang_graph_+3A_x">x</code></td>
<td>
<p>A compiled object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A triangulated graph as a neibor matrix
</p>

<hr>
<h2 id='initialize'>Initialize</h2><span id='topic+initialize'></span><span id='topic+initialize.charge'></span>

<h3>Description</h3>

<p>Initialization of CPTs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize(x)

## S3 method for class 'charge'
initialize(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initialize_+3A_x">x</code></td>
<td>
<p>A compiled object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiply the CPTs and allocate them to clique potentials.
</p>

<hr>
<h2 id='jt'>Junction Tree</h2><span id='topic+jt'></span><span id='topic+jt.charge'></span>

<h3>Description</h3>

<p>Construction of a junction tree and message passing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jt(x, evidence = NULL, flow = "sum", propagate = "full")

## S3 method for class 'charge'
jt(x, evidence = NULL, flow = "sum", propagate = "full")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jt_+3A_x">x</code></td>
<td>
<p>An object return from <code>compile</code></p>
</td></tr>
<tr><td><code id="jt_+3A_evidence">evidence</code></td>
<td>
<p>A named vector. The names are the variabes and the elements
are the evidence</p>
</td></tr>
<tr><td><code id="jt_+3A_flow">flow</code></td>
<td>
<p>Either &quot;sum&quot; or &quot;max&quot;</p>
</td></tr>
<tr><td><code id="jt_+3A_propagate">propagate</code></td>
<td>
<p>Either &quot;no&quot;, &quot;collect&quot; or &quot;full&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evidence can be entered either at compile stage
or after compilation. Hence, one can also combine
evidence from before compilation with evidence
after compilation. Before refers to entering
evidence in the 'compile' function and after
refers to entering evidence in the 'jt' function.
</p>


<h3>Value</h3>

<p>A <code>jt</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query_belief">query_belief</a></code>, <code><a href="#topic+mpe">mpe</a></code>,
<code><a href="#topic+get_cliques">get_cliques</a></code>, <code><a href="#topic+get_clique_root">get_clique_root</a></code>,
<code><a href="#topic+propagate">propagate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setting up the network
# ----------------------

library(igraph)
el &lt;- matrix(c(
"A", "T",
"T", "E",
"S", "L",
"S", "B",
"L", "E",
"E", "X",
"E", "D",
"B", "D"),
 nc = 2,
 byrow = TRUE
)

g &lt;- igraph::graph_from_edgelist(el)
plot(g)
# -----------------------

# Data
# ----
# We use the asia data; see the man page (?asia)

# Compilation
# -----------
cl &lt;- cpt_list(asia, g) # Checking and conversion
cp &lt;- compile(cl)

# After the network has been compiled, the graph has been triangulated and
# moralized. Furthermore, all conditional probability tables (CPTs) has been
# designated one of the cliques (in the triangulated and moralized graph).

# Example 1: sum-flow without evidence
# ------------------------------------
jt1 &lt;- jt(cp)
plot(jt1)
print(jt1)
query_belief(jt1, c("E", "L", "T"))
query_belief(jt1, c("B", "D", "E"), type = "joint")


# Notice, that jt1 is equivalent to:
# jt1 &lt;- jt(cp, propagate = "no")
# jt1 &lt;- propagate(jt1, prop = "full")

# That is; it is possible to postpone the actual propagation
# In this setup, the junction tree is saved in the jt1 object,
# and one can repeadetly enter evidence for new observations
# using the set_evidence function on jt1 and then query
# several probabilites without repeadetly calculating the
# the junction tree over and over again. One just needs
# to use the propagate function on jt1.

# Example 2: sum-flow with evidence
# ---------------------------------

e2  &lt;- c(A = "y", X = "n")
jt2 &lt;- jt(cp, e2) 
query_belief(jt2, c("B", "D", "E"), type = "joint")

# Notice that, the configuration (D,E,B) = (y,y,n) has changed
# dramatically as a consequence of the evidence

# We can get the probability of the evidence:
query_evidence(jt2)

# Example 3: max-flow without evidence
# ------------------------------------
jt3 &lt;- jt(cp, flow = "max")
mpe(jt3)


# Example 4: max-flow with evidence
# ---------------------------------
e4  &lt;- c(T = "y", X = "y", D = "y")
jt4 &lt;- jt(cp, e4, flow = "max")
mpe(jt4)

# Notice, that T, E, S, B, X and D has changed from "n" to "y"
# as a consequence of the new evidence e4


# Example 5: specifying a root node and only collect to save run time
# -------------------------------------------------------------------------


  cp5 &lt;- compile(cpt_list(asia, g), root_node = "X")
  jt5 &lt;- jt(cp5, propagate = "collect")
  query_belief(jt5, get_clique_root(jt5), "joint")


# We can only query from the variables in the root clique now
# but we have ensured that the node of interest, "X", does indeed live in
# this clique. The variables are found using 'get_clique_root'

# Example 6: Compiling from a list of conditional probabilities
# -------------------------------------------------------------------------

# * We need a list with CPTs which we extract from the asia2 object
#    - the list must be named with child nodes
#    - The elements need to be array-like objects

cl  &lt;- cpt_list(asia2)
cp6 &lt;- compile(cl)

# Inspection; see if the graph correspond to the cpts
# g &lt;- get_graph(cp6)
# plot(g) 

# This time we specify that no propagation should be performed
jt6 &lt;- jt(cp6, propagate = "no")

# We can now inspect the collecting junction tree and see which cliques
# are leaves and parents
plot(jt6)
get_cliques(jt6)
get_clique_root(jt6)

jt_leaves(jt6)
unlist(jt_parents(jt6))

# That is;
# - clique 2 is parent of clique 1
# - clique 3 is parent of clique 4 etc.

# Next, we send the messages from the leaves to the parents
jt6 &lt;- send_messages(jt6)

# Inspect again
plot(jt6)

# Send the last message to the root and inspect
jt6 &lt;- send_messages(jt6)
plot(jt6)

# The arrows are now reversed and the outwards (distribute) phase begins
jt_leaves(jt6)
jt_parents(jt6)

# Clique 2 (the root) is now a leave and it has 1, 3 and 6 as parents.

# Finishing the message passing
jt6 &lt;- send_messages(jt6)
jt6 &lt;- send_messages(jt6)

# Queries can now be performed as normal
query_belief(jt6, c("either", "tub"), "joint")

</code></pre>

<hr>
<h2 id='jt_leaves'>Query Parents or Leaves in a Junction Tree</h2><span id='topic+jt_leaves'></span><span id='topic+jt_leaves.jt'></span><span id='topic+jt_parents'></span><span id='topic+jt_parents.jt'></span>

<h3>Description</h3>

<p>Return the clique indices of current parents or leaves
in a junction tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jt_leaves(jt)

## S3 method for class 'jt'
jt_leaves(jt)

jt_parents(jt)

## S3 method for class 'jt'
jt_parents(jt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jt_leaves_+3A_jt">jt</code></td>
<td>
<p>A junction tree object, <code>jt</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>, <code><a href="#topic+get_cliques">get_cliques</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example 6 in the help page for the jt function
</code></pre>

<hr>
<h2 id='jt_nbinary_ops'>Number of Binary Operations</h2><span id='topic+jt_nbinary_ops'></span><span id='topic+jt_nbinary_ops.triangulation'></span>

<h3>Description</h3>

<p>Number of binary operations needed to propagate in a junction tree
given evidence, using the Lauritzen-Spiegelhalter scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jt_nbinary_ops(x, evidence = list(), root = NULL, nc = 1)

## S3 method for class 'triangulation'
jt_nbinary_ops(x, evidence = list(), root = NULL, nc = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jt_nbinary_ops_+3A_x">x</code></td>
<td>
<p>A junction tree object or an object returned from
the triangulation function</p>
</td></tr>
<tr><td><code id="jt_nbinary_ops_+3A_evidence">evidence</code></td>
<td>
<p>List of character vectors with evidence nodes</p>
</td></tr>
<tr><td><code id="jt_nbinary_ops_+3A_root">root</code></td>
<td>
<p>Integer specifying the root node in the junction tree</p>
</td></tr>
<tr><td><code id="jt_nbinary_ops_+3A_nc">nc</code></td>
<td>
<p>Integer. The number of cores to be used in parallel</p>
</td></tr>
</table>

<hr>
<h2 id='mpd'>Maximal Prime Decomposition</h2><span id='topic+mpd'></span><span id='topic+mpd.matrix'></span><span id='topic+mpd.cpt_list'></span>

<h3>Description</h3>

<p>Find the maximal prime decomposition and its associated junction tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpd(x, save_graph = TRUE)

## S3 method for class 'matrix'
mpd(x, save_graph = TRUE)

## S3 method for class 'cpt_list'
mpd(x, save_graph = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpd_+3A_x">x</code></td>
<td>
<p>Either a neighbor matrix or a <code>cpt_list</code> object</p>
</td></tr>
<tr><td><code id="mpd_+3A_save_graph">save_graph</code></td>
<td>
<p>Logical indicating if the moralized graph should be kept.
Useful when <code>x</code> is a <code>cpt_list</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>- <code>prime_ints</code>: a list with the prime components,
- <code>flawed</code>: indicating which prime components that are triangulated
- <code>jt_collect</code>: the MPD junction tree prepared for collecting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
el &lt;- matrix(c(
"A", "T",
"T", "E",
"S", "L",
"S", "B",
"L", "E",
"E", "X",
"E", "D",
"B", "D"),
 nc = 2,
 byrow = TRUE
)

g &lt;- igraph::graph_from_edgelist(el, directed = FALSE)
A &lt;- igraph::as_adjacency_matrix(g, sparse = FALSE)
mpd(A)
</code></pre>

<hr>
<h2 id='mpe'>Most Probable Explanation</h2><span id='topic+mpe'></span><span id='topic+mpe.jt'></span>

<h3>Description</h3>

<p>Returns the most probable explanation given the evidence entered in the
junction tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpe(x)

## S3 method for class 'jt'
mpe(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpe_+3A_x">x</code></td>
<td>
<p>A junction tree object, <code>jt</code>, with max-flow.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the 'jt' function
</code></pre>

<hr>
<h2 id='plot.charge'>A plot method for junction trees</h2><span id='topic+plot.charge'></span>

<h3>Description</h3>

<p>A plot method for junction trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'charge'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.charge_+3A_x">x</code></td>
<td>
<p>A compile object</p>
</td></tr>
<tr><td><code id="plot.charge_+3A_...">...</code></td>
<td>
<p>For S3 compatability. Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+compile">compile</a></code>
</p>

<hr>
<h2 id='plot.jt'>A plot method for junction trees</h2><span id='topic+plot.jt'></span>

<h3>Description</h3>

<p>A plot method for junction trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jt'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jt_+3A_x">x</code></td>
<td>
<p>A junction tree object, <code>jt</code>.</p>
</td></tr>
<tr><td><code id="plot.jt_+3A_...">...</code></td>
<td>
<p>For S3 compatability. Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>
</p>

<hr>
<h2 id='pot_list'>A check and extraction of clique potentials from a Markov random field
to be used in the junction tree algorithm</h2><span id='topic+pot_list'></span><span id='topic+pot_list.data.frame'></span>

<h3>Description</h3>

<p>A check and extraction of clique potentials from a Markov random field
to be used in the junction tree algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pot_list(x, g)

## S3 method for class 'data.frame'
pot_list(x, g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pot_list_+3A_x">x</code></td>
<td>
<p>Character <code>data.frame</code></p>
</td></tr>
<tr><td><code id="pot_list_+3A_g">g</code></td>
<td>
<p>A decomposable Markov random field as an igraph object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Typically one would use the ess package:
# library(ess)
# g  &lt;- ess::fit_graph(derma)
# pl &lt;- pot_list(derma, ess::as_igraph(g))
# pl

# Another example
g &lt;- igraph::sample_gnm(ncol(asia), 12)
while(!igraph::is.chordal(g)$chordal) g &lt;- igraph::sample_gnm(ncol(asia), 12, FALSE)
igraph::V(g)$name &lt;- colnames(asia)
plot(g)
pot_list(asia, g)

</code></pre>

<hr>
<h2 id='print.charge'>A print method for compiled objects</h2><span id='topic+print.charge'></span>

<h3>Description</h3>

<p>A print method for compiled objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'charge'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.charge_+3A_x">x</code></td>
<td>
<p>A compiled object</p>
</td></tr>
<tr><td><code id="print.charge_+3A_...">...</code></td>
<td>
<p>For S3 compatability. Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>
</p>

<hr>
<h2 id='print.cpt_list'>A print method for cpt lists</h2><span id='topic+print.cpt_list'></span>

<h3>Description</h3>

<p>A print method for cpt lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpt_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cpt_list_+3A_x">x</code></td>
<td>
<p>A <code>cpt_list</code> object</p>
</td></tr>
<tr><td><code id="print.cpt_list_+3A_...">...</code></td>
<td>
<p>For S3 compatability. Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+compile">compile</a></code>
</p>

<hr>
<h2 id='print.jt'>A print method for junction trees</h2><span id='topic+print.jt'></span>

<h3>Description</h3>

<p>A print method for junction trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.jt_+3A_x">x</code></td>
<td>
<p>A junction tree object, <code>jt</code>.</p>
</td></tr>
<tr><td><code id="print.jt_+3A_...">...</code></td>
<td>
<p>For S3 compatability. Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>
</p>

<hr>
<h2 id='propagate'>Propagation of junction trees</h2><span id='topic+propagate'></span><span id='topic+propagate.jt'></span>

<h3>Description</h3>

<p>Given a junction tree object, propagation is conducted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagate(x, prop = "full")

## S3 method for class 'jt'
propagate(x, prop = "full")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="propagate_+3A_x">x</code></td>
<td>
<p>A junction tree object <code>jt</code></p>
</td></tr>
<tr><td><code id="propagate_+3A_prop">prop</code></td>
<td>
<p>Either &quot;collect&quot; or &quot;full&quot;.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See Example 1 in the 'jt' function
</code></pre>

<hr>
<h2 id='query_belief'>Query probabilities</h2><span id='topic+query_belief'></span><span id='topic+query_belief.jt'></span>

<h3>Description</h3>

<p>Get probabilities from a junction tree object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_belief(x, nodes, type = "marginal")

## S3 method for class 'jt'
query_belief(x, nodes, type = "marginal")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query_belief_+3A_x">x</code></td>
<td>
<p>A junction tree object, <code>jt</code>.</p>
</td></tr>
<tr><td><code id="query_belief_+3A_nodes">nodes</code></td>
<td>
<p>The nodes for which the probability is desired</p>
</td></tr>
<tr><td><code id="query_belief_+3A_type">type</code></td>
<td>
<p>Either 'marginal' or 'joint'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>, <code><a href="#topic+mpe">mpe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the 'jt' function
</code></pre>

<hr>
<h2 id='query_evidence'>Query Evidence</h2><span id='topic+query_evidence'></span><span id='topic+query_evidence.jt'></span>

<h3>Description</h3>

<p>Get the probability of the evidence entered in the junction tree object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_evidence(x)

## S3 method for class 'jt'
query_evidence(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query_evidence_+3A_x">x</code></td>
<td>
<p>A junction tree object, <code>jt</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>, <code><a href="#topic+mpe">mpe</a></code>
</p>

<hr>
<h2 id='send_messages'>Send Messages in a Junction Tree</h2><span id='topic+send_messages'></span>

<h3>Description</h3>

<p>Send messages from the current leaves to the current parents
in a junction tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send_messages(jt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="send_messages_+3A_jt">jt</code></td>
<td>
<p>A <code>jt</code> object return from the <code>jt</code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>, <code><a href="#topic+get_cliques">get_cliques</a></code>, <code><a href="#topic+jt_leaves">jt_leaves</a></code>,
<code><a href="#topic+jt_parents">jt_parents</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example 6 in the help page for the jt function
</code></pre>

<hr>
<h2 id='set_evidence'>Enter Evidence</h2><span id='topic+set_evidence'></span><span id='topic+set_evidence.jt'></span><span id='topic+set_evidence.charge'></span>

<h3>Description</h3>

<p>Enter evidence into a the junction tree object that has not been propagated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_evidence(x, evidence, initialize_cpts = TRUE)

## S3 method for class 'jt'
set_evidence(x, evidence, initialize_cpts = FALSE)

## S3 method for class 'charge'
set_evidence(x, evidence, initialize_cpts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_evidence_+3A_x">x</code></td>
<td>
<p>A junction tree object, <code>jt</code>.</p>
</td></tr>
<tr><td><code id="set_evidence_+3A_evidence">evidence</code></td>
<td>
<p>A named vector. The names are the variabes and the elements
are the evidence.</p>
</td></tr>
<tr><td><code id="set_evidence_+3A_initialize_cpts">initialize_cpts</code></td>
<td>
<p><code>TRUE</code> if the CPTs should be initialized and then
create the clique potentials. Only relevant on objects returned from <code>compile</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+jt">jt</a></code>, <code><a href="#topic+mpe">mpe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the 'jt' function
</code></pre>

<hr>
<h2 id='sim_data_from_bn'>Simulate data from a Bayesian network</h2><span id='topic+sim_data_from_bn'></span>

<h3>Description</h3>

<p>Simulate data from a Bayesian network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data_from_bn(
  net,
  lvls,
  nsims = 1000,
  increasing_prob = FALSE,
  p1 = 0.8,
  p2 = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_data_from_bn_+3A_net">net</code></td>
<td>
<p>A Bayesian network as an igraph object</p>
</td></tr>
<tr><td><code id="sim_data_from_bn_+3A_lvls">lvls</code></td>
<td>
<p>Named integer vector where each element is the size of the
statespace of the corresponding variable</p>
</td></tr>
<tr><td><code id="sim_data_from_bn_+3A_nsims">nsims</code></td>
<td>
<p>Number of simulations
distributions from which the simulatios are drawn.</p>
</td></tr>
<tr><td><code id="sim_data_from_bn_+3A_increasing_prob">increasing_prob</code></td>
<td>
<p>Logical. If true, probabilities in the underlying CPTs
increases with as the number of levels increses.</p>
</td></tr>
<tr><td><code id="sim_data_from_bn_+3A_p1">p1</code></td>
<td>
<p>Probability</p>
</td></tr>
<tr><td><code id="sim_data_from_bn_+3A_p2">p2</code></td>
<td>
<p>Probability</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- igraph::graph(as.character(c(1,2,1,3,3,4,3,5,5,4,2,6,6,7,5,7)), directed = TRUE)
nodes_net &lt;- igraph::V(net)$name
lvls_net  &lt;- structure(sample(3:9, length(nodes_net)), names = nodes_net)
lvls_net  &lt;- structure(rep(3, length(nodes_net)), names = nodes_net)
sim_data_from_bn(net, lvls_net, 10)
</code></pre>

<hr>
<h2 id='sim_data_from_dmrf'>Simulate data from a decomposable discrete markov random field</h2><span id='topic+sim_data_from_dmrf'></span>

<h3>Description</h3>

<p>Simulate data from a decomposable discrete markov random field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data_from_dmrf(
  graph,
  lvls,
  nsims = 1000,
  increasing_prob = FALSE,
  p1 = 0.8,
  p2 = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_data_from_dmrf_+3A_graph">graph</code></td>
<td>
<p>A decomposable discrete markov random field as an igraph object</p>
</td></tr>
<tr><td><code id="sim_data_from_dmrf_+3A_lvls">lvls</code></td>
<td>
<p>Named integer vector where each element is the size of the
statespace of the corresponding variable</p>
</td></tr>
<tr><td><code id="sim_data_from_dmrf_+3A_nsims">nsims</code></td>
<td>
<p>Number of simulations
distributions from which the simulatios are drawn.</p>
</td></tr>
<tr><td><code id="sim_data_from_dmrf_+3A_increasing_prob">increasing_prob</code></td>
<td>
<p>Logical. If true, probabilities in the underlying CPTs
increases with as the number of levels increses.</p>
</td></tr>
<tr><td><code id="sim_data_from_dmrf_+3A_p1">p1</code></td>
<td>
<p>Probability</p>
</td></tr>
<tr><td><code id="sim_data_from_dmrf_+3A_p2">p2</code></td>
<td>
<p>Probability</p>
</td></tr>
</table>

<hr>
<h2 id='triangulate'>Triangulate a Bayesian network</h2><span id='topic+triangulate'></span><span id='topic+triangulate.cpt_list'></span>

<h3>Description</h3>

<p>Given a list of CPTs, this function finds a triangulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate(
  x,
  root_node = "",
  joint_vars = NULL,
  tri = "min_fill",
  pmf_evidence = NULL,
  alpha = NULL,
  perm = FALSE,
  mpd_based = FALSE
)

## S3 method for class 'cpt_list'
triangulate(
  x,
  root_node = "",
  joint_vars = NULL,
  tri = "min_fill",
  pmf_evidence = NULL,
  alpha = NULL,
  perm = FALSE,
  mpd_based = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triangulate_+3A_x">x</code></td>
<td>
<p>An object returned from <code>cpt_list</code> (baeysian network) or
<code>pot_list</code> (decomposable markov random field)</p>
</td></tr>
<tr><td><code id="triangulate_+3A_root_node">root_node</code></td>
<td>
<p>A node for which we require it to live in the root
clique (the first clique).</p>
</td></tr>
<tr><td><code id="triangulate_+3A_joint_vars">joint_vars</code></td>
<td>
<p>A vector of variables for which we require them
to be in the same clique. Edges between all these variables are added
to the moralized graph.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_tri">tri</code></td>
<td>
<p>The optimization strategy used for triangulation if x originates
from a Baeysian network. One of
</p>

<ul>
<li><p> 'min_fill'
</p>
</li>
<li><p> 'min_rfill'
</p>
</li>
<li><p> 'min_sp'
</p>
</li>
<li><p> 'min_ssp'
</p>
</li>
<li><p> 'min_lsp'
</p>
</li>
<li><p> 'min_lssp'
</p>
</li>
<li><p> 'min_elsp'
</p>
</li>
<li><p> 'min_elssp'
</p>
</li>
<li><p> 'min_nei'
</p>
</li>
<li><p> 'minimal'
</p>
</li>
<li><p> 'alpha'
</p>
</li></ul>
</td></tr>
<tr><td><code id="triangulate_+3A_pmf_evidence">pmf_evidence</code></td>
<td>
<p>A named vector of frequencies of the expected
missingness of a variable. Variables with frequencies of 1 can be
neglected; these are inferrred. A value of 0.25 means, that the
given variable is expected to be missing (it is not a evidence node)
in one fourth of the future cases. Relevant for <code>tri</code> methods
'min_elsp' and 'min_elssp'.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_alpha">alpha</code></td>
<td>
<p>Character vector. A permutation of the nodes
in the graph. It specifies a user-supplied eliminination ordering for
triangulation of the moral graph.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_perm">perm</code></td>
<td>
<p>Logical. If <code>TRUE</code> the moral graph is permuted</p>
</td></tr>
<tr><td><code id="triangulate_+3A_mpd_based">mpd_based</code></td>
<td>
<p>Logical. True if the triangulation should be performed on a maximal
peime decomposition</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
