<!DOCTYPE html><html><head><title>Help for package MNM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MNM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#affine.trans'><p> Function For Affine Data Transformation</p></a></li>
<li><a href='#anova.mvl1lm'>
<p>Comparisons between Multivariate Linear Models</p></a></li>
<li><a href='#beans'><p> Randomized Block Experiment of Plots of Beans</p></a></li>
<li><a href='#coef.mvl1lm'>
<p>Coefficients of an mvl1lm Object</p></a></li>
<li><a href='#fitted.mvl1lm'>
<p>Fitted Values of an mvl1lm Object</p></a></li>
<li><a href='#MNM-package'>
<p>Multivariate Nonparametric Methods. An Approach Based on Spatial Signs and Ranks</p></a></li>
<li><a href='#mv.1sample.est'><p> Multivariate One Sample Location Estimates</p></a></li>
<li><a href='#mv.1sample.test'><p>Multivariate Location Tests</p></a></li>
<li><a href='#mv.2sample.est'><p> Multivariate Two Sample Shift Estimates</p></a></li>
<li><a href='#mv.2way.est'><p>Treatment Effect Estimates in the Randomized Complete Block Case</p></a></li>
<li><a href='#mv.2way.test'><p>Randomized Complete Block Design.</p></a></li>
<li><a href='#mv.Csample.test'><p>C Sample Test of Location</p></a></li>
<li><a href='#mv.ind.test'>
<p>Independence Test</p></a></li>
<li><a href='#mv.l1lm'>
<p>Linear Regression Based on Identity, Spatial Sign or Spatial Rank Scores</p></a></li>
<li><a href='#mv.shape.est'><p>Shape Matrices</p></a></li>
<li><a href='#mv.shape.test'><p> Test for Sphericity</p></a></li>
<li><a href='#mvPCA'><p> Principal Component Analysis</p></a></li>
<li><a href='#pairs2'>
<p>Plotting two numeric matrices</p></a></li>
<li><a href='#plot.mvl1lm'>
<p>Residual Plot for an mvl1lm Object</p></a></li>
<li><a href='#plot.mvloc'>
<p>Plotting Method for mvloc Objects</p></a></li>
<li><a href='#plotMvloc'><p> Function to Plot Multivariate Location Estimates and Their Confidence Ellipsoids.</p></a></li>
<li><a href='#plotShape'><p> Pairwise Scatterplot Matrix of Shape Matrices</p></a></li>
<li><a href='#predict.mvl1lm'>
<p>Predicted Values Based on a Model Fitted by mv.l1lm</p></a></li>
<li><a href='#predict.mvPCA'><p> Prediction Method for a Principal Component Object of Type mvPCA</p></a></li>
<li><a href='#print.anovamvl1lm'>
<p>Printing an Object of Class anovamvl1lm</p></a></li>
<li><a href='#print.mvcloc'><p>Printing an 'mvcloc' Object</p></a></li>
<li><a href='#print.mvl1lm'>
<p>Printing an mvl1lm Object</p></a></li>
<li><a href='#print.mvloc'><p>Printing an 'mvloc' Object</p></a></li>
<li><a href='#print.mvPCA'><p> Printing Method for a Principal Component Object of Type mvPCA</p></a></li>
<li><a href='#residuals.mvl1lm'>
<p>Residuals of an mvl1lm Object</p></a></li>
<li><a href='#rmvpowerexp'><p>Random Samples From a Power Exponential Distributions</p></a></li>
<li><a href='#runifsphere'><p>Random Samples From the Unit Sphere</p></a></li>
<li><a href='#screeplot.mvPCA'><p> Plotting Method for a Principal Component Object of Type mvPCA</p></a></li>
<li><a href='#spatial.sign2'>
<p>Spatial Signs</p></a></li>
<li><a href='#summary.mvcloc'><p> Summarizing an 'mvcloc' Object</p></a></li>
<li><a href='#summary.mvl1lm'>
<p>Summary for an mvl1lm Object</p></a></li>
<li><a href='#summary.mvloc'><p> Summarizing an 'mvloc' Object</p></a></li>
<li><a href='#summary.mvPCA'><p>Summary for an object of class mvPCA.</p></a></li>
<li><a href='#vcov.mvl1lm'>
<p>Variance-Covariance Matrix of an mvl1lm Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Nonparametric Methods. An Approach Based on Spatial
Signs and Ranks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jyrki Mottonen <a href="https://orcid.org/0000-0002-6270-2556"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Hannu Oja <a href="https://orcid.org/0000-0002-4945-5976"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9.2), ICSNP, SpatialNP</td>
</tr>
<tr>
<td>Imports:</td>
<td>ellipse, ICS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gamlss, mvtnorm</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariate tests, estimates and methods based on the identity score, spatial sign score and spatial rank score are provided. The methods include one and c-sample problems, shape estimation and testing, linear regression and principal components. The methodology is described in Oja (2010) &lt;<a href="https://doi.org/10.1007%2F978-1-4419-0468-3">doi:10.1007/978-1-4419-0468-3</a>&gt; and Nordhausen and Oja (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v043.i05">doi:10.18637/jss.v043.i05</a>&gt;.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 13:04:58 UTC; admin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 14:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='affine.trans'> Function For Affine Data Transformation </h2><span id='topic+affine.trans'></span>

<h3>Description</h3>

<p>Function for transformations of the form <code class="reqn">Ax + b</code> or <code class="reqn">A^{1/2}x + b</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affine.trans(X, A = diag(1, dim(X)[2]), b = rep(0, dim(X)[2]), 
             A.sqrt = FALSE, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.trans_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix with p columns. </p>
</td></tr>
<tr><td><code id="affine.trans_+3A_a">A</code></td>
<td>
<p>full rank p times p matrix. </p>
</td></tr>
<tr><td><code id="affine.trans_+3A_b">b</code></td>
<td>
<p>numeric vector of length p. </p>
</td></tr>
<tr><td><code id="affine.trans_+3A_a.sqrt">A.sqrt</code></td>
<td>
<p>logical. If <code>TRUE</code> the symmetric square root of A will be used.</p>
</td></tr>
<tr><td><code id="affine.trans_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
IRIS &lt;- iris[,1:4]
colMeans(IRIS)
cov(IRIS)
IRIS.trans &lt;- affine.trans(IRIS, solve(cov(IRIS)), colMeans(IRIS),TRUE)
colMeans(IRIS.trans)
cov(IRIS.trans)
</code></pre>

<hr>
<h2 id='anova.mvl1lm'>
Comparisons between Multivariate Linear Models
</h2><span id='topic+anova.mvl1lm'></span>

<h3>Description</h3>

<p>Comparisons between nested multivariate linear models fitted by <code><a href="#topic+mv.l1lm">mv.l1lm</a></code>. The comparison can be based on score type of tests and Wald type of tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
anova(object, object2 = NULL, test = "Score", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.mvl1lm_+3A_object">object</code></td>
<td>

<p>an object of class <code>mvl1lm</code>. This gives the full model.
</p>
</td></tr>
<tr><td><code id="anova.mvl1lm_+3A_object2">object2</code></td>
<td>

<p>an object of class <code>mvl1lm</code> or <code>NULL</code>. This gives the restricted (nested) model.
</p>
</td></tr>
<tr><td><code id="anova.mvl1lm_+3A_test">test</code></td>
<td>

<p>The test to be used. Options are <code>Score</code> and <code>Wald</code>. The score version is the default.
</p>
</td></tr>
<tr><td><code id="anova.mvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only <code>object</code> is provided the function tests if all parameters equal zero. If <code>object</code> and <code>object2</code> are provided the function tests the
null hypothesis that the the restricted model (<code>object2</code>) is true.
For details see chapter 13 of the MNM book. Note that it is the users responsibility to make sure that the two models are nested and fitted on the same data.
For the regular L2 regression <code><a href="stats.html#topic+anova.mlm">anova.mlm</a></code> provides more options. 
</p>


<h3>Value</h3>

<p>A list with class 'anovamvl1lm' containing the following components:
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>the model call(s) of <code>object</code> and <code>object2</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>type of the test used.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of the test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer.</cite>
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating simple data

X &lt;- cbind(rep(1,100),rmvnorm(100,c(0,0,0)) )
B &lt;- matrix(c(4,1,1,0.5,-3,2,2,2),ncol=4, byrow=TRUE)
Y &lt;- X %*% t(B)+ rmvnorm(100,c(0,0), diag(0.2,2))
DAT &lt;- data.frame(x1=X[,2],x2=X[,3], x3=X[,4])

FullModel &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "s", stand="i", data=DAT)
RestModel &lt;- mv.l1lm(Y ~ x1, scores= "s", stand="i", data=DAT)

anova(FullModel)
anova(FullModel, RestModel)
anova(FullModel, RestModel, test="W")
</code></pre>

<hr>
<h2 id='beans'> Randomized Block Experiment of Plots of Beans</h2><span id='topic+beans'></span>

<h3>Description</h3>

<p>Results of a randomized block experiment in the Cook Islands involving the effect of six different treatments on plots of beans infested by the serpentine leaf miner insect. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(beans)</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 5 variables.
</p>

<dl>
<dt><code>Block</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code>.</p>
</dd>
<dt><code>Treatment</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code>.</p>
</dd>
<dt><code>y1</code></dt><dd><p>a numeric vector. The number of miners per leaf.</p>
</dd>
<dt><code>y2</code></dt><dd><p>a numeric vector. The weight of beans per plot (in kg).</p>
</dd>
<dt><code>y3</code></dt><dd><p>a numeric vector. 1/sin(sqrt(p)), where p is the proportion of leaves infested with borer.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The value of variable <code>y3</code> in Block 4 for Treatment 2 is an estimate of a missing value.
</p>


<h3>Source</h3>

<p>Data courtesy of Dr. R. Fullerton.
</p>


<h3>References</h3>

<p><cite>Seber, G. A. F. (1998), <em>Multivariate Observations</em>, London: Arnold.  </cite></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beans)
plot(beans)
</code></pre>

<hr>
<h2 id='coef.mvl1lm'>
Coefficients of an mvl1lm Object
</h2><span id='topic+coef.mvl1lm'></span>

<h3>Description</h3>

<p>Extracts the coefficents of an mvl1lm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mvl1lm_+3A_object">object</code></td>
<td>

<p>an object of class <code>mvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="coef.mvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for <code>rank</code> scores the intercept, even when specified in the model, is not considered a coefficient.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='fitted.mvl1lm'>
Fitted Values of an mvl1lm Object
</h2><span id='topic+fitted.mvl1lm'></span>

<h3>Description</h3>

<p>Extracts the fitted values of an mvl1lm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.mvl1lm_+3A_object">object</code></td>
<td>

<p>an object of class <code>mvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="fitted.mvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='MNM-package'>
Multivariate Nonparametric Methods. An Approach Based on Spatial Signs and Ranks</h2><span id='topic+MNM-package'></span><span id='topic+MNM'></span>

<h3>Description</h3>

<p>Multivariate tests, estimates and methods based on the identity score, spatial sign score and spatial rank score are provided. The methods include one and c-sample problems, shape estimation and testing, 
linear regression and principal components.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MNM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Multivariate Nonparametric Methods. An Approach Based on Spatial Signs and Ranks</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-11-29</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> 
    c(person("Klaus", "Nordhausen", 
             email = "klausnordhausenR@gmail.com",
             role = c("aut", "cre"),
             comment = c(ORCID = "0000-0002-3758-8501")),
      person("Jyrki", "Mottonen", 
             role = c("aut"),
             comment = c(ORCID = "0000-0002-6270-2556")),
      person("Hannu", "Oja", 
             role = c("aut"),
             comment = c(ORCID = "0000-0002-4945-5976")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> 
  Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
  Jyrki Mottonen [aut] (&lt;https://orcid.org/0000-0002-6270-2556&gt;),
  Hannu Oja [aut] (&lt;https://orcid.org/0000-0002-4945-5976&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.9.2), ICSNP, SpatialNP</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> ellipse, ICS</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> gamlss, mvtnorm</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Multivariate tests, estimates and methods based on the identity score, spatial sign score and spatial rank score are provided. The methods include one and c-sample problems, shape estimation and testing, linear regression and principal components. The methodology is described in Oja (2010) &lt;doi:10.1007/978-1-4419-0468-3&gt; and Nordhausen and Oja (2011) &lt;doi:10.18637/jss.v043.i05&gt;.  </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The methods implemented here are mainly described in Oja (2010) and the package can be used to reproduce most of the examples in the book. The book will be refered to as the MNM book. 
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen, Jyrki Mottonen and Hannu Oja
</p>
<p>Maintainer: Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R. An Approach Based on Spatial Signs and Ranks</em>, Springer. &lt;doi:10.1007/978-1-4419-0468-3&gt;. </cite> 
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28. &lt;doi:10.18637/jss.v043.i05&gt;.</cite>
</p>

<hr>
<h2 id='mv.1sample.est'> Multivariate One Sample Location Estimates</h2><span id='topic+mv.1sample.est'></span>

<h3>Description</h3>

<p>Estimates the multivariate location for different score functions and their asymptotic covariance matrices in the one sample case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.1sample.est(X, score = "identity", stand = "outer", maxiter = 100, 
               eps = 1e-06, na.action = na.fail, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.1sample.est_+3A_x">X</code></td>
<td>
<p> a numeric data frame or matrix. </p>
</td></tr>
<tr><td><code id="mv.1sample.est_+3A_score">score</code></td>
<td>
<p> the score to be used. Possible choices are <code>identity</code>, <code>sign</code> and <code>rank</code>. </p>
</td></tr>
<tr><td><code id="mv.1sample.est_+3A_stand">stand</code></td>
<td>
<p> the standardization method used. Possible choices are <code>outer</code> and <code>inner</code>.</p>
</td></tr>
<tr><td><code id="mv.1sample.est_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum number of iterations. Used only for <code>score = "sign"</code> and  <code>score = "rank"</code>.</p>
</td></tr>
<tr><td><code id="mv.1sample.est_+3A_eps">eps</code></td>
<td>
<p> convergence tolerance. Used only for <code>score = "sign"</code> and  <code>score = "rank"</code>.</p>
</td></tr>
<tr><td><code id="mv.1sample.est_+3A_...">...</code></td>
<td>
<p> arguments that can be passed on to functions used for the estimation of location. </p>
</td></tr>
<tr><td><code id="mv.1sample.est_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's. Default is to fail. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For identity scores the location estimate is the regular mean vector. For the spatial sign score it is the spatial median in the outer
standardization case and the Hettmansperger-Randles estimate in the inner standardization case. The rank estimate is the spatial Hodges-Lehmann estimator,
either regular (<code>stand = "outer"</code>) or affine equivariant (<code>stand = "inner"</code>).
</p>
<p>Computation with outer standardization is faster than with inner standardization and especially the rank version might be slow and memory consuming.
</p>
<p>For further details see chapters 3, 5, 6, 7 and 8 of the MNM book. 
</p>


<h3>Value</h3>

<p>A list with class 'mvloc' containing the following components:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>the location estimate as a vector.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the asymptotic covariance matrix of the location estimate.</p>
</td></tr>
<tr><td><code>est.name</code></td>
<td>
<p>name of the location estimate.</p>
</td></tr>
<tr><td><code>dname</code></td>
<td>
<p>name of the data set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. 
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite></p>


<h3>See Also</h3>

 <p><code><a href="ICSNP.html#topic+spatial.sign">spatial.sign</a></code>, <code><a href="SpatialNP.html#topic+spatial.signrank">spatial.signrank</a></code>, <code><a href="ICSNP.html#topic+spatial.median">spatial.median</a></code>, <code><a href="ICSNP.html#topic+HR.Mest">HR.Mest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1)
  X &lt;- rmvt(100, diag(c(1, 2, 0.5)), 3)
 
  est.Hot.X &lt;- mv.1sample.est(X)
  est.SS.o.X &lt;- mv.1sample.est(X,"s")
  est.SS.i.X &lt;- mv.1sample.est(X,"s","i")
  est.SR.o.X &lt;- mv.1sample.est(X,"r")
  est.SR.i.X &lt;- mv.1sample.est(X,"r","i")
  
  est.SR.o.X
  summary(est.SR.o.X)
  
  # plotting
   
  plot(est.Hot.X, est.SS.i.X, est.SR.i.X, X)
  # or
  plot(est.Hot.X, est.SS.i.X, est.SR.i.X)
</code></pre>

<hr>
<h2 id='mv.1sample.test'>Multivariate Location Tests </h2><span id='topic+mv.1sample.test'></span>

<h3>Description</h3>

<p>Tests for multivariate location using different score functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.1sample.test(X, mu = 0, score = "identity", stand = "outer", 
                method = "approximation", n.simu = 1000, 
                na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.1sample.test_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. </p>
</td></tr>
<tr><td><code id="mv.1sample.test_+3A_mu">mu</code></td>
<td>
<p> the null hypothesis value. Default is the zero vector.</p>
</td></tr>
<tr><td><code id="mv.1sample.test_+3A_score">score</code></td>
<td>
<p>the score to be used. Possible choices are <code>identity</code>, <code>sign</code> and <code>rank</code>.</p>
</td></tr>
<tr><td><code id="mv.1sample.test_+3A_stand">stand</code></td>
<td>
<p> the standardization method used. Possible choices are <code>outer</code> and <code>inner</code>. </p>
</td></tr>
<tr><td><code id="mv.1sample.test_+3A_method">method</code></td>
<td>
<p> method for the computation of the p-value for the spatial sign and spatial signed-rank tests.
Possible choices are <code>approximation</code> and <code>signchange</code>. </p>
</td></tr>
<tr><td><code id="mv.1sample.test_+3A_n.simu">n.simu</code></td>
<td>
<p> number of simulated sign changes if  <code>method=signchange</code>.</p>
</td></tr>
<tr><td><code id="mv.1sample.test_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's. Default is to fail. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tests provided here are the Hotelling's T^2 test, the spatial sign test and the signed-rank test and their affine invariant versions in the one sample location case. 
</p>
<p>Note that for the identity score the provided test is not the traditional Hotelling's T^2 test because here the covariance matrix is computed wrt to the null value and not wrt to the sample mean.
Use the function <code><a href="ICSNP.html#topic+HotellingsT2">HotellingsT2</a></code> for the traditional version of Hotelling's T^2 test.
Details about the tests can be found in the chapters 5-8 of the MNM book.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the test statistic or the number of replications in the simulation.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the location.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite>
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite>
</p>


<h3>See Also</h3>

 <p><code><a href="ICSNP.html#topic+HotellingsT2">HotellingsT2</a></code>,  <code><a href="SpatialNP.html#topic+sr.loc.test">sr.loc.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
X &lt;- rmvt(100, diag(c(1, 2, 0.5)), 3)

mv.1sample.test(X,mu=c(0,0,0.5))
mv.1sample.test(X,score="s", stand="i")
mv.1sample.test(X,score="s", stand="i", method="s")
mv.1sample.test(X,score="r", stand="o")
mv.1sample.test(X,score="r", stand="i")
</code></pre>

<hr>
<h2 id='mv.2sample.est'> Multivariate Two Sample Shift Estimates </h2><span id='topic+mv.2sample.est'></span>

<h3>Description</h3>

<p>Estimates the multivariate shift for different score functions and their asymptotic covariance matrices in the two sample case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.2sample.est(X, g, score = "identity", stand = "outer", 
               maxiter = 100, eps = 1e-06, na.action = na.fail,
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.2sample.est_+3A_x">X</code></td>
<td>
<p> a numeric data frame or matrix. </p>
</td></tr>
<tr><td><code id="mv.2sample.est_+3A_g">g</code></td>
<td>
<p> a factor with two levels </p>
</td></tr>
<tr><td><code id="mv.2sample.est_+3A_score">score</code></td>
<td>
<p> the score to be used. Possible choices are <code>identity</code>, <code>sign</code> and <code>rank</code>. </p>
</td></tr>
<tr><td><code id="mv.2sample.est_+3A_stand">stand</code></td>
<td>
<p> the standardization method used. Possible choices are <code>outer</code> and <code>inner</code>.</p>
</td></tr>
<tr><td><code id="mv.2sample.est_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum number of iterations. Used only for <code>score = "sign"</code> and  <code>score = "rank"</code>.</p>
</td></tr>
<tr><td><code id="mv.2sample.est_+3A_eps">eps</code></td>
<td>
<p> convergence tolerance. Used only for <code>score = "sign"</code> and  <code>score = "rank"</code>.</p>
</td></tr>
<tr><td><code id="mv.2sample.est_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's. Default is to fail.</p>
</td></tr>
<tr><td><code id="mv.2sample.est_+3A_...">...</code></td>
<td>
<p> arguments that can be passed on to functions used for the estimation of location. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the location estimates and their asymptotic covariance matrices as described in chapter 11 of the MNM book.
Note that the shift is the parameter for the defference between 'values of level 1 - values of level 2' where the levels are as defined in the factor <code>g</code>.
</p>
<p>For the general c sample location case the function <code><a href="#topic+mv.l1lm">mv.l1lm</a></code> might be used.  
</p>


<h3>Value</h3>

<p>A list with class 'mvloc' containing the following components:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>the location estimate as a vector.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the asymptotic covariance matrix of the location estimate.</p>
</td></tr>
<tr><td><code>est.name</code></td>
<td>
<p>name of the location estimate.</p>
</td></tr>
<tr><td><code>dname</code></td>
<td>
<p>name of data set for which the location was computed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> 
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite>
</p>


<h3>See Also</h3>

 <p><code><a href="ICSNP.html#topic+spatial.sign">spatial.sign</a></code>, <code><a href="SpatialNP.html#topic+spatial.signrank">spatial.signrank</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X1&lt;- rmvnorm(50,c(0,0,0))
X2&lt;- rmvnorm(70,c(1,1,2))
X&lt;-rbind(X1,X2)
g&lt;-factor(rep(1:2,c(50,70)))

  est.Hot.X &lt;- mv.2sample.est(X, g)
  est.SS.o.X &lt;- mv.2sample.est(X, g, "s")
  est.SS.i.X &lt;- mv.2sample.est(X, g, "s", "i")
  est.SR.o.X &lt;- mv.2sample.est(X, g, "r")
  est.SR.i.X &lt;- mv.2sample.est(X, g, "r", "i")

  est.SS.o.X
  
  summary(est.SS.o.X)
  
  # plotting
   
  plotMvloc(est.Hot.X, est.SS.i.X, est.SR.i.X)

</code></pre>

<hr>
<h2 id='mv.2way.est'>Treatment Effect Estimates in the Randomized Complete Block Case</h2><span id='topic+mv.2way.est'></span>

<h3>Description</h3>

<p>The treatment effect estimates for different
score functions and their asymptotic covariance matrices in the
randomized complete block case.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.2way.est(x, block, treatment, score = c("identity", "sign", "rank"),
             stand = c("outer", "inner"), 
             eps=1.0e-10, n.iter=1000, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.2way.est_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix.</p>
</td></tr>
<tr><td><code id="mv.2way.est_+3A_block">block</code></td>
<td>
<p>a factor with at least two levels.</p>
</td></tr>
<tr><td><code id="mv.2way.est_+3A_treatment">treatment</code></td>
<td>
<p>a factor with at least two levels.</p>
</td></tr>
<tr><td><code id="mv.2way.est_+3A_score">score</code></td>
<td>
<p>the score to be used. Possible choices are
<code>identity</code>, <code>sign</code> and <code>rank</code>.</p>
</td></tr>
<tr><td><code id="mv.2way.est_+3A_stand">stand</code></td>
<td>
<p>the standardization method used. Possible choices
are <code>outer</code> and <code>inner</code>.</p>
</td></tr>
<tr><td><code id="mv.2way.est_+3A_eps">eps</code></td>
<td>
<p>convergence criterion.</p>
</td></tr>
<tr><td><code id="mv.2way.est_+3A_n.iter">n.iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mv.2way.est_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain 'NA's. Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the treatment effect estimates described in
chapter 12 of the MNM book.</p>


<h3>Value</h3>

<p>A list of length c(c-1)/2 with class 'mvcloc' where c is the number of
treatments. Each component of the list is a list with class 'mvloc'
containing the following components:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>the adjusted treatment effect estimate when comparing the
treatment pair given in <code>dname</code>.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the asymptotic covariance matrix of the adjusted treatment effect estimate.</p>
</td></tr>
<tr><td><code>est.name</code></td>
<td>
<p>name of the adjusted treatment effect estimate.</p>
</td></tr>
<tr><td><code>dname</code></td>
<td>
<p>the treatment pair for which the adjusted treatment effect estimate was computed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jyrki Mottonen <a href="mailto:jyrki.mottonen@helsinki.fi">jyrki.mottonen@helsinki.fi</a></p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> </p>


<h3>See Also</h3>

<p><code><a href="#topic+mv.2way.test">mv.2way.test</a></code>, <code><a href="#topic+mv.1sample.est">mv.1sample.est</a></code>, <code><a href="#topic+mv.2sample.est">mv.2sample.est</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beans)
est&lt;-mv.2way.est(beans[,3:5],beans$Block,beans$Treatment,score="r",stand="i")
summary(est)
</code></pre>

<hr>
<h2 id='mv.2way.test'>Randomized Complete Block Design.</h2><span id='topic+mv.2way.test'></span>

<h3>Description</h3>

<p>Multivariate tests for testing the null hypothesis that there is no treatment effect in a randomized complete block design
using different scores.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.2way.test(x, block, treatment, score = c("identity", "sign", 
             "rank"), stand = c("outer", "inner"), 
             method = c("approximation", "permutation"),
             n.simu = 1000, eps=1.0e-10, n.iter=10000, 
             na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.2way.test_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix of response variables.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_block">block</code></td>
<td>
<p>a factor with at least two levels.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_treatment">treatment</code></td>
<td>
<p>a factor with at least two levels.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_score">score</code></td>
<td>
<p>the score to be used. Possible choices are
<code>identity</code>, <code>sign</code> and <code>rank</code>.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_stand">stand</code></td>
<td>
<p>the standardization method used. Possible choices are
<code>outer</code> and <code>inner</code>.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_method">method</code></td>
<td>
<p>method for the computation of the p-value for the
spatial sign and spatial rank tests. Possible choices are
<code>approximation</code> and <code>permutation</code>.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_n.simu">n.simu</code></td>
<td>
<p>number of simulated permutations if <code>method="permutation"</code>.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_eps">eps</code></td>
<td>
<p>convergence criterion.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_n.iter">n.iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mv.2way.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain 'NA's. Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the tests described in chapter 12 of the MNM book.</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the test statistic or the
number of replications in the simulation.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified null hypothesis value of the location.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data set
and of the grouping vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jyrki Mottonen <a href="mailto:jyrki.mottonen@helsinki.fi">jyrki.mottonen@helsinki.fi</a></p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> </p>


<h3>See Also</h3>

<p><code><a href="#topic+mv.1sample.test">mv.1sample.test</a></code>, <code><a href="#topic+mv.Csample.test">mv.Csample.test</a></code> ,  <code><a href="#topic+mv.2way.est">mv.2way.est</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
blocks &lt;- gl(10, 5)
treatments &lt;- factor(rep(1:5, 10))
X &lt;- rmvnorm(n = 50, mean = c(1,2,3), sigma = diag(3))
mv.2way.test(X, blocks, treatments, score="r", stand="i", method="a")
</code></pre>

<hr>
<h2 id='mv.Csample.test'>C Sample Test of Location </h2><span id='topic+mv.Csample.test'></span>

<h3>Description</h3>

<p>Several samples location tests using different scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.Csample.test(X, g, score = "identity", stand = "outer", 
                method = "approximation", n.simu = 1000, 
                na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.Csample.test_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix of response values. </p>
</td></tr>
<tr><td><code id="mv.Csample.test_+3A_g">g</code></td>
<td>
<p>a factor with at least two levels.</p>
</td></tr>
<tr><td><code id="mv.Csample.test_+3A_score">score</code></td>
<td>
<p>the score to be used. Possible choices are <code>identity</code>, <code>sign</code> and <code>rank</code>.</p>
</td></tr>
<tr><td><code id="mv.Csample.test_+3A_stand">stand</code></td>
<td>
<p> the standardization method used. Possible choices are <code>outer</code> and <code>inner</code>.</p>
</td></tr>
<tr><td><code id="mv.Csample.test_+3A_method">method</code></td>
<td>
<p>method for the computation of the p-value for the spatial sign and spatial signed-rank tests.
Possible choices are <code>approximation</code> and <code>permutation</code>.</p>
</td></tr>
<tr><td><code id="mv.Csample.test_+3A_n.simu">n.simu</code></td>
<td>
<p>number of simulated sign changes if  <code>method="permutation"</code>.</p>
</td></tr>
<tr><td><code id="mv.Csample.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's. Default is to fail. </p>
</td></tr> 
<tr><td><code id="mv.Csample.test_+3A_...">...</code></td>
<td>
<p>arguments that can be passed on to functions used for the estimation of the spatial signs and spatial ranks. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the location tests based on identity, sign or rank scores as described in chapter 11 of the MNM book.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the test statistic or the number of replications in the simulation.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the location.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data set and of the grouping vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> 
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite>
</p>


<h3>See Also</h3>

 <p><code><a href="ICSNP.html#topic+spatial.sign">spatial.sign</a></code>, <code><a href="SpatialNP.html#topic+spatial.rank">spatial.rank</a></code>, <code><a href="ICSNP.html#topic+HotellingsT2">HotellingsT2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvt(150,diag(1,3))
g1 &lt;- gl(3,50)
mv.Csample.test(X, g1)
mv.Csample.test(X, g1, score = "s")
mv.Csample.test(X, g1, score = "r")

Y &lt;- rbind(rmvnorm(40,c(0,0,0)), rmvnorm(60,c(0,0,0.4)))
g2 &lt;- factor(rep(1:2, c(40, 60)))
mv.Csample.test(Y, g2, score = "r")
mv.Csample.test(Y, g2, score = "r", method="p")
</code></pre>

<hr>
<h2 id='mv.ind.test'>
Independence Test
</h2><span id='topic+mv.ind.test'></span>

<h3>Description</h3>

<p>Tests for independence of two vectors using different scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.ind.test(X, Y, score = "identity", method = "approximation", 
            n.simu = 1000, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.ind.test_+3A_x">X</code></td>
<td>

<p>a numeric data frame or matrix. Must have the same number of rows as <code>Y</code>.
</p>
</td></tr>
<tr><td><code id="mv.ind.test_+3A_y">Y</code></td>
<td>

<p>a numeric data frame or matrix. Must have the same number of rows as <code>X</code>.
</p>
</td></tr>
<tr><td><code id="mv.ind.test_+3A_score">score</code></td>
<td>

<p>the score to be used. Possible are <code>identity</code>, <code>sign</code>, <code>symm</code> and <code>rank</code>.
</p>
</td></tr>
<tr><td><code id="mv.ind.test_+3A_method">method</code></td>
<td>

<p>method for for computation of the p-value for the spatial sign and spatial signed-rank tests.
Possible are <code>approximation</code> and <code>permutation</code>.
</p>
</td></tr>
<tr><td><code id="mv.ind.test_+3A_n.simu">n.simu</code></td>
<td>

<p>number of permutations if  <code>method="permutation"</code>.
</p>
</td></tr>
<tr><td><code id="mv.ind.test_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data
contain 'NA's. Default is to fail. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the independence tests as described in chapter 10 of the MNM book. Note that only inner test versions are implemented and that for the symmetrized sign score only
the approximative method for the computation of the p-value is available. 
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the test statistic or the number of replications in the simulation.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified null hypothesis value.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the two data matrices.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> 
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvt(150,diag(1,3),df=3)
Y &lt;- rmvt(150, matrix(c(1,0.5,0.5,1),nrow=2),df=3)

mv.ind.test(X, Y)
mv.ind.test(X, Y, method = "p")

mv.ind.test(X, Y, score = "si")
mv.ind.test(X, Y, score = "si", method = "p")

mv.ind.test(X, Y, score = "r")
mv.ind.test(X, Y, score = "r", method = "p")

mv.ind.test(X, Y, score = "sy")
</code></pre>

<hr>
<h2 id='mv.l1lm'>
Linear Regression Based on Identity, Spatial Sign or Spatial Rank Scores
</h2><span id='topic+mv.l1lm'></span>

<h3>Description</h3>

<p>This function fits a multivariate linear regression model based on identity, spatial sign or spatial rank scores. Both inner and outer standardization are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.l1lm(formula, scores = "identity", stand = "outer", 
        maxiter = 1000, eps = 1e-06, eps.S = 1e-06, 
        x = TRUE, y = TRUE, data, subset, na.action)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.l1lm_+3A_formula">formula</code></td>
<td>

<p>an object of class &quot;formula&quot; (or one that can be coerced to
that class): a symbolic description of the model to be
fitted. The left part of the formula (the response) must be a  n x p matrix with at least two columns.
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_scores">scores</code></td>
<td>

<p>score to be used. Can be either <code>"identity"</code>, <code>"sign"</code> or <code>"rank"</code>.
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_stand">stand</code></td>
<td>

<p>can be <code>"outer"</code> or <code>"inner"</code>.
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_maxiter">maxiter</code></td>
<td>

<p>maximum number of iterations. Used only for <code>score = "sign"</code> and  <code>score = "rank"</code>.
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_eps">eps</code></td>
<td>

<p>convergence tolerance. Used only for <code>score = "sign"</code> or  <code>score = "rank"</code>.
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_eps.s">eps.S</code></td>
<td>

<p>lower limit for the residual norms. Used only for <code>score = "sign"</code>  or  <code>score = "rank"</code> in the iteration procedure to avoid to divide by a zero norm.
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_x">x</code></td>
<td>

<p>logical. Indicating whether the design matrix 'x' returned from the model matrix should be stored. Default is <code>TRUE</code>. Might be needed for example 
in the <code>anova</code> function.  
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_y">y</code></td>
<td>

<p>logical. Indicating whether the response matrix 'y' should be stored. Default is <code>TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object
coercible by 'as.data.frame' to a data frame) containing the
variables in the model.  If not found in 'data', the
variables are taken from 'environment(formula)', typically
the environment from which 'mv.l1lm' is called.
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="mv.l1lm_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data
contain 'NA's. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The theory behind this function is described in detail in Chapter 13 of the MNM book. 
</p>
<p>For regular multivariate L2-regression the function <code><a href="stats.html#topic+lm">lm</a></code> might be more efficient and offers more methods. Note however that
the results given by <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="#topic+mv.l1lm">mv.l1lm</a></code> may differ slightly due to different divisors of the covariance matrix.
</p>
<p>The algorithms for the sign and rank scores are still in an early phase and therefore any feedback is very welcome. 
For example if p+1 residuals are 0, then the algorithms may not return correct values. Note also that the computations for rank scores 
might be slow. 
</p>
<p>Rank regression does not provide an estimate for the intercept parameter is not considered a parameter, a Hodges-Lehmann estimator of the residuals is then an estimate when an interecept term is in the formula.
For the one sample case however the function cannot be used for rank scores. We recommend that the regression function should not be used for the one or two sample case. There are
distinct functions designed for that purpose. Note furthermore that in the two sample case the covariance matrix returned from the regression function differs
slightly from the one returned by the function <code><a href="#topic+mv.2sample.est">mv.2sample.est</a></code> since there matrix A is computed in a different way. 
</p>
<p>In general it is recommended to use the <code>data</code> argument and specify there the data frame that contains the variables and matrices. For having a matrix Y in a data frame 
for example the following methods work:
</p>

<dl>
<dt>a)</dt><dd>
<p><code>MyData &lt;- data.frame(I(Y),...)</code>
</p>
<p>or
</p>
</dd>
<dt>b)</dt><dd>
<p><code>MyData &lt;- data.frame(...)</code> <br />
<code>MyData$Y &lt;- Y</code>
</p>
</dd></dl>

<p>Otherwise also the function <code><a href="base.html#topic+cbind">cbind</a></code> can be used on the left side of the formula to combine numeric vectors on the fly.
</p>


<h3>Value</h3>

<p><code>mv.l1ml</code> returns an object of 'class' <code>mvl1lm</code>.
</p>
<p>The functions <code>summary</code> is the best choice to view the results.  The
generic accessor functions <code>coefficients</code>, <code>fitted</code>, <code>residuals</code>
and <code>vcov</code> extract various useful features of
the value returned by <code>mv.l1ml</code>.
</p>
<p>An object of class <code>mv.l1ml</code> is a list wich contains different information depending on the scores and standardization used.
To see its content use the function <code><a href="utils.html#topic+str">str</a></code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer.</cite> 
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+mv.1sample.est">mv.1sample.est</a></code>, <code><a href="#topic+mv.1sample.test">mv.1sample.test</a></code>, <code><a href="#topic+mv.2sample.est">mv.2sample.est</a></code>, <code><a href="#topic+mv.Csample.test">mv.Csample.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating simple data

X &lt;- cbind(rep(1,100),rmvnorm(100,c(0,0,0)) )
B &lt;- matrix(c(4,1,1,0.5,-3,2,2,2),ncol=4, byrow=TRUE)
Y &lt;- X %*% t(B)+ rmvnorm(100,c(0,0), diag(0.2,2))
DAT &lt;- data.frame(x1=X[,2],x2=X[,3], x3=X[,4], Y=I(Y))

# true B
t(B)

# example using identity scores
test1 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, data=DAT)

print(test1)
summary(test1)
coef(test1)
vcov(test1)
head(fitted(test1))
head(residuals(test1))

# example using outer sign scores
test2 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "s", data=DAT)

print(test2)
summary(test2)
coef(test2)
vcov(test2)
head(fitted(test2))
head(residuals(test2))

# example using inner sign scores
test3 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "s", stand="i", 
data=DAT)

print(test3)
summary(test3)
coef(test3)
vcov(test3)
head(fitted(test3))
head(residuals(test3))

# example using outer rank scores
test4 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "r", stand="o", 
data=DAT)

print(test4)
summary(test4)
coef(test4)
vcov(test4)
head(fitted(test4))
head(residuals(test4))

# example using inner rank scores
test5 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "r", stand="i", 
data=DAT)

print(test5)
summary(test5)
coef(test5)
vcov(test5)
head(fitted(test5))
head(residuals(test5))

# prediction

newData &lt;- data.frame(x1=c(1,-2),x2=c(0.5,0.7), x3=c(-1,-1))
newData
predict(test1,newData)
predict(test2,newData)
predict(test3,newData)
predict(test4,newData)
predict(test5,newData)

</code></pre>

<hr>
<h2 id='mv.shape.est'>Shape Matrices </h2><span id='topic+mv.shape.est'></span>

<h3>Description</h3>

<p>Shape matrix estimates using different score functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.shape.est(X, score = "identity", estimate = "outer", 
             location = NULL, na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.shape.est_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. </p>
</td></tr>
<tr><td><code id="mv.shape.est_+3A_score">score</code></td>
<td>
<p>score to be used. Can be either <code>"identity"</code>, <code>"sign"</code>, <code>"symmsign"</code> or <code>"rank"</code>.</p>
</td></tr>
<tr><td><code id="mv.shape.est_+3A_estimate">estimate</code></td>
<td>
<p>can be <code>"outer"</code> or <code>"inner"</code>.</p>
</td></tr>
<tr><td><code id="mv.shape.est_+3A_location">location</code></td>
<td>
<p>If NULL the location vector is estimated. Alternatively a numeric p vector of location. </p>
</td></tr>
<tr><td><code id="mv.shape.est_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when
the data contain 'NA's. Default is to fail. </p>
</td></tr>
<tr><td><code id="mv.shape.est_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions returns different shape matrices depending on the score function chosen. For details see chapter 9 of the MNM book.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> 
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+cov">cov</a></code>, <code><a href="ICSNP.html#topic+tyler.shape">tyler.shape</a></code>, <code><a href="ICSNP.html#topic+duembgen.shape">duembgen.shape</a></code>, <code><a href="ICSNP.html#topic+HR.Mest">HR.Mest</a></code>, <code><a href="SpatialNP.html#topic+spatial.shape">spatial.shape</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
IRIS &lt;- iris[,1:4]
mv.shape.est(IRIS, "sign")
mv.shape.est(IRIS, "symmsign", "o")
mv.shape.est(IRIS, "rank")
</code></pre>

<hr>
<h2 id='mv.shape.test'> Test for Sphericity </h2><span id='topic+mv.shape.test'></span>

<h3>Description</h3>

<p>Test for sphericity based on different score functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv.shape.test(X, score = "identity", location = "est",
              na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv.shape.test_+3A_x">X</code></td>
<td>
<p> a numeric data frame or matrix.  </p>
</td></tr>
<tr><td><code id="mv.shape.test_+3A_score">score</code></td>
<td>
<p>the score to be used. Possible are <code>identity</code>, <code>sign</code>, and <code>symmsign</code>.</p>
</td></tr>
<tr><td><code id="mv.shape.test_+3A_location">location</code></td>
<td>
<p> specifies if the location should be estimated or taken to be the origin. Possible choices are <code>est</code> and <code>origin</code>.</p>
</td></tr>
<tr><td><code id="mv.shape.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's. Default is to fail.</p>
</td></tr>
<tr><td><code id="mv.shape.test_+3A_...">...</code></td>
<td>
<p> arguments  passed on to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that here inner standardization is not logical. The rank score test is not implemented. Otherwise the tests are as described in chapter
9 of the MNM book. 
</p>
<p>To test for other &quot;shapes&quot; than sperical, transform the data accordingly and then test for spericity.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the test statistic or the number of replications in the simulation.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite>
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="SpatialNP.html#topic+sr.sphere.test">sr.sphere.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvt(150,diag(1,3))
mv.shape.test(X)
mv.shape.test(X,"sym")
</code></pre>

<hr>
<h2 id='mvPCA'> Principal Component Analysis </h2><span id='topic+mvPCA'></span>

<h3>Description</h3>

<p>Principal component analysis based on different score functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvPCA(X, score = "identity", estimate = "outer", 
      na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvPCA_+3A_x">X</code></td>
<td>
<p> a numeric data frame or matrix with p columns. </p>
</td></tr>
<tr><td><code id="mvPCA_+3A_score">score</code></td>
<td>
<p>score to be used. Can be either <code>"identity"</code>, <code>"sign"</code>, <code>"symmsign"</code> or <code>"rank"</code>.</p>
</td></tr>
<tr><td><code id="mvPCA_+3A_estimate">estimate</code></td>
<td>
<p>can be <code>"outer"</code> or <code>"inner"</code>.</p>
</td></tr>
<tr><td><code id="mvPCA_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when
the data contain 'NA's. Default is to fail. </p>
</td></tr>
<tr><td><code id="mvPCA_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>PCA as descriped in chapter 9 of the MNM book. Note that here ALL scatter matrices used are standardized to have trace(p).
This function differs from most other PCA functions in R in that it does not center the data. The 'mvPCA' class has a print, summary, plot and predict
method. 
</p>


<h3>Value</h3>

<p>A list with class 'mvloc' containing the following components:
</p>
<table>
<tr><td><code>EigenV</code></td>
<td>
<p>the standardized eigenvalues.</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>matrix with the corresponding loadings.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>matrix with the principal components.</p>
</td></tr>
<tr><td><code>dname</code></td>
<td>
<p>name of X.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Which shape matrix was used for the computation.</p>
</td></tr>
<tr><td><code>n.obs</code></td>
<td>
<p>number of observations used.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>number of variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+princomp">princomp</a></code>, <code><a href="stats.html#topic+prcomp">prcomp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
IRIS &lt;- iris[,1:4]
iris.pca &lt;- mvPCA(IRIS, "sign", "i")
iris.pca
summary(iris.pca)
pairs(iris.pca$scores, col=iris[,5])
</code></pre>

<hr>
<h2 id='pairs2'>
Plotting two numeric matrices
</h2><span id='topic+pairs2'></span>

<h3>Description</h3>

<p>The function plots each variable contained in the matrix 'x' against the all variables contained in matrix 'y'. The function is not very sophisticated and 
only used to consider the residuals in a multivariate regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs2(x, y, mars = c(4, 4, 0.1, 0.1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs2_+3A_x">x</code></td>
<td>

<p>a numeric matrix. Same number or rows as <code>y</code>.
</p>
</td></tr>
<tr><td><code id="pairs2_+3A_y">y</code></td>
<td>

<p>a numeric matrix. Same number or rows as <code>x</code>.
</p>
</td></tr>
<tr><td><code id="pairs2_+3A_mars">mars</code></td>
<td>

<p>A numerical vector of the form 'c(bottom, left, top, right)'
which gives the number of lines of margin to be specified on
the four sides of the plot. The default is <code>c(4, 4, 0.1, 0.1)</code>.
</p>
</td></tr>
<tr><td><code id="pairs2_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods, such as graphical
parameters (see <code><a href="graphics.html#topic+par">par</a></code>). Should not contain <code>xlab</code> and <code>ylab</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvnorm(50, c(0,0,1))
Y &lt;- rmvnorm(50, c(20,1), matrix(rep(0.5,4),ncol=2))
colnames(X) &lt;- LETTERS[1:3]
colnames(Y) &lt;- letters[1:2]
pairs2(X,Y)
</code></pre>

<hr>
<h2 id='plot.mvl1lm'>
Residual Plot for an mvl1lm Object 
</h2><span id='topic+plot.mvl1lm'></span>

<h3>Description</h3>

<p>Scatterplots of fitted vs. residual values of the response variable for an mvl1lm object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
plot(x, captation = "Residuals vs fitted", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mvl1lm_+3A_x">x</code></td>
<td>

<p>an object of class <code>mvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="plot.mvl1lm_+3A_captation">captation</code></td>
<td>

<p>captation of the figure.
</p>
</td></tr>
<tr><td><code id="plot.mvl1lm_+3A_...">...</code></td>
<td>

<p>optional plotting arguments.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='plot.mvloc'>
Plotting Method for mvloc Objects
</h2><span id='topic+plot.mvloc'></span>

<h3>Description</h3>

<p>Visually presents and compares different multivariate location estimates and their confidence ellipsoids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvloc'
plot(x, est2 = NULL, est3 = NULL, X = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mvloc_+3A_x">x</code></td>
<td>
<p>an object of class <code>mvl1lm</code>.</p>
</td></tr>
<tr><td><code id="plot.mvloc_+3A_est2">est2</code></td>
<td>
<p>An optional additional location estimate. A list with the components <code>location</code>, <code>vcov</code> and <code>est.name</code>, for example an object of class 'mvloc'.</p>
</td></tr>
<tr><td><code id="plot.mvloc_+3A_est3">est3</code></td>
<td>
<p>An optional additional location estimate. A list with the components <code>location</code>, <code>vcov</code> and <code>est.name</code>, for example an object of class 'mvloc'.</p>
</td></tr>
<tr><td><code id="plot.mvloc_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. Optional data points on which the estimates could have been based.</p>
</td></tr>
<tr><td><code id="plot.mvloc_+3A_...">...</code></td>
<td>
<p>optional plotting arguments. For details see <code><a href="#topic+plotMvloc">plotMvloc</a> </code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The figure can be used to compare different multivariate location estimates. The location of the legend is currently problematic and it is
recommended that the user should provide the coordinates for the legend. The function calls <code><a href="#topic+plotMvloc">plotMvloc</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotMvloc">plotMvloc</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvt(50, diag(c(1, 2)), 3)

est1 &lt;- mv.1sample.est(X)
est2 &lt;- mv.1sample.est(X, "sign")
est3 &lt;- mv.1sample.est(X, "rank", "inner")

plot(est1)
plot(est1, est2, est3, X, alim="b", lty.ell=1:3, pch.ell=14:16)
plot(est1, est2, est3, X, alim="e")
</code></pre>

<hr>
<h2 id='plotMvloc'> Function to Plot Multivariate Location Estimates and Their Confidence Ellipsoids. </h2><span id='topic+plotMvloc'></span>

<h3>Description</h3>

<p>Visually presents and compares different multivariate location estimates and their confidence ellipsoids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMvloc(est1, est2 = NULL, est3 = NULL, X = NULL, alim = NULL, 
          color.ell = 2:4, color.points = grey(0.5), 
          lty.ell = rep(1, 3), pch.ell = rep(16, 3), 
          lwd.ell = rep(1, 3), cex.ell = rep(1, 3), 
          pch.points = 1, level = 0.95, npoints = 100, 
          x.legend, y.legend, cex.legend = 1, pty = "s", gap = 1, 
          oma.bottom, labels, cex.labels = 2, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMvloc_+3A_est1">est1</code></td>
<td>
<p>The location of interest. A list with the components <code>location</code>, <code>vcov</code> and <code>est.name</code>, for example an object of class 'mvloc'.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_est2">est2</code></td>
<td>
<p>An optional additional location estimate. A list with the components <code>location</code>, <code>vcov</code> and <code>est.name</code>, for example an object of class 'mvloc'.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_est3">est3</code></td>
<td>
<p>An optional additional location estimate. A list with the components <code>location</code>, <code>vcov</code> and <code>est.name</code>, for example an object of class 'mvloc'.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. Optional data points on which the estimates could have been based.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_alim">alim</code></td>
<td>
<p>can be <code>NULL</code>, <code>both</code> or <code>ellipses</code>. Specifies whether the plotting regions are are based on the confidence ellipsoids only or also the range of the data points.
If <code>NULL</code> it chooses <code>both</code> if <code>X</code> is provided and otherwise <code>ellipses</code>.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_color.ell">color.ell</code></td>
<td>
<p>vector of length 3 that gives the colors for the corresponding estimates <code>'est1'</code>, <code>'est2'</code> and <code>'est3'</code>.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_color.points">color.points</code></td>
<td>
<p>the color of the data points. </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_lty.ell">lty.ell</code></td>
<td>
<p>line types of the confidence ellipsoids.  </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_pch.ell">pch.ell</code></td>
<td>
<p>plotting symbols for the location estimates, the centers of the confidence ellipsoids. </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_lwd.ell">lwd.ell</code></td>
<td>
<p>line width values of the confidence ellipsoids. </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_cex.ell">cex.ell</code></td>
<td>
<p>cex values for the location estimates, the centers of the confidence ellipsoids. </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_pch.points">pch.points</code></td>
<td>
<p>plotting symbol for the data points <code>X</code>.  </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_level">level</code></td>
<td>
<p> the level of the confidence ellipsoids.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_npoints">npoints</code></td>
<td>
<p>the number of points used to approximate each ellipsoid.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_x.legend">x.legend</code></td>
<td>
<p>vertical position of the legend. By default tries to find for 2 to 4 dimensional data a good location. If <code>NULL</code> no legend is drawn.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_y.legend">y.legend</code></td>
<td>
<p>horicontal position of the legend. By default tries to find for 2 to 4 dimensional data a good location. If <code>NULL</code> no legend is drawn.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_cex.legend">cex.legend</code></td>
<td>
<p><code>cex</code> for the legend.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_pty">pty</code></td>
<td>
<p><code>pty</code> value for the individual plots of the scatter matrix. Default is <code>"s"</code>.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_gap">gap</code></td>
<td>
<p>distance between subplots, in margin lines.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_oma.bottom">oma.bottom</code></td>
<td>
<p><code>oma</code> value of the bottom.</p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_labels">labels</code></td>
<td>
<p>optional labels for the diagonals. </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_cex.labels">cex.labels</code></td>
<td>
<p><code>cex</code> for the labels. Default is 2. </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_main">main</code></td>
<td>
<p> optional title of the plot. </p>
</td></tr>
<tr><td><code id="plotMvloc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The figure can be used to compare different multivariate location estimates. The location of the legend is currently problematic and it is
recommended that the user should provide the coordinates for the legend.
</p>


<h3>Value</h3>

<p>A scatterplot matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

 <p><code><a href="ellipse.html#topic+ellipse">ellipse</a></code>, <code><a href="#topic+plotShape">plotShape</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvt(50, diag(c(1, 2)), 3)

est1 &lt;- mv.1sample.est(X)
est2 &lt;- mv.1sample.est(X, "sign")
est3 &lt;- mv.1sample.est(X, "rank", "inner")

plotMvloc(est1)
plotMvloc(est1, est2, est3, X, alim="b", lty.ell=1:3, pch.ell=14:16)
plotMvloc(est1, est2, est3, X, alim="e")
</code></pre>

<hr>
<h2 id='plotShape'> Pairwise Scatterplot Matrix of Shape Matrices</h2><span id='topic+plotShape'></span>

<h3>Description</h3>

<p>Function for visual comparisons for up to three shape matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotShape(est1, est2 = NULL, est3 = NULL, X = NULL, alim = NULL, 
          color.ell = 2:4, color.points = grey(0.5), 
          lty.ell = rep(1, 3), pch.ell = rep(16, 3), 
          lwd.ell = rep(1, 3), cex.ell = rep(1, 3),  
          pch.points = 1, level = 0.5, npoints = 100, 
          x.legend, y.legend, cex.legend = 1, pty = "s", gap = 1, 
          oma.bottom, labels, cex.labels = 2, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotShape_+3A_est1">est1</code></td>
<td>
<p>The shape matrix of interest. A list with the components <code>location</code>, <code>scatter</code> and <code>est.name</code>.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_est2">est2</code></td>
<td>
<p>An optional additional shape matrix. A list with the components <code>location</code>, <code>scatter</code> and <code>est.name</code>.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_est3">est3</code></td>
<td>
<p>An optional additional shape matrix. A list with the components <code>location</code>, <code>scatter</code> and <code>est.name</code>.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. Optional data points on which the estimates could have been based.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_alim">alim</code></td>
<td>
<p>can be <code>NULL</code>, <code>both</code> or <code>ellipses</code>. Specifies when the plotting regions are computed if only the size of the ellipses are to be considered 
or also the range of the data points.
If <code>NULL</code> it chooses <code>both</code> if <code>X</code> is provided and otherwise <code>ellipses</code>.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_color.ell">color.ell</code></td>
<td>
<p>vector of length 3 that gives the colors for the corresponding estimates <code>'est1'</code>, <code>'est2'</code> and <code>'est3'</code>.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_color.points">color.points</code></td>
<td>
<p>the color of the data points. </p>
</td></tr>
<tr><td><code id="plotShape_+3A_lty.ell">lty.ell</code></td>
<td>
<p>line types of the confidence ellipsoids.  </p>
</td></tr>
<tr><td><code id="plotShape_+3A_pch.ell">pch.ell</code></td>
<td>
<p>plotting symbols for the location estimates, the centers of the confidence ellipsoids. </p>
</td></tr>
<tr><td><code id="plotShape_+3A_lwd.ell">lwd.ell</code></td>
<td>
<p>line width values of the confidence ellipsoids. </p>
</td></tr>
<tr><td><code id="plotShape_+3A_cex.ell">cex.ell</code></td>
<td>
<p>cex values for the location estimates, the centers of the confidence ellipsoids. </p>
</td></tr>
<tr><td><code id="plotShape_+3A_pch.points">pch.points</code></td>
<td>
<p>plotting symbol for the data points <code>X</code>.  </p>
</td></tr>
<tr><td><code id="plotShape_+3A_level">level</code></td>
<td>
<p> The proportion of the data points that should be inside the ellipses. If there is no data the value for <code>t</code> in the function <code>ellipse</code>.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_npoints">npoints</code></td>
<td>
<p>the number of points used to approximate each ellipsoid.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_x.legend">x.legend</code></td>
<td>
<p>vertical position of the legend. By default tries to find for 2 to 4 dimensional data a good location. If <code>NULL</code> no legend is drawn.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_y.legend">y.legend</code></td>
<td>
<p>horicontal position of the legend. By default tries to find for 2 to 4 dimensional data a good location. If <code>NULL</code> no legend is drawn.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_cex.legend">cex.legend</code></td>
<td>
<p><code>cex</code> for the legend.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_pty">pty</code></td>
<td>
<p><code>pty</code> value for the individual plots of the scatter matrix. Default is <code>"s"</code>.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_gap">gap</code></td>
<td>
<p>distance between subplots, in margin lines.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_oma.bottom">oma.bottom</code></td>
<td>
<p><code>oma</code> value of the bottom.</p>
</td></tr>
<tr><td><code id="plotShape_+3A_labels">labels</code></td>
<td>
<p>optional labels for the diagonals. </p>
</td></tr>
<tr><td><code id="plotShape_+3A_cex.labels">cex.labels</code></td>
<td>
<p><code>cex</code> for the labels. Default is 2. </p>
</td></tr>
<tr><td><code id="plotShape_+3A_main">main</code></td>
<td>
<p> optional title of the plot. </p>
</td></tr>
<tr><td><code id="plotShape_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All scatter matrices are standardized to have determinant 1. If <code>X</code> is given, the Mahalanobis distances based on the location and shape estimates are computed, and <code>t</code>
in the function <code><a href="ellipse.html#topic+ellipse">ellipse</a> </code> is the level quantile of the Mahalanobis distances. If no <code>X</code> is provided <code>t</code> equals <code>level</code>.
</p>
<p>The location of the legend is currently problematic and it is
recommended that the user should provide the coordinates for the legend.
</p>


<h3>Value</h3>

<p>A scatter plot matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

 <p><code><a href="ellipse.html#topic+ellipse">ellipse</a></code>,  <code><a href="#topic+plotMvloc">plotMvloc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvt(100, diag(3), df=3)

EST1 &lt;- list(location=colMeans(X), scatter=cov(X), est.name="COV")
HR &lt;- HR.Mest(X)
EST2 &lt;- list(location=HR$center, scatter=HR$scatter, est.name="Tyler")
plotShape(EST1,EST2, X=X)
</code></pre>

<hr>
<h2 id='predict.mvl1lm'>
Predicted Values Based on a Model Fitted by mv.l1lm 
</h2><span id='topic+predict.mvl1lm'></span>

<h3>Description</h3>

<p>Predicted response values based on a model fitted by <code>mv.l1lm</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
predict(object, newdata, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mvl1lm_+3A_object">object</code></td>
<td>

<p>an object of class <code>mvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="predict.mvl1lm_+3A_newdata">newdata</code></td>
<td>

<p>An optional data frame with the values of the explaining variables.  If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.mvl1lm_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values
in 'newdata'.
</p>
</td></tr>
<tr><td><code id="predict.mvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='predict.mvPCA'> Prediction Method for a Principal Component Object of Type mvPCA</h2><span id='topic+predict.mvPCA'></span>

<h3>Description</h3>

<p>Prediction method for class mvPCA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvPCA'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mvPCA_+3A_object">object</code></td>
<td>
<p>an object of class <code>mvloc</code>. </p>
</td></tr>
<tr><td><code id="predict.mvPCA_+3A_newdata">newdata</code></td>
<td>
<p> New data with the same variables. If missing just the scores of object are returned.</p>
</td></tr>
<tr><td><code id="predict.mvPCA_+3A_...">...</code></td>
<td>
<p> needed for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the predicted principal components.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='print.anovamvl1lm'>
Printing an Object of Class anovamvl1lm
</h2><span id='topic+print.anovamvl1lm'></span>

<h3>Description</h3>

<p>Printing an object of class 'anovamvl1lm'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anovamvl1lm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.anovamvl1lm_+3A_x">x</code></td>
<td>

<p>an object of class <code>anovamvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="print.anovamvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='print.mvcloc'>Printing an 'mvcloc' Object </h2><span id='topic+print.mvcloc'></span>

<h3>Description</h3>

<p>Printing an mvcloc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvcloc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mvcloc_+3A_x">x</code></td>
<td>
<p>an object of class <code>mvcloc</code>.</p>
</td></tr>
<tr><td><code id="print.mvcloc_+3A_...">...</code></td>
<td>
<p>arguments that can be passed further on.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jyrki Mottonen <a href="mailto:jyrki.mottonen@helsinki.fi">jyrki.mottonen@helsinki.fi</a></p>

<hr>
<h2 id='print.mvl1lm'>
Printing an mvl1lm Object 
</h2><span id='topic+print.mvl1lm'></span>

<h3>Description</h3>

<p>Printing of an mvl1lm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mvl1lm_+3A_x">x</code></td>
<td>

<p>an object of class <code>mvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="print.mvl1lm_+3A_digits">digits</code></td>
<td>

<p>minimal number of _significant_ digits.
</p>
</td></tr>
<tr><td><code id="print.mvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='print.mvloc'>Printing an 'mvloc' Object </h2><span id='topic+print.mvloc'></span>

<h3>Description</h3>

<p>Printing an mvloc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvloc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mvloc_+3A_x">x</code></td>
<td>
<p>an object of class <code>mvloc</code>.</p>
</td></tr>
<tr><td><code id="print.mvloc_+3A_...">...</code></td>
<td>
<p>arguments that can be passed further on.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='print.mvPCA'> Printing Method for a Principal Component Object of Type mvPCA</h2><span id='topic+print.mvPCA'></span>

<h3>Description</h3>

<p>Prints an object of class mvPCA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvPCA'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mvPCA_+3A_x">x</code></td>
<td>
<p>object of type 'mvPCA' </p>
</td></tr>
<tr><td><code id="print.mvPCA_+3A_...">...</code></td>
<td>
<p> needed for other printing methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='residuals.mvl1lm'>
Residuals of an mvl1lm Object
</h2><span id='topic+residuals.mvl1lm'></span>

<h3>Description</h3>

<p>Extracts the residuals of an mvl1lm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mvl1lm_+3A_object">object</code></td>
<td>

<p>an object of class <code>mvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="residuals.mvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='rmvpowerexp'>Random Samples From a Power Exponential Distributions </h2><span id='topic+rmvpowerexp'></span>

<h3>Description</h3>

<p>Function to obtain random samples from a multivariate power exponential distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvpowerexp(n, Location = rep(0, nrow(Scatter)), 
            Scatter = diag(length(Location)), Beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvpowerexp_+3A_n">n</code></td>
<td>
<p>number of random samples. </p>
</td></tr>
<tr><td><code id="rmvpowerexp_+3A_location">Location</code></td>
<td>
<p>Location vector of the  distribution.</p>
</td></tr>
<tr><td><code id="rmvpowerexp_+3A_scatter">Scatter</code></td>
<td>
<p>Scatter matrix of the distribution.</p>
</td></tr>
<tr><td><code id="rmvpowerexp_+3A_beta">Beta</code></td>
<td>
<p> shape parameter of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power exponential distribution is an elliptical distribution which can have light or heavy tails.
<code>Beta = 1</code> yields a multivariate normal distribution, <code>Beta = 0.5</code> the multivariate Laplace distribution and
with increasing <code>Beta</code> converges to a multivariate uniform distribution.
</p>


<h3>Value</h3>

<p>a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> </p>


<h3>See Also</h3>

 <p><code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>, <code><a href="mvtnorm.html#topic+rmvt">rmvt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- rmvpowerexp(100,c(0,0,0),Beta = 0.5)
pairs(X1)
X2 &lt;- rmvpowerexp(100,c(0,0,0),Beta = 1)
pairs(X2)
X3 &lt;- rmvpowerexp(100,c(0,0,0),Beta = 10)
pairs(X3)
</code></pre>

<hr>
<h2 id='runifsphere'>Random Samples From the Unit Sphere</h2><span id='topic+runifsphere'></span>

<h3>Description</h3>

<p>Function to sample uniformly distributed observations on the unit sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifsphere(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifsphere_+3A_n">n</code></td>
<td>
<p> number of random samples.</p>
</td></tr>
<tr><td><code id="runifsphere_+3A_p">p</code></td>
<td>
<p> dimension of the unit sphere. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> </p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- runifsphere(100,2)
plot(X, pty = "s")
</code></pre>

<hr>
<h2 id='screeplot.mvPCA'> Plotting Method for a Principal Component Object of Type mvPCA </h2><span id='topic+plot.mvPCA'></span><span id='topic+screeplot.mvPCA'></span>

<h3>Description</h3>

<p>Creates a screeplot for an object of class mvPCA. Works analogously to a normal screeplot for a classical principal component analysis.
Here however the y-axis gives the proportion of the variation explained by the components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvPCA'
plot(x, main = deparse(substitute(x)), ...)
## S3 method for class 'mvPCA'
screeplot(x, npcs = min(10, length(x$EigenV)), 
          type = c("barplot", "lines"), 
          main = deparse(substitute(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screeplot.mvPCA_+3A_x">x</code></td>
<td>
<p> an object to type <code>mvPCA</code>. </p>
</td></tr>
<tr><td><code id="screeplot.mvPCA_+3A_npcs">npcs</code></td>
<td>
<p> the number of components to be plotted. </p>
</td></tr>
<tr><td><code id="screeplot.mvPCA_+3A_type">type</code></td>
<td>
<p> the type of plot. </p>
</td></tr>
<tr><td><code id="screeplot.mvPCA_+3A_main">main</code></td>
<td>
<p> title of the plot. </p>
</td></tr>
<tr><td><code id="screeplot.mvPCA_+3A_...">...</code></td>
<td>
<p> other graphical parameters passed to or from other methods. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A screeplot.
</p>


<h3>Author(s)</h3>

<p> Klaus Nordhausen</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mvPCA">mvPCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IRIS)
IRIS &lt;- iris[,1:4]
iris.pca &lt;- mvPCA(IRIS, "sign", "i")
plot(iris.pca, type="lines")
</code></pre>

<hr>
<h2 id='spatial.sign2'>
Spatial Signs
</h2><span id='topic+spatial.sign2'></span>

<h3>Description</h3>

<p>The function computes the spatial signs for a data set. This function differs from the function <code><a href="ICSNP.html#topic+spatial.sign">spatial.sign</a></code> in the way
how observations with small norms are treated. For details see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.sign2(X, center = TRUE, shape = TRUE, eps.S = 1e-05, 
              na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial.sign2_+3A_x">X</code></td>
<td>

<p>a numeric data frame or matrix.
</p>
</td></tr>
<tr><td><code id="spatial.sign2_+3A_center">center</code></td>
<td>

<p>either a logical value or a numeric vector of length equal to
the number of columns of 'X'. See below for more information. 
</p>
</td></tr>
<tr><td><code id="spatial.sign2_+3A_shape">shape</code></td>
<td>

<p>either a logical value or a square numeric matrix with number of columns equal to
the number of columns of 'X'. See below for more information.
</p>
</td></tr>
<tr><td><code id="spatial.sign2_+3A_eps.s">eps.S</code></td>
<td>

<p>treshold value which defines which obersvations are considered to have a small norm.
</p>
</td></tr>
<tr><td><code id="spatial.sign2_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.
</p>
</td></tr>
<tr><td><code id="spatial.sign2_+3A_...">...</code></td>
<td>

<p>arguments that can be passed on to functions used for the estimation of location
and shape.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial signs U of X with location <code class="reqn">\mu</code> and shape V are given by transforming the data points
<code class="reqn">z_i = (x_{i}-\mu)V^{-\frac{1}{2}}</code> and then computing
</p>
<p style="text-align: center;"><code class="reqn">u_{i}=\frac{z_i}{\| z_i \|}.</code>
</p>
 
<p>If a numeric value is given as 'center' and/or 'shape' these are used as <code class="reqn">\mu</code> and/or V in the above formula. 
If 'center' and/or 'shape' are 'TRUE' the values for <code class="reqn">\mu</code> and/or V are estimated, if 'FALSE' the origin is used as the 
value of <code class="reqn">\mu</code> and/or the identity matrix as the value of V.
</p>
<p>When the norm <code class="reqn">\| z_i \|</code> is 0 then the spatial sign is set usually to 0 as for example in the function 
<code><a href="ICSNP.html#topic+spatial.sign">spatial.sign</a></code>. Here however if  the spatial designs are defined as 
</p>
<p style="text-align: center;"><code class="reqn">u_{i}=\frac{z_i}{\| z_i \|} I(\| z_i \| &gt; eps.S) + \frac{z_i}{eps.S} I(\| z_i \| \leq eps.S).</code>
</p>



<h3>Value</h3>

<p>a matrix with the spatial signs of the data as rows or the univariate signs as a px1 matrix. The
centering vector and scaling matrix used are returned as attributes
'center' and 'shape'.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="ICSNP.html#topic+spatial.sign">spatial.sign</a></code>, <code><a href="ICSNP.html#topic+HR.Mest">HR.Mest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># comparing spatial.sign and spatial.sign2
data(pulmonary)
head(spatial.sign2(pulmonary, c(-0.1099999,-0.12,-4.3),FALSE))
head(spatial.sign(pulmonary, c(-0.1099999,-0.12,-4.3),FALSE))
</code></pre>

<hr>
<h2 id='summary.mvcloc'> Summarizing an 'mvcloc' Object </h2><span id='topic+summary.mvcloc'></span>

<h3>Description</h3>

<p>Summarizing an <code>'mvcloc'</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvcloc'
summary(object,..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mvcloc_+3A_object">object</code></td>
<td>
<p>an object of class <code>mvcloc</code>.</p>
</td></tr>
<tr><td><code id="summary.mvcloc_+3A_...">...</code></td>
<td>
<p>needed for other summary methods.</p>
</td></tr>
<tr><td><code id="summary.mvcloc_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jyrki Mottonen <a href="mailto:jyrki.mottonen@helsinki.fi">jyrki.mottonen@helsinki.fi</a></p>

<hr>
<h2 id='summary.mvl1lm'>
Summary for an mvl1lm Object 
</h2><span id='topic+summary.mvl1lm'></span>

<h3>Description</h3>

<p>Gives a detailed output for an object of class mvl1lm. Note that the output will differ for different score functions used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
summary(object, ..., digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mvl1lm_+3A_object">object</code></td>
<td>

<p>an object of class <code>mvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="summary.mvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
<tr><td><code id="summary.mvl1lm_+3A_digits">digits</code></td>
<td>

<p>minimal number of _significant_ digits.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='summary.mvloc'> Summarizing an 'mvloc' Object </h2><span id='topic+summary.mvloc'></span>

<h3>Description</h3>

<p>Summarizing an <code>'mvloc'</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvloc'
summary(object,..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mvloc_+3A_object">object</code></td>
<td>
<p>an object of class <code>mvloc</code>.</p>
</td></tr>
<tr><td><code id="summary.mvloc_+3A_...">...</code></td>
<td>
<p>needed for other summary methods.</p>
</td></tr>
<tr><td><code id="summary.mvloc_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>

<hr>
<h2 id='summary.mvPCA'>Summary for an object of class mvPCA.</h2><span id='topic+summary.mvPCA'></span><span id='topic+print.summary.mvPCA'></span>

<h3>Description</h3>

<p>Summary method for an object of class mvPCA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvPCA'
summary(object, loadings = FALSE, cutoff = 0.1, ...)

## S3 method for class 'summary.mvPCA'
print(x, digits = 3, loadings = x$print.loadings, 
               cutoff = x$cutoff, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mvPCA_+3A_object">object</code></td>
<td>
<p>an object to type <code>mvPCA</code>.</p>
</td></tr>
<tr><td><code id="summary.mvPCA_+3A_loadings">loadings</code></td>
<td>
<p>logical. Should the loadings be returned. </p>
</td></tr>
<tr><td><code id="summary.mvPCA_+3A_cutoff">cutoff</code></td>
<td>
<p> numeric. Loadings below this cutoff in absolute value are
shown as blank in the output. </p>
</td></tr>
<tr><td><code id="summary.mvPCA_+3A_x">x</code></td>
<td>
<p> an object of class &quot;summary.mvPCA&quot;. </p>
</td></tr>
<tr><td><code id="summary.mvPCA_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to be used in listing of
loadings. </p>
</td></tr>
<tr><td><code id="summary.mvPCA_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>'object' with additional components 'cutoff' and 'print.loadings'.
</p>


<h3>Author(s)</h3>

<p> Klaus Nordhausen</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mvPCA">mvPCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
IRIS &lt;- iris[,1:4]
iris.pca &lt;- mvPCA(IRIS, "sign", "i")
summary(iris.pca, loadings = TRUE)
</code></pre>

<hr>
<h2 id='vcov.mvl1lm'>
Variance-Covariance Matrix of an mvl1lm Object
</h2><span id='topic+vcov.mvl1lm'></span>

<h3>Description</h3>

<p>Extracts the variance-covariance matrix of an mvl1lm Object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvl1lm'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mvl1lm_+3A_object">object</code></td>
<td>

<p>an object of class <code>mvl1lm</code>.
</p>
</td></tr>
<tr><td><code id="vcov.mvl1lm_+3A_...">...</code></td>
<td>

<p>needed for other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see Chapter 13 of the MNM book. 
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer. </cite> 
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
