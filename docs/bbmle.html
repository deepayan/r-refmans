<!DOCTYPE html><html lang="en"><head><title>Help for package bbmle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bbmle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.profile.mle2'><p>convert profile to data frame</p></a></li>
<li><a href='#BIC-methods'><p>Log likelihoods and model selection for mle2 objects</p></a></li>
<li><a href='#call.to.char'><p>Convert calls to character</p></a></li>
<li><a href='#dnorm_n'>
<p>Normal distribution with profiled-out standard deviation</p></a></li>
<li><a href='#get.mnames'><p>extract model names</p></a></li>
<li><a href='#ICtab'><p>Compute table of information criteria and auxiliary info</p></a></li>
<li><a href='#mle2'><p>Maximum Likelihood Estimation</p></a></li>
<li><a href='#mle2-class'><p>Class &quot;mle2&quot;. Result of Maximum Likelihood Estimation.</p></a></li>
<li><a href='#mle2.options'><p>Options for maximum likelihood estimation</p></a></li>
<li><a href='#namedrop'><p>drop unneeded names from list elements</p></a></li>
<li><a href='#parnames'><p>get and set parameter names</p></a></li>
<li><a href='#pop_pred_samp'><p>generate population prediction sample from parameters</p></a></li>
<li><a href='#predict-methods'><p>Predicted values from an mle2 fit</p></a></li>
<li><a href='#profile-methods'><p>Likelihood profiles</p></a></li>
<li><a href='#profile.mle2-class'><p>Methods for likelihood profiles</p></a></li>
<li><a href='#relist2'><p>reconstruct the structure of a list</p></a></li>
<li><a href='#sbinom'><p>Abstract definitions of distributions</p></a></li>
<li><a href='#slice'><p>Calculate likelihood &quot;slices&quot;</p></a></li>
<li><a href='#slice.mle2-class'><p>likelihood-surface slices</p></a></li>
<li><a href='#strwrapx'><p>Wrap strings at white space and + symbols</p></a></li>
<li><a href='#summary.mle2-class'><p>Class &quot;summary.mle2&quot;, summary of &quot;mle2&quot; objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for General Maximum Likelihood Estimation</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods and functions for fitting maximum likelihood models in R. This package modifies and extends the 'mle' classes in the 'stats4' package.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.25.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats4</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, numDeriv, lattice, MASS, methods, bdsmatrix, Matrix,
mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>emdbook, rms, ggplot2, RUnit, MuMIn, AICcmodavg, Hmisc,
optimx (&ge; 2013.8.6), knitr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bbolker/bbmle">https://github.com/bbolker/bbmle</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'mle2-class.R' 'mle2-methods.R' 'mle.R' 'confint.R'
'predict.R' 'profile.R' 'update.R' 'dists.R' 'IC.R' 'slice.R'
'impsamp.R' 'TMB.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-08 23:45:52 UTC; bolker</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  R Development Core Team [aut],
  Iago Giné-Vázquez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Bolker &lt;bolker@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-09 01:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.profile.mle2'>convert profile to data frame</h2><span id='topic+as.data.frame.profile.mle2'></span><span id='topic+coerce+2Cprofile.mle2-method'></span><span id='topic+coerce+2Cprofile.mle2+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>converts a profile of a fitted mle2 object
to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile.mle2'
as.data.frame(x, row.names=NULL,
optional=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.profile.mle2_+3A_x">x</code></td>
<td>
<p>a profile object</p>
</td></tr>
<tr><td><code id="as.data.frame.profile.mle2_+3A_row.names">row.names</code></td>
<td>
<p>row names (unused)</p>
</td></tr>
<tr><td><code id="as.data.frame.profile.mle2_+3A_optional">optional</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="as.data.frame.profile.mle2_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with columns
</p>
<table role = "presentation">
<tr><td><code>param</code></td>
<td>
<p>name of parameter being profiled</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>signed square root of the deviance difference from the
minimum</p>
</td></tr>
<tr><td><code>parameter values</code></td>
<td>
<p>named par.vals.parname</p>
</td></tr>
<tr><td><code>focal</code></td>
<td>
<p>value of focal parameter: redundant, but included for
plotting convenience</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## use as.data.frame and lattice to plot profiles
  x &lt;- 0:10
  y &lt;- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
  library(bbmle)
  LL &lt;- function(ymax=15, xhalf=6) {
        -sum(stats::dpois(y, lambda=ymax/(1+x/xhalf), log=TRUE))
    }
  ## uses default parameters of LL
  fit1 &lt;- mle2(LL)
  p1 &lt;- profile(fit1)
  d1 &lt;- as.data.frame(p1)
  library(lattice)
  xyplot(abs(z)~focal|param,data=d1,
    subset=abs(z)&lt;3,
    type="b",
    xlab="",
    ylab=expression(paste(abs(z),
    " (square root of ",Delta," deviance)")),
    scale=list(x=list(relation="free")))
</code></pre>

<hr>
<h2 id='BIC-methods'>Log likelihoods and model selection for mle2 objects</h2><span id='topic+BIC-methods'></span><span id='topic+AIC-methods'></span><span id='topic+AICc-methods'></span><span id='topic+logLik-methods'></span><span id='topic+AICc'></span><span id='topic+AIC+2Cmle2-method'></span><span id='topic+AICc+2Cmle2-method'></span><span id='topic+AICc+2ClogLik-method'></span><span id='topic+AICc+2CANY-method'></span><span id='topic+AICc+2CANY+2Cmle2+2ClogLik-method'></span><span id='topic+qAICc'></span><span id='topic+qAICc-methods'></span><span id='topic+qAICc+2CANY-method'></span><span id='topic+qAICc+2Cmle2-method'></span><span id='topic+qAICc+2ClogLik-method'></span><span id='topic+qAIC'></span><span id='topic+qAIC-methods'></span><span id='topic+qAIC+2CANY-method'></span><span id='topic+qAIC+2Cmle2-method'></span><span id='topic+qAIC+2ClogLik-method'></span><span id='topic+qAIC+2CANY+2Cmle2+2ClogLik-method'></span><span id='topic+qAICc+2CANY+2Cmle2+2ClogLik-method'></span><span id='topic+logLik+2Cmle2-method'></span><span id='topic+anova+2Cmle2-method'></span>

<h3>Description</h3>

<p>Various functions for likelihood-based and information-theoretic
model selection of likelihood models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,mle2,logLik'
AICc(object,...,nobs,k=2)
## S4 method for signature 'ANY,mle2,logLik'
qAIC(object,...,k=2)
## S4 method for signature 'ANY,mle2,logLik'
qAICc(object,...,nobs,k=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BIC-methods_+3A_object">object</code></td>
<td>
<p>A <code>logLik</code> or <code>mle2</code> object</p>
</td></tr>
<tr><td><code id="BIC-methods_+3A_...">...</code></td>
<td>
<p>An optional list of additional <code>logLik</code>
or <code>mle2</code> objects (fitted to the same data set).</p>
</td></tr>
<tr><td><code id="BIC-methods_+3A_nobs">nobs</code></td>
<td>
<p>Number of observations (sometimes 
obtainable as an attribute of
the fit or of the log-likelihood)</p>
</td></tr>
<tr><td><code id="BIC-methods_+3A_k">k</code></td>
<td>
<p>penalty parameter (nearly always left at its default value of 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further arguments to <code>BIC</code> can be specified
in the <code>...</code> list: <code>delta</code> (logical)
specifies whether to include a column for delta-BIC
in the output.
</p>


<h3>Value</h3>

<p>A table of the BIC values, degrees of freedom,
and possibly delta-BIC values relative to the
minimum-BIC model
</p>


<h3>Methods</h3>


<dl>
<dt>logLik</dt><dd><p><code>signature(object = "mle2")</code>: Extract maximized
log-likelihood.</p>
</dd>
<dt>AIC</dt><dd><p><code>signature(object = "mle2")</code>: Calculate
Akaike Information Criterion</p>
</dd>
<dt>AICc</dt><dd><p><code>signature(object = "mle2")</code>: Calculate
small-sample corrected Akaike Information Criterion</p>
</dd>






<dt>anova</dt><dd><p><code>signature(object="mle2")</code>: Likelihood Ratio Test
comparision of different models</p>
</dd>
</dl>



<h3>Note</h3>

<p>This is implemented in an ugly way and could
probably be improved!</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- data.frame(x=0:10,y=c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8))
  (fit &lt;- mle2(y~dpois(lambda=ymax/(1+x/xhalf)),
      start=list(ymax=25,xhalf=3),data=d))
  (fit2 &lt;- mle2(y~dpois(lambda=(x+1)*slope),
      start=list(slope=1),data=d))
  BIC(fit)
  BIC(fit,fit2)
  </code></pre>

<hr>
<h2 id='call.to.char'>Convert calls to character</h2><span id='topic+call.to.char'></span>

<h3>Description</h3>

<p>Utility function (hack) to convert calls such
as y~x to their character equivalent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call.to.char(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call.to.char_+3A_x">x</code></td>
<td>
<p>a formula (call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It would be nice if <code>as.character(y~x)</code>
gave &quot;y~x&quot;, but it doesn't, so this hack achieves
the same goal
</p>


<h3>Value</h3>

<p>a character vector of length 1
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.character(y~x)
call.to.char(y~x)
</code></pre>

<hr>
<h2 id='dnorm_n'>
Normal distribution with profiled-out standard deviation
</h2><span id='topic+dnorm_n'></span>

<h3>Description</h3>

<p>Returns the Normal probability densities for a distribution
with the given mean values and the standard deviation equal
to the root mean-squared deviation between x and mu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnorm_n(x, mean, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dnorm_n_+3A_x">x</code></td>
<td>
<p>numeric vector of data</p>
</td></tr>
<tr><td><code id="dnorm_n_+3A_mean">mean</code></td>
<td>
<p>numeric vector or mean values</p>
</td></tr>
<tr><td><code id="dnorm_n_+3A_log">log</code></td>
<td>
<p>logical: return the log-density?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function, designed for the case
where you're trying to compute a MLE for the mean but
don't want to bother estimating the MLE for the standard
deviation at the same time
</p>


<h3>Value</h3>

<p>Numeric vector of probability densities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
x &lt;- rnorm(5,mean=3,sd=2)
dnorm_n(x,mean=3,log=TRUE)
</code></pre>

<hr>
<h2 id='get.mnames'>extract model names</h2><span id='topic+get.mnames'></span>

<h3>Description</h3>

<p>given a list of models, extract the names (or &quot;model n&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mnames(Call)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mnames_+3A_call">Call</code></td>
<td>
<p>a function call (usually a list of models)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of model names
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>

<hr>
<h2 id='ICtab'>Compute table of information criteria and auxiliary info</h2><span id='topic+ICtab'></span><span id='topic+AICtab'></span><span id='topic+BICtab'></span><span id='topic+AICctab'></span><span id='topic+print.ICtab'></span>

<h3>Description</h3>

<p>Computes information criteria for a series of models, optionally
giving information about weights, differences between ICs, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICtab(..., type=c("AIC","BIC","AICc","qAIC","qAICc"),
    weights = FALSE, delta = TRUE, base = FALSE,
logLik=FALSE, sort = TRUE,
nobs=NULL, dispersion = 1, mnames, k = 2)
AICtab(...,mnames)
BICtab(...,mnames)
AICctab(...,mnames)
## S3 method for class 'ICtab'
print(x,...,min.weight)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICtab_+3A_...">...</code></td>
<td>
<p>a list of (logLik or?) mle objects; in the case of
<code>AICtab</code> etc., could also include other arguments to <code>ICtab</code></p>
</td></tr>
<tr><td><code id="ICtab_+3A_type">type</code></td>
<td>
<p>specify information criterion to use</p>
</td></tr>
<tr><td><code id="ICtab_+3A_base">base</code></td>
<td>
<p>(logical) include base IC (and log-likelihood) values?</p>
</td></tr>
<tr><td><code id="ICtab_+3A_weights">weights</code></td>
<td>
<p>(logical) compute IC weights?</p>
</td></tr>
<tr><td><code id="ICtab_+3A_loglik">logLik</code></td>
<td>
<p>(logical) include log-likelihoods in the table?</p>
</td></tr>
<tr><td><code id="ICtab_+3A_delta">delta</code></td>
<td>
<p>(logical) compute differences among ICs (and log-likelihoods)?</p>
</td></tr>
<tr><td><code id="ICtab_+3A_sort">sort</code></td>
<td>
<p>(logical) sort ICs in increasing order?</p>
</td></tr>
<tr><td><code id="ICtab_+3A_nobs">nobs</code></td>
<td>
<p>(integer) number of observations: required for
<code>type="BIC"</code> or <code>type="AICc"</code> unless objects have
a <code><a href="stats.html#topic+nobs">nobs</a></code> method</p>
</td></tr>
<tr><td><code id="ICtab_+3A_dispersion">dispersion</code></td>
<td>
<p>overdispersion estimate, for computing qAIC:
required for <code>type="qAIC"</code> or <code>type="qAICc"</code> unless
objects have a <code>"dispersion"</code> attribute</p>
</td></tr>
<tr><td><code id="ICtab_+3A_mnames">mnames</code></td>
<td>
<p>names for table rows: defaults to names of objects passed</p>
</td></tr>
<tr><td><code id="ICtab_+3A_k">k</code></td>
<td>
<p>penalty term (largely unused: left at default of 2)</p>
</td></tr>
<tr><td><code id="ICtab_+3A_x">x</code></td>
<td>
<p>an ICtab object</p>
</td></tr>
<tr><td><code id="ICtab_+3A_min.weight">min.weight</code></td>
<td>
<p>minimum weight for exact reporting (smaller values
will be reported as &quot;&lt;[min.weight]&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing:
</p>
<table role = "presentation">
<tr><td><code>IC</code></td>
<td>
<p>information criterion</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom/number of parameters</p>
</td></tr>
<tr><td><code>dIC</code></td>
<td>
<p>difference in IC from minimum-IC model</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>exp(-dIC/2)/sum(exp(-dIC/2))</p>
</td></tr>
</table>


<h3>Note</h3>

<p>(1) The print method uses sensible defaults; all ICs are rounded
to the nearest 0.1, and IC weights are printed using
<code><a href="base.html#topic+format.pval">format.pval</a></code> to print an inequality for
values &lt;0.001. (2) The computation of degrees of freedom/number of
parameters (e.g., whether
variance parameters are included in the total) varies enormously
between packages.  As long as the df computations
for a given set of models is consistent, differences
don't matter, but one needs to be careful with log likelihoods
and models taken from different packages.  If necessary
one can change the degrees of freedom manually by
saying <code>attr(obj,"df") &lt;- df.new</code>, where <code>df.new</code>
is the desired number of parameters.
(3) Defaults have changed to <code>sort=TRUE</code>, <code>base=FALSE</code>,
<code>delta=TRUE</code>, to match my conviction that it rarely makes
sense to report the overall values of information criteria</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>References</h3>

<p>Burnham and Anderson 2002</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(101)
  d &lt;- data.frame(x=1:20,y=rpois(20,lambda=2))
  m0 &lt;- glm(y~1,data=d)
  m1 &lt;- update(m0,.~x)
  m2 &lt;- update(m0,.~poly(x,2))
  AICtab(m0,m1,m2,mnames=LETTERS[1:3])
  AICtab(m0,m1,m2,base=TRUE,logLik=TRUE)
  AICtab(m0,m1,m2,logLik=TRUE)
  AICctab(m0,m1,m2,weights=TRUE)
  print(AICctab(m0,m1,m2,weights=TRUE),min.weight=0.1)
</code></pre>

<hr>
<h2 id='mle2'>Maximum Likelihood Estimation</h2><span id='topic+mle2'></span><span id='topic+mle'></span><span id='topic+calc_mle2_function'></span>

<h3>Description</h3>

<p>Estimate parameters by the method of maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle2(minuslogl, start, method, optimizer,
    fixed = NULL, data=NULL,
    subset=NULL,
default.start=TRUE, eval.only = FALSE, vecpar=FALSE,
parameters=NULL,
parnames=NULL,
skip.hessian=FALSE,
hessian.opts=NULL,
use.ginv=TRUE,
trace=FALSE,
browse_obj=FALSE,
gr=NULL,
optimfun,
namedrop_args=TRUE,
...)
calc_mle2_function(formula,parameters, links, start,
   parnames, use.deriv=FALSE, data=NULL,trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle2_+3A_minuslogl">minuslogl</code></td>
<td>
<p>Function to calculate negative log-likelihood,
or a formula</p>
</td></tr>
<tr><td><code id="mle2_+3A_start">start</code></td>
<td>
<p>Named list. Initial values for optimizer</p>
</td></tr>
<tr><td><code id="mle2_+3A_method">method</code></td>
<td>
<p>Optimization method to use. See <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="mle2_+3A_optimizer">optimizer</code></td>
<td>
<p>Optimization function to use. Currently available
choices are &quot;optim&quot; (the default), &quot;nlm&quot;, &quot;nlminb&quot;, &quot;constrOptim&quot;,
&quot;optimx&quot;, and &quot;optimize&quot;. If &quot;optimx&quot; is used, (1) the <code>optimx</code>
package must be explicitly loaded with <code><a href="base.html#topic+load">load</a></code> or
<code><a href="base.html#topic+require">require</a></code>(<em>Warning:</em> Options other than the
default may be poorly tested, use with caution.)
</p>
</td></tr>
<tr><td><code id="mle2_+3A_fixed">fixed</code></td>
<td>
<p>Named list.  Parameter values to keep fixed during
optimization.</p>
</td></tr>
<tr><td><code id="mle2_+3A_data">data</code></td>
<td>
<p>list of data to pass to negative log-likelihood function: must
be specified if <code>minuslogl</code> is specified as a formula</p>
</td></tr>
<tr><td><code id="mle2_+3A_subset">subset</code></td>
<td>
<p>logical vector for subsetting data (STUB)</p>
</td></tr>
<tr><td><code id="mle2_+3A_default.start">default.start</code></td>
<td>
<p>Logical: allow default values of <code>minuslogl</code>
as starting values?</p>
</td></tr>
<tr><td><code id="mle2_+3A_eval.only">eval.only</code></td>
<td>
<p>Logical: return value of <code>minuslogl(start)</code>
rather than optimizing</p>
</td></tr>
<tr><td><code id="mle2_+3A_vecpar">vecpar</code></td>
<td>
<p>Logical: is first argument a vector of all parameters?
(For compatibility with <code><a href="stats.html#topic+optim">optim</a></code>.)
If <code>vecpar</code> is <code>TRUE</code>, then you should use
<code><a href="#topic+parnames">parnames</a></code> to define the parameter names for the
negative log-likelihood function.</p>
</td></tr>
<tr><td><code id="mle2_+3A_parameters">parameters</code></td>
<td>
<p>List of linear models for parameters.
<em>MUST BE SPECIFIED IN THE SAME ORDER as the start vector
(this is a bug/restriction that I hope to fix soon, but in
the meantime beware)</em></p>
</td></tr>
<tr><td><code id="mle2_+3A_links">links</code></td>
<td>
<p>(unimplemented) specify transformations of parameters</p>
</td></tr>
<tr><td><code id="mle2_+3A_parnames">parnames</code></td>
<td>
<p>List (or vector?) of parameter names</p>
</td></tr>
<tr><td><code id="mle2_+3A_gr">gr</code></td>
<td>
<p>gradient function</p>
</td></tr>
<tr><td><code id="mle2_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to optimizer</p>
</td></tr>
<tr><td><code id="mle2_+3A_formula">formula</code></td>
<td>
<p>a formula for the likelihood (see Details)</p>
</td></tr>
<tr><td><code id="mle2_+3A_trace">trace</code></td>
<td>
<p>Logical: print parameter values tested?</p>
</td></tr>
<tr><td><code id="mle2_+3A_browse_obj">browse_obj</code></td>
<td>
<p>Logical: drop into browser() within the objective function?</p>
</td></tr>
<tr><td><code id="mle2_+3A_skip.hessian">skip.hessian</code></td>
<td>
<p>Bypass Hessian calculation?</p>
</td></tr>
<tr><td><code id="mle2_+3A_hessian.opts">hessian.opts</code></td>
<td>
<p>Options for Hessian calculation, passed through to
the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function</p>
</td></tr>
<tr><td><code id="mle2_+3A_use.ginv">use.ginv</code></td>
<td>
<p>Use generalized inverse (<code><a href="MASS.html#topic+ginv">ginv</a></code>) to
compute approximate variance-covariance</p>
</td></tr>
<tr><td><code id="mle2_+3A_optimfun">optimfun</code></td>
<td>
<p>user-supplied optimization function. Must take exactly
the same arguments and return exactly the same structure as <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="mle2_+3A_use.deriv">use.deriv</code></td>
<td>
<p>(experimental, not yet implemented): construct symbolic
derivatives based on formula?</p>
</td></tr>
<tr><td><code id="mle2_+3A_namedrop_args">namedrop_args</code></td>
<td>
<p>hack: drop names in sub-lists occurring in data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="stats.html#topic+optim">optim</a></code> optimizer is used to find the minimum of the
negative log-likelihood.  An approximate covariance matrix for the
parameters is obtained by inverting the Hessian matrix at the optimum.
</p>
<p>The <code>minuslogl</code> argument can also specify a formula,
rather than an objective function, of the
form <code>x~ddistn(param1,...,paramn)</code>.  In this case
<code>ddistn</code> is taken to be a probability or density
function, which must have (literally) <code>x</code> as its
first argument (although this argument may be interpreted as
a matrix of multivariate responses) and which must have
a <code>log</code> argument that can be used to specify the
log-probability or log-probability-density is required.
If a formula is specified, then <code>parameters</code> can contain
a list of linear models for the parameters.
</p>
<p>If a formula is given and non-trivial linear models are given
in <code>parameters</code> for some of the variables, then
model matrices will be generated using <code>model.matrix</code>.
<code>start</code> can be given:
</p>

<ul>
<li><p> as a list containing lists, with each list corresponding
to the starting values for a particular parameter;
</p>
</li>
<li><p> just for the higher-level parameters, in which case
all of the additional parameters generated by <code>model.matrix</code>
will be given starting values of zero (unless a no-intercept
formula with <code>-1</code> is specified, in which case all the
starting values for that parameter will be set equal)
</p>
</li>
<li><p> (to be implemented!) as an exhaustive (flat) list
of starting values (in the order given by <code>model.matrix</code>)
</p>
</li></ul>

<p>The <code>trace</code> argument applies only when a formula is specified.
If you specify a function, you can build in your own <code>print()</code>
or <code>cat()</code> statement to trace its progress.  (You can also
specify a value for <code>trace</code> as part of a <code>control</code>
list for <code>optim()</code>: see <code><a href="stats.html#topic+optim">optim</a></code>.)
</p>
<p>The <code>skip.hessian</code> argument is useful if the function is
crashing with a &quot;non-finite finite difference value&quot; error when trying
to evaluate the Hessian, but will preclude many subsequent
confidence interval calculations.  (You will know the Hessian
is failing if you use <code>method="Nelder-Mead"</code> and still
get a finite-difference error.)
</p>
<p>If convergence fails, see the manual page of the
relevant optimizer (<code><a href="stats.html#topic+optim">optim</a></code> by default,
but possibly <code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>,
<code><a href="optimx.html#topic+optimx">optimx</a></code>, or <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>
if you have set the value of <code>optimizer</code>)
for the meanings of the error codes/messages.
</p>


<h3>Value</h3>

<p>An object of class <code>"mle2"</code>.
</p>


<h3>Warning</h3>

<p>Do not use a higher-level variable named <code>.i</code> in
<code>parameters</code> &ndash; this is reserved for internal use.
</p>


<h3>Note</h3>

<p>Note that the <code>minuslogl</code> function should
return the negative log-likelihood, -log L (not
the log-likelihood, log L, nor the deviance, -2 log L). It
is the user's responsibility
to ensure that the likelihood is correct, and that
asymptotic likelihood inference is valid (e.g.
that there are &quot;enough&quot; data and that the
estimated parameter values do not lie on the
boundary of the feasible parameter space).
</p>
<p>If <code>lower</code>, <code>upper</code>, <code>control$parscale</code>,
or <code>control$ndeps</code> are specified for <code>optim</code>
fits, they must be named vectors.
</p>
<p>The requirement that <code>data</code> be specified when using
the formula interface is relatively new: it saves many
headaches on the programming side when evaluating the
likelihood function later on (e.g. for profiling or
constructing predictions).  Since <code>data.frame</code> uses
the names of its arguments as column names by default, it
is probably the easiest way to package objects that are
lying around in the global workspace for use in <code>mle2</code>
(provided they are all of the same length).
</p>
<p>When <code>optimizer</code> is set to &quot;optimx&quot; and multiple
optimization methods are used (i.e. the <code>methods</code>
argument has more than one element, or <code>all.methods=TRUE</code>
is set in the control options), the best (minimum
negative log-likelihood) solution will be saved,
regardless of reported convergence status
(and future operations such as profiling on the fit
will only use the method that found the best result).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle2-class">mle2-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:10
y &lt;- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
d &lt;- data.frame(x,y)

## in general it is best practice to use the `data' argument,
##  but variables can also be drawn from the global environment
LL &lt;- function(ymax=15, xhalf=6)
    -sum(stats::dpois(y, lambda=ymax/(1+x/xhalf), log=TRUE))
## uses default parameters of LL
(fit &lt;- mle2(LL))
fit1F &lt;- mle2(LL, fixed=list(xhalf=6))
coef(fit1F)
coef(fit1F,exclude.fixed=TRUE)

(fit0 &lt;- mle2(y~dpois(lambda=ymean),start=list(ymean=mean(y)),data=d))
anova(fit0,fit)
summary(fit)
logLik(fit)
vcov(fit)
p1 &lt;- profile(fit)
plot(p1, absVal=FALSE)
confint(fit)

## use bounded optimization
## the lower bounds are really &gt; 0, but we use &gt;=0 to stress-test
## profiling; note lower must be named
(fit1 &lt;- mle2(LL, method="L-BFGS-B", lower=c(ymax=0, xhalf=0)))
p1 &lt;- profile(fit1)

plot(p1, absVal=FALSE)
## a better parameterization:
LL2 &lt;- function(lymax=log(15), lxhalf=log(6))
    -sum(stats::dpois(y, lambda=exp(lymax)/(1+x/exp(lxhalf)), log=TRUE))
(fit2 &lt;- mle2(LL2))
plot(profile(fit2), absVal=FALSE)
exp(confint(fit2))
vcov(fit2)
cov2cor(vcov(fit2))

mle2(y~dpois(lambda=exp(lymax)/(1+x/exp(lhalf))),
   start=list(lymax=0,lhalf=0),
   data=d,
   parameters=list(lymax~1,lhalf~1))

## Not run: 
## try bounded optimization with nlminb and constrOptim
(fit1B &lt;- mle2(LL, optimizer="nlminb", lower=c(lymax=1e-7, lhalf=1e-7)))
p1B &lt;- profile(fit1B)
confint(p1B)
(fit1C &lt;- mle2(LL, optimizer="constrOptim", ui = c(lymax=1,lhalf=1), ci=2,
   method="Nelder-Mead"))

set.seed(1001)
lymax &lt;- c(0,2)
lhalf &lt;- 0
x &lt;- sort(runif(200))
g &lt;- factor(sample(c("a","b"),200,replace=TRUE))
y &lt;- rnbinom(200,mu=exp(lymax[g])/(1+x/exp(lhalf)),size=2)
d2 &lt;- data.frame(x,g,y)

fit3 &lt;- mle2(y~dnbinom(mu=exp(lymax)/(1+x/exp(lhalf)),size=exp(logk)),
    parameters=list(lymax~g),data=d2,
    start=list(lymax=0,lhalf=0,logk=0))

## End(Not run)
</code></pre>

<hr>
<h2 id='mle2-class'>Class &quot;mle2&quot;. Result of Maximum Likelihood Estimation.</h2><span id='topic+mle2-class'></span><span id='topic+coef+2Cmle2-method'></span><span id='topic+show+2Cmle2-method'></span><span id='topic+slice+2Cmle2-method'></span><span id='topic+summary+2Cmle2-method'></span><span id='topic+update+2Cmle2-method'></span><span id='topic+vcov+2Cmle2-method'></span><span id='topic+deviance+2Cmle2-method'></span><span id='topic+coerce+2Cmle+2Cmle2-method'></span><span id='topic+formula+2Cmle2-method'></span><span id='topic+stdEr'></span><span id='topic+stdEr+2Cmle2-method'></span>

<h3>Description</h3>

<p>This class encapsulates results of a generic maximum
likelihood procedure.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("mle2", ...)</code>, but
most often as the result of a call to <code><a href="#topic+mle2">mle2</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>(language) The call to <code><a href="#topic+mle2">mle2</a></code>.</p>
</dd>
<dt><code>call.orig</code>:</dt><dd><p>(language) The call to <code><a href="#topic+mle2">mle2</a></code>,
saved in its original form (i.e. without data arguments
evaluated).</p>
</dd>
<dt><code>coef</code>:</dt><dd><p>(numeric) Vector of estimated parameters.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>(data frame or list) Data with which to evaluate the negative log-likelihood function</p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>(numeric) Fixed and estimated parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>(numeric matrix) Approximate variance-covariance
matrix, based on the second derivative matrix at the MLE.</p>
</dd>
<dt><code>min</code>:</dt><dd><p>(numeric) Minimum value of objective function =
minimum negative log-likelihood.</p>
</dd>
<dt><code>details</code>:</dt><dd><p>(list) Return value from <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>(function) The negative log-likelihood
function.</p>
</dd>
<dt><code>optimizer</code>:</dt><dd><p>(character) The optimizing function used.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>(character) The optimization method used.</p>
</dd>
<dt><code>formula</code>:</dt><dd><p>(character) If a formula was specified, a
character vector giving the formula and parameter specifications.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "mle2")</code>: Extract coefficients.
If <code>exclude.fixed=TRUE</code> (it is <code>FALSE</code> by default),
only the non-fixed parameter values are returned.</p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "mle2")</code>: Confidence
intervals from likelihood profiles, or quadratic approximations,
or root-finding.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "mle2")</code>: Display object
briefly.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "summary.mle2")</code>: Display object briefly.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "mle2")</code>: Generate object summary.</p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "mle2")</code>:  Update fit.</p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "mle2")</code>: Extract
variance-covariance matrix.</p>
</dd>
<dt>formula</dt><dd><p><code>signature(object="mle2")</code>: Extract formula</p>
</dd>
<dt>plot</dt><dd><p><code>signature(object="profile.mle2,missing")</code>: Plot
profile. </p>
</dd>
</dl>



<h3>Details on the confint method</h3>

<p>When the parameters in the original fit are constrained using
<code>lower</code> or <code>upper</code>, or when <code>prof.lower</code> or
<code>prof.upper</code> are set, and the confidence intervals lie
outside the constraint region, <code>confint</code> will return <code>NA</code>.
This may be too conservative &ndash; in some cases, the appropriate
answer would be to set the confidence limit to the lower/upper
bound as appropriate &ndash; but it is the most general answer.
</p>
<p>(If you have a strong opinion about the need for a new
option to <code>confint</code> that sets the bounds to the limits
automatically, please contact the package maintainer.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:10
y &lt;- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
lowerbound &lt;- c(a=2,b=-0.2)
d &lt;- data.frame(x,y)
fit1 &lt;- mle2(y~dpois(lambda=exp(a+b*x)),start=list(a=0,b=2),data=d,
method="L-BFGS-B",lower=c(a=2,b=-0.2))
(cc &lt;- confint(fit1,quietly=TRUE))
## to set the lower bounds to the limit
na_lower &lt;- is.na(cc[,1])
cc[na_lower,1] &lt;- lowerbound[na_lower]
cc
</code></pre>

<hr>
<h2 id='mle2.options'>Options for maximum likelihood estimation</h2><span id='topic+mle2.options'></span>

<h3>Description</h3>

<p>Query or set MLE parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle2.options(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle2.options_+3A_...">...</code></td>
<td>
<p>names of arguments to query,
or a list of values to set</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>optim.method</dt><dd><p>name of optimization method (see
<code><a href="stats.html#topic+optim">optim</a></code> for choices)</p>
</dd>
<dt>confint</dt><dd><p>name of confidence interval method: choices
are &quot;spline&quot;, &quot;uniroot&quot;, &quot;hessian&quot; corresponding
to spline inversion, attempt to find best answer via uniroot,
information-matrix approximation</p>
</dd>
<dt>optimizer</dt><dd><p>optimization function to use by default
(choices: &quot;optim&quot;, &quot;nlm&quot;, &quot;nlminb&quot;, &quot;constrOptim&quot;)</p>
</dd>
</dl>



<h3>Value</h3>

<p>Values of queried parameters, or (invisibly) the full list of parameters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle2-class">mle2-class</a></code>
</p>

<hr>
<h2 id='namedrop'>drop unneeded names from list elements</h2><span id='topic+namedrop'></span>

<h3>Description</h3>

<p>goes through a list (containing a combination
of single- and multiple-element vectors) and
removes redundant names that will make trouble
for mle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namedrop(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="namedrop_+3A_x">x</code></td>
<td>
<p>a list of named or unnamed, typically numeric, vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>examines each element of <code>x</code>.  If the element has length
one and is a named vector, the name is removed; if <code>length(x)</code>
is greater than 1, but all the names are the same, the vector
is renamed 
</p>


<h3>Value</h3>

<p>the original list, with names removed/added
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = list(a=c(a=1),b=c(d=1,d=2),c=c(a=1,b=2,c=3))
names(unlist(namedrop(x)))
names(unlist(namedrop(x)))
</code></pre>

<hr>
<h2 id='parnames'>get and set parameter names</h2><span id='topic+parnames'></span><span id='topic+parnames+3C-'></span>

<h3>Description</h3>

<p>Gets and sets the &quot;parnames&quot; attribute on a
negative log-likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parnames(obj)
parnames(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parnames_+3A_obj">obj</code></td>
<td>
<p>a negative log-likelihood function</p>
</td></tr>
<tr><td><code id="parnames_+3A_value">value</code></td>
<td>
<p>a character vector of parameter names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>parnames</code> attribute is used by <code>mle2()</code>
when the negative log-likelihood function takes a parameter
vector, rather than a list of parameters; this allows
users to use the same objective function for <code>optim()</code>
and <code>mle2()</code>
</p>


<h3>Value</h3>

<p>Returns the <code>parnames</code> attribute (a character vector of
parameter names) or sets it.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
set.seed(1001)
y &lt;- rbinom(5,prob=x/(1+x),size=10)
mfun &lt;- function(p) {
  a &lt;- p[1]
  b &lt;- p[2]
  -sum(dbinom(y,prob=a*x/(b+x),size=10,log=TRUE))
}
optim(fn=mfun,par=c(1,1))
parnames(mfun) &lt;- c("a","b")
mle2(minuslogl=mfun,start=c(a=1,b=1),method="Nelder-Mead")
</code></pre>

<hr>
<h2 id='pop_pred_samp'>generate population prediction sample from parameters</h2><span id='topic+pop_pred_samp'></span>

<h3>Description</h3>

<p>This [EXPERIMENTAL] function combines several sampling tricks to compute a version of an importance sample (based on flat priors) for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_pred_samp(
  object,
  n = 1000,
  n_imp = n * 10,
  return_wts = FALSE,
  impsamp = FALSE,
  PDify = FALSE,
  PDmethod = NULL,
  Sigma = vcov(object),
  tol = 1e-06,
  return_all = FALSE,
  rmvnorm_method = c("mvtnorm", "MASS"),
  fix_params = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pop_pred_samp_+3A_object">object</code></td>
<td>
<p>a fitted <code>mle2</code> object</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_n">n</code></td>
<td>
<p>number of samples to return</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_n_imp">n_imp</code></td>
<td>
<p>number of total samples from which to draw, if doing importance sampling</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_return_wts">return_wts</code></td>
<td>
<p>return a column giving the weights of the samples, for use in weighted summaries?</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_impsamp">impsamp</code></td>
<td>
<p>subsample values (with replacement) based on their weights?</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_pdify">PDify</code></td>
<td>
<p>use Gill and King generalized-inverse procedure to correct non-positive-definite variance-covariance matrix if necessary?</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_pdmethod">PDmethod</code></td>
<td>
<p>method for fixing non-positive-definite covariance matrices</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_tol">tol</code></td>
<td>
<p>tolerance for detecting small eigenvalues</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_return_all">return_all</code></td>
<td>
<p>return a matrix including all values, and weights (rather than taking a sample)</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_rmvnorm_method">rmvnorm_method</code></td>
<td>
<p>package to use for generating MVN samples</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_fix_params">fix_params</code></td>
<td>
<p>parameters to fix (in addition to parameters that were fixed during estimation)</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix for sampling</p>
</td></tr>
<tr><td><code id="pop_pred_samp_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to the negative log-likelihood function</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gill, Jeff, and Gary King. &quot;What to Do When Your Hessian Is Not Invertible: Alternatives to Model Respecification in Nonlinear Estimation.&quot; Sociological Methods &amp; Research 33, no. 1 (2004): 54-87.
Lande, Russ and Steinar Engen and Bernt-Erik Saether, Stochastic Population Dynamics in Ecology and Conservation. Oxford University Press, 2003.
</p>

<hr>
<h2 id='predict-methods'>Predicted values from an mle2 fit</h2><span id='topic+gfun'></span><span id='topic+predict-methods'></span><span id='topic+predict+2Cmle2-method'></span><span id='topic+residuals+2Cmle2-method'></span><span id='topic+simulate+2Cmle2-method'></span>

<h3>Description</h3>

<p>Given an <code>mle2</code> fit and an optional list
of new data, return predictions (more generally,
summary statistics of the predicted distribution)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S4 method for signature 'mle2'
predict(object, newdata=NULL,
                         location="mean", newparams=NULL, ...)
    ## S4 method for signature 'mle2'
simulate(object, nsim,
                         seed, newdata=NULL, newparams=NULL, ...)
    ## S4 method for signature 'mle2'
residuals(object,type=c("pearson","response"),
                   location="mean",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict-methods_+3A_object">object</code></td>
<td>
<p>an mle2 object</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_newdata">newdata</code></td>
<td>
<p>optional list of new data</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_newparams">newparams</code></td>
<td>
<p>optional vector of new parameters</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_location">location</code></td>
<td>
<p>name of the summary statistic to return</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_seed">seed</code></td>
<td>
<p>random number seed</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_type">type</code></td>
<td>
<p>residuals type</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_...">...</code></td>
<td>
<p>additional arguments (for generic compatibility)</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;mle2&quot;</dt><dd><p>an <code>mle2</code> fit</p>
</dd>
</dl>


<h3>Note</h3>

<p>For some models (e.g. constant models), <code>predict</code> may
return a single value rather than a vector of the appropriate length.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1002)
lymax &lt;- c(0,2)
lhalf &lt;- 0
x &lt;- runif(200)
g &lt;- factor(rep(c("a","b"),each=100))
y &lt;- rnbinom(200,mu=exp(lymax[g])/(1+x/exp(lhalf)),size=2)
dat &lt;- data.frame(y,g,x)

fit3 &lt;- mle2(y~dnbinom(mu=exp(lymax)/(1+x/exp(lhalf)),size=exp(logk)),
    parameters=list(lymax~g),
    start=list(lymax=0,lhalf=0,logk=0),
data=dat)

plot(y~x,col=g)
## true curves
curve(exp(0)/(1+x/exp(0)),add=TRUE)
curve(exp(2)/(1+x/exp(0)),col=2,add=TRUE)
## model predictions
xvec = seq(0,1,length=100)
lines(xvec,predict(fit3,newdata=list(g=factor(rep("a",100),levels=c("a","b")),
                                x = xvec)),col=1,lty=2)
lines(xvec,predict(fit3,newdata=list(g=factor(rep("b",100),levels=c("a","b")),
                                x = xvec)),col=2,lty=2)


## comparing automatic and manual predictions
p1 = predict(fit3)
p2A =
with(as.list(coef(fit3)),exp(`lymax.(Intercept)`)/(1+x[1:100]/exp(lhalf)))
p2B =
with(as.list(coef(fit3)),exp(`lymax.(Intercept)`+lymax.gb)/(1+x[101:200]/exp(lhalf)))
all(p1==c(p2A,p2B))
##
simulate(fit3)
</code></pre>

<hr>
<h2 id='profile-methods'>Likelihood profiles </h2><span id='topic+proffun'></span><span id='topic+profile-methods'></span><span id='topic+profile+2Cmle2-method'></span><span id='topic+profile.mle2'></span>

<h3>Description</h3>

<p>Compute likelihood profiles for a fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proffun(fitted, which = 1:p, maxsteps = 100,
                    alpha = 0.01, zmax = sqrt(qchisq(1 - alpha/2, p)),
                    del = zmax/5, trace = FALSE, skiperrs=TRUE,
                    std.err, 
                    tol.newmin = 0.001, debug=FALSE,
                    prof.lower, prof.upper,
                    skip.hessian = TRUE,
                    continuation = c("none","naive","linear"),
                    try_harder=FALSE, ...)
## S4 method for signature 'mle2'
profile(fitted, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile-methods_+3A_fitted">fitted</code></td>
<td>
<p>A fitted maximum likelihood model of class
&ldquo;mle2&rdquo;</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_which">which</code></td>
<td>
<p>a numeric or character vector describing which parameters
to profile (default is to profile all parameters)</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximum number of steps to take looking for an upper
value of the negative log-likelihood</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_alpha">alpha</code></td>
<td>
<p>maximum (two-sided) likelihood ratio test confidence
level to find</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_zmax">zmax</code></td>
<td>
<p>maximum value of signed square root of deviance difference
to find (default value corresponds to a
2-tailed chi-squared test at level alpha)</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_del">del</code></td>
<td>
<p>step size for profiling</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_trace">trace</code></td>
<td>
<p>(logical) produce tracing output?</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_skiperrs">skiperrs</code></td>
<td>
<p>(logical) ignore errors produced during profiling?</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_std.err">std.err</code></td>
<td>
<p>Optional numeric vector of standard errors, for cases
when the Hessian is badly behaved.  Will be replicated if necessary,
and NA values will be replaced by the corresponding values from
the fit summary</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_tol.newmin">tol.newmin</code></td>
<td>
<p>tolerance for diagnosing a new minimum below the
minimum deviance estimated in initial fit is found</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_debug">debug</code></td>
<td>
<p>(logical) debugging output?</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_prof.lower">prof.lower</code></td>
<td>
<p>optional vector of lower bounds for profiles</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_prof.upper">prof.upper</code></td>
<td>
<p>optional vector of upper bounds for profiles</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_continuation">continuation</code></td>
<td>
<p>use continuation method to set starting values?
<code>"none"</code> sets starting values to best fit; <code>"naive"</code>
sets starting values to those of previous profiling fit;
<code>"linear"</code> (not yet implemented) would use linear extrapolation
from the previous two profiling fits</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_skip.hessian">skip.hessian</code></td>
<td>
<p>skip hessian (defunct?)</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_try_harder">try_harder</code></td>
<td>
<p>(logical) ignore <code>NA</code> and flat spots in the
profile, try to continue anyway?</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>proffun</code> is the guts of the profile method, exposed
so that other packages can use it directly.
</p>
<p>See the vignette (<code>vignette("mle2",package="bbmle")</code>)
for more technical details of how profiling is done.
</p>


<h3>See Also</h3>

<p><code><a href="stats4.html#topic+profile.mle-class">profile.mle-class</a></code></p>

<hr>
<h2 id='profile.mle2-class'>Methods for likelihood profiles</h2><span id='topic+profile.mle2-class'></span><span id='topic+confint+2Cprofile.mle2-method'></span><span id='topic+confint+2Cmle2-method'></span><span id='topic+confint.mle2'></span><span id='topic+plot+2Cprofile.mle2-method'></span><span id='topic+plot+2Cprofile.mle2+2Cmissing-method'></span><span id='topic+show+2Cprofile.mle2-method'></span><span id='topic+plot.profile.mle2'></span>

<h3>Description</h3>

<p>Definition of the mle2 likelihood profile class,
and applicable methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'profile.mle2'
plot(x,
   levels, which=1:p, conf = c(99, 95, 90, 80, 50)/100,
   plot.confstr = TRUE,
   confstr = NULL, absVal = TRUE, add = FALSE,
   col.minval="green", lty.minval=2,
   col.conf="magenta", lty.conf=2,
   col.prof="blue", lty.prof=1,
   xlabs=nm, ylab="z",
   onepage=TRUE,
   ask=((prod(par("mfcol")) &lt; length(which)) &amp;&amp; dev.interactive() &amp;&amp;
               !onepage),
   show.points=FALSE,
   main, xlim, ylim, ...)
## S4 method for signature 'mle2'
confint(object, parm, level = 0.95, method,
          trace=FALSE,quietly=!interactive(),
          tol.newmin=0.001,...)
## S4 method for signature 'profile.mle2'
confint(object, parm, level = 0.95, trace=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile.mle2-class_+3A_x">x</code></td>
<td>
<p>An object of class <code>profile.mle2</code></p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_object">object</code></td>
<td>
<p>An object of class <code>mle2</code> or <code>profile.mle2</code>
(as appropriate)</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_levels">levels</code></td>
<td>
<p>levels at which to plot likelihood cutoffs (set by conf
by default)</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_level">level</code></td>
<td>
<p>level at which to compute confidence interval</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_which">which</code></td>
<td>
<p>(numeric or character) which parameter profiles to plot</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_parm">parm</code></td>
<td>
<p>(numeric or character) which parameter(s) to find
confidence intervals for</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_method">method</code></td>
<td>
<p>(character) &quot;spline&quot;, &quot;uniroot&quot;, or &quot;quad&quot;, for
spline-extrapolation-based (default), root-finding, or quadratic
confidence intervals.  By default it uses the value of
<code>mle2.options("confint")</code> &ndash; the factory setting is &quot;spline&quot;.</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_trace">trace</code></td>
<td>
<p>trace progress of confidence interval calculation when using
&lsquo;uniroot&rsquo; method?</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_conf">conf</code></td>
<td>
<p>(1-alpha) levels at which to plot likelihood
cutoffs/confidence intervals</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_quietly">quietly</code></td>
<td>
<p>(logical) suppress &ldquo;Profiling ...&rdquo; message
when computing profile to get confidence interval?</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_tol.newmin">tol.newmin</code></td>
<td>
<p>see <code><a href="#topic+profile-methods">profile-methods</a></code></p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_plot.confstr">plot.confstr</code></td>
<td>
<p>(logical) plot labels showing confidence levels?</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_confstr">confstr</code></td>
<td>
<p>(character) labels for confidence levels (by default, constructed from conf levels)</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_absval">absVal</code></td>
<td>
<p>(logical) plot absolute values of signed square
root deviance difference (&quot;V&quot; plot rather than straight-line
plot)?</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_add">add</code></td>
<td>
<p>(logical) add profile to existing graph?</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_col.minval">col.minval</code></td>
<td>
<p>color for minimum line</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_lty.minval">lty.minval</code></td>
<td>
<p>line type for minimum line</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_col.conf">col.conf</code></td>
<td>
<p>color for confidence intervals</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_lty.conf">lty.conf</code></td>
<td>
<p>line type for confidence intervals</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_col.prof">col.prof</code></td>
<td>
<p>color for profile</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_lty.prof">lty.prof</code></td>
<td>
<p>line type for profile</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_xlabs">xlabs</code></td>
<td>
<p>x labels</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_ylab">ylab</code></td>
<td>
<p>y label</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_onepage">onepage</code></td>
<td>
<p>(logical) plot all profiles on one page,
adjusting par(mfcol) as necessary?</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_ask">ask</code></td>
<td>
<p>(logical) pause for user input between plots?</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_show.points">show.points</code></td>
<td>
<p>(logical) show computed profile points
as well as interpolated spline?</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_main">main</code></td>
<td>
<p>(logical) main title</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_xlim">xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="profile.mle2-class_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default confidence interval calculation computes a likelihood
profile and uses the points therein, or uses the computed points in
an existing <code>profile.mle2</code> object, to construct an interpolation
spline (which by default has three times as many points as were in
the original set of profile points).  It then uses linear
interpolation between these interpolated points (!)
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("profile.mle2",
    ...)</code>, but most often by invoking <code>profile</code> on an &quot;mle2&quot; object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>profile</code>:</dt><dd><p>Object of class <code>"list"</code>. List of
profiles, one for each requested parameter. Each profile is a data
frame with the first column called <code>z</code> being the signed square
root of the deviance, and the others being the
parameters with names prefixed by <code>par.vals.</code></p>
</dd>
<dt><code>summary</code>:</dt><dd><p>Object of class <code>"summary.mle2"</code>. Summary
of object being profiled.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>confint</dt><dd><p><code>signature(object = "profile.mle2")</code>: Use profile
to generate approximate confidence intervals for parameters.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "profile.mle2", y = "missing")</code>: Plot
profiles for each parameter.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(x = "profile.mle2")</code>: Plot
profiles for each parameter.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "profile.mle2")</code>: Show object.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+mle2">mle2</a></code>, <code><a href="#topic+mle2-class">mle2-class</a></code>, <code><a href="#topic+summary.mle2-class">summary.mle2-class</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:10
y &lt;- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
d &lt;- data.frame(x,y)
## we have a choice here: (1) don't impose boundaries on the parameters,
##  put up with warning messages about NaN values: 
fit1 &lt;- mle2(y~dpois(lambda=ymax/(1+x/xhalf)),
     start=list(ymax=1,xhalf=1),
     data=d)
p1 &lt;- suppressWarnings(profile(fit1))
plot(p1,main=c("first","second"),
     xlab=c(~y[max],~x[1/2]),ylab="Signed square root deviance",
     show.points=TRUE)
suppressWarnings(confint(fit1)) ## recomputes profile
confint(p1)  ## operates on existing profile
suppressWarnings(confint(fit1,method="uniroot"))
## alternatively, we can use box constraints to keep ourselves
##  to positive parameter values ...
fit2 &lt;- update(fit1,method="L-BFGS-B",lower=c(ymax=0.001,xhalf=0.001))
## Not run: 
p2 &lt;- profile(fit2)
plot(p2,show.points=TRUE)
## but the fit for ymax is just bad enough that the spline gets wonky
confint(p2)  ## now we get a warning
confint(fit2,method="uniroot")
## bobyqa is a better-behaved bounded optimizer ...
##  BUT recent (development, 2012.5.24) versions of
##    optimx no longer allow single-parameter fits!
if (require(optimx)) {
  fit3 &lt;- update(fit1,
      optimizer="optimx",
      method="bobyqa",lower=c(ymax=0.001,xhalf=0.001))
   p3 &lt;- profile(fit3)
   plot(p3,show.points=TRUE)
  confint(p3)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='relist2'>reconstruct the structure of a list</h2><span id='topic+relist2'></span>

<h3>Description</h3>

<p>reshapes a vector according to a list template
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relist2(v, l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relist2_+3A_v">v</code></td>
<td>
<p>vector, probably numeric, of values to reshape</p>
</td></tr>
<tr><td><code id="relist2_+3A_l">l</code></td>
<td>
<p>template list giving structure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>attempts to coerce <code>v</code> into a list with the same
structure and names as <code>l</code>
</p>


<h3>Value</h3>

<p>a list with values corresponding to v and structure corresponding to l
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>Examples</h3>

<pre><code class='language-R'>  l = list(b=1,c=2:5,d=matrix(1:4,nrow=2))
  relist2(1:9,l)
</code></pre>

<hr>
<h2 id='sbinom'>Abstract definitions of distributions</h2><span id='topic+sbinom'></span><span id='topic+spois'></span><span id='topic+snbinom'></span><span id='topic+snorm'></span><span id='topic+sbeta'></span><span id='topic+sbetabinom'></span><span id='topic+slnorm'></span>

<h3>Description</h3>

<p>Functions returning values for summary statistics
(mean, median, etc.) of distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbeta(shape1, shape2)
sbetabinom(size, prob, theta)
sbinom(size, prob)
snbinom(size, prob, mu)
snorm(mean, sd)
spois(lambda)
slnorm(meanlog, sdlog)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbinom_+3A_prob">prob</code></td>
<td>
<p>probability as defined for <code><a href="stats.html#topic+dbinom">dbinom</a></code>,
<code><a href="stats.html#topic+dnbinom">dnbinom</a></code>, or beta-binomial distribution
(<code>dbetabinom</code> in the <code>emdbook</code> package)</p>
</td></tr>
<tr><td><code id="sbinom_+3A_size">size</code></td>
<td>
<p>size parameter as defined for
<code><a href="stats.html#topic+dbinom">dbinom</a></code> or <code>dbetabinom</code>
in the <code>emdbook</code> package, or size/overdispersion parameter
as in <code><a href="stats.html#topic+dnbinom">dnbinom</a></code></p>
</td></tr>
<tr><td><code id="sbinom_+3A_mean">mean</code></td>
<td>
<p>mean parameter as defined for <code><a href="stats.html#topic+dnorm">dnorm</a></code></p>
</td></tr>
<tr><td><code id="sbinom_+3A_mu">mu</code></td>
<td>
<p>mean parameter as defined for <code><a href="stats.html#topic+dnbinom">dnbinom</a></code></p>
</td></tr>
<tr><td><code id="sbinom_+3A_sd">sd</code></td>
<td>
<p>standard deviation parameter as defined for <code><a href="stats.html#topic+dnorm">dnorm</a></code></p>
</td></tr>
<tr><td><code id="sbinom_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter for <code><a href="stats.html#topic+dbeta">dbeta</a></code></p>
</td></tr>
<tr><td><code id="sbinom_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter for <code><a href="stats.html#topic+dbeta">dbeta</a></code></p>
</td></tr>
<tr><td><code id="sbinom_+3A_lambda">lambda</code></td>
<td>
<p>rate parameter as defined for <code><a href="stats.html#topic+dpois">dpois</a></code></p>
</td></tr>
<tr><td><code id="sbinom_+3A_theta">theta</code></td>
<td>
<p>overdispersion parameter for beta-binomial
(see <code>dbetabinom</code> in the <code>emdbook</code> package)</p>
</td></tr>
<tr><td><code id="sbinom_+3A_meanlog">meanlog</code></td>
<td>
<p>as defined for <code><a href="stats.html#topic+dlnorm">dlnorm</a></code></p>
</td></tr>
<tr><td><code id="sbinom_+3A_sdlog">sdlog</code></td>
<td>
<p>as defined for <code><a href="stats.html#topic+dlnorm">dlnorm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>title</code></td>
<td>
<p>name of the distribution</p>
</td></tr>
<tr><td><code>[parameters]</code></td>
<td>
<p>input parameters for the distribution</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>theoretical mean of the distribution</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>theoretical median of the distribution</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>theoretical mode of the distribution</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>theoretical variance of the distribution</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>theoretical standard deviation of the distribution</p>
</td></tr>
</table>


<h3>Note</h3>

<p>these definitions are tentative, subject to change
as I figure this out better.  Perhaps construct functions
that return functions? Strip down results? Do more
automatically?</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code>, <code><a href="stats.html#topic+dpois">dpois</a></code>, <code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+dnbinom">dnbinom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  sbinom(prob=0.2,size=10)
  snbinom(mu=2,size=1.2)
</code></pre>

<hr>
<h2 id='slice'>Calculate likelihood &quot;slices&quot;</h2><span id='topic+slice'></span><span id='topic+sliceOld'></span><span id='topic+slicetrans'></span><span id='topic+slice1D'></span><span id='topic+slice2D'></span>

<h3>Description</h3>

<p>Computes cross-section(s) of a multi-dimensional likelihood surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(x, dim=1, ...)
sliceOld(fitted, which = 1:p, maxsteps = 100,
                       alpha = 0.01, zmax = sqrt(qchisq(1 - alpha/2, p)),
                       del = zmax/5, trace = FALSE,
                       tol.newmin=0.001, ...)
slice1D(params,fun,nt=101,lower=-Inf,
                    upper=Inf,verbose=TRUE, tranges=NULL,
                    fun_args = NULL,
                    ...)
slice2D(params,fun,nt=31,lower=-Inf,
                    upper=Inf,
                    cutoff=10,verbose=TRUE,
                    tranges=NULL,
                    ...)
slicetrans(params, params2, fun, extend=0.1, nt=401,
                       lower=-Inf, upper=Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_+3A_x">x</code></td>
<td>
<p>a fitted model object of some sort</p>
</td></tr>
<tr><td><code id="slice_+3A_dim">dim</code></td>
<td>
<p>dimensionality of slices (1 or 2)</p>
</td></tr>
<tr><td><code id="slice_+3A_params">params</code></td>
<td>
<p>a named vector of baseline parameter values</p>
</td></tr>
<tr><td><code id="slice_+3A_params2">params2</code></td>
<td>
<p>a vector of parameter values</p>
</td></tr>
<tr><td><code id="slice_+3A_fun">fun</code></td>
<td>
<p>an objective function</p>
</td></tr>
<tr><td><code id="slice_+3A_fun_args">fun_args</code></td>
<td>
<p>additional arguments to pass to <code>fun</code></p>
</td></tr>
<tr><td><code id="slice_+3A_nt">nt</code></td>
<td>
<p>(integer) number of slice-steps to take</p>
</td></tr>
<tr><td><code id="slice_+3A_lower">lower</code></td>
<td>
<p>lower bound(s) (stub?)</p>
</td></tr>
<tr><td><code id="slice_+3A_upper">upper</code></td>
<td>
<p>upper bound(s) (stub?)</p>
</td></tr>
<tr><td><code id="slice_+3A_cutoff">cutoff</code></td>
<td>
<p>maximum increase in objective function to allow
when computing ranges</p>
</td></tr>
<tr><td><code id="slice_+3A_extend">extend</code></td>
<td>
<p>(numeric) fraction by which to extend range beyond specified points</p>
</td></tr>
<tr><td><code id="slice_+3A_verbose">verbose</code></td>
<td>
<p>print verbose output?</p>
</td></tr>
<tr><td><code id="slice_+3A_fitted">fitted</code></td>
<td>
<p>A fitted maximum likelihood model of class
&ldquo;mle2&rdquo;</p>
</td></tr>
<tr><td><code id="slice_+3A_which">which</code></td>
<td>
<p>a numeric or character vector describing which parameters
to profile (default is to profile all parameters)</p>
</td></tr>
<tr><td><code id="slice_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximum number of steps to take looking for an upper
value of the negative log-likelihood</p>
</td></tr>
<tr><td><code id="slice_+3A_alpha">alpha</code></td>
<td>
<p>maximum (two-sided) likelihood ratio test confidence
level to find</p>
</td></tr>
<tr><td><code id="slice_+3A_zmax">zmax</code></td>
<td>
<p>maximum value of signed square root of deviance difference
to find (default value corresponds to a
2-tailed chi-squared test at level alpha)</p>
</td></tr>
<tr><td><code id="slice_+3A_del">del</code></td>
<td>
<p>step size for profiling</p>
</td></tr>
<tr><td><code id="slice_+3A_trace">trace</code></td>
<td>
<p>(logical) produce tracing output?</p>
</td></tr>
<tr><td><code id="slice_+3A_tol.newmin">tol.newmin</code></td>
<td>
<p>tolerance for diagnosing a new minimum below the
minimum deviance estimated in initial fit is found</p>
</td></tr>
<tr><td><code id="slice_+3A_tranges">tranges</code></td>
<td>
<p>a two-column matrix giving lower and upper bounds for
each parameter</p>
</td></tr>
<tr><td><code id="slice_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slices provide a lighter-weight way to explore likelihood surfaces
than profiles, since they vary a single parameter rather than
optimizing over all but one or two parameters.
</p>

<dl>
<dt>slice</dt><dd><p>is a generic method</p>
</dd>
<dt>slice1D</dt><dd><p>creates one-dimensional slices, by default of all
parameters of a model</p>
</dd>
<dt>slice2D</dt><dd><p>creates two-dimensional slices, by default of all pairs
of parameters in a model. In each panel the closed point represents
the parameters given (typically the MLEs), while the open point
represents the observed minimum value within the 2D slice.
If everything has gone according to plan, these points should
coincide (at least up to grid precision).
</p>
</dd>
<dt>slicetrans</dt><dd><p>creates a slice along a transect between two specified
points in parameter space (see <code>calcslice</code> in the <code>emdbook</code>
package)</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>slice</code> with
</p>

<dl>
<dt>slices</dt><dd><p>a list of individual parameter (or parameter-pair)
slices, each of which is a data frame with elements
</p>

<dl>
<dt>var1</dt><dd><p>name of the first variable</p>
</dd>
<dt>var2</dt><dd><p>(for 2D slices) name of the second variable</p>
</dd>
<dt>x</dt><dd><p>parameter values</p>
</dd>
<dt>y</dt><dd><p>(for 2D slices) parameter values</p>
</dd>
<dt>z</dt><dd><p>slice values</p>
</dd>
<dt>ranges</dt><dd><p>a list (?) of the ranges for each parameter</p>
</dd>
<dt>params</dt><dd><p>vector of baseline parameter values</p>
</dd>
<dt>dim</dt><dd><p>1 or 2</p>
</dd>
</dl>

</dd>
</dl>
<p><code>sliceOld</code> returns instead a list with elements <code>profile</code>
and <code>summary</code> (see <code><a href="#topic+profile.mle2">profile.mle2</a></code>)

</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+profile">profile</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:10
y &lt;- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
d &lt;- data.frame(x,y)
fit1 &lt;- mle2(y~dpois(lambda=exp(lymax)/(1+x/exp(lhalf))),
   start=list(lymax=0,lhalf=0),
   data=d)
s1 &lt;- bbmle::slice(fit1,verbose=FALSE)
s2 &lt;- bbmle::slice(fit1,dim=2,verbose=FALSE)
require(lattice)
plot(s1)
plot(s2)
## 'transect' slice, from best-fit values to another point
st &lt;- bbmle::slice(fit1,params2=c(5,0.5))
plot(st)
</code></pre>

<hr>
<h2 id='slice.mle2-class'>likelihood-surface slices</h2><span id='topic+slice.mle2-class'></span>

<h3>Description</h3>

<p>evaluations of log-likelihood along transects in parameter space</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("slice.mle2", ...)</code>.
The objects are similar to likelihood profiles, but don't involve
any optimization with respect to the other parameters.
</p>


<h3>Slots</h3>


<dl>
<dt><code>profile</code>:</dt><dd><p>Object of class <code>"list"</code>. List of
slices, one for each requested parameter. Each slice is a data
frame with the first column called <code>z</code> being the signed square
root of the -2 log likelihood ratio, and the others being the
parameters with names prefixed by <code>par.vals.</code></p>
</dd>
<dt><code>summary</code>:</dt><dd><p>Object of class <code>"summary.mle2"</code>. Summary
of object being profiled.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "profile.mle2", y = "missing")</code>: Plot
profiles for each parameter.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+profile.mle2-class">profile.mle2-class</a></code>
</p>

<hr>
<h2 id='strwrapx'>Wrap strings at white space and + symbols</h2><span id='topic+strwrapx'></span>

<h3>Description</h3>

<p>Extended (hacked) version of strwrap: wraps a string at whitespace
and plus symbols
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strwrapx(x, width = 0.9 * getOption("width"), indent = 0,
exdent = 0, prefix = "", simplify = TRUE,
parsplit = "\n[ \t\n]*\n", wordsplit = "[ \t\n]")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strwrapx_+3A_x">x</code></td>
<td>
<p>a character vector, or an object which can be converted to a
character vector by <code><a href="base.html#topic+as.character">as.character</a></code>.</p>
</td></tr>
<tr><td><code id="strwrapx_+3A_width">width</code></td>
<td>
<p>a positive integer giving the target column for wrapping
lines in the output.</p>
</td></tr>
<tr><td><code id="strwrapx_+3A_indent">indent</code></td>
<td>
<p>a non-negative integer giving the indentation of the
first line in a paragraph.</p>
</td></tr>
<tr><td><code id="strwrapx_+3A_exdent">exdent</code></td>
<td>
<p>a non-negative integer specifying the indentation of
subsequent lines in paragraphs.</p>
</td></tr>
<tr><td><code id="strwrapx_+3A_prefix">prefix</code></td>
<td>
<p>a character string to be used as prefix for each line.</p>
</td></tr>
<tr><td><code id="strwrapx_+3A_simplify">simplify</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the result is a single
character vector of line text; otherwise, it is a list of the same
length as <code>x</code> the elements of which are character vectors of
line text obtained from the corresponding element of <code>x</code>.
(Hence, the result in the former case is obtained by unlisting that
of the latter.)</p>
</td></tr>
<tr><td><code id="strwrapx_+3A_parsplit">parsplit</code></td>
<td>
<p>Regular expression describing how to split paragraphs</p>
</td></tr>
<tr><td><code id="strwrapx_+3A_wordsplit">wordsplit</code></td>
<td>
<p>Regular expression decribing how to split words</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whitespace in the input is destroyed.  Double spaces after periods
(thought as representing sentence ends) are preserved.  Currently,
possible sentence ends at line breaks are not considered specially.
</p>
<p>Indentation is relative to the number of characters in the prefix
string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read in file 'THANKS'.
x &lt;- paste(readLines(file.path(R.home("doc"), "THANKS")), collapse = "\n")
## Split into paragraphs and remove the first three ones
x &lt;- unlist(strsplit(x, "\n[ \t\n]*\n"))[-(1:3)]
## Join the rest
x &lt;- paste(x, collapse = "\n\n")
## Now for some fun:
writeLines(strwrap(x, width = 60))
writeLines(strwrap(x, width = 60, indent = 5))
writeLines(strwrap(x, width = 60, exdent = 5))
writeLines(strwrap(x, prefix = "THANKS&gt; "))

## Note that messages are wrapped AT the target column indicated by
## 'width' (and not beyond it).
## From an R-devel posting by J. Hosking &lt;jh910@juno.com&gt;.
x &lt;- paste(sapply(sample(10, 100, rep=TRUE),
           function(x) substring("aaaaaaaaaa", 1, x)), collapse = " ")
sapply(10:40,
       function(m)
       c(target = m, actual = max(nchar(strwrap(x, m)))))
</code></pre>

<hr>
<h2 id='summary.mle2-class'>Class &quot;summary.mle2&quot;, summary of &quot;mle2&quot; objects</h2><span id='topic+summary.mle2-class'></span><span id='topic+coef+2Csummary.mle2-method'></span><span id='topic+show+2Csummary.mle2-method'></span>

<h3>Description</h3>

<p>Extract of &quot;mle2&quot; object</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("summary.mle2",
  ...)</code>, but most often by invoking <code>summary</code> on an &quot;mle2&quot; object.
They contain values meant for printing by <code>show</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> The call that
generated the &quot;mle2&quot; object.</p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Estimated
coefficients and standard errors </p>
</dd>
<dt><code>m2logL</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Minus twice
the log likelihood.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "summary.mle2")</code>: Pretty-prints
<code>object</code>  </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "summary.mle2")</code>: Extracts the
contents of the <code>coef</code> slot</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+mle2">mle2</a></code>, <code><a href="#topic+mle2-class">mle2-class</a></code> 
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
