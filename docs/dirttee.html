<!DOCTYPE html><html><head><title>Help for package dirttee</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dirttee}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dirttee-package'>
<p>DIstributional Regression for Times To EvEnt</p></a></li>
<li><a href='#asynorm'><p>The asymmetric normal distribution.</p></a></li>
<li><a href='#boot.modreg'><p>Estimate confidence intervals and standard errors for the mode regression fit</p></a></li>
<li><a href='#colcancer'><p>Colon Cancer Dataset</p></a></li>
<li><a href='#expectreg.aft'><p>Expectile regression for right censored event times using an auxiliary likelihood</p></a></li>
<li><a href='#expectreg.ipc'><p>Expectile regression for right-censored data</p></a></li>
<li><a href='#gumbel'><p>The Gumbel Distribution.</p></a></li>
<li><a href='#methods'><p>Methods for fitted modreg model</p></a></li>
<li><a href='#modreg'><p>Mode-regression for right-censored data</p></a></li>
<li><a href='#modreg.control'><p>Setting fitting values for <code>modreg</code>.</p></a></li>
<li><a href='#plot.modreg'><p>Plot regression terms for modreg objects</p></a></li>
<li><a href='#predict.modreg'><p>Prediction from a fitted modreg model</p></a></li>
<li><a href='#weightsKM'><p>Inverse probability of censoring weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Distributional Regression for Time to Event Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Seipp [aut, cre], Fabian Otto-Sobotka [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Seipp &lt;alexander.seipp@uni-oldenburg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Semiparametric distributional regression methods (expectile,
    quantile and mode regression) for time-to-event variables with
    right-censoring; uses inverse probability of censoring weights or
    accelerated failure time models with auxiliary likelihoods. Expectile
    regression using inverse probability of censoring weights has been
    introduced in Seipp et al. (2021) &ldquo;Weighted Expectile Regression for
    Right-Censored Data&rdquo; &lt;<a href="https://doi.org/10.1002%2Fsim.9137">doi:10.1002/sim.9137</a>&gt;, mode regression for
    time-to-event variables has been introduced in Seipp et al. (2022)
    &ldquo;Flexible Semiparametric Mode Regression for Time-to-Event Data&rdquo;
    &lt;<a href="https://doi.org/10.1177%2F09622802221122406">doi:10.1177/09622802221122406</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>expectreg(&ge; 0.5.0), R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>formula.tools, MASS, Matrix, mgcv, nloptr, provenance, rlang,
splines, survival</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-21 19:30:49 UTC; Seife</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dirttee-package'>
DIstributional Regression for Times To EvEnt
</h2><span id='topic+dirttee-package'></span><span id='topic+dirttee'></span>

<h3>Description</h3>

<p>This package includes regession methods for right-censored response variables.
It allows for the estimation of distributional regression methods with semiparametric predictors,
including, for example, nonlinear, spatial or random effects.
The distribution of the response can be estimated with expectiles, quantiles and mode regression.
Censored observations can be included with accelerated failure time models or inverse probability of censoring weights.
</p>


<h3>Author(s)</h3>

<p>Alexander Seipp, Fabian Otto-Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de/eub">https://uol.de/eub</a> <br />
</p>
<p>Maintainer: Alexander Seipp &lt;alexander.seipp@uni-oldenburg.de&gt;
</p>
<p>Special thanks for their help go to Lisa Eilers and Florian Berger!
</p>
<p>Partially funded by the German Research Foundation (DFG) grant SO1313/1-1, project 'Distributional Regression for Time-to-Event Data'.
</p>


<h3>References</h3>

<p>Seipp A, Uslar V, Weyhe D, Timmer A, Otto-Sobotka F. Weighted expectile regression for right-censored data. <em>Statistics in Medicine</em>. 2021;40(25):5501â€“5520. doi: 10.1002/sim.9137
</p>
<p>Seipp A, Uslar V, Weyhe D, Timmer A, Otto-Sobotka F. Flexible Semiparametric Mode Regression for Time-to-Event Data. <em>Statistical Methods in Medical Research</em>. 2022;31(12):2352-2367. doi: 10.1177/09622802221122406
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(colcancer)
c100 &lt;- colcancer[1:100,]

#mode regression
reg &lt;- modreg(Surv(logfollowup, death) ~ sex + LNE, data = c100)

#expectile regression
fit_exp &lt;- expectreg.aft(Surv(logfollowup, death) ~ LNE, data = c100,smooth="f")
fit_expipc &lt;- expectreg.ipc(Surv(logfollowup, death) ~ sex + LNE, data = c100)

#quantile regression
qu1 &lt;- qureg.aft(Surv(logfollowup, death) ~ sex + LNE, data=c100, smooth="fixed")




</code></pre>

<hr>
<h2 id='asynorm'>The asymmetric normal distribution.</h2><span id='topic+asynorm'></span><span id='topic+pasynorm'></span><span id='topic+rasynorm'></span><span id='topic+dasynorm'></span><span id='topic+qasynorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the asymmetric normal distribution with the parameters <code>mu</code>, <code>sigma</code> and <code>tau</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dasynorm(x, mu = 0, sigma = 1, tau = 0.5)
pasynorm(q, mu = 0, sigma = 1, tau = 0.5)
qasynorm(p, mu = 0, sigma = 1, tau = 0.5)
rasynorm(n, mu = 0, sigma = 1, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asynorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="asynorm_+3A_mu">mu</code></td>
<td>
<p>location parameter and mode of the distribution.</p>
</td></tr>
<tr><td><code id="asynorm_+3A_sigma">sigma</code></td>
<td>
<p>comparable to the standard deviation. Must be positive.</p>
</td></tr>
<tr><td><code id="asynorm_+3A_tau">tau</code></td>
<td>
<p>asymmetry parameter.</p>
</td></tr>
<tr><td><code id="asynorm_+3A_x">x</code></td>
<td>
<p>vector of locations.</p>
</td></tr>
<tr><td><code id="asynorm_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="asynorm_+3A_n">n</code></td>
<td>
<p>number of observations. If <code class="reqn">length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The asymmetric normal distribution has the following density<br />
<code class="reqn">f(x) =   (2\sqrt{\tau(1-\tau)/\pi}/\sigma)/(\sqrt{1-\tau} + \sqrt{\tau)}\exp(-|(\tau - (x &lt;= \mu))|*(x - \mu)^2/\sigma^2)</code>
The cdf is derived by integration of the distribution function by using the <code><a href="stats.html#topic+integrate">integrate</a></code> function.
</p>


<h3>Value</h3>

<p><code>dasynorm</code> gives the density, <code>pasynorm</code> gives the distribution function, <code>qasynorm</code> gives the quantile function, and <code>rasynorm</code> generates random deviates.
</p>
<p>Corresponds to the normal distribution for <code class="reqn">\tau = 0.5</code>.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rasynorm</code>, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hist(rasynorm(1000))

qg &lt;- qasynorm(0.1, 1, 2, 0.5)

pasynorm(qg, 1, 2, 0.5)

ax &lt;- c(1:1000)/100-5
plot(ax,dasynorm(ax), type = 'l')
</code></pre>

<hr>
<h2 id='boot.modreg'>Estimate confidence intervals and standard errors for the mode regression fit</h2><span id='topic+boot.modreg'></span>

<h3>Description</h3>

<p>Performs bootstrap on the modreg object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.modreg(
  reg,
  nboot,
  level = 0.95,
  newdata = NULL,
  bw = c("variable", "fixed"),
  quiet = FALSE,
  terms = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.modreg_+3A_reg">reg</code></td>
<td>
<p>an object of class modreg (output of the modreg function)</p>
</td></tr>
<tr><td><code id="boot.modreg_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="boot.modreg_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="boot.modreg_+3A_newdata">newdata</code></td>
<td>
<p>Should be a data frame containing all the variables needed for predictions. If supplied, confidence intervals are calculated for the corresponding predictions.</p>
</td></tr>
<tr><td><code id="boot.modreg_+3A_bw">bw</code></td>
<td>
<p>Either &quot;<code>variable</code>&quot; or &quot;<code>fix</code>&quot;, determining if the bandwidth of the 
original fit should be used for the bootstrap fits (<code>fix</code>) or if the bandwith 
should be recalculated (<code>variable</code>).</p>
</td></tr>
<tr><td><code id="boot.modreg_+3A_quiet">quiet</code></td>
<td>
<p>if TRUE, printing of the status is suppressed</p>
</td></tr>
<tr><td><code id="boot.modreg_+3A_terms">terms</code></td>
<td>
<p>character scalar. If supplied, uses this term for confidence intervals of the prediction</p>
</td></tr>
<tr><td><code id="boot.modreg_+3A_seed">seed</code></td>
<td>
<p>the seed to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A nonparametric residual bootstrap is performed to calculate standard errors of parameters and confidence intervals. More details can be found in Seipp et al. (2022).
<code>newdata</code> can be supplied to get confidence intervals for specific predictions. <code>terms</code> can be specified to calculate confidence interval for the contribution of one covariate (useful for P-splines).
<code>variable</code> bandwidth is the default, which has higher coverage than <code>fix</code>, but is computationally much more demanding. A <code>seed</code> can be supplied to guarantee a reproducible result.
</p>


<h3>Value</h3>

<p>a list with the following elements
</p>
<table>
<tr><td><code>confpredict</code></td>
<td>
<p>data frame, the confidence intervals for the predictions.</p>
</td></tr>
<tr><td><code>confparams</code></td>
<td>
<p>data frame, the confidence intervals and standard errors for the parametric regression coefficients.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code>na</code></td>
<td>
<p>scalar, stating the number of NA bootstrap repetitions.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>scalar, the used seed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Seipp, A., Uslar, V., Weyhe, D., Timmer, A., &amp; Otto-Sobotka, F. (2022). Flexible Semiparametric Mode Regression for Time-to-Event Data. Manuscript submitted for publication.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(colcancer)
colcancer80 &lt;- colcancer[1:80, ]

# linear mode regression
regL &lt;- modreg(Surv(logfollowup, death) ~ sex + age, data = colcancer80)

# bootstrap with a fixed bandwidth and 3 iterations, chosen to speed up the function. 
# Should in practice be much more than 3 iterations.
btL &lt;- boot.modreg(regL, 3, bw = "fixed", level = 0.9, seed = 100)

# coefficients, SE and confidence intervals
cbind(coef(regL), btL$confparams)


## confidence inverval for smooth effect / predictions

reg &lt;- modreg(Surv(logfollowup, death) ~ sex + s(age, bs = "ps"), data = colcancer80, 
              control = modreg.control(tol_opt = 10^-2, tol_opt2 = 10^-2, tol = 10^-3))
ndat &lt;- data.frame(sex = rep(colcancer80$sex[1], 200), age = seq(50, 90, length = 200))

# iterations should in practice be much more than 2!
bt &lt;- boot.modreg(reg, 2, bw = "fixed", newdata = ndat, terms = "s(age)", seed = 100)

pr &lt;- predict(reg, newdata = ndat, type = "terms", terms = "s(age)")[, 1]

plot(ndat$age, pr, ylim = c(-0.75, 1.5), type = "l", xlab = "age", ylab = "s(age)")
lines(ndat$age, bt$confpredict$lower, lty = 2)
lines(ndat$age, bt$confpredict$upper, lty = 2)




</code></pre>

<hr>
<h2 id='colcancer'>Colon Cancer Dataset</h2><span id='topic+colcancer'></span>

<h3>Description</h3>

<p>A dataset describing colon cancer patients. The data is based on real data from a hospital-based cancer registry but many
values are changed to ensure anonymity. Each row is a single case,
while the columns represent patients' health conditions and physical parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("colcancer")
</code></pre>


<h3>Format</h3>

<p>A data.frame with 546 observations with colon cancer cases. The 12 columns describe different parameters of patients' conditions.
</p>


<h3>Details</h3>

<p>The columns of the data set are:
</p>

<ul>
<li><p> followup. numeric. Follow-up time since surgery in days. The time the patient was observed.
</p>
</li>
<li><p> logfollowup. numeric. The follow-up time, but logarithmic.
</p>
</li>
<li><p> death. integer. Indicates whether the patient died. If death occured it is set to 1, otherwise 0.
</p>
</li>
<li><p> sex. factor. Level: &quot;f&quot;, &quot;m&quot;. The sex of the patient. In this case &quot;f&quot; stands for female, and &quot;m&quot; represents male patients.
</p>
</li>
<li><p> LNE. numeric. The number of examined lymph nodes.
</p>
</li>
<li><p> LNR. numeric, ranges from 0 to 1. The number of cancerous lymph nodes divided by the total number (LNE).
</p>
</li>
<li><p> pUICC. factor. Levels: &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;. Pathological cancer stage. The UICC staging system was used.
</p>
</li>
<li><p> CTX. factor. Levels: &quot;0&quot;, &quot;1&quot;. Chemotherapy (no / yes)
</p>
</li>
<li><p> ASA.score. factor. Levels: &quot;mild&quot;, &quot;severe&quot;. An ASA score smaller than 3 is considered a mild general illness, 3 or greater is considered a severe general illness. The ASA scoring system of patients was originally proposed by the American Society of Anesthesiologists. 
</p>
</li>
<li><p> R.status factor. Level: &quot;0&quot;, &quot;12&quot;. Residual tumor after surgery. 0 stands for no residual tumor. 12 stands either for microscopic (R1) or macroscopic residues (R2).
</p>
</li>
<li><p> preexisting.cancer. integer. If there was a history of cancer before the colon cancer. Set to 1 if there has been a cancer in the past and to 0 if not.
</p>
</li>
<li><p> age. numeric. The age of the patient in years.
</p>
</li></ul>


<hr>
<h2 id='expectreg.aft'>Expectile regression for right censored event times using an auxiliary likelihood</h2><span id='topic+expectreg.aft'></span><span id='topic+qureg.aft'></span>

<h3>Description</h3>

<p>Estimate a set of conditional expectiles or quantiles with semiparametric predictors
in accelerated failure time models.
For the estimation, the asymmetric loss functions are reformulated into auxiliary likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectreg.aft(
   formula,
   data = NULL,
   smooth = c("cvgrid", "aic", "bic", "lcurve", "fixed"), 
   lambda = 1, 
   expectiles = NA, ci = FALSE)

qureg.aft(
   formula, 
   data = NULL, 
   smooth = c( "cvgrid", "aic", "bic", "lcurve", "fixed"), 
   lambda = 1, 
   quantiles = NA, 
   ci = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectreg.aft_+3A_formula">formula</code></td>
<td>
<p>An R formula object consisting of the response variable, '~' and the sum of all effects that should be taken into consideration. Each semiparametric effect has to be given through the function <code><a href="expectreg.html#topic+rb">rb</a></code>. The response needs to be a call of <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="expectreg.aft_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables used in the model, if the data is not explicitely given in the formula.</p>
</td></tr>
<tr><td><code id="expectreg.aft_+3A_smooth">smooth</code></td>
<td>
<p>There are different smoothing algorithms that tune <code>lambda</code> to prevent overfitting. Caution, the currently implemented smoothing algorithms can take a long time. Cross validation is done with a grid search ('<code>cvgrid</code>'). The function can also use a supplied fixed penalty ('<code>fixed</code>'). The numerical minimisation is also possible with AIC or BIC as score ('<code>aic</code>', '<code>bic</code>'). The L-curve ('<code>lcurve</code>') is a new experimental grid search by Frasso and Eilers.</p>
</td></tr>
<tr><td><code id="expectreg.aft_+3A_lambda">lambda</code></td>
<td>
<p>The fixed penalty can be adjusted. Also serves as starting value for the smoothing algorithms.</p>
</td></tr>
<tr><td><code id="expectreg.aft_+3A_expectiles">expectiles</code></td>
<td>
<p>In default setting, the expectiles (0.01,0.02,0.05,0.1,0.2,0.5,0.8,0.9,0.95,0.98,0.99) are calculated. You may specify your own set of expectiles in a vector. The option may be set to 'density' for the calculation of a dense set of expectiles that enhances the use of <code><a href="expectreg.html#topic+cdf.qp">cdf.qp</a></code> and <code><a href="expectreg.html#topic+cdf.bundle">cdf.bundle</a></code> afterwards.</p>
</td></tr>
<tr><td><code id="expectreg.aft_+3A_ci">ci</code></td>
<td>
<p>Whether a covariance matrix for confidence intervals and a <code><a href="expectreg.html#topic+summary.expectreg">summary</a></code> is calculated.</p>
</td></tr>
<tr><td><code id="expectreg.aft_+3A_quantiles">quantiles</code></td>
<td>
<p>Quantiles for which the regression should be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For expectile regression, the LAWS loss function
</p>
<p style="text-align: center;"><code class="reqn"> S = \sum_{i=1}^{n}{ w_i(p)(y_i - \mu_i(p))^2} </code>
</p>

<p>with
</p>
<p><code class="reqn"> w_i(p) = p 1_{(y_i &gt; \mu_i(p))} + (1-p) 1_{(y_i &lt; \mu_i(p))} </code>
</p>
<p>is repackaged into the asymmetric normal distribution.
Then, an accelerated failure time model is estimated.
This function is based on the 'expectreg' package and uses the same functionality
to include semiparametric predictors.
</p>
<p>For quantile regression, the loss function is replaced with a likelihood from the asymmetric laplace distribution.
</p>


<h3>Value</h3>

<p>An object of class 'expectreg', which is basically a list consisting of:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>The final smoothing parameters for all expectiles and for all effects in a list.</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>
<p>The intercept for each expectile.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> A matrix of all the coefficients, for each base element
a row and for each expectile a column. </p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p> The fitted values for each observation and all expectiles,
separately in a list for each effect in the model,
sorted in order of ascending covariate values. </p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p> Vector of the response variable. </p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p> List with the values of the covariates. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> The formula object that was given to the function. </p>
</td></tr>
<tr><td><code>asymmetries</code></td>
<td>
<p> Vector of fitted expectile asymmetries as given by argument <code>expectiles</code>. </p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p> List of characters giving the types of covariates. </p>
</td></tr>
<tr><td><code>helper</code></td>
<td>
<p> List of additional parameters like neighbourhood structure for spatial effects or <code class="reqn">\phi</code> for kriging. </p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p> Complete design matrix. </p>
</td></tr>
<tr><td><code>bases</code></td>
<td>
<p> Bases components of each covariate. </p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> Fitted values <code class="reqn"> \hat{y} </code>. </p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p> Covariance matrix, estimated when <code>ci = TRUE</code>. </p>
</td></tr>
<tr><td><code>diag.hatma</code></td>
<td>
<p> Diagonal of the hat matrix. Used for model selection criteria. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> Original data </p>
</td></tr>
<tr><td><code>smooth_orig</code></td>
<td>
<p> Unchanged original type of smoothing. </p>
</td></tr>
</table>
<p><code><a href="expectreg.html#topic+plot.expectreg">plot</a></code>, <code><a href="expectreg.html#topic+predict.expectreg">predict</a></code>, <code><a href="expectreg.html#topic+resid.expectreg">resid</a></code>,
<code><a href="expectreg.html#topic+fitted.expectreg">fitted</a></code>, <code><a href="expectreg.html#topic+effects.expectreg">effects</a></code>
and further convenient methods are available for class 'expectreg'.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto-Sobotka <br /> Carl von Ossietzky University Oldenburg <br /> <a href="https://uol.de">https://uol.de</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectreg.ipc">expectreg.ipc</a></code>, <code><a href="expectreg.html#topic+expectreg.ls">expectreg.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(colcancer)
ex &lt;- c(0.05, 0.2, 0.5, 0.8, 0.95)
c100 &lt;- colcancer[1:100,]
exfit &lt;- expectreg.aft(Surv(logfollowup, death) ~ LNE, data = c100, expectiles = ex, smooth="f")
coef(exfit)

qu1 &lt;- qureg.aft(Surv(logfollowup, death) ~ LNE + sex, data=c100, smooth="fixed")
coef(qu1)

## Not run: 

# takes some time
qu2 &lt;- qureg.aft(Surv(logfollowup, death) ~ rb(LNE) + sex, data=colcancer[1:200,])

## End(Not run)

</code></pre>

<hr>
<h2 id='expectreg.ipc'>Expectile regression for right-censored data</h2><span id='topic+expectreg.ipc'></span>

<h3>Description</h3>

<p>This function extends expectile regression with inverse probability of censoring (IPC) weights to right-censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectreg.ipc(
  formula,
  data = NULL,
  smooth = c("schall", "ocv", "aic", "bic", "cvgrid", "lcurve", "fixed"),
  lambda = 1,
  expectiles = NA,
  LAWSmaxCores = 1,
  IPC_weights = c("IPCRR", "IPCKM"),
  KMweights = NULL,
  ci = FALSE,
  hat1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectreg.ipc_+3A_formula">formula</code></td>
<td>
<p>A formula object, with the response on the left of the &lsquo;~&rsquo;
operator, and the terms on the right.  The response must be a
<code><a href="survival.html#topic+Surv">Surv</a></code> object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> 
function. Only right censored data are allowed. Splines can be specified through the function <code><a href="expectreg.html#topic+rb">rb</a></code>.</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables used in the model, if the data is not explicitly given in the formula.</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_smooth">smooth</code></td>
<td>
<p>The smoothing method that shall be used.
There are different smoothing algorithms that should prevent overfitting. The '<code>schall</code>' algorithm balances 
variance of errors and contrasts. Ordinary cross- validation '<code>ocv</code>' minimizes a score-function using <code><a href="stats.html#topic+nlminb">nlminb</a></code> or with a grid search by '<code>cvgrid</code>'
or the function uses a fixed penalty. The numerical minimizatioin is also possible with AIC or BIC as score. 
The L-curve is an experimental grid search by Frasso and Eilers.</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_lambda">lambda</code></td>
<td>
<p>The fixed penalty can be adjusted. Also serves as starting value for the smoothing algorithms.</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_expectiles">expectiles</code></td>
<td>
<p>In default setting, the expectiles (0.01,0.02,0.05,0.1,0.2,0.5,0.8,0.9,0.95,0.98,0.99) are 
calculated. You may specify your own set of expectiles in a vector.</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_lawsmaxcores">LAWSmaxCores</code></td>
<td>
<p>How many cores should maximally be used by parallelization. Currently only implemented for Unix-like OS.</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_ipc_weights">IPC_weights</code></td>
<td>
<p>Denotes the kind of IPC weights to use. <code>IPCRR</code> weights differ from <code>IPCKM</code> weights by modifying the weights for the last observation if it is censored.</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_kmweights">KMweights</code></td>
<td>
<p>Custom IPC weights can be supplied here. This argument is used by <code><a href="#topic+modreg">modreg</a></code>.</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_ci">ci</code></td>
<td>
<p>If TRUE, calculates the covariance matrix</p>
</td></tr>
<tr><td><code id="expectreg.ipc_+3A_hat1">hat1</code></td>
<td>
<p>If TRUE, the hat matrix for the last asymetry level is calculated. This argument is mainly used by <code><a href="#topic+modreg">modreg</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits least asymmetrically weighted squares (LAWS) for each expectile. This function is intended
for right-censored data. For uncensored data, <code><a href="expectreg.html#topic+expectreg.ls">expectreg.ls</a></code> should be used instead.
This function modifies <code><a href="expectreg.html#topic+expectreg.ls">expectreg.ls</a></code> by adding IPC weights. See Seipp et al. (2021) for details on
the IPC weights. P-splines can be used with <code><a href="expectreg.html#topic+rb">rb</a></code>. The Schall algorithm is used for choosing the penalty.
</p>


<h3>Value</h3>

<p>A list with the following elements.
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>The final smoothing parameters for all expectiles and for all effects in a list.</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>
<p>The intercept for each expectile.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A matrix of all the coefficients, for each base element a row and for each expectile a column.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>The fitted values for each observation and all expectiles, separately in a list for each effect in the model, sorted in order of ascending covariate values.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>Vector of the response variable.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>List with the values of the covariates.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula object that was given to the function.</p>
</td></tr>
<tr><td><code>asymmetries</code></td>
<td>
<p>Vector of fitted expectile asymmetries as given by argument <code>expectiles</code>.</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p>List of characters giving the types of covariates.</p>
</td></tr>
<tr><td><code>helper</code></td>
<td>
<p>List of additional parameters like neighbourhood structure for spatial effects or <code class="reqn">\phi</code> for kriging.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>Complete design matrix.</p>
</td></tr>
<tr><td><code>bases</code></td>
<td>
<p>Bases components of each covariate.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values.</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code>diag.hatma</code></td>
<td>
<p>Diagonal of the hat matrix. Used for model selection criteria.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Original data.</p>
</td></tr>
<tr><td><code>smooth_orig</code></td>
<td>
<p>Unchanged original type of smoothing.</p>
</td></tr>
<tr><td><code>KMweights</code></td>
<td>
<p>Vector with IPC weights used in fitting.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>Area under the AIC, approximated with a Riemannian sum.</p>
</td></tr>
<tr><td><code>hat</code></td>
<td>
<p>The hat matrix for the last asymmetry level. This is used by <code><a href="#topic+modreg">modreg</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Seipp, A, Uslar, V, Weyhe, D, Timmer, A, Otto-Sobotka, F. Weighted expectile regression for right-censored data. Statistics in Medicine. 2021; 40(25): 5501- 5520. https://doi.org/10.1002/sim.9137
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(colcancer)

# linear effect
expreg &lt;- expectreg.ipc(Surv(logfollowup, death) ~ sex + age, data = colcancer, 
                        expectiles = c(0.05, 0.2, 0.5, 0.8, 0.95))
coef(expreg)


# with p-splines, smoothing parameter selection with schall algorithm
expreg2 &lt;- expectreg.ipc(Surv(logfollowup, death) ~ sex + rb(age), data = colcancer)
# smoothing parameter selection with AIC
expreg3 &lt;- expectreg.ipc(Surv(logfollowup, death) ~ sex + rb(age), data = colcancer, smooth = "aic")
# manually selected smoothing parameter
expreg4 &lt;- expectreg.ipc(Surv(logfollowup, death) ~ sex + rb(age), data = colcancer, 
                         smooth = "fixed", lambda = 2)

plot(expreg2)
plot(expreg3)
plot(expreg4)




</code></pre>

<hr>
<h2 id='gumbel'>The Gumbel Distribution.</h2><span id='topic+gumbel'></span><span id='topic+pgumbel'></span><span id='topic+rgumbel'></span><span id='topic+dgumbel'></span><span id='topic+qgumbel'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the gumbel distribution with the two parameters <code>location</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgumbel(x, location = 0, scale = 1)
pgumbel(q, location = 0, scale = 1)
qgumbel(p, location = 0, scale = 1)
rgumbel(n, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gumbel_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_location">location</code></td>
<td>
<p>location parameter and mode of the distribution.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_scale">scale</code></td>
<td>
<p>scaling parameter, has to be positive.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_x">x</code></td>
<td>
<p>vector of locations.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_n">n</code></td>
<td>
<p>number of observations. If <code class="reqn">length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gumbel distribution has the following density and cdf <br />
<code class="reqn">f(x) = (1/scale)*exp((x - location)/scale - exp((x - location)/scale))</code>,
<code class="reqn">F(x) = 1 - exp(- exp((x - location)/scale))</code>.
The mode of the distribution is <code>location</code>, the variance is <code class="reqn">\pi^{2/6} * \code{scale}</code>.
</p>


<h3>Value</h3>

<p><code>dgumbel</code> gives the density, <code>pgumbel</code> gives the distribution function, <code>qgumbel</code> gives the quantile function, and <code>rgumbel</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rgumbel</code>, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the result.
</p>


<h3>References</h3>

<p>Collett, D. (2015). Modelling survival data in medical research, chapter 6. CRC press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hist(rgumbel(1000))

qg &lt;- qgumbel(0.1, 1, 2)

pgumbel(qg, 1, 2)

ax &lt;- c(1:1000)/100-5
plot(ax,dgumbel(ax), type = 'l')

</code></pre>

<hr>
<h2 id='methods'>Methods for fitted modreg model</h2><span id='topic+methods'></span><span id='topic+coefficients.modreg'></span><span id='topic+coef.modreg'></span><span id='topic+print.modreg'></span><span id='topic+summary.modreg'></span><span id='topic+print.summary.modreg'></span>

<h3>Description</h3>

<p>Methods for <code>modreg</code> objects returned by the mode regression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modreg'
coefficients(object, ...)

## S3 method for class 'modreg'
coef(object, ...)

## S3 method for class 'modreg'
print(x, ...)

## S3 method for class 'modreg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="methods_+3A_x">x</code>, <code id="methods_+3A_object">object</code></td>
<td>
<p>A modreg object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coef</code> returns a named numerical vector with coefficients
</p>

<hr>
<h2 id='modreg'>Mode-regression for right-censored data</h2><span id='topic+modreg'></span>

<h3>Description</h3>

<p>This function implements semiparametric kernel-based mode regression for right-censored or full data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modreg(
  formula,
  data = NULL,
  bw = c("Pseudo", "Plugin"),
  lambda = NULL,
  KMweights = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modreg_+3A_formula">formula</code></td>
<td>
<p>A formula object, with the response on the left of the &lsquo;~&rsquo;
operator, and the terms on the right.  The response must be a
<code>Surv</code> object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code>
function. Only right censored data are allowed.</p>
</td></tr>
<tr><td><code id="modreg_+3A_data">data</code></td>
<td>
<p>A data set on which the regression should be performed on.
It should consist of columns that have the names of the specific variables
defined in <code>formula</code>. If <code>NULL</code>, the function will look for the
data in the environment given by the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="modreg_+3A_bw">bw</code></td>
<td>
<p>String, either &quot;<code>Pseudo</code>&quot;, &quot;<code>Plugin</code>&quot; or a fixed numerical value. This determines how
bandwidth should be estimated. &quot;<code>Plugin</code>&quot; only recommended for uncensored linear mode regression.</p>
</td></tr>
<tr><td><code id="modreg_+3A_lambda">lambda</code></td>
<td>
<p>Penalty term for penalized splines. Will be estimated if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="modreg_+3A_kmweights">KMweights</code></td>
<td>
<p>numerical vector, should be the same length as the response. Inverse probability of censoring weights can be provided here. They will be calculated if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="modreg_+3A_control">control</code></td>
<td>
<p>A call to <code><a href="boot.html#topic+control">control</a></code>. Various control parameters can be supplied here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits mode regression in an iteratively weighted least squares approach. A detailed description of
the approach and algorithm can be found in Seipp et al. (2022). In short, kernel-based mode regression leads
to minimization of weighted least squares, if the normal kernel is assumed. We use gam for estimation in each iteration.
Mode regression is extended to right-censored time-to event data with inverse probability of censoring weights.
Hyperparameters (bandwidth, penalty) are determined with a pseudo-likelihood approach for <code>bw = "Pseudo"</code>.
For &quot;Plugin&quot;, plug-in bandwidth selection is performed, as described in Yao and Li (2014). However, this is only justified for uncensored data
and mode regression with linear covariate trends or known transformations.
</p>
<p>The event time has to be supplied using the <code><a href="survival.html#topic+Surv">Surv</a></code> function. Positive event times with multiplicative relationships should be logarithmized
beforehand. Nonlinear trends can be estimated with P-splines, indicated by using <code><a href="mgcv.html#topic+s">s</a>(covariate, bs = "ps")</code>. This will be passed down to gam, which is why
the same notation is used. Other smooth terms are not tested yet. The whole gam object will be returned but standard errors and other information are not
valid. <code><a href="#topic+boot.modreg">boot.modreg</a></code> can be used for calculation of standard errors and confidence intervals.
</p>


<h3>Value</h3>

<p>This function returns a list with the following properties:
</p>
<table>
<tr><td><code>reg</code></td>
<td>
<p>object of class <a href="mgcv.html#topic+gam">gam</a>. Should be interpreted with care.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>The used bandwidth.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. Whether or not the iteratively weighted least squares algorithm converged.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations of the final weighted least squares fit</p>
</td></tr>
<tr><td><code>cova</code></td>
<td>
<p>Covariance matrix. Only supplied in case of linear terms and plug-in bandwidth.</p>
</td></tr>
<tr><td><code>KMweights</code></td>
<td>
<p>double vector. Weights used.</p>
</td></tr>
<tr><td><code>called</code></td>
<td>
<p>list. The arguments that were provided.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>Pseudo AIC.</p>
</td></tr>
<tr><td><code>pseudologlik</code></td>
<td>
<p>Pseudo log-likelihood.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Effective degrees of freedom</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>vector. Indicating whether an event has occured (1) or not (0) in the input data.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>vector with response values</p>
</td></tr>
<tr><td><code>hp_opt</code></td>
<td>
<p>Summary of hyperparameter estimation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Seipp, A., Uslar, V., Weyhe, D., Timmer, A., &amp; Otto-Sobotka, F. (2022). Flexible Semiparametric Mode Regression for Time-to-Event Data. Manuscript submitted for publication.<br />
Yao, W., &amp; Li, L. (2014). A new regression model: modal linear regression. Scandinavian Journal of Statistics, 41(3), 656-671.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(colcancer)
colcancer80 &lt;- colcancer[1:80, ]

# linear trend
regL &lt;- modreg(Surv(logfollowup, death) ~ sex + age, data = colcancer80)
summary(regL)

# mode regression with P-splines. Convergence criteria are changed to speed up the function
reg &lt;- modreg(Surv(logfollowup, death) ~ sex + s(age, bs = "ps"), data = colcancer80, 
control = modreg.control(tol_opt = 10^-2, tol_opt2 = 10^-2, tol = 10^-3))
summary(reg)
plot(reg)

# with a fixed penalty
reg2 &lt;- modreg(Surv(logfollowup, death) ~ sex + s(age, bs = "ps"), data = colcancer80, lambda = 0.1)

# for linear effects and uncensored data, we can use the plug-in bandwidth
regP &lt;- modreg(age ~ sex, data = colcancer, bw = "Plugin")



</code></pre>

<hr>
<h2 id='modreg.control'>Setting fitting values for <code><a href="#topic+modreg">modreg</a></code>.</h2><span id='topic+modreg.control'></span>

<h3>Description</h3>

<p>This is an internal function of package <code>dirttee</code> which allows control of the numerical options 
for fitting mode regression. Typically, users will want to modify the defaults if model fitting 
is slow or fails to converge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modreg.control(
  StartInterval = sqrt(3),
  nStart = 11,
  nInterim = NULL,
  maxit = 100,
  itInterim = 10,
  tol = 10^-4,
  tol_bw_plugin = 10^-3,
  maxit_bw_plugin = 10,
  maxit_penalty_plugin = 10,
  tol_penalty_plugin = 10^-3,
  tol_regopt = tol * 100,
  tol_opt = 10^-3,
  maxit_opt = 200,
  tol_opt2 = 10^-3,
  maxit_opt2 = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modreg.control_+3A_startinterval">StartInterval</code></td>
<td>
<p>Starting values are based on an estimate for the mean and an interval around it. The interval is <code class="reqn">+-\code{StartInterval} * \sigma</code>. Default is  <code class="reqn">\sqrt{3}</code>.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_nstart">nStart</code></td>
<td>
<p>Number of starting values, considered in the first iteration. Default is 11.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_ninterim">nInterim</code></td>
<td>
<p>Probably has little impact on speed and result. After <code>itInterim</code> weighted least squares iterations, the number of estimates is reduced from <code>nStart</code> to <code>nInterim</code> estimates. Default is 5.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for the weighted least squares algorithm. Default is 100.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_itinterim">itInterim</code></td>
<td>
<p>Probably has little impact on speed and result. After <code>itInterim</code> weighted least squares iterations, the number of estimates is reduced from <code>nStart</code> to <code>nInterim</code> estimates. Default is 10.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_tol">tol</code></td>
<td>
<p>Convergence criterion for the weighted least squares algorithm. Default is 10^-4.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_tol_bw_plugin">tol_bw_plugin</code></td>
<td>
<p>Convergence criterion for bandwidth selection in the <code>"Plugin"</code> method. Default is 10^-3.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_maxit_bw_plugin">maxit_bw_plugin</code></td>
<td>
<p>Maximum number of iterations for bandwidth selection in the <code>"Plugin"</code> method. Default is 10.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_maxit_penalty_plugin">maxit_penalty_plugin</code></td>
<td>
<p>Maximum number of iterations for penalty selection in the <code>"Plugin"</code> method. Default is 10.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_tol_penalty_plugin">tol_penalty_plugin</code></td>
<td>
<p>Convergence criterion for penalty selection in the <code>"Plugin"</code> method. Default is 10^-3.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_tol_regopt">tol_regopt</code></td>
<td>
<p>Weighted least squares are recalculated for hyperparameter optimization. This is the convergence criterion within this optimization. Default is <code>tol</code> * 100.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_tol_opt">tol_opt</code></td>
<td>
<p>Convergence criterion for the first hyperparameter optimizion. Can be increased to reduce compuation time. Default is 10^-3.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_maxit_opt">maxit_opt</code></td>
<td>
<p>Maximum number of iterations for the first hyperparameter optimizion. Can be lowered to reduce compuation time. Default is 200.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_tol_opt2">tol_opt2</code></td>
<td>
<p>Convergence criterion for the second hyperparameter optimizion. Default is 10^-3.</p>
</td></tr>
<tr><td><code id="modreg.control_+3A_maxit_opt2">maxit_opt2</code></td>
<td>
<p>Maximum number of iterations for the second hyperparameter optimizion. Default is 200.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is described in Seipp et al. (2022). To increase the speed of the algorithm, adapting <code>tol</code> and <code>maxit_opt</code>/<code>maxit_opt2</code> and other penalty / hyperparameter optimization parameters are a good starting point.
</p>


<h3>Value</h3>

<p>A list with the arguments as components
</p>


<h3>References</h3>

<p>Seipp, A., Uslar, V., Weyhe, D., Timmer, A., &amp; Otto-Sobotka, F. (2022). Flexible Semiparametric Mode Regression for Time-to-Event Data. Manuscript submitted for publication. <br />
Yao, W., &amp; Li, L. (2014). A new regression model: modal linear regression. Scandinavian Journal of Statistics, 41(3), 656-671.
</p>

<hr>
<h2 id='plot.modreg'>Plot regression terms for modreg objects</h2><span id='topic+plot.modreg'></span>

<h3>Description</h3>

<p>Plots smooth components of a fitted modreg object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modreg'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.modreg_+3A_x">x</code></td>
<td>
<p>The object to plot, must be of class modreg.</p>
</td></tr>
<tr><td><code id="plot.modreg_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>. It displays term plots of smoothed variables. Optionally produces term plots for parametric model components as well. Standard errors will not be displayed but can be estimated by <code>boot_modreg</code>.
</p>


<h3>Value</h3>

<p>The functions main purpose is its side effect of generating plots. It also silently returns a list of the data used to produce the plots, which can be used to generate customized plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(colcancer)
# mode regression with P-splines. Convergence criteria are changed to speed up the function
reg &lt;- modreg(Surv(logfollowup, death) ~ sex + s(age, bs = "ps"), data = colcancer[1:70, ], 
control = modreg.control(tol_opt = 10^-2, tol_opt2 = 10^-2, tol = 10^-3))
plot(reg)


</code></pre>

<hr>
<h2 id='predict.modreg'>Prediction from a fitted modreg model</h2><span id='topic+predict.modreg'></span>

<h3>Description</h3>

<p>Takes a fitted modreg object produced by <code>modreg</code> and produces predictions. New sets of covariates can by supplied through <code>newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modreg'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.modreg_+3A_object">object</code></td>
<td>
<p>The object to plot, must be of class modreg.</p>
</td></tr>
<tr><td><code id="predict.modreg_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>.
</p>


<h3>Value</h3>

<p>A vector or matrix of predictions. For <code>type = "terms"</code> this is a matrix with a column per term.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(colcancer)
colcancer70 &lt;- colcancer[1:70, ]

mc &lt;- modreg.control(tol_opt = 10^-2, tol_opt2 = 10^-2, 
tol = 10^-3)
reg &lt;- modreg(Surv(logfollowup, death) ~ sex + s(age, bs = "ps"), data = 
colcancer70, control = mc)
ndat &lt;- data.frame(sex = rep(colcancer70$sex[1], 200), age = seq(50, 90, length = 200))
pr &lt;- predict(reg, newdata = ndat)


</code></pre>

<hr>
<h2 id='weightsKM'>Inverse probability of censoring weights</h2><span id='topic+weightsKM'></span>

<h3>Description</h3>

<p>Computes inverse probability of censoring weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightsKM(y, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightsKM_+3A_y">y</code></td>
<td>
<p>numerical vector with right-censored follow-up times</p>
</td></tr>
<tr><td><code id="weightsKM_+3A_delta">delta</code></td>
<td>
<p>numerical vector, same length as y, 1 indicates an event while 0 indicates censoring</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inverse probability of censoring weights are calculated by dividing the event indicator by the Kaplan-Meier estimator of the censoring time.
This leads to zero weights for censored observations, while every uncensored event receives a weight larger than 1, representing several censored observations.
In the redistribute-to-the-right approach, the last observation always receives a positive weight such that no weight will be lost.
Further details can be found in Seipp et al. (2021).
</p>


<h3>Value</h3>

<p>A data frame with 2 coloumns. The first column consists of usual inverse probability of censoring weights. For the second column, IPC weights modified in a redistribute-to-the-right approach are given.
</p>


<h3>References</h3>

<p>Seipp, A., Uslar, V., Weyhe, D., Timmer, A., &amp; Otto-Sobotka, F. (2021). Weighted expectile regression for right-censored data. Statistics in Medicine, 40(25), 5501-5520.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colcancer)
kw &lt;- weightsKM(colcancer$logfollowup, colcancer$death)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
