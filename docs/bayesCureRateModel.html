<!DOCTYPE html><html lang="en"><head><title>Help for package bayesCureRateModel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesCureRateModel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesCureRateModel-package'>
<p>Bayesian Cure Rate Modeling for Time-to-Event Data</p></a></li>
<li><a href='#complete_log_likelihood_general'>
<p>Logarithm of the complete log-likelihood for the general cure rate model.</p></a></li>
<li><a href='#compute_fdr_tpr'>
<p>Compute the achieved FDR and TPR</p></a></li>
<li><a href='#cure_rate_MC3'>
<p>Main function of the package</p></a></li>
<li><a href='#cure_rate_mcmc'>
<p>The basic MCMC scheme.</p></a></li>
<li><a href='#log_dagum'>
<p>PDF and CDF of the Dagum distribution</p></a></li>
<li><a href='#log_gamma'>
<p>PDF and CDF of the Gamma distribution</p></a></li>
<li><a href='#log_gamma_mixture'>
<p>PDF and CDF of a Gamma mixture distribution</p></a></li>
<li><a href='#log_gompertz'>
<p>PDF and CDF of the Gompertz distribution</p></a></li>
<li><a href='#log_logLogistic'>
<p>PDF and CDF of the log-Logistic distribution.</p></a></li>
<li><a href='#log_lomax'>
<p>PDF and CDF of the Lomax distribution</p></a></li>
<li><a href='#log_user_mixture'>
<p>Define a finite mixture of a given family of distributions.</p></a></li>
<li><a href='#log_weibull'>
<p>PDF and CDF of the Weibull distribution</p></a></li>
<li><a href='#logLik.bayesCureModel'>
<p>Extract the log-likelihood.</p></a></li>
<li><a href='#marriage_dataset'><p>Marriage data</p></a></li>
<li><a href='#plot.bayesCureModel'>
<p>Plot method</p></a></li>
<li><a href='#plot.predict_bayesCureModel'>
<p>Plot method</p></a></li>
<li><a href='#predict.bayesCureModel'>
<p>Predict method.</p></a></li>
<li><a href='#print.bayesCureModel'>
<p>Print method</p></a></li>
<li><a href='#print.predict_bayesCureModel'>
<p>Print method for the <code>predict</code> object</p></a></li>
<li><a href='#print.summary_bayesCureModel'>
<p>Print method for the summary</p></a></li>
<li><a href='#residuals.bayesCureModel'>
<p>Computation of residuals.</p></a></li>
<li><a href='#sim_mix_data'><p>Simulated dataset</p></a></li>
<li><a href='#summary.bayesCureModel'>
<p>Summary method.</p></a></li>
<li><a href='#summary.predict_bayesCureModel'>
<p>Summary method for predictions.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Cure Rate Modeling for Time-to-Event Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Panagiotis Papastamoulis &lt;papapast@yahoo.gr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A fully Bayesian approach in order to estimate a general family of cure rate models under the presence of covariates, see Papastamoulis and Milienos (2024) &lt;<a href="https://doi.org/10.1007%2Fs11749-024-00942-w">doi:10.1007/s11749-024-00942-w</a>&gt;. The promotion time can be modelled (a) parametrically using typical distributional assumptions for time to event data (including the Weibull, Exponential, Gompertz, log-Logistic distributions), or (b) semiparametrically using finite mixtures of distributions. In both cases, user-defined families of distributions are allowed under some specific requirements. Posterior inference is carried out by constructing a Metropolis-coupled Markov chain Monte Carlo (MCMC) sampler, which combines Gibbs sampling for the latent cure indicators and Metropolis-Hastings steps with Langevin diffusion dynamics for parameter updates. The main MCMC algorithm is embedded within a parallel tempering scheme by considering heated versions of the target posterior distribution.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mqbssppe/Bayesian_cure_rate_model">https://github.com/mqbssppe/Bayesian_cure_rate_model</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.12), survival, doParallel, parallel, foreach,
mclust, coda, HDInterval, VGAM, calculus, flexsurv</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-03 20:27:21 UTC; panagiotis</td>
</tr>
<tr>
<td>Author:</td>
<td>Panagiotis Papastamoulis
    <a href="https://orcid.org/0000-0001-9468-7613"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Fotios Milienos <a href="https://orcid.org/0000-0003-1423-7132"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-03 23:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesCureRateModel-package'>
Bayesian Cure Rate Modeling for Time-to-Event Data
</h2><span id='topic+bayesCureRateModel-package'></span><span id='topic+bayesCureRateModel'></span>

<h3>Description</h3>

<p>A fully Bayesian approach in order to estimate a general family of cure rate models under the presence of covariates, see Papastamoulis and Milienos (2024) &lt;doi:10.1007/s11749-024-00942-w&gt;. The promotion time can be modelled (a) parametrically using typical distributional assumptions for time to event data (including the Weibull, Exponential, Gompertz, log-Logistic distributions), or (b) semiparametrically using finite mixtures of distributions. In both cases, user-defined families of distributions are allowed under some specific requirements. Posterior inference is carried out by constructing a Metropolis-coupled Markov chain Monte Carlo (MCMC) sampler, which combines Gibbs sampling for the latent cure indicators and Metropolis-Hastings steps with Langevin diffusion dynamics for parameter updates. The main MCMC algorithm is embedded within a parallel tempering scheme by considering heated versions of the target posterior distribution.
</p>
<p>The main function of the package is <code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code>. See details for a brief description of the model.
</p>


<h3>Details</h3>

<p>Let <code class="reqn">\boldsymbol{y} = (y_1,\ldots,y_n)</code> denote the observed data, which correspond to time-to-event data or censoring times. Let also <code class="reqn">\boldsymbol{x}_i = (x_{i1},\ldots,x_{x_{ip}})'</code> denote the covariates for subject <code class="reqn">i</code>, <code class="reqn">i=1,\ldots,n</code>. 
</p>
<p>Assuming that the <code class="reqn">n</code> observations are independent, the observed likelihood is defined as
</p>
<p style="text-align: center;"><code class="reqn">
L=L({\boldsymbol \theta}; {\boldsymbol y}, {\boldsymbol x})=\prod_{i=1}^{n}f_P(y_i;{\boldsymbol\theta},{\boldsymbol x}_i)^{\delta_i}S_P(y_i;{\boldsymbol \theta},{\boldsymbol x}_i)^{1-\delta_i},
</code>
</p>

<p>where <code class="reqn">\delta_i=1</code> if the <code class="reqn">i</code>-th observation corresponds to time-to-event while <code class="reqn">\delta_i=0</code> indicates censoring time. The parameter vector <code class="reqn">\boldsymbol\theta</code> is decomposed as 
</p>
<p style="text-align: center;"><code class="reqn">
\boldsymbol\theta = (\boldsymbol\alpha', \boldsymbol\beta', \gamma,\lambda)
</code>
</p>

<p>where 
</p>

<ul>
<li> <p><code class="reqn">\boldsymbol\alpha = (\alpha_1,\ldots,\alpha_d)'\in\mathcal A</code> are the parameters of the promotion time distribution whose cumulative distribution and density functions are denoted as <code class="reqn">F(\cdot,\boldsymbol\alpha)</code> and <code class="reqn">f(\cdot,\boldsymbol\alpha)</code>, respectively. 
</p>
</li>
<li> <p><code class="reqn">\boldsymbol\beta\in\mathbf R^{k}</code> are the regression coefficients with <code class="reqn">k</code> denoting the number of columns in the design matrix (it may include a constant term or not).
</p>
</li>
<li> <p><code class="reqn">\gamma\in\mathbf R</code>
</p>
</li>
<li> <p><code class="reqn">\lambda &gt; 0</code>. 
</p>
</li></ul>

<p>The population survival and density functions are defined as
</p>
<p style="text-align: center;"><code class="reqn">S_P(y;\boldsymbol\theta) = \left(1 + \gamma\exp\{\boldsymbol{x}_i\boldsymbol{\beta}'\}c^{\gamma\exp\{\boldsymbol{x}_i\boldsymbol{\beta}'\}}F(y;\boldsymbol\alpha)^\lambda\right)^{-1/\gamma}</code>
</p>

<p>whereas,
</p>
<p style="text-align: center;"><code class="reqn">f_P(y;\boldsymbol\theta)=-\frac{\partial S_P(y;\boldsymbol\theta)}{\partial y}.</code>
</p>

<p>Finally, the cure rate is affected through covariates and parameters as follows
</p>
<p style="text-align: center;"><code class="reqn">p_0(\boldsymbol{x}_i;\boldsymbol{\theta}) = \left(1 + \gamma\exp\{\boldsymbol{x}_i\boldsymbol{\beta}'\}c^{\gamma\exp\{\boldsymbol{x}_i\boldsymbol{\beta}'\}}\right)^{-1/\gamma}</code>
</p>

<p>where <code class="reqn">c = e^{e^{-1}}</code>.
</p>
<p>The promotion time distribution can be a member of standard families (currently available are the following: Exponential, Weibull, Gamma, Lomax, Gompertz, log-Logistic) and in this case <code class="reqn">\alpha = (\alpha_1,\alpha_2)\in (0,\infty)^2</code>. Also considered is the Dagum distribution, which has three parameters <code class="reqn">(\alpha_1,\alpha_2,\alpha_3)\in(0,\infty)^3</code>. In case that the previous parametric assumptions are not justified, the promotion time can belong to the more flexible family of finite mixtures of Gamma distributions. For example, assume a mixture of two Gamma distributions of the form
</p>
<p style="text-align: center;"><code class="reqn">
f(y;\boldsymbol \alpha) = \alpha_5 f_{\mathcal G}(y;\alpha_1,\alpha_3) + (1-\alpha_5) f_{\mathcal G}(y;\alpha_2,\alpha_4),
</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">f_\mathcal{G}(y;\alpha,\beta)=\frac{\beta^{\alpha}}{\Gamma(\alpha)}y^{\alpha-1}\exp\{-\beta y\}, y&gt;0</code>
</p>
<p> denotes the density of the Gamma distribution with parameters <code class="reqn">\alpha &gt; 0</code> (shape) and  <code class="reqn">\beta &gt; 0</code> (rate).
For the previous model, the parameter vector is </p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\alpha = (\alpha_1,\alpha_2,\alpha_3,\alpha_4,\alpha_5)'\in\mathcal A</code>
</p>

<p>where <code class="reqn">\mathcal A = (0,\infty)^4\times (0,1)</code>. 
</p>
<p>More generally, one can fit a mixture of <code class="reqn">K&gt;2</code> Gamma distributions. The appropriate model can be selected according to information criteria such as the BIC.
</p>
<p>The binary vector <code class="reqn">\boldsymbol{I} = (I_1,\ldots,I_n)</code> contains the (latent) cure indicators, that is, <code class="reqn">I_i = 1</code> if the <code class="reqn">i</code>-th subject is susceptible and <code class="reqn">I_i = 0</code> if the <code class="reqn">i</code>-th subject is cured.  <code class="reqn">\Delta_0</code> denotes the subset of <code class="reqn">\{1,\ldots,n\}</code> containing the censored subjects, whereas <code class="reqn">\Delta_1 = \Delta_0^c</code> is the (complementary) subset of uncensored subjects. The complete likelihood of the model is 
</p>
<p style="text-align: center;"><code class="reqn">L_c(\boldsymbol{\theta};\boldsymbol{y}, \boldsymbol{I}) = \prod_{i\in\Delta_1}(1-p_0(\boldsymbol{x}_i,\boldsymbol\theta))f_U(y_i;\boldsymbol\theta,\boldsymbol{x}_i)\\
\prod_{i\in\Delta_0}p_0(\boldsymbol{x}_i,\boldsymbol\theta)^{1-I_i}\{(1-p_0(\boldsymbol{x}_i,\boldsymbol\theta))S_U(y_i;\boldsymbol\theta,\boldsymbol{x}_i)\}^{I_i}.</code>
</p>

<p><code class="reqn">f_U</code> and <code class="reqn">S_U</code> denote the probability density and survival function of the susceptibles, respectively, that is
</p>
<p style="text-align: center;"><code class="reqn">
S_U(y_i;\boldsymbol\theta,{\boldsymbol x}_i)=\frac{S_P(y_i;\boldsymbol{\theta},{\boldsymbol x}_i)-p_0({\boldsymbol x}_i;\boldsymbol\theta)}{1-p_0({\boldsymbol x}_i;\boldsymbol\theta)}, f_U(y_i;\boldsymbol\theta,{\boldsymbol x}_i)=\frac{f_P(y_i;\boldsymbol\theta,{\boldsymbol x}_i)}{1-p_0({\boldsymbol x}_i;\boldsymbol\theta)}.</code>
</p>


<p>Index of help topics:
</p>
<pre>
bayesCureRateModel-package
                        Bayesian Cure Rate Modeling for Time-to-Event
                        Data
complete_log_likelihood_general
                        Logarithm of the complete log-likelihood for
                        the general cure rate model.
compute_fdr_tpr         Compute the achieved FDR and TPR
cure_rate_MC3           Main function of the package
cure_rate_mcmc          The basic MCMC scheme.
logLik.bayesCureModel   Extract the log-likelihood.
log_dagum               PDF and CDF of the Dagum distribution
log_gamma               PDF and CDF of the Gamma distribution
log_gamma_mixture       PDF and CDF of a Gamma mixture distribution
log_gompertz            PDF and CDF of the Gompertz distribution
log_logLogistic         PDF and CDF of the log-Logistic distribution.
log_lomax               PDF and CDF of the Lomax distribution
log_user_mixture        Define a finite mixture of a given family of
                        distributions.
log_weibull             PDF and CDF of the Weibull distribution
marriage_dataset        Marriage data
plot.bayesCureModel     Plot method
plot.predict_bayesCureModel
                        Plot method
predict.bayesCureModel
                        Predict method.
print.bayesCureModel    Print method
print.predict_bayesCureModel
                        Print method for the 'predict' object
print.summary_bayesCureModel
                        Print method for the summary
residuals.bayesCureModel
                        Computation of residuals.
sim_mix_data            Simulated dataset
summary.bayesCureModel
                        Summary method.
summary.predict_bayesCureModel
                        Summary method for predictions.
</pre>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis and Fotios S. Milienos
</p>
<p>Maintainer: Panagiotis Papastamoulis &lt;papapast@yahoo.gr&gt;
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2024). Bayesian inference and cure rate modeling for event history data. TEST doi: 10.1007/s11749-024-00942-w.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TOY EXAMPLE (very small numbers... only for CRAN check purposes)
# simulate toy data 
	set.seed(10)
        n = 4
        # censoring indicators
        stat = rbinom(n, size = 1, prob = 0.5)
        # covariates
        x &lt;- matrix(rnorm(2*n), n, 2)
        # observed response variable 
        y &lt;- rexp(n)
#	define a data frame with the response and the covariates        
        my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
# run a weibull model with default prior setup
# considering 2 heated chains 
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, 
		data = my_data_frame, 
		promotion_time = list(distribution = 'weibull'),
		nChains = 2, 
		nCores = 1, 
		mcmc_cycles = 3, sweep=2)
#	print method
	fit1	
# 	summary method	
	summary1 &lt;- summary(fit1)
	
# WARNING: the following parameters
#  mcmc_cycles, nChains
#        should take _larger_ values. E.g. a typical implementation consists of:
#        mcmc_cycles = 15000, nChains = 12
	

</code></pre>

<hr>
<h2 id='complete_log_likelihood_general'>
Logarithm of the complete log-likelihood for the general cure rate model. 
</h2><span id='topic+complete_log_likelihood_general'></span>

<h3>Description</h3>

<p>Compute the logarithm of the complete likelihood, given a realization of the latent binary vector of cure indicators <code>I_sim</code> and current values of the model parameters <code>g</code>, <code>lambda</code>, <code>b</code> and promotion time parameters (<code class="reqn">\boldsymbol\alpha</code>) which yield log-density values (one per observation) stored to the vector <code>log_f</code> and log-cdf values stored to the vector <code>log_F</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_log_likelihood_general(y, X, Censoring_status, 
	g, lambda, log_f, log_F, b, I_sim, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complete_log_likelihood_general_+3A_y">y</code></td>
<td>

<p>observed data (time-to-event or censored time)
</p>
</td></tr>
<tr><td><code id="complete_log_likelihood_general_+3A_x">X</code></td>
<td>

<p>design matrix. Should contain a column of 1's if the model has a constant term. 
</p>
</td></tr>
<tr><td><code id="complete_log_likelihood_general_+3A_censoring_status">Censoring_status</code></td>
<td>

<p>binary variables corresponding to time-to-event and censoring.
</p>
</td></tr>
<tr><td><code id="complete_log_likelihood_general_+3A_g">g</code></td>
<td>
<p>The <code class="reqn">\gamma</code> parameter of the model (real). </p>
</td></tr>
<tr><td><code id="complete_log_likelihood_general_+3A_lambda">lambda</code></td>
<td>
<p>The <code class="reqn">\lambda</code> parameter of the model (positive). </p>
</td></tr>  
<tr><td><code id="complete_log_likelihood_general_+3A_log_f">log_f</code></td>
<td>
<p>A vector containing the natural logarithm of the density function of the promotion time distribution per observation, for the current set of parameters. Its length should be equal to the sample size.</p>
</td></tr>
<tr><td><code id="complete_log_likelihood_general_+3A_log_f">log_F</code></td>
<td>
<p>A vector containing the natural logarithm of the cumulative density function of the promotion time distribution per observation, for the current set of parameters. Its length should be equal to the sample size.</p>
</td></tr>
<tr><td><code id="complete_log_likelihood_general_+3A_b">b</code></td>
<td>
<p>Vector of regression coefficients. Its length should be equal to the number of columns of the design matrix.</p>
</td></tr>
<tr><td><code id="complete_log_likelihood_general_+3A_i_sim">I_sim</code></td>
<td>
<p>Binary vector of the current value of the latent cured status per observation. Its length should be equal to the sample size. A time-to-event cannot be cured.</p>
</td></tr>
<tr><td><code id="complete_log_likelihood_general_+3A_alpha">alpha</code></td>
<td>
<p>A parameter between 0 and 1, corresponding to the temperature of the complete posterior distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The complete likelihood of the model is 
</p>
<p style="text-align: center;"><code class="reqn">L_c(\boldsymbol{\theta};\boldsymbol{y}, \boldsymbol{I}) = \prod_{i\in\Delta_1}(1-p_0(\boldsymbol{x}_i,\boldsymbol\theta))f_U(y_i;\boldsymbol\theta,\boldsymbol{x}_i)\\
\prod_{i\in\Delta_0}p_0(\boldsymbol{x}_i,\boldsymbol\theta)^{1-I_i}\{(1-p_0(\boldsymbol{x}_i,\boldsymbol\theta))S_U(y_i;\boldsymbol\theta,\boldsymbol{x}_i)\}^{I_i}.</code>
</p>

<p><code class="reqn">f_U</code> and <code class="reqn">S_U</code> denote the probability density and survival function of the susceptibles, respectively, that is
</p>
<p style="text-align: center;"><code class="reqn">
S_U(y_i;\boldsymbol\theta,{\boldsymbol x}_i)=\frac{S_P(y_i;\boldsymbol{\theta},{\boldsymbol x}_i)-p_0({\boldsymbol x}_i;\boldsymbol\theta)}{1-p_0({\boldsymbol x}_i;\boldsymbol\theta)}, f_U(y_i;\boldsymbol\theta,{\boldsymbol x}_i)=\frac{f_P(y_i;\boldsymbol\theta,{\boldsymbol x}_i)}{1-p_0({\boldsymbol x}_i;\boldsymbol\theta)}.</code>
</p>



<h3>Value</h3>

<p>A list with the following entries
</p>
<table role = "presentation">
<tr><td><code>cll</code></td>
<td>
<p>the complete log-likelihood for the current parameter values.</p>
</td></tr>
<tr><td><code>logS</code></td>
<td>
<p>Vector of logS values (one for each observation).</p>
</td></tr>
<tr><td><code>logP0</code></td>
<td>
<p>Vector of logP0 values (one for each observation).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2023). Bayesian inference and cure rate modeling for event history data. arXiv:2310.06926.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data 
	set.seed(1)
	n = 4
	stat = rbinom(n, size = 1, prob = 0.5)
	x &lt;- cbind(1, matrix(rnorm(n), n, 1))
	y &lt;- rexp(n)
	lw &lt;- log_weibull(y, a1 = 1, a2 = 1, c_under = 1e-9)
# compute complete log-likelihood
complete_log_likelihood_general(y = y, X = x, 
	Censoring_status = stat, 
	g = 1, lambda = 1, 
	log_f = lw$log_f, log_F = lw$log_F, 
	b = c(-0.5,0.5), 
	I_sim = stat, alpha = 1)

</code></pre>

<hr>
<h2 id='compute_fdr_tpr'>
Compute the achieved FDR and TPR
</h2><span id='topic+compute_fdr_tpr'></span>

<h3>Description</h3>

<p>This help function computes the achieved False Discovery Rate (FDR) and True Positive Rate (TPR). Useful for simulation studies where the ground truth classification of subjects in susceptibles and cured items is known. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_fdr_tpr(true_latent_status, posterior_probs, 
	myCut = c(0.01, 0.05, 0.1, 0.15))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_fdr_tpr_+3A_true_latent_status">true_latent_status</code></td>
<td>

<p>a binary vector containing the true latent status: 1 should correspond to the positive instances (&quot;cured&quot;) and 0 to the negative (&quot;susceptibles&quot;). 
</p>
</td></tr>
<tr><td><code id="compute_fdr_tpr_+3A_posterior_probs">posterior_probs</code></td>
<td>

<p>a numeric vector with entries between 0 and 1 containing the scores (posterior probabilities) of being positive (&quot;cured&quot;) for each item.
</p>
</td></tr>
<tr><td><code id="compute_fdr_tpr_+3A_mycut">myCut</code></td>
<td>

<p>Vector containing the desired nominal FDR levels.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return for every nominal FDR level the following quantities:
</p>
<table role = "presentation">
<tr><td><code>achieved_fdr</code></td>
<td>
<p>the achieved false discovery rate.</p>
</td></tr>
<tr><td><code>tpr</code></td>
<td>
<p>the true positive rate.</p>
</td></tr>
<tr><td><code>nominal_fdr</code></td>
<td>
<p>the nominal FDR level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
v1 &lt;- sample(0:1, size = 100, replace=TRUE, prob=c(0.8,0.2) )
v2 &lt;- runif(100)
compute_fdr_tpr(true_latent_status = v1, posterior_probs = v2)
</code></pre>

<hr>
<h2 id='cure_rate_MC3'>
Main function of the package
</h2><span id='topic+cure_rate_MC3'></span>

<h3>Description</h3>

<p>Runs a Metropolis Coupled MCMC (MC<code class="reqn">^3</code>) sampler in order to estimate the joint posterior distribution of the model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cure_rate_MC3(formula, data, nChains = 12, mcmc_cycles = 15000, 
	alpha = NULL,nCores = 1, sweep = 5, mu_g = 1, s2_g = 1, 
	a_l = 2.1, b_l = 1.1, mu_b = NULL, 
	Sigma = NULL, g_prop_sd = 0.045, 
	lambda_prop_scale = 0.03, b_prop_sd = NULL, 
	initialValues = NULL, plot = TRUE, adjust_scales = FALSE, 
	verbose = FALSE, tau_mala = 1.5e-05, mala = 0.15, 
	promotion_time = list(distribution = "weibull", 
	prior_parameters = matrix(rep(c(2.1, 1.1), 2), byrow = TRUE, 2, 2), 
	prop_scale = c(0.1, 0.2)), single_MH_in_f = 0.2, c_under = 1e-9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cure_rate_MC3_+3A_formula">formula</code></td>
<td>

<p>an object of class <code>formula</code>: a symbolic description of the model to be fitted. The left-hand side should be a <code>Surv</code> object, a class inherited from the <span class="pkg">survival</span> package. The binary censoring indicators are interpreted as a time-to-event (1) or as a censoring time (0).
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_data">data</code></td>
<td>

<p>a data frame containing all variable names included in <code>formula</code>. 
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_nchains">nChains</code></td>
<td>

<p>Positive integer corresponding to the number of heated chains in the MC<code class="reqn">^3</code> scheme.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_mcmc_cycles">mcmc_cycles</code></td>
<td>

<p>Length of the generated MCMC sample. Default value: 15000. Note that each MCMC cycle consists of <code>sweep</code> (see below) usual MCMC iterations. 
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_alpha">alpha</code></td>
<td>

<p>A decreasing sequence in <code class="reqn">[1,0)</code> of <code>nChains</code> temperatures (or heat values). The first value should always be equal to 1, which corresponds to the target posterior distribution (that is, the first chain). 
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores used for parallel processing. In case where <code>nCores</code> &gt; 1, the <code>nChains</code> will be processed in parallel using <code>nCores</code> cores. This may speed up significantly the run-time of the algorithm in Linux or macOS, but it is not suggested in Windows. 
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_sweep">sweep</code></td>
<td>

<p>The number of usual MCMC iterations per MCMC cycle. Default value: 10.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_mu_g">mu_g</code></td>
<td>

<p>Parameter <code class="reqn">a_{\gamma}</code> of the prior distribution of <code class="reqn">\gamma</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_s2_g">s2_g</code></td>
<td>

<p>Parameter <code class="reqn">b_{\gamma}</code> of the prior distribution of <code class="reqn">\gamma</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_a_l">a_l</code></td>
<td>

<p>Shape parameter <code class="reqn">a_{\lambda}</code> of the Inverse Gamma prior distribution of <code class="reqn">\lambda</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_b_l">b_l</code></td>
<td>

<p>Scale parameter <code class="reqn">b_{\lambda}</code> of the Inverse Gamma prior distribution of <code class="reqn">\lambda</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_mu_b">mu_b</code></td>
<td>

<p>Mean (<code class="reqn">\boldsymbol\mu</code>) of the multivariate normal prior distribution of regression coefficients. Should be a vector whose length is equal to <code class="reqn">k</code>, i.e. the number of columns of the design matrix <code>X</code>. Default value: rep(0, k). 
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_sigma">Sigma</code></td>
<td>

<p>Covariance matrix of the multivariate normal prior distribution of regression coefficients.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_g_prop_sd">g_prop_sd</code></td>
<td>

<p>The scale of the proposal distribution for single-site updates of the <code class="reqn">\gamma</code> parameter.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_lambda_prop_scale">lambda_prop_scale</code></td>
<td>

<p>The scale of the proposal distribution for single-site updates of the <code class="reqn">\lambda</code> parameter.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_b_prop_sd">b_prop_sd</code></td>
<td>

<p>The scale of the proposal distribution for the update of the <code class="reqn">\beta</code> parameter (regression coefficients).
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_initialvalues">initialValues</code></td>
<td>

<p>A list of initial values for each parameter (optional).
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_plot">plot</code></td>
<td>

<p>Plot MCMC sample on the run. Default: TRUE.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_adjust_scales">adjust_scales</code></td>
<td>

<p>Boolean. If TRUE the MCMC sampler runs an initial phase of a small number of iterations in order to tune the scale of the proposal distributions in the Metropolis-Hastings steps.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_verbose">verbose</code></td>
<td>

<p>Print progress on the terminal if TRUE.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_tau_mala">tau_mala</code></td>
<td>

<p>Scale of the Metropolis adjusted Langevin diffussion proposal distribution.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_mala">mala</code></td>
<td>

<p>A number between <code class="reqn">[0,1]</code> indicating the proportion of times the sampler attempts a MALA proposal. Thus, the probability of attempting a typical Metropolis-Hastings move is equal to 1 - <code>mala</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_promotion_time">promotion_time</code></td>
<td>
<p>A list with details indicating the parametric family of distribution describing the promotion time and corresponding prior distributions. See 'details'.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_single_mh_in_f">single_MH_in_f</code></td>
<td>

<p>The probability for attempting a series of single site updates in the typical Metropolis-Hastings move. Otherwise,  with probability 1 - <code>single_MH_in_f</code> a Metropolis-Hastings move will attempt to update all continuous parameters simultaneously. It only makes sense when <code>mala &lt; 1</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_MC3_+3A_c_under">c_under</code></td>
<td>

<p>A small positive number (much smaller than 1) which is used as a threshold in the CDF of the promotion time for avoiding underflows in the computation of the log-likelihood function. Default value: 1e-9.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is advised to scale all continuous explanatory variables in the design matrix, so their sample mean and standard deviations are equal to 0 and 1, respectively. 
The <code>promotion_time</code> argument should be a list containing the following entries
</p>

<dl>
<dt><code>distribution</code> </dt><dd><p>  Character string specifying the family of distributions <code class="reqn">\{F(\cdot;\boldsymbol\alpha);\boldsymbol\alpha\in\mathcal A\}</code> describing the promotion time.</p>
</dd>
<dt><code>prior_parameters</code> </dt><dd><p>  Values of hyper-parameters in the prior distribution of the parameters <code class="reqn">\boldsymbol\alpha</code>.</p>
</dd>
<dt><code>prop_scale</code> </dt><dd><p>  The scale of the proposal distributions for each parameter in <code class="reqn">\boldsymbol\alpha</code>.</p>
</dd>
<dt><code>K</code> </dt><dd><p> Optional. The number of mixture components in case where a mixture model is fitted, that is, when setting <code>distribution</code> to either <code>'gamma_mixture'</code> or <code>'user_mixture'</code>. </p>
</dd>
<dt><code>dirichlet_concentration_parameter</code> </dt><dd><p>  Optional. Relevant only in the case of the <code>'gamma_mixture'</code> or <code>'user_mixture'</code>. Positive scalar (typically, set to 1) determining the (common) concentration parameter of the Dirichlet prior distribution of mixing proportions. </p>
</dd>
</dl>

<p>The <code>distribution</code> specifies the distributional family of promotion time and corresponds to a character string with available choices: <code>'exponential'</code>, <code>'weibull'</code>, <code>'gamma'</code>, <code>'logLogistic'</code>, <code>'gompertz'</code>, <code>'lomax'</code>, <code>'dagum'</code>, <code>'gamma_mixture'</code>. User defined promotion time distributions and finite mixtures of them can be also fitted using the options <code>'user'</code> and <code>'user_mixture'</code>, respectively. In this case, the user should specify the distributional family in a separate argument named <code>define</code> which is passed as an additional entry in the <code>promotion_time</code>. This function should accept two input arguments <code>y</code> and <code>a</code> corresponding to the observed data (vector of positive numbers) and the parameters of the distribution (vector of positives). Pay attention to the positivity requirement of the parameters: if this is not the case, the user should suitably reparameterize the distribution in terms of positive parameters.
</p>
<p>The joint prior distribution of <code class="reqn">\boldsymbol\alpha = (\alpha_1,\ldots,\alpha_d)</code> factorizes into products of inverse Gamma distributions for all (positive) parameters of <code class="reqn">F</code>. Moreover, in the case of <code>'gamma_mixture'</code>, the joint prior also consists of another term to the Dirichlet prior distribution  on the mixing proportions. 
</p>
<p>The <code>prop_scale</code> argument should be a vector with length equal to the length of vector <code class="reqn">d</code> (number of elements in <code class="reqn">\boldsymbol\alpha</code>), containing (positive) numbers which correspond to the scale of the proposal distribution. Note that these scale parameters are used only as initial values in case where <code>adjust_scales = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>bayesCureModel</code>, i.e. a list with the following entries
</p>
<table role = "presentation">
<tr><td><code>mcmc_sample</code></td>
<td>
<p>Object of class <code>mcmc</code> (see the <span class="pkg">coda</span> package), containing the generated MCMC sample for the target chain. The column names correspond to 
</p>

<dl>
<dt><code>g_mcmc</code> </dt><dd><p> Sampled values for parameter <code class="reqn">\gamma</code></p>
</dd>
<dt><code>lambda_mcmc</code> </dt><dd><p> Sampled values for parameter <code class="reqn">\lambda</code></p>
</dd>
<dt><code>alpha1_mcmc</code>... </dt><dd><p> Sampled values for parameter <code class="reqn">\alpha_1</code>... of the promotion time distribution <code class="reqn">F(\cdot;\alpha_1,\ldots,\alpha_d)</code>. The subsequent <code class="reqn">d-1</code> columns contain the sampled values for all remaining parameters, <code class="reqn">\alpha_2,...,\ldots,\alpha_d</code>, where <code class="reqn">d</code> depens on the family used in <code>promotion_time</code>.</p>
</dd>
<dt><code>b0_mcmc</code> </dt><dd><p> Sampled values for the constant term of the regression (present only in the case where the design matrix <code>X</code> contains a column of 1s).</p>
</dd>
<dt><code>b1_mcmc</code>... </dt><dd><p> Sampled values for the regression coefficient for the first explanatory variable, and similar for all subsequent columns.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>latent_status_censored</code></td>
<td>
<p> A data frame with the simulated binary latent status for each censored item. </p>
</td></tr>
<tr><td><code>complete_log_likelihood</code></td>
<td>
<p>The complete log-likelihood for the target chain.</p>
</td></tr>
<tr><td><code>swap_accept_rate</code></td>
<td>
<p> the acceptance rate of proposed swappings between adjacent MCMC chains.</p>
</td></tr>
<tr><td><code>all_cll_values</code></td>
<td>
<p>The complete log-likelihood for all chains.</p>
</td></tr>
<tr><td><code>input_data_and_model_prior</code></td>
<td>
<p>the input data, model specification and selected prior parameters values.</p>
</td></tr>
<tr><td><code>log_posterior</code></td>
<td>
<p>the logarithm of the (non-augmented) posterior distribution (after integrating the latent cured-status parameters out), up to a normalizing constant.</p>
</td></tr>
<tr><td><code>map_estimate</code></td>
<td>
<p>The Maximum A Posterior estimate of parameters.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion of the fitted model.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike Information Criterion of the fitted model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The Cox-Snell residuals of the fitted model.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The core function is <code><a href="#topic+cure_rate_mcmc">cure_rate_mcmc</a></code>.
</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2024). Bayesian inference and cure rate modeling for event history data. TEST doi: 10.1007/s11749-024-00942-w.
</p>
<p>Plummer M, Best N, Cowles K, Vines K (2006). &quot;CODA: Convergence Diagnosis and Output Analysis for MCMC.&quot; R News, 6(1), 7-11. 
</p>
<p>Therneau T (2024). A Package for Survival Analysis in R. R package version 3.7-0, https://CRAN.R-project.org/package=survival. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cure_rate_mcmc">cure_rate_mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
	set.seed(10)
        n = 4
        # censoring indicators
        stat = rbinom(n, size = 1, prob = 0.5)
        # covariates
        x &lt;- matrix(rnorm(2*n), n, 2)
        # observed response variable 
        y &lt;- rexp(n)
#	define a data frame with the response and the covariates        
        my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, 
		data = my_data_frame,
		promotion_time = list(distribution = 'weibull'),
		nChains = 2, nCores = 1, 
		mcmc_cycles = 3, sweep = 2)

</code></pre>

<hr>
<h2 id='cure_rate_mcmc'>
The basic MCMC scheme. 
</h2><span id='topic+cure_rate_mcmc'></span>

<h3>Description</h3>

<p>This is core MCMC function. The continuous parameters of the model are updated using (a) single-site Metropolis-Hastings steps and (b) a Metropolis adjusted Langevin diffusion step. The binary latent variables of the model (cured status per censored observation) are updated according to a Gibbs step. This function is embedded to the main function of the package <code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code> which runs parallel tempered MCMC chains. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cure_rate_mcmc(y, X, Censoring_status, m, alpha = 1, mu_g = 1, s2_g = 1, 
	a_l = 2.1, b_l = 1.1, promotion_time = list(distribution = "weibull", 
	prior_parameters = matrix(rep(c(2.1, 1.1), 2), byrow = TRUE, 2, 2), 
	prop_scale = c(0.2, 0.03)), mu_b = NULL, Sigma = NULL, g_prop_sd = 0.045, 
	lambda_prop_scale = 0.03, b_prop_sd = NULL, initialValues = NULL, 
	plot = FALSE, verbose = FALSE, tau_mala = 1.5e-05, mala = 0.15, 
	single_MH_in_f = 0.5, c_under = 1e-9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cure_rate_mcmc_+3A_y">y</code></td>
<td>

<p>observed data (time-to-event or censored time)
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_x">X</code></td>
<td>

<p>design matrix. Should contain a column of 1's if the model has a constant term. 
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_censoring_status">Censoring_status</code></td>
<td>

<p>binary variables corresponding to time-to-event and censoring.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_m">m</code></td>
<td>

<p>number of MCMC iterations.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_alpha">alpha</code></td>
<td>

<p>A value between 0 and 1, corresponding to the temperature of the complete posterior distribution. The target posterior distribution corresponds to <code>alpha = 1</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_mu_g">mu_g</code></td>
<td>

<p>Parameter <code class="reqn">a_{\gamma}</code> of the prior distribution of <code class="reqn">\gamma</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_s2_g">s2_g</code></td>
<td>

<p>Parameter <code class="reqn">b_{\gamma}</code> of the prior distribution of <code class="reqn">\gamma</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_a_l">a_l</code></td>
<td>

<p>Shape parameter <code class="reqn">a_{\lambda}</code> of the Inverse Gamma prior distribution of <code class="reqn">\lambda</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_b_l">b_l</code></td>
<td>

<p>Scale parameter <code class="reqn">b_{\lambda}</code> of the Inverse Gamma prior distribution of <code class="reqn">\lambda</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_promotion_time">promotion_time</code></td>
<td>

<p>A list containing the specification of the promotion time distribution. See 'details'.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_mu_b">mu_b</code></td>
<td>

<p>Mean <code class="reqn">\mu</code> of the multivariate normal prior distribution of regression coefficients. Should be a vector whose length is equal to the number of columns of the design matrix <code>X</code>.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_sigma">Sigma</code></td>
<td>

<p>Covariance matrix of the multivariate normal prior distribution of regression coefficients.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_g_prop_sd">g_prop_sd</code></td>
<td>

<p>The scale of the proposal distribution for single-site updates of the <code class="reqn">\gamma</code> parameter.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_lambda_prop_scale">lambda_prop_scale</code></td>
<td>

<p>The scale of the proposal distribution for single-site updates of the <code class="reqn">\lambda</code> parameter.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_b_prop_sd">b_prop_sd</code></td>
<td>

<p>The scale of the proposal distribution for the update of the <code class="reqn">\beta</code> parameter (regression coefficients).
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_initialvalues">initialValues</code></td>
<td>

<p>A list of initial values for each parameter (optional).
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_plot">plot</code></td>
<td>

<p>Boolean for plotting on the run.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_verbose">verbose</code></td>
<td>

<p>Boolean for printing progress on the run.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_tau_mala">tau_mala</code></td>
<td>

<p>scale of the MALA proposal.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_mala">mala</code></td>
<td>

<p>Propability of attempting a MALA step. Otherwise, a simple MH move is attempted. 
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_single_mh_in_f">single_MH_in_f</code></td>
<td>

<p>Probability of attempting a single-site MH move in the basic Metropolis-Hastings step. Otherwise, a joint update is attempted.
</p>
</td></tr>
<tr><td><code id="cure_rate_mcmc_+3A_c_under">c_under</code></td>
<td>

<p>A small positive number (much smaller than 1) which is used as a threshold in the CDF of the promotion time for avoiding underflows in the computation of the log-likelihood function. Default value: 1e-9.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>mcmc_sample</code></td>
<td>
<p>The sampled MCMC values per parameter. See 'note'.</p>
</td></tr>
<tr><td><code>complete_log_likelihood</code></td>
<td>
<p> Logarithm of the complete likelihood per MCMC iteration.</p>
</td></tr>
<tr><td><code>acceptance_rates</code></td>
<td>
<p>The acceptance rate per move.</p>
</td></tr>
<tr><td><code>latent_status_censored</code></td>
<td>
<p> The MCMC sample of the latent status per censored observation.</p>
</td></tr>
<tr><td><code>log_prior_density</code></td>
<td>
<p>Logarithm of the prior density per MCMC iteration.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the case where the promotion time distribution is a mixture model, the mixing proportions <code class="reqn">w_1,\ldots,w_K</code> are reparameterized according to the following transformation
</p>
<p style="text-align: center;"><code class="reqn">w_j = \frac{\rho_j}{\sum_{i=1}^{K}\rho_i}, j = 1,\ldots,K</code>
</p>

<p>where <code class="reqn">\rho_i &gt; 0</code> for <code class="reqn">i=1,\ldots,K-1</code> and <code class="reqn">\rho_{K}=1</code>. The sampler returns the parameters <code class="reqn">\rho_1,\ldots,\rho_{K-1}</code>, not the mixing proportions. 
</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2024). Bayesian inference and cure rate modeling for event history data. TEST doi: 10.1007/s11749-024-00942-w.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
        set.seed(1)
        n = 10
        stat = rbinom(n, size = 1, prob = 0.5)
        x &lt;- cbind(1, matrix(rnorm(2*n), n, 2))
        y &lt;- rexp(n)
# run a weibull model (including const. term) 
#	for m = 10 mcmc iterations 
        fit1 &lt;- cure_rate_mcmc(y = y, X = x, Censoring_status = stat, 
              	plot = FALSE,
                promotion_time = list(distribution = 'weibull', 
                        prior_parameters = matrix(rep(c(2.1, 1.1), 2), 
                                                byrow = TRUE, 2, 2),
                        prop_scale = c(0.1, 0.1)
                ),
                m = 10)
#	the generated mcmc sampled values         
	fit1$mcmc_sample
</code></pre>

<hr>
<h2 id='log_dagum'>
PDF and CDF of the Dagum distribution
</h2><span id='topic+log_dagum'></span>

<h3>Description</h3>

<p>The Dagum distribution as evaluated at the <span class="pkg">VGAM</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_dagum(y, a1, a2, a3, c_under = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_dagum_+3A_y">y</code></td>
<td>

<p>observed data
</p>
</td></tr>
<tr><td><code id="log_dagum_+3A_a1">a1</code></td>
<td>

<p>scale parameter
</p>
</td></tr>
<tr><td><code id="log_dagum_+3A_a2">a2</code></td>
<td>

<p>shape1.a parameter
</p>
</td></tr>
<tr><td><code id="log_dagum_+3A_a3">a3</code></td>
<td>

<p>shape2.p parameter
</p>
</td></tr>
<tr><td><code id="log_dagum_+3A_c_under">c_under</code></td>
<td>

<p>A small positive value corresponding to the underflow threshold, e.g. c_under = 1e-9.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dagum distribution is a special case of the 4-parameter
generalized beta II distribution.
</p>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>log_f</code></td>
<td>
<p>natural logarithm of the pdf, evaluated at each datapoint.</p>
</td></tr>
<tr><td><code>log_F</code></td>
<td>
<p>natural logarithm of the CDF, evaluated at each datapoint.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Thomas W. Yee (2015). Vector Generalized Linear and Additive Models:
With an Implementation in R. New York, USA: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+ddagum">ddagum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_dagum(y = 1:10, a1 = 1, a2 = 1, a3 = 1, c_under = 1e-9)
</code></pre>

<hr>
<h2 id='log_gamma'>
PDF and CDF of the Gamma distribution
</h2><span id='topic+log_gamma'></span>

<h3>Description</h3>

<p>Computes the pdf and cdf of the Gamma distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_gamma(y, a1, a2, c_under = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_gamma_+3A_y">y</code></td>
<td>

<p>observed data
</p>
</td></tr>
<tr><td><code id="log_gamma_+3A_a1">a1</code></td>
<td>

<p>shape parameter
</p>
</td></tr>
<tr><td><code id="log_gamma_+3A_a2">a2</code></td>
<td>

<p>rate parameter
</p>
</td></tr>
<tr><td><code id="log_gamma_+3A_c_under">c_under</code></td>
<td>

<p>A small positive value corresponding to the underflow threshold, e.g. c_under = 1e-9.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>log_f</code></td>
<td>
<p>natural logarithm of the pdf, evaluated at each datapoint.</p>
</td></tr>
<tr><td><code>log_F</code></td>
<td>
<p>natural logarithm of the CDF, evaluated at each datapoint.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dgamma">dgamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_gamma(y = 1:10, a1 = 1, a2 = 1, c_under = 1e-9)
</code></pre>

<hr>
<h2 id='log_gamma_mixture'>
PDF and CDF of a Gamma mixture distribution
</h2><span id='topic+log_gamma_mixture'></span>

<h3>Description</h3>

<p>Computes the logarithm of the probability density function and cumulative density function per observation for each observation under a Gamma mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_gamma_mixture(y, a1, a2, p, c_under = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_gamma_mixture_+3A_y">y</code></td>
<td>

<p>observed data
</p>
</td></tr>
<tr><td><code id="log_gamma_mixture_+3A_a1">a1</code></td>
<td>

<p>vector containing the shape parameters of each Gamma mixture component
</p>
</td></tr>
<tr><td><code id="log_gamma_mixture_+3A_a2">a2</code></td>
<td>

<p>vector containing the rate parameters of each Gamma mixture component
</p>
</td></tr>
<tr><td><code id="log_gamma_mixture_+3A_p">p</code></td>
<td>

<p>vector of mixing proportions
</p>
</td></tr>
<tr><td><code id="log_gamma_mixture_+3A_c_under">c_under</code></td>
<td>

<p>threshold for underflows.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>log_f</code></td>
<td>
<p>natural logarithm of the pdf, evaluated at each datapoint.</p>
</td></tr>
<tr><td><code>log_F</code></td>
<td>
<p>natural logarithm of the CDF, evaluated at each datapoint.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- runif(10)
a1 &lt;- c(1,2)
a2 &lt;- c(1,1)
p &lt;- c(0.9,0.1)
log_gamma_mixture(y, a1, a2, p)
</code></pre>

<hr>
<h2 id='log_gompertz'>
PDF and CDF of the Gompertz distribution
</h2><span id='topic+log_gompertz'></span>

<h3>Description</h3>

<p>The Gompertz distribution as evaluated at the <span class="pkg">flexsurv</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_gompertz(y, a1, a2, c_under = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_gompertz_+3A_y">y</code></td>
<td>

<p>observed data
</p>
</td></tr>
<tr><td><code id="log_gompertz_+3A_a1">a1</code></td>
<td>

<p>shape parameter
</p>
</td></tr>
<tr><td><code id="log_gompertz_+3A_a2">a2</code></td>
<td>

<p>rate parameter
</p>
</td></tr>
<tr><td><code id="log_gompertz_+3A_c_under">c_under</code></td>
<td>

<p>A small positive value corresponding to the underflow threshold, e.g. c_under = 1e-9.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>log_f</code></td>
<td>
<p>natural logarithm of the pdf, evaluated at each datapoint.</p>
</td></tr>
<tr><td><code>log_F</code></td>
<td>
<p>natural logarithm of the CDF, evaluated at each datapoint.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Christopher Jackson (2016). flexsurv: A Platform for Parametric
Survival Modeling in R. Journal of Statistical Software, 70(8), 1-33.
doi:10.18637/jss.v070.i08
</p>


<h3>See Also</h3>

<p><code><a href="flexsurv.html#topic+dgompertz">dgompertz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_gompertz(y = 1:10, a1 = 1, a2 = 1, c_under = 1e-9)
</code></pre>

<hr>
<h2 id='log_logLogistic'>
PDF and CDF of the log-Logistic distribution.
</h2><span id='topic+log_logLogistic'></span>

<h3>Description</h3>

<p>The log-Logistic distribution as evaluated at the <span class="pkg">flexsurv</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_logLogistic(y, a1, a2, c_under = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_logLogistic_+3A_y">y</code></td>
<td>

<p>observed data
</p>
</td></tr>
<tr><td><code id="log_logLogistic_+3A_a1">a1</code></td>
<td>

<p>shape parameter
</p>
</td></tr>
<tr><td><code id="log_logLogistic_+3A_a2">a2</code></td>
<td>

<p>scale parameter
</p>
</td></tr>
<tr><td><code id="log_logLogistic_+3A_c_under">c_under</code></td>
<td>

<p>A small positive value corresponding to the underflow threshold, e.g. c_under = 1e-9.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-logistic distribution is the probability distribution of a random variable whose logarithm has a logistic distribution. 
</p>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>log_f</code></td>
<td>
<p>natural logarithm of the pdf, evaluated at each datapoint.</p>
</td></tr>
<tr><td><code>log_F</code></td>
<td>
<p>natural logarithm of the CDF, evaluated at each datapoint.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Christopher Jackson (2016). flexsurv: A Platform for Parametric
Survival Modeling in R. Journal of Statistical Software, 70(8), 1-33.
doi:10.18637/jss.v070.i08
</p>


<h3>See Also</h3>

<p><code><a href="flexsurv.html#topic+dllogis">dllogis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_logLogistic(y = 1:10, a1 = 1, a2 = 1, c_under = 1e-9)
</code></pre>

<hr>
<h2 id='log_lomax'>
PDF and CDF of the Lomax distribution
</h2><span id='topic+log_lomax'></span>

<h3>Description</h3>

<p>The Lomax distribution as evaluated at the <span class="pkg">VGAM</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_lomax(y, a1, a2, c_under = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_lomax_+3A_y">y</code></td>
<td>

<p>observed data
</p>
</td></tr>
<tr><td><code id="log_lomax_+3A_a1">a1</code></td>
<td>

<p>scale parameter
</p>
</td></tr>
<tr><td><code id="log_lomax_+3A_a2">a2</code></td>
<td>

<p>shape parameter
</p>
</td></tr>
<tr><td><code id="log_lomax_+3A_c_under">c_under</code></td>
<td>

<p>A small positive value corresponding to the underflow threshold, e.g. c_under = 1e-9.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lomax distribution is a special case of the 4-parameter
generalized beta II distribution.</p>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>log_f</code></td>
<td>
<p>natural logarithm of the pdf, evaluated at each datapoint.</p>
</td></tr>
<tr><td><code>log_F</code></td>
<td>
<p>natural logarithm of the CDF, evaluated at each datapoint.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Thomas W. Yee (2015). Vector Generalized Linear and Additive Models:
With an Implementation in R. New York, USA: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+dlomax">dlomax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_lomax(y = 1:10, a1 = 1, a2 = 1, c_under = 1e-9)
</code></pre>

<hr>
<h2 id='log_user_mixture'>
Define a finite mixture of a given family of distributions. 
</h2><span id='topic+log_user_mixture'></span>

<h3>Description</h3>

<p>This function computes the logarithm of the probability density function and cumulative density function per observation for each observation under a user-defined mixture of a given family of distributions. The parameters of the given family of distributions should belong to (0, inf). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_user_mixture(user_f, y, a, p, c_under = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_user_mixture_+3A_user_f">user_f</code></td>
<td>

<p>a user defined function that returns the logarithm of a given probability density and the corresponding logarithm of the cumulative distribution function. These arguments should be returned in the form of a list with two entries: <code>log_f</code> and <code>log_F</code>, containing the logarithm of the pdf and cdf values of <code>y</code>, respectively, for a given set of parameter values.
</p>
</td></tr>
<tr><td><code id="log_user_mixture_+3A_y">y</code></td>
<td>

<p>observed data
</p>
</td></tr>
<tr><td><code id="log_user_mixture_+3A_a">a</code></td>
<td>
<p>a matrix where each column corresponds to component specific parameters
and the columns to different components. All parameters should be positive. The number of columns should be the same with the number of mixture components.
</p>
</td></tr>
<tr><td><code id="log_user_mixture_+3A_p">p</code></td>
<td>

<p>vector of mixing proportions
</p>
</td></tr>
<tr><td><code id="log_user_mixture_+3A_c_under">c_under</code></td>
<td>

<p>threshold for underflows.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>log_f</code></td>
<td>
<p>natural logarithm of the pdf, evaluated at each datapoint.</p>
</td></tr>
<tr><td><code>log_F</code></td>
<td>
<p>natural logarithm of the CDF, evaluated at each datapoint.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We will define a mixture of 2 exponentials distributions.
# First we pass the exponential distribution at user_f
user_f &lt;- function(y, a){
	log_f &lt;- dexp(y, rate = a, log = TRUE)
	log_F &lt;- pexp(y, rate = a, log.p = TRUE)
	result &lt;- vector('list', length = 2)
	names(result) &lt;- c('log_f', 'log_F')
	result[["log_f"]] = log_f
	result[["log_F"]] = log_F
	return(result)
}
#	simulate some date
y &lt;- runif(10)
# Now compute the log of pdf and cdf for a mixture of K=2 exponentials
p &lt;- c(0.9,0.1)
a &lt;- matrix(c(0.1, 1.5), nrow = 1, ncol = 2)
log_user_mixture(user_f = user_f, y = y, a = a, p = p)
</code></pre>

<hr>
<h2 id='log_weibull'>
PDF and CDF of the Weibull distribution
</h2><span id='topic+log_weibull'></span>

<h3>Description</h3>

<p>Computes the log pdf and cdf of the weibull distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_weibull(y, a1, a2, c_under)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_weibull_+3A_y">y</code></td>
<td>

<p>observed data
</p>
</td></tr>
<tr><td><code id="log_weibull_+3A_a1">a1</code></td>
<td>

<p>shape parameter
</p>
</td></tr>
<tr><td><code id="log_weibull_+3A_a2">a2</code></td>
<td>

<p>rate parameter
</p>
</td></tr>
<tr><td><code id="log_weibull_+3A_c_under">c_under</code></td>
<td>

<p>A small positive value corresponding to the underflow threshold, e.g. c_under = 1e-9.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following entries
</p>
<table role = "presentation">
<tr><td><code>log_f</code></td>
<td>
<p>natural logarithm of the pdf, evaluated at each datapoint.</p>
</td></tr>
<tr><td><code>log_F</code></td>
<td>
<p>natural logarithm of the CDF, evaluated at each datapoint.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_weibull(y = 1:10, a1 = 1, a2 = 1, c_under = 1e-9)

</code></pre>

<hr>
<h2 id='logLik.bayesCureModel'>
Extract the log-likelihood.
</h2><span id='topic+logLik.bayesCureModel'></span>

<h3>Description</h3>

<p>Method to extract the log-likelihood of a <code>bayesCureModel</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesCureModel'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.bayesCureModel_+3A_object">object</code></td>
<td>

<p>An object of class <code>bayesCureModel</code>
</p>
</td></tr>
<tr><td><code id="logLik.bayesCureModel_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximum (observed) log-likelihood value obtained across the MCMC run.
</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2024). Bayesian inference and cure rate modeling for event history data. TEST doi: 10.1007/s11749-024-00942-w.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
	set.seed(10)
        n = 4
        # censoring indicators
        stat = rbinom(n, size = 1, prob = 0.5)
        # covariates
        x &lt;- matrix(rnorm(2*n), n, 2)
        # observed response variable 
        y &lt;- rexp(n)
#	define a data frame with the response and the covariates        
        my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
# run a weibull model with default prior setup
# considering 2 heated chains 
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, 
		data = my_data_frame, 
		promotion_time = list(distribution = 'exponential'),
		nChains = 2, 
		nCores = 1, 
		mcmc_cycles = 3, sweep=2)
	ll &lt;- logLik(fit1)

</code></pre>

<hr>
<h2 id='marriage_dataset'>Marriage data</h2><span id='topic+marriage_dataset'></span>

<h3>Description</h3>

<p>The variable of interest (<code>time</code>)  corresponds to the duration (in years) of first marriage for 1500 individuals. The available covariates are: 
</p>

<dl>
<dt><code>age</code> </dt><dd><p> age of respondent (in years) at the time of first marriage. The values are standardized (sample mean and variance equal to 0 and 1, respectively). </p>
</dd>
<dt><code>kids</code> </dt><dd><p> factor: whether there were kids during the first marriage (<code>"yes"</code>) or not (<code>"no"</code>).</p>
</dd>
<dt><code>race</code> </dt><dd><p> race of respondent with levels: <code>"black"</code>, <code>"hispanic"</code> and <code>"other"</code>.</p>
</dd>
</dl>

<p>Among the 1500 observations, there are 1018 censoring times (<code>censoring = 0</code>) and 482 divorces (<code>censoring = 1</code>). Source: National Longitudinal Survey of Youth 1997 (NLSY97).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(marriage_dataset)</code></pre>


<h3>Format</h3>

<p>Time-to-event data.</p>


<h3>References</h3>

<p>Bureau of Labor Statistics, U.S. Department of Labor. National Longitudinal Survey of Youth 1997 cohort, 1997-2022 (rounds 1-20). Produced and distributed by the Center for Human Resource Research (CHRR), The Ohio State University. Columbus, OH: 2023.
</p>

<hr>
<h2 id='plot.bayesCureModel'>
Plot method
</h2><span id='topic+plot.bayesCureModel'></span>

<h3>Description</h3>

<p>Plots and computes HDIs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesCureModel'
plot(x, burn = NULL, alpha = 0.05, gamma_mix = TRUE, 
	K_gamma = 5, plot_graphs = TRUE, bw = "nrd0", what = NULL, predict_output = NULL,  
	index_of_main_mode = NULL, draw_legend = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bayesCureModel_+3A_x">x</code></td>
<td>

<p>An object of class <code>bayesCureModel</code>
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_burn">burn</code></td>
<td>

<p>Number of iterations to discard as burn-in period.
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_alpha">alpha</code></td>
<td>

<p>A value between 0 and 1 in order to compute the 1-<code class="reqn">\alpha</code> Highest Posterior Density regions. 
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_gamma_mix">gamma_mix</code></td>
<td>

<p>Boolean. If TRUE, the density of the marginal posterior distribution of the <code class="reqn">\gamma</code> parameter is estimated from the sampled MCMC values by fitting a normal mixture  model.
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_k_gamma">K_gamma</code></td>
<td>

<p>Used only when <code>gamma_mix = TRUE</code> and corresponds to the number of normal mixture components used to estimate the marginal posterior density of the <code class="reqn">\gamma</code> parameter. 
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_plot_graphs">plot_graphs</code></td>
<td>

<p>Boolean, if FALSE only HDIs are computed.
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_bw">bw</code></td>
<td>

<p>bandwidth
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_what">what</code></td>
<td>

<p>Integer or a character string with possible values equal to <code>'cured_prob'</code>, <code>'survival'</code> or <code>'residuals'</code>.
An integer entry indicates which parameter should be plotted. If set to <code>NULL</code> (default), all parameters are plotted one by one. If set to <code>'cured_prob'</code> or <code>'survival'</code> the estimated cured probability or survival function is plotted, conditional on a set of covariates defined in the <code>p_cured_output</code> argument. In case where <code>what = 'residuals'</code> the residuals of the fitted model are plotted versus the quantity <code class="reqn">-log(S)</code> where <code class="reqn">S</code> denotes the estimated survival function arising from the Kaplan-Meier estimate based on the residuals and the censoring times.
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_predict_output">predict_output</code></td>
<td>

<p>Optional argument which is required only when <code>what = 'cured_prob'</code> or <code>what = 'survival'</code>. It is returned by a call to the <code>predict.bayesCureModel</code> function.  
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_index_of_main_mode">index_of_main_mode</code></td>
<td>

<p>If NULL (default), the whole MCMC output is used for plotting. Otherwise, it is a subset of the retained MCMC iterations in order to identify the main mode of the posterior distribution, as returned by the <code>index_of_main_mode</code> value of the <code>summary.bayesCureRateModel</code> function. 
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_draw_legend">draw_legend</code></td>
<td>

<p>Boolean. If TRUE (default), a legend is plotted in the case where <code>what = 'survival'</code> or <code>what = 'cured_prob'</code>.  
</p>
</td></tr>
<tr><td><code id="plot.bayesCureModel_+3A_...">...</code></td>
<td>

<p>arguments passed by other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function plots graphic output on the plot device if <code>plot_graphs = TRUE</code>. Furthermore, a list of <code class="reqn">100(1-\alpha)\%</code> Highest Density Intervals per parameter is returned. 
</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
	set.seed(10)
        n = 4
        # censoring indicators
        stat = rbinom(n, size = 1, prob = 0.5)
        # covariates
        x &lt;- matrix(rnorm(2*n), n, 2)
        # observed response variable 
        y &lt;- rexp(n)
#	define a data frame with the response and the covariates        
        my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
# run a weibull model with default prior setup
# considering 2 heated chains 
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, data = my_data_frame, 
		promotion_time = list(distribution = 'exponential'),
		nChains = 2, 
		nCores = 1, 
		mcmc_cycles = 3, sweep=2)
	mySummary &lt;- summary(fit1, burn = 0)
	# plot the marginal posterior distribution of the first parameter in returned mcmc output
	plot(fit1, what = 1, burn = 0)


</code></pre>

<hr>
<h2 id='plot.predict_bayesCureModel'>
Plot method
</h2><span id='topic+plot.predict_bayesCureModel'></span>

<h3>Description</h3>

<p>Plot the output of the predict method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict_bayesCureModel'
plot(x, what = 'survival', draw_legend = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.predict_bayesCureModel_+3A_x">x</code></td>
<td>

<p>An object of class <code>predict_bayesCureModel</code>
</p>
</td></tr>
<tr><td><code id="plot.predict_bayesCureModel_+3A_what">what</code></td>
<td>

<p>Character with possible values: <code>'cured_prob'</code> or <code>'survival'</code>, corresponding to the estimated cured probability or survival function.
</p>
</td></tr>
<tr><td><code id="plot.predict_bayesCureModel_+3A_draw_legend">draw_legend</code></td>
<td>

<p>Boolean. If TRUE (default), a legend is plotted in the case where <code>what = 'survival'</code> or <code>what = 'cured_prob'</code>.  
</p>
</td></tr>
<tr><td><code id="plot.predict_bayesCureModel_+3A_...">...</code></td>
<td>

<p>arguments passed by other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value, just a plot. 
</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
	set.seed(10)
        n = 4
        # censoring indicators
        stat = rbinom(n, size = 1, prob = 0.5)
        # covariates
        x &lt;- matrix(rnorm(2*n), n, 2)
        # observed response variable 
        y &lt;- rexp(n)
#	define a data frame with the response and the covariates        
        my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
# run a weibull model with default prior setup
# considering 2 heated chains 
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, data = my_data_frame, 
		promotion_time = list(distribution = 'exponential'),
		nChains = 2, 
		nCores = 1, 
		mcmc_cycles = 3, sweep=2)
	#compute predictions for two individuals with 
	#	x1 = 0.2 and x2 = -1
	#	and 
	#	x1 = -1 and x2 = 0
	covariate_levels1 &lt;- data.frame(x1 = c(0.2,-1), x2 = c(-1,0))
	predictions &lt;- predict(fit1, newdata = covariate_levels1, burn = 0)
	# plot cured probabilities based on the previous output
	plot(predictions, what='cured_prob')


</code></pre>

<hr>
<h2 id='predict.bayesCureModel'>
Predict method.
</h2><span id='topic+predict.bayesCureModel'></span>

<h3>Description</h3>

<p>Returns MAP estimates of the survival function and the conditional cured probability for a given set of covariates. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesCureModel'
predict(object, newdata = NULL, tau_values = NULL, 
	burn = NULL, K_max = 1, alpha = 0.1, nDigits = 3, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bayesCureModel_+3A_object">object</code></td>
<td>

<p>An object of class <code>bayesCureModel</code>
</p>
</td></tr>
<tr><td><code id="predict.bayesCureModel_+3A_newdata">newdata</code></td>
<td>

<p>A <code>data.frame</code> with new data for the covariates. The column names as well as the class of each column (variable) should match with the input data. 
</p>
</td></tr>
<tr><td><code id="predict.bayesCureModel_+3A_tau_values">tau_values</code></td>
<td>

<p>A vector of values for the response variable (time) for returning predictions for each row in the  <code>newdata</code>. 
</p>
</td></tr>
<tr><td><code id="predict.bayesCureModel_+3A_burn">burn</code></td>
<td>

<p>Positive integer corresponding to the number of mcmc iterations to discard as burn-in period
</p>
</td></tr>
<tr><td><code id="predict.bayesCureModel_+3A_k_max">K_max</code></td>
<td>

<p>Maximum number of components in order to cluster the (univariate) values of the joint posterior distribution across the MCMC run. Used to identify the main mode of the posterior distribution. 
</p>
</td></tr>
<tr><td><code id="predict.bayesCureModel_+3A_alpha">alpha</code></td>
<td>

<p>Scalar between 0 and 1 corresponding to 1 - confidencel level for computing Highest Density Intervals. If set to NULL, the confidence intervals are not computed.
</p>
</td></tr>
<tr><td><code id="predict.bayesCureModel_+3A_ndigits">nDigits</code></td>
<td>

<p>A positive integer for printing the output, after rounding to the corresponding number of digits. Default: <code>nDigits = 3</code>.
</p>
</td></tr>
<tr><td><code id="predict.bayesCureModel_+3A_verbose">verbose</code></td>
<td>

<p>Boolean. If set to TRUE (default) the function prints a summary of the predictions. 
</p>
</td></tr>
<tr><td><code id="predict.bayesCureModel_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of the posterior draws are clustered according to a (univariate) normal mixture model, and the main mode corresponds to the cluster with the largest mean. The maximum number of mixture components corresponds to the <code>K_max</code> argument. The <span class="pkg">mclust</span> library is used for this purpose. The inference for the latent cure status of each (censored) observation is based on the MCMC draws corresponding to the main mode of the posterior distribution. The FDR is controlled according to the technique proposed in Papastamoulis and Rattray (2018). 
</p>
<p>In case where <code>covariate_levels</code> is set to <code>TRUE</code>, the <code>summary</code> function also returns a list named <code>p_cured_output</code> with the following entries
</p>

<dl>
<dt>mcmc</dt><dd><p>It is returned only in the case where the argument <code>covariate_values</code> is not <code>NULL</code>. A vector of posterior cured probabilities for the given values in <code>covariate_values</code>, per retained MCMC draw.</p>
</dd>
<dt>map</dt><dd><p>It is returned only in the case where the argument <code>covariate_values</code> is not <code>NULL</code>. The cured probabilities computed at the MAP estimate of the parameters, for the given values <code>covariate_values</code>.</p>
</dd>
<dt>tau_values</dt><dd><p>tau values</p>
</dd>
<dt>covariate_levels</dt><dd><p>covariate levels</p>
</dd>
<dt>index_of_main_mode</dt><dd><p>the subset of MCMC draws allocated to the main mode of the posterior distribution.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the following entries
</p>
<table role = "presentation">
<tr><td><code>map_estimate</code></td>
<td>
<p>Maximum A Posteriori (MAP) estimate of the parameters of the model.</p>
</td></tr>
<tr><td><code>highest_density_intervals</code></td>
<td>
<p>Highest Density Interval per parameter</p>
</td></tr>
<tr><td><code>latent_cured_status</code></td>
<td>
<p>Estimated posterior probabilities of the latent cure status per censored subject.</p>
</td></tr>
<tr><td><code>cured_at_given_FDR</code></td>
<td>
<p>Classification as cured or not, at given FDR level.</p>
</td></tr>
<tr><td><code>p_cured_output</code></td>
<td>
<p>It is returned only in the case where the argument <code>covariate_values</code> is not <code>NULL</code>. See details.</p>
</td></tr>
<tr><td><code>main_mode_index</code></td>
<td>
<p>The retained MCMC iterations which correspond to the main mode of the posterior distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2024). Bayesian inference and cure rate modeling for event history data. TEST doi: 10.1007/s11749-024-00942-w.
</p>
<p>Papastamoulis and Rattray (2018). A Bayesian Model Selection Approach for Identifying Differentially Expressed Transcripts from RNA Sequencing Data, Journal of the Royal Statistical Society Series C: Applied Statistics, Volume 67, Issue 1.
</p>
<p>Scrucca L, Fraley C, Murphy TB, Raftery AE (2023). Model-Based Clustering, Classification, and Density Estimation Using mclust in R. Chapman and Hall/CRC. ISBN 978-1032234953
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
	set.seed(10)
        n = 4
        # censoring indicators
        stat = rbinom(n, size = 1, prob = 0.5)
        # covariates
        x &lt;- matrix(rnorm(2*n), n, 2)
        # observed response variable 
        y &lt;- rexp(n)
#	define a data frame with the response and the covariates        
        my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
# run a weibull model with default prior setup
# considering 2 heated chains 
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, data = my_data_frame, 
		promotion_time = list(distribution = 'exponential'),
		nChains = 2, 
		nCores = 1, 
		mcmc_cycles = 3, sweep=2)
	newdata &lt;- data.frame(x1 = c(0.2,-1), x2 = c(-1,0))
	# return predicted values at tau = c(0.5, 1)
	my_prediction &lt;- predict(fit1, newdata = newdata, 
		burn = 0, tau_values = c(0.5, 1))

</code></pre>

<hr>
<h2 id='print.bayesCureModel'>
Print method
</h2><span id='topic+print.bayesCureModel'></span>

<h3>Description</h3>

<p>This function prints a summary of objects returned by the <code>cure_rate_MC3</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesCureModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bayesCureModel_+3A_x">x</code></td>
<td>

<p>An object of class <code>bayesCureModel</code>, which is returned by the <code>cure_rate_MC3</code> function.
</p>
</td></tr>
<tr><td><code id="print.bayesCureModel_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints some basic information for a <code>cure_rate_MC3</code>, such as the MAP estimate of model parameters and the value of Bayesian information criterion.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>

<hr>
<h2 id='print.predict_bayesCureModel'>
Print method for the <code>predict</code> object
</h2><span id='topic+print.predict_bayesCureModel'></span>

<h3>Description</h3>

<p>This function prints a summary of objects returned by the <code>predict.cure_rate_MC3</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict_bayesCureModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.predict_bayesCureModel_+3A_x">x</code></td>
<td>

<p>An object of class <code>predict_bayesCureModel</code>, which is returned by the <code>predict.cure_rate_MC3</code> method.
</p>
</td></tr>
<tr><td><code id="print.predict_bayesCureModel_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints some basic information for the <code>predict</code> method of a <code>bayesCureModel</code> object. 
</p>


<h3>Value</h3>

<p>No return value, called for side effects.</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>

<hr>
<h2 id='print.summary_bayesCureModel'>
Print method for the summary
</h2><span id='topic+print.summary_bayesCureModel'></span>

<h3>Description</h3>

<p>This function prints a summary of objects returned by the <code>summary.cure_rate_MC3</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_bayesCureModel'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary_bayesCureModel_+3A_x">x</code></td>
<td>

<p>An object of class <code>summary_bayesCureModel</code>, which is returned by the <code>summary.cure_rate_MC3</code> method.
</p>
</td></tr>
<tr><td><code id="print.summary_bayesCureModel_+3A_digits">digits</code></td>
<td>

<p>Number of digits to print.
</p>
</td></tr>
<tr><td><code id="print.summary_bayesCureModel_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints some basic information for the summary of a <code>bayesCureModel</code> object. 
</p>


<h3>Value</h3>

<p>No return value, called for side effects.</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>

<hr>
<h2 id='residuals.bayesCureModel'>
Computation of residuals.
</h2><span id='topic+residuals.bayesCureModel'></span>

<h3>Description</h3>

<p>Methods for computing residuals for an object of class <code>bayesCureModel</code>. The Cox-Snell residuals are available for now. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesCureModel'
residuals(object, type = "cox-snell",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.bayesCureModel_+3A_object">object</code></td>
<td>

<p>An object of class <code>bayesCureModel</code>
</p>
</td></tr>
<tr><td><code id="residuals.bayesCureModel_+3A_type">type</code></td>
<td>

<p>The type of residuals to be computed. 
</p>
</td></tr>
<tr><td><code id="residuals.bayesCureModel_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals.
</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2024). Bayesian inference and cure rate modeling for event history data. TEST doi: 10.1007/s11749-024-00942-w.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
	set.seed(10)
        n = 4
        # censoring indicators
        stat = rbinom(n, size = 1, prob = 0.5)
        # covariates
        x &lt;- matrix(rnorm(2*n), n, 2)
        # observed response variable 
        y &lt;- rexp(n)
#	define a data frame with the response and the covariates        
        my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
# run a weibull model with default prior setup
# considering 2 heated chains 
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, 
		data = my_data_frame, 
		promotion_time = list(distribution = 'exponential'),
		nChains = 2, 
		nCores = 1, 
		mcmc_cycles = 3, sweep=2)
	my_residuals &lt;- residuals(fit1)

</code></pre>

<hr>
<h2 id='sim_mix_data'>Simulated dataset</h2><span id='topic+sim_mix_data'></span>

<h3>Description</h3>

<p>A synthetic dataset generated from a bimodal promotion time distribution. The available covariates are: 
</p>

<dl>
<dt><code>x1</code> </dt><dd><p> continuous. </p>
</dd>
<dt><code>x2</code> </dt><dd><p> factor with three levels.</p>
</dd>
</dl>

<p>Among the 500 observations, there are 123 censoring times (<code>censoring = 0</code>) and 377 &quot;events&quot; (<code>censoring = 1</code>). The true status (cured or susceptible) is contained in the column <code>true_status</code> and contains 59 cured and 441 susceptible subjects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim_mix_data)</code></pre>


<h3>Format</h3>

<p>Time-to-event data.</p>

<hr>
<h2 id='summary.bayesCureModel'>
Summary method.
</h2><span id='topic+summary.bayesCureModel'></span>

<h3>Description</h3>

<p>This function produces all summaries after fitting a cure rate model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesCureModel'
summary(object, burn = NULL, gamma_mix = TRUE, 
	K_gamma = 3,  K_max = 3, fdr = 0.1, covariate_levels = NULL, 
	yRange = NULL, alpha = 0.1, quantiles = c(0.05, 0.5, 0.95), 
	verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesCureModel_+3A_object">object</code></td>
<td>

<p>An object of class <code>bayesCureModel</code>
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_burn">burn</code></td>
<td>

<p>Positive integer corresponding to the number of mcmc iterations to discard as burn-in period
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_gamma_mix">gamma_mix</code></td>
<td>

<p>Boolean. If TRUE, the density of the marginal posterior distribution of the <code class="reqn">\gamma</code> parameter is estimated from the sampled MCMC values by fitting a normal mixture  model.
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_k_gamma">K_gamma</code></td>
<td>

<p>Used only when <code>gamma_mix = TRUE</code> and corresponds to the number of normal mixture components used to estimate the marginal posterior density of the <code class="reqn">\gamma</code> parameter. 
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_k_max">K_max</code></td>
<td>

<p>Maximum number of components in order to cluster the (univariate) values of the joint posterior distribution across the MCMC run. Used to identify the main mode of the posterior distribution. See details. 
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_fdr">fdr</code></td>
<td>

<p>The target value for controlling the False Discovery Rate when classifying subjects as cured or not. 
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_covariate_levels">covariate_levels</code></td>
<td>

<p>Optional <code>data.frame</code> with new data for the covariates. It is only required when the user wishes to obtain a vector with the estimated posterior cured probabilities for a given combination of covariates. The column names should be exactly the same with the ones used in the input data. 
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_yrange">yRange</code></td>
<td>

<p>Optional range (a vector of two non-negative values) for computing the sequence of posterior probabilities for the given values in <code>covariate_levels</code>. 
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_alpha">alpha</code></td>
<td>

<p>Scalar between 0 and 1 corresponding to 1 - confidencel level for computing Highest Density Intervals. If set to NULL, the confidence intervals are not computed.
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_quantiles">quantiles</code></td>
<td>

<p>A vector of quantiles to evaluate for each variable.
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_verbose">verbose</code></td>
<td>

<p>Boolean: if TRUE the function prints the summary.
</p>
</td></tr>
<tr><td><code id="summary.bayesCureModel_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of the posterior draws are clustered according to a (univariate) normal mixture model, and the main mode corresponds to the cluster with the largest mean. The maximum number of mixture components corresponds to the <code>K_max</code> argument. The <span class="pkg">mclust</span> library is used for this purpose. The inference for the latent cure status of each (censored) observation is based on the MCMC draws corresponding to the main mode of the posterior distribution. The FDR is controlled according to the technique proposed in Papastamoulis and Rattray (2018). 
</p>
<p>In case where <code>covariate_levels</code> is set to <code>TRUE</code>, the <code>summary</code> function also returns a list named <code>p_cured_output</code> with the following entries
</p>

<dl>
<dt>mcmc</dt><dd><p>It is returned only in the case where the argument <code>covariate_values</code> is not <code>NULL</code>. A vector of posterior cured probabilities for the given values in <code>covariate_values</code>, per retained MCMC draw.</p>
</dd>
<dt>map</dt><dd><p>It is returned only in the case where the argument <code>covariate_values</code> is not <code>NULL</code>. The cured probabilities computed at the MAP estimate of the parameters, for the given values <code>covariate_values</code>.</p>
</dd>
<dt>tau_values</dt><dd><p>tau values</p>
</dd>
<dt>covariate_levels</dt><dd><p>covariate levels</p>
</dd>
<dt>index_of_main_mode</dt><dd><p>the subset of MCMC draws allocated to the main mode of the posterior distribution.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the following entries
</p>
<table role = "presentation">
<tr><td><code>map_estimate</code></td>
<td>
<p>Maximum A Posteriori (MAP) estimate of the parameters of the model.</p>
</td></tr>
<tr><td><code>highest_density_intervals</code></td>
<td>
<p>Highest Density Interval per parameter</p>
</td></tr>
<tr><td><code>latent_cured_status</code></td>
<td>
<p>Estimated posterior probabilities of the latent cure status per censored subject.</p>
</td></tr>
<tr><td><code>cured_at_given_FDR</code></td>
<td>
<p>Classification as cured or not, at given FDR level.</p>
</td></tr>
<tr><td><code>p_cured_output</code></td>
<td>
<p>It is returned only in the case where the argument <code>covariate_values</code> is not <code>NULL</code>. See details.</p>
</td></tr>
<tr><td><code>main_mode_index</code></td>
<td>
<p>The retained MCMC iterations which correspond to the main mode of the posterior distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2024). Bayesian inference and cure rate modeling for event history data. TEST doi: 10.1007/s11749-024-00942-w.
</p>
<p>Papastamoulis and Rattray (2018). A Bayesian Model Selection Approach for Identifying Differentially Expressed Transcripts from RNA Sequencing Data, Journal of the Royal Statistical Society Series C: Applied Statistics, Volume 67, Issue 1.
</p>
<p>Scrucca L, Fraley C, Murphy TB, Raftery AE (2023). Model-Based Clustering, Classification, and Density Estimation Using mclust in R. Chapman and Hall/CRC. ISBN 978-1032234953
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
	set.seed(10)
        n = 4
        # censoring indicators
        stat = rbinom(n, size = 1, prob = 0.5)
        # covariates
        x &lt;- matrix(rnorm(2*n), n, 2)
        # observed response variable 
        y &lt;- rexp(n)
#	define a data frame with the response and the covariates        
        my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
# run a weibull model with default prior setup
# considering 2 heated chains 
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, 
		data = my_data_frame, 
		promotion_time = list(distribution = 'exponential'),
		nChains = 2, 
		nCores = 1, 
		mcmc_cycles = 3, sweep=2)
	mySummary &lt;- summary(fit1, burn = 0)

</code></pre>

<hr>
<h2 id='summary.predict_bayesCureModel'>
Summary method for predictions.
</h2><span id='topic+summary.predict_bayesCureModel'></span>

<h3>Description</h3>

<p>This function produces MCMC summaries for an object of class <code>predict_bayesCureModel</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict_bayesCureModel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.predict_bayesCureModel_+3A_object">object</code></td>
<td>

<p>An object of class <code>predict_bayesCureModel</code>.
</p>
</td></tr>
<tr><td><code id="summary.predict_bayesCureModel_+3A_...">...</code></td>
<td>

<p>Other options passed to the <code>summary.mcmc</code> method of the <code>coda</code> package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries
</p>
<table role = "presentation">
<tr><td><code>survival</code></td>
<td>
<p>MCMC summaries (quantiles) for the survival function.</p>
</td></tr>
<tr><td><code>cured_probability</code></td>
<td>
<p>MCMC summaries (quantiles) for the conditional cured probability.</p>
</td></tr>
<tr><td><code>cumulative_hazard</code></td>
<td>
<p>MCMC summaries (quantiles) for the cumulative hazard function.</p>
</td></tr>
<tr><td><code>hazard_rate</code></td>
<td>
<p>MCMC summaries (quantiles) for the hazard rate function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Papastamoulis and Milienos (2024). Bayesian inference and cure rate modeling for event history data. TEST doi: 10.1007/s11749-024-00942-w.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cure_rate_MC3">cure_rate_MC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate toy data just for cran-check purposes        
	set.seed(10)
	n = 4
	# censoring indicators
	stat = rbinom(n, size = 1, prob = 0.5)
	# covariates
	x &lt;- matrix(rnorm(2*n), n, 2)
	# observed response variable 
	y &lt;- rexp(n)
#       define a data frame with the response and the covariates        
	my_data_frame &lt;- data.frame(y, stat, x1 = x[,1], x2 = x[,2])
# run a weibull model with default prior setup
# considering 2 heated chains 
	fit1 &lt;- cure_rate_MC3(survival::Surv(y, stat) ~ x1 + x2, data = my_data_frame, 
	     promotion_time = list(distribution = 'exponential'),
	     nChains = 2, 
	     nCores = 1, 
	     mcmc_cycles = 3, sweep=2)
	newdata &lt;- data.frame(x1 = c(0.2,-1), x2 = c(-1,0))
	# return predicted values at tau = c(0.5, 1)
	my_prediction &lt;- predict(fit1, newdata = newdata, 
	     burn = 0, tau_values = c(0.5, 1))
	my_summary &lt;- summary(my_prediction, quantiles = c(0.1,0.9))		
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
