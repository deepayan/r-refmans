<!DOCTYPE html><html><head><title>Help for package slouch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {slouch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#artiodactyla'><p>Artiodactyla Phylogeny</p></a></li>
<li><a href='#brown.fit'><p>Function to fit Brownian-motion models of trait evolution</p></a></li>
<li><a href='#hillclimbplot'><p>Plot the hillclimber trajectory</p></a></li>
<li><a href='#logLik.slouch'><p>Extract Log-Likelihood</p></a></li>
<li><a href='#lseq'><p>Logarithmically spaced sequence</p></a></li>
<li><a href='#neocortex'><p>Artiodactyl brain data</p></a></li>
<li><a href='#plot.slouch'><p>Plot Grid Search</p></a></li>
<li><a href='#print.slouch'><p>Print, minimalist output</p></a></li>
<li><a href='#regimeplot.slouch'><p>Plot the internal regimes for a given fitted model</p></a></li>
<li><a href='#slouch-package'><p>SLOUCH: Stochastic Linear Ornstein Uhlenbeck Comparative Hypotheses</p></a></li>
<li><a href='#slouch.fit'><p>Function to fit Ornstein-Uhlenbeck models of trait evolution</p></a></li>
<li><a href='#summary.slouch'><p>Model Summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stochastic Linear Ornstein-Uhlenbeck Comparative Hypotheses</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-15</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of a phylogenetic comparative method. It can fit univariate among-species Ornstein-Uhlenbeck models of phenotypic trait evolution, where the trait evolves towards a primary optimum. The optimum can be modelled as a single parameter, as multiple discrete regimes on the phylogenetic tree, and/or with continuous covariates. See also Hansen (1997) &lt;<a href="https://doi.org/10.2307%2F2411186">doi:10.2307/2411186</a>&gt;, Butler &amp; King (2004) &lt;<a href="https://doi.org/10.1086%2F426002">doi:10.1086/426002</a>&gt;, Hansen et al. (2008) &lt;<a href="https://doi.org/10.1111%2Fj.1558-5646.2008.00412.x">doi:10.1111/j.1558-5646.2008.00412.x</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>FALSE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>FALSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), base, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>crayon, parallel, ape, memoise</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kopperud/slouch">https://github.com/kopperud/slouch</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kopperud/slouch/issues">https://github.com/kopperud/slouch/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 14:04:16 UTC; bkopper</td>
</tr>
<tr>
<td>Author:</td>
<td>Bjørn Tore Kopperud [aut, cre],
  Jason Pienaar [aut],
  Kjetil Lysne Voje [aut],
  Steven Hecht Orzack [aut],
  Thomas F. Hansen [aut],
  Mark Grabowski [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bjørn Tore Kopperud &lt;kopperud@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='artiodactyla'>Artiodactyla Phylogeny</h2><span id='topic+artiodactyla'></span>

<h3>Description</h3>

<p>A phylogenetic tree of Artiodactyla (even-toed ungulates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(artiodactyla)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"phylo"</code>, from package <code>"ape"</code>.
</p>


<h3>References</h3>

<p>The tree is taken from Toljagic et al. (2017).
</p>

<ul>
<li><p>Toljagić, O., Voje, K. L., Matschiner, M., Liow, L. H., &amp; Hansen, T. F. (2017). Millions of years behind: Slow adaptation of ruminants to grasslands. Systematic Biology, (318). https://doi.org/10.1093/sysbio/syx059
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(artiodactyla)
library(ape)
plot(artiodactyla)

# Note: This tree also has regime information for each internal node in the tree:
print(artiodactyla$node.label)

</code></pre>

<hr>
<h2 id='brown.fit'>Function to fit Brownian-motion models of trait evolution</h2><span id='topic+brown.fit'></span>

<h3>Description</h3>

<p>Function to fit Brownian-motion models of trait evolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brown.fit(
  phy,
  species = NULL,
  sigma2_y_values = NULL,
  response,
  mv.response = NULL,
  fixed.fact = NULL,
  direct.cov = NULL,
  mv.direct.cov = NULL,
  mcov.direct.cov = NULL,
  random.cov = NULL,
  mv.random.cov = NULL,
  mcov.random.cov = NULL,
  ace = NULL,
  anc_maps = "regimes",
  estimate.Ya = FALSE,
  interactions = FALSE,
  hessian = FALSE,
  support = 2,
  convergence = 1e-06,
  nCores = 1,
  hillclimb = TRUE,
  lower = 1e-08,
  upper = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brown.fit_+3A_phy">phy</code></td>
<td>
<p>an object of class 'phylo', must be rooted.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_species">species</code></td>
<td>
<p>a character vector of species tip labels, typically the &quot;species&quot; column in a data frame. This column needs to be an exact match and same order as phy$tip.label</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_sigma2_y_values">sigma2_y_values</code></td>
<td>
<p>a vector of one or more candidates for sigma squared (y) to be evaluated in grid search.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_response">response</code></td>
<td>
<p>a numeric vector of a trait to be treated as response variable</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_mv.response">mv.response</code></td>
<td>
<p>numeric vector of the observational variances of each response trait. E.g if response is a mean trait value, mv.response is the within-species squared standard error of the mean.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_fixed.fact">fixed.fact</code></td>
<td>
<p>factor of regimes on the terminal edges of the tree, in same order as species. If this is used, phy$node.label needs to be filled with the corresponding internal node regimes, in the order of node indices (root: n+1),(n+2),(n+3), ...</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_direct.cov">direct.cov</code></td>
<td>
<p>Direct effect independent variables</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_mv.direct.cov">mv.direct.cov</code></td>
<td>
<p>Estimation variances for direct effect independent variables. Must be the same shape as direct.cov</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_mcov.direct.cov">mcov.direct.cov</code></td>
<td>
<p>Estimation covariances between the response variable and direct effect independent variables. Most be the same shape as direct.cov</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_random.cov">random.cov</code></td>
<td>
<p>Independent variables each modeled as a brownian motion</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_mv.random.cov">mv.random.cov</code></td>
<td>
<p>Estimation variances for the brownian covariates. Must be the same shape as random.cov</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_mcov.random.cov">mcov.random.cov</code></td>
<td>
<p>Estimation covariances between the response variable and random effect independent variables. Most be the same shape as random.cov</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_ace">ace</code></td>
<td>
<p>An ape::ace object, with estimated ancestral character states. Optional</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_anc_maps">anc_maps</code></td>
<td>
<p>One of &quot;regimes&quot;, &quot;ace&quot; or &quot;simmap&quot;. &quot;regimes&quot; tells slouch to use 'phy$node.label' to assign internal regimes. &quot;ace&quot; tells slouch to use ancestral posterior probabilities for ancestral regimes. &quot;simmap&quot; tells slouch to use the simmap mappings associated with 'phy'</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_estimate.ya">estimate.Ya</code></td>
<td>
<p>independently estimates the ancestral state under Brownian motion. Note that, for an intercept model, the intercept IS the ancestral state estimate (since there are no directional or stabilizing trends in a standard Brownian motion).</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_interactions">interactions</code></td>
<td>
<p>a logical value. Whether to model interactions between (all) direct-effect continuous covariates and categorical regimes (experimental). Defaults to FALSE</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_hessian">hessian</code></td>
<td>
<p>use the approximate hessian matrix at the likelihood peak as found by the hillclimber, to compute standard errors for the parameters that enter in parameter search.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_support">support</code></td>
<td>
<p>a scalar indicating the size of the support set, defaults to 2 units of log-likelihood.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_convergence">convergence</code></td>
<td>
<p>threshold of iterative GLS estimation for when beta is considered to be converged.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_ncores">nCores</code></td>
<td>
<p>number of CPU cores used in grid-search. If 2 or more cores are used, all print statements are silenced during grid search. If performance is critical it is recommended to compile and link R to a multithreaded BLAS, since most of the heavy computations are common matrix operations. Even if a singlethreaded BLAS is used, this may or may not improve performance, and performance may vary with OS.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_hillclimb">hillclimb</code></td>
<td>
<p>logical, whether to use hillclimb parameter estimation routine or not. This routine (L-BFGS-B from optim()) may be combined with the grid-search, in which case it will on default start on the sigma and halflife for the local ML found by the grid-search.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_lower">lower</code></td>
<td>
<p>lower bounds for the optimization routine, defaults to 1e-8. When running direct effect models without observational error, it may be useful to specify a positive lower bounds for the sigma squared, since the residual variance-covariance matrix is degenerate when sigma = 0.</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_upper">upper</code></td>
<td>
<p>upper bounds for the optimization routine, defaults to 10 * var(response) * max(treeheight).</p>
</td></tr>
<tr><td><code id="brown.fit_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether to print a summary in each iteration of parameter search. May be useful when diagnosing unexpected behaviour or crashes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'slouch', essentially a list with the following fields:
</p>
<table>
<tr><td><code>parameter_space</code></td>
<td>
<p>a list of the entire parameter space traversed by the grid search and the hillclimber as applicable.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>a list of parameters concerning the tree:
</p>

<ul>
<li><p>phy - an object of class 'phy'
</p>
</li>
<li><p>T.term - a numeric vector including the time from the root of the tree to the tip, for all taxa 1,2,3... n.
</p>
</li>
<li><p>ta - for all pairs of species, the time from their most recent common ancestor (mrca) to the root of the tree.
</p>
</li>
<li><p>tia - for all pairs of species, the time from their mrca to the tip of species i.
</p>
</li>
<li><p>tja - the transpose of tia.
</p>
</li>
<li><p>tij - for all pairs of species, the time from species i to their mrca, plus the time from their mrca to species j. In other words, tia + transpose(tia).
</p>
</li>
<li><p>times - for all nodes (1,2,3... n, root, root+1, ...) in the tree, the time from the root to said node. 
</p>
</li>
<li><p>lineages - for all species (1,2,3... n), a list of their branch times and regimes as painted on the tree.
</p>
</li>
<li><p>regimes - for all nodes (1,2,3... n, root, root+1, ...) in the tree, the respective regime as specified by &quot;<code>phy$node.label</code>&quot; and &quot;<code>fixed.fact</code>&quot;.
</p>
</li></ul>

</td></tr>
<tr><td><code>modfit</code></td>
<td>
<p>a list of statistics to characterize model fit</p>
</td></tr>
<tr><td><code>supportplot</code></td>
<td>
<p>a list or matrix used to plot the grid search</p>
</td></tr>
<tr><td><code>supported_range</code></td>
<td>
<p>a matrix indicating the interval of grid search that is within the support region. If the grid search values are carefully selected, this may be used to estimate the true support region.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>the residual variance-covariance matrix for the maximum likelihood model as found by parameter search.</p>
</td></tr>
<tr><td><code>evolpar</code></td>
<td>
<p>maximum likelihood estimates of parameters under the chosen model.</p>
</td></tr>
<tr><td><code>beta_primary</code></td>
<td>
<p>regression coefficients and associated objects. Whether the regression coefficients are to be interpreted as optima or not depend on the type of model and model estimates.</p>
</td></tr>
<tr><td><code>beta_evolutionary</code></td>
<td>
<p>under a random effect model, &quot;beta_evolutionary&quot; is the evolutionary regression coefficients and associated objects.</p>
</td></tr>
<tr><td><code>n.par</code></td>
<td>
<p>number of free parameters with which the likelihood criteria are penalized.</p>
</td></tr>
<tr><td><code>brownian_predictors</code></td>
<td>
<p>under a random effect model, a matrix of means and standard errors for the independent Brownian motion variable(s). Not to be confused with the regression coefficients when the residuals are under a &quot;bm&quot; model.</p>
</td></tr>
<tr><td><code>climblog_df</code></td>
<td>
<p>a matrix of the path trajectory of the hillclimber routine.</p>
</td></tr>
<tr><td><code>fixed.fact</code></td>
<td>
<p>the respective regimes for all species (1,2,3... n).</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>internal parameters for control flow.</p>
</td></tr>
</table>

<hr>
<h2 id='hillclimbplot'>Plot the hillclimber trajectory</h2><span id='topic+hillclimbplot'></span><span id='topic+hillclimbplot.slouch'></span>

<h3>Description</h3>

<p>Plot the hillclimber trajectory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hillclimbplot(x, ...)

## S3 method for class 'slouch'
hillclimbplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hillclimbplot_+3A_x">x</code></td>
<td>
<p>An object of class 'slouch'</p>
</td></tr>
<tr><td><code id="hillclimbplot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'plot.default(...)'</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>hillclimbplot(slouch)</code>: Hillclimbplot for the 'slouch object'
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(slouch)
library(ape)

data(neocortex)
data(artiodactyla)

neocortex &lt;- neocortex[match(artiodactyla$tip.label, neocortex$species), ]

m0 &lt;- slouch.fit(phy = artiodactyla,
                species = neocortex$species,
                response = neocortex$neocortex_area_mm2_log_mean,
                mv.response = neocortex$neocortex_se_squared,
                hillclimb = TRUE)
                
hillclimbplot(m0)

m1 &lt;- brown.fit(phy = artiodactyla,
               species = neocortex$species,
               response = neocortex$neocortex_area_mm2_log_mean,
               mv.response = neocortex$neocortex_se_squared,
               hillclimb = TRUE)
               
hillclimbplot(m1)
</code></pre>

<hr>
<h2 id='logLik.slouch'>Extract Log-Likelihood</h2><span id='topic+logLik.slouch'></span>

<h3>Description</h3>

<p>Extract Log-Likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slouch'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.slouch_+3A_object">object</code></td>
<td>
<p>An object of class 'slouch'</p>
</td></tr>
<tr><td><code id="logLik.slouch_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'logLik'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(artiodactyla)
data(neocortex)

neocortex &lt;- neocortex[match(artiodactyla$tip.label, neocortex$species), ]

m0 &lt;- slouch.fit(phy = artiodactyla,
                 species = neocortex$species,
                 response = neocortex$body_mass_g_log_mean,
                 mv.response = neocortex$body_mass_g_log_varmean,
                 fixed.fact = neocortex$diet,
                 hillclimb = TRUE)
                 
logLik(m0)
</code></pre>

<hr>
<h2 id='lseq'>Logarithmically spaced sequence</h2><span id='topic+lseq'></span>

<h3>Description</h3>

<p>Logarithmically spaced sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lseq(from = 1, to = 1e+05, length.out = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lseq_+3A_from">from</code></td>
<td>
<p>the starting value of the sequence. Must be positive.</p>
</td></tr>
<tr><td><code id="lseq_+3A_to">to</code></td>
<td>
<p>the terminal value of the sequence. Must be larger than input to &quot;from&quot;.</p>
</td></tr>
<tr><td><code id="lseq_+3A_length.out">length.out</code></td>
<td>
<p>desired length of the sequence. Must not be negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence of logarithmically spaced numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lseq(1, 1000, length.out = 4)
</code></pre>

<hr>
<h2 id='neocortex'>Artiodactyl brain data</h2><span id='topic+neocortex'></span>

<h3>Description</h3>

<p>Morphological data on mean neocortex area (mm^2), mean brain size (g) and mean body size (g) for 43 species, including estimates of within-species observational error. These standard errors are not based directly on the unbiased sample variance estimator. The sample variances were first calculated, then a &quot;global sample variance&quot; was estimated using a weighted average. Lastly, the global sample variance was divided by the respective within-species sample size for each species to obtain the squared standard error as reported in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neocortex)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>References</h3>

<p>The following literature includes details on the original data collection.
</p>

<ul>
<li><p>Haarmann, K., &amp; Oboussier, H. (1972). Morphologishce und quantitative Neocortexuntersuchungen bei Boviden, ein Beitrag zur Phylogenie dieser Familie. II. Formen geringen Körpergewichts (3kg - 25kg) aus den Subfamilien Cephalophinae und Antilopinae. Mitteilungen Aus Dem Hamburgischen Zoologischen Museum Und Institut, 68, 231–269.
</p>
</li>
<li><p>Oboussier, H. (1972). Morphologische und quantitative Neocortexuntersuchungen bei Boviden, ein Beitrag zur Phylogenie dieser Familie III. Formen über 75 kg Körpergewicht. Mitteilungen Aus Dem Hamburgischen Zoologischen Museum Und Institut, 68, 271–292.
</p>
</li>
<li><p>Oboussier, H. (1978). Zur Kenntnis des Bergnyalas (Tragelaphus buxtoni) und des Bongos (Taurotragus euryceros). Untersuchungen über den Körperbau und das Gehirn. Zeitschrift Für Säugetierkunde, 43, 114–125.
</p>
</li>
<li><p>Oboussier, H., &amp; Möller, G. (1971). Zur Kenntnis des Gehirns der Giraffidae (Pecora, Artiodactyla, Mammalia) - ein Vergleich der Neocortex-Oberflåachengrösse). Zeitschrift Für Säugetierkunde, 36, 291–296.
</p>
</li>
<li><p>Ronnefeld, U. (1970). Morphologische und quantitative Neocortexuntersuchungen bei Boviden, ein Beitrag zur Phylogenie dieser Familie. I. Formen mittlerer Körpergrösse (25 kg bis 75 kg). Gegenbaurs Morphologische Jahrbuch, 161–230.
</p>
</li></ul>

<p>See also:
</p>

<ul>
<li><p>Haarmann, K. (1975). Morphological and histological study of neocortex of bovides (Antilopinae, Cephalophinae) and Tragulidae with comments on evolutionary development. Journal Fur Hirnforschung, 16, 93–116.
</p>
</li>
<li><p>Oboussier, H. (1979). Evolution of the brain and phylogenetic development of African Bovidae. South African Journal of Zoology, 14(3), 119–124. https://doi.org/10.1080/02541858.1979.11447660
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(neocortex)
plot(neocortex$brain_mass_g_log_mean, neocortex$neocortex_area_mm2_log_mean)

</code></pre>

<hr>
<h2 id='plot.slouch'>Plot Grid Search</h2><span id='topic+plot.slouch'></span>

<h3>Description</h3>

<p>Graphical plot of parameter space traversed by the grid search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slouch'
plot(x, theta = 30, phi = 30, expand = 0.5, shade = 0.75, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.slouch_+3A_x">x</code></td>
<td>
<p>An object of class 'slouch'</p>
</td></tr>
<tr><td><code id="plot.slouch_+3A_theta">theta</code>, <code id="plot.slouch_+3A_phi">phi</code></td>
<td>
<p>angles defining the viewing direction.
<code>theta</code> gives the azimuthal direction and <code>phi</code>
the colatitude.</p>
</td></tr>
<tr><td><code id="plot.slouch_+3A_expand">expand</code></td>
<td>
<p>a expansion factor applied to the <code>z</code>
coordinates. Often used with <code>0 &lt; expand &lt; 1</code> to shrink the
plotting box in the <code>z</code> direction.</p>
</td></tr>
<tr><td><code id="plot.slouch_+3A_shade">shade</code></td>
<td>
<p>the shade at a surface facet is computed as
<code>((1+d)/2)^shade</code>, where <code>d</code> is the dot product of
a unit vector normal to the facet and a unit vector in the
direction of a light source.  Values of <code>shade</code> close
to one yield shading similar to a point light source model
and values close to zero produce no shading.  Values in the
range 0.5 to 0.75 provide an approximation to daylight
illumination.</p>
</td></tr>
<tr><td><code id="plot.slouch_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to persp(...) or plot(...)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(artiodactyla)
data(neocortex)

neocortex &lt;- neocortex[match(artiodactyla$tip.label, neocortex$species), ]

m0 &lt;- slouch.fit(phy = artiodactyla,
                 hl_values = seq(0.001, 50, length.out = 15),
                 vy_values = seq(0.001, 3, length.out = 15),
                 species = neocortex$species,
                 response = neocortex$body_mass_g_log_mean,
                 mv.response = neocortex$body_mass_g_log_varmean,
                 fixed.fact = neocortex$diet)
                 
plot(m0)
</code></pre>

<hr>
<h2 id='print.slouch'>Print, minimalist output</h2><span id='topic+print.slouch'></span>

<h3>Description</h3>

<p>Print, minimalist output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slouch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.slouch_+3A_x">x</code></td>
<td>
<p>An object of class 'slouch'</p>
</td></tr>
<tr><td><code id="print.slouch_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(artiodactyla)
data(neocortex)

neocortex &lt;- neocortex[match(artiodactyla$tip.label, neocortex$species), ]

m0 &lt;- slouch.fit(phy = artiodactyla,
                 hl_values = seq(0.001, 4, length.out = 10),
                 vy_values = seq(0.001, 0.05, length.out = 10),
                 species = neocortex$species,
                 response = neocortex$neocortex_area_mm2_log_mean,
                 mv.response = neocortex$neocortex_se_squared,
                 random.cov = neocortex$brain_mass_g_log_mean,
                 mv.random.cov = neocortex$brain_se_squared,
                 fixed.fact = neocortex$diet,
                 hillclimb = FALSE)
</code></pre>

<hr>
<h2 id='regimeplot.slouch'>Plot the internal regimes for a given fitted model</h2><span id='topic+regimeplot.slouch'></span><span id='topic+regimeplot'></span>

<h3>Description</h3>

<p>Plot the internal regimes for a given fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slouch'
regimeplot(x, ...)

regimeplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regimeplot.slouch_+3A_x">x</code></td>
<td>
<p>an object of class 'slouch'</p>
</td></tr>
<tr><td><code id="regimeplot.slouch_+3A_...">...</code></td>
<td>
<p>additional parameters passed to plot.phylo(...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>regimeplot(slouch)</code>: Regimeplot for the 'slouch' object
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
data(artiodactyla)
data(neocortex)

neocortex &lt;- neocortex[match(artiodactyla$tip.label, neocortex$species), ]

m0 &lt;- slouch.fit(phy = artiodactyla,
                 species = neocortex$species,
                 response = neocortex$body_mass_g_log_mean,
                 mv.response = neocortex$body_mass_g_log_varmean,
                 fixed.fact = neocortex$diet,
                 hillclimb = TRUE)
                 
regimeplot(m0)

</code></pre>

<hr>
<h2 id='slouch-package'>SLOUCH: Stochastic Linear Ornstein Uhlenbeck Comparative Hypotheses</h2><span id='topic+slouch'></span><span id='topic+slouch-package'></span>

<h3>Description</h3>

<p>An implementation of a phylogenetic comparative method. It can fit univariate among-species Ornstein-Uhlenbeck models of phenotypic trait evolution, where the trait evolves towards a primary optimum. The optimum can be modelled as a single parameter, as multiple discrete regimes on the phylogenetic tree, and/or with continuous covariates. See also Hansen (1997) <a href="https://doi.org/10.2307/2411186">doi:10.2307/2411186</a>, Butler &amp; King (2004) <a href="https://doi.org/10.1086/426002">doi:10.1086/426002</a>, Hansen et al. (2008) <a href="https://doi.org/10.1111/j.1558-5646.2008.00412.x">doi:10.1111/j.1558-5646.2008.00412.x</a>.
</p>


<h3>References</h3>


<ul>
<li><p> Hansen, T. F. (1997). Stabilizing Selection and the Comparative Analysis of Adaptation. Evolution, 51(5), 1341. https://doi.org/10.2307/2411186
</p>
</li>
<li><p> Hansen, T. F., Pienaar, J., &amp; Orzack, S. H. (2008). A comparative method for studying adaptation to a randomly evolving environment. Evolution, 62(8), 1965–1977. https://doi.org/10.1111/j.1558-5646.2008.00412.x
</p>
</li>
<li><p> Labra, A., Pienaar, J., &amp; Hansen, T. F. (2009). Evolution of Thermal Physiology in Liolaemus Lizards: Adaptation, Phylogenetic Inertia, and Niche Tracking. The American Naturalist, 174(2), 204–220. https://doi.org/10.1086/600088
</p>
</li>
<li><p> Hansen, T. F., &amp; Bartoszek, K. (2012). Interpreting the evolutionary regression: The interplay between observational and biological errors in phylogenetic comparative studies. Systematic Biology, 61(3), 413–425. https://doi.org/10.1093/sysbio/syr122
</p>
</li>
<li><p> Escudero, M., Hipp, A. L., Hansen, T. F., Voje, K. L., &amp; Luceño, M. (2012). Selection and inertia in the evolution of holocentric chromosomes in sedges (Carex, Cyperaceae). New Phytologist, 195(1), 237–247. https://doi.org/10.1111/j.1469-8137.2012.04137.x
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Bjørn Tore Kopperud <a href="mailto:kopperud@protonmail.com">kopperud@protonmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jason Pienaar
</p>
</li>
<li><p> Kjetil Lysne Voje
</p>
</li>
<li><p> Steven Hecht Orzack
</p>
</li>
<li><p> Thomas F. Hansen
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Mark Grabowski [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/kopperud/slouch">https://github.com/kopperud/slouch</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/kopperud/slouch/issues">https://github.com/kopperud/slouch/issues</a>
</p>
</li></ul>


<hr>
<h2 id='slouch.fit'>Function to fit Ornstein-Uhlenbeck models of trait evolution</h2><span id='topic+slouch.fit'></span>

<h3>Description</h3>

<p>Function to fit Ornstein-Uhlenbeck models of trait evolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slouch.fit(
  phy,
  species = NULL,
  hl_values = NULL,
  a_values = NULL,
  vy_values = NULL,
  sigma2_y_values = NULL,
  response,
  mv.response = NULL,
  fixed.fact = NULL,
  direct.cov = NULL,
  mv.direct.cov = NULL,
  mcov.direct.cov = NULL,
  random.cov = NULL,
  mv.random.cov = NULL,
  mcov.random.cov = NULL,
  ace = NULL,
  anc_maps = "regimes",
  estimate.Ya = FALSE,
  estimate.bXa = FALSE,
  interactions = FALSE,
  hessian = FALSE,
  support = 2,
  convergence = 1e-06,
  nCores = 1,
  hillclimb = TRUE,
  lower = c(1e-08, 1e-08),
  upper = Inf,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slouch.fit_+3A_phy">phy</code></td>
<td>
<p>an object of class 'phylo', must be rooted.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_species">species</code></td>
<td>
<p>a character vector of species tip labels, typically the &quot;species&quot; column in a data frame. This column needs to be an exact match and same order as phy$tip.label</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_hl_values">hl_values</code></td>
<td>
<p>a vector of candidate phylogenetic half-life values to be evaluated in grid search. Optional.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_a_values">a_values</code></td>
<td>
<p>a vector of candidate rate of adaptation values to be evaluated in grid search. Optional.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_vy_values">vy_values</code></td>
<td>
<p>a vector of candidate stationary variances for the response trait, to be evaluated in grid search. Optional.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_sigma2_y_values">sigma2_y_values</code></td>
<td>
<p>alternative to vy_values, if the stationary variance is reparameterized as the variance parameter for the Brownian motion.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_response">response</code></td>
<td>
<p>a numeric vector of a trait to be treated as response variable</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_mv.response">mv.response</code></td>
<td>
<p>numeric vector of the observational variances of each response trait. E.g if response is a mean trait value, mv.response is the within-species squared standard error of the mean.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_fixed.fact">fixed.fact</code></td>
<td>
<p>factor of regimes on the terminal edges of the tree, in same order as species. If this is used, phy$node.label needs to be filled with the corresponding internal node regimes, in the order of node indices (root: n+1),(n+2),(n+3), ...</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_direct.cov">direct.cov</code></td>
<td>
<p>Direct effect independent variables</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_mv.direct.cov">mv.direct.cov</code></td>
<td>
<p>Estimation variances for direct effect independent variables. Must be the same shape as direct.cov</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_mcov.direct.cov">mcov.direct.cov</code></td>
<td>
<p>Estimation covariances between the response variable and direct effect independent variables. Most be the same shape as direct.cov</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_random.cov">random.cov</code></td>
<td>
<p>Independent variables each modeled as a brownian motion</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_mv.random.cov">mv.random.cov</code></td>
<td>
<p>Estimation variances for the brownian covariates. Must be the same shape as random.cov</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_mcov.random.cov">mcov.random.cov</code></td>
<td>
<p>Estimation covariances between the response variable and random effect independent variables. Most be the same shape as random.cov</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_ace">ace</code></td>
<td>
<p>An ape::ace object, with estimated ancestral character states. Optional</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_anc_maps">anc_maps</code></td>
<td>
<p>One of &quot;regimes&quot;, &quot;ace&quot; or &quot;simmap&quot;. &quot;regimes&quot; tells slouch to use 'phy$node.label' to assign internal regimes. &quot;ace&quot; tells slouch to use ancestral posterior probabilities for ancestral regimes. &quot;simmap&quot; tells slouch to use the simmap mappings associated with 'phy'</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_estimate.ya">estimate.Ya</code></td>
<td>
<p>a logical value indicathing whether &quot;Ya&quot; should be estimated. If true, the intercept K = 1 is expanded to Ya = exp(-a*t) and b0 = 1-exp(-a*t). If models with categorical covariates are used, this will instead estimate a separate primary optimum for the root niche, &quot;Ya&quot;. This only makes sense for non-ultrametric trees. If the tree is ultrametric, the model matrix becomes singular.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_estimate.bxa">estimate.bXa</code></td>
<td>
<p>a logical value indicathing whether &quot;bXa&quot; should be estimated. If true, bXa = 1-exp(-a*t) - (1-(1-exp(-a*t))/(a*t)) is added to the model matrix, estimating b*Xa. Same requirements as for estimating Ya.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_interactions">interactions</code></td>
<td>
<p>a logical value. Whether to model interactions between (all) direct-effect continuous covariates and categorical regimes (experimental). Defaults to FALSE</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_hessian">hessian</code></td>
<td>
<p>use the approximate hessian matrix at the likelihood peak as found by the hillclimber, to compute standard errors for the parameters that enter in parameter search.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_support">support</code></td>
<td>
<p>a scalar indicating the size of the support set, defaults to 2 units of log-likelihood.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_convergence">convergence</code></td>
<td>
<p>threshold of iterative GLS estimation for when beta is considered to be converged.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_ncores">nCores</code></td>
<td>
<p>number of CPU cores used in grid-search. If 2 or more cores are used, all print statements are silenced during grid search. If performance is critical it is recommended to compile and link R to a multithreaded BLAS, since most of the heavy computations are common matrix operations. Even if a singlethreaded BLAS is used, this may or may not improve performance, and performance may vary with OS.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_hillclimb">hillclimb</code></td>
<td>
<p>logical, whether to use hillclimb parameter estimation routine or not. This routine (L-BFGS-B from optim()) may be combined with the grid-search, in which case it will on default start on the sigma and halflife for the local ML found by the grid-search.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_lower">lower</code></td>
<td>
<p>lower bounds for the optimization routine, defaults to c(0,0). First entry in vector is half-life, second is stationary variance. When running direct effect models without observational error, it may be useful to specify a positive lower bounds for the stationary variance, e.g c(0, 0.001), since the residual variance-covariance matrix is degenerate when sigma = 0.</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_upper">upper</code></td>
<td>
<p>upper bounds for the optimization routine, defaults to c(Inf, Inf).</p>
</td></tr>
<tr><td><code id="slouch.fit_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether to print a summary in each iteration of parameter search. May be useful when diagnosing unexpected behaviour or crashes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'slouch', essentially a list with the following fields:
</p>
<table>
<tr><td><code>parameter_space</code></td>
<td>
<p>a list of the entire parameter space traversed by the grid search and the hillclimber as applicable.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>a list of parameters concerning the tree:
</p>

<ul>
<li><p>phy - an object of class 'phy'
</p>
</li>
<li><p>T.term - a numeric vector including the time from the root of the tree to the tip, for all taxa 1,2,3... n.
</p>
</li>
<li><p>ta - for all pairs of species, the time from their most recent common ancestor (mrca) to the root of the tree.
</p>
</li>
<li><p>tia - for all pairs of species, the time from their mrca to the tip of species i.
</p>
</li>
<li><p>tja - the transpose of tia.
</p>
</li>
<li><p>tij - for all pairs of species, the time from species i to their mrca, plus the time from their mrca to species j. In other words, tia + transpose(tia).
</p>
</li>
<li><p>times - for all nodes (1,2,3... n, root, root+1, ...) in the tree, the time from the root to said node. 
</p>
</li>
<li><p>lineages - for all species (1,2,3... n), a list of their branch times and regimes as painted on the tree.
</p>
</li>
<li><p>regimes - for all nodes (1,2,3... n, root, root+1, ...) in the tree, the respective regime as specified by &quot;<code>phy$node.label</code>&quot; and &quot;<code>fixed.fact</code>&quot;.
</p>
</li></ul>

</td></tr>
<tr><td><code>modfit</code></td>
<td>
<p>a list of statistics to characterize model fit</p>
</td></tr>
<tr><td><code>supportplot</code></td>
<td>
<p>a list or matrix used to plot the grid search</p>
</td></tr>
<tr><td><code>supported_range</code></td>
<td>
<p>a matrix indicating the interval of grid search that is within the support region. If the grid search values are carefully selected, this may be used to estimate the true support region.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>the residual variance-covariance matrix for the maximum likelihood model as found by parameter search.</p>
</td></tr>
<tr><td><code>evolpar</code></td>
<td>
<p>maximum likelihood estimates of parameters under the chosen model.</p>
</td></tr>
<tr><td><code>beta_primary</code></td>
<td>
<p>regression coefficients and associated objects. Whether the regression coefficients are to be interpreted as optima or not depend on the type of model and model estimates.</p>
</td></tr>
<tr><td><code>beta_evolutionary</code></td>
<td>
<p>under a random effect model, &quot;beta_evolutionary&quot; is the evolutionary regression coefficients and associated objects.</p>
</td></tr>
<tr><td><code>n.par</code></td>
<td>
<p>number of free parameters with which the likelihood criteria are penalized.</p>
</td></tr>
<tr><td><code>brownian_predictors</code></td>
<td>
<p>under a random effect model, a matrix of means and standard errors for the independent Brownian motion variable(s). Not to be confused with the regression coefficients when the residuals are under a &quot;bm&quot; model.</p>
</td></tr>
<tr><td><code>climblog_df</code></td>
<td>
<p>a matrix of the path trajectory of the hillclimber routine.</p>
</td></tr>
<tr><td><code>fixed.fact</code></td>
<td>
<p>the respective regimes for all species (1,2,3... n).</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>internal parameters for control flow.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.slouch'>Model Summary</h2><span id='topic+summary.slouch'></span>

<h3>Description</h3>

<p>Model Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slouch'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.slouch_+3A_object">object</code></td>
<td>
<p>An object of class 'slouch'</p>
</td></tr>
<tr><td><code id="summary.slouch_+3A_...">...</code></td>
<td>
<p>Additional arguments, unused.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(artiodactyla)
data(neocortex)

neocortex &lt;- neocortex[match(artiodactyla$tip.label, neocortex$species), ]

m0 &lt;- slouch.fit(phy = artiodactyla,
                 hl_values = seq(0.001, 4, length.out = 10),
                 vy_values = seq(0.001, 0.05, length.out = 10),
                 species = neocortex$species,
                 response = neocortex$neocortex_area_mm2_log_mean,
                 mv.response = neocortex$neocortex_se_squared,
                 random.cov = neocortex$brain_mass_g_log_mean,
                 mv.random.cov = neocortex$brain_se_squared,
                 fixed.fact = neocortex$diet,
                 hillclimb = FALSE)
                 
summary(m0) 

plot(m0, theta = 150)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
