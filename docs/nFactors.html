<!DOCTYPE html><html lang="en"><head><title>Help for package nFactors</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nFactors}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nFactors'><p>nFactors: Number of factor or components to retain in a factor analysis</p></a></li>
<li><a href='#bentlerParameters'><p>Bentler and Yuan's Computation of the LRT Index and the Linear Trend</p>
Coefficients</a></li>
<li><a href='#componentAxis'><p>Principal Component Analysis With Only n First Components Retained</p></a></li>
<li><a href='#corFA'><p>Insert Communalities in the Diagonal of a Correlation or a Covariance Matrix</p></a></li>
<li><a href='#dFactors'><p>Eigenvalues from classical studies</p></a></li>
<li><a href='#diagReplace'><p>Replacing Upper or Lower Diagonal of a Correlation or Covariance Matrix</p></a></li>
<li><a href='#eigenBootParallel'><p>Bootstrapping of the Eigenvalues From a Data Frame</p></a></li>
<li><a href='#eigenComputes'><p>Computes Eigenvalues According to the Data Type</p></a></li>
<li><a href='#eigenFrom'><p>Identify the Data Type to Obtain the Eigenvalues</p></a></li>
<li><a href='#generateStructure'><p>Generate a Factor Structure Matrix</p></a></li>
<li><a href='#is.nFactors'><p>Utility Functions for nFactors Class Objects</p></a></li>
<li><a href='#iterativePrincipalAxis'><p>Iterative Principal Axis Analysis</p></a></li>
<li><a href='#makeCor'><p>Create a Full Correlation/Covariance Matrix from a Matrix With Lower Part Filled and Upper Part With Zeros</p></a></li>
<li><a href='#moreStats'><p>Statistical Summary of a Data Frame</p></a></li>
<li><a href='#nBartlett'><p>Bartlett, Anderson and Lawley Procedures to Determine the Number of Components/Factors</p></a></li>
<li><a href='#nBentler'><p>Bentler and Yuan's Procedure to Determine the Number of Components/Factors</p></a></li>
<li><a href='#nCng'><p>Cattell-Nelson-Gorsuch CNG Indices</p></a></li>
<li><a href='#nMreg'><p>Multiple Regression Procedure to Determine the Number of Components/Factors</p></a></li>
<li><a href='#nScree'><p>Non Graphical Cattel's Scree Test</p></a></li>
<li><a href='#nSeScree'><p>Standard Error Scree and Coefficient of Determination Procedures to</p>
Determine the Number of Components/Factors</a></li>
<li><a href='#parallel'><p>Parallel Analysis of a Correlation or Covariance Matrix</p></a></li>
<li><a href='#plotnScree'><p>Scree Plot According to a nScree Object Class</p></a></li>
<li><a href='#plotParallel'><p>Plot a Parallel Analysis Class Object</p></a></li>
<li><a href='#plotuScree'><p>Plot of the Usual Cattell's Scree Test</p></a></li>
<li><a href='#principalAxis'><p>Principal Axis Analysis</p></a></li>
<li><a href='#principalComponents'><p>Principal Component Analysis</p></a></li>
<li><a href='#rRecovery'><p>Test of Recovery of a Correlation or a Covariance matrix from a Factor</p>
Analysis Solution</a></li>
<li><a href='#structureSim'><p>Population or Simulated Sample Correlation Matrix from a Given Factor</p>
Structure Matrix</a></li>
<li><a href='#studySim'><p>Simulation Study from Given Factor Structure Matrices and Conditions</p></a></li>
<li><a href='#summary.nScree'><p>Utility Functions for nScree Class Objects</p></a></li>
<li><a href='#summary.structureSim'><p>Utility Functions for nScree Class Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parallel Analysis and Other Non Graphical Solutions to the
Cattell Scree Test</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Gilles Raiche (Universite du Quebec a Montreal) and David Magis (Universite de Liege)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gilles Raiche &lt;raiche.gilles@uqam.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Indices, heuristics and strategies to help determine the number of factors/components to retain:
                1. Acceleration factor (af with or without Parallel Analysis);
                2. Optimal Coordinates (noc with or without Parallel Analysis);
                3. Parallel analysis (components, factors and bootstrap);
                4. lambda &gt; mean(lambda) (Kaiser, CFA and related);
                5. Cattell-Nelson-Gorsuch (CNG);
                6. Zoski and Jurs multiple regression (b, t and p);
                7. Zoski and Jurs standard error of the regression coeffcient (sescree);
                8. Nelson R2;
                9. Bartlett khi-2;
               10. Anderson khi-2;
               11. Lawley khi-2 and
               12. Bentler-Yuan khi-2.</td>
</tr>
<tr>
<td>License:</td>
<td></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS, psych</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-10 11:47:48 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-10 12:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='nFactors'>nFactors: Number of factor or components to retain in a factor analysis</h2><span id='topic+nFactors'></span><span id='topic+nFactors-package'></span>

<h3>Description</h3>

<p>A package for determining the number of factor or components to retain in a factor analysis.
The methods are all based on eigenvalues.
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>

<hr>
<h2 id='bentlerParameters'>Bentler and Yuan's Computation of the LRT Index and the Linear Trend
Coefficients</h2><span id='topic+bentlerParameters'></span>

<h3>Description</h3>

<p>This function computes the Bentler and Yuan's (1996, 1998) <em>LRT</em> index
for the linear trend in eigenvalues of a covariance matrix.  The related
<code class="reqn">\chi^2</code> and <em>p</em>-value are also computed.  This function is
generally called from the <code>nBentler</code> function.  But it could be of use
for graphing the linear trend function and to study it's behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bentlerParameters(x, N, nFactors, log = TRUE, cor = TRUE,
  minPar = c(min(lambda) - abs(min(lambda)) + 0.001, 0.001),
  maxPar = c(max(lambda), lm(lambda ~ I(length(lambda):1))$coef[2]),
  resParx = c(0.01, 2), resPary = c(0.01, 2), graphic = TRUE,
  resolution = 30, typePlot = "wireframe", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bentlerParameters_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of
correlations or of covariances or a <code>data.frame</code> of data</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_n">N</code></td>
<td>
<p>numeric: number of subjects.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_nfactors">nFactors</code></td>
<td>
<p>numeric: number of components to test.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_log">log</code></td>
<td>
<p>logical: if <code>TRUE</code> the minimization is applied on the log
values.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation
matrix, else from a covariance matrix</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_minpar">minPar</code></td>
<td>
<p>numeric: minimums for the coefficient of the linear trend.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_maxpar">maxPar</code></td>
<td>
<p>numeric: maximums for the coefficient of the linear trend.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_resparx">resParx</code></td>
<td>
<p>numeric: restriction on the <code class="reqn">\alpha</code> coefficient (x) to
graph the function to minimize.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_respary">resPary</code></td>
<td>
<p>numeric: restriction on the <code class="reqn">\beta</code> coefficient (y) to
graph the function to minimize.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_graphic">graphic</code></td>
<td>
<p>logical: if <code>TRUE</code> plots the minimized function
<code>"wireframe"</code>, <code>"contourplot"</code> or <code>"levelplot"</code>.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_resolution">resolution</code></td>
<td>
<p>numeric: resolution of the 3D graph (number of points from
<code class="reqn">\alpha</code> and from <code class="reqn">\beta</code>).</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_typeplot">typePlot</code></td>
<td>
<p>character: plots the minimized function according to a 3D
plot: <code>"wireframe"</code>, <code>"contourplot"</code> or <code>"levelplot"</code>.</p>
</td></tr>
<tr><td><code id="bentlerParameters_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters from the <code>"wireframe"</code>,
<code>"contourplot"</code> or <code>"levelplot"</code> <code>lattice</code> functions. Also
additionnal parameters for the <code>eigenFrom</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented Bentler and Yuan's procedure must be used with care because
the minimized function is not always stable. In many cases, constraints must
applied to obtain a solution.  The actual implementation did, but the user
can modify these constraints.
</p>
<p>The hypothesis tested (Bentler and Yuan, 1996, equation 10) is: <br /> <br />
</p>
<p>(1) <code class="reqn">\qquad \qquad H_k: \lambda_{k+i} = \alpha + \beta x_i, (i = 1,
\ldots, q)</code> <br />
</p>
<p>The solution of the following simultaneous equations is needed to find
<code class="reqn">(\alpha, \beta) \in</code> <br />
</p>
<p>(2) <code class="reqn">\qquad \qquad f(x) = \sum_{i=1}^q \frac{ [ \lambda_{k+j} - N \alpha
+ \beta x_j ] x_j}{(\alpha + \beta x_j)^2} = 0</code> <br /> <br />
</p>
<p>and <code class="reqn">\qquad \qquad g(x) = \sum_{i=1}^q \frac{ \lambda_{k+j} - N \alpha +
\beta x_j x_j}{(\alpha + \beta x_j)^2} = 0</code> <br />
</p>
<p>The solution to this system of equations was implemented by minimizing the
following equation: <br />
</p>
<p>(3) <code class="reqn">\qquad \qquad (\alpha, \beta) \in \inf{[h(x)]} = \inf{\log{[f(x)^2
+ g(x)^2}}]</code> <br />
</p>
<p>The likelihood ratio test <code class="reqn">LRT</code> proposed by Bentler and Yuan (1996,
equation 7) follows a <code class="reqn">\chi^2</code> probability distribution with <code class="reqn">q-2</code>
degrees of freedom and is equal to: <br />
</p>
<p>(4) <code class="reqn">\qquad \qquad LRT = N(k - p)\left\{ {\ln \left( {{n \over N}}
\right) + 1} \right\} - N\sum\limits_{j = k + 1}^p {\ln \left\{ {{{\lambda
_j } \over {\alpha + \beta x_j }}} \right\}} + n\sum\limits_{j = k + 1}^p
{\left\{ {{{\lambda _j } \over {\alpha + \beta x_j }}} \right\}} </code> <br />
</p>
<p>With <code class="reqn">p</code> beeing the number of eigenvalues, <code class="reqn">k</code> the number of
eigenvalues to test, <code class="reqn">q</code> the <code class="reqn">p-k</code> remaining eigenvalues, <code class="reqn">N</code>
the sample size, and <code class="reqn">n = N-1</code>.  Note that there is an error in the
Bentler and Yuan equation, the variables <code class="reqn">N</code> and <code class="reqn">n</code> beeing inverted
in the preceeding equation 4.
</p>
<p>A better strategy proposed by Bentler an Yuan (1998) is to use a minimized
<code class="reqn">\chi^2</code> solution. This strategy will be implemented in a future version
of the <span class="pkg">nFactors</span> package.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nFactors</code></td>
<td>
<p> numeric: vector of the number of factors retained
by the Bentler and Yuan's procedure. </p>
</td></tr> <tr><td><code>details</code></td>
<td>
<p> numeric: matrix of
the details of the computation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
<br /> <br /> David Magis <br /> Departement de mathematiques <br /> Universite de Liege
<br /> <a href="mailto:David.Magis@ulg.ac.be">David.Magis@ulg.ac.be</a>
</p>


<h3>References</h3>

<p>Bentler, P. M. and Yuan, K.-H. (1996). Test of linear trend in
eigenvalues of a covariance matrix with application to data analysis.
<em>British Journal of Mathematical and Statistical Psychology, 49</em>,
299-312.
</p>
<p>Bentler, P. M. and Yuan, K.-H. (1998). Test of linear trend in the smallest
eigenvalues of the correlation matrix. <em>Psychometrika, 63</em>(2), 131-144.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nBartlett">nBartlett</a></code>, <code><a href="#topic+nBentler">nBentler</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ................................................
## SIMPLE EXAMPLE OF THE BENTLER AND YUAN PROCEDURE

# Bentler (1996, p. 309) Table 2 - Example 2 .............
n=649
bentler2&lt;-c(5.785, 3.088, 1.505, 0.582, 0.424, 0.386, 0.360, 0.337, 0.303,
            0.281, 0.246, 0.238, 0.200, 0.160, 0.130)

results  &lt;- nBentler(x=bentler2, N=n,  details=TRUE)
results

# Two different figures to verify the convergence problem identified with
# the 2th component
bentlerParameters(x=bentler2, N=n, nFactors= 2, graphic=TRUE,
                  typePlot="contourplot",
                  resParx=c(0,9), resPary=c(0,9), cor=FALSE)

bentlerParameters(x=bentler2, N=n, nFactors= 4, graphic=TRUE, drape=TRUE,
                  resParx=c(0,9), resPary=c(0,9),
                  scales = list(arrows = FALSE) )

plotuScree(x=bentler2, model="components",
  main=paste(results$nFactors,
  " factors retained by the Bentler and Yuan's procedure (1996, p. 309)",
  sep=""))
# ........................................................

# Bentler (1998, p. 140) Table 3 - Example 1 .............
n        &lt;- 145
example1 &lt;- c(8.135, 2.096, 1.693, 1.502, 1.025, 0.943, 0.901, 0.816,
              0.790,0.707, 0.639, 0.543,0.533, 0.509, 0.478, 0.390,
              0.382, 0.340, 0.334, 0.316, 0.297,0.268, 0.190, 0.173)

results  &lt;- nBentler(x=example1, N=n,  details=TRUE)
results

# Two different figures to verify the convergence problem identified with
# the 10th component
bentlerParameters(x=example1, N=n, nFactors= 10, graphic=TRUE,
                  typePlot="contourplot",
                  resParx=c(0,0.4), resPary=c(0,0.4))

bentlerParameters(x=example1, N=n, nFactors= 10, graphic=TRUE, drape=TRUE,
                  resParx=c(0,0.4), resPary=c(0,0.4),
                  scales = list(arrows = FALSE) )

plotuScree(x=example1, model="components",
   main=paste(results$nFactors,
   " factors retained by the Bentler and Yuan's procedure (1998, p. 140)",
   sep=""))
# ........................................................
</code></pre>

<hr>
<h2 id='componentAxis'>Principal Component Analysis With Only n First Components Retained</h2><span id='topic+componentAxis'></span>

<h3>Description</h3>

<p>The <code>componentAxis</code> function returns a principal component analysis
with the first <em>n</em> components retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>componentAxis(R, nFactors = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="componentAxis_+3A_r">R</code></td>
<td>
<p>numeric: correlation or covariance matrix</p>
</td></tr>
<tr><td><code id="componentAxis_+3A_nfactors">nFactors</code></td>
<td>
<p>numeric: number of components/factors to retain</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p> numeric: variance of each component/factor retained </p>
</td></tr>
<tr><td><code>varExplained</code></td>
<td>
<p> numeric: variance explained by each component/factor
retained </p>
</td></tr> <tr><td><code>varExplained</code></td>
<td>
<p> numeric: cumulative variance explained by
each component/factor retained </p>
</td></tr> <tr><td><code>loadings</code></td>
<td>
<p> numeric: loadings of each
variable on each component/factor retained </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Kim, J.-O. and Mueller, C. W. (1978). <em>Introduction to
factor analysis. What it is and how to do it</em>. Beverly Hills, CA: Sage.
</p>
<p>Kim, J.-O. and Mueller, C. W. (1987). <em>Factor analysis. Statistical
methods and practical issues</em>. Beverly Hills, CA: Sage.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+principalComponents">principalComponents</a></code>,
<code><a href="#topic+iterativePrincipalAxis">iterativePrincipalAxis</a></code>, <code><a href="#topic+rRecovery">rRecovery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# .......................................................
# Example from Kim and Mueller (1978, p. 10)
# Simulated sample: lower diagnonal
 R &lt;- matrix(c( 1.000, 0.560, 0.480, 0.224, 0.192, 0.16,
                0.560, 1.000, 0.420, 0.196, 0.168, 0.14,
                0.480, 0.420, 1.000, 0.168, 0.144, 0.12,
                0.224, 0.196, 0.168, 1.000, 0.420, 0.35,
                0.192, 0.168, 0.144, 0.420, 1.000, 0.30,
                0.160, 0.140, 0.120, 0.350, 0.300, 1.00),
                nrow=6, byrow=TRUE)

# Factor analysis: Selected principal components - Kim and Mueller
# (1978, p. 20)
 componentAxis(R, nFactors=2)

# .......................................................
</code></pre>

<hr>
<h2 id='corFA'>Insert Communalities in the Diagonal of a Correlation or a Covariance Matrix</h2><span id='topic+corFA'></span>

<h3>Description</h3>

<p>This function inserts communalities in the diagonal of a correlation/covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corFA(R, method = "ginv")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corFA_+3A_r">R</code></td>
<td>
<p>An integer matrix or a data.frame of correlations</p>
</td></tr>
<tr><td><code id="corFA_+3A_method">method</code></td>
<td>
<p>A character vector: inversion method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix with coerced variables with communalities in the diagonal.
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche, Universite du Quebec a Montreal (<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>,
<code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## LOWER CORRELATION MATRIX WITH ZEROS ON UPPER PART
## From Gorsuch (table 1.3.1)
 gorsuch &lt;- c(
 1,0,0,0,0,0,0,0,0,0,
 .6283, 1,0,0,0,0,0,0,0,0,
 .5631, .7353, 1,0,0,0,0,0,0,0,
 .8689, .7055, .8444, 1,0,0,0,0,0,0,
 .9030, .8626, .6890, .8874, 1,0,0,0,0,0,
 .6908, .9028, .9155, .8841, .8816, 1,0,0,0,0,
 .8633, .7495, .7378, .9164, .9109, .8572, 1,0,0,0,
 .7694, .7902, .7872, .8857, .8835, .8884, .7872, 1,0,0,
 .8945, .7929, .7656, .9494, .9546, .8942, .9434, .9000, 1,0,
 .5615, .6850, .8153, .7004, .6583, .7720, .6201, .6141, .6378, 1)

## UPPER CORRELATION MATRIX FILLED WITH UPPER CORRELATION MATRIX
 gorsuch &lt;- makeCor(gorsuch)

## REPLACE DIAGONAL WITH COMMUNALITIES
 gorsuchCfa &lt;- corFA(gorsuch)
 gorsuchCfa

</code></pre>

<hr>
<h2 id='dFactors'>Eigenvalues from classical studies</h2><span id='topic+dFactors'></span>

<h3>Description</h3>

<p>Classical examples of eigenvalues vectors used to study the number of factors
to retain in the litterature. These examples generally give the number of
subjects use to obtain these eigenvalues.
The number of subjects is used with the parallel analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dFactors
</code></pre>


<h3>Format</h3>

<p>A list of examples. For each example, a list is also used to give the eigenvalues
vector and the number of subjects.
</p>

<dl>
<dt>Bentler</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Buja</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Cliff1</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Cliff2</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Cliff3</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Hand</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Harman</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Lawley</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Raiche</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Tucker1</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
<dt>Tucker2</dt><dd><p>$eigenvalues and $nsubjects</p>
</dd>
</dl>


<h3>Details</h3>

<p>Other datasets will be added in future versions of the package.
</p>


<h3>Source</h3>

<p>Lawley and Hand dataset:  Bartholomew <em>et al</em>. (2002, p. 123, 126)
</p>
<p>Bentler dataset:          Bentler and Yuan (1998, p. 139-140)
</p>
<p>Buja datasets:            Buja and Eyuboglu (1992, p. 516, 519) &lt; Number of subjects not specified by Buja and Eyuboglu &gt;
</p>
<p>Cliff datasets:           Cliff (1970, p. 165)
</p>
<p>Raiche dataset:           Raiche, Langevin, Riopel and Mauffette (2006)
</p>
<p>Raiche dataset:           Raiche, Riopel and Blais (2006, p. 9)
</p>
<p>Tucker datasets:          Tucker <em>et al</em>. (1969, p. 442)
</p>


<h3>References</h3>

<p>Bartholomew, D. J., Steele, F., Moustaki, I. and Galbraith, J.
I. (2002).  <em>The analysis and interpretation of multivariate data for
social scientists</em>. Boca Raton, FL: Chapman and Hall.
</p>
<p>Bentler, P. M. and Yuan, K.-H. (1998). Tests for linear trend in the
smallest eigenvalues of the correlation matrix. <em>Psychometrika, 63</em>(2),
131-144.
</p>
<p>Buja, A. and Eyuboglu, N. (1992). Remarks on parallel analysis.
<em>Multivariate Behavioral Research, 27</em>(4), 509-540.
</p>
<p>Cliff, N. (1970). The relation between sample and population characteristic
vectors.  <em>Psychometrika, 35</em>(2), 163-178.
</p>
<p>Hand, D. J., Daly, F., Lunn, A. D., McConway, K. J. and Ostrowski, E.
(1994).  <em>A handbook of small data sets</em>. Boca Raton, FL: Chapman and
Hall.
</p>
<p>Lawley, D. N. and Maxwell, A. E. (1971). <em>Factor analysis as a
statistical method</em> (2nd edition). London: Butterworth.
</p>
<p>Raiche, G., Langevin, L., Riopel, M. and Mauffette, Y. (2006). Etude
exploratoire de la dimensionnalite et des facteurs expliques par une
traduction francaise de l'Inventaire des approches d'enseignement de
Trigwell et Prosser dans trois universite quebecoises. <em>Mesure et
Evaluation en Education, 29</em>(2), 41-61.
</p>
<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013).
Non-graphical solutions for Cattell's scree test. Methodology, 9(1), 23-29.
</p>
<p>Tucker, L. D., Koopman, R. F. and Linn, R. L. (1969). Evaluation of factor
analytic research procedures by mean of simulated correlation matrices.
<em>Psychometrika, 34</em>(4), 421-459.
</p>
<p>Zoski, K. and Jurs, S. (1993). Using multiple regression to determine the
number of factors to retain in factor analysis. <em>Multiple Linear
Regression Viewpoint, 20</em>(1), 5-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLES FROM DATASET
 data(dFactors)

# COMMAND TO VISUALIZE THE CONTENT AND ATTRIBUTES OF THE DATASETS
 names(dFactors)
 attributes(dFactors)
 dFactors$Cliff1$eigenvalues
 dFactors$Cliff1$nsubjects

# SCREE PLOT OF THE Cliff1 DATASET
 plotuScree(dFactors$Cliff1$eigenvalues)

</code></pre>

<hr>
<h2 id='diagReplace'>Replacing Upper or Lower Diagonal of a Correlation or Covariance Matrix</h2><span id='topic+diagReplace'></span>

<h3>Description</h3>

<p>The <code>diagReplace</code> function returns a modified correlation or covariance
matrix by replacing upper diagonal with lower diagonal, or lower diagonal
with upper diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagReplace(R, upper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagReplace_+3A_r">R</code></td>
<td>
<p>numeric: correlation or covariance matrix</p>
</td></tr>
<tr><td><code id="diagReplace_+3A_upper">upper</code></td>
<td>
<p>logical: if <code>TRUE</code> upper diagonal is replaced with lower
diagonal. If <code>FALSE</code>, lower diagonal is replaced with upper diagonal.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>R</code></td>
<td>
<p> numeric: correlation or covariance matrix </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# .......................................................
# Example from Kim and Mueller (1978, p. 10)
# Population: upper diagonal
# Simulated sample: lower diagnonal
 R &lt;- matrix(c( 1.000, .6008, .4984, .1920, .1959, .3466,
                .5600, 1.000, .4749, .2196, .1912, .2979,
                .4800, .4200, 1.000, .2079, .2010, .2445,
                .2240, .1960, .1680, 1.000, .4334, .3197,
                .1920, .1680, .1440, .4200, 1.000, .4207,
                .1600, .1400, .1200, .3500, .3000, 1.000),
                nrow=6, byrow=TRUE)

# Replace upper diagonal with lower diagonal
 RU &lt;- diagReplace(R, upper=TRUE)

# Replace lower diagonal with upper diagonal
 RL &lt;- diagReplace(R, upper=FALSE)
# .......................................................

</code></pre>

<hr>
<h2 id='eigenBootParallel'>Bootstrapping of the Eigenvalues From a Data Frame</h2><span id='topic+eigenBootParallel'></span>

<h3>Description</h3>

<p>The <code>eigenBootParallel</code> function samples observations from a
<code>data.frame</code> to produce correlation or covariance matrices from which
eigenvalues are computed. The function returns statistics about these
bootstrapped eigenvalues. Their means or their quantile could be used later
to replace the eigenvalues inputted to a parallel analysis.  The
<code>eigenBootParallel</code> can also compute random eigenvalues from empirical
data by column permutation (Buja and Eyuboglu, 1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenBootParallel(x, quantile = 0.95, nboot = 30,
  option = "permutation", cor = TRUE, model = "components", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigenBootParallel_+3A_x">x</code></td>
<td>
<p>data.frame: data from which a correlation matrix will be obtained</p>
</td></tr>
<tr><td><code id="eigenBootParallel_+3A_quantile">quantile</code></td>
<td>
<p>numeric: eigenvalues quantile to be reported</p>
</td></tr>
<tr><td><code id="eigenBootParallel_+3A_nboot">nboot</code></td>
<td>
<p>numeric: number of bootstrap samples</p>
</td></tr>
<tr><td><code id="eigenBootParallel_+3A_option">option</code></td>
<td>
<p>character: <code>"permutation"</code> or <code>"bootstrap"</code></p>
</td></tr>
<tr><td><code id="eigenBootParallel_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation
matrix, else from a covariance matrix (<code>eigenComputes</code>)</p>
</td></tr>
<tr><td><code id="eigenBootParallel_+3A_model">model</code></td>
<td>
<p>character: bootstraps from a principal component analysis
(<code>"components"</code>) or from a factor analysis (<code>"factors"</code>)</p>
</td></tr>
<tr><td><code id="eigenBootParallel_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the <code>cor</code> or
<code>cov</code> functions</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p> data.frame: mean, median, quantile, standard
deviation, minimum and maximum of bootstrapped eigenvalues </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Buja, A. and Eyuboglu, N. (1992). Remarks on parallel analysis.
<em>Multivariate Behavioral Research, 27</em>(4), 509-540.
</p>
<p>Zwick, W. R. and Velicer, W. F. (1986). Comparison of five rules for
determining the number of components to retain.  <em>Psychological
bulletin, 99</em>, 432-442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+principalComponents">principalComponents</a></code>,
<code><a href="#topic+iterativePrincipalAxis">iterativePrincipalAxis</a></code>, <code><a href="#topic+rRecovery">rRecovery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# .......................................................
# Example from the iris data
 eigenvalues &lt;- eigenComputes(x=iris[,-5])

# Permutation parallel analysis distribution
 aparallel   &lt;- eigenBootParallel(x=iris[,-5], quantile=0.95)$quantile

# Number of components to retain
 results     &lt;- nScree(x = eigenvalues, aparallel = aparallel)
 results$Components
 plotnScree(results)
# ......................................................

# ......................................................
# Bootstrap distributions study of the eigenvalues from iris data
# with different correlation methods
 eigenBootParallel(x=iris[,-5],quantile=0.05,
                   option="bootstrap",method="pearson")
 eigenBootParallel(x=iris[,-5],quantile=0.05,
                   option="bootstrap",method="spearman")
 eigenBootParallel(x=iris[,-5],quantile=0.05,
                   option="bootstrap",method="kendall")

</code></pre>

<hr>
<h2 id='eigenComputes'>Computes Eigenvalues According to the Data Type</h2><span id='topic+eigenComputes'></span>

<h3>Description</h3>

<p>The <code>eigenComputes</code> function computes eigenvalues from the identified data
type. It is used internally in many
fonctions of the <span class="pkg">nFactors</span> package in order to apply these to a vector of
eigenvalues, a matrix of correlations or covariance or a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenComputes(x, cor = TRUE, model = "components", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigenComputes_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of
correlations or of covariances or a <code>data.frame</code> of data</p>
</td></tr>
<tr><td><code id="eigenComputes_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation
matrix, else from a covariance matrix</p>
</td></tr>
<tr><td><code id="eigenComputes_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="eigenComputes_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the <code>cor</code> or
<code>cov</code> functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: return a vector of eigenvalues
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
<br /> <br /> David Magis <br /> Departement de mathematiques <br /> Universite de Liege
<br /> <a href="mailto:David.Magis@ulg.ac.be">David.Magis@ulg.ac.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># .......................................................
# Different data types
# Vector of eigenvalues
data(dFactors)
x1 &lt;- dFactors$Cliff1$eigenvalues
eigenComputes(x1)

# Data from a data.frame
x2 &lt;- data.frame(matrix(20*rnorm(100), ncol=5))
eigenComputes(x2, cor=TRUE,  use="everything")
eigenComputes(x2, cor=FALSE, use="everything")
eigenComputes(x2, cor=TRUE,  use="everything", method="spearman")
eigenComputes(x2, cor=TRUE,  use="everything", method="kendall")

x3 &lt;- cov(x2)
eigenComputes(x3, cor=TRUE,  use="everything")
eigenComputes(x3, cor=FALSE, use="everything")

x4 &lt;- cor(x2)
eigenComputes(x4, use="everything")
# .......................................................

</code></pre>

<hr>
<h2 id='eigenFrom'>Identify the Data Type to Obtain the Eigenvalues</h2><span id='topic+eigenFrom'></span>

<h3>Description</h3>

<p>The <code>eigenFrom</code> function identifies the data type from which to obtain the
eigenvalues. The function is used internally in many functions of
the <span class="pkg">nFactors</span> package to be able to apply these to a vector of eigenvalues,
a matrix of correlations or covariance or a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenFrom(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigenFrom_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of correlations or of covariances or a <code>data.frame</code> of data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character: return the data type to obtain the eigenvalues: <code>"eigenvalues"</code>, <code>"correlation"</code> or <code>"data"</code>
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
<br /> <br /> David Magis <br /> Departement de mathematiques <br /> Universite de Liege
<br /> <a href="mailto:David.Magis@ulg.ac.be">David.Magis@ulg.ac.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># .......................................................
# Different data types
# Examples of adequate data sources
# Vector of eigenvalues
data(dFactors)
x1 &lt;- dFactors$Cliff1$eigenvalues
eigenFrom(x1)

# Data from a data.frame
x2 &lt;- data.frame(matrix(20*rnorm(100), ncol=5))
eigenFrom(x2)

# From a covariance matrix
x3 &lt;- cov(x2)
eigenFrom(x3)

# From a correlation matrix
x4 &lt;- cor(x2)
eigenFrom(x4)

# Examples of inadequate data sources: not run because of errors generated
# x0 &lt;- c(2,1)             # Error: not enough eigenvalues
# eigenFrom(x0)
# x2 &lt;- matrix(x1, ncol=5) # Error: non a symetric covariance matrix
# eigenFrom(x2)
# eigenFrom(x3[,(1:2)])    # Error: not enough variables
# x6 &lt;- table(x5)          # Error: not a valid data class
# eigenFrom(x6)
# .......................................................
</code></pre>

<hr>
<h2 id='generateStructure'>Generate a Factor Structure Matrix</h2><span id='topic+generateStructure'></span>

<h3>Description</h3>

<p>The <code>generateStructure</code> function returns a <em>mjc</em> factor structure matrix.
The number of variables per major factor <em>pmjc</em> is equal for each factor.
The argument <em>pmjc</em> must be divisible by <em>nVar</em>.
The arguments are strongly inspired from Zick and Velicer (1986, p. 435-436) methodology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateStructure(var, mjc, pmjc, loadings, unique)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateStructure_+3A_var">var</code></td>
<td>
<p>numeric: number of variables</p>
</td></tr>
<tr><td><code id="generateStructure_+3A_mjc">mjc</code></td>
<td>
<p>numeric: number of major factors (factors with practical significance)</p>
</td></tr>
<tr><td><code id="generateStructure_+3A_pmjc">pmjc</code></td>
<td>
<p>numeric: number of variables that load significantly on each major factor</p>
</td></tr>
<tr><td><code id="generateStructure_+3A_loadings">loadings</code></td>
<td>
<p>numeric: loadings on the significant variables on each major factor</p>
</td></tr>
<tr><td><code id="generateStructure_+3A_unique">unique</code></td>
<td>
<p>numeric: loadings on the non significant variables on each major factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>values  numeric matrix: factor structure
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
<br /> <br /> David Magis <br /> Departement de mathematiques <br /> Universite de Liege
<br /> <a href="mailto:David.Magis@ulg.ac.be">David.Magis@ulg.ac.be</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>
<p>Zwick, W. R. and Velicer, W. F. (1986). Comparison of five rules for
determining the number of components to retain. <em>Psychological Bulletin, 99</em>, 432-442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+principalComponents">principalComponents</a></code>, <code><a href="#topic+iterativePrincipalAxis">iterativePrincipalAxis</a></code>, <code><a href="#topic+rRecovery">rRecovery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># .......................................................
# Example inspired from Zwick and Velicer (1986, table 2, p. 437)
## ...................................................................
unique=0.2; loadings=0.5
zwick1 &lt;- generateStructure(var=36, mjc=6, pmjc= 6, loadings=loadings,
                           unique=unique)
zwick2 &lt;- generateStructure(var=36, mjc=3, pmjc=12, loadings=loadings,
                           unique=unique)
zwick3 &lt;- generateStructure(var=72, mjc=9, pmjc= 8, loadings=loadings,
                           unique=unique)
zwick4 &lt;- generateStructure(var=72, mjc=6, pmjc=12, loadings=loadings,
                           unique=unique)
sat=0.8
## ...................................................................
zwick5 &lt;- generateStructure(var=36, mjc=6, pmjc= 6, loadings=loadings,
                           unique=unique)
zwick6 &lt;- generateStructure(var=36, mjc=3, pmjc=12, loadings=loadings,
                           unique=unique)
zwick7 &lt;- generateStructure(var=72, mjc=9, pmjc= 8, loadings=loadings,
                           unique=unique)
zwick8 &lt;- generateStructure(var=72, mjc=6, pmjc=12, loadings=loadings,
                          unique=unique)
## ...................................................................

# nsubjects &lt;- c(72, 144, 180, 360)
# require(psych)
# Produce an usual correlation matrix from a congeneric model
nsubjects &lt;- 72
mzwick5   &lt;- psych::sim.structure(fx=as.matrix(zwick5), n=nsubjects)
mzwick5$r

# Factor analysis: recovery of the factor structure
iterativePrincipalAxis(mzwick5$model, nFactors=6,
                      communalities="ginv")$loadings
iterativePrincipalAxis(mzwick5$r    , nFactors=6,
                      communalities="ginv")$loadings
factanal(covmat=mzwick5$model,         factors=6)
factanal(covmat=mzwick5$r    ,         factors=6)

# Number of components to retain
eigenvalues  &lt;- eigen(mzwick5$r)$values
aparallel    &lt;- parallel(var      = length(eigenvalues),
                        subject  = nsubjects,
                        rep      = 30,
                        quantile = 0.95,
                        model="components")$eigen$qevpea
results &lt;- nScree(x         = eigenvalues,
                 aparallel = aparallel)
results$Components
plotnScree(results)

# Number of factors to retain
eigenvalues.fa  &lt;- eigen(corFA(mzwick5$r))$values
aparallel.fa    &lt;- parallel(var      = length(eigenvalues.fa),
                           subject  = nsubjects,
                           rep      = 30,
                           quantile = 0.95,
                           model="factors")$eigen$qevpea
results.fa &lt;- nScree(x      = eigenvalues.fa,
                    aparallel = aparallel.fa,
                    model     ="factors")
results.fa$Components
plotnScree(results.fa)
# ......................................................


</code></pre>

<hr>
<h2 id='is.nFactors'>Utility Functions for nFactors Class Objects</h2><span id='topic+is.nFactors'></span><span id='topic+print.nFactors'></span><span id='topic+summary.nFactors'></span>

<h3>Description</h3>

<p>Utility functions for <code>nFactors</code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.nFactors(x)

## S3 method for class 'nFactors'
print(x, ...)

## S3 method for class 'nFactors'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.nFactors_+3A_x">x</code></td>
<td>
<p>nFactors: an object of the class nFactors</p>
</td></tr>
<tr><td><code id="is.nFactors_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the <code>print</code>
function with <code>print.nFactors</code> or to the <code>summary</code> function with
<code>summary.nFactors</code></p>
</td></tr>
<tr><td><code id="is.nFactors_+3A_object">object</code></td>
<td>
<p>nFactors: an object of the class nFactors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generic functions for the nFactors class:
</p>
<table role = "presentation">
<tr><td><code>is.nFactors</code></td>
<td>
<p> logical: is the object of the class nFactors? </p>
</td></tr>
<tr><td><code>print.nFactors</code></td>
<td>
<p> numeric: vector of the number of components/factors
to retain: same as the <code>nFactors</code> vector from the <code>nFactors</code>
object</p>
</td></tr> <tr><td><code>summary.nFactors</code></td>
<td>
<p> data.frame: details of the results from a
nFactors object: same as the <code>details</code> data.frame from the
<code>nFactors</code> object, but with easier control of the number of decimals
with the <code>digits</code> parameter</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nBentler">nBentler</a></code>, <code><a href="#topic+nBartlett">nBartlett</a></code>,
<code><a href="#topic+nCng">nCng</a></code>, <code><a href="#topic+nMreg">nMreg</a></code>, <code><a href="#topic+nSeScree">nSeScree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## SIMPLE EXAMPLE
 data(dFactors)
 eig      &lt;- dFactors$Raiche$eigenvalues
 N        &lt;- dFactors$Raiche$nsubjects

 res &lt;- nBartlett(eig,N); res; is.nFactors(res); summary(res, digits=2)
 res &lt;- nBentler(eig,N);  res; is.nFactors(res); summary(res, digits=2)
 res &lt;- nCng(eig);        res; is.nFactors(res); summary(res, digits=2)
 res &lt;- nMreg(eig);       res; is.nFactors(res); summary(res, digits=2)
 res &lt;- nSeScree(eig);    res; is.nFactors(res); summary(res, digits=2)

## SIMILAR RESULTS, BUT NOT A nFactors OBJECT
 res &lt;- nScree(eig);      res; is.nFactors(res); summary(res, digits=2)

</code></pre>

<hr>
<h2 id='iterativePrincipalAxis'>Iterative Principal Axis Analysis</h2><span id='topic+iterativePrincipalAxis'></span>

<h3>Description</h3>

<p>The <code>iterativePrincipalAxis</code> function returns a principal axis analysis with
iterated communality estimates. Four different choices of initial communality
estimates are given: maximum correlation, multiple correlation (usual and
generalized inverse) or estimates based
on the sum of the squared principal component analysis loadings. Generally, statistical
packages initialize the communalities at the multiple correlation value.
Unfortunately, this strategy cannot always deal with singular correlation or
covariance matrices.
If a generalized inverse, the maximum correlation or the estimated communalities
based on the sum of loadings
are used instead, then a solution can be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterativePrincipalAxis(R, nFactors = 2, communalities = "component",
  iterations = 20, tolerance = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterativePrincipalAxis_+3A_r">R</code></td>
<td>
<p>numeric: correlation or covariance matrix</p>
</td></tr>
<tr><td><code id="iterativePrincipalAxis_+3A_nfactors">nFactors</code></td>
<td>
<p>numeric: number of factors to retain</p>
</td></tr>
<tr><td><code id="iterativePrincipalAxis_+3A_communalities">communalities</code></td>
<td>
<p>character: initial values for communalities (<code>"component", "maxr", "ginv" or "multiple"</code>)</p>
</td></tr>
<tr><td><code id="iterativePrincipalAxis_+3A_iterations">iterations</code></td>
<td>
<p>numeric: maximum number of iterations to obtain a solution</p>
</td></tr>
<tr><td><code id="iterativePrincipalAxis_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric: minimal difference in the estimated communalities after a given iteration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>values       numeric: variance of each component
</p>
<p>varExplained numeric: variance explained by each component
</p>
<p>varExplained numeric: cumulative variance explained by each component
</p>
<p>loadings     numeric: loadings of each variable on each component
</p>
<p>iterations   numeric: maximum number of iterations to obtain a solution
</p>
<p>tolerance    numeric: minimal difference in the estimated communalities after a given iteration
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
<br /> <br /> David Magis <br /> Departement de mathematiques <br /> Universite de Liege
<br /> <a href="mailto:David.Magis@ulg.ac.be">David.Magis@ulg.ac.be</a>
</p>


<h3>References</h3>

<p>Kim, J.-O. and Mueller, C. W. (1978). <em>Introduction to factor analysis. What it
is and how to do it</em>. Beverly Hills, CA: Sage.
</p>
<p>Kim, J.-O. and Mueller, C. W. (1987). <em>Factor analysis. Statistical methods and
practical issues</em>. Beverly Hills, CA: Sage.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+componentAxis">componentAxis</a></code>, <code><a href="#topic+principalAxis">principalAxis</a></code>, <code><a href="#topic+rRecovery">rRecovery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ................................................
# Example from Kim and Mueller (1978, p. 10)
# Population: upper diagonal
# Simulated sample: lower diagnonal
R &lt;- matrix(c( 1.000, .6008, .4984, .1920, .1959, .3466,
               .5600, 1.000, .4749, .2196, .1912, .2979,
               .4800, .4200, 1.000, .2079, .2010, .2445,
               .2240, .1960, .1680, 1.000, .4334, .3197,
               .1920, .1680, .1440, .4200, 1.000, .4207,
               .1600, .1400, .1200, .3500, .3000, 1.000),
            nrow=6, byrow=TRUE)

# Factor analysis: Principal axis factoring with iterated communalities
# Kim and Mueller (1978, p. 23)
# Replace upper diagonal with lower diagonal
RU         &lt;- diagReplace(R, upper=TRUE)
nFactors   &lt;- 2
fComponent &lt;- iterativePrincipalAxis(RU, nFactors=nFactors,
                                     communalities="component")
fComponent
rRecovery(RU,fComponent$loadings, diagCommunalities=FALSE)

fMaxr      &lt;- iterativePrincipalAxis(RU, nFactors=nFactors,
                                     communalities="maxr")
fMaxr
rRecovery(RU,fMaxr$loadings, diagCommunalities=FALSE)

fMultiple  &lt;- iterativePrincipalAxis(RU, nFactors=nFactors,
                                     communalities="multiple")
fMultiple
rRecovery(RU,fMultiple$loadings, diagCommunalities=FALSE)
# .......................................................

</code></pre>

<hr>
<h2 id='makeCor'>Create a Full Correlation/Covariance Matrix from a Matrix With Lower Part Filled and Upper Part With Zeros</h2><span id='topic+makeCor'></span>

<h3>Description</h3>

<p>This function creates a full correlation/covariance matrix from a matrix with
lower part filled and upper part with zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCor(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeCor_+3A_x">x</code></td>
<td>
<p>numeric: matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: full correlation matrix
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>, <code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ................................................
## LOWER CORRELATION MATRIX WITH ZEROS ON UPPER PART
## From Gorsuch (table 1.3.1)
gorsuch &lt;- c(
 1,0,0,0,0,0,0,0,0,0,
 .6283, 1,0,0,0,0,0,0,0,0,
 .5631, .7353, 1,0,0,0,0,0,0,0,
 .8689, .7055, .8444, 1,0,0,0,0,0,0,
 .9030, .8626, .6890, .8874, 1,0,0,0,0,0,
 .6908, .9028, .9155, .8841, .8816, 1,0,0,0,0,
.8633, .7495, .7378, .9164, .9109, .8572, 1,0,0,0,
 .7694, .7902, .7872, .8857, .8835, .8884, .7872, 1,0,0,
 .8945, .7929, .7656, .9494, .9546, .8942, .9434, .9000, 1,0,
 .5615, .6850, .8153, .7004, .6583, .7720, .6201, .6141, .6378, 1)

## UPPER CORRELATION MATRIX FILLED WITH UPPER CORRELATION MATRIX
gorsuch &lt;- makeCor(gorsuch)
gorsuch
</code></pre>

<hr>
<h2 id='moreStats'>Statistical Summary of a Data Frame</h2><span id='topic+moreStats'></span>

<h3>Description</h3>

<p>This function produces another summary of a <code>data.frame</code>. This function
was proposed in order to apply some functions globally on a <code>data.frame</code>:
<code>quantile</code>, <code>median</code>, <code>min</code> and <code>max</code>. The usual <em>R</em>
version cannot do so.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moreStats(x, quantile = 0.95, show = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moreStats_+3A_x">x</code></td>
<td>
<p>numeric: matrix or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="moreStats_+3A_quantile">quantile</code></td>
<td>
<p>numeric: quantile of the distribution</p>
</td></tr>
<tr><td><code id="moreStats_+3A_show">show</code></td>
<td>
<p>logical: if <code>TRUE</code> prints the quantile choosen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: <code>data.frame</code> of statistics: mean, median, quantile, standard deviation, minimum and maximum
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>, <code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ................................................
## GENERATION OF A MATRIX OF 100 OBSERVATIONS AND 10 VARIABLES
x   &lt;- matrix(rnorm(1000),ncol=10)

## STATISTICS
res &lt;- moreStats(x, quantile=0.05, show=TRUE)
res

</code></pre>

<hr>
<h2 id='nBartlett'>Bartlett, Anderson and Lawley Procedures to Determine the Number of Components/Factors</h2><span id='topic+nBartlett'></span>

<h3>Description</h3>

<p>This function computes the Bartlett, Anderson and Lawley indices for determining the
number of components/factors to retain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nBartlett(x, N, alpha = 0.05, cor = TRUE, details = TRUE,
  correction = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nBartlett_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of correlations or of covariances or a <code>data.frame</code> of data (eigenFrom)</p>
</td></tr>
<tr><td><code id="nBartlett_+3A_n">N</code></td>
<td>
<p>numeric: number of subjects</p>
</td></tr>
<tr><td><code id="nBartlett_+3A_alpha">alpha</code></td>
<td>
<p>numeric: statistical significance level</p>
</td></tr>
<tr><td><code id="nBartlett_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation matrix, else from a covariance matrix</p>
</td></tr>
<tr><td><code id="nBartlett_+3A_details">details</code></td>
<td>
<p>logical: if <code>TRUE</code> also returns detains about the computation for each eigenvalue</p>
</td></tr>
<tr><td><code id="nBartlett_+3A_correction">correction</code></td>
<td>
<p>logical: if <code>TRUE</code> uses a correction for the degree of freedom after the first eigenvalue</p>
</td></tr>
<tr><td><code id="nBartlett_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the <code>cor</code> or <code>cov</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the latex formulas are available only in the pdf version of this help file.
</p>
<p>The hypothesis tested is: <br />
</p>
<p>(1)  <code class="reqn">\qquad \qquad H_k: \lambda_{k+1} = \ldots = \lambda_p</code> <br />
</p>
<p>This hypothesis is verified by the application of different version of a
<code class="reqn">\chi^2</code> test with different values for the degrees of freedom.
Each of these tests shares the compution of a <code class="reqn">V_k</code> value: <br />
</p>
<p>(2) <code class="reqn">\qquad \qquad V_k  =
  \prod\limits_{i = k + 1}^p
  \left\{ \frac{\displaystyle \lambda_i}{\frac{1}{q}\sum\limits_{i = k + 1}^p {\lambda
  _i } } \right\} </code>
</p>
<p><code class="reqn">p</code> is the number of eigenvalues, <code class="reqn">k</code> the number of eigenvalues to test,
and <code class="reqn">q</code> the <code class="reqn">p-k</code> remaining eigenvalues. <code class="reqn">n</code> is equal to the sample size
minus 1 (<code class="reqn">n = N-1</code>). <br />
</p>
<p>The Anderson statistic is distributed as a <code class="reqn">\chi^2</code> with <code class="reqn">(q + 2)(q - 1)/2</code> degrees
of freedom and is equal to: <br />
</p>
<p>(3) <code class="reqn">\qquad \qquad - n\log (V_k ) \sim \chi _{(q + 2)(q - 1)/2}^2 </code> <br />
</p>
<p>An improvement of this statistic from Bartlett (Bentler, and Yuan, 1996, p. 300;
Horn and Engstrom, 1979, equation 8) is distributed as a <code class="reqn">\chi^2</code>
with <code class="reqn">(q)(q - 1)/2</code> degrees of freedom and is equal to: <br />
</p>
<p>(4) <code class="reqn">\qquad \qquad - \left[ {n - k - {{2q^2 q + 2} \over {6q}}}
                                \right]\log (V_k ) \sim \chi _{(q + 2)(q - 1)/2}^2 </code>  <br />
</p>
<p>Finally, Anderson (1956) and James (1969) proposed another statistic. <br />
</p>
<p>(5) <code class="reqn">\qquad \qquad - \left[ {n - k - {{2q^2 q + 2} \over {6q}}
  + \sum\limits_{i = 1}^k {{{\bar \lambda _q^2 } \over {\left( {\lambda _i
    - \bar \lambda _q } \right)^2 }}} } \right]\log (V_k ) \sim \chi _{(q + 2)(q - 1)/2}^2 </code> <br />
</p>
<p>Bartlett (1950, 1951) proposed a correction to the degrees of freedom of these <code class="reqn">\chi^2</code> after the
first significant test: <code class="reqn">(q+2)(q - 1)/2</code>. <br />
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nFactors</code></td>
<td>
<p>numeric: vector of the number of factors retained by the Bartlett, Anderson and Lawley procedures.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>numeric: matrix of the details for each index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Anderson, T. W. (1963). Asymptotic theory for principal component analysis. <em>Annals of Mathematical Statistics, 34</em>, 122-148.
</p>
<p>Bartlett, M. S. (1950). Tests of significance in factor analysis. <em>British Journal of Psychology, 3</em>, 77-85.
</p>
<p>Bartlett, M. S. (1951). A further note on tests of significance. <em>British Journal of Psychology, 4</em>, 1-2.
</p>
<p>Bentler, P. M. and Yuan, K.-H. (1996). Test of linear trend in eigenvalues of a covariance matrix with application to data analysis.
<em>British Journal of Mathematical and Statistical Psychology, 49</em>, 299-312.
</p>
<p>Bentler, P. M. and Yuan, K.-H. (1998). Test of linear trend in the smallest
eigenvalues of the correlation matrix. <em>Psychometrika, 63</em>(2), 131-144.
</p>
<p>Horn, J. L. and Engstrom, R. (1979). Cattell's scree test in relation to
Bartlett's chi-square test and other observations on the number of factors
problem. <em>Multivariate Behavioral Reasearch, 14</em>(3), 283-300.
</p>
<p>James, A. T. (1969). Test of equality of the latent roots of the covariance
matrix. <em>In</em> P. K. Krishna (Eds): <em>Multivariate analysis, volume 2</em>.New-York, NJ: Academic Press.
</p>
<p>Lawley, D. N. (1956). Tests of significance for the latent roots of covarianceand correlation matrix. <em>Biometrika, 43</em>(1/2), 128-136.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>, <code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ................................................
## SIMPLE EXAMPLE OF A BARTLETT PROCEDURE

data(dFactors)
eig      &lt;- dFactors$Raiche$eigenvalues

results  &lt;- nBartlett(x=eig, N= 100, alpha=0.05, details=TRUE)
results

plotuScree(eig, main=paste(results$nFactors[1], ", ",
                           results$nFactors[2], " or ",
                           results$nFactors[3],
                           " factors retained by the LRT procedures",
                           sep=""))

</code></pre>

<hr>
<h2 id='nBentler'>Bentler and Yuan's Procedure to Determine the Number of Components/Factors</h2><span id='topic+nBentler'></span>

<h3>Description</h3>

<p>This function computes the Bentler and Yuan's indices for determining the
number of components/factors to retain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nBentler(x, N, log = TRUE, alpha = 0.05, cor = TRUE,
  details = TRUE, minPar = c(min(lambda) - abs(min(lambda)) + 0.001,
  0.001), maxPar = c(max(lambda), lm(lambda ~
  I(length(lambda):1))$coef[2]), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nBentler_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of
correlations or of covariances or a <code>data.frame</code> of data</p>
</td></tr>
<tr><td><code id="nBentler_+3A_n">N</code></td>
<td>
<p>numeric: number of subjects.</p>
</td></tr>
<tr><td><code id="nBentler_+3A_log">log</code></td>
<td>
<p>logical: if <code>TRUE</code> does the maximization on the log values.</p>
</td></tr>
<tr><td><code id="nBentler_+3A_alpha">alpha</code></td>
<td>
<p>numeric: statistical significance level.</p>
</td></tr>
<tr><td><code id="nBentler_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation
matrix, else from a covariance matrix</p>
</td></tr>
<tr><td><code id="nBentler_+3A_details">details</code></td>
<td>
<p>logical: if <code>TRUE</code> also returns detains about the
computation for each eigenvalue.</p>
</td></tr>
<tr><td><code id="nBentler_+3A_minpar">minPar</code></td>
<td>
<p>numeric: minimums for the coefficient of the linear trend to
maximize.</p>
</td></tr>
<tr><td><code id="nBentler_+3A_maxpar">maxPar</code></td>
<td>
<p>numeric: maximums for the coefficient of the linear trend to
maximize.</p>
</td></tr>
<tr><td><code id="nBentler_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the <code>cor</code> or
<code>cov</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented Bentler and Yuan's procedure must be used with care because
the minimized function is not always stable, as Bentler and Yan (1996, 1998)
already noted. In many cases, constraints must applied to obtain a solution,
as the actual implementation did, but the user can modify these constraints.
</p>
<p>The hypothesis tested (Bentler and Yuan, 1996, equation 10) is: <br /> <br />
</p>
<p>(1) <code class="reqn">\qquad \qquad H_k: \lambda_{k+i} = \alpha + \beta x_i, (i = 1,
\ldots, q)</code> <br />
</p>
<p>The solution of the following simultaneous equations is needed to find
<code class="reqn">(\alpha, \beta) \in</code> <br />
</p>
<p>(2) <code class="reqn">\qquad \qquad f(x) = \sum_{i=1}^q \frac{ [ \lambda_{k+j} - N \alpha
+ \beta x_j ] x_j}{(\alpha + \beta x_j)^2} = 0</code> <br /> <br /> and <code class="reqn">\qquad
\qquad g(x) = \sum_{i=1}^q \frac{ \lambda_{k+j} - N \alpha + \beta x_j
x_j}{(\alpha + \beta x_j)^2} = 0</code> <br />
</p>
<p>The solution to this system of equations was implemented by minimizing the
following equation: <br />
</p>
<p>(3) <code class="reqn">\qquad \qquad (\alpha, \beta) \in \inf{[h(x)]} = \inf{\log{[f(x)^2
+ g(x)^2}}]</code> <br />
</p>
<p>The likelihood ratio test <code class="reqn">LRT</code> proposed by Bentler and Yuan (1996,
equation 7) follows a <code class="reqn">\chi^2</code> probability distribution with <code class="reqn">q-2</code>
degrees of freedom and is equal to: <br />
</p>
<p>(4) <code class="reqn">\qquad \qquad LRT = N(k - p)\left\{ {\ln \left( {{n \over N}}
\right) + 1} \right\} - N\sum\limits_{j = k + 1}^p {\ln \left\{ {{{\lambda
_j } \over {\alpha + \beta x_j }}} \right\}} + n\sum\limits_{j = k + 1}^p
{\left\{ {{{\lambda _j } \over {\alpha + \beta x_j }}} \right\}} </code> <br />
</p>
<p>With <code class="reqn">p</code> beeing the number of eigenvalues, <code class="reqn">k</code> the number of
eigenvalues to test, <code class="reqn">q</code> the <code class="reqn">p-k</code> remaining eigenvalues, <code class="reqn">N</code>
the sample size, and <code class="reqn">n = N-1</code>.  Note that there is an error in the
Bentler and Yuan equation, the variables <code class="reqn">N</code> and <code class="reqn">n</code> beeing inverted
in the preceeding equation 4.
</p>
<p>A better strategy proposed by Bentler an Yuan (1998) is to used a minimized
<code class="reqn">\chi^2</code> solution. This strategy will be implemented in a future version
of the <span class="pkg">nFactors</span> package.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nFactors</code></td>
<td>
<p> numeric: vector of the number of factors retained
by the Bentler and Yuan's procedure. </p>
</td></tr> <tr><td><code>details</code></td>
<td>
<p> numeric: matrix of
the details of the computation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
<br /> <br /> David Magis <br /> Departement de mathematiques <br /> Universite de Liege
<br /> <a href="mailto:David.Magis@ulg.ac.be">David.Magis@ulg.ac.be</a>
</p>


<h3>References</h3>

<p>Bentler, P. M. and Yuan, K.-H. (1996). Test of linear trend in
eigenvalues of a covariance matrix with application to data analysis.
<em>British Journal of Mathematical and Statistical Psychology, 49</em>,
299-312.
</p>
<p>Bentler, P. M. and Yuan, K.-H. (1998). Test of linear trend in the smallest
eigenvalues of the correlation matrix. <em>Psychometrika, 63</em>(2), 131-144.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nBartlett">nBartlett</a></code>, <code><a href="#topic+bentlerParameters">bentlerParameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ................................................
## SIMPLE EXAMPLE OF THE BENTLER AND YUAN PROCEDURE

# Bentler (1996, p. 309) Table 2 - Example 2 .............
n=649
bentler2&lt;-c(5.785, 3.088, 1.505, 0.582, 0.424, 0.386, 0.360, 0.337, 0.303,
            0.281, 0.246, 0.238, 0.200, 0.160, 0.130)

results  &lt;- nBentler(x=bentler2, N=n)
results

plotuScree(x=bentler2, model="components",
    main=paste(results$nFactors,
    " factors retained by the Bentler and Yuan's procedure (1996, p. 309)",
    sep=""))
# ........................................................

# Bentler (1998, p. 140) Table 3 - Example 1 .............
n        &lt;- 145
example1 &lt;- c(8.135, 2.096, 1.693, 1.502, 1.025, 0.943, 0.901, 0.816, 0.790,
              0.707, 0.639, 0.543,
              0.533, 0.509, 0.478, 0.390, 0.382, 0.340, 0.334, 0.316, 0.297,
              0.268, 0.190, 0.173)

results  &lt;- nBentler(x=example1, N=n)
results

plotuScree(x=example1, model="components",
   main=paste(results$nFactors,
   " factors retained by the Bentler and Yuan's procedure (1998, p. 140)",
   sep=""))
# ........................................................

</code></pre>

<hr>
<h2 id='nCng'>Cattell-Nelson-Gorsuch CNG Indices</h2><span id='topic+nCng'></span>

<h3>Description</h3>

<p>This function computes the <em>CNG</em> indices for the eigenvalues of a
correlation/covariance matrix (Gorsuch and Nelson, 1981; Nasser, 2002, p.
400; Zoski and Jurs, 1993, p. 6).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nCng(x, cor = TRUE, model = "components", details = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nCng_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of
correlations or of covariances or a <code>data.frame</code> of data</p>
</td></tr>
<tr><td><code id="nCng_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation
matrix, else from a covariance matrix</p>
</td></tr>
<tr><td><code id="nCng_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="nCng_+3A_details">details</code></td>
<td>
<p>logical: if <code>TRUE</code> also returns detains about the
computation for each eigenvalue.</p>
</td></tr>
<tr><td><code id="nCng_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the
<code>eigenComputes</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>nCng</code> function is only valid when more than six
eigenvalues are used and that these are obtained in the context of a
principal component analysis. For a factor analysis, some eigenvalues could
be negative and the function will stop and give an error message.
</p>
<p>The slope of all possible sets of three adjacent eigenvalues are compared,
so <em>CNG</em> indices can be applied only when more than six eigenvalues are
used. The eigenvalue at which the greatest difference between two successive
slopes occurs is the indicator of the number of components/factors to
retain.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nFactors</code></td>
<td>
<p> numeric: number of factors retained by the CNG
procedure. </p>
</td></tr> <tr><td><code>details</code></td>
<td>
<p> numeric: matrix of the details for each index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Gorsuch, R. L. and Nelson, J. (1981). <em>CNG scree test: an
objective procedure for determining the number of factors</em>. Presented at the
annual meeting of the Society for multivariate experimental psychology.
</p>
<p>Nasser, F. (2002). The performance of regression-based variations of the
visual scree for determining the number of common factors. <em>Educational
and Psychological Measurement, 62(3)</em>, 397-419.
</p>
<p>Zoski, K. and Jurs, S. (1993). Using multiple regression to determine the
number of factors to retain in factor analysis. <em>Multiple Linear
Regression Viewpoints, 20</em>(1), 5-9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>,
<code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## SIMPLE EXAMPLE OF A CNG ANALYSIS

 data(dFactors)
 eig      &lt;- dFactors$Raiche$eigenvalues

 results  &lt;- nCng(eig, details=TRUE)
 results

 plotuScree(eig, main=paste(results$nFactors,
                            " factors retained by the CNG procedure",
                            sep=""))

</code></pre>

<hr>
<h2 id='nMreg'>Multiple Regression Procedure to Determine the Number of Components/Factors</h2><span id='topic+nMreg'></span>

<h3>Description</h3>

<p>This function computes the <code class="reqn">\beta</code> indices, like their associated
Student <em>t</em> and probability (Zoski and Jurs, 1993, 1996, p. 445). These
three values can be used as three different indices for determining the
number of components/factors to retain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nMreg(x, cor = TRUE, model = "components", details = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nMreg_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of
correlations or of covariances or a <code>data.frame</code> of data (eigenFrom)</p>
</td></tr>
<tr><td><code id="nMreg_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation
matrix, else from a covariance matrix</p>
</td></tr>
<tr><td><code id="nMreg_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="nMreg_+3A_details">details</code></td>
<td>
<p>logical: if <code>TRUE</code> also returns details about the
computation for each eigenvalue.</p>
</td></tr>
<tr><td><code id="nMreg_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the
<code>eigenComputes</code> and <code>cor</code> or <code>cov</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the associated Student <em>t</em> test is applied, the following
hypothesis is considered: <br />
</p>
<p>(1) <code class="reqn">\qquad \qquad H_k: \beta (\lambda_1 \ldots \lambda_k) - \beta
(\lambda_{k+1} \ldots \lambda_p), (k = 3, \ldots, p-3) = 0</code> <br />
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nFactors</code></td>
<td>
<p> numeric: number of components/factors retained by
the <em>MREG</em> procedures. </p>
</td></tr> <tr><td><code>details</code></td>
<td>
<p> numeric: matrix of the details
for each indices.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Zoski, K. and Jurs, S. (1993). Using multiple regression to
determine the number of factors to retain in factor analysis. <em>Multiple
Linear Regression Viewpoints, 20</em>(1), 5-9.
</p>
<p>Zoski, K. and Jurs, S. (1996). An objective counterpart to the visual scree
test for factor analysis: the standard error scree test.  <em>Educational
and Psychological Measurement, 56</em>(3), 443-451.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>,
<code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## SIMPLE EXAMPLE OF A MREG ANALYSIS

 data(dFactors)
 eig      &lt;- dFactors$Raiche$eigenvalues

 results  &lt;- nMreg(eig)
 results

 plotuScree(eig, main=paste(results$nFactors[1], ", ",
                            results$nFactors[2], " or ",
                            results$nFactors[3],
                            " factors retained by the MREG procedures",
                            sep=""))

</code></pre>

<hr>
<h2 id='nScree'>Non Graphical Cattel's Scree Test</h2><span id='topic+nScree'></span>

<h3>Description</h3>

<p>The <code>nScree</code> function returns an analysis of the number of component or
factors to retain in an exploratory principal component or factor analysis.
The function also returns information about the number of components/factors
to retain with the Kaiser rule and the parallel analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nScree(eig = NULL, x = eig, aparallel = NULL, cor = TRUE,
  model = "components", criteria = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nScree_+3A_eig">eig</code></td>
<td>
<p>depreciated parameter (use x instead): eigenvalues to analyse</p>
</td></tr>
<tr><td><code id="nScree_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of
correlations or of covariances or a <code>data.frame</code> of data</p>
</td></tr>
<tr><td><code id="nScree_+3A_aparallel">aparallel</code></td>
<td>
<p>numeric: results of a parallel analysis.  Defaults
eigenvalues fixed at <code class="reqn">\lambda &gt;= \bar{\lambda}</code> (Kaiser and related
rule) or <code class="reqn">\lambda &gt;= 0</code> (CFA analysis)</p>
</td></tr>
<tr><td><code id="nScree_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation
matrix, else from a covariance matrix</p>
</td></tr>
<tr><td><code id="nScree_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="nScree_+3A_criteria">criteria</code></td>
<td>
<p>numeric: by default fixed at <code class="reqn">\bar{\lambda}</code>.  When the
<code class="reqn">\lambda</code>s are computed from a principal component analysis on a
correlation matrix, it corresponds to the usual Kaiser <code class="reqn">\lambda &gt;= 1</code>
rule. On a covariance matrix or from a factor analysis, it is simply the
mean.  To apply <code class="reqn">\lambda &gt;= 0</code>, sometimes used with factor analysis, fix
the criteria to <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="nScree_+3A_...">...</code></td>
<td>
<p>variabe: additionnal parameters to give to the <code>cor</code> or
<code>cov</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>nScree</code> function returns an analysis of the number of
components/factors to retain in an exploratory principal component or factor
analysis. Different solutions are given. The classical ones are the Kaiser
rule, the parallel analysis, and the usual scree test
(<code><a href="#topic+plotuScree">plotuScree</a></code>).  Non graphical solutions to the Cattell
subjective scree test are also proposed: an acceleration factor (<em>af</em>)
and the optimal coordinates index <em>oc</em>. The acceleration factor
indicates where the elbow of the scree plot appears. It corresponds to the
acceleration of the curve, i.e. the second derivative.  The optimal
coordinates are the extrapolated coordinates of the previous eigenvalue that
allow the observed eigenvalue to go beyond this extrapolation. The
extrapolation is made by a linear regression using the last eigenvalue
coordinates and the <code class="reqn">k+1</code> eigenvalue coordinates. There are <code class="reqn">k-2</code>
regression lines like this.  The Kaiser rule or a parallel analysis
criterion (<code><a href="#topic+parallel">parallel</a></code>) must also be simultaneously satisfied to
retain the components/factors, whether for the acceleration factor, or for
the optimal coordinates.
</p>
<p>If <code class="reqn">\lambda_i</code> is the <code class="reqn">i^{th}</code> eigenvalue, and <code class="reqn">LS_i</code> is a
location statistics like the mean or a centile (generally the followings:
<code class="reqn">1^{st}, \ 5^{th}, \ 95^{th}, \ or \ 99^{th}</code>).
</p>
<p>The Kaiser rule is computed as: </p>
<p style="text-align: center;"><code class="reqn"> n_{Kaiser} = \sum_{i} (\lambda_{i}
\ge \bar{\lambda}).</code>
</p>
<p> Note that <code class="reqn">\bar{\lambda}</code> is equal to 1 when a
correlation matrix is used.
</p>
<p>The parallel analysis is computed as: </p>
<p style="text-align: center;"><code class="reqn">n_{parallel} = \sum_{i}
(\lambda_{i} \ge LS_i).</code>
</p>

<p>The acceleration factor (<code class="reqn">AF</code>) corresponds to a numerical solution to
the elbow of the scree plot: </p>
<p style="text-align: center;"><code class="reqn">n_{AF} \equiv \ If \ \left[ (\lambda_{i}
\ge LS_i) \ and \ max(AF_i) \right].</code>
</p>

<p>The optimal coordinates (<code class="reqn">OC</code>) corresponds to an extrapolation of the
preceeding eigenvalue by a regression line between the eigenvalue
coordinates and the last eigenvalue coordinates: </p>
<p style="text-align: center;"><code class="reqn">n_{OC} = \sum_i
\left[(\lambda_i \ge LS_i) \cap (\lambda_i \ge (\lambda_{i \ predicted})
\right].</code>
</p>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Components</code></td>
<td>
<p> Data frame for the number of components/factors
according to different rules </p>
</td></tr> <tr><td><code>Components$noc</code></td>
<td>
<p> Number of
components/factors to retain according to optimal coordinates <em>oc</em></p>
</td></tr>
<tr><td><code>Components$naf</code></td>
<td>
<p> Number of components/factors to retain according to
the acceleration factor <em>af</em></p>
</td></tr> <tr><td><code>Components$npar.analysis</code></td>
<td>
<p>Number
of components/factors to retain according to parallel analysis </p>
</td></tr>
<tr><td><code>Components$nkaiser</code></td>
<td>
<p> Number of components/factors to retain according
to the Kaiser rule </p>
</td></tr> <tr><td><code>Analysis</code></td>
<td>
<p> Data frame of vectors linked to the
different rules </p>
</td></tr> <tr><td><code>Analysis$Eigenvalues</code></td>
<td>
<p> Eigenvalues </p>
</td></tr>
<tr><td><code>Analysis$Prop</code></td>
<td>
<p> Proportion of variance accounted by eigenvalues </p>
</td></tr>
<tr><td><code>Analysis$Cumu</code></td>
<td>
<p> Cumulative proportion of variance accounted by
eigenvalues </p>
</td></tr> <tr><td><code>Analysis$Par.Analysis</code></td>
<td>
<p> Centiles of the random
eigenvalues generated by the parallel analysis. </p>
</td></tr> <tr><td><code>Analysis$Pred.eig</code></td>
<td>

<p>Predicted eigenvalues by each optimal coordinate regression line </p>
</td></tr>
<tr><td><code>Analysis$OC</code></td>
<td>
<p> Critical optimal coordinates <em>oc</em></p>
</td></tr>
<tr><td><code>Analysis$Acc.factor</code></td>
<td>
<p> Acceleration factor <em>af</em></p>
</td></tr>
<tr><td><code>Analysis$AF</code></td>
<td>
<p> Critical acceleration factor <em>af</em></p>
</td></tr></table>
<p> Otherwise,
returns a summary of the analysis.
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Cattell, R. B. (1966). The scree test for the number of factors.
<em>Multivariate Behavioral Research, 1</em>, 245-276.
</p>
<p>Dinno, A. (2009). <em>Gently clarifying the application of Horn's parallel
analysis to principal component analysis versus factor analysis</em>.  Portland,
Oregon: Portland Sate University.
</p>
<p>Guttman, L. (1954). Some necessary conditions for common factor analysis.
<em>Psychometrika, 19, 149-162</em>.
</p>
<p>Horn, J. L. (1965). A rationale for the number of factors in factor
analysis.  <em>Psychometrika, 30</em>, 179-185.
</p>
<p>Kaiser, H. F. (1960). The application of electronic computer to factor
analysis.  <em>Educational and Psychological Measurement, 20</em>, 141-151.
</p>
<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+plotnScree">plotnScree</a></code>,
<code><a href="#topic+parallel">parallel</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## INITIALISATION
 data(dFactors)                      # Load the nFactors dataset
 attach(dFactors)
 vect         &lt;- Raiche              # Uses the example from Raiche
 eigenvalues  &lt;- vect$eigenvalues    # Extracts the observed eigenvalues
 nsubjects    &lt;- vect$nsubjects      # Extracts the number of subjects
 variables    &lt;- length(eigenvalues) # Computes the number of variables
 rep          &lt;- 100                 # Number of replications for PA analysis
 cent         &lt;- 0.95                # Centile value of PA analysis

## PARALLEL ANALYSIS (qevpea for the centile criterion, mevpea for the
## mean criterion)
 aparallel    &lt;- parallel(var     = variables,
                          subject = nsubjects,
                          rep     = rep,
                          cent    = cent
                          )$eigen$qevpea  # The 95 centile

## NUMBER OF FACTORS RETAINED ACCORDING TO DIFFERENT RULES
 results      &lt;- nScree(x=eigenvalues, aparallel=aparallel)
 results
 summary(results)

## PLOT ACCORDING TO THE nScree CLASS
 plotnScree(results)

</code></pre>

<hr>
<h2 id='nSeScree'>Standard Error Scree and Coefficient of Determination Procedures to
Determine the Number of Components/Factors</h2><span id='topic+nSeScree'></span>

<h3>Description</h3>

<p>This function computes the <em>seScree</em> (<code class="reqn">S_{Y \bullet X}</code>) indices
(Zoski and Jurs, 1996) and the coefficient of determination indices of
Nelson (2005) <code class="reqn">R^2</code> for determining the number of components/factors to
retain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nSeScree(x, cor = TRUE, model = "components", details = TRUE,
  r2limen = 0.75, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nSeScree_+3A_x">x</code></td>
<td>
<p>numeric: eigenvalues.</p>
</td></tr>
<tr><td><code id="nSeScree_+3A_cor">cor</code></td>
<td>
<p>logical: if <code>TRUE</code> computes eigenvalues from a correlation
matrix, else from a covariance matrix</p>
</td></tr>
<tr><td><code id="nSeScree_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="nSeScree_+3A_details">details</code></td>
<td>
<p>logical: if <code>TRUE</code> also returns details about the
computation for each eigenvalue.</p>
</td></tr>
<tr><td><code id="nSeScree_+3A_r2limen">r2limen</code></td>
<td>
<p>numeric: criterion value retained for the coefficient of
determination indices.</p>
</td></tr>
<tr><td><code id="nSeScree_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the
<code>eigenComputes</code> and <code>cor</code> or <code>cov</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Zoski and Jurs <code class="reqn">S_{Y \bullet X}</code> index is the standard error of the
estimate (predicted) eigenvalues by the regression from the <code class="reqn">(k+1,
\ldots, p)</code> subsequent ranks of the eigenvalues. The standard error is
computed as:
</p>
<p>(1) <code class="reqn">\qquad \qquad S_{Y \bullet X} = \sqrt{ \frac{(\lambda_k -
\hat{\lambda}_k)^2} {p-2} } </code> <br />
</p>
<p>A value of <code class="reqn">1/p</code> is choosen as the criteria to determine the number of
components or factors to retain, <em>p</em> corresponding to the number of
variables.
</p>
<p>The Nelson <code class="reqn">R^2</code> index is simply the multiple regresion coefficient of
determination for the <code class="reqn">k+1, \ldots, p</code> eigenvalues.  Note that Nelson
didn't give formal prescriptions for the criteria for this index. He only
suggested that a value of 0.75 or more must be considered. More is to be
done to explore adequate values.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nFactors</code></td>
<td>
<p> numeric: number of components/factors retained by
the seScree procedure. </p>
</td></tr> <tr><td><code>details</code></td>
<td>
<p> numeric: matrix of the details for
each index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Nasser, F. (2002). The performance of regression-based
variations of the visual scree for determining the number of common factors.
<em>Educational and Psychological Measurement, 62(3)</em>, 397-419.
</p>
<p>Nelson, L. R. (2005). Some observations on the scree test, and on
coefficient alpha. <em>Thai Journal of Educational Research and
Measurement, 3(1)</em>, 1-17.
</p>
<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>
<p>Zoski, K. and Jurs, S. (1993). Using multiple regression to determine the
number of factors to retain in factor analysis. <em>Multiple Linear
Regression Viewpoints, 20</em>(1), 5-9.
</p>
<p>Zoski, K. and Jurs, S. (1996). An objective counterpart to the visuel scree
test for factor analysis: the standard error scree. <em>Educational and
Psychological Measurement, 56</em>(3), 443-451.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>,
<code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## SIMPLE EXAMPLE OF SESCREE AND R2 ANALYSIS

 data(dFactors)
 eig      &lt;- dFactors$Raiche$eigenvalues

 results  &lt;- nSeScree(eig)
 results

 plotuScree(eig, main=paste(results$nFactors[1], " or ", results$nFactors[2],
                            " factors retained by the sescree and R2 procedures",
                            sep=""))

</code></pre>

<hr>
<h2 id='parallel'>Parallel Analysis of a Correlation or Covariance Matrix</h2><span id='topic+parallel'></span>

<h3>Description</h3>

<p>This function gives the distribution of the eigenvalues of correlation or a
covariance matrices of random uncorrelated standardized normal variables.
The mean and a selected quantile of this distribution are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel(subject = 100, var = 10, rep = 100, cent = 0.05,
  quantile = cent, model = "components", sd = diag(1, var), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel_+3A_subject">subject</code></td>
<td>
<p>numeric: nmber of subjects (default is 100)</p>
</td></tr>
<tr><td><code id="parallel_+3A_var">var</code></td>
<td>
<p>numeric: number of variables (default is 10)</p>
</td></tr>
<tr><td><code id="parallel_+3A_rep">rep</code></td>
<td>
<p>numeric: number of replications of the correlation matrix
(default is 100)</p>
</td></tr>
<tr><td><code id="parallel_+3A_cent">cent</code></td>
<td>
<p>depreciated numeric (use quantile instead): quantile of the
distribution on which the decision is made (default is 0.05)</p>
</td></tr>
<tr><td><code id="parallel_+3A_quantile">quantile</code></td>
<td>
<p>numeric: quantile of the distribution on which the decision
is made (default is 0.05)</p>
</td></tr>
<tr><td><code id="parallel_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="parallel_+3A_sd">sd</code></td>
<td>
<p>numeric: vector of standard deviations of the simulated variables
(for a parallel analysis on a covariance matrix)</p>
</td></tr>
<tr><td><code id="parallel_+3A_...">...</code></td>
<td>
<p>variable: other parameters for the <code>"mvrnorm"</code>, <code>corr</code>
or <code>cov</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if the decision is based on a quantile value rather than on the
mean, care must be taken with the number of replications (<code>rep</code>). In
fact, the smaller the quantile (<code>cent</code>), the bigger the number of
necessary replications.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>eigen</code></td>
<td>
<p> Data frame consisting of the mean and the quantile of
the eigenvalues distribution </p>
</td></tr> <tr><td><code>eigen$mevpea</code></td>
<td>
<p> Mean of the eigenvalues
distribution</p>
</td></tr> <tr><td><code>eigen$sevpea</code></td>
<td>
<p> Standard deviation of the eigenvalues
distribution</p>
</td></tr> <tr><td><code>eigen$qevpea</code></td>
<td>
<p> quantile of the eigenvalues distribution</p>
</td></tr>
<tr><td><code>eigen$sqevpea</code></td>
<td>
<p> Standard error of the quantile of the eigenvalues
distribution</p>
</td></tr> <tr><td><code>subject</code></td>
<td>
<p> Number of subjects</p>
</td></tr> <tr><td><code>variables</code></td>
<td>
<p> Number
of variables</p>
</td></tr> <tr><td><code>centile</code></td>
<td>
<p> Selected quantile</p>
</td></tr></table>
<p> Otherwise, returns a
summary of the parallel analysis.
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Drasgow, F. and Lissak, R. (1983) Modified parallel analysis: a
procedure for examining the latent dimensionality of dichotomously scored
item responses. <em>Journal of Applied Psychology, 68</em>(3), 363-373.
</p>
<p>Hoyle, R. H. and Duvall, J. L. (2004). Determining the number of factors in
exploratory and confirmatory factor analysis.  In D. Kaplan (Ed.): <em>The
Sage handbook of quantitative methodology for the social sciences</em>. Thousand
Oaks, CA: Sage.
</p>
<p>Horn, J. L. (1965). A rationale and test of the number of factors in factor
analysis. <em>Psychometrika, 30</em>, 179-185.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>,
<code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+plotParallel">plotParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## SIMPLE EXAMPLE OF A PARALLEL ANALYSIS
## OF A CORRELATION MATRIX WITH ITS PLOT
 data(dFactors)
 eig      &lt;- dFactors$Raiche$eigenvalues
 subject  &lt;- dFactors$Raiche$nsubjects
 var      &lt;- length(eig)
 rep      &lt;- 100
 quantile &lt;- 0.95
 results  &lt;- parallel(subject, var, rep, quantile)

 results

## IF THE DECISION IS BASED ON THE CENTILE USE qevpea INSTEAD
## OF mevpea ON THE FIRST LINE OF THE FOLLOWING CALL
 plotuScree(x    = eig,
            main = "Parallel Analysis"
            )

 lines(1:var,
       results$eigen$qevpea,
       type="b",
       col="green"
       )


## ANOTHER SOLUTION IS SIMPLY TO
 plotParallel(results)

</code></pre>

<hr>
<h2 id='plotnScree'>Scree Plot According to a nScree Object Class</h2><span id='topic+plotnScree'></span>

<h3>Description</h3>

<p>Plot a scree plot adding information about a non graphical <code>nScree</code>
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotnScree(nScree, legend = TRUE, ylab = "Eigenvalues",
  xlab = "Components", main = "Non Graphical Solutions to Scree Test")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotnScree_+3A_nscree">nScree</code></td>
<td>
<p>Results of a previous <code>nScree</code> analysis</p>
</td></tr>
<tr><td><code id="plotnScree_+3A_legend">legend</code></td>
<td>
<p>Logical indicator of the presence or not of a legend</p>
</td></tr>
<tr><td><code id="plotnScree_+3A_ylab">ylab</code></td>
<td>
<p>Label of the y axis (default to <code>"Eigenvalue"</code>)</p>
</td></tr>
<tr><td><code id="plotnScree_+3A_xlab">xlab</code></td>
<td>
<p>Label of the x axis (default to <code>"Component"</code>)</p>
</td></tr>
<tr><td><code id="plotnScree_+3A_main">main</code></td>
<td>
<p>Main title (default to <code>"Non Graphical Solutions to the
Scree Test"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing returned.
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>,
<code><a href="#topic+plotParallel">plotParallel</a></code>, <code><a href="#topic+parallel">parallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## INITIALISATION
 data(dFactors)                      # Load the nFactors dataset
 attach(dFactors)
 vect         &lt;- Raiche              # Use the second example from Buja and Eyuboglu
                                     # (1992, p. 519, nsubjects not specified by them)
 eigenvalues  &lt;- vect$eigenvalues    # Extract the observed eigenvalues
 nsubjects    &lt;- vect$nsubjects      # Extract the number of subjects
 variables    &lt;- length(eigenvalues) # Compute the number of variables
 rep          &lt;- 100                 # Number of replications for the parallel analysis
 cent         &lt;- 0.95                # Centile value of the parallel analysis

## PARALLEL ANALYSIS (qevpea for the centile criterion, mevpea for the mean criterion)
 aparallel    &lt;- parallel(var     = variables,
                          subject = nsubjects,
                          rep     = rep,
                          cent    = cent)$eigen$qevpea  # The 95 centile

## NOMBER OF FACTORS RETAINED ACCORDING TO DIFFERENT RULES
 results &lt;- nScree(eig       = eigenvalues,
                   aparallel = aparallel
                   )

 results

## PLOT ACCORDING TO THE nScree CLASS
 plotnScree(results)

</code></pre>

<hr>
<h2 id='plotParallel'>Plot a Parallel Analysis Class Object</h2><span id='topic+plotParallel'></span>

<h3>Description</h3>

<p>Plot a scree plot adding information about a parallel analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotParallel(parallel, eig = NA, x = eig, model = "components",
  legend = TRUE, ylab = "Eigenvalues", xlab = "Components",
  main = "Parallel Analysis", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotParallel_+3A_parallel">parallel</code></td>
<td>
<p>numeric: vector of the results of a previous parallel
analysis</p>
</td></tr>
<tr><td><code id="plotParallel_+3A_eig">eig</code></td>
<td>
<p>depreciated parameter: eigenvalues to analyse (not used if x is
used, recommended)</p>
</td></tr>
<tr><td><code id="plotParallel_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of
correlations or of covariances or a <code>data.frame</code> of data</p>
</td></tr>
<tr><td><code id="plotParallel_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="plotParallel_+3A_legend">legend</code></td>
<td>
<p>logical: indicator of the presence or not of a legend</p>
</td></tr>
<tr><td><code id="plotParallel_+3A_ylab">ylab</code></td>
<td>
<p>character: label of the y axis</p>
</td></tr>
<tr><td><code id="plotParallel_+3A_xlab">xlab</code></td>
<td>
<p>character: label of the x axis</p>
</td></tr>
<tr><td><code id="plotParallel_+3A_main">main</code></td>
<td>
<p>character: title of the plot</p>
</td></tr>
<tr><td><code id="plotParallel_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the <code>cor</code> or
<code>cov</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>eig</code> is <code>FALSE</code> the plot shows only the parallel analysis
without eigenvalues.
</p>


<h3>Value</h3>

<p>Nothing returned.
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotuScree">plotuScree</a></code>, <code><a href="#topic+nScree">nScree</a></code>,
<code><a href="#topic+plotnScree">plotnScree</a></code>, <code><a href="#topic+parallel">parallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## SIMPLE EXAMPLE OF A PARALLEL ANALYSIS
## OF A CORRELATION MATRIX WITH ITS PLOT
 data(dFactors)
 eig      &lt;- dFactors$Raiche$eigenvalues
 subject  &lt;- dFactors$Raiche$nsubjects
 var      &lt;- length(eig)
 rep      &lt;- 100
 cent     &lt;- 0.95
 results  &lt;- parallel(subject,var,rep,cent)

 results


## PARALLEL ANALYSIS SCREE PLOT
 plotParallel(results, x=eig)
 plotParallel(results)


</code></pre>

<hr>
<h2 id='plotuScree'>Plot of the Usual Cattell's Scree Test</h2><span id='topic+plotuScree'></span>

<h3>Description</h3>

<p><code>uScree</code> plot a usual scree test of the eigenvalues of a correlation
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotuScree(Eigenvalue, x = Eigenvalue, model = "components",
  ylab = "Eigenvalues", xlab = "Components", main = "Scree Plot",
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotuScree_+3A_eigenvalue">Eigenvalue</code></td>
<td>
<p>depreciated parameter: eigenvalues to analyse (not used if
x is used, recommended)</p>
</td></tr>
<tr><td><code id="plotuScree_+3A_x">x</code></td>
<td>
<p>numeric: a <code>vector</code> of eigenvalues, a <code>matrix</code> of
correlations or of covariances or a <code>data.frame</code> of data</p>
</td></tr>
<tr><td><code id="plotuScree_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="plotuScree_+3A_ylab">ylab</code></td>
<td>
<p>character: label of the y axis (default is <code>Eigenvalue</code>)</p>
</td></tr>
<tr><td><code id="plotuScree_+3A_xlab">xlab</code></td>
<td>
<p>character: label of the x axis (default is <code>Component</code>)</p>
</td></tr>
<tr><td><code id="plotuScree_+3A_main">main</code></td>
<td>
<p>character: title of the plot (default is <code>Scree Plot</code>)</p>
</td></tr>
<tr><td><code id="plotuScree_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the
<code>eigenComputes</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing returned with this function.
</p>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Cattell, R. B. (1966). The scree test for the number of factors.
<em>Multivariate Behavioral Research, 1</em>, 245-276.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nScree">nScree</a></code>, <code><a href="#topic+parallel">parallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## SCREE PLOT
 data(dFactors)
 attach(dFactors)
 eig = Cliff1$eigenvalues
 plotuScree(x=eig)

</code></pre>

<hr>
<h2 id='principalAxis'>Principal Axis Analysis</h2><span id='topic+principalAxis'></span>

<h3>Description</h3>

<p>The <code>PrincipalAxis</code> function returns a principal axis analysis without
iterated communalities estimates. Three different choices of communalities
estimates are given: maximum corelation, multiple correlation or estimates
based on the sum of the squared principal component analysis loadings.
Generally statistical packages initialize the the communalities at the
multiple correlation value (usual inverse or generalized inverse).
Unfortunately, this strategy cannot deal with singular correlation or
covariance matrices.  If a generalized inverse, the maximum correlation or
the estimated communalities based on the sum of loading are used instead,
then a solution can be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>principalAxis(R, nFactors = 2, communalities = "component")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="principalAxis_+3A_r">R</code></td>
<td>
<p>numeric: correlation or covariance matrix</p>
</td></tr>
<tr><td><code id="principalAxis_+3A_nfactors">nFactors</code></td>
<td>
<p>numeric: number of factors to retain</p>
</td></tr>
<tr><td><code id="principalAxis_+3A_communalities">communalities</code></td>
<td>
<p>character: initial values for communalities
(<code>"component", "maxr", "ginv" or "multiple"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p> numeric: variance of each component/factor </p>
</td></tr>
<tr><td><code>varExplained</code></td>
<td>
<p> numeric: variance explained by each component/factor </p>
</td></tr>
<tr><td><code>varExplained</code></td>
<td>
<p> numeric: cumulative variance explained by each
component/factor </p>
</td></tr> <tr><td><code>loadings</code></td>
<td>
<p> numeric: loadings of each variable on
each component/factor </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Kim, J.-O. and Mueller, C. W. (1978). <em>Introduction to
factor analysis. What it is and how to do it</em>. Beverly Hills, CA: Sage.
</p>
<p>Kim, J.-O. and Mueller, C. W. (1987). <em>Factor analysis. Statistical
methods and practical issues</em>. Beverly Hills, CA: Sage.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+componentAxis">componentAxis</a></code>, <code><a href="#topic+iterativePrincipalAxis">iterativePrincipalAxis</a></code>,
<code><a href="#topic+rRecovery">rRecovery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# .......................................................
# Example from Kim and Mueller (1978, p. 10)
# Population: upper diagonal
# Simulated sample: lower diagnonal
 R &lt;- matrix(c( 1.000, .6008, .4984, .1920, .1959, .3466,
                .5600, 1.000, .4749, .2196, .1912, .2979,
                .4800, .4200, 1.000, .2079, .2010, .2445,
                .2240, .1960, .1680, 1.000, .4334, .3197,
                .1920, .1680, .1440, .4200, 1.000, .4207,
                .1600, .1400, .1200, .3500, .3000, 1.000),
                nrow=6, byrow=TRUE)

# Factor analysis: Principal axis factoring
# without iterated communalities -
# Kim and Mueller (1978, p. 21)
# Replace upper diagonal with lower diagonal
 RU &lt;- diagReplace(R, upper=TRUE)
 principalAxis(RU, nFactors=2, communalities="component")
 principalAxis(RU, nFactors=2, communalities="maxr")
 principalAxis(RU, nFactors=2, communalities="multiple")
# Replace lower diagonal with upper diagonal
 RL &lt;- diagReplace(R, upper=FALSE)
 principalAxis(RL, nFactors=2, communalities="component")
 principalAxis(RL, nFactors=2, communalities="maxr")
 principalAxis(RL, nFactors=2, communalities="multiple")
# .......................................................

</code></pre>

<hr>
<h2 id='principalComponents'>Principal Component Analysis</h2><span id='topic+principalComponents'></span>

<h3>Description</h3>

<p>The <code>principalComponents</code> function returns a principal component
analysis.  Other R functions give the same results, but
<code>principalComponents</code> is customized mainly for the other factor
analysis functions available in the <span class="pkg">nfactors</span> package. In order to
retain only a small number of components the <code>componentAxis</code> function
has to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>principalComponents(R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="principalComponents_+3A_r">R</code></td>
<td>
<p>numeric: correlation or covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p> numeric: variance of each component </p>
</td></tr>
<tr><td><code>varExplained</code></td>
<td>
<p> numeric: variance explained by each component </p>
</td></tr>
<tr><td><code>varExplained</code></td>
<td>
<p> numeric: cumulative variance explained by each
component </p>
</td></tr> <tr><td><code>loadings</code></td>
<td>
<p> numeric: loadings of each variable on each
component </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Joliffe, I. T. (2002). <em>Principal components analysis</em> (2th
Edition).  New York, NJ: Springer-Verlag.
</p>
<p>Kim, J.-O. and Mueller, C. W. (1978). <em>Introduction to factor analysis.
What it is and how to do it</em>. Beverly Hills, CA: Sage.
</p>
<p>Kim, J.-O. and Mueller, C. W. (1987). <em>Factor analysis. Statistical
methods and practical issues</em>. Beverly Hills, CA: Sage.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+componentAxis">componentAxis</a></code>, <code><a href="#topic+iterativePrincipalAxis">iterativePrincipalAxis</a></code>,
<code><a href="#topic+rRecovery">rRecovery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# .......................................................
# Example from Kim and Mueller (1978, p. 10)
# Population: upper diagonal
# Simulated sample: lower diagnonal
 R &lt;- matrix(c( 1.000, .6008, .4984, .1920, .1959, .3466,
                .5600, 1.000, .4749, .2196, .1912, .2979,
                .4800, .4200, 1.000, .2079, .2010, .2445,
                .2240, .1960, .1680, 1.000, .4334, .3197,
                .1920, .1680, .1440, .4200, 1.000, .4207,
                .1600, .1400, .1200, .3500, .3000, 1.000),
                nrow=6, byrow=TRUE)

# Factor analysis: Principal component -
# Kim et Mueller (1978, p. 21)
# Replace upper diagonal with lower diagonal
 RU &lt;- diagReplace(R, upper=TRUE)
 principalComponents(RU)

# Replace lower diagonal with upper diagonal
 RL &lt;- diagReplace(R, upper=FALSE)
 principalComponents(RL)
# .......................................................

</code></pre>

<hr>
<h2 id='rRecovery'>Test of Recovery of a Correlation or a Covariance matrix from a Factor
Analysis Solution</h2><span id='topic+rRecovery'></span>

<h3>Description</h3>

<p>The <code>rRecovery</code> function returns a verification of the quality of the
recovery of the initial correlation or covariance matrix by the factor
solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rRecovery(R, loadings, diagCommunalities = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rRecovery_+3A_r">R</code></td>
<td>
<p>numeric: initial correlation or covariance matrix</p>
</td></tr>
<tr><td><code id="rRecovery_+3A_loadings">loadings</code></td>
<td>
<p>numeric: loadings from a factor analysis solution</p>
</td></tr>
<tr><td><code id="rRecovery_+3A_diagcommunalities">diagCommunalities</code></td>
<td>
<p>logical: if <code>TRUE</code>, the correlation between
the initial solution and the estimated one will use a correlation of one in
the diagonal. If <code>FALSE</code> (default) the diagonal is not used in the
computation of this correlation.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>R</code></td>
<td>
<p> numeric: initial correlation or covariance matrix </p>
</td></tr>
<tr><td><code>recoveredR</code></td>
<td>
<p> numeric: recovered estimated correlation or covariance
matrix </p>
</td></tr> <tr><td><code>difference</code></td>
<td>
<p> numeric: difference between initial and
recovered estimated correlation or covariance matrix</p>
</td></tr> <tr><td><code>cor</code></td>
<td>
<p> numeric:
Pearson correlation between initial and recovered estimated correlation or
covariance matrix. Computations depend on the logical value of the
<code>communalities</code> argument. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+componentAxis">componentAxis</a></code>, <code><a href="#topic+iterativePrincipalAxis">iterativePrincipalAxis</a></code>,
<code><a href="#topic+principalAxis">principalAxis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# .......................................................
# Example from Kim and Mueller (1978, p. 10)
# Population: upper diagonal
# Simulated sample: lower diagnonal
 R &lt;- matrix(c( 1.000, .6008, .4984, .1920, .1959, .3466,
                .5600, 1.000, .4749, .2196, .1912, .2979,
                .4800, .4200, 1.000, .2079, .2010, .2445,
                .2240, .1960, .1680, 1.000, .4334, .3197,
                .1920, .1680, .1440, .4200, 1.000, .4207,
                .1600, .1400, .1200, .3500, .3000, 1.000),
                nrow=6, byrow=TRUE)


# Replace upper diagonal with lower diagonal
 RU         &lt;- diagReplace(R, upper=TRUE)
 nFactors   &lt;- 2
 loadings   &lt;- principalAxis(RU, nFactors=nFactors,
                             communalities="component")$loadings
 rComponent &lt;- rRecovery(RU,loadings, diagCommunalities=FALSE)$cor

 loadings   &lt;- principalAxis(RU, nFactors=nFactors,
                             communalities="maxr")$loadings
 rMaxr      &lt;- rRecovery(RU,loadings, diagCommunalities=FALSE)$cor

 loadings   &lt;- principalAxis(RU, nFactors=nFactors,
                             communalities="multiple")$loadings
 rMultiple  &lt;- rRecovery(RU,loadings, diagCommunalities=FALSE)$cor

 round(c(rComponent = rComponent,
         rmaxr      = rMaxr,
         rMultiple  = rMultiple), 3)
# .......................................................


</code></pre>

<hr>
<h2 id='structureSim'>Population or Simulated Sample Correlation Matrix from a Given Factor
Structure Matrix</h2><span id='topic+structureSim'></span>

<h3>Description</h3>

<p>The <code>structureSim</code> function returns a population and a sample
correlation matrices from a predefined congeneric factor structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structureSim(fload, reppar = 30, repsim = 100, N, quantile = 0.95,
  model = "components", adequacy = FALSE, details = TRUE,
  r2limen = 0.75, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="structureSim_+3A_fload">fload</code></td>
<td>
<p>matrix: loadings of the factor structure</p>
</td></tr>
<tr><td><code id="structureSim_+3A_reppar">reppar</code></td>
<td>
<p>numeric: number of replications for the parallel analysis</p>
</td></tr>
<tr><td><code id="structureSim_+3A_repsim">repsim</code></td>
<td>
<p>numeric: number of replications of the matrix correlation
simulation</p>
</td></tr>
<tr><td><code id="structureSim_+3A_n">N</code></td>
<td>
<p>numeric: number of subjects</p>
</td></tr>
<tr><td><code id="structureSim_+3A_quantile">quantile</code></td>
<td>
<p>numeric: quantile for the parallel analysis</p>
</td></tr>
<tr><td><code id="structureSim_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="structureSim_+3A_adequacy">adequacy</code></td>
<td>
<p>logical: if <code>TRUE</code> prints the recovered population
matrix from the factor structure</p>
</td></tr>
<tr><td><code id="structureSim_+3A_details">details</code></td>
<td>
<p>logical: if <code>TRUE</code> outputs details of the <code>repsim</code>
simulations</p>
</td></tr>
<tr><td><code id="structureSim_+3A_r2limen">r2limen</code></td>
<td>
<p>numeric: R2 limen value for the R2 Nelson index</p>
</td></tr>
<tr><td><code id="structureSim_+3A_all">all</code></td>
<td>
<p>logical: if <code>TRUE</code> computes the Bentler and Yuan index (very
long computing time to consider)</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p> the output depends of the logical value of details.
If <code>FALSE</code>, returns only statistics about the eigenvalues: mean,
median, quantile, standard deviation, minimum and maximum. If <code>TRUE</code>,
returns also details about the <code>repsim</code> simulations.  If
<code>adequacy</code> = <code>TRUE</code> returns the recovered factor structure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>
<p>Zwick, W. R. and Velicer, W. F. (1986). Comparison of five rules
for determining the number of components to retain. <em>Psychological
Bulletin, 99</em>, 432-442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+principalComponents">principalComponents</a></code>,
<code><a href="#topic+iterativePrincipalAxis">iterativePrincipalAxis</a></code>, <code><a href="#topic+rRecovery">rRecovery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# .......................................................
# Example inspired from Zwick and Velicer (1986, table 2, p. 437)
## ...................................................................
 nFactors  &lt;- 3
 unique    &lt;- 0.2
 loadings  &lt;- 0.5
 nsubjects &lt;- 180
 repsim    &lt;- 30
 zwick     &lt;- generateStructure(var=36, mjc=nFactors, pmjc=12,
                                loadings=loadings,
                                unique=unique)
## ...................................................................

# Produce statistics about a replication of a parallel analysis on
# 30 sampled correlation matrices

 mzwick.fa &lt;-  structureSim(fload=as.matrix(zwick), reppar=30,
                            repsim=repsim, N=nsubjects, quantile=0.5,
                            model="factors")

 mzwick    &lt;-  structureSim(fload=as.matrix(zwick), reppar=30,
                            repsim=repsim, N=nsubjects, quantile=0.5, all=TRUE)

# Very long execution time that could be used only with model="components"
# mzwick    &lt;-  structureSim(fload=as.matrix(zwick), reppar=30,
#                            repsim=repsim, N=nsubjects, quantile=0.5, all=TRUE)

 par(mfrow=c(2,1))
 plot(x=mzwick,    nFactors=nFactors, index=c(1:14), cex.axis=0.7, col="red")
 plot(x=mzwick.fa, nFactors=nFactors, index=c(1:11), cex.axis=0.7, col="red")
 par(mfrow=c(1,1))

 par(mfrow=c(2,1))
 boxplot(x=mzwick,    nFactors=3, cex.axis=0.8, vLine="blue", col="red")
 boxplot(x=mzwick.fa, nFactors=3, cex.axis=0.8, vLine="blue", col="red",
         xlab="Components")
 par(mfrow=c(1,1))
# ......................................................
 
## End(Not run)

</code></pre>

<hr>
<h2 id='studySim'>Simulation Study from Given Factor Structure Matrices and Conditions</h2><span id='topic+studySim'></span>

<h3>Description</h3>

<p>The <code>structureSim</code> function returns statistical results from
simulations from predefined congeneric factor structures. The main ideas
come from the methodology applied by Zwick and Velicer (1986).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>studySim(var, nFactors, pmjc, loadings, unique, N, repsim, reppar,
  stats = 1, quantile = 0.5, model = "components", r2limen = 0.75,
  all = FALSE, dir = NA, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="studySim_+3A_var">var</code></td>
<td>
<p>numeric: vector of the number of variables</p>
</td></tr>
<tr><td><code id="studySim_+3A_nfactors">nFactors</code></td>
<td>
<p>numeric: vector of the number of components/factors</p>
</td></tr>
<tr><td><code id="studySim_+3A_pmjc">pmjc</code></td>
<td>
<p>numeric: vector of the number of major loadings on each
component/factor</p>
</td></tr>
<tr><td><code id="studySim_+3A_loadings">loadings</code></td>
<td>
<p>numeric: vector of the major loadings on each
component/factor</p>
</td></tr>
<tr><td><code id="studySim_+3A_unique">unique</code></td>
<td>
<p>numeric: vector of the unique loadings on each
component/factor</p>
</td></tr>
<tr><td><code id="studySim_+3A_n">N</code></td>
<td>
<p>numeric: vector of the number of subjects/observations</p>
</td></tr>
<tr><td><code id="studySim_+3A_repsim">repsim</code></td>
<td>
<p>numeric: number of replications of the matrix correlation
simulation</p>
</td></tr>
<tr><td><code id="studySim_+3A_reppar">reppar</code></td>
<td>
<p>numeric: number of replications for the parallel and
permutation analysis</p>
</td></tr>
<tr><td><code id="studySim_+3A_stats">stats</code></td>
<td>
<p>numeric: vector of the statistics to return: mean(1),
median(2), sd(3), quantile(4), min(5), max(6)</p>
</td></tr>
<tr><td><code id="studySim_+3A_quantile">quantile</code></td>
<td>
<p>numeric: quantile for the parallel and permutation analysis</p>
</td></tr>
<tr><td><code id="studySim_+3A_model">model</code></td>
<td>
<p>character: <code>"components"</code> or <code>"factors"</code></p>
</td></tr>
<tr><td><code id="studySim_+3A_r2limen">r2limen</code></td>
<td>
<p>numeric: R2 limen value for the R2 Nelson index</p>
</td></tr>
<tr><td><code id="studySim_+3A_all">all</code></td>
<td>
<p>logical: if <code>TRUE</code> computes the Bentler and Yuan index (very
long computing time to consider)</p>
</td></tr>
<tr><td><code id="studySim_+3A_dir">dir</code></td>
<td>
<p>character: directory where to save output. Default to NA</p>
</td></tr>
<tr><td><code id="studySim_+3A_trace">trace</code></td>
<td>
<p>logical: if <code>TRUE</code> outputs details of the status of the
simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p> Returns selected statistics about the number of
components/factors to retain: mean, median, quantile, standard deviation,
minimum and maximum.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>
<p>Zwick, W. R. and Velicer, W. F. (1986). Comparison of five rules
for determining the number of components to retain. <em>Psychological
Bulletin, 99</em>, 432-442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateStructure">generateStructure</a></code>, <code><a href="#topic+structureSim">structureSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# ....................................................................
# Example inspired from Zwick and Velicer (1986)
# Very long computimg time
# ...................................................................

# 1. Initialisation
# reppar    &lt;- 30
# repsim    &lt;- 5
# quantile  &lt;- 0.50

# 2. Simulations
# X         &lt;- studySim(var=36,nFactors=3, pmjc=c(6,12), loadings=c(0.5,0.8),
#                       unique=c(0,0.2), quantile=quantile,
#                       N=c(72,180), repsim=repsim, reppar=reppar,
#                       stats=c(1:6))

# 3. Results (first 10 results)
# print(X[1:10,1:14],2)
# names(X)

# 4. Study of the error done in the determination of the number
#    of components/factors. A positive value is associated to over
#    determination.
# results   &lt;- X[X$stats=="mean",]
# residuals &lt;- results[,c(11:25)] - X$nfactors
# BY        &lt;- c("nsubjects","var","loadings")
# round(aggregate(residuals, by=results[BY], mean),0)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='summary.nScree'>Utility Functions for nScree Class Objects</h2><span id='topic+summary.nScree'></span><span id='topic+print.nScree'></span><span id='topic+plot.nScree'></span><span id='topic+is.nScree'></span>

<h3>Description</h3>

<p>Utility functions for <code>nScree</code> class objects. Some of these functions
are already implemented in the <code>nFactors</code> package, but are easier to
use with generic functions like these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nScree'
summary(object, ...)

## S3 method for class 'nScree'
print(x, ...)

## S3 method for class 'nScree'
plot(x, ...)

is.nScree(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.nScree_+3A_object">object</code></td>
<td>
<p>nScree: an object of the class <code>nScree</code></p>
</td></tr>
<tr><td><code id="summary.nScree_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the <code>print</code>
function with <code>print.nScree</code>, the <code>plotnScree</code> with
<code>plot.nScree</code> or to the <code>summary</code> function with
<code>summary.nScree</code></p>
</td></tr>
<tr><td><code id="summary.nScree_+3A_x">x</code></td>
<td>
<p>Results of a previous <code>nScree</code> analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generic functions for the nScree class:
</p>
<table role = "presentation">
<tr><td><code>is.nScree</code></td>
<td>
<p> logical: is the object of the class <code>nScree</code>? </p>
</td></tr>
<tr><td><code>plot.nScree</code></td>
<td>
<p> graphic: plots a figure according to the
<code>plotnScree</code> function</p>
</td></tr>
<tr><td><code>print.nScree</code></td>
<td>
<p> numeric: vector of the
number of components/factors to retain: same as the <code>Components</code> vector
from the <code>nScree</code> object</p>
</td></tr>
<tr><td><code>summary.nScree</code></td>
<td>
<p> data.frame: details
of the results from a nScree analysis: same as the <code>Analysis</code>
data.frame from the <code>nScree</code> object, but with easier control of the
number of decimals with the <code>digits</code> parameter</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## INITIALISATION
 data(dFactors)                      # Load the nFactors dataset
 attach(dFactors)
 vect         &lt;- Raiche              # Use the example from Raiche
 eigenvalues  &lt;- vect$eigenvalues    # Extract the observed eigenvalues
 nsubjects    &lt;- vect$nsubjects      # Extract the number of subjects
 variables    &lt;- length(eigenvalues) # Compute the number of variables
 rep          &lt;- 100                 # Number of replications for the parallel analysis
 cent         &lt;- 0.95                # Centile value of the parallel analysis

## PARALLEL ANALYSIS (qevpea for the centile criterion, mevpea for the mean criterion)
 aparallel    &lt;- parallel(var     = variables,
                          subject = nsubjects,
                          rep     = rep,
                          cent    = cent
                          )$eigen$qevpea  # The 95 centile

## NOMBER OF FACTORS RETAINED ACCORDING TO DIFFERENT RULES
 results      &lt;- nScree(x=eigenvalues, aparallel=aparallel)

 is.nScree(results)
 results
 summary(results)

## PLOT ACCORDING TO THE nScree CLASS
 plot(results)


</code></pre>

<hr>
<h2 id='summary.structureSim'>Utility Functions for nScree Class Objects</h2><span id='topic+summary.structureSim'></span><span id='topic+boxplot.structureSim'></span><span id='topic+is.structureSim'></span><span id='topic+plot.structureSim'></span><span id='topic+print.structureSim'></span>

<h3>Description</h3>

<p>Utility functions for <code>structureSim</code> class objects. Note that with the
<code>plot.structureSim</code> a dotted black vertical line shows the median
number of factors retained by all the different indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'structureSim'
summary(object, index = c(1:15),
  eigenSelect = NULL, ...)

## S3 method for class 'structureSim'
print(x, index = NULL, ...)

## S3 method for class 'structureSim'
boxplot(x, nFactors = NULL, eigenSelect = NULL,
  vLine = "green", xlab = "Factors", ylab = "Eigenvalues",
  main = "Eigen Box Plot", ...)

## S3 method for class 'structureSim'
plot(x, nFactors = NULL, index = NULL,
  main = "Index Acuracy Plot", ...)

is.structureSim(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.structureSim_+3A_object">object</code></td>
<td>
<p>structureSim: an object of the class <code>structureSim</code></p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_index">index</code></td>
<td>
<p>numeric: vector of the index of the selected indices</p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_eigenselect">eigenSelect</code></td>
<td>
<p>numeric: vector of the index of the selected eigenvalues</p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_...">...</code></td>
<td>
<p>variable: additionnal parameters to give to the <code>boxplot</code>,
<code>plot</code>, <code>print</code> and <code>summary functions.</code></p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_x">x</code></td>
<td>
<p>structureSim: an object of the class <code>structureSim</code></p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_nfactors">nFactors</code></td>
<td>
<p>numeric: if known, number of factors</p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_vline">vLine</code></td>
<td>
<p>character: color of the vertical indicator line of the initial
number of factors in the eigen boxplot</p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_xlab">xlab</code></td>
<td>
<p>character: x axis label</p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_ylab">ylab</code></td>
<td>
<p>character: y axis label</p>
</td></tr>
<tr><td><code id="summary.structureSim_+3A_main">main</code></td>
<td>
<p>character: main title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generic functions for the <code>structureSim</code> class:
</p>
<table role = "presentation">
<tr><td><code>boxplot.structureSim</code></td>
<td>
<p> graphic: plots an eigen boxplot </p>
</td></tr>
<tr><td><code>is.structureSim</code></td>
<td>
<p> logical: is the object of the class
<code>structureSim</code>? </p>
</td></tr> <tr><td><code>plot.structureSim</code></td>
<td>
<p> graphic: plots an index
acuracy plot</p>
</td></tr> <tr><td><code>print.structureSim</code></td>
<td>
<p> numeric: data.frame of statistics
about the number of components/factors to retain according to different
indices following a <code>structureSim</code> simulation</p>
</td></tr>
<tr><td><code>summary.structureSim</code></td>
<td>
<p> list: two data.frame, the first with the
details of the simulated eigenvalues, the second with the details of the
simulated indices</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilles Raiche <br /> Centre sur les Applications des Modeles de
Reponses aux Items (CAMRI) <br /> Universite du Quebec a Montreal<br />
<a href="mailto:raiche.gilles@uqam.ca">raiche.gilles@uqam.ca</a>
</p>


<h3>References</h3>

<p>Raiche, G., Walls, T. A., Magis, D., Riopel, M. and Blais, J.-G. (2013). Non-graphical solutions
for Cattell's scree test. Methodology, 9(1), 23-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nFactors-package">nFactors-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## INITIALISATION
 library(xtable)
 library(nFactors)
 nFactors  &lt;- 3
 unique    &lt;- 0.2
 loadings  &lt;- 0.5
 nsubjects &lt;- 180
 repsim    &lt;- 10
 var       &lt;- 36
 pmjc      &lt;- 12
 reppar    &lt;- 10
 zwick     &lt;- generateStructure(var=var, mjc=nFactors, pmjc=pmjc,
                                loadings=loadings,
                                unique=unique)

## SIMULATIONS
mzwick    &lt;-  structureSim(fload=as.matrix(zwick), reppar=reppar,
                           repsim=repsim, details=TRUE,
                           N=nsubjects, quantile=0.5)

## TEST OF structureSim METHODS
 is(mzwick)
 summary(mzwick, index=1:5, eigenSelect=1:10, digits=3)
 print(mzwick, index=1:10)
 plot(x=mzwick, index=c(1:10), cex.axis=0.7, col="red")
 boxplot(x=mzwick, nFactors=3, vLine="blue", col="red")
 
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
